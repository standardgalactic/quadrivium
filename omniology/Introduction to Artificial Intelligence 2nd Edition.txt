Undergraduate Topics in Computer Science
Wolfgang Ertel
Introduction 
to Artificial 
Intelligence
 Second Edition 

Undergraduate Topics in Computer Science
Series editor
Ian Mackie
Advisory Board
Samson Abramsky, University of Oxford, Oxford, UK
Karin Breitman, Pontiﬁcal Catholic University of Rio de Janeiro, Rio de Janeiro, Brazil
Chris Hankin, Imperial College London, London, UK
Dexter Kozen, Cornell University, Ithaca, USA
Andrew Pitts, University of Cambridge, Cambridge, UK
Hanne Riis Nielson, Technical University of Denmark, Kongens Lyngby, Denmark
Steven Skiena, Stony Brook University, Stony Brook, USA
Iain Stewart, University of Durham, Durham, UK

Undergraduate Topics in Computer Science (UTiCS) delivers high-quality instruc-
tional content for undergraduates studying in all areas of computing and information
science. From core foundational and theoretical material to ﬁnal-year topics and
applications, UTiCS books take a fresh, concise, and modern approach and are ideal
for self-study or for a one- or two-semester course. The texts are all authored by
established experts in their ﬁelds, reviewed by an international advisory board, and
contain numerous examples and problems. Many include fully worked solutions.
More information about this series at http://www.springer.com/series/7592

Wolfgang Ertel
Introduction to Artificial
Intelligence
Second Edition
Translated by Nathanael Black
With illustrations by Florian Mast
123

Wolfgang Ertel
Hochschule Ravensburg-Weingarten
Weingarten
Germany
ISSN 1863-7310
ISSN 2197-1781
(electronic)
Undergraduate Topics in Computer Science
ISBN 978-3-319-58486-7
ISBN 978-3-319-58487-4
(eBook)
DOI 10.1007/978-3-319-58487-4
Library of Congress Control Number: 2017943187
1st edition: © Springer-Verlag London Limited 2011
2nd edition: © Springer International Publishing AG 2017
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part
of the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations,
recitation, broadcasting, reproduction on microﬁlms or in any other physical way, and transmission
or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar
methodology now known or hereafter developed.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this
publication does not imply, even in the absence of a speciﬁc statement, that such names are exempt from
the relevant protective laws and regulations and therefore free for general use.
The publisher, the authors and the editors are safe to assume that the advice and information in this
book are believed to be true and accurate at the date of publication. Neither the publisher nor the
authors or the editors give a warranty, express or implied, with respect to the material contained herein or
for any errors or omissions that may have been made. The publisher remains neutral with regard to
jurisdictional claims in published maps and institutional afﬁliations.
Printed on acid-free paper
This Springer imprint is published by Springer Nature
The registered company is Springer International Publishing AG
The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland

Preface to the Second Edition
After 60 years, Artiﬁcial Intelligence (AI) has now reached industry and the con-
sciousness of the population. The impressive successes and new AI methods are
now so relevant that they should be taught even in a basic course. In about 30 new
pages, I report mainly on deep learning, a consistent further development of neural
networks, which ﬁnally enables image processing systems to recognize almost any
object in pixel images. Among other beneﬁts, this lead to the ﬁrst computer pro-
gram that could beat one of the world’s best Go players.
In the new section on Deep Learning, we must not leave out a short report about
the fascinating new subarea of creativity. For the ﬁrst time neural networks can
creatively generate texts, music pieces, and even paintings in the style of the old
masters. These achievements are based on many years of research on neural net-
works and machine learning. Practical AI has developed into an engineering dis-
cipline in which programs are developed in large industrial teams by experts from
various specializations.
Self-driving cars, service robots, and smart homes—which are all applications of
AI—will greatly change our lives. However, in addition to great rays of hope, there
will be a dark side. Though we live in a time of rapid technological progress, we
have long since exceeded the limits of growth. We must therefore think about
sustainability when implementing each new invention. In Chap. 1, I would like to
give you some food for thought about this topic.
Other new additions to the book include a section on performance evaluation of
clustering algorithms and two practical examples explaining Bayes’ theorem and its
relevance in everyday life. Finally, in a section on search algorithms, we analyze the
cycle check, explain route planning for car navigation systems, and brieﬂy intro-
duce Monte Carlo Tree Search.
All known errors have been corrected and updates have been made in many
places.
I would like to sincerely thank the readers who have given me feedback and all
those who contributed to this new edition through proofreading and suggestions.
v

I would especially like to thank Adrian Batzill for the route planning measurements
and graphs, as well as Nate Black, Nicole Dathe, Markus Schneider, Robin Leh-
mann, Ankita Agrawal, Wenzel Massag, Lars Berge, Jonas Lang, and Richard
Cubek.
Ravensburg
Wolfgang Ertel
March 2017
vi
Preface to the Second Edition

Preface to the First Edition
Artiﬁcial Intelligence (AI) has the deﬁnite goal of understanding intelligence and
building intelligent systems. However, the methods and formalisms used on the
way to this goal are not ﬁrmly set, which has resulted in AI consisting of a
multitude of subdisciplines today. The difﬁculty in an introductory AI course lies in
conveying as many branches as possible without losing too much depth and
precision.
Russell and Norvig’s book [RN10] is more or less the standard introduction into
AI. However, since this book has 1,152 pages, and since it is too extensive and
costly for most students, the requirements for writing this book were clear: it should
be an accessible introduction to modern AI for self-study or as the foundation of a
four-hour lecture, with at most 300 pages. The result is in front of you.
In the space of 300 pages, a ﬁeld as extensive as AI cannot be fully covered. To
avoid turning the book into a table of contents, I have attempted to go into some
depth and to introduce concrete algorithms and applications in each of the following
branches: agents, logic, search, reasoning with uncertainty, machine learning, and
neural networks.
The ﬁelds of image processing, fuzzy logic, and natural language processing are
not covered in detail. The ﬁeld of image processing, which is important for all of
computer science, is a stand-alone discipline with very good textbooks, such as
[GW08]. Natural language processing has a similar status. In recognizing and
generating text and spoken language, methods from logic, probabilistic reasoning,
and neural networks are applied. In this sense this ﬁeld is part of AI. On the other
hand, computer linguistics is its own extensive branch of computer science and has
much in common with formal languages. In this book we will point to such
appropriate systems in several places, but not give a systematic introduction. For a
ﬁrst introduction in this ﬁeld, we refer to Chaps. 22 and 23 in [RN10]. Fuzzy logic,
or fuzzy set theory, has developed into a branch of control theory due to its primary
application in automation technology and is covered in the corresponding books
and lectures. Therefore we will forego an introduction here.
The dependencies between chapters of the book are coarsely sketched in the
graph shown below. To keep it simple, Chap. 1, with the fundamental introduction
for all further chapters, is left out. As an example, the thicker arrow from 2 to 3
means that propositional logic is a prerequisite for understanding predicate logic.
vii

The thin arrow from 9 to 10 means that neural networks are helpful for under-
standing reinforcement learning, but not absolutely necessary. Thin backward
arrows should make clear that later chapters can give more depth of understanding
to topics which have already been learned.
This book is applicable to students of computer science and other technical natural
sciences and, for the most part, requires high school level knowledge of mathe-
matics. In several places, knowledge from linear algebra and multidimensional
analysis is needed. For a deeper understanding of the contents, actively working on
the exercises is indispensable. This means that the solutions should only be con-
sulted after intensive work with each problem, and only to check one’s solutions,
true to Leonardo da Vinci’s motto “Study without devotion damages the brain”.
Somewhat more difﬁcult problems are marked with ❄, and especially difﬁcult ones
with
❄❄. Problems which require programming or special computer science
knowledge are labeled with ➳.
On the book’s web site at http://www.hs-weingarten.de/*ertel/aibook digital
materials for the exercises such as training data for learning algorithms, a page with
references to AI programs mentioned in the book, a list of links to the covered
topics, a clickable list of the bibliography, an errata list, and presentation slides for
lecturers can be found. I ask the reader to please send suggestions, criticisms, and
tips about errors directly to ertel@hs-weingarten.de.
This book is an updated translation of my German book “Grundkurs Künstliche
Intelligenz” published by Vieweg Verlag. My special thanks go to the translator
Nathan Black who in an excellent trans-Atlantic cooperation between Germany and
California via SVN, Skype and Email produced this text. I am grateful to Franz
Kurfeß, who introduced me to Nathan; to MatthewWight for proofreading the
translated book and to Simon Rees from Springer Verlag for his patience.
I would like to thank my wife Evelyn for her support and patience during this
time consuming project. Special thanks go to Wolfgang Bibel and Chris Loben-
schuss, who carefully corrected the German manuscript. Their suggestions and
discussions lead to many improvements and additions. For reading the corrections
and other valuable services, I would like to thank Richard Cubek, Celal Döven,
Joachim Feßler, Nico Hochgeschwender, Paul Kirner, Wilfried Meister, Norbert
Perk, Peter Radtke, Markus Schneider, Manfred Schramm, Uli Stärk, Michel Tokic,
Arne Usadel and all interested students. My thanks also go out to Florian Mast for
the priceless cartoons and very effective collaboration.
I hope that during your studies this book will help you share my fascination with
Artiﬁcial Intelligence.
Ravensburg
Wolfgang Ertel
February 2011
viii
Preface to the First Edition

Contents
1
Introduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1
What Is Artiﬁcial Intelligence? . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1.1
Brain Science and Problem Solving. . . . . . . . . . . . . . .
3
1.1.2
The Turing Test and Chatterbots . . . . . . . . . . . . . . . . .
5
1.2
The History of AI. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.2.1
The First Beginnings . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.2.2
Logic Solves (Almost) All Problems . . . . . . . . . . . . . .
8
1.2.3
The New Connectionism . . . . . . . . . . . . . . . . . . . . . . .
9
1.2.4
Reasoning Under Uncertainty . . . . . . . . . . . . . . . . . . .
9
1.2.5
Distributed, Autonomous and Learning Agents . . . . . .
10
1.2.6
AI Grows Up. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
1.2.7
The AI Revolution. . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
1.3
AI and Society . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
1.3.1
Does AI Destroy Jobs? . . . . . . . . . . . . . . . . . . . . . . . .
11
1.3.2
AI and Transportation . . . . . . . . . . . . . . . . . . . . . . . . .
14
1.3.3
Service Robotics . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
1.4
Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
1.5
Knowledge-Based Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
1.6
Exercises. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
2
Propositional Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
2.1
Syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
2.2
Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
2.3
Proof Systems. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
2.4
Resolution. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
2.5
Horn Clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
2.6
Computability and Complexity . . . . . . . . . . . . . . . . . . . . . . . . .
36
2.7
Applications and Limitations . . . . . . . . . . . . . . . . . . . . . . . . . .
37
2.8
Exercises. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
37
ix

3
First-order Predicate Logic. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
3.1
Syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
3.2
Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
41
3.2.1
Equality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
3.3
Quantiﬁers and Normal Forms . . . . . . . . . . . . . . . . . . . . . . . . .
45
3.4
Proof Calculi. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
3.5
Resolution. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
3.5.1
Resolution Strategies . . . . . . . . . . . . . . . . . . . . . . . . . .
55
3.5.2
Equality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
55
3.6
Automated Theorem Provers. . . . . . . . . . . . . . . . . . . . . . . . . . .
56
3.7
Mathematical Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
3.8
Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
3.9
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
63
3.10
Exercises. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
63
4
Limitations of Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
4.1
The Search Space Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
4.2
Decidability and Incompleteness. . . . . . . . . . . . . . . . . . . . . . . .
67
4.3
The Flying Penguin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
69
4.4
Modeling Uncertainty . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
71
4.5
Exercises. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
73
5
Logic Programming with PROLOG . . . . . . . . . . . . . . . . . . . . . . . . .
75
5.1
PROLOG Systems and Implementations. . . . . . . . . . . . . . . . . .
76
5.2
Simple Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
5.3
Execution Control and Procedural Elements . . . . . . . . . . . . . . .
79
5.4
Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
81
5.5
Self-modifying Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
82
5.6
A Planning Example. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
83
5.7
Constraint Logic Programming . . . . . . . . . . . . . . . . . . . . . . . . .
85
5.8
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
87
5.9
Exercises. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
88
6
Search, Games and Problem Solving . . . . . . . . . . . . . . . . . . . . . . . . .
91
6.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
91
6.2
Uninformed Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
6.2.1
Breadth-First Search . . . . . . . . . . . . . . . . . . . . . . . . . .
97
6.2.2
Depth-First Search . . . . . . . . . . . . . . . . . . . . . . . . . . . .
99
6.2.3
Iterative Deepening . . . . . . . . . . . . . . . . . . . . . . . . . . .
100
6.2.4
Comparison . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
102
6.2.5
Cycle Check . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
102
6.3
Heuristic Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
103
6.3.1
Greedy Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
106
6.3.2
A★-Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
107
6.3.3
Route Planning with the A★Search Algorithm . . . . . .
109
x
Contents

6.3.4
IDA★-Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
111
6.3.5
Empirical Comparison of the Search Algorithms. . . . .
111
6.3.6
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
113
6.4
Games with Opponents. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
114
6.4.1
Minimax Search. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
114
6.4.2
Alpha-Beta-Pruning . . . . . . . . . . . . . . . . . . . . . . . . . . .
115
6.4.3
Non-deterministic Games. . . . . . . . . . . . . . . . . . . . . . .
117
6.5
Heuristic Evaluation Functions . . . . . . . . . . . . . . . . . . . . . . . . .
118
6.5.1
Learning of Heuristics . . . . . . . . . . . . . . . . . . . . . . . . .
118
6.6
State of the Art . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
119
6.6.1
Chess. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
120
6.6.2
Go . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
121
6.7
Exercises. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
122
7
Reasoning with Uncertainty . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
125
7.1
Computing with Probabilities . . . . . . . . . . . . . . . . . . . . . . . . . .
127
7.1.1
Conditional Probability . . . . . . . . . . . . . . . . . . . . . . . .
130
7.2
The Principle of Maximum Entropy . . . . . . . . . . . . . . . . . . . . .
136
7.2.1
An Inference Rule for Probabilities . . . . . . . . . . . . . . .
136
7.2.2
Maximum Entropy Without Explicit Constraints . . . . .
141
7.2.3
Conditional Probability Versus Material
Implication. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
142
7.2.4
MaxEnt-Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
143
7.2.5
The Tweety Example. . . . . . . . . . . . . . . . . . . . . . . . . .
144
7.3
LEXMED, an Expert System for Diagnosing Appendicitis. . . . . .
145
7.3.1
Appendicitis Diagnosis with Formal Methods . . . . . . .
145
7.3.2
Hybrid Probabilistic Knowledge Base . . . . . . . . . . . . .
146
7.3.3
Application of LEXMED. . . . . . . . . . . . . . . . . . . . . . . . .
149
7.3.4
Function of LEXMED. . . . . . . . . . . . . . . . . . . . . . . . . . .
150
7.3.5
Risk Management Using the Cost Matrix . . . . . . . . . .
153
7.3.6
Performance. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
155
7.3.7
Application Areas and Experiences . . . . . . . . . . . . . . .
157
7.4
Reasoning with Bayesian Networks . . . . . . . . . . . . . . . . . . . . .
158
7.4.1
Independent Variables . . . . . . . . . . . . . . . . . . . . . . . . .
158
7.4.2
Graphical Representation of Knowledge as a
Bayesian Network . . . . . . . . . . . . . . . . . . . . . . . . . . . .
160
7.4.3
Conditional Independence . . . . . . . . . . . . . . . . . . . . . .
160
7.4.4
Practical Application . . . . . . . . . . . . . . . . . . . . . . . . . .
162
7.4.5
Software for Bayesian Networks . . . . . . . . . . . . . . . . .
163
7.4.6
Development of Bayesian Networks . . . . . . . . . . . . . .
165
7.4.7
Semantics of Bayesian Networks. . . . . . . . . . . . . . . . .
168
7.5
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
170
7.6
Exercises. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
171
Contents
xi

8
Machine Learning and Data Mining . . . . . . . . . . . . . . . . . . . . . . . . .
175
8.1
Data Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
180
8.2
The Perceptron, a Linear Classiﬁer . . . . . . . . . . . . . . . . . . . . . .
183
8.2.1
The Learning Rule. . . . . . . . . . . . . . . . . . . . . . . . . . . .
185
8.2.2
Optimization and Outlook . . . . . . . . . . . . . . . . . . . . . .
188
8.3
The Nearest Neighbor Method . . . . . . . . . . . . . . . . . . . . . . . . .
189
8.3.1
Two Classes, Many Classes, Approximation . . . . . . . .
193
8.3.2
Distance Is Relevant . . . . . . . . . . . . . . . . . . . . . . . . . .
194
8.3.3
Computation Times . . . . . . . . . . . . . . . . . . . . . . . . . . .
195
8.3.4
Summary and Outlook. . . . . . . . . . . . . . . . . . . . . . . . .
196
8.3.5
Case-Based Reasoning. . . . . . . . . . . . . . . . . . . . . . . . .
197
8.4
Decision Tree Learning. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
198
8.4.1
A Simple Example. . . . . . . . . . . . . . . . . . . . . . . . . . . .
199
8.4.2
Entropy as a Metric for Information Content. . . . . . . .
200
8.4.3
Information Gain . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
203
8.4.4
Application of C4.5 . . . . . . . . . . . . . . . . . . . . . . . . . . .
205
8.4.5
Learning of Appendicitis Diagnosis. . . . . . . . . . . . . . .
207
8.4.6
Continuous Attributes . . . . . . . . . . . . . . . . . . . . . . . . .
210
8.4.7
Pruning—Cutting the Tree. . . . . . . . . . . . . . . . . . . . . .
211
8.4.8
Missing Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
212
8.4.9
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
213
8.5
Cross-Validation and Overﬁtting. . . . . . . . . . . . . . . . . . . . . . . .
213
8.6
Learning of Bayesian Networks . . . . . . . . . . . . . . . . . . . . . . . .
215
8.6.1
Learning the Network Structure. . . . . . . . . . . . . . . . . .
215
8.7
The Naive Bayes Classiﬁer. . . . . . . . . . . . . . . . . . . . . . . . . . . .
218
8.7.1
Text Classiﬁcation with Naive Bayes . . . . . . . . . . . . .
220
8.8
One-Class Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
222
8.8.1
Nearest Neighbor Data Description . . . . . . . . . . . . . . .
223
8.9
Clustering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
224
8.9.1
Distance Metrics . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
225
8.9.2
k-Means and the EM Algorithm . . . . . . . . . . . . . . . . .
226
8.9.3
Hierarchical Clustering . . . . . . . . . . . . . . . . . . . . . . . .
228
8.9.4
How is the Number of Clusters Determined? . . . . . . .
230
8.10
Data Mining in Practice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
233
8.10.1
The Data Mining Tool KNIME . . . . . . . . . . . . . . . . . .
233
8.11
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
236
8.12
Exercises. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
238
9
Neural Networks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
245
9.1
From Biology to Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . .
246
9.1.1
The Mathematical Model. . . . . . . . . . . . . . . . . . . . . . .
247
9.2
Hopﬁeld Networks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
250
xii
Contents

9.2.1
Application to a Pattern Recognition Example . . . . . .
251
9.2.2
Analysis. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
252
9.2.3
Summary and Outlook. . . . . . . . . . . . . . . . . . . . . . . . .
255
9.3
Neural Associative Memory . . . . . . . . . . . . . . . . . . . . . . . . . . .
256
9.3.1
Correlation Matrix Memory. . . . . . . . . . . . . . . . . . . . .
257
9.3.2
The Binary Hebb Rule. . . . . . . . . . . . . . . . . . . . . . . . .
259
9.3.3
A Spelling Correction Program . . . . . . . . . . . . . . . . . .
261
9.4
Linear Networks with Minimal Errors . . . . . . . . . . . . . . . . . . .
263
9.4.1
Least Squares Method . . . . . . . . . . . . . . . . . . . . . . . . .
264
9.4.2
Application to the Appendicitis Data. . . . . . . . . . . . . .
265
9.4.3
The Delta Rule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
266
9.4.4
Comparison to the Perceptron . . . . . . . . . . . . . . . . . . .
268
9.5
The Backpropagation Algorithm . . . . . . . . . . . . . . . . . . . . . . . .
269
9.5.1
NETtalk: A Network Learns to Speak . . . . . . . . . . . . .
272
9.5.2
Learning of Heuristics for Theorem Provers . . . . . . . .
273
9.5.3
Problems and Improvements . . . . . . . . . . . . . . . . . . . .
274
9.6
Support Vector Machines . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
275
9.7
Deep Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
277
9.7.1
Nature as Example. . . . . . . . . . . . . . . . . . . . . . . . . . . .
278
9.7.2
Stacked Denoising Autoencoder . . . . . . . . . . . . . . . . .
279
9.7.3
Other Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
280
9.7.4
Systems and Implementations . . . . . . . . . . . . . . . . . . .
281
9.7.5
Applications of Deep Learning . . . . . . . . . . . . . . . . . .
281
9.8
Creativity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
282
9.9
Applications of Neural Networks . . . . . . . . . . . . . . . . . . . . . . .
284
9.10
Summary and Outlook . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
285
9.11
Exercises. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
286
10
Reinforcement Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
289
10.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
289
10.2
The Task. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
291
10.3
Uninformed Combinatorial Search . . . . . . . . . . . . . . . . . . . . . .
293
10.4
Value Iteration and Dynamic Programming . . . . . . . . . . . . . . .
295
10.5
A Learning Walking Robot and Its Simulation . . . . . . . . . . . . .
298
10.6
Q-Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
300
10.6.1
Q-Learning in a Nondeterministic Environment. . . . . .
303
10.7
Exploration and Exploitation. . . . . . . . . . . . . . . . . . . . . . . . . . .
304
10.8
Approximation, Generalization and Convergence . . . . . . . . . . .
305
10.9
Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
306
10.10
AlphaGo, the Breakthrough in Go . . . . . . . . . . . . . . . . . . . . . .
306
10.11
Curse of Dimensionality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
309
10.12
Summary and Outlook . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
310
10.13
Exercises. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
310
Contents
xiii

11
Solutions for the Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
313
11.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
313
11.2
Propositional Logic. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
314
11.3
First-Order Predicate Logic. . . . . . . . . . . . . . . . . . . . . . . . . . . .
316
11.4
Limitations of Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
317
11.5
PROLOG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
317
11.6
Search, Games and Problem Solving . . . . . . . . . . . . . . . . . . . .
319
11.7
Reasoning with Uncertainty . . . . . . . . . . . . . . . . . . . . . . . . . . .
322
11.8
Machine Learning and Data Mining . . . . . . . . . . . . . . . . . . . . .
329
11.9
Neural Networks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
335
11.10
Reinforcement Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
337
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
339
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
351
xiv
Contents

1
Introduction
1.1
What Is Artificial Intelligence?
The term artiﬁcial intelligence stirs emotions. For one thing there is our fascination
with intelligence, which seemingly imparts to us humans a special place among life
forms. Questions arise such as “What is intelligence?”, “How can one measure
intelligence?” or “How does the brain work?”. All these questions are meaningful
when trying to understand artiﬁcial intelligence. However, the central question for
the engineer, especially for the computer scientist, is the question of the intelligent
machine that behaves like a person, showing intelligent behavior.
The attribute artiﬁcial might awaken much different associations. It brings up
fears of intelligent cyborgs. It recalls images from science ﬁction novels. It raises
the question of whether our highest good, the soul, is something we should try to
understand, model, or even reconstruct.
With such different offhand interpretations, it becomes difﬁcult to deﬁne the term
artiﬁcial intelligence or AI simply and robustly. Nevertheless I would like to try,
using examples and historical deﬁnitions, to characterize the ﬁeld of AI. In 1955,
John McCarthy, one of the pioneers of AI, was the ﬁrst to deﬁne the term artiﬁcial
intelligence, roughly as follows:
The goal of AI is to develop machines that behave as though they were intelligent.
To test this deﬁnition, the reader might imagine the following scenario. Fifteen
or so small robotic vehicles are moving on an enclosed four by four meter square
surface. One can observe various behavior patterns. Some vehicles form small
groups with relatively little movement. Others move peacefully through the
space and gracefully avoid any collision. Still others appear to follow a leader.
Aggressive behaviors are also observable. Is what we are seeing intelligent
behavior?
According to McCarthy’s deﬁnition the aforementioned robots can be described
as intelligent. The psychologist Valentin Braitenberg has shown that this seemingly
© Springer International Publishing AG 2017
W. Ertel, Introduction to Artificial Intelligence, Undergraduate Topics
in Computer Science, DOI 10.1007/978-3-319-58487-4_1
1

complex behavior can be produced by very simple electrical circuits [Bra84].
So-called Braitenberg vehicles have two wheels, each of which is driven by an
independent electric motor. The speed of each motor is inﬂuenced by a light sensor
on the front of the vehicle as shown in Fig. 1.1. The more light that hits the sensor,
the faster the motor runs. Vehicle 1 in the left part of the ﬁgure, according to its
conﬁguration, moves away from a point light source. Vehicle 2 on the other hand
moves toward the light source. Further small modiﬁcations can create other
behavior patterns, such that with these very simple vehicles we can realize the
impressive behavior described above.
Clearly the above deﬁnition is insufﬁcient because AI has the goal of solving
difﬁcult practical problems which are surely too demanding for the Braitenberg
vehicle. In the Encyclopedia Britannica [Bri91] one ﬁnds a Deﬁnition that goes like:
AI is the ability of digital computers or computer controlled robots to solve problems that
are normally associated with the higher intellectual processing capabilities of humans …
But this deﬁnition also has weaknesses. It would admit for example that a
computer with large memory that can save a long text and retrieve it on demand
displays intelligent capabilities, for memorization of long texts can certainly be
considered a higher intellectual processing capability of humans, as can for
example the quick multiplication of two 20-digit numbers. According to this
deﬁnition, then, every computer is an AI system. This dilemma is solved elegantly
by the following deﬁnition by Elaine Rich [Ric83]:
Artiﬁcial Intelligence is the study of how to make computers do things at which, at the
moment, people are better.
Rich, tersely and concisely, characterizes what AI researchers have been doing for
the last 50 years. Even in the year 2050, this deﬁnition will be up to date.
Tasks such as the execution of many computations in a short amount of time are
the strong points of digital computers. In this regard they outperform humans by
many multiples. In many other areas, however, humans are far superior to
machines. For instance, a person entering an unfamiliar room will recognize the
surroundings within fractions of a second and, if necessary, just as swiftly make
decisions and plan actions. To date, this task is too demanding for autonomous1
Fig. 1.1 Two very simple Braitenberg vehicles and their reactions to a light source
1An autonomous robot works independently, without manual support, in particular without remote
control.
2
1
Introduction

robots. According to Rich’s deﬁnition, this is therefore a task for AI. In fact,
research on autonomous robots is an important, current theme in AI. Construction
of chess computers, on the other hand, has lost relevance because they already play
at or above the level of grandmasters.
It would be dangerous, however, to conclude from Rich’s deﬁnition that AI is
only concerned with the pragmatic implementation of intelligent processes. Intel-
ligent systems, in the sense of Rich’s deﬁnition, cannot be built without a deep
understanding of human reasoning and intelligent action in general, because of
which neuroscience (see Sect. 1.1.1) is of great importance to AI. This also shows
that the other cited deﬁnitions reﬂect important aspects of AI.
A particular strength of human intelligence is adaptivity. We are capable of
adjusting to various environmental conditions and change our behavior accordingly
through learning. Precisely because our learning ability is so vastly superior to that
of computers, machine learning is, according to Rich’s deﬁnition, a central subﬁeld
of AI.
1.1.1
Brain Science and Problem Solving
Through research of intelligent systems we can try to understand how the human
brain works and then model or simulate it on the computer. Many ideas and
principles in the ﬁeld of neural networks (see Chap. 9) stem from brain science with
the related ﬁeld of neuroscience.
A very different approach results from taking a goal-oriented line of action,
starting from a problem and trying to ﬁnd the most optimal solution. How humans
solve the problem is treated as unimportant here. The method, in this approach, is
secondary. First and foremost is the optimal intelligent solution to the problem.
Rather than employing a ﬁxed method (such as, for example, predicate logic) AI
has as its constant goal the creation of intelligent agents for as many different tasks
as possible. Because the tasks may be very different, it is unsurprising that the
methods currently employed in AI are often also quite different. Similar to medi-
cine, which encompasses many different, often life-saving diagnostic and therapy
procedures, AI also offers a broad palette of effective solutions for widely varying
applications. For mental inspiration, consider Fig. 1.2 on page 4. Just as in medi-
cine, there is no universal method for all application areas of AI, rather a great
number of possible solutions for the great number of various everyday problems,
big and small.
Cognitive science is devoted to research into human thinking at a somewhat
higher level. Similarly to brain science, this ﬁeld furnishes practical AI with many
important ideas. On the other hand, algorithms and implementations lead to further
important conclusions about how human reasoning functions. Thus these three
ﬁelds beneﬁt from a fruitful interdisciplinary exchange. The subject of this book,
however, is primarily problem-oriented AI as a subdiscipline of computer science.
There are many interesting philosophical questions surrounding intelligence and
artiﬁcial intelligence. We humans have consciousness; that is, we can think about
1.1
What Is Artificial Intelligence?
3

ourselves and even ponder that we are able to think about ourselves. How does
consciousness come to be? Many philosophers and neurologists now believe that
the mind and consciousness are linked with matter, that is, with the brain. The
Fig. 1.2 A small sample of the solutions offered by AI
4
1
Introduction

question of whether machines could one day have a mind or consciousness could
at some point in the future become relevant. The mind-body problem in particu-
lar concerns whether or not the mind is bound to the body. We will not discuss
these questions here. The interested reader may consult [Spe98, Spe97] and
is invited, in the course of AI technology studies, to form a personal opinion about
these questions.
1.1.2
The Turing Test and Chatterbots
Alan Turing made a name for himself as an early pioneer of AI with his deﬁnition
of an intelligent machine, in which the machine in question must pass the following
test. The test person Alice sits in a locked room with two computer terminals. One
terminal is connected to a machine, the other with a non-malicious person Bob.
Alice can type questions into both terminals. She is given the task of deciding, after
ﬁve minutes, which terminal belongs to the machine. The machine passes the test if
it can trick Alice at least 30% of the time [Tur50].
While the test is very interesting philosophically, for practical AI, which deals
with problem solving, it is not a very relevant test. The reasons for this are similar to
those mentioned above related to Braitenberg vehicles (see Exercise 1.3 on
page 21).
The AI pioneer and social critic Joseph Weizenbaum developed a program
named Eliza, which is meant to answer a test subject’s questions like a human
psychologist [Wei66]. He was in fact able to demonstrate success in many cases.
Supposedly his secretary often had long discussions with the program. Today in the
internet there are many so-called chatterbots, some of whose initial responses are
quite impressive. After a certain amount of time, however, their artiﬁcial nature
becomes apparent. Some of these programs are actually capable of learning, while
others possess extraordinary knowledge of various subjects, for example geography
or software development. There are already commercial applications for chatterbots
in online customer support and there may be others in the ﬁeld of e-learning. It is
conceivable that the learner and the e-learning system could communicate through a
chatterbot. The reader may wish to compare several chatterbots and evaluate their
intelligence in Exercise 1.1 on page 20.
1.2
The History of AI
AI draws upon many past scientiﬁc achievements which are not mentioned here, for
AI as a science in its own right has only existed since the middle of the Twentieth
Century. Table 1.1 on page 6, with the most important AI milestones, and a
graphical representation of the main movements of AI in Fig. 1.3 on page 8
complement the following text.
1.1
What Is Artificial Intelligence?
5

Table 1.1 Milestones in the development of AI from Gödel to today
1931
The Austrian Kurt Gödel shows that in ﬁrst-order predicate logic all true statements
are derivable [Göd31a]. In higher-order logics, on the other hand, there are true
statements that are unprovable [Göd31b]. (In [Göd31b] Gödel showed that predicate
logic extended with the axioms of arithmetic is incomplete.)
1937
Alan Turing points out the limits of intelligent machines with the halting
problem [Tur37].
1943
McCulloch and Pitts model neural networks and make the connection to propositional
logic.
1950
Alan Turing deﬁnes machine intelligence with the Turing test and writes about
learning machines and genetic algorithms [Tur50].
1951
Marvin Minsky develops a neural network machine. With 3000 vacuum tubes he
simulates 40 neurons.
1955
Arthur Samuel (IBM) builds a learning checkers program that plays better than its
developer [Sam59].
1956
McCarthy organizes a conference in Dartmouth College. Here the name Artiﬁcial
Intelligence was ﬁrst introduced.
Newell and Simon of Carnegie Mellon University (CMU) present the Logic Theorist,
the ﬁrst symbol-processing computer program [NSS83].
1958
McCarthy invents at MIT (Massachusetts Institute of Technology) the high-level
language LISP. He writes programs that are capable of modifying themselves.
1959
Gelernter (IBM) builds the Geometry Theorem Prover.
1961
The General Problem Solver (GPS) by Newell and Simon imitates human
thought [NS61].
1963
McCarthy founds the AI Lab at Stanford University.
1965
Robinson invents the resolution calculus for predicate logic [Rob65] (Sect. 3.5).
1966
Weizenbaum’s program Eliza carries out dialog with people in natural
language [Wei66] (Sect. 1.1.2).
1969
Minsky and Papert show in their book Perceptrons that the perceptron, a very simple
neural network, can only represent linear functions [MP69] (Sect. 1.1.2).
1972
French scientist Alain Colmerauer invents the logic programming language PROLOG
(Chap. 5).
British physician de Dombal develops an expert system for diagnosis of acute
abdominal pain [dDLS+72]. It goes unnoticed in the mainstream AI community of the
time (Sect. 7.3).
1976
Shortliffe and Buchanan develop MYCIN, an expert system for diagnosis of infectious
diseases, which is capable of dealing with uncertainty (Chap. 7).
1981
Japan begins, at great expense, the “Fifth Generation Project” with the goal of building
a powerful PROLOG machine.
1982
R1, the expert system for conﬁguring computers, saves Digital Equipment Corporation
40 million dollars per year [McD82].
1986
Renaissance of neural networks through, among others, Rumelhart, Hinton and
Sejnowski [RM86]. The system Nettalk learns to read texts aloud [SR86] (Chap. 9).
1990
Pearl [Pea88], Cheeseman [Che85], Whittaker, Spiegelhalter bring probability theory
into AI with Bayesian networks (Sect. 7.4). Multi-agent systems become popular.
(continued)
6
1
Introduction

1.2.1
The First Beginnings
In the 1930s Kurt Gödel, Alonso Church, and Alan Turing laid important foundations
for logic and theoretical computer science. Of particular interest for AI are Gödel’s
theorems. The completeness theorem states that ﬁrst-order predicate logic is com-
plete. This means that every true statement that can be formulated in predicate logic is
provable using the rules of a formal calculus. On this basis, automatic theorem provers
could later be constructed as implementations of formal calculi. With the incom-
pleteness theorem, Gödel showed that in higher-order logics there exist true state-
ments that are unprovable.2 With this he uncovered painful limits of formal systems.
Alan Turing’s proof of the undecidability of the halting problem also falls into
this time period. He showed that there is no program that can decide whether a
given arbitrary program (and its respective input) will run in an inﬁnite loop. With
Table 1.1 (continued)
1992
Tesauros TD-gammon program demonstrates the advantages of reinforcement
learning.
1993
Worldwide RoboCup initiative to build soccer-playing autonomous robots [Roba].
1995
From statistical learning theory, Vapnik develops support vector machines, which are
very important today.
1997
IBM’s chess computer Deep Blue defeats the chess world champion Gary Kasparov.
First international RoboCup competition in Japan.
2003
The robots in RoboCup demonstrate impressively what AI and robotics are capable of
achieving.
2006
Service robotics becomes a major AI research area.
2009
First Google self-driving car drives on the California freeway.
2010
Autonomous robots begin to improve their behavior through learning.
2011
IBM’s “Watson” beats two human champions on the television game show
“Jeopardy!”. Watson understands natural language and can answer difﬁcult questions
very quickly (Sect. 1.4).
2015
Daimler premiers the ﬁrst autonomous truck on the Autobahn.
Google self-driving cars have driven over one million miles and operate within cities.
Deep learning (Sect. 11.9) enables very good image classiﬁcation.
Paintings in the style of the Old Masters can be automatically generated with deep
learning. AI becomes creative!
2016
The Go program AlphaGo by Google DeepMind [SHM+16] beats the European
champion 5:0 in January and Korean Lee Sedol, one of the world’s best Go players,
4:1 in March. Deep learning techniques applied to pattern recognition, as well as
reinforcement learning and Monte Carlo tree search lead to this success.
2Higher-order logics are extensions of predicate logic, in which not only variables, but also
function symbols or predicates can appear as terms in a quantiﬁcation. Indeed, Gödel only
showed that any system that is based on predicate logic and can formulate Peano arithmetic is
incomplete.
1.2
The History of AI
7

this Turing also identiﬁed a limit for intelligent programs. It follows, for example,
that there will never be a universal program veriﬁcation system.3
In the 1940s, based on results from neuroscience, McCulloch, Pitts and Hebb
designed the ﬁrst mathematical models of neural networks. However, computers at
that time lacked sufﬁcient power to simulate simple brains.
1.2.2
Logic Solves (Almost) All Problems
AI as a practical science of thought mechanization could of course only begin once
there were programmable computers. This was the case in the 1950s. Newell and
Simon introduced Logic Theorist, the ﬁrst automatic theorem prover, and thus also
showed that with computers, which actually only work with numbers, one can also
process symbols. At the same time McCarthy introduced, with the language LISP,
a programming language specially created for the processing of symbolic
structures. Both of these systems were introduced in 1956 at the historic Dartmouth
Conference, which is considered the birthday of AI.
In the US, LISP developed into the most important tool for the implementation
of symbol-processing AI systems. Thereafter the logical inference rule known as
resolution developed into a complete calculus for predicate logic.
1930
1940
1950
1960
1970
1980
1990
2000
2010
neuro−
hardware
Minsky/Papert
Turing
Gödel
LISP
GPS
resolution
PROLOG
heuristic search
probabilistic reasoning
symbolic
numeric
C4.5
Zadeh
Jaynes
Hunt
Bayesian networks
backpropagation
Dartmounth conference
ID3, CART
automated theorem provers
PTTP, Otter, SETHEO, E−prover
propositional logic
Davis/Putnam
hybrid
systems
book
planning in
robotics
deep learning
year
first order logic
representation
power of
decision tree learning
fuzzy logic
neural networks
support vector machines
Fig. 1.3 History of the various AI areas. The width of the bars indicates prevalence of the
method’s use
3This statement applies to “total correctness”, which implies a proof of correct execution as well as
a proof of termination for every valid input.
8
1
Introduction

In the 1970s the logic programming language PROLOG was introduced as the
European counterpart to LISP. PROLOG offers the advantage of allowing direct
programming using Horn clauses, a subset of predicate logic. Like LISP, PROLOG
has data types for convenient processing of lists.
Until well into the 1980s, a breakthrough spirit dominated AI, especially among
many logicians. The reason for this was the string of impressive achievements in
symbol processing. With the Fifth Generation Computer Systems project in Japan
and the ESPRIT program in Europe, heavy investment went into the construction of
intelligent computers.
For small problems, automatic provers and other symbol-processing systems
sometimes worked very well. The combinatorial explosion of the search space,
however, deﬁned a very narrow window for these successes. This phase of AI was
described in [RN10] as the “Look, Ma, no hands!” era.
Because the economic success of AI systems fell short of expectations, funding
for logic-based AI research in the United States fell dramatically during the 1980s.
1.2.3
The New Connectionism
During this phase of disillusionment, computer scientists, physicists, and Cognitive
scientists were able to show, using computers which were now sufﬁciently pow-
erful, that mathematically modeled neural networks are capable of learning using
training examples, to perform tasks which previously required costly programming.
Because of the fault-tolerance of such systems and their ability to recognize pat-
terns, considerable successes became possible, especially in pattern recognition.
Facial recognition in photos and handwriting recognition are two example appli-
cations. The system Nettalk was able to learn speech from example texts [SR86].
Under the name connectionism, a new subdiscipline of AI was born.
Connectionism boomed and the subsidies ﬂowed. But soon even here feasibility
limits became obvious. The neural networks could acquire impressive capabilities,
but it was usually not possible to capture the learned concept in simple formulas or
logical rules. Attempts to combine neural nets with logical rules or the knowledge
of human experts met with great difﬁculties. Additionally, no satisfactory solution
to the structuring and modularization of the networks was found.
1.2.4
Reasoning Under Uncertainty
AI as a practical, goal-driven science searched for a way out of this crisis. One
wished to unite logic’s ability to explicitly represent knowledge with neural net-
works’ strength in handling uncertainty. Several alternatives were suggested.
The most promising, probabilistic reasoning, works with conditional probabil-
ities for propositional calculus formulas. Since then many diagnostic and expert
systems have been built for problems of everyday reasoning using Bayesian
1.2
The History of AI
9

networks. The success of Bayesian networks stems from their intuitive compre-
hensibility,
the
clean
semantics
of
conditional
probability,
and from
the
centuries-old, mathematically grounded probability theory.
The weaknesses of logic, which can only work with two truth values, can be
solved by fuzzy logic, which pragmatically introduces inﬁnitely many values
between zero and one. Though even today its theoretical foundation is not totally
ﬁrm, it is being successfully utilized, especially in control engineering.
A much different path led to the successful synthesis of logic and neural net-
works under the name hybrid systems. For example, neural networks were
employed to learn heuristics for reduction of the huge combinatorial search space in
proof discovery [SE90].
Methods of decision tree learning from data also work with probabilities.
Systems like CART, ID3 and C4.5 can quickly and automatically build very
accurate decision trees which can represent propositional logic concepts and then
be used as expert systems. Today they are a favorite among machine learning
techniques (Sect. 8.4).
Since about 1990, data mining has developed as a subdiscipline of AI in the area
of statistical data analysis for extraction of knowledge from large databases. Data
mining brings no new techniques to AI, rather it introduces the requirement of using
large databases to gain explicit knowledge. One application with great market
potential is steering ad campaigns of big businesses based on analysis of many
millions of purchases by their customers. Typically, machine learning techniques
such as decision tree learning come into play here.
1.2.5
Distributed, Autonomous and Learning Agents
Distributed artiﬁcial intelligence, DAI, has been an active area research since about
1985. One of its goals is the use of parallel computers to increase the efﬁciency of
problem solvers. It turned out, however, that because of the high computational
complexity of most problems, the use of “intelligent” systems is more beneﬁcial
than parallelization itself.
A very different conceptual approach results from the development of autonomous
software agents and robots that are meant to cooperate like human teams. As with the
aforementioned Braitenberg vehicles, there are many cases in which an individual
agent is not capable of solving a problem, even with unlimited resources. Only the
cooperation of many agents leads to the intelligent behavior or to the solution of a
problem. An ant colony or a termite colony is capable of erecting buildings of very
high architectural complexity, despite the fact that no single ant comprehends how the
whole thing ﬁts together. This is similar to the situation of provisioning bread for a
large city like New York [RN10]. There is nocentral planningagency for bread, rather
there are hundreds of bakers that know their respective areas of the city and bake the
appropriate amount of bread at those locations.
Active skill acquisition by robots is an exciting area of current research. There
are robots today, for example, that independently learn to walk or to perform
10
1
Introduction

various motorskills related to soccer (Chap. 10). Cooperative learning of multiple
robots to solve problems together is still in its infancy.
1.2.6
AI Grows Up
The above systems offered by AI today are not a universal recipe, but a workshop
with a manageable number of tools for very different tasks. Most of these tools are
well-developed and are available as ﬁnished software libraries, often with conve-
nient user interfaces. The selection of the right tool and its sensible use in each
individual case is left to the AI developer or knowledge engineer. Like any other
artisanship, this requires a solid education, which this book is meant to promote.
More than nearly any other science, AI is interdisciplinary, for it draws upon
interesting discoveries from such diverse ﬁelds as logic, operations research,
statistics, control engineering, image processing, linguistics, philosophy, psychol-
ogy, and neurobiology. On top of that, there is the subject area of the particular
application. To successfully develop an AI project is therefore not always so
simple, but almost always extremely exciting.
1.2.7
The AI Revolution
Around the year 2010 after about 25 years of research on neural networks, scientists
could start harvesting the fruits of their research. The very powerful deep learning
networks can for example learn to classify images with very high arruracy. Since
image classiﬁcation is of crucial importance for all types of smart robots, this initiated
the AI revolution which in turn leads to smart self-driving cars and service robots.
1.3
AI and Society
There have been many scientiﬁc books and science ﬁction novels written on all
aspects of this subject. Due to great advances in AI research, we have been on the
brink of the age of autonomous robots and the Internet of Things since roughly
2005. Thus we are increasingly confronted with AI in everyday life. The reader,
who may soon be working as an AI developer, must also deal with the social impact
of this work. As an author of a book on AI techniques, I have the crucial task of
examining this topic. I would like to deal with some particularly important aspects
of AI which are of great practical relevance for our lives.
1.3.1
Does AI Destroy Jobs?
In January 2016, the World Econonic Forum published a study [SS16], frequently
cited by the German press, predicting that “industry 4.0 ” would destroy over ﬁve
1.2
The History of AI
11

million jobs in the next ﬁve years. This forecast is hardly surprising because auto-
mation in factories, ofﬁces, administration, transportation, in the home and in many
other areas has led to continually more work being done by computers, machines and
robots. AI has been one of the most important factors in this trend since about 2010.
Presumably, the majority of people would gladly leave physically hard, dirty and
unhealthy jobs and tasks to machines. Thus automation is a complete blessing for
humanity, assuming it does not result in negative side effects, such as harm to the
environment. Many of the aforementioned unpleasant jobs can be done faster, more
precisely, and above all cheaper by machines. This seems almost like a trend
towards paradise on Earth, where human beings do less and less unpleasant work
and have correspondingly more time for the good things in life. This seems almost
like a trend towards paradise on earth. We have to do less and less unpleasant work
and in turn have more time for the good things in life.4 All the while, we would
enjoy the same (or potentially even increasing) prosperity, for the economy would
not employ these machines if they did not markedly raise productivity.
Unfortunately we are not on the road to paradise. For several decades, we have
worked more than 40 hours per week, have been stressed, complained of burnout
and other sicknesses, and suffered a decline in real wages. How can this be, if
productivity is continually increasing? Many economists say that the reason for this
is competitive pressure. In an effort to compete and deliver the lowest priced goods
to market, companies need to lower production costs and thus lay off workers. This
results in the aforementioned unemployment. In order to avoid a drop in sales
volume due to reduced prices, more products need to be manufactured and sold.
The economy must grow!
If the economy continues to grow in a country in which the population is no
longer growing (as is the case in most modern industrialized countries), each citizen
must necessarily consume more. For that to happen, new markets must be created,5
and marketing has the task of convincing us that we want the new products.
This is—allegedly—the only way to “sustainably” ensure prosperity. Apparently
there seems to be no escape from this growth/consumption spiral. This has two fatal
consequences. For one thing, this increase in consumption should make people
happier, but it is having quite the opposite effect: mental illness is increasing.
Even more obvious and, above all, fatal, are economic growth’s effects on our
living conditions. It is no secret that the earth’s growth limit has long been excee-
ded [MMZM72, Ran12], and that we are overexploiting nature’s nonrenewable
resources. We are therefore living at the expense of our children and grandchildren,
who consequently will have poorer living conditions than we have today. It is also
known that every additional dollar of economic growth is an additional burden on
the environment—for example through additional CO2 concentration in the atmo-
sphere and the resulting climate change [Pae16]. We are destroying our own basis of
4Those of us, such as scientists, computer scientists and engineers, who enjoy it may of course
continue our work.
5Many EU and German Ministry of Education and Research funding programs for example require
that scientists who submit proposals show evidence that their research will open up new markets.
12
1
Introduction

existence. Thus it is obvious that we should abandon this path of growth for the sake
of a livable future. But how?
Let’s think back to the road to paradise that AI is supposedly preparing for us.
Apparently, as we practice it, it does not lead to paradise. Understanding this
problem and ﬁnding the right path is one of the central tasks of today. Because of
inherent complexities, this problem can not be fully dealt with in an introductory AI
textbook. However, I would like to provide the reader with a little food for thought.
Although productivity is growing steadily in almost all areas of the economy,
workers are required to work as hard as ever. They do not beneﬁt from the increase
in productivity. So, we must ask, where do the proﬁts go? Evidently not to the
people to whom they are owed, i.e. the workers. Instead, part of the proﬁts is spent
on investment and thus on further growth and the rest is taken by the capital
owners, while employees work the same hours for declining real wages [Pik14].
This leads to ever-increasing capital concentration among a few rich individuals and
private banks, while on the other hand increasing poverty around the world is
creating political tensions that result in war, expulsion and ﬂight.
What is missing is a fair and just distribution of proﬁts. How can this be
achieved? Politicians and economists are continually trying to optimize our eco-
nomic system, but politics has not offered a sustainable solution, and too few
economists are investigating this highly exciting economic question. Obviously the
attempt to optimize the parameters of our current capitalist economic system has not
lead to a more equitable distribution of wealth, but to the opposite.
This is why economists and ﬁnancial scientists must begin to question the
system and look for alternatives. We should ask ourselves how to change the rules
and laws of the economy so that all people proﬁt from increased productivity.
A growing community of economists and sustainability scientists have offered
interesting solutions, a few of which I will brieﬂy describe here.
Problem Number One is the creation of ﬁat money by the banks. New money—
which is needed, among other things, to keep our growing economy going—is now
being created by private banks. This is made possible by the fact that banks have to
own only a small part, namely the minimum cash reserve ratio, of the money they
give as loans. In the EU in 2016, the minimum cash reserve ratio is one percent.
States then borrow this money from private banks in the form of government
bonds and thus fall into debt. This is how our current government debt crises have
developed. This problem can be solved easily by prohibiting creation of money by
the banks by increasing the minimum cash reserve ratio to 100%. State central banks
will then get back the monopoly on creating money, and the newly created money
can be used directly by the state for the purposes of social welfare. It should be
evident that this simple measure would signiﬁcantly ease the problem of public debt.
Further interesting components of such an economic reform could be the
conversion of the current interest rate system to the so-called natural economic order
[GP58], and the introduction of the “economy for the common good” [Fel14] and the
biophysical economy [GK09, Küm11]. The practical implementation of the econ-
omy for the common good would involve a tax reform, the most important elements
of which would be the abolition of the income tax and substantially increased value
1.3
AI and Society
13

added tax on energy and resource consumption. We would thus arrive at a highly
prosperous, more sustainable human world with less environmental damage and
more local trade. The reader may study the literature and assess whether the ideas
quoted here are interesting and, if necessary, help to make the required changes.
To conclude this section, I would like to quote the famous physicist Stephen
Hawking. In a community-driven interview on www.reddit.com he gave the following
answer to whether he had any thoughts about unemployment caused by automation:
If machines produce everything we need, the outcome will depend on how things are
distributed. Everyone can enjoy a life of luxurious leisure if the machine-produced
wealth is shared, or most people can end up miserably poor if the machine-owners
successfully lobby against wealth redistribution. So far, the trend seems to be toward the
second option, with technology driving ever-increasing inequality.
Another Hawking quotation is also ﬁtting. During the same interview,6 to an AI
professor’s question about which moral ideas he should impart to his students,
Hawking answered:
… Please encourage your students to think not only about how to create AI, but also about
how to ensure its beneﬁcial use.
As a consequence we should question the reasonableness of AI applications such as
the export of intelligent cruise missiles to “allied” Arab states, the deployment of
humanoid combat robots, etc.
1.3.2
AI and Transportation
In the past 130 years, automotive industry engineers have made great strides. In
Germany, one out of every two people owns their own car. These cars are highly
reliable. This makes us very mobile and we use this very convenient mobility in work,
everyday life and leisure. Moreover, we are dependent on it. Today, we can not get by
without a motor vehicle, especially in rural areas with weak public transportation
infrastructure, as for instance in Upper Swabia, where the author and his students live.
The next stage of increased convenience in road transportation is now imminent.
In a few years, we will be able to buy electric self-driving cars, i.e. robotic cars,
which will autonomously bring us to almost any destination. All passengers in the
robotic car would be able to read, work or sleep during the trip. This is possible on
public transit already, but passengers in a robotic car would be able to do this at any
time and on any route.
Autonomous vehicles that can operate independently could also travel without
passengers. This will lead to yet another increase in convenience: robotic taxis. Via a
smartphone app, we will be able to order the optimal taxi, in terms of size and
equipment, for any conceivable transportation purpose. We will be able to choose
whether we want to travel alone in the taxi or whether we are willing to share a ride with
6https://www.reddit.com/user/Prof-Stephen-Hawking.
14
1
Introduction

other passengers. We will not need our own car anymore. All associated responsibil-
ities and expenses, such as refueling, technical service, cleaning, searching for parking,
buying and selling, garage rent, etc. are void, which saves us money and effort.
Besides the immediate gains in comfort and convenience, robotic cars will offer
other signiﬁcant advantages. For example, according to a McKinsey study [GHZ14],
we will need far fewer cars and, above all, far fewer parking places in the era of
self-driving cars, which will lead to an immense reduction in resource consumption.
According to a Lawrence Berkeley National Laboratory study [GS15], electric
self-driving cars will cause a 90% reduction in green house emissions per passenger
mile due to the vehicles’ energy efﬁciency and the optimized ﬁt between the vehicle
and its purpose. Due to their optimal resource utilization, robotic taxis will be much
more environmentally friendly than, for example, heavy buses, which often run at
low capacity, especially in rural areas. Overall, robot taxis will contribute dramati-
cally to energy savings and thus, among other things, to a signiﬁcant improvement in
CO2 and climate problems.
Passenger safety will be much higher than it is today. Experts currently estimate
future accident rates between zero and ten percent compared to today. Emotional
driving (“road rage”), distracted driving and driving under the inﬂuence of drugs
and alcohol will no longer exist.
Taxi drivers losing their jobs is often cited as a disadvantage of robotic cars. It is
almost certain that there will no longer be taxi drivers from about 2030 onwards,
but that is not necessarily a problem. As explained in the previous section, our
society just needs to deal with the newly gained productivity properly.
In addition to the many advantages mentioned above, robotic cars have two critical
problems. Firstly, the so-called rebound effect will nullify at least some of the gains in
resource, energy and time savings. Shorter driving times as well as more comfortable
and cheaper driving will tempt us to drive more. We can only deal with this problem
by rethinking our attitude towards consumption and quality of life. Do we have to use
the entire time saved for more activities? Here we are all invited to critical reﬂection.
Another problem we should take seriously is that the robotic cars will need to be
networked. In principle, this gives hackers and terrorists the ability to access and
manipulate the vehicles’ controls through security holes in their network protocols.
If a hacker manages to do this once, he could repeat the attack on a grand scale,
potentially bringing entire vehicle ﬂeets to a halt, causing accidents, spying on
vehicle occupants, or initiating other criminal actions. Here, as in other areas such
as home automation and the Internet of Things, IT security experts will be needed
to ensure the highest possible security guarantees using tools of the trade such as
cryptographic methods. By the way, improved machine learning algorithms will be
useful in detecting hacking attacks.
1.3.3
Service Robotics
In a few years, shortly after self-driving cars, the next bit of consumption bait on the
shelves of electronics stores will be service robots. Recently the Google subsidiary
1.3
AI and Society
15

Boston Dynamics provided an impressive example in its humanoid robot Atlas.7
Like the new cars, service robots offer a large gain in comfort and convenience
which we would probably like to enjoy. One need only imagine such a robot
dutifully cleaning and scrubbing after a party from night until morning without a
grumble. Or think of the help that an assistance robot like Marvin, shown in
Fig. 1.4, could provide to the elderly8 or to people with disabilities [SPR+16].
In contrast to the robotic cars, however, these beneﬁts come with costlier
trade-offs. Completely new markets would be created, more natural resources and
more energy would be consumed, and it is not even certain that people’s lives
would be simpliﬁed by the use of service robots in all areas. One of the ﬁrst
applications for robots like Atlas, developed by Boston Dynamics in contract with
Google, will probably be military combat.
It is therefore all the more important that, before these robots come to market,
we engage in social discourse on this topic. Science ﬁction ﬁlms, such as
“Ex Machina” (2015) with its female androids, the chilling “I, Robot” (2004) or the
humorous “Robot and Frank” (2012), which depicts the pleasant side of a service
robot as an old man’s helper, can also contribute to such a discussion.
Fig. 1.4 The assistance
robot Marvin, deployed in the
AsRoBe research project
7https://youtu.be/rVlhMGQgDkY.
8In the coming demographic shift, assistance robots could become important for the elderly and
thus for our whole society.
16
1
Introduction

1.4
Agents
Although the term intelligent agents is not new to AI, only in recent years has it
gained prominence through [RN10], among others. Agent denotes rather generally a
system that processes information and produces an output from an input. These
agents may be classiﬁed in many different ways.
In classical computer science, software agents are primarily employed
(Fig. 1.5). In this case the agent consists of a program that calculates a result from
user input.
In robotics, on the other hand, hardware agents (also called autonomous robots)
are employed, which additionally have sensors and actuators at their disposal
(Fig. 1.6). The agent can perceive its environment with the sensors. With the
actuators it carries out actions and changes its environment.
With respect to the intelligence of the agent, there is a distinction between reﬂex
agents, which only react to input, and agents with memory, which can also include
the past in their decisions. For example, a driving robot that through its sensors
knows its exact position (and the time) has no way, as a reﬂex agent, of determining
its velocity. If, however, it saves the position, at short, discrete time steps, it can
thus easily calculate its average velocity in the previous time interval.
If a reﬂex agent is controlled by a deterministic program, it represents a function
of the set of all inputs to the set of all outputs. An agent with memory, on the other
hand, is in general not a function. Why? (See Exercise 1.5 on page 21.) Reﬂex
agents are sufﬁcient in cases where the problem to be solved involves a Markov
decision process. This is a process in which only the current state is needed to
determine the optimal next action (see Chap. 10).
A mobile robot which should move from room 112 to room 179 in a building
takes actions different from those of a robot that should move to room 105. In other
words, the actions depend on the goal. Such agents are called goal-based.
Fig. 1.5 A software agent
with user interaction
Fig. 1.6 A hardware agent
1.4
Agents
17

Example 1.1 A spam ﬁlter is an agent that puts incoming emails into wanted or
unwanted (spam) categories, and deletes any unwanted emails. Its goal as a goal-
based agent is to put all emails in the right category. In the course of this
not-so-simple task, the agent can occasionally make mistakes. Because its goal is to
classify all emails correctly, it will attempt to make as few errors as possible.
However, that is not always what the user has in mind. Let us compare the fol-
lowing two agents. Out of 1,000 emails, Agent 1 makes only 12 errors. Agent 2 on
the other hand makes 38 errors with the same 1,000 emails. Is it therefore worse
than Agent 1? The errors of both agents are shown in more detail in the following
table, the so-called “confusion matrix”:
Agent 1:
Agent 2:
correct class
wanted spam
spam ﬁlter
decides
wanted
189
1
spam
11
799
correct class
wanted spam
spam ﬁlter
decides
wanted
200
38
spam
0
762
Agent 1 in fact makes fewer errors than Agent 2, but those few errors are severe
because the user loses 11 potentially important emails. Because there are in this
case two types of errors of differing severity, each error should be weighted with the
appropriate cost factor (see Sect. 7.3.5 and Exercise 1.7 on page 21).
The sum of all weighted errors gives the total cost caused by erroneous
decisions.The goal of a cost-based agent is to minimize the cost of erroneous
decisions in the long term, that is, on average. In Sect. 7.3 we will become
familiar with the medical diagnosis system LEXMED as an example of a
cost-based agent.
Analogously, the goal of a utility-based agent is to maximize the utility derived
from correct decisions in the long term, that is, on average. The sum of all decisions
weighted by their respective utility factors gives the total utility.
Of particular interest in AI are Learning agents, which are capable of changing
themselves given training examples or through positive or negative feedback, such
that the average utility of their actions grows over time (see Chap. 8).
As mentioned in Sect. 1.2.5, distributed agents are increasingly coming into use,
whose intelligence are not localized in one agent, but rather can only be seen
through cooperation of many agents.
The design of an agent is oriented, along with its objective, strongly toward its
environment, or alternately its picture of the environment, which strongly depends
on it sensors. The environment is observable if the agent always knows the complete
state of the world. Otherwise the environment is only partially observable. If an
action always leads to the same result, then the environment is deterministic.
Otherwise it is nondeterministic. In a discrete environment only ﬁnitely many
states and actions occur, whereas a continuous environment boasts inﬁnitely many
states or actions.
18
1
Introduction

1.5
Knowledge-Based Systems
An agent is a program that implements a mapping from perceptions to actions. For
simple agents this way of looking at the problem is sufﬁcient. For complex
applications in which the agent must be able to rely on a large amount of infor-
mation and is meant to do a difﬁcult task, programming the agent can be very costly
and unclear how to proceed. Here AI provides a clear path to follow that will
greatly simplify the work.
First we separate knowledge from the system or program, which uses the
knowledge to, for example, reach conclusions, answer queries, or come up with a
plan. This system is called the inference mechanism. The knowledge is stored in
a knowledge base (KB). Acquisition of knowledge in the knowledge base is
denoted Knowledge Engineering and is based on various knowledge sources such
as human experts, the knowledge engineer, and databases. Active learning
systems can also acquire knowledge through active exploration of the world (see
Chap. 10). In Fig. 1.7 the general architecture of knowledge-based systems is
presented.
Moving toward a separation of knowledge and inference has several crucial
advantages. The separation of knowledge and inference can allow inference
systems to be implemented in a largely application-independent way. For example,
application of a medical expert system to other diseases is much easier by replacing
the knowledge base rather than by programming a whole new system.
Through the decoupling of the knowledge base from inference, knowledge can
be stored declaratively. In the knowledge base there is only a description of the
knowledge, which is independent from the inference system in use. Without this
clear separation, knowledge and processing of inference steps would be interwoven,
and any changes to the knowledge would be very costly.
Fig. 1.7 Structure of a classic knowledge-processing system
1.5
Knowledge-Based Systems
19

Formal language as a convenient interface between man and machine lends itself
to the representation of knowledge in the knowledge base. In the following chapters
we will get to know a whole series of such languages. First, in Chaps. 2 and 3 there
are propositional calculus and ﬁrst-order predicate logic (PL1). But other for-
malisms such as probabilistic logic and decision trees are also presented. We start
with propositional calculus and the related inference systems. Building on that, we
will present predicate logic, a powerful language that is accessible by machines and
very important in AI.
As an example for a large scale knowledge based system we want to refer to
the software agent “Watson”. Developed at IBM together with a number of
universities, Watson is a question answering program, that can be fed with clues
given in natural language. It works on a knowledge base comprising four terabytes
of hard disk storage, including the full text of Wikipedia [FNA+09]. Watson was
developed within IBM’s DeepQA project which is characterized in [Dee11] as
follows:
The DeepQA project at IBM shapes a grand challenge in Computer Science that aims to
illustrate how the wide and growing accessibility of natural language content and the
integration and advancement of Natural Language Processing, Information Retrieval,
Machine Learning, Knowledge Representation and Reasoning, and massively parallel
computation can drive open-domain automatic Question Answering technology to a point
where it clearly and consistently rivals the best human performance.
In the U.S. television quiz show “Jeopardy!”, in February 2011, Watson defeated
the two human champions Brad Rutter and Ken Jennings in a two-game,
combined-point match and won the one million dollar price. One of Watson’s
particular strengths was its very fast reaction to the questions with the result that
Watson often hit the buzzer (using a solenoid) faster than its human competitors and
then was able to give the ﬁrst answer to the question.
The high performance and short reaction times of Watson were due to an
implementation on 90 IBM Power 750 servers, each of which contains 32
processors, resulting in 2880 parallel processors.
1.6
Exercises
Exercise 1.1 Test some of the chatterbots available on the internet. Start for
example with www.hs-weingarten.de/*ertel/aibook in the collection of links under
Turingtest/Chatterbots, or at www.simonlaven.com or www.alicebot.org. Write
down a starting question and measure the time it takes, for each of the various
programs, until you know for certain that it is not a human.
❄❄Exercise 1.2 At www.pandorabots.com you will ﬁnd a server on which you can
build a chatterbot with the markup language AIML quite easily. Depending on
your interest level, develop a simple or complex chatterbot, or change an
existing one.
20
1
Introduction

Exercise 1.3 Give reasons for the unsuitability of the Turing test as a deﬁnition of
“artiﬁcial intelligence” in practical AI.
➳Exercise 1.4 Many well-known inference processes, learning processes, etc. are
NP-complete or even undecidable. What does this mean for AI?
Exercise 1.5
(a) Why is a deterministic agent with memory not a function from the set of all
inputs to the set of all outputs, in the mathematical sense?
(b) How can one change the agent with memory, or model it, such that it becomes
equivalent to a function but does not lose its memory?
Exercise 1.6 Let there be an agent with memory that can move within a plane.
From its sensors, it receives at clock ticks of a regular interval Dt its exact position
(x, y) in Cartesian coordinates.
(a) Give a formula with which the agent can calculate its velocity from the current
time t and the previous measurement of t −Dt.
(b) How must the agent be changed so that it can also calculate its acceleration?
Provide a formula here as well.
❄Exercise 1.7
(a) Determine for both agents in Example 1.1 on page 18 the costs created by the
errors and compare the results. Assume here that having to manually delete a
spam email costs one cent and retrieving a deleted email, or the loss of an
email, costs one dollar.
(b) Determine for both agents the proﬁt created by correct classiﬁcations and
compare the results. Assume that for every desired email recognized, a proﬁt
of one dollar accrues and for every correctly deleted spam email, a proﬁt of
one cent.
1.6
Exercises
21

2
Propositional Logic
In propositional logic, as the name suggests, propositions are connected by logical
operators. The statement “the street is wet” is a proposition, as is “it is raining”.
These two propositions can be connected to form the new proposition
if it is raining the street is wet.
Written more formally
it is raining ) the street is wet.
This notation has the advantage that the elemental propositions appear again in
unaltered form. So that we can work with propositional logic precisely, we will
begin with a deﬁnition of the set of all propositional logic formulas.
2.1
Syntax
Deﬁnition 2.1 Let Op = {¬, ^, _, ),,,(,)} be the set of logical operators
and R a set of symbols. The sets Op, R and {t, f} are pairwise disjoint. R is
called the signature and its elements are the proposition variables. The set of
propositional logic formulas is now recursively deﬁned:
• t and f are (atomic) formulas.
• All proposition variables, that is all elements from R, are (atomic)
formulas.
• If A and B are formulas, then ¬A, (A), A ^ B, A _ B, A ) B, A , B are
also formulas.
© Springer International Publishing AG 2017
W. Ertel, Introduction to Artificial Intelligence, Undergraduate Topics
in Computer Science, DOI 10.1007/978-3-319-58487-4_2
23

This elegant recursive deﬁnition of the set of all formulas allows us to generate
inﬁnitely many formulas. For example, given R = {A, B, C},
A ^ B;
A ^ B ^ C;
A ^ A ^ A;
C ^ B _ A;
ð:A ^ BÞ ) ð:C _ AÞ
are formulas. (((A)) _ B) is also a syntactically correct formula.
Deﬁnition 2.2
We read the symbols and operators in the following way:
t: “true”
f : “false”
¬A: “not A”
(negation)
A ∧B: “A and B”
(conjunction)
A ∨B: “A or B”
(disjunction)
A ⇒B: “if A then B”
(implication (also called material implication))
A ⇔B: “A if and only if B” (equivalence)
The formulas deﬁned in this way are so far purely syntactic constructions
without meaning. We are still missing the semantics.
2.2
Semantics
In propositional logic there are two truth values: t for “true” and f for “false”.
We begin with an example and ask ourselves whether the formula A ^ B is true.
The answer is: it depends on whether the variables A and B are true. For example, if
A stands for “It is raining today” and B for “It is cold today” and these are both true,
then A ^ B is true. If, however, B represents “It is hot today” (and this is false), then
A ^ B is false.
We must obviously assign truth values that reﬂect the state of the world to
proposition variables. Therefore we deﬁne
Deﬁnition 2.3
A mapping I : R ! {t, f}, which assigns a truth value to
every proposition variable, is called an interpretation.
Because every proposition variable can take on two truth values, every propo-
sitional logic formula with n different variables has 2n different interpretations.
We deﬁne the truth values for the basic operations by showing all possible inter-
pretations in a truth table (see Table 2.1 on page 25).
24
2
Propositional Logic

The empty formula is true for all interpretations. In order to determine the truth
value for complex formulas, we must also deﬁne the order of operations for logical
operators. If expressions are parenthesized, the term in the parentheses is evaluated
ﬁrst. For unparenthesized formulas, the priorities are ordered as follows, beginning
with the strongest binding: ¬, ^, _, ),,.
To clearly differentiate between the equivalence of formulas and syntactic
equivalence, we deﬁne
Deﬁnition 2.4
Two formulas F and G are called semantically equivalent if
they take on the same truth value for all interpretations. We write F  G.
Semantic equivalence serves above all to be able to use the meta-language, that
is, natural language, to talk about the object language, namely logic. The statement
“A  B” conveys that the two formulas A and B are semantically equivalent. The
statement “A, B” on the other hand is a syntactic object of the formal language of
propositional logic.
According to the number of interpretations in which a formula is true, we can
divide formulas into the following classes:
Deﬁnition 2.5
A formula is called
• Satisﬁable if it is true for at least one interpretation.
• Logically valid or simply valid if it is true for all interpretations. True
formulas are also called tautologies.
• Unsatisﬁable if it is not true for any interpretation.
Every interpretation that satisﬁes a formula is called a model of the formula.
Clearly the negation of every generally valid formula is unsatisﬁable. The
negation of a satisﬁable, but not generally valid formula F is satisﬁable.
We are now able to create truth tables for complex formulas to ascertain their
truth values. We put this into action immediately using equivalences of formulas
which are important in practice.
Table 2.1 Deﬁnition of the
logical operators by truth
table
A
B
(A)
¬A
A ^ B A _ B A ) B A,B
t
t
t
f
t
t
t
t
t
f
t
f
f
t
f
f
f
t
f
t
f
t
t
f
f
f
f
t
f
f
t
t
2.2
Semantics
25

Theorem 2.1 The operations ^, _ are commutative and associative, and the
following equivalences are generally valid:
¬A ∨B
⇔
A ⇒B
(implication)
A ⇒B
⇔
¬B ⇒¬A
(contraposition)
(A ⇒B) ∧(B ⇒A)
⇔
(A ⇔B)
(equivalence)
¬(A ∧B)
⇔
¬A ∨¬B
(De Morgan’s law)
¬(A ∨B)
⇔
¬A ∧¬B
A ∨(B ∧C)
⇔
(A ∨B) ∧(A ∨C)
(distributive law)
A ∧(B ∨C)
⇔
(A ∧B) ∨(A ∧C)
A ∨¬A
⇔
w
(tautology)
A ∧¬A
⇔
f
(contradiction)
A ∨f
⇔
A
A ∨w
⇔
w
A ∧f
⇔
f
A ∧w
⇔
A
Proof
To show the ﬁrst equivalence, we calculate the truth table for ¬A _ B and
A ) B and see that the truth values for both formulas are the same for all
interpretations. The formulas are therefore equivalent, and thus all the values of the
last column are “t”s.
The proofs for the other equivalences are similar and are recommended as exercises
for the reader (Exercise 2.2 on page 37).
□
2.3
Proof Systems
In AI we are interested in taking existing knowledge and from that deriving new
knowledge or answering questions. In propositional logic this means showing that a
knowledge base KB—that is, a (possibly extensive) propositional logic formula—
a formula Q1 follows. Thus, we ﬁrst deﬁne the term “entailment”.
A
B
¬A
¬A _ B
A ) B
(¬A _ B) , (A ) B)
t
t
f
t
t
t
t
f
f
f
f
t
f
t
t
t
t
t
f
f
t
t
t
t
1Here Q stands for query.
26
2
Propositional Logic

Deﬁnition 2.6 A formula KB entails a formula Q (or Q follows from KB) if
every model of KB is also a model of Q. We write KB  Q.
In other words, in every interpretation in which KB is true, Q is also true. More
succinctly, whenever KB is true, Q is also true. Because, for the concept of
entailment, interpretations of variables are brought in, we are dealing with a
semantic concept.
Every formula that is not valid chooses so to speak a subset of the set of all
interpretations as its model. Tautologies such as A _ ¬A, for example, do not restrict
the number of satisfying interpretations because their proposition is empty. The
empty formula is therefore true in all interpretations. For every tautology T then
;  T. Intuitively this means that tautologies are always true, without restriction of
the interpretations by a formula. For short we write  T. Now we show an important
connection between the semantic concept of entailment and syntactic implication.
Theorem 2.2
(Deduktionstheorem)
A  B if and only if  A ) B:
Proof
Observe the truth table for implication:
An arbitrary implication A ) B is clearly always true except with the interpretation
A ↦t, B ↦f. Assume that A  B holds. This means that for every interpretation
that makes A true, B is also true. The critical second row of the truth table does not
even apply in that case. Therefore A ) B is true, which means that A ) B is a
tautology. Thus one direction of the statement has been shown.
Now assume that A ) B holds. Thus the critical second row of the truth table is
also locked out. Every model of A is then also a model of B. Then A  B holds.
□
If we wish to show that KB entails Q, we can also demonstrate by means of the
truth table method that KB ) Q is a tautology. Thus we have our ﬁrst proof system
for propositional logic, which is easily automated. The disadvantage of this method
is the very long computation time in the worst case. Speciﬁcally, in the worst case
A
B
A ) B
t
t
t
t
f
f
f
t
t
f
f
t
2.3
Proof Systems
27

with n proposition variables, for all 2n interpretations of the variables the formula
KB ) Q must be evaluated. The computation time grows therefore exponentially
with the number of variables. Therefore this process is unusable for large variable
counts, at least in the worst case.
If a formula KB entails a formula Q, then by the deduction theorem KB ) Q is a
tautology. Therefore the negation ¬(KB ) Q) is unsatisﬁable. We have
:ðKB ) QÞ  :ð:KB _ QÞ  KB ^ :Q:
Therefore, KB ^ ¬Q is also unsatisﬁable. We formulate this simple, but important
consequence of the deduction theorem as a theorem.
Theorem 2.3
(Proof by contradiction) KB  Q if and only if KB ^ ¬Q is
unsatisﬁable.
To show that the query Q follows from the knowledge base KB, we can also add
the negated query ¬Q to the knowledge base and derive a contradiction. Because of
the equivalence A ^ ¬A , f from Theorem 2.1 on page 26 we know that a
contradiction is unsatisﬁable. Therefore, Q has been proved. This procedure, which
is frequently used in mathematics, is also used in various automatic proof calculi
such as the resolution calculus and in the processing of PROLOG programs.
One way of avoiding having to test all interpretations with the truth table method
is the syntactic manipulation of the formulas KB and Q by application of inference
rules with the goal of greatly simplifying them, such that in the end we can instantly
see that KB  Q. We call this syntactic process derivation and write KB ⊢Q. Such
syntactic proof systems are called calculi. To ensure that a calculus does not
generate errors, we deﬁne two fundamental properties of calculi.
Deﬁnition 2.7
A calculus is called sound if every derived proposition fol-
lows semantically. That is, if it holds for formulas KB and Q that
if
KB ‘ Q
then
KB  Q:
A calculus is called complete if all semantic consequences can be derived.
That is, for formulas KB and Q the following holds:
if
KB  Q
then
KB ‘ Q:
The soundness of a calculus ensures that all derived formulas are in fact semantic
consequences of the knowledge base. The calculus does not produce any “false
consequences”. The completeness of a calculus, on the other hand, ensures that the
calculus does not overlook anything. A complete calculus always ﬁnds a proof if
28
2
Propositional Logic

the formula to be proved follows from the knowledge base. If a calculus is sound
and complete, then syntactic derivation and semantic entailment are two equivalent
relations (see Fig. 2.1).
To keep automatic proof systems as simple as possible, these are usually made to
operate on formulas in conjunctive normal form.
Deﬁnition 2.8 A formula is in conjunctive normal form (CNF) if and only if
it consists of a conjunction
K1 ^ K2 ^    ^ Km
of clauses. A clause Ki consists of a disjunction
ðLi1 _ Li2 _    _ LiniÞ
of literals. Finally, a literal is a variable (positive literal) or a negated variable
(negative literal).
The formula (A _ B _ ¬C) ^ (A _ B) ^ (¬B _ ¬C) is in conjunctive normal
form. The conjunctive normal form does not place a restriction on the set of
formulas because:
Theorem 2.4 Every propositional logic formula can be transformed into an
equivalent conjunctive normal form.
KB
interpretation
derivation
Q
interpretation
syntactic level
(formula)
Mod(KB)
entailment
Mod(Q)
semantic level
(interpretation)
Fig. 2.1 Syntactic derivation and semantic entailment. Mod(X) represents the set of models of a
formula X
2.3
Proof Systems
29

Example 2.1 We put A _ B ) C ^ D into conjunctive normal form by using the
equivalences from Theorem 2.1 on page 26:
A _ B ) C ^ D
 :ðA _ BÞ _ ðC ^ DÞ
ðimplicationÞ
 ð:A ^ :BÞ _ ðC ^ DÞ
ðde MorganÞ
 ð:A _ ðC ^ DÞÞ ^ ð:B _ ðC ^ DÞÞ
ðdistributive lawÞ
 ðð:A _ CÞ ^ ð:A _ DÞÞ ^ ðð:B _ CÞ ^ ð:B _ DÞÞ ðdistributive lawÞ
 ð:A _ CÞ ^ ð:A _ DÞ ^ ð:B _ CÞ ^ ð:B _ DÞ
ðassociative lawÞ
We are now only missing a calculus for syntactic proof of propositional logic
formulas. We start with the modus ponens, a simple, intuitive rule of inference, which,
from the validity of A and A ) B, allows the derivation of B. We write this formally as
A;
A ) B
B
:
This notation means that we can derive the formula(s) below the line from the
comma-separated formulas above the line. Modus ponens as a rule by itself, while
sound, is not complete. If we add additional rules we can create a complete
calculus, which, however, we do not wish to consider here. Instead we will
investigate the resolution rule
A _ B;
:B _ C
A _ C
ð2:1Þ
as an alternative. The derived clause is called resolvent. Through a simple trans-
formation we obtain the equivalent form
A _ B;
B ) C
A _ C
:
If we set A to f, we see that the resolution rule is a generalization of the modus
ponens. The resolution rule is equally usable if C is missing or if A and C are
missing. In the latter case the empty clause can be derived from the contradiction
B ^ ¬B (Exercise 2.7 on page 38).
2.4
Resolution
We now generalize the resolution rule again by allowing clauses with an arbitrary
number of literals. With the literals A1, …, Am, B, C1, …, Cn the general resolution
rule reads
30
2
Propositional Logic

ðA1 _    _ Am _ BÞ;
ð:B _ C1 _    _ CnÞ
ðA1 _    _ Am _ C1 _    _ CnÞ
:
ð2:2Þ
We call the literals B and ¬B complementary. The resolution rule deletes a pair of
complementary literals from the two clauses and combines the rest of the literals
into a new clause.
To prove that from a knowledge base KB, a query Q follows, we carry out a
proof by contradiction. Following Theorem 2.3 on page 28 we must show that a
contradiction can be derived from KB ^ ¬Q. In formulas in conjunctive normal
form, a contradiction appears in the form of two clauses (A) and (¬A), which lead to
the empty clause as their resolvent. The following theorem ensures us that this
process really works as desired.
For the calculus to be complete, we need a small addition, as shown by the
following example. Let the formula (A _ A) be given as our knowledge base. To
show by the resolution rule that from there we can derive (A ^ A), we must
show that the empty clause can be derived from (A _ A) ^ (¬A _ ¬A). With the
resolution rule alone, this is impossible. With factorization, which allows deletion
of copies of literals from clauses, this problem is eliminated. In the example, a
double application of factorization leads to (A) ^ (¬A), and a resolution step to the
empty clause.
Theorem 2.5
The resolution calculus for the proof of unsatisﬁability of
formulas in conjunctive normal form is sound and complete.
Because it is the job of the resolution calculus to derive a contradiction from
KB ^ ¬Q, it is very important that the knowledge base KB is consistent:
Deﬁnition 2.9 A formula KB is called consistent if it is impossible to derive
from it a contradiction, that is, a formula of the form / ^ ¬/.
Otherwise anything can be derived from KB (see Exercise 2.8 on page 38). This
is true not only of resolution, but also for many other calculi.
Of the calculi for automated deduction, resolution plays an exceptional role.
Thus we wish to work a bit more closely with it. In contrast to other calculi,
resolution has only two inference rules, and it works with formulas in conjunctive
normal form. This makes its implementation simpler. A further advantage com-
pared to many calculi lies in its reduction in the number of possibilities for the
application of inference rules in every step of the proof, whereby the search space is
reduced and computation time decreased.
As an example, we start with a simple logic puzzle that allows the important
steps of a resolution proof to be shown.
2.4
Resolution
31

Example 2.2 Logic puzzle number 7, entitled A charming English family, from the
German book [Ber89] reads (translated to English):
Despite studying English for seven long years with brilliant success, I must admit that when
I hear English people speaking English I’m totally perplexed. Recently, moved by noble
feelings, I picked up three hitchhikers, a father, mother, and daughter, who I quickly
realized were English and only spoke English. At each of the sentences that follow I
wavered between two possible interpretations. They told me the following (the second
possible meaning is in parentheses): The father: “We are going to Spain (we are from
Newcastle).” The mother: “We are not going to Spain and are from Newcastle (we stopped
in Paris and are not going to Spain).” The daughter: “We are not from Newcastle (we
stopped in Paris).” What about this charming English family?
To solve this kind of problem we proceed in three steps: formalization, trans-
formation into normal form, and proof. In many cases formalization is by far the
most difﬁcult step because it is easy to make mistakes or forget small details. (Thus
practical exercise is very important. See Exercises 2.9–2.11 on page 38.)
Here we use the variables S for “We are going to Spain”, N for “We are from
Newcastle”, and P for “We stopped in Paris” and obtain as a formalization of the
three propositions of father, mother, and daughter
ðS _ NÞ ^ ½ð:S ^ NÞ _ ðP ^ :SÞ ^ ð:N _ PÞ:
Factoring out ¬S in the middle sub-formula brings the formula into CNF in one
step. Numbering the clauses with subscripted indices yields
KB  ðS _ NÞ1 ^ ð:SÞ2 ^ ðP _ NÞ3 ^ ð:N _ PÞ4:
Now we begin the resolution proof, at ﬁrst still without a query Q. An expression of
the form “Res(m, n): 〈clause〉k” means that 〈clause〉is obtained by resolution of
clause m with clause n and is numbered k.
Resð1; 2Þ:
(N)5
Resð3; 4Þ:
(P)6
Resð1; 4Þ:
(S _ P)7
We could have derived clause P also from Res(4, 5) or Res(2, 7). Every further
resolution step would lead to the derivation of clauses that are already available.
Because it does not allow the derivation of the empty clause, it has therefore been
shown that the knowledge base is non-contradictory. So far we have derived
N and P. To show that ¬S holds, we add the clause (S)8 to the set of clauses as a
negated query. With the resolution step
Resð2; 8Þ :
ðÞ9
the proof is complete. Thus ¬S ^ N ^ P holds. The “charming English family”
evidently comes from Newcastle, stopped in Paris, but is not going to Spain.
32
2
Propositional Logic

Example 2.3 Logic puzzle number 28 from [Ber89], entitled The High Jump, reads
Three girls practice high jump for their physical education ﬁnal exam. The bar is set to 1.20
meters. “I bet”, says the ﬁrst girl to the second, “that I will make it over if, and only if, you
don’t”. If the second girl said the same to the third, who in turn said the same to the ﬁrst,
would it be possible for all three to win their bets?
We show through proof by resolution that not all three can win their bets.
Formalization:
The first girl’s jump succeeds: A;
First girl’s bet: A , :B
ð
Þ;
the second girl’s jump succeeds: B;
second girl’s bet: B , :C
ð
Þ;
the third girl’s jump succeeds: C:
third girl’s bet: C , :A
ð
Þ:
Claim: the three cannot all win their bets:
Q  :ððA , :BÞ ^ ðB , :CÞ ^ ðC , :AÞÞ
It must now be shown by resolution that ¬Q is unsatisﬁable.
Transformation into CNF: First girl’s bet:
ðA , :BÞ  ðA ) :BÞ ^ ð:B ) AÞ  ð:A _ :BÞ ^ ðA _ BÞ
The bets of the other two girls undergo analogous transformations, and we obtain
the negated claim
:Q  :A _ :B
ð
Þ1 ^ A _ B
ð
Þ2 ^ :B _ :C
ð
Þ3 ^ B _ C
ð
Þ4 ^ :C _ :A
ð
Þ5
^ C _ A
ð
Þ6:
From there we derive the empty clause using resolution:
Resð1; 6Þ :
ðC _ :BÞ7
Resð4; 7Þ :
ðCÞ8
Resð2; 5Þ :
ðB _ :CÞ9
Resð3; 9Þ :
ð:CÞ10
Resð8; 10Þ :
ðÞ
Thus the claim has been proved.
2.5
Horn Clauses
A clause in conjunctive normal form contains positive and negative literals and can
be represented in the form
2.4
Resolution
33

ð:A1 _    _ :Am _ B1 _    _ BnÞ
with the variables A1, …, Am and B1, …, Bn. This clause can be transformed in two
simple steps into the equivalent form
A1 ^    ^ Am ) B1 _    _ Bn:
This implication contains the premise, a conjunction of variables and the conclu-
sion, a disjunction of variables. For example, “If the weather is nice and there is
snow on the ground, I will go skiing or I will work.” is a proposition of this form.
The receiver of this message knows for certain that the sender is not going
swimming. A signiﬁcantly clearer statement would be “If the weather is nice and
there is snow on the ground, I will go skiing.”. The receiver now has deﬁnite
information. Thus we call clauses with at most one positive literal deﬁnite clauses.
These clauses have the advantage that they only allow one conclusion and are thus
distinctly simpler to interpret. Many relations can be described by clauses of this
type. We therefore deﬁne
Deﬁnition 2.10
Clauses with at most one positive literal of the form
ð:A1 _    _ :Am _ BÞ
or
ð:A1 _    _ :AmÞ
or
B
or (equivalently)
A1 ^    ^ Am ) B
or
A1 ^    ^ Am ) f
or
B:
are named Horn clauses (after their inventor). A clause with a single positive
literal is a fact. In clauses with negative and one positive literal, the positive
literal is called the head.
To better understand the representation of Horn clauses, the reader may derive
them from the deﬁnitions of the equivalences we have currently been using
(Exercise 2.12 on page 38).
Horn clauses are easier to handle not only in daily life, but also in formal
reasoning, as we can see in the following example. Let the knowledge base consist
of the following clauses (the “^” binding the clauses is left out here and in the text
that follows):
nice weather
ð
Þ1
snowfall
ð
Þ2
snowfall ) snow
ð
Þ3
nice weather ^ snow ) skiing
ð
Þ4
34
2
Propositional Logic

If we now want to know whether skiing holds, this can easily be derived. A slightly
generalized modus ponens sufﬁces here as an inference rule:
A1 ^    ^ Am;
A1 ^    ^ Am ) B
B
:
The proof of “skiing” has the following form (MP(i1, …, ik) represents application
of the modus ponens on clauses i1 to ik:
MPð2; 3Þ :
ðsnowÞ5
MPð1; 5; 4Þ :
ðskiingÞ6:
With modus ponens we obtain a complete calculus for formulas that consist of
propositional logic Horn clauses. In the case of large knowledge bases, however,
modus ponens can derive many unnecessary formulas if one begins with the
wrong clauses. Therefore, in many cases it is better to use a calculus that starts
with the query and works backward until the facts are reached. Such systems are
designated backward chaining, in contrast to forward chaining systems, which
start with facts and ﬁnally derive the query, as in the above example with the
modus ponens.
For backward chaining of Horn clauses, SLD resolution is used. SLD stands for
“Selection rule driven linear resolution for deﬁnite clauses”. In the above example,
augmented by the negated query (skiing ) f)
nice weather
ð
Þ1
snowfall
ð
Þ2
snowfall ) snow
ð
Þ3
nice weather ^ snow ) skiing
ð
Þ4
skiing ) f
ð
Þ5
we carry out SLD resolution beginning with the resolution steps that follow from
this clause
Resð5; 4Þ :
nice weather ^ snow ) f
ð
Þ6
Resð6; 1Þ :
snow ) f
ð
Þ7
Resð7; 3Þ :
snowfall ) f
ð
Þ8
Resð8; 2Þ :
ðÞ
and derive a contradiction with the empty clause. Here we can easily see “linear
resolution”, which means that further processing is always done on the currently
derived clause. This leads to a great reduction of the search space. Furthermore, the
2.5
Horn Clauses
35

literals of the current clause are always processed in a ﬁxed order (for example,
from right to left) (“Selection rule driven”). The literals of the current clause are
called subgoal. The literals of the negated query are the goals. The inference rule
for one step reads
A1 ^    ^ Am ) B1;
B1 ^ B2 ^    ^ Bn ) f
A1 ^    ^ Am ^ B2 ^    ^ Bn ) f
:
Before application of the inference rule, B1, B2, …, Bn—the current subgoals—must
be proved. After the application, B1 is replaced by the new subgoal A1 ^  ^ Am.
To show that B1 is true, we must now show that A1 ^  ^ Am are true. This process
continues until the list of subgoals of the current clauses (the so-called goal stack) is
empty. With that, a contradiction has been found. If, for a subgoal ¬Bi, there is no
clause with the complementary literal Bi as its clause head, the proof terminates and
no contradiction can be found. The query is thus unprovable.
SLD resolution plays an important role in practice because programs in the logic
programming language PROLOG consist of predicate logic Horn clauses, and their
processing is achieved by means of SLD resolution (see Exercise 2.13 on page 38,
or Chap. 5).
2.6
Computability and Complexity
The truth table method, as the simplest semantic proof system for propositional
logic, represents an algorithm that can determine every model of any formula in
ﬁnite time. Thus the sets of unsatisﬁable, satisﬁable, and valid formulas are
decidable. The computation time of the truth table method for satisﬁability grows in
the worst case exponentially with the number n of variables because the truth table
has 2n rows. An optimization, the method of semantic trees, avoids looking at
variables that do not occur in clauses, and thus saves computation time in many
cases, but in the worst case it is likewise exponential.
In resolution, in the worst case the number of derived clauses grows exponen-
tially with the number of initial clauses. To decide between the two processes, we
can therefore use the rule of thumb that in the case of many clauses with few
variables, the truth table method is preferable, and in the case of few clauses with
many variables, resolution will probably ﬁnish faster.
The question remains: can proof in propositional logic go faster? Are there better
algorithms? The answer: probably not. After all, S. Cook, the founder of com-
plexity theory, has shown that the 3-SAT problem is NP-complete. 3-SAT is the set
of all CNF formulas whose clauses have exactly three literals. Thus it is clear that
there is probably (modulo the P/NP problem) no polynomial algorithm for 3-SAT,
and thus probably not a general one either. For Horn clauses, however, there is an
algorithm in which the computation time for testing satisﬁability grows only lin-
early as the number of literals in the formula increases.
36
2
Propositional Logic

2.7
Applications and Limitations
Theorem provers for propositional logic are part of the developer’s everyday
toolset in digital technology. For example, the veriﬁcation of digital circuits and
the generation of test patterns for testing of microprocessors in fabrication are
some of these tasks. Special proof systems that work with binary decision dia-
grams (BDD) are also employed as a data structure for processing propositional
logic formulas.
In AI, propositional logic is employed in simple applications. For example,
simple expert systems can certainly work with propositional logic. However, the
variables must all be discrete, with only a few values, and there may not be any
cross-relations between variables. Complex logical connections can be expressed
much more elegantly using predicate logic.
Probabilistic logic is a very interesting and current combination of propositional
logic and probabilistic computation that allows modeling of uncertain knowledge.
It is handled thoroughly in Chap. 7.
2.8
Exercises
➳Exercise 2.1 Give a Backus–Naur form grammar for the syntax of propositional
logic.
Exercise 2.2 Show that the following formulas are tautologies:
(a) ¬(A ^ B) , ¬A _ ¬B
(b) A ) B , ¬B ) ¬A
(c) ((A ) B) ^ (B ) A)) , (A , B)
(d) (A _ B) ^ (¬B _ C) ) (A _ C)
Exercise 2.3 Transform the following formulas into conjunctive normal form:
(a) A , B
(b) A ^ B , A _ B
(c) A ^ (A ) B) ) B
Exercise 2.4 Check the following statements for satisﬁability or validity.
(a) (play_lottery ^ six_right) ) winner
(b) (play_lottery ^ six_right ^ (six_right ) win)) ) win
(c) ¬(¬gas_in_tank ^ (gas_in_tank _ ¬car_starts) ) ¬car_starts)
❄❄Exercise 2.5 Using the programming language of your choice, program a theorem
prover for propositional logic using the truth table method for formulas in
conjunctive normal form. To avoid a costly syntax check of the formulas, you may
represent clauses as lists or sets of literals, and the formulas as lists or sets of
clauses. The program should indicate whether the formula is unsatisﬁable, satisﬁ-
able, or true, and output the number of different interpretations and models.
2.7
Applications and Limitations
37

Exercise 2.6
(a) Show that modus ponens is a valid inference rule by showing that
A ^ ðA ) BÞ  B.
(b) Show that the resolution rule (2.1) is a valid inference rule.
❄Exercise 2.7 Show by application of the resolution rule that, in conjunctive normal
form, the empty clause is equivalent to the false statement.
❄Exercise 2.8 Show that, with resolution, one can “derive” any arbitrary clause from
a knowledge base that contains a contradiction.
Exercise 2.9 Formalize the following logical functions with the logical operators
and show that your formula is valid. Present the result in CNF.
(a) The XOR operation (exclusive or) between two variables.
(b) The statement at least two of the three variables A, B, C are true.
❄Exercise 2.10 Solve the following case with the help of a resolution proof: “If the
criminal had an accomplice, then he came in a car. The criminal had no accomplice
and did not have the key, or he had the key and an accomplice. The criminal had the
key. Did the criminal come in a car or not?”
Exercise 2.11 Show by resolution that the formula from
(a) Exercise 2.2(d) is a tautology.
(b) Exercise 2.4(c) is unsatisﬁable.
Exercise 2.12 Prove the following equivalences, which are important for working
with Horn clauses:
(a) (¬A1_  _ ¬Am _ B)  A1 ^  ^ Am ) B
(b) (¬A1 _  _ ¬Am)  A1 ^  ^ Am ) f
(c) A  w ) A
Exercise 2.13 Show by SLD resolution that the following Horn clause set is
unsatisﬁable.
ðAÞ1
ðDÞ4
ðA ^ D ) GÞ7
ðBÞ2
ðEÞ5
ðC ^ F ^ E ) HÞ8
ðCÞ3
ðA ^ B ^ C ) FÞ6
ðH ) fÞ9
➳Exercise 2.14 In Sect. 2.6 it says: “Thus it is clear that there is probably (modulo
the P/NP problem) no polynomial algorithm for 3-SAT, and thus probably not a
general one either.” Justify the “probably” in this sentence.
38
2
Propositional Logic

3
First-order Predicate Logic
Many practical, relevant problems cannot be or can only very inconveniently be
formulated in the language of propositional logic, as we can easily recognize in the
following example. The statement
“Robot 7 is situated at the xy position (35, 79)”
can in fact be directly used as the propositional logic variable
“Robot_7_is_situated_at_xy_position_(35, 79)”
for reasoning with propositional logic, but reasoning with this kind of proposition
is very inconvenient. Assume 100 of these robots can stop anywhere on a grid of
100  100 points. To describe every position of every robot, we would need
100 ⋅100 ⋅100 = 1000000 = 106 different variables. The deﬁnition of relationships
between objects (here robots) becomes truly difﬁcult. The relation
“Robot A is to the right of robot B.”
is semantically nothing more than a set of pairs. Of the 10000 possible pairs of
x-coordinates there are (99 ⋅98)/2 = 4851 ordered pairs. Together with all 10 000
combinations of possible y-values for both robots, there are (100 ⋅99) = 9900
formulas of the type
Robot 7 is to the right of robot 12 ,
Robot 7 is situated at xy position ð35; 79Þ
^ Robot 12 is situated at xy position ð10; 93Þ _ . . .
deﬁning these relations, each of them with (104)2 ⋅0.485 = 0.485 ⋅108 alternatives
on the right side. In ﬁrst-order predicate logic, we can deﬁne a predicate
© Springer International Publishing AG 2017
W. Ertel, Introduction to Artificial Intelligence, Undergraduate Topics
in Computer Science, DOI 10.1007/978-3-319-58487-4_3
39

Position(number, xPosition, yPosition). The above relation must no longer be
enumerated as a huge number of pairs, rather it is described abstractly with a rule of
the form
8u 8v is further rightðu; vÞ,
9xu 9yu 9xv 9yv positionðu; xu; yuÞ ^ positionðv; xv; yvÞ ^ xu [ xv;
Where 8u is read as “for every u” and 9v as “there exists v”.
In this chapter we will deﬁne the syntax and semantics of ﬁrst-order predicate
logic (PL1), show that many applications can be modeled with this language and
that there is a complete and sound calculus for this language.
3.1
Syntax
First we solidify the syntactic structure of terms.
Deﬁnition 3.1 Let V be a set of variables, K a set of constants, and F a set of
function symbols. The sets V, K and F are pairwise disjoint. We deﬁne the set
of terms recursively:
• All variables and constants are (atomic) terms.
• If t1, … , tn are terms and f an n-place function symbol, then f (t1, … , tn) is
also a term.
Some examples of terms are f (sin(ln(3)), exp(x)) and g(g(g(x))). To be able to
establish logical relationships between terms, we build formulas from terms.
Deﬁnition 3.2 Let P be a set of predicate symbols. Predicate logic formulas
are built as follows:
• If t1, … , tn are terms and p an n-place predicate symbol, then p(t1, …, tn)
is an (atomic) formula.
• If A and B are formulas, then ¬A, (A), A ^ B, A _ B, A ) B, A , B are
also formulas.
• If x is a variable and A a formula, then 8x A and 9x A are also formulas.
8 is the universal quantiﬁer and 9 the existential quantiﬁer.
• p(t1, …, tn) and ¬p(t1, …, tn) are called literals.
40
3
First-order Predicate Logic

• Formulas in which every variable is in the scope of a quantiﬁer are called
ﬁrst-order sentences or closed formulas. Variables which are not in the
scope of a quantiﬁer are called free variables.
• Deﬁnitions 2.8 (CNF) and 2.10 (Horn clauses) hold for formulas of
predicate logic literals analogously.
In Table 3.1 several examples of PL1 formulas are given along with their
intuitive interpretations.
3.2
Semantics
In propositional logic, every variable is directly assigned a truth value by an
interpretation. In predicate logic, the meaning of formulas is recursively deﬁned
over the construction of the formula, in that we ﬁrst assign constants, variables, and
function symbols to objects in the real world.
Table 3.1 Examples of formulas in ﬁrst-order predicate logic. Please note that mother here is a
function symbol
Formula
Description
8x frog(x) ) green(x)
All frogs are green
8x frog(x) ^ brown(x) ) big(x)
All brown frogs are big
8x likes(x, cake)
Everyone likes cake
¬8x likes(x, cake)
Not everyone likes cake
¬9x likes(x, cake)
No one likes cake
9x 8y likes(y, x)
There is something that everyone likes
9x 8y likes(x, y)
There is someone who likes everything
8x 9y likes(y, x)
Everything is loved by someone
8x 9y likes(x, y)
Everyone likes something
8x customer(x) ) likes(bob, x)
Bob likes every customer
9x customer(x) ^ likes(x, bob)
There is a customer whom bob likes
9x baker(x) ^ 8y customer(y) ) likes(x, y) There is a baker who likes all of his
customers
8x older(mother(x), x)
Every mother is older than her child
8x older(mother(mother(x)), x)
Every grandmother is older than her
daughter’s child
8x 8y 8z rel(x, y) ^ rel(y, z) ) rel(x, z)
rel is a transitive relation
3.1
Syntax
41

Deﬁnition 3.3 An interpretation I is deﬁned as
• A mapping from the set of constants and variables K [ V to a set W of
names of objects in the world.
• A mapping from the set of function symbols to the set of functions in the
world. Every n-place function symbol is assigned an n-place function.
• A mapping from the set of predicate symbols to the set of relations in the
world. Every n-place predicate symbol is assigned an n-place relation.
Example 3.1 Let c1, c2, c3 be constants, “plus” a two-place function symbol, and
“gr” a two-place predicate symbol. The truth of the formula
F  grðplusðc1; c3Þ; c2Þ
depends on the interpretation I. We ﬁrst choose the following obvious interpretation
of constants, the function, and of the predicates in the natural numbers:
I1: c1 7! 1; c2 7! 2; c3 7! 3;
plus 7! þ ;
gr 7![ :
Thus the formula is mapped to
1 þ 3 [ 2;
or after evaluation
4 [ 2:
The greater-than relation on the set {1, 2, 3, 4} is the set of all pairs (x, y) of
numbers with x > y, meaning the set G = {(4, 3), (4, 2), (4, 1), (3, 2), (3, 1), (2, 1)}.
Because (4, 2) 2 G, the formula F is true under the interpretation I1. However, if we
choose the interpretation
I2: c1 7! 2; c2 7! 3; c3 7! 1;
plus 7! ;
gr 7![ ;
we obtain
2  1 [ 3;
or
1 [ 3:
The pair (1, 3) is not a member of G. The formula F is false under the interpretation
I2. Obviously, the truth of a formula in PL1 depends on the interpretation. Now,
after this preview, we deﬁne truth.
42
3
First-order Predicate Logic

Deﬁnition 3.4
• An atomic formula p(t1,…, tn ) is true (or valid) under the interpretation I
if, after interpretation and evaluation of all terms t1, … , tn and interpre-
tation of the predicate p through the n-place relation r, it holds that
ðIðt1Þ; . . . ; IðtnÞÞ 2 r:
• The truth of quantiﬁerless formulas follows from the truth of atomic
formulas—as in propositional calculus—through the semantics of the
logical operators deﬁned in Table 2.1 on page 25.
• A formula 8x F is true under the interpretation I exactly when it is true
given an arbitrary change of the interpretation for the variable x (and only
for x)
• A formula 9x F is true under the interpretation I exactly when there is an
interpretation for x which makes the formula true.
The deﬁnitions of semantic equivalence of formulas, for the concepts satis-
ﬁable, true, unsatisﬁable, and model, along with semantic entailment (Deﬁ-
nitions 2.4, 2.5, 2.6) carry over unchanged from propositional calculus to
predicate logic.
Theorem 3.1 Theorems 2.2 (deduction theorem) and 2.3 (proof by contra-
diction) hold analogously for PL1.
Example 3.2 The family tree given in Fig. 3.1 graphically represents (in the
semantic level) the relation
Fig. 3.1 A family tree. The edges going from Clyde B. upward to Mary B. and Oscar B.
represent the element (Clyde B., Mary B., Oscar B.) as a child relationship
3.2
Semantics
43

Child ¼ fðOscar A., Karen A., Frank A.Þ;
ðMary B., Karen A., Frank A.Þ;
(Henry A., Anne A., Oscar A.),
(Eve A., Anne A., Oscar A.),
(Isabelle A., Anne A., Oscar A.),
(Clyde B., Mary B., Oscar B.)g
For example, the triple (Oscar A., Karen A., Frank A.) stands for the proposition
“Oscar A. is a child of Karen A. and Frank A.”. From the names we read off the
one-place relation
Female ¼ fKaren A., Anne A., Mary B., Eve A., Isabelle A.g
of the women. We now want to establish formulas for family relationships. First we
deﬁne a three-place predicate child(x, y, z) with the semantic
Iðchildðx; y; zÞÞ ¼ w  ðIðxÞ; IðyÞ; IðzÞÞ 2 Kind:
Under the interpretation IðoscarÞ ¼ Oscar A., IðeveÞ ¼ Eve A., IðanneÞ ¼ Anne A.,
it is also true that child(eve, anne, oscar). For child(eve, oscar, anne) to be true,
we require, with
8x 8y 8z childðx; y; zÞ , childðx; z; yÞ;
symmetry of the predicate child in the last two arguments. For further deﬁnitions we
refer to Exercise 3.1 on page 63 and deﬁne the predicate descendant recursively as
8x 8y descendantðx; yÞ , 9z childðx; y; zÞ _
ð9u 9v childðx; u; vÞ ^ descendantðu; yÞÞ:
Now we build a small knowledge base with rules and facts. Let
KB  femaleðkarenÞ ^ femaleðanneÞ ^ femaleðmaryÞ
^ femaleðeveÞ ^ femaleðisabelleÞ
^ childðoscar; karen; franzÞ ^ childðmary; karen; franzÞ
^ childðeve; anne; oscarÞ ^ childðhenry; anne; oscarÞ
^ childðisabelle; anne; oscarÞ ^ childðclyde; mary; oscarbÞ
^ ð8x 8y 8z childðx; y; zÞ ) childðx; z; yÞÞ
^ ð8x 8y descendantðx; yÞ , 9z childðx; y; zÞ
_ ð9u 9v childðx; u; vÞ ^ descendantðu; yÞÞÞ:
We can now ask, for example, whether the propositions child(eve, oscar, anne) or
descendant(eve, franz) are derivable. To that end we require a calculus.
44
3
First-order Predicate Logic

3.2.1
Equality
To be able to compare terms, equality is a very important relation in predicate logic.
The equality of terms in mathematics is an equivalence relation, meaning it is
reﬂexive, symmetric and transitive. If we want to use equality in formulas, we must
either incorporate these three attributes as axioms in our knowledge base, or we
must integrate equality into the calculus. We take the easy way and deﬁne a
predicate “=” which, deviating from Deﬁnition 3.2 on page 40, is written using
inﬁx notation as is customary in mathematics. (An equation x = y could of course
also be written in the form eq(x, y).) Thus, the equality axioms have the form
8x
x ¼ x
ðreflexivityÞ
8x 8y
x ¼ y ) y ¼ x
ðsymmetryÞ
8x 8y 8z
x ¼ y ^ y ¼ z ) x ¼ z
ðtransitivityÞ:
ð3:1Þ
To guarantee the uniqueness of functions, we additionally require
8x 8y x ¼ y ) fðxÞ ¼ fðyÞ
ðsubstitution axiomÞ
ð3:2Þ
for every function symbol. Analogously we require for all predicate symbols
8x 8y x ¼ y ) pðxÞ , pðyÞ
ðsubstitution axiomÞ:
ð3:3Þ
We formulate other mathematical relations, such as the “<” relation, by similar
means (Exercise 3.4 on page 64).
Often a variable must be replaced by a term. To carry this out correctly and
describe it simply, we give the following deﬁnition.
Deﬁnition 3.5 We write u[x/t] for the formula that results when we replace
every free occurrence of the variable x in u with the term t. Thereby we do
not allow any variables in the term t that are quantiﬁed in u. In those cases
variables must be renamed to ensure this.
Example 3.3 If, in the formula 8x x ¼ y, the free variable y is replaced by the term
x + 1, the result is 8x x ¼ x þ 1. With correct substitution we obtain the formula
8x x ¼ y þ 1, which has a very different semantic.
3.3
Quantifiers and Normal Forms
By Deﬁnition 3.4 on page 43, the formula 8x p(x) is true if and only if it is true
for all interpretations of the variable x. Instead of the quantiﬁer, one could write
p(a1) ^ ⋅⋅⋅^ p(an) for all constants a1⋅⋅⋅an in K. For 9x p(x) one could write
p(a1) _ ⋅⋅⋅_ p(an). From this it follows with de Morgan’s law that
3.2
Semantics
45

8x u  :9x:u:
Through this equivalence, universal, and existential quantiﬁers are mutually
replaceable.
Example 3.4 The proposition “Everyone wants to be loved” is equivalent to the
proposition “Nobody does not want to be loved”.
Quantiﬁers are an important component of predicate logic’s expressive power.
However, they are disruptive for automatic inference in AI because they make the
structure of formulas more complex and increase the number of applicable inference
rules in every step of a proof. Therefore our next goal is to ﬁnd, for every predicate
logic formula, an equivalent formula in a standardized normal form with as few
quantiﬁers as possible. As a ﬁrst step we bring universal quantiﬁers to the beginning
of the formula and thus deﬁne
Deﬁnition 3.6 A predicate logic formula u is in prenex normal form if it
holds that
• u = Q1x1 ⋅⋅⋅Qnxn w.
• w is a quantiﬁerless formula.
• Qi 2{8, 9} for i = 1, … , n.
Caution is advised if a quantiﬁed variable appears outside the scope of its
quantiﬁer, as for example x in
8x pðxÞ ) 9x qðxÞ:
Here one of the two variables must be renamed, and in
8x pðxÞ ) 9y qðyÞ
the quantiﬁer can easily be brought to the front, and we obtain as output the
equivalent formula
8x 9y pðxÞ ) qðyÞ:
If, however, we wish to correctly bring the quantiﬁer to the front of
ð8x pðxÞÞ ) 9y qðyÞ
ð3:4Þ
46
3
First-order Predicate Logic

we ﬁrst write the formula in the equivalent form
:ð8x pðxÞÞ _ 9y qðyÞ:
The ﬁrst universal quantiﬁer now turns into
ð9x:pðxÞÞ _ 9y qðyÞ
and now the two quantiﬁers can ﬁnally be pulled forward to
9x 9y:pðxÞ _ qðyÞ;
which is equivalent to
9x 9ypðxÞ ) qðyÞ:
We see then that in (3.4) on page 46 we cannot simply pull both quantiﬁers to the
front. Rather, we must ﬁrst eliminate the implications so that there are no negations
on the quantiﬁers. It holds in general that we may only pull quantiﬁers out if
negations only exist directly on atomic sub-formulas.
Example 3.5 As is well known in analysis, convergence of a series (an)n2ℕto a
limit a is deﬁned by
8e [ 0 9n0 2 N 8n [ n0jan  aj \ e:
With the function abs(x) for |x|, a(n) for an, minus(x, y) for x–y and the predicates
el(x, y) for x 2 y, gr(x, y) for x > y, the formula reads
8e ðgrðe; 0Þ)9n0ðelðn0; NÞ)8n ðgrðn; n0Þ)grðe; absðminusðaðnÞ; aÞÞÞÞÞÞ:
ð3:5Þ
This is clearly not in prenex normal form. Because the variables of the inner
quantiﬁers 9n0 and 8n do not occur to the left of their respective quantiﬁers, no
variables must be renamed. Next we eliminate the implications and obtain
8e ð:grðe; 0Þ _ 9n0 ð:elðn0; NÞ _ 8n ð:grðn; n0Þ _ grðe; absðminusðaðnÞ; aÞÞÞÞÞÞ:
Because every negation is in front of an atomic formula, we bring the quantiﬁers
forward, eliminate the redundant parentheses, and with
8e 9n0 8n ð:grðe; 0Þ _ :elðn0; NÞ _ :grðn; n0Þ _ grðe; absðminusðaðnÞ; aÞÞÞÞ
it becomes a quantiﬁed clause in conjunctive normal form.
3.3
Quantifiers and Normal Forms
47

The transformed formula is equivalent to the output formula. The fact that this
transformation is always possible is guaranteed by
Theorem 3.2 Every predicate logic formula can be transformed into an
equivalent formula in prenex normal form.
In addition, we can eliminate all existential quantiﬁers. However, the formula
resulting from the so-called Skolemization is no longer equivalent to the output
formula. Its satisﬁability, however, remains unchanged. In many cases, especially
when one wants to show the unsatisﬁability of KB ^ ¬Q, this is sufﬁcient. The
following formula in prenex normal form will now be skolemized:
8x1 8x2 9y1 8x3 9y2 pðfðx1Þ; x2; y1Þ _ qðy1; x3; y2Þ:
Because the variable y1 apparently depends on x1 and x2, every occurrence of y1 is
replaced by a Skolem function g(x1, x2). It is important that g is a new function
symbol that has not yet appeared in the formula. We obtain
8x1 8x2 8x3 9y2 pðfðx1Þ; x2; gðx1; x2ÞÞ _ qðgðx1; x2Þ; x3; y2Þ
and replace y2 analogously by h(x1, x2, x3), which leads to
8x1 8x2 8x3 pðfðx1Þ; x2; gðx1; x2ÞÞ _ qðgðx1; x2Þ; x3; hðx1; x2; x3ÞÞ:
Because now all the variables are universally quantiﬁed, the universal quantiﬁers
can be left out, resulting in
pðfðx1Þ; x2; gðx1; x2ÞÞ _ qðgðx1; x2Þ; x3; hðx1; x2; x3ÞÞ:
Now we can eliminate the existential quantiﬁer (and thereby also the universal
quantiﬁer) in (3.5) on page 47 by introducing the Skolem function n0(e). The
skolemized prenex and conjunctive normal form of (3.5) on page 47 thus reads
:grðe; 0Þ _ :elðn0ðeÞ; NÞ _ :grðn; n0ðeÞÞ _ grðe; absðminusðaðnÞ; aÞÞÞ:
By dropping the variable n0, the Skolem function can receive the name n0.
When skolemizing a formula in prenex normal form, all existential quanti-
ﬁers are eliminated from the outside inward, where a formula of the form
8x1 … 8xn 9y u is replaced by 8x1 … 8xn u[y/f (x1, … , xn)], during which f may
not appear in u. If an existential quantiﬁer is on the far outside, such as in 9y p(y),
then y must be replaced by a constant (that is, by a zero-place function symbol).
48
3
First-order Predicate Logic

The procedure for transforming a formula in conjunctive normal form is sum-
marized in the pseudocode represented in Fig. 3.2. Skolemization has polynomial
runtime in the number of literals. When transforming into normal form, the number
of literals in the normal form can grow exponentially, which can lead to exponential
computation time and exponential memory usage. The reason for this is the repe-
ated application of the distributive law. The actual problem, which results from a
large number of clauses, is the combinatorial explosion of the search space for a
subsequent resolution proof. However, there is an optimized transformation algo-
rithm which only spawns polynomially many literals [Ede91].
3.4
Proof Calculi
For reasoning in predicate logic, various calculi of natural reasoning such as
Gentzen calculus or sequent calculus, have been developed. As the name suggests,
these calculi are meant to be applied by humans, since the inference rules are more
or less intuitive and the calculi work on arbitrary PL1 formulas. In the next section
we will primarily concentrate on the resolution calculus, which is in practice the
most important efﬁcient, automatizable calculus for formulas in conjunctive normal
form. Here, using Example 3.2 on page 43 we will give a very small “natural”
proof. We use the inference rule
A;
A ) B
B
ðmodus ponens, MPÞ
and
8x A
A½x=t
ð8-elimination; 8EÞ:
The modus ponens is already familiar from propositional logic. When eliminating
universal quantiﬁers one must keep in mind that the quantiﬁed variable x must be
NORMALFORMTRANSFORMATION(Formula):
1. Transformation into prenex normal form:
Transformation into conjunctive normal form (Theorem 2.1):
Elimination of equivalences.
Elimination of implications.
Repeated application of de Morgan’s law and distributive law.
Renaming of variables if necessary.
Factoring out universal quantiﬁers.
2. Skolemization:
Replacement of existentially quantiﬁed variables by new Skolem
functions.
Deletion of resulting universal quantiﬁers.
Fig. 3.2 Transformation of predicate logic formulas into normal form
3.3
Quantifiers and Normal Forms
49

replaced by a ground term t, meaning a term that contains no variables. The proof of
child(eve, oscar, anne) from an appropriately reduced knowledge base is presented
in Table 3.2.
The two formulas of the reduced knowledge base are listed in rows 1 and 2. In
row 3 the universal quantiﬁers from row 2 are eliminated, and in row 4 the claim is
derived with modus ponens.
The calculus consisting of the two given inference rules is not complete.
However, it can be extended into a complete procedure by addition of further
inference rules. This nontrivial fact is of fundamental importance for mathematics
and AI. The Austrian logician Kurt Gödel proved in 1931 that [Göd31a].
Theorem 3.3 (Gödel’s completeness theorem)
First-order predicate logic
is complete. That is, there is a calculus with which every proposition that is a
consequence of a knowledge base KB can be proved. If KB  u, then it holds
that KB ⊢u.
Every true proposition in ﬁrst-order predicate logic is therefore provable. But is
the reverse also true? Is everything we can derive syntactically actually true? The
answer is “yes”:
Theorem 3.4 (Correctness)
There are calculi with which only true propo-
sitions can be proved. That is, if KB ⊢u holds, then KB  u.
In fact, nearly all known calculi are correct. After all, it makes little sense to
work with incorrect proof methods. Provability and semantic consequence are
therefore equivalent concepts, as long as correct and complete calculus is being
used. Thereby ﬁrst-order predicate logic becomes a powerful tool for mathematics
and AI. The aforementioned calculi of natural deduction are rather unsuited for
automatization. Only resolution calculus, which was introduced in 1965 and
essentially works with only one simple inference rule, enabled the construction of
powerful automated theorem provers, which later were employed as inference
machines for expert systems.
Table 3.2 Simple proof with modus ponens and quantiﬁer elimination
WB:
1
child(eve, anne, oscar)
WB:
2
8x 8y 8z child(x, y, z) ) child(x, z, y)
8E(2): x/eve, y/anne, z/oscar
3
child(eve, anne, oscar) ) child(eve, oscar, anne)
MP(1, 3)
4
child(eve, oscar, anne)
50
3
First-order Predicate Logic

3.5
Resolution
Indeed, the correct and complete resolution calculus triggered a logic euphoria
during the 1970s. Many scientists believed that one could formulate almost every
task of knowledge representation and reasoning in PL1 and then solve it with an
automated prover. Predicate logic, a powerful, expressive language, together with a
complete proof calculus seemed to be the universal intelligent machine for repre-
senting knowledge and solving many difﬁcult problems (Fig. 3.3).
If one feeds a set of axioms (that is, a knowledge base) and a query into such a
logic machine as input, the machine searches for a proof and returns it—for one
exists and will be found—as output. With Gödel’s completeness theorem and the
work of Herbrand as a foundation, much was invested into the mechanization of
logic. The vision of a machine that could, with an arbitrary non-contradictory PL1
knowledge base, prove any true query was very enticing. Accordingly, until now
many proof calculi for PL1 are being developed and realized in the form of theorem
provers. As an example, here we describe the historically important and widely
used resolution calculus and show its capabilities. The reason for selecting reso-
lution as an example of a proof calculus in this book is, as stated, its historical and
Fig. 3.3 The universal logic machine
3.5
Resolution
51

didactic importance. Today, resolution represents just one of many calculi used in
high-performance provers.
We begin by trying to compile the proof in Table 3.2 on page 50 with the
knowledge base of Example 3.2 on page 43 into a resolution proof. First the
formulas are transformed into conjunctive normal form and the negated query
:Q  :childðeve; oscar; anneÞ
is added to the knowledge base, which gives
KB ^ :Q  ðchildðeve; anne; oscarÞÞ1 ^
ð:childðx; y; zÞ _ childðx; z; yÞÞ2 ^
ð:childðeve; oscar; anneÞÞ3:
The proof could then look something like
ð2Þ x=eve; y=anne; z=oscar : ð:childðeve; anne; oscarÞ _
childðeve; oscar; anneÞÞ4
Resð3; 4Þ : ð:childðeve; anne; oscarÞÞ5
Resð1; 5Þ : ðÞ6;
where, in the ﬁrst step, the variables x, y, z are replaced by constants. Then two
resolution steps follow under application of the general resolution rule from (2.2),
which was taken unchanged from propositional logic.
The circumstances in the following example are somewhat more complex. We
assume that everyone knows his own mother and ask whether Henry knows anyone.
With the function symbol “mother” and the predicate “knows”, we have to derive a
contradiction from
ðknowsðx; motherðxÞÞÞ1 ^ ð:knowsðhenry; yÞÞ2:
By the replacement x/henry, y/mother(henry) we obtain the contradictory clause
pair
ðknowsðhenry; motherðhenryÞÞÞ1 ^ ð:knowsðhenry; motherðhenryÞÞÞ2:
This replacement step is called uniﬁcation. The two literals are complementary,
which means that they are the same other than their signs. The empty clause is now
derivable with a resolution step, by which it has been shown that Henry does know
someone (his mother). We deﬁne
52
3
First-order Predicate Logic

Deﬁnition 3.7 Two literals are called uniﬁable if there is a substitution r for
all variables which makes the literals equal. Such a r is called a uniﬁer.
A uniﬁer is called the most general uniﬁer (MGU) if all other uniﬁers can be
obtained from it by substitution of variables.
Example 3.6 We want to unify the literals p(f(g(x)), y, z) and p(u, u, f(u)). Several
uniﬁers are
r1 :
y=fðgðxÞÞ;
z=fðfðgðxÞÞÞ;
u=fðgðxÞÞ;
r2 :
x=hðvÞ;
y=fðgðhðvÞÞÞ;
z=fðfðgðhðvÞÞÞÞ;
u=fðgðhðvÞÞÞ
r3 :
x=hðhðvÞÞ;
y=fðgðhðhðvÞÞÞÞ;
z=fðfðgðhðhðvÞÞÞÞÞ;
u=fðgðhðhðvÞÞÞÞ
r4 :
x=hðaÞ;
y=fðgðhðaÞÞÞ;
z=fðfðgðhðaÞÞÞÞ;
u=fðgðhðaÞÞÞ
r5 :
x=a;
y=fðgðaÞÞ;
z=fðfðgðaÞÞÞ;
u=fðgðaÞÞ
where r1 is the most general uniﬁer. The other uniﬁers result from r1 through the
substitutions x=hðvÞ; x=hðhðvÞÞ; x=hðaÞ; x=a.
We can see in this example that during uniﬁcation of literals, the predicate
symbols can be treated like function symbols. That is, the literal is treated like a term.
Implementations of uniﬁcation algorithms process the arguments of functions
sequentially. Terms are uniﬁed recursively over the term structure. The simplest
uniﬁcation algorithms are very fast in most cases. In the worst case, however, the
computation time can grow exponentially with the size of the terms. Because for
automated provers the overwhelming number of uniﬁcation attempts fail or are very
simple, in most cases the worst case complexity has no dramatic effect. The fastest
uniﬁcation algorithms have nearly linear complexity even in the worst case [Bib82].
We can now give the general resolution rule for predicate logic:
Deﬁnition 3.8 The resolution rule for two clauses in conjunctive normal
form reads
ðA1 _    _ Am _ BÞ;
ð:B0 _ C1 _    _ CnÞ
rðBÞ ¼ rðB0Þ
ðrðA1Þ _    _ rðAmÞ _ rðC1Þ _    _ rðCnÞÞ
;
ð3:6Þ
where r is the MGU of B and B′.
Theorem 3.5 The resolution rule is correct. That is, the resolvent is a
semantic consequence of the two parent clauses.
3.5
Resolution
53

For Completeness, however, we still need a small addition, as is shown in the
following example.
Example 3.7 The famous Russell paradox reads “There is a barber who shaves
everyone who does not shave himself.” This statement is contradictory, meaning it
is unsatisﬁable. We wish to show this with resolution. Formalized in PL1, the
paradox reads
8x shavesðbarber; xÞ , :shavesðx; xÞ
and transformation into clause form yields (see Exercise 3.6 on page 64)
ð:shavesðbarbier; xÞ _ :shavesðx; xÞÞ1 ^ ðshavesðbarbier; xÞ _ shavesðx; xÞÞ2:
ð3:7Þ
From these two clauses we can derive several tautologies, but no contradiction.
Thus resolution is not complete. We need yet a further inference rule.
Deﬁnition 3.9 Factorization of a clause is accomplished by
ðA1 _ A2 _    _ AnÞ
rðA1Þ ¼ rðA2Þ
ðrðA2Þ _    _ rðAnÞÞ
;
where r is the MGU of A1 and A2.
Now a contradiction can be derived from (3.7)
Fakð1; r : x=barberÞ :
ð:shavesðbarber; barberÞÞ3
Fakð2; r : x=barberÞ :
ðshavesðbarber; barberÞÞ4
Resð3; 4Þ :
ðÞ5
and we assert:
Theorem 3.6 The resolution rule (3.6) together with the factorization rule
(3.9) is refutation complete. That is, by application of factorization and
resolution steps, the empty clause can be derived from any unsatisﬁable
formula in conjunctive normal form.
54
3
First-order Predicate Logic

3.5.1
Resolution Strategies
While completeness of resolution is important for the user, the search for a proof
can be very frustrating in practice. The reason for this is the immense combinatorial
search space. Even if there are only very few pairs of clauses in KB ^ ¬Q in the
beginning, the prover generates a new clause with every resolution step, which
increases the number of possible resolution steps in the next iteration. Thus it has
long been attempted to reduce the search space using special strategies, preferably
without losing completeness. The most important strategies are the following.
Unit resolution prioritizes resolution steps in which one of the two clauses
consists of only one literal, called a unit clause. This strategy preserves com-
pleteness and leads in many cases, but not always, to a reduction of the search
space. It therefore is a heuristic process (see Sect. 6.3).
One obtains a guaranteed reduction of the search space by application of the set
of support strategy. Here a subset of KB ^ ¬Q is deﬁned as the set of support
(SOS). Every resolution step must involve a clause from the SOS, and the resolvent
is added to the SOS. This strategy is incomplete. It becomes complete when it is
ensured that the set of clauses is satisﬁable without the SOS (see Exercise 3.7 on
page 64). The negated query ¬Q is often used as the initial SOS.
In input resolution, a clause from the input set KB ^ ¬Q must be involved in
every resolution step. This strategy also reduces the search space, but at the cost of
completeness.
With the pure literal rule all clauses that contain literals for which there are no
complementary literals in other clauses can be deleted. This rule reduces the search
space and is complete, and therefore it is used by practically all resolution provers.
If the literals of a clause K1 represent a subset of the literals of the clause K2, then
K2 can be deleted. For example, the clause
ðrainingðtodayÞ ) street wetðtodayÞÞ
is redundant if street_wet(today) is already valid. This important reduction step is
called subsumption. Subsumption, too, is complete.
3.5.2
Equality
Equality is an especially inconvenient cause of explosive growth of the search
space. If we add (3.1) on page 45 and the equality axioms formulated in (3.2) on
page 45 to the knowledge base, then the symmetry clause ¬x = y _ y = x can be
uniﬁed with every positive or negated equation, for example. This leads to the
derivation of new clauses and equations upon which equality axioms can again be
applied, and so on. The transitivity and substitution axioms have similar conse-
quences. Because of this, special inference rules for equality have been developed
which get by without explicit equality axioms and, in particular, reduce the search
3.5
Resolution
55

space. Demodulation, for example, allows substitution of a term t2 for t1, if the
equation t1 = t2 exists. An equation t1 = t2 is applied by means of uniﬁcation to a
term t as follows:
t1 ¼ t2;
ð. . . t. . .Þ; rðt1Þ ¼ rðtÞ
ð. . . rðt2Þ. . .Þ
:
Somewhat more general is paramodulation, which works with conditional equa-
tions [Bib82, Lov78].
The equation t1 = t2 allows the substitution of the term t1 by t2 as well as the
substitution t2 by t1. It is usually pointless to reverse a substitution that has already
been carried out. On the contrary, equations are frequently used to simplify terms.
They are thus often used in one direction only. Equations which are only used in
one direction are called directed equations. Efﬁcient processing of directed equa-
tions is accomplished by so-called term rewriting systems. For formulas with many
equations there exist special equality provers.
3.6
Automated Theorem Provers
Implementations of proof calculi on computers are called theorem provers. Along
with specialized provers for subsets of PL1 or special applications, there exist today
a whole line of automated provers for the full predicate logic and higher-order
logics, of which only a few will be discussed here. An overview of the most
important systems can be found in [McC].
One of the oldest resolution provers was developed at the Argonne National
Laboratory in Chicago. Based on early developments starting in 1963, Otter
[Kal01], was created in 1984. Above all, Otter was successfully applied in
specialized areas of mathematics, as one can learn from its home page:
“Currently, the main application of Otter is research in abstract algebra and formal logic.
Otter and its predecessors have been used to answer many open questions in the areas of
ﬁnite semigroups, ternary Boolean algebra, logic calculi, combinatory logic, group theory,
lattice theory, and algebraic geometry.”
Several years later the University of Technology, Munich, created the high-
performance prover SETHEO [LSBB92] based on fast PROLOG technology. With
the goal of reaching even higher performance, an implementation for parallel
computers was developed under the name PARTHEO. It turned out that it was not
worthwhile to use special hardware in theorem provers, as is also the case in other
areas of AI, because these computers are very quickly overtaken by faster pro-
cessors and more intelligent algorithms. Munich is also the birthplace of E [Sch02],
an award-winning modern equation prover, which we will become familiar with in
the next example. On E’s homepage one can read the following compact, ironic
characterization, whose second part incidentally applies to all automated provers in
existence today.
56
3
First-order Predicate Logic

“E is a purely equational theorem prover for clausal logic. That means it is a program that
you can stuff a mathematical speciﬁcation (in clausal logic with equality) and a hypothesis
into, and which will then run forever, using up all of your machines resources. Very
occasionally it will ﬁnd a proof for the hypothesis and tell you so ;-).”
Finding proofs for true propositions is apparently so difﬁcult that the search suc-
ceeds only extremely rarely, or only after a very long time—if at all. We will go
into this in more detail in Chap. 4. Here it should be mentioned, though, that not
only computers, but also most people have trouble ﬁnding strict formal proofs.
Though evidently computers by themselves are in many cases incapable of
ﬁnding a proof, the next best thing is to build systems that work semi-automatically
and allow close cooperation with the user. Thereby the human can better apply his
knowledge of special application domains and perhaps limit the search for the
proof. One of the most successful interactive provers for higher-order predicate
logic is Isabelle [NPW02], a common product of Cambridge University and the
University of Technology, Munich.
Anyone searching for a high-performance prover should look at the current
results of the CASC (CADE ATP System Competition) [SS06].1 Here we ﬁnd that
the winner from 2001 to 2006 in the PL1 and clause normal form categories was
Manchester’s prover Vampire, which works with a resolution variant and a special
approach to equality. The system Waldmeister of the Max Planck Institute in
Saarbrücken has been leading for years in equality proving.
The many top positions of German systems at CASC show that German research
groups in the area of automated theorem proving are playing a leading role, today as
well as in the past.
3.7
Mathematical Examples
We now wish to demonstrate the application of an automated prover with the
aforementioned prover E [Sch02]. E is a specialized equality prover which greatly
shrinks the search space through an optimized treatment of equality.
We want to prove that left- and right-neutral elements in a semigroup are equal.
First we formalize the claim step by step.
Deﬁnition 3.10 A structure (M,⋅) consisting of a set M with a two-place inner
operation “⋅” is called a semigroup if the law of associativity
8x 8y 8z ðx  yÞ  z ¼ x  ðy  zÞ
holds.
An
element
e2M
is
called
left-neutral
(right-neutral)
if
8x e  x ¼ x ð8x x  e ¼ xÞ.
1CADE is the annual “Conference on Automated Deduction” [CAD] and ATP stands for
“Automated Theorem Prover”.
3.6
Automated Theorem Provers
57

It remains to be shown that
Theorem 3.7 If a semigroup has a left-neutral element el and a right-neutral
element er, then el = er.
First we prove the theorem semi-formally by intuitive mathematical reasoning.
Clearly it holds for all x 2 M that
el  x ¼ x
ð3:8Þ
and
x  er ¼ x:
ð3:9Þ
If we set x = er in (3.8) and x = el in (3.9), we obtain the two equations el ⋅er = er
and el ⋅er = el. Joining these two equations yields
el ¼ el  er ¼ er;
which we want to prove. In the last step, incidentally, we used the fact that equality
is symmetric and transitive.
Before we apply the automated prover, we carry out the resolution proof man-
ually. First we formalize the negated query and the knowledge base KB, consisting
of the axioms as clauses in conjunctive normal form:
ð:el ¼ erÞ1
negated query
ðmðmðx; yÞ; zÞ ¼ mðx; mðy; zÞÞÞ2
ðmðel; xÞ ¼ xÞ3
ðmðx; erÞ ¼ xÞ4
equality axioms:
ðx ¼ xÞ5
(reflexivity)
ð:x ¼ y _ y ¼ xÞ6
(symmetry)
ð:x ¼ y _ :y ¼ z _ x ¼ zÞ7
(transitivity)
ð:x ¼ y _ mðx; zÞ ¼ mðy; zÞÞ8
substitution in m
ð:x ¼ y _ mðz; xÞ ¼ mðz; yÞÞ9
substitution in m;
where multiplication is represented by the two-place function symbol m. The
equality axioms were formulated analogously to (3.1) on page 45 and (3.2) on
page 45. A simple resolution proof has the form
58
3
First-order Predicate Logic

Resð3; 6; x6=mðel; x3Þ; y6=x3Þ :
ðx ¼ mðel; xÞÞ10
Resð7; 10; x7=x10; y7=mðel; x10ÞÞ :
ð:mðel; xÞ ¼ z _ x ¼ zÞ11
Resð4; 11; x4=el; x11=er; z11=elÞ :
ðer ¼ elÞ12
Resð1; 12; ;Þ :
ðÞ:
Here, for example, Res(3, 6, x6/m(el , x3), y6/x3) means that in the resolution of clause 3
with clause 6, the variable x from clause 6 is replaced by m(el, x3) with variable x from
clause 3. Analogously, y from clause 6 is replaced by x from clause 3.
Now we want to apply the prover E to the problem. The clauses are transformed
into the clause normal form language LOP through the mapping
(¬A1_  _ ¬Am _ B1 _  _ Bn)
7!
B1;; Bn < –A1,, Am.
The syntax of LOP represents an extension of the PROLOG syntax (see Chap. 5)
for non Horn clauses. Thus we obtain as an input ﬁle for E
y
r
e
u
q
#
.
)
r
e
,
l
e
(
q
e
-
<
eq( m(m(X,Y),Z), m(X,m(Y,Z)) ).
# associativity of m
eq( m(el,X), X ).
# left-neutral element of m
eq( m(X,er), X ).
# right-neutral element of m
y
t
i
v
i
x
e
l
f
e
r
:
y
t
i
l
a
u
q
e
#
.
)
X
,
X
(
q
e
eq(Y,X) <- eq(X,Y).
# equality: symmetry
eq(X,Z) <- eq(X,Y), eq(Y,Z).
# equality: transitivity
eq( m(X,Z), m(Y,Z) ) <- eq(X,Y).
# equality: substitution in m
eq( m(Z,X), m(Z,Y) ) <- eq(X,Y).
# equality: substitution in m
where equality is modeled by the predicate symbol eq. Calling the prover delivers
unixprompt> eproof halbgr1.lop
# Problem status determined, constructing proof object
# Evidence for problem status starts
0 : [--eq(el,er)] : initial
1 : [++eq(X1,X2),--eq(X2,X1)] : initial
2 : [++eq(m(el,X1),X1)] : initial
3 : [++eq(m(X1,er),X1)] : initial
4 : [++eq(X1,X2),--eq(X1,X3),--eq(X3,X2)] : initial
5 : [++eq(X1,m(X1,er))] : pm(3,1)
6 : [++eq(X2,X1),--eq(X2,m(el,X1))] : pm(2,4)
7 : [++eq(el,er)] : pm(5,6)
8 : [] : sr(7,0)
9 : [] : 8 : {proof}
# Evidence for problem status ends
3.7
Mathematical Examples
59

Positive literals are identiﬁed by ++ and negative literals by ––. In lines 0 to 4,
marked with initial, the clauses from the input data are listed again. pm(a, b)
stands for a resolution step between clause a and clause b. We see that the proof
found by E is very similar to the manually created proof. Because we explicitly
model the equality by the predicate eq, the particular strengths of E do not come
into play. Now we omit the equality axioms and obtain
y
r
e
u
q
%
.
r
e
=
l
e
-
<
m(m(X,Y),Z) = m(X,m(Y,Z)) .
% associativity of m
m(el,X) = X .
% left-neutral element of m
m(X,er) = X .
% right-neutral element of m
as input for the prover.
The proof also becomes more compact. We see in the following output of the
prover that the proof consists essentially of a single inference step on the two
relevant clauses 1 and 2.
unixprompt> eproof halbgr1a.lop
# Problem status determined, constructing proof object
# Evidence for problem status starts
0 : [--equal(el, er)] : initial
1 : [++equal(m(el,X1), X1)] : initial
2 : [++equal(m(X1,er), X1)] : initial
3 : [++equal(el, er)] : pm(2,1)
4 : [--equal(el, el)] : rw(0,3)
5 : [] : cn(4)
6 : [] : 5 : {proof}
# Evidence for problem status ends
The reader might now take a closer look at the capabilities of E (Exercise 3.9 on
page 64).
3.8
Applications
In mathematics automated theorem provers are used for certain specialized tasks.
For example, the important four color theorem of graph theory was ﬁrst proved in
1976 with the help of a special prover. However, automated provers still play a
minor role in mathematics.
60
3
First-order Predicate Logic

On the other hand, in the beginning of AI, predicate logic was of great impor-
tance for the development of expert systems in practical applications. Due to its
problems modeling uncertainty (see Sect. 4.4), expert systems today are most often
developed using other formalisms.
Today logic plays an ever more important role in veriﬁcation tasks. Automatic
program veriﬁcation is currently an important research area between AI and soft-
ware engineering. Increasingly complex software systems are now taking over tasks
of more and more responsibility and security relevance. Here a proof of certain
safety characteristics of a program is desirable. Such a proof cannot be brought
about through testing of a ﬁnished program, for in general it is impossible to apply a
program to all possible inputs. This is therefore an ideal domain for general or even
specialized inference systems. Among other things, cryptographic protocols are in
use today whose security characteristics have been automatically veriﬁed [FS97,
Sch01]. A further challenge for the use of automated provers is the synthesis of
software and hardware. To this end, for example, provers should support the
software engineer in the generation of programs from speciﬁcations.
Software reuse is also of great importance for many programmers today. The
programmer looks for a program that takes input data with certain properties and
calculates a result with desired properties. A sorting algorithm accepts input data
with entries of a certain data type and from these creates a permutation of these
entries with the property that every element is less than or equal to the next element.
The programmer ﬁrst formulates a speciﬁcation of the query in PL1 consisting of
two parts. The ﬁrst part PREQ comprises the preconditions, which must hold before
the desired program is applied. The second part POSTQ contains the postconditions,
which must hold after the desired program is applied.
In the next step a software database must be searched for modules which fulﬁll
these requirements. To check this formally, the database must store a formal
description of the preconditions PREM and postconditions POSTM for every mod-
ule M. An assumption about the capabilities of the modules is that the preconditions
of the module follow from the preconditions of the query. It must hold that
PREQ ) PREM:
All conditions that are required as a prerequisite for the application of module
M must appear as preconditions in the query. If, for example, a module in the
database only accepts lists of integers, then lists of integers as input must also
appear as preconditions in the query. An additional requirement in the query that,
for example, only even numbers appear, does not cause a problem.
Furthermore, it must hold for the postconditions that
POSTM ) POSTQ:
That is, after application of the module, all attributes that the query requires must be
fulﬁlled. We now show the application of a theorem prover to this task in an
example from [Sch01].
3.8
Applications
61

Example 3.8 VDM-SL, the Vienna Development Method Speciﬁcation Language,
is often used as a language for the speciﬁcation of pre- and postconditions. Assume
that in the software database the description of a module ROTATE is available, which
moves the ﬁrst list element to the end of the list. We are looking for a module SHUFFLE,
which creates an arbitrary permutation of the list. The two speciﬁcations read
ROTATE(l : List) l : List
pre true
post
(l = [] ⇒l = [])∧
(l
l = (taill)ˆ[headl])
SHUFFLE(x : List) x : List
pre true
post ∀i : Item·
(∃x1,x2 : List · x = x1ˆ[i]ˆx2 ⇔
∃y1,y2 : List · x = y1ˆ[i]ˆy2)
Here “^” stands for the concatenation of lists, and “⋅” separates quantiﬁers with their
variables from the rest of the formula. The functions “head l” and “tail l” choose the
ﬁrst element and the rest from the list, respectively. The speciﬁcation of SHUFFLE
indicates that every list element i that was in the list (x) before the application of
SHUFFLE must be in the result (x′) after the application, and vice versa. It must now be
shown that the formula (PREQ ) PREM) ^ (POSTM ) POSTQ) is a consequence of
the knowledge base containing a description of the data type List. The two VDM-SL
speciﬁcations yield the proof task
∀l,l ,x,x : List · (l = x ∧l = x ∧(w ⇒w)) ∧
(l = x ∧l = x ∧((l = [] ⇒l = []) ∧(l
l = (tll)ˆ[hd l])
⇒∀i : Item · (∃x1,x2 : List · x = x1ˆ[i]ˆx2 ⇔∃y1,y2 : List · x = y1ˆ[i]ˆy2))),
which can then be proven with the prover SETHEO.
In the coming years the semantic web will likely represent an important appli-
cation of PL1. The content of the World Wide Web is supposed to become inter-
pretable not only for people, but for machines. To this end web sites are being
furnished with a description of their semantics in a formal description language.
The search for information in the web will thereby become signiﬁcantly more
effective than today, where essentially only text building blocks are searchable.
Decidable subsets of predicate logic are used as description languages. The
development of efﬁcient calculi for reasoning is very important and closely con-
nected to the description languages. A query for a future semantically operating
search engine could (informally) read: Where in Switzerland next Sunday at ele-
vations under 2000 meters will there be good weather and optimally prepared ski
slopes? To answer such a question, a calculus is required that is capable of working
very quickly on large sets of facts and rules. Here, complex nested function terms
are less important.
62
3
First-order Predicate Logic

As a basic description framework, the World Wide Web Consortium developed
the language RDF (Resource Description Framework). Building on RDF, the sig-
niﬁcantly more powerful language OWL (Web Ontology Language) allows the
description of relations between objects and classes of objects, similarly to PL1
[SET09]. Ontologies are descriptions of relationships between possible objects.
A difﬁculty when building a description of the innumerable websites is the
expenditure of work and also checking the correctness of the semantic descriptions.
Here machine learning systems for the automatic generation of descriptions can be
very helpful. An interesting use of “automatic” generation of semantics in the web
was introduced by Luis von Ahn of Carnegie Mellon University [vA06]. He
developed computer games in which the players, distributed over the network, are
supposed to collaboratively describe pictures with key words. Thus the pictures are
assigned semantics in a fun way at no cost.
3.9
Summary
We have provided the most important foundations, terms, and procedures of
predicate logic and we have shown that even one of the most difﬁcult intellectual
tasks, namely the proof of mathematical theorems, can be automated. Automated
provers can be employed not only in mathematics, but rather, in particular, in
veriﬁcation tasks in computer science. For everyday reasoning, however, predicate
logic in most cases is ill-suited. In the next and the following chapters we show its
weak points and some interesting modern alternatives. Furthermore, we will show
in Chap. 5 that one can program elegantly with logic and its procedural
extensions.
Anyone interested in ﬁrst-order logic, resolution and other calculi for automated
provers will ﬁnd good advanced instruction in [New00, Fit96, Bib82, Lov78,
CL73]. References to Internet resources can be found on this book’s web site.
3.10
Exercises
Exercise 3.1 Let the three-place predicate “child” and the one-place predicate
“female” from Example 3.2 on page 43 be given. Deﬁne:
(a) A one-place predicate “male”.
(b) A two-place predicate “father” and “mother”.
(c) A two-place predicate “siblings”.
(d) A predicate “parents (x, y, z)”, which is true if and only if x is the father and
y is the mother of z.
(e) A predicate “uncle (x, y)”, which is true if and only if x is the uncle of y (use
the predicates that have already been deﬁned).
(f) A two-place predicate “ancestor” with the meaning: ancestors are parents,
grandparents, etc. of arbitrarily many generations.
3.8
Applications
63

Exercise 3.2 Formalize the following statements in predicate logic:
(a) Every person has a father and a mother.
(b) Some people have children.
(c) All birds ﬂy.
(d) There is an animal that eats (some) grain-eating animals.
(e) Every animal eats plants or plant-eating animals which are much smaller than
itself.
Exercise 3.3 Adapt Exercise 3.1 on page 63 by using one-place function symbols
and equality instead of “father” and “mother”.
Exercise 3.4 Give predicate logic axioms for the two-place relation “<” as a total
order. For a total order we must have (1) Any two elements are comparable. (2) It is
symmetric. (3) It is transitive.
Exercise 3.5 Unify (if possible) the following terms and give the MGU and the
resulting terms.
(a) p(x, f(y)), p(f(z), u)
(b) p(x, f(x)), p(y, y)
(c) x = 4 −7  x, cos y = z
(d) x < 2  x, 3 < 6
(e) q(f(x, y, z), f(gðw; wÞ, g(x, x), g(y, y))), q(u, u)
Exercise 3.6
(a) Transform Russell’s Paradox from Example 3.7 on page 54 into CNF.
(b) Show that the empty clause cannot be derived using resolution without
factorization from (3.7) on page 54. Try to understand this intuitively.
Exercise 3.7
(a) Why is resolution with the set of support strategy incomplete?
(b) Justify (without proving) why the set of support strategy becomes complete if
(KB ^ ¬Q)\SOS is satisﬁable.
(c) Why is resolution with the pure literal rule complete?
❄Exercise 3.8 Formalize and prove with resolution that in a semigroup with at least
two different elements a, b, a left-neutral element e, and a left null element n, these
two elements have to be different, that is, that n 6¼ e. Use demodulation, which
allows replacement of “like with like”.
Exercise 3.9 Obtain the theorem prover E [Sch02] or another prover and prove the
following statements. Compare these proofs with those in the text.
(a) The claim from Example 2.3 on page 33.
(b) Russell’s paradox from Example 3.7 on page 54.
(c) The claim from Exercise 3.8.
64
3
First-order Predicate Logic

4
Limitations of Logic
4.1
The Search Space Problem
As already mentioned in several places, in the search for a proof there are almost
always many (depending on the calculus, potentially inﬁnitely many) possibilities
for the application of inference rules at every step. The result is the aforementioned
explosive growth of the search space (Fig. 4.1 on page 66). In the worst case, all of
these possibilities must be tried in order to ﬁnd the proof, which is usually not
possible in a reasonable amount of time.
If we compare automated provers or inference systems with mathematicians or
human experts who have experience in special domains, we make interesting
observations. For one thing, experienced mathematicians can prove theorems which
are far out of reach for automated provers. On the other hand, automated provers
perform tens of thousands of inferences per second. A human in contrast performs
maybe one inference per second. Although human experts are much slower on the
object level (that is, in carrying out inferences), they apparently solve difﬁcult
problems much faster.
There are several reasons for this. We humans use intuitive calculi that work on a
higher level and often carry out many of the simple inferences of an automated
prover in one step. Furthermore, we use lemmas, that is, derived true formulas that
we already know and therefore do not need to re-prove them each time. Meanwhile
there are also machine provers that work with such methods. But even they cannot
yet compete with human experts.
A further, much more important advantage of us humans is intuition, without
which we could not solve any difﬁcult problems [PS09]. The attempt to formalize
intuition causes problems. Experience in applied AI projects shows that in complex
domains such as medicine (see Sect. 7.3) or mathematics, most experts are unable
to formulate this intuitive meta-knowledge verbally, much less to formalize it.
Therefore we cannot program this knowledge or integrate it into calculi in the form
of heuristics. Heuristics are methods that in many cases can greatly simplify or
shorten the way to the goal, but in some cases (usually rarely) can greatly lengthen
© Springer International Publishing AG 2017
W. Ertel, Introduction to Artificial Intelligence, Undergraduate Topics
in Computer Science, DOI 10.1007/978-3-319-58487-4_4
65

the way to the goal. Heuristic search is important not only to logic, but generally to
problem solving in AI and will therefore be thoroughly handled in Chap. 6.
An interesting approach, which has been pursued since about 1990, is the
application of machine learning techniques to the learning of heuristics for directing
the search of inference systems, which we will brieﬂy sketch now. A resolution
prover has, during the search for a proof, hundreds or more possibilities for reso-
lution steps at each step, but only a few lead to the goal. It would be ideal if the
prover could ask an oracle which two clauses it should use in the next step to
quickly ﬁnd the proof. There are attempts to build such proof-directing modules,
which evaluate the various alternatives for the next step and then choose the
alternative with the best rating. In the case of resolution, the rating of the available
clauses could be computed by a function that calculates a value based on the
number of positive literals, the complexity of the terms, etc., for every pair of
resolvable clauses.
How can this function be implemented? Because this knowledge is “intuitive”,
the programmer is not familiar with it. Instead, one tries to copy nature and uses
machine learning algorithms to learn from successful proofs [ESS89, SE90].
Fig. 4.1 Possible consequences of the explosion of a search space
66
4
Limitations of Logic

The attributes of all clause pairs participating in successful resolution steps are
stored as positive, and the attributes of all unsuccessful resolutions are stored as
negative. Then, using this training data and a machine learning system, a program is
generated which can rate clause pairs heuristically (see Sect. 9.5).
A different, more successful approach to improving mathematical reasoning is
followed with interactive systems that operate under the control of the user. Here
one could name computer algebra programs such as Mathematica, Maple, or
Maxima, which can automatically carry out difﬁcult symbolic mathematical
manipulations. The search for the proof, however, is left fully to the human. The
aforementioned interactive prover Isabelle [NPW02] provides distinctly more
support during the proof search. There are at present several projects, such as
Omega [SB04] and MKM,1 for the development of systems for supporting math-
ematicians during proofs.
In summary, one can say that, because of the search space problem, automated
provers today can only prove relatively simple theorems in special domains with
few axioms.
4.2
Decidability and Incompleteness
First-order predicate logic provides a powerful tool for the representation of
knowledge and reasoning. We know that there are correct and complete calculi and
theorem provers. When proving a theorem, that is, a true statement, such a prover is
very helpful because, due to completeness, one knows after ﬁnite time that the
statement really is true. What if the statement is not true? The completeness theorem
(Theorem 3.3 on page 50) does not answer this question.2 Speciﬁcally, there is no
process that can prove or refute any formula from PL1 in ﬁnite time, for it holds that
Theorem 4.1 The set of valid formulas in ﬁrst-order predicate logic is semi-
decidable.
This theorem implies that there are programs (theorem provers) which, given a
true (valid) formula as input, determine its truth in ﬁnite time. If the formula is not
valid, however, it may happen that the prover never halts. (The reader may grapple
with this question in Exercise 4.1 on page 73.) Propositional logic is decidable
because the truth table method provides all models of a formula in ﬁnite time.
Evidently predicate logic with quantiﬁers and nested function symbols is a language
somewhat too powerful to be decidable.
1www.mathweb.org/mathweb/demo.html.
2Just this case is especially important in practice, because if I already know that a statement is true,
I no longer need a prover.
4.1
The Search Space Problem
67

On the other hand, predicate logic is not powerful enough for many purposes.
One often wishes to make statements about sets of predicates or functions. This
does not work in PL1 because it only knows quantiﬁers for variables, but not for
predicates or functions.
Kurt Gödel showed, shortly after his completeness theorem for PL1, that com-
pleteness is lost if we extend PL1 even minimally to construct a higher-order logic.
A ﬁrst-order logic can only quantify over variables. A second-order logic can also
quantify over formulas of the ﬁrst order, and a third-order logic can quantify over
formulas of the second order. Even adding only the induction axiom for the natural
numbers makes the logic incomplete. The statement “If a predicate p(n) holds for n,
then p(n + 1) also holds”, or
8p pðnÞ ) pðn þ 1Þ
is a second-order proposition because it quantiﬁes over a predicate. Gödel proved
the following theorem:
Theorem 4.2 (Gödel’s incompleteness theorem) Every axiom system for the
natural numbers with addition and multiplication (arithmetic) is incomplete.
That is, there are true statements in arithmetic that are not provable.
Gödel’s proof works with what is called Gödelization, in which every arithmetic
formula is encoded as a number. It obtains a unique Gödel number. Gödelization is
now used to formulate the proposition
F ¼ “I am not provable.”
in the language of arithmetic. This formula is true for the following reason. Assume
F is false. Then we can prove F and therefore show that F is not provable. This is a
contradiction. Thus F is true and therefore not provable.
The deeper background of this theorem is that mathematical theories (axiom
systems) and, more generally, languages become incomplete if the language
becomes too powerful. A similar example is set theory. This language is so
powerful that one can formulate paradoxes with it. These are statements that
contradict themselves, such as the statement we already know from Example 3.7
on page 54 about the barbers who all shave those who do not shave themselves
(see Exercise 4.2 on page 73). The dilemma consists therein that with languages
which are powerful enough to describe mathematics and interesting applications,
we are smuggling contradictions and incompletenesses through the back door.
This does not mean, however, that higher-order logics are wholly unsuited for
formal methods. There are certainly formal systems as well as provers for
higher-order logics.
68
4
Limitations of Logic

4.3
The Flying Penguin
With a simple example we will demonstrate a fundamental problem of logic and
possible solution approaches. Given the statements
1. Tweety is a penguin
2. Penguins are birds
3. Birds can ﬂy
Formalized in PL1, the knowledge base KB results:
penguinðtweetyÞ
penguinðxÞ ) birdðxÞ
birdðxÞ ) flyðxÞ
From there (for example with resolution) ﬂy(tweety) can be derived (Fig. 4.2 on
page 70).3 Evidently the formalization of the ﬂight attributes of penguins is
insufﬁcient. We try the additional statement Penguins cannot ﬂy, that is
penguinðxÞ ) : flyðxÞ
From there ¬ﬂy(tweety) can be derived. But ﬂy(tweety) is still true. The knowledge
base is therefore inconsistent. Here we notice an important characteristic of logic,
namely monotony. Although we explicitly state that penguins cannot ﬂy, the
opposite can still be derived.
Deﬁnition 4.1 A logic is called monotonic if, for an arbitrary knowledge
base KB and an arbitrary formula /, the set of formulas derivable from KB is
a subset of the formulas derivable from KB [ /.
If a set of formulas is extended, then, after the extension, all previously derivable
statements can still be proved, and additional statements can potentially also be
proved. The set of provable statements thus grows monotonically when the set of
formulas is extended. For our example this means that the extension of the
knowledge base will never lead to our goal. We thus modify KB by replacing the
obviously false statement “(all) birds can ﬂy” with the more exact statement “(all)
birds except penguins can ﬂy” and obtain as KB2 the following clauses:
penguinðtweetyÞ
penguinðxÞ ) birdðxÞ
birdðxÞ ^ : penguinðxÞ ) flyðxÞ
penguinðxÞ ) : flyðxÞ
3The formal execution of this and the following simple proof may be left to the reader
(Exercise 4.3 on page 73).
4.3
The Flying Penguin
69

Now the world is apparently in order again. We can derive ¬ﬂy(tweety), but not ﬂy
(tweety), because for that we would need ¬ penguin(x), which, however, is not
derivable. As long as there are only penguins in this world, peace reigns. Every
normal bird, however, immediately causes problems. We wish to add the raven
Abraxas (from the German book “The Little Witch”) and obtain
ravenðabraxasÞ
ravenðxÞ ) birdðxÞ
penguinðtweetyÞ
penguinðxÞ ) birdðxÞ
birdðxÞ ^ : penguinðxÞ ) flyðxÞ
penguinðxÞ ) : flyðxÞ
We cannot say anything about the ﬂight attributes of Abraxas because we forgot to
formulate that ravens are not penguins. Thus we extend KB3 to KB4:
ravenðabraxasÞ
ravenðxÞ ) birdðxÞ
ravenðxÞ ) : pinguinðxÞ
penguinðtweetyÞ
penguinðxÞ ) birdðxÞ
birdðxÞ ^ : penguinðxÞ ) flyðxÞ
penguinðxÞ ) : flyðxÞ
The fact that ravens are not penguins, which is self-evident to humans, must be
explicitly added here. For the construction of a knowledge base with all 9,800 or so
Fig. 4.2 The ﬂying penguin Tweety
70
4
Limitations of Logic

types of birds worldwide, it must therefore be speciﬁed for every type of bird
(except for penguins) that it is not a member of penguins. We must proceed
analogously for all other exceptions such as the ostrich.
For every object in the knowledge base, in addition to its attributes, all of the
attributes it does not have must be listed.
To solve this problem, various forms of non-monotonic logic have been
developed, which allow knowledge (formulas) to be removed from the knowledge
base. Under the name default logic, logics have been developed which allow
objects to be assigned attributes which are valid as long as no other rules are
available. In the Tweety example, the rule birds can ﬂy would be such a default
rule. Despite great effort, these logics have at present, due to semantic and practical
problems, not succeeded.
Monotony can be especially inconvenient in complex planning problems in
which the world can change. If for example a blue house is painted red, then
afterwards it is red. A knowledge base such as
colorðhouse; blueÞ
paintðhouse; redÞ
paintðx; yÞ ) colorðx; yÞ
leads to the conclusion that, after painting, the house is red and blue. The problem
that comes up here in planning is known as the frame problem. A solution for this is
the situation calculus presented in Sect. 5.6.
An interesting approach for modeling problems such as the Tweety example is
probability theory. The statement “all birds can ﬂy” is false. A statement something
like “almost all birds can ﬂy” is correct. This statement becomes more exact if we
give a probability for “birds can ﬂy”. This leads to probabilistic logic, which today
represents an important sub-area of AI and an important tool for modeling uncer-
tainty (see Chap. 7).
4.4
Modeling Uncertainty
Two-valued logic can and should only model circumstances in which there is true,
false, and no other truth values. For many tasks in everyday reasoning, two-valued
logic is therefore not expressive enough. The rule
birdðxÞ ) flyðxÞ
is true for almost all birds, but for some it is false. As was already mentioned,
working with probabilities allows exact formulation of uncertainty. The statement
“99% of all birds can ﬂy” can be formalized by the expression
PðbirdðxÞ ) flyðxÞÞ ¼ 0:99:
4.3
The Flying Penguin
71

In Chap. 7 we will see that here it is better to work with conditional probabilities
such as
PðflyjbirdÞ ¼ 0:99:
With the help of Bayesian networks, complex applications with many variables can
also be modeled.
A different model is needed for the statement “The weather is nice”. Here it often
makes no sense to speak in terms of true and false. The variable weather_is_nice
should not be modeled as binary, rather continuously with values, for example, in
the interval [0, 1]. weather_is_nice = 0.7 then means “The weather is fairly nice”.
Fuzzy logic was developed for this type of continuous (fuzzy) variable.
Probability theory also offers the possibility of making statements about the
probability of continuous variables. A statement in the weather report such as
“There is a high probability that there will be some rain” could for example be
exactly formulated as a probability density of the form
Pðrainfall ¼ XÞ ¼ Y
and represented graphically something like in Fig. 4.3.
This very general and even visualizable representation of both types of uncertainty
we have discussed, together with inductive statistics and the theory of Bayesian
networks, makes it possible, in principle, to answer arbitrary probabilistic queries.
Probability theory as well as fuzzy logic are not directly comparable to predicate
logic because they do not allow variables or quantiﬁers. They can thus be seen as
extensions of propositional logic as shown in the following table.
Fig. 4.3 Probability density of the continuous variable rainfall
Formalism
Number of
truth values
Probabilities
expressible
Propositional logic
2
–
Fuzzy logic
∞
–
Discrete probabilistic logic
n
yes
Continuous probabilistic logic
∞
yes
72
4
Limitations of Logic

4.5
Exercises
❄Exercise 4.1
(a) With the following (false) argument, one could claim that PL1 is decidable:
We take a complete proof calculus for PL1. With it we can ﬁnd a proof for any
true formula in ﬁnite time. For every other formula / I proceed as follows: I
apply the calculus to ¬/ and show that ¬/ is true. Thus / is false. Thus I can
prove or refute every formula in PL1. Find the mistake in the argument and
change it so it becomes correct.
(b) Construct a decision process for the set of true and unsatisﬁable formulas in
PL1.
Exercise 4.2
(a) Given the statement “There is a barber who shaves every person who does not
shave himself.” Consider whether this barber shaves himself.
(b) Let M = {x | x 62 x}. Describe this set and consider whether M contains itself.
Exercise 4.3 Use an automated theorem prover (for example E [Sch02]) and apply
it to all ﬁve different axiomatizations of the Tweety example from Sect. 4.3.
Validate the example’s statements.
4.5
Exercises
73

5
Logic Programming with PROLOG
Compared to classical programming languages such as C or Pascal, Logic makes it
possible to express relationships elegantly, compactly, and declaratively. Auto-
mated theorem provers are even capable of deciding whether a knowledge base
logically entails a query. Proof calculus and knowledge stored in the knowledge
base are strictly separated. A formula described in clause normal form can be used
as input data for any theorem prover, independent of the proof calculus used. This is
of great value for reasoning and the representation of knowledge.
If one wishes to implement algorithms, which inevitably have procedural
components, a purely declarative description is often insufﬁcient. Robert Kowalski,
one of the pioneers of logic programming, made this point with the formula
Algorithm ¼ Logic þ Control:
This idea was brought to fruition in the language PROLOG. PROLOG is used in
many projects, primarily in AI and computational linguistics. We will now give a
short introduction to this language, present the most important concepts, show its
strengths, and compare it with other programming languages and theorem provers.
Those looking for a complete programming course are directed to textbooks such as
[Bra11, CM94] and the handbooks [Wie04, Dia04].
The syntax of the language PROLOG only allows Horn clauses. Logical nota-
tion and PROLOG’s syntax are juxtaposed in the following table:
PL1 / clause normal form
PROLOG
Description
(¬A1 _ … _ ¬Am _ B)
B:- A1, … , Am.
Rule
(A1 ^ … ^ Am) ) B
B:- A1, … , Am.
Rule
A
A.
Fact
(¬A1 _ … _ ¬Am)
?- A1, … , Am.
Query
¬(A1 ^ … ^ Am)
?- A1, … , Am.
Query
© Springer International Publishing AG 2017
W. Ertel, Introduction to Artificial Intelligence, Undergraduate Topics
in Computer Science, DOI 10.1007/978-3-319-58487-4_5
75

Here A1, … , Am, A, B are literals. The literals are, as in PL1, constructed from
predicate symbols with terms as arguments. As we can see in the above table, in
PROLOG there are no negations in the strict logical sense because the sign of a
literal is determined by its position in the clause.
5.1
PROLOG Systems and Implementations
An overview of current PROLOG systems is available in the collection of links on
this book’s home page. To the reader we recommend the very powerful and freely
available (under GNU public licenses) systems GNU-PROLOG [Dia04] and
SWI-PROLOG. For the following examples, SWI-PROLOG [Wie04] was used.
Most modern PROLOG systems work with an interpreter based on the Warren
abstract machine (WAM). PROLOG source code is compiled into so-called
WAM code, which is then interpreted by the WAM. The fastest implementations
of a WAM manage up to 10 million logical inferences per second (LIPS) on a
1 GHz PC.
5.2
Simple Examples
We begin with the family relationships from Example 3.2 on page 43. The small
knowledge base KB is coded—without the facts for the predicate female—as a
PROLOG program named rel.pl in Fig. 5.1.
The program can be loaded and compiled in the PROLOG interpreter with the
command
?- [rel].
1 child(oscar,karen,frank).
2 child(mary,karen,frank).
3 child(eve,anne,oscar).
4 child(henry,anne,oscar).
5 child(isolde,anne,oscar).
6 child(clyde,mary,oscarb).
7
8 child(X,Z,Y) :- child(X,Y,Z).
9
10 descendant(X,Y) :- child(X,Y,Z).
11 descendant(X,Y) :- child(X,U,V), descendant(U,Y).
Fig. 5.1 PROLOG program with family relationships
76
5
Logic Programming with PROLOG

An initial query returns the dialog
?- child(eve,oscar,anne).
Yes
with the correct answer Yes. How does this answer come about? For the query
“?- child(eve,oscar,anne).” there are six facts and one rule with the same
predicate in its clause head. Now uniﬁcation is attempted between the query and each
of the complementary literals in the input data in order of occurrence. If one of the
alternatives fails, this results in backtracking to the last branching point, and the next
alternative is tested. Because uniﬁcation fails with every fact, the query is uniﬁed
with the recursive rule in line 8. Now the system attempts to solve the subgoal
child(eve,anne,oscar), which succeeds with the third alternative. The query
?- descendant(X,Y).
X = oscar
Y = karen
Yes
is answered with the ﬁrst solution found, as is
?- descendant(clyde,Y).
Y = mary
Yes
The query
?- descendant(clyde,karen).
is not answered, however. The reason for this is the clause in line 8, which speciﬁes
symmetry of the child predicate. This clause calls itself recursively without the
possibility of termination. This problem can be solved with the following new
program (facts have been omitted here).
1 descendant(X,Y) :- child(X,Y,Z).
2 descendant(X,Y) :- child(X,Z,Y).
3 descendant(X,Y) :- child(X,U,V), descendant(U,Y).
But now the query
?- child(eve,oscar,anne).
5.2
Simple Examples
77

is no longer correctly answered because the symmetry of child in the last two
variables is no longer given. A solution to both problems is found in the program
1 child_fact(oscar,karen,franz).
2 child_fact(mary,karen,franz).
3 child_fact(eva,anne,oscar).
4 child_fact(henry,anne,oscar).
5 child_fact(isolde,anne,oscar).
6 child_fact(clyde,mary,oscarb).
7
8 child(X,Z,Y) :- child_fact(X,Y,Z).
9 child(X,Z,Y) :- child_fact(X,Z,Y).
10
11 descendant(X,Y) :- child(X,Y,Z).
12 descendant(X,Y) :- child(X,U,V), descendant(U,Y).
By introducing the new predicate child_fact for the facts, the predicate child
is no longer recursive. However, the program is no longer as elegant and simple as
the—logically correct—ﬁrst variant in Fig. 5.1 on page 76, which leads to the
inﬁnite loop. The PROLOG programmer must, just as in other languages, pay
attention to processing and avoid inﬁnite loops. PROLOG is just a programming
language and not a theorem prover.
We must distinguish here between declarative and procedural semantics of
PROLOG programs. The declarative semantics is given by the logical interpretation
of the horn clauses. The procedural semantics, in contrast, is deﬁned by the exe-
cution of the PROLOG program, which we wish to observe in more detail now. The
execution of the program from Fig. 5.1 on page 76 with the query child(eve,
oscar,anne) is represented in Fig. 5.2 as a search tree.1 Execution begins at the
top left with the query. Each edge represents a possible SLD resolution step with a
complementary uniﬁable literal. While the search tree becomes inﬁnitely deep by
the recursive rule, the PROLOG execution terminates because the facts occur
before the rule in the input data.
Fig. 5.2 PROLOG search tree for child(eve,oscar,anne)
1The constants have been abbreviated to save space.
78
5
Logic Programming with PROLOG

With the query descendant(clyde,karen), in contrast, the PROLOG
execution does not terminate. We can see this clearly in the and-or tree pre-
sented
in
Fig. 5.3.
In
this
representation
the
branches,
represented
by
, lead from the head of a clause to the subgoals. Because all subgoals of a
clause must be solved, these are and branches. All other branches are or branches,
of which at least one must be uniﬁable with its parent nodes. The two outlined facts
represent the solution to the query. The PROLOG interpreter does not terminate
here, however, because it works by using a depth-ﬁrst search with backtracking (see
Sect. 6.2.2) and thus ﬁrst chooses the inﬁnitely deep path to the far left.
5.3
Execution Control and Procedural Elements
As we have seen in the family relationship example, it is important to control the
execution of PROLOG. Avoiding unnecessary backtracking especially can lead to
large increases in efﬁciency. One means to this end is the cut. By inserting an
exclamation mark into a clause, we can prevent backtracking over this point. In the
following program, the predicate max(X,Y,Max) computes the maximum of the
two numbers X and Y.
1 max(X,Y,X) :- X >= Y.
2 max(X,Y,Y) :- X < Y.
If the ﬁrst case (ﬁrst clause) applies, then the second will not be reached. On the
other hand, if the ﬁrst case does not apply, then the condition of the second case is
true, which means that it does not need to be checked. For example, in the query
Fig. 5.3 And-or tree for desc(clyde,karen)
5.2
Simple Examples
79

?- max(3,2,Z), Z > 10.
backtracking is employed because Z = 3, and the second clause is tested for max,
which is doomed to failure. Thus backtracking over this spot is unnecessary. We
can optimize this with a cut:
1 max(X,Y,X) :- X >= Y, !.
2 max(X,Y,Y).
Thus the second clause is only called if it is really necessary, that is, if the
ﬁrst clause fails. However, this optimization makes the program harder to
understand.
Another possibility for execution control is the built-in predicate fail, which is
never true. In the family relationship example we can quite simply print out all
children and their parents with the query
?- child\_fact(X,Y,Z), write(X), write(’ is a child of ’),
write(Y), write(’ and ’), write(Z), write(’.’), nl, fail.
The corresponding output is
oscar is a child of karen and frank.
mary is a child of karen and frank.
eve is a child of anne and oscar.
...
No.
where the predicate nl causes a line break in the output. What would be the output
in the end without use of the fail predicate?
With the same knowledge base, the query “?- child_fact(ulla,X,Y).”
would result in the answer No because there are no facts about ulla. This answer
is not logically correct. Speciﬁcally, it is not possible to prove that there is no object
with the name ulla. Here the prover E would correctly answer “No proof
found.” Thus if PROLOG answers No, this only means that the query Q cannot
be proved. For this, however, ¬Q must not necessarily be proved. This behavior is
called negation as failure.
Restricting ourselves to Horn clauses does not cause a big problem in most
cases. However, it is important for procedural execution using SLD-resolution
(Sect. 2.5). Through the singly determined positive literal per clause, SLD
resolution, and therefore the execution of PROLOG programs, have a unique
entry point into the clause. This is the only way it is possible to have repro-
ducible execution of logic programs and, therefore, well-deﬁned procedural
semantics.
Indeed, there are certainly problem statements which cannot be described by
Horn clauses. An example is Russell’s paradox from Example 3.7 on page 54,
which contains the non-Horn clause (shaves(barber, X) _ shaves(X, X)).
80
5
Logic Programming with PROLOG

5.4
Lists
As a high-level language, PROLOG has, like the language LISP, the convenient
generic list data type. A list with the elements A, 2, 2, B, 3, 4, 5 has the form
[A,2,2,B,3,4,5]
The construct [Head|Tail] separates the ﬁrst element (Head) from the rest
(Tail) of the list. With the knowledge base
list([A,2,2,B,3,4,5]).
PROLOG displays the dialog
?- list([H|T]).
H = A
T = [2, 2, B, 3, 4, 5]
Yes
By using nested lists, we can create arbitrary tree structures. For example, the two
trees
•
b
c
and
a
b
c
can be represented by the lists [b,c] and [a,b,c], respectively, and the two trees
•
•
•
d
e
f
g
h
and
a
b
c
d
e
f
g
h
by the lists [[e,f,g],[h],d] and [a,[b,e,f,g],[c,h],d], respec-
tively. In the trees where the inner nodes contain symbols, the symbol is the head of
the list and the child nodes are the tail.
A nice, elegant example of list processing is the deﬁnition of the predicate
append(X,Y,Z) for appending list Y to the list X. The result is saved in Z. The
corresponding PROLOG program reads
1 append([],L,L).
2 append([X|L1],L2,[X|L3]) :- append(L1,L2,L3).
This is a declarative (recursive) logical description of the fact that L3 results from
appending L2 to L1. At the same time, however, this program also does the work
when it is called. The call
?- append([a,b,c],[d,1,2],Z).
5.4
Lists
81

returns the substitution Z = [a, b, c, d, 1, 2], just as the call
?- append(X,[1,2,3],[4,5,6,1,2,3]).
yields the substitution X = [4, 5, 6]. Here we observe that append is not a
two-place function, but a three-place relationship. Actually, we can also input the
“output parameter” Z and ask whether it can be created.
Reversing the order of a list’s elements can also be elegantly described and
simultaneously programmed by the recursive predicate
1 nrev([],[]).
2 nrev([H|T],R) :- nrev(T,RT), append(RT,[H],R).
which reduces the reversal of a list down to the reversal of a list that is one element
smaller. Indeed, this predicate is very inefﬁcient due to calling append. This
program is known as naive reverse and is often used as a PROLOG benchmark (see
Exercise 5.6 on page 89). Things go better when one proceeds using a temporary
store, known as the accumulator, as follows:
The corresponding PROLOG program reads
1 accrev([],A,A).
2 accrev([H|T],A,R) :- accrev(T,[H|A],R).
5.5
Self-modifying Programs
PROLOG programs are not fully compiled, rather, they are interpreted by the
WAM. Therefore it is possible to modify programs at runtime. A program can even
modify itself. With commands such as assert and retract, facts and rules can
be added to the knowledge base or taken out of it.
A simple application of the variant asserta is the addition of derived facts to
the beginning of the knowledge base with the goal of avoiding a repeated, poten-
tially time-expensive derivation (see Exercise 5.8 on page 89). If in our family
relationship example we replace the two rules for the predicate descendant with
List
Accumulator
[a,b,c,d]
[]
[b,c,d]
[a]
[c,d]
[b,a]
[d]
[c,b,a]
[]
[d,c,b,a]
82
5
Logic Programming with PROLOG

1 :- dynamic descendant/2.
2 descendant(X,Y) :- child(X,Y,Z), asserta(descendant(X,Y)).
3 descendant(X,Y) :- child(X,U,V), descendant(U,Y),
4          
asserta(descendant(X,Y)).
then all derived facts for this predicate are saved in the knowledge base and thus in
the future are not re-derived. The query
?- descendant(clyde, karen).
leads to the addition of the two facts
descendant(clyde, karen).
descendant(mary, karen).
By manipulating rules with assert and retract, even programs that change
themselves completely can be written. This idea became known under the term
genetic programming. It allows the construction of arbitrarily ﬂexible learning
programs. In practice, however, it turns out that, due to the huge number of
senseless possible changes, changing the code by trial and error rarely leads to a
performance increase. Systematic changing of rules, on the other hand, makes
programming so much more complex that, so far, such programs that extensively
modify their own code have not been successful. In Chap. 8 we will show how
machine learning has been quite successful. However, only very limited modiﬁ-
cations of the program code are being conducted here.
5.6
A Planning Example
Example 5.1 The following riddle serves as a problem statement for a typical
PROLOG program.
A farmer wants to bring a cabbage, a goat, and a wolf across a river, but his boat is so small
that he can only take them across one at a time. The farmer thought it over and then said to
himself: “If I ﬁrst bring the wolf to the other side, then the goat will eat the cabbage. If I
transport the cabbage ﬁrst, then the goat will be eaten by the wolf. What should I do?”
This is a planning task which we can quickly solve with a bit of thought.
The PROLOG program given in Fig. 5.4 on page 84 is not created quite as fast.
The program works on terms of the form state(Farmer,Wolf,Goat,
Cabbage), which describe the current state of the world. The four variables with
possible values left, right give the location of the objects. The central
5.5
Self-modifying Programs
83

recursive predicate plan ﬁrst creates a successor state Next using go, tests its
safety with safe, and repeats this recursively until the start and goal states are
the same (in program line 15). The states which have already been visited are
stored in the third argument of plan. With the built-in predicate member it
is tested whether the state Next has already been visited. If yes, it is not
attempted.
The deﬁnition of the predicate write_path for the task of outputting the plan
found is missing here. It is suggested as an exercise for the reader (Exercise 5.2 on
page 88). For initial program tests the literal write_path(Path) can be
replaced with write(Path). For the query “?- start.” we get the answer
Solution:
Farmer and goat from left to right
Farmer from right to left
Farmer and wolf from left to right
Farmer and goat from right to left
Farmer and cabbage from left to right
Farmer from right to left
Farmer and goat from left to right
Yes
1 start :- action(state(left,left,left,left),
.
)
)
t
h
g
i
r
,
t
h
g
i
r
,
t
h
g
i
r
,
t
h
g
i
r
(
e
t
a
t
s
2
3
4 action(Start,Goal):-
5
plan(Start,Goal,[Start],Path),
6
nl,write(’Solution:’),nl,
7
write_path(Path).
8 %
write_path(Path), fail.
% all solutions output
9
10 plan(Start,Goal,Visited,Path):-
11
go(Start,Next),
12
safe(Next),
13
\+ member(Next,Visited),
% not(member(...))
14
plan(Next,Goal,[Next|Visited],Path).
15 plan(Goal,Goal,Path,Path).
16
17 go(state(X,X,Z,K),state(Y,Y,Z,K)):-across(X,Y). % farmer, wolf
18 go(state(X,W,X,K),state(Y,W,Y,K)):-across(X,Y). % farmer, goat
19 go(state(X,W,Z,X),state(Y,W,Z,Y)):-across(X,Y). % farmer, cabbage
20 go(state(X,W,Z,K),state(Y,W,Z,K)):-across(X,Y). % farmer
21
22 across(left,right).
23 across(right,left).
24
25 safe(state(B,W,Z,K)):- across(W,Z), across(Z,K).
26 safe(state(B,B,B,K)).
27 safe(state(B,W,B,B)).
Fig. 5.4 PROLOG program for the farmer–wolf–goat–cabbage problem
84
5
Logic Programming with PROLOG

For better understanding we describe the deﬁnition of plan in logic:
8z planðz; zÞ ^ 8s 8z 8n ½goðs; nÞ ^ safeðnÞ ^ planðn; zÞ ) planðs; zÞ
This deﬁnition comes out signiﬁcantly more concise than in PROLOG. There are
two reasons for this. For one thing, the output of the discovered plan is unimportant
for logic. Furthermore, it is not really necessary to check whether the next state
was already visited if unnecessary trips do not bother the farmer. If, however,
\+ member(...) is left out of the PROLOG program, then there is an inﬁnite
loop and PROLOG might not ﬁnd a schedule even if there is one. The cause of this
is PROLOG’s backward chaining search strategy, which, according to the
depth-ﬁrst search (Sect. 6.2.2) principle, always works on subgoals one at a time
without restricting recursion depth, and is therefore incomplete. This would not
happen to a theorem prover with a complete calculus.
As in all planning tasks, the state of the world changes as actions are carried out
from one step to the next. This suggests sending the state as a variable to all
predicates that depend on the state of the world, such as in the predicate safe. The
state transitions occur in the predicate go. This approach is called situation cal-
culus [RN10]. We will become familiar with an interesting extension to learning
action sequences in partially observable, non-deterministic worlds in Chap. 10.
Predicate logic and simpler sub-languages for the description and solution of
planning tasks play an increasingly important role for intelligent robots. To solve
complex tasks, robots often work on symbolic relational descriptions of the world. The
classic application for a service robot is recognizing an audible command linguisti-
cally and then converting it into a logical formula. Then a planner has the task of
ﬁnding a plan which eventually reaches a state in which the formula becomes true.
Even more interesting is when the robot learns to meet the goals of its trainer by
observing them and then use the symbolic planner to achieve the goals [CEP15b]. One
very exciting thing about this is that the robot is able to take numerical sensor values
such as pixel images and turn them into a symbolic description of situations. This
generally very difﬁcult task is known in AI as symbol grounding. Robotics developers
have found interesting solutions to this problem for certain tasks [CEP15a].
5.7
Constraint Logic Programming
The programming of scheduling systems, in which many (sometimes complex)
logical and numerical conditions must be fulﬁlled, can be very expensive and
difﬁcult with conventional programming languages. This is precisely where logic
could be useful. One simply writes all logical conditions in PL1 and then enters a
query. Usually this approach fails miserably. The reason is the penguin problem
discussed in Sect. 4.3. The fact penguin(tweety) does ensure that penguin
(tweety) is true. However, it does not rule out that raven(tweety) is also
true. To rule this out with additional axioms is very inconvenient (Sect. 4.3).
5.6
A Planning Example
85

Constraint Logic Programming (CLP), which allows the explicit formulation of
constraints for variables, offers an elegant and very efﬁcient mechanism for solving
this problem. The interpreter constantly monitors the execution of the program for
adherence to all of its constraints. The programmer is fully relieved of the task of
controlling the constraints, which in many cases can greatly simplify programming.
This is expressed in the following quotation by Eugene C. Freuder from [Fre97]:
Constraint programming represents one of the closest approaches computer science has yet
made to the Holy Grail of programming: the user states the problem, the computer solves it.
Without going into the theory of the constraint satisfaction problem (CSP), we will
apply the CLP mechanism of GNU-PROLOG to the following example.
Example 5.2 The secretary of Albert Einstein High School has to come up with a
plan for allocating rooms for ﬁnal exams. He has the following information: the
four teachers Mayer, Hoover, Miller and Smith give tests for the subjects German,
English, Math, and Physics in the ascendingly numbered rooms 1, 2, 3 and 4. Every
teacher gives a test for exactly one subject in exactly one room. Besides that, he
knows the following about the teachers and their subjects.
1. Mr. Mayer never tests in room 4.
2. Mr. Miller always tests German.
3. Mr. Smith and Mr. Miller do not give tests in neighboring rooms.
4. Mrs. Hoover tests Mathematics.
5. Physics is always tested in room number 4.
6. German and English are not tested in room 1.
Who gives a test in which room?
A GNU-PROLOG program for solving this problem is given in Fig. 5.5. This
program works with the variables Mayer,Hoover,Miller,Smith as well as
1 start :-
2
fd_domain([Mayer, Hoover, Miller, Smith],1,4),
3
fd_all_different([Mayer, Miller, Hoover, Smith]),
4
5
fd_domain([German, English, Math, Physics],1,4),
6
fd_all_different([German, English, Math, Physics]),
7
8
fd_labeling([Mayer, Hoover, Miller, Smith]),
9
4
m
o
o
r
n
i
t
o
n
r
e
y
a
M
%
,
4
=
\
#
r
e
y
a
M
0
1
11
Miller #= German,
% Miller tests German
12
dist(Miller,Smith) #>= 2,
% Distance Miller/Smith >= 2
13
Hoover #= Math,
% Hoover tests mathematics
14
Physics #= 4,
% Physics in room 4
15
German #\=1,
% German not in room 1
16
English #\=1,
% English not in room 1
17
nl,
18
write([Mayer, Hoover, Miller, Smith]), nl,
19
write([German, English, Math, Physics]), nl.
Fig. 5.5 CLP program for the room scheduling problem
86
5
Logic Programming with PROLOG

German,English,Math,Physics, which can each take on an integer value
from 1 to 4 as the room number (program lines 2 and 5). A binding Mayer = 1
and German = 1 means that Mr. Mayer gives the German test in room 1. Lines 3
and 6 ensure that the four particular variables take on different values. Line 8
ensures that all variables are assigned a concrete value in the case of a solution.
This line is not absolutely necessary here. If there were multiple solutions,
however, only intervals would be output. In lines 10 to 16 the constraints are
given, and the remaining lines output the room numbers for all teachers and all
subjects in a simple format.
The program is loaded into GNU-PROLOG with “[′raumplan.pl′].”, and
with “start.” we obtain the output
[3,1,2,4]
[2,3,1,4]
Represented somewhat more conveniently, we have the following room schedule:
GNU-PROLOG has, like most other CLP languages, a so-called ﬁnite domain
constraint solver, with which variables can be assigned a ﬁnite range of integers.
This need not necessarily be an interval as in the example. We can also input a list
of values. As an exercise the user is invited, in Exercise 5.9 on page 89, to create a
CLP program, for example with GNU-PROLOG, for a not-so-simple logic puzzle.
This puzzle, supposedly created by Einstein, can very easily be solved with a CLP
system. If we tried using PROLOG without constraints, on the other hand, we could
easily grind our teeth out. Anyone who ﬁnds an elegant solution with PROLOG or a
prover, please let it ﬁnd its way to the author.
5.8
Summary
Uniﬁcation, lists, declarative programming, and the relational view of procedures,
in which an argument of a predicate can act as both input and output, allow the
development of short, elegant programs for many problems. Many programs would
be signiﬁcantly longer and thus more difﬁcult to understand if written in a proce-
dural language. Furthermore, these language features save the programmer time.
Therefore PROLOG is also an interesting tool for rapid prototyping, particularly for
AI applications. The CLP extension of PROLOG is helpful not only for logic
puzzles, but also for many optimization and scheduling tasks.
Room num.
1
2
3
4
Teacher
Hoover
Miller
Mayer
Smith
Subject
Math
German
English
Physics
5.7
Constraint Logic Programming
87

Since its invention in 1972, in Europe PROLOG has developed into one of
Europe’s leading programming languages in AI, along with procedural languages.
In the U.S., on the other hand, the natively invented language LISP dominates the
AI market.
PROLOG is not a theorem prover. This is intentional, because a programmer
must be able to easily and ﬂexibly control processing, and would not get very far
with a theorem prover. On the other hand, PROLOG is not very helpful on its own
for proving mathematical theorems. However, there are certainly interesting theo-
rem provers which are programmed in PROLOG.
Recommended as advanced literature are [Bra11] and [CM94], as well as the
handbooks [Wie04, Dia04] and, on the topic of CLP, [Bar98].
5.9
Exercises
Exercise 5.1 Try to prove the theorem from Sect. 3.7 about the equality of left- and
right-neutral elements of semi-groups with PROLOG. Which problems come up?
What is the cause of this?
Exercise 5.2
(a) Write a predicate write_move(+State1, +State2), that outputs a
sentence like “Farmer and wolf cross from left to right” for each boat crossing.
State1 and State2 are terms of the form state(Farmer, Wolf,
Goat, Cabbage).
(b) Write a recursive predicate write_path(+Path), which calls the predi-
cate write_move(+State1, +State2) and outputs all of the farmer’s
actions.
Exercise 5.3
(a) At ﬁrst glance the variable Path in the predicate plan of the PROLOG
program from Example 5.1 on page 83 is unnecessary because it is apparently
not changed anywhere. What is it needed for?
(b) If we add a fail to the end of action in the example, then all solutions will
be given as output. Why is every solution now printed twice? How can you
prevent this?
Exercise 5.4
(a) Show by testing out that the theorem prover E (in contrast to PROLOG),
given the knowledge base from Fig. 5.1 on page 76, answers the query
“?- descendant(clyde, karen).” correctly. Why is that?
(b) Compare the answers of PROLOG and E for the query “?- descendant
(X, Y).”.
Exercise 5.5 Write as short a PROLOG program as possible that outputs 1024 ones.
88
5
Logic Programming with PROLOG

❄Exercise 5.6 Investigate the runtime behavior of the naive reverse predicate.
(a) Run PROLOG with the trace option and observe the recursive calls of nrev,
append, and accrev.
(b) Compute the asymptotic time complexity of append(L1,L2,L3), that is,
the dependency of the running time on the length of the list for large lists.
Assume that access to the head of an arbitrary list takes constant time.
(c) Compute the time complexity of nrev(L,R).
(d) Compute the time complexity of accrev(L,R).
(e) Experimentally determine the time complexity of the predicates nrev,
append, and accrev, for example by carrying out time measurements
(time(+Goal) gives inferences and CPU time.).
Exercise 5.7 Use function symbols instead of lists to represent the trees given in
Sect. 5.4 on page 81.
❄Exercise 5.8 The Fibonacci sequence is deﬁned recursively by ﬁb(0) = 1, ﬁb(1) = 1
and ﬁb(n) = ﬁb(n −1) + ﬁb(n −2).
(a) Deﬁne a recursive PROLOG predicate fib(N,R) which calculates ﬁb(N) and
returns it in R.
(b) Determine the runtime complexity of the predicate fib theoretically and by
measurement.
(c) Change your program by using asserta such that unnecessary inferences
are no longer carried out.
(d) Determine the runtime complexity of the modiﬁed predicate theoretically and
by measurement (notice that this depends on whether fib was previously
called).
(e) Why is fib with asserta also faster when it is started for the ﬁrst time right
after PROLOG is started?
❄Exercise 5.9 The following typical logic puzzle was supposedly written by Albert
Einstein. Furthermore, he supposedly claimed that only 2% of the world’s
population is capable of solving it. The following statements are given.
• There are ﬁve houses, each painted a different color.
• Every house is occupied by a person with a different nationality.
• Every resident prefers a speciﬁc drink, smokes a speciﬁc brand of cigarette, and
has a speciﬁc pet.
• None of the ﬁve people drinks the same thing, smokes the same thing, or has the
same pet.
• Hints:
– The Briton lives in the red house.
– The Swede has a dog.
– The Dane likes to drink tea.
– The green house is to the left of the white house.
5.9
Exercises
89

– The owner of the green house drinks coffee.
– The person who smokes Pall Mall has a bird.
– The man who lives in the middle house drinks milk.
– The owner of the yellow house smokes Dunhill.
– The Norwegian lives in the ﬁrst house.
– The Marlboro smoker lives next to the one who has a cat.
– The man with the horse lives next to the one who smokes Dunhill.
– The Winﬁeld smoker likes to drink beer.
– The Norwegian lives next to the blue house.
– The German smokes Rothmanns.
– The Marlboro smoker has a neighbor who drinks water.
Question: To whom does the ﬁsh belong?
(a) First solve the puzzle manually.
(b) Write a CLP program (for example with GNU-PROLOG) to solve the puzzle.
Orient yourself with the room scheduling problem in Fig. 5.5 on page 86.
90
5
Logic Programming with PROLOG

6
Search, Games and Problem Solving
6.1
Introduction
The search for a solution in an extremely large search tree presents a problem for
nearly all inference systems. From the starting state there are many possibilities for
the ﬁrst inference step. For each of these possibilities there are again many possi-
bilities in the next step, and so on. Even in the proof of a very simple formula from
[Ert93] with three Horn clauses, each with at most three literals, the search tree for
SLD resolution has the following shape:
The tree was cut off at a depth of 14 and has a solution in the leaf node marked
by . It is only possible to represent it at all because of the small branching factor of
at most two and a cutoff at depth 14. For realistic problems, the branching factor
and depth of the ﬁrst solution may become signiﬁcantly bigger.
Assume the branching factor is a constant equal to 30 and the ﬁrst solution is at
depth 50. The search tree has 3050  7.2  1073 leaf nodes. But the number of
inference steps is even bigger because not only every leaf node, but also every inner
node of the tree corresponds to an inference step. Therefore we must add up the
nodes over all levels and obtain the total number of nodes of the search tree
X
50
d¼0
30d ¼ 1  3051
1  30 ¼ 7:4  1073;
which does not change the node count by much. Evidently, nearly all of the nodes
of this search tree are on the last level. As we will see, this is generally the case. But
now back to the search tree with the 7.4  1073 nodes. Assume we had 10,000
© Springer International Publishing AG 2017
W. Ertel, Introduction to Artificial Intelligence, Undergraduate Topics
in Computer Science, DOI 10.1007/978-3-319-58487-4_6
91

computers which can each perform a billion inferences per second, and that we
could distribute the work over all of the computers with no cost. The total com-
putation time for all 7.4  1073 inferences would be approximately equal to
7:4  1073 inferences
10000  109 inferences=sec ¼ 7:4  1060 sec  2:3  1053 years;
which is about 1043 times as much time as the age of our universe. By this simple
thought exercise, we can quickly recognize that there is no realistic chance of
searching this kind of search space completely with the means available to us in this
world. Moreover, the assumptions related to the size of the search space were
completely realistic. In chess for example, there are over 30 possible moves for a
typical situation, and a game lasting 50 half-turns is relatively short.
How can it be then, that there are good chess players—and these days also good
chess computers? How can it be that mathematicians ﬁnd proofs for theorems in
which the search space is even much bigger? Evidently we humans use intelligent
strategies which dramatically reduce the search space. The experienced chess player,
just like the experienced mathematician, will, by mere observation of the situation,
immediately rule out many actions as senseless. Through his experience, he has the
ability to evaluate various actions for their utility in reaching the goal. Often a person
will go by feel. If one asks a mathematician how he found a proof, he may answer that
the intuition came to him in a dream. In difﬁcult cases, many doctors ﬁnd a diagnosis
purely by feel, based on all known symptoms. Especially in difﬁcult situations, there
is often no formal theory for solution-ﬁnding that guarantees an optimal solution. In
everyday problems, such as the search for a runaway cat in Fig. 6.1 on page 93,
intuition plays a big role. We will deal with this kind of heuristic search method in
Sect. 6.3 and additionally describe processes with which computers can, similarly to
humans, improve their heuristic search strategies by learning.
First, however, we must understand how uninformed search, that is, blindly
trying out all possibilities, works. We begin with a few examples.
Example 6.1 With the 8-puzzle, a classic example for search algorithms [Nil98,
RN10], the various algorithms can be very visibly illustrated. Squares with the
numbers 1 to 8 are distributed in a 3  3 matrix like the one in Fig. 6.2 on page 93.
The goal is to reach a certain ordering of the squares, for example in ascending
order by rows as represented in Fig. 6.2 on page 93. In each step a square can be
moved left, right, up, or down into the empty space. The empty space therefore
moves in the corresponding opposite direction. For analysis of the search space, it is
convenient to always look at the possible movements of the empty ﬁeld.
The search tree for a starting state is represented in Fig. 6.3 on page 94. We can
see that the branching factor alternates between two, three, and four. Averaged over
two levels at a time, we obtain an average branching factor1 of
ﬃﬃﬃ
8
p
 2:83. We see
1The average branching factor of a tree is the branching factor that a tree with a constant branching
factor, equal depth, and an equal amount of leaf nodes would have.
92
6
Search, Games and Problem Solving

Fig. 6.1 A heavily trimmed search tree—or: “Where is my cat?”
Fig. 6.2 Possible starting
and goal states of the 8-puzzle
6.1
Introduction
93

that each state is repeated multiple times two levels deeper because in a simple
uninformed search, every action can be reversed in the next step.
If we disallow cycles of length 2, then for the same starting state we obtain the
search tree represented in Fig. 6.4. The average branching factor is reduced by
about 1 and becomes 1.8.2
Before we begin describing the search algorithms, a few new terms are needed.
We are dealing with discrete search problems here. Being in state s, an action a1
leads to a new state s′. Thus s′ = a1(s). A different action may lead to state s″, in
Fig. 6.3 Search tree for the 8-puzzle. Bottom right a goal state in depth 3 is represented. To save
space the other nodes at this level have been omitted
Fig. 6.4 Search tree for an 8-puzzle without cycles of length 2
2For an 8-puzzle the average branching factor depends on the starting state (see Exercise 6.2 on
page 122).
94
6
Search, Games and Problem Solving

other words: s″ = a2(s). Recursive application of all possible actions to all states,
beginning with the starting state, yields the search tree.
Deﬁnition 6.1 A search problem is deﬁned by the following values
State: Description of the state of the world in which the search agent ﬁnds
itself.
Starting state: The initial state in which the search agent is started.
Goal state: If the agent reaches a goal state, then it terminates and outputs a
solution (if desired).
Actions: All of the agents allowed actions.
Solution: The path in the search tree from the starting state to the goal state.
Cost function: Assigns a cost value to every action. Necessary for ﬁnding a
cost-optimal solution.
State space: Set of all states.
Applied to the 8-puzzle, we get
State: 3  3 matrix S with the values 1, 2, 3, 4, 5, 6, 7, 8 (once each) and one
empty square.
Starting state: An arbitrary state.
Goal state: An arbitrary state, e.g. the state given to the right in Fig. 6.2 on page 93.
Actions: Movement of the empty square Sij to the left (if j 6¼ 1), right (if j 6¼ 3),
up (if i 6¼ 1), down (if i 6¼ 3).
Cost function: The constant function 1, since all actions have equal cost.
State space: The state space is degenerate in domains that are mutually unreachable
(Exercise 6.4 on page 122). Thus there are unsolvable 8-puzzle problems.
For analysis of the search algorithms, the following terms are needed:
Deﬁnition 6.2
• The number of successor states of a state s is called the branching factor
b(s), or b if the branching factor is constant.
• The effective branching factor of a tree of depth d with n total nodes is
deﬁned as the branching factor that a tree with constant branching factor,
equal depth, and equal n would have (see Exercise 6.3 on page 122).
• A search algorithm is called complete if it ﬁnds a solution for every
solvable problem. If a complete search algorithm terminates without
ﬁnding a solution, then the problem is unsolvable.
For a given depth d and node count n, the effective branching factor can be
calculated by solving the equation
6.1
Introduction
95

n ¼ bd þ 1  1
b  1
ð6:1Þ
for b because a tree with constant branching factor and depth d has a total of
n ¼
X
d
i¼0
bi ¼ bd þ 1  1
b  1
ð6:2Þ
nodes.
For the practical application of search algorithms for ﬁnite search trees, the last
level is especially important because
Theorem 6.1 For heavily branching ﬁnite search trees with a large constant
branching factor, almost all nodes are on the last level.
The simple proof of this theorem is recommended to the reader as an exercise
(Exercise 6.1 on page 122).
Example 6.2 We are given a map, such as the one represented in Fig. 6.5, as a
graph with cities as nodes and highway connections between the cities as weighted
edges with distances. We are looking for an optimal route from city A to city B. The
description of the corresponding schema reads
State: A city as the current location of the traveler.
Starting state: An arbitrary city.
Goal state: An arbitrary city.
Actions: Travel from the current city to a neighboring city.
Cost function: The distance between the cities. Each action corresponds to an edge
in the graph with the distance as the weight.
Fig. 6.5 The graph of southern Germany as an example of a search task with a cost function
96
6
Search, Games and Problem Solving

State space: All cities, that is, nodes of the graph.
To ﬁnd the route with minimal length, the costs must be taken into account because
they are not constant as they were in the 8-puzzle.
Deﬁnition 6.3 A search algorithm is called optimal if it, if a solution exists,
always ﬁnds the solution with the lowest cost.
The 8-puzzle problem is deterministic, which means that every action leads from
a state to a unique successor state. It is furthermore observable, that is, the agent
always knows which state it is in. In route planning in real applications both
characteristics are not always given. The action “Drive from Munich to
Ulm” may—for example because of an accident—lead to the successor state
“Munich”. It can also occur that the traveler no longer knows where he is because
he got lost. We want to ignore these kinds of complications at ﬁrst. Therefore in this
chapter we will only look at problems that are deterministic and observable.
Problems like the 8-puzzle, which are deterministic and observable, make action
planning relatively simple because, due to having an abstract model, it is possible to
ﬁnd action sequences for the solution of the problem without actually carrying out
the actions in the real world. In the case of the 8-puzzle, it is not necessary to
actually move the squares in the real world to ﬁnd the solution. We can ﬁnd optimal
solutions with so-called ofﬂine algorithms. One faces much different challenges
when, for example, building robots that are supposed to play soccer. Here there will
never be an exact abstract model of the actions. For example, a robot that kicks the
ball in a speciﬁc direction cannot predict with certainty where the ball will move
because, among other things, it does not know whether an opponent will catch or
deﬂect the ball. Here online algorithms are then needed, which make decisions
based on sensor signals in every situation. Reinforcement learning, described in
Chap. 10, works toward optimization of these decisions based on experience.
6.2
Uninformed Search
6.2.1
Breadth-First Search
In breadth-ﬁrst search, the search tree is explored from top to bottom according to
the algorithm given in Fig. 6.6 on page 98 until a solution is found. First every
node in the node list is tested for whether it is a goal node, and in the case of
success, the program is stopped. Otherwise all successors of the node are generated.
The search is then continued recursively on the list of all newly generated nodes.
The whole thing repeats until no more successors are generated.
This algorithm is generic. That is, it works for arbitrary applications if the two
application-speciﬁc functions “GoalReached” and “Successors” are provided.
6.1
Introduction
97

“GoalReached” calculates whether the argument is a goal node, and “Successors”
calculates the list of all successor nodes of its argument. Figure 6.7 shows a
snapshot of breadth-ﬁrst search.
Analysis
Since breadth-ﬁrst search completely searches through every depth and
reaches every depth in ﬁnite time, it is complete if the branching factor b is ﬁnite.
The optimal (that is, the shortest) solution is found if the costs of all actions are the
same (see Exercise 6.7 on page 123). Computation time and memory space grow
exponentially with the depth of the tree. For a tree with constant branching factor
b and depth d, the total compute time is thus given by
c 
X
d
i¼0
bi ¼ bd þ 1  1
b  1
¼ OðbdÞ:
Although only the last level is saved in memory, the memory space requirement is
also O(bd).
BREADTHFIRSTSEARCH(NodeList, Goal)
NewNodes H ;
For all Node
NodeList
If GoalReached(Node, Goal)
Return(“Solution found”, Node)
NewNodes H Append(NewNodes, Successors(Node))
If NewNodes
Return(BREADTH-FIRST-SEARCH(NewNodes, Goal))
Else
Return(“No solution”)
2
Fig. 6.6 The algorithm for breadth-ﬁrst search
Fig. 6.7 Breadth-ﬁrst search during the expansion of the third-level nodes. The nodes are
numbered according to the order they were generated. The successors of nodes 11 and 12 have not
yet been generated
98
6
Search, Games and Problem Solving

With the speed of today’s computers, which can generate billions of nodes
within minutes, main memory quickly ﬁlls up and the search ends. The problem of
the shortest solution not always being found can be solved by the so-called Uniform
Cost Search, in which the node with the lowest cost from the list of nodes (which is
sorted ascendingly by cost) is always expanded, and the new nodes sorted in. Thus
we ﬁnd the optimal solution. The memory problem is not yet solved, however.
A solution for this problem is provided by depth-ﬁrst search.
6.2.2
Depth-First Search
In depth-ﬁrst search only a few nodes are stored in memory at one time. After the
expansion of a node only its successors are saved, and the ﬁrst successor node is
immediately expanded. Thus the search quickly becomes very deep. Only when a
node has no successors and the search fails at that depth is the next open node
expanded via backtracking to the last branch, and so on. We can best perceive this
in the elegant recursive algorithm in Fig. 6.8 and in the search tree in Fig. 6.9 on
page 100.
Analysis
Depth-ﬁrst search requires much less memory than breadth-ﬁrst search
because at most b nodes are saved at each depth. Thus we need at most b ⋅d memory
cells.
However, depth-ﬁrst search is not complete for inﬁnitely deep trees because
depth-ﬁrst search runs into an inﬁnite loop when there is no solution in the far left
branch. Therefore the question ofﬁnding the optimal solution is obsolete. Because of
the inﬁnite loop, no bound on the computation time can be given. In the case of a
ﬁnitely deep search tree with depth d, a total of about bd nodes are generated. Thus
the computation time grows, just as in breadth-ﬁrst search, exponentially with depth.
We can make the search tree ﬁnite by setting a depth limit. Now if no solution is
found in the pruned search tree, there can nonetheless be solutions outside the limit.
DEPTHFIRSTSEARCH(Node, Goal)
If GoalReached(Node, Goal) Return(“Solution found”)
NewNodes D Successors(Node)
While NewNodes
Result = DEPTH-FIRST-SEARCH(First(NewNodes), Goal)
If Result = “Solution found” Return(“Solution found”)
NewNodes = Rest(NewNodes)
Return(“No solution”)
Fig. 6.8 The algorithm for depth-ﬁrst search. The function “First” returns the ﬁrst element of a
list, and “Rest” the rest of the list
6.2
Uninformed Search
99

Thus the search becomes incomplete. There are obvious ideas, however, for getting
the search to completeness.
6.2.3
Iterative Deepening
We begin the depth-ﬁrst search with a depth limit of 1. If no solution is found, we
raise the limit by 1 and start searching from the beginning, and so on, as shown in
Fig. 6.10. This iterative raising of the depth limit is called iterative deepening.
We must augment the depth-ﬁrst search program given in Fig. 6.8 on page 99
with the two additional parameters “Depth” and “Limit”. “Depth” is raised by one
at the recursive call, and the head line of the while loop is replaced by “While
NewNodes 6¼ ; And Depth < Limit”. The modiﬁed algorithm is represented in
Fig. 6.11 on page 101.
Analysis
The memory requirement is the same as in depth-ﬁrst search. One could
argue that repeatedly re-starting depth-ﬁrst search at depth zero causes a lot of
redundant work. For large branching factors this is not the case. We now show that
Fig. 6.9 Execution of depth-ﬁrst search. All nodes at depth three are unsuccessful and cause
backtracking. The nodes are numbered in the order they were generated
Fig. 6.10 Schematic representation of the development of the search tree in iterative deepening
with limits from 1 to 7. The breadth of the tree corresponds to a branching factor of 2
100
6
Search, Games and Problem Solving

the sum of the number of nodes of all depths up to the one before last dmax −1
in all trees searched is much smaller than the number of nodes in the last tree
searched.
Let Nb(d) be the number of nodes of a search tree with branching factor b and
depth d and dmax be the last depth searched. The last tree searched contains
NbðdmaxÞ ¼
X
dmax
i¼0
bi ¼ bdmax þ 1  1
b  1
nodes. All trees searched beforehand together have
X
dmax1
d¼1
NbðdÞ ¼
X
dmax1
d¼1
bd þ 1  1
b  1
¼
1
b  1
X
dmax1
d¼1
bd þ 1
 
!
 dmax þ 1
 
!
¼
1
b  1
X
dmax
d¼2
bd
 
!
 dmax þ 1
 
!
¼
1
b  1
bdmax þ 1  1
b  1
 1  b  dmax þ 1



1
b  1
bdmax þ 1  1
b  1


¼
1
b  1 NbðdmaxÞ
ITERATIVEDEEPENING(Node, Goal)
DepthLimit = 0
Repeat
Result = DEPTHFIRSTSEARCH-B(Node, Goal, 0, DepthLimit)
DepthLimit = DepthLimit + 1
Until Result = “Solution found”
DEPTHFIRSTSEARCH-B(Node, Goal, Depth, Limit)
If GoalReached(Node, Goal) Return(“Solution found”)
NewNodes = Successors(Node)
While NewNodes
And Depth < Limit
Result =
DEPTHFIRSTSEARCH-B(First(NewNodes), Goal, Depth + 1, Limit)
If Result = “Solution found” Return(“Solution found”)
NewNodes = Rest(NewNodes)
Return(“No solution”)
Fig. 6.11 The algorithm for iterative deepening, which calls the slightly modiﬁed depth-ﬁrst
search with a depth limit (TIEFENSUCHE-B)
6.2
Uninformed Search
101

nodes. For b > 2 this is less than the number Nb(dmax) of nodes in the last tree. For
b = 20 the ﬁrst dmax −1 trees together contain only about
1
b1 ¼ 1=19 of the number of
nodes in the last tree. The computation time for all iterations besides the last
can be ignored.
Just like breadth-ﬁrst search, this method is complete, and given a constant cost
for all actions, it ﬁnds the shortest solution.
6.2.4
Comparison
The described search algorithms have been put side-by-side in Table 6.1.
We can clearly see that iterative deepening is the winner of this test because it
gets the best grade in all categories. In fact, of all four algorithms presented it is the
only practically usable one.
We do indeed have a winner for this test, although for realistic applications it is
usually not successful. Even for the 15-puzzle, the 8-puzzle’s big brother (see
Exercise 6.4 on page 122), there are about 2  1013 different states. For non-trivial
inference systems the state space is many orders of magnitude bigger. As shown in
Sect. 6.1, all the computing power in the world will not help much more. Instead
what is needed is an intelligent search that only explores a tiny fraction of the search
space and ﬁnds a solution there.
6.2.5
Cycle Check
As shown in Sect. 6.1, nodes may be repeatedly visited during a search. In the
8-puzzle, for example, every move can be immediately undone, which leads to
unnecessary cycles of length two. Such cycles can be prevented by recording within
each node all of its predecessors and, when expanding a node, comparing the newly
created successor nodes with the predecessor nodes. All of the duplicates found can
be removed from the list of successor nodes. This simple check costs only a small
constant factor of additional memory space and increases the constant computation
time c by an additional constant d for the check itself for a total of c þ d. This
overhead for the cycle check is (hopefully) offset by a reduction in the cost of the
Table 6.1 Comparison of the uninformed search algorithms. (*) means that the statement is only
true given a constant action cost. ds is the maximal depth for a ﬁnite search tree
Breadth-ﬁrst
search
Uniform cost
search
Depth-ﬁrst
search
Iterative
deepening
Completeness
Yes
Yes
No
Yes
Optimal solution
Yes (*)
Yes
No
Yes (*)
Computation time
bd
bd
1 or bd
bd
Memory use
bd
bd
bd
bd
102
6
Search, Games and Problem Solving

search. The reduction depends, of course, on the particular application and therefore
cannot be given in general terms.
For the 8-puzzle we obtain the result as follows. If, for example, during
breadth-ﬁrst search with effective branching factor b on a ﬁnite tree of depth d, the
computation time without the cycle check is c  bd, the required time with the cycle
check becomes
ðc þ dÞ  ðb  1Þd:
The check thus practically always results in a clear gain because reducing the branching
factor by one has an exponentially growing effect as the depth increases, whereas the
additional computation time d only somewhat increases the constant factor.
Now the question arises as to how a check on cycles of arbitrary length would
affect the search performance. The list of all predecessors must now be stored for each
node, which can be done very efﬁciently (see Exercise 6.8 on page 123). During the
search, each newly created node must now be compared with all its predecessors. The
computation time of depth-ﬁrst search or breadth-ﬁrst search is given by
c1 
X
d
i¼0
bi þ c2 
X
d
i¼0
i  bi:
Here, the ﬁrst term is the already-known cost of generating the nodes, and the
second term is the cost of the cycle check. We can show that for large values of
b and d,
X
d
i¼0
i  bi  d  bd:
The complexity of the search with the full cycle check therefore only increases by a
factor of d faster than for the search without a cycle check. In search trees that are not
very deep, this extra complexity is not important. For search tasks with very deep,
weakly branching trees, it may be advantageous to use a hash table [CLR90] to store
the list of predecessors. Lookups in the table can be done in constant time such that
the computation time of the search algorithm only grows by a small constant factor.
In summary, we can conclude that the cycle check implies hardly any additional
overhead and is therefore worthwhile for applications with repeatedly occurring
nodes.
6.3
Heuristic Search
Heuristics are problem-solving strategies which in many cases ﬁnd a solution faster
than uninformed search. However, this is not guaranteed. Heuristic search could
require a lot more time and can even result in the solution not being found.
6.2
Uninformed Search
103

We humans successfully use heuristic processes for all kinds of things. When
buying vegetables at the supermarket, for example, we judge the various options for
a pound of strawberries using only a few simple criteria like price, appearance,
source of production, and trust in the seller, and then we decide on the best option
by gut feeling. It might theoretically be better to subject the strawberries to a basic
chemical analysis before deciding whether to buy them. For example, the straw-
berries might be poisoned. If that were the case the analysis would have been worth
the trouble. However, we do not carry out this kind of analysis because there is a
very high probability that our heuristic selection will succeed and will quickly get
us to our goal of eating tasty strawberries.
Heuristic decisions are closely linked with the need to make real-time decisions
with limited resources. In practice a good solution found quickly is preferred over a
solution that is optimal, but very expensive to derive.
A heuristic evaluation function f(s) for states is used to mathematically model a
heuristic. The goal is to ﬁnd, with little effort, a solution to the stated search
problem with minimal total cost. Please note that there is a subtle difference
between the effort to ﬁnd a solution and the total cost of this solution. For example
it may take Google Maps half a second’s worth of effort to ﬁnd a route from the
City Hall in San Francisco to Tuolumne Meadows in Yosemite National Park, but
the ride from San Francisco to Tuolumne Meadows by car may take four hours and
some money for gasoline etc. (total cost).
Next we will modify the breadth-ﬁrst search algorithm by adding the evaluation
function to it. The currently open nodes are no longer expanded left to right by row,
but rather according to their heuristic rating. From the set of open nodes, the node
with the minimal rating is always expanded ﬁrst. This is achieved by immediately
evaluating nodes as they are expanded and sorting them into the list of open nodes.
The list may then contain nodes from different depths in the tree.
Because heuristic evaluation of states is very important for the search, we will
differentiate from now on between states and their associated nodes. The node
contains the state and further information relevant to the search, such as its depth in
the search tree and the heuristic rating of the state. As a result, the function
“Successors”, which generates the successors (children) of a node, must also
immediately calculate for these successor nodes their heuristic ratings as a com-
ponent of each node. We deﬁne the general search algorithm HEURISTICSEARCH in
Fig. 6.12 on page 105.
The node list is initialized with the starting nodes. Then, in the loop, the ﬁrst
node from the list is removed and tested for whether it is a solution node. If not, it
will be expanded with the function “Successors” and its successors added to the list
with the function “SortIn”. “SortIn(X,Y)” inserts the elements from the unsorted list
X into the ascendingly sorted list Y. The heuristic rating is used as the sorting key.
Thus it is guaranteed that the best node (that is, the one with the lowest heuristic
value) is always at the beginning of the list.3
3When sorting in a new node from the node list, it may be advantageous to check whether the node
is already available and, if so, to delete the duplicate.
104
6
Search, Games and Problem Solving

Depth-ﬁrst and breadth-ﬁrst search also happen to be special cases of the
function HEURISTICSEARCH. We can easily generate them by plugging in the
appropriate evaluation function (Exercise 6.11 on page 123).
The best heuristic would be a function that calculates the actual costs from each
node to the goal. To do that, however, would require a traversal of the entire search
space, which is exactly what the heuristic is supposed to prevent. Therefore we need
a heuristic that is fast and simple to compute. How do we ﬁnd such a heuristic?
An interesting idea for ﬁnding a heuristic is simpliﬁcation of the problem. The
original task is simpliﬁed enough that it can be solved with little computational
cost. The costs from a state to the goal in the simpliﬁed problem then serve as an
estimate for the actual problem (see Fig. 6.13). This cost estimate function we
denote h.
HEURISTICSEARCH(Start, Goal)
NodeList = [Start]
While True
If NodeList = ∅Return(“No solution”)
Node = First(NodeList)
NodeList = Rest(NodeList)
If GoalReached(Node, Goal) Return(“Solution found”, Node)
NodeList = SortIn(Successors(Node),NodeList)
Fig. 6.12 The algorithm for heuristic search
Fig. 6.13 He: “Dear, think of the fuel cost! I’ll pluck one for you somewhere else.” She: “No,
I want that one over there!”
6.3
Heuristic Search
105

6.3.1
Greedy Search
It seems sensible to choose the state with the lowest estimated h value (that is, the
one with the lowest estimated cost) from the list of currently available states. The
cost estimate then can be used directly as the evaluation function. For the evaluation
in the function HEURISTICSEARCH we set f (s) = h(s). This can be seen clearly in the
trip planning example (Example 6.2 on page 96). We set up the task of ﬁnding the
straight line path from city to city (that is, the ﬂying distance) as a simpliﬁcation of
the problem. Instead of searching the optimal route, we ﬁrst determine from every
node a route with minimal ﬂying distance to the goal. We choose Ulm as the
destination. Thus the cost estimate function becomes
hðsÞ ¼ flying distance from city s to Ulm.
The ﬂying distances from all cities to Ulm are given in Fig. 6.14 next to the graph.
The search tree for starting in Linz is represented in Fig. 6.15 on page 107 left.
We can see that the tree is very slender. The search thus ﬁnishes quickly. Unfor-
tunately, this search does not always ﬁnd the optimal solution. For example, this
algorithm fails to ﬁnd the optimal solution when starting in Mannheim (Fig. 6.15
on page 107 right). The Mannheim–Nürnberg–Ulm path has a length of 401 km.
The route Mannheim–Karlsruhe–Stuttgart–Ulm would be signiﬁcantly shorter at
238 km. As we observe the graph, the cause of this problem becomes clear.
Nürnberg is in fact somewhat closer than Karlsruhe to Ulm, but the distance from
Mannheim to Nürnberg is signiﬁcantly greater than that from Mannheim to Karl-
sruhe. The heuristic only looks ahead “greedily” to the goal instead of also taking
into account the stretch that has already been laid down to the current node. This is
why we give it the name greedy search.
Fig. 6.14 City graph with ﬂying distances from all cities to Ulm
106
6
Search, Games and Problem Solving

6.3.2
A★-Search
We now want to take into account the costs that have accrued during the search up
to the current node s. First we deﬁne the cost function
gðsÞ ¼ Sum of accrued costs from the start to the current node;
then add to that the estimated cost to the goal and obtain as the heuristic evaluation
function
fðsÞ ¼ gðsÞ þ hðsÞ:
Now we add yet another small, but important requirement.
Deﬁnition 6.4 A heuristic cost estimate function h(s) that never overestimates
the actual cost from state s to the goal is called admissible.
The
function
HEURISTICSEARCH
together
with
an
evaluation
function
f(s) = g(s) + h(s) and an admissible heuristic function h is called A★-algorithm. This
famous algorithm is complete and optimal. A★thus always ﬁnds the shortest
solution for every solvable search problem. We will explain and prove this in the
following discussion.
Fig. 6.15 Greedy search: from Linz to Ulm (left) and from Mannheim to Ulm (right). The node
list data structure for the left search tree, sorted by the node rating before the expansion of the node
München is given
6.3
Heuristic Search
107

First we apply the A★-algorithm to the example. We are looking for the shortest
path from Frankfurt to Ulm.
In the top part of Fig. 6.16 we see that the successors of Mannheim are generated
before the successors of Würzburg. The optimal solution Frankfurt–Würzburg–Ulm
is generated shortly thereafter in the eighth step, but it is not yet recognized as such.
Thus the algorithm does not terminate yet because the node Karlsruhe (3) has a
better (lower) f value and thus is ahead of the node Ulm (8) in line. Only when all
f values are greater than or equal to that of the solution node Ulm (8) have we
ensured that we have an optimal solution. Otherwise there could potentially be
another solution with lower costs. We will now show that this is true generally.
Theorem 6.2 The A★algorithm is optimal. That is, it always ﬁnds the
solution with the lowest total cost if the heuristic h is admissible.
Proof In the HEURISTICSEARCH algorithm, every newly generated node s is sorted in
by the function “SortIn” according to its heuristic rating f(s). The node with the
Fig. 6.16 Two snapshots of the A★search tree for the optimal route from Frankfurt to Ulm. In
the boxes below the name of the city s we show g(s), h(s), f(s). Numbers in parentheses after the
city names show the order in which the nodes have been generated by the “Successor” function
108
6
Search, Games and Problem Solving

smallest rating value thus is at the beginning of the list. If the node l at the
beginning of the list is a solution node, then no other node has a better heuristic
rating. For all other nodes s it is true then that f (l)  f (s). Because the heuristic is
admissible, no better solution l′ can be found, even after expansion of all other
nodes (see Fig. 6.17). Written formally:
gðlÞ ¼ gðlÞ þ hðlÞ ¼ fðlÞ  fðsÞ ¼ gðsÞ þ hðsÞ  gðl0Þ:
The ﬁrst equality holds because l is a solution node with h(l) = 0. The second is the
deﬁnition of f. The third (in)equality holds because the list of open nodes is sorted
in ascending order. The fourth equality is again the deﬁnition of f. Finally, the last
(in)equality is the admissibility of the heuristic, which never overestimates the cost
from node s to an arbitrary solution. Thus it has been shown that g(l)  g(l′), that
is, that the discovered solution l is optimal.
□
6.3.3
Route Planning with the A★Search Algorithm
Many current car navigation systems use the A★algorithm. The simplest, but very
good heuristic for computing A★is the straight-line distance from the current node
to the destination. The use of 5 to 60 so-called landmarks is somewhat better. For
these randomly chosen points the shortest paths to and from all nodes on the map
are calculated in a precomputation step. Let l be such a landmark, s the current
node, and z the destination node. Also let c★(x, y) be the cost of the shortest path
from x to y. Then we obtain for the shortest path from s to l the triangle inequality
(see Exercise 6.11 on page 123)
cHðs; lÞ  cHðs; zÞ þ cHðz; lÞ:
Solving for c★(s, z) results in the admissible heuristic
hðsÞ ¼ cHðs; lÞ  cHðz; lÞ  cHðs; zÞ:
In [Bat16], it was shown that this heuristic is better than the straight-line distance for
route planning. On one hand, it can be calculated faster than the straight-line dis-
tance. Due to precomputation, distances to the landmarks can be quickly retrieved
Fig. 6.17 The ﬁrst solution
node l found by A★never has
a higher cost than another
arbitrary node l′
6.3
Heuristic Search
109

from an array, whereas the Euclidean distances must be computed individually. It
turns out that the landmark heuristic shrinks the search space even more. This can be
seen in the left image of Fig. 6.18, which illustrates the search tree of A★search for
planning a route from Ravensburg to Biberach (two towns in southern Germany).4
The edges without any heuristic (i.e. with h(s) = 0) are plotted in red colour, dark
green lines show the search tree using the straight-line distance heuristic, and the
edges of the landmark heuristic with twenty landmarks are plotted in blue.
The right image shows the same route using bidirectional search, where a route
from Ravensburg to Biberach and one in the opposite direction are planned
effectively in parallel. If the routes meet, given certain conditions of the heuristic, an
optimal route has been found [Bat16]. A quantitative analysis of the search tree
sizes and the computation time on a PC can be found in Table 6.2.
Fig. 6.18 A★search tree without heuristic (red), with straight-line distance (dark green) and with
landmarks (blue). The left image shows unidirectional search and the right shows bidirectional
search. Note that the green edges are covered by blue and the red edges are covered by green and blue
Table 6.2 Comparison of search tree size and computation time for route planning with and
without each of the two heuristics. The landmark heuristic is the clear winner
Unidirectional
Bidirectional
Tree Size
[nodes]
Comp. time
[msec.]
Tree Size
[nodes]
Comp. time
[msec.]
No heuristic
62000
192
41850
122
Straight-line distance
9380
86
12193
84
Landmark heuristic
5260
16
7290
16
4Both graphs in Fig. 6.18 were generated by A. Batzill using the system described in [Bat16].
110
6
Search, Games and Problem Solving

Observing unidirectional search, we see that both heuristics clearly reduce the
search space. The computation times are truly interesting. In the case of the land-
mark heuristic, we see the computation time and the size of the search space
reduced by a factor of about 12. The cost of computing the heuristic is thus
insigniﬁcant. The straight-line distance, however, results in a search space reduction
of a factor of 6.6, but only an improvement of a factor of 2.2 in run time due to the
overhead of computing the euclidean distance.
In the case of bidirectional search, in contrast to unidirectional search, we see a
signiﬁcant reduction of the search space even without heuristic. On the other hand,
the search space is larger than the unidirectional case for both heuristics. However,
because the nodes are partitioned into two sorted lists in bidirectional search (see
HEURISTICSEARCH function in Fig. 6.12 on page 105), the lists are handled faster and
the resulting computation times are roughly the same [Bat16].
When planning a route, usually the driver cares more about driving time than the
distance driven. We should thus adjust the heuristic accordingly and replace
straight-line distance d(s, z) with time tðs; zÞ ¼ dðs; zÞ=vmax. Here we have to divide
by the maximum average velocity, which degrades the heuristic because it causes
the heuristically estimated times to be much too small. The landmark heuristic, in
contrast, builds on precomputed optimal routes and therefore does not degrade.
Thus, as shown in [Bat16], the search for a time-optimized route using landmark
heuristic is signiﬁcantly faster than with the modiﬁed straight-line distance.
The contraction hierarchies
algorithm performs even better than A★with
landmark heuristic. It is based on the idea of combining, in a precompution step,
several edges into so-called shortcuts, which are then used to reduce the search
space [GSSD08, Bat16].
6.3.4
IDA★-Search
The A★search inherits a quirk from breadth-ﬁrst search. It has to save many nodes in
memory, which can lead to very high memory use. Furthermore, the list of open
nodes must be sorted. Thus insertion of nodes into the list and removal of nodes from
the list can no longer run in constant time, which increases the algorithm’s complexity
slightly. Based on the heapsort algorithm, we can structure the node list as a heap with
logarithmic time complexity for insertion and removal of nodes (see [CLR90]).
Both problems can be solved—similarly to breadth-ﬁrst search—by iterative
deepening. We work with depth-ﬁrst search and successively raise the limit.
However, rather than working with a depth limit, here we use a limit for the
heuristic evaluation f (s). This process is called the IDA★-algorithm.
6.3.5
Empirical Comparison of the Search Algorithms
In A★, or (alternatively) IDA★, we have a search algorithm with many good
properties. It is complete and optimal. It can thus be used without risk. The most
6.3
Heuristic Search
111

important thing, however, is that it works with heuristics, and therefore can sig-
niﬁcantly reduce the computation time needed to ﬁnd a solution. We would like to
explore this empirically in the 8-puzzle example.
For the 8-puzzle there are two simple admissible heuristics. The heuristic h1
simply counts the number of squares that are not in the right place. Clearly this
heuristic is admissible. Heuristic h2 measures the Manhattan distance. For
every square the horizontal and vertical distances to that square’s location in the
goal state are added together. This value is then summed over all squares. For
example, the Manhattan distance of the two states
is calculated as
h2ðsÞ ¼ 1 þ 1 þ 1 þ 1 þ 2 þ 0 þ 3 þ 1 ¼ 10:
The admissibility of the Manhattan distance is also obvious (see Exercise 6.13 on
page 123).
The described algorithms were implemented in Mathematica. For a comparison
with uninformed search, the A★algorithm with the two heuristics h1 and h2 and
iterative deepening was applied to 132 randomly generated 8-puzzle problems. The
average values for the number of steps and computation time are given in Table 6.3.
We see that the heuristics signiﬁcantly reduce the search cost compared to unin-
formed search.
If we compare iterative deepening to A★with h1 at depth 12, for example, it
becomes evident that h1 reduces the number of steps by a factor of about 3,000, but
Table 6.3 Comparison of the computation cost of uninformed search and heuristic search for
solvable 8-puzzle problems with various depths. Measurements are in steps and seconds. All
values are averages over multiple runs (see last column)
Depth
Iterative deepening
A★algorithm
Num.
runs
Steps
Time
[sec]
Heuristic h1
Heuristic h2
Steps
Time [sec]
Steps
Time [sec]
2
20
0.003
3.0
0.0010
3.0
0.0010
10
4
81
0.013
5.2
0.0015
5.0
0.0022
24
6
806
0.13
10.2
0.0034
8.3
0.0039
19
8
6455
1.0
17.3
0.0060
12.2
0.0063
14
10
50512
7.9
48.1
0.018
22.1
0.011
15
12
486751
75.7
162.2
0.074
56.0
0.031
12
IDA★
14
–
–
10079.2
2.6
855.6
0.25
16
16
–
–
69386.6
19.0
3806.5
1.3
13
18
–
–
708780.0
161.6
53941.5
14.1
4
112
6
Search, Games and Problem Solving

the computation time by only a factor of 1,023. This is due to the higher cost per
step for the computation of the heuristic.
Closer examination reveals a jump in the number of steps between depth 12 and
depth 14 in the column for h1. This jump cannot be explained solely by the repeated
work done by IDA★. It comes about because the implementation of the A★algo-
rithm deletes duplicates of identical nodes and thereby shrinks the search space.
This is not possible with IDA★because it saves almost no nodes. Despite this, A★
can no longer compete with IDA★beyond depth 14 because the cost of sorting in
new nodes pushes up the time per step so much.
A computation of the effective branching factor according to (6.1) on page 96
yields values of about 2.8 for uninformed search. This number is consistent with
the value from Sect. 6.1. Heuristic h1 reduces the branching factor to values of
about 1.5 and h2 to about 1.3. We can see in the table that a small reduction of
the branching factor from 1.5 to 1.3 gives us a big advantage in computation
time.
Heuristic search thus has an important practical signiﬁcance because it can solve
problems which are far out of reach for uninformed search.
6.3.6
Summary
Of the various search algorithms for uninformed search, iterative deepening is the
only practical one because it is complete and can get by with very little memory.
However, for difﬁcult combinatorial search problems, even iterative deepening
usually fails due to the size of the search space. Heuristic search helps here through
its reduction of the effective branching factor. The IDA★-algorithm, like iterative
deepening, is complete and requires very little memory.
Heuristics naturally only give a signiﬁcant advantage if the heuristic is “good”.
When solving difﬁcult search problems, the developer’s actual task consists of
designing heuristics which greatly reduce the effective branching factor. In Sect. 6.5
we will deal with this problem and also show how machine learning techniques can
be used to automatically generate heuristics.
In closing, it remains to note that heuristics have no performance advantage for
unsolvable problems because the unsolvability of a problem can only be estab-
lished when the complete search tree has been searched through. For decidable
problems such as the 8-puzzle this means that the whole search tree must be
traversed up to a maximal depth whether a heuristic is being used or not. The
heuristic is always a disadvantage in this case, attributable to the computational
cost of evaluating the heuristic. This disadvantage can usually be estimated by a
constant factor independent of the size of the problem. For undecidable problems
such as the proof of PL1 formulas, the search tree can be inﬁnitely deep. This
means that, in the unsolvable case, the search potentially never ends. In summary
we can say the following: for solvable problems, heuristics often reduce compu-
tation time dramatically, but for unsolvable problems the cost can even be higher
with heuristics.
6.3
Heuristic Search
113

6.4
Games with Opponents
Games for two players, such as chess, checkers, Othello, and Go are deterministic
because every action (a move) results in the same child state given the same parent
state. In contrast, backgammon is non-deterministic because its child state depends
on the result of a dice roll. These games are all observable because every player
always knows the complete game state. Many card games, such as poker, for
example, are only partially observable because the player does not know the other
players’ cards, or only has partial knowledge about them.
The problems discussed so far in this chapter were deterministic and observable.
In the following we will look at games which, too, are deterministic and observable.
Furthermore, we will limit ourselves to zero-sum games. These are games in which
every gain one player makes means a loss of the same value for the opponent. The
sum of the gain and loss is always equal to zero. This is true of the games chess,
checkers, Othello, and Go, mentioned above.
6.4.1
Minimax Search
The goal of each player is to make optimal moves that result in victory. In principle
it is possible to construct a search tree and completely search through it (like with
the 8-puzzle) for a series of moves that will result in victory. However, there are
several peculiarities to watch out for:
1. The effective branching factor in chess is around 30 to 35. In a typical game
with 50 moves per player, the search tree has more than 30100  10148 leaf
nodes. Thus there is no chance to fully explore the search tree. Additionally,
chess is often played with a time limit. Because of this real-time requirement,
the search must be limited to an appropriate depth in the tree, for example eight
half-moves. Since among the leaf nodes of this depth-limited tree there are
normally no solution nodes (that is, nodes which terminate the game) a heuristic
evaluation function B for board positions is used. The level of play of the
program strongly depends on the quality of this evaluation function. Therefore
we will further treat this subject in Sect. 6.5.
2. In the following we will call the player whose game we wish to optimize Max,
and his opponent Min. The opponent’s (Min’s) moves are not known in
advance, and thus neither is the actual search tree. This problem can be elegantly
solved by assuming that the opponent always makes the best move he can. The
higher the evaluation B(s) for position s, the better position s is for the player
Max and the worse it is for his opponent Min. Max tries to maximize the
evaluation of his moves, whereas Min makes moves that result in as low an
evaluation as possible.
A search tree with four half-moves and evaluations of all leaves is given in
Fig. 6.19 on page 115. The evaluation of an inner node is derived recursively as the
maximum or minimum of its child nodes, depending on the node’s level.
114
6
Search, Games and Problem Solving

6.4.2
Alpha-Beta-Pruning
By switching between maximization and minimization, we can save ourselves a lot
of work in some circumstances. Alpha-beta pruning works with depth-ﬁrst search
up to a preset depth limit. In this way the search tree is searched through from left to
right. Like in minimax search, in the minimum nodes the minimum is generated
from the minimum value of the successor nodes and in the maximum nodes like-
wise the maximum. In Fig. 6.20 this process is depicted for the tree from Fig. 6.19.
At the node marked a, all other successors can be ignored after the ﬁrst child is
evaluated as the value 1 because the minimum is sure to be 1. It could even
become smaller still, but that is irrelevant since the maximum is already 3 one
level above. Regardless of how the evaluation of the remaining successors turns
out, the maximum will keep the value 3. Analogously the tree will be trimmed at
node b. Since the ﬁrst child of b has the value 2, the minimum to be generated for
b can only be less than or equal to 2. But the maximum at the root node is already
sure to be 3. This cannot be changed by values 2. Thus the remaining subtrees
of b can be pruned.
The same reasoning applies for the node c. However, the relevant maximum
node is not the direct parent, but the root node. This can be generalized.
Fig. 6.19 A minimax game tree with look-ahead of four half-moves
Fig. 6.20 An alpha-beta game tree with look-ahead of four half-moves. The dotted portions of the
tree are not traversed because they have no effect on the end result
6.4
Games with Opponents
115

• At every leaf node the evaluation is calculated.
• For every maximum node the current largest child value is saved in a.
• For every minimum node the current smallest child value is saved in b.
• If at a minimum node k the current value b  a, then the search under k can end.
Here a is the largest value of a maximum node in the path from the root
to k.
• If at a maximum node l the current value a  b, then the search under l
can end. Here b is the smallest value of a minimum node in the path from the
root to l.
The algorithm given in Fig. 6.21 is an extension of depth-ﬁrst search with two
functions which are called in alternation. It uses the values deﬁned above for a
and b.
The initial alpha-beta pruning call is done with the command
ALPHABETAMAX(RootNode, –∞, ∞).
Complexity
The computation time saved by alpha-beta pruning heavily depends
on the order in which child nodes are traversed. In the worst case, alpha-beta
ALPHABETAMAX(Node,α,β)
If DepthLimitReached(Node) Return(Rating(Node))
NewNodes = Successors(Node)
While NewNodes
α = Maximum(α, ALPHABETAMIN(First(NewNodes), α,β))
If α ≥β Return(β)
NewNodes = Rest(NewNodes)
Return(αα)
ALPHABETAMIN(Node,α,β)
If DepthLimitReached(Node) Return(Rating(Node))
NewNodes = Successors(Node)
While NewNodes
β = Minimum(β, ALPHABETAMAX(First(NewNodes), α,β))
If β ≤α Return(α)
NewNodes = Rest(NewNodes)
Return(β)
Fig. 6.21 The algorithm for alpha-beta search with the two functions ALPHABETAMIN and
ALPHABETAMAX
116
6
Search, Games and Problem Solving

pruning does not offer any advantage. For a constant branching factor b the number
nd of leaf nodes to evaluate at depth d is equal to
nd ¼ bd:
In the best case, when the successors of maximum nodes are descendingly sorted
and the successors of minimum nodes are ascendingly sorted, the effective
branching factor is reduced to
ﬃﬃﬃ
b
p
. In chess this means a substantial reduction of the
effective branching factor from 35 to about 6. Then only
nd ¼
ﬃﬃﬃﬃ
b
p
d ¼ bd=2
leaf nodes would be created. This means that the depth limit and thus also the
search horizon are doubled with alpha-beta pruning. However, this is only true in
the case of optimally sorted successors because the child nodes’ ratings are
unknown at the time when they are created. If the child nodes are randomly sorted,
then the branching factor is reduced to b3/4 and the number of leaf nodes to
nd ¼ b
3
4 d:
With the same computing power a chess computer using alpha-beta pruning can, for
example, compute eight half-moves ahead instead of six, with an effective
branching factor of about 14. A thorough analysis with a derivation of these
parameters can be found in [Pea84].
To double the search depth as mentioned above, we would need the child nodes
to be optimally ordered, which is not the case in practice. Otherwise the search
would be unnecessary. With a simple trick we can get a relatively good node
ordering. We connect alpha-beta pruning with iterative deepening over the depth
limit. Thus at every new depth limit we can access the ratings of all nodes of
previous levels and order the successors at every branch. Thereby we reach an
effective branching factor of roughly 7 to 8, which is not far from the theoretical
optimum of
ﬃﬃﬃﬃﬃ
35
p
[Nil98].
6.4.3
Non-deterministic Games
Minimax search can be generalized to all games with non-deterministic actions,
such as backgammon. Each player rolls before his move, which is inﬂuenced by the
result of the dice roll. In the game tree there are now therefore three types of levels
in the sequence
Max, dice, Min, dice, … ,
where each dice roll node branches six ways. Because we cannot predict the value
of the die, we average the values of all rolls and conduct the search as described
with the average values from [RN10].
6.4
Games with Opponents
117

6.5
Heuristic Evaluation Functions
How do we ﬁnd a good heuristic evaluation function for the task of searching? Here
there are fundamentally two approaches. The classical way uses the knowledge of
human experts. The knowledge engineer is given the usually difﬁcult task of for-
malizing the expert’s implicit knowledge in the form of a computer program. We
now want to show how this process can be simpliﬁed in the chess program
example.
In the ﬁrst step, experts are questioned about the most important factors in the
selection of a move. Then it is attempted to quantify these factors. We obtain a list
of relevant features or attributes. These are then (in the simplest case) combined into
a linear evaluation function B(s) for positions, which could look like:
BðsÞ ¼ a1  material þ a2  pawn structure þ a3  king safety
þ a4  knight in center þ a5  bishop diagonal coverage þ    ;
ð6:3Þ
where “material” is by far the most important feature and is calculated by
material ¼ material(own teamÞ  material(opponent)
with
material(team) ¼ num pawnsðteamÞ  100 þ num knightsðteamÞ  300
þ num bishopsðteamÞ  300 þ num rooksðteamÞ  500
þ num queensðteamÞ  900
Nearly all chess programs make a similar evaluation for material. However, there
are big differences for all other features, which we will not go into here [Fra05, Lar00].
In the next step the weights ai of all features must be determined. These are set
intuitively after discussion with experts, then changed after each game based on
positive and negative experience. The fact that this optimization process is very
expensive and furthermore that the linear combination of features is very limited
suggests the use of machine learning.
6.5.1
Learning of Heuristics
We now want to automatically optimize the weights ai of the evaluation function
B(s) from (6.3). In this approach the expert is only asked about the relevant features
f1(s), … , fn(s) for game state s. Then a machine learning process is used with the
goal of ﬁnding an evaluation function that is as close to optimal as possible. We
start with an initial pre-set evaluation function (determined by the learning process),
and then let the chess program play. At the end of the game a rating is derived from
the result (victory, defeat, or draw). Based on this rating, the evaluation function is
118
6
Search, Games and Problem Solving

changed with the goal of making fewer mistakes next time. In principle, the same
thing that is done by the developer is now being taken care of automatically by the
learning process.
As easy as this sounds, it is very difﬁcult in practice. A central problem with
improving the position rating based on won or lost matches is known today as the
credit assignment problem. We do in fact have a rating at the end of the game, but
no ratings for the individual moves. Thus the agent carries out many actions but
does not receive any positive or negative feedback until the very end. How should it
then assign this feedback to the many actions taken in the past? And how should it
improve its actions in that case? The exciting ﬁeld of reinforcement learning
deals with these questions (see Chap. 10).
Monte Carlo tree search (MCTS) [KS06] works quite similarly. To improve the
heuristic rating of a game state s, a random number of search tree branches starting
from this state are either explored to the end and evaluated, or stopped at a certain
depth and then the leaf nodes are evaluated heuristically. The evaluation B(s) of
state s is given as the mean of all leaf node scores. The use of MCTS paths requires
only a small part of the entire exponentially exploding tree to be searched. This is
illustrated in Fig. 6.22. For many computer-simulated games, such as chess, this
algorithm can be used to achieve better play for the same computational effort or to
reduce computational effort for the same difﬁculty level [KS06]. This method was
used together with machine learning algorithms in 2016 by the program AlphaGo,
described in Sect. 10.10, which was the ﬁrst Go program to defeat world-class
human players [SHM+16].
6.6
State of the Art
For evaluation of the quality of the heuristic search processes, I would like to repeat
Elaine Rich’s deﬁnition [Ric83]:
Artiﬁcial Intelligence is the study of how to make computers do things at which, at the
moment, people are better.
Fig. 6.22 In this sketch of a search tree, several MCTS paths to leaf nodes are shown in red.
Notice that only a small part of the tree is searched
6.5
Heuristic Evaluation Functions
119

There is hardly a better suited test for deciding whether a computer program is
intelligent as the direct comparison of computer and human in a game like chess,
checkers, backgammon or Go.
In 1950, Claude Shannon, Konrad Zuse, and John von Neumann introduced the
ﬁrst chess programs, which, however, could either not be implemented or would
take a great deal of time to implement. Just a few years later, in 1955, Arthur
Samuel wrote a program that played checkers and could improve its own param-
eters through a simple learning process. To do this he used the ﬁrst programmable
logic computer, the IBM 701. Compared to the chess computers of today, however,
it had access to a large number of archived games, for which every individual move
had been rated by experts. Thus the program improved its evaluation function. To
achieve further improvements, Samuel had his program play against itself. He
solved the credit assignment problem in a simple manner. For each individual
position during a game it compares the evaluation by the function B(s) with the one
calculated by alpha-beta pruning and changes B(s) accordingly. In 1961 his
checkers program beat the fourth-best checkers player in the USA. With this
ground-breaking work, Samuel was surely nearly 30 years ahead of his time.
Only at the beginning of the nineties, as reinforcement learning emerged, did
Gerald Tersauro build a learning backgammon program named TD-Gammon,
which played at the world champion level (see Chap. 10).
6.6.1
Chess
Today many chess programs exist that play above grandmaster level. The break-
through came in 1997, as IBM’s Deep Blue defeated the chess world champion
Gary Kasparov with a score of 3.5 games to 2.5. Deep Blue could on average
compute 12 half-moves ahead with alpha-beta pruning and heuristic position
evaluation.
Around the year 2005 one of the most powerful chess computers was Hydra, a
parallel computer owned by a company in the United Arab Emirates. The software
was developed by the scientists Christian Donninger (Austria) and Ulf Lorenz
(Germany), as well as the German chess grand champion Christopher Lutz. Hydra
uses 64 parallel Xeon processors with about 3 GHz computing power and 1 GByte
memory each. For the position evaluation function each processor has an FPGA (ﬁeld
programmable gate array) co-processor. Thereby it becomes possible to evaluate
200 million positions per second even with an expensive evaluation function.
With this technology Hydra can on average compute about 18 moves ahead. In
special, critical situations the search horizon can even be stretched out to 40
half-moves. Clearly this kind of horizon is beyond what even grand champions can
do, for Hydra often makes moves which grand champions cannot comprehend, but
which in the end lead to victory. In 2005 Hydra defeated seventh ranked grand-
master Michael Adams with 5.5–0.5 games.
Hydra uses little special textbook knowledge about chess, rather alpha-beta
search with relatively general, well-known heuristics and a good hand-coded
120
6
Search, Games and Problem Solving

position evaluation. In particular, Hydra is not capable of learning. Improvements
are carried out between games by the developers. As a consequence, Hydra was
soon outperformed by machines that used smart learning algorithms rather than
expensive hardware.
In 2009 the system Pocket Fritz 4, running on a PDA, won the Copa Mercosur
chess tournament in Buenos Aires with nine wins and one draw against 10 excellent
human chess players, three of them grandmasters. Even though not much infor-
mation about the internal structure of the software is available, this chess machine
represents a trend away from raw computing power toward more intelligence. This
machine plays at grandmaster level, and is comparable to, if not better than Hydra.
According to Pocket Fritz developer Stanislav Tsukrov [Wik13], Pocket Fritz with
its chess search engine HIARCS 13 searches less than 20,000 positions per second,
which is slower than Hydra by a factor of about 10,000. This leads to the con-
clusion that HIARCS 13 deﬁnitely uses better heuristics to decrease the effective
branching factor than Hydra and can thus well be called more intelligent than
Hydra. By the way, HIARCS is a short hand for Higher Intelligence Auto Response
Chess System.
6.6.2
Go
Even though today no human stands a chance against the best chess computers,
there are still many challenges for AI. For example Go. In this ancient Japanese
game, played on a square board of 361 spaces with 181 white and 180 black stones,
the effective branching factor is about 250. After 8 half-moves there are already
1:5  1019
possible positions. Given this complexity, none of the classic,
well-known game tree search algorithms have a chance against a good human Go
player. Yet in the most recent previous edition of this book, it was stated that:
The experts agree that “truly intelligent” algorithms are needed here. Combinatoric enu-
meration of all possibilities is the wrong approach. Rather, procedures are needed that
recognize patterns on the board, track gradual developments, and make rapid “intuitive”
decisions. Similar to object recognition in complex images, we humans are still far superior
to today’s computer programs. We process the image as a whole in a highly parallel
manner, whereas the computer processes the millions of pixels successively and has great
difﬁculty recognizing the essentials in the abundance of pixels. The program “The Many
Faces of Go” recognizes 1100 different patterns and knows 200 different playing strategies.
All Go programs, however, still have great difﬁculty recognizing whether a group of stones
is dead or alive, or where in between to classify them.
This statement is now obsolete. In January of 2016, Google [SHM+16] and
Facebook [TZ16] published the breakthrough concurrently. That same month, the
program AlphaGo, developed and presented in [SHM+16] by Google DeepMind,
defeated European Go champion Fan Hui 5:0. Two months later, Korean player Lee
Sedol, one of the best in the world, was defeated 4:1. Deep Learning for pattern
recognition (see Sect. 9.7), reinforcement learning (see Chap. 10) and Monte Carlo
tree search (MCTS, see Sect. 6.5.1) lead to this successful result.
6.6
State of the Art
121

The program plays hundreds of thousands of games against itself and uses the
results (win, loss, draw) to learn the best possible heuristic score for a given
position. Monte Carlo tree search is used as a replacement for Minimax search,
which is not suitable for Go. In Sect. 10.10, after we have gained familiarity with
the necessary learning algorithms, we will introduce AlphaGo.
6.7
Exercises
Exercise 6.1
(a) Prove Theorem 6.1 on page 96, in other words, prove that for a tree with large
constant branching factor b, almost all nodes are on the last level at depth d.
(b) Show that this is not always true when the effective branching factor is large
and not constant.
Exercise 6.2
(a) Calculate the average branching factor for the 8-puzzle without a check for
cycles. The average branching factor is the branching factor that a tree with an
equal number of nodes on the last level, constant branching factor, and equal
depth would have.
(b) Calculate the average branching factor for the 8-puzzle for uninformed search
while avoiding cycles of length 2.
Exercise 6.3
(a) What is the difference between the average and the effective branching factor
(Deﬁnition 6.2 on page 95)?
(b) Why is the effective branching factor better suited to analysis and comparison of
the computation time of search algorithms than the average branching factor?
(c) Show that for a heavily branching tree with n nodes and depth d the effective
branching factor b is approximately equal to the average branching factor and
thus equal to
ﬃﬃﬃn
dp .
Exercise 6.4
(a) Calculate the size of the state space for the 8-puzzle, for the analogous
3-puzzle (2  2-matrix), as well as for the 15-puzzle (4  4-matrix).
(b) Prove that the state graph consisting of the states (nodes) and the actions
(edges) for the 3-puzzle falls into two connected sub-graphs, between which
there are no connections.
Exercise 6.5 With breadth-ﬁrst search for the 8-puzzle, ﬁnd a path (manually) from
the starting node
to the goal node
.
122
6
Search, Games and Problem Solving

➳Exercise 6.6
(a) Program breadth-ﬁrst search, depth-ﬁrst search, and iterative deepening in the
language of your choice and test them on the 8-puzzle example.
(b) Why does it make little sense to use depth-ﬁrst search on the 8-puzzle?
Exercise 6.7
(a) Show that breadth-ﬁrst search given constant cost for all actions is guaranteed
to ﬁnd the shortest solution.
(b) Show that this is not the case for varying costs.
Exercise 6.8 The predecessors of all nodes must be stored to check for cycles
during depth-ﬁrst search.
(a) For depth ﬁrst search develop a data structure (not a hash table) that is as
efﬁcient as possible for storing all nodes in the search path of a search tree.
(b) For constant branching factor b and depth d, give a formula for the storage
space needed by depth-ﬁrst search with and without storing predecessors.
(c) Show that for large b and d, we have Pd
k¼0 k  bk  d  bd.
Exercise 6.9 Using A★search for the 8-puzzle, search (manually) for a path from
the starting node
to the goal node
(a) using the heuristic h1 (Sect. 6.3.4).
(b) using the heuristic h2 (Sect. 6.3.4).
Exercise 6.10 Construct the A★search tree for the city graph from Fig. 6.14 on
page 106 and use the ﬂying distance to Ulm as the heuristic. Start in Bern with Ulm
as the destination. Take care that each city only appears once per path.
Exercise 6.11
(a) Show that the triangle inequality is valid for shortest distances on maps.
(b) Using an example, show that it is not always the case that the triangle
inequality holds for direct neighbor nodes x and y, where the distance is
d(x, y). That is, it is not the case that dðx; yÞ  dðx; zÞ þ dðz; yÞ.
➳Exercise 6.12 Program A★search in the programming language of your choice
using the heuristics h1 and h2 and test these on the 8-puzzle example.
❄Exercise 6.13 Give a heuristic evaluation function for states with which HEURIS-
TICSEARCH can be implemented as depth-ﬁrst search, and one for a breadth-ﬁrst
search implementation.
6.7
Exercises
123

Exercise 6.14 What is the relationship between the picture of the couple at the
canyon from Fig. 6.13 on page 105 and admissible heuristics?
Exercise 6.15 Show that the heuristics h1 and h2 for the 8-puzzle from Sect. 6.3.4
are admissible.
Exercise 6.16
(a) The search tree for a two-player game is given in Fig. 6.23 with the ratings of
all leaf nodes. Use minimax search with a-b pruning from left to right. Cross
out all nodes that are not visited and give the optimal resulting rating for each
inner node. Mark the chosen path.
(b) Test yourself using P. Winston’s applet [Win].
Fig. 6.23 Minimax search tree
124
6
Search, Games and Problem Solving

7
Reasoning with Uncertainty
We have already shown in Chap. 4 with the Tweety problem that two-value logic
leads to problems in everyday reasoning. In this example, the statements Tweety is a
penguin, Penguins are birds, and All birds can ﬂy lead to the (semantically
incorrect) inference Tweety can ﬂy. Probability theory provides a language in which
we can formalize the statement Nearly all birds can ﬂy and carry out inferences on
it. Probability theory is a proven method we can use here because the uncertainty
about whether birds can ﬂy can be modeled well by a probability value. We will
show, that statements such as 99% of all birds can ﬂy, together with probabilistic
logic, lead to correct inferences.
Reasoning under uncertainty with limited resources plays a big role in everyday
situations and also in many technical applications of AI. In these areas heuristic
processes are very important, as we have already discussed in Chap. 6. For example,
we use heuristic techniques when looking for a parking space in city trafﬁc. Heuristics
alone are often not enough, especially when a quick decision is needed given
incomplete knowledge, as shown in the following example. A pedestrian crosses the
street and an auto quickly approaches. To prevent a serious accident, the pedestrian
must react quickly. He is not capable of worrying about complete information about
the state of the world, which he would need for the search algorithms discussed in
Chap. 6. He must therefore come to an optimal decision under the given constraints
(little time and little, potentially uncertain knowledge). If he thinks too long, it will be
dangerous. In this and many similar situations (see Fig. 7.1 on page 126), a method
for reasoning with uncertain and incomplete knowledge is needed.
We want to investigate the various possibilities of reasoning under uncertainty in
a simple medical diagnosis example. If a patient experiences pain in the right lower
abdomen and a raised white blood cell (leukocyte) count, this raises the suspicion
that it might be appendicitis. We model this relationship using propositional logic
with the formula
Stomach pain right lower ^ Leukocytes [ 10000 ! Appendicitis
© Springer International Publishing AG 2017
W. Ertel, Introduction to Artificial Intelligence, Undergraduate Topics
in Computer Science, DOI 10.1007/978-3-319-58487-4_7
125

Fig. 7.1 “Let’s just sit back and think about what to do!”
If we then know that
Stomach pain right lower ^ Leukocytes [ 10000
is true, then we can use modus ponens to derive Appendicitis. This model is clearly
too coarse. In 1976, Shortliffe and Buchanan recognized this when building their
medical expert system MYCIN [Sho76]. They developed a calculus using so-called
certainty factors, which allowed the certainty of facts and rules to be represented.
A rule A →B is assigned a certainty factor β. The semantic of a rule A →β B is
deﬁned via the conditional probability P (B | A) ¼ β. In the above example, the rule
could then read
Stomach pain right lower ^ Leukocytes [ 10000 !0:6 Appendicitis:
For reasoning with this kind of formulas, they used a calculus for connecting the
factors of rules. It turned out, however, that with this calculus inconsistent results
could be derived.
126
7
Reasoning with Uncertainty

As discussed in Chap. 4, there were also attempts to solve this problem by using
non-monotonic logic and default logic, which, however, were unsuccessful in the
end. The Dempster–Schäfer theory assigns a belief function Bel(A) to a logical
proposition A, whose value gives the degree of evidence for the truth of A. But even
this formalism has weaknesses, which is shown in [Pea88] using a variant of the
Tweety example. Even fuzzy logic, which above all is successful in control theory,
demonstrates considerable weaknesses when reasoning under uncertainty in more
complex applications [Elk93].
Since about the mid-1980s, probability theory has had more and more inﬂuence in
AI [Pea88, Che85, Whi96, Jen01]. In the ﬁeld of reasoning with Bayesian networks,
or subjective probability, it has secured itself a ﬁrm place among successful
AI techniques. Rather than implication as it is known in logic (material implication),
conditional probability is used here, which models everyday causal reasoning sig-
niﬁcantly better. Reasoning with probability proﬁts heavily from the fact that
probability theory is a hundreds of years old, well-established branch of mathematics.
In this chapter we will select an elegant, but for an instruction book somewhat
unusual, entry point into this ﬁeld. After a short introduction to the most important
foundations needed here for reasoning with probability, we will begin with a
simple, but important example for reasoning with uncertain and incomplete
knowledge. In a quite natural, almost compelling way, we will be led to the method
of maximum entropy (MaxEnt). Then we will show the usefulness of this method in
practice using the medical expert system LEXMED. Finally we will introduce the now
widespread reasoning with Bayesian networks, and show the relationship between
the two methods.
7.1
Computing with Probabilities
The reader who is familiar with probability theory can skip this section. For
everyone else we will give a quick ramp-up and recommend a few appropriate
textbooks such as [Ros09, FPP07].
Probability is especially well-suited for modeling reasoning under uncertainty.
One reason for this is that probabilities are intuitively easy to interpret, which can
be seen in the following elementary example.
Example 7.1 For a single roll of a gaming die (experiment), the probability of the
event “rolling a six” equals 1/6, whereas the probability of the occurrence “rolling
an odd number” is equal to 1/2.
Deﬁnition 7.1 Let Ω be the ﬁnite set of events for an experiment. Each event
ω 2 Ω represents a possible outcome of the experiment. If these events wi 2 Ω
mutually exclude each other, but cover all possible outcomes of the attempt,
then they are called elementary events.
7
Reasoning with Uncertainty
127

Example 7.2 For a single roll of one gaming die
X ¼ f1; 2; 3; 4; 5; 6g
because no two of these events can happen simultaneously. Rolling an even number
({2, 4, 6}) is therefore not an elementary event, nor is rolling a number smaller than
ﬁve ({1, 2, 3, 4}) because {2, 4, 6} \ {1, 2, 3, 4} ¼ {2, 4} 6¼ ;.
Given two events A and B, A [ B is also an event. Ω itself is denoted the certain
event, and the empty set ; the impossible event.
In the following we will use the propositional logic notation for set opera-
tions. That is, for the set A \ B we write A ∧B. This is not only a syntactic
transformation, rather it is also semantically correct because the intersection of two
sets is deﬁned as
x 2 A \ B , x 2 A ^ x 2 B:
Because this is the semantic of A ∧B, we can and will use this notation. This is also
true for the other set operations union and complement, and we will, as shown in
the following table, use the propositional logic notation for them as well.
The variables used here (for example A, B, etc.) are called random variables in
probability theory. We will only use discrete chance variables with ﬁnite domains
here. The variable face_number for a dice roll is discrete with the values 1, 2, 3, 4,
5, 6. The probability of rolling a ﬁve or a six is equal to 1/3. This can be described by
Pðface number 2 f5; 6gÞ ¼ Pðface number ¼ 5 _ face number ¼ 6Þ ¼ 1=3:
The concept of probability is supposed to give us a description as objective as
possible of our “belief” or “conviction” about the outcome of an experiment. All
numbers in the interval [0,1] should be possible, where 0 is the probability of the
impossible event and 1 the probability of the certain event. We come to this from
the following deﬁnition.
Set notation
Propositional logic
Description
A \ B
A ^ B
intersection / and
A [ B
A _ B
union / or
A
:A
complement / negation
X
t
certain event / true
;
f
impossible event / false
128
7
Reasoning with Uncertainty

Deﬁnition 7.2 Let Ω = {ω1, ω2, … , ωn} be ﬁnite. There is no preferred
elementary event, which means that we assume a symmetry related to the
frequency of how often each elementary event appears. The probability
P(A) of the event A is then
PðAÞ ¼ jAj
jXj ¼ Number of favorable cases for A
Number of possible cases
:
It follows immediately that every elementary event has the probability 1/|Ω|. The
requirement that elementary events have equal probability is called the Laplace
assumption and the probabilities calculated thereby are called Laplace probabili-
ties. This deﬁnition hits its limit when the number of elementary events becomes
inﬁnite. Because we are only looking at ﬁnite event spaces here, though, this does
not present a problem. To describe events we use variables with the appropriate
number of values. For example, a variable eye_color can take on the values green,
blue, brown. eye_color ¼ blue then describes an event because we are dealing with
a proposition with the truth values t or f. For binary (boolean) variables, the variable
itself is already a proposition. Here it is enough, for example, to write P(JohnCalls)
instead of P(JohnCalls ¼ t).
Example 7.3 By this deﬁnition, the probability of rolling an even number is
Pðface number 2 f2; 4; 6gÞ ¼
jf2; 4; 6gj
jf1; 2; 3; 4; 5; 6gj ¼ 3
6 ¼ 1
2 :
The following important rules follow directly from the deﬁnition.
Theorem 7.1
1. P(Ω) = 1.
2. P(;) = 0, which means that the impossible event has a probability of 0.
3. For pairwise exclusive events A and B it is true that P(A ∨B) = P(A) + P(B).
4. For two complementary events A and ¬A it is true that P(A) + P(¬A) = 1.
5. For arbitrary events A and B it is true that P(A ∨B) = P(A) + P(B) −
P(A ∧B).
6. For A  B it is true that P(A) ≤P(B).
7. If A1; . . . ; An are the elementary events, then Pn
i¼1 PðAiÞ ¼ 1 (normal-
ization condition).
7.1
Computing with Probabilities
129

The expression P(A ∧B) or equivalently P(A, B) stands for the probability of the
events A ∧B. We are often interested in the probabilities of all elementary events,
that is, of all combinations of all values of the variables A and B. For the binary
variables A and B these are P(A, B), P(A,¬B), P(¬A, B), P(¬A, ¬B). We call the vector
ðPðA; BÞ; PðA; :BÞ; Pð:A; BÞ; Pð:A; :BÞÞ
consisting of these four values a distribution or joint probability distribution of the
variables A and B. A shorthand for this is P(A, B). The distribution in the case of
two variables can be nicely visualized in the form of a table (matrix), represented
as follows:
For the d variables X1; . . . ; Xd with n values each, the distribution has the values
PðX1 ¼ x1; . . . ; Xd ¼ xdÞ and x1; . . . ; xd, each of which take on n different values.
The distribution can therefore be represented as a d-dimensional matrix with a total
of nd elements. Due to the normalization condition from Theorem 7.1 on page 129,
however, one of these nd values is redundant and the distribution is characterized by
nd −1 unique values.
7.1.1
Conditional Probability
Example 7.4 On Landsdowne street in Boston, the speed of 100 vehicles is mea-
sured. For each measurement it is also noted whether the driver is a student.
The results are
We pose the question: Do students speed more frequently than the average
person, or than non-students?1
P(A, B)
B ¼ w
B ¼ f
A ¼ w
P(A, B)
P(A, ¬B)
A ¼ f
P(¬A, B)
P(¬A, ¬B)
Event
Frequency
Relative frequency
Vehicle observed
100
1
Driver is a student (S)
30
0.3
Speed too high (G)
10
0.1
Driver is a student and speeding (S ∧G)
5
0.05
1The computed probabilities can only be used for continued propositions if the measured sample
(100 vehicles) is representative. Otherwise only propositions about the observed 100 vehicles can
be made.
130
7
Reasoning with Uncertainty

The answer is given by the probability
PðGjSÞ ¼ jDriver is a student and speedingj
jDriver is a studentj
¼ 5
30 ¼ 1
6  0:17
for speeding under the condition that the driver is a student. This is obviously
different from the a priori probability P(G) = 0.1 for speeding. For the a priori
probability, the event space is not limited by additional conditions.
Deﬁnition 7.3 For two events A and B, the probability P(A|B) for A under
the condition B (conditional probability) is deﬁned by
PðAjBÞ ¼ PðA ^ BÞ
PðBÞ
:
In Example 7.4 we see that in the case of a ﬁnite event space, the conditional
probability P(A|B) can be understood as the probability of A ∧B when we only
look at the event B, that is, as
PðAjBÞ ¼ jA ^ Bj
jBj
:
This formula can be easily derived using Deﬁnition 7.2 on page 129
PðAjBÞ ¼ PðA ^ BÞ
PðBÞ
¼
jA^Bj
jXj
jBj
jXj
¼ jA ^ Bj
jBj
:
Deﬁnition 7.4 If, for two events A and B,
PðAjBÞ ¼ PðAÞ;
then these events are called independent.
Thus A and B are independent if the probability of the event A is not inﬂuenced
by the event B.
7.1
Computing with Probabilities
131

Theorem 7.2 For independent events A and B, it follows from the deﬁnition
that
PðA ^ BÞ ¼ PðAÞ  PðBÞ:
Example 7.5 For a roll of two dice, the probability of rolling two sixes is 1/36 if the
two dice are independent because
PðD1 ¼ 6 ^ D2 ¼ 6Þ ¼ PðD1 ¼ 6Þ  PðD2 ¼ 6Þ ¼ 1
6  1
6 ¼ 1
36 ;
where the ﬁrst equation is only true when the two dice are independent. If for
example by some magic power die 2 is always the same as die 1, then
PðD1 ¼ 6 ^ D2 ¼ 6Þ ¼ 1
6 :
Chain Rule
Solving the deﬁnition of conditional probability for P(A ∧B) results in the
so-called product rule
PðA ^ BÞ ¼ PðAjBÞ PðBÞ;
which we immediately generalize for the case of n variables. By repeated appli-
cation of the above rule we obtain the chain rule
PðX1; . . . ; XnÞ
¼ PðXnjX1; . . . ; Xn1Þ  PðX1; . . . ; Xn1Þ
¼ PðXnjX1; . . . ; Xn1Þ  PðXn1jX1; . . . ; Xn2Þ  PðX1; . . . ; Xn2Þ
¼ PðXnjX1; . . . ; Xn1Þ  PðXn1jX1; . . . ; Xn2Þ  . . .  PðXnjX1Þ  PðX1Þ
¼
Y
n
i¼1
PðXnjX1; . . . ; Xi1Þ;
ð7:1Þ
with which we can represent a distribution as a product of conditional probabilities.
Because the chain rule holds for all values of the variables X1; . . . ; Xn, it has been
formulated for the distribution using the symbol P.
Marginalization
Because A ⇔(A ∧B) ∨(A ∧¬B) is true for binary variables A and B
PðAÞ ¼ PððA ^ BÞ _ ðA ^ :BÞÞ ¼ PðA ^ BÞ þ PðA ^ :BÞ:
132
7
Reasoning with Uncertainty

By summation over the two values of B, the variable B is eliminated. Analogously,
for arbitrary variables X1; . . . ; Xd, a variable, for example Xd, can be eliminated by
summation over all of their variables and we get
PðX1 ¼ x1; . . . ; Xd1 ¼ xd1Þ ¼
X
xd
PðX1 ¼ x1; . . . ; Xd1 ¼ xd1; Xd ¼ xdÞ:
The application of this formula is called marginalization. This summation can
continue with the variables X1, … , Xd−1 until just one variable is left. Marginal-
ization can also be applied to the distribution P(X1, … , Xd). The resulting distri-
bution P(X1, … , Xd−1) is called the marginal distribution. It is comparable to the
projection of a rectangular cuboid on a ﬂat surface. Here the three-dimensional
object is drawn on the edge or “margin” of the cuboid, i.e. on a two-dimensional
set. In both cases the dimensionality is reduced by one.
Example 7.6 We observe the set of all patients who come to the doctor with acute
stomach pain. For each patient the leukocyte value is measured, which is a metric
for the relative abundance of white blood cells in the blood. We deﬁne the variable
Leuko, which is true if and only if the leukocyte value is greater than 10,000. This
indicates an infection in the body. Otherwise we deﬁne the variable App, which tells
us whether the patient has appendicitis, that is, an infected appendix. The distri-
bution P(App, Leuko) of these two variables is given in the following table:
In the last row the sum over the rows is given, and in the last column the sum of the
columns is given. These sums are arrived at by marginalization. For example, we
read off
PðLeukoÞ ¼ PðApp; LeukoÞ þ Pð:App; LeukoÞ ¼ 0:54:
The given distribution P(App, Leuko) could come from a survey of German doctors,
for example. From it we can then calculate the conditional probability
PðLeukojAppÞ ¼ PðLeuko; AppÞ
PðAppÞ
¼ 0:82
which tells us that about 82% of all appendicitis cases lead to a high leukocyte
value. Values like this are published in medical literature. However, the conditional
P(App, Leuko)
App
¬App
Total
Leuko
0.23
0.31
0.54
¬Leuko
0.05
0.41
0.46
Total
0.28
0.72
1
7.1
Computing with Probabilities
133

probability P(App|Leuko), which would actually be much more helpful for diag-
nosing appendicitis, is not published. To understand this, we will ﬁrst derive a
simple, but very important formula.
Bayes’ Theorem
Swapping A and B in Deﬁnition 7.3 yields
PðAjBÞ ¼ PðA ^ BÞ
PðBÞ
and
PðBjAÞ ¼ PðA ^ BÞ
PðAÞ
:
By solving both equations for PðA ^ BÞ and equating them we obtain Bayes’
theorem
PðAjBÞ ¼ PðBjAÞ  PðAÞ
PðBÞ
;
ð7:2Þ
whose relevance to many applications we will illustrate using three examples. First
we apply it to the appendicitis example and obtain
Example 7.7
PðAppjLeukoÞ ¼ PðLeukojAppÞ  PðAppÞ
PðLeukoÞ
¼ 0:82  0:28
0:54
¼ 0:43:
ð7:3Þ
Why then is PðLeukojAppÞ published, but not PðAppjLeukoÞ?
Assuming that appendicitis affects the biology of all humans the same, regard-
less of ethnicity, PðLeukojAppÞ is a universal value that is valid worldwide. In
Equation 7.3 we see that PðAppjLeukoÞ is not universal, for this value is inﬂuenced
by the a priori probabilities PðAppÞ and PðLeukoÞ. Each of these can vary
according to one’s life circumstances. For example, PðLeukoÞ is dependent on
whether a population has a high or low rate of exposure to infectious diseases. In
the tropics, this value can differ signiﬁcantly from that of cold regions. Bayes’
theorem, however, makes it easy for us to take the universally valid value
PðLeukojAppÞ, and compute PðAppjLeukoÞ which is useful for diagnosis.
Before we dive deeper into this example and build a medical expert system for
appendicitis in Sect. 7.3 let us ﬁrst apply Bayes’ theorem to another interesting
medical example.
Example 7.8 In cancer diagnosis, so-called tumor markers are often measured. One
example of this is the use of the tumor marker PSA (prostate speciﬁc antigen) for
the diagnosis of prostate cancer (PCa = prostate cancer) in men. Assuming that no
further tests for PCa have been conducted, the test is considered positive, that is,
there is suspected PCa, if the concentration of PSA reaches a level at or above
4 ng/ml. If this occurs, the probability P Cjpos
ð
Þ of PCa is of interest to the patient.
134
7
Reasoning with Uncertainty

The binary variable C is true if the patient has PCa, and pos represents a PSA value
 4 ng=ml. Let us now compute the P Cjpos
ð
Þ. For reasons similar to those men-
tioned for appendicitis diagnosis, this value is not reported. Instead, researchers
publish the sensitivity P posjC
ð
Þ and the speciﬁcity Pðnegj:CÞ of the test.2
According to [HL04], for a sensitivity of 0.95, the speciﬁcity can be at most 0.25,
which is why we proceed from PðposjCÞ ¼ 0:95 and Pðnegj:CÞ ¼ 0:25 below. We
apply Bayes’ theorem and obtain
PðCjposÞ ¼ PðposjCÞ  PðCÞ
PðposÞ
¼
PðposjCÞ  PðCÞ
PðposjCÞ  PðCÞ þ Pðposj:CÞ  Pð:CÞ
¼
0:95  0:0021
0:95  0:0021 þ 0:75  0:99679 ¼ 0:95  0:0021
0:75
¼ 0:0027:
Here
we
use
Pðposj:CÞ ¼ 1  Pðnegj:CÞ ¼ 1  0:25 ¼ 0:75
and
PðCÞ ¼
0:0021 ¼ 0:21% as the a priori probability of PCa during one year.3 It makes sense
to assume that the PSA test is done once per year. This result is somewhat sur-
prising from the patient’s perspective because the probability of PCa after a positive
test is, at 0:27%, only marginally higher than the probability of 0:21% for PCa for a
55-year-old man. Thus, a PSA value of just over 4 ng/ml is deﬁnitively no reason
for the patient to panic. At most it is used as a basis for further examinations, such
as biopsy or MRI, leading if necessary to radiation and surgery. The situation is
similar for many other tumor markers such as those for colorectal cancer or breast
cancer diagnosis by mammography.
The cause of this problem is the very low speciﬁcity Pðnegj:CÞ ¼ 0:25, which
leads to 75% of healthy patients (without PCa) getting a false-positive test result
and consequently undergoing unnecessary examinations. Because of this, PSA
testing has been a controversial discussion topic for years.4
Assume we had a better test with a speciﬁcity of 99%, which would only deliver
a false-positive result for one percent of healthy men. Then, in the above calcula-
tion, we would assign Pðposj:CÞ the value 0.01 and obtain the result
PðCjposÞ ¼ 0; 17. Plainly, this test would be much more speciﬁc.
Example 7.9 A sales representative who wants to sell an alarm system could make
the following argument:
If you buy this very reliable alarm system, it will alert you to any break-in with 99%
certainty. Our competitor’s system only offers a certainty of 85%.
Hearing this, if the buyer concludes that from an alert A he can infer a break-in
B with high certainty, he is wrong. Bayes’ theorem shows the reason. What the
2For deﬁnitions of sensitivity and speciﬁcity see Eqs. 7.16 and 7.17.
3See http://www.prostata.de/pca_haeuﬁgkeit.html for a 55-year-old man.
4The author is not a medical doctor. Therefore these computations should not be used as a basis for
personal medical decisions by potentially afﬂicted individuals. If necessary, please consult a
specialist physician or the relevant specialist literature.
7.1
Computing with Probabilities
135

representative told us is that PðAjBÞ ¼ 0:99. What he doesn’t say, however, is what
it means when we hear the alarm go off. To ﬁnd out, we use Bayes’ theorem to
compute P(B|A) and assume that the buyer lives in a relatively safe area in which
break-ins are rare, with PðBÞ ¼ 0:001. Additionally, we assume that the alarm
system is triggered not only by burglars, but also by animals, such as birds or cats in
the yard, which results in PðAÞ ¼ 0:1. Thus we obtain
PðBjAÞ ¼ PðAjBÞPðBÞ
PðAÞ
¼ 0:99  0:001
0:1
¼ 0:01;
which means that whoever buys this system will not be happy because they will be
startled by too many false alarms. When we examine the denominator
PðAÞ ¼ PðAjBÞ PðBÞ þ PðAj:BÞ Pð:BÞ ¼ 0:00099 þ PðAj:BÞ  0:999 ¼ 0:1
of Bayes’ theorem more closely, we see that PðAj:BÞ  0:1, which means that the
alarm will be triggered roughly every tenth day that there is not a break-in.
From this example we learn, among other things, that it is important to consider
which probabilities we are really interested in as a buyer, expecially when it
comes to security. When the arguments of a conditional probability are inter-
changed, the value can change dramatically when the prior probabilities differ
signiﬁcantly.
7.2
The Principle of Maximum Entropy
We will now show, using an inference example, that a calculus for reasoning under
uncertainty can be realized using probability theory. However, we will soon see that
the well-worn probabilistic paths quickly come to an end. Speciﬁcally, when too
little knowledge is available to solve the necessary equations, new ideas are needed.
The American physicist E.T. Jaynes did pioneering work in this area in the 1950s.
He claimed that given missing knowledge, one can maximize the entropy of the
desired probability distribution, and applied this principle to many examples in
[Jay57, Jay03]. This principle was then further developed [Che83, Nil86, Kan89,
KK92] and is now mature and can be applied technologically, which we will show
in the example of the LEXMED project in Sect. 7.3.
7.2.1
An Inference Rule for Probabilities
We want to derive an inference rule for uncertain knowledge that is analogous to
the modus ponens. From the knowledge of a proposition A and a rule A ⇒B, the
conclusion B shall be reached. Formulated succinctly, this reads
136
7
Reasoning with Uncertainty

A; A ! B
B
:
The generalization for probability rules yields
PðAÞ ¼ a;
PðBjAÞ ¼ b
PðBÞ ¼ ?
:
Let the two probability rules α, β be given and the value P(B) desired. By
marginalization we obtain the desired marginal distribution
PðBÞ ¼ PðA; BÞ þ Pð:A; BÞ ¼ PðBjAÞ  PðAÞ þ PðBj:AÞ  Pð:AÞ:
The three values P(A), P(¬A), P BjA
ð
Þ on the right side are known, but the value
P(B| ¬A) is unknown. We cannot make an exact statement about P(B) with classical
probability theory, but at the most we can estimate P B
ð Þ  P BjA
ð
Þ  PðAÞ.
We now consider the distribution
PðA; BÞ ¼ ðPðA; BÞ; PðA; :BÞ; Pð:A; BÞ; Pð:A; :BÞÞ
and introduce for shorthand the four unknowns
p1 ¼ PðA; BÞ;
p2 ¼ PðA; :BÞ;
p3 ¼ Pð:A; BÞ;
p4 ¼ Pð:A; :BÞ:
These four parameters determine the distribution. If they are all known, then every
probability for the two variables A and B can be calculated. To calculate the four
unknowns, four equations are needed. One equation is already known in the form of
the normalization condition
p1 þ p2 þ p3 þ p4 ¼ 1:
Therefore, three more equations are needed. In our example, however, only two
equations are known.
From the given values PðAÞ ¼ a and PðBjAÞ ¼ b we calculate
PðA; BÞ ¼ PðBjAÞ  PðAÞ ¼ ab
and
PðAÞ ¼ PðA; BÞ þ PðA; :BÞ:
7.2
The Principle of Maximum Entropy
137

From this we can set up the following system of equations and solve it as far as is
possible:
p1 ¼ ab;
ð7:4Þ
p1 þ p2 ¼ a;
ð7:5Þ
p1 þ p2 þ p3 þ p4 ¼ 1;
ð7:6Þ
ð7:4Þ in (7.5):
p2 ¼ a  ab ¼ að1  bÞ;
ð7:7Þ
ð7:5Þ in ð7:6Þ:
p3 þ p4 ¼ 1  a:
ð7:8Þ
The probabilities p1, p2 for the interpretations (A, B) and (A, ¬B) are thus
known, but for the values p3, p4 only one equation still remains. To come to a
deﬁnite solution despite this missing knowledge, we change our point of view.
We use the given equation as a constraint for the solution of an optimization
problem.
We are looking for a distribution p (for the variables p3, p4) which maximizes
the entropy
Hð pÞ ¼ 
X
n
i¼1
pi ln pi ¼ p3 ln p3  p4 ln p4
ð7:9Þ
under the constraint p3 + p4 = 1 −α (7.8). Why exactly should the entropy
function be maximized? Because we are missing information about the distribu-
tion, it must somehow be added in. We could ﬁx an ad hoc value, for example
p3 = 0.1. Yet it is better to determine the values p3 and p4 such that the infor-
mation added is minimal. We can show (Sect. 8.4.2 and [SW76]) that entropy
measures the uncertainty of a distribution up to a constant factor. Negative entropy
is then a measure of the amount of information a distribution contains. Maxi-
mization of entropy minimizes the information content of the distribution. To
visualize this, the entropy function for the two-dimensional case is represented
graphically in Fig. 7.2 on page 139.
To determine the maximum of the entropy under the constraint p3 + p4 −1 + α = 0
we use the method of Lagrange multipliers [Ste07]. The Lagrange function reads
L ¼ p3 ln p3  p4 ln p4 þ kðp3 þ p4  1 þ aÞ:
Taking the partial derivatives with respect to p3 and p4 we obtain
@L
@p3
¼  ln p3  1 þ k ¼ 0;
@L
@p4
¼  ln p4  1 þ k ¼ 0
138
7
Reasoning with Uncertainty

and calculate
p3 ¼ p4 ¼ 1  a
2
:
Now we can calculate the desired value
PðBÞ ¼ PðA; BÞ þ Pð:A; BÞ ¼ p1 þ p3 ¼ ab þ 1  a
2
¼ a

b  1
2

þ 1
2 :
Substituting in α and β yields
PðBÞ ¼ PðAÞ

PðBjAÞ  1
2

þ 1
2 :
P(B) is shown in Fig. 7.3 on page 140 for various values of P BjA
ð
Þ. We see that in
the two-value edge case, that is, when P(B) and P BjA
ð
Þ take on the values 0 or 1,
probabilistic inference returns the same value for P(B) as the modus ponens. When
A and B|A are both true, B is also true. An interesting case is P(A) = 0, in which
¬A is true. Modus ponens cannot be applied here, but our formula results in the
value 1/2 for P(B) irrespective of P BjA
ð
Þ. When A is false, we know nothing about
B, which reﬂects our intuition exactly. The case where P(A) = 1 and P BjA
ð
Þ = 0 is
also covered by propositional logic. Here A is true and A ⇒B false, and thus
A ∧¬B true. Then B is false. The horizontal line in the ﬁgure means that we cannot
make a prediction about B in the case of P BjA
ð
Þ = 1/2. Between these points,
P(B) changes linearly for changes to P(A) or P BjA
ð
Þ.
Fig. 7.2 Contour line
diagram of the
two-dimensional entropy
function. We see that it is
strictly convex in the whole
unit square and that it has an
isolated global maximum.
Also marked is the constraint
p3 + p4 = 1 as a special case of
the condition p3 + p4 −1 + α = 0
for α = 0 which is relevant here
7.2
The Principle of Maximum Entropy
139

Theorem 7.3 Let there be a consistent5 set of linear probabilistic equations.
Then there exists a unique maximum for the entropy function with the given
equations as constraints. The MaxEnt distribution thereby deﬁned has min-
imum information content under the constraints.
It follows from this theorem that there is no distribution which satisﬁes the
constraints and has higher entropy than the MaxEnt distribution. A calculus that
leads to lower entropy puts in additional ad hoc information, which is not justiﬁed.
Looking more closely at the above calculation of P(B), we see that the two
values p3 and p4 always occur symmetrically. This means that swapping the two
variables does not change the result. Thus the end result is p3 = p4. The so-called
indifference of these two variables leads to them being set equal by MaxEnt. This
relationship is valid generally:
Deﬁnition 7.5 If an arbitrary exchange of two or more variables in the
Lagrange equations results in equivalent equations, these variables are called
indifferent.
Fig. 7.3 Curve array for P(B) as a function of P(A) for different values of P BjA
ð
Þ
5A set of probabilistic equations is called consistent if there is at least one solution, that is, one
distribution which satisﬁes all equations.
140
7
Reasoning with Uncertainty

Theorem 7.4 If a set of variables fpi1; . . . ; pikg is indifferent, then the
maximum of the entropy under the given constraints is at the point where
pi1 ¼ pi2 ¼    ¼ pik.
With this knowledge we could have immediately set the two variables p3 and p4
equal (without solving the Lagrange equations).
7.2.2
Maximum Entropy Without Explicit Constraints
We now look at the case in which no knowledge is given. This means that, other
than the normalization condition
p1 þ p2 þ    þ pn ¼ 1;
there are no constraints. All variables are therefore indifferent. Therefore we can set
them equal and it follows that p1 = p2 = ⋅⋅⋅= pn = 1/n.6 For reasoning under
uncertainty, this means that given a complete lack of knowledge, all worlds are
equally probable. That is, the distribution is uniform. For example, in the case of
two variables A and B it would be the case that
PðA; BÞ ¼ PðA; :BÞ ¼ Pð:A; BÞ ¼ Pð:A; :BÞ ¼ 1=4;
from which P(A) = P(B) = 1/2 and P(B|A) = 1/2 follow. The result for the
two-dimensional case can be seen in Fig. 7.2 on page 139 because the marked
condition is exactly the normalization condition. We see that the maximum of the
entropy lies on the line at exactly (1/2, 1/2).
As soon as the value of a condition deviates from the one derived from the
uniform distribution, the probabilities of the worlds shift. We show this in a further
example. With the same descriptions as used above we assume that only
PðBjAÞ ¼ b
is known. Thus PðA; BÞ ¼ PðBjAÞPðAÞ ¼ bPðAÞ, from which p1 = β(p1 + p2)
follows and we derive the two constraints
bp2 þ ðb  1Þp1 ¼ 0;
p1 þ p2 þ p3 þ p4  1 ¼ 0:
6The reader may calculate this result by maximization of the entropy under the normalization
condition (Exercise 7.5 on page 132).
7.2
The Principle of Maximum Entropy
141

Here the Lagrange equations can no longer be solved symbolically so easily.
A numeric solution of the Lagrange equations yields the picture represented in
Fig. 7.4, which shows that p3 = p4. We can already see this in the constraints, in which
p3 and p4 are indifferent. For P BjA
ð
Þ = 1/2 we obtain the uniform distribution, which
is no surprise. This means that the constraint for this value does not imply a restriction
on the distribution. Furthermore, we can see that for small P(B|A), P(A, B) is
also small.
7.2.3
Conditional Probability Versus Material Implication
We will now show that, for modeling reasoning, conditional probability is better
than what is known in logic as material implication (to this end, also see [Ada75]).
First we observe the truth table shown in Table 7.1, in which the conditional
probability and material implication for the extreme cases of probabilities zero and
one are compared. In both cases with false premises (which, intuitively, are critical
cases), P BjA
ð
Þ is undeﬁned, which makes sense.
Fig. 7.4 p1, p2, p3, p4 in dependence on β
Table 7.1 Truth table for material implication and conditional probability for propositional logic
limit
A
B
A ⇒B
P(A)
P(B)
P BjA
ð
Þ
t
t
t
1
1
1
t
f
f
1
0
0
f
t
t
0
1
Undeﬁned
f
f
t
0
0
Undeﬁned
142
7
Reasoning with Uncertainty

Now we ask ourselves which value is taken on by P BjA
ð
Þ when arbitrary values
P(A) = α and P(B) = γ are given and no other information is known. Again we
maximize entropy under the given constraints. As above we set
p1 ¼ PðA; BÞ;
p2 ¼ PðA; :BÞ;
p3 ¼ Pð:A; BÞ;
p4 ¼ Pð:A; :BÞ
and obtain as constraints
p1 þ p2 ¼ a;
ð7:10Þ
p1 þ p3 ¼ c;
ð7:11Þ
p1 þ p2 þ p3 þ p4 ¼ 1:
ð7:12Þ
With this we calculate using entropy maximization (see Exercise 7.8 on page 173)
p1 ¼ ac;
p2 ¼ að1  cÞ;
p3 ¼ cð1  aÞ;
p4 ¼ ð1  aÞð1  cÞ:
From p1 = αγ it follows that P(A, B) = P(A) ⋅P(B), which means that A and B are
independent. Because there are no constraints connecting A and B, the MaxEnt
principle results in the independence of these variables. The right half of Table 7.1
on page 142 makes this easier to understand. From the deﬁnition
PðBjAÞ ¼ PðA; BÞ
PðAÞ
it follows for the case P(A) ≠0, that is, when the premise is not false, because A and
B are independent, that P BjA
ð
Þ ¼ P B
ð Þ. For the case P(A) = 0, P BjA
ð
Þ remains
undeﬁned.
7.2.4
MaxEnt-Systems
As previously mentioned, due to the nonlinearity of the entropy function, MaxEnt
optimization usually cannot be carried out symbolically for non-trivial problems.
Thus two systems were developed for numerical entropy maximization. The ﬁrst
system, SPIRIT (Symmetrical Probabilistic Intensional Reasoning in Inference
Networks in Transition, www.xspirit.de), [RM96] was built at Fernuniversität
Hagen. The second, PIT (Probability Induction Tool) was developed at the Munich
Technical University [Sch96, ES99, SE00]. We will now brieﬂy introduce PIT.
The PIT system uses the sequential quadratic programming (SQP) method to
ﬁnd an extremum of the entropy function under the given constraints. As input, PIT
7.2
The Principle of Maximum Entropy
143

expects data containing the constraints. For example, the constraints P(A) = α and
P(B|A) = β from Sect. 7.2.1 have the form
var A{t,f}, B{t,f};
P([A=t]) = 0.6;
P([B=t] | [A=t]) = 0.3;
QP([B=t]);
QP([B=t] | [A=t]);
Because PIT performs a numerical calculation, we have to input explicit proba-
bility values. The second to last row contains the query QP([B = t]). This means
that P(B) is the desired value. At www.pit-systems.de under “Examples” we now put
this input into a blank input page (“Blank Page”) and start PIT. As a result we get
and from there read off P(B) = 0.38 and P BjA
ð
Þ ¼ 0:3.
Nr.
Truth value
Probability
Query
1
UNSPECIFIED
3.800e–01
QP([B = t]);
2
UNSPECIFIED
3.000e–01
QP([A = t]-|> [B = t]);
7.2.5
The Tweety Example
We now show, using the Tweety example from Sect. 4.3, that probabilistic rea-
soning and in particular MaxEnt are non-monotonic and model everyday reasoning
very well. We model the relevant rules with probabilities as follows:
P(birdjpenguin) = 1
‘‘penguins are birds’’
P( fliesjbird)
2 [0.95, 1]
‘‘(almost all) birds can fly’’
P( fliesjpenguin) = 0
‘‘penguins cannot fly’’
The ﬁrst and third rules represent ﬁrm predictions, which can also be easily
formulated in logic. In the second, however, we express our knowledge that almost
all birds can ﬂy by means of a probability interval. With the PIT input data
var penguin{yes,no}, bird{yes,no}, flies{yes,no};
P([bird=yes] | [penguin=yes]) = 1;
P([flies=yes] | [bird=yes]) IN [0.95,1];
P([flies=yes] | [penguin=yes]) = 0;
QP([flies=yes]| [penguin=yes]);
144
7
Reasoning with Uncertainty

we get back the correct answer
with the proposition that penguins cannot ﬂy.7 The explanation for this is very
simple. With P fliesjbird
ð
Þ 2 [0.95, 1] it is possible that there are non-ﬂying birds. If
this rule were replaced by P(ﬂies|bird) = 1, then PIT would not be able to do
anything and would output an error message about inconsistent constraints.
In this example we can easily see that probability intervals are often very helpful
for modeling our ignorance about exact probability values. We could have made an
even fuzzier formulation of the second rule in the spirit of “normally birds ﬂy” with
P(ﬂies|bird) 2 (0.5, 1]. The use of the half-open interval excludes the value 0.5.
It has already been shown in [Pea88] that this example can be solved using
probabilistic logic, even without MaxEnt. In [Sch96] it is shown for a number of
demanding benchmarks for non-monotonic reasoning that these can be solved
elegantly with MaxEnt. In the following section we introduce a successful practical
application of MaxEnt in the form of a medical expert system.
7.3
LEXMED, an Expert System for Diagnosing Appendicitis
The medical expert system LEXMED, which uses the MaxEnt method, was developed
at the Ravensburg-Weingarten University of Applied Sciences by Manfred
Schramm, Walter Rampf, and the author, in cooperation with the Weingarten
14-Nothelfer Hospital [SE00, Le999].8 The acronym LEXMED stands for learning
expert system for medical diagnosis.
7.3.1
Appendicitis Diagnosis with Formal Methods
The most common serious cause of acute abdominal pain [dD91] is appendicitis—
an inﬂammation of the appendix, a blind-ended tube connected to the cecum. Even
today, diagnosis can be difﬁcult in many cases [OFY+95]. For example, up to about
20% of the removed appendices are without pathological ﬁndings, which means
that the operations were unnecessary. Likewise, there are regularly cases in which
an inﬂamed appendix is not recognized as such.
Since as early as the beginning of the 1970s, there have been attempts to automate
the diagnosis of appendicitis, with the goal of reducing the rate of false
Nr.
Truthvalue
Probability
Query
1
UNSPECIFIED
0.000e+00
QP([penguin = yes]-|> [ﬂies = yes]);
7QP([penguin=yes]-|> [ﬂies=yes]) is an alternative form of the PIT syntax for
QP([ﬂies=yes] | [penguin=yes]).
8The project was ﬁnanced by the German state of Baden-Württemberg, the health insurance
company AOK Baden-Württemberg, the Ravensburg-Weingarten University of Applied Sciences,
and the 14 Nothelfer Hospital in Weingarten.
7.2
The Principle of Maximum Entropy
145

diagnoses [dDLS+72, OPB94, OFY+95]. Especially noteworthy is the expert sys-
tem for diagnosis of acute abdominal pain, developed by de Dombal in Great Britain.
It was made public in 1972, thus distinctly earlier than the famous system MYCIN.
Nearly all of the formal diagnostic processes used in medicine to date have been
based on scores. Score systems are extremely easy to apply: For each value of a
symptom (for example fever or lower right stomach pain) the doctor notes a certain
number of points. If the sum of the points is over a certain value (threshold), a certain
decision is recommended (for example operation). For n symptoms S1, …, Sn a
score for appendicitis can be described formally as
Diagnose ¼
Appendicitis
if w1S1 þ    þ wnSn [ H;
negative
else.

With scores, a linear combination of symptom values is thus compared with a
threshold Θ. The weights of the symptoms are extracted from databases using
statistical methods. The advantage of scores is their simplicity of application. The
weighted sum of the points can be computed by hand easily and a computer is not
needed for the diagnosis.
Because of the linearity of this method, scores are too weak to model complex
relationships. Since the contribution wiSi of a symptom Si to the score is calculated
independently of the other symptoms, it is clear that score systems cannot take any
“context” into account. Principally, they cannot distinguish between combinations
of symptoms, for example they cannot distinguish between the white blood cell
count of an old patient and that of a young patient.
For a ﬁxed given set of symptoms, conditional probability is much more
powerful than scores for making predictions because the latter cannot describe the
dependencies between different symptoms. We can show that scores implicitly
assume that all symptoms are independent.
When using scores, yet another problem comes up. To arrive at a good diagnosis
quality, we must put strict requirements on the databases used to statistically
determine the weights wi. In particular they must be representative of the set of
patients in the area in which the diagnosis system is used. This is often difﬁcult, if
not impossible, to guarantee. In such cases, scores and other statistical methods
either cannot be used, or will have a high rate of errors.
7.3.2
Hybrid Probabilistic Knowledge Base
Complex probabilistic relationships appear frequently in medicine. With LEXMED,
these relationships can be modeled well and calculated quickly. Here the use of
probabilistic propositions, with which uncertain and incomplete information can be
expressed and processed in an intuitive and mathematically grounded way, is
essential. The following question may serve as a typical query against the expert
system: “How high is the probability of an inﬂamed appendix if the patient is a
23-year-old man with pain in the right lower abdomen and a white blood cell count
146
7
Reasoning with Uncertainty

of 13,000?” Formulated as conditional probability, using the names and value
ranges for the symptoms used in Table 7.2, this reads
PðDiag4 ¼ inflamed _ Diag4 ¼ perforated j
Sex2 ¼ male ^ Age10 2 2125 ^ Leuko7 2 12k15kÞ:
By using probabilistic propositions, LEXMED has the ability to use information
from non-representative databases because this information can be complemented
appropriately from other sources. Underlying LEXMED is a database which only
contains data about patients whose appendixes were surgically removed. With
statistical methods, (about 400) rules are generated which compile the knowledge
contained in the database into an abstracted form [ES99]. Because there are no
patients in this database who were suspected of having appendicitis but had neg-
ative diagnoses (that is, not requiring treatment),9 there is no knowledge about
negative patients in the database. Thus knowledge from other sources must be
added in. In LEXMED therefore the rules gathered from the database are comple-
mented by (about 100) rules from medical experts and the medical literature. This
results in a hybrid probabilistic database, which contains knowledge extracted from
data as well as knowledge explicitly formulated by experts. Because both types of
rules are formulated as conditional probabilities (see for example (7.14) on
page 152), they can be easily combined, as shown in Fig. 7.5 on page 148 and with
more details in Fig. 7.7 on page 150.
Table 7.2 Symptoms used for the query in LEXMED and their values. The number of values for
the each symptom is given in the column marked #
Symptom
Values
#
Short
Gender
Male, female
2
Sex2
Age
0–5, 6–10, 11–15, 16–20, 21–25, 26–35, 36–45, 46–55, 56–65, 65– 10
Age10
Pain 1st Quad.
Yes, no
2
P1Q2
Pain 2nd Quad.
Yes, no
2
P2Q2
Pain 3rd Quad.
Yes, no
2
P3Q2
Pain 4th Quad.
Yes, no
2
P4Q2
Guarding
Local, global, none
3
Gua3
Rebound tenderness
Yes, no
2
Reb2
Pain on tapping
Yes, no
2
Tapp2
Rectal pain
Yes, no
2
RecP2
Bowel sounds
Weak, normal, increased, none
4
BowS4
Abnormal ultrasound
Yes, no
2
Sono2
Abnormal urine sedim. Yes, no
2
Urin2
Temperature (rectal)
–37.3, 37.4–37.6, 37.7–38.0, 38.1–38.4, 38.5–38.9, 39.0–
6
TRec6
Leukocytes
0–6k, 6k–8k, 8k–10k, 10k–12k, 12k–15k, 15k–20k, 20k–
7
Leuko7
Diagnosis
Inﬂamed, perforated, negative, other
4
Diag4
9These negative diagnoses are denoted “non-speciﬁc abdominal pain” (NSAP).
7.3
LEXMED, an Expert System for Diagnosing Appendicitis
147

LEXMED calculates the probabilities of various diagnoses using the probability
distribution of all relevant variables (see Table 7.2 on page 147). Because all 14
symptoms used in LEXMED and the diagnoses are modeled as discrete variables
(even continuous variables like the leukocyte value are divided into ranges), the size
of the distribution (that is, the size of the event space) can be determined using
Table 7.2 on page 147 as the product of the number of values of all symptoms, or
210  10  3  4  6  7  4 ¼ 20643840
elements. Due to the normalization condition from Theorem 7.1 on page 129, it thus
has 20643839 independent values. Every rule set with fewer than 20643839 proba-
bility values potentially does not completely describe this event space. To be able to
answer any arbitrary query, the expert system needs a complete distribution. The
construction of such an extensive, consistent distribution using statistical methods is
very difﬁcult.10 To require from a human expert all 20643839 values for the distri-
bution (instead of the aforementioned 100 rules) would essentially be impossible.
Here the MaxEnt method comes into play. The generalization of about 500 rules
to a complete probability model is done in LEXMED by maximizing the entropy with
the 500 rules as constraints. An efﬁcient encoding of the resulting MaxEnt distri-
bution leads to response times for the diagnosis of around one second.
Fig. 7.5 Probabilistic rules are generated from data and expert knowledge, which are integrated
in a rule base (knowledge base) and ﬁnally made complete using the MaxEnt method
10The task of generating a function from a set of data is known as machine learning. We will cover
this thoroughly in Chap. 8.
148
7
Reasoning with Uncertainty

7.3.3
Application of LEXMED
The usage of LEXMED is simple and self-explanatory. The doctor visits the LEXMED
home page at www.lexmed.de.11 For an automatic diagnosis, the doctor inputs the
results of his examination into the input form in Fig. 7.6. After one or two seconds
he receives the probabilities for the four different diagnoses as well as a suggestion
for a treatment (Sect. 7.3.5). If certain examination results are missing as input
(for example the sonogram results), then the doctor chooses the entry not examined.
Naturally the certainty of the diagnosis is higher when more symptom values
are input.
Fig. 7.6 The LEXMED input mask for input of the examined symptoms and below it the output of
the resulting diagnosis probabilities
11A version with limited functionality is accessible without a password.
7.3
LEXMED, an Expert System for Diagnosing Appendicitis
149

Each registered user has access to a private patient database, in which input data
can be archived. Thus data and diagnoses from earlier patients can be easily
compared with those of a new patient. An overview of the processes in LEXMED is
given in Fig. 7.7.
7.3.4
Function of LEXMED
Knowledge is formalized using probabilistic propositions. For example, the
proposition
PðLeuko7 [ 20000jDiag4 ¼ inflamedÞ ¼ 0:09
gives a frequency of 9% for a leukocyte value of more than 20,000 in case of an
inﬂamed appendix.12
Learning of Rules by Statistical Induction
The raw data in LEXMED’s database contain 54 different (anonymized) values for
14,646 patients. As previously mentioned, only patients whose appendixes were
surgically removed are included in this database. Of the 54 attributes used in the
Fig. 7.7 Rules are generated from the database as well as from expert knowledge. From these,
MaxEnt creates a complete probability distribution. For a user query, the probability of every
possible diagnosis is calculated. Using the cost matrix (see Sect. 7.3.5) a decision is then suggested
12Instead of individual numerical values, intervals can also be used here (for example [0.06, 0.12]).
150
7
Reasoning with Uncertainty

database, after a statistical analysis the 14 symptoms shown in Table 7.2 on
page 147 were used. Now the rules are created from this database in two steps. The
ﬁrst step determines the dependency structure of the symptoms. The second step
ﬁlls this structure with the respective probability rules.13
Determining the Dependency Graph The graph in Fig. 7.8 contains for each
variable (the symptom and the diagnosis) a node and directed edges which connect
various nodes. The thickness of the edges between the variables represents a
measure of the statistical dependency or correlation of the variables. The correlation
of two independent variables is equal to zero. The pair correlation for each of the 14
symptoms with Diag4 was computed and listed in the graph. Furthermore, all triple
correlations between the diagnosis and two symptoms were calculated. Of these,
only the strongest values have been drawn as additional edges between the two
participating symptoms.
Fig. 7.8 Dependency graph computed from the database
13For a systematic introduction to machine learning we refer the reader to Chap. 8.
7.3
LEXMED, an Expert System for Diagnosing Appendicitis
151

Estimating the Rule Probabilities The structure of the dependency graph describes
the structure of the learned rules.14 The rules here have different complexities: there
are rules which only describe the distribution of the possible diagnoses (a priori rules,
for example (7.13)), rules which describe the dependency between the diagnosis and
a symptom (rules with simple conditions, for example (7.14)), and ﬁnally rules which
describe the dependency between the diagnosis and two symptoms, as given in
Fig. 7.9 in PIT syntax.
PðDiag4 ¼ inflamedÞ ¼ 0:40;
ð7:13Þ
PðSono2 ¼ yesjDiag4 ¼ inflamedÞ ¼ 0:43;
ð7:14Þ
PðP4Q2 ¼ yesjDiag4 ¼ inflamed ^ P2Q2 ¼ yesÞ ¼ 0:61:
ð7:15Þ
To keep the context dependency of the saved knowledge as small as possible, all
rules contain the diagnosis in their conditions and not as conclusions. This is quite
similar to the construction of many medical books with formulations of the kind
“With appendicitis we usually see …”. As previously shown in Example 7.6 on
page 133, however, this does not present a problem because, using the Bayesian
formula, LEXMED automatically puts these rules into the right form.
The numerical values for these rules are estimated by counting their frequency in
the database. For example, the value in (7.14) is given by counting and calculating
jDiag4 ¼ inflamed ^ Sono2 ¼ yesj
jDiag4 ¼ inflamedj
¼ 0:43:
1 P([Leuco7=0-6k]
| [Diag4=negativ] * [Age10=16-20]) = [0.132,0.156];
2 P([Leuco7=6-8k]
| [Diag4=negativ] * [Age10=16-20]) = [0.257,0.281];
3 P([Leuco7=8-10k]
| [Diag4=negativ] * [Age10=16-20]) = [0.250,0.274];
4 P([Leuco7=10-12k] | [Diag4=negativ] * [Age10=16-20]) = [0.159,0.183];
5 P([Leuco7=12-15k] | [Diag4=negativ] * [Age10=16-20]) = [0.087,0.112];
6 P([Leuco7=15-20k] | [Diag4=negativ] * [Age10=16-20]) = [0.032,0.056];
7 P([Leuco7=20k-]
| [Diag4=negativ] * [Age10=16-20]) = [0.000,0.023];
8 P([Leuco7=0-6k]
| [Diag4=negativ] * [Age10=21-25]) = [0.132,0.172];
9 P([Leuco7=6-8k]
| [Diag4=negativ] * [Age10=21-25]) = [0.227,0.266];
10 P([Leuco7=8-10k]
| [Diag4=negativ] * [Age10=21-25]) = [0.211,0.250];
11 P([Leuco7=10-12k] | [Diag4=negativ] * [Age10=21-25]) = [0.166,0.205];
12 P([Leuco7=12-15k] | [Diag4=negativ] * [Age10=21-25]) = [0.081,0.120];
13 P([Leuco7=15-20k] | [Diag4=negativ] * [Age10=21-25]) = [0.041,0.081];
14 P([Leuco7=20k-]
| [Diag4=negativ] * [Age10=21-25]) = [0.004,0.043];
Fig. 7.9 Some of the LEXMED rules with probability intervals. “*” stands for “∧” here
14The difference between this and a Bayesian network is, for example, that the rules are equipped
with probability intervals and that only after applying the principle of maximum entropy is a
unique probability model produced.
152
7
Reasoning with Uncertainty

Expert Rules
Because the appendicitis database only contains patients who have undergone the
operation, rules for non-speciﬁc abdominal pain (NSAP) receive their values from
propositions of medical experts. The experiences in LEXMED conﬁrm that the
probabilistic rules are easy to read and can be directly translated into natural lan-
guage. Statements by medical experts about frequency relationships of speciﬁc
symptoms and the diagnosis, whether from the literature or as the result of an
interview, can therefore be incorporated into the rule base with little expense. To
model the uncertainty of expert knowledge, the use of probability intervals has
proven effective. The expert knowledge was primarily acquired from the partici-
pating surgeons, Dr. Rampf and Dr. Hontschik, and their publications [Hon94].
Once the expert rules have been created, the rule base is ﬁnished. Then the
complete probability model is calculated with the method of maximum entropy by
the PIT-system.
Diagnosis Queries
Using its efﬁciently stored probability model, LEXMED calculates the probabilities
for the four possible diagnoses within a few seconds. For example, we assume the
following output:
A decision must be made based on these four probability values to pursue one of
the four treatments: operation, emergency operation, stationary observation, or
ambulant observation.15 While the probability for a negative diagnosis in this case
outweighs the others, sending the patient home as healthy is not a good decision.
We can clearly see that, even when the probabilities of the diagnoses have been
calculated, the diagnosis is not yet ﬁnished.
Rather, the task is now to derive an optimal decision from these probabilities.
To this end, the user can have LEXMED calculate a recommended decision.
7.3.5
Risk Management Using the Cost Matrix
How can the computed probabilities now be translated optimally into decisions?
A naive algorithm would assign a decision to each diagnosis and ultimately select
the decision that corresponds to the highest probability. Assume that the computed
probabilities are 0.40 for the diagnosis appendicitis (inﬂamed or perforated), 0.55
for the diagnosis negative, and 0.05 for the diagnosis other. A naive algorithm
would now choose the (too risky) decision “no operation” because it corresponds to
the diagnosis with the higher probability. A better method consists of comparing
Diagnosis
Results of the PIT diagnosis
Appendix inﬂamed
Appendix perforated
Negative
Other
Probability
0.24
0.16
0.57
0.03
15Ambulant observation means that the patient is released to stay at home.
7.3
LEXMED, an Expert System for Diagnosing Appendicitis
153

Table 7.3 The cost matrix of LEXMED together with a patient’s computed diagnosis probabilities
Therapy
Probability of various diagnoses
Inﬂamed
Perforated
Negative
Other
0.25
0.15
0.55
0.05
Operation
0
500
5800
6000
3565
Emergency operation
500
0
6300
6500
3915
Ambulant observ.
12000
150000
0
16500
26325
Other
3000
5000
1300
0
2215
Stationary observ.
3500
7000
400
600
2175
the costs of the possible errors that can occur for each decision. The error is
quantiﬁed in the form of “(hypothetical) additional cost of the current decision
compared to the optimum”. The given values contain the costs to the hospital, to the
insurance company, the patient (for example risk of post-operative complications),
and to other parties (for example absence from work), taking into account long term
consequences. These costs are given in Table 7.3.
The entries are ﬁnally averaged for each decision, that is, summed while taking
into account their frequencies. These are listed in the last column in Table 7.3.
Finally, the decision with the smallest average cost of error is suggested. In
Table 7.3 the matrix is given together with the probability vector calculated for a
patient (in this case: (0.25, 0.15, 0.55, 0.05)). The last column of the table contains
the result of the calculations of the average expected costs of the errors. The value of
Operation in the ﬁrst row is thus calculated as 0.25 ⋅0 + 0.15 ⋅500 + 0.55 ⋅5800 +
0.05 ⋅6000 = 3565, a weighted average of all costs. The optimal decisions are
entered with (additional) costs of 0. The system decides on the treatment with the
minimal average cost. It thus is an example of a cost-oriented agent.
Cost Matrix in the Binary Case
To better understand the cost matrix and risk management we will now restrict the
LEXMED system to the two-value decision between the diagnosis appendicitis with
probability
p1 ¼ PðappendicitisÞ ¼ PðDiag4 ¼ inflamedÞ þ PðDiag4 ¼ perforatedÞ
and NSAP with the probability
p2 ¼ PðNSAPÞ ¼ PðDiag4 ¼ negativeÞ þ PðDiag4 ¼ otherÞ
The only available treatments are operation and ambulant observation.
The cost matrix is thus a 2 × 2 matrix of the form
0
k2
k1
0


:
154
7
Reasoning with Uncertainty

The two zeroes in the diagonal stand for the correct decision operation in the case
of appendicitis and ambulant observation for NSAP. The parameter k2 stands for
the expected costs which occur when a patient without an inﬂamed appendix is
operated on. This error is called a false positive. On the other hand, the decision
ambulant observation in the case of appendicitis is a false negative. The probability
vector (p1, p2)T is now multiplied by this matrix and we obtain the vector
ðk2 p2; k1 p1ÞT
with the average additional cost for the two possible treatments. Because the
decision only takes into account the relationship of the two components, the vector
can be multiplied by any scalar factor. We choose 1/k1 and obtain ((k2/k1) p2, p1).
Thus only the relationship k = k2/k1 is relevant here. The same result is obtained by
the simpler cost matrix
0
k
1
0


;
which only contains the variable k. This parameter is very important because it
determines risk management. By changing k we can ﬁt the “working point” of the
diagnosis system. For k →∞the system is put in an extremely risky setting
because no patient will ever be operated on, with the consequence that it gives no
false positive classiﬁcations, but many False negatives. In the case of k = 0 the
conditions are in exact reverse and all patients are operated upon.
7.3.6
Performance
LEXMED is intended for use in a medical practice or ambulance. Prerequisites for the
use of LEXMED are acute abdominal pain for several hours (but less than ﬁve days).
Furthermore, LEXMED is (currently) specialized for appendicitis, which means that
for other illnesses the system contains very little information.
In the scope of a prospective study, a representative database with 185 cases was
created in the 14 Nothelfer Hospital. It contains the hospital’s patients who came to
the clinic after several hours of acute abdominal pain and suspected appendicitis.
From these patients, the symptoms and the diagnosis (veriﬁed from a tissue sample
in the case of an operation) is noted.
If the patients were released to go home (without operation) after a stay of
several hours or 1–2 days with little or no complaint, it was afterwards inquired by
telephone whether the patient remained free of symptoms or whether a positive
diagnosis was found in subsequent treatment.
To simplify the representation and make for a better comparison to similar
studies, LEXMED was restricted to the two-value distinction between appendicitis
and NSAP, as described in Sect. 7.3.5. Now k is varied between zero and inﬁnity
7.3
LEXMED, an Expert System for Diagnosing Appendicitis
155

and for every value of k the sensitivity and speciﬁcity are measured against the test
data. Sensitivity measures
Pðclassified positivejpositiveÞ ¼ jpositive and classified positivej
jpositivej
;
ð7:16Þ
that is, the relative portion of positive cases which are correctly identiﬁed. It indi-
cates how sensitive the diagnostic system is. Speciﬁcity, on the other hand, measures
Pðclassified negativejnegativeÞ ¼ jnegative and classified negativej
jnegativej
;
ð7:17Þ
that is, the relative portion of negative cases which are correctly identiﬁed.
We give the results of the sensitivity and speciﬁcity in Fig. 7.10 for 0 ≤k < ∞.
This curve is denoted the ROC curve, or receiver operating characteristic. Before
we come to the analysis of the quality of LEXMED, a few words about the meaning of
the ROC curve. The line bisecting the diagram diagonally is drawn in for orien-
tation. All points on this line correspond to a random decision. For example, the
point (0.2, 0.2) corresponds to a speciﬁcity of 0.8 with a sensitivity of 0.2. We can
arrive at this quite easily by classifying a new case, without looking at it, with
probabilities 0.2 for positive and 0.8 for negative. Every knowledge-based diag-
nosis system must therefore generate a ROC which clearly lies above the diagonal.
Specificity
Fig. 7.10 ROC curve from LEXMED compared with the Ohmann score and two additional models
156
7
Reasoning with Uncertainty

The extreme values in the ROC curve are also interesting. At point (0, 0) all
three curves intersect. The corresponding diagnosis system would classify all cases
as negative. The other extreme value (1, 1) corresponds to a system which would
decide to do the operation for every patient and thus has a sensitivity of 1. We could
call the ROC curve the characteristic curve for two-value diagnostic systems. The
ideal diagnostic system would have a characteristic curve which consists only of the
point (0, 1), and thus has 100% speciﬁcity and 100% sensitivity.
Now let us analyse the ROC curve. At a sensitivity of 88%, LEXMED attains a
speciﬁcity of 87% (k = 0.6). For comparison, the Ohmann score, an established,
well-known score for appendicitis is given [OMYL96, ZSR+99]. Because LEXMED
is above or to the left of the Ohmann score almost everywhere, its average quality of
diagnosis is clearly better. This is not surprising because scores are simply too weak
to model interesting propositions. In Sect. 8.7 and in Exercise 8.17 on page 242 we
will show that scores are equivalent to the special case of naive Bayes, that is, to the
assumption that all symptoms are pairwise independent when the diagnosis is
known. When comparing LEXMED with scores it should, however, be mentioned that
a statistically representative database was used for the Ohmann score, but a
non-representative database enhanced with expert knowledge was used for LEXMED.
To get an idea of the quality of the LEXMED data in comparison to the Ohmann data, a
linear score was calculated using the least squares method (see Sect. 9.4.1), which is
also drawn for comparison. Furthermore, a neural network was trained on the
LEXMED data with the RProp algorithm (see Sect. 9.5). The strength of combining
data and expert knowledge is displayed clearly in the difference between the LEXMED
curve and the curves of the score system and the RProp algorithm.
7.3.7
Application Areas and Experiences
LEXMED should not replace the judgment of an experienced surgeon. However,
because a specialist is not always available in a clinical setting, a LEXMED query
offers a substantive second opinion. Especially interesting and worthwhile is the
application of the system in a clinical ambulance and for general practitioners.
The learning capability of LEXMED, which makes it possible to take into account
further symptoms, further patient data, and further rules, also presents new possi-
bilities in the clinic. For especially rare groups which are difﬁcult to diagnose, for
example children under six years of age, LEXMED can use data from pediatricians or
other special databases, to support even experienced surgeons.
Aside from direct use in diagnosis, LEXMED also supports quality assurance
measures. For example, insurance companies can compare the quality of diagnosis
of hospitals with that of expert systems. By further developing the cost matrix
created in LEXMED (with the consent of doctors, insurance, and patients), the quality
of physician diagnoses, computer diagnoses, and other medical institutions will
become easier to compare.
LEXMED has pointed to a new way of constructing automatic diagnostic systems.
Using the language of probability theory and the MaxEnt algorithm, inductively,
7.3
LEXMED, an Expert System for Diagnosing Appendicitis
157

statistically derived knowledge is combined with knowledge from experts and from
the literature. The approach based on probabilistic models is theoretically elegant,
generally applicable, and has given very good results in a small study.
LEXMED has been in practical use in the 14 Nothelfer Hospital in Weingarten since
1999 and has performed there very well. It is also available at www.lexmed.de,
without warranty, of course. Its quality of diagnosis is comparable with that of an
experienced surgeon and is thus better than that of an average general practitioner, or
that of an inexperienced doctor in the clinic.
Despite this success it has become evident that it is very difﬁcult to market such
a system commercially in the German medical system. One reason for this is that
there is no free market to promote better quality (here better diagnoses) through its
selection mechanisms. Furthermore, in medicine the time for broad use of intelli-
gent techniques is not yet at hand—even in 2010. One cause of this could be
conservative teachings in this regard in German medical school faculties.
A further issue is the desire of many patients for personal advice and care from
the doctor, together with the fear that, with the introduction of expert systems, the
patient will only communicate with the machine. This fear, however, is wholly
unfounded. Even in the long term, medical expert systems cannot replace the
doctor. They can, however, just like laser surgery and magnetic resonance imaging,
be used advantageously for all participants. Since the ﬁrst medical computer
diagnostic system of de Dombal in 1972, almost 40 years have passed. It remains to
be seen whether medicine will wait another 40 years until computer diagnostics
becomes an established medical tool.
7.4
Reasoning with Bayesian Networks
One problem with reasoning using probability in practice was already pointed out in
Sect. 7.1. If d variables X1, … , Xd with n values each are used, then the associated
probability distribution has nd total values. This means that in the worst case the
memory use and computation time for determining the speciﬁed probabilities grows
exponentially with the number of variables.
In practice the applications are usually very structured and the distribution contains
many redundancies. This means that it can be heavily reduced with the appropriate
methods. The use of Bayesian networks has proved its power here and is one of the AI
techniques which have been successfully used in practice. Bayesian networks utilize
knowledge about the independence of variables to simplify the model.
7.4.1
Independent Variables
In the simplest case, all variables are pairwise independent and it is the case that
PðX1; . . .; XdÞ ¼ PðX1Þ  PðX2Þ      PðXdÞ:
158
7
Reasoning with Uncertainty

All entries in the distribution can thus be calculated from the d values P(X1),…, P(Xd).
Interesting applications, however, can usually not be modeled because conditional
probabilities become trivial.16 Because of
PðAjBÞ ¼ PðA; BÞ
PðBÞ
¼ PðAÞPðBÞ
PðBÞ
¼ PðAÞ
all conditional probabilities are reduced to the a priori probabilities. The situation
becomes more interesting when only a portion of the variables are independent or
independent under certain conditions. For reasoning in AI, the dependencies
between variables happen to be important and must be utilized.
We would like to outline reasoning with Bayesian networks through a simple
and very illustrative example by J. Pearl [Pea88], which became well known
through [RN10] and is now basic AI knowledge.
Example 7.10 (Alarm-Example) Bob, who is single, has had an alarm system
installed in his house to protect against burglars. Bob cannot hear the alarm when he
is working at the ofﬁce. Therefore he has asked his two neighbors, John in the house
next door to the left, and Mary in the house to the right, to call him at his ofﬁce if
they hear his alarm. After a few years Bob knows how reliable John and Mary are
and models their calling behavior using conditional probability as follows.17
PðJjAlÞ¼ 0:90
PðMjAlÞ ¼ 0:70;
PðJj:AlÞ¼ 0:05
PðMj:AlÞ ¼ 0:01:
Because Mary is hard of hearing, she fails to hear the alarm more often than John.
However, John sometimes mixes up the alarm at Bob’s house with the alarms at
other houses. The alarm is triggered by a burglary, but can also be triggered by a
(weak) earthquake, which can lead to a false alarm because Bob only wants to know
about burglaries while at his ofﬁce. These relationships are modeled by
PðAljBur; EarÞ ¼ 0:95;
PðAljBur; :EarÞ ¼ 0:94;
PðAlj:Bur; EarÞ ¼ 0:29;
PðAlj:Bur; :EarÞ ¼ 0:001;
as well as the a priori probabilities P(Bur) = 0.001 and P(Ear) = 0.002. These two
variables are independent because earthquakes do not make plans based on the
habits of burglars, and conversely there is no way to predict earthquakes, so
burglars do not have the opportunity to set their schedule accordingly.
16In the naive Bayes method, the independence of all attributes is assumed, and this method has
been successfully applied to text classiﬁcation (see Sect. 8.7).
17The binary variables J and M stand for the two events “John calls”, and “Mary calls”,
respectively, Al for “alarm siren sounds”, Bur for “burglary” and Ear for “earthquake”.
7.4
Reasoning with Bayesian Networks
159

Queries are now made against this knowledge base. For example, Bob might be
interested in P(Bur|J ∨M), P(J|Bur) or P(M|Bur). That is, he wants to know how
sensitively the variables J and M react to a burglary report.
7.4.2
Graphical Representation of Knowledge as a Bayesian
Network
We can greatly simplify practical work by graphically representing knowledge that
is formulated as conditional probability. Figure 7.11 shows the Bayesian network
for the alarm example. Each node in the network represents a variable and every
directed edge a statement of conditional probability. The edge from Al to J for
example represents the two values P(J|Al) and P(J | ¬Al), which is given in the form
of a table, the so-called CPT (conditional probability table). The CPT of a node lists
all the conditional probabilities of the node’s variable conditioned on all the nodes
connected by incoming edges.
While studying the network, we might ask ourselves why there are no other
edges included besides the four that are drawn in. The two nodes Bur and Ear are
not linked since the variables are independent. All other nodes have a parent node,
which makes the reasoning a little more complex. We ﬁrst need the concept of
conditional independence.
7.4.3
Conditional Independence
Analogously to independence of random variables, we give
Deﬁnition 7.6 Two variables A and B are called conditionally independent,
given C if
PðA; BjCÞ ¼ PðAjCÞ  PðBjCÞ:
Fig. 7.11 Bayesian network
for the alarm example with
the associated CPTs
160
7
Reasoning with Uncertainty

This equation is true for all combinations of values for all three variables (that is,
for the distribution), which we see in the notation. We now look at nodes J and M in
the alarm example, which have the common parent node Al. If John and Mary
independently react to an alarm, then the two variables J and M are independent
given Al, that is:
PðJ; MjAlÞ ¼ PðJjAlÞ  PðMjAlÞ:
If the value of Al is known, for example because an alarm was triggered, then the
variables J and M are independent (under the condition Al = w). Because of the
conditional independence of the two variables J and M, no edge between these two
nodes is added. However, J and M are not independent (see Exercise 7.11 on
page 173).
Quite similar is the relationship between the two variables J and Bur, because
John does not react to a burglary, rather the alarm. This could be, for example,
because of a high wall that blocks his view on Bob’s property, but he can still hear
the alarm. Thus J and Bur are independent given Al and
PðJ; BurjAlÞ ¼ PðJjAlÞ  PðBurjAlÞ:
Given an alarm, the variables J and Ear, M and Bur, as well as M and Ear are
also independent. For computing with conditional independence, the following
characterizations, which are equivalent to the above deﬁnition, are helpful:
Theorem 7.5 The following equations are pairwise equivalent, which means
that each individual equation describes the conditional independence for the
variables A and B given C.
PðA; BjCÞ ¼ PðAjCÞ  PðBjCÞ;
ð7:18Þ
PðAjB; CÞ ¼ PðAjCÞ;
ð7:19Þ
PðBjA; CÞ ¼ PðBjCÞ:
ð7:20Þ
Proof On one hand, using conditional independence (7.18) we can conclude that
PðA; B; CÞ ¼ PðA; BjCÞPðCÞ ¼ PðAjCÞ PðBjCÞ PðCÞ:
On the other hand, the product rule gives us
PðA; B; CÞ ¼ PðAjB; CÞPðBjCÞPðCÞ:
Thus P(A|B, C) = P(A|C) is equivalent to (7.18). We obtain (7.20) analogously by
swapping A and B in this derivation.
□
7.4
Reasoning with Bayesian Networks
161

7.4.4
Practical Application
Now we turn again to the alarm example and show how the Bayesian network in
Fig. 7.11 can be used for reasoning. Bob is interested, for example, in the sensi-
tivity of his two alarm reporters John and Mary, that is, in P JjBur
ð
Þ and P MjBur
ð
Þ.
However, the values P BurjJ
ð
Þ and P BurjM
ð
Þ, as well as P BurjJ; M
ð
Þ are even
more important to him. We begin with P JjBur
ð
Þ and calculate
PðJjBurÞ ¼ PðJ; BurÞ
PðBurÞ ¼ PðJ; Bur; AlÞ þ PðJ; Bur; :AlÞ
PðBurÞ
ð7:21Þ
and
PðJ; Bur; AlÞ ¼ PðJjBur; AlÞPðAljBurÞPðBurÞ ¼ PðJjAlÞPðAljBurÞPðBurÞ;
ð7:22Þ
where for the last two equations we have used the product rule and the conditional
independence of J and Bur given Al. Inserted in (7.21) we obtain
PðJjBurÞ ¼ PðJjAlÞPðAljBurÞPðBurÞ þ PðJj:AlÞPð:AljBurÞPðBurÞ
PðBurÞ
¼ PðJjAlÞPðAljBurÞ þ PðJj:AlÞPð:AljBurÞ:
ð7:23Þ
Here P(Al|Bur) and P(¬Al|Bur) are missing. Therefore we calculate
PðAljBurÞ ¼ PðAl; BurÞ
PðBurÞ
¼ PðAl; Bur; EarÞ þ PðAl; Bur; :EarÞ
PðBurÞ
¼ PðAljBur; EarÞPðBurÞPðEarÞ þ PðAljBur; :EarÞPðBurÞPð:EarÞ
PðBurÞ
¼ PðAljBur; EarÞPðEarÞ þ PðAljBur; :EarÞPð:EarÞ
¼ 0:95  0:002 þ 0:94  0:998 ¼ 0:94
as well as P(¬Al|Bur) = 0.06 and insert this into (7.23) which gives the result
PðJjBurÞ ¼ 0:9  0:94 þ 0:05  0:06 ¼ 0:849:
Analogously we calculate P(M|Bur) = 0.659. We now know that John calls for
about 85% of all break-ins and Mary for about 66% of all break-ins. The probability
that both of them call is calculated, due to conditional independence, as
PðJ; MjBurÞ ¼ PðJ; MjAlÞPðAljBurÞ þ PðJ; Mj:AlÞPð:AljBurÞ
¼ PðJjAlÞPðMjAlÞPðAljBurÞ þ PðJj:AlÞPðMj:AlÞPð:AljBurÞ
¼ 0:9  0:7  0:94 þ 0:05  0:01  0:06 ¼ 0:5922:
162
7
Reasoning with Uncertainty

More interesting, however, is the probability of a call from John or Mary
PðJ _ MjBurÞ ¼ Pð:ð:J; :MÞjBurÞ ¼ 1  Pð:J; :MjBurÞ
¼ 1  ½Pð:JjAlÞPð:MjAlÞPðAljBurÞ þ Pð:Jj:AlÞPð:Mj:AlÞPð:AljBurÞ
¼ 1  ½0:1  0:3  0:94 þ 0:95  0:99  0:06 ¼ 1  0:085 ¼ 0:915:
Bob thus receives a notiﬁcation for about 92% of all burglaries. Now to calculate
P BurjJ
ð
Þ, we apply Bayes’ theorem, which gives us
PðBurjJÞ ¼ PðJjBurÞPðBurÞ
PðJÞ
¼ 0:849  0:001
0:052
¼ 0:016:
Evidently only about 1.6% of all calls from John are actually due to a break-in.
Because the probability of false alarms is ﬁve times smaller for Mary, with
P BurjM
ð
Þ ¼ 0:056, we have signiﬁcantly higher conﬁdence given a call from
Mary. Bob should only be seriously concerned about his home if both of them call,
because P BurjJ; M
ð
Þ ¼ 0:284 (see Exercise 7.11 on page 173).
In (7.23) on page 162 we showed with
PðJjBurÞ ¼ PðJjAlÞPðAljBurÞ þ PðJj:AlÞPð:AljBurÞ
how we can “slide in” a new variable. This relationship holds in general for two
variables A and B given the introduction of an additional variable C and is called
conditioning:
PðAjBÞ ¼
X
c
PðAjB; C ¼ cÞPðC ¼ cjBÞ:
If furthermore A and B are conditionally independent given C, this formula sim-
pliﬁes to
PðAjBÞ ¼
X
c
PðAjC ¼ cÞPðC ¼ cjBÞ:
7.4.5
Software for Bayesian Networks
We will give a brief introduction to two tools using the alarm example. We are
already familiar with the system PIT. We input the values from the CPTs in PIT
syntax into the online input window at www.pit-systems.de. After the input shown
in Fig. 7.12 on page 164 we receive the answer:
P([Einbruch=t] | [John=t] AND [Mary=t]) = 0.2841.
7.4
Reasoning with Bayesian Networks
163

While PIT is not a classical Bayesian network tool, it can take arbitrary conditional
probabilities and queries as input and calculate correct results. It can be shown
[Sch96], that on input of CPTs or equivalent rules, the MaxEnt principle implies the
same conditional independences and thus also the same answers as a Bayesian
network. Bayesian networks are thus a special case of MaxEnt.
Next we will look at JavaBayes [Coz98], a classic system also freely available
on the Internet with the graphical interface shown in Fig. 7.13. With the graphical
network editor, nodes and edges can be manipulated and the values in the CPTs
edited. Furthermore, the values of variables can be assigned with “Observe” and the
values of other variables called up with “Query”. The answers to queries then
appear in the console window.
The professional, commercial system Hugin is signiﬁcantly more powerful and
convenient. For example, Hugin can use continuous variables in addition to discrete
variables. It can also learn Bayesian networks, that is, generate the network fully
automatically from statistical data (see Sect. 8.5).
1 var Alarm{t,f}, Burglary{t,f}, Earthquake{t,f}, John{t,f}, Mary{t,f};
2
3 P([Earthquake=t]) = 0.002;
4 P([Burglary=t]) = 0.001;
5 P([Alarm=t] | [Burglary=t] AND [Earthquake=t]) = 0.95;
6 P([Alarm=t] | [Burglary=t] AND [Earthquake=f]) = 0.94;
7 P([Alarm=t] | [Burglary=f] AND [Earthquake=t]) = 0.29;
8 P([Alarm=t] | [Burglary=f] AND [Earthquake=f]) = 0.001;
9 P([John=t] | [Alarm=t]) = 0.90;
10 P([John=t] | [Alarm=f]) = 0.05;
11 P([Mary=t] | [Alarm=t]) = 0.70;
12 P([Mary=t] | [Alarm=f]) = 0.01;
13
14 QP([Burglary=t] | [John=t] AND [Mary=t]);
Fig. 7.12 PIT input for the alarm example
Fig. 7.13 The user interface of JavaBayes: left the graphical editor and right the console where
the answers are given as output
164
7
Reasoning with Uncertainty

7.4.6
Development of Bayesian Networks
A compact Bayesian network is very clear and signiﬁcantly more informative for
the reader than a full probability distribution. Furthermore, it requires much less
memory. For the variables v1; . . . ; vn with jv1j; . . . ; jvnj different values each, the
distribution has a total of
Y
n
i¼1
jvij  1
independent entries. In the alarm example the variables are all binary. Thus for all
variables jvij = 2, and the distribution has 25 −1 = 31 independent entries. To
calculate the number of independent entries for the Bayesian network, the total
number of all entries of all CPTs must be determined. For a node vi with ki parent
nodes ei1; . . . ; eiki, the associated CPT has
ðjvij  1Þ
Y
ki
j¼1
jeijj
entries. Then all CPTs in the network together have
X
n
i¼1
ðjvij  1Þ
Y
ki
j¼1
jeijj
ð7:24Þ
entries.18 For the alarm example the result is then
2 þ 2 þ 4 þ 1 þ 1 ¼ 10
independent entries which uniquely describe the network. The comparison in
memory complexity between the full distribution and the Bayesian network
becomes clearer when we assume that all n variables have the same number b of
values and each node has k parent nodes. Then (7.24) can be simpliﬁed and all
CPTs together have n(b −1)bk entries. The full distribution contains bn −1 entries.
A signiﬁcant gain is only made then if the average number of parent nodes is much
smaller than the number of variables. This means that the nodes are only locally
connected. Because of the local connection, the network becomes modularized,
which—as in software engineering—leads to a reduction in complexity. In the
alarm example the alarm node separates the nodes Bur and Ear from the nodes
J and M. We can also see this clearly in the LEXMED example.
18For the case of a node without ancestors the product in this sum is empty. For this we substitute
the value 1 because the CPT for nodes without ancestors contains, with its a priori probability,
exactly one value.
7.4
Reasoning with Bayesian Networks
165

LEXMED as a Bayesian Network
The LEXMED system described in Sect. 7.3 can also be modeled as a Bayesian
network. By making the outer, thinly-drawn lines directed (giving them arrows), the
independence graph in Fig. 7.8 on page 151 can be interpreted as a Bayesian
network. The resulting network is shown in Fig. 7.14.
In Sect. 7.3.2 the size of the distribution for LEXMED was calculated as the value
20643 839. The Bayesian network on the other hand can be fully described with
only 521 values. This value can be determined by entering the variables from
Fig. 7.14 into (7.24) on page 165. In the order (Leuko, TRek, Gua, Age, Reb,
Sono, Tapp, BowS, Sex, P4Q, P1Q, P2Q, RecP, Urin, P3Q, Diag4) we calculate
X
n
i¼1
ðjvij  1Þ
Y
ki
j¼1
jeijj ¼ 6  6  4 þ 5  4 þ 2  4 þ 9  7  4 þ 1  3  4 þ 1  4 þ 1  2  4
þ 3  3  4 þ 1  4 þ 1  4  2 þ 1  4  2 þ 1  4 þ 1  4 þ 1  4
þ 1  4 þ 1 ¼ 521:
Fig. 7.14 Bayesian network for the LEXMED application
166
7
Reasoning with Uncertainty

This example demonstrates that it is practically impossible to build a full distri-
bution for real applications. A Bayesian network with 22 edges and 521 probability
values on the other hand is still manageable.
Causality and Network Structure
Construction of a Bayesian network usually proceeds in two stages.
1. Design of the network structure: This step is usually performed manually and
will be described in the following.
2. Entering the probabilities in the CPTs: Manually entering the values in the case
of many variables is very tedious. If (as for example with LEXMED) a database is
available, this step can be automated through estimating the CPT entries by
counting frequencies.
We will now describe the construction of the network in the alarm example (see
Fig. 7.15). At the beginning we know the two causes Burglary and Earthquake and
the two symptoms John and Mary. However, because John and Mary do not directly
react to a burglar or earthquake, rather only to the alarm, it is appropriate to add this
as an additional variable which is not observable by Bob. The process of adding
edges starts with the causes, that is, with the variables that have no parent nodes.
First we choose Burglary and next Earthquake. Now we must check whether
Earthquake is independent of Burglary. This is given, and thus no edge is added
from Burglary to Earthquake. Because Alarm is directly dependent on Burglary and
Earthquake, these variables are chosen next and an edge is added from both Bur-
glary and Earthquake to Alarm. Then we choose John. Because Alarm and John are
not independent, an edge is added from alarm to John. The same is true for Mary.
Now we must check whether John is conditionally independent of Burglary given
Alarm. If this is not the case, then another edge must be inserted from Burglary to
John. We must also check whether edges are needed from Earthquake to John and
from Burglary or Earthquake to Mary. Because of conditional independence, these
four edges are not necessary. Edges between John and Mary are also unnecessary
because John and Mary are conditionally independent given Alarm.
The structure of the Bayesian network heavily depends on the chosen variable
ordering. If the order of variables is chosen to reﬂect the causal relationship
beginning with the causes and proceeding to the diagnosis variables, then the result
will be a simple network. Otherwise the network may contain signiﬁcantly more
edges. Such non-causal networks are often very difﬁcult to understand and have a
higher complexity for reasoning. The reader may refer to Exercise 7.11 on
page 173 for better understanding.
Fig. 7.15 Stepwise construction of the alarm network considering causality
7.4
Reasoning with Bayesian Networks
167

7.4.7
Semantics of Bayesian Networks
As we have seen in the previous section, no edge is added to a Bayesian network
between two variables A and B when A and B are independent or conditionally
independent given a third variable C. This situation is represented in Fig. 7.16.
We now require the Bayesian network to have no cycles and we assume that the
variables are numbered such that no variable has a lower number than any variable
that precedes it. This is always possible when the network has no cycles.19 Then,
when using all conditional independencies, we have
PðXnjX1; . . .; Xn1Þ ¼ PðXnjParentsðXnÞÞ:
This equation thus is a proposition that an arbitrary variable Xi in a Bayesian
network is conditionally independent of its ancestors, given its parents. The
somewhat more general proposition depicted in Fig. 7.17 on page 169 can be stated
compactly as
Theorem 7.6 A node in a Bayesian network is conditionally independent
from all non-successor nodes, given its parents.
Now we are able to greatly simplify the chain rule ((7.1) on page 132):
PðX1; . . . ; XnÞ ¼
Y
n
i¼1
PðXijX1. . . ; Xi1Þ ¼
Y
n
i¼1
PðXijParentsðXiÞÞ:
ð7:25Þ
Using this rule we could, for example, write (7.22) on page 162 directly
PðJ; Bur; AlÞ ¼ PðJjAlÞ PðAljBurÞ PðBurÞ:
We now know the most important concepts and foundations of Bayesian
networks. Let us summarize them [Jen01]:
Fig. 7.16 There is no edge between A and B if they are independent (left) or conditionally
independent (middle, right)
19If for example three nodes X1, X2, X3 form a cycle, then there are the edges (X1, X2), (X2, X3) and
(X3, X1) where X1 has X3 as a successor.
168
7
Reasoning with Uncertainty

Deﬁnition 7.7 A Bayesian network is deﬁned by:
• A set of variables and a set of directed edges between these variables.
• Each variable has ﬁnitely many possible values.
• The variables together with the edges form a directed acyclic graph
(DAG). A DAG is a graph without cycles, that is, without paths of the
form (A,…,A).
• For every variable A the CPT (that is, the table of conditional probabilities
P(A|Parents(A))) is given.
Two variables A and B are called conditionally independent given C if
PðA; BjCÞ ¼ PðAjCÞ  PðBjCÞ or, equivalently, if PðAjB; CÞ ¼ PðAjCÞ.
Besides the foundational rules of computation for probabilities, the following
rules are also true:
Bayes’ Theorem: PðAjBÞ ¼ PðBjAÞPðAÞ
PðBÞ
Marginalization: PðBÞ ¼ PðA; BÞ þ Pð:A; BÞ ¼ PðBjAÞ  PðAÞ þ PðBj:AÞ 
Pð:AÞ
Conditioning: P(A|B) = ∑c P (A|B, C = c) P (C = c|B)
A variable in a Bayesian network is conditionally independent of all
non-successor variables given its parent variables. If X1,…,Xn−1 are no
successors of Xn, we have P(Xn|X1,…,Xn−1) = P(Xn|Parents(Xn)). This con-
dition must be honored during the construction of a network.
During construction of a Bayesian network the variables should be ordered
according to causality. First the causes, then the hidden variables, and the
diagnosis variables last.
Chain rule: PðX1; . . . ; XnÞ ¼ Qn
i¼1 PðXijParentsðXiÞÞ
Fig. 7.17 Example of
conditional independence in a
Bayesian network. If the
parent nodes E1 and E2 are
given, then all non-successor
nodes B1,…, B8 are
independent of A
7.4
Reasoning with Bayesian Networks
169

In [Pea88] and [Jen01] the term d-separation is introduced for Bayesian net-
works, from which a theorem similar to Theorem 7.6 on page 168 follows. We will
refrain from introducing this term and thereby reach a somewhat simpler, though
not a theoretically as clean representation.
7.5
Summary
In a way that reﬂects the prolonged, sustained trend toward probabilistic systems,
we have introduced probabilistic logic for reasoning with uncertain knowledge.
After introducing the language—propositional logic augmented with probabilities
or probability intervals—we chose the natural, if unusual approach via the method
of maximum entropy as an entry point and showed how we can model
non-monotonic reasoning with this method. Bayesian networks were then intro-
duced as a special case of the MaxEnt method.
Why are Bayesian networks a special case of MaxEnt? When building a
Bayesian network, assumptions about independence are made which are unneces-
sary for the MaxEnt method. Furthermore, when building a Bayesian network, all
CPTs must be completely ﬁlled in so that a complete probability distribution can be
constructed. Otherwise reasoning is restricted or impossible. With MaxEnt, on the
other hand, the developer can formulate all the knowledge he has at his disposal in
the form of probabilities. MaxEnt then completes the model and generates the
distribution. Even if (for example when interviewing an expert) only vague
propositions are available, this can be suitably modeled. A proposition such as
“I am pretty sure that A is true.” can for example be modeled using P(A) 2 [0.6, 1]
as a probability interval. When building a Bayesian network, a concrete value must
be given for the probability, if necessary by guessing. This means, however, that the
expert or the developer put ad hoc information into the system. One further
advantage of MaxEnt is the possibility of formulating (almost) arbitrary proposi-
tions. For Bayesian networks the CPTs must be ﬁlled.
The freedom that the developer has when modeling with MaxEnt can be a
disadvantage (especially for a beginner) because, in contrast to the Bayesian
approach, it is not necessarily clear what knowledge should be modeled. When
modeling with Bayesian networks the approach is quite clear: according to causal
dependencies, from the causes to the effects, one edge after the other is entered into
the network by testing conditional independence.20 At the end all CPTs are ﬁlled
with values.
However, the following interesting combinations of the two methods are pos-
sible: we begin by building a network according to the Bayesian methodology,
enter all the edges accordingly and then ﬁll the CPTs with values. Should certain
values for the CPTs be unavailable, then they can be replaced with intervals or
by other probabilistic logic formulas. Naturally such a network—or better: a rule
20This is also not always quite so simple.
170
7
Reasoning with Uncertainty

set—no longer has the special semantics of a Bayesian network. It must then be
processed and completed by a MaxEnt system.
The ability to use MaxEnt with arbitrary rule sets has a downside, though.
Similarly to the situation in logic, such rule sets can be inconsistent. For example,
the two rules P(A) = 0.7 and P(A) = 0.8 are inconsistent. While the MaxEnt system
PIT for example can recognize the inconsistency, if cannot give a hint about how to
remove the problem.
We introduced the medical expert system LEXMED, a classic application for rea-
soning with uncertain knowledge, and showed how it can be modeled and imple-
mented using MaxEnt and Bayesian networks, and how these tools can replace the
well-established, but too weak linear scoring systems used in medicine.21
In the LEXMED example we showed that it is possible to build an expert system
for reasoning under uncertainty that is capable of discovering (learning) knowledge
from the data in a database. We will give more insight into the methods of learning
of Bayesian networks in Chap. 8, after the necessary foundations for machine
learning have been laid.
Today Bayesian reasoning is a large, independent ﬁeld, which we can only
brieﬂy describe here. We have completely left out the handling of continuous
variables. For the case of normally distributed random variables there are proce-
dures and systems. For arbitrary distributions, however, the computational com-
plexity is a big problem. In addition to the directed networks that are heavily based
on causality, there are also undirected networks. Connected with this is a discussion
about the meaning and usefulness of causality in Bayesian networks. The interested
reader is directed to excellent textbooks such as [Pea88, Jen01, Whi96, DHS01], as
well as the proceedings of the annual conference of the Association for Uncertainty
in Artiﬁcial Intelligence (AUAI) (www.auai.org).
7.6
Exercises
Exercise 7.1 Prove the proposition from Theorem 7.1 on page 129.
Exercise 7.2 The gardening hobbyist Max wants to statistically analyze his yearly
harvest of peas. For every pea pod he picks he measures its length xi in centimeters
and its weight yi in grams. He divides the peas into two classes, the good and the
bad (empty pods). The measured data (xi, yi) are
good peas:
x 1 2 2 3 3 4 4 5 6
y 2 3 4 4 5 5 6 6 6
bad peas:
x 4 6 6 7
y 2 2 3 3
21In Sect. 8.7 and in Exercise 8.17 on page 242 we will show that the scores are equivalent to the
special case naive Bayes, that is, to the assumption that all symptoms are conditionally
independent given the diagnosis.
7.5
Summary
171

(a) From the data, compute the probabilities P(y > 3|Class = good) and P(y ≤3|
Class = good). Then use Bayes’ formula to determine P(Class = good|y > 3)
and P(Class = good|y ≤3).
(b) Which of the probabilities computed in subproblem (a) contradicts the state-
ment “All good peas are heavier than 3 grams”?
Exercise 7.3 You are supposed to predict the afternoon weather using a few simple
weather values from the morning of this day. The classical probability calculation
for this requires a complete model, which is given in the following table.
Sky
Bar
Prec
P (Sky,Bar,Prec)
Clear
Rising
Dry
0.40
Clear
Rising
Raining
0.07
Clear
Falling
Dry
0.08
Clear
Falling
Raining
0.10
Cloudy
Rising
Dry
0.09
Cloudy
Rising
Raining
0.11
Cloudy
Falling
Dry
0.03
Sky:
The sky is clear or
cloudy in the morning
Bar:
Barometer rising or
falling in the morning
Prec:
Raining or dry in the
afternoon
(a) How many events are in the distribution for these three variables?
(b) Compute P(Prec = dry|Sky = clear, Bar = rising).
(c) Compute P(Prec = rain|Sky = cloudy).
(d) What would you do if the last row were missing from the table?
❄Exercise 7.4 In a television quiz show, the contestant must choose between three
closed doors. Behind one door the prize awaits: a car. Behind both of the other
doors are goats. The contestant chooses a door, e.g. number one. The host, who
knows where the car is, opens another door, e.g. number three, and a goat appears.
The contestant is now given the opportunity to choose between the two remaining
doors (one and two). What is the better choice from his point of view? To stay with
the door he originally chose or to switch to the other closed door?
Exercise 7.5 Using the Lagrange multiplier method, show that, without explicit
constraints, the uniform distribution p1 = p2 = … = pn = 1/n represents maximum
entropy. Do not forget the implicitly ever-present constraint p1 + p2 +  + pn = 1.
How can we show this same result using indifference?
Exercise 7.6 Use the PIT system (http://www.pit-systems.de) or SPIRIT (http://
www.xspirit.de) to calculate the MaxEnt solution for P(B) under the constraint
P(A) = α and P(B|A) = β. Which disadvantage of PIT, compared with calculation
by hand, do you notice here?
Exercise 7.7 Given the constraints P(A) = α and P(A ∨B) = β, manually calculate
P(B) using the MaxEnt method. Use PIT to check your solution.
172
7
Reasoning with Uncertainty

❄Exercise 7.8 Given the constraints from (7.10), (7.11), (7.12): p1 þ p2 = α,
p1 þ p3 = γ, p1 þ p2 þ p3 þ p4 = 1. Show that p1 = αγ, p2 = α(1 −γ), p3 = γ(1 −α),
p4 = (1 −α)(1 −γ) represents the entropy maximum under these constraints.
❄Exercise 7.9 A probabilistic algorithm calculates the likelihood p that an inbound
email is spam. To classify the emails in classes delete and read, a cost matrix is then
applied to the result.
(a) Give a cost matrix (2 × 2 matrix) for the spam ﬁlter. Assume here that it
costs the user 10 cents to delete an email, while the loss of an email costs 10
dollars (compare this to Example 1.1 on page 17 and Exercise 1.7 on
page 21).
(b) Show that, for the case of a 2 × 2 matrix, the application of the cost matrix is
equivalent to the application of a threshold on the spam probability and
determine the threshold.
Exercise 7.10 Given a Bayesian network with the three binary variables A, B,
C and P(A) = 0.2, P(B) = 0.9, as well as the CPT shown below:
(a) Compute P(A|B).
(b) Compute P(C|A).
A
B
P (C)
t
f
0.1
t
t
0.2
f
t
0.9
f
f
0.4
Exercise 7.11 For the alarm example (Example 7.10 on page 159), calculate the
following conditional probabilities:
(a) Calculate the a priori probabilities P(Al), P(J), P(M).
(b) Calculate P MjBur
ð
Þ using the product rule, marginalization, the chain rule,
and conditional independence.
(c) Use Bayes’ formula to calculate P BurjM
ð
Þ
(d) Compute P AljJ; M
ð
Þ and P BurjJ; M
ð
Þ.
(e) Show that the variables J and M are not independent.
(f) Check all of your results with JavaBayes and with PIT (see [Ert11] for
demo programs).
(g) Design a Bayesian network for the alarm example, but with the altered
variable ordering M, Al, Ear, Bur, J. According to the semantics of Bayesian
networks, only the necessary edges must be drawn in. (Hint: the variable order
given here does NOT represent causality. Thus it will be difﬁcult to intuitively
determine conditional independences.)
(h) In the original Bayesian network of the alarm example, the earthquake nodes
is removed. Which CPTs does this change? (Why these in particular?)
(i) Calculate the CPT of the alarm node in the new network.
7.6
Exercises
173

Exercise 7.12 A diagnostic system is to be made for a dynamo-powered
bicycle light using a Bayesian network. The variables in the following table
are given.
The following variables are pairwise independent:
Str, Flw, B, K. Furthermore: (R, B), (R, K), (V, B),
(V, K) are independent and the following equation holds:
PðLijV; RÞ ¼ PðLijVÞ
PðVjR; StrÞ ¼ PðVjRÞ
PðVjR; FlwÞ ¼ PðVjRÞ
(a) Draw all of the edges into the graph (taking
causality into account).
(b) Enter all missing CPTs into the graph (table of
conditional probabilities). Freely insert plausible
values for the probabilities.
(c) Show that the network does not contain an edge
(Str, Li).
(d) Compute P(V|Str = snow_covered).
Abbr.
Meaning
Values
Li
Light is on
t/f
Str
Street condition
dry, wet, snow_covered
Flw
Dynamo ﬂywheel worn out
t/f
R
Dynamo sliding
t/f
V
Dynamo shows voltage
t/f
B
Light bulb o.k.
t/f
K
Cable o.k.
t/f
V
B
K
P (Li)
t
t
t
0.99
t
t
f
0.01
t
f
t
0.01
t
f
f
0.001
f
t
t
0.3
f
t
f
0.005
f
f
t
0.005
f
f
f
0
174
7
Reasoning with Uncertainty

8
Machine Learning and Data Mining
If we deﬁne AI as is done in Elaine Rich’s book [Ric83]:
Artiﬁcial Intelligence is the study of how to make computers do things at which, at the
moment, people are better.
and if we consider that the computer’s learning ability is especially inferior to that
of humans, then it follows that research into learning mechanisms, and the devel-
opment of machine learning algorithms is one of the most important branches
of AI.
There is also demand for machine learning from the viewpoint of the software
developer who programs, for example, the behavior of an autonomous robot. The
structure of the intelligent behavior can become so complex that it is very difﬁcult
or even impossible to program close to optimally, even with modern high-level
languages such as PROLOG and Python.1 Machine learning algorithms are even
used today to program robots in a way similar to how humans learn (see Chap. 10
or [BCDS08, RGH+06]), often in a hybrid mixture of programmed and learned
behavior.
The task of this chapter is to describe the most important machine learning
algorithms and their applications. The topic will be introduced in this section,
followed by important fundamental learning algorithms in the next sections.
Theory and terminology will be built up in parallel to this. The chapter will close
with a summary and overview of the various algorithms and their applications.
We will restrict ourselves in this chapter to supervised and unsupervised learning
algorithms. As an important class of learning algorithms, neural networks
will be dealt with in Chap. 9. Due to its special place and important role for
autonomous robots, reinforcement learning will also have its own dedicated
chapter (Chap. 10).
1Python is a modern scripting language with very readable syntax, powerful data types, and
extensive standard libraries, which can be used to this end.
© Springer International Publishing AG 2017
W. Ertel, Introduction to Artificial Intelligence, Undergraduate Topics
in Computer Science, DOI 10.1007/978-3-319-58487-4_8
175

What Is Learning? Learning vocabulary of a foreign language, or technical terms,
or even memorizing a poem can be difﬁcult for many people. For computers,
however, these tasks are quite simple because they are little more than saving text in
a ﬁle. Thus memorization is uninteresting for AI. In contrast, the acquisition of
mathematical skills is usually not done by memorization. For addition of natural
numbers this is not at all possible, because for each of the terms in the sum x + y there
are inﬁnitely many values. For each combination of the two values x and y, the triple
(x, y, x + y) would have to be stored, which is impossible. For decimal numbers, this
is downright impossible. This poses the question: how do we learn mathematics?
The answer reads: The teacher explains the process and the students practice it on
examples until they no longer make mistakes on new examples. After 50 examples
the student (hopefully) understands addition. That is, after only 50 examples he
can apply what was learned to inﬁnitely many new examples, which to that point
were not seen. This process is known as generalization. We begin with a simple
example.
Example 8.1 A fruit farmer wants to automatically divide harvested apples into the
merchandise classes A and B. The sorting device is equipped with sensors to
measure two features, size and color, and then decide which of the two classes the
apple belongs to. This is a typical classiﬁcation task. Systems which are capable of
dividing feature vectors into a ﬁnite number of classes are called classiﬁers.
To conﬁgure the machine, apples are hand-picked by a specialist, that is, they
are classiﬁed. Then the two measurements are entered together with their class
Fig. 8.1 Supervised learning …
176
8
Machine Learning and Data Mining

label in a table (Table 8.1. The size is given in the form of diameter in centimeters
and the color by a numeric value between 0 (for green) and 1 (for red). A visu-
alization of the data is listed as points in a scatterplot diagram in the right of
Fig. 8.2.
The task in machine learning consists of generating a function from the col-
lected, classiﬁed data which calculates the class value (A or B) for a new apple from
the two features size and color. In Fig. 8.3 such a function is shown by the dividing
line drawn through the diagram. All apples with a feature vector to the bottom left
of the line are put into class B, and all others into class A.
In this example it is still very simple to ﬁnd such a dividing line for the two
classes. It is clearly a more difﬁcult, and above all much less visualizable task, when
the objects to be classiﬁed are described by not just two, but many features. In
practice 30 or more features are usually used. For n features, the task consists of
ﬁnding an n −1 dimensional hyperplane within the n-dimensional feature space
Fig. 8.2 BayWa company apple sorting equipment in Kressbronn and some apples classiﬁed into
merchandise classes A and B in feature space (Photo: BayWa)
Table 8.1 Training data for
the apple sorting agent
Size [cm]
8
8
6
3
…
Color
0.1
0.3
0.9
0.8
…
Merchandise class
B
A
A
B
…
Fig. 8.3 The curve drawn in
into the diagram divides the
classes and can then be
applied to arbitrary new
apples
8
Machine Learning and Data Mining
177

which divides the classes as well as possible. A “good” division means that the
percentage of falsely classiﬁed objects is as small as possible.
A classiﬁer maps a feature vector to a class value. Here it has a ﬁxed, usually
small, number of alternatives. The desired mapping is also called target function. If
the target function does not map onto a ﬁnite domain, then it is not a classiﬁcation,
but rather an approximation problem. Determining the market value of a stock from
given features is such an approximation problem. In the following sections we will
introduce several learning agents for both types of mappings.
The Learning Agent We can formally describe a learning agent as a function
which maps a feature vector to a discrete class value or in general to a real number.
This function is not programmed, rather it comes into existence or changes itself
during the learning phase, inﬂuenced by the training data. In Fig. 8.4 such an agent
is presented in the apple sorting example. During learning, the agent is fed with the
already classiﬁed data from Table 8.1 on page 177. Thereafter the agent constitutes
as good a mapping as possible from the feature vector to the function value (e.g.
merchandise class).
We can now attempt to approach a deﬁnition of the term “machine learning”.
Tom Mitchell [Mit97] gives this deﬁnition:
Machine Learning is the study of computer algorithms that improve automati-
cally through experience.
Drawing on this, we give
Deﬁnition 8.1 An agent is a learning agent if it improves its performance
(measured by a suitable criterion) on new, unknown data over time (after it
has seen many training examples).
It is important to test the generalization capability of the learning algorithm on
unknown data, the test data. Otherwise every system that just saved the training
data would appear to perform optimally just by calling up the saved data. A learning
agent is characterized by the following terms:
Task: the task of the learning algorithm is to learn a mapping. This could for
example be the mapping from an apple’s size and color to its merchandise class,
Fig. 8.4 Functional structure of a learning agent for apple sorting (left) and in general (right)
178
8
Machine Learning and Data Mining

but also the mapping from a patient’s 15 symptoms to the decision of whether or
not to remove his appendix.
Variable agent: (more precisely a class of agents): here we have to decide which
learning algorithm will be worked with. If this has been chosen, thus the class of
all learnable functions is determined.
Training data: (experience): the training data (sample) contain the knowledge
which the learning algorithm is supposed to extract and learn. With the choice of
training data one must ensure that it is a representative sample for the task to be
learned.
Test data: important for evaluating whether the trained agent can generalize well
from the training data to new data.
Performance measure: for the apple sorting device, the number of correctly
classiﬁed apples. We need it to test the quality of an agent. Knowing the per-
formance measure is usually much easier than knowing the agent’s function. For
example, it is easy to measure the performance (time) of a 10,000 meter runner.
However, this does not at all imply that the referee who measures the time can run
as fast. The referee only knows how to measure the performance, but not the
“function” of the agent whose performance he is measuring.
What Is Data Mining? The task of a learning machine to extract knowledge from
training data. Often the developer or the user wants the learning machine to make
the extracted knowledge readable for humans as well. It is still better if the
Fig. 8.5 Data Mining
8
Machine Learning and Data Mining
179

developer can even alter the knowledge. The process of induction of decision trees
in Sect. 8.4 is an example of this type of method.
Similar challenges come from electronic business and knowledge management.
A classic problem presents itself here: from the actions of visitors to his web portal,
the owner of an Internet business would like to create a relationship between the
characteristics of a customer and the class of products which are interesting to that
customer. Then a seller will be able to place customer-speciﬁc advertisements. This
is demonstrated in a telling way at www.amazon.com, where the customer is rec-
ommended products which are similar to those seen in the previous visit. In many
areas of advertisement and marketing, as well as in customer relationship man-
agement (CRM), data mining techniques are coming into use. Whenever large
amounts of data are available, one can attempt to use these data for the analysis of
customer preferences in order to show customer-speciﬁc advertisements. The
emerging ﬁeld of preference learning is dedicated to this purpose.
The process of acquiring knowledge from data, as well as its representation
and application, is called data mining. The methods used are usually taken
from statistics or machine learning and should be applicable to very large
amounts of data at reasonable cost.
In the context of acquiring information, for example on the Internet or in an
intranet, text mining plays an increasingly important role. Typical tasks include
ﬁnding similar text in a search engine or the classiﬁcation of texts, which for
example is applied in spam ﬁlters for email. In Sect. 8.7.1 we will introduce the
widespread naive Bayes algorithm for the classiﬁcation of text. A relatively new
challenge for data mining is the extraction of structural, static, and dynamic
information from graph structures such as social networks, trafﬁc networks, or
Internet trafﬁc.
Because the two described tasks of machine learning and data mining are for-
mally very similar, the basic methods used in both areas are for the most part
identical. Therefore in the description of the learning algorithms, no distinction will
be made between machine learning and data mining.
Because of the huge commercial impact of data mining techniques, there are
now many sophisticated optimizations and a whole line of powerful data mining
systems, which offer a large palette of convenient tools for the extraction of
knowledge from data. Such a system is introduced in Sect. 8.10.
8.1
Data Analysis
Statistics provides a number of ways to describe data with simple parameters. From
these we choose a few which are especially important for the analysis of training
data and test these on a subset of the LEXMED data from Sect. 7.3. In this example
dataset, the symptoms x1,…, x15 of N = 473 patients, concisely described in
180
8
Machine Learning and Data Mining

Table 8.2 on page 181, as well as the class label—that is, the diagnosis (appen-
dicitis positive/negative)—are listed. Patient number one, for example, is described
by the vector
x1 ¼ ð26; 1; 0; 0; 1; 0; 1; 0; 1; 1; 0; 37:9; 38:8; 23100; 0; 1Þ
and patient number two by
x2 ¼ ð17; 2; 0; 0; 1; 0; 1; 0; 1; 1; 0; 36:9; 37:4; 8100; 0; 0Þ
Patient number two has the leukocyte value x2
14 ¼ 8100.
For each variable xi, its average xi is deﬁned as
xi :¼ 1
N
X
N
p¼1
x p
i
and the standard deviation si as a measure of its average deviation from the average
value as
si :¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
1
N  1
X
N
p¼1
ðxp
i  xiÞ2
v
u
u
t
:
The question of whether two variables xi and xj are statistically dependent (correlated)
is important for the analysis of multidimensional data. For example, the covariance
Table 8.2 Description of
variables x1, …, x16.
A slightly different
formalization was used in
Table 7.2 on page 147
Var. num.
Description
Values
1
Age
Continuous
2
Sex (1 = male, 2 = female)
1, 2
3
Pain quadrant 1
0, 1
4
Pain quadrant 2
0, 1
5
Pain quadrant 3
0, 1
6
Pain quadrant 4
0, 1
7
Local muscular guarding
0, 1
8
Generalized muscular guarding
0, 1
9
Rebound tenderness
0, 1
10
Pain on tapping
0, 1
11
Pain during rectal examination
0, 1
12
Axial temperature
Continuous
13
Rectal temperature
Continuous
14
Leukocytes
Continuous
15
Diabetes mellitus
0, 1
16
Appendicitis
0, 1
8.1
Data Analysis
181

rij ¼
1
N  1
X
N
p¼1
ðxp
i  xiÞðxp
j  xjÞ
gives information about this. In this sum, the summand returns a positive entry for
the pth data vector exactly when the deviations of the ith and jth components from
the average both have the same sign. If they have different signs, then the entry is
negative. Therefore the covariance r12,13 of the two different fever values should be
quite clearly positive.
However, the covariance also depends on the absolute value of the variables,
which makes comparison of the values difﬁcult. To be able to compare the degree
of dependence in the case of multiple variables, we therefore deﬁne the correlation
coefﬁcient
Kij ¼ rij
si  sj
for two values xi and xj, which is nothing but a normalized covariance. The matrix
K of all correlation coefﬁcients contains values between −1 and 1, is symmetric, and
all of its diagonal elements have the value 1. The correlation matrix for all 16
variables is given in Table 8.3.
This matrix becomes somewhat more readable when we represent it as a density
plot. Instead of the numerical values, the matrix elements in Fig. 8.6 on page 183
are ﬁlled with gray values. In the right diagram, the absolute values are shown.
Thus we can very quickly see which variables display a weak or strong dependence.
We can see, for example, that the variables 7, 9, 10 and 14 show the strongest
correlation with the class variable appendicitis and therefore are more important for
the diagnosis than the other variable. We also see, however, that the variables 9 and
10 are strongly correlated. This could mean that one of these two values is
potentially sufﬁcient for the diagnosis.
Table 8.3 Correlation matrix for the 16 appendicitis variables measured in 473 cases
1.
−0.009
0.14
0.037
−0.096
0.12
0.018
0.051
−0.034
−0.041
0.034
0.037
0.05
−0.037
0.37
0.012
−0.009
1.
−0.0074
−0.019
−0.06
0.063
−0.17
0.0084
−0.17
−0.14
−0.13
−0.017
−0.034
−0.14
0.045
−0.2
0.14
−0.0074
1.
0.55
−0.091
0.24
0.13
0.24
0.045
0.18
0.028
0.02
0.045
0.03
0.11
0.045
0.037
−0.019
0.55
1.
−0.24
0.33
0.051
0.25
0.074
0.19
0.087
0.11
0.12
0.11
0.14
−0.0091
−0.096
−0.06
−0.091
−0.24
1.
0.059
0.14
0.034
0.14
0.049
0.057
0.064
0.058
0.11
0.017
0.14
0.12
0.063
0.24
0.33
0.059
1.
0.071
0.19
0.086
0.15
0.048
0.11
0.12
0.063
0.21
0.053
0.018
−0.17
0.13
0.051
0.14
0.071
1.
0.16
0.4
0.28
0.2
0.24
0.36
0.29
−0.0001
0.33
0.051
0.0084
0.24
0.25
0.034
0.19
0.16
1.
0.17
0.23
0.24
0.19
0.24
0.27
0.083
0.084
−0.034
−0.17
0.045
0.074
0.14
0.086
0.4
0.17
1.
0.53
0.25
0.19
0.27
0.27
0.026
0.38
−0.041
−0.14
0.18
0.19
0.049
0.15
0.28
0.23
0.53
1.
0.24
0.15
0.19
0.23
0.02
0.32
0.034
−0.13
0.028
0.087
0.057
0.048
0.2
0.24
0.25
0.24
1.
0.17
0.17
0.22
0.098
0.17
0.037
−0.017
0.02
0.11
0.064
0.11
0.24
0.19
0.19
0.15
0.17
1.
0.72
0.26
0.035
0.15
0.05
−0.034
0.045
0.12
0.058
0.12
0.36
0.24
0.27
0.19
0.17
0.72
1.
0.38
0.044
0.21
−0.037
−0.14
0.03
0.11
0.11
0.063
0.29
0.27
0.27
0.23
0.22
0.26
0.38
1.
0.051
0.44
0.37
0.045
0.11
0.14
0.017
0.21
−0.0001
0.083
0.026
0.02
0.098
0.035
0.044
0.051
1.
−0.0055
0.012
−0.2
0.045
−0.0091
0.14
0.053
0.33
0.084
0.38
0.32
0.17
0.15
0.21
0.44
−0.0055
1.
182
8
Machine Learning and Data Mining

8.2
The Perceptron, a Linear Classifier
In the apple sorting classiﬁcation example, a curved dividing line is drawn between
the two classes in Fig. 8.3 on page 177. A simpler case is shown in Fig. 8.7. Here
the two-dimensional training examples can be separated by a straight line. We call
such a set of training data linearly separable. In n dimensions a hyperplane is
needed for the separation. This represents a linear subspace of dimension n −1.
Because every (n −1)-dimensional hyperplane in ℝn can be described by an
equation
X
n
i¼1
aixi ¼ h
it makes sense to deﬁne linear separability as follows.
Fig. 8.6 The correlation matrix as a frequency graph. In the left diagram, dark stands for negative
and light for positive. In the right image the absolute values were listed. Here black means Kij  0
(uncorrelated) and white |Kij |  1 (strongly correlated)
Fig. 8.7 A linearly separable
two dimensional data set.
The equation for the
dividing straight line is
a1x1 þ a2x2 ¼ 1
8.2
The Perceptron, a Linear Classifier
183

Deﬁnition 8.2 Two sets M1  ℝn and M2  ℝn are called linearly separable
if real numbers a1, …, an, h exist with
X
n
i¼1
aixi [ h
for all x 2 M1
and
X
n
i¼1
aixi  h
for all x 2 M2:
The value h is denoted the threshold.
In Fig. 8.8 we see that the AND function is linearly separable, but the XOR
function is not. For AND, for example, the line −x1 + 3/2 separates true and false
interpretations of the formula x1 ^ x2. In contrast, the XOR function does not have a
straight line of separation. Clearly the XOR function has a more complex structure
than the AND function in this regard.
With the perceptron, we present a very simple learning algorithm which can
separate linearly separable sets.
Deﬁnition 8.3 Let w = (w1, … , wn) 2 ℝn be a weight vector and x 2 ℝn an
input vector. A perceptron represents a function P: ℝn !{0, 1} which cor-
responds to the following rule:
PðxÞ ¼
1
if w x ¼ Pn
i¼1 wixi [ 0;
0
else.

The perceptron [Ros58, MP69] is a very simple classiﬁcation algorithm. It is
equivalent to a two-layer neural network with activation by a threshold function,
shown in Fig. 8.9 on page 185. As shown in Chap. 9, each node in the network
represents a neuron, and every edge a synapse. For now, however, we will only view
Fig. 8.8 The boolean function AND is linearly separable, but XOR is not (
^¼ true,
^¼ false)
184
8
Machine Learning and Data Mining

the perceptron as a learning agent, that is, as a mathematical function which maps a
feature vector to a function value. Here the input variables xi are denoted features.
As we can see in the formula Pn
i¼1 wixi [ 0, all points x above the hyperplane
Pn
i¼1 wixi ¼ 0 are classiﬁed as positive ðPðxÞ ¼ 1Þ, and all others as negative
PðxÞ ¼ 0. The separating hyperplane goes through the origin because h ¼ 0. We
will use a little trick to show that the absence of an arbitrary threshold represents no
restriction of power. First, however, we want to introduce a simple learning algo-
rithm for the perceptron.
8.2.1
The Learning Rule
With the notation Mþ and M for the sets of positive and negative training patterns
respectively, the perceptron learning rule reads [MP69]
PERCEPTRONLEARNING[M+,M−]
w = arbitrary vector of real numbers
Repeat
For all x ∈M+
If w x ≤0 Then w = w + x
For all x ∈M−
If w x > 0 Then w = w −x
Until all x ∈M+ ∪M−are correctly classiﬁed
The perceptron should output the value 1 for all x 2 M+. By Deﬁnition 8.3 on
page 184 this is true when w x > 0. If this is not the case then x is added to the weight
vector w, whereby the weight vector is changed in exactly the right direction. We see
this when we apply the perceptron to the changed vector w þ x because
ðw þ xÞ  x ¼ w x þ x2:
If this step is repeated often enough, then at some point the value w x will become
positive, as it should be. Analogously, we see that, for negative training data, the
perceptron calculates an ever smaller value
Fig. 8.9 Graphical
representation of a perceptron
as a two-layer neural network
8.2
The Perceptron, a Linear Classifier
185

ðw  xÞ  x ¼ w x  x2
which at some point becomes negative.2
Example 8.2 A perceptron is to be trained on the sets M+ ¼ {(0, 1.8), (2, 0.6)} and
M−¼ {(−1.2, 1.4), (0.4, −1)}. w ¼ (1, 1) was used as an initial weight vector. The
training data and the line deﬁned by the weight vector w x ¼ x1 þ x2 ¼ 0 are shown
in Fig. 8.10 on page 187 in the ﬁrst picture in the top row. In addition, the weight
vector is drawn as a dashed line. Because w x ¼ 0, this is orthogonal to the line.
In the ﬁrst iteration through the loop of the learning algorithm, the only falsely
classiﬁed training example is (−1.2, 1.4) because
ð1:2; 1:4Þ 
1
1


¼ 0:2 [ 0:
This results in w ¼ (1, 1) −(−1.2, 1.4) ¼ (2.2, −0.4), as drawn in the second image in
the top row in Fig. 8.10 on page 187. The other images show how, after a total ofﬁve
changes, the dividing line lies between the two classes. The perceptron thus classiﬁes
all data correctly. We clearly see in the example that every incorrectly classiﬁed data
point from M+ “pulls” the weight vector w in its direction and every incorrectly
classiﬁed point from M−“pushes” the weight vector in the opposite direction.
It has been shown [MP69] that the perceptron always converges for linearly
separable data. We have
Theorem 8.1 Let classes M+ and M−be linearly separable by a hyperplane
w x ¼ 0. Then PERCEPTRONLEARNING converges for every initialization of the
vector w. The perceptron P with the weight vector so calculated divides the
classes M+ and M−, that is:
PðxÞ ¼ 1
,
x 2 M þ
and
PðxÞ ¼ 0
,
x 2 M:
As we can clearly see in Example 8.2, perceptrons as deﬁned above cannot
divide arbitrary linearly separable sets, rather only those which are divisible by a
line through the origin, or in ℝn by a hyperplane through the origin, because the
constant term h is missing from the equation Pn
i¼1 wixi ¼ 0.
2Caution! This is not a proof of convergence for the perceptron learning rule. It only shows that the
perceptron converges when the training dataset consists of a single example.
186
8
Machine Learning and Data Mining

With the following trick we can generate the constant term. We hold the last
component xn of the input vector x constant and set it to the value 1. Now the
weight wn ¼: −h works like a threshold because
X
n
i¼1
wixi ¼
X
n1
i¼1
wixi  h [ 0
,
X
n1
i¼1
wixi [ h:
Such a constant value xn ¼ 1 in the input is called a bias unit. Because the
associated weight causes a constant shift of the hyperplane, the term “bias” ﬁts well.
In the application of the perceptron learning algorithm, a bit with the constant
value 1 is appended to the training data vector. We observe that the weight wn, or
the threshold h, is learned during the learning process.
Now it has been shown that a perceptron Ph: ℝn−1! {0, 1}
Phðx1; . . . ; xn1Þ ¼
1
if Pn1
i¼1 wixi [ h;
0
else

ð8:1Þ
with an arbitrary threshold can be simulated by a perceptron P: ℝn ! {0, 1} with
the threshold 0. If we compare (8.1) with the deﬁnition of linearly separable, then
we see that both statements are equivalent. In summary, we have shown that:
Fig. 8.10 Application of the perceptron learning rule to two positive (•) and two negative ( ) data
points. The solid line shows the current dividing line w x ¼ 0. The orthogonal dashed line is the
weight vector w and the second dashed line the change vector Dw ¼ x or Dw ¼ x to be added,
which is calculated from the currently active data point surrounded in light green
8.2
The Perceptron, a Linear Classifier
187

Theorem 8.2 A function f: ℝn ! {0, 1} can by represented by a perceptron if
and only if the two sets of positive and negative input vectors are linearly
separable.
Example 8.3 We now train a perceptron with a threshold on six simple, graphical
binary patterns, represented in Fig. 8.11, with 5  5 pixels each.
The training data can be learned by PERCEPTRONLEARNING in four iterations over
all patterns. Patterns with a variable number of inverted bits introduced as noise are
used to test the system’s generalization capability. The inverted bits in the test
pattern are in each case in sequence one after the other. In Fig. 8.12 the percentage
of correctly classiﬁed patterns is plotted as a function of the number of false bits.
After about ﬁve consecutive inverted bits, the correctness falls off sharply, which
is not surprising given the simplicity of the model. In the next section we will
present an algorithm that performs much better in this case.
8.2.2
Optimization and Outlook
As one of the simplest neural-network-based learning algorithms, the two-layer
perceptron can only divide linearly separable classes. In Sect. 9.5 we will see that
multi-layered networks are signiﬁcantly more powerful. Despite its simple
Fig. 8.11 The six patterns used for training. The whole right pattern is one of the 22 test patterns
for the ﬁrst pattern with a sequence of four inverted bits
Fig. 8.12 Relative
correctness of the perceptron
as a function of the number of
inverted bits in the test data
188
8
Machine Learning and Data Mining

structure, the perceptron in the form presented converges very slowly. It can
be accelerated by normalization of the weight-altering vector. The formulas
w ¼ w  x are replaced by w ¼ w  x=jxj. Thereby every data point has the same
weight during learning, independent of its value.
The speed of convergence heavily depends on the initialization of the vector w.
Ideally it would not need to be changed at all and the algorithm would converge after
one iteration. We can get closer to this goal by using the heuristic initialization
w0 ¼
X
x2M þ
x 
X
x2M
x;
which we will investigate more closely in Exercise 8.5 on page 239.
If we compare the perceptron formula with the scoring method presented in
Sect. 7.3.1, we immediately see their equivalence. Furthermore, the perceptron, as
the simplest neural network model, is equivalent to naive Bayes, the simplest type
of Bayesian network (see Exercise 8.17 on page 242). Thus evidently several very
different classiﬁcation algorithms have a common origin.
In Chap. 9 we will become familiar with a generalization of the perceptron in the
form of the back-propagation algorithm, which can divide non linearly separable
sets through the use of multiple layers, and which possesses a better learning rule.
8.3
The Nearest Neighbor Method
For a perceptron, knowledge available in the training data is extracted and saved in
a compressed form in the weights wi. Thereby information about the data is lost.
This is exactly what is desired, however, if the system is supposed to generalize
from the training data to new data. Generalization in this case is a time-intensive
process with the goal of ﬁnding a compact representation of data in the form of a
function which classiﬁes new data as good as possible.
Memorization of all data by simply saving them is quite different. Here the
learning is extremely simple. However, as previously mentioned, the saved
knowledge is not so easily applicable to new, unknown examples. Such an approach
is very unﬁt for learning how to ski, for example. A beginner can never become a
good skier just by watching videos of good skiers. Evidently, when learning
movements of this type are automatically carried out, something similar happens as
in the case of the perceptron. After sufﬁciently long practice, the knowledge stored in
training examples is transformed into an internal representation in the brain.
However, there are successful examples of memorization in which generaliza-
tion is also possible. During the diagnosis of a difﬁcult case, a doctor could try to
remember similar cases from the past. If his memory is sound, then he might hit
upon this case, look it up in his ﬁles and ﬁnally come a similar diagnosis. For this
approach the doctor must have a good feeling for similarity, in order to remember
the most similar case. If he has found this, then he must ask himself whether it is
similar enough to justify the same diagnosis.
8.2
The Perceptron, a Linear Classifier
189

What does similarity mean in the formal context we are constructing? We rep-
resent the training samples as usual in a multidimensional feature space and deﬁne:
The smaller their distance in the feature space, the more two examples are similar.
We now apply this deﬁnition to the simple two-dimensional example from
Fig. 8.13. Here the next neighbor to the black point is a negative example. Thus it is
assigned to the negative class.
The distance d(x, y) between two points x 2 ℝn and y 2 ℝn can for example be
measured by the Euclidean distance
dðx; yÞ ¼ jx  yj ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
X
n
i¼1
ðxi  yiÞ2
s
:
Because there are many other distance metrics besides this one, it makes sense to
think about alternatives for a concrete application. In many applications, certain
features are more important than others. Therefore it is often sensible to scale the
features differently by weights wi. The formula then reads
dwðx; yÞ ¼ jx  yj ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
X
n
i¼1
wiðxi  yiÞ2
s
:
The following simple nearest neighbor classiﬁcation program searches the
training data for the nearest neighbor t to the new example s and then classiﬁes
s exactly like t.3
NEARESTNEIGHBOR[M+,M−,s]
t = argminx∈M+∪M−{d(s,x)}
If t ∈M+
Then Return („+”)
Else Return(„–”)
Fig. 8.13 In this example
with negative and positive
training examples, the nearest
neighbor method groups the
new point marked in black
into the negative class
3The functionals argmin and argmax determine, similarly to min and max, the minimum or
maximum of a set or function. However, rather than returning the value of the maximum or
minimum, they give the position, that is, the argument in which the extremum appears.
190
8
Machine Learning and Data Mining

In contrast to the perceptron, the nearest neighbor method does not generate a
line that divides the training data points. However, an imaginary line separating the
two classes certainly exists. We can generate this by ﬁrst generating the so-called
Voronoi diagram. In the Voronoi diagram, each data point is surrounded by a
convex polygon, which thus deﬁnes a neighborhood around it. The Voronoi dia-
gram has the property that for an arbitrary new point, the nearest neighbor among
the data points is the data point, which lies in the same neighborhood. If the
Voronoi diagram for a set of training data is determined, then it is simple to ﬁnd the
nearest neighbor for a new point which is to be classiﬁed. The class membership
will then be taken from the nearest neighbor.
In Fig. 8.14 we see clearly that the nearest neighbor method is signiﬁcantly
more powerful than the perceptron. It is capable of correctly realizing arbitrarily
complex dividing lines (in general: hyperplanes). However, there is a danger
here. A single erroneous point can in certain circumstances lead to very bad
classiﬁcation results. Such a case occurs in Fig. 8.15 during the classiﬁcation of
the black point. The nearest neighbor method may classify this wrong. If the
black point is immediately next to a positive point that is an outlier of the
positive class, then it will be classiﬁed positive rather than negative as would
be intended here. An erroneous ﬁtting to random errors (noise) is called
overﬁtting.
Fig. 8.14 A set of points together with their Voronoi-Diagram (left) and the dividing line
generated for the two classes M+ and M−
Fig. 8.15 The nearest
neighbor method assigns the
new point marked in black to
the wrong (positive) class
because the nearest neighbor
is most likely classiﬁed wrong
8.3
The Nearest Neighbor Method
191

To prevent false classiﬁcations due to single outliers, it is recommended to
smooth out the division surface somewhat. This can be accomplished by, for
example, with the K-NEARESTNEIGHBOR algorithm in Fig. 8.16, which makes a
majority decision among the k nearest neighbors.
Example 8.4 We now apply NEARESTNEIGHBOR to Example 8.3 on page 188.
Because we are dealing with binary data, we use the Hamming distance as the
distance metric.4 As a test example, we again use modiﬁed training examples with
n consecutive inverted bits each. In Fig. 8.17 the percentage of correctly classiﬁed
test examples is shown as a function of the number of inverted bits b. For up to
eight inverted bits, all patterns are correctly identiﬁed. Past that point, the number of
errors quickly increases. This is unsurprising because training pattern number 2
from Fig. 8.11 on page 188 from class Mþ has a hamming distance of 9 to the two
training examples, numbers 4 and 5 from the other class. This means that the test
pattern is very likely close to the patterns of the other class. Quite clearly we see
that nearest neighbor classiﬁcation is superior to the perceptron in this application
for up to eight false bits.
K-NEARESTNEIGHBOR(M+,M−,s)
V = {k nearest neighbors in M+ ∪M−}
If
|M+ ∩V | > |M−∩V | Then
Return(„+”)
ElseIf |M+ ∩V | < |M−∩V | Then
Return(„–”)
Else
Return(Random(„+”, „–”))
Fig. 8.16 The K-NEARESTNEIGHBOR ALGORITHM
Fig. 8.17 Relative
correctness of nearest
neighbor classiﬁcation as a
function of the number of
inverted bits. The structure of
the curve with its minimum at
13 and its maximum at 19 is
related to the special structure
of the training data. For
comparison the values of the
perceptron from Example 8.3
on page 188 are shown in
gray
4The Hamming distance between two bit vectors is the number of different bits of the two vectors.
192
8
Machine Learning and Data Mining

8.3.1
Two Classes, Many Classes, Approximation
Nearest neighbor classiﬁcation can also be applied to more than two classes. Just like
the case of two classes, the class of the feature vector to be classiﬁed is simply set as
the class of the nearest neighbor. For the k nearest neighbor method, the class is to be
determined as the class with the most members among the k nearest neighbors.
If the number of classes is large, then it usually no longer makes sense to use
classiﬁcation algorithms because the size of the necessary training data grows
quickly with the number of classes. Furthermore, in certain circumstances important
information is lost during classiﬁcation of many classes. This will become clear in
the following example.
Example 8.5 An autonomous robot with simple sensors similar to the Braitenberg
vehicles presented in Fig. 1.1 on page 2 is supposed to learn to move away from
light. This means it should learn as optimally as possible to map its sensor values
onto a steering signal which controls the driving direction. The robot is equipped
with two simple light sensors on its front side. From the two sensor signals (with sl
for the left and sr for the right sensor), the relationship x ¼ sr /sl is calculated.
To control the electric motors of the two wheels from this value x, the difference
v ¼ Ur −Ul of the two voltages Ur and Ul of the left and right motors, respectively.
The learning agent’s task is now to avoid a light signal. It must therefore learn a
mapping f which calculates the “correct” value v ¼ f ðxÞ.5
For this we carry out an experiment in which, for a few measured values x, we
ﬁnd as optimal a value v as we can. These values are plotted as data points in
Fig. 8.18 and shall serve as training data for the learning agent. During nearest
neighbor classiﬁcation each point in the feature space (that is, on the x-axis) is
classiﬁed exactly like its nearest neighbor among the training data. The function for
steering the motors is then a step function with large jumps (Fig. 8.18 middle). If
we want ﬁner steps, then we must provide correspondingly more training data. On
Fig. 8.18 The learning agent, which is supposed to avoid light (left), represented as a classiﬁer
(middle), and as an approximation (right)
5To keep the example simple and readable, the feature vector x was deliberately kept
one-dimensional.
8.3
The Nearest Neighbor Method
193

the other hand, we can obtain a continuous function if we approximate a smooth
function to ﬁt the ﬁve points (Fig. 8.18 on page 193 right). Requiring the function
f to be continuous leads to very good results, even with no additional data points.
For the approximation of functions on data points there are many mathematical
methods, such as polynomial interpolation, spline interpolation, or the method of
least squares. The application of these methods becomes problematic in higher
dimensions. The special difﬁculty in AI is that model-free approximation methods
are needed. That is, a good approximation of the data must be made without
knowledge about special properties of the data or the application. Very good results
have been achieved here with neural networks and other nonlinear function
approximators, which are presented in Chap. 9.
The k nearest neighbor method can be applied in a simple way to the approximation
problem. In the algorithm K-NEARESTNEIGHBOR, after the set V = {x1, x2, … , xk}
is determined, the k nearest neighbors average function value
^fðxÞ ¼ 1
k
X
k
i¼1
f ðxiÞ
ð8:2Þ
is calculated and taken as an approximation ^f for the query vector x. The larger
k becomes, the smoother the function ^f is.
8.3.2
Distance Is Relevant
In practical application of discrete as well as continuous variants of the k nearest
neighbor method, problems often occur. As k becomes large, there typically exist
more neighbors with a large distance than those with a small distance. Thereby the
calculation of ^f is dominated by neighbors that are far away. To prevent this, the
k neighbors are weighted such that the more distant neighbors have lesser inﬂuence
on the result. During the majority decision in the algorithm K-NEARESTNEIGHBOR, the
“votes” are weighted with the weight
wi ¼
1
1 þ adðx; xiÞ2 ;
ð8:3Þ
which decreases with the square of the distance. The constant a determines the
speed of decrease of the weights. Equation (8.2) is now replaced by
^fðxÞ ¼
Pk
i¼1 wi fðxiÞ
Pk
i¼1 wi
:
For uniformly distributed concentration of points in the feature space, this ensures
that the inﬂuence of points asymptotically approaches zero as distance increases.
Thereby it becomes possible to use many or even all training data to classify or
approximate a given input vector.
194
8
Machine Learning and Data Mining

To get a feeling for these methods, in Fig. 8.19 the k-nearest neighbor method
(in the upper row) is compared with its distance weighted optimization. Due to the
averaging, both methods can generalize, or in other words, cancel out noise, if the
number of neighbors for k-nearest neighbor or the parameter a is set appropriately.
The diagrams show nicely that the distance weighted method gives a much
smoother approximation than k-nearest neighbor. With respect to approximation
quality, this very simple method can compete well with sophisticated approxima-
tion algorithms such as nonlinear neural networks, support vector machines, and
Gaussian processes.
There are many alternatives to the weight function (also called kernel) given in
(8.3) on page 194. For example a Gaussian or similar bell-shaped function can be
used. For most applications, the results are not very sensible on the selection of the
kernel. However, the width parameter a which for all these functions has to be set
manually has great inﬂuence on the results, as shown in Fig. 8.19. To avoid such an
inconvenient manual adaptation, optimization methods have been developed for
automatically setting this parameter [SA94, SE10].
8.3.3
Computation Times
As previously mentioned, training is accomplished in all variants of the nearest
neighbor method by simply saving all training vectors together with their labels
(class values), or the function value f(x). Thus there is no other learning algorithm
that learns as quickly. However, answering a query for classiﬁcation or approxi-
mation of a vector x can become very expensive. Just ﬁnding the k nearest
neighbors for n training data requires a cost which grows linearly with n. For
classiﬁcation or approximation, there is additionally a cost which is linear in k. The
total computation time thus grows as H(n + k). For large amounts of training data,
this can lead to problems.
Fig. 8.19 Comparison of the k-nearest neighbor method (upper row) with k ¼ 1 (left), k ¼ 2
(middle) and k ¼ 6 (right), to its distance weighted variant (lower row) with a ¼ 20 (left), a ¼ 4
(middle) and a ¼ 1 (right) on a one-dimensional dataset
8.3
The Nearest Neighbor Method
195

8.3.4
Summary and Outlook
Because nothing happens in the learning phase of the presented nearest neighbor
methods, such algorithms are also denoted lazy learning, in contrast to eager
learning, in which the learning phase can be expensive, but application to new
examples is very efﬁcient. The perceptron and all other neural networks, decision
tree learning, and the learning of Bayesian networks are eager learning methods.
Since the lazy learning methods need access to the memory with all training data for
approximating a new input, they are also called memory-based learning.
To compare these two classes of learning processes, we will use as an example
the task of determining the current avalanche hazard from the amount of newly
fallen snow in a certain area of Switzerland.6 In Fig. 8.20 values determined by
experts are entered, which we want to use as training data. During the application of
a eager learning algorithm which undertakes a linear approximation of the data, the
dashed line shown in the ﬁgure is calculated. Due to the restriction to a straight line,
the error is relatively large with a maximum of about 1.5 hazard levels. During lazy
learning, nothing is calculated before a query for the current hazard level arrives.
Then the answer is calculated from several nearest neighbors, that is, locally. It
could result in the curve shown in the ﬁgure, which is put together from line
segments and shows much smaller errors. The advantage of the lazy method is its
locality. The approximation is taken locally from the current new snow level and
not globally. Thus for fundamentally equal classes of functions (for example linear
functions), the lazy algorithms are better.
Nearest neighbor methods are well suited for all problem situations in which a
good local approximation is needed, but which do not place a high requirement on
the speed of the system. The avalanche predictor mentioned here, which runs once
per day, is such an application. Nearest neighbor methods are not suitable when a
description of the knowledge extracted from the data must be understandable by
Fig. 8.20 To determine
avalanche hazard, a function
is approximated from training
data. Here for comparison are
a local model (solid line), and
a global model (dashed line)
6The three day total of snowfall is in fact an important feature for determining the hazard level. In
practice, however, additional attributes are used [Bra01]. The example used here is simpliﬁed.
196
8
Machine Learning and Data Mining

humans, which today is the case for many data mining applications (see Sect. 8.4).
In recent years these memory-based learning methods are becoming popular, and
various improved variants (for example locally weighted linear regression) have
been applied [Cle79].
To be able to use the described methods, the training data must be available in
the form of vectors of integers or real numbers. They are thus unsuitable for
applications in which the data are represented symbolically, for example as ﬁrst
order logic formulas. We will now brieﬂy discuss this.
8.3.5
Case-Based Reasoning
In case-based reasoning (CBR), the nearest neighbor method is extended to sym-
bolic problem descriptions and their solutions. CBR is used in the diagnosis of
technical problems in customer service or for telephone hotlines. The example
shown in Fig. 8.21 about the diagnosis of a bicycle light going out illustrates this
type of situation.
A solution is searched for the query of a customer with a defective rear bicycle
light. In the right column, a case similar to the query in the middle column is given.
This stems from the case base, which corresponds to training data in the nearest
neighbor method. If we simply took the most similar case, as we do in the nearest
neighbor method, then we would end up trying to repair the front light when the
rear light is broken. We thus need a reverse transformation of the solution to the
discovered similar problem back to the query. The most important steps in the
solution to a CBR case are carried out in Fig. 8.22 on page 198. The transformation
in this example is simple: rear light is mapped to front light.
As beautiful and simple as this methods seems in theory, in practice the con-
struction of CBR diagnostic systems is a very difﬁcult task. The three main difﬁ-
culties are:
Modeling The domains of the application must be modeled in a formal context. Here
logical monotony, which we know from Chap. 4, presents difﬁculties. Can the
developer predict and map all possible special cases and problem variants?
Feature
Query
Case from case base
Defective part:
Rear light
Front light
Bicycle model:
Marin Pine Mountain
VSF T400
Year:
1993
2001
Power source:
Battery
Dynamo
Bulb condition:
ok
ok
Light cable condition:
?
ok
Solution
Diagnosis:
?
Front electrical contact missing
Repair:
?
Establish front electrical contact
Fig. 8.21 Simple diagnosis example for a query and the corresponding case from the case base
8.3
The Nearest Neighbor Method
197

Similarity Finding a suitable similarity metric for symbolic, non-numerical features.
Transformation Even if a similar case is found, it is not yet clear how the
transformation mapping and its inverse should look.
Indeed there are practical CBR systems for diagnostic applications in use today.
However, due to the reasons mentioned, these remain far behind human experts in
performance and ﬂexibility. An interesting alternative to CBR are the Bayesian
networks presented in Chap. 7. Often the symbolic problem representation can also
be mapped quite well to discrete or continuous numerical features. Then the
mentioned inductive learning methods such as decision trees or neural networks can
be used successfully.
8.4
Decision Tree Learning
Decision tree learning is an extraordinarily important algorithm for AI because it is
very powerful, but also simple and efﬁcient for extracting knowledge from data.
Compared to the two already introduced learning algorithms, it has an important
advantage. The extracted knowledge is not only available and usable as a black box
function, but rather it can be easily understood, interpreted, and controlled by
humans in the form of a readable decision tree. This also makes decision tree
learning an important tool for data mining.
We will discuss function and application of decision tree learning using the C4.5
algorithm. C4.5 was introduced in 1993 by the Australian Ross Quinlan and is an
improvement of its predecessor ID3 (Iterative Dichotomiser 3, 1986). It is freely
available for noncommercial use [Qui93]. A further development, which works even
more efﬁciently and can take into account the costs of decisions, is C5.0 [Qui93].
The CART (Classiﬁcation and Regression Trees, 1984) system developed by Leo
Breiman [BFOS84] works similarly to C4.5. It has a convenient graphical user
interface, but is very expensive.
Twenty years earlier, in 1964, the CHAID (Chi-square Automatic Interaction
Detectors) system, which can automatically generate decision trees, was introduced
by J. Sonquist and J. Morgan. It has the noteworthy characteristic that it stops the
growth of the tree before it becomes too large, but today it has no more relevance.
Fig. 8.22 If for a case x a similar case y is found, then to obtain a solution for x, the
transformation must be determined and its inverse applied to the discovered case y
198
8
Machine Learning and Data Mining

Also interesting is the data mining tool KNIME (Konstanz Information Miner),
which has a friendly user interface and, using the WEKA Java library, also makes
induction of decision trees possible. In Sect. 8.10 we will introduce KNIME.
Now we ﬁrst show in a simple example how a decision tree can be constructed
from training data, in order to then analyze the algorithm and apply it to the more
complex LEXMED example for medical diagnosis.
8.4.1
A Simple Example
A devoted skier who lives near the high sierra, a beautiful mountain range in
California, wants a decision tree to help him decide whether it is worthwhile to
drive his car to a ski resort in the mountains. We thus have a two-class problem ski
yes/no based on the variables listed in Table 8.4.
Figure 8.23 on page 200 shows a decision tree for this problem. A decision tree
is a tree whose inner nodes represent features (attributes). Each edge stands for an
attribute value. At each leaf node a class value is given.
The data used for the construction of the decision tree are shown in Table 8.5 on
page 200. Each row in the table contains the data for one day and as such represents
a sample. Upon closer examination we see that row 6 and row 7 contradict each
other. Thus no deterministic classiﬁcation algorithm can correctly classify all of the
data. The number of falsely classiﬁed data must therefore be 	 1. The tree in
Fig. 8.23 on page 200 thus classiﬁes the data optimally.
How is such a tree created from the data? To answer this question we will at
ﬁrst restrict ourselves to discrete attributes with ﬁnitely many values. Because the
number of attributes is also ﬁnite and each attribute can occur at most once per
path, there are ﬁnitely many different decision trees. A simple, obvious algorithm
for the construction of a tree would simply generate all trees, then for each tree
calculate the number of erroneous classiﬁcations of the data, and at the end
choose the tree with the minimum number of errors. Thus we would even have an
optimal algorithm (in the sense of errors for the training data) for decision tree
learning.
The obvious disadvantage of this algorithm is its unacceptably high computation
time, as soon as the number of attributes becomes somewhat larger. We will now
develop a heuristic algorithm which, starting from the root, recursively builds
Table 8.4 Variables for the skiing classiﬁcation problem
Variable
Value
Description
Ski (goal variable)
yes, no
Should I drive to the nearest ski resort with enough snow?
Sun (feature)
yes, no
Is there sunshine today?
Snow_Dist (feature)  100, >100 Distance to the nearest ski resort with good snow conditions
(over/under 100 km)
Weekend (feature)
yes, no
Is it the weekend today?
8.4
Decision Tree Learning
199

a decision tree. First the attribute with the highest information gain (Snow_ Dist) is
chosen for the root node from the set of all attributes. For each attribute value
(100, >100) there is a branch in the tree. Now for every branch this process is
repeated recursively. During generation of the nodes, the attribute with the highest
information gain among the attributes which have not yet been used is always
chosen, in the spirit of a greedy strategy.
8.4.2
Entropy as a Metric for Information Content
The described top-down algorithm for the construction of a decision tree, at each
step selects the attribute with the highest information gain. We now introduce the
Fig. 8.23 Decision tree for the skiing classiﬁcation problem. In the lists to the right of the nodes,
the numbers of the corresponding training data are given. Notice that of the leaf nodes sunny = yes
only two of the three examples are classiﬁed correctly
Table 8.5 Data set for the
skiing classiﬁcation problem
Day
Snow_Dist
Weekend
Sun
Skiing
1
100
yes
yes
yes
2
100
yes
yes
yes
3
100
yes
no
yes
4
100
no
yes
yes
5
>100
yes
yes
yes
6
>100
yes
yes
yes
7
>100
yes
yes
no
8
>100
yes
no
no
9
>100
no
yes
no
10
>100
no
yes
no
11
>100
no
no
no
200
8
Machine Learning and Data Mining

entropy as the metric for the information content of a set of training data D. If we
only look at the binary variable skiing in the above example, then D can be
described as
D ¼ (yes, yes, yes, yes, yes, yes, no, no, no, no, no)
with estimated probabilities
p1 ¼ PðyesÞ ¼ 6=11
and
p2 ¼ PðnoÞ ¼ 5=11:
Here we evidently have a probability distribution p ¼ (6/11, 5/11). In general, for
an n class problem this reads
p ¼ ðp1; . . .; pnÞ
with
X
n
i¼1
pi ¼ 1:
To introduce the information content of a distribution we observe two extreme
cases. First let
p ¼ ð1; 0; 0; . . .; 0Þ:
ð8:4Þ
That is, the ﬁrst one of the n events will certainly occur and all others will not. The
uncertainty about the outcome of the events is thus minimal. In contrast, for the
uniform distribution
p ¼
1
n ; 1
n ; . . .; 1
n

ð8:5Þ
the uncertainty is maximal because no event can be distinguished from the others.
Here Claude Shannon asked himself how many bits would be needed to encode such
an event. In the certain case of (8.4) zero bits are needed because we know that the
case i ¼ 1 always occurs. In the uniformly distributed case of (8.5) there are n equally
probable possibilities. For binary encodings, log2n bits are needed here. Because all
individual probabilities are pi ¼ 1/n, log2
1
pi bits are needed for this encoding.
In the general case p ¼ (p1, … , pn), if the probabilities of the elementary events
deviate from the uniform distribution, then the expectation value H for the number
of bits is calculated. To this end we will weight all values log2
1
pi ¼  log2 pi with
their probabilities and obtain
H ¼
X
n
i¼1
pið log2 piÞ ¼ 
X
n
i¼1
pi log2 pi:
The more bits we need to encode an event, clearly the higher the uncertainty about
the outcome. Therefore we deﬁne:
8.4
Decision Tree Learning
201

Deﬁnition 8.4 The Entropy H as a metric for the uncertainty of a probability
distribution is deﬁned by7
Hð pÞ ¼ Hðp1; . . .; pnÞ :¼ 
X
n
i¼1
pi log2 pi:
A detailed derivation of this formula is found in [SW76]. If we substitute the
certain event p ¼ (1, 0, 0, … , 0), then 0log2 0, an undeﬁned expression results. We
solve this problem by the deﬁnition 0log2 0 := 0 (see Exercise 8.10 on page 240).
Now we can calculate H(1, 0, … , 0) = 0. We will show that the entropy in the
hypercube [0, 1]n under the constraint Pn
i¼1 pi ¼ 1 takes on its maximum value
with the uniform distribution ð1
n ; . . .; 1
nÞ. In the case of an event with two possible
outcomes, which correspond to two classes, the result is
Hð pÞ ¼ Hðp1; p2Þ ¼ Hðp1; 1  p1Þ ¼ ðp1 log2 p1 þ ð1  p1Þ log2ð1  p1ÞÞ:
This expression is shown as a function of p1 in Fig. 8.24 with its maximum at
p1 = 1/2.
Because each classiﬁed dataset D is assigned a probability distribution p by
estimating the class probabilities, we can extend the concept of entropy to data by
the deﬁnition
Fig. 8.24 The entropy
function for the case of two
classes. We see the maximum
at p ¼ 1/2 and the symmetry
with respect to swapping
p and 1 −p
7In (7.9) on page 138 the natural logarithm rather than log2 is used in the deﬁnition of entropy.
Because here, and also in the case of the MaxEnt method, entropies are only being compared, this
difference does not play a role. (see Exercise 8.12 on page 240).
202
8
Machine Learning and Data Mining

HðDÞ ¼ Hð pÞ:
Now, since the information content I(D) of the dataset D is meant to be the opposite
of uncertainty. Thus we deﬁne:
Deﬁnition 8.5 The information content of a dataset is deﬁned as
IðDÞ :¼ 1  HðDÞ:
ð8:6Þ
8.4.3
Information Gain
If we apply the entropy formula to the example, the result is
Hð6=11; 5=11Þ ¼ 0:994
During construction of a decision tree, the dataset is further subdivided by each new
attribute. The more an attribute raises the information content of the distribution by
dividing the data, the better that attribute is. We deﬁne accordingly:
Deﬁnition 8.6 The information gain G(D, A) through the use of the attribute
A is determined by the difference of the average information content of the
dataset D ¼ D1 [ D2 [ ⋅⋅⋅[ Dn divided by the n-value attribute A and the
information content I(D) of the undivided dataset, which yields
GðD; AÞ ¼
X
n
i¼1
jDij
jDj IðDiÞ  IðDÞ:
With (8.6) we obtain from this
GðD; AÞ ¼
X
n
i¼1
jDij
jDjIðDiÞ  IðDÞ ¼
X
n
i¼1
jDij
jDjð1  HðDiÞÞ  ð1  HðDÞÞ
¼ 1 
X
n
i¼1
jDij
jDjHðDiÞ  1 þ HðDÞ
¼ HðDÞ 
X
n
i¼1
jDij
jDjHðDiÞ:
ð8:7Þ
8.4
Decision Tree Learning
203

Applied to our example for the attribute Snow_Dist, this yields
GðD; Snow DistÞ ¼ HðDÞ 
4
11 HðD  100Þ þ 7
11 HðDÞ[100


¼ 0:994 
4
11  0 þ 7
11  0:863


¼ 0:445:
Analogously we obtain
GðD; WeekendÞ ¼ 0:150
and
GðD; SunÞ ¼ 0:049:
The attribute Snow_Dist now becomes the root node of the decision tree. The
situation of the selection of this attribute is once again clariﬁed in Fig. 8.25.
The two attribute values 100 and >100 generate two edges in the tree, which
correspond to the subsets D100 and D>100. For the subset D100 the classiﬁcation is
clearly yes. thus the tree terminates here. In the other branch D>100 there is no clear
result. Thus the algorithm repeats recursively. From the two attributes still avail-
able, Sun and Weekend, the better one must be chosen. We calculate
GðD[100; WeekendÞ ¼ 0:292
and
GðD[100; SunÞ ¼ 0:170:
The node thus gets the attribute Weekend assigned. For Weekend = no the tree
terminates with the decision Ski = no. A calculation of the gain here returns the
value 0. For Weekend = yes, Sun results in a gain of 0.171. Then the construction of
the tree terminates because no further attributes are available, although example
Fig. 8.25 The calculated gain for the various attributes reﬂects whether the division of the data by
the respective attribute results in a better class division. The more the distributions generated by the
attribute deviate from the uniform distribution, the higher the information gain
204
8
Machine Learning and Data Mining

number 7 is falsely classiﬁed. The ﬁnished tree is already familiar from Fig. 8.23 on
page 200.
8.4.4
Application of C4.5
The decision tree that we just generated can also be generated by C4.5. The training
data are saved in a data ﬁle ski.data in the following format:
The information about attributes and classes is stored in the ﬁle ski.names
(lines beginning with “|” are comments):
C4.5 is then called from the Unix command line and generates the decision tree
shown below, which is formatted using indentations. The option -f is for the name
of the input ﬁle, and the option -m speciﬁes the minimum number of training data
points required for generating a new branch in the tree. Because the number of
training data points in this example is extremely small, -m 1 is sensible here. For
larger datasets, a value of at least -m 10 should be used.
<=100, yes,
yes,
yes
<=100, yes,
yes,
yes
<=100, yes,
no,
yes
<=100, no,
yes,
yes
>100,
yes,
yes,
yes
>100,
yes,
yes,
yes
>100,
yes,
yes,
no
>100,
yes,
no,
no
>100,
no,
yes,
no
>100,
no,
yes,
no
>100,
no,
no,
no
|Classes: no: do not ski, yes: go skiing
|
no,yes.
|
|Attributes
|
Snow_Dist:
<=100,>100.
Weekend:
no,yes.
Sun:
no,yes.
8.4
Decision Tree Learning
205

Additionally, a simpliﬁed tree with only one attribute is given. This tree, which
was created by pruning (see Sect. 8.4.7), will be important for an increasing amount
of training data. In this little example it does not yet makes much sense. The error
rate for both trees on the training data is also given. The numbers in parentheses
after the decisions give the size of the underlying dataset and the number of errors.
For example, the line Sun = yes: yes (3.0/1.0) in the top tree indicates that
for this leaf node Sun = yes, three training examples exist, one of which is falsely
classiﬁed. The user can thus read from this whether the decision is statistically
grounded and/or certain.
In Fig. 8.26 on page 207 we can now give the schema of the learning algorithm
for generating a decision tree.
We are now familiar with the foundations of the automatic generation of deci-
sion trees. For the practical application, however, important extensions are needed.
We will introduce these using the already familiar LEXMED application.
unixprompt> c4.5 -f ski -m 1
C4.5 [release 8] decision tree generator
Wed Aug 23 10:44:49 2010
----------------------------------------
Options:
File stem <ski>
Sensible test requires 2 branches with >=1 cases
Read 11 cases (3 attributes) from ski.data
Decision Tree:
Snow_Dist = <=100: ja (4.0)
Snow_Dist = >100:
|
Weekend = no: no (3.0)
|
Weekend = yes:
|
| Sun = no: no (1.0)
|
| Sun = yes: yes (3.0/1.0)
Simplified Decision Tree:
Snow_Dist = <=100: yes (4.0/1.2)
Snow_Dist = >100: no (7.0/3.4)
Evaluation on training data (11 items):
Before Pruning
After Pruning
----------------
---------------------------
Size
Errors
Size
Errors
Estimate
7
1(9.1%)
3
2(18.2%)
(41.7%) <<
206
8
Machine Learning and Data Mining

8.4.5
Learning of Appendicitis Diagnosis
In the research project LEXMED, an expert system for the diagnosis of appendicitis
was developed on top of a database of patient data [ES99, SE00]. The system,
which works with the method of maximum entropy, is described in Sect. 7.3.
We now use the LEXMED database to generate a decision tree for diagnosing
appendicitis with C4.5. The symptoms used as attributes are deﬁned in the ﬁle
app.names:
GENERATEDECISIONTREE(Data,Node)
Amax = Attribute with maximum information gain
If G(Amax) = 0
Then Node becomes leaf node with most frequent class in Data
Else assign the attribute Amax to Node
For each value a1,...,an of Amax, generate
a successor node: K1,...,Kn
Divide Data into D1,...,Dn with Di = {x ∈Data|Amax(x) = ai}
For all i ∈{1,...,n}
If all x ∈Di belong to the same class Ci
Then generate leaf node Ki of class Ci
Else GENERATEDECISIONTREE(Di,Ki)
Fig. 8.26 Algorithm for the construction of a decision tree
|Definition of the classes and attributes
|
|Classes 0=appendicitis negative
| 1=appendicitis positive
0,1.
|
|Attributes
|
Age: continuous.
Sex_(1=m___2=w): 1,2.
Pain_Quadrant1_(0=no__1=yes): 0,1.
Pain_Quadrant2_(0=no__1=yes): 0,1.
Pain_Quadrant3_(0=no__1=yes): 0,1.
Pain_Quadrant4_(0=no__1=yes): 0,1.
Local_guarding_(0=no__1=yes): 0,1.
Generalized_guarding_(0=no__1=yes): 0,1.
Rebound_tenderness_(0=no__1=yes): 0,1.
Pain_on_tapping_(0=no__1=yes): 0,1.
8.4
Decision Tree Learning
207

Pain_during_rectal_examination_(0=no__1=yes): 0,1.
Temp_axial: continuous.
Temp_rectal: continuous.
Leukocytes: continuous.
Diabetes_mellitus_(0=no__1=yes): 0,1
We see that, besides many binary attributes such as the various pain symptoms,
continuous symptoms such as age and fever temperature also occur. In the fol-
lowing training data ﬁle, app.data, in each line a case is described. In the ﬁrst
line is a 19-year-old male patient with pain in the third quadrant (lower right, where
the appendix is), the two fever values 36.2 and 37.8 degree Celsius a leukocyte
value of 13400 and a positive diagnosis, that is, an inﬂamed appendix.
19,1,0,0,1,0,1,0,1,1,0,362,378,13400,0,1
13,1,0,0,1,0,1,0,1,1,1,383,385,18100,0,1
32,2,0,0,1,0,1,0,1,1,0,364,374,11800,0,1
18,2,0,0,1,1,0,0,0,0,0,362,370,09300,0,0
73,2,1,0,1,1,1,0,1,1,1,376,380,13600,1,1
30,1,1,1,1,1,0,1,1,1,1,377,387,21100,0,1
56,1,1,1,1,1,0,1,1,1,0,390,?,14100,0,1
36,1,0,0,1,0,1,0,1,1,0,372,382,11300,0,1
36,2,0,0,1,0,0,0,1,1,1,370,379,15300,0,1
33,1,0,0,1,0,1,0,1,1,0,367,376,17400,0,1
19,1,0,0,1,0,0,0,1,1,0,361,375,17600,0,1
12,1,0,0,1,0,1,0,1,1,0,364,370,12900,0,0
...
Without going into detail about the database, it is important to mention that only
patients who were suspected of having appendicitis upon arrival at the hospital and
were then operated upon are included in the database. We see in the seventh row
that C4.5 can also deal with missing values. The data contain 9764 cases.
unixprompt> c4.5 -f app -u -m 100
C4.5 [release 8] decision tree generator
Wed Aug 23 13:13:15 2006
----------------------------------------
Read 9764 cases (15 attributes) from app.data
Decision Tree:
208
8
Machine Learning and Data Mining

Leukocytes <= 11030 :
| Rebound_tenderness = 0:
| | Temp_rectal > 381 : 1 (135.9/54.2)
| | Temp_rectal <= 381 :
| | | Local_guarding = 0: 0 (1453.3/358.9)
| | | Local_guarding = 1:
| | | | Sex_(1=m___2=w) = 1: 1 (160.1/74.9)
| | | | Sex_(1=m___2=w) = 2: 0 (286.3/97.6)
| Rebound_tenderness = 1:
| | Leukocytes <= 8600 :
| | | Temp_rectal > 378 : 1 (176.0/59.4)
| | | Temp_rectal <= 378 :
| | | | Sex_(1=m___2=w) = 1:
| | | | | Local_guarding = 0: 0 (110.7/51.7)
| | | | | Local_guarding = 1: 1 (160.6/68.5)
| | | | Sex_(1=m___2=w) = 2:
| | | | | Age <= 14 : 1 (131.1/63.1)
| | | | | Age > 14 : 0 (398.3/137.6)
| | Leukocytes > 8600 :
| | | Sex_(1=m___2=w) = 1: 1 (429.9/91.0)
| | | Sex_(1=m___2=w) = 2:
| | | | Local_guarding = 1: 1 (311.2/103.0)
| | | | Local_guarding = 0:
| | | | | Temp_rectal <= 375 : 1 (125.4/55.8)
| | | | | Temp_rectal > 375 : 0 (118.3/56.1)
Leukocytes > 11030 :
| Rebound_tenderness = 1: 1 (4300.0/519.9)
| Rebound_tenderness = 0:
| | Leukocytes > 14040 : 1 (826.6/163.8)
| | Leukocytes <= 14040 :
| | | Pain_on_tapping = 1: 1 (260.6/83.7)
| | | Pain_on_tapping = 0:
| | | | Local_guarding = 1: 1 (117.5/44.4)
| | | | Local_guarding = 0:
| | | | | Temp_axial <= 368 : 0 (131.9/57.4)
| | | | | Temp_axial > 368 : 1 (130.5/57.8)
Simplified Decision Tree:
Leukocytes > 11030 : 1 (5767.0/964.1)
Leukocytes <= 11030 :
| Rebound_tenderness = 0:
| | Temp_rectal > 381 : 1 (135.9/58.7)
| | Temp_rectal <= 381 :
| | | Local_guarding = 0: 0 (1453.3/370.9)
| | | Local_guarding = 1:
| | | | Sex_(1=m___2=w) = 1: 1 (160.1/79.7)
| | | | Sex_(1=m___2=w) = 2: 0 (286.3/103.7)
| Rebound_tenderness = 1:
| | Leukocytes > 8600 : 1 (984.7/322.6)
| | Leukocytes <= 8600 :
8.4
Decision Tree Learning
209

| | | Temp_rectal > 378 : 1 (176.0/64.3)
| | | Temp_rectal <= 378 :
| | | | Sex_(1=m___2=w) = 1:
| | | | | Local_guarding = 0: 0 (110.7/55.8)
| | | | | Local_guarding = 1: 1 (160.6/73.4)
| | | | Sex_(1=m___2=w) = 2:
| | | | | Age <= 14 : 1 (131.1/67.6)
| | | | | Age > 14 : 0 (398.3/144.7)
Evaluation on training data (9764 items):
Before Pruning
After Pruning
----------------
---------------------------
Size
Errors
Size
Errors
Estimate
37
2197(22.5%)
21
2223(22.8%)
(23.6%)
<<
Evaluation on test data (4882 items):
Before Pruning
After Pruning
----------------
---------------------------
Size
Errors
Size
Errors
Estimate
37
1148(23.5%)
21
1153(23.6%)
(23.6%)
<<
(a)
(b)
<-classified as
---- ----
758
885
(a): class 0
268 2971
(b): class 1
8.4.6
Continuous Attributes
In the trees generated for the appendicitis diagnosis there is a node Leukocytes >
11030 which clearly comes from the continuous attribute Leukocytes by setting a
threshold at the value 11030. C4.5 thus has made a binary attribute Leukocytes >
11030 from the continuous attribute Leukocytes. The threshold HD; A for an
attribute A is determined by the following algorithm: for all values v which occur in the
training data D, the binary attribute A > v is generated and its information gain is
calculated. The threshold HD; A is then set to the value v with the maximum infor-
mation gain, that is:
HD; A ¼ argmaxvfGðD; A [ vÞg:
For an attribute such as the leukocyte value or the patient’s age, a decision based on a
binary discretization is presumably too imprecise. Nevertheless there is no need to
discretize ﬁner because each continuous attribute is tested on each newly generated
node and can thus occur repeatedly in one tree with a different threshold HD;A. Thus
we ultimately obtain a very good discretization whose ﬁneness ﬁts the problem.
210
8
Machine Learning and Data Mining

8.4.7
Pruning—Cutting the Tree
Since the time of Aristotle it has been stipulated that of two scientiﬁc theories which
explain the same situation equally well, the simpler one is preferred. This law of
economy, also now known as Occam’s razor, is of great importance for machine
learning and data mining.
A decision tree is a theory for describing the training data. A different theory for
describing the data is the data themselves. If the tree classiﬁes all data without any
errors, but is much more compact and thus more easily understood by humans, then
it is preferable according to Occam’s razor. The same is true for two decision trees
of different sizes. Thus the goal of every algorithm for generating a decision tree
must be to generate the smallest possible decision tree for a given error rate. Among
all trees with a ﬁxed error rate, the smallest tree should always be selected.
Up until now we have not deﬁned the term error rate precisely. As already
mentioned several times, it is important that the learned tree not just memorize the
training data, rather that it generalizes well. To test the ability of a tree to generalize,
we divide the available data into a set of training data and a set of v. The test data
are hidden from the learning algorithm and only used for testing. If a large dataset is
available, such as the appendicitis data, then we can for example use two-thirds of
the data for learning and the remaining third for testing.
Aside from better comprehensibility, Occam’s razor has another important jus-
tiﬁcation: generalization ability. The more complex the model (here a decision tree),
the more details are represented, but to the same extent the less is the model
transferable to new data. This relationship is illustrated in Fig. 8.27. Decision trees
of various sizes were trained against the appendicitis data. In the graph, classiﬁ-
cation errors on both the training data and on the test data are given. The error rate
on the training data decreases monotonically with the size of the tree. Up to a tree
size of 55 nodes, the error rate on test data also decreases. If the tree grows further,
however, then the error rate starts to increase again! This effect, which we have
already seen in the nearest neighbor method, is called overﬁtting.
Fig. 8.27 Learning curve of
C4.5 on the appendicitis data.
We clearly see the overﬁtting
of trees with more than 55
nodes
8.4
Decision Tree Learning
211

We will give this concept, which is important for nearly all learning processes,
a general deﬁnition taken from [Mit97]:
Deﬁnition 8.7 Let a speciﬁc learning algorithm, that is, a learning agent, be
given. We call an agent A overﬁt to the training data if there is another agent
A′ whose error on the training data is larger than that of A, but whose error on
the whole distribution of data is smaller than the error of A.
How can we now ﬁnd this point of minimum error on the test data? The most
obvious algorithm is called cross-validation. During construction of the tree, the
error on the test data is measured in parallel. As soon as the error rises signiﬁcantly,
the tree with the minimum error is saved. This algorithm is used by the CART
system mentioned earlier.
C4.5 works somewhat differently. First, using the algorithm GENERATEDECI-
SIONTREE from Fig. 8.26 on page 207, it generates a tree which is usually overﬁt.
Then, using pruning, it attempts to cut away nodes of the tree until the error on the
test data, estimated by the error on the training data, begins to rise.8 Like the con-
struction of the tree, this is also a greedy algorithm. This means that once a node is
pruned, it cannot be re-inserted, even if this later turns out to be better.
8.4.8
Missing Values
Frequently individual attribute values are missing from the training data. In the
LEXMED dataset, the following entry occurs:
56; 1; 1; 1; 1; 1; 0; 1; 1; 1; 0; 390; ?; 14100; 0; 1;
in which one of the fever values is missing. Such data can nevertheless be used
during construction of the decision tree. We can assign the attribute the most
frequent value from the whole dataset or the most frequent of all data points from
the same class. It is even better to substitute the probability distribution of all
attribute values for the missing attribute value and to split the training example into
branches according to this distribution. This is incidentally a reason for the
occurrence of non-integer values in the expressions in parentheses next to the leaf
nodes of the C4.5 tree.
Missing values can occur not only during learning, but also during classiﬁcation.
These are handled in the same way as during learning.
8It would be better to use the error on the test data directly. At least when the amount of training
data is sufﬁcient to justify a separate testing set.
212
8
Machine Learning and Data Mining

8.4.9
Summary
Learning of decision trees is a favorite approach to classiﬁcation tasks. The reasons
for this are its simple application and speed. On a dataset of about 10 000 LEXMED
data points with 15 attributes each, C4.5 requires about 0.3 s for learning. This is
very fast compared to other learning algorithms.
For the user it is also important, however, that the decision tree as a learned
model can be understood and potentially changed. It is also not difﬁcult to auto-
matically transform a decision tree into a series of if-then-else statements and thus
efﬁciently build it into an existing program.
Because a greedy algorithm is used for construction of the tree as well as during
pruning, the trees are in general suboptimal. The discovered decision tree does usually
have a relatively small error rate. However, there is potentially a better tree, because the
heuristic greedy search of C4.5 prefers small trees and attributes with high information
gain at the top of the tree. For attributes with many values, the presented formula for the
information gain shows weaknesses. Alternatives to this are given in [Mit97].
8.5
Cross-Validation and Overfitting
As discussed in Sect. 8.4.7, many learning algorithms have the problem of over-
ﬁtting. Powerful learning algorithms, such as for example decision tree learning,
can adapt the complexity of the learned model to the complexity of the training
data. This leads to overﬁtting if there is noise in the data.
With cross-validation one attempts to optimize the model complexity such that it
minimizes the classiﬁcation or approximation error on an unknown test data set.
This requires the model complexity to be controllable by a parameter c. For
decision trees this is, for example, the size of the tree. For the k nearest neighbor
method from Sect. 8.3, the parameter is k, the number of nearest neighbors, while
for neural networks it is the number of hidden neurons (see Chap. 9).
We vary a parameter c while training the algorithm on a training data set and
choose the value of c that minimizes the error on an independent testing data set.
k-ary cross-validation works according to the following schema:
CrossValidation(X , k)
Partition data into k equally sized blocks X = X 1 ∪. . . ∪X k
For all γ ∈{γmin, . . . , γmax}
For all i ∈{1, . . . , k}
Train a model of complexity γ on X \X i
Compute the error E(γ, X i) on the test set X i
Compute the mean error E(γ) = 1
k
k
i=1 E(γ, X i)
Choose the value γopt = argminγ E(γ) with smallest mean error
Train the ﬁnal model with complexity γopt on the whole data set X
8.4
Decision Tree Learning
213

The whole data set X is divided into k equally sized blocks. Then the algorithm is
trained k times on k  1 blocks and tested on the remaining block. The k computed
errors are averaged and the value copt with the smallest mean error is chosen to train
the ﬁnal model on the whole data set X.
If the training set X is large, it may be divided, for example, into k ¼ 3 or k ¼ 10
blocks. The resulting increase in computational complexity is usually acceptable.
For small training sets, it is preferable to train on all n feature vectors if possible.
Then one can choose k ¼ n, which yields what is called leave-one-out
cross-validation.
Cross-validation is the most important and most used automatic optimiza-
tion
method
for
model
complexity.
It
solves
the
overﬁtting
problem.
We can gain additional insight into this problem from short look at the so called
bias
variance
tradeoff.
If
an
overly
simple
model
is
used,
this
forces
the non-optimal approximation of the data in a certain direction (bias). On the
other hand, if an overly complex model is used, it will tend to overﬁt any data
set. Thus, for a new data sample from the same distribution, it may learn a very
different model. The model therefore varies greatly for a change in the data
(variance).
This relationship can be illustrated by the example of function approximation
using polynomials. If one chooses the degree of the polymonial as the complexity
parameter c, degree 1 approximates a line, which is not a good approximation for
non-trivial data. If, on the other hand, the polynomial degree equals n  1 for
n points, it tends to hit every point and reduce the error on the training data to zero.
This can be seen in Fig. 8.28 left on page 215, in which eight data points have been
generated using
yðxÞ ¼ sinðxÞ þ gð0; 0:2Þ;
where g(0, 0.2) generates normally distributed noise with zero mean and a standard
deviation of 0.2.
In the left image, in addition to the data points, the underlying sine function
(black) is inscribed, as well as a straight line (red) approximated using the method
of least squares (see Sect. 9.4 oder [Ert15]). In addition, a seventh degree poly-
nomial (green) is interpolated through the points, hitting each point, as well as a
fourth degree polynomial (blue), which comes closest to the sine curve. In the right
image, the same approximations were carried out again on eight new data points.
One can see very nicely that despite differing data, both straight lines deviate
greatly from the data (large bias), but have a similar function graph (very small
variance). Both seventh degree polynomials, on the other hand, ﬁt the data perfectly
(zero bias), but they have very different function graphs (very large variance). This
is an obvious overﬁtting effect. The fourth degree polynomial presents a good
compromise. Cross-validation would presumably yield degree four as the optimal
solution.
214
8
Machine Learning and Data Mining

8.6
Learning of Bayesian Networks
In Sect. 7.4, it was shown how to build a Bayesian network manually. Now we
will introduce algorithms for the induction of Bayesian networks. Similar to the
learning process described previously, a Bayesian network is automatically gen-
erated from a ﬁle containing training data. This process is typically decomposed
into two parts.
1. Learning the network structure: For given variables, the network topology is
generated from the training data. This ﬁrst step is by far the more difﬁcult one
and will be given closer attention later.
2. Learning the conditional probabilities: For known network topologies, the CPTs
must be ﬁlled with values. If enough training data is available, all necessary
conditional probabilities can be estimated by counting the frequencies in the data.
This step can be automated relatively easily.
We will now explain how Bayesian networks learn using a simple algorithm
from [Jen01].
8.6.1
Learning the Network Structure
During the development of a Bayesian network (see Sect. 7.4.6), the causal
dependency of the variables must be taken into account in order to obtain a simple
network of good quality. The human developer relies on background knowledge,
which is unavailable to the machine. Therefore, this procedure cannot be easily
automated.
Finding an optimal structure for a Bayesian network can be formulated as a
classic search problem. Let a set of variables V1, … , Vn and a ﬁle with training data
-1.5
-1
-0.5
0
0.5
1
1.5
0
1
2
3
4
5
6
7
-1.5
-1
-0.5
0
0.5
1
1.5
0
1
2
3
4
5
6
7
Fig. 8.28 Two different data sets approximated by polynomials of degree 1, 4 and 7. The bias
variance tradeoff is clearly visible
8.6
Learning of Bayesian Networks
215

be given. We are looking for a set of directed edges without cycles between the
nodes V1, … , Vn, that is, a directed acyclic graph (DAG) which reproduces the
underlying data as well as possible.
First we observe the search space. The number of different DAGs grows more
than exponentially with the number of nodes. For ﬁve nodes there are 29281 and
for nine nodes about 1015 different DAGs [MDBM00]. Thus an uninformed
combinatorial search (see Sect. 6.2) in the space of all graphs with a given set of
variables is hopeless if the number of variables grows. Therefore heuristic algo-
rithms must be used. This poses the question of an evaluation function for
Bayesian networks. It is possible to measure the classiﬁcation error of a network
during application to a set of test data, as is done, for example, in C4.5 (see
Sect. 8.4). For this, however, the probabilities calculated by the Bayesian network
must be mapped to a decision.
A direct measurement of the quality of a network can be taken over the prob-
ability distribution. We assume that, before the construction of the network from the
data, we could determine (estimate) the distribution. Then we begin the search in
the space of all DAGs, estimate the value of the CPTs for each DAG (that is, for
each Bayesian network) using the data, and from that we calculate the distribution
and compare it to the distribution known from the data. For the comparison of
distributions we will obviously need a distance metric.
Let us consider the weather prediction example from Exercise 7.3 on page 172
with the three variables Sky, Bar, Prec, and the distribution
PðSky; Bar; PrecÞ ¼ ð0:40; 0:07; 0:08; 0:10; 0:09; 0:11; 0:03; 0:12Þ:
In Fig. 8.29 on page 217 two Bayesian networks are presented, which we will now
compare with respect to their quality. Each of these networks makes an assumption
of independence, which is validated in that we determine the distribution of the
network and then compare this with the original distribution (see Exercise 8.16 on
page 241).
Because, for constant predetermined variables, the distribution is clearly repre-
sented by a vector of constant length, we can calculate the Euclidian norm of the
difference of the two vectors as a distance between distributions. We deﬁne
dqðx; yÞ ¼
X
i
ðxi  yiÞ2
as the sum of the squares of the distances of the vector components and calculate
the distance dq (Pa, P) ¼ 0.0029 of the distribution Pa of network 1 from the
original distribution. For network 2 we calculate dq (Pb, P) ¼ 0.014. Clearly
network 1 is a better approximation of the distribution. Often, instead of the square
distance, the so-called Kullback–Leibler distance
dkðx; yÞ ¼
X
i
yiðlog2 yi  log2 xiÞ;
216
8
Machine Learning and Data Mining

an information theory metric, is used. With it we calculate dk (Pa, P) ¼ 0.017 and
dk (Pb, P) ¼ 0.09 and come to the same conclusion as before. It is to be expected
that networks with many edges approximate the distribution better than those with
few edges. If all edges in the network are constructed, then it becomes very con-
fusing and creates the risk of overﬁtting, as is the case in many other learning
algorithms. To avoid overﬁtting, we give small networks a larger weight using a
heuristic evaluation function
fðNÞ ¼ SizeðNÞ þ w  dkðPN; PÞ:
Here Size(N) is the number of entries in the CPTs and PN is the distribution of
network N. w is a weight factor, which must be manually ﬁt.
The learning algorithm for Bayesian networks thus calculates the heuristic
evaluation f(N) for many different networks and then chooses the network with the
smallest value. As previously mentioned, the difﬁculty consists of the reduction of
the search space for the network topology we are searching for. As a simple
algorithm it is possible, starting from a (for example causal) ordering of the vari-
ables V1, … , Vn, to include in the graph only those edges for which i < j. We start
with the maximal model which fulﬁlls this condition. This network is shown in
Fig. 8.30 for ﬁve ordered variables.
Now, for example in the spirit of a greedy search (compare Sect. 6.3.1), one
edge after another is removed until the value f no longer decreases.
This algorithm is not practical for larger networks in this form. The large search
space, the manual tuning of the weight w, and the necessary comparison with a goal
distribution P are reasons for this, because these can simply become too large, or
the available dataset could be too small.
In fact, research into learning of Bayesian networks is still in full swing, and
there is a large number of suggested algorithms, for example the EM algorithm (see
Sect. 8.9.2), Markov chain Monte Carlo methods, and Gibbs sampling [DHS01,
Jor99, Jen01, HTF09]. Besides batch learning, which has been presented here, in
which the network is generated once from the whole dataset, there are also incre-
mental algorithms, in which each individual new case is used to improve the
Fig. 8.29 Two Bayesian networks for modeling the weather prediction example from
Exercise 7.3 on page 172
Fig. 8.30 The maximal
network with ﬁve variables
and edges (Vi, Vj) which fulﬁll
the condition i < j
8.6
Learning of Bayesian Networks
217

network. Implementations of these algorithms also exist, such as Hugin (www.
hugin.com) and Bayesware (www.bayesware.com).
8.7
The Naive Bayes Classifier
In Fig. 7.14 on page 166 the diagnosis of appendicitis was modeled as a Bayesian
network. Because directed edges start at a diagnosis node and none end there, Bayes’
formula must be used to answer a diagnosis query. For the symptoms S1, … , Sn and
the k-value diagnosis D with the values b1, … , bk we calculate the probability
PðDjS1; . . .; SnÞ ¼ PðS1; . . .; SnjDÞ  PðDÞ
PðS1; . . .; SnÞ
;
for the diagnosis given the patient’s symptoms. In the worst case, that is, if there
were no independent variables, all combinations of all symptoms and D would need
to be determined for all 20 643 840 probabilities of the distribution P(S1,…, Sn, D).
This would require an enormous database. In the case of LEXMED’s Bayesian net-
work, the number of necessary values (in the CPTs) is reduced to 521. The network
can be further simpliﬁed, however, in that we assume all symptom variables are
conditionally independent given D, that is:
PðS1; . . . ; SnjDÞ ¼ PðS1jDÞ      PðSnjDÞ:
The Bayesian network for appendicitis is then simpliﬁed to the star shown in
Fig. 8.31 on page 219.
Thus we obtain the formula
PðDjS1; . . .; SnÞ ¼ PðDÞ Qn
i¼1 PðSijDÞ
PðS1; . . .; SnÞ
:
ð8:8Þ
The computed probabilities are transformed into a decision by a simple naive Bayes
classiﬁer, which chooses the maximum P(D ¼ di |S1,…, Sn) from all values di
in D. That is, it determines
dNaiveBayes ¼ argmaxi2f1;...;kgP ðD ¼ dijS1; . . . ; SnÞ:
Because the denominator in (8.8) is constant, it can be omitted during maximiza-
tion, which results in the naive Bayes formula
dNaiveBayes ¼ argmaxi2f1;...;kgPðD ¼ diÞ
Y
n
j¼1
PðSjjDÞ:
218
8
Machine Learning and Data Mining

Because several nodes now have less ancestors, the number of values necessary to
describe the LEXMED distribution in the CPTs decreases, according to (7.24) on
page 165, to
6  4 þ 5  4 þ 2  4 þ 9  4 þ 3  4 þ 10  ð1  4Þ þ 3 ¼ 143:
For a medical diagnostic system like LEXMED this simpliﬁcation would not be
acceptable. But for tasks with many independent variables, naive Bayes is partly or
even very well suited, as we will see in the text classiﬁcation example.
By the way, naive Bayes classiﬁcation is equally expressive as the linear score
system described in Sect. 7.3.1 (see Exercise 8.17 on page 242). That is, all scores
share the underlying assumption that all symptoms are conditionally independent
given the diagnosis. Nevertheless, scores are still used in medicine today. Despite the
fact that it was generated from a better, representative database, the Ohmann score
compared with LEXMED in Fig. 7.10 on page 156 has a worse quality of diagnosis. Its
limited expressiveness is certainly a reason for this. For example, as with naive
Bayes, it is not possible to model dependencies between symptoms using scores.
Fig. 8.31 Bayesian network
for the LEXMED application
with the assumption that all
symptoms are conditionally
independent given the
diagnosis
8.7
The Naive Bayes Classifier
219

Estimation of Probabilities If we observe the naive Bayes formula in (8.8) on page
218, we see that the whole expression becomes zero as soon as one of the factors
P(Si |D) on the right side becomes zero. Theoretically there is nothing wrong here. In
practice, however, this can lead to very uncomfortable effects if the P(Si |D) are small,
because these are estimated by counting frequencies and substituting them into
PðSi ¼ x j D ¼ yÞ ¼ jSi ¼ x ^ D ¼ yj
jD ¼ yj
:
Assume that for the variables Si: P(Si ¼ x | D ¼ y) ¼ 0.01 and that there are 40
training cases with D ¼ y. Then with high probability there is no training case with
Si ¼ x and D ¼ y, and we estimate P(Si ¼ x | D ¼ y) ¼ 0. For a different value D ¼
z, assume that the relationships are similarly situated, but the estimate results in
values greater than zero for all P(Si ¼ x | D ¼ z). Thus the value D ¼ z is always
preferred, which does not reﬂect the actual probability distribution. Therefore, when
estimating probabilities, the formula
PðAjBÞ  jA ^ Bj
jBj
¼ nAB
nB
is replaced by
PðAjBÞ  nAB þ mp
nB þ m ;
where p ¼ P(A) is the a priori probability for A, and m is a constant which can be
freely chosen and is known as the “equivalent data size”. The larger m becomes, the
larger the weight of the a priori probability compared to the value determined from
the measured frequency.
8.7.1
Text Classification with Naive Bayes
Naive Bayes is very successful and proliﬁc today in text classiﬁcation. Its primary,
and at the same time very important, application is the automatic ﬁltering of email
into desired and undesired, or spam emails. In spam ﬁlters such as SpamAssassin
[Sch04], among other methods a naive Bayes classiﬁer is used that learns to sep-
arate desired emails from spam. SpamAssassin is a hybrid system which performs
an initial ﬁltering using black and white lists. Black lists are lists of blocked email
addresses from spam senders whose emails are always deleted, and white lists are
those with senders whose emails are always delivered. After this preﬁltering, the
remaining emails are classiﬁed by the naive Bayes classiﬁer according to their
actual content, in other words, according to the text. The detected class value is then
evaluated by a score, together with other attributes from the header of the email
such as the sender’s domain, the MIME type, etc., and then ﬁnally ﬁltered.
220
8
Machine Learning and Data Mining

Here the learning capability of the naive Bayes ﬁlter is quite important. For this
the user must at ﬁrst manually classify a large number of emails as desired or spam.
Then the ﬁlter is trained. To stay up to date, the ﬁlter must be regularly retrained.
For this the user should correctly classify all emails which were falsely classiﬁed by
the ﬁlter, that is, put them in the appropriate folders. The ﬁlter is then continually
retrained with these emails.
Beside spam ﬁltering, there are many other applications for automatic text
classiﬁcation. Important applications include ﬁltering of undesired entries in
Internet discussion forums, and tracking websites with criminal content such as
militant or terrorist activities, child pornography or racism. It can also be used to
customize search engines to ﬁt the user’s preferences in order to better classify the
search results. In the industrial and scientiﬁc setting, company-wide search in
databases or in the literature is in the foreground of research. Through its learning
ability, a ﬁlter can adapt to the habits and wishes of each individual user.
We will introduce the application of naive Bayes to text analysis on a short
example text by Alan Turing from [Tur50]:
“We may hope that machines will eventually compete with men in all purely intellectual
ﬁelds. But which are the best ones to start with? Even this is a difﬁcult decision. Many
people think that a very abstract activity, like the playing of chess, would be best. It can also
be maintained that it is best to provide the machine with the best sense organs that money
can buy, and then teach it to understand and speak English. This process could follow the
normal teaching of a child. Things would be pointed out and named, etc. Again I do not
know what the right answer is, but I think both approaches should be tried.”
Suppose that texts such as the one given should be divided into two classes: “I”
for interesting and “¬I for uninteresting. Suppose also that a database exists of texts
which are already classiﬁed. Which attributes should be used? In a classical
approach to the construction of a Bayesian network, we deﬁne a set of attributes
such as the length of the text, the average sentence length, the relative frequency of
speciﬁc punctuation marks, the frequency of several important words such as “I”,
“machines”, etc. During classiﬁcation using naive Bayes, in contrast, a surprisingly
primitive algorithm is selected. For each of the n word positions in the text, an
attribute si is deﬁned. All words which occur in the text are allowed as possible
values for all positions si. Now for the classes I and ¬I the values
PðIjs1; . . .; snÞ ¼ c  PðIÞ
Y
n
i¼1
PðsijIÞ
ð8:9Þ
and P(¬I|s1,…, sn) must be calculated and then the class with the maximum value
selected. In the above example with a total of 113 words, this yields
PðIjs1; . . .; snÞ
¼ c  PðIÞ  Pðs1 ¼ “We”jIÞ  Pðs2 ¼ “may”jIÞ. . .. . Pðs113 ¼ “tried”jIÞ
8.7
The Naive Bayes Classifier
221

and
Pð:Ijs1; . . .; snÞ
¼ c  ðP:Þ  Pðs1 ¼ “We”j:IÞ
 Pðs2 ¼ “may”j:IÞ      Pðs113 ¼ “tried”j:IÞ:
The learning here is quite simple. The conditional probabilities P(si | I), P(si | ¬I)
and the a priori probabilities P(I), P(¬I) must simply be calculated. We now addi-
tionally assume that the P(si | I) are not dependent on position in the text. This means,
for example, that
Pðs61 ¼ “and”jIÞ ¼ Pðs69 ¼ “and”jIÞ ¼ Pðs86 ¼ “and”jIÞ:
We could thus use the expression P(and|I), with the new binary variable and, as the
probability of the occurrence of “and” at an arbitrary position.
The implementation can be accelerated somewhat if we ﬁnd the frequency ni of
every word wi which occurs in the text and use the formula
PðIjs1; . . .; snÞ ¼ c  PðIÞ
Y
l
i¼1
PðwijIÞni
ð8:10Þ
which is equivalent to (8.9) on page 221. Please note that the index i in the product
only goes to the number l of different words which occur in the text.
Despite its simplicity, naive Bayes delivers excellent results for text classiﬁca-
tion. Spam ﬁlters which work with naive Bayes achieve error rates of well under
one percent. The systems DSPAM and CRM114 can even be so well trained that
they only incorrectly classify one in 7000 or 8000 emails respectively. This cor-
responds to a correctness of nearly 99.99%.
8.8
One-Class Learning
Classiﬁcation tasks in supervised learning require all training data to be given class
labels. However, there are applications for which only one class of labels is avail-
able. A classic example is detecting errors in complex technical systems. The task is
to recognize whether a device is defective or not. This sounds like an ordinary
two-class problem. In the training data, the state of the device (good or defective)
must be provided manually. In practice, the classiﬁer training happens during
deployment of the device or later on demand while it is being used in production.
Data capture in the error-free condition is not a problem. Collection of data from the
defective system however is problematic due to the following reasons:
• Measurement on production equipment that has intentionally been made
defective is associated with high costs because the measurement leads to
expensive downtime.
222
8
Machine Learning and Data Mining

• Measurement using defective equipment with errors that actually occur in
practice is often impossible because, during the deployment of the equipment,
the later occurring potential errors may be unknown.
• No engineer knows in advance exactly which kind of errors will occur in a new
piece of equipment. If now, during training, measurements with a few types of
errors are taken, this may lead to poor classiﬁcation results. If the errors used for
training are not representative for the device, i.e. if some types of errors are
missing in the training data, then the learned class-separating hypersurface in the
feature space will often lead to false-positive classiﬁcations.
In such cases, it is not possible to train a two-class classiﬁer in the standard way.
Instead, one can use one-class learning, which gets by with data from one class
during training.
Assume that there is no negative data are available. Positive data, i.e. data from
error-free operation, however, are available in sufﬁcient amount. Thus a learning
algorithm is needed which can, based on the error-free data, capture all error-free
operational states of the device and classify all others as negative.
For this purpose, there are a number of different algorithms known as one-class
learning algorithms [Tax01], such as nearest neighbor data description (NNDD),
support vector data description (SVDD, see also Sect. 9.6), etc. In statistics, these
and related algorithms fall under the category of outlier detection.
One of the best known algorithms today is the local outlier factor (LOF,
[BKNS00]), which calculates an outlier score for a point that is to be classiﬁed
based on its density estimate. For large data sets with millions of points, and for
high-dimensional data points with thousands of dimensions, the algorithms dis-
cussed so far are not suitable. The EXPoSE algorithm presented in [SEP16] has a
failure rate about as low as that of LOF, but it is suitable for large high-dimensional
data sets due to its constant computation time. With the simple example of NNDD
we will now brieﬂy introduce the one-class learning principle.
8.8.1
Nearest Neighbor Data Description
Similar to the nearest neighbor method from Sect. 8.3, the nearest neighbor data
description algorithm belongs to the category of lazy learning algorithms. During
learning, the only things that happen are normalization and storage of the feature
vectors. Thus the qualiﬁer “lazy” learning. Normalization of each individual feature
is necessary in order to give each feature the same weight. Without normalization, a
feature in the range ½0; 104
 would be lost in the noise of another feature in the
range ½10000; þ 10000
. Thus all features are linearly scaled onto the interval
[0, 1].9 The actual nearest neighbor algorithm ﬁrst comes into play during
classiﬁcation.
9Feature scaling is necessary or advantageous for many machine learning algorithms.
8.8
One-Class Learning
223

Let X ¼ ðx1; . . .; xnÞ be a training set consiting of n feature vectors. A new point
q, which is yet to be classiﬁed, is accepted if
Dðq; NNðqÞÞ  cD;
ð8:11Þ
that is, if the distance to a nearest neighbor is no larger than cD. Here Dðx; yÞ is a
distance metric, for example, as used here, the Euclidean distance. The function
NNðqÞ ¼ argmin
x2X
fDðq; xÞg
returns a nearest neighbor of q and
D ¼ 1
n
X
n
i¼1
Dðxi; NNðxiÞÞ
is the mean distance of the nearest neighbors to all data points in X. To calculate D
the distance of each point to its nearest neighbor is calculated. D is then the
arithmetic mean of these calculated distances. One could use c ¼ 1 in Eq. 8.11, but
would then obtain suboptimal classiﬁcation results. It is better to determine the
parameter c using cross-validation (Sect. 8.5) such that the NNDD classiﬁer’s error
rate is as small as possible.
The NNDD algorithm used here is a modiﬁcation of the NNDDT algorithm used
in [Tax01], in which a point q is accepted if the distance to its nearest neighbor in
the training data is no larger than the distance of the discovered nearest neighbor to
its own nearest neighbor in the training data. Formally this reads
Dðq; NNðqÞÞ  DðNNðqÞ; NNðNNðqÞÞÞ:
ð8:12Þ
This formula has several disadvantages compared to Inequality 8.5. First, the use of
NNDDT (Inequality 8.12) results in intuitively ugly lines of class separation, as shown
in Fig. 8.32 right on page 225 in a simple two-dimensional example. In the center of
Fig. 8.32 on page 225 we can see that the bottom left data point deﬁnes a large area of
inﬂuence, despite or directly because of the fact that it is far from all other data points.
NNDD with Eq. 8.5 on page 201 on the other hand yields the circular class partitions
of a constant radius shown in Fig. 8.32 left on page 225. This intuitive conjecture is
conﬁrmed by practical experiments.
8.9
Clustering
If we search in a search engine for the term “mars”, we will get results like “the
planet mars” and “Chocolate, confectionery and beverage conglomerate” which are
semantically quite different. In the set of discovered documents there are two
224
8
Machine Learning and Data Mining

noticeably different clusters. Google, for example, still lists the results in an
unstructured way. It would be better if the search engine separated the clusters and
presented them to the user accordingly because the user is usually interested in only
one of the clusters.
The distinction of clustering in contrast to supervised learning is that the training
data are unlabeled. Thus the pre-structuring of the data by the supervisor is missing.
Rather, ﬁnding structures is the whole point of clustering. In the space of training
data, accumulations of data such as those in Fig. 8.33 are to be found. In a cluster,
the distance of neighboring points is typically smaller than the distance between
points of different clusters. Therefore the choice of a suitable distance metric for
points, that is, for objects to be grouped and for clusters, is of fundamental
importance. As before, we assume in the following that every data object is
described by a vector of numerical attributes.
8.9.1
Distance Metrics
Accordingly for each application, the various distance metrics are deﬁned for the
distance d between two vectors x and y in ℝn. The most common is the Euclidean
distance
NNDD with γ = 0.5
NNDDT with γ = 0.5
NNDDT with γ = 1.0
Fig. 8.32 NNDD and NNDDT applied to a set of 16 selected two-dimensional data points (black
points). In each case, class membership has been determined for 10,000 randomly selected points.
The points marked in red were classiﬁed as positive, i.e. assigned the training set’s class, while the
blue points are classiﬁed as negative
Fig. 8.33 Simple
two-dimensional example
with four clearly separated
clusters
8.9
Clustering
225

deðx; yÞ ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
X
n
i¼1
ðxi  yiÞ2
s
:
Somewhat simpler is the sum of squared distances
dqðx; yÞ ¼
X
n
i¼1
ðxi  yiÞ2;
which, for algorithms in which only distances are compared, is equivalent to the
Euclidean distance (Exercise 8.20 on page 242). Also used are the aforementioned
Manhattan distance
dmðx; yÞ ¼
X
n
i¼1
jxi  yij
as well as the distance of the maximum component
d1ðx; yÞ ¼ max
i¼1;...;n jxi  yij
which is based on the maximum norm. During text classiﬁcation, the normalized
projection of the two vectors on each other, that is, the normalized scalar product
x y
jxj jyj
is frequently calculated, where | x | is the Euclidian norm of x. Because this formula
is a metric for the similarity of the two vectors, as a distance metric the inverse
dsðx; yÞ ¼ jxj jyj
x y
can be used, or “>” and “<” can be swapped for all comparisons. In the search for a
text, the attributes x1,…, xn are calculated similarly to naive Bayes as components
of the vector x as follows. For a dictionary with 50,000 words, the value xi equals
the frequency of the ith dictionary word in the text. Since normally almost all
components are zero in such a vector, during the calculation of the scalar product,
nearly all terms of the summation are zero. By exploiting this kind of information,
the implementation can be sped up signiﬁcantly (Exercise 8.21 on page 243).
8.9.2
k-Means and the EM Algorithm
Whenever the number of clusters is already known in advance, the k-means
algorithm can be used. As its name suggests, k clusters are deﬁned by their average
226
8
Machine Learning and Data Mining

value. First the k cluster midpoints l1,…,lk are initialized to the coordinates of
k randomly or manually selected data points. (Note: Selection of arbitrary points
(which are not data points) as cluster centers may lead to empty clusters.) Then the
following two steps are repeatedly carried out:
• Classiﬁcation of all data to their nearest cluster midpoint
• Recomputation of the cluster midpoint.
The following scheme results as an algorithm:
K-MEANS(x1,...,xn,k)
initialize cluster centers
Repeat
classify x1,...,xn to each’s nearest µi
recalculate µ1,...,µk
Until no change in µ1,...,µk
Return(µ1,...,µk)
x 1
=
,...,
i
x
=
i
µ1
µk
k (e.g. randomly)
The calculation of the cluster midpoint l for points x1, … , xl is done by
l ¼ 1
l
X
l
i¼1
xi:
The execution on an example is shown in Fig. 8.34 for the case of two classes.
We see how after three iterations, the class centers, which were ﬁrst randomly
chosen, stabilize. While this algorithm does not guarantee convergence, it usually
converges very quickly. This means that the number of iteration steps is typically
much smaller than the number of data points. Its complexity is O(ndkt), where n is
Fig. 8.34 k-means with two classes (k = 2) applied to 30 data points. Far left is the dataset with
the initial centers, and to the right is the cluster after each iteration. After three iterations
convergence is reached
8.9
Clustering
227

the total number of points, d the dimensionality of the feature space, and t the
number of iteration steps.
In many cases, the necessity of giving the number of classes in advance poses an
inconvenient limitation. Therefore we will next introduce an algorithm which is
more ﬂexible.
Before that, however, we will mention the EM algorithm, which is a continuous
variant of k-means, for it does not make a ﬁrm assignment of the data to classes,
rather, for each point it returns the probability of it belonging to the various classes.
Here we must assume that the type of probability distribution is known. Often the
normal distribution is used. The task of the EM algorithm is to determine the
parameters (mean li and covariance matrix Ri of the k multi-dimensional normal
distributions) for each cluster. Similarly to k-means, the two following steps are
repeatedly executed:
Expectation: For each data point the probability P(Cj | xi) that it belongs to each
cluster is calculated.
Maximization: Using the newly calculated probabilities, the parameters of the
distribution are recalculated.
Thereby a softer clustering is achieved, which in many cases leads to better results.
This alternation between expectation and maximization gives the algorithm its
name. In addition to clustering, for example, the EM algorithm is used to learn
Bayesian networks [DHS01].
8.9.3
Hierarchical Clustering
In hierarchical clustering we begin with n clusters consisting of one point each.
Then the nearest neighbor clusters are combined until all points have been com-
bined into a single cluster, or until a termination criterion has been reached. We
obtain the scheme
HIERARCHICALCLUSTERING(x1,...,xn,k)
initialize C1 = {x1},...,Cn = {xn}
Repeat
Find two clusters Ci and Cj with the smallest distance
Combine Ci and Cj
Until Termination condition reached
Return(tree with clusters)
The termination condition could be chosen as, for example, a desired number of
clusters or a maximum distance between clusters. In Fig. 8.35 on page 229 this
algorithm is represented schematically as a binary tree, in which from bottom to top
228
8
Machine Learning and Data Mining

in each step, that is, at each level, two subtrees are connected. At the top level all
points are uniﬁed into one large cluster.
It is so far unclear how the distances between the clusters are calculated. Indeed,
in the previous section we deﬁned various distance metrics for points, but these
cannot be used on clusters. A convenient and often used metric is the distance
between the two closest points in the two clusters Ci and Cj:
dminðCi; CjÞ ¼
min
x2Ci; y2Cj dðx; yÞ:
Thus we obtain the nearest neighbor algorithm, whose application is shown in
Fig. 8.36.10 We see that this algorithm generates a minimum spanning tree.11 The
example furthermore shows that the two described algorithms generate quite different
clusters. This tells us that for graphs with clusters which are not clearly separated, the
result depends heavily on the algorithm or the chosen distance metric.
For an efﬁcient implementation of this algorithm, we ﬁrst create an adjacency
matrix in which the distances between all points is saved, which requires O(n2) time
Fig. 8.35 In hierarchical clustering, the two clusters with the smallest distance are combined in
each step
Fig. 8.36 The nearest neighbor algorithm applied to the data from Fig. 8.34 on page 227 at
different levels with 12, 6, 3, 1 clusters
10The nearest neighbor algorithm is not to be confused with the nearest neighbor method for
classiﬁcation from Sect. 8.3.
11A minimum spanning tree is an acyclic, undirected graph with the minimum sum of edge
lengths.
8.9
Clustering
229

and memory. If the number of clusters does not have an upper limit, the loop will
iterate n −1 times and the asymptotic computation time becomes O(n3).
To calculate the distance between two clusters, we can also use the distance
between the two farthest points
dmaxðCi; CjÞ ¼
max
x2Ci; y2Cj dðx; yÞ
and obtain the farthest neighbor algorithm. Alternatively, the distance of the cluster’s
midpoint dl (Ci, Cj) = d(li, lj) is used. Besides the clustering algorithm presented
here, there are many others, for which we direct the reader to [DHS01] for further
study.
8.9.4
How is the Number of Clusters Determined?
In all of the clustering algorithms discussed so far, the user must specify the number of
clusters. In many cases, users have no idea what a sensible number of clusters would
be, rather they simply want a “good” partitioning, i.e. separation of their n data points
into clusters. Because there is, unfortunately, no absolute and generally accepted
standard for the quality of a partition, we present a approved heuristic method for
evaluating a clustering using the silhouette width criterion presented in [Rou87].
Before we discuss this criterion, let us ﬁrst show how it can be applied. Assume
that we had a program that could combinatorially enumerate all possible partitions
for a set of n data points. Then we could simply apply the silhouette width criterion
to each partition and use the maximum to determine the best partition. But because
the number of partitions grows quickly with the number of data points, this method
is not practical. We could, however, simply apply one of the presented clustering
algorithms (for example k-means), let it run for k from 1 to n, and then use the
silhouette width criterion to determine the best k and its respective partition.
What we are still missing is such a criterion that measures the quality of a
partition. The idea, very roughly, is as follows: the mean distance between two
arbitrary points within the same cluster should be smaller than the distance between
two arbitrary points that are in different neighboring clusters. The ratio of the mean
distance between points in neighboring clusters and the mean distance between
points within the cluster should be maximized.
Let the data points ðx1; . . .; xnÞ be given, as well as a clustering function
c : xi 7! cðxiÞ;
which assigns each point to a cluster. Let dði; ‘Þ be the mean distance from xi to all
points (6¼ xi) in cluster ‘. Then aðiÞ ¼ dði; cðxiÞÞ is the mean distance from xi to all
other points in its own cluster. If xi is the only point in the cluster, we set aðiÞ ¼ 0.
bðiÞ ¼ min
j6¼cðxiÞfdði; jÞg
is the smallest mean distance from point xi to a cluster to which xi does not belong.
230
8
Machine Learning and Data Mining

We now deﬁne the function
sðiÞ ¼
0
if aðiÞ ¼ 0
bðiÞ  aðiÞ
maxfaðiÞ; bðiÞg
otherwise
8
<
:
which measures how well the point xi ﬁts into a cluster. Then we have
1  sðiÞ  1 and
sðiÞ ¼
1
if xi is in the middle of a clearly delineated cluster.
0
if xi lies on the border of two clusters.
1 if xi is in the “wrong” cluster.
8
<
:
Reﬂecting the idea formulated above, we now seek a partition that maximizes the
mean
S ¼ 1
n
X
n
i¼1
sðiÞ
of s(i) over all points, called silhouette width criterion. For k-means clustering,
this can be done with the OMRk algorithm presented in [BJCdC14]:
OMRk(x 1, . . . , x n, p, kmax)
S∗= −∞
For k = 2 To kmax
For i=1 To p
Generate a random partition with k clusters (initialization)
Obtain a partition P with k-means
Determine S for P
If S > S∗Then
S∗= S; k∗= k; P ∗= P
Return (k∗, P ∗)
This algorithm repeatedly applies k-means for different values of k. Because the
result of k-means depends heavily on its initialization, for every k, p different
random initializations are tried in the inner loop, and then the function returns the
optimal k and the corresponding best partition P. The OMRk algorithm can also
be used with other clustering algorithms such as the EM algorithm and hierarchical
clustering.
Example 4 The top left diagram in Fig. 8.37 on page 232 shows a set of
two-dimensional data points with four obvious clusters. The OMRk algorithm was
run on this data with p ¼ 30 and kmax ¼ 9. In the following eight diagrams, the
ﬁgure shows the best partition together with its quality S for each k. The algorithm
ﬁnds the maximum value S ¼ 0:786 at k ¼ 5. This does not reﬂect the natural (to
8.9
Clustering
231

the human eye) grouping of the points into four clusters. In the partition found for
k ¼ 4, several points which should belong to the blue cluster are assigned to the red
cluster. This is because k-means minimizes the distance to the cluster center point,
and the points are closer to the center of the red cluster. The higher density of points
in the red cluster is not taken into account.
The EM algorithm, which can approximate the difference in point density by
using a normal distribution, performs signiﬁcantly better. As shown in Fig. 8.38 on
page 233, the EM algorithm ﬁnds almost exactly the same aforementioned natural
distribution for k ¼ 4.
Finally we should reiterate that all of the methods we have described are only
heuristic greedy search algorithms which do not explore the entire space of all
partitions. The silhouette width criterion described is only a heuristic estimation of a
partition’s “quality”. There can be no absolute measure of quality for partitions
because, as we have shown in even such a simple two-dimensional example, dif-
ferent people can in certain cases prefer very different groupings. We should also
mention that there are many other interesting clustering algorithms such as the
density-based DBSCAN algorithm.
Fig. 8.37 Results of the OMRk algorithm for k ¼ 2 to 9. The best value of S ¼ 0:786 was found
with k ¼ 5
232
8
Machine Learning and Data Mining

8.10
Data Mining in Practice
All the learning algorithms presented so far can be used as tools for data mining.
For the user it is, however, sometimes quite troublesome to get used to new soft-
ware tools for each application and furthermore to put the data to be analyzed into
the appropriate format for each particular case.
A number of data mining systems address these problems. Most of these systems
offer a convenient graphical user interface with diverse tools for visualization of the
data, for preprocessing such as manipulation of missing values, and for analysis.
For analysis, the learning algorithms presented here are used, among others.
The comprehensive open-source Java library WEKA deserves a special mention. It
offers a large number of algorithms and simpliﬁes the development of new algorithms.
The freely available system KNIME, which we will brieﬂy introduce in the
following section, offers a convenient user interface and all the types of tools
mentioned above. KNIME also uses WEKA modules. Furthermore it offers a simple
way of controlling the data ﬂow of the chosen visualization, preprocessing, and
analysis tools with a graphical editor. A large number of other systems meanwhile
offer quite similar functionality, such as the open-source project RapidMiner (www.
rapidminer.com), the system Clementine (www.spss.com/clementine) sold by SPSS,
and the KXEN analytic framework (www.kxen.com).
8.10.1
The Data Mining Tool KNIME
Using the LEXMED data, we will now show how to extract knowledge from data using
KNIME (Konstanz Information Miner, www.knime.org). First we generate a deci-
sion tree as shown in Fig. 8.39 on page 234. After creating a new project, a
workﬂow is built graphically. To do this, the appropriate tools are simply taken out
of the node repository with the mouse and dragged into the main workﬂow window.
Fig. 8.38 A partition
generated by the EM
algorithm with k ¼ 4
8.10
Data Mining in Practice
233

The training and test data from the C4.5 ﬁle can be read in with the two ﬁle
reader nodes without any trouble. These nodes can, however, also be quite easily
conﬁgured for other ﬁle formats. The sideways trafﬁc light under the node shows its
status (not ready, conﬁgured, executed). Then node J48 is selected from the WEKA
library [WF01], which contains a Java implementation of C4.5. The conﬁguration
for this is quite simple. Now a predictor node is chosen, which applies the generated
tree to the test data. It inserts a new column into the test data table “Prediction” with
the classiﬁcation generated by the tree. From there the scorer node calculates the
confusion matrix shown in the ﬁgure, which gives the number of correctly classiﬁed
cases for both classes in the diagonal, and additionally the number of false positive
and false negative data points.
Once the ﬂow is completely built and all nodes conﬁgured, then an arbitrary
node can be executed. It automatically ensures that predecessor nodes are executed,
if necessary. The J48 node generates the view of the decision tree, shown in the
right of the ﬁgure. This tree is identical with the one generated by C4.5 in
Sect. 8.4.5, although here the node TRekt<=378 is shown collapsed.
For comparison, a project for learning a multilayer perceptron (see Sect. 9.5) is
shown in Fig. 8.40 on page 235. This works similarly to the previously introduced
Fig. 8.39 The KNIME user interface with two additional views, which show the decision tree
and the confusion matrix
234
8
Machine Learning and Data Mining

linear perceptron, but it can also divide non linearly separable classes. Here the
ﬂow is somewhat more complex. An extra node is needed for error handling
missing values when preprocessing each of the two ﬁles. We set it so that those
lines will be deleted. Because neural networks cannot deal with arbitrary values,
the values of all variables are scaled linearly into the interval [0, 1] using the
“normalizer” node.
After applying the RProp learner, an improvement on backpropagation (see
Sect. 9.5), we can analyze the progression in time of the approximation error in
the learning curve shown. In the confusion matrix, the scorer outputs the analysis
of the test data. The “CSV Writer” node at the bottom right serves to export
the result ﬁles, which can then be used externally to generate the ROC curve
shown in Fig. 7.10 on page 156, for which there is unfortunately no KNIME
tool (yet).
Fig. 8.40 The KNIME user interface with the workﬂow window, the learning curve, and the
confusion matrix
8.10
Data Mining in Practice
235

In summary, we can say the following about KNIME (and similar tools): for
projects with data analysis requirements which are not too exotic, it is worthwhile to
work with such a powerful workbench for analysis of data. The user already saves a
lot of time with the preprocessing stage. There is a large selection of easily usable
“mining tools”, such as nearest neighbor classiﬁers, simple Bayesian network
learning algorithms, as well as the k-means clustering algorithm (Sect. 8.9.2).
Evaluation of the results, for example cross validation, can be easily carried out. It
remains to be mentioned, that besides those shown, there are many other tools for
visualization of the data. Furthermore, the developers of KNIME have made an
extension to KNIME available, with which the user can program his own tools in
Java or Python.
However, it should also be mentioned that the user of this type of data mining
system should bring along solid prior knowledge of machine learning and the use
of data mining techniques. The software alone cannot analyze data, but in the
hand of a specialist it becomes a powerful tool for the extraction of knowledge
from data. For the beginner in the fascinating ﬁeld of machine learning, such a
system offers an ideal and simple opportunity to test one’s knowledge practically
and to compare the various algorithms. The reader may verify this in Exer-
cise 8.22 on page 243.
8.11
Summary
We have thoroughly covered several algorithms from the established ﬁeld of
supervised learning, including decision tree learning, Bayesian networks, and the
nearest neighbor method. These algorithms are stable and efﬁciently usable in
various applications and thus belong to the standard repertoire in AI and data
mining. The same is true for the clustering algorithms, which work without a
“supervisor” and can be found, for example, in search engine applications. Rein-
forcement learning as another ﬁeld of machine learning uses no supervisor either. In
contrast to supervised learning, where the learner receives the correct actions or
answers as the labels in the training data, in reinforcement learning only now and
then positive or negative feedback is received from the environment. In Chap. 10
we will show how this works. Not quite as hard is the task in semi-supervised
learning, a young sub-area of machine learning, where only very few out of a large
number of training data are labeled.
Supervised learning is now a well established area with lots of successful
applications. For supervised learning of data with continuous labels any function
approximation algorithm can be employed. Thus there are many algorithms from
various areas of mathematics and computer science. In Chap. 9 we will introduce
various types of neural networks, least squares algorithms and support vector
machines, which are all function approximators. Nowadays, Gaussian processes are
very popular because they are very universal and easy to apply and provide the user
with an estimate of the uncertainty of the output values [RW06].
236
8
Machine Learning and Data Mining

The following taxonomy gives an overview of the most important learning
algorithms and their classiﬁcation.
Supervised learning
• Lazy learning
– k nearest neighbor method (classiﬁcation + approximation)
– Locally weighted regression (approximation)
– Case-based learning (classiﬁcation + approximation)
• Eager learning
– Decision trees induction (classiﬁcation)
– Learning of Bayesian networks (classiﬁcation + approximation)
– Neural networks (classiﬁcation + approximation)
– Gaussian processes (classiﬁcation + approximation)
– Support vector machines
– Wavelets, splines, radial basis functions, …
Unsupervised learning (clustering)
• Nearest neighbor algorithm
• Farthest neighbor algorithm
• k-means
• Neural networks
Reinforcement learning
• Value iteration
• Q learning
• TD learning
• Policy gradient methods
• Neural networks
What has been said about supervised learning is only true, however, when
working with a ﬁxed set of known attributes. An interesting, still open ﬁeld under
intensive research is automatic feature selection. In Sect. 8.4, for learning with
decision trees, we presented an algorithm for the calculation of the information gain
of attributes that sorts the attributes according to their relevance and uses only those
which improve the quality of the classiﬁcation. With this type of method it is
possible to automatically select the relevant attributes from a potentially large base
set. This base set, however, must be manually selected.
Still open and also not clearly deﬁned is the question of how the machine
can ﬁnd new attributes. Let us imagine a robot which is supposed to pick
apples. For this he must learn to distinguish between ripe and unripe apples and
other objects. Traditionally we would determine certain attributes such as the
color and form of pixel regions and then train a learning algorithm using man-
ually classiﬁed images. It is also possible that for example a neural network
could be trained directly with all pixels of the image as input, which for high
resolution is linked with severe computation time problems, however. Approa-
ches which automatically make suggestions for relevant features would be
desired here.
8.11
Summary
237

Clustering provides one approach to feature selection. Before training the
apple recognition machine, we let clustering run on the data. For (supervised)
learning of the classes apple and non apple, the input is no longer all of the
pixels, rather only the classes found during clustering, potentially together with
other attributes. Clustering at any rate can be used for automatic, creative “dis-
covery” of features. It is, however, uncertain whether the discovered features are
relevant. The relatively young but successful deep learning algorithms, which
combine large, complex neural networks with unsupervised pre-processing, rep-
resent a breakthrough in feature generation, and therefore a milestone in AI. We
will cover this topic in Sect. 9.7.
The following problem is yet more difﬁcult: assume that the video camera used
for apple recognition only transmits black and white images. The task can no longer
be solved well. It would be nice if the machine would be creative on its own
account, for example by suggesting that the camera should be replaced with a color
camera. This would be asking for too much today.
In addition to specialized works about all subﬁelds of machine learning, there are
very good textbooks such as [Mit97, Bis06, DHS01, HTF09, Alp04]. Above all, I
recommend the excellent book by Peter Flach [Fla12], which paves the way to a
deep understanding of the concepts and algorithms of machine learning with very
good explanations and examples. For current research results, a look into the freely
available Journal of Machine Learning Research (http://jmlr.csail.mit.edu), the
Machine Learning Journal, as well as the proceedings of the International Con-
ference on Machine Learning (ICML) is recommended. For every developer of
learning algorithms, the Machine Learning Repository [DNM98] of the University
of California at Irvine (UCI) is interesting, with its large collection of training and
test data for learning algorithms and data mining tools. MLOSS, which stands for
machine learning open source software, is an excellent directory of links to freely
available software (www.mloss.org).
8.12
Exercises
8.12.1
Introduction
Exercise 8.1
(a) Specify the task of an agent which should predict the weather for the next day
given measured values for temperature, air pressure, and humidity. The
weather should be categorized into one of the three classes: sunny, cloudy, and
rainy.
(b) Describe the structure of a ﬁle with the training data for this agent.
Exercise 8.2 Show that the correlation matrix is symmetric and that all diagonal
elements are equal to 1.
238
8
Machine Learning and Data Mining

8.12.2
The Perceptron
Exercise 8.3 Apply the perceptron learning rule to the sets
M þ ¼ fð0; 1:8Þ; ð2; 0:6Þg
and
M ¼ fð1:2; 1:4Þ; ð0:4; 1Þg
from Example 8.2 on page 186 and give the result of the values of the weight
vector.
Exercise 8.4 Given the table to the right with the training data:
(a) Using a graph, show that the data are linearly
separable.
(b) Manually determine the weights w1 and w2, as
well as the threshold H of a perceptron (with
threshold) which correctly classiﬁes the data.
(c) Program the perceptron learning rule and
apply your program to the table. Compare
the discovered weights with the manually
calculated ones.
Exercise 8.5
(a) Give a visual interpretation of the heuristic initialization
w0 ¼
X
xi2M þ
xi 
X
xi2M
xi;
of the weight vector described in Sect. 8.2.2.
(b) Give an example of a linearly separable dataset for which this heuristic does
not produce a dividing line.
8.12.3
Nearest Neighbor Method
Exercise 8.6
(a) Show the Voronoi diagram for neighboring
sets of points.
(b) Then draw in the class division lines.
Exercise 8.7 Let the table with training data from Exercise 8.4 be given. In
the following, use the Manhattan distance d(a, b), deﬁned as d(a, b) ¼ |a1 −b1| +
Num.
x1
x2
Class
1
6
1
0
2
7
3
0
3
8
2
0
4
9
0
0
5
8
4
1
6
8
6
1
7
9
2
1
8
9
5
1
8.12
Exercises
239

|a2 −b2|, to determine the distance d between two data points a ¼ (a1, a2) and b ¼
(b1, b2).
(a) Classify the vector v = (8, 3.5) with the nearest neighbor method.
(b) Classify the vector v = (8, 3.5) with the k nearest neighbor method for
k = 2, 3, 5.
❄Exercise 8.8
(a) Show that in a two-dimensional feature space it is reasonable, as claimed in
(8.3) on page 194, to weight the k nearest neighbors by the inverse of the
squared distance.
(b) Why would a weighting using w0
i ¼
1
1 þ adðx; xiÞ make less sense?
Exercise 8.9
(a) Write a program implementing the k-Nearest-Neighbor-Method for classiﬁcation.
(b) Apply this program for k = 1 (i.e. one nearest neighbor) to the Lexmed-data
from http://www.hs-weingarten.de/*ertel/kibuch/uebungen/. Use for training
the ﬁle app1.data and for testing the ﬁle app1.test. Do not forget to nor-
malize all features before training.
(c) Apply leave-one-out cross-validation on the whole data set app1.data [
app1.test to determine the optimal number of nearest neighbors k and
determine the classiﬁcation error.
(d) Repeat the cross-validation with not normalized data.
(e) Compare your results with those given in Fig. 9.14 on page 266 for the least
squares method and RProp.
8.12.4
Decision Trees
Exercise 8.10 Show
that
the
deﬁnition
0 log2 0
:=
0
is
reasonable,
in
other words, that the function f(x) = x log2 x thereby becomes continuous in the
origin.
Exercise 8.11 Determine the entropy for the following distributions.
(a)
(1, 0, 0, 0, 0)
ðbÞ
1
2 ; 1
2 ; 0; 0; 0


ðcÞ
1
2 ; 1
4 ; 1
4 ; 0; 0


ðdÞ
1
2 ; 1
4 ; 1
8 ; 1
16 ; 1
16


ðeÞ
1
5 ; 1
5 ; 1
5 ; 1
5 ; 1
5


ðfÞ
1
2 ; 1
4 ; 1
8 ; 1
16 ; 1
32 ; . . .


Exercise 8.12
(a) Show that the two different deﬁnitions of entropy from (7.9) on page 138 and
Deﬁnition 8.4 on page 202 only differ by a constant factor, that is, that
240
8
Machine Learning and Data Mining

X
n
i¼1
pi log2 pi ¼ c
X
n
i¼1
pi ln pi
and give the constant c.
(b) Show that for the MaxEnt method and for decision trees it makes no difference
which of the two formulas we use.
Exercise 8.13 Develop a decision tree for the dataset D from Exercise 8.4 on
page 239.
(a) Treat both attributes as discrete.
(b) Now treat attribute x2 as continuous and x1 as discrete.
(c) Have C4.5 generate a tree with both variants. Use -m 1 -t 10 as parameters
in order to get different suggestions.
Exercise 8.14 Given the following decision tree and tables for both training and
test data:
Training data
A
B
C
Class
t
t
f
t
t
f
f
t
t
t
t
f
f
f
t
f
f
f
f
f
f
t
t
t
Test data
A
B
C
Class
t
t
f
t
t
f
f
t
f
t
f
f
f
f
t
f
t
t
t
t
t
(a) Give the correctness of the tree for the training and test data.
(b) Give a propositional logic formula equivalent to the tree.
(c) Carry out pruning on the tree, draw the resulting tree, and give its correctness
for the training and test data.
❄Exercise 8.15
(a) When determining the current attribute, the algorithm for generating decision
trees (Fig. 8.26 on page 207) does not eliminate the attributes which have
already been used further up in the tree. Despite this, a discrete attribute occurs
in a path at most once. Why?
(b) Why can continuous attributes occur multiple times?
8.12.5
Learning of Bayesian Networks
Exercise 8.16 Use the distribution given in Exercise 7.3 on page 172 and deter-
mine the CPTs for the three Bayesian networks:
8.12
Exercises
241

(a)
(b)
(c)
(d) Determine the distribution for the two networks from (a) and (b) and compare
these with the original distribution. Which network is “better”?
(e) Now determine the distribution for network (c). What does occur to you? Justify!
❄❄Exercise 8.17 Show that for binary variables S1, … , Sn and binary class variable
K, a linear score of the form
decision ¼
positive
if w1S1 þ    þ wnSn [ H
negative
else

is equally expressive in relation to the perceptron and to the naive Bayes classiﬁer,
which both decide according to the formula
decision ¼
positive
if PðKjS1; . . .; SnÞ [ 1=2;
negative else

Exercise 8.18 In the implementation of text classiﬁcation with naive Bayes,
exponent underﬂow can happen quickly because the factors P(wi |K) (which appear
in (8.10) on page 222) are typically all very small, which can lead to extremely
small results. How can we mitigate this problem?
➳❄Exercise 8.19 Write a program for naive Bayes text analysis. Then train and test it
on text benchmarks using a tool of your choice. Counting the frequency of words in
the text can be done easily in Linux with the command
cat <datei> | tr -d “[:punct:]” | tr -s “[:space:]” “\n” | sort | uniq -ci
Obtain the Twenty Newsgroups data by Tom Mitchell in the UCI machine
learning benchmark collection (Machine Learning Repository) [DNM98]. There
you will also ﬁnd a reference to a naive Bayes program for text classiﬁcation by
Mitchell.
8.12.6
Clustering
Exercise 8.20 Show that for algorithms which only compare distances, applying a
strictly monotonically increasing function f to the distance makes no difference. In
other words you must show that the distance d1(x, y) and the distance d2(x, y): =
f (d1(x,y)) lead to the same result with respect to the ordering relation.
242
8
Machine Learning and Data Mining

Exercise 8.21 Determine the distances ds (scalar product) of the following texts to
each other.
x1:
We will introduce the application of naive Bayes to text analysis on a short
example text by Alan Turing from [Tur50].
x2:
We may hope that machines will eventually compete with men in all purely
intellectual ﬁelds. But which are the best ones to start with?
x3:
Again I do not know what the right answer is, but I think both approaches
should be tried.
8.12.7
Data Mining
Exercise 8.22 Use KNIME (www.knime.de) and
(a) Load the example ﬁle with the Iris data from the KNIME directory and
experiment with the various data representations, especially with the scatter-
plot diagrams.
(b) First train a decision tree for the three classes, and then train an RProp
network.
(c) Load the appendicitis data on this book’s website. Compare the classiﬁcation
quality of the k nearest neighbor method to that of an RProp network.
Optimize k as well as the number of hidden neurons of the RProp network.
(d) Obtain a dataset of your choice from the UCI data collection for data mining at
http://kdd.ics.uci.edu or for machine learning at http://mlearn.ics.uci.edu/
MLRepository.html and experiment with it.
8.12
Exercises
243

9
Neural Networks
Neural networks are networks of nerve cells in the brains of humans and animals.
The human brain has about 100 billion nerve cells. We humans owe our intelligence
and our ability to learn various motor and intellectual capabilities to the brain’s
complex relays and adaptivity. For many centuries biologists, psychologists, and
doctors have tried to understand how the brain functions. Around 1900 came the
revolutionary realization that these tiny physical building blocks of the brain, the
nerve cells and their connections, are responsible for awareness, associations,
thoughts, consciousness, and the ability to learn.
The ﬁrst big step toward neural networks in AI was made 1943 by McCulloch and
Pittsinanarticleentitled“A logical calculusoftheideasimmanentinnervousactivity”
[AR88]. They were the ﬁrst to present a mathematical model of the neuron as the basic
switching element of the brain. This article laid the foundation for the construction of
artiﬁcial neural networks and thus for this very important branch of AI.
We could consider the ﬁeld of modeling and simulation of neural networks to be
the bionics branch within AI.1 Nearly all areas of AI attempt to recreate cognitive
processes, such as in logic or in probabilistic reasoning. However, the tools used for
modeling—namely mathematics, programming languages, and digital computers—
have very little in common with the human brain. With artiﬁcial neural networks,
the approach is different. Starting from knowledge about the function of natural
neural networks, we attempt to model, simulate, and even reconstruct them in
hardware. Every researcher in this area faces the fascinating and exciting challenge
of comparing results with the performance of humans.
In this chapter we will attempt to outline the historical progression by deﬁning a
model of the neuron and its interconnectivity, starting from the most important
biological insights. Then we will present several important and fundamental
models: the Hopﬁeld model, two simple associative memory models, and the—
exceedingly important in practice—backpropagation algorithm.
1Bionics is concerned with unlocking the “discoveries of living nature” and its innovative
conversion into technology [Wik13].
© Springer International Publishing AG 2017
W. Ertel, Introduction to Artificial Intelligence, Undergraduate Topics
in Computer Science, DOI 10.1007/978-3-319-58487-4_9
245

9.1
From Biology to Simulation
Each of the roughly 100 billion neurons in a human brain has, as shown in a
simpliﬁed representation in Fig. 9.1, the following structure and function. Besides
the cell body, the neuron has an axon, which can make local connections to other
neurons over the dendrites. The axon can, however, grow up to a meter long in the
form of a nerve ﬁber through the body.
The cell body of the neuron can store small electrical charges, similarly to a
capacitor or battery. This storage is loaded by incoming electrical impulses from
other neurons. The more electric impulse comes in, the higher the voltage. If the
voltage exceeds a certain threshold, the neuron will ﬁre. This means that it unloads
its store, in that it sends a spike over the axon and the synapses. The electrical
current divides and reaches many other neurons over the synapses, in which the
same process takes place.
Now the question of the structure of the neural network arises. Each of the
roughly 1011 neurons in the brain is connected to roughly 1000 to 10 000 other
neurons, which yields a total of over 1014 connections. If we further consider that
this gigantic number of extremely thin connections is made up of soft,
three-dimensional tissue and that experiments on human brains are not easy to carry
out, then it becomes clear why we do not have a detailed circuit diagram of the
Fig. 9.1 Two stages of the
modeling of a neural network.
Above a biological model and
below a formal model with
neurons and directed
connections between them
246
9
Neural Networks

brain. Presumably we will never be capable of completely understanding the circuit
diagram of our brain, based solely on its immense size.
From today’s perspective, it is no longer worth even trying to make a complete
circuit diagram of the brain, because the structure of the brain is adaptive.
It changes itself on the ﬂy and adapts according to the individual’s activities and
environmental inﬂuences. The central role here is played by the synapses, which
create the connection between neurons. At the connection point between two
neurons, it is as if two cables meet. However, the two leads are not perfectly
conductively connective, rather there is a small gap, which the electrons cannot
directly jump over. This gap is ﬁlled with chemical substances, so-called neuro-
transmitters. These can be ionized by an applied voltage and then transport a charge
over the gap. The conductivity of this gap depends on many parameters, for
example the concentration and the chemical composition of the neurotransmitter.
It is enlightening that the function of the brain reacts very sensitively to changes of
this synaptic connection, for example through the inﬂuence of alcohol or
other drugs.
How does learning work in such a neural network? The surprising thing here is
that it is not the actual active units, namely the neurons, which are adaptive, rather it
is the connections between them, that is, the synapses. Speciﬁcally, this can change
their conductivity. We know that a synapse is made stronger by however much
more electrical current it must carry. Stronger here means that the synapse has a
higher conductivity. Synapses which are used often obtain an increasingly higher
weight. For synapses which are used infrequently or are not active at all, the
conductivity continues to decrease. This can even lead to them dying off.
All neurons in the brain work asynchronously and in parallel, but, compared to a
computer, at very low speed. The time for a neural impulse takes about a millisecond,
exactly the same as the time for the ions to be transported over the synaptic gap. The
clock frequency of the neuron then is under one kilohertz and is thus lower than that
of modern computers by a factor of 106. This disadvantage, however, is more than
compensated for in many complex cognitive tasks, such as image recognition, by the
very high degree of parallel processing in the network of nerve cells.
The connection to the outside world comes about through sensor neurons, for
example on the retina in the eyes, or through nerve cells with very long axons
which reach from the brain to the muscles and thus can carry out actions such as the
movement of a leg.
However, it is still unclear how the principles discussed make intelligent
behavior possible. Just like many researchers in neuroscience, we will attempt to
explain using simulations of a simple mathematical model how cognitive tasks, for
example pattern recognition, become possible.
9.1.1
The Mathematical Model
First we replace the continuous time axis with a discrete time scale. The neuron
i carries out the following calculation in a time step. The “loading” of the activation
9.1
From Biology to Simulation
247

potential is accomplished simply by summation of the weighted output values
x1, … , xn of all incoming connections over the formula
X
n
j¼1
wijxj:
This weighted sum is calculated by most neural models. Then an activation function
f is applied to it and the result
xi ¼ f
 X
n
j¼1
wijxj
!
is passed on to the neighboring neurons as output over the synaptic weights. In
Fig. 9.2 this kind of modeled neuron is shown. For the activation function there are
a number of possibilities. The simplest is the identity: fðxÞ ¼ x. The neuron thus
calculates only the weighted sum of the input values and passes this on. However,
this frequently leads to convergence problems with the neural dynamics because the
function fðxÞ ¼ x is unbounded and the function values can grow beyond all limits
over time.
Very well restricted, in contrast, is the threshold function (Heaviside step
function)
HH x
ð Þ ¼
0
if x\H;
1
else.
(
The whole neuron then computes its output as
xi ¼
0
if
Xn
j¼1 wijxj\H;
1
else.
(
This formula is identical to (8.1) on page 187, in other words, to a perceptron with the
threshold H (Fig. 9.3 on page 249). The input neurons 1, … , n here have only the
function of variables which pass on their externally set values x1, … , xn unchanged.
The step function is quite sensible for binary neurons because the activation of a
neuron can only take on the values zero or one anyway. In contrast, for continuous
Fig. 9.2 The structure of a formal neuron, which applies the activation function f to the weighted
sum of all inputs
248
9
Neural Networks

neurons with activations between 0 and 1, the step function creates a discontinuity.
However, this can be smoothed out by a sigmoid function, such as
fðxÞ ¼
1
1 þ exH
T
with the graph in Fig. 9.4. Near the critical area around the threshold H, this
function behaves close to linearly and it has an asymptotic limit. The smoothing can
be varied by the parameter T.
Modeling learning is central to the theory of neural networks. As previously
mentioned, one possibility of learning consists of strengthening a synapse
according to how many electrical impulses it must transmit. This principle was
postulated by D. Hebb in 1949 and is known as the Hebb rule:
If there is a connection wij between neuron j and neuron i and repeated signals
are sent from neuron j to neuron i, which results in both neurons being
simultaneously active, then the weight wij is reinforced. A possible formula
for the weight change Dwij is
Dwij ¼ gxixj
with the constant η (learning rate), which determines the size of the individual
learning steps.
Fig. 9.3 The neuron with a step function works like a perceptron with a threshold
Fig. 9.4 The sigmoid function for various values of the parameter T. We can see that in the limit
T ! 0 the step function results
9.1
From Biology to Simulation
249

There are many modiﬁcations of this rule, which then result in different types of
networks or learning algorithms. In the following sections, we will become familiar
with a few of these.
9.2
Hopfield Networks
Looking at the Hebb rule, we see that for neurons with values between zero and one,
the weights can only grow with time. It is not possible for a neuron to weaken or even
die according to this rule. This can be modeled, for example, by a decay constant
which weakens an unused weight by a constant factor per time step, such as 0.99.
This problem is solved quite differently by the model presented by Hopﬁeld in
1982 [Hop82]. It uses binary neurons, but with the two values −1 for inactive and 1
for active. Using the Hebb rule we obtain a positive contribution to the weight
whenever two neurons are simultaneously active. If, however, only one of the two
neurons is active, Dwij is negative.
Hopﬁeld networks, which are a beautiful and visualizable example of
auto-associative memory, are based on this idea. Patterns can be stored in
auto-associative memory. To call up a saved pattern, it is sufﬁcient to provide a
similar pattern. The store then ﬁnds the most similar saved pattern. A classic
application of this is handwriting recognition.
In the learning phase of a Hopﬁeld network, N binary coded patterns, saved in the
vectors q1, …, qN, are supposed to be learned. Each component q j
i 2 f1; 1g of such
a vector q j represents a pixel of a pattern. For vectors consisting of n pixels, a neural
network with n neurons is used, one for each pixel position. The neurons are fully
connected with the restriction that the weight matrix is symmetric and all diagonal
elements wij are zero. That is, there is no connection between a neuron and itself.
The fully connected network includes complex feedback loops, so-called
recurrences, in the network (Fig. 9.5).
N patterns can be learned by simply calculating all weights with the formula
wij ¼ 1
N
X
N
k¼1
qk
i qk
j :
ð9:1Þ
This formula points out an interesting relationship to the Hebb rule. Each pattern in
which the pixels i and j have the same value makes a positive contribution to the weight
Fig. 9.5 Recurrent connections between two neurons in a Hopﬁeld network
250
9
Neural Networks

wij. Each other pattern makes a negative contribution. Since each pixel corresponds to
a neuron, here the weights between neurons which simultaneously have the same
value are being reinforced. Please note this small difference to the Hebb rule.
Once all the patterns have been stored, the network can be used for pattern
recognition. We give the network a new pattern x and update the activations of all
neurons in an asynchronous process according to the rule
xi ¼
1
if Pn
j¼1
j6¼i
wijxj \ 0;
1
else
(
ð9:2Þ
until the network becomes stable, that is, until no more activations change. As a
program schema this reads as follows:
HOPFIELDASSOCIATOR(q)
Initialize all neurons: x = q
Repeat
i = Random(1,n)
Update neuron i according to (9.2)
Until x converges
Return (x)
9.2.1
Application to a Pattern Recognition Example
We apply the described algorithm to a simple pattern recognition example. It should
recognize digits in a 10  10 pixel ﬁeld. The Hopﬁeld network thus has 100
neurons with a total of
100  99
2
¼ 4950
weights. First the patterns of the digits 1, 2, 3, 4 in Fig. 9.6 above on page 252 are
trained. That is, the weights are calculated by (9.1) on page 250. Then we put in the
pattern with added noise and let the Hopﬁeld dynamics run until convergence. In
rows 2 to 4 in the ﬁgure, ﬁve snapshots of the network’s development are shown
during recognition. At 10% noise all four learned patterns are very reliably rec-
ognized. Above about 20% noise the algorithm frequently converges to other
learned patterns or even to patterns which were not learned. Several such pattern are
shown in Fig. 9.6 on page 252 below.
Now we save the digits 0 to 9 (Fig. 9.7 on page 253 top) in the same network
and test the network again with patterns that have a random amount of about 10%
inverted pixels. In the ﬁgure we clearly see that the Hopﬁeld iteration often does not
converge to the most similar learned state even for only 10% noise. Evidently the
9.2
Hopfield Networks
251

network can securely save and recognize four patterns, but for ten patterns its
memory capacity is exceeded. To understand this better, we will take a quick look
into the theory of this network.
9.2.2
Analysis
In 1982, John Hopﬁeld showed in [Hop82] that this model is formally equivalent to
a physical model of magnetism. Small elementary magnets, so-called spins,
Fig. 9.6 Dynamics of a Hopﬁeld network. In rows 2, 3 and 4 we can easily see how the network
converges and the learned pattern is recognized after about 300 to 400 iterations. In the last row
several stable states are shown which are reached by the network when the input pattern deviates
too much from all learned patterns
252
9
Neural Networks

mutually inﬂuence each other over their magnetic ﬁelds (see Fig. 9.8). If we
observe two such spins i and j, they interact over a constant wij and the total energy
of the system is then
E ¼  1
2
X
i;j
wijxixj:
By the way, wii ¼ 0 in physics too, because particles have no self-interaction.
Because physical interactions are symmetric, wij ¼ wji.
A physical system in equilibrium takes on a (stable) state of minimal energy and
thus minimizes E(x, y). If such a system is brought into an arbitrary state, then it
moves toward a state of minimal energy. The Hopﬁeld dynamics deﬁned in (9.2) on
page 251 correspond exactly to this principle because it updates the state in each
iteration such that, of the two states −1 and 1, the one with smaller total energy is
taken on. The contribution of the neuron i to total energy is
 1
2 xi
X
n
j6¼i
wijxj:
Fig. 9.7 For ten learned states the network shows chaotic behavior. Even with little noise the
network converges to the wrong patterns or to artifacts
Fig. 9.8 Comparison between the neural and physical interpretation of the Hopﬁeld model
9.2
Hopfield Networks
253

If now
X
n
j6¼i
wijxj \ 0;
then xi ¼ 1 results in a negative contribution to the total energy, and xi ¼ 1 results
in a positive contribution. For xi ¼ 1, the network takes on a state of lower energy
than it does for xi ¼ 1. Analogously, we can assert that in the case of
X
n
j6¼i
wijxj  0;
it must be true that xi ¼ 1.
If each individual iteration of the neural dynamics results in a reduction of the
energy function, then the total energy of the system decreases monotonically with
time. Because there are only ﬁnitely many states, the network moves in time to a
state of minimal energy. Now we have the exciting question: what do these minima
of the energy function mean?
As we saw in the pattern recognition experiment, in the case offew learned patterns
the system converges to one of the learned patterns. The learned patterns represent
minima of the energy function in the state space. If however too many patterns are
learned, then the system converges to minima which do not correspond to learned
patterns. Here we have a transition from an ordered dynamics into a chaotic one.
Hopﬁeld and other physicists have investigated exactly this process and have
shown that there is in fact a phase transition at a critical number of learned patterns.
If the number of learned patterns exceeds this value, then the system changes from
the ordered phase into the chaotic.
In magnetic physics there is such a transition from the ferromagnetic mode, in
which all elementary magnets try to orient themselves parallel, to a so-called spin
glass, in which the spins interact chaotically. A more visualizable example of such a
physical phase transition is the melting of an ice crystal. The crystal is in a high state
of order because the H2O molecules are strictly ordered. In liquid water, by contrast,
the structure of the molecules is dissolved and their positions are more random.
In a neural network there is then a phase transition from ordered learning and
recognition of patterns to chaotic learning in the case of too many patterns, which
can no longer be recognized for certain. Here we deﬁnitely see parallels to effects
which we occasionally experienced ourselves.
We can understand this phase transition [RMS92] if we bring all neurons into a
pattern state, for example q1, and insert the learned weights from (9.1) on
page 250 into the term Pn
j¼1; j6¼i wijqj, which is relevant for updating neuron i. This
results in
254
9
Neural Networks

X
n
j¼1
j6¼i
wijq1
j ¼ 1
n
X
n
j¼1
j6¼i
X
N
k¼1
qk
i qk
j q1
j ¼ 1
n
X
n
j¼1
j6¼i
q1
j

q1
j
2 þ
X
N
k¼2
qk
i qk
j q1
j
 
!
¼ q1
i þ 1
n
X
n
j¼1
j6¼i
X
N
k¼2
qk
i qk
j q1
j :
Here we see the ith component of the input pattern plus a sum with (n −1)(N −1)
terms. If these summands are all statistically independent, then we can describe the
sum by a normally distributed random variable with standard deviation
1
n
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
ðn  1ÞðN  1Þ
p

ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
N  1
n
r
:
Statistical independence can be achieved, for example, with uncorrelated random
patterns. The sum then generates noise which is not disruptive as long as N  n,
which means that the number of learned patterns stays much smaller than the
number of neurons. If, however, N  n, then the inﬂuence of the noise becomes as
large as the pattern and the network reacts chaotically. A more exact calculation of
the phase transition gives N ¼ 0:146 n as the critical point. Applied to our example,
this means that for 100 neurons, up to 14 patterns can be saved. Since the patterns
in the example however are strongly correlated, the critical value is much lower,
evidently between 0.04 and 0.1. Even a value of 0.146 is much lower than the
storage capacity of a traditional memory list (Exercise 9.3 on page 286).
Hopﬁeld networks in the presented form only work well when patterns with
roughly 50% 1-bits are learned. If the bits are very asymmetrically distributed, then
the neurons must be equipped with a threshold [Roj96]. In physics this is analogous
to the application of an outer magnetic ﬁeld, which also brings about an asymmetry
of the spin 1/2 and the spin −1/2 states.
9.2.3
Summary and Outlook
Through its biological plausibility, the well understood mathematical model, and
above all through the impressive simulations in pattern recognition, the Hopﬁeld
model contributed to a wave of excitement about neural networks and to the rise of
neuroinformatics as an important branch of AI.2 Subsequently many further net-
work models were developed. On one hand, networks without back-couplings were
investigated because their dynamics is signiﬁcantly easier to understand than
recurrent Hopﬁeld networks. On the other hand, attempts were made to improve the
storage capacity of the networks, which we will go into in the next section.
2Even the author was taken up by this wave, which carried him from physics into AI in 1987.
9.2
Hopfield Networks
255

A special problem of many neural models was already evident in the Hopﬁeld
model. Even if there is a guarantee of convergence, it is not certain whether the
network will converge to a learned state or get stuck at a local minimum. The
Boltzmann machine, with continuous activation values and a probabilistic update
rule for its network dynamics, was developed as an attempt to solve this problem.
Using a “temperature” parameter, we can vary the amount of random state
changes and thus attempt to escape local minima, with the goal of ﬁnding a stable
global minimum. This algorithm is called “simulated annealing”. Annealing is a
process of heat treating metals with the goal of making the metal stronger and
more “stable”.
The Hopﬁeld model carries out a search for a minimum of the energy function in
the space of activation values. It thereby ﬁnds the pattern saved in the weights, and
which is thus represented in the energy function. The Hopﬁeld dynamics can also
be applied to other energy functions, as long as the weight matrix is symmetric and
the diagonal elements are zero. This was successfully demonstrated by Hopﬁeld
and Tank on the traveling salesman problem [HT85, Zel94]. The task here is, given
n cities and their distance matrix, to ﬁnd the shortest round trip that visits each city
exactly once.
9.3
Neural Associative Memory
A traditional list memory can in the simplest case be a text ﬁle in which strings of
digits are saved line by line. If the ﬁle is sorted by line, then the search for an
element can be done very quickly in logarithmic time, even for very large ﬁles.
List memory can also be used to create mappings, however. For example, a
telephone book is a mapping from the set of all entered names to the set of all
telephone numbers. This mapping is implemented as a simple table, typically saved
in a database.
Access control to a building using facial recognition is a similar task. Here we
could also use a database in which a photo of every person is saved together with
the person’s name and possibly other data. The camera at the entrance then takes a
picture of the person and searches the database for an identical photo. If the photo is
found, then the person is identiﬁed and gets access to the building. However, a
building with such a control system would not get many visitors because the
probability that the current photo matches the saved photo exactly is very small.
In this case it is not enough to just save the photo in a table. Rather, what we
want is associative memory, which is capable of not only assigning the right name
to the photo, but also to any of a potentially inﬁnite set of “similar” photos.
A function for ﬁnding similarity should be generated from a ﬁnite set of training
data, namely the saved photos labeled with the names. A simple approach for this is
the nearest neighbor method introduced in Sect. 8.3. During learning, all of the
photos are simply saved.
256
9
Neural Networks

To apply this function, the photo most similar to the current one must be found
in the database. For a database with many high-resolution photos, this process,
depending on the distance metric used, can require very long computation times and
thus cannot be implemented in this simple form. Therefore, instead of such a lazy
algorithm, we will prefer one which transfers the data into a function which then
creates a very fast association when it is applied.
Finding a suitable distance metric presents a further problem. We would like a
person to be recognized even if the person’s face appears in another place on the
photo (translation), or if it is smaller, larger, or even rotated. The viewing angle and
lighting might also vary.
This is where neural networks show their strengths. Without requiring the
developer to think about a suitable similarity metric, they still deliver good results.
We will introduce two of the simplest associative memory models and begin with a
model by Teuvo Kohonen, one of the pioneers in this area.
The Hopﬁeld model presented in the previous chapter would be too difﬁcult to
use for two reasons. First, it is only an auto-associative memory, that is, an
approximately identical mapping which maps similar objects to the learned original.
Second, the complex recurrent dynamics is often difﬁcult to manage in practice.
Therefore we will now look at simple two-layer feedforward networks.
9.3.1
Correlation Matrix Memory
In [Koh72] Kohonen introduced an associative memory model based on elementary
linear algebra. This maps query vectors x 2 ℝn to result vectors y 2 ℝm. We are
looking for a matrix W which correctly maps out of a set of training data
T ¼ fðq1; t1Þ; . . . ; ðqN; t NÞg
with N query-response pairs all query vectors to their responses.3 That is, for p ¼ 1,
… , N it must be the case that
tp ¼ W  qp;
ð9:3Þ
or
t p
i ¼
X
n
j¼1
wijq p
j :
ð9:4Þ
3For a clear differentiation between training data and other values of a neuron, in the following
discussion we will refer to the query vector as q and the desired response as t (target).
9.3
Neural Associative Memory
257

Fig. 9.9 Representation of
the Kohonen associative
memory as a two-layer neural
network
To calculate the matrix elements wij, the rule
wij ¼
X
N
p¼1
q p
j t p
i
ð9:5Þ
is used. These two linear equations can be simply understood as a neural network if
we deﬁne, as in Fig. 9.9, a two-layer network with q as the input layer and t as the
output layer. The neurons of the output layer have a linear activation function, and
(9.5) is used as the learning rule, which corresponds exactly to the Hebb rule.
Before we show that the network recognizes the training data, we need the
following deﬁnition:
Deﬁnition 9.1 Two vectors x and y are called orthonormal if
xT  y ¼
1
if x ¼ y;
0
else.
(
Thus
Theorem 9.1 If all N query vectors qp in the training data are orthonormal,
then every vector qp is mapped to the target vector tp by multiplication with
the matrix W from (9.5).
Proof: We substitute (9.5) into (9.4) on page 257 and obtain
ðW  qpÞi ¼
X
n
j¼1
wijq p
j ¼
X
n
j¼1
X
N
r¼1
qr
jtr
i qp
j ¼
X
n
j¼1

qp
j qp
j tp
i þ
X
N
r6¼p
r¼1
qr
jqp
j tr
i

¼tp
i
X
n
j¼1
qp
j qp
j
|ﬄﬄﬄﬄ{zﬄﬄﬄﬄ}
¼1
þ
X
N
r6¼p
r¼1
tr
i
X
n
j¼1
qr
jqp
j
|ﬄﬄﬄﬄ{zﬄﬄﬄﬄ}
¼0
¼ tp
i
h
258
9
Neural Networks

Thus, if the query vectors are orthonormal, all patterns will be correctly
mapped to the respective targets. However, orthonormality is too strong a
restriction. In Sect. 9.4 we will present an approach that overcomes this
limitation.
Since linear mappings are continuous and injective, we know that the mapping
from query vectors to target vectors preserves similarity. Similar queries are thus
mapped to similar targets due to the continuity. At the same time we know,
however, that different queries are mapped to different targets. If the network was
trained to map faces to names and if the name Henry is assigned to a face, then we
are sure that for the input of a similar face, an output similar to “Henry” will be
produced, but “Henry” itself is guaranteed not to be calculated. If the output can be
interpreted as a string, then, for example, it could be “Genry” or “Gfnry”. To arrive
at the most similar learned case, Kohonen uses a binary coding for the output
neuron. The calculated result of a query is rounded if its value is not zero or one.
Even then we have no guarantee that we will hit the target vector. Alternatively, we
could add a subsequent mapping of the calculated answer to the learned target
vector with the smallest distance.
9.3.2
The Binary Hebb Rule
In the context of associative memory, the so-called binary Hebb rule was suggested.
It requires that the pattern is binary-encoded. This means that for all patterns qp 2
{0, 1}n and tp 2 {0, 1}m. Furthermore, the summation from (9.5) on page 258 is
replaced by a simple logical OR and we obtain the binary Hebb rule
wij ¼
_
N
p¼1
q p
j t p
i :
ð9:10Þ
The weight matrix is thus also binary, and a matrix element wij is equal to one if and
only if at least one of the entries q1
j t1
i ; . . . ; qN
j tN
i
is not zero. All other matrix
elements are zero. We are tempted to believe that a lot of information is lost here
during learning because, when a matrix element takes on the value 1 once, it cannot
be changed by additional patterns. Figure 9.10 on page 260 shows how the matrix
is ﬁlled with ones for an example with n ¼ 10; m ¼ 6 after learning three pairs.
To retrieve the saved patterns we simply multiply a query vector q by the matrix
and look at the result Wq. We test this on the example and get Fig. 9.11 on page 260.
We see that in the target vector on the right side there is the value 3 in the place
where the learned target vector had a one. The correct results would be obtained by
setting a threshold value of 3. In the general case we choose the number of ones in
the query vector as the threshold. Each output neuron thus works like a perceptron,
albeit with a variable threshold.
As long as the weight matrix is sparse, this algorithm performs well. However, if
many different patterns are saved, the matrix becomes more and more dense. In the
9.3
Neural Associative Memory
259

extreme case it contains only ones. Then, after setting the threshold, all answers
would consist of just ones and would no longer contain any information.
This case rarely occurs as long as the number of bits saved in the matrix does not
become too large. The matrix has a size of m n elements. A pair to be saved has
m + n bits. One can show [Pal80] that the number of memorizable patterns Nmax is
determined by the following condition:
a ¼
number of storable bits
number of binary matrix elements
¼ m þ n
ð
ÞNmax
mn
 ln 2  0:69:
ð9:11Þ
For a list memory we have a ¼ 1. Associative memory with the binary Hebb rule
has a maximum memory efﬁciency of a ¼ 0:69 compared to a ¼ 0:72 for Kohonen
associative memory and a ¼ 0:292 for Hopﬁeld networks [Pal80, Pal91]. The
memory capacity of the binary Hebb rule is thus surprisingly high in comparison to
the Kohonen model with continuous neurons.
It is obvious that such memory becomes “full” less quickly when the query and
target vectors are sparsely populated with ones. This is not the only reason why the
encoding of input and output for associative memories—as also for other neural
networks—is very important for good performance. We will now demonstrate this
on an application of this memory with suitably chosen encodings of input and
output.
Fig. 9.10 The matrix
W after saving three pairs
(q1, t1), (q2, t2), (q3, t3).
Empty ﬁelds correspond to
the value 0
Fig. 9.11 Calculation of the
product Wq1, Wq2, Wq3
260
9
Neural Networks

9.3.3
A Spelling Correction Program
As an application of the described associative memory with the binary Hebb rule,
we choose a program that corrects erroneous inputs and maps them to saved words
from a dictionary. Clearly an auto-associative memory would be needed here.
However, because we encode the query and target vectors differently, this is not the
case. For the query vectors q we choose a pair encoding. For an alphabet with 26
characters there are 26 ⋅26 ¼ 676 ordered pairs of letters. With 676 bits, the query
vector has one bit for each of the possible pairs
aa; ab; . . . ; az; ba; . . . ; bz; . . . ; za; . . . ; zz:
If a pair of letters occurs in the word, then a one will be entered in the appropriate
place. For the word “hans”, for instance, the slots for “ha”, “an”, and “ns” are ﬁlled
with ones. For the target vector t, 26 bits are reserved for each position in the word
up to a maximum length (for example ten characters). For the ith letter in the
alphabet in position j in the word then the bit number (j −1) ⋅26 + i is set. For the
word “hans”, bits 8, 27, 66, and 97 are set. For a maximum of 10 letters per word,
the target vector thus has a length of 260 bits.
The weight matrix W thus has a size of 676 ⋅260 bits ¼ 199420 bits, which by
(9.11) on page 260 can store at most
Nmax  0:69 m n
m þ n ¼ 0:69 676  260
676 þ 260  130
words. With 72 ﬁrst names, we save about half that many and test the system. The
stored names and the output of the program for several example inputs are given in
Fig. 9.12 on page 262. The threshold is always initialized to the number of bits in
the encoded query. Here this is the number of letter pairs, thus the word length
minus one. Then it is stepwise reduced to two. We could further automate the
choice of the threshold by comparing with the dictionary for each attempted
threshold and output the word found when the comparison succeeds.
The reaction to the ambiguous inputs “andr” and “johanne” is interesting. In
both cases, the network creates a mix of two saved words that ﬁt. We see here an
important strength of neural networks. They are capable of making associations to
similar objects without an explicit similarity metric. However, similarly to
heuristic search and human decision making, there is no guarantee for a “correct”
solution.
Since the training data must be available in the form of input-output pairs for all
neural models which have been introduced so far, we are dealing with supervised
learning, which is also the case for the networks introduced in the following
sections.
9.3
Neural Associative Memory
261

Stored words:
agathe, agnes, alexander, andreas, andree, anna, annemarie, astrid, august, bernhard, bjorn,
cathrin, christian, christoph, corinna, corrado, dieter, elisabeth, elvira, erdmut, ernst, evelyn,
fabrizio, frank, franz, geoffrey, georg, gerhard, hannelore, harry, herbert, ingilt, irmgard, jan,
johannes, johnny, juergen, karin, klaus, ludwig, luise, manfred, maria, mark, markus, marleen,
martin, matthias, norbert, otto, patricia, peter, phillip, quit, reinhold, renate, robert, robin, sabine,
sebastian, stefan, stephan, sylvie, ulrich, ulrike, ute, uwe, werner, wolfgang, xavier
Associations of the program:
input pattern: harry
threshold: 4, answer: harry
threshold: 3, answer: harry
threshold: 2, answer: horryrrde
-------------------------------
input pattern: ute
threshold: 2, answer: ute
-------------------------------
input pattern: gerhar
threshold: 5, answer: gerhard
threshold: 4, answer: gerrarn
threshold: 3, answer: jerrhrrd
threshold: 2, answer: jurtyrrde
-------------------------------
input pattern: egrhard
threshold: 6, answer:
threshold: 5, answer:
threshold: 4, answer: gerhard
threshold: 3, answer: gernhrrd
threshold: 2, answer: irrryrrde
-------------------------------
input pattern: andr
threshold: 3, answer: andrees
threshold: 2, answer: anexenser
input pattern: andrees
threshold: 6, answer: a
threshold: 5, answer: andree
threshold: 4, answer: andrees
threshold: 3, answer: mnnrens
threshold: 2, answer: morxsnssr
-------------------------------
input pattern: johanne
threshold: 6, answer: johnnnes
threshold: 5, answer: johnnnes
threshold: 4, answer: jornnnrse
threshold: 3, answer: sorrnyrse
threshold: 2, answer: wtrrsyrse
-------------------------------
input pattern: johnnnes
threshold: 6, answer: joh
threshold: 5, answer: johnnnes
threshold: 4, answer: johnnyes
threshold: 3, answer: jonnnyes
threshold: 2, answer: jornsyrse
-------------------------------
input pattern: johnnyes
threshold: 7, answer:
threshold: 6, answer: joh
threshold: 5, answer: johnny
threshold: 4, answer: johnnyes
threshold: 3, answer: johnnyes
threshold: 2, answer: jonnnyes
Fig. 9.12 Application of the spelling correction program to various learned or erroneous inputs.
The correct inputs are found with the maximum (that is, the ﬁrst attempted) threshold. For
erroneous inputs the threshold must be lowered for a correct association
262
9
Neural Networks

9.4
Linear Networks with Minimal Errors
The Hebb rule used in the neural models presented so far works with associations
between neighboring neurons. In associative memory, this is exploited in order to learn
a mapping from query vectors to targets. This works very well in many cases, espe-
cially when the query vectors are linearly independent. If this condition is not fulﬁlled,
for example when too much training data is available, the question arises: how do we
ﬁnd the optimal weight matrix? Optimal means that it minimizes the average error.
We humans are capable of learning from mistakes. The Hebb rule does not offer
this possibility. The backpropagation algorithm, described in the following, uses an
elegant solution known from function approximation to change the weights such
that the error on the training data is minimized.
Let N pairs of training vectors
T ¼ fðq1; t1Þ; . . . ; ðqN; tNÞg
be given with qp 2 [0, 1]n t p 2 [0, 1]m. We are looking for a function f : [0, 1]n !
[0, 1]m which minimizes the squared error
X
N
p¼1
ð fðqpÞ  tpÞ2
on the data. Let us ﬁrst assume that the data contains no contradictions. That is,
there is no query vector in the training data which should be mapped to two
different targets. In this case it is not difﬁcult to ﬁnd a function that minimizes the
squared error. In fact, there exist inﬁnitely many functions which make the error
zero. We deﬁne the function
fðqÞ ¼ 0;
if q 62 fq1; . . . ; qNg
and
fðqpÞ ¼ t p
8 p 2 f1; . . . ; Ng:
This is a function which even makes the error on the training data zero. What more
could we want? Why are we not happy with this function?
The answer is: because we want to build an intelligent system! Intelligent means,
among other things, that the learned function can generalize well from the training
data to new, unknown data from the same representative data set. In other words it
means: we do not want overﬁtting of the data by memorization. What is it then that
we really want?
We want a function that is smooth and “evens out” the space between the points.
Continuity and the ability to take multiple derivatives would be sensible require-
ments. Because even with these conditions there are still inﬁnitely many functions
which make the error zero, we must restrict this class of functions even further.
9.4
Linear Networks with Minimal Errors
263

9.4.1
Least Squares Method
The simplest choice is a linear mapping. We begin with a two-layer network
(Fig. 9.13) in which the single neuron y of the second layer calculates its activation
using
y ¼ f
 X
n
i¼1
wixi
!
with fðxÞ ¼ x. The fact that we are only looking at output neurons here does not
pose a real restriction because a two-layer network with two or more output neurons
can always be separated into independent networks with identical input neurons for
each of the original output neurons. The weights of the subnetworks are all inde-
pendent. Using a sigmoid function instead of the linear activation does not give any
advantage here because the sigmoid function is strictly monotonically increasing
and does not change the order relation between various output values.
Desired is a vector w which minimizes the squared error
EðwÞ ¼
X
N
p¼1
ðw qp  t pÞ2 ¼
X
N
p¼1
 X
n
i¼1
wiqi
p  t p
!2
:
As a necessary condition for a minimum of this error function all partial derivatives
must be zero. Thus we require that for j ¼ 1; . . . ; n:
@E
@wj
¼ 2
X
N
p¼1
 X
n
i¼1
wiq p
i  t p
!
q p
j ¼ 0:
Multiplying this out yields
X
N
p¼1
 X
n
i¼1
wiq p
i q p
j  t pq p
j
!
¼ 0;
Fig. 9.13 A two-layer
network with an output
neuron
264
9
Neural Networks

and exchanging the sums results in the linear system of equations
X
n
i¼1
wi
X
N
p¼1
q p
i q p
j ¼
X
N
p¼1
t pq p
j ;
which with
Aij ¼
X
N
p¼1
q p
i q p
j
and
bj ¼
X
N
p¼1
t pq p
j
ð9:12Þ
can be written as the matrix equation
Aw ¼ b:
ð9:13Þ
These so-called normal equations always have at least one solution and, when A is
invertible, exactly one. Furthermore, the matrix A is positive-deﬁnite, which has the
implication that the discovered solution in the unique case is a global minimum.
This algorithm is known as least squares method.
The calculation time for setting up the matrix A grows with H(N ⋅n2) and the time
for solving the system of equations as O(n3). This method can be extended very
simply to incorporate multiple output neurons because, as already mentioned, for
two-layer feedforward networks the output neurons are independent of each other.
9.4.2
Application to the Appendicitis Data
As an application we now determine a linear score for the appendicitis diagnosis.
From the LEXMED project data, which is familiar from Sect. 8.4.5, we use the least
squares method to determine a linear mapping from symptoms to the continuous class
variables AppScore with values in the interval [0, 1] and obtain the linear combination
AppScore ¼ 0:00085 Age  0:125 Sex þ 0:025 P1Q þ 0:035 P2Q  0:021 P3Q
 0:025 P4Q þ 0:12 TensLoc þ 0:031 TensGlo þ 0:13 Losl
þ 0:081 Conv þ 0:0034 RectS þ 0:0027 TAxi þ 0:0031 TRec
þ 0:000021 Leuko  0:11 Diab  1:83:
This function returns continuous variables for AppScore, although the actual binary
class variable App only takes on the values 0 and 1. Thus we have to decide on a
threshold value, as with the perceptron. The classiﬁcation error of the score as a
function of the threshold is listed in Fig. 9.14 on page 266 for the training data and the
test data. We clearly see that both curves are nearly the same and have their minimum
at H ¼ 0:5. In the small difference of the two curves we see that overﬁtting is not a
problem for this method because the model generalizes from the test data very well.
9.4
Linear Networks with Minimal Errors
265

Also in the ﬁgure is the result for the nonlinear, three-layer RProp network
(Sect. 9.5) with a somewhat lower error for threshold values between 0.2 and 0.9.
For practical application of the derived score and the correct determination of the
threshold H it is important to not only look at the error, but also to differentiate by
type of error (namely false positive and false negative), as is done in the LEXMED
application in Fig. 7.10 on page 156. In the ROC curve shown there, the score
calculated here is also shown. We see that the simple linear model is clearly inferior
to the LEXMED system. Evidently, linear approximations are not powerful enough
for many complex applications.
9.4.3
The Delta Rule
Least squares is, like the perceptron and decision tree learning, a so-called batch
learning algorithm, as opposed to incremental learning. In batch learning, all
training data must be learned in one run. If new training data is added, it cannot
simply be learned in addition to what is already there. The whole learning process
must be repeated with the enlarged set. This problem is solved by incremental
learning algorithms, which can adapt the learned model to each additional new
example. In the algorithms we will look at in the following discussion, we will
additively update the weights for each new training example by the rule
wj ¼ wj þ Dwj:
To derive an incremental variant of the least squares method, we reconsider the
above calculated n partial derivatives of the error function
@E
@wj
¼ 2
X
N
p¼1
 X
n
i¼1
wiq p
i  t p
!
q p
j :
Fig. 9.14 Least squares error for training and test data
266
9
Neural Networks

The gradient
rE ¼
 @E
@w1
; . . . ; @E
@wn

as a vector of all partial derivatives of the error function points in the direction of
the strongest rise of the error function in the n-dimensional space of the weights.
While searching for a minimum, we will therefore follow the direction of the
negative gradient. As a formula for changing the weights we obtain
Dwj ¼  g
2
@E
@wj
¼ g
X
N
p¼1
 X
n
i¼1
wiq p
i  t p
!
q p
j ;
where the learning rate η is a freely selectable positive constant. A larger η speeds
up convergence but at the same time raises the risk of oscillation around minima or
ﬂat valleys. Therefore, the optimal choice of η is not a simple task (see Fig. 9.15).
A large η, for example η ¼ 1, is often used to start with, and then slowly shrunk.
By replacing the activation
yp ¼
X
n
i¼1
wiq p
i
of the output neuron for applied training example qp, the formula is simpliﬁed and
we obtain the delta rule
Dwj ¼ g
X
N
p¼1
ðtp  ypÞqp
j :
Thus for every training example the difference between the target tp and the actual
output yp of the network is calculated for the given input qp. After summing over all
patterns, the weights are then changed proportionally to the sum. This algorithm is
shown in Fig. 9.16 on page 268.
Fig. 9.15 Gradient descent for a large η (left) and a very small η (right) into a valley descending
ﬂatly to the right. For a large η there are oscillations around the valley. For a η which is too small,
in contrast, convergence in the ﬂat valley happens very slowly
9.4
Linear Networks with Minimal Errors
267

We see that the algorithm is still not really incremental because the weight
changes only occur after all training examples have been applied once. We can
correct this deﬁciency by directly changing the weights (incremental gradient
descent) after every training example (Fig. 9.17), which, strictly speaking, is no
longer a correct implementation of the delta rule.
9.4.4
Comparison to the Perceptron
The learning rule for perceptrons introduced in Sect. 8.2.1, the least squares
method, and the delta rule can be used to generate linear functions from data. For
perceptrons however, in contrast to the other methods, a classiﬁer for linearly
separable classes is learned through the threshold decision. The other two methods,
however, generate a linear approximation to the data. As shown in Sect. 9.4.2, a
classiﬁer can be generated from the linear mapping, if desired, by application of a
threshold function.
DELTALEARNING(TrainingExamples, η)
Initialize all weights wj randomly
Repeat
w
0
For all (qp,tp)
TrainingExamples
Calculate network output yp
wpqp
w
w
η(tp
yp)qp
w
w
w
Until w converges
Fig. 9.16 Learning a two-layer linear network with the delta rule. Notice that the weight changes
always occur after all of the training data are applied
DELTALEARNINGINCREMENTAL(TrainingExamples, η)
Initialize all weights wj randomly
Repeat
For all (qp,tp) ∈TrainingExamples
Calculate network output yp = wpqp
w = w + η(tp −yp)qp
Until w converges
Fig. 9.17 Incremental variant of the delta rule
268
9
Neural Networks

The perceptron and the delta rule are iterative algorithms for which the time until
convergence depends heavily on the data. In the case of linearly separable data, an
upper limit on the number of iteration steps can be found for the perceptron. For the
delta rule, in contrast, there is only a guarantee of asymptotic convergence without
limit [HKP91].
For least squares, learning consists of setting up and solving a linear system of
equations for the weight vector. There is thus a hard limit on the computation time.
Because of this, the least squares method is always preferable when incremental
learning is not needed.
9.5
The Backpropagation Algorithm
With the backpropagation algorithm, we now introduce the most-used neural
model. The reason for its widespread use its universal versatility for arbitrary
approximation tasks. The algorithm originates directly from the incremental delta
rule. In contrast to the delta rule, it applies a nonlinear sigmoid function on
the weighted sum of the inputs as its activation function. Furthermore, a back-
propagation network can have more than two layers of neurons. The algorithm
became
known
through
the
article
[RHR86]
in
the
legendary
PDP
collection [RM86].
In Fig. 9.18 on page 270 a typical backpropagation network with an input layer,
a hidden layer, and an output layer is shown. Since the current output value xp
j of
the output layer neuron is compared with the target output value tp
j , these are drawn
parallel to each other. Other than the input neurons, all neurons calculate their
current value xj by the rule
xj ¼ f
 X
n
i¼1
wjixi
!
ð9:14Þ
where n is the number of neurons in the previous layer. We use the sigmoid
function
fðxÞ ¼
1
1 þ ex :
Analogous to the incremental delta rule, the weights are changed proportional to the
negative gradient of the quadratic error function summed over the output neurons
EpðwÞ ¼ 1
2
X
k2output
ðt p
k  xp
kÞ2
9.4
Linear Networks with Minimal Errors
269

for the training pattern p:
Dpwji ¼ g @Ep
@wji
:
For deriving the learning rule, the above expression is substituted for Ep. Within the
expression, xk is replaced by (9.14) on page 269. Within the equation, the outputs xi
of the neurons of the next, deeper layer occur recursively, etc. By multiple appli-
cations of the chain rule (see [RHR86] or [Zel94]) we obtain the backpropagation
learning rule
Dpwji ¼ gd p
j x p
i ;
with
d p
j ¼
xp
j ð1  xp
j Þðt p
j  xp
j Þ
if j is an output neuron,
xp
j ð1  xp
j Þ P
k dp
k wkj
if j is a hidden neuron,
8
<
:
Fig. 9.18 A three-layer
backpropagation network
with n1 neurons in the ﬁrst, n2
neurons in the second, and n3
neurons in the third layer
which is also denoted the generalized delta rule. For all neurons, the formula for
changing weight wji from neuron i to neuron j (see Fig. 9.19 on page 271) contains,
like the Hebb rule, a term gxp
i xp
j . The new factor ð1  xp
j Þ creates the symmetry,
which is missing from the Hebb rule, between the activations 0 and 1 of neuron
j. For the output neurons, the factor ðtp
j  xp
j Þ takes care of a weight change pro-
portional to the error. For the hidden neurons, the value dp
j of neuron j is calculated
recursively from all changes dp
k of the neurons of the next higher level.
270
9
Neural Networks

The entire execution of the learning process is shown in Fig. 9.20. After cal-
culating the output of the network (forward propagation) for a training example, the
approximation error is calculated. This is then used during backward propagation to
alter the weights backward from layer to layer. The whole process is then applied to
all training examples and repeated until the weights no longer change or a time limit
is reached.
If we build a network with at least one hidden layer, nonlinear mappings can be
learned. Without hidden layers, the output neurons are no more powerful than a
linear neuron, despite the sigmoid function. The reason for this is that the sigmoid
function is strictly monotonic. The same is true for multi-layer networks which only
use a linear function as an activation function, for example the identity function.
This is because chained executions of linear mappings is linear in aggregate.
Just like with the perceptron, the class of the functions which can be represented
are also enlarged if we use a variable sigmoid function
Fig. 9.19 Designation of the
neurons and weights for the
application of the
backpropagation rule
BACKPROPAGATION(TrainingExamples, η)
Initialize all weights wj to random values
Repeat
For all (qp,tp) ∈TrainingExamples
1. Apply the query vector qp to the input layer
2. Forward propagation:
For all layers from the ﬁrst hidden layer upward
For each neuron of the layer
Calculate activation xj = f (
n
i=1 wjixi)
3. Calculation of the square error Ep(w)
4. Backward propagation:
For all levels of weights from the last downward
For each weight wji
wji = wji + ηδp
j xp
i
Until w converges or time limit is reached
Fig. 9.20 The backpropagation algorithm
9.5
The Backpropagation Algorithm
271

fðxÞ ¼
1
1 þ eðxHÞ :
with threshold H. This is implemented analogously to the way shown in Sect. 8.2,
in which a neuron whose activation always has the value one and which is con-
nected to neurons in the next highest level is inserted into the input layer and into
each hidden layer. The weights of these connections are learned normally and
represent the threshold H of the successor neurons.
9.5.1
NETtalk: A Network Learns to Speak
Sejnowski and Rosenberg demonstrated very impressively in 1986 what back-
propagation is capable of performing [SR86]. They built a system that is able to
understandably read English text aloud from a text ﬁle. The architecture of the
network shown in Fig. 9.21 consists of an input layer with 7  29 ¼ 203 neurons in
which the current letter and three previous letters, as well as three subsequent,
letters are encoded. For each of these seven letters, 29 neurons are reserved for the
characters “a...z ,.”. The input is mapped onto the 26 output neurons over 80
hidden neurons, each of which stands for a speciﬁc phoneme. For example, the “a”
in “father” is pronounced deep, accented, and central. The network was trained with
1,000 words, which were applied randomly one after another letter by letter. For
each letter, the target output was manually given for its intonation. To translate the
intonation attributes into actual sounds, part of the speech synthesis system
Fig. 9.21 The NETtalk network maps a text to its pronunciation attributes
272
9
Neural Networks

DECtalk was used. Through complete interconnectivity, the network contains a
total of 203  80 þ 80  26 ¼ 18320 weights.
The system was trained using a simulator on a VAX 780 with about 50 cycles
over all words. Thus, at about 5 characters per word on average, about 5  50 
1000 ¼ 250 000 iterations of the backpropagation algorithm were needed. At a rate
of about one character per second, this means roughly 69 hours of computation
time. The developers observed many properties of the system which are quite
similar to human learning. At ﬁrst the system can only speak unclearly or use
simple words. With time it continued to improve and ﬁnally reached 95% cor-
rectness of pronounced letters.
For visual experiments with neural networks, the Java Neural Network Simu-
lator JNNS is recommended [Zel94]. The NETtalk network, loaded and trained
with JNNS, is shown in Fig. 9.22.
9.5.2
Learning of Heuristics for Theorem Provers
In Chap. 6, algorithms for heuristic search, such as the A⋆-algorithm and the
IDA⋆-algorithm were discussed. To reach a signiﬁcant reduction of the search
space, a good heuristic is needed for the implementation of these algorithms. In
Fig. 9.22 The NETtalk network in JNNS. In the left window from left to right we see the 7 ⋅29
input neurons, 80 hidden, and 26 output neurons. Due to their large number, the weights are
omitted from the network. Top right is a learning curve showing the development of the squared
error over time
9.5
The Backpropagation Algorithm
273

Sect. 4.1 the problem of the exploding search space during theorem provers’ search
for a proof was demonstrated. This problem is caused by the large number of
possible inference steps in each step.
We now attempt to build heuristic proof controlling modules which evaluate the
various alternatives for the next step and then choose the alternative with the best
rating. In the case of resolution, the rating of the available clauses could be done by
a function which, based on certain attributes of clauses such as the number of
literals, the complexity of the terms, etc., calculates a value for each pair of
resolvable clauses. In [ESS89, SE90] such a heuristic was learned for the theorem
prover SETHEO using backpropagation. While learning the heuristic, the attributes
of the current clause were saved as training data for the positive class for every
proof found at every branch during the search. At all branches which did not lead to
a proof, the attributes of the current clause were saved as training data for the
negative class. Such a tree, with a successful path and the corresponding node
ratings, is sketched in Fig. 9.23.
A backpropagation network was trained on this data and then used to evaluate
clauses in the prover. For each clause, 16 numeric attributes were calculated,
normalized, and encoded in an input neuron. The network was trained with 25
hidden neurons and one output neuron for the class (positive/negative).
It was shown that the number of attempted inferences can be reduced by many
orders of magnitude for difﬁcult problems, which ultimately reduces the compu-
tation time from hours to seconds. Thereby it became possible to prove theorems
which, without heuristics, were out of reach.
9.5.3
Problems and Improvements
Backpropagation is now 25 years old and has proved itself in various applications,
for example in pattern recognition and in robotics. However, its application is
sometimes problematic. Especially when the network has many thousands of
weights and there is a lot of training data to learn, two problems come up:
The network often converges to local minima of the error function. Furthermore,
backpropagation often converges very slowly. This means that many iterations over
Fig. 9.23 Search tree with a successful path whose nodes are evaluated as positive, and the
negatively rated unsuccessful branches
274
9
Neural Networks

all training patterns are needed. Many improvements have been suggested to
alleviate these problems. As mentioned in Sect. 9.4.3, oscillations can be avoided
by slowly reducing the learning rate η as shown in Fig. 9.15 on page 267.
Another method for reducing oscillations is the use of a momentum term while
updating the weights, which ensures that the direction of gradient descent does not
change too dramatically from one step to the next. Here for the current weight
change Dpwji (t) at time t another part of the change Dpwji (t −1) from the previous
step is added. The learning rule then changes to
DpwjiðtÞ ¼ gdp
j xp
i þ cDpwjiðt  1Þ
with a parameter c between zero and one. This is depicted in a two-dimensional
example in Fig. 9.24.
Another idea is to minimize the linear error function instead of the square error
function, which reduces the problem of slow convergence into ﬂat valleys.
Gradient descent in backpropagation is ultimately based on a linear approxi-
mation of the error function. Quickprop, an algorithm which uses a quadratic
approximation to the error function and thus achieves faster convergence, was
created by Scott Fahlmann.
Through smart uniﬁcation of the improvements mentioned and other heuristic
tricks, Martin Riedmiller achieved a further optimization with the RProp algo-
rithm [RB93]. RProp has replaced backpropagation and is the new state of the art
feedforward neural network approximation algorithm. In Sect. 8.9 we applied
RProp to the classiﬁcation of the appendicitis data and achieved an error which is
approximately the same size as that of a learned decision tree.
9.6
Support Vector Machines
Feedforward neural networks with only one layer of weights are linear. Linearity
leads to simple networks and fast learning with guaranteed convergence. Further-
more, the danger of overﬁtting is small for linear models. For many applications,
however, the linear models are not strong enough, for example because the relevant
classes are not linearly separable. Here multi-layered networks such as backprop-
agation come into use, with the consequence that local minima, convergence
problems, and overﬁtting can occur.
Fig. 9.24 Abrupt direction
changes are smoothed out by
the use of the momentum
term. An iteration without the
momentum term (left) in
comparison to iteration with
the momentum term (right)
9.5
The Backpropagation Algorithm
275

A promising approach, which brings together the advantages of linear and
nonlinear models, follows the theory of support vector machines (SVM), which we
will roughly outline using a two class problem.4
In the case of two linearly separable classes, it is easy to ﬁnd a dividing hyper
plane, for example with the perceptron learning rule. However, there are usually
inﬁnitely many such planes, as in the two-dimensional example in Fig. 9.25. We
are looking for a plane which has the largest minimum distance to both classes. This
plane is usually uniquely deﬁned by a few points in the border area. These points,
the so-called support vectors, all have the same distance to the dividing line. To ﬁnd
the support vectors, there is an efﬁcient optimizing algorithm. It is interesting that
the optimal dividing hyperplane is determined by a few parameters, namely by the
support vectors. Thus the danger of overﬁtting is small.
Support vector machines apply this algorithm to non linearly separable problems
in a two-step process: In the ﬁrst step, a nonlinear transformation is applied to the
data, with the property that the transformed data is linearly separable. In the second
step the support vectors are then determined in the transformed space.
The ﬁrst step is highly interesting, but not quite simple. In fact, it is always
possible to make the classes linearly separable by transforming the vector space, as
long as the data contains no contradictions.5 Such a separation can be reached for
example by introducing a new (n + 1)th dimension and the deﬁnition
xn þ 1 ¼
1
if x 2 class 1;
0
if x 2 class 0:
(
However, this formula does not help much because it is not applicable to new
points of an unknown class which are to be classiﬁed. We thus need a general
transformation which is as independent as possible from the current data. It can be
shown that there are such generic transformations even for arbitrarily shaped class
division boundaries in the original vector space. In the transformed space, the data
are then linearly separable. However, the number of dimensions of the new vector
space grows exponentially with the number of dimensions of the original vector
Fig. 9.25 Two classes with
the maximally dividing line.
The circled points are the
support vectors
4Support vector machines are not neural networks. Due to their historical development and
mathematical relationship to linear networks, however, they are discussed here.
5A data point is contradictory if it belongs to both classes.
276
9
Neural Networks

space. However, the large number of new dimensions is not so problematic
because, when using support vectors, the dividing plane, as mentioned above, is
determined by only a few parameters.
The central nonlinear transformation of the vector space is called the kernel,
because of which support vector machines are also known as kernel methods. The
original SVM theory developed for classiﬁcation tasks has been extended and can
now be used on regression problems also.
The mathematics used here is very interesting, but too extensive for an initial
introduction. To delve deeper into this promising young branch of machine
learning, we refer the reader to [SS02, Alp04] and [Bur98].
9.7
Deep Learning
In Chaps. 8 and 9 we saw that there are many good learning algorithms today which
are capable of learning non-trivial, sometimes complex classiﬁcations or approxi-
mations for all sorts of applications, such as diagnosis and prognosis based on
sensor inputs. We have also seen that, up to now, generation of features has not
been successful. Instead it is the job of a data scientist to ﬁnd a sensible small set of
features, which can then be used as input for the learning algorithm.
Why do we not simply use all available sensor data, i.e. a direct image of the
world, as input? For example, for object recognition in a photo we could use all ten
million pixels as an input vector, which has a length of 30 million (in the case of
RGB or HSV images, which each have three color values). What is the problem
with this approach? The answer is known as the “curse of the dimensionality”. This
means, among other things, that training time grows very fast, often exponentially,
with the dimension of the input data. To keep computation times within bounds, we
must therefore ﬁrst reduce the input data to short feature vectors. As described
above, this mapping is usually created manually. However, for many applications,
such as object classiﬁcation in images it is difﬁcult if not impossible to manually
ﬁnd the formula for features. One old method for automatic reduction of dimensions
is principal component analysis (PCA) [Ert15], which determines the directions of
highest variance (i.e. the principal component) in the vector space of the training
data and projects the data into the subspace of the principal components using a
linear transformation. Because of the missing nonlearity of the compression map-
ping PCA is not as powerful as the new methods described below.
Since about 1995 work has been done on deep learning, a highly promising class
of algorithms to solve this problem, and there are now impressive successes to report.
Deep learning includes methods such as convolutional neural networks (CNNs), or
deep belief networks and variations thereof. The architectures of the multi-layered
neural networks with up to twenty or more layers are in part very complex and cannot
be explained in detail here. [LBH15] is a good review article, and a very detailed
introduction can be found in [GBC16], as well as in deeplearning.stanford.
edu. Now let us try to understand the most important principles.
9.6
Support Vector Machines
277

Pattern recognition is simple in low-dimensional spaces or in case of classiﬁ-
cation when the classes are linearly separable. For classes that are not linearly
separable in high dimensional spaces, however, problems arise because here
learning poses a nonlinear optimization problem. In principle there are solutions
using gradient descent algorithms such as backpropagation. However, convergence
problems and unacceptably high computation times arise for the classical algo-
rithms, especially when networks with many hidden layers are used. Thus other
methods have been sought.
9.7.1
Nature as Example
All successful approaches in deep learning to date work with many layers of
neurons. The network is split into two parts, similar to the feedforward network
shown schematically in Fig. 9.26. After a preprocessing layer there are several
layers which are pre-trained by unsupervised learning (UL). Each layer in this UL
network represents features of the input pattern. The lower the layer, the simpler the
features. In object recognition in photos, the features of the lower layers typically
represent edges or lines in different orientations.6 Complex features such as the
preprocessing
input layer
SL
UL
.....
2nd feature layer
1st feature layer
n−th feature layer
raw data
output layer
backpropagation−
network
.....
.....
.....
.....
.....
.....
Fig. 9.26 Simpliﬁed architecture of a deep learning network. It is composed of a preprocessor,
several layers (in this case two) for unsupervised feature detection and then one classical neural
network, which, in this example, is trained by backpropagation
6Visual representations of such edge features, including explanation, can be found at
deeplearning.stanford.edu.
278
9
Neural Networks

presence of a face can form on higher layers. This architecture shows certain
similarities to the structure of the brains of humans and animals. Starting from the
sense organs, for example the eyes, the brain is built up in many layers, and the
higher the layer, the more abstract the information to be found there. However,
there is still far too little known about how neural networks work in nature that
leads to a signiﬁcant beneﬁt in deep learning [GBC16].
Attached to the UL network is a classical supervised learning (SL) network,
which can be trained with backpropagation or RProp. Thus the learning process
works as follows:
1. Unsupervised training of all feature layer weights.
2. Supervised training of the SL network with gradient descent.
The unsupervised learning of the weights to the feature layers remains to be
explained. By learning these weights, the features will be extracted. Feature
extraction should have the property that input data is mapped into a lower
dimensional space, if possible without (too much) loss of information. One could
therefore see feature extraction as a form of compression. We now outline one of
the many possible algorithms for feature learning.
9.7.2
Stacked Denoising Autoencoder
The feature layer’s weights are determined by a fundamentally simple and obvi-
ous algorithm called stacked denoising autoencoder [VLL+10], as shown in
Fig. 9.27.
To train the ﬁrst hidden layer, an autoencoder is trained with a supervised
learning method, for example RProp. Its job is to learn the identity mapping of all
input vectors x onto itself. The feature layer acts as the hidden layer. To make sure
that features form in this layer, it is important to avoid overﬁtting. The classical
approach would be to use cross-validation over the number of hidden neurons in the
feature layer. That would lead to a small number of hidden neurons and thus few
features. It has been shown that such a compressed encoding of the features is not
optimal. So-called sparse coding leads to better results.
copy of input layer
feature layer
input layer
decoder
encoder
.....
.....
.....
Fig. 9.27 Autoencoder for learning the weights of a feature layer. A classical backpropagation
network can be used here to learn the identity mapping from the current input layer onto itself.
Features form in the hidden layer during learning
9.7
Deep Learning
279

In order to ﬁnd many different features via such a sparse coding, denoising,
rather than cross-validation, will be used. During each learning cycle, the values of
some of the input neurons are randomly changed, for example with Gaussian noise
or by setting the activation to 0 or 1. The distance
jjy  xjj
of the calculated output vector y from the original input vector x is used as the error
function for the weight change. Thus the encoder is trained to become robust against
noise. During learning, a variable parameter weights the noisiﬁed neurons more
strongly than the others, so as to optimize the desired effect of the noise on learning.
After the autoencoder is trained, the actually unneeded decoder layer, i.e. the
second layer of weights, is removed. The ﬁrst layer is frozen and used to calculate the
features in the UL network in Fig. 9.26 on page 278. Then, with this ﬁxed ﬁrst layer
of weights, the second feature layer is trained with the autoencoder algorithm,
frozen, and so on until the last feature layer. Thus the unsupervised part of the
learning is ﬁnished.
Now the SL portion of the network is trained with a classical supervised learning
algorithm. For each training example, the output of of the UL network, i.e., the last
feature layer is used as input, and a particular data label is the target output. During
backpropagation, the weights of the feature layers can be trained again for the
purpose of ﬁne-tuning, or they can be left unchanged.
We have not yet mentioned the preprocessing step, which differs depending on
the application. Often all of the input variables are normalized. For photos, the pixel
image is often transformed into a lower dimensional space, similar to PCA, using a
process called whitening, with the goal of making the generated features less
redundant. Here one could also directly use PCA.
9.7.3
Other Methods
In addition to the stacked denoising autoencoder, the previously mentioned con-
volutional neural networks play an important role. To reduce complexity and save
time, the feature layers are not fully connected, rather each feature neuron retains
input from only a few neurons in the layer below. The layers also alternate between
convolution and pooling layers. In each convolution layer, a trainable linear ﬁlter is
used on the input neurons, and in the pooling layer, an average, maximum or a more
complex function is calculated from the input neurons.
Also quite popular are deep belief networks, which use restricted Boltzmann
machines for learning [HOT06].
Discovery of features with UL networks can be completely replaced by clus-
tering, in which, for every discovered cluster, a binary feature determines whether a
point belongs to that particular cluster. One can also use kernel PCA, a nonlinear
generalization of PCA, to learn features. As mentioned earlier, the fully connected
SL network can also be replaced by other learning algorithms, for instance by a
support vector machine.
280
9
Neural Networks

9.7.4
Systems and Implementations
Even the best current implementations of deep learning systems are very compu-
tationally intensive. The cause of the long computation times is the size of the input
layer and the high number of layers in the network. This effect is ampliﬁed further
if, in the case of a large input layer, the training data are elements of a
high-dimensional vector space. To represent the trained classes well, a great many
data vectors are needed, which makes the computation time even longer.
This means that a training run can take from minutes up to even days. In
addition, the system parameters of the complex networks have to be conﬁgured,
which, in turn, has a big impact on the quality of the results. As we know from
Chap. 8, optimal metaparameters for a learning algorithm can be found with
cross-validation, that is by trying out all combinations of values. Due to the
complexity of deep learning algorithms, there are many parameters, and the set of
parameter combinations grows exponentially with the number of parameters.
Therefore, the naive application of cross-validation is not practical. Instead, algo-
rithms are used which look for a point in the space of the system’s metaparameters
that minimizes errors on the validation data [BBBK11]. Examples of such meta-
parameters are the number of layers in the UL network as well as the SL network,
the number of neurons in the individual layers, the learning rates, and the degree of
interconnectedness for CNN networks. The algorithms for optimization of meta-
parameters use, for example, random search or gradient descent in the space of
metaparameters [MDA15].
Thus, for high-dimensional data sets, simple PCs are overwhelmed. Today one
works with multiprocessor machines and the learning algorithms are run highly
parallel on modern graphics cards, which ultimately leads to training times of hours
to weeks for training with hyper parameter optimization.
Thirty-eight different freely available software systems are listed at http://
deeplearning.net/software_links.7 Theano, with special support for graphics cards,
and the systems Pylearn2 und Keras, which are based on Theano, are especially
interesting. Each of these are programmed in the Python programming language.
Tensorﬂow from Google Deep Brain also uses Python. The only additional
requirement for a successful project is a suitably fast machine, which can be rented
from cloud service providers as needed.
9.7.5
Applications of Deep Learning
Especially in object classiﬁcation in photos, deep learning has shown impressive
progress. In [Ben16] there is a collection of results for various data sets. For
example, in the recognition of hand-written digits, the classiﬁcation accuracy of
99.8% has been achieved on the MNIST data set presented in [LBBH98] (Fig. 9.28
on page 282 links). On the SVHN data set (Fig. 9.28 on page 282 center) generated
7Accessed April, 2016.
9.7
Deep Learning
281

as part of the Google Street View Project with photos of home address numbers
[NWC+11], the accuracy is at about 98.3%. It is even possible to describe photos in
complete sentences [VTBE15]. For the photo shown in the right of Fig. 9.28, this
system produces the sentence “A person riding a motorcycle on a dirt road.”
It uses a convolutional neural network for object recognition and a recurrent neural
network for text generation.
In addition to many other applications, there are impressive variants of deep
learning for creatively generating works of art.
9.8
Creativity
With deep learning, programs have emerged that can, for example, compose jazz
melodies [BBSK10]. A recurrent neural network is used in [Kar15] to generate
texts, syntactically correct XML code, even LATEX source with mathematical
notation and short computer programs. Hence recurrent neural networks can learn
grammar. A program trained on Shakespeare’s body of work can, from scratch,
generate new texts such as:
KING LEAR:
O, if you were a feeble sight, the courtesy of your law,
Your sight and several breath, will wear the gods
With his heads, and my hands are wonder’d at the deeds,
So drop upon your lordship’s head, and your opinion
Shall be against your honour.
Wikipedia describes creativity as a phenomenon in which something new and
somehow valuable is formed. It is easy to appreciate this deﬁnition in light of the
above text. Let us imagine a program that randomly generates text letter by letter.
The result might begin something like
NitDjgMQsQfI 6zz1B:6xZkgp1xe.EqyD7z(C
While the text is new, it is not very valuable and therefore not a creative artifact.
On the other hand, a program that queries and outputs text from a database does not
Fig. 9.28 Examples of MNIST data (left), SVHN data (center) and an example photo for the
image description system
282
9
Neural Networks

count as creative either because it produces nothing new. A creative program, for
example, should write a novel that is both interesting and new at the same time. One
could easily check the text’s novely, for example by using software for testing the
originality of student thesis papers. Interestingness is more difﬁcult. It would be
good if a program could generate new texts that a person would enjoy based on the
ratings which that person has given to previously read literature.
Somewhat more formally, we could deﬁne an adaptive creative program as one
that takes some objects from a given distribution of training data, then approximates
the distribution and randomly creates a new object from this distribution.
Fig. 9.29 Artistic pictures of the view of Tübingen in the top left generated with the network
from [GEB15]. For each pair of images, the famous painting whose style was used to transform the
photo can be seen in the bottom left (Source [GEB15])
9.8
Creativity
283

One very nice example of such a creative effort is the CNN in [GEB15], which
takes two input images and generates a new one that assumes the style of the ﬁrst
image and the content of the second. The results of this program are shown
impressively in Fig. 9.29 on page 283. The photo in the top left is transformed into
the respective styles of each painting by the old masters.
The program uses the VGG network [SZ15], which is a convolutional network
that was pre-trained on the imagenet large scale visual recognition challenge with
hundreds of object categories and millions of images [RDS+15]. From this
pre-trained object classiﬁcation network only the feature layers, but not the fully
connected classiﬁcation layers, are used here. Rather, the authors use only sixteen
convolutional layers and ﬁve pooling layers.
To gain a better understanding of the procedure we ﬁrst solve two simpler
problems. The photograph is applied and propagated forward through the network,
generating the features of the photo image. Now a pixel image with white noise is
applied and propagated forward through the network, generating the features of the
white noise image. Using gradient descent search, the pixels of the white noise
image are now varied until the distance between the features of the image features
to those of the photograph is minimized. Ultimately this reproduces the photo’s
content.
Then the photograph is replaced by the old work of art which is applied to
another network with the same structure and, similarly to the photo, the features are
computed. Again a pixel image with white noise is applied to the network. Using
gradient descent search, it is changed until the distance between the correlations of
the generated features and those of the painting are minimized. Ultimately this
reproduces the painting’s style.
Now, to transfer the syle of the painting onto the photo, both methods are
combined. We apply gradient descent search on a pixel image with white noise but
now we minimize a linear combination of both of the above distance functions.
Thus an image in the style of the painting with the content of the photo is created.
9.9
Applications of Neural Networks
In addition to the applications given as examples thus far, there are countless
applications for neural networks in all areas of industry, especially for deep
learning. Pattern recognition in all of its forms is a very important area, whether
analysis of photos to recognize people or faces, recognition of ﬁsh swarms in sonar
readings, recognition and classiﬁcation of military vehicles in radar scans, or any
number of other applications. Neural networks can also be trained to recognize
spoken language and hand written text.
Neural networks are not only used for recognizing objects and scenes. They can
be trained to control self driving cars or robots based on sensor data, as well as for
heuristically controlling search in backgammon and chess computers. An inter-
esting use of networks for reinforcement learning is described in Sect. 10.8
284
9
Neural Networks

For quite some time, neural networks, in addition to statistical methods, have
been used successfully to forecast stock prices and to judge the creditworthiness of
bank customers. Speed trading of international ﬁnancial transactions would be
impossible without the help of smart and fast neural networks that autonomously
decide about buying or selling.
Other machine learning algorithms can as well be used for many of these
applications. Due to the great commercial success of data mining, decision tree
learning and support vector machines, there are neural algorithms for many
applications as well as others that are not biologically motivated at all. The ﬁeld of
neural networks is a subarea of machine learning.
9.10
Summary and Outlook
With the perceptron, the delta rule, backpropagation, and, built upon them, deep
learning, we have introduced the most important class of feedforward networks and
shown their relationship to scores and naive Bayes, and also to the method of least
squares.
Nearest to their biological role models are the fascinating Hopﬁeld networks.
However, due to their complex dynamics, they are difﬁcult to handle in practice.
In all neural models, stored information is distributed over many weights.
Therefore, the death of a few neurons has little noticeable effect on the function of a
brain. The network is robust against small disturbances due to the distributed
storage of the data. Related to this is the ability to recognize noisy patterns, which
has been shown in several examples.
The distributed representation of knowledge has the disadvantage, however, that it
is difﬁcult for knowledge engineers to localize knowledge. It is practically impossible
to analyze and understand the many weights in a trained fully connected neural net-
work. In contrast, it is relatively easy to understand the learned knowledge in a decision
tree, and even to represent it as a logical formula. Predicate logic, which allows
formalization of relationships, is especially expressive and elegant. For example, a
predicate grandmother(katrin, klaus) is easy to understand. This type of
relationship can also be learned with neural networks. However, it is not possible to
locate the “grandmother neuron” in the network. Thus, even today there are problems
when connecting neural networks with symbol processing systems. A very important
step in this direction is the automatic feature generation of deep learning networks.
Of the great number of interesting neural models, many have not been discussed.
For example, self-organizing maps, introduced by Kohonen, are very interesting.
A self-organizing map performs biologically inspired mapping from a sensory
neural layer onto a second layer of neurons with the property that this mapping is
adaptive and preserves similarities.
One problem with the networks presented here is incremental learning. If, for
example, a fully trained backpropagation network is trained further with new pat-
terns, many and eventually all of the old patterns will begin to be quickly forgotten.
9.9
Applications of Neural Networks
285

To solve this problem, Carpenter and Grossberg developed adaptive resonance
theory (ART), which has lead to a set of neural models.
As further reading, we recommend the textbooks [Bis05, Zel94, RMS92, Roj96,
GBC16]. The collected volumes [AR88, APR90] are recommended for those
interested in studying the history of this exciting area from the older, original works.
9.11
Exercises
9.11.1
From Biology to Simulation
Exercise 9.1 Show the point symmetry of the sigmoid function to ðh; 1
2Þ.
9.11.2
Hopfield Networks
Exercise 9.2 Use the Hopﬁeld network applet at http://www.cbu.edu/*pong/ai/
hopﬁeld/hopﬁeldapplet.html and test the memory capacity for correlated and
uncorrelated patterns (with randomly set bits) with a 10  10 grid size. Use a
pattern with 10% noise for testing.
Exercise 9.3 Compare the theoretical limit N ¼ 0:146 n for the maximum number
of patterns which can be stored, given in Sect. 9.2.2, with the capacity of classical
binary storage of the same size.
9.11.3
Linear Networks with Minimal Errors
➳Exercise 9.4
(a) Write a program for learning a linear mapping with the least mean square
method. This is quite simple: one must only set up the normal equations
by (9.12) on page 265 and then solve the system of equations.
(a) Apply this program to the appendicitis data on this book’s website and
determine a linear score. Give the error as a function of the threshold, as in
Fig. 9.14 on page 266.
(c) Now determine the ROC curve for this score.
9.11.4
Backpropagation
Exercise 9.5 Using a backpropagation program (for example in JNNS or KNIME),
create a network with eight input neurons, eight output neurons, and three hidden
neurons. Then train the network with eight training data pairs qp, qp with the
286
9
Neural Networks

property that, in the pth vector qp, the pth bit is one and all other bits are zero. The
network thus has the simple task of learning an identical mapping. Such a network
is called an 8-3-8 encoder. After the learning process, observe the encoding of the
three hidden neurons for the input of all eight learned input vectors. What do you
notice? Now repeat the experiment, reduce the number of hidden neurons to two
and then one.
Exercise 9.6 In order to show that backpropagation networks can divide non lin-
early separable sets, train the XOR function. The training data for this is: ((0, 0), 0),
((0, 1), 1), ((1, 0), 1), ((1, 1), 0).
(a) Create a network with two neurons each in the input layer and hidden layer,
and one neuron in the output layer, and train this network.
(b) Now delete the hidden neurons and connect the input layer directly to the
output neurons. What do you observe?
Exercise 9.7
(a) Show that any multi-layer backpropagation network with a linear activation
function is equally powerful as a two-layer one. For this it is enough to show
that successive executions of linear mappings is a linear mapping.
(b) Show that a two-layer backpropagation network with any strictly monotonic
activation function is not more powerful for classiﬁcation tasks than one
without an activation function or with a linear activation function.
9.11.5
Support Vector Machines
❄Exercise 9.8 Two non linearly separable two-dimensional sets of training data M+
and M−are given. All points in M+ are within the unit circle x2
1 þ x2
2 ¼ 1 and all
points in M−are outside. Give a coordinate transform f : ℝ2 ! ℝ2 which makes the
data linearly separable. Give the equation of the dividing line and sketch the two
spaces and the data points.
9.11
Exercises
287

10
Reinforcement Learning
10.1
Introduction
All of the learning algorithms described so far—except the clustering algorithms—
belong to the class of supervised learning. In supervised learning, the agent is
supposed to learn a mapping from the input variables to the output variables. Here it
is important that for each individual training example, all values for both input
variables and output variables are provided. In other words, we need a teacher or a
database in which the mapping to be learned is approximately deﬁned for a sufﬁ-
cient number of input values. The sole task of the machine learning algorithm is to
ﬁlter out the noise from the data and ﬁnd a function which approximates the
mapping well, even between the given data points.
In reinforcement learning the situation is different and more difﬁcult because no
training data is available. We begin with a simple illustrative example from
robotics, which then is used as an application for the various algorithms.
Reinforcement learning is very valuable in the ﬁeld of robotics, where the tasks
to be performed are frequently complex enough to defy encoding as programs and
no training data is available. The robot’s task consists of ﬁnding out, through trial
and error (or success), which actions are good in a certain situation and which are
not. In many cases we humans learn in a very similar way. For example, when a
child learns to walk, this usually happens without instruction, rather simply through
reinforcement. Successful attempts at walking are rewarded by forward progress,
and unsuccessful attempts are penalized by often painful falls. Positive and negative
reinforcement are also important factors in successful learning in school and in
many sports (see Fig. 10.1 on page 290).
A greatly simpliﬁed movement task is learned in the following example.
Example 10.1 A robot whose mechanism consists only of a rectangular block and
an arm with two joints gy and gx is shown in Fig. 10.2 on page 290 (see [KMK97]).
The robot’s only possible actions are the movement of gy up or down and of gx right
or left. Furthermore, we only allow movements of ﬁxed discrete units (for example,
© Springer International Publishing AG 2017
W. Ertel, Introduction to Artificial Intelligence, Undergraduate Topics
in Computer Science, DOI 10.1007/978-3-319-58487-4_10
289

of 10-degree increments). The agent’s task consists of learning a policy which
allows it to move as quickly as possible to the right. The walking robot in Fig. 10.2
works analogously within the same two-dimensional state space.
A successful action sequence is shown in Table 10.1 on page 291. The action at
time t ¼ 2 results in the loaded arm moving the body one unit length to the right.
Nice animations of this example can be found through [KMK97] and [Tok06].
Before we go into the learning algorithm, we must suitably model the task
mathematically. We describe the state of the robot by the two variables gx and gy for
the position of the joints, each with ﬁnitely many discrete values. The state of the
robot is thus encoded as a vector (gx, gy). The number of possible joint positions
is nx, or respectively ny. We use the horizontal position of the robot’s body, which
can take on real values, to evaluate the robot’s actions. Movements to the right are
Fig. 10.1 “Maybe next time I should start turning a bit sooner or go slower?”—Learning from
negative reinforcement
Fig. 10.2 By moving both of its joints, the crawling robot in the left of the image can move
forward and backward. The walking robot on the right side must correspondingly move the frame
up and down or left and right. The feedback for the robot’s movement is positive for movement to
the right and negative for movement to the left
290
10
Reinforcement Learning

rewarded with positive changes to x, and movements to the left are punished with
negative changes.
In Fig. 10.3 the state space for two variants of this is shown in simpliﬁed form.1
In the left example, both joints have two positions, and in the middle example they
each have four positions. An optimal policy is given in Fig. 10.3 right.
10.2
The Task
As shown in Fig. 10.4 on page 292, we distinguish between the agent and its
environment. At time t the world, which includes the agent and its environment, is
described by a state st 2 S. The set S is an abstraction of the actual possible states
Table 10.1 A cycle of a periodic series of movements with systematic forward movement
Crawling robot
Running robot
Time
State
Reward
Action
t
gy
gx
x
at
0
Up
Left
0
Right
1
Up
Right
0
Down
2
Down
Right
0
Left
3
Down
Left
1
Up
Fig. 10.3 The state space of the example robot in the case of two possible positions for each of
the joints (left) and in the case of four horizontal and vertical positions for each (middle). In the
right image an optimal policy is given
1The arm movement space consisting of arcs is rendered as a right-angled grid.
10.1
Introduction
291

of the world because, on one hand, the world cannot be exactly described, and on
the other hand the agent often only has incomplete information about the actual
state because of measurement errors. The agent then carries out an action at 2 A at
time t. This action changes the world and thus results in the state st + 1 at time t þ 1.
The state transition function d deﬁned by the environment determines the new state
st + 1 ¼ d(st, at). It cannot be inﬂuenced by the agent.
After executing action at, the agent obtains immediate reward rt ¼ r(st, at) (see
Fig. 10.4). The immediate reward rt ¼ r(st, at) is always dependent on the current
state and the executed action. r(st, at) ¼ 0 means that the agent receives no
immediate feedback for the action at. During learning, rt > 0 should result in
positive and rt < 0 in negative reinforcement of the evaluation of the action at
in state st. In reinforcement learning especially, applications are being studied in
which no immediate reward happens for a long time. A chess player for example
learns to improve his game from won or lost matches, even if he gets no immediate
reward for all individual moves. Here we can see the difﬁculty of assigning the
reward at the end of a sequence of actions to all the actions in the sequence that led
to this point (credit assignment problem).
In the crawling robot’s case the state consists of the position of the two joints,
that is, s ¼ (gx, gy). The reward is given by the distance x traveled.
A policy p : S ! A is a mapping from states to actions. The goal of reinforcement
learning is that the agent learns an optimal policy based on its experiences. A policy is
optimal if it maximizes reward in the long run, that is, over many steps. But what does
“maximize reward” mean exactly? We deﬁne the value, or the discounted reward
VpðstÞ ¼ rt þ crt þ 1 þ c2rt þ 2 þ    ¼
X
1
i¼0
cirt þ i
ð10:1Þ
of a policy p when we start in starting state st. Here 0  c < 1 is a constant, which
ensures that future feedback is discounted more the farther in the future that it
happens. The immediate reward rt is weighted the strongest. This reward function is
the most predominantly used. An alternative which is sometimes interesting is the
average reward
VpðstÞ ¼ lim
h!1
1
h
X
h
i¼0
rt þ i:
ð10:2Þ
Fig. 10.4 The agent and its interaction with the environment
292
10
Reinforcement Learning

A policy p⋆is called optimal, if for all states s
VpHðsÞ  VpðsÞ:
ð10:3Þ
That is, it is at least as good as all other policies according to the deﬁned value
function. For better readability, the optimum value function VpH will be denoted V⋆.
The agents discussed here, or their policies, only use information about the
current state st to determine the next state, and not the prior history. This is justiﬁed
if the reward of an action only depends on the current state and current actions.
Such processes are called Markov decision processes (MDP). In many applications,
especially in robotics, the actual state of the agent is not exactly known, which
makes planning actions even more difﬁcult. The reason for this may be a noisy
sensor signal. We call such a process a partially observable Markov decision
process (POMDP).
10.3
Uninformed Combinatorial Search
The simplest possibility of ﬁnding a successful policy is the combinatorial enu-
meration of all policies, as described in Chap. 6. However, even in the simple
Example 10.1 on page 289 there are a very many policies, which causes combi-
natorial search to be associated with extremely high computational cost. In
Fig. 10.5 the number of possible actions is given for every state. From that, the
number of possible policies is calculated as the product of the given values, as
shown in Table 10.2 on page 294.
For arbitrary values of nx and ny there are always four corner nodes with two
possible actions, 2(nx −2) + 2(ny −2) edge nodes with three actions, and (nx −2)
(ny −2) inner nodes with four actions. Thus there are
2432ðnx2Þ þ 2ðny2Þ4ðnx2Þðny2Þ
Fig. 10.5 The state space for the example with the values 2, 3, 4, 5 for nx and ny. The number of
possible actions is given for each state in the respective circles
10.2
The Task
293

different policies for ﬁxed nx and ny. The number of policies thus grows expo-
nentially with the number of states. This is true in general if there is more than one
possible action per state. For practical applications this algorithm is therefore
useless. Even heuristic search, described in Chap. 6, cannot be used here. Since the
direct reward for almost all actions is zero, it cannot be used as a heuristic evalu-
ation function.
The computational cost rises even higher when we consider that (in addition to
enumerating all policies), the value V p (s) must be calculated for every generated
policy p and every starting state s. The inﬁnite sum in V p (s) must be cut off for use
in a practical calculation; however, due to the exponential reduction of the ci factors
in (10.1) on page 292, this does not present a problem.
In Example 10.1 on page 289 the difference xt+1 −xt can be used as an
immediate reward for an action at, which means that every movement of the robot’s
body to the right is rewarded with 1 and every movement of the robot’s body to the
left is penalized with −1. In Fig. 10.6, two policies are shown. Here the immediate
reward is zero everywhere other than in the bottom row of the state space. The left
policy p1 is better in the long term because, for long action sequences, the average
progress per action is 3/8 ¼ 0.375 for p1 and 2/6  0.333 for p2. If we use (10.1) on
page 292 for V p (s), the result is the following table with starting state s0 at the top
left and various c values:
c
0.9
0.8375
0.8
Vp1ðs0Þ
2.52
1.156
0.77
Vp2ðs0Þ
2.39
1.156
0.80
Here we see that policy p1 is superior to policy p2 when gamma ¼ 0.9, and the
reverse is true when gamma ¼ 0.8. For c  0.8375 both policies are equally good.
We can clearly see that a larger c results in a larger time horizon for the evaluation
of policies.
Table 10.2 Number of
policies for differently sized
state spaces in the example
nx, ny
Number of states
Number of policies
2
4
24 = 16
3
9
24344 = 5184
4
16
243844  2.7  107
5
25
2431249  2.2  1012
Fig. 10.6 Two different
policies for the example
294
10
Reinforcement Learning

10.4
Value Iteration and Dynamic Programming
In the naive approach of enumerating all policies, much redundant work is per-
formed, because many policies are for the most part identical. They may only differ
slightly. Nevertheless every policy is completely newly generated and evaluated.
This suggests saving intermediate results for parts of policies and reusing them.
This approach to solving optimization problems was introduced as dynamic pro-
gramming by Richard Bellman already in 1957 [Bel57]. Bellman recognized that
for an optimal policy it is the case that:
Independent of the starting state st and the ﬁrst action at, all subsequent decisions pro-
ceeding from every possible successor state st+1 must be optimal.
Based on the so-called Bellman principle, it becomes possible to ﬁnd a globally
optimal policy through local optimization of individual actions. We will derive this
principle for MDPs together with a suitable iteration algorithm.
Desired is an optimal policy p⋆which fulﬁlls (10.3) on page 293 and (10.1) on
page 292. We rewrite the two equations and obtain
V
HðstÞ ¼
max
at;at þ 1;at þ 2;...ðrðst; atÞ þ crðst þ 1; at þ 1Þ þ c2rðst þ 2; at þ 2Þ þ   Þ:
ð10:4Þ
Since the immediate reward r(st, at) only depends on st and at, but not on the
successor states and actions, the maximization can be distributed, which ultimately
results in the following recursive characterization of V⋆:
V
HðstÞ ¼ max
at ½r st; at
ð
Þ þ c
max
at þ 1;at þ 2;... r st þ 1; at þ 1
ð
Þ þ c r st þ 2; at þ 2
ð
Þ þ   
ð
Þ
¼ max
at
r st; at
ð
Þ þ cV
Hðst þ 1Þ
½
:
ð10:5Þ
Equation (10.5) results from the substitution t ! t + 1 in (10.4). Written somewhat
simpler:
V
HðsÞ ¼ max
a ½rðs; aÞ þ cV
Hðdðs; aÞÞ:
ð10:6Þ
This equation implies, as does (10.1) on page 292, that, to calculate V⋆(s), the
immediate reward is added to the reward of all successor states, discounted by the
factor c. If V⋆(d(s, a)) is known, then V⋆(s) clearly results by simple local opti-
mization over all possible actions a in state s. This corresponds to the Bellman
principle, because of which (10.6) is also called the Bellman equation.
10.4
Value Iteration and Dynamic Programming
295

The optimal policy p⋆(s) carries out an action in state s which results in the
maximum value V⋆. Thus,
p
HðsÞ ¼ argmax
a
½rðs; aÞ þ cV
Hðdðs; aÞÞ:
ð10:7Þ
From the recursion equation (10.6) on page 295 an iteration rule for approximat-
ing V⋆: follows in a straightforward manner:
^VðsÞ ¼ max
a ½rðs; aÞ þ c ^Vðdðs; aÞÞ:
ð10:8Þ
To begin the approximate values ^VðsÞ for all states are initialized, for example with
the value zero. Now ^VðsÞ is repeatedly updated for each state by recursively falling
back on the value ^Vðdðs; aÞÞ of the best successor state. This process of calculating
V⋆is called value iteration and is shown schematically in Fig. 10.7. It can be
shown that value iteration converges to V⋆[SB98]. An excellent analysis of
dynamic programming algorithms can be found in [Sze10], where, based on con-
traction properties of the particular algorithms (for example value iteration), con-
vergence can be proven using Banach’s ﬁxed-point theorem.
In Fig. 10.8 on page 297 this algorithm is applied to Example 10.1 on page 289
with c ¼ 0.9. In each iteration the states are processed row-wise from bottom left to
top right. Shown are several beginning iterations and in the second image in the
bottom row the stable limit values for V⋆.
We clearly see the progression of the learning in this sequence. The agent
repeatedly explores all states, carries out value iteration for each state and saves the
policy in the form of a tabulated function V⋆, which then can be further compiled
into an efﬁciently usable table p⋆.
Incidentally, to ﬁnd an optimal policy from V⋆it would be wrong to choose the
action in state st which results in the state with the maximum V⋆value. Corre-
sponding to (10.7), the immediate reward r(st, at) must also be added because we
VALUEITERATION()
For all s ∈S
ˆV (s) = 0
Repeat
For all s ∈S
ˆV (s) = maxa[r(s,a) + γ ˆV (δ(s,a))]
Until ˆV (s) does not change
Fig. 10.7 The algorithm for
value iteration
296
10
Reinforcement Learning

are searching for V⋆(st) and not V⋆(st+1). Applied to state s ¼ (2, 3) in Fig. 10.8, this
means
p
H 2; 3
ð
Þ ¼
argmax
a2 left;right;up
f
g
r s; a
ð
Þ þ cV
H d s; a
ð
Þ
ð
Þ
½

¼ argmax
left;right;up
f
g
1 þ 0:9  2:66; 1 þ 0:9  4:05; 0 þ 0:9  3:28
f
g
¼ argmax
left;right;up
f
g
3:39; 2:65; 2:95
f
g ¼ left.
In (10.7) on page 296 we see that the agent in state st must know the immediate
reward rt and the successor state st+1 ¼ d(st, at) to choose the optimal action at. It
must also have a model of the functions r and d. Since this is not the case for many
practical applications, algorithms are needed which can also work without
knowledge of r and d. Section 10.6 is dedicated to such an algorithm.
Fig. 10.8 Value iteration in the example with 3  3 states. The last two images show two optimal
policies. The numbers next to the arrows give the immediate reward r(s, a) of each action
10.4
Value Iteration and Dynamic Programming
297

10.5
A Learning Walking Robot and Its Simulation
A graphical user interface for simple experiments with reinforcement learning is
shown in Fig. 10.9 [TEF09]. The user can observe reinforcement learning for
differently sized two-dimensional state spaces. For better generalization, back-
propagation networks are used to save the state (see Sect. 10.8). The feedback
editor shown at the bottom right, with which the user can manually supply feedback
about the environment, is especially interesting for experiments. Not shown is the
menu for setting up the parameters for value iteration and backpropagation learning.
Fig. 10.9 Four different windows of the walking robot simulator
298
10
Reinforcement Learning

Besides the simulation, two small, real crawling robots with the same
two-dimensional discrete state space were developed speciﬁcally for teach-
ing [TEF09].2 The two robots are shown in Fig. 10.10. Each moves with a servo
actuator. The servos are controlled by a microcontroller or through a wireless
interface directly from a PC. Using simulation software, the feedback matrix of the
robot can be visualized on the PC. With this saved feedback, a policy can be trained
on the PC (which computes faster), then loaded again into the robot and executed.
However, the robot can also learn autonomously. For a state space of size 5  5 this
takes about 30 seconds.
It is interesting to observe the difference between the simulation and the “real”
robot. In contrast to the simulation, the crawler learns policies in which it never lifts
its arm from the ground, but nonetheless moves forward very efﬁciently. The reason
for this is that, depending on the surface of the underground, the tip of the “un-
derarm” can grip the ground during backward movement, but slides through during
forward movement. This effect is very sensibly perceived through the distance
measuring sensors and evaluated accordingly during learning.
The robot’s adaptivity results in surprising effects. For example, we can observe
how the crawler, despite a defective servo which slips at a certain angle,
nonetheless learns to walk (more like hobbling). It is even capable of adapting to
changed situations by changing policies. A thoroughly desirable effect is the ability,
given differently smooth surfaces (for example, different rough carpets) to learn an
optimal policy for each. It also turns out that the real robot is indeed very adaptable
given a small state space of size 5  5.
The reader may (lacking a real robot) model various surfaces or servo defects by
varying feedback values and then observing the resulting policies (Exercise 10.3 on
page 311).
Fig. 10.10 Two versions of the crawling robot
2Further
information
and
related
sources
about
crawling
robots
are
available
through
www.hs-weingarten.de/*ertel/kibuch.
10.5
A Learning Walking Robot and Its Simulation
299

10.6
Q-Learning
A policy based on evaluation of possible successor states is clearly not useable if
the agent does not have a model of the world, that is, when it does not know which
state a possible action leads to. In most realistic applications the agent cannot resort
to such a model of the world. For example, a robot which is supposed to grasp
complex objects cannot predict whether the object will be securely held in its grip
after a gripping action, or whether it will remain in place.
If there is no model of the world, an evaluation of an action at carried out in state
st is needed even if it is still unknown where this action leads to. Thus we now work
with an evaluation function Q(st, at) for states with their associated actions. With
this function, the choice of the optimal action is made by the rule
p
HðsÞ ¼ argmax
a
Qðs; aÞ:
ð10:9Þ
To deﬁne the evaluation function we again use stepwise discounting of the eval-
uation for state-action pairs which occur further into the future, just as in (10.1) on
page 292. We thus want to maximize rt + crt+1+ c2rt+2+ ⋅⋅⋅. Therefore, to evaluate
action at in state st we deﬁne in analogy to (10.4) on page 295:
Qðst; atÞ ¼
max
at þ 1;at þ 2;...ðrðst; atÞ þ crðst þ 1; at þ 1Þ þ c2rðst þ 2; at þ 2Þ þ   Þ: ð10:10Þ
Analogously to the approach for value iteration, we bring this equation into a
simple recursive form by
Q st; at
ð
Þ ¼
max
at þ 1;at þ 2;... r st; at
ð
Þ þ cr st þ 1; at þ 1
ð
Þ þ c2r st þ 2; at þ 2
ð
Þ þ   


¼ r st; at
ð
Þ þ c
max
at þ 1;at þ 2;... r st þ 1; at þ 1
ð
Þ þ cr st þ 2; at þ 2
ð
Þ þ   
ð
Þ
¼ r st; at
ð
Þ þ c max
at þ 1 ðr st þ 1; at þ 1
ð
Þ þ c max
at þ 2 r st þ 2; at þ 2
ð
Þ þ   
ð
ÞÞ
¼ r st; at
ð
Þ þ c max
at þ 1 Q st þ 1; at þ 1
ð
Þ
¼ r st; at
ð
Þ þ c max
at þ 1 Q d st; at
ð
Þ; at þ 1
ð
Þ
¼ r s; a
ð
Þ þ c max
a0 Q d s; a
ð
Þ; a0
ð
Þ:
ð10:11Þ
What then is the advantage compared to value iteration? The old equation is only
slightly rewritten, but this turns out to be exactly the right approach to a new algo-
rithm. Instead of saving V⋆, now the function Q is saved, and the agent can choose its
actions from the functions d and r without a model of the world. We still do not have
a process, however, which can learn Q directly, that is, without knowledge of V H.
From the recursive formulation of Q(s, a), an iteration algorithm for determining
Q(s, a) can be derived in a straightforward manner. We initialize a table ^Qðs; aÞ for
all states arbitrarily, for example with zeroes, and iteratively carry out
300
10
Reinforcement Learning

^Qðs; aÞ ¼ rðs; aÞ þ c max
a0
^Qðdðs; aÞ; a0Þ:
ð10:12Þ
It remains to note that we do not know the functions r and d. We solve this problem
quite pragmatically by letting the agent in its environment in state s carry out
action a. The successor state is then clearly d(s, a) and the agent receives its reward
from the environment. The algorithm shown in Fig. 10.11 implements this algo-
rithm for Q-learning.
The application of the algorithm to Example 10.1 on page 289 with c ¼ 0.9 and
nx ¼ 3, ny ¼ 2 (that is, in a 2  3 grid) is shown in Fig. 10.12 on page 302 as an
example. In the ﬁrst picture, all Q values are initialized to zero. In the second
picture, after the ﬁrst action sequence, the four r values which are not equal to zero
become visible as Q values. In the last picture, the learned optimal policy is given.
The following theorem, whose proof is found in [Mit97], shows that this algorithm
converges not just in the example, but in general.
Theorem 10.1 Let a deterministic MDP with limited immediate reward
r(s, a) be given. Equation (10.12) with 0  c < 1 is used for learning. Let
^Qnðs; aÞ be the value for ^Qðs; aÞ after n updates. If each state-action pair is
visited inﬁnitely often, then ^Qnðs; aÞ converges to Q(s, a) for all valuess and a
for n ! ∞.
Proof Since each state-action transition occurs inﬁnitely often, we look at suc-
cessive time intervals with the property that, in every interval, all state-action
transitions occur at least once. We now show that the maximum error for all
entries in the ^Q table is reduced by at least the factor c in each of these
intervals. Let
Q-LEARNING()
For all s ∈S,a ∈A
ˆQ(s,a) = 0 (or randomly)
Repeat
Select (e.g. randomly) a state s
Repeat
Select an action a and carry it out
Obtain reward r and new state s
ˆQ(s,a) := r(s,a) + γ maxa ˆQ(s ,a )
s := s
Until s is an ending state Or time limit reached
Until ˆQ converges
Fig. 10.11 The algorithm for Q-learning
10.6
Q-Learning
301

Dn ¼ max
s;a j^Qnðs; aÞ  Qðs; aÞj
be the maximum error in the table ^Qn and s′ ¼ d(s, a). For each table entry ^Qnðs; aÞ
we calculate its contribution to the error after an interval as
^Qn þ 1 s; a
ð
Þ  Q s; a
ð
Þ

 ¼ jðr þ c max
a0
^Qn s0; a0
ð
ÞÞ  ðr þ c max
a0
Q s0; a0
ð
ÞÞj
¼ cjmax
a0
^Qn s0; a0
ð
Þ  max
a0
Q s0; a0
ð
Þj
 c max
a0
j^Qn s0; a0
ð
Þ  Q s0; a0
ð
Þj
 c max
s00a0 j^Qn s00; a0
ð
Þ  Q s00; a0
ð
Þj ¼ c Dn:
The ﬁrst inequality is true because, for arbitrary functions f and g,
lj max
x
fðxÞ  max
x
gðxÞj  max
x
j fðxÞ  gðxÞj
and the second inequality is true because, by additional variation of the state s00, the
resulting maximum cannot become smaller. Thus it has been shown that Dn+1 
cDn. Since the error in each interval is reduced by a factor of at least c, after
k intervals it is at most ck D0, and, as a result, D0 is bounded. Since each state is
visited inﬁnitely many times, there are inﬁnitely many intervals and Dn converges
to zero.
□
Fig. 10.12 Q-learning applied to the example with nx ¼ 3, ny ¼ 2. The gray arrows mark the
actions carried out in each picture. The updated Q values are given. In the last picture, the current
policy, which is also optimal, is shown
302
10
Reinforcement Learning

According to Theorem 10.1 on page 301 Q-learning converges independently of
the actions chosen during learning. This means that for convergence it does not
matter which actions the agent chooses, as long as each is executed inﬁnitely often.
The speed of convergence, however, certainly depends on which paths the agent
takes during learning (see Sect. 10.7).
10.6.1
Q-Learning in a Nondeterministic Environment
In many robotics applications, the agent’s environment is nondeterministic. This
means that the reaction of the environment to the action a in state s at two different
points in time can result in different successor states and rewards. Such a nondeter-
ministic Markov process is modeled by a probabilistic transition function d(s, a) and
probabilistic immediate reward r(s, a). To deﬁne the Q function, each time the
expected value must be calculated over all possible successor states. Equa-
tion (10.11) on page 300 is thus generalized to
Qðst; atÞ ¼ Eðrðs; aÞÞ þ c
X
s0
Pðs0js; aÞ max
a0
Qðs0; a0Þ;
ð10:13Þ
where Pðs0js; aÞ is the probability of moving from state s to the successor state s0
with action a. Unfortunately there is no guarantee of convergence for Q-learning in
the nondeterministic case if we proceed as before according to (10.12) on page 301.
This is because, in successive runs through the outer loop of the algorithm in
Fig. 10.11 on page 301, the reward and successor state can be completely different
for the same state s and same action a. This may result in an alternating sequence
which jumps back and forth between several values. To avoid this kind of strongly
jumping Q values, we add the old weighted Q value to the right side of (10.12) on
page 301. This stabilizes the iteration. The learning rule then reads
^Qnðs; aÞ ¼ ð1  anÞ^Qn1ðs; aÞ þ an
h
rðs; aÞ þ c max
a0
^Qn1ðdðs; aÞ; a0Þ
i
ð10:14Þ
with a time-varying weighting factor
an ¼
1
1 þ bnðs; aÞ :
The value bn (s, a) indicates how often the action a was executed in state s at the nth
iteration. For small values of bn (that is, at the beginning of learning) the stabilizing
term ^Qn1ðs; aÞ does not come into play, for we want the learning process to make
quick progress. Later, however, bn gets bigger and thereby prevents excessively
large jumps in the sequence of ^Q values. When integrating (10.14) into Q-learning,
the values bn (s, a) must be saved for all state-action pairs. This can be accom-
plished by extending the table of ^Q values.
10.6
Q-Learning
303

For a better understanding of (10.14) on page 303, we simplify this by assuming
an ¼ a is a constant and transforming it as follows:
^Qn s; a
ð
Þ ¼ 1  a
ð
Þ^Qn1 s; a
ð
Þ þ a½r s; a
ð
Þ þ c max
a0
^Qn1 d s; a
ð
Þ; a0
ð
Þ
¼ ^Qn1 s; a
ð
Þ þ a½r s; a
ð
Þ þ c max
a0
^Qn1 d s; a
ð
Þ; a0
ð
Þ  ^Qn1 s; a
ð
Þ:
|ﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄ{zﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄ}
TDerror
The new Q value ^Qnðs; aÞ can clearly be represented as the old ^Qn1ðs; aÞ plus a
times a correction term which is the same as the Q value’s change in this step. The
correction term is called the TD-error, or temporal difference error, and the above
equation for changing the Q value is a special case of TD-Learning, an important
class of learning algorithms [SB98]. For a ¼ 1 we obtain the Q-learning described
above. For a ¼ 0 the ^Q values are completely unchanged. Thus no learning
takes place.
10.7
Exploration and Exploitation
For Q-learning so far, only a coarse algorithm schema has been given. Especially
lacking is a description of the choice of the starting state each time and the actions
to be carried out in the inner loop of Fig. 10.11 on page 301. For the selection of
the next action there are two possibilities. Among the possible actions, one can be
chosen randomly. In the long term this results in a uniform exploration of all
possible actions or policies, but with very slow convergence. An alternative to this
is the exploitation of previously learned ^Q values. Here the agent always chooses
the action with the highest ^Q value. This results in relatively fast convergence of a
speciﬁc trajectory. Other paths, however, remain unvisited all the way to the end. In
the extreme case then we can obtain non-optimal policies. In Theorem 10.1 on
page 301 it is therefore required that every state-action pair is visited inﬁnitely
many times. It is recommended to use a combination of exploration and exploita-
tion with a high exploration portion at the beginning and reduce it more and more
over time.
The choice of the starting state also inﬂuences the speed of learning. In the ﬁrst
three pictures in Fig. 10.12 on page 302 we can clearly see that, for the ﬁrst
iterations, only the Q values in the immediate vicinity of state-action pairs are
changed by immediate reward. Starting farther away from this kind of point results
in much unnecessary work. This suggests transferring prior knowledge about
state-action pairs with immediate reward into starting states nearby these points. In
the course of learning then more distant starting states can be selected.
304
10
Reinforcement Learning

10.8
Approximation, Generalization and Convergence
As Q-learning has been described so far, a table with all Q values is explicitly saved
in a table. This is only possible when working with a ﬁnite state space with ﬁnitely
many actions. If the state space is inﬁnite, however, for example in the case of
continuous variables, then it is neither possible to save all Q values nor to visit all
state-action pairs during learning.
Nonetheless there is a simple way of using Q-learning and value iteration on
continuous variables. The Q(s, a) table is replaced by a neural network, for example
a backpropagation network with the input variables s, a and the Q value as the
target output. For every update of a Q value, the neural network is presented a
training example with (s, a) as input and Q(s, a) as target output. At the end we
have a ﬁnite representation of the function Q(s, a). Since we only ever have ﬁnitely
many training examples, but the function Q(s, a) is deﬁned for inﬁnitely many
inputs, we thus automatically obtain a generalization if the network size is chosen
appropriately (see Chap. 9). Instead of a neural network, we can also use another
supervised learning algorithm or a function approximator such as a support vector
machine or a Gaussian process.
However, the step from ﬁnitely many training examples to a continuous function
can become very expensive in certain situations. Q-learning with function
approximation might not converge because Theorem 10.1 on page 301 is only true
if each state-action pair is visited inﬁnitely often.
However, convergence problems can also come up in the case of ﬁnitely many
state-action pairs when Q-learning is used on a POMDP. Q-learning can be
applied—in both described variants—to deterministic and nondeterministic Markov
processes (MDPs). For a POMDP it can happen that the agent, due to noisy sensors
for example, perceives many different states as one. Often many states in the real
world are purposefully mapped to one so-called observation. The resulting obser-
vation space is then much smaller than the state space, whereby learning becomes
faster and overﬁtting can be avoided (see Sect. 8.4.7).
However, by bundling together multiple states, the agent can no longer differ-
entiate between the actual states, and an action may lead it into many different
successor states, depending on which state it is really in. This can lead to con-
vergence problems for value iteration or for Q-learning. In the literature (e.g.,
in [SB98]) many different approaches to a solution are suggested.
Also very promising are so-called policy improvement methods and their
derived policy gradient methods, in which Q values are not changed, but rather the
policy is changed directly. In this scheme a policy is searched for in the space of all
policies, which maximizes the cumulative discounted reward ((10.1) on page 292).
One possibility of achieving this is by following the gradient of the cumulative
reward to a maximum. The policy found in this way then clearly optimizes the
cumulative reward. In [PS08] it is shown that this algorithm can greatly speed up
learning in applications with large state spaces, such as those which occur for
humanoid robots.
10.8
Approximation, Generalization and Convergence
305

10.9
Applications
The practical utility of reinforcement learning has meanwhile been shown many
times over. From a large number of examples of this, we will brieﬂy present a small
selection.
TD-learning, together with a backpropagation network with 40 to 80 hidden
neurons was used very successfully in TD-gammon, a backgammon-playing pro-
gram [Tes95]. The only immediate reward for the program is the result at the end of
the game. An optimized version of the program with a two-move lookahead was
trained against itself in 1.5 million games. It went on to defeat world-class players
and plays as well as the three best human players.
There are many applications in robotics. For example, in the RoboCup Soccer
Simulation League, the best robot soccer teams now successfully use reinforcement
learning [SSK05, Robb]. Balancing a pole, which is relatively easy for a human,
has been solved successfully many times with reinforcement learning.
An impressive demonstration of the learning ability of robots was given by Russ
Tedrake at IROS 2008 in his presentation about a model airplane which learns to
land at an exact point, just like a bird landing on a branch [Ted08]. Because air
currents become very turbulent during such highly dynamic landing approach, the
associated differential equation, the Navier–Stokes equation, is unsolvable. Landing
therefore cannot be controlled in the classical mathematical way. Tedrake’s com-
ment about this:
“Birds don’t solve Navier–Stokes!”
Birds can clearly learn to ﬂy and land even without the Navier–Stokes equation.
Tedrake showed that this is now also possible for airplanes.
Today it is also possible to learn to control a real car in only 20 minutes using
Q-learning and function approximation [RMD07]. This example shows that real
industrial applications in which few measurements must be mapped to actions can
be learned very well in short time.
Real robots still have difﬁculty learning in high-dimensional state-action spaces
because, compared to a simulation, real robots get feedback from the environment
relatively slowly. Due to time limitations, the many millions of necessary training
cycles are therefore not realizable. Here, besides fast learning algorithms, methods
are needed which allow at least parts of the learning to happen ofﬂine, that is,
without feedback from the environment.
10.10
AlphaGo, the Breakthrough in Go
Although alpha-beta pruning has been used successfully by chess computers, it
cannot achieve the same success in Go programs due to the game’s large branching
factor of roughly 250, as was described in Sect. 6.6.2. It has been known for some
time that in Go the next move should be chosen using pattern recognition
306
10
Reinforcement Learning

algorithms on the current board position. Yet all prior attempts had not been very
successful. This changed when Google DeepMind presented AlphaGo in
[SHM þ16]. This program uses Monte Carlo tree search (MCTS) to generate
training data, deep learning to evaluate board positions and reinforcement learning
to improve its strategy by playing against itself. Roughly sketched, the algorithm
works as follows:
The learning process’s most important goal is to learn a policy p which, for a
position s, calculates the probability p(a|s) of winning for every possible move a. If
this probability function is found, then it will be used in the game such that when in
a position s, the best of all possible moves
a	 ¼ argmax
a
p ajs
ð
Þ
will be chosen. Because the program should play better than its human role model
in the end, it is a multi-stage process to learn a policy p that is as good as possible.
First, using saved champion-level games, two different move selection functions are
learned (stage 1). The stronger of the two will then be further improved using
reinforcement learning (stage 2) and transformed into a position evaluation function
(stage 3). Finally, the program plays by combining the resulting position evaluation
function with the two move selection policies from stage 1 in a complex MCTS
search process.
Stage 1: Deep Learning Based on Saved Games The KGS Go Server contains
many complete Go matches by champion players with a total of thirty million board
positions s and the players’ respective moves a(s). All of these moves are used to
train a convolutional neural network (CNN).
The CNN takes a board position s as input and, after training, should return the
probability prðajsÞ for all legal moves a. The de facto realization of prðajsÞ is a
19  19 matrix, which represents the board. The values for each of the 361 points
on the board stand for the probability of winning for the corresponding move. An
example for the application of such a policy function can be seen in Fig. 10.13 on
page 308. For the board state s left, prðajsÞ is represented in a density graph on the
right. On this turn, the player may set a white stone on one of the points. For nearly
all of the available points, the probability of winning is zero, but for a few inter-
esting points, the probability is represented as a grayscale value. Apparently the
most desirable place to put the stone is in the top middle in row 2, column 11.
During training, the 19  19 board state for each of the thirty million champion
moves in the database is given as input to the network, and the target output is the
19  19 matrix with all values set to null and the square selected by the expert
set to one.
On a holdout set of test data it has not yet seen, the complex thirteen-layer CNN
network used by AlphaGo chooses the correct move up to 57% of the time, which
demonstrates an impressive gain over the best performance to date of about 44% by
other Go programs.
10.10
AlphaGo, the Breakthrough in Go
307

In addition to the policy prðajsÞ, a much simpler rollout policy ppðajsÞ is trained
on the same training data with a simpler CNN. It chooses moves correctly only 24%
of the time, but does calculations about 1000 times faster.
Stage 2: Improving the Learned Policy with Reinforcement Learning Next, the
move selection function is improved using reinforcement learning. This second step
is necessary in order for the program to play better than its human role models.
The policy prðajsÞ learned from the database is used by AlphaGo to play against
itself. After every game, the current policy pqðajsÞ is improved using stochastic
gradient descent. To avoid overﬁtting, AlphaGo does not always play against the
current version, rather against a randomly selected earlier one.
Stage 3: Learning a Position’s Value Next, the current policy pqðajsÞ is used to
train a board state evaluation function V(s) using value iteration (see Sect. 10.4).
The Final AlphaGo Game Policy and its Performance AlphaGo’s actual playing
algorithm uses a complex MCTS algorithm in which the tree is expanded a bit from
the current position. From the leaf nodes thus generated, the game is played to the
end using a fast but simple rollout policy ppðajsÞ. The position is then evaluated
using the simulated game’s outcome together with the value function V(s). Despite
having a very good policy, the computational cost is immense because of the
complexity of this MCTS algorithm. AlphaGo’s highest playing ability, that was
used to defeated Go grandmaster Lee Sedol of Korea 4:1, was reached on a parallel
computer with 1202 CPUs and 176 GPUs.
In summary, AlphaGo represents a great milestone in the history of AI. This
achievement was made possible by using deep learning and by the astounding
engineering effort of a large team of experts in the various areas of machine
learning.
Fig. 10.13 Density graph (right) of a move probability prðajsÞ for the player with white stones in
the board state shown on the left. For each white square, prðajsÞ ¼ 0. The darker the square, the
higher the value for a move by white onto the corresponding grid point
308
10
Reinforcement Learning

10.11
Curse of Dimensionality
Despite success in recent years, reinforcement learning remains an active area of
research in AI, not least because even the best learning algorithms known
today are still impractical for high-dimensional state and action spaces due to
their gigantic computation time. This problem is known as the “curse of
dimensionality”.
In the search for solutions to this problem, scientists observe animals and
humans during learning. Here we notice that learning in nature takes place on many
levels of abstraction. A baby ﬁrst learns simple motor and language skills on the
lowest level. When these are well learned, they are saved and can later be called up
any time and used. Translated into the language of computer science, this means
that every learned ability is encapsulated in a module and then, on a higher level,
represents an action. By using such complex actions on a higher level, the action
space becomes greatly reduced and thus learning is accelerated. In a similar way,
states can be abstracted and thus the state space can be shrunk. This learning on
multiple levels is called hierarchical learning [BM03].
Another approach to modularization of learning is distributed learning, or
multi-agent learning [PL05]. When learning a humanoid robot’s motor skills, up to
50
different
motors
must
be
simultaneously
controlled,
which
results
in
50-dimensional state space and also a 50-dimensional action space. To reduce this
gigantic complexity, central control is replaced by distributed control. For example,
each individual motor could get an individual control which steers it directly, if
possible independently of the other motors. In nature, we ﬁnd this kind of control in
insects. For example, the many legs of a millipede are not steered by a central brain,
rather each pair of legs has its own tiny “brain”.
Similar to uninformed combinatorial search, reinforcement learning has the task
of ﬁnding the best of a huge number of policies. The learning task becomes sig-
niﬁcantly easier if the agent has a more or less good policy before learning begins.
Then the high-dimensional learning tasks can be solved sooner. But how do we ﬁnd
such an initial policy? Here there are two main possibilities.
The ﬁrst possibility is classical programming. The programmer provides the
agent with a policy comprising a program which he considers good. Then a
switchover occurs, for example to Q-learning. The agent chooses, at least at the
beginning of learning, its actions according to the programmed policy and thus is
led into “interesting” areas of the state-action space. This can lead to dramatic
reductions in the search space of reinforcement learning.
If traditional programming becomes too complex, we can begin training the
robot or agent by having a human proscribe the right actions. In the simplest case,
this is done by manual remote-control of the robot. The robot then saves the
proscribed action for each state and generalizes using a supervised learning algo-
rithm such as backpropagation or decision tree learning. This so-called demon-
stration learning [BCDS08, SE10] thus also provides an initial policy for the
subsequent reinforcement learning.
10.11
Curse of Dimensionality
309

10.12
Summary and Outlook
Today we have access to well-functioning and established learning algorithms for
training our machines. The task for the human trainer or developer, however, is still
demanding for complex applications. There are namely many possibilities for how
to structure the training of a robot and it will not be successful without experi-
mentation. This experimentation can be very tedious in practice because each new
learning project must be designed and programmed. Tools are needed here which,
besides the various learning algorithms, also offer the trainer the ability to combine
these with traditional programming and demonstration learning. One of the ﬁrst of
this kind of tool is the Teaching-Box [ESCT09], which in addition to an extensive
program library also offers templates for the conﬁguration of learning projects and
for communication between the robot and the environment. For example, the
human teacher can give the robot further feedback from the keyboard or through a
speech interface in addition to feedback from the environment.
Reinforcement learning is a fascinating and active area of research that will be
increasingly used in the future. More and more robot control systems, but also other
programs, will learn through feedback from the environment. Today there exist a
multitude of variations of the presented algorithms and also completely different
algorithms. The scaling problem remains unsolved. For small action and state
spaces with few degrees of freedom, impressive results can be achieved. If the
number of degrees of freedom in the state space grows to 18, for example for a
simple humanoid robot, then learning becomes very expensive.
For further foundational lectures, we recommend the compact introduction into
reinforcement learning in Tom Mitchell’s book [Mit97]. The standard work by
Sutton and Barto [SB98] is thorough and comprehensive, as is the survey article by
Kaelbling, Littman and Moore [KLM96].
10.13
Exercises
Exercise 10.1
(a) Calculate the number of different policies for n states and n actions. Thus
transitions from each state to each state are possible.
(b) How does the number of policies change in subproblem (a) if empty actions,
i.e., actions from one state to itself, are not allowed.
(c) Using arrow diagrams like those in Fig. 10.3 on page 291, give all policies for
two states.
(d) Using arrow diagrams, give all policies without empty actions for three states.
Exercise 10.2 Use value iteration manually on Example 10.1 on page 289 with
nx ¼ ny ¼ 2.
310
10
Reinforcement Learning

Exercise 10.3 Carry out various experiments using a value iteration simulator.
(a) Install the value iteration simulator from [Tok06].
(b) Reproduce the results from Exercise 10.2 on page 310 by ﬁrst putting in the
feedback with the feedback editor and then carrying out value iteration.
(c) Model surfaces of differing smoothness and observe how the policy changes.
(d) With a similar feedback matrix, enlarge the state space incrementally up to
about 100  100 and ﬁt the discount factor c such that a sensible policy
results.
❄Exercise 10.4 Show that for the example calculation in Fig. 10.8 on page 297 the
exact value is V⋆(3, 3) ¼ 1.9/(1 −0.96)  4.05499.
Exercise 10.5
Carry out Q-learning on the 3  3 grid on the right.
The state in the middle right is an absorbing goal state.
Exercise 10.6 A robot arm with n joints (dimensions) and ‘ discrete states per joint
is given. Actions from each state to each state are possible (if the robot does
nothing, this is evaluated as an (empty) action).
(a) Give a formula for the number of states and the number of actions in each state
and for the number of policies for the robot.
(b) Create a table with the number of strategies for n ¼ 1, 2, 3, 4, 8 and ‘ ¼ 1, 2, 3,
4, 10.
(c) To reduce the number of possible strategies, assume that the number of
possible actions per joint is always equal to 2 and that the robot can only move
one joint at a time. Give a new formula for the number of strategies and create
the associated table.
(d) With the calculated result, justify that an agent which operates autonomously
and adaptively with n ¼ 8 and l ¼ 10 can certainly be called intelligent.
10.13
Exercises
311

11
Solutions for the Exercises
11.1
Introduction
Exercise 1.3 Many well-known inference processes, learning processes, etc. are
NP-complete or even undecidable. What does this mean for AI?
Exercise 1.4 If a problem is NP-complete or can be described as “hard”, that
means that there are instances in which the problem cannot be solved in an
acceptable amount of time. This is the so-called worst case. In some applications
we have to live with the fact that in the worst case an efﬁcient solution is impos-
sible. This means that even in the future there will be practically relevant problems
which in certain special cases are unsolvable.
AI will therefore neither ﬁnd a universal formula, nor build a super machine
with which all problems become solvable. It gives itself rather the task of building
systems with a higher probability of ﬁnding a solution, or with a higher probability
of ﬁnding fast, optimal solutions. We humans in everyday life deal with subop-
timal solutions quite well. The reason is, quite simply, the excessive cost of
ﬁnding the optimal solution. For example, it only takes me seven minutes to ﬁnd
my way from point A to point B with a map in an unfamiliar city. The shortest
path would have taken only six minutes. Finding the shortest path, however,
would have taken perhaps an hour. The proof of the optimality of the path might
be even costlier.
Exercise 1.5
(a) The output depends not only on the input, but also on the contents of the
memory. For an input x, depending on the contents of the memory, the output
could be y1 or y2. It is thus not unique and therefore not a function.
(b) If one considers the contents of the memory as a further input, then the output is
unique (because the agent is deterministic) and the agent represents a function.
© Springer International Publishing AG 2017
W. Ertel, Introduction to Artificial Intelligence, Undergraduate Topics
in Computer Science, DOI 10.1007/978-3-319-58487-4_11
313

Exercise 1.6
(a) Velocity vxðtÞ ¼ @x
@t ¼ lim
Dt!0
xðtÞ  xðt  DtÞ
Dt
 xðtÞ  xðt  DtÞ
Dt
. vy is calculated
analogously.
(b) Acceleration axðtÞ ¼ @2x
@t2 ¼ @
@t vxðtÞ ¼ lim
Dt!0
vxðtÞ  vxðt  DtÞ
Dt
¼ lim
Dt!0
xðtÞ  xðt  DtÞ
ðDtÞ2

"
xðt  DtÞ  xðt  2DtÞ
ðDtÞ2
#
¼ xðtÞ  2xðt  DtÞ þ xðt  2DtÞ
ðDtÞ2
. ay
is calculated analo-
gously. One also needs the position at the three times t −2Dt, t −Dt, t.
Exercise 1.7
(a) Costs for agent 1 = 11 ⋅100 cents + 1 ⋅1 cent = 1,101 cents.
Costs for 2 = 0 ⋅100 cents + 38 ⋅1 cent = 38 cents.
Therefore agent 2 saves 1,101 cents −38 cents = 1,063 cents.
(b) Proﬁt for agent 1 = 189 ⋅100 cents + 799 ⋅1 cent = 19,699 cents.
Proﬁt for agent 2 = 200 ⋅100 cents + 762 ⋅1 cent = 20,762 cents.
Agent 2 therefore has 20,762 cents −19,699 cents = 1,063 cents higher proﬁt.
If one assesses the lost proﬁts due to errors, the utility-based agent makes the
same decisions as a cost-based agent.
11.2
Propositional Logic
Exercise 2.1 With the signature R = {r1, r2, …, rn} and the grammar variables
〈formula〉, the syntax of propositional logic can be deﬁned as follows:
h formulai :: ¼ r1 r2
j
j    rn
j
jwj f
:h formulai
j
j hformulai
ð
Þjh formulai ^ hformulai
hformulai _ hformulai
j
jh formulai ) hformulai
hformulai , hformulai
j
Exercise 2.2 Proof by the truth table method.
Exercise 2.3 (a) (¬A _ B) ^ (¬B _ A)
(b) (¬A _ B) ^ (¬B _ A)
(c) t
Exercise 2.4 (a) satisﬁable
(b) true
(c) unsatisﬁable
Exercise 2.6
(a) In Exercise 2.3(c) it was already shown that A ^ (A ) B) ) B is a tautology.
The deduction theorem thus ensures the correctness of the inference rule.
(b) We show by the truth table method that (A _ B) ^ (¬B _ C) ) (A _ C) is a
tautology.
Exercise 2.7 Application of the resolution rule to the clause (f _ B) and (¬B _ f)
yields the resolvent (f _ f)  (f). Now we apply the resolution rule to the clauses
B and ¬B and obtain the empty clause as the resolvent. Because (f _ B)  B and
314
11
Solutions for the Exercises

(¬B _ f)  ¬B, (f)  (). It is important in practice that, whenever the empty clause is
derived, it is due to a contradiction.
Exercise 2.8 If KB contains a contradiction, then there are two clauses A and ¬A,
which allow the empty clause to be derived. The contradiction in KB is clearly still
in KB ^ ¬Q. Therefore it also allows the empty clause to be derived.
Exercise 2.9 (a) (A _ B) ^ (¬A _ ¬B)
(b) (A _ B) ^ (B _ C) ^ (A _ C)
Exercise 2.10 Formalization: Accomplice: A, Car: C, Key: K
WB  ðA ) CÞ ^ ½ð:A ^ :KÞ _ ðA ^ KÞ ^ K
Transformation into CNF: (¬A ^ ¬K) _ (A ^ K)  (¬K _ A) ^ (¬A _ K)
Try to prove C and add ¬C to the set of clauses. The CNF clause set is
ð:A _ CÞ1 ^ ð:K _ AÞ2 ^ ð:A _ KÞ3 ^ ðKÞ4 ^ ð:CÞ5:
Resolution proof: Resð2; 4Þ : ðAÞ6
Resð1; 6Þ : ðCÞ7
Resð7; 5Þ : ðÞ8
Thus C has been shown.
Exercise 2.11
(a) KB  (A _ B) ^ (¬B _ C), Q  (A _ C)
KB ^ ¬Q  (A _ B)1 ^ (¬B _ C)2 ^ (¬A)3 ^ (¬C)4
Resolution proof: Resð1; 3Þ : ðBÞ5
Resð2; 4Þ : ð:BÞ6
Resð5; 6Þ : ðÞ
(b) ¬(¬B ^ (B _ ¬A) ) ¬A)  (¬B)1 ^ (B _ ¬A)2 ^ (A)3
Resolution proof: Resð1; 2Þ : ð:AÞ4
Resð3; 4Þ : ðÞ
Exercise 2.12 By application of the equivalences from Theorem 2.1 on page 26,
we can immediately prove the claims.
Exercise 2.13
Resð8; 9Þ :
C ^ F ^ E ) f
ð
Þ10
Resð3; 10Þ :
F ^ E ) f
ð
Þ11
Resð6; 11Þ :
A ^ B ^ C ^ E ) f
ð
Þ12
Resð1; 12Þ :
B ^ C ^ E ) f
ð
Þ13
Resð2; 13Þ :
C ^ E ) f
ð
Þ14
Resð3; 14Þ :
E ) f
ð
Þ15
Resð5; 15Þ : ðÞ
11.2
Propositional Logic
315

11.3
First-Order Predicate Logic
Exercise 3.1
(a) 8x male(x) , ¬female(x)
(b) 8x 8y 9z father(x, y) , male(x) ^ child(y, x, z)
(c) 8x 8y siblings(x, y) , [(9z father(z, x) ^ father(z, y)) _ (9z mother(z, x) ^
mother(z, y))]
(d) 8x 8y 8z parents(x, y, z) , father(x, z) ^ mother(y, z)
(e) 8x 8y uncle(x, y) , 9z 9u child(y, z, u) ^ siblings(z, x) ^ male(x)
(f)
8x 8y ancestorðx; yÞ , 9z childðy; x; zÞ _ 9u 9v childðu; x; vÞ ^ ancestorðu; yÞÞ
Exercise 3.2
(a) 8x 9y 9z father(y, x) ^ mother(z, x)
(b) 9x 9y child(y, x, z)
(c) 8x bird(x) ) ﬂies(x)
(d) 9x 9y 9z animal(x) ^ animal(y) ^ eats(x, y) ^ eats(y, z) ^ grain(z)
(e) 8x animal(x) ) (9y (eats(x, y) ^ (plant(y) _ (animal(y) ^ 9z plant(z) ^ eats
(y, z) ^ much_smaller(y, x)))
Exercise 3.3 8x 8y 9z x = father(y) , male(x) ^ child(y, x, z)
Exercise 3.4
∀x ∀y x < y ∨y < x ∨x = y,
∀x ∀y x < y ⇒¬y < x,
∀x ∀y ∀z x < y ∧y < z ⇒x < z
Exercise 3.5
(a) MGU: x / f(z), u / f(y), term: p(f(z), f(y))
(b) not uniﬁable
(c) MGU: x / cos y, z / 4 −7 ⋅cos y, term: cos y = 4 −7 ⋅cos y
(d) not uniﬁable
(e) MGU: u=fðgðw; wÞ; gðgðw; wÞ; gðw; wÞÞ; gðgðgðw; wÞ; gðw; wÞÞ; gðgðw; wÞ; gðw; wÞÞÞÞ
x=gðw; wÞ; y=gðgðw; wÞ; gðw; wÞÞ z=gðgðgðw; wÞ; gðw; wÞÞ; gðgðw; wÞ; gðw; wÞÞÞ
term: qðfðgðw; wÞ; gðgðw; wÞ; gðw; wÞÞ; gðgðgðw; wÞ; gðw; wÞÞ; gðgðw; wÞ; gðw; wÞÞÞÞ;
fðgðw; wÞ; gðgðw; wÞ; gðw; wÞÞ; gðgðgðw; wÞ; gðw; wÞÞ; gðgðw; wÞ; gðw; wÞÞÞÞÞ
Exercise 3.7
(a) Let the unsatisﬁable formula p(x) ^ ¬p(x) ^ r(x) be given. We choose the
clause r(x) as the SOS, so no contradiction can be derived.
(b) If the SOS is already unsatisﬁable, then no contradiction can be derived. If not,
then resolution steps between clauses from SOS and (KB ^ ¬Q)\SOS are
necessary.
316
11
Solutions for the Exercises

(c) If there is no complement to a literal L in a clause K, then the literal L will remain
in every clause that is derived using resolution from clause K. Thus the empty
clause cannot be derived from K or its resolvent, nor any future resolvent.
Exercise 3.8 ¬Q ^ KB  (e = n)1 ^ (n ⋅x = n)2 ^ (e ⋅x = x)3 ^ (¬a = b)4
Proof : Demð1; 2Þ :
ðe  x ¼ eÞ5
Tra,Symð3; 5Þ : ðx ¼ eÞ6
Demð4; 6Þ :
ð:e ¼ bÞ7
Demð7; 6Þ :
ð:e ¼ eÞ8
ðÞ
Here “Dem” stands for demodulation. Clause number 6 was derived by application
of transitivity and symmetry of the equality in clauses 3 and 5. The empty clause is
obtained by applying the reﬂexive propery of equality to e, which yields ðe ¼ eÞ,
and, via resolution with clause 8, results in the empty clause.
Exercise 3.9 The LOP input ﬁles are:
(a) a;b<-.
<-a,b.
b;c<-.
<-b,c.
c;a<-.
<-c,a.
(b) <- shaves(barb,X),
shaves(X,X).
shaves(barb,X);
shaves(X,X) <-.
(c) e = n.
<- a = b.
m(m(X,Y),Z)=m(X,m(Y,Z)).
m(e,X) = X.
m(n,X) = n.
11.4
Limitations of Logic
Exercise 4.1
(a) Correctly: We take a complete proof calculus for PL1. With it we ﬁnd a proof
for every true formula in ﬁnite time. For all unsatisﬁable formulas I proceed
as follows: I apply the calculus to ¬/ and show that ¬/ is true. Thus / is
false. Thus we can prove every true formula from PL1 and refute every false
formula. Unfortunately, this process is unsuitable for satisﬁable formulas.
Exercise 4.2
(a) He shaves himself if and only if he does not shave. (contradiction)
(b) The set of all sets which do not contain themselves. It contains itself if and
only if it does not contain itself.
11.5
PROLOG
Exercise 5.1 PROLOG signals a stack overﬂow. The reason is PROLOG’s
depth-ﬁrst search, which always chooses the ﬁrst uniﬁable predicate in the input ﬁle.
With recursive predicates such as equality, this causes a non-terminating recursion.
11.3
First-Order Predicate Logic
317

Exercise 5.2
Exercise 5.3
(a) It is needed to output the solutions found. The uniﬁcation in the fact
plan(Goal,Goal,Path,Path). takes care of this.
(b) The conditions for entry into the clauses of the predicate safe overlap each
other. The backtracking caused by the fail leads to the execution of the
second or third alternative of safe, where the same solution will clearly be
found again. A cut at the end of the ﬁrst two safe clauses solves the problem.
Alternatively, all safe states can be explicitly given, as for example safe
(state(left,left,left,right)).
Exercise 5.5
Exercise 5.6
(a) With n1 ¼ | L1|, n2 ¼ |L2| it is true that Tappendðn1; n2Þ ¼ Hðn1Þ.
(b) With n ¼ |L| it is true that TnrevðnÞ ¼ Hðn2Þ.
(c) With n ¼ |L| it is true that TaccrevðnÞ ¼ HðnÞ.
Exercise 5.7 For the trees with symbols on the inner nodes, we can use the terms
a(b,c) and a(b(e,f,g),c(h),d), for example. Trees without symbols:
tree(b,c), or tree(tree(e,f,g),tree(h),d).
Exercise 5.8 SWI-PROLOG programs:
(a) ﬁb(0,1). ﬁb(1,1).
ﬁb(N,R) :- N1 is N-1, ﬁb(N1, R1), N2 is N-2,
ﬁb(N2,R2), R is R1 + R2.
(b) T(n) = H(2n).
(c) :- dynamic ﬁb/2. ﬁb(0,1). ﬁb(1,1).
ﬁb(N,R) :- N1 is N-1, ﬁb(N1, R1), N2 is N-2,
ﬁb(N2,R2), R is R1 + R2,
asserta(ﬁb(N,R)).
write_path( [H1,H2|T] ) :- write_path([H2|T]), write_move(H2,H1).
write_path( [_X] ).
write_move( state(X,W,Z,K), state(Y,W,Z,K) ) :-
write(’Farmer from ’), write(X), write(’ to ’), write(Y), nl.
write_move( state(X,X,Z,K), state(Y,Y,Z,K) ) :-
write(’Farmer and wolf from ’), write(X), write(’ to ’), write(Y),nl.
write_move( state(X,W,X,K), state(Y,W,Y,K) ) :-
write(’Farmer and goat from ’),write(X),write(’ to ’), write(Y), nl.
write_move( state(X,W,Z,X), state(Y,W,Z,Y) ) :-
write(’Farmer and cabbage from ’),write(X),write(’ to ’), write(Y), nl.
?- one(10).
one(0) :- write(1).
one(N) :- N1 is N-1, one(N1), one(N1).
318
11
Solutions for the Exercises

(d) If the facts ﬁb(0,1) to ﬁb(k,fib(k)) were already calculated, then for the
call ﬁb(n,X) it is true that
TðnÞ ¼
H 1
ð Þ
if n  k;
H n  k
ð
Þ
if n [ k:

(e) Because after the ﬁrst n calls to the ﬁb predicate, all further calls have direct
access to facts.
Exercise 5.9
(a) The solution is not disclosed here.
(b)
11.6
Search, Games and Problem Solving
Exercise 6.1
(a)
On the last level there are bd nodes. All previous levels together have
NbðdmaxÞ ¼
X
d1
i¼0
bi ¼ bd  1
b  1  bd1
nodes, if b becomes large. Because bd /bd−1 = b there are about b times as
many nodes on the last level as on all other levels together.
start :-
fd_domain([Briton, Swede, Dane, Norwegian, German],1,5),
fd_all_different([Briton, Swede, Dane, Norwegian, German]),
fd_domain([Tea, Coffee, Water, Beer, Milk],1,5),
fd_all_different([Tea, Coffee, Water, Beer, Milk]),
fd_domain([Red, White, Green, Yellow, Blue],1,5),
fd_all_different([Red, White, Green, Yellow, Blue]),
fd_domain([Dog, Bird, Cat, Horse, Fish],1,5),
fd_all_different([Dog, Bird, Cat, Horse, Fish]),
fd_domain([Pallmall, Dunhill, Marlboro, Winfield, Rothmanns],1,5),
fd_all_different([Pallmall, Dunhill, Marlboro, Winfield, Rothmanns]),
fd_labeling([Briton, Swede, Dane, Norwegian, German]),
Briton #= Red,
% The Briton lives in the red house
Swede #= Dog,
% The Swede doesn’t have a dog
Dane #= Tea,
% The Dane likes to drink tea
Green #= White - 1,
% The green house is to the left of the white house
Green #= Coffee,
% The owner of the green house drinks coffee
Pallmall #= Bird,
% The person who smokes Pall Mall has a bird
k
l
i
m
s
k
n
i
r
d
e
s
u
o
h
e
l
d
d
i
m
e
h
t
n
i
n
a
m
e
h
T
%
,
3
=
#
k
l
i
M
Yellow #= Dunhill,
% The owner of the yellow house smokes Dunhill
Norwegian #= 1,
% The Norwegian lives in the first house
dist(Marlboro,Cat)#= 1,
% The Marlboro smoker lives next to the cat
dist(Horse,Dunhill) #= 1,
% The man with the horse lives next to the Dunhill smoker
Winfield #= Beer,
% The Winfield smoker likes to drink beer
dist(Norwegian,Blue) #= 1, % The Norwegian lives next to the blue house
German #= Rothmanns,
% The German smokes Rothmanns
dist(Marlboro,Water)#=1,
% The Marlboro smoker’s neighbor drinks water.
write([Briton, Swede, Dane, Norwegian, German]), nl,
write([Dog, Bird, Cat, Horse, Fish]), nl.
11.5
PROLOG
319

(b)
For a non-constant branching factor this statement is no longer true, as the
following counter-example shows: A tree that branches heavily up to the
level before last, followed by a level with a constant branching factor of 1,
has exactly as many nodes on the last level as on the level before last.
Exercise 6.2
(a) In Fig. 6.3 on page 94 the structure of the tree at the second level with its eight
nodes repeats. Thus we can calculate the average branching factor bm from
b2
m ¼ 8 to bm ¼
ﬃﬃﬃ
8
p
.
(b) Here the calculation is not so simple because the root node of the tree branches
more heavily than all others. We can say, however, that in the interior of the
tree the branching factor is exactly 1 smaller than it would be without the cycle
check. Thus bm 
ﬃﬃﬃ
8
p
 1  1:8.
Exercise 6.3
(a) For the average branching factor the number of leaf nodes is ﬁxed. For the
effective branching factor, in contrast, the number of nodes in the whole tree is
ﬁxed.
(b) Because the number of all nodes in the tree is usually a better measurement of
the computation time for searching an entire tree than the number of leaf nodes.
(c) For a large b according to (6.1) on page 96 we have n  bd þ 1=b ¼ bd,
yielding b ¼
ﬃﬃﬃn
dp .
Exercise 6.4
(a) 3-puzzle: 4! = 24 states, 8-puzzle: 9! = 362 880 states,
15-puzzle: 16! = 20 922 789 888 000 states.
(b) After moving the empty square 12 times in the clockwise direction we reach
the starting state again and thus create a cyclical sub-space with 12 states.
Exercise 6.6 (a) Mathematica program:
0 BreadthFirstSearch[Node_, Goal_, Depth_] := Module[{i, NewNodes={}},
1
For[i=1, i<= Length[Node], i++,
2
NewNodes = Join[ NewNodes, Successors[ Node[[i]] ] ];
3
If[MemberQ[Successors[ Node[[i]] ], Goal],
4
Return[{"Solution found", Depth+1}], 0
5
]
6
];
7
If[Length[NewNodes] > 0,
8
BreadthFirstSearch[NewNodes, Goal, Depth+1],
9
Return[{"Fail", Depth}]
10
]
11 ]
(b) Because the depth of the search space is not limited.
320
11
Solutions for the Exercises

Exercise 6.7
(a) For a constant cost 1 the cost of all paths at depth d are smaller than the costs
of all paths at depth d + 1. Since all nodes at depth d are tested before the ﬁrst
node at depth d + 1, a solution of length d is guaranteed to be found before a
solution of length d + 1.
(b) For the neighboring search tree, node number 2 and the
solution node number 3 of cost 10 are generated ﬁrst. The
search terminates. The nodes 4 and 5 with path costs of 2
each are not generated. The optimal solution is therefore not
found.
Exercise 6.8
(a) It is appropriate to store the predecessor nodes of the current search path
in a linked list. This has the advantage that during expansion only one
node must be appended and during backtracking only one node must
be deleted.
(b) A look at Fig. 6.9 on page 100 shows that without the cycle check, and thus
without storing the predecessor nodes, we must store Hððb  1Þ  dÞ nodes.
When storing all predecessors in the tree structure, Hðb  dÞ storage space is
necessary because at each level all nodes must be stored.
(c)
X
d
k¼1
k  bk ¼ b d
db
X
d
k¼1
bk ¼ b d
db
bd þ 1  b
b  1
¼
b
ðb  1Þ2 ðdbd þ 1  ðd þ 1Þbd þ 1Þ
¼ H
b
b2 dbd þ 1


¼ HðdbdÞ
Exercise 6.11
(a) Let dHðx; yÞ be the shortest distance from x to y. Then a path from x over z to
y cannot be even shorter. Then dHðx; yÞ  dHðx; zÞ þ dHðz; yÞ.
(b) If the only direct connection between x and y is a curvy mountain pass,
then it can be shorter to drive from x to y through z. Use a sketch to
illustrate this.
Exercise 6.13 Depth-ﬁrst search: the new node must have a lower rating than all
open nodes. Breadth-ﬁrst search: the new node must have a higher rating than all
open nodes.
Exercise 6.14 Just like an admissible heuristic, the wife underestimates the dis-
tance to the goal. This could result in the two of them ﬁnding the quickest way to
the goal—though with great effort. This is only true, however, if the lady always
underestimates the distance.
11.6
Search, Games and Problem Solving
321

Exercise 6.16
(a)
11.7
Reasoning with Uncertainty
Exercise 7.1
1. PðXÞ ¼ jXj
jXj ¼ 1.
2. P(;) = 1 −P(X) = 0.
3. For
pairwise
exclusive
events
A
and
B:
PðA _ BÞ ¼ jA _ Bj
jXj
¼ jAj þ jBj
jXj
¼
PðAÞ þPðBÞ.
4. For two complementary events A and ¬A: PðAÞ þ Pð:AÞ ¼ PðAÞ þ PðX  AÞ ¼
jAj
jXj þ jXAj
jXj ¼ jXj
jXj ¼ 1.
5. PðA _ BÞ ¼ jA _ Bj
jXj
¼ jAj þ jBjjA ^ Bj
jXj
¼ PðAÞ þ PðBÞ  PðA ^ BÞ.
6. For A  B: PðAÞ ¼ jAj
jXj  jBj
jXj ¼ PðBÞ.
7. According to Deﬁnition 7.1 on page 127: A1 _ ⋅⋅⋅_ An =X and Pn
i¼1 PðAiÞ ¼
Pn
i¼1
jAij
jXj ¼
Pn
i¼1 jAij
jXj
¼ jA1 _  _ Anj
jXj
¼ jXj
jXj ¼ 1.
Exercise 7.2
ðaÞ
P y [ 3 j Class ¼ good
ð
Þ ¼ 7=9
P Class ¼ good
ð
Þ ¼ 9=13 P y [ 3
ð
Þ ¼ 7=13;
P Class ¼ good j y [ 3
ð
Þ ¼ P y [ 3 j Class ¼ good
ð
Þ  P Class ¼ good
ð
Þ
P y [ 3
ð
Þ
¼ 7=9  9=13
7=13
¼ 1;
P Class ¼ good j y  3
ð
Þ ¼ P y  3 j Class ¼ good
ð
Þ  P Class ¼ good
ð
Þ
P y  3
ð
Þ
¼ 2=9  9=13
6=13
¼ 1
3 :
(b) P(y > 3 | Class = good) = 7/9.
322
11
Solutions for the Exercises

Exercise 7.3
(a) eight events.
(b)
PðPrec ¼ dryjSky ¼ clear; Bar ¼ risingÞ
¼ PðPrec ¼ dry; Sky ¼ clear; Bar ¼ risingÞ
PðSky ¼ clear; Bar ¼ risingÞ
¼ 0:4
0:47 ¼ 0:85:
(c) Missing row in the table:
P Prec ¼ rainingjSky ¼ cloudy
ð
Þ ¼ P Prec ¼ raining; Sky ¼ cloudy
ð
Þ
P Sky ¼ cloudy
ð
Þ
¼ 0:23
0:35 ¼ 0:66:
(d) The missing probability measure is 0.15. The indifference principle (Deﬁni-
tion 7.5 on page 140) now requires that both missing rows be symmetrically
allocated the value 0.075.
Exercise 7.4
The candidate ﬁrst chose door number 1. Then the host
opened door number 3. We introduce the abbreviation Ai
for “Car is behind door number i (before the experiment
begins)
and
Mi
for
“Host
(moderator)
opens
door
number i”. Then P(A1) = P(A2) = P(A3) = 1/3 and we
compute
P A1 M3
j
ð
Þ ¼ P M3 A1
j
ð
ÞP A1
ð
Þ
P M3
ð
Þ
¼
P M3 A1
j
ð
ÞP A1
ð
Þ
P M3 A1
j
ð
ÞP A1
ð
Þ þ P M3 A2
j
ð
ÞP A2
ð
Þ þ P M3 A3
j
ð
ÞP A3
ð
Þ
¼
1=2  1=3
1=2  1=3 þ 1  1=3 þ 0  1=3 ¼ 1=2  1=3
1=2
¼ 1=3;
P A2 M3
j
ð
Þ ¼ P M3 A2
j
ð
ÞP A2
ð
Þ
P M3
ð
Þ
¼ 1  1=3
1=2
¼ 2=3:
Thus it is clear that it is better to switch to the other door.
Cloudy
Falling
Raining
0.12
11.7
Reasoning with Uncertainty
323

Exercise 7.5 The Lagrange function reads L ¼  Pn
i¼1 pi ln pi þ kðPn
i¼1 pi  1Þ.
Setting the partial derivatives with respect to pi and pj equal to zero yields
@L
@pi
¼  ln pi  1 þ k ¼ 0
and
@L
@pj
¼  ln pj  1 þ k ¼ 0:
Subtraction of these two equations results in pi = pj for all i, j 2 {1,…,n}. Thus
p1= p2 = ⋅⋅⋅= pn = 1/n.
Exercise 7.6
Because PIT operates numerically, it cannot compute symbolically with the
parameters a and b, rather only with concrete numbers.
Exercise 7.7
If: p1 ¼ P(A, B), p2 ¼ P(A, ¬B), p3 ¼ P(¬A, B), p4 ¼ P(¬A, ¬B)
The constraints are : p1 þ p2 ¼ a
ð11:1Þ
p4 ¼ 1  b
ð11:2Þ
p1 þ p2 þ p3 þ p4 ¼ 1
ð11:3Þ
It follows that p3 = b −a. From (11.1) we infer, based on indifference, that
p1 = p2 = a/2. Thus P(B) = p1 + p3 = a/2 + b −a = b −a/2 = P(A _ B) −1/2P(A).
The corresponding PIT program reads
var A{t,f}, B{t,f};
P([A=t]) = 0.6;
P([B=t] OR [A=t]) = 0.94;
QP([B=t]).
Exercise 7.8 The Lagrange function reads
L ¼ 
X
4
i¼1
pi ln pi þ k1ðp1 þ p2  aÞ þ k2ðp1 þ p3  cÞ þ k3ðp1 þ p2 þ p3 þ p4  1Þ:
ð11:4Þ
PIT input data:
var A{t,f}, B{t,f};
P([A=t]) = 0.5;
P([B=t] | [A=t]) = 0.94;
QP([B=t]);
PIT output:
Reporting State of Queries
Nr Truthvalue Probability Query
1 UNSPECIFIED 7.200e-01 QP([B=t]);
324
11
Solutions for the Exercises

Taking partial derivatives for p1, p2, p3, p4 we obtain
@L
@p1
¼  ln p1  1 þ k1 þ k2 þ k3 ¼ 0;
ð11:5Þ
@L
@p2
¼  ln p2  1 þ k1 þ k3 ¼ 0;
ð11:6Þ
@L
@p3
¼  ln p3  1 þ k2 þ k3 ¼ 0;
ð11:7Þ
@L
@p4
¼  ln p4  1 þ k3 ¼ 0
ð11:8Þ
and compute
11:5
ð
Þ 11:6
ð
Þ : ln p2  ln p1 þ k2 ¼ 0;
ð11:9Þ
11:7
ð
Þ 11:8
ð
Þ : ln p4  ln p3 þ k2 ¼ 0;
ð11:10Þ
from which it follows that p3 / p4 = p1/p2, which we immediately substitute into
(7.12) on page 143:
p2p3
p4
þ p2 þ p3 þ p4 ¼ 1
,
p2

1 þ p3
p4

þ p3 þ p4 ¼ 1
(7.10)(7.11):
p2 ¼ p3 þ a  c
ð11:11Þ
which, substituted for p2, yields ðp3 þ a  cÞð1 þ p3
p4Þ þ p3 þ p4 ¼ 1
(7.10) in (7.12):
a þ p3 þ p4 ¼ 1:
ð11:12Þ
Thus we eliminate p4 in (11.8), which results in
p3 þ a  c
ð
Þ 1 þ
p3
1  a  p3


þ 1  a ¼ 1
ð11:13Þ
, p3 þ a  c
ð
Þ 1  a  p3 þ p3
ð
Þ ¼ a 1  a  p3
ð
Þ
ð11:14Þ
, p3 þ a  c
ð
Þ 1  a
ð
Þ ¼ a 1  a  p3
ð
Þ
ð11:15Þ
11.7
Reasoning with Uncertainty
325

, p3 þ a  c  ap3  a2 þ ac ¼ a  a2  ap3
ð11:16Þ
, p3 ¼ c 1  a
ð
Þ:
ð11:17Þ
With (11.12) on page 325 it follows that p4 = (1 −a)(1 −c) and with (11.11) on
page 325 we obtain p2 = a(1 −c) and p1 = ac.
Exercise 7.9
(a)
M ¼
0
1000
10
0


:
(b)
M 
p
1  p


¼
1000  ð1  pÞ
10  p


:
Because the decision between delete or read is found by establishing the minimum
of the two values, it is sufﬁcient to compare the two values: 1000(1 −p) < 10p,
which results in p > 0.99. In general, for a matrix M ¼
 0 k
1 0
 we compute the
threshold k/(k + 1).
Exercise 7.10
(a) Because A and B are independent, P(A|B) = P(A) = 0.2.
(b) By applying the conditioning rule (page 176) we obtain
PðCjAÞ ¼ PðCjA; BÞPðBÞ þ PðCjA; :BÞPð:BÞ ¼ 0:2  0:9 þ 0:1  0:1 ¼ 0:19:
Exercise 7.11
(a)
P Al
ð
Þ ¼ P Al; Bur; Ear
ð
Þ þ P Al; :Bur; Ear
ð
Þ
þ P Al; Bur; :Ear
ð
Þ þ P Al; :Bur; :Ear
ð
Þ
¼ P AljBur; Ear
ð
ÞP Bur; Ear
ð
Þ þ P Alj:Bur; Ear
ð
ÞP :Bur; Ear
ð
Þ
þ P AljBur; :Ear
ð
ÞP Bur; Ear
ð
Þ
þ P Alj:Bur; :Ear
ð
ÞP :Bur; :Ear
ð
Þ
¼ 0:95  0:001  0:002 þ 0:29  0:999  0:002 þ 0:94  0:001  0:998
þ 0:001  0:999  0:998
¼ 0:00252;
P J
ð Þ ¼ P J; Al
ð
Þ þ P J; :Al
ð
Þ ¼ P JjAl
ð
ÞP Al
ð
Þ þ P Jj:Al
ð
ÞP :Al
ð
Þ
¼ 0:9  0:0025 þ 0:05  1  0:0025
ð
Þ ¼ 0:052;
P M
ð
Þ ¼ P M; Al
ð
Þ þ P M; :Al
ð
Þ ¼ P MjAl
ð
ÞP Al
ð
Þ þ P Mj:Al
ð
ÞP :Al
ð
Þ
¼ 0:7  0:0025 þ 0:01  1  0:0025
ð
Þ ¼ 0:0117:
326
11
Solutions for the Exercises

(b)
P AljBur
ð
Þ ¼ P AljBur; Ear
ð
ÞP Ear
ð
Þ þ P AljBur; :Ear
ð
ÞP :Ear
ð
Þ
¼ 0:95  0:002 þ 0:94  0:998 ¼ 0:94002;
P MjBur
ð
Þ ¼ P M; Bur
ð
Þ=P Bur
ð
Þ ¼ P M; Al; Bur
ð
Þ þ P M; :Al; Bur
ð
Þ
½

=P Bur
ð
Þ
¼ P MjAl
ð
ÞP AljBur
ð
ÞP Bur
ð
Þ þ P Mj:Al
ð
ÞP :AljBur
ð
ÞP Bur
ð
Þ
½

=P Bur
ð
Þ
¼ P MjAl
ð
ÞP AljBur
ð
Þ þ P Mj:Al
ð
ÞP :AljBur
ð
Þ
¼ 0:7  0:94002 þ 0:01  0:05998 ¼ 0:659:
(c)
PðBurjMÞ ¼ PðMjBurÞPðBurÞ
PðMÞ
¼ 0:659  0:001
0:0117
¼ 0:056:
(d)
(e) P(J)P(M) = 0.052 ⋅0.0117 = 0.00061, but P(J, M) = 0.00208 (see above).
Therefore P(J)P(M) 6¼ P(J, M).
P(Al|J,M) = P(Al,J,M)
P(J,M)
=
P(Al,J,M)
P(Al,J,M) + P(¬Al,J,M)
=
1
1 + P(¬Al,J,M)
P(Al,J,M)
=
1
1 + P(J|¬Al)P(M|¬Al)P(¬Al)
P(J|Al)P(M|Al)P(Al)
=
1
1 + 0.05·0.01·0.9975
0.9·0.7·0.0025
= 0.761,
P(J,M|Bur) = P(J,M|Al)P(Al|Bur) + P(J,M|¬Al)P(¬Al|Bur))
= P(J|Al)P(M|Al)P(Al|Bur)
+ P(J|¬Al)P(M|¬Al)P(¬Al|Bur))
= 0.9 · 0.7 · 0.94 + 0.05 · 0.01 · 0.06 = 0.5922,
P(Al|¬Bur) = P(Al|¬Bur,Ear)P (Ear) + P(Al|¬Bur,¬Ear)P(¬Ear)
= 0.29 · 0.002 + 0.001 · 0.998 = 0.00158,
P(J,M|¬Bur) = P(J,M|Al)P(Al|¬Bur) + P(J,M|¬Al)P(¬Al|¬Bur))
= P(J|Al)P(M|Al)P(Al|¬Bur)
+ P(J|¬Al)P(M|¬Al)P(¬Al|¬Bur))
= 0.9 · 0.7 · 0.00158 + 0.05 · 0.01 · 0.998 = 0.00149,
P(J,M) = P(J,M|Bur)P (Bur) + P(J,M|¬Bur)P(¬Bur)
= 0.5922 · 0.001 + 0.00149 · 0.999 = 0.00208,
P(Bur|J,M) = P(J,M|Bur)P(Bur)
P(J,M)
= 0.5922 · 0.001/0.00208 = 0.284.
11.7
Reasoning with Uncertainty
327

(f) See Sect. 7.4.5 on page 163.
(g)
Other
solutions
are
possible
due
to
the
counterproductive vari-
able
order.
Thus
we
learn:
Always
use
a
variable
order
that
respects causality!
(h) Only the CPT of
the
alarm
node
changes.
All
of
the
other
nodes
are independent of
earthquake
or
independent
of
earthquake
given
alarm.
Bur
P(Al)
t
0.94
f
0.0016
(i)
Mary
John
Alarm
Earthquake
Burglary
Exercise 7.12
(a), (b) See Fig. 11.1.
(c) The edge (Str, Li) is missing because Li and Str are conditionally independent
given V, i.e., P(Li|V, Str) = P(Li|V) because the street condition has no direct
inﬂuence on the light, rather only over the dynamo and the voltage it generates. (The
conditional independence Li and Str given V cannot be shown here by calculation
based on available data for P(Li|V, Str) and P(Li|V), rather it can only be asserted.)
(d) For the given CPTs:
P RjStr
ð
Þ ¼ P RjStr; Flw
ð
ÞP Flw
ð
Þ þ P RjStr; :Flw
ð
ÞP :Flw
ð
Þ
¼ 0:95  0:4 þ 0:7  0:6 ¼ 0:8;
P VjStr
ð
Þ ¼ P VjR
ð
ÞP RjStr
ð
Þ þ P Vj:R
ð
ÞP :RjStr
ð
Þ
¼ 0:04  0:8 þ 0:99  0:2 ¼ 0:23:
Fig. 11.1 Bayesian network
for the bicycle light. The CPT
for Li is given in the problem
statement
328
11
Solutions for the Exercises

11.8
Machine Learning and Data Mining
Exercise 8.1
(a) The agent is a function A, which maps the vector (t1, t2, t3, d1, d2, d3, f1, f2, f3)
consisting of three values each for temperature, pressure, and humidity to a
class value k 2 {sunny, cloudy, rainy}.
(b) The training data ﬁle consists of a line of the form
ti1; ti2; ti3; di1; di2; di3; fi1; fi2; fi3; ki
for every single training data item. The index i runs over all training data.
A concrete ﬁle could for example begin:
17,17,17,980,983,986,63,61,50,sunny
20,22,25,990,1014,1053,65,66,69,sunny
20,22,18,990,979,929,52,60,61,rainy
Exercise 8.2 We can see the symmetry directly using the deﬁnition of correlation
coefﬁcients, or of covariance. Swapping i and j does not change the value. For the
diagonal elements we calculate
Kii ¼ rii
si  si
¼
PN
p¼1ðx p
i  xiÞðx p
i  xiÞ
PN
p¼1ðx p
i  xiÞ2
¼ 1:
Exercise 8.3 The sequence of values for w is
ð1; 1Þ; ð2:2; 0:4Þ; ð1:8; 0:6Þ; ð1:4; 1:6Þ; ð2:6; 0:2Þ; ð2:2; 1:2Þ
Exercise 8.4
(a)
(b) Drawing a straight line in the graph yields:
1:5x1 þ x2  15 [ 0:
After 442 iterations, the perceptron learn-
ing algorithms with the start vector w =
(1, 1 ,1) returns:
w ¼ ð11; 16; 129Þ:
This corresponds to: 0.69x1 + x2 −8.06 > 0
11.8
Machine Learning and Data Mining
329

Exercise 8.5
(a) The vector P
x2M þ x points in an “average” direction of all positive points and
P
x2M x points in an “average” direction of all negative points. The difference
of these vectors points from the negative points toward the positive points.
The dividing line is then perpendicular to this difference vector.
(b) The point cloud of the positive and negative points
dominate during the calculation of w. The two
outliers hardly play a role here. For determining the
dividing line, however, they are important.
Exercise 8.6
Exercise 8.7
(a) Nearest neighbor is (8, 4), thus class 1.
(b) k = 2: class undeﬁned since one instance of class 1 and one instance of class 2.
k = 3: decision 2:1 for class 0.
k = 5: decision 2:3 for class 1.
Exercise 8.8
(a) To be able to make general statements, we must assume that the points are
evenly distributed in the feature space, which means that the number of points
per area is overall approximately equal. Now we calculate the area Ad of a
narrow ring of width dd and distance d around the point x:
Ad ¼ pðd þ DdÞ2  pd2 ¼ pðd2 þ 2dDd þ Dd2Þ  pd2  2pdDd:
The total weight of all points in the ring of width Dd and distance d is thus
proportional to dwi = d/(1 + ad2)  1/(ad) for d ! ∞.
(b) For this weighting, the total weight of all points in the ring of width Dd and
distance d would be proportional to dw0
i ¼ d=d ¼ 1. Thus each ring of width
Dd would have the same weight, independent of its distance to point x. This
certainly does not make sense because the immediate surroundings are most
important for the approximation.
330
11
Solutions for the Exercises

Exercise 8.10 limx!0 x log2 x ¼ limx!0
log2 x
1=x ¼ limx!0
1=ðx ln 2Þ
1=x2 ¼ limx!0 x
ln 2 ¼ 0, where
for the second equation l’Hospital’s rule was used.
Exercise 8.11 (a) 0
(b) 1
(c) 1.5
(d) 1.875
(e) 2.32
(f) 2
Exercise 8.12
(a) From log2x = ln x/ln 2, it follows that c = 1/ln 2  1.44.
(b) Since both entropy functions only differ by a constant factor, the position of
the entropy maximum does not change. Extrema under constraints also
maintain the same position. Thus the factor c does not cause a problem
for the MaxEnt method. For learning of decision trees, the information
gains of various attributes are compared. Because here only the ordering
matters, but not the absolute value, the factor c does not cause a problem
here either.
Exercise 8.13
(a) For the ﬁrst attribute we calculate
G D; x1
ð
Þ ¼ H D
ð Þ 
X
9
i¼6
Dx1¼i
j
j
D
j j H Dx1¼i
ð
Þ
¼ 1 
1
8 H Dx1¼6
ð
Þ þ 1
8 H Dx1¼7
ð
Þ þ 3
8 H Dx1¼8
ð
Þ þ 3
8 H Dx1¼9
ð
Þ


¼ 1 
0 þ 0 þ 3
8  0:918 þ 3
8  0:918


¼ 0:311
G(D, x2) = 0.75, thus x2 is selected. For x2 = 0, 1, 3, 4,
5, 6 the decision is clear. For x2 = 2, x1 is selected. The
tree then has the form
(b) Information gain for the continuous attribute x2 as the root node:
x2 = 0: 0 (1/0)
x2 = 1: 0 (1/0)
x2 = 2:
| x1 = 6: 0 (0/0)
| x1 = 7: 0 (0/0)
| x1 = 8: 0 (1/0)
| x1 = 9: 1 (1/0)
x2 = 3: 0 (1/0)
x2 = 4: 1 (1/0)
x2 = 5: 1 (1/0)
x2 = 6: 1 (1/0)
Threshold H
0
1
2
3
4
5
G(D, x2  H)
0.138
0.311
0.189
0.549
0.311
0.138
11.8
Machine Learning and Data Mining
331

Since G(D, x2  3) = 0.549 > 0.311 =
G(D,
x1),
x2

3
is
selected.
For
x2  3 the classiﬁcation is not unique. We
calculate
GðDx2  3; x1Þ ¼ 0:322,
GðDx2  3;
x2  0Þ ¼ 0:073,
GðDx2  3; x2  1Þ ¼ 0:17,
GðDx2  3; x2  2Þ ¼ 0:073. Thus x1 is selected.
For x1 = 9 the classiﬁcation is not unique.
Here the decision is clearly GðDðx2  3;x1¼9Þ;
x1Þ ¼ 0,
GðDðx2  3;x1¼9Þ; x2  1Þ ¼ 1,
x2  1
is
chosen, and the tree once again has 100%
correctness.
Exercise 8.14
(a) 100% for the training data, 75% for the test data, 90% total correctness.
(b) (A ^ ¬C) _ (¬A ^ B)
(c)
66.6% correctness for the training data
100% correctness for the test data
80% total correctness
Exercise 8.15
(a) Equation (8.7) on page 203 for calculating the information gain of an attribute
A reads
InfoGainðD; AÞ ¼ HðDÞ 
X
n
i¼1
jDij
jDj HðDiÞ;
where n is the number of the values of the currently observed attribute. If the
attribute A is tested somewhere in the subtree as a successor of the value aj,
then only the value A = aj will occur in the dataset Dj and each of its sub-
sets D′. Thus D0 ¼ D0
j and for all k 6¼ j, jD0
kj ¼ 0 and we obtain
InfoGain(D0,A) ¼ HðD0Þ 
X
n
i¼1
jD0
ij
jD0j HðD0
iÞ ¼ HðD0
jÞ 
jD0
jj
jD0
jj HðD0
jÞ ¼ 0:
The repeated attribute thus has an information gain of zero, because of which it
is no longer used.
(b) From every continuous attribute A a binary attribute A > HD,A is generated. If,
further down in the tree, the attribute A is discretized again with a different
threshold HD′,A, then the attribute A > HD′,A is different from A > HD,A. If it
then has a higher information gain than all other attributes, it will be used in
the tree. However, this also means that for multiple occurrences of a
continuous attribute, the thresholds must be different.
Tree:
x2 <= 3:
| x1 = 6: 0 (1/0)
| x1 = 7: 0 (0/0)
| x1 = 8: 0 (1/0)
| x1 = 9:
| | x2 <= 1: 0 (1/0)
| | x2 > 1: 1 (1/0)
x2 > 3: 1 (3/0)
332
11
Solutions for the Exercises

Exercise 8.16
(a)
P(Sky = clear) = 0.65
P(Bar = rising) = 0.67
(b) P(Sky = clear) = 0.65
(c) The necessary CPTs for P(Prec|Sky, Bar) and P(Bar|Sky), as well as P(Sky) are
already known.
(d) Pa = (0.37, 0.065, 0.095, 0.12, 0.11, 0.13, 0.023, 0.092)
Pb = (0.34, 0.13, 0.06, 0.12, 0.15, 0.054, 0.05, 0.1)
P = (0.4, 0.07, 0.08, 0.1, 0.09, 0.11, 0.03, 0.12)
(original distribution)
Quadratic distance: dq (Pa, P) = 0.0029,
dq (Pb, P) = 0.014
Kullback–Leibler dist.: dk (Pa, P) = 0.017,
dk (Pb, P) = 0.09
Both distance metrics show that the network (a) approximates the distribution
better than network (b). This means that the assumption that Prec and Sky are
conditionally independent given Bar is less likely true than the assumption
that Sky and Bar are independent.
(e) Pc = (0.4, 0.07, 0.08, 0.1, 0.09, 0.11, 0.03, 0.12). This distribution is exactly
equal to the original distribution P. This is not surprising because there are no
missing edges in the network. This means that no independencies were
assumed.
Exercise 8.17 We can immediately see that scores and perceptrons are equiva-
lent by comparing their deﬁnitions. Now for the equivalence to naive Bayes:
First we establish that P(K | S1, …, Sn) > 1/2 is equivalent to P(K | S1, …, Sn) >
P(¬K | S1, …, Sn) because P(¬K | S1, …, Sn) > 1 −P(K|S1, …, Sn). We are in fact
dealing with a binary naive Bayes classiﬁer here.
We apply the logarithm to the naive Bayes formula
PðKjS1; . . .; SnÞ ¼ PðS1jKÞ      PðSnjKÞ  PðKÞ
PðS1; . . .; SnÞ
;
and obtain
log P KjS1; . . .; Sn
ð
Þ ¼ log P S1jK
ð
Þ þ    þ log P SnjK
ð
Þ þ log P K
ð Þ
 log P S1; . . .; Sn
ð
Þ:
ð11:18Þ
Sky
Bar
P(Prec = dry|Sky, Bar)
Clear
Rising
0.85
Clear
Falling
0.44
Cloudy
Falling
0.45
Cloudy
Falling
0.2
Bar
P(Prec = dry|Bar)
Rising
0.73
Falling
0.33
Sky
P(Bar = rising|Sky)
Clear
0.72
Cloudy
0.57
11.8
Machine Learning and Data Mining
333

To obtain a score, we must interpret the variables S1, …, Sn as numeric variables
with the values 1 and 0. We can easily see that
log PðSijKÞ ¼ ðlog PðSi ¼ 1jKÞ  log PðSi ¼ 0jKÞÞSi þ log PðSi ¼ 0jKÞ:
It follows that
X
n
i¼1
log P SijK
ð
Þ ¼
X
n
i¼1
ðlog P Si ¼ 1jK
ð
Þ  log P Si ¼ 0jK
ð
ÞÞSi
þ
X
n
i¼1
log P Si ¼ 0jK
ð
Þ:
Now we deﬁne wi = log P(Si = 1|K) −log P(Si = 0|K) and c ¼ Pn
i¼1 log PðSi ¼
0jKÞ and simplify
X
n
i¼1
log PðSijKÞ ¼
X
n
i¼1
wiSi þ c:
Substituted in (11.18) on page 333 we obtain
log PðKjS1; . . . ; SnÞ ¼
X
n
i¼1
wiSi þ c þ log PðKÞ  log PðS1; . . . ; SnÞ:
For the decision K it must be the case, according to the deﬁnition of the Bayes
classiﬁer, that logP(K|S1, … ,Sn) > log(1/2). Thus it must either be the case that
X
n
i¼1
wiSi þ c þ log PðKÞ  log PðS1; . . . ; SnÞ [ logð1=2Þ
or that
X
n
i¼1
wiSi [ log 1=2  c  log PðKÞ þ log PðS1; . . . ; SnÞ;
with which we have deﬁned a score with the threshold H = log 1/2 −c −log P(K) +
log P(S1, …, Sn ). Because all of the transformations can be reversed, we can also
transform any score into a Bayesian classiﬁer. With that, the equivalence has been
shown.
Exercise 8.18 Taking the logarithm of (8.10) on page 222 results in
log PðIjs1; . . . ; snÞ ¼ log c þ log PðIÞ þ
X
l
i¼1
ni log PðwijIÞ:
334
11
Solutions for the Exercises

Thereby very small negative numbers become moderate negative numbers. Since
the logarithm function grows monotonically, to determine the class we maximize
according to the rule
INaiveBayes ¼ argmax
I2fw; fg
log PðIjs1; . . . ; snÞ:
The disadvantage of this method is the somewhat longer computation time in the
learning phase for large texts. During classiﬁcation the time does not increase,
because the values logP(I|s1, … , sn) can be saved during learning.
Exercise 8.20 Let f be strictly monotonically increasing, that is, 8x, y x < y )
f(x) < f(y). If now d1(s, t) < d1(u, v), then clearly d2(s, t) = f(d1(s, t)) < f(d1(u, v)) =
d2(u, v). Because the inverse of f is also strictly monotonic, the reverse is true, that
is, d2(s, t) < d2(u, v) ) d1(s, t) < d1(u, v). Thus it has been shown that d2(s, t) <
d2(u, v) , d1(s, t) < d1(u, v).
Exercise 8.21
x1x2 ¼ 4;
and thus
dsðx1; x2Þ ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
23  26
p
4
¼ 6:11
x2x3 ¼ 2;
and thus
dsðx2; x3Þ ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
26  20
p
2
¼ 11:4
x1x3 ¼ 1;
and thus
dsðx1; x3Þ ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
23  20
p
1
¼ 21:4
Sentences 1 and 2 are most similar w.r.t. the distance metric ds.
Exercise 8.22 Help for problems with KNIME: www.knime.org/forum
11.9
Neural Networks
Exercise 9.1 We want to show that f(H + x) + f(H −x) = 1.
f H þ x
ð
Þ ¼
1
1 þ ex
T ¼
e
x
T
1 þ e
x
T ;
f H  x
ð
Þ ¼
1
1 þ e
x
T ;
f H þ x
ð
Þ þ f H  x
ð
Þ ¼ 1:
Exercise 9.3 Each pattern saved in the network has a size of n bits. The network has
a total of n(n −1)/2 weights. If we reserve 16 bits per weight and deﬁne binary
storage of size 16n(n −1)/2 as equally large, then this can clearly store N = 8n(n −1)/
n = 4(n −1) patterns n bits in size. For large n we obtain N = 4n as the limit. If we
take the quotient a of the number of storable bits and the number of available storage
cells, as in (9.11) on page 260, then we obtain the value 1 for the list memory and the
value a = 0.146n2/(16n(n −1)/2)  0.018 for the Hopﬁeld network. The classical
storage thus has (for 16 bits per weight), a capacity roughly 55 times higher.
11.8
Machine Learning and Data Mining
335

Exercise 9.4
(a) Mathematica program for the least square method.
Exercise 9.6 (a) Learning works without errors.
(b) Learning does not work
without errors!
Exercise 9.7
(a) A mapping f is called linear if for all x, y, k it is the case that f(x + y) = f(x) +
f(y) and f(kx) = kf(x). Now let f and g be linear mappings. Then f(g(x + y)) =
f(g(x) + g(y)) = f(g(x)) + f(g(y)) and f(g(kx)) = f(kg(x)) = kf(g(x)). Thus,
successive executions of linear mappings are a linear mapping.
(b) We observe two arbitrary output neurons j and k. Each of the two represent a
class. Classiﬁcation is done by forming the maximum of the two activations.
Let netj = P
iwjixi and netk = P
iwkixi be the weighted sum of values arriving at
neurons j and k. Furthermore, let netj > netk. Without an activation function,
class j is output. Now if a strictly monotonic activation function f is applied,
nothing changes in the result because, due to the function being strictly
monotonic, f(netj) > f(netk).
Exercise 9.8 f1ðx1; x2Þ ¼ x2
1;
f2ðx1; x2Þ ¼ x2
2. Then the dividing line in the
transformed space has the equation y1 + y2 = 1.
LeastSq[q_,a_] := Module[{Nq,Na,m,A,b,w},
Nq = Length[q]; m = Length[q[[1]]]; Na = Length[a];
If[Nq != Na, Print["Length[q] != Length[a]"]; Exit, 0];
A = Table[N[Sum[q[[p,i]] q[[p,j]], {p,1,Nq}]], {i,1,m}, {j,1,m}];
b = Table[N[Sum[a[[p]] q[[p,j]], {p,1,Nq}]], {j,1,m}];
w = LinearSolve[A,b]
]
LeastSq::usage = "LeastSq[x,y,f] computes from the query vectors q[[1]],...,
q[[m]] a table of coefficients w[[i]] for a linear mapping f[x] =
Sum[w[[i]] x[[i]], {i,1,m}] with f[q[[p]]] = a[[p]]."
(b)
(c)
336
11
Solutions for the Exercises

11.10
Reinforcement Learning
Exercise 10.1
(a) nn
(b) (n−1)n
(c)
(d)
Exercise 10.2 Value iteration yields the sequence of value tables below.
Depending on the order of value updates, the intermediate conﬁgurations may
differ, but not the ﬁnal conﬁguration.
Exercise 10.3
(c)
(d) We see that the longer a policy becomes (i.e., the more steps, for example, that
a cycle of a cyclical strategy has), the closer the value c must be to 1 because a
higher value for c makes a longer memory possible. However, value iteration
converges that much more slowly.
Exercise 10.4 The value V⋆(3, 3) at bottom right in the state matrix is changed as
follows:
V Hð3; 1Þ ¼ 0:9V Hð2; 1Þ ¼ 0:92V Hð2; 2Þ ¼ 0:93V Hð2; 3Þ ¼ 0:94V Hð3; 3Þ: ð11:19Þ
This chain of equations follows from (10.6) on page 295 because, for all given state
transitions, the maximum immediate reward is r(s, a) = 0, and it is the case that
V HðsÞ ¼ max
a ½rðs; aÞ þ cV Hðdðs; aÞÞ ¼ cV Hðdðs; aÞÞ ¼ 0:9V Hðdðs; aÞÞ:
0
0
0
0
→
0.81
0.9
0.73
1
→
1.35
1.49
1.21
1.66
→··· →
2.36
2.62
2.12
2.91
11.10
Reinforcement Learning
337

From (10.6) on page 295 it also follows that V⋆(3, 2) ¼ 1 þ 0:9V⋆(3, 1), because
r(s, a) ¼ 1 is maximal. Analogously it is true that V⋆(3, 3) ¼ 1 þ 0:9 V⋆(3, 2) and the
circle closes. The two last equations together yield V⋆(3, 3) ¼ 1 þ 0:9ð1 þ 0:9
V⋆(3, 1)). From (11.19) on page 337 it follows that V⋆(3, 1) ¼ 0:94V⋆(3, 3).
Substituted in V⋆(3, 3), this yields
V Hð3; 3Þ ¼ 1 þ 0:9ð1 þ 0:95V Hð3; 3ÞÞ;
from which the claim follows.
Exercise 10.5
Stable Q-values and an optimal policy:
Exercise 10.6
(a) Number of states = ‘n. Number of actions per state = ‘n. Number of poli-
cies ¼ ‘n
ð
Þ‘n ¼ ‘n‘n.
(b)
(c) Per state there are now 2n possible actions. Thus there are ð2nÞ‘n policies.
l = 1
l = 2
l = 3
l = 4
l = 10
n = 1
1
4
27
256
1010
n = 2
1
256
3.9 	 108
1.8 	 1019
10200
n = 3
1
1.7 	 107
4.4 	 1038
3.9 	 10115
103000
n = 4
1
1.8 	 1019
3.9 	 10154
3.2 	 10616
1040000
n = 8
1
3.2 	 10616
1.4 	 1025043
6.7 	 10315652
10800000000
l = 1
l = 2
l = 3
l = 4
l = 10
n = 1
2
4
8
16
1024
n = 2
4
256
2.6 	 109
4.3 	 109
1.6 	 1060
n = 3
6
1.7 	 106
1.0 	 1021
6.3 	 1049
1.4 	 10778
n = 4
8
2.8 	 1014
1.4 	 1073
1.6 	 10231
7.9 	 109030
n = 8
16
1.8 	 10308
1.7 	 107900
1.6 	 1078913
1.8 	 10120411998
(d) 10120411998 different policies can never be explored combinatorially, even if all
of the available computers in the world were to operate on them in parallel.
Thus “intelligent” algorithms are necessary to ﬁnd an optimal or nearly
optimal policy.
338
11
Solutions for the Exercises

References
[ACM09]
A survey of robot learning from demonstration. Robotics and Autonomous Systems,
57:469–483, 2009
[Ada75]
E.W. Adams. The Logic of Conditionals, volume 86 of Synthese Library. D. Reidel
Publishing Company, 1975
[Alp04]
E. Alpaydin. Introduction to Machine Learning. MIT Press, 2004
[AOJJ89]
S. K. Andersen, K. G. Olesen, F. V. Jensen, and F. Jensen. HUGIN - A Shell for
Building Bayesian Belief Universes for Expert Systems. In Proc. of the 11th Intl.
Joint Conf. on Artiﬁcial Intelligence (IJCAI-89), 1989
[APR90]
J. Anderson, A. Pellionisz, and E. Rosenfeld. Neurocomputing (vol. 2): directions
for research. MIT Press, Cambridge, MA, USA, 1990
[AR88]
J. Anderson and E. Rosenfeld. Neurocomputing: Foundations of Research. MIT
Press, Cambridge, MA, 1988. Collection of fundamental original papers
[Bar98]
R. Bartak. Online guide to constraint programming. http://kti.ms.mff.cuni.cz/bartak/
constraints, 1998
[Bat16]
A. Batzill, Optimal route planning on mobile systems (Masterarbeit, Hochschule
Ravensburg-Weingarten, 2016)
[BBBK11]
J. Bergstra, R. Bardenet, Y. Bengio, and B. Kégl. Algorithms for hyper-parameter
optimization. In Advances in Neural Information Processing Systems, pages
2546–2554, 2011
[BBSK10]
Greg Bickerman, Sam Bosley, Peter Swire, and Robert Keller. Learning to create
jazz melodies using deep belief nets. In First International Conference on
Computational Creativity, 2010
[BCDS08]
A. Billard, S. Calinon, R. Dillmann, and S. Schaal. Robot programming by
demonstration. In B. Siciliano and O. Khatib, editors, Handbook of Robotics, pages
1371–1394. Springer, 2008
[Bel57]
R.E. Bellman. Dynamic Programming. Princeton University Press, 1957
[Ben16]
R. Benenson. What is the class of this image? http://rodrigob.github.io/are_we_
there_yet/build/classiﬁcation_datasets_results.html, February 2016
[Ber89]
M. Berrondo. Fallgruben für Kopffüssler. Fischer Taschenbuch Nr. 8703, 1989
[BFOS84]
L. Breiman, J. Friedman, R. A. Olshen, and C. J. Stone. Classiﬁcation and
regression trees. Wadsworth, 1984
[Bib82]
W. Bibel. Automated Theorem Proving. Vieweg Verlag, 1982
[Bis05]
C.M. Bishop. Neural networks for pattern recognition. Oxford University Press,
2005
[Bis06]
C.M. Bishop, Pattern recognition and machine learning (Springer, New York,
2006)
[BJCdC14]
R.C. Barros, P.A. Jaskowiak, R. Cerri, A.C. de Carvalho, A framework for
bottom-up induction of oblique decision trees. Neurocomputing 135, 3–12 (2014)
[BKI00]
C. Beierle and G. Kern-Isberner. Methoden wissensbasierter Systeme. Vieweg, 2000
© Springer International Publishing AG 2017
W. Ertel, Introduction to Artificial Intelligence, Undergraduate Topics
in Computer Science, DOI 10.1007/978-3-319-58487-4
339

[BKNS00]
M. Breunig, H.P. Kriegel, R. Ng, J. Sander, Lof: identifying density-based local
outliers. ACM sigmod record 29(2), 93–104 (2000)
[BM03]
A.G. Barto, S. Mahadevan, Recent advances in hierarchical reinforcement learning.
Discrete Event Systems, Special issue on reinforcement learning 13, 41–77 (2003)
[Bra84]
V. Braitenberg. Vehicles – Experiments in Synthetic Psychology. MIT Press, 1984
[Bra01]
B. Brabec. Computergestützte regionale Lawinenprognose. PhD thesis, ETH
Zürich, 2001
[Bra11]
I. Bratko. PROLOG Programming for Artiﬁcial Intelligence. Addison-Wesley, 4th
edition, 2011
[Bri91]
Encyclopedia Britannica. Encyclopedia Britannica Verlag, London, 1991
[Bur98]
C.J. Burges, A tutorial on support vector machines for pattern recognition. Data
Min. Knowl. Discov. 2(2), 121–167 (1998)
[CAD]
CADE: Conference on Automated Deduction. http://www.cadeconference.org
[CEP15a]
R. Cubek, W. Ertel, and G. Palm. A critical review on the symbol grounding
problem as an issue of autonomous agents. In Proceedings of the 38th German
Conference on Artiﬁcial Intelligence (KI), Dresden, Germany, 2015
[CEP15b]
R. Cubek, W. Ertel, and G. Palm. High-level learning from demonstration with
conceptual spaces and subspace clustering. In Proceedings of the 2015 IEEE
International Conference on Robotics and Automation (ICRA), Seattle, Washington,
2015
[Che83]
P. Cheeseman. A method for computing generalised bayesian probability values for
expert systems. In Proc. of the 8th Intl. Joint Conf. on Artiﬁcial Intelligence
(IJCAI-83), 1983
[Che85]
P. Cheeseman. In defense of probability. In Proc. of the 9th Intl. Joint Conf. on
Artiﬁcial Intelligence (IJCAI-85), 1985
[CL73]
C.L. Chang, R.C. Lee, Symbolic Logic and Mechanical Theorem Proving
(Academic Press, Orlando, Florida, 1973)
[Cle79]
W.S. Cleveland, Robust locally weighted regression and smoothing scatterplots.
Journal of the American Statistical Association 74(368), 829–836 (1979)
[CLR90]
T. Cormen, Ch. Leiserson, R. Rivest, Introduction to Algorithms (MIT Press,
Cambridge, Mass, 1990)
[CM94]
W.F. Clocksin, C.S. Mellish, Programming in Prolog, 4th edn. (Springer, Berlin,
Heidelberg, New York, 1994)
[CMS+92]
C. Ohmann, M. Kraemer, S. Jaeger, H. Sitter, C. Pohl, B. Stadelmayer, P. Vietmeier,
J. Wickers, L. Latzke, B. Koch, K. Thon, Akuter bauchschmerz - standardisierte
befundung als diagnoseunterstützung. Chirurg 63, 113–123 (1992)
[Coz98]
F.G. Cozman. Javabayes, bayesian networks in java, 1998. http://www.cs.cmu.edu/
javabayes
[dD91]
F.T. de Dombal. Diagnosis of Acute Abdominal Pain. Churchill Livingstone, 1991
[dDLS+72]
F.T. de Dombal, D.J. Leaper, J.R. Staniland, A.P. McCann, J.C. Horrocks,
Computer aided diagnosis of acute abdominal pain. British Medical Journal 2, 9–13
(1972)
[Dee11]
The DeepQA Project, 2011. http://www.research.ibm.com/deepqa/deepqa.shtml
[DH73]
R.O. Duda and P.E. Hart. Pattern Classiﬁcation and Scene Analysis. Wiley, 1973.
Klassiker zur Bayes-Decision-Theorie
[DHS01]
R.O. Duda, P.E. Hart, and D.G. Stork. Pattern Classiﬁcation. Wiley, 2001
[Dia04]
D. Diaz. GNU PROLOG. Universität Paris, 2004. Auﬂ. 1.7, für GNU Prolog version
1.2.18, http://gnu-prolog.inria.fr
[DNM98]
C.L. Blake D.J. Newman, S. Hettich and C.J. Merz. UCI repository of machine
learning databases. http://www.ics.uci.edu/mlearn/MLRepository.html, 1998
[Ede91]
E. Eder. Relative Complexities of First Order Calculi. Vieweg Verlag, 1991
340
References

[Elk93]
C. Elkan. The paradoxical success of fuzzy logic. In Proceedings of the Eleventh
National Conference on Artiﬁcial Intelligence (AAAI-93), pages 698–703. MIT
Press, 1993
[Ert93]
W. Ertel. Parallele Suche mit randomisiertem Wettbewerb in Inferenzsystemen,
volume 25 of DISKI. Inﬁx-Verlag, St. Augustin, 1993. Dissertation, Technische
Universität München
[Ert07]
W. Ertel. Grundkurs Künstliche Intelligenz. Vieweg-Verlag, 2007
[Ert11]
W. Ertel. Artiﬁcial Intelligence. http://www.hs-weingarten.de/ertel/aibook, 2011.
Homepage to this book with materials, demo programs, links, literature, errata, etc
[Ert15]
W. Ertel. Advanced mathematics for engineers. Lecture notes, Hochschule
Ravensburg-Weingarten:
http://www.hs-weingarten.de/ertel/vorlesungen/mae/
matheng-skript-1516-v2.pdf, 2015
[ES99]
W. Ertel and M. Schramm. Combining Data and Knowledge by MaxEnt-
Optimization of Probability Distributions. In PKDD'99 (3rd European Conference
on Principles and Practice of Knowledge Discovery in Databases), volume 1704 of
LNCS, pages 323–328, Prague, 1999. Springer Verlag
[ESCT09]
W. Ertel, M. Schneider, R. Cubek, and M. Tokic. The teaching-box: A universal
robot learning framework. In Proceedings of the 14th International Conference on
Advanced Robotics (ICAR 2009), 2009. http://www.servicerobotik.hs-weingarten.
de/teachingbox
[ESS89]
W. Ertel, J. Schumann, and Ch. Suttner. Learning Heuristics for a Theorem Prover
using Back Propagation. In J. Retti and K. Leidlmair, editors, 5. Österreichische
Artiﬁcial-Intelligence-Tagung,
pages
87–95.
Informatik-Fachberichte
208,
Springer-Verlag, Berlin, Heidelberg, 1989
[Fel14]
C. Felber. Die Gemeinwohl-Ökonomie. Deuticke Verlag, 2014
[Fit96]
M. Fitting. First-order logic and automated theorem proving. Springer, 1996
[Fla12]
Peter Flach. Machine Learning: The Art and Science of Algorithms that Make Sense
of Data. Cambridge University Press, 2012
[FNA+09]
D. Ferrucci, E. Nyberg, J. Allan, K. Barker, E. Brown, J. Chu-Carroll, A. Ciccolo,
P. Duboue, J. Fan, D. Gondek et al. Towards the open advancement of question
answer systems. IBM Technical Report RC24789, Yorktown Heights, NY, 2009.
http://www.research.ibm.com/deepqa/question_answering.shtml
[FPP07]
D. Freedman, R. Pisani, and R. Purves. Statistics. Norton, 4th edition, 2007
[Fra05]
C. Frayn. Computer chess programming theory. http://www.frayn.net/beowulf/
theory.html, 2005
[Fre97]
E. Freuder, In pursuit of the holy grail. Constraints 2(1), 57–61 (1997)
[FS96]
V.G. Fischer and M. Schramm. Efﬁcient Compilation of Probabilistic Expressions
for Use in MaxEnt Optimization Problems. Technical Report TUM-I9636, Institut
für Informatik, Technische Universität München, 1996
[FS97]
B. Fischer and J. Schumann. Setheo goes software engineering: Application of atp
to software reuse. In Conference on Automated Deduction (CADE-14), volume
1249 of LNCS, pages 65–68. Springer, 1997. http://ase.arc.nasa.gov/people/
schumann/publications/papers/cade97-reuse.html
[GAKW91]
M. Greiner, Kölbl A, C. Kredler, and S. Wagenpfeil. Numerical Comparison of
Standard SQP-Software with some Second Order Nonlinear Optimization Methods.
Report 348, DFG-Schwerpunkt: Anwendungsbezogene Optimierung und Steuer-
ung, 1991
[GBC16]
I. Goodfellow, Y. Bengio, and A. Courville. Deep learning. Buch in Vorbereitung
für MIT Press, http://www.deeplearningbook.org, 2016
[GEB15]
L. Gatys, A. Ecker, and M. Bethge. A neural algorithm of artistic style. arXiv
preprint
arXiv:1508.06576,
2015.
http://www.boredpanda.com/computer-deep-
learning-algorithm-painting-masters
References
341

[GHZ14]
P. Gao, R. Hensley, and A. Zielke. A road map to the future for the auto industry.
McKinsey Quarterly, Oct, 2014
[GK95]
C.
Goller
and
A.
Küchler.
Learning
Task-Dependent
Distributed
Structure-Representations by Backpropagation Through Structure. AR-Report
AR-95-02, Institut für Informatik, Technische Universität München, 1995. (a short-
ened version will appear in the Proc. of the ICNN-96)
[GK96]
C. Goller and A. Küchler. Learning Task-Dependent Distributed Representations by
Backpropagation Through Structure. In Proc. of the ICNN-96, volume 1, pages
347–352. IEEE, 1996
[GK09]
J. Grahl and R. Kümmel. Das Loch im Fass – Energiesklaven, Arbeitsplätze und die
Milderung des Wachstumszwangs. Wissenschaft und Umwelt Interdiziplinär,
13:195–212, 2009. http://www.fwu.at/assets/userFiles/Wissenschaft_Umwelt/13_
2009/2009_13_wachstum_5.pdf
[Gol94]
C. Goller. A Connectionist Control Component for the Theorem Prover SETHEO.
In Proc. of the ECAI'94 Workshop W14: Combining Symbolic and Connectionist
Processing, pages 99–93. ECAI in cooperation with AAAI and IJCAI, 1994
[Gol97]
C. Goller. A Connectionist Approach for Learning Search-Control Heuristics for
Automated Deduction Systems. PhD thesis, Fakultät für Informatik, Technische
Universität München, 1997. (In preparation)
[GP58]
Silvio Gesell and Philip Pye. The natural economic order. Owen, 1958
[GR06]
T. Gabel and M. Riedmiller. Learning a partial behavior for a competitive robotic
soccer agent. Künstliche Intelligenz, 20(2), 2006. BöttcherIT Verlag
[Gra13]
Alex Graves. Generating sequences with recurrent neural networks. arXiv preprint
http://arxiv.org/abs/1308.0850, 2013.
[GRS03]
G. Görz, C.-R. Rollinger, and J. Schneeberger, editors. Handbuch der Künstlichen
Intelligenz. Oldenbourg Verlag, 2003
[GS15]
J.B. Greenblatt, S. Saxena, Autonomous taxis could greatly reduce greenhouse-gas
emissions of us light-duty vehicles. Nature Clim. Change 5(9), 860–863 (2015)
[GSSD08]
R. Geisberger, P. Sanders, D. Schultes, and D. Delling. Contraction hierarchies:
Faster and simpler hierarchical routing in road networks. In Experimental
Algorithms, pages 319–333. Springer, 2008
[GT96]
M. Greiner, G. Tinhofer, Stochastik für Studienanfänger der Informatik (Carl
Hanser Verlag, München, Wien, 1996)
[Gue02]
G. Guerrerio, Spektrum der wissenschaft, spezial 1/2002: Kurt gödel (Spektrum
Verlag, Heidelberg, 2002)
[GW08]
R.C. González and R.E. Woods. Digital Image Processing. Pearson/Prentice Hall,
2008
[Göd31a]
K. Gödel, Diskussion zur Grundlegung der Mathematik, Erkenntnis 2. Monatsheft
für Mathematik und Physik 32(1), 147–148 (1931)
[Göd31b]
K. Gödel, Über formal unentscheidbare Sätze der Principia Mathematica und
verwandter Systeme I. Monatsheft für Mathematik und Physik 38(1), 173–198
(1931)
[HKP91]
J. Hertz, A. Krogh, and R. Palmer. Introduction to the theory of neural computation.
Addison Wesley, 1991
[HL04]
P. Hammerer and M. Lein. Stellenwert der PSA-Bestimmung zur Früherkennung
des Prostatakarzinoms. Deutsches Ärzteblatt, 101(26):A–1892/B–1581/C–1517,
2004.
http://www.aerzteblatt.de/archiv/42497/Stellenwert-der-PSA-Bestimmung-
zur-Frueherkennung-des-Prostatakarzinoms
[HMS+72]
J.C. Horrocks, A.P. McCann, J.R. Staniland, D.J. Leaper, F.T. de Dombal,
Computer-aided diagnosis: Description of an adaptable system, and operational
experience with 2.034 cases. British Medical Journal 2, 5–9 (1972)
[Hon94]
B. Hontschik. Theorie und Praxis der Appendektomie. Mabuse Verlag, 1994
342
References

[Hop82]
J.J. Hopﬁeld. Neural networks and physical systems with emergent collective
computational abilities. Proc. Natl. Acad. Sci. USA, 79:2554–2558, April 1982.
Wiederabdruck in [AR88] S. 460–464
[HOT06]
G. Hinton, S. Osindero, Y. Teh, A fast learning algorithm for deep belief nets.
Neural computation 18(7), 1527–1554 (2006)
[HT85]
J.J. Hopﬁeld and D.W. Tank. “Neural” computation of decisions in optimization
problems. Biological Cybernetics, 52(3):141–152, 1985. Springer
[HTF09]
T. Hastie, R. Tibshirani, and J. Friedman. The Elements of Statistical Learning:
Data Mining, Inference, and Prediction. Springer, Berlin, 3rd. edition, 2009. Online
version: http://www-stat.stanford.edu/tibs/ElemStatLearn/
[Hub14]
J. Huber. Monetäre Modernisierung, Zur Zukunft der Geldordnung: Vollgeld und
Monetative. Metropolis Verlag, 2014. http://www.monetative.de
[HW95]
Daniel Heckerman, Michael P. Wellman, Bayesian Networks. Communications of
the ACM 38(3), 27–30 (1995)
[Hüb03]
G. Hübner. Stochastik. Vieweg Verlag, 2003
[Jay57]
E. T. Jaynes. Information Theory and Statistical Mechanics. Physical Review, 1957
[Jay78]
E.T. Jaynes. Where do we stand on Maximum Entropy? In R.D. Rosenkrantz,
editor, Papers on Probability, Statistics and Statistical Physics, pages 210–314.
Kluwer Academic Publishers, 1978
[Jay82a]
E.T. Jaynes. Concentration of distributions at entropy maxima. In Rosenkrantz,
editor, Papers on Probability, Statistics and statistical Physics. D. Reidel Publishing
Company, 1982
[Jay82b]
E.T. Jaynes, On the Rationale of Maximum Entropy Methods. Proc. of the IEEE 70
(9), 939–952 (1982)
[Jay89]
E.T. Jaynes. The Well-Posed Problem. In R.D. Rosenkrantz, editor, E.T. Jaynes:
Papers on Probability, Statistics and Statistical Physics, pages 133–148. Kluwer
Academic Publishers, 1989
[Jay03]
E.T. Jaynes. Probability Theory: The Logic of Science. Cambridge University Press,
2003
[Jen01]
F.V. Jensen. Bayesian networks and decision graphs. Springer-Verlag, 2001
[Jor99]
Michael I. Jordan (ed.), Learning in graphical models (MIT Press, Cambridge, MA,
USA, 1999)
[Kal01]
J.A. Kalman. Automated Reasoning with OTTER. Rinton Press, 2001. http://www-
unix.mcs.anl.gov/AR/otter/index.html
[Kan89]
Th. Kane. Maximum entropy in nilsson’s probabilistic logic. In Proc. of the 11th
Intl. Joint Conf. on Artiﬁcial Intelligence (IJCAI-89), 1989
[Kan93]
L.N. Kanal, On Pattern, Categories and Alternate Realities. Pattern Recognition
Letters 14, 241–255 (1993)
[Kar15]
Andrej Karpathy. The unreasonable effectiveness of recurrent neural networks, Mai
2015. http://karpathy.github.io/2015/05/21/rnn-effectiveness/
[Ken06]
M. Kennedy. Geld ohne Zinsen und Inﬂation. Ein Tauschmittel, das jedem dient.
Goldmann Verlag, München, 2006
[KK92]
J.N. Kapur and H.K. Kesavan. Entropy Optimization Principles with Applications.
Academic Press, 1992
[KLM96]
L.P. Kaelbling, M.L. Littman, and A.P. Moore. Reinforcement Learning: A Survey.
Journal of Artiﬁcial Intelligence Research, 4:237–285, 1996. http://www2.cs.cmu.
edu/afs/cs/project/jair/pub/volume4/kaelbling96a.pdf
[KMK97]
H. Kimura, K. Miyazaki, and S. Kobayashi. Reinforcement Learning in POMDPs
with Function Approximation. In 14th International Conference on Machine
Learning, pages 152–160. Morgan Kaufmann Publishers, 1997. http://sysplan.nams.
kyushu-u.ac.jp/gen/papers/JavaDemoML97/robodemo.html
[Koh72]
T. Kohonen. Correlation matrix memories. IEEE Transactions on Computers, C-21
(4):353–359, 1972. Reprint in [AR88] pp. 171–174
References
343

[KR79]
R. Kowalski and A. Robert. Algorithmic = Logic + Control. Communications of the
ACM, 22(7):424–436, Juli 1979
[Kre06]
Ch. Kreitz, Formale methoden der künstlichen intelligenz. Künstliche Intelligenz 4,
22–28 (2006)
[KS06]
L. Kocsis and C. Szepesvári. Bandit based monte-carlo planning. In European
Conference on Machine Learning(ECML) 2006, pages 282–293. Springer, 2006
[Küm11]
R. Kümmel. The second law of economics: Energy, entropy, and the origins of
wealth. Springer Science & Business Media, 2011
[Lar00]
F.D. Laramée. Chess programming, part 1–6. http://www.gamedev.net/reference/
programming/features/chess1, 2000
[Lau96]
S.L. Lauritzen. Graphical Models. Oxford Science Publications, 1996
[LBBH98]
Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-based learning applied to
document recognition. Proceedings of the IEEE, 86(11):2278–2324, 1998.
MNIST-Daten: http://yann.lecun.com/exdb/mnist
[LBH15]
Y. LeCun, Y. Bengio, G. Hinton, Deep learning. Nature 521(7553), 436–444 (2015)
[Le999]
Lexmed – a learning expert system for medical diagnosis. http://www.lexmed.de,
1999
[Let03]
R. Letz. Praktikum beweiser. http://www4.in.tum.de/letz/PRAKTIKUM/al-ss05.pdf,
2003
[Lif89]
V. Lifschitz. Benchmark problems for formal non-monotonic reasoning. In
Reinfrank et al, editor, Non-Monotonic Reasoning: 2nd International Workshop,
volume 346 of LNAI, pages 202–219. Springer, 1989
[LM88]
Kai-Fu Lee, Sanjoy Mohajan, A Pattern Classiﬁcation Approach to Evaluation Func
tion Learning. Artiﬁcial Intelligence 36, 1–25 (1988)
[Lov78]
D.W. Loveland. Automated Theorem Proving: a Logical Basis. North-Holland,
1978
[LR02]
M. Lauer and M. Riedmiller. Generalisation in Reinforcement Learning and the Use
of Obse rvation-Based Learning. In Gabriella Kokai and Jens Zeidler, editors,
Proceedings of the FGML Workshop 2002, pages 100–107, 2002. http://amy.
informatik.uos.de/riedmiller/publications/lauer.riedml.fgml02.ps.gz
[LSBB92]
R. Letz, J. Schumann, S. Bayerl, and W. Bibel. SETHEO: A High-Performance
Theorem Prover. Journal of Automated Reasoning, 8(2):183–212, 1992. http://
www4.informatik.tu-muenchen.de/letz/setheo
[MA94]
P.M. Murphy, D.W. Aha, UCI Repository of Machine Learning Databases
(University of California at Irvine, Department of Information and Computer
Science, 1994)
[McC]
W. McCune. Automated deduction systems and groups. www-unix.mcs.anl.
gov/AR/others.html.
see
also
http://www-formal.stanford.edu/clt/ARS/systems.
html
[McD82]
J. McDermott, R1: A rule-based conﬁgurer of computer systems. Artiﬁcial
Intelligence 19, 39–88 (1982)
[MDA15]
D. Maclaurin, D. Duvenaud, and R. Adams. Gradient-based hyperparameter
optimization through reversible learning. arXiv preprint arXiv:1502.03492, 2015
[MDBM00]
G. Melancon, I. Dutour, and G. Bousque-Melou. Random generation of dags for
graph drawing. Technical Report INS-R0005, Dutch Research Center for Mathe-
matical and Computer Science (CWI), 2000. http://ftp.cwi.nl/CWIreports/INS/INS-
R0005.pdf
[Mit97]
T. Mitchell. Machine Learning. McGraw Hill, 1997. http://www-2.cs.cmu.edu/tom/
mlbook.html
[MMZM72]
D.L. Meadows, D.H. Meadows, E. Zahn, and P. Milling. Die Grenzen des
Wachstums. Bericht des Club of Rome zur Lage der Menschheit. Dt. Verl. Deutsche
Verlagsanstalt, Stuttgart, 1972
[MP69]
M. Minsky, S. Papert, Perceptrons (MIT Press, Cambridge, MA, 1969)
344
References

[Nea90]
R.E. Neapolitan. Probabilistic Reasoning in Expert Systems. Wiley-Interscience.
John Wiley & Sons, Inc., 1990
[New00]
M. Newborn. Automated Theorem Proving: Theory and Practice. Springer Verlag,
2000
[Nil86]
N.J. Nilsson, Probabilistic Logic. Artiﬁcial Intelligence 28(1), 71–87 (1986)
[Nil98]
N. Nilsson. Artiﬁcial Intelligence – A New Synthesis. Morgan Kaufmann, 1998
[NPW02]
T. Nipkow, L.C. Paulson, and M. Wenzel. Isabelle/HOL — A Proof Assistant for
Higher-Order Logic, volume 2283 of LNCS. Springer, 2002. http://www.cl.cam.ac.
uk/Research/HVG/Isabelle
[NS61]
A. Newell, H.A. Simon, Gps, a program that simulates human thought, in Lernende
Automaten, ed. by H. Billing (Oldenbourg, München, 1961), pp. 109–124
[NSS83]
A. Newell, J. C. Shaw, and H. A. Simon. Empirical explorations with the logic
theory machine: A case study in heuristics. In J. Siekmann and G. Wrightson,
editors, Automation of Reasoning 1: Classical Papers on Computational Logic
1957-1966, pages 49–73. Springer, Berlin, Heidelberg, 1983. Erstpublikation: 1957
[NWC+11]
Y. Netzer, T. Wang, A. Coates, A. Bissacco, B. Wu, and A. Ng. Reading digits in
natural images with unsupervised feature learning. In NIPS workshop on deep
learning and unsupervised feature learning, volume 2011, page 4, 2011.
SVHN-Daten:http://uﬂdl.stanford.edu/housenumbers
[OFY+95]
C. Ohmann, C. Franke, Q. Yang, M. Margulies, M. Chan, van P.J. Elk, F.T. de
Dombal, and H.D. Röher. Diagnosescore für akute Appendizitis. Der Chirurg,
66:135–141, 1995
[OMYL96]
C. Ohmann, V. Moustakis, Q. Yang, K. Lang, Evaluation of automatic knowledge
acquisition techniques in the diagnosis of acute abdominal pain. Art. Intelligence in
Medicine 8, 23–36 (1996)
[OPB94]
C. Ohmann, C. Platen, G. Belenky, Computerunterstütze Diagnose bei akuten
Bauchschmerzen. Chirurg 63, 113–123 (1994)
[OR04]
Oliver Obst and Markus Rollmann. SPARK – A Generic Simulator for Physical
Multiagent Simulations. In Gabriela Lindemann, Jörg Denzinger, Ingo J. Timm, and
Rainer Unland, editors, Multiagent System Technologies – Proceedings of the
MATES 2004, volume 3187, pages 243–257. Springer, September 2004
[OYF95]
C. Ohmann, Q. Yang, C. Franke, Diagnostic scores for Acute Appendicitis. Eur.
J. Surg. 161, 273–281 (1995)
[Pae16]
N. Paech, Befreiung vom Überﬂuss – Grundlagen einer Wirtschaft ohne Wachstum,
Fromm Forum, volume 20 (Erich Fromm Gesellschaft, Tübingen, 2016), pp. 70–76
[Pal80]
G. Palm, On associative memory. Biological Cybernetics 36, 19–31 (1980)
[Pal91]
G. Palm. Memory capacities of local rules for synaptic modiﬁcation. Concepts in
Neuroscience, 2(1):97–128, 1991. MPI Tübingen
[Pea84]
J. Pearl, Heuristics (Addison-Wesley Publishing Company, Intelligent Search
Strategies for Computer Problem Solving, 1984)
[Pea88]
J. Pearl, Probabilistic Reasoning in Intelligent Systems (Morgan Kaufmann,
Networks of Plausible Inference, 1988)
[Pik14]
T. Piketty, Das Kapital im 21 (CH Beck Verlag, Jahrhundert, 2014)
[PL05]
L. Panait, S. Luke, Cooperative multi-agent learning: The state of the art.
Autonomous Agents and Multi-Agent Systems 11(3), 387–434 (2005)
[PS08]
J. Peters, S. Schaal, Reinforcement learning of motor skills with policy gradients.
Neural Networks 21(4), 682–697 (2008)
[PS09]
George Pólya and S. Sloan. How to Solve It: A New Aspect of Mathematical
Method. Ishi Press, 2009
[PV90]
J.B. Paris, A. Vencovska, A Note on the Inevitability of Maximum Entropy.
International Journal of Approximate Reasoning 3, 183–223 (1990)
References
345

[PVS03]
J. Peters, S. Vijayakumar, and S. Schaal. Reinforcement learning for humanoid
robotics. In Humanoids2003, Third IEEE-RAS International Conference on
Humanoid Robots, Karlsruhe, 2003
[Qui]
J.R. Quinlan. C5.0. http://www.rulequest.com
[Qui93]
J. Ross Quinlan. C4.5: Programs for Machine Learning. Morgan Kaufmann
Publishers,
1993.
C4.5
Download:
http://www.rulequest.com/Personal,
C5.0
Bestellung: http://www.rulequest.com
[Ran12]
J. Randers. 2052: A Global Forecast for the Next Forty Years. Chelsea Green
Publishing, 2012
[Rau96]
W. Rautenberg. Einführung in die Mathematische Logik. Vieweg Verlag, 1996
[RB93]
M. Riedmiller and H. Braun. A direct adaptive method for faster backpropagation
learning: The rprop algorithm. In Proceedings of the IEEE International Conference
on Neural Networks, pages 586–591, 1993
[RDS+15]
O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A.
Karpathy, A. Khosla, M. Bernstein et al., Imagenet large scale visual recognition
challenge. International Journal of Computer Vision 115(3), 211–252 (2015)
[RGH+06]
M. Riedmiller, T. Gabel, R. Hafner, S. Lange, M. Lauer, Die Brainstormers:
Entwurfsprinzipien lernfähiger autonomer Roboter. Informatik-Spektrum 29(3),
175–190 (2006)
[RHR86]
D.E. Rumelhart, G.E. Hinton, and Williams R.J. Learning Internal Representations
by Error Propagation. in [RM86], 1986
[Ric83]
E. Rich. Artiﬁcial Intelligence. McGraw-Hill, 1983
[Ric03]
M. Richter. Fallbasiertes schließen. In Görz et al. [GRS03], chapter 11, pages
407–430
[RM86]
D. Rumelhart and J. McClelland. Parallel Distributed Processing, volume 1. MIT
Press, 1986
[RM96]
W. Rödder and C.-H. Meyer. Coherent Knowledge Processing at Maximum
Entropy by SPIRIT. In KI-96 (German national conference on AI), Dresden, 1996
[RMD07]
M. Riedmiller, M. Montemerlo, and H. Dahlkamp. Learning to drive a real car in 20
minutes. In FBIT '07: Proceedings of the 2007 Frontiers in the Convergence of
Bioscience and Information Technologies, pages 645–650, Washington, DC, USA,
2007. IEEE Computer Society
[RMS92]
H. Ritter, T. Martinez, and K. Schulten. Neural computation and self-organizing
maps. Addison Wesley, 1992
[RN10]
S. Russell and P. Norvig. Artiﬁcial Intelligence: A Modern Approach. Prentice Hall,
3rd edition, 2010. 1st edition 1995, http://aima.cs.berkeley.edu
[Roba]
Robocup ofﬁcial site. http://www.robocup.org
[Robb]
The robocup soccer simulator. http://sserver.sourceforge.net
[Rob65]
J.A. Robinson, A machine-oriented logic based on the resolution principle. Journal
of the ACM 12(1), 23–41 (1965)
[Rob77]
R. W. Robinson. Counting labeled acyclic digraphs. In F. Harary, editor, New
Directions in the Theory of Graphs, pages 28–43. Academic Press, 1977
[Roj96]
R. Rojas. Neural Networks: a Systematic Introduction. Springer, 1996
[Ros58]
F. Rosenblatt. The perceptron : a probabilistic model for information storage and
organization in the brain. Psychological Reviews, 65:386–408, 1958. Wiederab-
druck in [AR88], S. 92–114
[Ros09]
S.M. Ross. Introduction to probability and statistics for engineers and scientists.
Academic Press, 2009
[Rou87]
P.J. Rousseeuw, Silhouettes: a graphical aid to the interpretation and validation of
cluster analysis. Computational and Applied Mathematics 20, 53–65 (1987)
[RW06]
C.E. Rasmussen and C.K.I. Williams. Gaussian Processes for Machine Learning.
Mit Press, 2006. Online version: http://www.gaussianprocess.org/gpml/chapters/
346
References

[SA94]
S. Schaal, C.G. Atkeson, Robot juggling: implementation of memory-based
learning. IEEE Control Systems Magazine 14(1), 57–71 (1994)
[Sam59]
A.L. Samuel, Some Studies in Machine Learning Using the Game of Checkers. IBM
Journal 1(3), 210–229 (1959)
[Sam67]
A.L. Samuel, Some Studies in Machine Learning Using the Game of Checkers. II.
IBM Journal 11(6), 601–617 (1967)
[SB98]
R. Sutton and A. Barto. Reinforcement Learning. MIT Press, 1998. http://www.cs.
ualberta.ca/sutton/book/the-book.html
[SB04]
J. Siekmann and Ch. Benzmüller. Omega: Computer supported mathematics. In KI
2004: Advances in Artiﬁcial Intelligence, LNAI 3238, pages 3–28. Springer Verlag,
2004. http://www.ags.uni-sb.de/omega
[Sch96]
M.
Schramm.
Indifferenz,
Unabhängigkeit
und
maximale
Entropie:
Eine
wahrscheinlichkeitstheoretische Semantik für Nicht-Monotones Schließen. Number
4 in Dissertationen zur Informatik. CS-Press, München, 1996
[Sch01]
J. Schumann. Automated Theorem Proving in Software Engineering. Springer
Verlag, 2001
[Sch02]
S. Schulz. E – A Brainiac Theorem Prover. Journal of AI Communications, 15
(2/3):111–126,
2002.
http://www4.informatik.tu-muenchen.de/schulz/WORK/
eprover.html
[Sch04]
A. Schwartz. SpamAssassin. O'Reilly, 2004. Spamassassin-Homepage: http://
spamassassin.apache.org
[SE90]
Ch. Suttner and W. Ertel. Automatic Acquisition of Search Guiding Heuristics. In
10th Int. Conf. on Automated Deduction, pages 470–484. Springer-Verlag, LNAI
449, 1990
[SE00]
M. Schramm and W. Ertel. Reasoning with Probabilities and Maximum Entropy:
The System PIT and its Application in LEXMED. In K. Inderfurth et al, editor,
Operations Research Proceeedings (SOR'99), pages 274–280. Springer Verlag,
2000
[SE10]
M. Schneider and W. Ertel. Robot Learning by Demonstration with Local Gaussian
Process Regression. In Proceedings of the IEEE/RSJ International Conference on
Intelligent Robots and Systems (IROS'10), 2010
[SEP16]
M. Schneider, W. Ertel, and G. Palm. Expected similarity estimation for large-scale
batch and streaming anomaly detection. Machine Learning, 2016. accepted
[SET09]
T. Segaran, C. Evans, and J. Taylor. Programming the Semantic Web. O'Reilly,
2009
[SG95]
M. Schramm and M. Greiner. Foundations: Indifference, Independence & Maxent.
In J. Skilling, editor, Maximum Entropy and Bayesian Methods in Science and
Engeneering (Proc. of the MaxEnt'94). Kluwer Academic Publishers, 1995
[SHM+16]
D. Silver, A. Huang, C.J. Maddison, A. Guez, L. Sifre, G. van den Driessche,
J. Schrittwieser, I. Antonoglou, V. Panneershelvam, M. Lanctot et al., Mastering the
game of go with deep neural networks and tree search. Nature 529(7587), 484–489
(2016)
[Sho76]
E.H. Shortliffe, Computer-based medical consultations (MYCIN. North-Holland,
New York, 1976)
[Spe97]
Mysteries of the Mind. Speciel Issue. Scientiﬁc American Inc., 1997
[Spe98]
Exploring Intelligence, volume 9 of Scientiﬁc American presents. Scientiﬁc
American Inc., 1998
[SPR+16]
B. Staehle, S. Pﬁffner, B. Reiner, W. Ertel, B. Weber-Fiori, and M. Winter. Marvin,
ein Assistenzroboter für Menschen mit körperlicher Behinderung im praktischen
Einsatz. In M.A. Pfannstiel, S. Krammer, and W. Swoboda, editors, Digitalisierung
von Dienstleistungen im Gesundheitswesen. Springer Verlag, 2016. http://asrobe.hs-
weingarten.de
References
347

[SR86]
T.J. Sejnowski and C.R. Rosenberg. NETtalk: a parallel network that learns to read
aloud. Technical Report JHU/EECS-86/01, The John Hopkins University Electrical
Engineering and Computer Science Technical Report, 1986. Wiederabdruck in
[AR88] S. 661–672
[SS02]
S. Schölkopf, A. Smola, Learning with Kernels: Support Vector Machines
(Optimization, and Beyond. MIT Press, Regularization, 2002)
[SS06]
G. Sutcliffe and C. Suttner. The State of CASC. AI Communications, 19(1):35–48,
2006. CASC-Homepage: http://www.cs.miami.edu/tptp/CASC
[SS16]
K. Schwab and R. Samans. The future of jobs – employment, skills and workforce
strategy for the fourth industrial revolution. World Economic Forum, http://reports.
weforum.org/future-of-jobs-2016, January 2016
[SSK05]
P.
Stone,
R.S.
Sutton,
and
G.
Kuhlmann.
Reinforcement
Learning
for
RoboCup-Soccer Keepaway. Adaptive Behavior, 2005. http://www.cs.utexas.edu/
pstone/Papers/bib2html-links/AB05.pdf
[Ste07]
J. Stewart. Multivariable Calculus. Brooks Cole, 2007
[SW76]
C.E. Shannon and W. Weaver. Mathematische Grundlagen der Informationsthe-
orie. Oldenbourg Verlag, 1976
[SZ15]
K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale
image recognition. arXiv:1409.1556, 2015
[Sze10]
C. Szepesvari. Algorithms for Reinforcement Learning. Morgan & Claypool
Publishers, 2010. draft available online: http://www.ualberta.ca/szepesva/RLBook.
html
[Tax01]
D.M.J. Tax. One-class classiﬁcation. PhD thesis, Delft University of Technology,
2001
[Ted08]
R. Tedrake. Learning control at intermediate reynolds numbers. In Workshop on:
Robotics Challenges for Machine Learning II, International Conference on
Intelligent Robots and Systems (IROS 2008), Nice, France, 2008
[TEF09]
M. Tokic, W. Ertel, and J. Fessler. The crawler, a class room demonstrator for
reinforcement learning. In In Proceedings of the 22nd International Florida
Artiﬁcial Intelligence Research Society Conference (FLAIRS 09), Menlo Park,
California, 2009. AAAI Press
[Tes95]
G. Tesauro. Temporal difference learning and td-gammon. Communications of the
ACM, 38(3), 1995. http://www.research.ibm.com/massive/tdl.html
[Tok06]
M. Tokic. Entwicklung eines Lernfähigen Laufroboters. Diplomarbeit Hochschule
Ravensburg-Weingarten, 2006. Inklusive Simulationssoftware verfügbar auf http://
www.hs-weingarten.de/ertel/kibuch
[Tur37]
A.M. Turing. On computable numbers, with an application to the Entschei-
dungsproblem. Proceedings of the London Mathemat. Society, 42(2), 1937
[Tur50]
A.M. Turing, Computing Machinery and Intelligence. Mind 59, 433–460 (1950)
[TZ16]
Y. Tian and Y. Zhu. Better computer go player with neural network and long-term
prediction. arXiv preprint arXiv:1511.06410, 2016
[vA06]
L. v. Ahn. Games with a purpose. IEEE Computer Magazine, pages 96–98, Juni
2006. http://www.cs.cmu.edu/biglou/ieee-gwap.pdf
[VLL+10]
P. Vincent, H. Larochelle, I. Lajoie, Y. Bengio, P. Manzagol, Stacked denoising
autoencoders: Learning useful representations in a deep network with a local
denoising criterion. J. Mach. Learn. Res. 11, 3371–3408 (2010)
[VTBE15]
O. Vinyals, A. Toshev, S. Bengio, and D. Erhan. Show and tell: A neural image
caption generator. In Proceedings of the IEEE Conference on Computer Vision and
Pattern Recognition, pages 3156–3164, 2015
[Wei66]
J. Weizenbaum, ELIZA–A Computer Program For the Study of Natural Language
Communication Between Man and Machine. Communications of the ACM 9(1),
36–45 (1966)
348
References

[WF01] I.
Witten and E. Frank. Data Mining. Hanser Verlag München, 2001. (DataMining
Java Library WEKA: http://www.cs.waikato.ac.nz/ml/weka)
[Whi96]
J. Whittaker. Graphical models in applied multivariate statistics. Wiley, 1996
[Wie]
U. Wiedemann. PhilLex, Lexikon der Philosophie. http://www.phillex.de/paradoxa.
htm
[Wie04]
J. Wielemaker. SWI-Prolog 5.4. Universität Amsterdam, 2004. http://www.swi-
prolog.org
[Wik13]
Wikipedia, the free enzyclopedia. http://en.wikipedia.org, 2013
[Win]
P. Winston. Game demonstration. http://www.ai.mit.edu/courses/6.034f/gamepair.
html. Java Applet for Minimax- and Alpha-Beta-Search
[Zdz05]
J. Zdziarski. Ending Spam. No Starch Press, 2005
[Zel94]
A. Zell. Simulation Neuronaler Netze. Addison Wesley, 1994. Description of SNNS
and JNNS: http://www-ra.informatik.uni-tuebingen.de/SNNS
[ZSR+99]
A. Zielke, H. Sitter, T.A. Rampp, E. Sch''afer, C. Hasse, W. Lorenz, and M.
Rothmund. Überprüfung eines diagnostischen Scoresystems (Ohmann-Score) für
die akute Appendizitis. Chirurg 70, 777–783 (1999)
[ZW94]
W.C. Zimmerli, S. Wolf (eds.), Künstliche Intelligenz – Philosophische Probleme
(Philipp Reclam, Stuttgart, 1994)
References
349

Index
A
A⋆-algorithm, 107, 273
Action, 97, 98
Activation function, 248, 258
Actuators, 17
Adaptive Resonance Theory (ART), 286
Admissible, 107, 109
Agent, 3, 17, 289, 290, 293, 296, 297, 300,
301, 303, 305
autonomous, 10
cost-based, 18
distributed, 10
goal-based, 17
hardware, 17
intelligent, 17
learning, 11, 18, 178
reﬂex, 17
software, 17
utility-based, 18
with memory, 17
Agents, distributed, 18
Alarm-example, 159
Alpha-beta pruning, 115
AlphaGo, 7, 119, 121, 306, 308
And branches, 79
And-or tree, 79
Appendicitis, 133, 145
Approximation, 178, 193
A priori probability, 131, 135
Artiﬁcial Intelligence (AI), 1
Associative memory, 256
Attribute, 118, 199
Auto-associative memory, 250, 257, 261
Autoencoder, 279
Automation, 12
Automotive industry, 14
Autonomous robots, 11
B
Backgammon, 306
Backpropagation, 279, 298, 322
learning rule, 270
Backtracking, 77, 99
Backward chaining, 35
Batch learning, 217, 266
Bayes formula. See Bayes theorem
Bayesian network, 6, 10, 72, 77, 127, 158, 160,
198
learning, 241
Bayes theorem, 134, 163
BDD. See Binary decision diagram
Bellman
equation, 295
principle, 295
Bias unit, 187
Bias variance tradeoff, 214
Binary decision diagram, 37
Boltzmann machine, 256
Brain science, 3
Braitenberg vehicle, 2, 10, 193
Branching factor, 91, 95
average, 92
effective, 95
Built-in predicate, 84
C
C4.5, 198, 216
Calculus, 28
Gentzen, 49
natural reasoning, 49
sequent, 49
Cancer diagnosis, 134
Car, 14
CART, 198, 212
CASC, 57
© Springer International Publishing AG 2017
W. Ertel, Introduction to Artificial Intelligence, Undergraduate Topics
in Computer Science, DOI 10.1007/978-3-319-58487-4
351

Case base, 197
Case-based reasoning, 197
CBR. See Case-based reasoning
Certainty factors, 126
Chain rule for Bayesian networks, 132, 168,
169
Chatterbots, 5
Checkers, 114, 120
Chess, 114, 117, 120, 121, 306
Church, Alonso, 7
Classiﬁcation, 178
Classiﬁer, 178, 223, 268
Clause, 29
deﬁnite, 34
-head, 34
Closed formula, 41
CLP. See Constraint logic programming
Cluster, 225
Clustering, 224, 238
hierarchical, 22
Cognitive science, 3
Complementary, 31
Complete, 28
Computer diagnostic, 158
Conclusion, 34
Conditionally independent, 160, 169
Conditional probability, 137
table. See CPT
Conditioning, 163, 169
Confusion matrix, 234
Conjunction, 24, 29
Conjunctive Normal Form (CNF), 29
Connectionism, 9
Consistent, 31
Constant, 40
Constraint logic programming, 86
Constraint Satisfaction Problem (CSP), 86
Contraction hierarchies, 111
Convolutional Neural Network (CNN), 277,
280, 282, 307
Correlation, 151
coefﬁcient, 182
matrix, 238
Cost estimate function, 105
Cost function, 95, 107
Cost matrix, 150, 155
CPT, 160, 170, 216, 218
Creativity, 282, 283
Credit assignment, 119, 292
Cross-validation, 212, 213, 279, 281
Curse of dimensionality, 309
Cut, 79
D
DAG, 169, 216
Data mining, 179, 180, 197, 198, 211
Data scientist, 277
Decision, 153
Decision tree, 198
induction, 180, 199
learning, 309
Deep belief network, 277, 280
Deep learning, 121, 238, 277, 307, 308
Default logic, 71
Default rule, 71
Delta rule, 266, 268
generalized, 270
Demodulation, 56
De Morgan, 45
Dempster–Schäfer theory, 127
Dependency graph, 151
Depth limit, 100
Derivation, 28
Deterministic, 97, 114
Diagnosis system, 146
Disjunction, 24, 29
Distance metric, 225
Distributed Artiﬁcial Intelligence (DAI), 10
Distributed learning, 309
Distribution, 130, 148
D-separation, 170
Dynamic programming, 296
E
Eager learning, 196, 237
Economic growth, 12
Economy, 12
E-learning, 5
Elementary event, 128
Eliza, 5
EM algorithm, 217, 228, 232
Entropy, 202
maximum, 127, 136
Environment, 12, 17, 18
continuous, 18
deterministic, 18
discrete, 18
nondeterministic, 18
observable, 18
partially observable, 18
Equation, directed, 55
Equivalence, 24
352
Index

Evaluation function, 114
Event, 128
Expert system, 145, 158
F
Fact, 34
Factorization, 31, 54
False negative, 155
False positive, 155
Farthest neighbor algorithm, 230
Feature, 118, 176, 185, 198, 237, 277
Feature space, 177
Feedforward networks, 285
Finite domain constraint solver, 87
First-order sentence, 41
First we solidify, 40
Forward chaining, 35
Frame problem, 71
Free variables, 41
Function symbol, 40
Fuzzy logic, 10, 72, 127
G
Gaussian process, 195, 236
Generalization, 178
General Problem Solver (GPS), 6
Genetic programming, 83
Go, 114, 120, 122, 306, 308
Goal, 36
stack, 36
state, 94
Gödel
incompleteness theorem, 7
Kurt, 7
’s completeness theorem, 7
’s incompleteness theorem, 68
Google DeepMind, 121, 307
Gradient descent, 267
Greedy search, 106, 107, 217, 232
Ground term, 50
H
Halting problem, 7
Hebb rule, 249, 258, 270
binary, 259
Heuristic, 103
Heuristic evaluation function, 104, 107
Hierarchical learning, 309
Home automation, 15
Hopﬁeld network, 250, 251, 260
Horn clause, 34, 80
Hugin, 164
I
ID3, 198
IDA⋆-algorithm, 113
Immediate reward, 292
Implication, 24
Incremental gradient descent, 268
Incremental learning, 266
Independent, 131
conditionally, 160, 169
Indifference, 140
Indifferent variables, 146
Industry 4.0, 11
Inference machine, 50
Inference mechanism, 19
Information content, 203
Information gain, 200, 203, 237
Input resolution, 55
Internet of Things, 11, 15
Interpretation, 24, 41
Iterative deepening, 100, 102
IT security, 15
J
JavaBayes, 164
Jobs, 11
K
Kernel, 195, 277
Kernel methods, 277
Kernel PCA, 280
K-means, 226
k-nearest neighbor method, 192, 194, 213
KNIME, 199, 233
Knowledge, 19
base, 160
consistent, 31
engineer, 11, 19
sources, 19
L
Landmark, 109
heuristic, 110
Laplace assumption, 129
Laplace probabilities, 129
Law of economy, 211
Lazy learning, 196
Learning, 171, 176, 198
batch, 266
by demonstration, 309
Index
353

Learning (cont.)
distributed, 309
hierarchical, 309
incremental, 218, 266
machine, 151
multi-agent, 309
one-class, 222
reinforcement, 97, 175, 307
semi-supervised, 236
supervised, 176, 225, 261
unsupervised, 278
Learning agent, 178
Learning phase, 178
Learning rate, 249, 267
Least squares, 157, 264, 265, 269
Leave-one-out cross-validation, 214
LEXMED, 127, 136, 145, 207
Limited resources, 104
Linear approximation, 268
Linearly separable, 183, 184
LIPS, 76
LISP, 6, 8
Literal, 29
complementary, 31
Locally weighted linear regression, 197
Logic
fuzzy, 127
higher-order, 6
probabilistic, 19
Logically valid, 25
Logic Theorist, 6, 8
M
Machine learning, 148, 175
Manhattan distance, 112, 226
Marginal distribution, 133
Marginalization, 133, 137, 169
Markov Decision Process (MDP), 17, 293, 305
deterministic, 301
nondeterministic, 305
partially observable, 293
Material implication, 127, 142
MaxEnt, 127, 140, 143, 145, 150, 164, 170
distribution, 140
Memorization, 176
Memory-based learning, 196, 197
Metaparameter, 281
MGU, 53
Minimum cash reserve ratio, 13
Minimum spanning tree, 229
Mining, 179
Model, 25
Model complexity, 213, 214
Modus ponens, 126, 139
Momentum, 275
Monotonic, 69
Monte Carlo Tree Search (MCTS), 7, 119, 122,
307
Multi-agent systems, 6
MYCIN, 126, 146
N
Naive Bayes, 157, 159, 171, 180, 189, 218,
220, 242
classiﬁcation, 190
classiﬁer, 218, 220
method, 189
Naive reverse, 82
Navier–Stokes equation, 306
Nearest neighbor
classiﬁcation, 190
method, 189
Nearest neighbor algorithm, 229
Nearest neighbor method, 223
Nearest neighbor data description, 223
Negation, 24
Negation as failure, 80
Neural network, 6, 8, 194, 195, 238, 245
recurrent, 255, 257, 282
Neuroinformatics, 255
Neuroscience, 3
Neurotransmitter, 247
Noise, 191
Non-monotonic logic, 144
Normal equations, 265
Normal form
conjunctive, 29
prenex, 46
Normalization, 223, 280
O
Object classiﬁcation, 277, 281
Observable, 97, 114
Occam’s razor, 211
OMRk algorithm, 232
One-class learning, 222, 223
Ontology, 63
Or branches, 79
Orthonormal, 258
Othello, 114
Outlier detection, 223
Overﬁtting, 191, 211, 213–215, 217, 263, 265,
276
OWL, 63
P
Paradox, 68
Paramodulation, 56
354
Index

Partially Observable Markov Decision Process
(POMDP), 293
Penguin problem, 85
Perceptron, 192, 196, 249
Phase transition, 254
PIT, 143, 144, 164, 172
PL1, 19, 40
Planning, 83
Plans, 85
Policy, 292
gradient method, 305
policy based on its, 292
Postcondition, 62
Precondition, 61
Predicate logic, 7
ﬁrst-order, 20, 40
Preference learning, 180
Premise, 34
Principal Component Analysis (PCA), 277,
280
Probabilistic
logic, 20, 71
reasoning, 9
Probability, 126, 128
distribution, 130
rules, 150
Product rule, 132
Program veriﬁcation, 61
PROLOG, 6, 9, 75
Proof system, 26
Propositional
calculus, 20
logic, 23
Proposition variables, 23
Pruning, 206, 212
Pure literal rule, 55
Q
Q-learning, 300
convergence, 303
Quickprop, 275
R
Random variables, 128
Rapid prototyping, 87
RDF, 63
Real-time decision, 104
Real-time requirement, 114
Receiver operating characteristic, 156
Reinforcement
learning, 119, 292
negative, 292
positive, 292
Resolution, 8, 30
calculus, 6, 28
rule, 30
general, 30, 52
SLD, 35
Resolvent, 30
Reward
discounted, 292
immediate, 292
Risk management, 155
Road transportation, 14
RoboCup, 7, 306
Robot, 17, 289, 293
car, 14, 15
taxi, 14
walking, 289
ROC curve, 157, 235
RProp, 275, 279
S
Sample, 199
Satisﬁable, 25
Scatterplot diagram, 177
Science ﬁction, 11
Score, 146, 157, 223, 242, 266
Search
algorithm, 94
complete, 95
optimal, 96
bidirectional, 110
heuristic, 92
space, 31, 35
tree, 94
uninformed, 92
Self-driving car, 14
Self-organizing maps, 285
Semantics
declarative (PROLOG), 78
procedural (PROLOG), 78, 82
Semantic trees, 36
Semantic web, 62
Semi-decidable, 67
Semi-supervised learning, 236
Sensitivity, 135, 156, 162
Sensor, 17
Service robotics, 15
Set of support strategy, 55
Sigmoid function, 249, 264, 269
Signature, 23
Silhouette width criterion, 231
Similarity, 189
Simulated annealing, 256
Situation calculus, 71
Index
355

Skolemization, 48
SLD resolution, 38
Software reuse, 61
Solution, 95
Sound, 28
Space, 49, 95
Spam, 220
ﬁlter, 220
Sparse coding, 279
Speciﬁcity, 135, 156
Stacked denoising autoencoder,
279, 280
Starting state, 94
State, 94, 95
space, 95
transition function, 292
Statistical induction, 150
Stochastic gradient descent, 308
Subgoal, 36, 77
Substitution axiom, 45
Subsumption, 55
Support vector data description, 223
Support vector machine, 195, 276,
280
Sustainability, 13
SVM. See Support vector machine
Symbol grounding, 85
T
Target function, 178
Tautology, 26
TD, 304
-error, 304
-gammon, 306
-learning, 304
Teaching-Box, 310
Temporal difference
error, 304
learning, 301
Term
rewriting, 56
Test data, 178, 211
Text
classiﬁcation, 220
mining, 180
Theorem, 134, 169
Theorem prover, 8, 50
Training data, 178, 211
Transition function, 292, 303
Transportation, 12
True, 42
Truth table, 24
method, 27
Turing
Alan, 7
test, 5
Tweety example, 144
U
Uniﬁable, 53
Uniﬁcation, 52
Uniﬁer, 53
most general, 53
Uniform cost search, 99
Unit
clause, 55
resolution, 55
Unsatisﬁable, 25
V
Valid, 25, 43
Value iteration, 308
Variable, 40
Vienna Development Method Speciﬁcation
Language (VDM-SL), 62
Voronoi diagram, 191
W
Walking robot, 290
Warren Abstract Machine (WAM),
76, 82
Watson, 20
WEKA, 199, 233
Whitening, 280
356
Index

