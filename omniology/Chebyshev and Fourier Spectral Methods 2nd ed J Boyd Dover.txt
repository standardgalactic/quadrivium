Chebyshev and Fourier Spectral Methods
Second Edition
John P. Boyd
University of Michigan
Ann Arbor, Michigan 48109-2143
email: jpboyd@engin.umich.edu
http://www-personal.engin.umich.edu/∼jpboyd/
2000
DOVER Publications, Inc.
31 East 2nd Street
Mineola, New York 11501
1

Dedication
To Marilyn, Ian, and Emma
“A computation is a temptation that should be resisted as
long as possible.”
— J. P. Boyd, paraphrasing T. S. Eliot
i

Contents
PREFACE
x
Acknowledgments
xiv
Errata and Extended-Bibliography
xvi
1
Introduction
1
1.1
Series expansions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2
First Example
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.3
Comparison with ﬁnite element methods . . . . . . . . . . . . . . . . . . . .
4
1.4
Comparisons with Finite Differences . . . . . . . . . . . . . . . . . . . . . . .
6
1.5
Parallel Computers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
1.6
Choice of basis functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
1.7
Boundary conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
1.8
Non-Interpolating and Pseudospectral . . . . . . . . . . . . . . . . . . . . . .
12
1.9
Nonlinearity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
1.10 Time-dependent problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
1.11 FAQ: Frequently Asked Questions . . . . . . . . . . . . . . . . . . . . . . . .
16
1.12 The Chrysalis
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
2
Chebyshev & Fourier Series
19
2.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
2.2
Fourier series
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
2.3
Orders of Convergence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25
2.4
Convergence Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
2.5
Assumption of Equal Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
2.6
Darboux’s Principle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
2.7
Why Taylor Series Fail . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
2.8
Location of Singularities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
36
2.8.1
Corner Singularities & Compatibility Conditions
. . . . . . . . . . .
37
2.9
FACE: Integration-by-Parts Bound . . . . . . . . . . . . . . . . . . . . . . . .
41
2.10 Asymptotic Calculation of Fourier Coefﬁcients . . . . . . . . . . . . . . . . .
45
2.11 Convergence Theory: Chebyshev Polynomials . . . . . . . . . . . . . . . . .
46
2.12 Last Coefﬁcient Rule-of-Thumb . . . . . . . . . . . . . . . . . . . . . . . . . .
50
2.13 Convergence Theory for Legendre Polynomials . . . . . . . . . . . . . . . . .
51
2.14 Quasi-Sinusoidal Rule of Thumb . . . . . . . . . . . . . . . . . . . . . . . . .
54
2.15 Witch of Agnesi Rule–of–Thumb . . . . . . . . . . . . . . . . . . . . . . . . .
56
2.16 Boundary Layer Rule-of-Thumb
. . . . . . . . . . . . . . . . . . . . . . . . .
57
ii

CONTENTS
iii
3
Galerkin & Weighted Residual Methods
61
3.1
Mean Weighted Residual Methods . . . . . . . . . . . . . . . . . . . . . . . .
61
3.2
Completeness and Boundary Conditions
. . . . . . . . . . . . . . . . . . . .
64
3.3
Inner Product & Orthogonality . . . . . . . . . . . . . . . . . . . . . . . . . .
65
3.4
Galerkin Method
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
3.5
Integration-by-Parts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
3.6
Galerkin Method: Case Studies . . . . . . . . . . . . . . . . . . . . . . . . . .
70
3.7
Separation-of-Variables & the Galerkin Method . . . . . . . . . . . . . . . . .
76
3.8
Heisenberg Matrix Mechanics . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
3.9
The Galerkin Method Today . . . . . . . . . . . . . . . . . . . . . . . . . . . .
80
4
Interpolation, Collocation & All That
81
4.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
81
4.2
Polynomial interpolation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
82
4.3
Gaussian Integration & Pseudospectral Grids . . . . . . . . . . . . . . . . . .
86
4.4
Pseudospectral Is Galerkin Method via Quadrature
. . . . . . . . . . . . . .
89
4.5
Pseudospectral Errors
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
93
5
Cardinal Functions
98
5.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
98
5.2
Whittaker Cardinal or “Sinc” Functions . . . . . . . . . . . . . . . . . . . . .
99
5.3
Trigonometric Interpolation . . . . . . . . . . . . . . . . . . . . . . . . . . . .
100
5.4
Cardinal Functions for Orthogonal Polynomials
. . . . . . . . . . . . . . . .
104
5.5
Transformations and Interpolation . . . . . . . . . . . . . . . . . . . . . . . .
107
6
Pseudospectral Methods for BVPs
109
6.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
109
6.2
Choice of Basis Set
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
109
6.3
Boundary Conditions: Behavioral & Numerical . . . . . . . . . . . . . . . . .
109
6.4
“Boundary-Bordering” . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
111
6.5
“Basis Recombination” . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
112
6.6
Transﬁnite Interpolation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
114
6.7
The Cardinal Function Basis . . . . . . . . . . . . . . . . . . . . . . . . . . . .
115
6.8
The Interpolation Grid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
116
6.9
Computing Basis Functions & Derivatives . . . . . . . . . . . . . . . . . . . .
116
6.10 Higher Dimensions: Indexing . . . . . . . . . . . . . . . . . . . . . . . . . . .
118
6.11 Higher Dimensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
120
6.12 Corner Singularities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
120
6.13 Matrix methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
121
6.14 Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
121
6.15 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
123
7
Linear Eigenvalue Problems
127
7.1
The No-Brain Method
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
127
7.2
QR/QZ Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
128
7.3
Eigenvalue Rule-of-Thumb
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
129
7.4
Four Kinds of Sturm-Liouville Problems . . . . . . . . . . . . . . . . . . . . .
134
7.5
Criteria for Rejecting Eigenvalues . . . . . . . . . . . . . . . . . . . . . . . . .
137
7.6
“Spurious” Eigenvalues
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
139
7.7
Reducing the Condition Number . . . . . . . . . . . . . . . . . . . . . . . . .
142
7.8
The Power Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
145
7.9
Inverse Power Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
149

iv
CONTENTS
7.10 Combining Global & Local Methods . . . . . . . . . . . . . . . . . . . . . . .
149
7.11 Detouring into the Complex Plane . . . . . . . . . . . . . . . . . . . . . . . .
151
7.12 Common Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
155
8
Symmetry & Parity
159
8.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
159
8.2
Parity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
159
8.3
Modifying the Grid to Exploit Parity . . . . . . . . . . . . . . . . . . . . . . .
165
8.4
Other Discrete Symmetries . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
165
8.5
Axisymmetric & Apple-Slicing Models . . . . . . . . . . . . . . . . . . . . . .
170
9
Explicit Time-Integration Methods
172
9.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
172
9.2
Spatially-Varying Coefﬁcients . . . . . . . . . . . . . . . . . . . . . . . . . . .
175
9.3
The Shamrock Principle
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
177
9.4
Linear and Nonlinear . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
178
9.5
Example: KdV Equation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
179
9.6
Implicitly-Implicit: RLW & QG . . . . . . . . . . . . . . . . . . . . . . . . . .
181
10 Partial Summation, the FFT and MMT
183
10.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
183
10.2 Partial Summation
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
184
10.3 The Fast Fourier Transform: Theory
. . . . . . . . . . . . . . . . . . . . . . .
187
10.4 Matrix Multiplication Transform
. . . . . . . . . . . . . . . . . . . . . . . . .
190
10.5 Costs of the Fast Fourier Transform . . . . . . . . . . . . . . . . . . . . . . . .
192
10.6 Generalized FFTs and Multipole Methods . . . . . . . . . . . . . . . . . . . .
195
10.7 Off-Grid Interpolation
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
198
10.8 Fast Fourier Transform: Practical Matters . . . . . . . . . . . . . . . . . . . .
200
10.9 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
200
11 Aliasing, Spectral Blocking, & Blow-Up
202
11.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
202
11.2 Aliasing and Equality-on-the-Grid . . . . . . . . . . . . . . . . . . . . . . . .
202
11.3 “2 h-Waves” and Spectral Blocking . . . . . . . . . . . . . . . . . . . . . . . .
205
11.4 Aliasing Instability: History and Remedies
. . . . . . . . . . . . . . . . . . .
210
11.5 Dealiasing and the Orszag Two-Thirds Rule . . . . . . . . . . . . . . . . . . .
211
11.6 Energy-Conserving: Constrained Interpolation . . . . . . . . . . . . . . . . .
213
11.7 Energy-Conserving Schemes: Discussion
. . . . . . . . . . . . . . . . . . . .
214
11.8 Aliasing Instability: Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . .
216
11.9 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
218
12 Implicit Schemes & the Slow Manifold
222
12.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
222
12.2 Dispersion and Amplitude Errors . . . . . . . . . . . . . . . . . . . . . . . . .
224
12.3 Errors & CFL Limit for Explicit Schemes . . . . . . . . . . . . . . . . . . . . .
226
12.4 Implicit Time-Marching Algorithms
. . . . . . . . . . . . . . . . . . . . . . .
228
12.5 Semi-Implicit Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
229
12.6 Speed-Reduction Rule-of-Thumb . . . . . . . . . . . . . . . . . . . . . . . . .
230
12.7 Slow Manifold: Meteorology
. . . . . . . . . . . . . . . . . . . . . . . . . . .
231
12.8 Slow Manifold: Deﬁnition & Examples . . . . . . . . . . . . . . . . . . . . . .
232
12.9 Numerically-Induced Slow Manifolds . . . . . . . . . . . . . . . . . . . . . .
236
12.10Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
239

CONTENTS
v
12.11The Method of Multiple Scales(Baer-Tribbia)
. . . . . . . . . . . . . . . . . .
241
12.12Nonlinear Galerkin Methods
. . . . . . . . . . . . . . . . . . . . . . . . . . .
243
12.13Weaknesses of the Nonlinear Galerkin Method . . . . . . . . . . . . . . . . .
245
12.14Tracking the Slow Manifold . . . . . . . . . . . . . . . . . . . . . . . . . . . .
248
12.15Three Parts to Multiple Scale Algorithms
. . . . . . . . . . . . . . . . . . . .
249
13 Splitting & Its Cousins
252
13.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
252
13.2 Fractional Steps for Diffusion . . . . . . . . . . . . . . . . . . . . . . . . . . .
255
13.3 Pitfalls in Splitting, I: Boundary Conditions . . . . . . . . . . . . . . . . . . .
256
13.4 Pitfalls in Splitting, II: Consistency . . . . . . . . . . . . . . . . . . . . . . . .
258
13.5 Operator Theory of Time-Stepping . . . . . . . . . . . . . . . . . . . . . . . .
259
13.6 High Order Splitting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
261
13.7 Splitting and Fluid Mechanics . . . . . . . . . . . . . . . . . . . . . . . . . . .
262
14 Semi-Lagrangian Advection
265
14.1 Concept of an Integrating Factor
. . . . . . . . . . . . . . . . . . . . . . . . .
265
14.2 Misuse of Integrating Factor Methods . . . . . . . . . . . . . . . . . . . . . .
267
14.3 Semi-Lagrangian Advection: Introduction . . . . . . . . . . . . . . . . . . . .
270
14.4 Advection & Method of Characteristics
. . . . . . . . . . . . . . . . . . . . .
271
14.5 Three-Level, 2D Order Semi-Implicit . . . . . . . . . . . . . . . . . . . . . . .
273
14.6 Multiply-Upstream SL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
275
14.7 Numerical Illustrations & Superconvergence . . . . . . . . . . . . . . . . . .
277
14.8 Two-Level SL/SI Algorithms
. . . . . . . . . . . . . . . . . . . . . . . . . . .
280
14.9 Noninterpolating SL & Numerical Diffusion
. . . . . . . . . . . . . . . . . .
281
14.10Off-Grid Interpolation
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
283
14.10.1 Off-Grid Interpolation: Generalities . . . . . . . . . . . . . . . . . . .
283
14.10.2 Spectral Off-grid
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
284
14.10.3 Low-order Polynomial Interpolation . . . . . . . . . . . . . . . . . . .
284
14.10.4 McGregor’s Taylor Series Scheme
. . . . . . . . . . . . . . . . . . . .
286
14.11Higher Order SL Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
286
14.12History and Relationships to Other Methods . . . . . . . . . . . . . . . . . .
286
14.13Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
289
15 Matrix-Solving Methods
290
15.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
290
15.2 Stationary One-Step Iterations . . . . . . . . . . . . . . . . . . . . . . . . . . .
291
15.3 Preconditioning: Finite Difference
. . . . . . . . . . . . . . . . . . . . . . . .
293
15.4 Computing Iterates: FFT/Matrix Multiplication
. . . . . . . . . . . . . . . .
297
15.5 Alternative Preconditioners . . . . . . . . . . . . . . . . . . . . . . . . . . . .
299
15.6 Raising the Order Through Preconditioning . . . . . . . . . . . . . . . . . . .
301
15.7 Multigrid: An Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
301
15.8 MRR Method
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
304
15.9 Delves-Freeman Block-and-Diagonal Iteration
. . . . . . . . . . . . . . . . .
307
15.10Recursions & Formal Integration: Constant Coefﬁcient ODEs . . . . . . . . .
312
15.11Direct Methods for Separable PDE’s
. . . . . . . . . . . . . . . . . . . . . . .
314
15.12Fast Iterations for Almost Separable PDEs . . . . . . . . . . . . . . . . . . . .
317
15.13Positive Deﬁnite and Indeﬁnite Matrices . . . . . . . . . . . . . . . . . . . . .
318
15.14Preconditioned Newton Flow . . . . . . . . . . . . . . . . . . . . . . . . . . .
320
15.15Summary & Proverbs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
322

vi
CONTENTS
16 Coordinate Transformations
323
16.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
323
16.2 Programming Chebyshev Methods . . . . . . . . . . . . . . . . . . . . . . . .
323
16.3 Theory of 1-D Transformations . . . . . . . . . . . . . . . . . . . . . . . . . .
325
16.4 Inﬁnite and Semi-Inﬁnite Intervals . . . . . . . . . . . . . . . . . . . . . . . .
326
16.5 Maps for Endpoint & Corner Singularities . . . . . . . . . . . . . . . . . . . .
327
16.6 Two-Dimensional Maps & Corner Branch Points . . . . . . . . . . . . . . . .
329
16.7 Periodic Problems & the Arctan/Tan Map . . . . . . . . . . . . . . . . . . . .
330
16.8 Adaptive Methods
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
332
16.9 Almost-Equispaced Kosloff/Tal-Ezer Grid . . . . . . . . . . . . . . . . . . . .
334
17 Methods for Unbounded Intervals
338
17.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
338
17.2 Domain Truncation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
339
17.2.1 Domain Truncation for Rapidly-decaying Functions . . . . . . . . . .
339
17.2.2 Domain Truncation for Slowly-Decaying Functions . . . . . . . . . .
340
17.2.3 Domain Truncation for Time-Dependent Wave Propagation:
Sponge Layers
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
340
17.3 Whittaker Cardinal or “Sinc” Functions . . . . . . . . . . . . . . . . . . . . .
341
17.4 Hermite functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
346
17.5 Semi-Inﬁnite Interval: Laguerre Functions . . . . . . . . . . . . . . . . . . . .
353
17.6 New Basis Sets via Change of Coordinate . . . . . . . . . . . . . . . . . . . .
355
17.7 Rational Chebyshev Functions: TBn . . . . . . . . . . . . . . . . . . . . . . .
356
17.8 Behavioral versus Numerical Boundary Conditions . . . . . . . . . . . . . .
361
17.9 Strategy for Slowly Decaying Functions . . . . . . . . . . . . . . . . . . . . .
363
17.10Numerical Examples: Rational Chebyshev Functions
. . . . . . . . . . . . .
366
17.11Semi-Inﬁnite Interval: Rational Chebyshev TLn
. . . . . . . . . . . . . . . .
369
17.12Numerical Examples: Chebyshev for Semi-Inﬁnite Interval . . . . . . . . . .
370
17.13Strategy: Oscillatory, Non-Decaying Functions . . . . . . . . . . . . . . . . .
372
17.14Weideman-Cloot Sinh Mapping . . . . . . . . . . . . . . . . . . . . . . . . . .
374
17.15Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
377
18 Spherical & Cylindrical Geometry
380
18.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
380
18.2 Polar, Cylindrical, Toroidal, Spherical
. . . . . . . . . . . . . . . . . . . . . .
381
18.3 Apparent Singularity at the Pole
. . . . . . . . . . . . . . . . . . . . . . . . .
382
18.4 Polar Coordinates: Parity Theorem . . . . . . . . . . . . . . . . . . . . . . . .
383
18.5 Radial Basis Sets and Radial Grids . . . . . . . . . . . . . . . . . . . . . . . .
385
18.5.1 One-Sided Jacobi Basis for the Radial Coordinate
. . . . . . . . . . .
387
18.5.2 Boundary Value & Eigenvalue Problems on a Disk . . . . . . . . . . .
389
18.5.3 Unbounded Domains Including the Origin in Cylindrical Coordinates 390
18.6 Annular Domains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
390
18.7 Spherical Coordinates: An Overview . . . . . . . . . . . . . . . . . . . . . . .
391
18.8 The Parity Factor for Scalars: Sphere versus Torus . . . . . . . . . . . . . . .
391
18.9 Parity II: Horizontal Velocities & Other Vector Components . . . . . . . . . .
395
18.10The Pole Problem: Spherical Coordinates
. . . . . . . . . . . . . . . . . . . .
398
18.11Spherical Harmonics: Introduction . . . . . . . . . . . . . . . . . . . . . . . .
399
18.12Legendre Transforms and Other Sorrows
. . . . . . . . . . . . . . . . . . . .
402
18.12.1 FFT in Longitude/MMT in Latitude . . . . . . . . . . . . . . . . . . .
402
18.12.2 Substitutes and Accelerators for the MMT . . . . . . . . . . . . . . . .
403
18.12.3 Parity and Legendre Transforms . . . . . . . . . . . . . . . . . . . . .
404

CONTENTS
vii
18.12.4 Hurrah for Matrix/Vector Multiplication . . . . . . . . . . . . . . . .
404
18.12.5 Reduced Grid and Other Tricks . . . . . . . . . . . . . . . . . . . . . .
405
18.12.6 Schuster-Dilts Triangular Matrix Acceleration
. . . . . . . . . . . . .
405
18.12.7 Generalized FFT: Multipoles and All That . . . . . . . . . . . . . . . .
407
18.12.8 Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
407
18.13Equiareal Resolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
408
18.14Spherical Harmonics: Limited-Area Models . . . . . . . . . . . . . . . . . . .
409
18.15Spherical Harmonics and Physics . . . . . . . . . . . . . . . . . . . . . . . . .
410
18.16Asymptotic Approximations, I
. . . . . . . . . . . . . . . . . . . . . . . . . .
410
18.17Asymptotic Approximations, II . . . . . . . . . . . . . . . . . . . . . . . . . .
412
18.18Software: Spherical Harmonics . . . . . . . . . . . . . . . . . . . . . . . . . .
414
18.19Semi-Implicit: Shallow Water . . . . . . . . . . . . . . . . . . . . . . . . . . .
416
18.20Fronts and Topography: Smoothing/Filters . . . . . . . . . . . . . . . . . . .
418
18.20.1 Fronts and Topography
. . . . . . . . . . . . . . . . . . . . . . . . . .
418
18.20.2 Mechanics of Filtering . . . . . . . . . . . . . . . . . . . . . . . . . . .
419
18.20.3 Spherical splines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
420
18.20.4 Filter Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
422
18.20.5 Filtering with Spatially-Variable Order
. . . . . . . . . . . . . . . . .
423
18.20.6 Topographic Filtering in Meteorology . . . . . . . . . . . . . . . . . .
423
18.21Resolution of Spectral Models . . . . . . . . . . . . . . . . . . . . . . . . . . .
425
18.22Vector Harmonics & Hough Functions . . . . . . . . . . . . . . . . . . . . . .
428
18.23Radial/Vertical Coordinate: Spectral or Non-Spectral? . . . . . . . . . . . . .
429
18.23.1 Basis for Axial Coordinate in Cylindrical Coordinates . . . . . . . . .
429
18.23.2 Axial Basis in Toroidal Coordinates
. . . . . . . . . . . . . . . . . . .
429
18.23.3 Vertical/Radial Basis in Spherical Coordinates . . . . . . . . . . . . .
429
18.24Stellar Convection in a Spherical Annulus: Glatzmaier (1984) . . . . . . . . .
430
18.25Non-Tensor Grids: Icosahedral, etc. . . . . . . . . . . . . . . . . . . . . . . . .
431
18.26Robert Basis for the Sphere . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
433
18.27Parity-Modiﬁed Latitudinal Fourier Series . . . . . . . . . . . . . . . . . . . .
434
18.28Projective Filtering for Latitudinal Fourier Series . . . . . . . . . . . . . . . .
435
18.29Spectral Elements on the Sphere . . . . . . . . . . . . . . . . . . . . . . . . . .
437
18.30Spherical Harmonics Besieged . . . . . . . . . . . . . . . . . . . . . . . . . . .
438
18.31Elliptic and Elliptic Cylinder Coordinates . . . . . . . . . . . . . . . . . . . .
439
18.32Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
440
19 Special Tricks
442
19.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
442
19.2 Sideband Truncation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
443
19.3 Special Basis Functions, I: Corner Singularities . . . . . . . . . . . . . . . . .
446
19.4 Special Basis Functions, II: Wave Scattering . . . . . . . . . . . . . . . . . . .
448
19.5 Weakly Nonlocal Solitary Waves
. . . . . . . . . . . . . . . . . . . . . . . . .
450
19.6 Root-Finding by Chebyshev Polynomials . . . . . . . . . . . . . . . . . . . .
450
19.7 Hilbert Transform . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
453
19.8 Spectrally-Accurate Quadrature Methods . . . . . . . . . . . . . . . . . . . .
454
19.8.1 Introduction: Gaussian and Clenshaw-Curtis Quadrature
. . . . . .
454
19.8.2 Clenshaw-Curtis Adaptivity
. . . . . . . . . . . . . . . . . . . . . . .
455
19.8.3 Mechanics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
456
19.8.4 Integration of Periodic Functions and the Trapezoidal Rule . . . . . .
457
19.8.5 Inﬁnite Intervals and the Trapezoidal Rule . . . . . . . . . . . . . . .
458
19.8.6 Singular Integrands
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
458
19.8.7 Sets and Solitaries
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
460

viii
CONTENTS
20 Symbolic Calculations
461
20.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
461
20.2 Strategy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
462
20.3 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
465
20.4 Summary and Open Problems . . . . . . . . . . . . . . . . . . . . . . . . . . .
472
21 The Tau-Method
473
21.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
473
21.2 τ-Approximation for a Rational Function
. . . . . . . . . . . . . . . . . . . .
474
21.3 Differential Equations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
476
21.4 Canonical Polynomials . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
476
21.5 Nomenclature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
478
22 Domain Decomposition Methods
479
22.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
479
22.2 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
480
22.3 Connecting the Subdomains: Patching . . . . . . . . . . . . . . . . . . . . . .
480
22.4 Weak Coupling of Elemental Solutions . . . . . . . . . . . . . . . . . . . . . .
481
22.5 Variational Principles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
484
22.6 Choice of Basis & Grid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
485
22.7 Patching versus Variational Formalism . . . . . . . . . . . . . . . . . . . . . .
486
22.8 Matrix Inversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
487
22.9 The Inﬂuence Matrix Method . . . . . . . . . . . . . . . . . . . . . . . . . . .
488
22.10Two-Dimensional Mappings & Sectorial Elements . . . . . . . . . . . . . . .
491
22.11Prospectus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
492
23 Books and Reviews
494
A
A Bestiary of Basis Functions
495
A.1 Trigonometric Basis Functions: Fourier Series . . . . . . . . . . . . . . . . . .
495
A.2 Chebyshev Polynomials: Tn(x) . . . . . . . . . . . . . . . . . . . . . . . . . .
497
A.3 Chebyshev Polynomials of the Second Kind: Un(x)
. . . . . . . . . . . . . .
499
A.4 Legendre Polynomials: Pn(x) . . . . . . . . . . . . . . . . . . . . . . . . . . .
500
A.5 Gegenbauer Polynomials . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
502
A.6 Hermite Polynomials: Hn(x)
. . . . . . . . . . . . . . . . . . . . . . . . . . .
505
A.7 Rational Chebyshev Functions: TBn(y)
. . . . . . . . . . . . . . . . . . . . .
507
A.8 Laguerre Polynomials: Ln(x)
. . . . . . . . . . . . . . . . . . . . . . . . . . .
508
A.9 Rational Chebyshev Functions: TLn(y)
. . . . . . . . . . . . . . . . . . . . .
509
A.10 Graphs of Convergence Domains in the Complex Plane . . . . . . . . . . . .
511
B
Direct Matrix-Solvers
514
B.1
Matrix Factorizations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
514
B.2
Banded Matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
518
B.3
Matrix-of-Matrices Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . .
520
B.4
Block-Banded Elimination: the “Lindzen-Kuo” Algorithm
. . . . . . . . . .
520
B.5
Block and “Bordered” Matrices . . . . . . . . . . . . . . . . . . . . . . . . . .
522
B.6
Cyclic Banded Matrices (Periodic Boundary Conditions)
. . . . . . . . . . .
524
B.7
Parting shots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
524

CONTENTS
ix
C Newton Iteration
526
C.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
526
C.2
Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
529
C.3
Eigenvalue Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
531
C.4
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
534
D The Continuation Method
536
D.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
536
D.2 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
537
D.3 Initialization Strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
538
D.4 Limit Points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
542
D.5 Bifurcation points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
544
D.6 Pseudoarclength Continuation
. . . . . . . . . . . . . . . . . . . . . . . . . .
546
E
Change-of-Coordinate Derivative Transformations
550
F
Cardinal Functions
561
F.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
561
F.2
General Fourier Series: Endpoint Grid . . . . . . . . . . . . . . . . . . . . . .
562
F.3
Fourier Cosine Series: Endpoint Grid . . . . . . . . . . . . . . . . . . . . . . .
563
F.4
Fourier Sine Series: Endpoint Grid . . . . . . . . . . . . . . . . . . . . . . . .
565
F.5
Cosine Cardinal Functions: Interior Grid
. . . . . . . . . . . . . . . . . . . .
567
F.6
Sine Cardinal Functions: Interior Grid . . . . . . . . . . . . . . . . . . . . . .
568
F.7
Sinc(x): Whittaker cardinal function . . . . . . . . . . . . . . . . . . . . . . .
569
F.8
Chebyshev Gauss-Lobatto (“Endpoints”)
. . . . . . . . . . . . . . . . . . . .
570
F.9
Chebyshev Polynomials: Interior or “Roots” Grid
. . . . . . . . . . . . . . .
571
F.10 Legendre Polynomials: Gauss-Lobatto Grid . . . . . . . . . . . . . . . . . . .
572
G Transformation of Derivative Boundary Conditions
575
Glossary
577
Index
586
References
595

Preface
[Preface to the First Edition (1988)]
The goal of this book is to teach spectral methods for solving boundary value, eigen-
value and time-dependent problems. Although the title speaks only of Chebyshev poly-
nomials and trigonometric functions, the book also discusses Hermite, Laguerre, rational
Chebyshev, sinc, and spherical harmonic functions.
These notes evolved from a course I have taught the past ﬁve years to an audience
drawn from half a dozen different disciplines at the University of Michigan: aerospace
engineering, meteorology, physical oceanography, mechanical engineering, naval architec-
ture, and nuclear engineering. With such a diverse audience, this book is not focused on a
particular discipline, but rather upon solving differential equations in general. The style is
not lemma-theorem-Sobolev space, but algorithm-guidelines-rules-of-thumb.
Although the course is aimed at graduate students, the required background is limited.
It helps if the reader has taken an elementary course in computer methods and also has
been exposed to Fourier series and complex variables at the undergraduate level. How-
ever, even this background is not absolutely necessary. Chapters 2 to 5 are a self-contained
treatment of basic convergence and interpolation theory.
Undergraduates who have been overawed by my course have suffered not from a
lack of knowledge, but a lack of sophistication. This volume is not an almanac of un-
related facts, even though many sections and especially the appendices can be used to
look up things, but rather is a travel guide to the Chebyshev City where the individual
algorithms and identities interact to form a community. In this mathematical village, the
special functions are special friends. A differential equation is a pseudospectral matrix in
drag. The program structure of grids point/basisset/collocation matrix is as basic to life as
cloud/rain/river/sea.
It is not that spectral concepts are difﬁcult, but rather that they link together as the com-
ponents of an intellectual and computational ecology. Those who come to the course with
no previous adventures in numerical analysis will be like urban children abandoned in the
wildernes. Such innocents will learn far more than hardened veterans of the arithmurgical
wars, but emerge from the forests with a lot more bruises.
In contrast, those who have had a couple of courses in numerical analysis should ﬁnd
this book comfortable: an elaboration fo familiar ideas about basis sets and grid point rep-
resentations. Spectral algorithms are a new worldview of the same computational land-
scape.
These notes are structured so that each chapter is largely self-contained. Because of this
and also the length of this volume, the reader is strongly encouraged to skip-and-choose.
The course on which this book is based is only one semester. However, I have found
it necessary to omit seven chapters or appendices each term, so the book should serve
equally well as the text for a two-semester course.
Although tese notes were written for a graduate course, this book should also be useful
to researchers. Indeed, half a dozen faculty colleagues have audited the course.
x

Preface
xi
The writing style is an uneasy mixture of two inﬂuences. In private life, the author
has written fourteen published science ﬁction and mystery short stories. When one has
described zeppelins jousting in the heavy atmosphere of another world or a stranded ex-
plorer alone on an artiﬁcial toroidal planet, it is difﬁcult to write with the expected scientiﬁc
dullness.
Nonetheless, I have not been too proud to forget most of the wise precepts I learned in
college English: the book makes heavy use of both the passive voice and the editorial “we”.
When I was still a postdoc, a kindly journal editor took me in hand, and circled every single
“I” in red. The scientiﬁc abhorrence of the personal pronoun, the active voice, and lively
writing is as hypocritical as the Victorian horror of “breast” and “pregnant”. Nevertheless,
most readers are so used to the anti-literature of science that what would pass for good
writing elsewhere would be too distracting. So I have done my best to write a book that is
not about its style but about its message.
Like any work, this volume reﬂects the particular interests and biases of the author.
While a Harvard undergraduate, I imagined that I would grow up in the image of my pro-
fessors: a pillar of the A. M. S., an editorial board member for a dozen learned journals, and
captain and chief executive ofﬁcer of a large company of graduate students and postdocs.
My actual worldline has been amusingly different.
I was once elected to a national committee, but only after my interest had shifted. I said
nothing and was not a nuisance. I have never had any connection with a journal except
as a reviewer. In twelve years at Michigan, I have supervised a single Ph. D. thesis. And
more than three-quarters of my 65 papers to date have had but a single author.
This freedom from the usual entanglements has allowed me to follow my interests:
chemical physics as an undergraduate, dynamic meteorology as a graduate student, hydro-
dynamic stability and equatorial ﬂuid mechanics as an assistant professor, nonlinear waves
and a stronger interest in numerical algorithms after I was tenured. This book reﬂects these
interests: broad, but with a bias towards ﬂuid mechanics, geophysics and waves.
I have also tried, not as successfully as I would have wished, to stress the importance of
analyzing the physics of the problem before, during, and after computation. This is partly a
reﬂection of my own scientiﬁc style: like a sort of mathematical guerrilla, I have ambushed
problems with Pad´e approximants and perturbative derivations of the Korteweg-deVries
equation as well as with Chebyshev polynomials; numerical papers are only half my pub-
lished articles.
However, there is a deeper reason: the numerical agenda is always set by the physics.
The geometry, the boundary layers and fronts, and the symmetries are the topography of
the computation. He or she who would scale Mt. Everest is well-advised to scout the
passes before beginning the climb.
When I was an undergraduate — ah, follies of youth — I had a quasi-mystical belief in
the power of brute force computation.
Fortunately, I learned better before I could do too much damage. Joel Primack (to him
be thanks) taught me John Wheeler’s First Moral Principle: Never do a calculation until
you already know the answer.
The point of the paradox is that one can usually deduce much about the solution —
orders-of-magnitude, symmetries, and so on — before writing a single line of code. A
thousand errors have been published because the authors had no idea what the solution
ought to look like. For the scientist, as for Sherlock Holmes, it is the small anomalies that
are the clues to the great pattern. One cannot appreciate the profound signiﬁcance of the
unexpected without ﬁrst knowing the expected.
The during-and-after theory is important, too. My thesis advisor, Richard Lindzen,
never had much interest in computation per se, and yet he taught me better than anyone
else the art of good scientiﬁc number-crunching. When he was faced with a stiff boundary

xii
Preface
value problem, he was not too proud to run up and down the halls, knocking on doors,
until he ﬁnally learned of a good algorithm: centered differences combined with the tridi-
agonal elimination described in Appendix B. This combination had been known for twenty
years, but was only rarely mentioned in texts because it was hard to prove convergence the-
orems.1 He then badgered the programming staff at the National Center for Atmospheric
Research to help him code the algorithm for the most powerful computer then available,
the CDC 7600, with explicit data swaps to and from the core.
A scientist who is merely good would have stopped there, but Lindzen saw from the
numerical output that equatorial waves in vertical shear satisﬁed the separation-of-scales
requirement of singular perturbation theory. He then wrote two purely analytical papers
to derive the perturbative approximation, and showed it agreed with his numerical cal-
culations. The analysis was very complicated — a member of the National Academy of
Sciences once described it to me, laughing, as “the most complicated damn thing I’ve ever
seen” — but the ﬁnal answers ﬁts on one line.
In sad contrast, I see far too many students who sit at their workstation, month after
month, trying to batter a problem into submission. They never ask for help, though Michi-
gan has one of the ﬁnest and broadest collections of arithmurgists on the planet. Nor will
they retreat to perturbation theory, asymptotic estimates, or even a little time alone in the
corner.
It is all too easy to equate multiple windows with hard work, and multiple contour
plots with progress. Nevertheless, a scientist by deﬁnition is one who listens for the voice
of God. It is part of the fallen state of man that He whispers.
In order that this book may help to amplify those whispers, I have been uninhibited in
expressing my opinions. Some will be wrong; some will be soon outdated.2 Nevertheless,
I hope I may be forgiven for choosing to stick my neck out rather than drown the reader in
a sea of uninformative blandness. The worst sin of a thesis advisor or a textbook writer is
to have no opinions.
[Preface to the Second Edition, January, 1999]
In revising this book ten years after, I deleted the old Chapter 11 (case studies of ﬂuid
computations) and Appendix G (least squares) and added four new chapters on eigen-
value problems, aliasing and spectral blocking, the slow manifold and Nonlinear Galerkin
theory, and semi-Lagrangian spectral methods. All of the chapters have been updated and
most have been rewritten. Chapter 18 has several new sections on polar coordinates. Ap-
pendix E contains a new table giving the transformations of ﬁrst and second derivatives
for a two-dimensional map. Appendix F has new analytical formulas for the Legendre-
Lobatto grid points up to nine-point grids, which is sufﬁcient for most spectral element
applications.
My second book, Weakly Nonlocal Solitary Waves and Beyond-All-Orders-Asymptotics (Kluwer,
1998) has two chapters that amplify on themes in this volume. Chapter 8 is an expanded
version of Appendices C and D here, describing a much wider range of strategies for non-
linear algebraic equations and for initializing interations. Chapter 9 explains how a stan-
dard inﬁnite interval basis can be extended to approximate functions that oscillate rather
than decay-to-zero at inﬁnity.
Other good books on spectral methods have appeared in recent years. These and a
selection of review articles are catalogued in Chapter 23.
1Alas, numerical analysis is still more proof-driven than accomplishment-driven even today.
2Surely, too, the book has typographical errors, and the reader is warned to check formulas and tables before
using them.

Preface
xiii
My original plan was to build a bibliographical database on spectral methods and ap-
plications of spectral algorithms that could be printed in full here. Alas, this dream was
overtaken by events: as the database grew past 2000 items, I was forced to limit the bib-
liography to 1025 references. Even so, this partial bibliography and the Science Citation
Index should provide the reader with ample entry points into any desired topic.
The
complete database is available online at the author’s homepage, currently at http://www-
personal.engin.umich.edu/∼jpboyd. To paraphrase Newton, it is better to stand on the
shoulders of giants than to try to recreate what others have already done better.
Spectral elements have become an increasingly important part of the spectral world in
the last decade. However, the ﬁrst edition, with but a single chapter on spectral elements,
was almost 800 pages long. (Students irrevently dubbed it the “Encyclopedia Boydica”.)
So, I have reluctantly included only the original chapter on domain decomposition in this
edition. A good treatment of spectral elements in the lowbrow spirit of this book will have
to await another volume.
Perhaps it is just as well. The bibliographic explosion is merely a symptom of a ﬁeld
that is still rapidly evolving. The reader is invited to use this book as a base camp for his
or her own expeditions.
The Heart of Africa has lost its mystery; the planets of Tau Ceti are currently unknown
and unreachable. Nevertheless, the rise of digital computers has given this generation its
galleons and astrolabes. The undiscovered lands exist, in one sense, only as intermittent
electric rivers in dendritic networks of copper and silicon, invisible as the soul. And yet
the mystery of scientiﬁc computing is that its new worlds over the water, wrought only of
numbers and video images, are as real as the furrowed brow of the ﬁrst Cro-Magnon who
was mystiﬁed by the stars, and looked for a story.

Acknowledgments
The author’s work has been supported by the National Science Foundation through the
Physical Oceanography, Meteorology, Computational Engineering and Computational Math-
ematics programs via grants OCE7909191, OCE8108530, OCE8305648, OCE8509923, OCE812300,
DMS8716766 and by the Department of Energy. My leave of absence at Harvard in 1980
was supported through grant NASA NGL-22-007-228 and the hospitality of Richard Lindzen.
My sabbatical at Rutgers was supported by the Institute for Marine and Coastal Sciences
and the hospitality of Dale Haidvogel.
I am grateful for the comments and suggestions of William Schultz, George Delic, and
the students of the course on which this book is based, especially Ahmet Selamet, Mark
Storz, Sue Haupt, Mark Schumack, Hong Ma, Beth Wingate, Laila Guessous, Natasha Flyer
and Jeff Hittinger. I thank Andreas Chaniotis for correcting a formula
I am also appreciative of the following publishers and authors for permission to repro-
duce ﬁgures or tables. Fig. 3.3: C. A. Coulson, Valence (1973), Oxford University Press.
Fig. 7.3: H. Weyl, Symmetry (1952) [copyright renewed, 1980], Princeton University Press.
Tables 9.1 and Figs. 9.1 and 9.2: D. Gottlieb and S. A. Orszag, Numerical Analysis of Spectral
Methods (1977), Society for Industrial and Applied Mathematics. Fig. 12-4: C. Canuto and
A. Quarteroni, Journal of Computational Physics (1985), Academic Press. Tables 12.2 and 12.3:
T. Z. Zang, Y. S. Wong and M. Y. Hussaini, Journal of Computational Physics (1984), Academic
Press. Fig. 13.1 and Table 13.2: J. P. Boyd, Journal of Computational Physics (1985), Academic
Press. Fig. 14.3: E. Merzbacher, Quantum Mechanics (1970), John Wiley and Sons. Figs.
14.4, 14.5, 14.7, 14.8, 14.9, 14.10, and 14.11: J. P. Boyd Journal of Computational Physics (1987),
Academic Press. Fig. 15.1: W. D’Arcy Thompson, Growth and Form (1917), Cambridge Uni-
versity Press. Fig. D.1 (wth changes): J. P. Boyd, Physica D (1986), Elsevier. Fig. D.2: E.
Wasserstrom, SIAM Review (1973), Society for Industrial and Applied Mathematics.
I thank Gene, Dale, Dave and Terry of the Technical Illustration Dept., DRDA [now
disbanded], for turning my rough graphs and schematics into camera-ready drawings.
I also would like to acknowledge a debt to Paul Bamberg of the Harvard Physics de-
partment. His lecturing style strongly inﬂuenced mine, especially his heavy reliance on
class notes both as text and transparencies.
I thank Joel Primack, who directed my undergraduate research, for his many lessons.
One is the importance of preceding calculation with estimation. Another is the need to
write quick-and-rough reports, summary sheets and annotations for even the most prelim-
inary results. It is only too true that “otherwise, in six months all your computer output
and all your algebra will seem the work of a stranger.”
I am also thankful for Richard Goody’s willingness to humour an undergraduate by
teaching him in a reading course. Our joint venture on tides in the Martian atmosphere
was scooped, but I found my calling.
I am grateful for Richard Lindzen’s patient tolerance of my ﬁrst experiments with
Chebyshev polynomials. His running commentary on science, scientists, and the interplay
of numerics and analysis was a treasured part of my education.
xiv

Acknowledgments
xv
I thank Steven Orszag for accepting this manuscript for the Lecture Notes in Engi-
neering series (Springer-Verlag) where the ﬁrst edition appeared. The treatment of time-
stepping methods in Chapter 10 is heavily inﬂuenced by his MIT lectures of many years
ago, and the whole book is strongly shaped by his many contributions to the ﬁeld.
I am appreciative of John Grafton and the staff of Dover Press for bringing this book
back into print in an expanded and corrected form.
Lastly, I am grateful for the support of the colleagues and staff of the University of
Michigan, particularly Stan Jacobs for sharing his knowledge of nonlinear waves and per-
turbation theory, Bill Schultz for many fruitful collaborations in applying spectral methods
to mechanical engineering, and Bill Kuhn for allowing me to introduce the course on which
this book is based.

Errata and Extended-Bibliography
These may be found on author’s homepage, currently at
http://www-personal.engin.umich.edu/∼jpboyd
Errata and comments may be sent to the author at the fol-
lowing:
jpboyd@umich.edu
Thank you!
xvi

Chapter 1
Introduction
“I have no satisfaction in formulas unless I feel their numerical magnitude.”
–Sir William Thomson, 1st Lord Kelvin (1824–1907)
“It is the increasingly pronounced tendency of modern analysis to substitute ideas for
calculation; nevertheless, there are certain branches of mathematics where calculation con-
serves its rights.”
–P. G. L. Dirichlet (1805–1859)
1.1
Series expansions
Our topic is a family of methods for solving differential and integral equations. The basic
idea is to assume that the unknown u(x) can be approximated by a sum of N + 1 “basis
functions” φn(x):
u(x) ≈uN(x) =
N
X
n=0
an φn(x)
(1.1)
When this series is substituted into the equation
Lu = f(x)
(1.2)
where L is the operator of the differential or integral equation, the result is the so-called
“residual function” deﬁned by
R(x; a0, a1, . . . , aN) = LuN −f
(1.3)
Since the residual function R(x; an) is identically equal to zero for the exact solution,
the challenge is to choose the series coefﬁcients {an} so that the residual function is mini-
mized. The different spectral and pseudospectral methods differ mainly in their minimiza-
tion strategies.
1

2
CHAPTER 1. INTRODUCTION
1.2
First Example
These abstract ideas can be made concrete by a simple problem. Although large problems
are usually programmed in FORTRAN and C, it is very educational to use an algebraic
manipulation language like Maple, Mathematica, Macsyma or Reduce. In what follows,
Maple statements are shown in bold face. The machine’s answers have been converted
into standard mathematical notation.
The example is the linear, one-dimensional boundary value problem:
uxx −(x6 + 3x2)u = 0
(1.4)
u(−1) = u(1) = 1
(1.5)
The exact solution is (Scraton, 1965)
u(x) = exp([x4 −1]/4)
(1.6)
Polynomial approximations are recommended for most problems, so we shall choose a
spectral solution of this form. In order to satisfy the boundary conditions independently
of the unknown spectral coefﬁcients, it is convenient to write the approximation as u2:=1
+ (1-x*x)*(a0 + a1*x + a2*x*x);
u2 = 1 + (1 −x2)(a0 + a1x + a2x2)
(1.7)
where the decision to keep only three degrees of freedom is arbitrary.
The residual for this approximation is Resid:= diff(u,x,x) - (x**6 + 3*x**2)*u;
R(x; a0, a1, a2) = u2,xx −(x6 + 3x2)u2
(1.8)
R
=
(2a2 + 2a0) −6a1x −(3 + 3a0 + 12a2)x2 −3a1x3 + 3(a0 −a2)x4
(1.9)
+3a1x5 + (−1 −a0 + 3a2)x6 −a1x7 + (a0 −a2)x8 + a1x9 + 10a2x10
As error minimization conditions, we choose to make the residual zero at a set of points
equal in number to the undetermined coefﬁcients in u2(x). This is called the “collocation”
or “pseudospectral” method. If we arbitrarily choose the points xi = (−1/2, 0, 1/2), this
gives the three equations: eq1:=subs(x=-1/2,Resid);
eq2:=subs(x=0,Resid); eq3:=subs(x=1/2,Resid);
eq1
=
−659
256a0 + 1683
512 a1 −1171
1024a2 −49
64
eq2
=
−2(a0 −a2)
eq3
=
−659
256a0 −1683
512 a1 −1171
1024a2 −49
64
(1.10)
The coefﬁcients are then determined by solving eq1 = eq2 = eq3 = 0;
solutionarray:= solve({eq1,eq2,eq3}, {a0,a1,a2}); yields
a0 = −784
3807,
a1 = 0,
a2 = a0
(1.11)
Figure 1.1 shows that this low order approximation is quite accurate.
However, the example raises a whole host of questions including:

1.2. FIRST EXAMPLE
3
1. What is an optimum choice of basis functions?
2. Why choose “collocation” as the residual-minimizing condition?
3. What are the optimum collocation points?
4. Why is a1 zero? Could we have anticipated this, and used a trial solution with just
two degrees of freedom for the same answer?
5. How do we solve the algebraic problem for the coefﬁcients when the Maple “solve”
function isn’t available?
The answer to the ﬁrst question is that choosing powers of x as a basis is actually rather
dangerous unless N, the number of degrees-of-freedom, is small or the calculations are
being done in exact arithmetic, as true for the Maple solution here. In the next section, we
describe the good choices. In an algebraic manipulation language, different rules apply as
explained in Chapter 20.
The second answer is: Collocation is the simplest choice which is guaranteed to work,
and if done right, nothing else is superior. To understand why, however, we shall have to
understand both the standard theory of Fourier and Chebyshev series and Galerkin meth-
ods (Chapters 2 and 3) and the theory of interpolation and cardinal functions (Chapters 4
and 5).
The third answer is: once the basis set has been chosen, there are only two optimal sets
of interpolation points for each basis (the Gauss-Chebyshev points and the Gauss-Lobatto
points); both are given by elementary formulas in Appendices A and F, and which one is
used is strictly a matter of convenience.
The fourth answer is: Yes, the irrelevance of a1 could have been anticipated. Indeed, one
can show that for this problem, all the odd powers of x have zero coefﬁcients. Symmetries
of various kinds are extremely important in practical applications (Chapter 8).
-1
0
1
0.75
0.8
0.85
0.9
0.95
1
Exact - u2
-1
0
1
-0.018
-0.016
-0.014
-0.012
-0.01
-0.008
-0.006
-0.004
-0.002
0
Error
Figure 1.1: Left panel: Exact solution u = exp([x4 −1]/4) (solid) is compared with the
three-coefﬁcient numerical approximation (circles). Right panel: u −u2.

4
CHAPTER 1. INTRODUCTION
Table 1.1: Maple program to solve linear boundary-value problem
u2:=1 + (1-x*x)*(a0 + a1*x + a2*x*x);
Resid:= diff(u,x,x) - (x**6 + 3*x**2)*u;
eq1:=subs(x=-1/2,Resid); eq2:=subs(x=0,Resid); eq3:=subs(x=1/2,Resid);
solutionarray:=solve({eq1,eq2,eq3},{a0,a1,a2});
The ﬁfth answer is: the algebraic equations can be written (for a linear differential equa-
tion) as a matrix equation, which can then be solved by library software in FORTRAN or
C.
Many other questions will be asked and answered in later chapters. However, some
things are already clear.
First, the method is not necessarily harder to program than ﬁnite difference or ﬁnite
element algorithms. In Maple, the complete solution of the ODE/BVP takes just ﬁve lines
(Table 1.1)!
Second, spectral methods are not purely numerical.
When N is sufﬁciently small,
Chebyshev and Fourier methods yield an analytic answer.
1.3
Comparison with ﬁnite element methods
Finite element methods are similar in philosophy to spectral algorithms; the major differ-
ence is that ﬁnite elements chop the interval in x into a number of sub-intervals, and choose
the φn(x) to be local functions which are polynomials of ﬁxed degree which are non-zero
only over a couple of sub-intervals. In contrast, spectral methods use global basis func-
tions in which φn(x) is a polynomial (or trigonometric polynomial) of high degree which is
non-zero, except at isolated points, over the entire computational domain.
When more accuracy is needed, the ﬁnite element method has three different strategies.
The ﬁrst is to subdivide each element so as to improve resolution uniformly over the whole
domain. This is usually called “h-reﬁnement” because h is the common symbol for the size
or average size of a subdomain. (Figure 1.2).
The second alternative is to subdivide only in regions of steep gradients where high
resolution is needed. This is “r-reﬁnement”.
The third option is to keep the subdomains ﬁxed while increasing p, the degree of the
polynomials in each subdomain. This strategy of ”p-reﬁnement” is precisely that employed
by spectral methods. Finite element codes which can quickly change p are far from univer-
sal, but those that can are some called “p-type” ﬁnite elements.
Finite elements have two advantages. First, they convert differential equations into
matrix equations that are sparse because only a handful of basis functions are non-zero in
a given sub-interval. (“Sparse” matrices are discussed in Appendix B; sufﬁce it to say that
“sparse” matrix equations can be solved in a fraction of the cost of problems of similar
size with “full” matrices.) Second, in multi-dimensional problems, the little sub-intervals
become little triangles or tetrahedra which can be ﬁtted to irregularly-shaped bodies like
the shell of an automobile. Their disadvantage is low accuracy (for a given number of
degrees of freedom N) because each basis function is a polynomial of low degree.
Spectral methods generate algebraic equations with full matrices, but in compensation,
the high order of the basis functions gives high accuracy for a given N. When fast iterative
matrix–solvers are used, spectral methods can be much more efﬁcient than ﬁnite element

1.3. COMPARISON WITH FINITE ELEMENT METHODS
5
or ﬁnite difference methods for many classes of problems. However, they are most useful
when the geometry of the problem is fairly smooth and regular.
So-called “spectral element” methods gain the best of both worlds by hybridizing spec-
tral and ﬁnite element methods. The domain is subdivided into elements, just as in ﬁnite
elements, to gain the ﬂexibility and matrix sparsity of ﬁnite elements. At the same time,
the degree of the polynomial p in each subdomain is sufﬁciently high to retain the high
accuracy and low storage of spectral methods. (Typically, p = 6 to 8, but spectral element
codes are almost always written so that p is an arbitrary, user-choosable parameter.)
It turns out that most of the theory for spectral elements is the same as for global spec-
tral methods, that is, algorithms in which a single expansion is used everywhere. Conse-
quently, we shall concentrate on spectral methods in the early going. The ﬁnal chapter will
describe how to match expansions in multiple subdomains.
Low order ﬁnite elements can be derived, justiﬁed and implemented without knowl-
edge of Fourier or Chebyshev convergence theory. However, as the order is increased, it
turns out that ad hoc schemes become increasingly ill-conditioned and ill-behaved. The
only practical way to implement “nice” high order ﬁnite elements, where “high order”
generally means sixth or higher order, is to use the technology of spectral methods.
Similarly, it turns out that the easiest way to match spectral expansions across subdo-
main walls is to use the variational formalism of ﬁnite elements.
Thus, it really doesn’t make much sense to ask: Are ﬁnite elements or spectral methods
better? For sixth or higher order, they are essentially the same. The big issue is: Does one
need high order, or is second or fourth order sufﬁcient?
Smaller h
h-refinement
 h
p-refinement
increase 
polynomial 
degree p
r-refinement
subdivide only where 
       high resolution 
              needed
Figure 1.2: Schematic of three types of ﬁnite elements

6
CHAPTER 1. INTRODUCTION
1.4
Comparisons with Finite Difference Method: Why Spec-
tral Methods are Accurate and Memory-Minimizing
Finite difference methods approximate the unknown u(x) by a sequence of overlapping
polynomials which interpolate u(x) at a set of grid points. The derivative of the local
interpolant is used to approximate the derivative of u(x). The result takes the form of a
weighted sum of the values of u(x) at the interpolation points.
Spectral
Finite Element/Spectral Element
One high-order polynomial for WHOLE domain
Finite Difference
Multiple Overlapping Low-Order Polynomials
Non-Overlapping  Polynomials, 
One per Subdomain
Figure 1.3: Three types of numerical algorithms. The thin, slanting lines illustrate all the
grid points (black circles) that directly affect the estimates of derivatives at the points shown
above the lines by open circles. The thick black vertical lines in the bottom grid are the
subdomain walls.
The most accurate scheme is to center the interpolating polynomial on the grid point
where the derivative is needed. Quadratic, three-point interpolation and quartic, ﬁve-point
interpolation give
df/dx ≈[f(x + h) −f(x −h)]/(2h) + O(h2)
(1.12)
df/dx ≈[−f(x + 2h) + 8f(x + h) −8f(x −h) + f(x −2h)]/(12h) + O(h4)
(1.13)

1.4. COMPARISONS WITH FINITE DIFFERENCES
7
Figure 1.4: Weights wj in the approximation df/dx |x=x0≈P
j wjf(x0 + jh) where x0 = π
and h = π/5. In each group, the Fourier weights are the open, leftmost bars. Middle, cross-
hatched bars (j = ±1, ±2 only): Fourth-order differences. Rightmost, solid bars (j = ±1
only): weights for second order differences.
The function O( ), the “Landau gauge symbol”, denotes that in order-of-magnitude, the
errors are proportional to h2 and h4, respectively.
Since the pseudospectral method is based on evaluating the residual function only at
the “selected points”, {xi}, we can take the grid point values of the approximate solution,
the set {uN(xi)}, as the unknowns instead of the series coefﬁcients. Given the value of
a function at (N+1) points, we can compute the (N + 1) series coefﬁcients {an} through
polynomial or trigonometric interpolation. Indeed, this symbolic equation
series coefﬁcients{an} ⇐⇒grid point values{uN(xi)}
(1.14)
is one of the most important themes we will develop in this course, though the mechanics
of interpolation will be deferred to Chapters 4 and 5.
Similarly, the ﬁnite element and spectral element algorithms approximate derivatives
as a weighted sum of grid point values. However, only those points which lie within a
given subdomain contribute directly to the derivative approximations in that subdomain.
(Because the solution in one subdomain is matched to that in the other subdomain, there
is an indirect connection between derivatives at a point and the whole solution, as true of
ﬁnite differences, too.) Figure 1.3 compares the regions of direct dependency in derivative
formulas for the three families of algorithms.
Figs.1.4 and 1.5 compare the weights of each point in the second and fourth-order ﬁ-
nite difference approximations with the N = 10 Fourier pseudospectral weights. Since the
basis functions can be differentiated analytically and since each spectral coefﬁcient an is
determined by all the grid point values of u(x), it follows that the pseudospectral differen-
tiation rules are not 3-point formulas, like second-order ﬁnite differences, or even 5-point
formulas, like the fourth-order expressions; rather, the pseudospectral rules are N-point
formulas. To equal the accuracy of the pseudospectral procedure for N = 10, one would
need a tenth-order ﬁnite difference or ﬁnite element method with an error of O(h10).
As N is increased, the pseudospectral method beneﬁts in two ways. First, the interval h

8
CHAPTER 1. INTRODUCTION
Figure 1.5: Same as previous ﬁgure except for the second derivative. Hollow bars: pseu-
dospectral. Cross-hatched bars: Fourth-order differences. Solid bars: Second-order differ-
ences.
between grid points becomes smaller – this would cause the error to rapidly decrease even
if the order of the method were ﬁxed. Unlike ﬁnite difference and ﬁnite element methods,
however, the order is not ﬁxed. When N increases from 10 to 20, the error becomes O(h20)
in terms of the new, smaller h. Since h is O(1/N), we have
Pseudospectral error ≈O[(1/N)N]
(1.15)
The error is decreasing faster than any ﬁnite power of N because the power in the error
formula is always increasing, too. This is “inﬁnite order” or “exponential” convergence.1
This is the magic of pseudospectral methods. When many decimal places of accu-
racy are needed, the contest between pseudospectral algorithms and ﬁnite difference and
ﬁnite element methods is not an even battle but a rout: pseudospectral methods win
hands-down. This is part of the reason that physicists and quantum chemists, who must
judge their calculations against experiments accurate to as many as fourteen decimal places
(atomic hydrogen maser), have always preferred spectral methods.
However, even when only a crude accuracy of perhaps 5% is needed, the high order of
pseudospectral methods makes it possible to obtain this modest error with about half as
many degrees of freedom – in each dimension – as needed by a fourth order method. In other
words, spectral methods, because of their high accuracy, are memory-minimizing. Problems
that require high resolution can often be done satisfactorily by spectral methods when a
three-dimensional second order ﬁnite difference code would fail because the need for eight
or ten times as many grid points would exceed the core memory of the available computer.
’Tis true that virtual memory gives almost limitless memory capacity in theory. In prac-
tice, however, swapping multi-megabyte blocks of data to and from the hard disk is very
slow. Thus, in a practical (as opposed to theoretical) sense, virtual storage is not an option
when core memory is exhausted. The Nobel Laureate Ken Wilson has observed that be-
cause of this, memory is a more severe constraint on computational problem-solving than
1Chapter 2 shows show that the convergence is always exponential for well-behaved functions, but (1.15) is
usually too optimistic. The error in an N-point method is O(M[n]hn) where M(n) is a proportionality constant;
we ignored the (slow) growth of this constant with n to derive (1.15).

1.5. PARALLEL COMPUTERS
9
CPU time. It is easy to beg a little more time on a supercomputer, or to continue a job
on your own workstation for another night, but if one runs out of memory, one is simply
stuck – unless one switches to an algorithm that uses a lot less memory, such as a spectral
method.
For this reason, pseudospectral methods have triumphed in metereology, which is most
emphatically an area where high precision is impossible!
The drawbacks of spectral methods are three-fold. First, they are usually more difﬁcult
to program than ﬁnite difference algorithms. Second, they are more costly per degree of
freedom than ﬁnite difference procedures. Third, irregular domains inﬂict heavier losses
of accuracy and efﬁciency on spectral algorithms than on lower-order alternatives. Over
the past ﬁfteen years, however, numerical modellers have learned the “right” way to im-
plement pseudospectral methods so as to minimize these drawbacks.
1.5
Parallel Computers
The current generation of massively parallel machines is communications-limited. That is to
say, each processor is a workstation-class chip capable of tens of megaﬂops or faster, but
the rate of interprocessor transfers is considerably slower.
Spectral elements function very well on massively parallel machines. One can assign
a single large element with a high order polynomial approximation within it to a single
processor. A three-dimensional element of degree p has roughly p3 internal degrees of
freedom, but the number of grid points on its six walls is O(6p2). It is these wall values that
must be shared with other elements – i. e., other processors – so that the numerical solution
is everywhere continuous. As p increases, the ratio of internal grid points to boundary
grid points increases, implying that more and more of the computations are internal to
the element, and the shared boundary values become smaller and smaller compared to
the total number of unknowns. Spectral elements generally require more computation per
unknown than low order methods, but this is irrelevant when the slowness of interprocessor
data transfers, rather than CPU time, is the limiting factor.
To do the same calculation with low order methods, one would need roughly eight
times as many degrees of freedom in three dimensions. That would increase the interpro-
cessor communication load by at least a factor of four. The processors would likely have
a lot of idle time: After applying low order ﬁnite difference formulas quickly throughout
its assigned block of unknowns, each processor is then idled while boundary values from
neighboring elements are communicated to it.
Successful applications of spectral elements to complicated ﬂuid ﬂows on massively
parallel machines have been given by Fischer(1990, 1994a,b, 1997) Iskandarani, Haidvogel
and Boyd (1994), Taylor, Tribbia and Iskandarani(1997) and Curchitser, Iskandarani and
Haidvogel(1998), among others.
1.6
Choice of basis functions
Now that we have compared spectral methods with other algorithms, we can return to
some fundamental issues in understanding spectral methods themselves.
An important question is: What sets of ”basis functions” φn(x) will work? It is obvi-
ous that we would like our basis sets to have a number of properties: (i) easy to compute
(ii) rapid convergence and (iii) completeness, which means that any solution can be repre-
sented to arbitrarily high accuracy by taking the truncation N to be sufﬁciently large.

10
CHAPTER 1. INTRODUCTION
Although we shall discuss many types of basis functions, the best choice for 95% of all
applications is an ordinary Fourier series, or a Fourier series in disguise. By “disguise” we
mean a change of variable which turns the sines and cosines of a Fourier series into differ-
ent functions. The most important disguise is the one worn by the Chebyshev polynomials,
which are deﬁned by
Tn(cosθ) ≡cos(nθ)
(1.16)
Although the Tn(x) are polynomials in x, and are therefore usually considered a sepa-
rate and distinct species of basis functions, a Chebyshev series is really just a Fourier cosine
expansion with a change of variable. This brings us to the ﬁrst of our proverbial sayings:
MORAL PRINCIPLE 1:
(i) When in doubt, use Chebyshev polynomials unless the solution is spatially periodic, in which
case an ordinary Fourier series is better.
(ii) Unless you’re sure another set of basis functions is better, use Chebyshev polynomials.
(iii) Unless you’re really, really sure that another set of basis functions is better, use Chebyshev
polynomials.
There are exceptions: on the surface of a sphere, it is more efﬁcient to use spherical
harmonics than Chebyshev polynomials. Similarly, if the domain is inﬁnite or semi-inﬁnite,
it is better to use basis sets tailored to those domains than Chebyshev polynomials, which
in theory and practice are associated with a ﬁnite interval.
The general rule is: Geometry chooses the basis set. The engineer never has to make a
choice. Table A-1 in Appendix A and Figure 1.6 summarize the main cases. When multiple
basis sets are listed for a single geometry or type of domain, there is little to choose between
them.
It must be noted, however, that the non-Chebyshev cases in the table only strengthen
the case for our ﬁrst Moral Principle. Though not quite as good as spherical harmonics,
Chebyshev polynomials in latitude and longtitude work just ﬁne on the sphere (Boyd,
1978b). The rational Chebyshev basis sets are actually just the images of the usual Cheby-
shev polynomials under a change of coordinate that stretches the interval [-1, 1] into an
inﬁnite or semi-inﬁnite domain. Chebyshev polynomials are, as it were, almost idiot-proof.
Consequently, our analysis will concentrate almost exclusively upon Fourier series and
Chebyshev polynomials. Because these two basis sets are the same except for a change
of variable, the theorems for one are usually trivial generalizations of those for the other.
The formal convergence theory for Legendre polynomials is essentially the same as for
Chebyshev polynomials except for a couple of minor items noted in Chapter 2. Thus,
understanding Fourier series is the key to all spectral methods.
1.7
Boundary conditions
Normally, boundary and initial conditions are not a major complication for spectral meth-
ods. For example, when the boundary conditions require the solution to be spatially pe-
riodic, the sines and cosines of a Fourier series (which are the natural basis functions for
all periodic problems) automatically and individually satisfy the boundary conditions. Con-
sequently, our only remaining task is to choose the coefﬁcients of the Fourier series to
minimize the residual function.

1.7. BOUNDARY CONDITIONS
11
Periodic
 Non-Periodic
Semi-Infinite
Infinite
x  ∈ [0, ∞]
x  ∈ [−1, 1]
x  ∈ [− ∞, ∞]
θ ∈ [0, 2 π]
Fourier
Rational Cheby. TL
 or Laguerre
Chebyshev
 or Legendre
Rational Cheby. TB
 or Hermite or Sinc
Figure 1.6: Choice of basis functions. Upper left: on a periodic interval, use sines and
cosines. This case is symbolized by a ring because the dependence on an angular coordi-
nate, such as longitude, is always periodic. Upper right: a ﬁnite interval, which can always
be rescaled and translated to x ∈[−1, 1]. Chebyshev or Legendre polynomials are optimal.
Lower left: semi-inﬁnite interval x ∈[0, ∞], symbolized by a one-sided arrow. Rational
Chebyshev functions TLn(x) are the generic choice, but Laguerre functions are sometimes
more convenient for particular problems. Lower right: x ∈[−∞, ∞] (double-ended ar-
row). Rational Chebyshev functions TBn(x) are the most general, but sinc and Hermite
functions are widely used, and have similar convergence properties.
For non-periodic problems, Chebyshev polynomials are the natural choice as explained
in the next chapter. They do not satisfy the appropriate boundary conditions, but it is easy
to add explicit constraints such as
N
X
n=0
an φn(1) = α
(1.17)
to the algebraic equations obtained from minimizing R(x; a0, a1, . . . , aN) so that u(1) = α
is satisﬁed by the approximate solution.

12
CHAPTER 1. INTRODUCTION
Alternatively, one may avoid explicit constraints like (1.17) by writing the solution as
u(x) ≡v(x) + w(x)
(1.18)
where w(x) is a known function chosen to satisfy the inhomogeneous boundary conditions.
The new unknown, v(x), satisﬁes homogeneous boundary conditions. For (1.17), for ex-
ample, w(1) = α and v(1) = 0. The advantage of homogenizing the boundary conditions is
that we may combine functions of the original basis, such as the Chebyshev polynomials,
into new basis functions that individually satisfy the homogeneous boundary conditions.
This is surprisingly easy to do; for example, to satisfy v(−1) = v(1) = 0, we expand v(x) in
terms of the basis functions
φ2n(x)
≡
T2n(x) −1,
n = 1, 2, . . .
φ2n+1(x)
≡
T2n+1(x) −x,
n = 1, 2, . . .
(1.19)
where the Tn(x) are the usual Chebyshev polynomials whose properties (including bound-
ary values) are listed in Appendix A. This basis is complete for functions which vanish at
the ends of the interval. The reward for the switch of basis set is that it is unnecessary,
when using basis recombination, to waste rows of the discretization matrix on the bound-
ary conditions: All algebraic equations come from minimizing the residual of the differen-
tial equation.
1.8
The Two Kingdoms: Non-Interpolating and Pseudospec-
tral Families of Methods
Spectral methods fall into two broad categories. In the same way that all of life was once
divided into the “plant” and “animal” kingdoms2, most spectral methods may be classed
as either “interpolating” or “non–interpolating”. Of course, the biological classiﬁcation
may be ambiguous – is a virus a plant or animal? How about a sulfur-eating bacteria? The
mathematical classiﬁcation may be ambiguous, too, because some algorithms mix ideas
from both the interpolating and non-interpolating kingdoms. Nonetheless, the notion of
two exclusive “kingdoms” is a useful taxonomical starting point for both biology and nu-
merical analysis.
The “interpolating” or “pseudospectral” methods associate a grid of points with each
basis set. The coefﬁcients of a known function f(x) are found by requiring that the trun-
cated series agree with f(x) at each point of the grid. Similarly, the coefﬁcients an of a
pseudospectral approximation to the solution of a differential equation are found by re-
quiring that the residual function interpolate f ≡0:
R(xi; a0, a1, . . . , aN) = 0,
i = 0, 1, ..., N
(1.20)
In words, the pseudospectral method demands that the differential equation be exactly
satisﬁed at a set of points known as the “collocation” or “interpolation” points. Presum-
ably, as R(x; an) is forced to vanish at an increasingly large number of discrete points, it
will be smaller and smaller in the gaps between the collocation points so that R ≈x every-
where in the domain, and therefore uN(x) will converge to u(x) as N increases. Methods in
this kingdom of algorithms are also called “orthogonal collocation” or “method of selected
points”.
The “non–interpolating” kingdom of algorithms includes Galerkin’s method and the
Lanczos tau-method. There is no grid of interpolation points. Instead, the coefﬁcients of
2Modern classiﬁcation schemes use three to ﬁve kingdoms, but this doesn’t change the argument.

1.9. NONLINEARITY
13
a known function f(x) are computed by multiplying f(x) by a given basis function and
integrating. It is tempting to describe the difference between the two algorithmic kingdoms
as ”integration” versus ”interpolation”, but unfortunately this is a little simplistic. Many
older books, such as Fox and Parker (1968), show how one can use the properties of the
basis functions – recurrence relations, trigonometric identities, and such – to calculate co-
efﬁcients without explicitly performing any integrations. Even though the end product is
identical with that obtained by integration, it is a little confusing to label a calculation as an
”integration-type” spectral method when there is not an integral sign in sight! Therefore,
we shall use the blander label of ”non-interpolating”.
Historically, the “non–interpolating” methods were developed ﬁrst. For this reason,
the label “spectral” is sometimes used in a narrow sense as a collective tag for the “non–
interpolating” methods. In these notes, we shall use “spectral” only as catch–all for global
expansion methods in general, but the reader should be aware of its other, narrower usage.
(Actually, there are several other uses because “spectral” has other meanings in time series
analysis and functional analysis – ugh!).
Many spectral models of time-dependent hydrodynamics split the calculation into sev-
eral subproblems and apply different techniques to different subproblems. To continue
with our biological metaphor, the computer code becomes a little ecology of interacting
“interpolating” and “non–interpolating” parts. Each algorithm (or algorithmic kingdom)
has ecological niches where it is superior to all competition, so we must master both non–
interpolating and pseudospectral methods.
At ﬁrst glance, there is no obvious relation between the pseudospectral method and the
alternatives that use weighted integrals of R(x; an) to choose the {an}. Worse still, we now
have the further burden of choosing the interpolation points, {xi}. Fortunately, there is a
natural choice of interpolation points for each of the common basis sets. These points are
the Gaussian quadrature points for the integrals of Galerkin’s method. The pseudospectral
method is therefore equivalent to the spectral if we evaluate the integrals of the latter by
numerical quadrature with (N + 1) points. This is the reason why the interpolation-based
methods are now commonly called “pseudospectral”.
Better yet, we shall show in later chapters that the accuracy of pseudospectral methods
is only a little bit poorer than that of the non-interpolating kingdom – too little to outweigh
the much greater simplicity and computational efﬁciency of the pseudospectral algorithms.
Consequently, we shall emphasize pseudospectral methods in this book. Nonetheless, the
justiﬁcation for the pseudospectral kingdom is derived from that for the non-interpolating
methods, and the latter are still superior to interpolation for specialized but important
applications. We cannot understand the high efﬁciency of either kingdom of spectral algo-
rithms without ﬁrst reviewing the theory of Fourier series (Chapter 2).
1.9
Nonlinearity
Nonlinearity is not a major complication for spectral methods per se. For expository sim-
plicity, we shall usually concentrate on linear algorithms, especially in explaining the basic
ideas. The extension to nonlinear problems usually only requires minor modiﬁcations.
To illustrate this, we shall do a very simple nonlinear boundary value problem here.
Such equations normally are solved by Newton’s iteration. If we set up the iteration by ﬁrst
linearizing the differential equation about the current iterate (the “Newton-Kantorovich”
method of Appendix C), then we solve a linear differential equation at each step.
In this example, we shall instead apply the spectral method ﬁrst. The only difference
from a linear problem is that the system of algebraic equations for the coefﬁcients is nonlin-
ear. It is usually irrelevant whether the Newton iteration is created before or after applying

14
CHAPTER 1. INTRODUCTION
the spectral method; take your choice!
Figure 1.7: Comparison of exact and approximate solutions: Nonlinear diffusion equation
The nonlinear boundary value problem is
uxx + α(ux)2 + αuuxx = 0
(1.21)
subject to the boundary conditions that
u(0) = 0;
u(1) = 1
(1.22)
We will take the approximate solution u2(x) to be a quadratic polynomial. The most gen-
eral quadratic polynomial which satisﬁes the boundary conditions is
u2 = x + a2(x2 −x)
(1.23)
Since there is only one undetermined coefﬁcient a2, only a single collocation point is needed.
The obvious choice, the midpoint of the interval, is best.
The residual function is
R(x; a2) = a2
2 α [6x2 −6x + 1] + 2a2 [3αx + 1 −α] + α
(1.24)
The condition that R(x = 1/2; a2) = 0 then gives the quadratic equation
a2
2 α [−1/2] + 2a2 [α/2 + 1] + α = 0
(1.25)
We note an amusing fact: although pseudospectral methods are usually considered only
as numerical techniques, we have in fact obtained an analytical solution to this nonlinear
problem. To see how accurate it is, let us specialize to α = 1 for which the exact solution is
u(x; α = 1) = −1 + (1 + 3x)1/2
(1.26)
There are two roots to the quadratic, of course, but one gives an unphysical heat ﬂux to-
wards the boundary source at x = 1, so it can be rejected.3
3The ambiguity of multiple solutions is a difﬁculty raised by the nonlinearity of the differential equation, not
by the method used to solve it. All algorithms for solving nonlinear boundary value problems have the drawback
that the algebraic equations that are the discretization of the differential equation have multiple solutions. Most
are unphysical and must be rejected on various grounds including (i) imaginary parts (ii) unrealistic behavior
such as the heat ﬂux for this example or (iii) failure to converge as N is varied.

1.10. TIME-DEPENDENT PROBLEMS
15
The other gives the approximate solution
u2(x; α = 1) = x −0.317(x2 −x)
(1.27)
Fig. 1.7 compares the exact and approximate solutions. The maximum of u(x) is 1.00;
the maximum absolute error of the 1-point pseudospectral solution is only 0.014. The ﬁgure
shows that even though the functional forms of (1.26) and (1.27) bear no obvious resem-
blance, the two graphs differ so little that it is hard to tell them apart.
In real-life problems, of course, the exact solution is not known, but the accuracy of
an approximate solution can be tested by repeating the calculation with higher N. This
problem is particularly difﬁcult because it is nonlinear, so for all N we will invariably
be left with a nonlinear algebraic equation or set of equations to determine the solution.
However, these can be easily solved by Newton’s method since the lowest approximation,
obtained analytically, is sufﬁciently close to the exact solution to furnish a good ﬁrst guess
for the iteration. One of the great virtues of the pseudospectral method is the ease with
which it can be applied to nonlinear differential equations.
1.10
Time-dependent problems
Although it is possible to treat the time coordinate spectrally, and we shall describe some
special cases and special algorithms where this has been done, it is generally most efﬁcient
to apply spectral methods only to the spatial dependence. The reason is that the time-
dependence can be marched forward, from one time level to another. Marching is much
cheaper than computing the solution simultaneously over all space-time.
A space-only spectral discretization reduces the original partial differential equation
to a set of ordinary differential equations in time, which can then be integrated by one’s
favorite Runge-Kutta or other ODE time-marching scheme. (This approach, of discretizing
one or more coordinates to generate a system of ODEs in the remaining coordinate, is
sometimes called the “method of lines”, especially in the Russian literature.)
As an illustration, consider the following generalized diffusion problem:
ut = uxx −2q cos(2x)u
(1.28)
with the boundary conditions that the solution must be periodic with a period of 2π. The
exact general solution is
u(x, t) =
∞
X
n=0
an(0) exp(−λnt)cen(x) +
∞
X
n=1
bn(0) exp(−µnt)sen(x)
(1.29)
where the cen(x) and sen(x) are transcendental functions known as Mathieu functions and
the λn and µn are the corresponding eigenvalues. The coefﬁcients an(0) and bn(0) are the
values of the coefﬁcients of the Mathieu function series for u(x) at t = 0. As for a Fourier
series, they can be calculated via
an(0) = (u[x, t = 0], cen)/(cen, cen)
(1.30)
bn(0) = (u[x, t = 0], sen)/(sen, sen)
(1.31)
where
(f, g) ≡
Z 2π
0
f(x)g(x)dx
[“inner product”]
(1.32)

16
CHAPTER 1. INTRODUCTION
In the next chapter, we will discuss “inner products”; the cen(x) and sen(x) are computed
using “sideband truncation” in Chapter 19.
As a numerical example, take
u(x, t = 0) ≡1
(1.33)
and employ two-point collocation with the basis functions
u2(x) = a0(t) + a2(t) cos(2x)
(1.34)
and the collocation or interpolation points
x0 = 0; x1 = π/3
(1.35)
The reasons for omitting cos(x) and any and all sine functions are discussed in the chapter
on parity and symmetry (Chapter 8). The choice of collocation points is standard for a
periodic interval as explained in Chapter 4.
The residual function R(x; a0, a2) is
R(x; a0, a2) = −{ [2q cos(2x) a0 + a0,t] + cos(2x)[ (4 + 2q cos(2x)) a2 + a2,t] }
(1.36)
The collocation conditions that (i) R(x = 0; a0, a2) = 0 and (ii) R(x = π/3; a0, a2) = 0
give two coupled, ordinary differential equations in time that determine a0(t) and a2(t):
a0,t + a2,t + 2q a0 + (4 + 2q) a2 = 0
(1.37)
a0,t −(1/2)a2,t −q a0 −(1/2)(4 −q) a2 = 0
(1.38)
Solving these is straightforward; for the special case q = 1,
u2(x) = {0.95 −0.37 cos(2x)} exp[0.54t] + {0.05 + 0.37 cos(2x)} exp[−5.54t]
(1.39)
The corresponding exact solution is
u(x)
=
{0.916 −0.404 cos(2x) + 0.031 cos(4x) −· · · } exp[0.454t]
(1.40)
+{0.091 + 0.339 cos(2x) −0.030 cos(4x) + · · · } exp[−4.370t] + · · ·
Comparing the two solutions, we see that the low-order collocation approximation is
at least qualitatively correct. It predicts that one mode will grow with time while the rest
decay; the growth rate of the growing mode is about 20 % too large. The dominant Fourier
coefﬁcients are of the growing mode are fairly close — 0.95 versus 0.916, -0.37 versus -
0.404 — while the coefﬁcients of higher degree cosines (cos[4x], cos[6x], etc.), which are
completely neglected in this approximation, have amplitudes of 0.03 or less.
This example is typical of many time-dependent problems we shall solve: the pseu-
dospectral method is applied to the spatial dependence to reduce the problem to a set of
coupled ordinary differential equations in time. The ODE’s in time will often be nonlinear,
however, and it is usually easier to integrate them through ﬁnite differences in time even
when a (complicated!) analytic solution is possible.
1.11
FAQ: Frequently Asked Questions
1. Are spectral methods harder to program than ﬁnite difference or ﬁnite element meth-
ods?
Sometimes. However, our ﬁrst example took just six Maple statements. Spectral
methods are only a little more difﬁcult to program than ﬁnite differences.

1.12. THE CHRYSALIS
17
2. Is the high, many-decimal place accuracy of spectral methods even needed in the real
world of engineering?
Sometimes. I was called in as a consultant by KMS Fusion because they needed to
model the ﬂows around a pellet of frozen deuterium to about ﬁve decimal places.
Small imperfections in the spherical shape, on the order of 1%, drastically altered
nuclear fusion when the pellet was hit with high intensity laser beams. A two or
three decimal place solution would not necessarily have revealed anything about the
role of the bumps because the numerical errors of such crude solutions would be
comparable with the size of the bumps themselves.
Long-term hydrodynamic integrations and transition-to-turbulence are often wrecked
by computational instability.
Common strategies for preserving stability include
(i) adding lots of dissipation and (ii) energy-conserving difference or ﬁnite element
schemes. However, both strategies can greatly distort the solution. A highly accurate
solution should not need strong artiﬁcial damping or explicit imposition of energy
conservation. Spectral solutions are often stable even without damping or imposed
energy conservation.
3. Are spectral methods useful only when high accuracy is needed?
No, because spectral methods also are “memory-minimizing”. In three dimensions,
one can typically resolve a ﬂow crudely, to within 1% accuracy or so, using only 1/8
as many degrees of freedom as needed by a second or fourth order ﬁnite difference
method.
4. Are spectral methods useful for ﬂows with shock waves or fronts?
Yes. It’s true, however, that spectral methods for shock problems do not have the
sophistication of some low order ﬁnite difference, ﬁnite volume and ﬁnite element
codes that have been tailored to shock ﬂows. However, much progress has been
made in adapting these ideas to spectral methods.
1.12
The Chrysalis
In numerical analysis, many computations, even in the most sophisticated models, is still
performed using the same second order differences employed by Lewis Richardson in
1910, and Sir Richard Southwell and his group in the 1930’s. There are some good rea-
sons for this conservatism. When computer modelling attacks new challenges, such as
shocks or the complicated geometry of ocean basins or auto frames, it is only sensible to
begin by applying and reﬁning low order methods ﬁrst. The challenging task of customiz-
ing old algorithms to new vector and parallel hardware has also (sensibly) begun with
simple differences and elements. Lastly, for weather forecasting and many other species of
models, the physics is so complicated — photochemistry, radiative transfer, cloud physics,
topographic effects, air-sea interaction, and ﬁnite resolution of observations — that purely
numerical errors are a low priority.
Nevertheless, high order models displaced second order codes for operational forecast-
ing in the 70’s, and seem likely to do the same in other engineering and science ﬁelds in
the twenty-ﬁrst century. Even when the physics is complicated, there is no excuse for poor
numerics. A rusted mufﬂer is no excuse for failing to change the oil. Another reason is that
we can, with high order algorithms, explore numerical frontiers previously unreachable.
The Space Shuttle has a much greater reach than a clipper ship. Too much of numerical
modelling is still in the Age of Sail.

18
CHAPTER 1. INTRODUCTION
A ﬁnal reason is that low order methods are like the chrysalis of a butterﬂy. As shown
later, inside every low order program is a high order algorithm waiting to burst free. Given
a second order ﬁnite difference or ﬁnite element boundary-value solver, one can promote
the code to spectral accuracy merely by appending a single subroutine to spectrally eval-
uate the residual, and then calling the boundary value solver repeatedly with the spectral
residual as the forcing function. Similarly, the structure and logic of an initial value solver is
very much the same for both low and high order methods. The central question is simply:
Will one approximate the spatial derivatives badly or well?

Chapter 2
Chebyshev & Fourier Series
“Fourier’s Theorem is not only one of the most beautiful results of modern analysis, but
it may be said to furnish an indispensable instrument in the treatment of nearly every
recondite question in modern physics.”
— William Thompson & P. G. Tait (1874)
2.1
Introduction
The total error in solving differential equations is the sum of several contributions which
are deﬁned below. These errors are distinct from the spectral coefﬁcients {an}, which in
turn are not the same as the terms in the series, which are coefﬁcients multiplied by a
basis function. Our ﬁrst major theme is that all these quantities, though distinct, have
the property of decaying to zero with increasing N at the same qualitative rate, usually
exponentially.
Our second theoretical keystone is Darboux’s Principle. This states that the convergence
of a spectral series for u(x) is controlled by the singularities of u(x) where “singularity” is
a catch-all for any point in the complex x-plane where u(x) ceases to be analytic in the
sense of complex variable theory. Square roots, logarithms, simple poles, step function
discontinuities and inﬁnities or abrupt discontinuities in any of the derivatives of u(x) at a
point are all “singularities”.
The reason that Darboux’s Principle is a keystone is that it implies that two functions
which have convergence-limiting singularities in the same place, of the same strength and
type, will have spectral series whose coefﬁcients an asymptote to the same values as n →
∞. This justiﬁes the “Method of Model Functions”: We can understand a lot about the
success and failure of spectral methods by ﬁrst understanding the spectral series of simple,
explicit model functions with various types of logarithms, poles, and jumps.
The third keystone is that from Darboux’s Principle, and limited knowledge about a
function, such as whether it is or is not pathological on the solution domain, we can predict
rates of convergence for spectral series and spectral approximations to differential equa-
tions. Several qualitatively different rates are possible: algebraic, geometric, subgeometric,
and supergeometric.
The fourth keystone is that from model functions and Darboux’s Principle, we can de-
velop some rules-of-thumb that allow us to qualitatively estimate a priori how many de-
grees of freedom N are needed to resolve a given physical phenomenon. These heuristics
19

20
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
are useful to identify both errors and unexpected physics, and also to answer the question:
Is a given calculation feasible on my machine?
We will return to each of these four key themes in the middle of the chapter, though not
in the same order as above. First, though, a brief review of Fourier series.
2.2
Fourier series
The Fourier series of a general function f(x) is
f(x) = a0 +
∞
X
n=1
an cos(nx) +
∞
X
n=1
bn sin(nx)
(2.1)
where the coefﬁcients are
a0
=
(1/2π)
Z π
−π
f(x)dx
an
=
(1/π)
Z π
−π
f(x) cos(nx)dx
bn
=
(1/π)
Z π
−π
f(x) sin(nx)dx
(2.2)
First note: because the sines and cosines are periodic with a period of 2 π, we can also
compute the Fourier expansion on the interval x ∈[0, 2π]. The only alteration is that the
limits of integration in the coefﬁcient integrals (2.2) are also changed from [−π, π] to [0, 2π].
Second note: the general Fourier series can also be written in the complex form
f(x) =
∞
X
n=−∞
cn exp(inx)
(2.3)
where the coefﬁcients are
cn = (1/2π)
Z π
−π
f(x) exp(−inx)dx
(2.4)
The identities
cos(x) ≡(exp(ix) + exp(−ix))/2;
sin(x) ≡(exp(ix) −exp(−ix))/(2i),
(2.5)
show that (2.3) and (2.1) are completely equivalent, and we shall use whichever is conve-
nient. The coefﬁcients of the two forms are related by
c0
=
a0,
n = 0
cn
=
½
(an −ibn)/2,
n > 0
(an + ibn)/2,
n < 0
Often, it is unnecessary to use the full Fourier series. In particular, if f(x) is known to
have the property of being symmetric about x = 0, which means that f(x) = f(−x) for all
x, then all the sine coefﬁcients are zero. The series with only the constant and the cosine
terms is known as a “Fourier cosine series”. (A Chebyshev series is a Fourier cosine series
with a change of variable.) If f(x) = −f(−x) for all x, then f(x) is said to be antisymmetric
about x = 0 and all the an = 0. Its Fourier series is a sine series. These special cases are
extremely important in applications as discussed in the Chapter 8.

2.2. FOURIER SERIES
21
Deﬁnition 1 (PERIODICITY)
A function f(x) is PERIODIC with a period of 2 π if
f(x) = f(x + 2π)
(2.6)
for all x.
To illustrate these abstract concepts, we will look at four explicit examples. These will
allow us to develop an important theme: The smoother the function, more rapidly its spec-
tral coefﬁcients converge.
EXAMPLE ONE: “Piecewise Linear” or “Sawtooth” Function
Since the basis functions of the Fourier expansion, {1, cos(nx), sin(nx)}, all are peri-
odic, it would be reasonable to suppose that the Fourier series would be useful only for
expanding functions that have this same property. In fact, this is only half-true. Fourier se-
ries work best for periodic functions, and whenever possible, we will use them only when
the boundary conditions are that the solution be periodic. (Geophysical example: because
the earth is round, atmospheric ﬂows are always periodic in longitude). However, Fourier
series will converge, albeit slowly, for quite arbitrary f(x).
In keeping with our rather low-brow approach, we will prove this by example. Suppose
we take f(x) = x, evaluate the integrals (2.2) and sum the series (2.1). What do we get?
Because all the basis functions are periodic, their sum must be periodic even if the
function f(x) in the integrals is not periodic. The result is that the Fourier series converges
to the so-called “saw-tooth” function (Fig. 2.1).
Since f(x) ≡x is antisymmetric, all the an are 0. The sine coefﬁcients are
bn
=
(1/π)
Z π
−π
x sin(nx)dx
=
(−1)n+1(2/n)
(2.7)
Since the coefﬁcients are decreasing as O(1/n), the series does not converge with blaz-
ing speed; in fact, this is the worst known example for an f(x) which is continuous.
Nonetheless, Fig. 2.2 shows that adding more and more terms to the sine series does indeed
generate a closer and closer approximation to a straight line.
The graph of the error shows that the discontinuity has polluted the approximation
with small, spurious oscillations everywhere. At any given ﬁxed x, however, the ampli-
tude of these oscillations decreases as O(1/N). Near the discontinuity, there is a region
where (i) the error is always O(1) and (ii) the Fourier partial sum overshoots f(x) by the
same amount, rising to a maximum of about 1.18 instead of 1, independent of N. Collec-
tively, these facts are known as “Gibbs’ Phenomenon”. Fortunately, through “ﬁltering”,
“sequence acceleration” and “reconstruction”, it is possible to ameliorate some of these
0
π
2π
3π
−π
−2π
Figure 2.1: “Sawtooth” (piecewise linear) function.

22
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
0
1
2
3
0
0.5
1
1.5
2
2.5
3
N=18
N=3
0
1
2
3
-1
-0.5
0
0.5
1
1.5
N=18
N=3
Figure 2.2: Left: partial sums of the Fourier series of the piecewise linear (“sawtooth”)
function (divided by π) for N=3 , 6, 9, 12, 15, 18. Right: errors. For clarity, both the partial
sums and errors have been shifted with upwards with increasing N.
problems. Because shock waves in ﬂuids are discontinuities, shocks produce Gibbs’ Phe-
nomenon, too, and demand the same remedies.
EXAMPLE TWO: “Half-Wave Rectiﬁer” Function
This is deﬁned on t ∈[0, 2π] by
f(t) ≡



sin(t),
0 < t < π
0,
π < t < 2π
and is extended to all t by assuming that this pattern repeats with a period of 2 π. [Geo-
physical note: this approximately describes the time dependence of thermal tides in the
earth’s atmosphere: the solar heating rises and falls during the day but is zero at night.]
Integration gives the Fourier coefﬁcients as
a0 = (1/π);
a2n = −2/[π(4n2 −1)]
(n > 0);
a2n+1 = 0(n ≥1)
(2.8)
b1 = 1/2;
b2n = 0
(n > 1)
(2.9)
Fig. 2.3 shows the sum of the ﬁrst four terms of the series, f4(x) = 0.318 + 0.5 sin(t) −
0.212 cos(2t)−0.042 cos(4t). The graph shows that the series is converging much faster than
that for the saw-tooth function. At t = π/2, where f(t) = 1.000, the ﬁrst four terms sum to
0.988, an error of only 1.2 %.
This series converges more rapidly than that for the “saw-tooth” because the “half-
wave rectiﬁer” function is smoother than the “saw-tooth” function. The latter is discontin-
uous and its coefﬁcients decrease as O(1/n) in the limit n →∞; the “half-wave rectiﬁer” is
continuous but its ﬁrst derivative is discontinous, so its coefﬁcients decrease as O(1/n2). This
is a general property: the smoother a function is, the more rapidly its Fourier coefﬁcients will
decrease, and we can explicitly derive the appropriate power of 1/n.

2.2. FOURIER SERIES
23
0
1
2
3
4
5
6
0
0.5
1
t
0
2
4
6
8
10
12
0
0.5
1
t
Figure 2.3: Top: graph of the “half-wave rectiﬁer” function. Bottom: A comparison of the
“half-wave rectiﬁer” function [dashed] with the sum of the ﬁrst four Fourier terms [solid].
f4(x) = 0.318 + 0.5 sin(t) −0.212 cos(2 t) −0.042 cos(4 t). The two curves are almost
indistinguishable.
Although spectral methods (and all other algorithms!) work best when the solution is
smooth and inﬁnitely differentiable, the “half-wave rectiﬁer” shows that this is not always
possible.
EXAMPLE THREE: Inﬁnitely Differentiable but Singular for Real x
f(x) ≡exp{−cos2(x)/ sin2(x)}
(2.10)
This function has an essential singularity of the form exp(−1/x2) at x = 0. The power
series about x = 0 is meaningless because all the derivatives of (2.10) tend to 0 as x →0.
However, the derivatives exist because their limit as x →0 is well-deﬁned and bounded.
The exponential decay of exp(−1/x2) is sufﬁcient to overcome the negative powers of x
that appear when we differentiate so that none of the derivatives are inﬁnite. Boyd (1982a)
shows that the Fourier coefﬁcients of (2.10) are asymptotically of the form
an ∼[ ] exp(−1.5n2/3) cos(2.60n2/3 + π/4)
(2.11)
where [] denotes an algebraic factor of n irrelevant for present purposes. Fast convergence,
even though the power series about x = 0 is useless, is a clear signal that spectral expan-
sions are more potent than Taylor series (Fig. 2.4).
This example may seem rather contrived. However, “singular-but-inﬁnitely-differentiable”
is actually the most common case for functions on an inﬁnite or semi-inﬁnite interval. Most
functions have such bounded singularities at inﬁnity, that is, at one or both endpoints of
the expansion interval.
EXAMPLE FOUR: “Symmetric, Imbricated-Lorentzian” (SIP) Function
f(x) ≡(1 −p2)/
©
(1 + p2) −2p cos(x)
ª
(2.12)

24
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
10
20
30
40
10
-10
10
-8
10
-6
10
-4
10
-2
10
0
degree n
Fourier coeffs.
-2
0
2
0
0.2
0.4
0.6
0.8
1
x
f
Figure 2.4: Left: graph of f(x) ≡exp(−cos2(x) / sin2(x) ). Right: Fourier cosine coefﬁ-
cients of this function. The sine coefﬁcients are all zero because this function is symmetric
with respect to x = 0.
where p < 1 is a constant. This f(x) is a periodic function which is inﬁnitely differentiable and
continuous in all its derivatives. Its Fourier series is
f(x) = 1 + 2
∞
X
n=1
pn cos(nx)
(2.13)
This example illustrates the “exponential” and “geometric” convergence which is typ-
ical of solutions to differential equations in the absence of shocks, corner singularities, or
discontinuities.
We may describe (2.13) as a “geometrically-converging” series because at x = 0, this is
a geometric series. Since | cos(nx) | ≤1 for all n and x, each term in the Fourier series is
bounded by the corresponding term in the geometric power series in p for all x. Because
this rate of convergence is generic and typical, it is important to understand that it is qual-
itatively different from the rate of the convergence of series whose terms are proportional
to some inverse power of n.
Note that each coefﬁcient in (2.13) is smaller than its predecessor by a factor of p where
p < 1. However, if the coefﬁcients were decreasing as O(1/nk) for some ﬁnite k where
k = 1 for the “saw-tooth” and k = 2 for the “half-wave rectiﬁer”, then
an+1/an
∼
nk/(n + 1)k
∼
1 −k/n
for
n >> k
(2.14)
∼
1
[Non −exponential Convergence]
Thus, even if k is a very large number, the ratio of an+1/an tends to 1 from below
for large n. This never happens for a series with “exponential” convergence; the ratio of
| an+1/an | is always bounded away from one — by p in (2.13), for example.

2.3. ORDERS OF CONVERGENCE
25
Clearly, series can converge at qualitatively different rates.
2.3
Orders of Convergence
It is useful to have precise deﬁnitions for classifying the rate of convergence (Boyd, 1982a).
Warning: these are all asymptotic deﬁnitions based on the behavior of the series coefﬁ-
cients for large n. They may be highly misleading if applied for small or moderate n.
Deﬁnition 2
The ALGEBRAIC INDEX OF CONVERGENCE k is the largest number for which
lim
n→∞| an | nk < ∞,
n >> 1
(2.15)
where the an are the coefﬁcients of the series. (For a Fourier series, the limit must be ﬁnite for both
the cosine coefﬁcients an and the sine coefﬁcients bn.)
Alternative deﬁnition: if the coefﬁcients of a series are an and if
an ∼O[1/nk],
n >> 1
(2.16)
then k is the algebraic index of convergence.
The two deﬁnitions are equivalent, but the roundabout form (2.15) also gives an un-
ambiguous deﬁnition of the order even for exotic cases for which the asymptotic form is
an ∼O(log[n]/nk) or the like.
Examples: the algebraic convergence order k is k = 1 for the Fourier series of the “saw-
tooth” function and k = 2 for that of the “half-wave rectiﬁer” function, whose coefﬁcients
are proportional to 1/n2 for n >> 1. This deﬁnition provides a guideline: One should
choose the spectral algorithm so as to maximize the algebraic convergence order for a given
problem; the method with the largest k will always give fastest asymptotic convergence.
Deﬁnition 3
If the algebraic index of convergence k is unbounded – in other words, if the coefﬁcients an decrease
faster than 1/nk for ANY ﬁnite power of k – then the series is said to have the property of “INFINITE
ORDER”, “EXPONENTIAL”, or “SPECTRAL” convergence.
Alternative deﬁnition: If
an ∼O[exp(−qnr)],
n >> 1
(2.17)
with q a constant for some r > 0, then the series has INFINITE ORDER or EXPONENTIAL
convergence.
The equivalence of the second deﬁnition to the ﬁrst is shown by the identity
lim
n→∞nk exp(−qnr) = 0,
all k, all r > 0
(2.18)
(Abramowitz and Stegun, 1965, pg. 68). The reason for giving two deﬁnitions is that (2.17),
which is more obvious and easier to understand, does not cover all possible cases. The
terms “exponential” and “inﬁnite order” are synonyms and may be used interchangeably.
The term “spectral accuracy” is widely used.
However, we shall avoid it because
algebraically-converging Chebyshev series are “spectral”, too. The popularity of this term
is a reminder that inﬁnite order convergence is usual for any well-designed spectral algo-
rithm.

26
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
Deﬁnition 4
The EXPONENTIAL INDEX OF CONVERGENCE r is given by
r ≡lim
n→∞
log | log(| an |) |
log(n)
(2.19)
An equivalent deﬁnition is that if s and q > 0 are constants and
an ∼O(s exp[−qnr]),
n >> 1,
(2.20)
then the EXPONENTIAL INDEX OF CONVERGENCE is the exponent r.
Example: the coefﬁcients of the function (2.12) are an = 2 exp(−{−log p} n), which is
of the form of (2.20) with the constant s = 2, q = −log(p), and the exponential index of
convergence r = 1.
Not all functions have series coefﬁcients in the form of (2.20); the coefﬁcients of the j-th
derivative of f(x) = (1 −p2)/[(1 + p2) −2p cos(x)] are O[nj exp(−qn)] whereas the j-th
integral has coefﬁcients that are O[ exp(−qn)/nj ]. The rigorous deﬁnition (2.19) allows for
such algebraic factors of n multiplying the exponential — by ignoring them.
The reason for ignoring algebraic factors is that nk varies very slowly in comparison
with the exponential for large n. (This is why (2.18) is true even for very large positive
values of k). We shall adopt the convention of representing such slowly-varying algebraic
factors of n by empty brackets [].
Deﬁnition 5 (Rates of Exponential Convergence) A series whose coefﬁcients are an is said to
have the property of SUPERGEOMETRIC, GEOMETRIC, or SUBGEOMETRIC convergence de-
pending upon whether
lim
n→∞log(| an |)/n =



∞
SUPERGEOMETRIC
constant
GEOMETRIC
0
SUBGEOMETRIC
(2.21)
Alternative deﬁnitions:
1. If an ∼O([] exp{−(n/j) log(n)}), convergence is SUPERGEOMETRIC
2. If an ∼O([] exp{−qn}), convergence is GEOMETRIC
3. If the exponential index of convergence r < 1, then the convergence is SUBGEOMETRIC.
(The empty brackets [] denote factors that vary more slowly with n than the exponentials.)
The motive for these deﬁnitions is that the Fourier and Chebyshev series of so-called
“entire functions” [functions without singularities anywhere in the complex plane except
at ∞] have “supergeometric” convergence. For the expansion of functions with poles or
branch points which are a ﬁnite distance off the expansion interval — the usual case —
geometric convergence is normal. Both entire functions and functions with singularities at
ﬁnite x (but off the expansion interval) have r = 1, so the exponential index of convergence
cannot discriminate between them even though these are quite distinct classes of functions.
“Subgeometric” convergence rarely occurs when solving problems on a ﬁnite interval, but
it is normal for series on inﬁnite or semi-inﬁnite intervals in x.
These deﬁnitions have been expressed in terms of the sequence of coefﬁcients an. How-
ever, normalized basis functions are always O(1) so that the magnitude of the term an φn(x)
is that of the coefﬁcient an.
The second comment is that the limits deﬁned above are meaningless when, for exam-
ple, every other coefﬁcient is zero. Strictly speaking, the limits should be supremum limits
(see glossary). It often sufﬁces, however, to apply the ordinary limit to the non-zero coefﬁ-
cients.

2.4. CONVERGENCE ORDER
27
Deﬁnition 6 (ASYMPTOTIC RATE OF GEOMETRIC CONVERGENCE ) If a series has ge-
ometric convergence, that is, if an expansion has an exponential index of convergence r = 1 so that
an ∼[ ] exp(−nµ)
(2.22)
where an are the spectral coefﬁcients, µ is a constant, and [ ] denotes unspeciﬁed factors that vary
more slowly with n than the exponential (such as nk for some k), then the ASYMPTOTIC RATE
OF GEOMETRIC CONVERGENCE is µ. Equivalently,
µ = lim
n→∞{−log | an | /n}
(2.23)
This deﬁnition is meaningful only for geometrically converging series; it does not apply when the
algebraic index of convergence is < ∞nor when the exponential index of convergence r < 1.
For power series, µ is simply the logarithm of the radius of convergence. Later in the
chapter, we shall explain how to calculate µ for Fourier and Chebyshev series in terms of
the singularities of the function being expanded.
2.4
Graphical Interpretation of Orders of Convergence
These abstract concepts become clearer with graphs. On a LOG-LINEAR graph, for example,
the coefﬁcients of a GEOMETRICALLY converging series will ASYMPTOTE to a STRAIGHT
LINE as shown by the solid curve in Fig. 2.5. “Supergeometric” convergence can then
be graphically deﬁned as coefﬁcients whose curve develops a more and more negative
slope (rather than a constant slope) on a log-linear graph. Similarly, subgeometric and
Subgeometric
0
10
20
30
40
10-10
10-8
10-6
10-4
10-2
100
Algebraic
Geometric
Supergeometric
Log-Linear
Figure 2.5: log | an | versus n for four rates of convergence. Circles: algebraic convergence,
such as an ∼1/n2. Dashed: subgeometric convergence, such as an ∼exp(−1.5 n2/3). Solid:
geometric convergence, such as exp(−µ n) for any positive µ. Pluses: supergeometric, such
as an ∼exp(−n log(n) ) or faster decay.

28
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
100
101
102
10-6
10-4
10-2
100
AA
AA
Log-Log
Algebraic
Subgeometric
Geometric
Supergeometric
Figure 2.6: Same as previous ﬁgure except that the graph is log-log: the degree of the
spectral coefﬁcient n is now plotted on a logarithmic scale, too.
100
101
102
10-10
10-5
100
n
Figure 2.7: Spectral coefﬁcients for two series. Upper curve: an = 1/n2. Lower curve:
an = exp(−n) + 10−8/n2.

2.4. CONVERGENCE ORDER
29
0
20
40
60
80
100
10-10
10-5
100
exp(- 0.3  n)
n2 exp(- 0.3  n)
exp(- 0.3 n)/(n log(n) )
Figure 2.8: Spectral coefﬁcients for three geometrically converging series. Although the
three sets of coefﬁcients differ through algebraic coefﬁcients — the top curve is larger by
n2 than the middle curve, which in turn is larger by a factor of n log(n) than the bottom
curve — the exponential dependence on n is the same for all. Consequently, all three sets of
coefﬁcients asymptote to parallel lines on this log-linear plot.
0
20
40
60
80
100
10
-5
10
-4
10
-3
10
-2
10
-1
10
0
Figure 2.9:
Solid:
logarithm of the absolute value of the spectral coefﬁcients of a
geometrically-converging series whose coefﬁcients oscillate with degree n. Dashed: the
“envelope” of the spectral coefﬁcients.

30
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
algebraic convergence rates produce curves which bend upward away from the straight
line of geometric convergence: Their slopes tend to zero from below on a log-linear plot.
If we change the graph format from log-linear to log-log, then algebraic convergence
with algebraic index of convergence k can be deﬁned as coefﬁcients whose curve asymp-
totes to a straight line whose slope is −k (Fig. 2.6). All species of exponential convergence
bend away with ever-increasing negative slopes on a plot of the logarithm of the absolute
value of { an } versus the logarithm of n. Graphically, “inﬁnite order” convergence is a
synonym for “unbounded negative slope” on a log-log plot.
Four qualiﬁers are necessary. First, these orders of convergence are meaningfully only
asymptotically. Fig. 2.7 compares the coefﬁcients of two spectral series that have the same
(poor) asymptotic convergence rate. However, the lower curve shows that its coefﬁcients
have fallen to O(10−8) before entering the asymptotic regime, so its slow convergence is
likely to be irrelevant in a practical sense.
Although the ﬁgure is contrived, the same thing is common in real-life. Boyd(1986c)
compares the coefﬁcients of the two-dimensional Chebyshev series for the solution of the
nonlinear eigenvalue problem known as Bratu’s equation with the corresponding series
for the solution to Poisson’s equation with constant forcing. Asymptotically, both spectral
series are sixth order because of weak singularities in the four corners of the square domain.
Although the Poisson series clearly exhibits this algebraic convergence on a log-log graph,
the Bratu coefﬁcients appear to fall off exponentially on Boyd’s graph. The reason is that
the nonlinearity introduces additional singularities – off the computational domain but
strong – which dominate the early spectral coefﬁcients. Only after the Bratu coefﬁcients
have fallen to less than O(10−5) of the maximum of the solution does the slope of the
Bratu series alter to match that of the Poisson equation. We cannot repeat this too often:
Asymptotic concepts like “convergence order” are meaningful only for large n. For small
n, who knows!
The second point is that the deﬁnitions above ignore algebraic factors of n which mod-
ulate the leading exponential; we have replaced these by empty square brackets in many
of the formulas of this chapter. Fig. 2.8 compares three series which differ only through
such algebraic factors. Obviously, the three series are not identical. A factor of n2 may
be anything but ignorable when n = 100! However, the graph shows that all three series
asymptote to parallel straight lines. It is in this sense that algebraic factors of n, such as pow-
ers and logarithms of n, are asymptotically irrelevant. The exponential factor of n must
dominate for sufﬁciently large n.
Third, what happens when the coefﬁcients of a spectral series oscillate with degree n?
Fig. 2.9 shows, consistent with asymptotic theories of spectral coefﬁcients, that it is possible
to tightly bound the spectral coefﬁcients by a monotonically-decaying curve even when the
individual coefﬁcients oscillate. This motivates the following.
Deﬁnition 7 (Envelope of the Spectral Coefﬁcients)
The ENVELOPE of the spectral coefﬁcients is deﬁned to be that curve, of the form of the leading
asymptotic term in the logarithm of the absolute value of the spectral coefﬁcients, which bounds the
coefﬁcients from above as tightly as possible.
Lastly, the asymptotic order may be defeated by the “Roundoff Plateau” illustrated in
Fig 2.10.

2.5. ASSUMPTION OF EQUAL ERRORS
31
0
20
40
60
80
100
10
-15
10
-10
10
-5
10
0
Roundoff Plateau
Figure 2.10: Numerically-generated spectral coefﬁcients for a typical function. Let amax de-
note the maximum absolute value of the spectral coefﬁcients aj for all j. Let ϵ denote a con-
stant proportional to the roundoff error or “machine epsilon”, typically around 10−16 on
most computers, but somewhat larger, perhaps by a factor of 100 or more. Then when the
exact coefﬁcients fall below ϵ amax, spectral algorithms including interpolation will com-
pute roundoff-corrupted coefﬁcients that will ﬂatten out at roughly an ∼ϵamax for all suf-
ﬁciently large n. (“Roughly” means that coefﬁcients in the “Roundoff Plateau” ﬂuctuate
randomly about the indicated magnitude.)
2.5
Assumption of Equal Errors
Deﬁnition 8 (Truncation Error)
The TRUNCATION ERROR ET (N) is deﬁned to be the error made by neglecting all spectral
coefﬁcients an with n > N.
Deﬁnition 9 (Discretization Error)
The DISCRETIZATION ERROR ED(N) is the difference between the ﬁrst (N + 1) terms of the
exact solution and the corresponding terms as computed by a spectral or pseudospectral method
using (N + 1) basis functions.
Deﬁnition 10 (Interpolation Error)
The INTERPOLATION ERROR EI(N) is the error made by approximating a function by an N +
1-term series whose coefﬁcients are chosen to make the approximation agree with the target function
exactly at each of N + 1 “interpolation” or “collocation” points, or it is the error in differential
equation approximations that use similar principles, i. e., the “pseudospectral” method.
It is generally impossible to estimate these various errors precisely for the unknown
solution to a differential equation. We have two useful alternatives. One is to look at the
numerically-computed spectral coefﬁcients, as described in Sec. 12. The other strategy, and
the only one which can be applied a priori is deﬁned by the following.
Deﬁnition 11 (Method of Model Functions)
Truncation error is estimated by computing the expansion of a KNOWN function which is “simi-
lar”, in a technical sense to be explained later, to the solution of the target differential equation, and
then truncating the known expansion after N + 1 terms.

32
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
It is rather disheartening to be forced to look at spectral coefﬁcients and truncation
errors for models when what we want is the total error in computing the solution to a dif-
ferential equation. A numerical method that has a low truncation error is useless if the
corresponding discretization error is horrible. However, many years of numerical experi-
ence has established the following assumption which will underlie the rest of the chapter.
Rule-of-Thumb 1 (ASSUMPTION OF EQUAL ERRORS)
The discretization and interpolation errors are the same order-of-magnitude as the truncation error.
Therefore, we can roughly compare the effectiveness of various algorithms and estimate the smallest
truncation N that gives a speciﬁed accuracy by inspection of the truncation error alone.
This is a strong assumption, and one that cannot be “proved” in any sense. A few
counter-examples are known. However, the assumption is clearly true in a negative sense:
A method that gives a poor truncation error (unless N is huge) is a terrible way to solve the
differential equation. The truncation error is therefore a very safe way to determine what
numerical procedures not to use.
Later, we will evaluate both types of error for a couple of examples and show that the
assumption is true at least for these particular cases.
2.6
Darboux’s Principle
Theorem 1 (DARBOUX’S PRINCIPLE: SINGULARITIES & CONVERGENCE)
For all types of spectral expansions (and for ordinary power series), both the DOMAIN of CONVER-
GENCE in the complex plane and also the RATE of CONVERGENCE are controlled by the LOCATION
and STRENGTH of the GRAVEST SINGULARITY in the complex plane. “Singularity” in this context
denotes poles, fractional powers, logarithms and other branch points, and discontinuities of f(z) or
any of its derivatives.
Each such singularity gives its own additive contribution to the coefﬁcients an in the asymptotic
limit n →∞. The “gravest” singularity is the one whose contribution is larger than the others in
this limit; there may be two or more of equal strength.
For the special case of power series, this is “DARBOUX’s THEOREM” (Darboux, 1878a, b,
Dingle, 1973, Hunter, 1986).
Darboux’s Principle also justiﬁes the assertion made in Sec. 2: the smoother f(x), the
faster the convergence of its spectral series. Table 2.2 (end of the chapter) catalogues the
relationship between the type of a singularity (logarithm, square root, etc.) and the asymp-
totic spectral coefﬁcients.
Darboux’s Principle implies a corollary that clariﬁes the Method of Model Functions.
Corollary 1 (SINGULARITY-MATCHING)
If two functions f(z) and g(z) have convergence-limiting singularities of the same type and
strength, then their asymptotic spectral coefﬁcients are the same in the limit n →∞. If f(z) −g(z)
is singular, but more weakly singular than either f(z) or g(z), the difference between the spectral
coefﬁcients of f(z) and g(z) decreases as an algebraic function of the degree n. If f(z) −g(z) is
not singular at the location of the common gravest singularity of f(z) and g(z), then the difference
between spectral coefﬁcients decreases exponentially fast with n.
This corollary is a direct consequence of Theorem 1: If we can compute asymptotic
expansions for the series coefﬁcients which depend only on the gravest singularity, then
when the singularity is eliminated by taking the difference f(z) −g(z), the leading term in
the asymptotic approximation for the spectral coefﬁcients is also eliminated. The spectral

2.6. DARBOUX’S PRINCIPLE
33
series for the difference must therefore converge more rapidly than the expansions for the
more singular functions f(z) and g(z).
This corollary deﬁnes in what sense an explicit model function should resemble the
unknown solution to a differential equation: The model and the unknown u(x) should
have the same gravest, convergence-limiting singularities.
This theorem implies that the examples below are not merely special cases. Rather, each
is typical of a whole class of functions that have singularities of the same type at the same
point. For example, 1/(x + a) where a is an arbitrary complex parameter is representative
of all functions whose convergence is limited by a ﬁrst order pole at x = −a.
An example is useful in explaining Darboux’s Principle. The geometrically converg-
ing Fourier series (2.24) has a partial fraction expansion which explicitly shows that this
function is singular only through simple poles at x = ±ia along the imaginary axis and
the images of these two poles under the periodicity shift, x →x + 2 π m where m is an
arbitrary integer:
λ(x; p)
≡
(1 −p2)
(1 + p2) −2 p cos(x)
=
1 + 2
∞
X
n=1
pn cos(n x)
(2.24)
=
2 a
∞
X
m=−∞
1
(a2 + (x −2π m )2)
(2.25)
where a ≡−log(p) →p = exp( −a ).
In contrast, the elliptic function Dn has an inﬁnite number of simple poles on the imag-
0
10
20
10
-1
10
0
degree n
Fourier coeffs.
0
0.5
0
5
10
15
λ
Dn
x
λ
Dn
Figure 2.11: Left panel: Graphs of Dn(x; p) (solid) and λ(x; p) (dashed).
Right panel:
Fourier coefﬁcients. Top (solid): coefﬁcients of λ. Bottom (circles): coefﬁcients of Dn.

34
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
inary axis, instead of just two.
Dn(x; p)
≡
(1/2) + 2
∞
X
n=1
[pn/(1 + p2n)] cos(nx)
(2.26)
=
B
∞
X
m=−∞
sech[B(x −2πm)]
(2.27)
B(p)
≡
π/ [ 2 log(1/p)]
(2.28)
Dn has simple poles at
x = 2πm + ia(2j + 1)
all
integers
m, j
(2.29)
Either by matching poles and residues or by Taylor expanding the 1/(1 + p2n) factor,
one can show
Dn(x; p) = (1/2) +
∞
X
j=0
(−1)j {λ(x; p2j+1) −1}
(2.30)
This is a partial fraction expansion, modiﬁed so that all poles at a given distance from
the real axis are combined into a single term, and it converges rather slowly. Graphed
as a function of x, this elliptic function Dn(x; p) resembles λ(x; p) only in a general way
(Fig. 2.11).
However, the Fourier coefﬁcients of the elliptic function are more and more dominated
by those of λ(x; p) as the degree of the coefﬁcient increases because
pn/(1 + p2n) ≈pn{1 + O(p2n)},
p << 1
(2.31)
If p is only slightly smaller than 1 (a slowly-converging series), then the lowest few elliptic
coefﬁcients will be roughly half those of the “imbricated-Lorentzian” λ. As the degree
of the coefﬁcient n increases, however, the approximation (2.31) will eventually become
accurate. If we truncate the series at n = N and choose N sufﬁciently large so that we
obtain an accuracy of 10−t, then the relative error in the last retained coefﬁcient, an, is
O(10−2t).
The reason that Eq. (2.31) is so accurate is that the difference,
δ(x; p) ≡Dn(x; p) −λ(x; p),
(2.32)
is a function which is no longer singular at x = ±i a, but instead converges for all | ℑ(x) |<
3a. It is a general truth that whenever the difference between the “model” and “target”
functions has a larger domain of convergence than f(x), the difference between the Fourier
(or Chebyshev or any kind of spectral) coefﬁcients will decrease exponentially fast with n.
Of course, the situation is not always so favorable. For example, if a function is approx-
imated by
f(x) ≈log(x −ia){1 + b1(x −ia) + b2(x −i a)2 + . . . }
(2.33)
in the vicinity of its convergence-limiting poles, it is easy to match the gravest branch point,
log(x −i a). Unfortunately, the difference between f(x) and the model will still be singular
at x = ia with the weaker branch point, (x −i a) log(x −i a). The difference f(x) −log(x −
i a) has a Fourier series that converges more rapidly than that of f(x) by a factor of n, so
the error in approximating the Fourier coefﬁcients of f(x) by those of the logarithmically
singular model will decrease as O(1/n).

2.7. WHY TAYLOR SERIES FAIL
35
Even so, it is clear that each function is representative of a whole class of functions: The
class of all functions that have singularities of that type and at that convergence-limiting
location. In a weaker sense (that is, if algebraic factors of n are ignored), each function
is representative of all functions that have convergence-limiting singularities at a given
point, regardless of the type of singularity (pole, square root, logarithm or whatever). It
follows that to understand a few representative functions is to understand spectral series
in general.
2.7
Convergence Domains: Why Taylor Series Don’t Work
For all the standard basis functions, the spectral series converges in a domain of known
shape in the complex plane. Since the singularities of f(x) control the asymptotic form of
the spectral coefﬁcients (Darboux’s Principle), it follows that the size of the convergence
domain and the rate of convergence at a given point within the domain are both controlled
by the singularities of f(x), too.
Theorem 2 (CONVERGENCE DOMAIN in COMPLEX PLANE)
Barring a few exceptional cases, a spectral series converges in the largest domain in the x-plane, of
a certain basis-dependent shape, which is free of singularities. For power series, the domain shape
is a disk. For Fourier and Hermite series, it is an inﬁnite strip, symmetric around the real x-axis.
For Chebyshev, Legendre, and Gegenbauer polynomials, the convergence domain is the interior of
an ellipse with foci at x = ±1.
The exceptional cases are entire functions which grow very rapidly in certain parts of the complex
plane as described in Chapter 17 and Boyd (2001).
PROOF: Given, for various basis sets, in classical treatises on Fourier series and orthog-
onal polynomials.
Appendix A graphs the convergence domain for several basis sets, but we usually have
little direct interest in summing a spectral series for complex x! These convergence do-
mains are signiﬁcant only in the indirect sense that the larger the convergence region, the
faster the spectral series converges for that interval of real x that we really care about.
Later in the chapter, we shall show that knowledge of the complex singularities of a func-
tion u(x) allows us to explicitly calculate the asymptotic Fourier or Chebyshev coefﬁcients
of the function.
A power series’ disk-shaped convergence domain is a fatal weakness for many appli-
cations, such as approximating the solution to a boundary value problem. Figure 2.12
compares the domains of convergence for the power series and the Fourier series of the
function f(x) ≡(1 −p2)/
©
(1 + p2) −2p cos(x)
ª
. This function is smooth, well-behaved
and inﬁnitely differentiable for all real x. Nevertheless, both expansions have ﬁnite do-
mains of convergence because f(x) has simple poles, where it blows up as 1/(x −x0),
along the imaginary x-axis.
Because the convergence domain for a Taylor series is a disk, the power series only
converges for a ﬁnite interval along the real x-axis. If we want to solve a boundary value
problem on an interval x ∈[−π, π] whose solution is f(x), or a function similar to it, a
power series will fail. In contrast, the strip of convergence for the Fourier series embraces
all real x.
Similarly, Chebyshev and Legendre polynomials are normally applied to solve prob-
lems on the canonical interval [-1, 1]. (If the domain is a different interval y ∈[a, b], one can
always make the trivial change of variable x ≡(2y −(b + a))/(b −a) to map the problem
into x ∈[−1, 1].) Since the foci of an ellipse always lie inside it, the convergence domain for

36
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
A
A
A
AA
AA
AA
AA
AAA
AAA
AAA
AAA
AA
AA
AA
AA
AA
AA
AA
AA
AA
AAA
AAA
AAA
AA
AA
AA
AA
A
A
A
A
Re(z)
Im(z)
−π
π
0
Figure 2.12: A comparison of the regions of Fourier and Taylor series convergence in the
complex z-plane for the function f(z) ≡(1 −p2)/
©
(1 + p2) −2p cos(z)
ª
for p = 0.35. The
Fourier series converges within the strip bounded by the two horizontal dashed lines. The
power series converges only within the disk bounded by the dotted circle.
these orthogonal polynomials, which is bounded by an ellipse with foci at x = ±1, always
includes the whole interval [-1, 1]. Thus, singularities of f(x) outside this interval (whether
at real or complex locations) can slow the convergence of a Legendre or Chebyshev series,
but can never destroy it.
It is for this reason that our series, instead of being the more familiar Taylor expansions,
will be Fourier or Chebyshev or Legendre series instead. If its disk of convergence is too
small to include the boundaries, the power series will give nonsense. In contrast, the suc-
cess of spectral methods is guaranteed as long as the target interval, x ∈[−1, 1], is free of
singularities.
2.8
Stalking the Wild Singularity or Where the Branch Points
Are
It is sometimes possible to identify the type and nature of the singularities of the solution
to a differential equation a priori without knowing the solution.
Theorem 3 (SINGULARITIES of the SOLUTION to a LINEAR ODE)
The solution to a linear ordinary differential equation is singular only where the coefﬁcients of the
differential equation or the inhomogeneous forcing are singular, and it may be analytic even at these
points.
PROOF: Given in undergraduate mathematics textbooks.
An equivalent way of stating the theorem is to say that at points where all the coefﬁ-
cients of the differential equation and the inhomogeneous term are analytic functions, one
may expand the solution as a Taylor series (Frobenius method) about that point with a
non-zero radius of convergence.
Thus,the solution of
uxx +
1
1 + x2 u = 0
(2.34)

2.8. LOCATION OF SINGULARITIES
37
on x ∈[−1, 1], is singular only at the poles of the coefﬁcient of the undifferentiated term
at x = ±i and at inﬁnity. The Chebyshev and Legendre series of u(x) is, independent
of the boundary conditions, guaranteed to converge inside the ellipse in the complex x-
plane with foci at ±1 which intersects the locations of the poles of 1/(1 + x2). By using the
methods described in a later section, we can calculate the rate of geometric convergence to
show that the series coefﬁcients |an| must decrease as O([ ] (0.17)n/2). The empty bracket
represents an algebraic factor of n; this can be deduced by performing a local analysis
around x = ± i to determine the type of the singularity of u(x) [this type need not match
that of the coefﬁcients of the differential equation] and applying Table 2.2. All without
actually knowing u(x) itself or even specifying boundary conditions!
Unfortunately, the theorem does not extend to partial differential equations or to nonlin-
ear equations even in one dimension.
EXAMPLE: First Painlev´e Transcendent
The differential equation
uxx −u2 = x
(2.35)
u(0) = ux(0) = 0
(2.36)
has coefﬁcients and an inhomogeneous term which have no singularities. Nonetheless,
numerical integration and asymptotic analysis show that u(x) has poles at x=3.742, 8.376,
12.426, etc.: an inﬁnite number of poles on the real axis. (Bender and Orszag, 1978, pg.
162). These poles are actually “movable” singularities, that is, their location depends on
the initial conditions, and not merely upon the form of the differential equation.
Movable singularities are generic properties of solutions to nonlinear differential equa-
tions. The reason can be understood by examining an ODE closely related to the Painlev´e
transcendent:
uxx −U(x)u = x
(2.37)
where U(x) is arbitrary. Because this is linear, Theorem 3 tells us that u(x) is singular only
where U(x) is singular. If we chose U(x) to be a solution of the Painlev´e equation, however,
then the linear ODE simply becomes (2.35). Thus, for a nonlinear ODE, the solution u(x)
itself furnishes the spatially-variable coefﬁcients. Theorem 3 actually still applies; unfortu-
nately, it is useless because we cannot apply it until we already know the singularities of
u(x), which is of course the very information we want from the theorem.
For many nonlinear equations, a problem-speciﬁc analysis will deduce some a priori
information about the location of singularities, but no general methods are known.
On a more positive note, often the physics of a problem shows that the solution must
be “nice” on the problem domain. This implies, if the interval is rescaled to x ∈[−1, 1]
and a Chebyshev or Legendre expansion applied, that the spectral series is guaranteed to
converge exponentially fast. The only catch is that the asymptotic rate of convergence µ,
where the spectral coefﬁcients are asymptotically of the form an ∼[ ] exp(−n µ ), could
be very large or very small or anywhere in between — without advance knowledge of the
singurities of u(x) outside the problem domain, we cannot be more speciﬁc than to assert
“exponential convergence”. (However, some rules-of-thumb will be offered later.)
2.8.1
Corner Singularities & Compatibility Conditions
Unfortunately, for partial differential equations, it is usual for the solution to even a lin-
ear, constant coefﬁcient equation to be weakly singular in the corners of the domain, if the
boundary has sharp corners.

38
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
EXAMPLE: Poisson equation on a rectangle. If
∇2u = −1;
u = 0
on the sides of the rectangle,
(2.38)
then the solution is weakly singular in the four corners. In terms of a polar coordinate
system (r, θ) centered on one of the corners, the singularity is of the form
u = (constant) r2 log(r) sin(2θ) + other terms
(2.39)
(Birkhoff and Lynch, 1984). The singularity is “weak” in the sense that u(x, y) and its ﬁrst
two derivatives are bounded; it is only the third derivative that is inﬁnite in the corners.
Constant coefﬁcient, constant forcing, singular solution? It seems a contradiction. How-
ever, the boundary curve of a square or any other domain with a corner cannot be repre-
sented by a smooth, inﬁnitely differentiable curve. At a right-angled corner, for example,
the boundary curve must abruptly shift from vertical to horizontal: the curve is continuous,
but its slope has a jump discontinuity.
This argument suggests, correctly, that corner singularities can be eliminated by slighly
rounding the corners so that both the boundary curve and the values of u upon it can be
parameterized by smooth, inﬁnitely differentiable curves. This is true physically as well as
mathematically.
In solid mechanics, corners are regions of very high stress, and the corner singularities
are merely a mathematical reﬂection of this. In a house, cracks in paint or drywall often
radiate from the corners of windows and door openings. The ﬁrst commercial jet aircraft,
the British Comet, was grounded in the early 1950s after three catastrophic, no-survivor
crashes. One of the surviving airframes was tested to destruction in a water tank that was
repeatedly pressurized. After six weeks, the airframe failed abruptly. A crack began at a
corner of one of the airliner’s square windows and then propagated backwards until it was
ten meters long!
Modern airliners all have windows with rounded corners. Unfortunately, in other con-
texts, it is often necessary to solve problems with unrounded corners.
There are two pieces of good news. First, corner singularities are often so weak as to
be effectively ignorable even for high accuracy Chebyshev solutions (Boyd, 1986c, Lee,
Schultz and Boyd, 1989b). Second, there are good methods for dealing with singularities
including mapping and singularity subtraction as will be described in Chapter 16.
EXAMPLE: One-Dimensional Diffusion Equation
ut = uxx,
u(0) = u(π) = 0
(2.40)
u(x, t = 0) = Q(x)
(2.41)
Although the diffusion equation is a partial differential equation, it is one-dimensional and
linear. The particular initial condition
Q(x) = x(π −x)
(2.42)
satisﬁes the boundary conditions and is a polynomial which can be exactly represented by
the sum of the lowest three Chebyshev polynomials. Nevertheless, u(x, t) is singular.
The reason is that the solution to the problem as posed is actually the restriction to
the interval x ∈[0, π] of the diffusion equation on the inﬁnite interval, subject to an initial

2.8. LOCATION OF SINGULARITIES
39
condition which is spatially periodic and antisymmetric with respect to both the origin and
x = π. We can create such an initial condition by either (i) expanding the initial Q(x) as a
sine series or (ii) deﬁning it directly as
P(x) = sign(sin(x))Q(x)
∀x ∈[−∞, ∞]
(2.43)
where the sign function equals one when its argument is positive and is equal to minus
one when its argument is negative. Fig 2.13 shows the initial condition (Eq. 2.42) and its
second derivative. The latter has jump discontinuities at x = ±0, π, 2 π, . . . .
At t = 0, these discontinuities cause no problems for a Chebyshev expansion because
the Chebyshev series is restricted to x ∈[0, π] (using Chebyshev polynomials with argu-
ment y ≡(2/π)(x −π/2)). On this interval, the initial second derivative is just the constant
−2. For t > 0 but very small, diffusion smooths the step function discontinuities in uxx,
replacing the jumps by very narrow boundary layers. As t →0+, the layers become in-
ﬁnitely thin, and thus a Chebyshev approximation for any ﬁxed truncation N must converge
slowly for sufﬁciently small t.
Fortunately, this pathology is often not fatal in practice because these diffusive bound-
ary layers widen rapidly so that the evolution for later times can be easily tracked with a
Chebyshev spectral method for small or moderate N. Indeed, many scientists have hap-
pily solved the diffusion equation, graphing the answer only at longish time intervals, and
missed the narrow transient boundary layers with no ill effect.
EXAMPLE: One-Dimensional Wave Equation
utt = uxx,
u(0) = u(π) = 0
(2.44)
-5
0
5
-2
-1
0
1
2
Q
-5
0
5
-2
-1
0
1
2
Qxx
-5
0
5
-2
-1
0
1
2
u(x,t=1/10)
-5
0
5
-2
-1
0
1
2
uxx(x,t=1/10)
Figure 2.13: A representative solution to the diffusion equation. Upper panels: Initial con-
dition (left) and its second derivative (right). Bottom panels: Solution at t = 1/10 (left) and
its second derivative (right).

40
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
0
2
4
6
-2
-1
0
1
2
f
0
2
4
6
-2
-1
0
1
2
fxx
0
2
4
6
-2
-1
0
1
2
u(x,t=0.5)
0
2
4
6
-2
-1
0
1
2
uxx(x,t=0.5)
Figure 2.14: Wave equation. Upper panels: Initial condition (left) and its second derivative
(right). Bottom panels: Solution at t = 1/2 (left) and its second derivative (right). The
singularities, which are initially at x = 0, π, 2π, etc., propagate both left and right.
u(x, t = 0) = f(x),
ut(x, t = 0) = g(x)
(2.45)
The particular initial condition
f(x) = x(π −x),
g(x) = 0
(2.46)
is the same as for the diffusion example, and also yields a singular solution
Again, the reason is that the problem as posed is actually the restriction to the interval
x ∈[0, π] of the same equation on the inﬁnite interval with the initial condition:
P(x) = sign(sin(x))f(x) ∀x ∈[−∞, ∞]
(2.47)
Fig 2.14 shows the initial condition and its second derivative. The latter has jump disconti-
nuities at x = ±0, π, 2 π, . . . .
The general solution to the wave equation (ut(x, t = 0) = 0) is
u(x, t) = (1/2){ f(x −t) + f(x + t) }
(2.48)
Instead of diffusing away, the jumps in the second derivative, initially at t = mπ where m is
an any integer, propagate both left and right. Thus, at the later time illustrated in the lower
panels of Fig. 2.14, the exact solution has a second derivative which is discontinuous at two
points in the interior of x ∈[0, 1], even though the initial condition was super-smooth: a
quadratic polynomial.
The singularities of the diffusion and wave equations are similar to those of Poisson’s
equation in that they, too, are located at the corners, at least initially. However, the corners
are now in space-time, that is, at the corners of a domain in the x −t plane.

2.9. FACE: INTEGRATION-BY-PARTS BOUND
41
In contrast to the singularities of an elliptic equation, the corner singularities of a hy-
perbolic or parabolic equation are usually unphysical. The reason is that the choice of the
initial time is usually arbitrary. In weather forecasting, for example, the forecast is usually
begun at midnight Greenwich mean time. Why should the singularities be located at the
boundary of the atmosphere at this time and no other? Would physical singularities move
if the forecast were begun an hour earlier or later? Boyd and Flyer(1999) discuss how initial
conditions can be slightly modiﬁed to satisfy “compatibility” conditions and thus eliminate
the space-time corner singularities.
These three examples should chill the blood of any aspiring computational scientist.
Albert Einstein noted ”Subtle is the Lord”, which is the great man’s way of saying that your
computer program is always trying to kill you. Fear is a very good thing for a numerical
analyst. One may wish mournfully for faster silicon, but the only absolutely fatal disease
to a scientist is a deﬁciency of thinking.
With thinking, spectral methods do very well indeed, even for nasty problems. In the
rest of the book, we explain how.
2.9
FACE: Integration-by-Parts Bound on Fourier Coefﬁcients
The coefﬁcients of the complex-exponential form of a Fourier series are:
cn =
1
2 π
Z π
−π
f(x) exp(−in x) dx
(2.49)
If we integrate by parts, repeatedly integrating the exponential and differentiating f(x),
we obtain without approximation after (J + 1) steps:
cn
=
1
2 π
J
X
j=0
(−1)j+n
µ i
n
¶j+1 n
f (j)(π) −f (j)(−π)
o
+ 1
2 π
µ
−i
n
¶J+1 Z π
−π
f (J+1)(x) exp(−in x ) dx
(2.50)
where f J+1(x) denotes the (J + 1)-st derivative of f(x). (Note that these integrations-by-
parts assume sufﬁcient differentiability of f(x).) The integral can be bounded by the length
of the integration interval times the maximum of the integrand, which is the maximum of
the absolute value of | f J+1 |. In the limit n →∞for ﬁxed J, it follows that the integral is
O(1/nJ+1); ignoring it gives what Lyness (1971, 1984) has dubbed the “Fourier Asymptotic
Coefﬁcient Expansion” (FACE):
cn ∼1
2π
J
X
j=0
(−1)j+n
µ i
n
¶j+1 n
f (j)(π) −f (j)(−π)
o
+ O(n−(J+1)), n →∞, ﬁxed J (2.51)
This expansion is an asymptotic series, diverging in the limit of ﬁxed n, J →∞.
By taking real and imaginary parts and recalling that the cosine and sine coefﬁcients
are related to the complex coefﬁcients via (for real-valued f(x))
an = 2 ℜ(cn);
bn = −2 ℑcn
∀n > 0
(2.52)

42
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
one obtains an equivalent form of the FACE as (n > 0)
an ∼1
π
J
X
j=0
(−1)n+j
µf (2j+1)(π) −f (2j+1)(−π)
n2j+2
¶
+ O(n−(2J+4)), n →∞, ﬁxed J
(2.53)
bn ∼1
π
J
X
j=0
(−1)n+1+j
µf (2j)(π) −f (2j)(−π)
n2j+1
¶
+ O(n−(2J+3)), n →∞, ﬁxed J
(2.54)
If a function has discontinuities in the interior of the interval x ∈[−π, π], then the inte-
grals can be split into segments and integration-by-parts applied to derive similar asymp-
totic expansions.
Although sometimes used to accelerate the calculation of Fourier coefﬁcients for func-
tions whose series lack exponential convergence, the FACE is most important as the proof
of the following theorem.
Theorem 4 (INTEGRATION-BY-PARTS COEFFICIENT BOUND) If
1.
f(π) = f(−π), f (1)(π) = f (1)(−π), ..., f (k−2)(π) = f (k−2)(−π)
(2.55)
2. f (k)(x) is integrable
then the coefﬁcients of the Fourier series
f(x) = a0 +
∞
X
n=1
an cos(nx) +
∞
X
n=1
bn sin(nx)
(2.56)
have the upper bounds
| an |≤F/nk;
| bn |≤F/nk
(2.57)
for some sufﬁciently large constant F, which is independent of n.
An equivalent way of stating the theorem is that, if the two conditions above are satisﬁed, then
the algebraic index of convergence is at least as large as k.
Notes: (a) f (k) denotes the k-th derivative of f(x) (b) The integrability of f (k) requires that f(x),
f (1)(x), . . . , f (k−2)(x) must be continuous.
PROOF: Under the conditions of the theorem, the ﬁrst (k −1) terms in the FACE are
zero. For sufﬁciently large n, the lowest nonzero term in the series will dominate, implying
that the Fourier coefﬁcients are asymptotically O(nk). Q. E. D.
A few remarks are in order. First, the usual way to exploit the theorem is to integrate-
by-parts as many times as possible until lack of smoothness or a mismatch in boundary
values forces us to stop. At that point, the number k that appears in the theorem is a lower
bound on the algebraic convergence index deﬁned earlier.
However, the index of convergence need not be an integer. For example, if f(x) is a
periodic function with a cube root singularity for real x, such as sin1/3(x), one integration
by parts shows that the Fourier coefﬁcients decrease at least as fast as O(1/n). Because
the second derivative of a cube root singularity has a branch point proportional to x−5/3,

2.9. FACE: INTEGRATION-BY-PARTS BOUND
43
which is not integrable, we cannot integrate-by-parts a second time. However, one can
show by other arguments that the integral
1
n
Z π
−π
f (1)(x) exp(−inx) dx
(2.58)
is actually O(1/n4/3). (It would take us too far aﬁeld to give the detailed proof of this.) The
theorem gives the largest integer which is less than or equal to the actual algebraic index
of convergence. For the sawtooth function and the half-wave rectiﬁer function, the index
is an integer and then the theorem gives it precisely.
Second, for pure sine or pure cosine series, every other integration-by-parts is triv-
ial. (Note that the FACE for the cosine coefﬁcients proceeds only in even powers of n and
odd derivatives of f(x) while the sine coefﬁcient expansion involves only odd powers of
n but even derivatives of f(x).) For example, if f(x) = f(−x), then the function is sym-
metric about x = 0 and all its sine coefﬁcients are zero. The even order boundary terms
for the cosine coefﬁcients vanish independent of whether f (2k)(π) = f (2k)(−π); as if to re-
inforce the point, the symmetry condition ensures that all the even derivatives are equal
at the boundaries anyway. Thus, for a cosine series, it is sufﬁcient to examine whether
f (2k−1)(π) = f (2k−1)(−π). Similarly, for a sine series, boundary matching of the odd order
derivatives is irrelevant and the process of integration–by–parts can only be blocked after
an odd number of integrations.
Third, if the function is periodic and differentiable to all orders, we can integrate–by–
parts an arbitrary number of times. In that case, the theorem implies that for large n, the
Fourier coefﬁcients are decreasing faster than any ﬁnite power of n. This is the property of
“inﬁnite order” or “exponential” convergence deﬁned above.
Fourth, since a Chebyshev series in x becomes a Fourier series in y only after we
make the substitution x = cos(y), a Chebyshev series – after the change of variable –
is automatically periodic in y.
Therefore, a CHEBYSHEV SERIES ALWAYS HAS THE
PROPERTY OF INFINITE ORDER CONVERGENCE EVEN FOR FUNCTIONS THAT ARE
NON-PERIODIC (in x, the Chebyshev argument) if all its derivatives are bounded on the
expansion interval, x ∈[−1, 1].
Fifth, the constant F increases with k, the number of times we integrate-by-parts. Con-
sequently, we cannot take the limit of k →∞for ﬁxed n. (Taking this limit with the false
assumption of k-independent F would imply that all the coefﬁcients are zero!) Rather, the
theorem tells us how rapidly the coefﬁcients decrease for large n as n →∞for ﬁxed k.
Sixth, this theorem can be strengthened to the statement that if f(x) is in the Lipschitz
space Lλ “on the circle”, then an, bn ∼O(n−λ). A function is in the Lipschitz space Lλ (for
0 < λ < 1) if |f(x) −f(y)| = O(|x −y|λ) for all x, y on the interval; Lipschitz spaces for
λ > 1 are deﬁned by taking higher order differences of f. The phrase “on the circle” means
that continuity is analyzed as if the interval x ∈[−π, π] is bent into a circle so that x = π is
continuous with x = −π; for example, f(−π) ̸= f(π) implies that the function is not in any
Lipschitz space with λ > 0.
EXAMPLE: Let us calculate the index of convergence of the Fourier series solution to
uxx + Q(x) u = f(x);
u(0) = u(π) = 0
(2.59)
Since the boundary conditions do not impose periodicity, the solution to this problem is
usually not periodic even if the functions Q(x) and f(x) are periodic themselves.
Because of the lack of periodicity, we really ought to use Chebyshev polynomials for
this problem. Nonetheless, many old papers have applied Fourier series to non-periodic

44
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
problems; certain analytical techniques, such as the method of separation-of-variables, fail
otherwise. It therefore is useful to see just how bad this choice of basis functions is.
Because the boundary conditions demand u(0) = 0, we must exclude the cosine terms
(and the constant) from the Fourier series and use only the sine functions:
u(x) =
∞
X
n=1
bn sin(nx)
(2.60)
Since the sum of the sine series and the individual sine functions are both antisymmetric
with respect to x = 0, we halve the interval of integration to [0, π] and double the result.
This is natural for this problem since [0, π] is the interval between the boundaries. Thus,
bn = (2/π)
Z π
0
u(x) sin(nx)dx
(2.61)
One integration-by-parts gives
bn = −(2/[nπ])
¯¯¯
π
0u(x) cos(nx) + (2/[nπ])
Z π
0
u(1)(x) cos(nx)
(2.62)
The boundary conditions u(0) = u(π) guarantee that the boundary term in (2.62) is zero
independent of Q(x) and f(x). Integrating–by–parts a second time gives
bn = (2/[n2π])
¯¯¯
π
0u(1)(x) sin(nx) −(2/[n2π])
Z π
0
u(2)(x) sin(nx)dx
(2.63)
Since sin(0) = sin(nπ) = 0, it does not matter whether u(1)(0) = u(1)(π); the boundary term
in (2.63) is 0 anyway.
Integrating-by-parts a third time gives
bn = (2/[n3π])
¯¯¯
π
0u(2)(x) cos(nx) −(2/[n3π])
Z π
0
u(3)(x) cos(nx)dx
(2.64)
Since cos(nπ) ̸= cos(0) for odd n, we are stuck with k = 3 as the algebraic index of conver-
gence unless u(2)(0) = u(2)(π). Since one can only impose one pair of boundary conditions
on the solution of a second order differential equation, we would seem to be out of luck.
Evaluating the differential equation at x = 0, however, gives
u(2)(0)
=
−Q(0) u(0) + f(0)
=
f(0)
(2.65)
since the boundary conditions on the differential equation require u(0) = 0. Similarly,
u(2)(π) = f(π). We see that if
f(0) = f(π) = 0,
(2.66)
then the combination of the differential equation with its associated boundary conditions
forces the boundary term in (2.64) to vanish. We can integrate twice more before being
defeated by the fact that u(4)(0) ̸= u(4)(π). Thus, whether the index of convergence is k
= 3 or 5 depends entirely upon whether f(x) satisﬁes condition (2.66) (as is often true in
practical applications). A k = 5 geophysical example is Eliasen (1954), who used a Fourier
sine series to solve the “barotropic instability problem” for a cosine jet.
The important point is that we deduced the index of convergence simply from the form
of the differential equation and the boundary conditions. We did not have to specify Q(x)

2.10. ASYMPTOTIC CALCULATION OF FOURIER COEFFICIENTS
45
at all, and f(x) only at two points to compute k. The integration–by–parts theorem is a
very powerful tool because we can apply it before we solve the differential equation.
This theorem is also important because it generalizes to all other spectral basis sets. That
is to say, integration–by–parts can be used to provide similar coefﬁcient bounds for any
of the standard basis functions including Chebyshev and Legendre polynomials, Hermite
functions and spherical harmonics.
2.10
Asymptotic Calculation of Fourier Coefﬁcients
Theorem 5 (STRIP OF CONVERGENCE FOR FOURIER SERIES) Let z = x + iy and let
ρ denote the absolute value of the imaginary part of the location of that singularity of f(z) which is
nearest the real z-axis. In other words, if zj, j = 1, 2, . . . denotes the location of the singularities of
f(z), then
ρ = min
j
|ℑ(zj)| .
(2.67)
Then the Fourier series converges uniformly and absolutely within the STRIP in the complex z-
plane, centered on the real axis, which is deﬁned by
| y |< ρ,
x = arbitrary
[convergence]
(2.68)
and diverges outside the strip,
| y |> ρ,
x = arbitrary
[divergence]
(2.69)
If the limit exists, then the asymptotic coefﬁcients of the Fourier series
f(z) = a0 +
∞
X
n=1
an cos(nz) +
∞
X
n=1
bn sin(nz)
(2.70)
are related to ρ, the half-width of the strip of convergence, by
lim sup
n→∞log | an/an+1 |= ρ
(2.71)
and similarly for the sine coefﬁcients bn.
The asymptotic rate of convergence for real z is given by µ = ρ.
If the series has a ﬁnite algebraic index of convergence, then ρ = 0 and the series converges only
on the real axis.
If the function is periodic and entire, i. e., has no poles or branch points except at inﬁnity, then
usually ρ = ∞and the coefﬁcients are O[exp(−(n/k) log(n) + O(n))] for some constant k. (The
exceptions with ﬁnite ρ are entire functions that grow very rapidly with | z | such as exponentials-
of-exponentials, as discussed in Boyd (1994b).)
Note: In this context, “singularity” includes not only poles and branch points, but also discon-
tinuities caused by a lack of periodicity, as for the saw-tooth function.
PROOF: We omit a rigorous proof, but offer the following argument. Let z = x + iy so
that | exp(i n z) | = exp(−n y). Thus, in the complex form of the Fourier series
f(z) =
∞
X
n=−∞
cn exp(inz) =
∞
X
n=−∞
cn exp(inx) exp(−ny)
(2.72)

46
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
all terms with negative n grow exponentially as exp(| n |y) in the upper half-plane while
those with n > 0 grow in the lower half-plane. It follows that the series can converge at
| y | = ρ if and only if | c±n | decay at least as fast as exp(−n ρ).
On the other hand, if f(z) has a pole at y = ρ, the series must converge to ever-larger
values as ℑ(z) →ρ. This implies that the coefﬁcients cannot decrease faster than exp(−nρ)
(modulo the usual algebraic factor of n). (Note that if the coefﬁcients could be bounded by
exp(−n(ρ −ϵ)) for some small positive ϵ, for example, then one could bound the Fourier
series, term-by-term, by a convergent geometric series to show it was ﬁnite even at the
pole.)
Thus, the series coefﬁcients must decrease as exp(−n ρ) when f(z) has a singularity at
| ℑ(z) | = µ. Q. E. D.
The theorem shows that “geometric” convergence is normal for a Fourier series. It is only
when the function has a discontinuity or other singularity for real z that the series will have
sub-geometric or algebraic convergence.
2.11
Convergence Theory for Chebyshev Polynomials
Since a Chebyshev polynomial expansion is merely a Fourier cosine series in disguise, the
convergence theory is very similar to that for Fourier series. Every theorem, every identity,
of Chebyshev polynomials has its Fourier counterpart. Nonetheless, the mapping does
produce some noteworthy consequences.
The mapping is
z = cos(θ)
(2.73)
and then
Tn(z) ≡cos(nθ)
(2.74)
The following two series are then equivalent under the transformation:
f(z) =
∞
X
n=0
an Tn(z)
(2.75)
f(cos θ) =
∞
X
n=0
an cos(nθ)
(2.76)
In other words, the coefﬁcients of f(z) as a Chebyshev series are identical with the Fourier
cosine coefﬁcients of f(cos(θ)).
FIRST IMPLICATION: EXPONENTIAL CHEBYSHEV CONVERGENCE for
NON-PERIODIC FUNCTIONS.
Even if f(z) itself is not periodic in z, the function f(cos θ) must inevitably be periodic
in θ with period 2π. As we vary θ over all real θ, the periodicity of cos(θ) implies that z (=
cos[θ]) merely oscillates between -1 to 1 as shown in Fig. 2.15. Since f(cos θ) is periodic, its
Fourier series must have exponential convergence unless f(z) is singular for z ∈[−1, 1]. It
does not matter if f(z) is periodic in z nor does it matter if f(z) has singularities for real z
outside the interval [-1, 1]. The Fourier cosine series in (2.76) sees f(cos θ) only as a periodic
function. For real θ, the Fourier series sees only those variations in f(z) that occur for
z ∈[−1, 1]. The exponential convergence of the Fourier series (2.76) then implies equally
fast convergence of the Chebyshev series since the sums are term–by–term identical.

2.11. CONVERGENCE THEORY: CHEBYSHEV POLYNOMIALS
47
−6
−4
−2
0
2
4
6
−1
−0.5
0
0.5
1
θ
z
Figure 2.15: The Chebyshev polynomials, Tn(z), are related to the terms of a Fourier co-
sine series through the identity Tn(cos[θ]) = cos( n θ). The graph shows the relationship
between z and θ, z = cos(θ).
SECOND IMPLICATION: the FOURIER EQUIVALENT of a CHEBYSHEV SERIES is a
FOURIER COSINE SERIES.
This is implicit in (2.76). Since cos(θ) is symmetric about θ = 0, f(cos θ) is forced to be
symmetric in θ, too, even if f(z) has no symmetry whatsoever with respect to z. Conse-
quently, we need only the cosines.1
THIRD IMPLICATION:
Theorem 6 (CHEBYSHEV TRUNCATION THEOREM) The error in approximating f(z) by
the sum of its ﬁrst N terms is bounded by the sum of the absolute values of all the neglected coefﬁ-
cients. If
fN(z) ≡
N
X
n=0
anTn(z)
(2.77)
then
ET (N) ≡| f(z) −fN(z) |≤
∞
X
n=N+1
| an |
(2.78)
for all f(z), all N, and all z ∈[−1, 1].
PROOF: The Chebyshev polynomials are bounded by one, that is, | Tn(z) | ≤1 for all z ∈
[−1, 1] & for all n. This implies that the n-th term is bounded by | an |. Subtracting the
truncated series from the inﬁnite series, bounding each term in the difference, and sum-
ming the bounds gives the theorem. Q. E. D.
The mapping alters the shape of the convergence region as described by the following.
1If f(z) does have symmetry, the basis can be further reduced. If f(z) = f(−z), then only the even cosines,
1, cos(2 θ), cos(4 θ), . . . , are needed. Similarly, only the odd cosines (or odd degree Chebyshev polynomials in z)
are needed if f(z) = −f(−z).

48
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
Theorem 7 (CONVERGENCE ELLIPSE: CHEBYSHEV SERIES) Let z = x + iy. Introduc-
ing the elliptical coordinates (µ, η) via the equations
x
=
cosh(µ) cos(η),
µ ∈[0, ∞]
y
=
−sinh(µ) sin(η),
η ∈[0, 2π],
(2.79)
the surfaces of constant µ deﬁne ellipses in the complex z-plane with foci at z = −1 and z = 1. (See
Fig. 2.16.) For large µ, elliptical coordinates tend to polar coordinates with µ proportional to log(r)
and η →−θ.)
Suppse f(z) has poles, branch points or other singularities at the points (in elliptical coordi-
nates) (µj, ηj), j = 1, 2, . . . in the complex z-plane. Deﬁne
µ0 ≡minj|µj|
(2.80)
Then the Chebyshev series
f(z) =
∞
X
n=0
anTn(z)
(2.81)
converges within the region bounded by the ellipse µ = µ0,
µ < µ0, for all η,
[convergence]
(2.82)
and diverges for all (x, y) outside this ellipse.
The coefﬁcients are related to µ0, the quasi-radial coordinate of the ellipse, by the equation
lim sup
n→∞log (| an/an+1 |) = µ0,
[if the limit exists]
(2.83)
Note: the “ellipse” µ = 0 is the real interval [-1, 1]. If the coefﬁcients an decrease algebraically
with n or if the convergence is exponential but subgeometric, then the Chebyshev series converges
only for µ = 0, i. e., only on the real interval z ∈[−1, 1].
PROOF: Let the complex variable θ = η + iµ. Now a trigonometric identity shows that
for any (µ, η),
cos(η + iµ) = cosh(µ) cos(η) −i sinh(µ) sin(η)
(2.84)
(Abramowitz and Stegun,1965). Thus, the transformation z = cos(θ) relates (x, y) to (µ, η)
just as deﬁned in (2.79). The straight lines which are the boundaries of the strip of Fourier
convergence in the complex θ-plane must be mapped into curves of constant µ in the z-
plane.
To show that µ = µ0 is indeed the equation of an ellipse, substitute Eq.(2.79) into
x2/a2 + y2/b2 = 1
[central equation of ellipse]
(2.85)
where the axes of the ellipse are a = cosh(µ0) and b = sinh(µ0). Cancelling the hyperbolic
functions reduces (2.85) to the identity cos2(η) + sin2(η) = 1. Q. E. D.
It is unusual to worry about imaginary values of z in applications, but since complex
singularities will limit the convergence of the series, we need to understand that a singu-
larity at one point on an ellipse will produce the same (asymptotic!) rate of convergence
as a pole or branch point on any other part of the same ellipse. This has two important
implications.
First, Fig. 2.16 shows that when µ is small, the ellipses of constant µ are long and narrow,
pass very close to z = ±1 and then cross the imaginary axis at much larger distances.

2.11. CONVERGENCE THEORY: CHEBYSHEV POLYNOMIALS
49
AAAAAA
AAAAAA
η=0
η=2 π
η=π/2
η=π
η=3 π/2
Figure 2.16: Elliptical coordinates (µ,
η) in the complex z-plane; z = x + i y via
x = cosh(µ) cos(η) & y = −sinh(µ) sin(η). which implies Tn(x + i y) = cos( n [η + i µ]) =
cosh(n µ) cos(n η) −i sinh(n µ) sin(n η). The surfaces of constant µ are ellipses; the
contours of constant “angle” η are hyperbolas. If a function f(z) has a pole or other singu-
larity anywhere on the ellipse µ = µ0 and no singularities on ellipses of smaller µ, then
the Chebyshev series of f(z) diverges everywhere outside the ellipse µ = µ0 and converges
everywhere inside this ellipse.
This implies that singularities very close to z = ±1 have no worse effect on convergence
than singularities on the imaginary axis that are much farther from the interval [-1, 1].
Chebyshev polynomials have a kind of inherent coordinate-stretching that makes them
much better at resolving singularities or boundary layers near the endpoints of [-1, 1] than
near the middle.
Second, Fig. 2.16 shows that singularities for real z will not destroy the property of
exponential convergence for the Chebyshev series as long as they lie outside the interval
[-1, 1]. Conversely, convergence on the “canonical interval”, even geometric convergence,
does not imply convergence for all real z, but no further than | z0 | where z0 is the location
of the nearest real singularity, and maybe not even that far if there are also poles or branch
points of f(z) for complex z.
If we know (or can estimate) the location of the convergence-limiting singularity, then
the following is very useful.
Theorem 8 ( CHEBYSHEV RATE of CONVERGENCE) The asymptotic rate of convergence
of a Chebyshev series for z ∈[−1, 1] is equal to µ, the quasi-radial coordinate of the ellipse of
convergence. This is related to the location of the convergence-limiting singularity at (x0, y0) in the
complex plane via
µ
=
Im{arccos[x0 + iy0]}
(2.86)
=
log | z0 ± (z2
0 −1)1/2 |
(2.87)
=
log
³
α +
p
α2 −1
´
(2.88)

50
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
where the sign in the second line is chosen to make the argument of the logarithm > 1 so that µ > 0
and where
α ≡1
2
q
(x0 + 1)2 + y2
0 + 1
2
q
(x0 −1)2 + y2
0
(2.89)
2.12
An Upper Bound on the Truncation Error: Last Coefﬁ-
cient Rule-of-Thumb
Theorem 9 (FOURIER TRUNCATION ERROR BOUND) Let
f(x) = a0 +
∞
X
n=1
an cos(nx) +
∞
X
n=1
bn sin(nx)
(2.90)
and let fN(x) be the approximation to f(x) which is obtained by truncating each of the series in
(2.90) after N terms:
fN(x) ≡a0 +
N
X
n=1
an cos(nx) +
N
X
n=1
bn sin(nx)
(2.91)
Then the truncation error deﬁned by
ET (N) ≡| f(x) −fN(x) |,
[“truncation error′′]
(2.92)
is bounded from above by the sum of the absolute values of all the neglected coefﬁcients:
EN(N) ≤
∞
X
n=N+1
| an | + | bn |
(2.93)
PROOF: Similar to the analogous Chebyshev result, Theorem 6.
Other basis functions satisfy similar theorems with slightly different numerical factors;
for Hermite functions, for example, we multiply the R. H. S. of (2.93) by 0.785.
This theorem is very powerful because it tells us that the coefﬁcients of the spectral
series are also (roughly) the errors, or at least an upper bound on the errors. It is also seem-
ingly quite useless because we normally do not know what all the neglected coefﬁcients
are, but let us look at a representative case.
EXAMPLE: For the “Symmetric, Imbricated-Lorentzian” function of the previous sec-
tion, the expansion is
f(x) = 1 + 2
∞
X
n=1
pn cos(nx)
(2.94)
The Truncation Error Bound Theorem then implies
| f(x) −fN(x) | ≤2
∞
X
n=N+1
pn = 2pN+1/(1 −p)
(2.95)
since the geometric series can be explicitly summed. Because the terms of (2.94) are all
positive at x = 0, Eq. (2.95) is a tight upper bound.

2.13. CONVERGENCE THEORY FOR LEGENDRE POLYNOMIALS
51
When computing the hitherto-unknown solution of a differential equation, we do not
know the exact form of the neglected coefﬁcients. However, we have already seen that
almost all Fourier and Chebyshev series for smooth, inﬁnitely differentiable functions con-
verge asymptotically like geometric series. In other words, it is the rule rather than the
exception that
an ∼[ ] pn,
n >> 1
(2.96)
where [ ] is a slowly varying (algebraic) function of n or a constant. This implies that while
we cannot get a numerical bound on the truncation error for unknown functions, we can
predict that they will behave qualitatively like the geometrically-converging Fourier series
(2.95).
The pay-off is the following assertion:
Rule-of-Thumb 2 (LAST COEFFICIENT ERROR ESTIMATE) The truncation error is the
same order-of-magnitude as the last COEFFICIENT RETAINED in the truncation for series with
geometric convergence. Since the truncation error is a quantity we can only estimate anyway (in
the absence of a known, exact solution), we can loosely speak of the last retained coefﬁcient as being
the truncation error, that is:
ET (N) ∼O(| aN |)
(2.97)
Extension: if the series has algebraic convergence index k, i. e., if an ∼O(1/nk) for large n,
then
ET (N) ∼O(N | aN | )
(2.98)
JUSTIFICATION: If we accept that a large class of Fourier and Chebyshev series con-
verge geometrically, then (2.97) follows immediately from (2.95). Note that the last re-
tained coefﬁcient is an = 2 pN, so that (2.97) is true with the proportionality constant
p/(1 −p) ∼O(1).
For algebraically converging series, note that
∞
X
n=N+1
1
nk ∼
1
(k −1)N k−1 ,
N >> 1
(2.99)
(Bender and Orszag, 1978, pg. 379.) Thus, the bound in the error truncation theorem is
O(1/N k−1) while the last retained coefﬁcient is O(1/N k), and this implies (2.98).
The ultimate test of a numerical solution is to repeat the calculation with different N
and compare results. The rule-of-thumb is not intended to substitute for that. Rather, it
has two uses. First, it provides a quick-and-dirty way of estimating the error from a single
calculation; if the last retained coefﬁcient is not small in comparison to the desired error,
then we need larger N. If it is small, and the lower coefﬁcients decrease smoothly towards
an, the calculation is probably okay. Second, it provides order-of-magnitude guidelines for
estimating the feasibility of a calculation. Without such guidelines, one would waste lots
of time by attempting problems which far exceed the available computing power.
2.13
Convergence Theory for Legendre Polynomials
When the computational domain is split into a large number of subdomains with a separate
spectral series on each subdomain, a popular strategy is to mimic the ﬁnite element method

52
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
10
0
10
1
10
2
10
0
10
1
Ratio
0
50
10
-10
10
-8
10
-6
10
-4
10
-2
10
0
Legendre
Chebyshev
Figure 2.17: Left: absolute values of the coefﬁcients of f(x; p) = 1/(1 −2 p x + p2)1/2.
Legendre coefﬁcients: upper curve. Chebyshev coefﬁcients: bottom curve. Right: the
solid curve is the ratio of the absolute value of the n-th Legendre coefﬁcient to the n-th
Chebyshev coefﬁcient. The dashed line is the n1/2.
with a so-called “weak” formulation. One crucial point is that the weak formulation is
greatly simpliﬁed by using a basis of Legendre polynomials instead of Chebyshev.
The good news is that the convergence theory for Legendre polynomials is virtually
identical with that of Chebyshev polynomials — indeed, it is identical if one ignores alge-
braic factors of n, as done so often above. The bad news is that for a given arbitrary function
f(x), the maximum pointwise error of a Legendre series (or interpolant), truncated after N
terms, is worse than that of the corresponding Chebyshev series by a factor of the square
root of N.
Theorem 10 ( LEGENDRE POLYNOMIAL RATE of CONVERGENCE)
• The domain of convergence for Legendre series is the interior of the largest ellipse, with foci
at ±1, which is free of singularities of the function being expanded. This domain is identical
with the domain of convergence of the Chebyshev series for the same function.
• The asymptotic rate of convergence µ of a Legendre series is identical with that of the corre-
sponding Chebyshev series, that is, it is the elliptical coordinate of the boundary of the domain
of convergence in the complex plane.
• In the asymptotic limit N →∞, the maximum pointwise error of a Legendre series is larger
than that of the Chebyshev series of the same order, also truncated after N terms, by O(N 1/2).
PROOF: The ﬁrst part is proved in Davis (1975). The convergence domain implicitly
speciﬁes the asymptotic rate of convergence. Fox and Parker (1968, pg. 17) prove an
asymptotic relation that suggests Legendre series are worse than Chebyshev by a factor
of
p
2/(π N).
An example is instructive. The function
1
p
1 −2 p x + p2 =
∞
X
n=0
pn Pn(x)
(2.100)

2.13. CONVERGENCE THEORY FOR LEGENDRE POLYNOMIALS
53
-1
-0.5
0
0.5
1
-0.5
0
0.5
1
Figure 2.18: Graph of P100(x), the Legendre polynomial of degree one hundred. It is also a
schematic illustrating the form of all Legendre polynomials: Oscillations over most of the
interval whose amplitude at a ﬁxed x is O(1/n1/2) plus narrow boundary layers near the
endpoints where the polynomial rises to ± 1.
has reciprocal-of-square root branch points in the complex plane which limit convergence.
The coefﬁcients of the Chebyshev series for this function are not known in closed form, but
it is known that they are asymptotically of the form
a(Chebyshev)
n
∼constant pn
√n,
n →∞
(2.101)
Fig 2.17 compares the Chebyshev and Legendre coefﬁcients for this function. The left panel
shows that both sets asymptote to parallel straight lines, but the Chebyshev coefﬁcients are
smaller. (Since Pn(1) = 1 and |Pn(x)| ≤1 for all n, just as for the Chebyshev polynomials,
these differences in coefﬁcients translate directly into differences in errors between the two
basis sets.) The right panel shows that the ratio of the coefﬁcients rapidly asymptotes to
p
(π/2)N.
Another way of stating the same thing is to inspect the Legendre polynomials them-
selves (Fig. 2.18). In contrast to the Chebyshev polynomials, which oscillate uniformly over
the interval x ∈[−1, 1] (as obvious from the relation Tn(cos(θ)) ≡cos(n θ)), the Legendre
polynomials are nonuniform with small amplitude over most of the interval except in ex-
tremely narrow boundary layers where the polynomial rises to one or falls to minus one.
The even polynomials have local maxima at both x = 1 and x = 0; the ratio of these is
ρn ≡|Pn(0)/Pn(1)| ∼
r
2
π n,
n even,
n →∞
(2.102)
There are two reasons why this nonuniformity and the poorer error of Legendre poly-
nomials are not particularly upsetting to practitioners of spectral elements. First, the de-
gree of the polynomials on each element is rather small, rarely greater than N = 8. Sec-
ond, Fig. 2.18 shows that the boundary layers where the Legendre polynomial is large are
very thin. For arbitrary functions, this is still an embarrassment. However, the solutions
to boundary value problems are constrained by the boundary conditions. For spectral ele-
ments, some constraint exists even on interior subdomain walls because the expansions in

54
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
each adjoining element must have common values on the common walls. Thus, spectral
element expansions in Legendre polynomials are constrained by matching and boundary
conditions to be close to the exact solution in precisely those regions where the errors in a
Legendre series would otherwise be large.
The Chebyshev-Legendre theory also applies to the larger family of Gegenbauer poly-
nomials. All members of the Gegenbauer family converge in the same ellipse-bounded
domain at the same asymptotic rate of convergence. However, for Gegenbauer polynomi-
als Cm
n (x), which are orthogonal with respect to the weight factor w(x) = (1−x2)m−1/2, the
maximum pointwise errors are worse than Chebyshev by a factor of O(nm) for sufﬁciently
large m. Legendre polynomials are the special case m = 1/2.
2.14
Quasi-Sinusoidal Rule of Thumb
It is easy to determine the cost of an accurate computation after the fact. (One can repeat
with different N to be sure the calculation is accurate.) In planning a computation, how-
ever, it is important to estimate in advance the approximate cost because this may determine
whether the computation is feasible.
Rule-of-Thumb 3 (TELLER’S LAW) A state-of-the-art calculation requires 100 hours of CPU
time on the state-of-the-art computer, independent of the decade.
The point of this maxim is that people push the current technology to the limit. This
will be as true in 2100 as it was in the time of Charles Babbage. However, there have always
been bureaucrats to put some limits on the enthusiasts (for which moderate users should
be grateful). Because of these constraints, one can get in enormous trouble if a proposed 20
hour calculation in fact requires 200.
There are several strategies for estimating costs a priori. One is library research: looking
up the costs and resolution of previously published calculations for similar problems.
A second strategy is the “Method of Model Functions”. One chooses a simple analytic
function which has the same behavior as is expected of the unknown solution — boundary
layers, fronts, oscillations, whatever. One can then expand this as a series of basis functions
by performing a matrix multiplication or FFT. If the model has the same scales of variation
as the true solution, then one can obtain a good estimate of how many basis functions will
be needed. The rate at which the model’s {an} decrease will be roughly the same as that of
the coefﬁcients of the unknown solution even though the individual numerical values will
be different.
A third strategy is to use rules-of-thumb.
The “quasi-sinusoidal” rule-of-thumb is based on the observation that a wide variety
of phenomena have oscillations. If we can estimate or guess the approximate wavelength
— strictly speaking, we should say local wavelength since the scale of oscillation may vary
from place to place — then we ought to be able to estimate how many Chebyshev polyno-
mials are needed to resolve it. Gottlieb and Orszag’s method of estimation is quite simple:
solve the partial differential equation
ut + ux = 0
x ∈[−1, 1]
(2.103)
with initial and boundary conditions such that the exact solution is a steadily translating
sine wave, and then compare different numerical methods.
Table 2.1 shows the results. The solution is
u(x, t) = sin[M π(x −t −1)]
(2.104)

2.14. QUASI-SINUSOIDAL RULE OF THUMB
55
Table 2.1: RMS (L2) errors in the solution of the one-dimensional wave equation. The exact
solution is u(x) = sin(M π[x −t −1]). There are a total of M wavelengths on the inter-
val [−1, 1]. N is the total number of grid points or Chebyshev polynomials. To achieve a
1% error, the second order method requires N/M > 40, the second order method needs
N/M > 15, while the spectral method needs N/M > 3.5. The Chebyshev-tau algorithm
was used here, but another graph in Gottlieb & Orszag (1977) shows that error is approx-
imately the same for Galerkin’s method and the pseudospectral method. The striking dif-
ferences are between the spectral methods and the ﬁnite difference methods, not between
different variants within the family of spectral algorithms.
SECOND ORDER
FOURTH ORDER
CHEBYSHEV
N
M
ERROR
N
M
ERROR
N
M
ERROR
40
2
0.1
20
2
0.04
16
4
0.08
80
2
0.03
30
2
0.008
20
4
0.001
160
2
0.008
40
2
0.002
28
8
0.2
40
4
1.
40
4
0.07
32
8
0.008
80
4
0.2
80
4
0.005
42
12
0.2
160
4
0.06
160
4
0.0003
46
12
0.02
so that M = total number of wavelengths on the interval [−1, 1]. For all the numerical
methods, N is the total number of degrees of freedom.
As might be expected, the accuracy does not depend on either N or M alone, but only
on their ratio
N
M ≡number of grid points
wavelengths
(2.105)
We ﬁnd
Rule-of-Thumb 4 (QUASI-SINUSOIDAL RESOLUTION REQUIREMENT)
To achieve 5% accuracy for a wave-like solution, one needs roughly
20 grid pts./wavelength
SECOND ORDER
FINITE DIFFERENCE
[40 pts/wave
for 1 % error]
10 grid pts./wavelength
FOURTH ORDER
FINITE DIFFERENCE
[15 pts/wave
for 1 % error]
3.5 polys./wavelength
CHEBYSHEV
PSEUDOSPECTRAL
[3.5 polys./wave
for 1 % error]
To estimate the number of wavelengths M, let △x be the smallest scale that one must resolve on
x ∈[−1, 1]. Then
M ≈
π
△x

56
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
0
2
4
6
8
10
10-10
10-8
10-6
10-4
10-2
100
N/M
M=1
M=5
M=20
M=100
π
Figure 2.19: The errors in the approximation of f(x) ≡2−1/2(cos(Mπx) + sin(Mπx)),
graphed versus N/M, that is, the number of Chebyshev polynomials retained in the trun-
cation divided by M, the number of wavelengths of f(x) on x ∈[−1, 1]. The dashed vertical
line is the asymptotic limit M →∞, which is at N/M = π.
This is but a rule-of-thumb — an unkind wit might deﬁne “rule-of-thumb” as a syn-
onym for “educated guess” — but it is representative of the extraordinary efﬁciency of
pseudospectral methods versus ﬁnite difference methods for large N. The rule-of-thumb
lists the needed resolution for 1% error to emphasize that the advantage of pseudospectral
over ﬁnite difference methods increases very rapidly as the error decreases, even for rather
moderate accuracy.
Fig. 2.19 shows the errors in the Chebyshev expansion of sin(M π x). There is almost no
accuracy at all until N/M > π, and then the error just falls off the table.
One must be a little careful in applying the rule when M and N are small. The reason is
that when we increase N by 1 or 2, we typically decrease the error (for a sine function) by
an order-of-magnitude whether N is 10 or 10,000. This increase of N (for the sake of more
accuracy) has a negligible effect on the ratio N/M when M is huge, but N/M must be
signiﬁcantly greater than 3 to obtain high accuracy when M is small. A more conservative
rule-of-thumb is to use
N = 6 + 4(M −1)
(2.106)
coefﬁcients, allocating 6 polynomials to resolve the ﬁrst wavelength and 4 for each addi-
tional wavelength.
2.15
Witch of Agnesi Rule–of–Thumb
Another caution is that sin(Mπx) is an entire function, free of singularities, whereas most
real-life solutions have poles or branch-points which determine the asymptotic rate of con-
vergence. For this reason, we will derive a second rule-of-thumb, which we call poeti-
cally the “Witch of Angesi” Rule-of-Thumb’ because it is derived by examing the analytical
Chebyshev coefﬁcients for the function known variously as the “Lorentzian” or the “Witch
of Agnesi”, which is
ϵ2
(x2 + ϵ2) =
∞
X
n=0
an Tn(x)
(2.107)

2.16. BOUNDARY LAYER RULE-OF-THUMB
57
where the odd coefﬁcients are zero by symmetry and where the even coefﬁcients are asymp-
totically
|an| ∼2 ϵ e−nϵ
n ≫1 & ϵ ≪1
(2.108)
For simplicity, assume ϵ is small. Bounding the error by the sum of all the neglected coef-
ﬁcients as in (2.95) shows that the error in truncating after aN is approximately |aN|/ϵ for
ϵ ≪1. If we demand the truncation error = 10−d so that d is the number of decimal places
of accuracy, then we obtain the following.
Rule-of-Thumb 5 (WITCH-OF-AGNESI RESOLUTION ESTIMATE)
If a function has an internal boundary layer of width 2 ϵ due to poles at x = ± i ϵ, then the value
of N needed to reduce the truncation error for that function to 10−d is roughly
N ≈
µd
ϵ
¶
log(10)
ϵ ≪1
(2.109)
What this rule-of-thumb asserts is that for more realistic functions — with singularities
— the slope of the error will asymptote to a straight line on a log/linear plot as shown in
Fig. 2.20 rather than diving more steeply off the bottom of the graph, as true for the entire
function sin(x).
By “width of the internal boundary layer”, we mean that the spoor of the complex
singularities is that the witch-of-Agnesi function rises from 1/2 to 1 and then falls to 1/2
again on the small interval [−ϵ, ϵ] as shown on the inset in Fig. 2.20. Presumably, some
small-scale features in hydrodynamic ﬂows (or whatever) are similarly associated with
poles or branch points for complex x close to the center of the feature.
A couple of caveats are in order. First, singularities a distance ϵ from the real axis are
most damaging to convergence when near the center of the interval. As one moves to
x = ±1, the pole becomes progressively less harmful until N becomes a function of 1/√ϵ
— not 1/ϵ — in the immediate neighborhood of the endpoints. This special endpoint effect
is described in the next section, but it signiﬁcantly modiﬁes (2.109) only when the branch
point or pole is quite close to x = ±1. (Observe the equiconvergence ellipses in Fig. 2.16;
the innermost curves (small ϵ) are very eccentric and approximately parallel the real axis
except in the small, semi-circular caps around ±1.)
Second caveat: Eq.(2.108) should be multiplied by a factor of nk when the singularities
are other than simple poles where k = 1 for a second order pole (stronger singularity) and
k = −1 for a logarithm (weaker singularity, the integral of a simple pole). In this case, one
can show that N(d, ϵ) should be determined from the more complex rule
N ϵ + k log(N) ≈d log(10)
(2.110)
Often, however, especially when d is large, the logarithm of N may be neglected. Usually
the simpler rule is best because one rarely knows the precise type or location of a complex
singularity of the solution to a differential equation; one merely estimates a scale, ϵ.
2.16
Boundary Layer Rule-of-Thumb
Viscous ﬂows have boundary layers next to solid surfaces where the tangential velocity
is reduced to zero. When the boundary layer is of width ϵ where ϵ ≪1, it is normally
necessary to increase the number of grid points as O(1/ϵ) as ϵ →0. This is extremely
expensive for high Reynolds number ﬂows.

58
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
0
5
10
15
10-15
10
-10
10-5
100
N ε / log(10)
-0.5
0
0.5
1
0
0.2
0.4
0.6
0.8
1
2ε
Figure 2.20: Witch-of-Agnesi Rule-of-Thumb. This predicts that if a function has a peak in
the interior of the interval of width 2ϵ due to singularities at ℑ(x) = ϵ, then the error will be
10d where d = N ϵ/log(10). The errors in the Chebyshev approximation of f(x) ≡ϵ2/(x2 +
ϵ2) is plotted versus N ϵ/ log(10), i. e., against the expected number of decimal digits in
the error for ϵ varying from 1 (circles) to 1/100. As predicted, the curves lie approximately
on top of one another (with some deviation for ϵ = 1. When N ϵ/ log(10) ≈15, the error
is indeed O(10−15). The inset graph illustrates the “Witch of Agnesi” function itself along
with the meaning of the width parameter ϵ.
A much better approach is to use a mapping, that is, a change of variable of the form
y = f(x)
(2.111)
where y is the original, unmapped coordinate and x is the new coordinate. Unfortunately,
there are limits: If the mapping varies too rapidly with x, it will itself introduce sharp
gradients in the solution, and this will only aggravate the problem. However, the higher
the order of the method, the more rapidly the transformation may vary near the bound-
ary. Orszag and Israeli (1974) assert (without giving a proof) that with an “optimal map-
ping”, this change-of-coordinates trick can reduce the error (for a given total number of
grid points) by O(ϵ2) for a second order method and O(ϵ4) for a fourth order scheme.
One effective mapping for the most common case — boundary layers near the end-
points — was employed by Kalnay de Rivas(1972) who used
y = cos(x)
(2.112)
for a “physical” coordinate y ∈[−1, 1]. This is precisely the change-of-variable that con-
verts a Chebyshev series in y into a Fourier series in x. It follows that her evenly spaced
grid in x is the same grid that we would use with an un-mapped Chebyshev series in y. To
put it another way, the uneven grid in y that is sometimes such a burden with Chebyshev
methods, particularly for time-integration schemes, is in fact just what we need to resolve
boundary layers.

2.16. BOUNDARY LAYER RULE-OF-THUMB
59
0
1
2
3
4
5
10-3
10-2
10-1
10
0
0.97 0.98 0.99
1
0.2
0.4
0.6
0.8
1
ε
Ν ε
Figure 2.21: Boundary Layer Rule-of-Thumb. The errors in the approximation of f(x) =
tanh([x −1]/ϵ) are plotted versus Nscaled ≡N ϵ1/2 for ϵ = 1 (lower circles), ϵ = 1/10 (as-
terisks), ϵ = 1/100 (plus signs), ϵ = 1/1000 (x’s) and ϵ = 1/10000 (upper circles). Except for
ϵ = 1, which is offset a little below the others, the curves for different ϵ are superimposed
one atop another. Regardless of the thickness ϵ of the boundary layer, when Nscaled ≥3,
that is, when the number N of Chebyshev polynomials is greater than 3/ϵ1/2, the approx-
imation has at least moderate (1%) accuracy. The inset shows f(x) = tanh((x −1)/ϵ) for
ϵ = 1/100, together with the grid points (circles) for Nscaled = 3, i. e., N = 30. As long
as there are a couple of grid points in the boundary layer, the Chebyshev approximation is
okay.
Rule-of-Thumb 6 (BOUNDARY LAYER RESOLUTION REQUIREMENT)
To resolve a boundary layer of width ϵ at y = ±1 (as opposed to an internal boundary layer,
such as a front), one should use approximately
N = 3
√ϵ polynomials
ϵ ≪1
(2.113)
to obtain a moderate accuracy of O(1 %).
Source: Orszag & Israeli (1974).
This rule-of-thumb, like all such empirical principles, must always be applied with cau-
tion. (See Fig. 2.21.) It is interesting, however, that it agrees exactly with Kalnay’s (1972)
rule-of-thumb for her second order ﬁnite difference method, even to the numerical factor
of 3, although hers was expressed in terms of grid points rather than polynomials.
The reason that N is proportional to the square root of 1/ϵ, instead of 1/ϵ itself, is that
the Chebyshev polynomials have a “built-in” variable stretching which is “quadratic” in
the sense that the interior grid points closest to the boundary are only O(1/N 2) away from
the endpoint [rather than O(1/N) as for an evenly spaced grid]. This is easily proved by
recalling that the Chebyshev grid is the map of an evenly spaced grid in x via y = cos x,
and then using the Taylor expansion of the cosine near x = 0, π.

60
CHAPTER 2. CHEBYSHEV & FOURIER SERIES
The conclusion is that with Chebyshev polynomials and Fourier series, the best way
to deal with boundary layers may well be to do nothing! (When Fourier series are used,
the boundary condition is spatial periodicity; a periodic interval is equivalent to a ring-
shaped interval without boundaries or boundary layers.) For some problems, however, the
natural, quadratic boundary layer stretching which is, as it were, “built-in” to Chebyshev
methods may not be optimum. Then, an additional mapping may be helpful.
For boundary value and eigenvalue problems, it follows that boundary layers are not
a major problem. For time-dependent problems, alas, they are a serious complication be-
cause the narrow grid spacing near the wall implies that a very small time step is needed
with an explicit time-differencing scheme. This is not a problem peculiar to spectral meth-
ods, however; Kalnay’s ﬁnite difference scheme was subject to exactly the same restrictions
as a Chebyshev method, and for the same reason.
Thus, boundary layers pose no special problems for spectral methods.
Rather, the
Chebyshev grid is unfortunate only when boundary layers are not present. With Cheby-
shev polynomials, the high density of grid points near the walls requires either a very
small timestep or an implicit time integration even when there is no physical reason for
high resolution near the endpoints.
Table 2.2: Relationships Between Singularities and Asymptotic Spectral Coefﬁcients.
Note:
all
rows
apply
to
Fourier
series
as
well
as
Chebyshev
and
Legen-
dre polynomials except where marked by (*), which exclude trigonometric series.
Form of singularity
Type of singularity
Asymptotic form
spectral coefﬁcients
1/(x −a)
Simple pole
[ ]pn
1/(x −a)2
Double pole
[ ]n pn
log(x −a)
Logarithm
[ ]n−1 pn
1/√x −a
Reciprocal of square root
[ ]n−1/2 pn
(x −a)1/3
Cube root
[ ]pn/n4/3
exp(−q/|x|)
Inﬁnitely differentiable but
[ ] exp(−p n1/2)
singular at x = 0
xψ
Branch point within [-1,1]
[ ] 1/nψ+1
f(x) = sign(x)
Jump discontinuity
[ ] /n
df/dx = sign(x)
Discontinuous ﬁrst derivative
[ ] /n2
(assuming f continuous)
(1 −x)ψ
Branch point at endpoint
[ ] 1/n2 ψ+1 *
exp(−q/|x + 1|)
Inﬁnitely differentiable but
[ ] exp(−p n2/3)
singular at endpoint

Chapter 3
Galerkin Method, the Mean
Weighted Residual Method &
Inner Products
“Six months in the lab can save you a day in the library.”
Albert Migliori, quoted by J. Maynard in Physics Today 49, 27 (1996)
3.1
Mean Weighted Residual Methods
One difference between algorithms is the “error distribution” principle, that is, the means
of making the residual function R(x; a0, a1, . . . , aN) small where
R(x; a0, a1, . . . , aN) ≡HuN −f
(3.1)
where H is the differential or integral operator and uN(x) is the approximation
uN ≡
N
X
n=0
an φn(x)
(3.2)
for some suitable basis functions φn(x).
Finlayson (1973) has pointed out that most methods of minimizing R(x; {an}) can be
lumped into a common framework as the “method of mean weighted residuals” (MWR).
If the φn(x) already satisfy the boundary conditions, MWR determines the spectral coefﬁ-
cients an by imposing the (N + 1) conditions
(wi, R[x; a0, a1, . . . , aN]) = 0,
i = 0, 1, . . . , N
(3.3)
for some suitable “test functions” wi(x) where the “inner product” is deﬁned by
(u, v) ≡
Z b
a
ω(x)dx u(x) v(x)
(3.4)
61

62
CHAPTER 3. GALERKIN & WEIGHTED RESIDUAL METHODS
for a given non-negative weight function ω(x) and any two functions u(x) and v(x).
Four choices of test functions are popular.
PSEUDOSPECTRAL alias COLLOCATION alias METHOD OF SELECTED POINTS:
wi(x) ≡δ(x −xi)
(3.5)
where the xi are some suitable set of “interpolation” or“collocation” points [the two terms
are used interchangeably] and where δ(x) is the Dirac delta-function. Computationally,
one would impose the condition that
R(xi; a0, a1, . . . , aN) = 0,
i = 1, . . . , N
(3.6)
for each collocation point.
METHOD OF MOMENTS:
wi(x) ≡xi,
i = 0, 1, . . . , N
(3.7)
The reason for the name is that (xi, f(x)) is said to be, in statistics, the “i-th moment” of
f(x).
This technique has been very popular in engineering. It works well if a small number of
terms ( say N = 2 or 3) is used. Unfortunately, the method of moments is almost invariably
a disaster if N is large. The difﬁculty is that high powers of x become linearly dependent
due to round-off error. For this reason, the powers of x are unsuitable as basis functions.
For example, ﬁtting a polynomial to a function will fail when N is greater than 6 if the poly-
nomial is expressed as powers of x. The matrix of this least-squares problem, the infamous
“Hilbert matrix”, is a popular test for matrix software because it maximizes the effect of
round-off! The method of moments generates matrices that are just as ill-conditioned.
The method of moments works well if (i) N is very small or (ii) calculations are per-
formed in exact rational arithmetic using a symbolic manipulation language like Maple or
Mathematica. Otherwise, the best way to avoid disastrous accumulation of roundoff error
is reject the method of moments. Instead, use Chebyshev or Legendre polynomials as the
“test” and basis functions.
LEAST SQUARES:
If H is a linear operator, then
wi(x) ≡Hφi(x)
(3.8)
The reason for the name is that one can show that this minimizes the “norm” of the residual
where the norm is deﬁned by
||R|| ≡
p
(R, R)
(3.9)
In other words, “least squares” determines the coefﬁcients a0, a1, . . . , aN in such a way
that the inner product of R(x; a0, a1, . . . , aN) with itself is made as small as possible for the
class of functions deﬁned by an (N + 1)-term spectral series. The mathematical statement
of this is
(R, R) ≤(Hv −f, Hv −f) for all v(x) of the form
(3.10)

3.1. MEAN WEIGHTED RESIDUAL METHODS
63
v(x) =
N
X
n=0
dnφn(x)
for
some
{dn}
(3.11)
It is possible to make (R, R) smaller only by using more terms in the series, not by using
different numerical values of the (N + 1) coefﬁcients.
If the basis functions have the property of completeness — i. e., if we can approximate
the exact solution u(x) to arbitrarily high accuracy by using a sufﬁciently large number of
terms in the spectral series, then the “least squares” method is guaranteed to work.
One great advantage of “least-squares” is that it always generates symmetric matrices
even if the operator H lacks the property of “self-adjointness”. This is helpful in three
ways. First, it greatly simpliﬁes the theoretical numerical analysis. Second, symmetric
matrix problems can be solved by a variety of special tricks which are faster and use less
storage than the algorithms for non-symmetric matrices. Third, symmetric matrices are
more stable in time-marching schemes.
It is possible to generalize the “least squares” method to nonlinear problems by deﬁning
wi(x) ≡∂R/∂ai,
i = 0, 1, . . . , N
(3.12)
which includes (3.8) as a special case.
Despite its many virtues, the “least squares” method is relatively uncommon.
For
self-adjoint problems — and this includes all of quantum physics and chemistry, for ex-
ample — the Galerkin method is simpler and has the same virtues: Minimum norm of
the residual and a symmetric matrix. Nonlinear problems are usually solved by colloca-
tion/pseudospectral methods because “least squares” gives a very unwieldy set of alge-
braic equations.
However, the least squares method is still the safest way of generating approximations
that depend nonlinearly on the unknowns.
Galerkin METHOD:
wi(x) ≡φi(x)
(3.13)
This choice of test function is successful because any well-chosen set of basis functions
φn(x) will have all the properties desired of weighting functions, too, including linear in-
dependence and completeness. (We will take up the properties of basis sets in the next two
sections.)
There are many workable choices of “test functions” wi(x) besides the four described
here. This book, however, will concentrate on the Galerkin method and the pseudospec-
tral/collocation algorithm.
One should also brieﬂy note that terminology is not too well standardized. In this
book, “collocation” is a synonym for “pseudospectral”. However, the former term is also
used for a class of ﬁnite element methods whereas “pseudospectral” is applied only when
collocation is used with a basis of global (Fourier, Chebyshev . . . ) rather than local (tent,
pyramid, splines . . . ) functions.
In addition, some authors such as Birkhoff and Lynch (1984) and Strang and Fix (1973)
use “Rayleigh–Ritz” as a synonym for what we have called “Galerkin” and “Galerkin”
as a synonym for “mean weighted residual”. Finlayson’s terminology is preferable since
“mean weighted residual” is descriptive in a way that a surname is not.
When the test functions differ from the basis functions, the label “Petrov-Galerkin” is
common.
In addition, some authors like Canuto et al. (1988) restrict “Galerkin” to basis sets that
individually satisfy the boundary conditions while using “tau-method” when φi(x) is a

64
CHAPTER 3. GALERKIN & WEIGHTED RESIDUAL METHODS
Chebyshev polynomial. Our reasons for avoiding this usage are partly historical and partly
pragmatic. The historical reason is given in Chapter 21. The pragmatic reason is that for
some problems, such as those with differential equations which are singular at the end-
points, Chebyshev polynomials do satisfy the boundary conditions. Thus, a tau-method
sometimes is a Galerkin method, too. We shall therefore avoid the label “tau–method” and
use “Galerkin” to refer to any method which uses basis functions, either before or after
modiﬁcations, as the “test” functions.
3.2
Completeness and Boundary Conditions
Useful sets of basis functions have a number of properties. First, they must be easy to
compute. Trigonometric functions and polynomials both certainly meet this criterion.
A second requirement is completeness. This means that the basis functions must be suf-
ﬁcient to represent all functions in the class we are interested in with arbitrarily high accu-
racy. A rigorous completeness proof is too complicated to discuss here. However, all the
basis functions in this book — Fourier series, Chebyshev polynomials, Hermite functions,
spherical harmonics and so on — do have the property of completeness.
When explicitly imposing boundary conditions, however, it is possible — indeed, very
useful — to use a basis set which is incomplete for arbitrary functions. For instance, suppose
the boundary conditions are homogeneous such as:
u(−1) = u(1) = 0
(3.14)
We have two options: (i) impose the constraint on the basis functions by adding two rows
to the matrix problem we solve for the an:
∞
X
n=0
anTn(±1) = 0
(3.15)
or (ii) choose basis functions that independently satisfy the boundary conditions.
EXAMPLE: Chebyshev basis functions that vanish at the endpoints
The set of functions deﬁned by
φ2n(x) ≡T2n −T0;
φ2n+1(x) ≡T2n+1(x) −T1,
n ≥1
(3.16)
have the property
φn(±1) = 0,
for all n
(3.17)
as can be proved by converting the Chebyshev polynomials in (3.16) into the corresponding
cosines and evaluating at θ = 0, π, which correspond to x = 1, −1.
This basis set omits two degrees of freedom since T0 and T1(x) are no longer inde-
pendent, but instead appear only in combination with Chebyshev polynomials of higher
degree. However, u(x) is not arbitrary either; it must satisfy the two boundary conditions.
Therefore, the basis functions deﬁned by (3.16) are complete for the most general function
u(x) that satisﬁes the boundary conditions (3.14).
Warning: a common programming error is to set up a test problem whose solution does
not have homogeneous boundary conditions. If the basis vanishes at the endpoints and the
target function u(x) does not, then the coefﬁcients are meaningless, oscillatory, and rather
large even in the N-th coefﬁcient.
This device of taking linear combinations of Chebyshev polynomials (or something
else) is extremely useful with homogeneous boundary conditions. We no longer have to

3.3. INNER PRODUCT & ORTHOGONALITY
65
complicate the programming by using two rows of our matrix equation for boundary con-
ditions; now, all the rows of the matrix come from minimizing the residual R(x; an).
Another advantage of basis recombination, noted ﬁrst by W. Heinrichs, is that the re-
combined basis functions are better conditioned than the Chebyshev polynomials them-
selves. That is to say, accumulated roundoff error is much lower with basis recombination,
especially when solving high order differential equations. A full explanation is deferred
until a later chapter. The short explanation is that high order derivatives of Chebyshev
(and Legendre) polynomials grow rapidly as the endpoints are approached. The mismatch
between the large values of the derivatives near x = ±1 and the small values near the
origin can lead to poorly conditioned matrices and accumulation of roundoff error. Basis
recombination greatly reduces this because the basis functions are tending rapidly to zero
near x = ±1, precisely where the polynomials (and their derivatives) are oscillating most
wildly. (However, the ill-conditioning of an uncombined basis is usually not a problem
unless N ∼100 or the differential equation has third or higher derivatives.)
3.3
Properties of Basis Functions: Inner Product & Orthog-
onality
Deﬁnition 12 (INNER PRODUCT) Let f(x) and g(x) be arbitrary functions. Then the inner
product of f(x) with g(x) with respect to the weight function ω(x) on the interval [a, b] is deﬁned
by
(f, g) ≡
Z b
a
f(x)g(x)ω(x)dx
(3.18)
Deﬁnition 13 (ORTHOGONALITY) A set of basis functions φn(x) is said to be ORTHOGO-
NAL with respect to a given inner product if
(φm, φn) = δmn ν2
n
(3.19)
where δmn is the “Kronecker delta function” deﬁned by
δmn =



1,
m = n
0,
m ̸= n
[Kronecker δ −function]
(3.20)
and where the constants νn are called “normalization constants”.
The great virtue of orthogonality is that it gives a procedure for computing the spectral
coefﬁcients. Let the expansion be
f(x) =
∞
X
n=0
anφn(x)
(3.21)
The inner product of both sides with the m-th basis function is
(f, φm) =
∞
X
n=0
an(φm, φn)
(3.22)
However, if (and only if) the basis functions are orthogonal, all of the inner products are
zero except the single term n = m. This proves the following.

66
CHAPTER 3. GALERKIN & WEIGHTED RESIDUAL METHODS
Theorem 11 (INNER PRODUCT for SPECTRAL COEFFICIENTS) If a function f(x) is ex-
panded as a series of orthogonal functions,
f(x) ≡
N
X
n=0
anφn(x)
(3.23)
then for arbitrary N,
an = (φn, f)/(φn, φn)
∀n
(3.24)
It is sometimes convenient to eliminate the “normalization constants” νn ≡
p
(φn, φn)
by rescaling the basis functions by deﬁning
φN(x) ≡φn(x)/νn
(3.25)
Deﬁnition 14 (ORTHONORMAL) A basis set is said to be ORTHONORMAL if the basis func-
tions have been rescaled so that
(φn, φn) = 1
(3.26)
This implies that the coefﬁcients of an arbitrary function f(x) are simply
an = (φn, f)
(3.27)
The property of orthonormality, as opposed to mere orthogonality, is much more use-
ful for some basis functions than for others. Since the normalization factor is 1/√π for all
Fourier and Chebyshev terms (except the constant), it is usually not worth the bother to
“normalize” these basis sets. The simplest deﬁnition of Hermite functions (integer coef-
ﬁcients) unfortunately leads to normalization factors which grow wildly with n, so it is
quite helpful to use orthonormalized Hermite functions. (“Wildly” is not an exaggeration;
I have sometimes had overﬂow problems with unnormalized Hermite functions!) From a
theoretical standpoint, it does not matter in the least whether the basis is orthonormal or
not so long as one is consistent.
Orthogonality, however, is always useful. It seems so special that one might think it
hard to obtain orthogonal sets of functions, but in fact it is quite easy. All the sets which
we shall use are the eigenfunctions of a class of eigenvalue equations known as “Sturm-
Liouville” problems. These two 19th century mathematicians proved that all problems of
this class generate complete, orthogonal basis sets.
Alternatively, we can choose a set of arbitrary functions. By applying a simple recursive
procedure called “Gram-Schmidt” orthogonalization, which is discussed in most linear al-
gebra texts, one can systematically ﬁnd linear combinations of the chosen functions which
are mutually orthogonal. For example, the new basis functions deﬁned by (3.16) are not or-
thogonal, but can be made so by the Gram-Schmidt process. The orthogonal polynomials
in this book — Chebyshev, Legendre, Hermite, and so on — can be described as the re-
sult of Gram-Schmidt orthogonalization of the set of powers of x, {1, x, x2, . . . }, on various
intervals with various weight functions.
Since the properties of Sturm-Liouville eigenfunctions are not important in applica-
tions, the theoretical details will be left to Morse and Feshbach(1953) and Carrier and
Pearson (1968). However, Sturm-Liouville theory is of enormous conceptual importance
because it is a general way of obtaining basis functions that are both complete and orthogo-
nal. Furthermore, the Sturm-Liouville methodology supplies the weight function ω(x) and
the interval [a, b] for each basis set as summarized in Appendix A.

3.4. GALERKIN METHOD
67
One ﬁnal comment on orthogonality: as noted earlier, it is important that the basis
functions be as different as possible; adding terms that can be closely approximated by a
sum of the other basis functions is a waste of time. Obviously, two functions that are very
similar will not be orthogonal, but instead will have an inner product little different from
the inner product of either one with itself.
Orthogonality guarantees that a set of basis functions will be as different from one an-
other as possible; it is a sort of maximization of linear independence.
3.4
Galerkin Method
The residual function R(x; a0, a1, . . . , aN) can be expanded as a series of basis functions
like any other function of x,
R(x; a0, a1, . . . , aN) =
∞
X
n=0
rn(a0, a1, . . . , aN) φn(x)
(3.28)
where the coefﬁcients are given by the usual inner product
rn = (R, φn)
(3.29)
The Galerkin method employs the “error distribution principle” that R(x) should be small
in the sense that the ﬁrst (N + 1) terms of its spectral series are 0. The Fourier and Cheby-
shev series of smooth functions decrease exponentially fast with n, so all the rn for n > N
will presumably be very, very tiny if N is large enough. Thus, forcing the lower degree rn
to be 0 should make R(x) very, very small over the whole interval. In the limit that N →∞,
R(x) must →0 and therefore the approximation must converge exponentially fast to the
exact solution.
This strategy is identical to the Galerkin method as previously deﬁned since the “weighted
residual” conditions (φn, R) = 0 are the same as
rn = 0,
n = 0, 1, 2, . . . , N
[Galerkin
method]
(3.30)
in virtue of (3.29).
Because the weighting functions are a complete set, (3.30) must force R(x) →0 as N →
∞. In contrast to the “method of moments”, Galerkin’s method is a very robust algorithm;
the “test” functions are orthogonal, and therefore are highly linearly independent.
When the basis set is not complete for arbitrary functions, but rather is restricted to ba-
sis functions that satisfy homogeneous boundary conditions, one might wonder whether
it is legitimate to limit the “test functions” to these modiﬁed basis functions, such as the
set deﬁned by (3.16). The answer is yes. The reason is that, at least in the limit N →∞,
the residual function R(x) is converging towards the trivial function f(x) ≡0. Since this
limiting function and all its derivatives vanish at the endpoints (and everywhere else!), it
follows that f(x) ≡0 must satisfy any and all reasonable homogeneous boundary condi-
tions that we may have imposed upon the basis functions. Thus, any set of basis functions
that are complete for u(x)will also be complete for the residual function R(x).
For simplicity, we assume here and in the next section that the operator H is a linear
operator. (This is not as restrictive as it might seem as explained in Appendix C.) In that
case, the Galerkin conditions can be expressed in the form of a matrix equation. Let ⃗⃗H
denote an (N + 1) × (N + 1) square matrix whose elements are given by (3.31), ⃗f be the

68
CHAPTER 3. GALERKIN & WEIGHTED RESIDUAL METHODS
column matrix whose elements are given by (3.32), and ⃗a be the column vector whose
elements are the (N + 1) spectral coefﬁcients:
Hij = (φi, Hφj)
i, j = 1, 2, . . . , (N + 1)
(3.31)
fi = (φi, f)
i = 1, 2, . . . , (N + 1)
(3.32)
Then the spectral coefﬁcients an are the solution of the matrix equation
⃗⃗H
⃗a = ⃗f
[Galerkin
method]
(3.33)
The i-th row of (3.33) is the inner product of φi(x) with the residual function
R(x; a0, a1, . . . , aN) ≡−f(x) +
N
X
j=0
ajHφj
(3.34)
If the basis functions do not individually satisfy the boundary conditions, then it is neces-
sary to replace some of the rows of (3.33) by equations that express the boundary condtions.
The endproduct is still a matrix equation like (3.33).
The ﬁnal step is to solve (3.33) via standard linear algebra libraries such as LINPACK
and EISPACK. The user’s chore is simply to (i) calculate the matrix elements in (3.31) and
(3.32) and (ii) evaluate uN(x) by summing the spectral series. It’s that simple.
3.5
Weak & Strong Forms of Differential Equations: the Use-
fulness of Integration-by-Parts
The “strong” form of a differential equation is the one we all learned as undergraduates: a
relationship between derivatives that applies at each point on an interval, for example
uxx −q(x)u = −f(x)
(3.35)
In the mathematical and numerical literature, there are frequent references to the “weak”
form, which is based on the Galerkin method.
For simplicity, assume that the differential equation is subject to homogeneous Dirichlet
boundary conditions. (Quite general boundary conditions can be used without altering
what follows.) Then the “weak” form of Eq.( 3.35) is: For all “test” functions v(x) in the
appropriate Sobolev space, the solution of the “weak” form of the differential equation is
that function u(x) such
(v, uxx −q(x)u) = −(v, f)
(3.36)
where the parentheses denote the usual integral inner product. “Appropriate” means that
the test functions must satisfy the boundary conditions.
The weak form is merely Galerkin’s method. In practical applications, the Sobolev
space would be restricted to polynomials up to and including degree N for both the test
functions and the solution.
The usefulness of the weak form arises from a trick: Integration-by-parts. If we multiply
by (-1), the weak form can be rewritten without approximation as
(vx, ux) −{v(b)ux(b) −v(a)ux(a)} + (v, qu) = (v, f)
(3.37)

3.5. INTEGRATION-BY-PARTS
69
where x ∈[a, b]. Because the “test” functions v(x) satisfy the homogeneous boundary
conditions, the endpoint terms in the braces are zero, simplifying the “weak” form to
(vx, ux) + (v, qu) = (v, f)
(3.38)
The reason that this is useful is that although the original differential equation (in its
“strong” form) is second order, through integration-by-parts we have found an equivalent
statement which involves only ﬁrst derivatives. This has several beneﬁts.
First, the “weak” form is meaningful even for problems with shock waves or other
pathologies. As long as the ﬁrst derivative is integrable, even if it has a discontinuity at
some point on the interval, the “weak” form is well-deﬁned.
Second, the weak form widens the choice of basis functions. To solve the strong form
through collocation or the Galerkin method, we need basis functions that have non-zero
second derivatives, so piecewise-linear functions are excluded. Nevertheless, piecewise
linear or “tent” functions are very widely used in ﬁnite elements and give second order
accuracy. “Tent” functions are possible only with the weak form.
The high-brow way of saying this is to assert that the appropriate Sobolev space is
H1
0. The subscript “0” means that the elements of the Sobolev space satisfy homogeneous
Dirichlet boundary conditions, that is, v(a) = v(b) for all test and basis functions. The
superscript “1” means that the ﬁrst derivatives of the functions in the space must be in the
space L2, that is, the square of vx must be integrable on the interval x ∈[a, b].
The third advantage is important only in multiple dimensions. To solve a problem on
an irregularly-shaped domain, one must make a change of coordinates to map the domain
from the physical coordinates (x, y) to a square domain in the computational coordinates
(r, s). One can then expand the solution in a “tensor product” basis, i. e., in basis functions
of the form Tm(r)Tn(s). Unfortunately, the change of coordinates alters the coefﬁcients of
the differential equation by inserting “metric factors” that depend on the mapping. The
transformation of ﬁrst derivatives is messy but not too bad. The transformation of second
derivatives is very messy. (Appendix E, Sec. 9.) The transformation of third and fourth
derivatives — the programmer shudders and turns away in horror.
The weak form, however, needs only ﬁrst derivatives even though the original differ-
ential equation is of second order. Similarly, a fourth order differential equation can be
represented in the weak form using no derivatives higher than second order. With the
weak form, it is no longer necessary to drown under a ﬂashﬂood of the metric factors of
high order derivatives.
This is important not only for preserving the sanity of the programmer. Complicated
metric factors also greatly increase the operation count and slow the computations.
The fourth advantage is that if the Sobolev space is restricted to the span of a ﬁnite
number N of linearly independent basis functions, the Galerkin matrix for the weak form
is automatically symmetric:
Hij = (φx,i, φx,j) + (φi, q(x)φj)
(3.39)
Because the test functions and basis functions both enter as the ﬁrst derivative, interchang-
ing the indices i, j does not change the numerical value of the Galerkin matrix for the weak
form.
The symmetry of the Galerkin matrix for the weak form has some important implica-
tions. First, it explains the relative unpopularity of the least squares method, which also
generates symmetric matrices. The Galerkin weak form is also symmetric but much sim-
pler.
Second, symmetric matrices can be solved by special methods which are much cheaper
than the more general algorithms that must be used for nonsymmetric matrices. For ex-

70
CHAPTER 3. GALERKIN & WEIGHTED RESIDUAL METHODS
ample, a matrix equation with a symmetric matrix can be solved by a “Cholesky” decom-
position (Appendix B), which requires only half the ﬂoating point operations and half the
memory storage of an LU factorization.
If the matrix equation is solved by an iterative scheme, one can use the “conjugate gra-
dient” method if the matrix is symmetric. Its unsymmetric counterpart is the “biconjugate
gradient” method which is roughly twice as expensive per step in both operations and
storage, and also more likely to converge very slowly or fail.
Matrix symmetry requires that the differential equation should be “self-adjoint”. For-
tunately, this is true of many important physical problems.
Lastly, the weak form can be connected with the calculus of variations to justify some
unconventional (but cheap and efﬁcient) schemes for patching solutions on separate sub-
domains together. Consequently, the spectral element method, which is the most popular
scheme for applying spectral methods with domain decomposition, almost always is based
on the “weak” form rather than collocation.
It turns out, however, that the integrals of the weak form are usually approximated
by a Gaussian quadrature scheme which is very closely related to interpolation and the
pseudospectral method as explained in the next chapter.
3.6
Galerkin Method: Case Studies
EXAMPLE ONE:
uxx −(1/2)u = −(3/2) cos(x) −(9/2) cos(2x)
(3.40)
with periodic boundary conditions. This is in the form Hu = f with
H ≡∂xx −(1/2);
f(x) = −(3/2) cos(x) −(9/2) cos(2x)
(3.41)
Since the boundary conditions are periodic, Fourier functions are the obvious basis
set. We assert without proof that a Fourier cosine series (without the constant) is sufﬁ-
cient for this problem; note that only cosines appear on the R. H. S. [A full discussion is
given in Chap. 8 on parity and symmetry.] The matrix equivalent of (3.41) with the basis
cos(x), cos(2x) is
(cos[x], H cos[x])
(cos[x], H cos[2 x])
a1
(cos[x], f)
=
(cos[2x], H cos[x])
(cos[2x], H cos[2 x])
a2
(cos[2 x], f)
where
(g, h) ≡
Z π
−π
dx g(x) h(x)
(3.42)
for any two functions g(x) and h(x).
To evaluate the matrix elements, note that
H cos(nx)
≡
[cos(nx)]xx −(1/2) cos(nx),
for all n
=
−{n2 + 1/2} cos(nx),
for all n
(3.43)
and
(cos[mx], cos[nx]) = πδmn,
all
m, n > 0
(3.44)

3.6. GALERKIN METHOD: CASE STUDIES
71
Thus, (3.6) becomes
(−3/2)
0
a1
(−3/2)
=
0
(−9/2)
a2
(−9/2)
which gives ⃗a = (1, 1)T [the superscript “T” denotes the “transpose” of the row vector into
a column vector] and the solution
u2(x) = cos(x) + cos(2x)
(3.45)
For this carefully contrived example, the approximation is exact.
EXAMPLE TWO:
uxx + {cos(x) + cos2(x)}u = exp[−1 + cos(x)]
(3.46)
subject to periodic boundary conditions. We assert without proof that a Fourier cosine
series is sufﬁcient to solve (3.46). [A rigorous justiﬁcation can be given through the discus-
sion of “parity” in Chapter 8]. The R. H. S. of (3.46) is also the exact solution, which is the
special case ∆= 1 of the expansion
exp{∆[−1 + cos(x)]} = exp(−∆){I0(∆) + 2
∞
X
n=1
In(∆) cos(nx)}
(3.47)
Let
u3(x) = a0 + a1 cos(x) + a2 cos(2x) + a3 cos(3x)
(3.48)
H ≡∂xx + cos(x) + cos2(x);
f(x) = exp[−1 + cos(x)]
(3.49)
The Galerkin method gives the following 4 x 4 matrix problem:
(1/2)
(1/2)
...
(1/4)
(0)
a0
f0
(1)
(−1/4)
...
(1/2)
(1/4)
a1
f1
.....
....
...
−−−
=
−−−−
(1/2)
(1/2)
(−7/2)
(1/2)
a2
f2
(0)
(1/4)
(1/2)
(−17/2)
a3
f3
(3.50)
As noted earlier, the acid test of the accuracy of any numerical calculation is to repeat it
with different truncations. The two-term Galerkin approximation to (3.46) can be obtained
by simply truncating (3.50) to the upper halves of the column vectors ⃗a and ⃗f — the parts
above the dashes — and truncating the square matrix H to its upper left 2 × 2 block, which
is the block partitioned from the rest of the matrix by the dotted lines.
The matrix elements in (3.50) are given symbolically by
Hjk
≡
(cos(jx), {−k2 + cos(x) + cos2(x)} cos(kx))
(3.51)
fj
≡
(cos(jx), exp(−1 + cos(x))) =
½
exp(−1) I0(1)
[j = 0]
2 exp(−1) Ij(1)[j ̸= 0]

72
CHAPTER 3. GALERKIN & WEIGHTED RESIDUAL METHODS
0
0.5
1
1.5
2
2.5
3
0
0.2
0.4
0.6
0.8
1
x
Figure 3.1: Example Two: a comparison between the exact solution (solid) and the two–
term approximation (dashed with circles).
0
0.5
1
1.5
2
2.5
3
-0.025
-0.02
-0.015
-0.01
-0.005
0
0.005
0.01
0.015
0.02
x
Figure 3.2: Example Two: the errors for the three-term approximation (dashed with circles)
and four-term Galerkin solution (solid with x’s).

3.6. GALERKIN METHOD: CASE STUDIES
73
Table 3.1: Comparison of exact and approximate spectral coefﬁcients for EXAMPLE TWO
for various truncations, and also the errors in these coefﬁcients.
n
Exact
N=1 (two terms)
N=2 (three terms)
N=3 (four terms)
an
an
Errors
an
Errors
an
Errors
0
0.4658
0.5190
-0.0532
0.4702
-0.0044
0.4658
0.0
1
0.4158
0.4126
0.0032
0.4126
0.0032
0.4159
-0.0001
2
0.0998
–
–
0.0976
0.0022
0.0998
0.0
3
0.0163
–
–
–
–
0.0162
0.0001
4
0.0020
–
–
–
–
–
–
Table 3.2: Comparison of upper bounds on the discretization error ED and truncation error
ET with the maximum pointwise error [ error in the L∞norm].
[N=1]
[N=2]
[N=3]
ED(bound)
0.0564
0.0098
0.0002
ET (bound)
0.1181
0.0183
0.0020
L∞error
0.153
0.021
0.0023
upper bound on
ED = PN
n=0 |aexact
n
−aapprox.
n
|
upper bound on ET = P∞
n=N+1 |an|
L∞
error = max∀xϵ[−π,π] |u(x) −uN(x)|
where j, k = 0, . . . , N. Numerical evaluation of these integrals then gives (3.50).
The coefﬁcients as calculated with two, three, and four terms are in Table 3.1 along with
the differences between these coefﬁcients and those of the exact solution. Table 3.2 of the
table shows upper bounds on the discretization error and the truncation error that were
calculated by taking the absolute value of each error (or neglected term) and summing.
Fig. 3.1 compares the exact solution with the two term approximation. The errors in the
higher approximations are so small that it is difﬁcult to see the difference between the
curves, so Fig. 3.2 graphs only the absolute errors for u2(x) and u3(x). The table and ﬁgures
support many previous assertions.
First, it was claimed that the discretization error ED and the truncation error ET are of
the same order-of-magnitude so that it is legitimate to use the latter as an estimate of the
total error. Table 3.1 shows that this is true; the total error (sum of ED plus ET ) is only half
again as large as ET for all three truncations.
Second, Table 3.2 shows that the maximum pointwise error is only a little smaller than
the sum of the absolute values of the discretization and truncation errors. Put another way,
the Fourier Truncation Theorems give fairly tight bounds on the pointwise error rather
than wild overestimates.
Third, we asserted that the last retained coefﬁcient aN was a loose but useful estimate of
the total error. Table 3.2 shows that this is true although rather conservative. For N = 3, for
instance, the last calculated coefﬁcient is 0.0162, but the maximum error in u2(x) is about
eight times smaller.
Fourth, it was claimed that spectral methods are much more accurate than ﬁnite differ-
ence methods. Fig. 3.1 shows that even the N = 1 (two term) approximation is qualita-
tively similar to u(x); Fig. 3.2 shows that using just four terms gives a maximum error of
only 1 part in 500 relative to the maximum of u(x). It would be quite impossible to obtain

74
CHAPTER 3. GALERKIN & WEIGHTED RESIDUAL METHODS
anything like this accuracy with ﬁnite difference methods. The Quasi-Sinusoidal Rule-of-
Thumb suggests that one would need about 20 grid points with a second order method to
achieve the same accuracy as the N = 3 spectral approximation.
Fifth, Fig. 3.2 shows that the error is highly uniform over the interval. The error oscillates
with several changes of sign, and different peaks of error differ in size by no more than a
factor of two for N = 2 and are almost identical in size for N = 3. These are very general
properties of spectral approximations: Basis function methods do not favor one part of the
domain over another.
EXAMPLE THREE:
The eigenvalue problem
(1 −x2) uxx −λx2u = 0
(3.52)
where λ is the eigenvalue and where the homogeneous boundary conditions are that u(x)
should be analytic at x = ±1 in spite of the singularities of the differential equation at
those points. This problem is a special case of Laplace’s Tidal Equation for zero zonal
wavenumber (Leovy, 1964, & Longuet-Higgins,1968).
We will use the Chebyshev approximation
u2 = a0T0 + a2T2(x) + a4T4(x)
(3.53)
(The reason for using only the symmetric polynomials is explained in Chapter 8: All the
eigenfunctions have either even or odd parity.) We do not need to impose explicit condi-
tions on the approximation because every term in (3.53) is analytic at the endpoints. This
situation — holomorphic eigensolutions at endpoints where the differential equation is sin-
gular — is the only case where explicit boundary conditions are unnecessary in a problem
which is (a) nonperiodic and (b) deﬁned on a ﬁnite interval. (The boundary conditions are
discussed further below.)
The algebraic equivalent of the differential equation is
(T0, HT0)
(T0, HT2)
(T0, HT4)
a0
0
(T2, HT0)
(T2, HT2)
(T2, HT4)
a2
=
0
(T4, HT0)
(T4, HT2)
(T4, HT4)
a4
0
where the operator H is
H ≡(1 −x2)(d2/dx2) −λx2
(3.54)
The integrals can be evaluated by making the change of variable x = cos(θ) and then ap-
plying a table of trigonometric integrals, or by numerical integration. The result, dividing
by a common factor of π, is
(−λ/2)
(2 −λ/4)
(4)
a0
0
(−λ/2)
(−2 −λ/2)
(8 −λ/4)
a2
=
0
(0)
(−λ/4)
(−12 −λ/2)
a4
0
Since this algebraic system of equations is homogeneous, it has a non-trivial solution if
and only if the determinant of the matrix is 0, that is, if
λ (−λ2 −96λ −768) = 0
(3.55)

3.6. GALERKIN METHOD: CASE STUDIES
75
which has the three roots
λ = 0, −8.808, −87.192
(3.56)
One difﬁculty which is peculiar to eigenvalue problems is to determine which eigen-
values are accurate and which are hopelessly inaccurate for a given truncation N. A full
discussion is postponed to Chapter 7, but we anticpate one rule-of-thumb: For a “nice”
eigenvalue problem, typically about N/2 eigenvalues are accurate.
If N is large, the error in the lowest mode may be only 1 part in 1010, but will increase
rapidly with the mode number until there is no accuracy at all for (roughly!) the largest
N/2 modes. Repeating the calculation with different N is a good idea for any class of
problem to check the answer; linear eigenvalue problems are the only class where one has
to rerun the code simply to know what the answer is. (More precisely, to know how many
modes one has actually succeeded in computing.)
For this problem, the lowest mode is exact but useless: λ = 0 corresponds to u(x) =
constant, which is a mathematically legitimate solution with no physical signiﬁcance. The
ﬁrst non-trivial mode has the exact eigenvalue λ1 = −8.127, so that the three-term spectral
solution has an error of only 7.7%. The second root, -87.192, is an absolutely atrocious
approximation to the second mode, λ3 ≈−12. However, we can calculate λ3 as accurately
as desired by using a sufﬁciently large truncation.
Besides the eigenvalue rule-of-thumb, this example is useful in illustrating two addi-
tional general principles.
First, this is our ﬁrst example of a “behavioral” (as opposed to “numerical”) boundary
condition for a non-periodic problem. “Numerical” boundary conditions are those that we
must explicitly impose on the numerical approximation to force it or its derivatives to equal
certain numbers at the boundaries. The Dirichlet conditions u(0) = 1, u(1) = −1/2 are
“numerical” conditions. For Laplace’s Tidal Equation, however, the differential equation
itself forces the solution to behave properly at the boundaries without the need for any
intervention on our part. The only requirement is that the numerical solution must be
analytical at the endpoints even though the differential equation has singular coefﬁcients
there; this behavioral boundary condition is implicitly satisﬁed by a truncated Chebyshev
series because these polynomials are analytic at x = ±1.
Behavioral boundary conditions are the rule rather than the exception in spherical or
cylindrical geometry, or whenever the coordinate system introduces singularities that do
not reﬂect the physics of the problem. (Laplace’s Tidal Equation is usually expressed in
terms of colatitude φ on a sphere; we have converted it to a form suitable for Chebyshev
polynomials by making the change-of-variable x = cos(φ).) Spherical coordinates are fully
discussed with numerical illustrations in Boyd (1978b) and in Chapter 18.
Another example is Bessel’s equation, which arises in polar coordinates or cylindrical
coordinates. The function Jn has an n-th order zero at the origin, but one can blindly
assume a solution in Chebyshev polynomials in radius r, and obtain good results. An
approximation table for J7(r) is given in Gottlieb and Orszag (1977).
A third class of examples is furnished by problems on an unbounded interval. “Be-
havioral” versus “numerical” boundary conditions for this case are discussed in Chapter
17.
Second, because this is a problem in spherical coordinates, the natural basis set would
be spherical harmonics — Legendre polynomials for our special case of zero zonal wavenum-
ber. Nonetheless, we bravely applied Chebyshev polynomials to compute the smallest
eigenvalue to within less than 8% error by solving a quadratic equation.
As claimed earlier, Chebyshev polynomials work just ﬁne even when they are not the
obvious or the optimum basis set.

76
CHAPTER 3. GALERKIN & WEIGHTED RESIDUAL METHODS
3.7
Separation-of-Variables & the Galerkin Method
In the pre-computer age, partial differential equations were solved almost exclusively by
“separation–of–variables”. While systematizing this procedure, Sturm and Liouville dis-
covered that eigenvalue problems generate eigenfunctions which have all the properties
that make them desirable as spectral basis functions. Conversely, one can look backwards
and see that “separation–of–variables” is just a special case of spectral methods.
EXAMPLE: Diffusion Equation
ut = uxx
(3.57)
with boundary conditions of spatial periodicity with a period of 2π and the initial condition
u(x, t = 0) = Q(x) where Q(x) is arbitrary. Since the boundary conditions are periodicity,
the obvious basis is a Fourier series:
u(x, t) = a0(t) +
∞
X
n=1
an(t) cos(nx) +
∞
X
n=1
bn(t) sin(nx)
(3.58)
Since the basis functions are individually periodic, all rows of the Galerkin matrix come
from the differential equation. The cosine rows are
Hmn
=
(cos(mx), {∂t −∂xx} cos(nx))
(3.59)
=
(cos(mx), {∂t + n2} cos(nx))
(3.60)
=
{∂t + n2}δmnπ
(3.61)
The sine rows are similar. It is not necessary to bother with a particular truncation be-
cause the Galerkin matrix is diagonal and each sine or cosine function is uncoupled from all
the others. The spectral method in x reduces the problem to the uncoupled, independent
ordinary differential equations
a0,t = 0;
an,t + n2an = 0;
bn,t + n2bn = 0
(3.62)
a0(t) = a0(0);
an(t) = an(0) exp(−n2t);
bn(t) = bn(0) exp(−n2t)
(3.63)
where the values of the coefﬁcients at t = 0 are obtained by expanding the initial condition
Q(x) as a Fourier series.
We could alternatively solve this same problem with Chebyshev polynomials. The
Chebyshev series would also generate a set of ordinary differential equations in time. The
difference is that with a basis of anything other than trigonometric functions, all the dif-
ferential equations would be coupled, just as were the pair obtained by Fourier series for
the variable coefﬁcient diffusion equation in Chapter 1. Instead of the explicit solutions of
(3.63), we are left with a mess.
The heart of “separation–of–variables” is to make a clever choice of basis functions so
that the differential equations in the remaining variable are uncoupled. For the constant
coefﬁcient diffusion equation, sines and cosines are the “clever” choice, independent of
the boundary conditions.
Separation-of-variables series often converge at only an algebraic rate. However, this
slow convergence frequently reﬂects corner singularities in space or space-time, so non-
separable basis sets like Chebyshev and Legendre polynomials converge algebraically, too.
For more complicated equations, alas, it is necessary to use basis sets more complicated
than trigonometric functions to “separate variables” — wierd creatures named Mathieu,

3.8. HEISENBERG MATRIX MECHANICS
77
Lam´e, and parabolic cylinder functions, to list but a few. We shall spare the reader these
exotica. Nevertheless, since most textbooks on the physical sciences written before 1960
are little more than catalogues of successful applications of “separation-of-variables”, it is
important to recognize that it is but a special case of spectral methods.
3.8
Galerkin Method in Quantum Theory: Heisenberg Ma-
trix Mechanics
In quantum mechanics, one computes the energy levels of atoms and molecules by solving
the eigenvalue problem
Hψ = Eψ
(3.64)
where the linear operator H is the “Hamiltonian”, E is the energy and also the eigenvalue,
and ψ(x) is the wave function. Until very recently, spectral methods were the only tool used
on Schroedinger’s equation. Indeed, the ﬁrst half-century of wave mechanics is mostly a
catalogue of increasingly elaborate applications of spectral methods to calculate energy
levels.
Why spectral methods? The ﬁrst reason is the curse of dimensionality. The wavefunc-
tion for the helium atom, which has two electrons, is a function of the coordinates of both
electrons and thus is six-dimensional even though physical space has only three dimen-
sions. An N-electron wavefunction is a native of a 3N-dimensional conﬁguration space.
The second reason is that one special case, the hydrogen atom, can be solved in closed,
analytical form by separation-of-variables. The eigenfunctions are the product of Laguerre
functions in radius with spherical harmonics in longitude and latitude; although a bit
messy, the eigenfunctions can evaluated by recurrence on a four-function calculator. This
is a great gift because the orbits of electrons in molecules and multi-electron atoms are not
too much distorted from those of the hydrogen atom. In other words, it is possible to build
up good approximations to molecular structure from a small number of hydrogenic wave
functions.
The third reason is the Rayleigh-Ritz variational principle. This states that for a lin-
ear, self-adjoint eigenvalue problem, the solution for the lowest eigenvalue is that which
minimizes the “Rayleigh functional”
RR ≡(ψ, Hψ)/(ψ, ψ)
(3.65)
(Physicists call the mode with the lowest eigenvalue the “ground state”.) If we substitute a
trial wavefunction ψtrial into RR(ψ), then E ≈RR. The special virtue of the Rayleigh-Ritz
principle is that one can prove that
E ≤RR(ψ)
for all ψ
(3.66)
In words, any calculation, even a crude one, will always give an upper bound on the true
energy.
The Rayleigh-Ritz principle allowed the early quantum chemists to search for approx-
imate wave functions with wild abandon. It was rather like breaking an Olympic record;
each guess that broke the previous minimum for E was a triumph since the Rayleigh-Ritz
principle guaranteed that this had to be a better approximation than any wavefunction that
had gone before it. In particular, one did not need to worry about completeness, or even
linearity. If the trial wavefunction depended nonlinearly on certain parameters, one could
still minimize R with respect to those parameters and perhaps obtain a very good approx-
imation.

78
CHAPTER 3. GALERKIN & WEIGHTED RESIDUAL METHODS
EXAMPLE: H+
2 MOLECULAR ION
This is a one-electron ion with two attracting protons which we shall label “A” and “B”.
Now the ground state for the hydrogen atom is
ψA = [constant]
exp[−rA/a0]
(3.67)
where rA is the distance from the electron to proton A and where a0 is the “Bohr radius”.
To simplify notation, we shall ignore the normalizing constants as in (3.67). An obvious
approach is to use hydrogen 1s orbitals like (3.67), but to take
ψ ≈ψA ± ψB
(3.68)
where ψA is given by (3.67) and where ψB has the same functional form except that rA is re-
placed by rB, the distance from the electron to the second proton. This trial solution allows
for the electron’s freedom to orbit either proton or to trace ﬁgure-eights. The symmetry
— both protons have equal charge — implies that ψA and ψB must come in with equal
amplitude, but we must allow for the possibility of the minus sign. Graphing the Rayleigh
functional as a function of the internuclear separation rN then gives a prediction for E, and
simultaneously for the distance between the two protons.
Crude as this approximation is, it correctly predicts negative energy for the plus sign in
(3.68); the hydrogen ion is a stable species. The observed internuclear separation distance
is such that contours of wavefunction amplitude are nearer the protons in the ion than for
the hydrogen atom, so this suggests improving (3.68) by taking ψA to be of the same shape
as (3.67), but with a re-scaled radial dependence:
ψA ≡exp[−crA/a0]
(3.69)
and similarly for ψB. Minimizing R with respect to both c and rN gives the lowest energy
for c = 1.24.
The third improvement is to note that the pull of the other proton tends to distort the
hydrogenic orbitals so that they are elongated in the direction of the other positive charge.
This “polarity effect” suggests
ψA = exp[−crA/a0] + λx exp[−crA/a0]
(3.70)
where the x-axis is aligned along the line between the two protons. The result of min-
imizing the Rayleigh functional with respect to c and λ is shown as a function of rN in
Fig. 3.3, which is taken from Coulson (1961). In Coulson’s words, “the true energy differs
inappreciably from (iii) [7.7]”.
This is a stirring success for an approximation with just three parameters. When more
terms are included, as is necessary for more complicated molecules, it becomes a great
burden to use nonlinear parameters, so chemists are forced to use approximations that
depend linearly on the unknowns, that is, a spectral series. The Rayleigh-Ritz method is
then equivalent to the Galerkin. The “valence bond” and “molecular orbital” theories are
merely different choices of spectral basis functions. The acronym often used for the latter
— L. C. A. O.–M. O. theory — sums up the underlying philosophy of both: “Linear Com-
binations of Atomic Orbitals - Molecular Orbitals”. In other words, the approximations for
molecules are assembled using atomic orbitals as the basis functions.
For some types of bonds, the appropriate atomic orbitals are the “s-orbitals” of hydro-
gen; for others, the p-, d- or higher orbitals are appropriate. For the benzene ring, for
example, which consists of six carbon atoms at the corners of a hexagon, the simplest ap-
proximation is
ψ ≈a1ψ1 + a2ψ2 + a3ψ3 + a4ψ4 + a5ψ5 + a6ψ6
(3.71)

3.8. HEISENBERG MATRIX MECHANICS
79
Figure 3.3: A graph of the energy for the hydrogen molecular ion H+
2 , as a function of the
internuclear separation RN in units of the Bohr radius a0. (i) Sum of two hydrogen orbitals,
ψ = ψA +ψB (ii) Sum of two “screened” hydrogen orbitals which incorporate the screening
parameter, c (iii) ψA = exp(−crA/a0) + λx exp(−crA/a0) and similarly for ψB where λ is
known as the “polarity” constant. The true energy differs negligibly from the minimum of
(iii). After Coulson (1961) and Dickinson(1933).
where the ψi’s are hydrogen p-orbitals centered on each of the six carbon atoms and where
the ai’s are the spectral coefﬁcients. The separation of the carbon atoms, although it can be
calculated as for the hydrogen molecular ion, is usually taken as an observational given at
this (crude) order of approximation so that the problem is linear in the variational parame-
ters. Minimizing the Rayleigh functional with respect to the ai’s gives the matrix problem
(ψ1, H −Eψ1)
(ψ1, H −Eψ2)
. . .
(ψ1, H −Eψ6)
a
0
(ψ2, H −Eψ1)
. . .
. . .
. . .
a2
0
...
=
(ψ6, H −Eψ1)
. . .
. . .
(ψ6, H −Eψ6)
a6
0
(3.72)
Chemists, for historical reasons, call determinants of this form “secular determinants”,
but the matrices are the same as those created by the Galerkin method. Eq. (3.72) is a
standard matrix eigenvalue equation with E as the eigenvalue.
As Fig. 3.3 shows, heuristic guessing of basis functions which are not standard basis
functions can be very effective when coupled with the Rayleigh-Ritz principle and an ap-
propriate measure of desperation. This strategy is a good way of generating low-order
analytical approximations in other ﬁelds, too, but it can be risky. With the Rayleigh-Ritz
principle, a bad guess is immediately evident: its lowest energy is larger than that of previ-
ous calculations. Victory is as clear and well-deﬁned as breaking a record in track-and-ﬁeld.
In other scientiﬁc areas, this strategy has also been tried, but the risks are much higher.
In the absence of the Rayleigh-Ritz principle, guessing trial functions may make Galerkin
and collocation approximations worse instead of better (Finlayson, 1973).
Fortunately, it is possible to regain security of the Rayleigh-Ritz principle. The remedy
is to minimize the square of the residual as explained in Appendix G of the ﬁrst edition of
this book (1989). The cost is that the programming is more complicated and the execution
time and storage are somewhat increased.

80
CHAPTER 3. GALERKIN & WEIGHTED RESIDUAL METHODS
3.9
The Galerkin Method Today
In the next chapter, we will discuss pseudospectral/collocation algorithms, so it is a little
premature to compare different methods. However, a few preliminary remarks are in order.
First, the Galerkin method is more difﬁcult to program than pseudospectral algorithms.
The reason is simply that it is easier to evaluate a function than it is to integrate it.
It is often possible to replace the numerical integration by use of trigonometric identi-
ties, but this makes it more difﬁcult to test the program because a simple problem with a
known, exact solution may not use all the identities which are needed to solve more com-
plex equations (O’Connor, 1996). In contrast, a collocation program (or Galerkin method
with numerical evaluation of the matrix elements) does not use special tricks, and therefore
will either succeed or fail for both the test problem and the real one.
Second, the Galerkin method with a truncation of N is usually equal in accuracy to a
pseudospectral method with a truncation of N +1 or N +2. When N is large, this difference
is negligible, and pseudospectral algorithms are better. When N is small, however, that
extra one or two degrees of freedom can be very important.
We have already seen that spectral methods are often accurate even for N so small that
one can substitute paper-and-pencil for a computer. Thus, spectral methods are not merely
a tool for numerical analysis, but for theoretical analysis, too. For theoretical purposes, the
smallness of N usually implies that one needs that extra accuracy given by the Galerkin
method. Furthermore, if a problem is simple enough so that one can analytically perform
the linear algebra, one can usually analytically evaluate the integrals for the Galerkin ma-
trix elements, too. Finlayson (1973) is full of such examples, drawn mostly from engineer-
ing. A full discussion with programs in the algebraic manipulation languages REDUCE
and Maple is given in Chapter 20 and Boyd (1993).
Another exception arises in time-marching. Implicit methods require solving a bound-
ary value problem at each step. However, if only some of the terms are treated implicitly
so as to give a “semi-implicit” algorithm, the boundary value problem may be linear and
constant coefﬁcient. For such problems, as explained in Chapter 15, the Galerkin matrix is
banded and Galerkin’s method is much faster than the pseudospectral scheme. Galerkin’s
method is an important component of spherical harmonic weather forecasting and climate
models for this reason.
In addition to these exceptions, quantum chemistry is an area where the Galerkin method
is still widely used, and for all the right reasons. Complex molecules require so many de-
grees of freedom that most of the computations must be done by machine. However, one is
usually forced to use a small number of basis functions per electron, so that is one is in effect
carrying out a low order simulation even when N = 400! The extra accuracy of Galerkin’s
method is therefore very important.
Normally, one should use only the standard, simple basis sets like Fourier series and
Chebyshev polynomials. However, quantum chemists are quite sensible in using LCAO
(“Linear Combinations of Atomic Orbitals”) as the trial functions; it would be quite im-
possible to obtain such good results for the H+
2 molecular ion with just three degrees of
freedom unless the choice of trial solution was guided by physical intuition. For similar
reasons explained Chapter 20 on symbolic calculations, it is sometimes better to use poly-
nomials other than Chebyshev for certain types of analytical, low-order calculations.
For most high-resolution numerical calculations, however, the best advice is still this:
use pseudospectral methods instead of spectral, and use Fourier series and Chebyshev
polynomials in preference to more exotic functions.

Chapter 4
Interpolation, Collocation & All
That
“In the past several years, there has been extensive activity in both the theory and ap-
plication of spectral methods. This activity has been mainly concentrated in the area of
pseudospectral methods.”
— Gottlieb, Hussaini, & Orszag (1984)
4.1
Introduction
The pseudospectral family of algorithms is closely related to the Galerkin method. To show
this and to understand the mechanics of pseudospectral methods, it is necessary to review
some classical numerical analysis: polynomial interpolation, trigonometric interpolation,
and Gaussian integration.
Deﬁnition 15 (INTERPOLATION)
An INTERPOLATING approximation to a function f(x) is an expression PN−1(x), usually
an ordinary or trigonometric polynomial, whose N degrees of freedom are determined by the require-
ment that the INTERPOLANT agree with f(x) at each of a set of N INTERPOLATION points:
PN−1(xi) = f(xi)
i = 1, 2, . . . , N
(4.1)
In the rest of this chapter, we will discuss the choice of interpolation points and methods
for computing the interpolant.
A note on terminology: we shall use “collocation points” and “interpolation points”
as synonyms. However, “interpolation” has the connotation that f(x), the function which
is being approximated by a polynomial, is already a known function. “Collocation” and
“pseudospectral” are applied to interpolatory methods for solving differential equations
for an unknown function f(x). The label “pseudospectral” is narrower than “collocation”
in that the former is rarely used except when the basis functions are global, such as Cheby-
shev or Fourier functions. Thus, almost any journal article with “pseudospectral” in the
title is relevant to this book, but many “collocation” methods are ﬁnite element procedures.
81

82
CHAPTER 4. INTERPOLATION, COLLOCATION & ALL THAT
x0
x1
Figure 4.1: Linear interpolation. The dashed line is that linear polynomial which intersects
the function being approximated (solid curve) at the two interpolation points.
4.2
Polynomial interpolation
Before hand-held calculators, tables of mathematical functions were essential survival equip-
ment. If one needed values of the function at points which were not listed in the table, one
used interpolation. The simplest variant, linear interpolation, is to draw a straight line
between the two points in the table which bracket the desired x. The value of the linear
function at x is then taken as the approximation to f(x), i. e.
f(x) ≈(x −x1)
(x0 −x1)f(x0) + (x −x0)
(x1 −x0)f(x1)
[Linear Interpolation]
(4.2)
Fig. 4.1 is a graphic proof of the high school theorem: a straight line is completely deter-
mined by specifying any two points upon it; the linear interpolating polynomial is unique.
A more abstract deﬁnition is that P1(x) is that unique linear polynomial which satisﬁes the
two interpolation conditions
P1(x0) = f(x0)
;
P1(x1) = f(x1)
(4.3)
Linear interpolation is not very accurate unless the tabulated points are very, very close
together, but one can extend this idea to higher order. Fig. 4.2 illustrates quadratic interpo-
x0
x1
x2
Figure 4.2: Schematic of quadratic interpolation. The dashed curve is the unique quadratic
polynomial (i. e., a parabola) which intersects the curve of the function being approximated
(solid) at three points.

4.2. POLYNOMIAL INTERPOLATION
83
lation. A parabola is uniquely speciﬁed by giving any three points upon it. Thus, we can
alternatively approximate f(x) by the quadratic polynomial P2(x) which satisﬁes the three
interpolation conditions
P2(x0) = f(x0)
;
P2(x1) = f(x1)
;
P2(x2) = f(x2)
(4.4)
P2(x)
≡
(x −x1)(x −x2)
(x0 −x1)(x0 −x2)f(x0) + (x −x0)(x −x2)
(x1 −x0)(x1 −x2)f(x1)
(4.5)
+
(x −x0)(x −x1)
(x2 −x0)(x2 −x1)f(x2)
In general, one may ﬁt any N + 1 points by a polynomial of N-th degree via
PN(x) ≡
N
X
i=0
f(xi) Ci(x)
[Lagrange Interpolation Formula]
(4.6)
where the Ci(x), the “cardinal functions”, are polynomials of degree N which satisfy the
conditions
Ci(xj) = δij
(4.7)
where δij is the Kronecker δ-function. The cardinal functions are deﬁned by
Ci(x) =
N
Y
j=0,j̸=i
x −xj
xi −xj
[Cardinal Function]
(4.8)
The N factors of (x −xj) insure that Ci(x) vanishes at all the interpolation points except xi.
(Note that we omit the factor j = i so that Ci(x) is a polynomial of degree N, not (N + 1).)
The denominator forces Ci(x) to equal 1 at the interpolation point x = xi; at that point,
every factor in the product is (xi −xj)/(xi −xj) = 1. The cardinal functions are also called
the “fundamental polynomials for pointwise interpolation”, the “elements of the cardinal
basis”, the “Lagrange basis”, or the “shape functions”.
The cardinal function representation is not efﬁcient for computation, but it does give a
proof-by-construction of the theorem that it is possible to ﬁt an interpolating polynomial
of any degree to any function. Although the interpolating points are often evenly spaced
— surely this is the most obvious possibility — no such restriction is inherent in (4.6); the
formula is still valid even if the {xi} are unevenly spaced or out of numerical order.
It seems plausible that if we distribute the interpolation points evenly over an interval
[a, b], then the error in PN(x) should →0 as N →∞for any smooth function f(x). At the
turn of the century, Runge showed that this is not true.
His famous example is
f(x) ≡
1
1 + x2
x ∈[−5, 5]
(4.9)
Runge proved that for this function, interpolation with evenly spaced points converges
only within the interval | x |≤3.63 and diverges for larger | x | (Fig. 4.3). The 15-th degree
polynomial does an excellent job of representing the function for | x |≤3; but as we use
more and more points, the error gets worse and worse near the endpoints. The lower
right panel of Fig. 4.3, which plots the logarithm (base 10) of the error for the 30-th degree
polynomial, makes the same point even more strongly.

84
CHAPTER 4. INTERPOLATION, COLLOCATION & ALL THAT
-5
0
5
0
0.5
1
6-pt
-5
0
5
0
0.5
1
1.5
2
11-pt
-5
0
5
0
0.5
1
1.5
2
15-pt
-5
0
5
10
0
31-pt
Errors
Figure 4.3: An example of the Runge phenomenon.
a. Solid curve without symbols: f(x) ≡1/(1 + x2), known as the “Lorentzian” or “witch
of Agnesi”. Disks-and-solid curve: ﬁfth-degree polynomial interpolant on x ∈[−5, 5]. The
six evenly spaced interpolation points are the locations where the dashed and the solid
curves intersect.
b. Interpolating polynomial [disks] of tenth degree.
c. The interpolating polynomial of degree ﬁfteen is the dashed curve. d. Same as previous
parts except that only the error, log10(|f(x)−P30|), is shown where P30(x) is the polynomial
of degree thirty which interpolates f(x) at 31 evenly spaced points on x ∈[−5, 5]. Because
the error varies so wildly, it is plotted on a logarithmic scale with limits of 10−3 and 102.
In the interior of the interval, the error is only 1 /1000. Just inside the endpoints, how-
ever, P30(x) reaches a maximum value of 73.1 even though the maximum of f(x) is only
1! It is not possible to graph f(x) and P30(x) on the same ﬁgure because the curve of f(x)
would be almost invisible; one would see only the two enormous spikes near the endpoints
where the polynomial approximation goes wild.
Since f(x) = 1/(1 + x2) has simple poles at x = ±i, its power series converges only for
| x |≤1. These same singularities destroy the polynomial interpolation, too; the wonder
is not that Lagrangian interpolation fails, but that it succeeds over a much larger interval
than the Taylor series.
This in turn hints that the situation is not hopeless if we are willing to consider an uneven
grid of interpolation points. The lower panels of Fig. 4.3 show that, as Runge proved, the
middle of the interval is not the problem. The big errors are always near the endpoints. This
suggests that we should space the grid points relatively far apart near the middle of the

4.2. POLYNOMIAL INTERPOLATION
85
interval where we are getting high accuracy anyway and increase the density of points as
we approach the endpoints.
Unfortunately, as its degree N increases, so does the tendency of a polynomial of degree
N to oscillate wildly at the endpoints. Consequently, the enpoint squeezing must increase
with N. The Chebyshev interpolation procedure, which does indeed make Lagrangian in-
terpolation successful for any function which is analytic on the interval, has the grid points
only O(1/N 2) apart near the endpoints versus the 1/N spacing of our (failed!) effort to
approximate Runge’s example with an evenly spaced grid.
But what distribution of points is best? The answer is given by a couple of very old
theorems.
Theorem 12 (CAUCHY INTERPOLATION ERROR THEOREM)
Let f(x) have at least (N + 1) derivatives on the interval of interest and let PN(x) be its La-
grangian interpolant of degree N. Then
f(x) −PN(x) =
1
[N + 1] ! f (N+1)(ξ)
N
Y
i=0
(x −xi)
(4.10)
for some ξ on the interval spanned by x and the interpolation points. The point ξ depends on the
function being approximated, upon N, upon x, and upon the location of the interpolation points.
PROOF: Davis (1975).
If we want to optimize Lagrangian interpolation, there is nothing we can do about the
f (N+1)(ξ) factor (in general) since it depends on the speciﬁc function being approximated,
but the magnitude of the polynomial factor depends upon our choice of grid points. It
is evident that the coefﬁcient of xN is 1, independent of the grid points, so the question
becomes: What choice of grid points gives us a polynomial (with leading coefﬁcient 1)
which is as small as possible over the interval spanned by the grid points? By a linear
change of variable, we can always rescale and shift the interval [a, b] to [-1, 1], but what
then? Ironically, this question was answered half a century before the Runge phenomenon
was discovered.
Theorem 13 (CHEBYSHEV MINIMAL AMPLITUDE THEOREM)
Of all polynomials of degree N with leading coefﬁcient [coefﬁcient of xN] equal to 1, the unique
polynomial which has the smallest maximum on [-1, 1] is TN(x)/2N−1, the N-th Chebyshev poly-
nomial divided by 2N−1. In other words, all polynomials of the same degree and leading coefﬁcient
unity satisfy the inequality
max
x ∈[-1,1] |PN(x)| ≥max
x ∈[-1,1]
¯¯¯¯
TN(x)
2N−1
¯¯¯¯ =
1
2N−1
(4.11)
PROOF: Davis (1975, pg. 62).
Now any polynomial of degree N can be factored into the product of linear factors of
the form of (x −xi) where xi is one of the roots of the polynomial, so in particular
1
2N TN+1(x) ≡
N+1
Y
i=1
(x −xi)
(4.12)
To minimize the error in the Cauchy Remainder Theorem, the polynomial part of the re-
mainder should be proportional to TN+1(x). This implies that the OPTIMAL INTERPO-
LATION POINTS are the ROOTS of the CHEBYSHEV POLYNOMIAL of DEGREE (N +1).

86
CHAPTER 4. INTERPOLATION, COLLOCATION & ALL THAT
Figure 4.4: Graphical construction of the unevenly spaced Chebyshev interpolation grid. If
a semicircle of unit radius is cut into evenly spaced segments, and then vertical lines are
drawn from these “Fourier” gridpoints to the line segment [−1, 1], which is the base of the
semicircle, the vertical lines will intersect the horizontal line at the Chebyshev grid points.
The polar coordinates of the grid points on the semicircle are unit radius and angle θ =
π(2i −1)/(2N) where i = 1, . . . , N. The Chebyshev grid points are xi = cos(θi).
Since the Chebyshev polynomials are just cosine functions in disguise, these roots are
xi ≡−cos
·(2i −1)π
2(N + 1)
¸
i = 1, 2, . . . , N + 1
(4.13)
By Taylor expansion of the cosine function, we verify the assertion made above that the
grid spacing is O(1/N 2) near the endpoints:
x1 ≈−1 + π2
8N 2
;
x2 ≈−1 + 9π
8N 2
[N ≫1]
(4.14)
and similarly near x = 1.
The grid is illustrated in Fig. 4.4.
A number of important questions still remain. First, how accurate is Chebyshev in-
terpolation? Does it converge over as wide a region as the usual Chebyshev expansion
in which we compute a polynomial approximation by integration instead of interpolation?
Second, many problems (such as those in spherical coordinates or an inﬁnite domain) re-
quire something exotic like spherical harmonics or Hermite functions. What interpolation
scheme is best for those geometries? Third, it is obvious that (4.13) deﬁnes a choice of in-
terpolation points that we can use to solve differential equations via the pseudospectral
method, but what is the relationship, if any, between such an algorithm and the Galerkin
method?
In the next section, we generalize the choice of a best grid to other basis sets appropri-
ate for other geometries. In later sections, we will return to the Chebyshev and Fourier
methods and show that the price we pay for interpolation instead of integration is modest
indeed.
4.3
Gaussian Integration & Pseudospectral Grids
The reason that “collocation” methods are alternatively labelled “pseudospectral” is that
the optimum choice of the interpolation points, such as (4.13) for Chebyshev polynomials,

4.3. GAUSSIAN INTEGRATION & PSEUDOSPECTRAL GRIDS
87
makes collocation methods identical with the Galerkin method if the inner products are
evaluated by a type of numerical quadrature known as “Gaussian integration”.
Numerical integration and Lagrangian interpolation are very closely related because
one obvious method of integration is to ﬁt a polynomial to the integrand f(x) and then
integrate PN(x). Since the interpolant can be integrated exactly, the error comes entirely
from the difference between f(x) and PN(x). The standard textbook formulas are of the
form
Z b
a
f(x) dx ≈
N
X
i=0
wif(xi)
(4.15)
The weight functions wi are given by
wi ≡
Z b
a
Ci(x) dx
[“quadrature weight”]
(4.16)
where the Ci(x) are the cardinal functions on the set of points {xi} as deﬁned by (4.8) above.
As if there were not already enough jargon, the interpolation points are “abscissas” and
the integrals of the cardinal functions are “quadrature weights” in the context of numerical
integration.
The order of a numerical method is directly related to the highest polynomial for which
it is exact. For example, the usual three-point and ﬁve-point centered difference formulas
(Chapter 1) are exact when applied to general second-degree and fourth-degree polynomi-
als, respectively, so the errors are O(h2) and O(h4), respectively. Similarly, a quadrature
formula with (N + 1) points will be exact if the integrand is a polynomial of degree N.
Gauss made the observation that an evenly spaced grid is nothing sacred. In particular,
if we allow the interpolation points {xi} as well as the weights {wi} to be unknowns, we
have twice as many parameters to choose to maximize the accuracy of the method, and we
can make it exact for polynomials of degree (2N + 1).
Theorem 14 (GAUSS-JACOBI INTEGRATION)
If the (N +1) “interpolation points” or “abscissas” {xi} are chosen to be the zeros of PN+1(x)
where PN+1(x) is the polynomial of degree (N + 1) of the set of polynomials which are orthogonal
on x ∈[a, b] with respect to the weight function ρ(x), then the quadrature formula
Z b
a
f(x) ρ(x) dx =
N
X
i=0
wi f(xi)
(4.17)
is exact for all f(x) which are polynomials of at most degree (2N + 1).
PROOF: Davis (1975, pg. 343)
As noted earlier, we can take almost any smooth function ρ(x), insert it into the integral
inner product, and then apply Gram-Schmidt orthogonalization to 1, x, x2, . . . to create an
inﬁnite set of polynomials which are orthogonal with respect to the inner product
(f, g) =
Z b
a
f(x) g(x) ρ(x) dx
(4.18)
The Chebyshev, Legendre, Gegenbauer, Hermite, and Laguerre polynomials merely corre-
spond to different choices of weight functions and of the interval [a, b].
The general theory of orthogonal polynomials shows that the (N +2)-th member of a
family of polynomials is always of degree (N +1) and always has exactly (N +1) real zeros

88
CHAPTER 4. INTERPOLATION, COLLOCATION & ALL THAT
within the interval [a, b]. We might worry about the possibility that, for exotic basis sets like
Hermite functions, the zeros might be complex, or otherwise outside the physical domain,
but this fear is groundless. The only difﬁculty is that the roots are not known in closed form
for general N except for Chebyshev polynomials or trigonometric interpolation. However,
the roots and weights wi for various N and various weight functions ρ(x) can be found in
most mathematical handbooks such as Abramowitz and Stegun (1965) and also are easily
calculated by the FORTRAN routines in the appendix of Canuto et al.(1988). The Legendre-
Lobatto roots up to degree N are known in analytical form and are given in Appendix F,
Sec. F.8.
Theorem 15 (PERIODIC GAUSSIAN QUADRATURE)
The “Composite Trapezoidal Rule” and “Composite Midpoint Rule”, which both use abscissas
which are uniformly spaced, are Gaussian quadratures in the sense that these formulas are exact
with N points for TRIGONOMETRIC polynomials of degree 2N −2, that is, for polynomials
composed of the constant plus the ﬁrst (N −2) cosines plus the ﬁrst (N −2) sines.
PROOF: Implicit in the discrete orthogonality relationships between the sines and cosines
given in the next section.
The Trapezoidal Rule and Midpoint Rule are described in introductory numerical anal-
ysis courses as simple but crude quadrature schemes with an accuracy of O(1/N 2). This is a
libel, true only when integrating a NON-PERIODIC f(x). For PERIODIC functions, these nu-
merical integration schemes are GAUSSIAN QUADRATURES with an error which decreases
GEOMETRICALLY FAST with N for f(x) which are analytic for real x.
What does all this have to do with interpolation and the pseudospectral method? The
answer is that since quadrature formulas are obtained by analytical integration of the in-
terpolating polynomial, it follows that the best choice of quadrature points is also the best
choice of interpolation points and vice-versa. This implies the following principle that ap-
plies to Fourier series, Chebyshev, Legendre and Gegenbauer polynomials, Hermite and
Laguerre functions and so on.
Rule-of-Thumb 7 (CHOICE OF PSEUDOSPECTRAL GRIDS)
The grid points should be the abscissas of a Gaussian quadrature associated with the basis set.
The vague phrase “a Gaussian” quadrature is necessary because there are actually two
useful Gaussian quadratures associated with each basis. In the Fourier case, one can use
either the Trapezoidal Rule or the Midpoint Rule; which are equally accurate. The Trape-
zoidal Rule, as used in the next section, is the default choice, but the Midpoint Rule (alias
Rectangle Rule), which does not include either x = 0 or x = 2π as grid points, is convenient
when solving differential equations which have singularities at either of these endpoints.
Lobatto showed that one could obtain a numerical integration formula with all the good
properties of Gaussian quadrature by using the zeros of the ﬁrst derivative of a Chebyshev
or Legendre polynomial plus the endpoints x = ±1 as the quadrature points. This “Lo-
batto” or “endpoints-plus-extrema” grid is now more popular than the “Gauss” or “roots”
grid for solving boundary value problems because the boundary conditions instantly fur-
nish two grid point values for the unknown u(x). When the differential equation is singular
at the endpoints — for example, in cylindrical coordinates, differential equations usually
have singularities at r = 0 even when the solution is perfectly smooth and well-behaved
at the origin — then the “roots” grid is preferable . There is little difference between the
Trapezoidal and Midpoint Rule, or between the Gauss and Lobatto grids, in terms of accu-
racy or other theoretical properties.
The one mild exception to this Rule-of-Thumb is that weather forecasting models, which
use a spherical harmonics basis, usually employ a single latitudinal grid for all zonal

4.4. PSEUDOSPECTRAL IS GALERKIN METHOD VIA QUADRATURE
89
wavenumbers. The spherical harmonics for a given zonal wavenumber m are Gegenbauer
polynomials whose order is m+1/2. Technically, the optimum grid for a given m is a func-
tion of m. However, using different grids for different m would entail enormous amounts
of interpolation from one grid to another to calculate the nonlinear terms where different
wavenumbers m interact. So, a single grid is employed for all m. However, this grid is the
Gauss grid for the Legendre polynomials, so interpreted broadly, the rule applies to this
case, too.
4.4
Pseudospectral: Galerkin Method via Gaussian Quadra-
ture
The integrals that deﬁne the matrix elements in the Galerkin method usually must be eval-
uated by numerical quadrature. What scheme is most efﬁcient? The answer is Gaussian
quadrature, using the roots of the very same orthogonal polynomials (or trigonometric
functions) that are the basis functions. This choice connects the collocation and Galerkin
methods.
Theorem 16 (GALERKIN’s with QUADRATURE)
If the matrix elements are evaluated by (N +1)-point Gaussian quadrature, then for linear prob-
lems the spectral coefﬁcients {an} in
uN, G(x) =
N
X
n=0
an φn(x)
(4.19)
as calculated by the Galerkin method will be identical with those computed by the collocation method
using the same number of terms in the series and the same set of interpolation points.
It is because of this close relationship between the collocation and Galerkin methods that collocation-
at-the-Gaussian-quadrature-abscissas is also known as the “pseudospectral” method. (Historically,
before the development of collocation algorithms, “spectral” was a synonym for Galerkin.)
PROOF: Let the pseudospectral matrix equation be ⃗⃗L⃗a = ⃗f. The matrix elements are
Lij ≡L φj(xi)
;
fi ≡f(xi)
(4.20)
where L (without vector symbol) is the operator of the differential or integral equation and
f(x) is the forcing function. A single row of the matrix equation is then
N
X
j=0
Lij aj = fi
(4.21)
or written out in full,
N
X
j=0
[L φj(xi)] aj = f(xi)
(4.22)
Multiply each row of (4.22) by wi φn(xi) for some particular choice of n and then add.
(For simplicity, assume the basis functions are orthonormal.) The constants wi are the Gaus-
sian quadrature weights. This gives
N
X
j=0
Hnj aj = gn
(4.23)

90
CHAPTER 4. INTERPOLATION, COLLOCATION & ALL THAT
where
Hnj ≡
N
X
i=0
wi φn(xi) [L φj(xi)]
(4.24)
But this is simply the Galerkin matrix element
Hnj ≈(φn, L φj)
(4.25)
if the inner product integral is evaluated using Gaussian quadrature with (N + 1) points.
Similarly,
gn ≡
N
X
i=0
wi φn(xi) f(xi)
(4.26)
gn ≈(φn, f)
(4.27)
which is the n-th row of the column vector on the R. H. S. of the Galerkin matrix equation,
⃗⃗H⃗a = ⃗g.
If some rows of the matrix are used to impose boundary conditions, then the proof is
only slightly modiﬁed. The boundary rows are the same for either the Galerkin or pseu-
dospectral methods. With two boundary rows, for example, we impose only (N −1) collo-
cation conditions. We then add those collocation rows using the weights wi appropriate to
Gaussian integration with (N −1) points, and again reproduce the corresponding (N −1)
rows of the Galerkin matrix. Q. E. D.
Theorem 16 implies that collocation — with the right set of points — must inherit the
aura of invincibility of the Galerkin method.
Theorem 17 (ORTHOGONALITY under the DISCRETE INNER PRODUCT)
If a set of (N + 1) basis functions are orthogonal under the integral inner product
(φi, φj) = δij
(4.28)
where δij is the Kronecker δ-function, then they are still orthogonal with respect to the discrete inner
product
(φi, φj)G = δij
(4.29)
where the discrete inner product is deﬁned by
(f, g)G ≡
N
X
i=0
wi f(xi) g(xi)
(4.30)
for arbitrary functions f(x) and g(x), that is, where the discrete inner product is the (N + 1)-point
Gaussian quadrature approximation to the integral inner product.
PROOF: The product of two polynomials, each of degree at most N, is of degree at most
2N. Gaussian quadrature with (N + 1) points, however, is exact for polynomials of degree
(2N + 1) or less. Therefore, Gaussian quadrature evaluates without error the integrals that
express the mutual orthogonality of the ﬁrst (N + 1) basis functions among themselves.
Q.E.D.

4.4. PSEUDOSPECTRAL IS GALERKIN METHOD VIA QUADRATURE
91
This second theorem implies that the reward for exact evaluation of inner product inte-
grals, instead of approximation by Gaussian quadrature, is modest indeed. If we write
f(x) =
N
X
n=0
an φn(x) + ET (N; x),
(4.31)
then the property of exponential convergence implies that for large N, ET (N; x) will be
very small. Precisely how small depends upon f(x) and N, of course, but the virtue of
exponential convergence is that it is not a great deal more difﬁcult to obtain 15 decimal
places of accuracy than it is to get 1% accuracy. (For ln(1 + x) on x ∈[0, 1], for example,
N = 19 gives a relative error of at worst 1 part in 1015 !) Theorem 17 implies that
an,G ≡(f, φn)G
(4.32)
must evaluate to
an,G = an + (ET , φn)G
(4.33)
In words, the discrete inner product (that is, Gaussian integration) correctly and exactly
integrates that part of (f, φ) which is due to the truncated series portion of f, and all the
error in the integration comes from the truncation error in the (N + 1)-term approxima-
tion. If ET ≈1/1015, it is obvious that the difference between an,G and the exact spectral
coefﬁcient an must be of this same ridiculously small magnitude. (The exceptions are the
coefﬁcients whose degree n is close to the truncation limit N. The absolute error in ap-
proximating these tiny coefﬁcients by quadrature is small, but the relative error may not
be small.) However, Gaussian integration is a well-conditioned numerical procedure, so
the absolute errors in the {an} will always be small for all n. It follows that if we blindly
calculate (N +1) spectral coefﬁcients via (N +1)-point Gaussian quadrature and then sum
to calculate f(x), we will always get very high accuracy for f(x) if N is sufﬁciently large.
Thus, to represent a known function f(x) as a spectral series, we can safely dump our
table of integrals and simply multiply the grid point values of f(x) by a square matrix:
⃗a ≈⃗⃗M ⃗f
(4.34)
where ⃗a is the column vector of spectral coefﬁcients and where the elements of the other
two matrices are
Mij ≡φi(xj) wj
;
fj ≡f(xj)
(4.35)
where the {xj} are the (N + 1) Gaussian quadrature abscissas — the roots of φN+1(x) —
and the wj are the corresponding quadrature weights. Note that if the basis functions are
not orthonormal, we should divide the i-th row of ⃗M by (φi, φi). This transformation from
the grid point values f(xj) to the corresponding spectral coefﬁcients aj is discussed further
in Chapter 5, Sec. 5, and Chapter 10, Sec. 4, as the “Matrix Multiplication Transformation”
(MMT).
When solving a differential equation, we merely apply the same procedure as in (4.34)
and (4.35) to approximate the residual function R(x; a0, a1, . . . , aN) by interpolation. Again,
if N is large enough so that the coefﬁcients rn in the residual series are small for n > N, the
error in using Gaussian quadrature instead of exact integration to compute the rn must be
small.
Although we have referred to “polynomials” throughout this section, Theorems 16 and
17 not only apply to all the standard types of orthogonal polynomials but to trigonometric

92
CHAPTER 4. INTERPOLATION, COLLOCATION & ALL THAT
polynomials (that is, truncated Fourier series) as well. For most types of polynomials, it
is difﬁcult to estimate the error in (4.34) except to conclude, as we have already done, that
if N is large, this error will be absurdly small. Numerical experience has conﬁrmed that
the pseudospectral method is a very accurate and robust procedure for Hermite functions,
Jacobi polynomials and so on.
For Fourier series and Chebyshev polynomials, however, it is possible to analyze the
error in approximating coefﬁcient integrals by Gaussian quadrature (4.34) in a simple way.
This “aliasing” analysis turns out to be essential in formulating the famous “Two-Thirds
Rule” for creating “un-aliased” pseudospectral codes for nonlinear ﬂuid mechanics prob-
lems, so it is the topic of the next section.
We began this chapter with a discussion of interpolation and then turned to inner prod-
ucts and numerical integration. The next theorem shows that these two themes are inti-
mately connected.
Theorem 18 (INTERPOLATION BY QUADRATURE)
Let PN(x) denote that polynomial of degree N which interpolates to a function f(x) at the
(N + 1) Gaussian quadrature points associated with a set of orthogonal polynomials {φn(x)}:
PN(xi) = f(xi)
i = 0, 1, . . . , N
(4.36)
PN(x) may be expanded without error as the sum of the ﬁrst (N + 1) φN(x) because it is merely a
polynomial of degree N. The coefﬁcients {an} of this expansion
PN(x) =
N
X
n=0
an φn(x)
(4.37)
are given WITHOUT APPROXIMATION by the discrete inner product
an = (f, φn)G
(φn, φn)G
(4.38)
that is to say, are precisely the coefﬁcients calculated by (4.34) and (4.35) above, the Matrix Multi-
plication Transform (MMT).
PROOF: Since the interpolating polynomial is a polynomial, and since Theorem 18 shows
that the discrete inner product preserves the orthogonality of the ﬁrst (N + 1) basis func-
tions among themselves, it is obvious that applying the discrete inner product to the ﬁnite
series (4.37) will exactly retrieve the coefﬁcients an. What is not obvious is that we will
compute the same coefﬁcients when we use f(x) itself in the inner product since f(x) is
not a polynomial, but a function that can be represented only by an inﬁnite series.
However, the Gaussian integration uses only the (N + 1) values of f(x) at the interpola-
tion points — and these are the same as the values of PN(x) at those points. Thus, when we
use Gaussian quadrature to approximate f(x), we are really expanding the interpolating
polynomial PN(x) instead. Q. E. D.
Since it is easy to sum a truncated spectral series like (4.37) by recurrence, it is far more
efﬁcient to perform Lagrangian interpolation by calculating the coefﬁcients as in (4.34) and
(4.35) than it is to use the cardinal function representation (4.6), even though the two are
mathematically identical (ignoring round-off error).
One must be a bit careful to understand just what the theorem means. The coefﬁcients
computed by Gaussian integration are not the exact spectral coefﬁcients of f(x), but only
good approximations. The pseudospectral coefﬁcients are the exact expansion coefﬁcients
only of PN(x), the interpolating polynomial. For large N, however, such subtleties are
academic: PN(x) is a ridiculously good approximation to f(x), and therefore its coefﬁcients
are exceedingly good approximations to those of f(x).

4.5. PSEUDOSPECTRAL ERRORS
93
4.5
Pseudospectral Errors: Trigonometric & Chebyshev Poly-
nomials
Theorem 19 (TRIGONOMETRIC INTERPOLATION)
Let the collocation points {xk} be deﬁned by
xk ≡−π + 2 π k
N
k = 1, 2, . . . , N
(4.39)
Let a function f(x) have the exact, inﬁnite Fourier series representation
f(x) ≡1
2 α0 +
∞
X
n=1
αn cos(nx) +
∞
X
n=1
βn sin(nx)
(4.40)
Let the trigonometric polynomial which interpolates to f(x) at the N collocation points (4.39) be
SN(x) = 1
2 a0 +
N/2−1
X
n=1
an cos(nx) +
N/2−1
X
n=1
bn sin(nx) + 1
2 aM cos(Mx)
(4.41)
where M ≡N/2 and where
SN(xk) = f(xk),
k = 1, 2, . . . , N
(4.42)
Then the coefﬁcients of the interpolant can be computed without error by the Trapezoidal Rule
an
=
2
N
N
X
k=1
f(xk) cos (nxk)
[Trapezoidal Rule]
(4.43a)
bn
=
2
N
N
X
k=1
f(xk) sin(nxk)
[Trapezoidal Rule]
(4.43b)
and these coefﬁcients of the interpolant are given by inﬁnite series of the exact Fourier coefﬁcients:
an
=
αn +
∞
X
j=1
(αn+jN + α−n+jN)
n = 0, 1, . . . , N
2
(4.44a)
bn
=
βn +
∞
X
j=1
(βn+jN −β−n+jN)
n = 1, 2, . . . , N
2 −1
(4.44b)
PROOF: Young and Gregory (1972).
The factor of (1/2) multiplying both a0 and α0 is a convention. The reason for it is that
(cos[nx], cos[nx]) = (sin[nx], sin[nx]) = π for any n > 0, but (1, 1) = 2 π. There are two
ways of dealing with this factor of 2. One, which is normal in working with a Fourier series,
is to simply insert a denominator of (1/2π) in front of the integral that gives the constant
in the Fourier series and a factor of (1/π) in front of all the other coefﬁcient integrals. The
alternative, which is used in the theorem, is to employ a factor of 1/π in the deﬁnition of all
coefﬁcients — which means computing a coefﬁcient a0 which is a factor of two larger than
the constant in the Fourier series — and then inserting the compensating factor of (1/2)
directly into the Fourier sum (4.40) or (4.41).
This second convention is quite popular with the pseudospectral crowd because it elim-
inates factors of 2 from (4.44) as well as from (4.43).

94
CHAPTER 4. INTERPOLATION, COLLOCATION & ALL THAT
Eq. (4.43) is labelled the “Trapezoidal Rule” is because it is equivalent to applying that
simple integration formula to the Fourier coefﬁcient integrals. 1 The Trapezoidal Rule is a
very crude approximation with a relative accuracy of only O(h2) for general, that is to say,
for non-periodic functions. For periodic f(x), however, the Trapezoidal Rule is equivalent to
Gaussian integration. Unlike the optimum quadrature methods associated with Legendre
or Hermite polynomials, it is not necessary to look up the weights and abscissas in a table.
The weights (with the convention of the factor of (1/2) in (4.40) and (4.41)) are wk ≡2/N for
all k, and the interpolation points are evenly spaced as in (4.39). (Parenthetically, note that
in computing Fourier transforms, the Trapezoidal Rule also gives accuracy that increases
exponentially with N for sufﬁciently nice functions.)
Most of Theorem 19 merely repeats the trigonometric equivalent of the interpolation-
at-the-Gaussian-abscissas ideas of the previous section, but (4.44) is something remarkably
different. Theorems 17 and 18 imply that for any set of orthogonal polynomials,
an = αn +
∞
X
j=N+1
en,j(N) αj
(4.45)
where the {αn} are the exact spectral coefﬁcients and where the {an, n = 0, 1, . . . , N} are
the coefﬁcients of the interpolating polynomial. What is surprising about (4.44) is that it
shows that for Fourier series (and through change-of-variable, Chebyshev polynomials),
only one ej out of each group of (N/2) is different from 0.
This simple fact turns out to be profoundly important for coping with “nonlinear alias-
ing instability”, which is a vice of both ﬁnite difference and pseudospectral hydrodynamic
codes. For pseudospectral algorithms and quadratic nonlinearity, aliasing can be cured by
evaluating the nonlinear products using 2N interpolation points [double the number of
terms in the series] so that the expansion of the nonlinear term can be computed exactly.
S. A. Orszag pointed out that this is wasteful for Fourier and Chebyshev methods. The
special form of the Gaussian quadrature error in (4.44) makes it possible to use only about
(3/2) N points instead of 2N. This has become known as the “3/2’s Rule” or “Two-Thirds
Rule” where the latter name reﬂects that the yield of coefﬁcients is only (2/3) the number of
points used for quadrature. Unfortunately, the Two-Thirds Rule applies only for these two
types of basis functions: Fourier and Chebyshev. We will discuss the “Two-Thirds Rule” in
some detail in Chapter 11.
Another payoff of (4.44) is a proof of the following.
Theorem 20 (ERROR: FOURIER INTERPOLATION)
Let SN(x) denote the trigonometric polynomial that interpolates to a function f(x) at N points.
Let fN(x) denote the corresponding truncation of the exact Fourier series. Let the {αn} denote the
exact spectral coefﬁcients of the inﬁnite Fourier series. Then, as stated in Theorem 10 of Chapter 2
(with slightly different notation),
|f(x) −fN(x)|
≤
¯¯bN/2
¯¯ +
∞
X
n=1+N/2
(|an| + |bn|) ,
(4.46)
that is to say, the error is bounded by the sum of the absolute value of all the neglected coefﬁcients.
The new theorem is that the corresponding bound for trigonometric interpolation is, for all N
1Strictly speaking, the classical Trapezoidal Rule would add the quadrature point x = −π and multiply f(−π)
and f(π) by one-half the weight used for the interior points. Because of the periodicity, however, f(−π) ≡f(π),
so it sufﬁces to weight all the points the same, and use only f(π).

4.5. PSEUDOSPECTRAL ERRORS
95
and all real x,
|f(x) −SN(x)|
≤
2



¯¯bN/2
¯¯ +
∞
X
n=1+N/2
(|an| + |bn|)


,
(4.47)
that is to say, the error is bounded by TWICE the sum of the absolute values of all the neglected
coefﬁcients.
Comparing (4.46) and (4.47), we conclude:
the PENALTY for using INTERPOLATION instead of TRUNCATION is at WORST a
FACTOR of TWO.
PROOF:
Similar to that of Theorem 10 (Chap. 2). When we sum the absolute values of the terms
in (4.44) that are the errors due to interpolation, we ﬁnd that each neglected coefﬁcient
appears in (4.44) exactly once. Each neglected coefﬁcient also appears in the difference
between f(x) and fN(x) exactly once. When we add the absolute values of all the errors,
truncation and interpolation, we obtain (4.48).
To a ﬁnite difference modeller, the factor of two in Theorem 20 is a big deal. With a
second order scheme, it would be necessary to increase the number of grid points by 40%
to reduce the error by that factor.
A spectral modeller has a rather different perspective. For example, the coefﬁcients of
ln(1 + x) for x ∈[0, 1] are proportional to pn/n where p = 0.18. This implies that each
coefﬁcient is more than ﬁve times smaller than its immediate predecessor. It follows that
if the ﬁrst N terms of the Chebyshev series for ln(1 + x) gives an error everywhere less
than ϵ, then the Chebyshev interpolating polynomial with (N + 1) terms will have an even
smaller error bounded by 0.23 ϵ. When N is large, adding one or two more terms increases
the cost only slightly. The penalty we accept for using the pseudospectral method instead
of the Galerkin method is completely insigniﬁcant2.
The only reason the Galerkin method has not completely disappeared for numerical
computations is that it sometimes generates sparse matrices which can be inverted much
more easily than the full matrices generated by the pseudospectral method, as discussed in
the chapter on matrix-solving.
For completeness, we shall state the analogous theorems for Chebyshev polynomials.
Theorem 21 (CHEBYSHEV INTERPOLATION & its ERROR BOUND)
Let the “Chebyshev-extrema” (“Gauss-Lobatto”) grid {xk} be given by
xk = −cos
µkπ
N
¶
k = 0, 1, . . . , N
[“Chebyshev-extrema” grid]
(4.48)
Let the polynomial PN(x) which interpolates to f(x) at these grid points be
PN(x) =
N
X
n=0
′′ bn Tn(x)
[Extrema Grid]
(4.49)
2The exception is a paper-and-pencil or Maple calculation for very small N. A 4×4 determinant is approximately
ﬁve times harder to evaluate analytically than a 3 × 3 determinant, so the Galerkin method is a good choice for
low order analytical work.

96
CHAPTER 4. INTERPOLATION, COLLOCATION & ALL THAT
where the (′′) on the summation means that the ﬁrst and last terms are to be taken with a factor of
(1/2). [Compare this with the constant and cos(Mx) term in the Fourier interpolant, SN(x).] The
coefﬁcients of the interpolating polynomial are given by
bn = 2
N
N
X
k=0
′′f(xk) Tn(xk)
[Extrema Grid]
(4.50)
Let the “Chebyshev-roots” grid be deﬁned by
xk = −cos
·(2k + 1)π
2(N + 1)
¸
k = 0, 1, . . . , N
[“Chebyshev-roots” Grid]
(4.51)
and let QN(x) denote the interpolating polynomial of degree N which interpolates to f(x) on this
alternative grid:
QN(x) =
N
X
n=0
′ cn Tn(x)
[Roots Grid]
(4.52)
where the (′) on the sum means that the ﬁrst term [c0 T0] is to be divided by (1/2), then the coefﬁ-
cients are
cn =
2
N + 1
N
X
k=0
f(xk) Tn(xk)
[Roots Grid]
(4.53)
Let {αn} denote the exact spectral coefﬁcients of f(x), that is, let
f(x) =
∞
X
n=0
′ αn Tn(x)
(4.54)
The coefﬁcients of the interpolating polynomials are related to those of f(x) via
bn
=
αn +
∞
X
j=1
(αn+2jN + α−n+2jN) [Extrema Grid]
(4.55)
cn
=
αn +
∞
X
j=1
¡
αn+2j(N+1) + α−n+2j(N+1)
¢
(−1)j [Roots Grid]
(4.56)
For all N and all real x ∈[−1, 1], the errors in either of the interpolating polynomials is bounded
by TWICE the sum of the absolute values of all the neglected coefﬁcients:
|f(x) −PN(x)|
≤
2
∞
X
n=N+1
|αn|
(4.57)
|f(x) −QN(x)|
≤
2
∞
X
n=N+1
|αn| ,
(4.58)
that is, the penalty for using interpolation instead of truncation is the same for Chebyshev series as
for Fourier series:
a FACTOR of TWO.

4.5. PSEUDOSPECTRAL ERRORS
97
PROOF: Fox and Parker (1968).
Canuto et al. (1988) show that for incompressible (or weakly divergent) ﬂuid mechan-
ics, it is often useful to employ both these Chebyshev grids simultaneously. On this pseu-
dospectral “staggered” grid, the pressure is deﬁned on the “roots” grid while the velocities
are deﬁned on the “extrema” grid.
Although two alternative optimum Chebyshev grids may seem one too many, both sets
of points are useful in practice.

Chapter 5
Cardinal Functions
“Understanding grows only logarithmically with the number of ﬂoating point operations.”
— J. P. Boyd
5.1
Introduction
Mathematics courses have given the average physics or engineering student a rather warped
view of global expansion methods: The coefﬁcients are everything, and values of f(x) at
various points are but the poor underclass. Indeed, some massive tomes on Fourier series
never even mention the the word “interpolation”.
To understand pseudospectral methods, one must take a more broad-minded view: The
series coefﬁcients {an} and the values of the function at the interpolation points {f(xi)}
are equivalent and co-equal representations of the pseudospectral approximation to f(x).
Given the (N + 1) coefﬁcients of the approximating polynomial PN(x), we can certainly
evaluate the truncated series at each grid point to calculate the {f(xi)}. It is equally true,
however, that given the {f(xi)}, we have all the information needed to calculate the {an}
by applying the discrete inner product, i. e. interpolation. This operation, which is simply
the multiplication of a column vector by a square matrix1 introduces no additional errors
because the discrete inner product computes the expansion coefﬁcients of PN(x) exactly.
Because of this, pseudospectral methods may use either the series coefﬁcients or the
grid point values as the unknowns. Employing the {u(xi)} is very convenient because
a pseudospectral technique then becomes a grid point method — just like a ﬁnite differ-
ence procedure. The only alteration is that derivatives are computed through an N-point
scheme instead of the three- or ﬁve-point formulas of conventional ﬁnite differences.
There are a couple of different ways of working directly with grid point values, and
this chapter will discuss each in turn. In Chapter 9, we will then show that this freedom to
jump between the {an} and {u(xi)} representations of u(x) is absolutely essential to coping
with nonlinearity.
A major reason for discussing cardinal functions, however, is not computational but
conceptual. Pseudospectral algorithms are simply N-th order ﬁnite difference methods in
disguise.
1For Fourier and Chebyshev series, this transformation can alternatively be performed by using a Fast Fourier
Transform (FFT) routine.
98

5.2. WHITTAKER CARDINAL OR “SINC” FUNCTIONS
99
5.2
Whittaker Cardinal or “Sinc” Functions
Sir Edmund Whittaker (1915) showed that for an inﬁnite interval, the analogues to the
“fundamental polynomials of Lagrangian interpolation” are what he called the “cardinal
functions”. The collocation points are evenly spaced:
xj ≡j h
j = 0, ±1, ±2, . . .
(5.1)
Whittaker’s cardinal functions are
Ck(x; h) ≡sin{π(x −kh)/h}
π (x −kh)/h
[“Whittaker Cardinal Functions”]
(5.2)
and have the property
Ck(xj; h) = δjk
(5.3)
One great simpliﬁcation is that, through a linear shift and rescaling of the argument, the
Whittaker cardinal functions can all be expressed in terms of a single, universal function
sinc(x) ≡sin(πx)
(πx)
(5.4)
The sine function in the numerator has zeros at all integral values of x, x = 0, ±1, ±2, etc.
However, the root at the origin is cancelled by the denominator factor of (πx). Near x = 0,
Taylor expansion of the sine gives
sinc(x)
≈
(πx) −(πx)3/6 + (πx)5/120 −. . .
πx
(5.5)
≈
1 −(πx)2
6
+ . . .
|x| ≪1
(5.6)
Eq. (5.6) shows that sinc(0) = 1 from which (5.3) follows. The sinc function is illustrated in
the upper left panel of Fig. 5.1.
The property that each cardinal function is non-zero at one and only one of the interpo-
lation points implies that for arbitrary f(x), the function deﬁned by
˜f(x) ≡
∞
X
j=−∞
f(xj) Cj(x)
(5.7)
interpolates f(x) at every point of the grid. However, this hardly guarantees a good ap-
proximation; recall the Runge phenomenon for polynomials. In Chapter 17, Sec. 3, how-
ever, we show that, for a sufﬁciently small grid spacing h and for a sufﬁciently large trun-
cation of the inﬁnite sum (5.7), the sinc series is an accurate approximation if f(x) decays
sufﬁciently fast as |x| →∞.
Because of this, Sir Edmund Whittaker described sinc(x) as “a function of royal blood in
the family of entire functions, whose distinguished properties separate it from its bourgeois
brethren.” Strong words indeed, but the sinc(x) function is not only successful, but also a
good deal simpler than a Chebyshev polynomial or a spherical harmonic. In the next two
sections, we shall see that Fourier and Chebyshev grids also have their “royal functions”.
The lack of boundaries on an inﬁnite interval makes the Whittaker cardinal function
the simplest case.

100
CHAPTER 5. CARDINAL FUNCTIONS
-2
0
2
0
0.5
1
sinc
-2
0
2
0
0.5
1
Trig.
-2
0
2
-0.04
-0.02
0
0.02
0.04
sinc - Trig
-2
0
2
-15
-10
-5
0
Polynomial
Cardinal Func.
Figure 5.1: a. The Whittaker cardinal function, sinc ([x −π]/h), with h = π/6.
b. [Upper Right] Trigonometric cardinal function associated with the same interpolation
point (x = π) and grid spacing (h = π/6) as in (a).
c. [Lower Left] Difference between the Whittaker cardinal function (graphed upper left)
and the trigonometric cardinal function (graphed upper right)
d. Polynomial cardinal function associated with interpolation at x = π and evenly spaced
grid points, same as for the three other panels. Because of the large “wings” of this func-
tion, the value of f(x) at x = π has a greater effect on the interpolant in the remote region
near the endpoints (x = 0, 2π) than in the local neighborhood around x = π.
5.3
Cardinal Functions for Trigonometric Interpolation
Gottlieb, Hussaini, and Orszag (1984) show that for the collocation points
xj = 2 π j
N
;
j = 0, 1, . . . , N −1,
(5.8)
the trigonometric interpolant to f(x) can be written as
f(x) ≈
N−1
X
j=0
f(xj) Cj(x)
(5.9)

5.3. TRIGONOMETRIC INTERPOLATION
101
Figure 5.2: Schematic of a spatially periodic interval with nodes and a typical Fourier car-
dinal function.
where the cardinal functions are
Cj(x) ≡1
N sin
·N(x −xj)
2
¸
cot
·(x −xj)
2
¸
(5.10)
Just like the terms of the Whittaker sinc series, all the cardinal functions (5.10) are iden-
tical in shape, and differ only in the location of the peak. This shape similarity of all the
trigonometric cardinal functions, regardless of whether xj is in the middle or near the end-
points of [0, 2π], is a reminder that for periodic functions, there are in effect no endpoints. A
spatially-periodic interval can always be conceptualized as a ring, rather than a line seg-
ment (Fig. 5.2).
The same is emphatically not true for polynomial interpolation of a non-periodic func-
tion. Elementary courses in numerical analysis stress that centered ﬁnite difference approxi-
mations are much more accurate than one-sided approximations. This implies that, all other
things being equal, Lagrangian interpolation will give much more accurate approxima-
tions to df/dx (and to f(x) itself) at the center of the interval than at the endpoints where
the approximation is completely one-sided. This is exactly what happens with an even grid
spacing in the Runge example — good accuracy near the center of the interval and diver-
gence in the regions of mostly one-sided approximations near the ends of the interval.
Chebyshev interpolation gives very uniform approximation over the whole interval [-1,
1] because it compensates for the one-sided approximation near the endpoints by increas-
ing the density of the grid near the endpoints. We have the symbolic relationship
(near x ≈±1) [Small h; One-Sided] ←→[Large h; Centered] (near x ≈0)

102
CHAPTER 5. CARDINAL FUNCTIONS
For periodic functions with a uniform grid, however, we have the accuracy of a fully-
centered approximation even at the endpoint x = 0. Although the grid point values to the
left of the origin (x ∈[−π, 0]) are outside the interval of approximation, they are equal to
the corresponding values of f(x) on x ∈[π, 2 π], which is part of our grid. Consequently,
the cardinal functions for trigonometric interpolation on an evenly spaced grid have the
same shape for each point on the grid. Because of this uniformity of shape, the accuracy of
the approximation is uniform over the whole interval.
An analytical way to show the close relationship between the trigonometric cardinal
functions and the sinc functions is to Taylor expand the cotangent in (5.10), which gives
Cj(x)
=
sin [N(x −xj)/2]
N(x −xj)/2
(
1 −[x −xj]2
12
+ O
¡
[x −xj]4¢
)
(5.11)
=
sinc
·N(x −xj)
2
¸ ½
1 −[x −xj]2
12
−[x −xj]4
720
+ . . .
¾
(5.12)
Near its peak, the trigonometric cardinal function is indistinguishable from Whittaker’s
cardinal function, and differences appear only on the fringes where Cj(x) has decayed to
a rather small amplitude. Fig. 5.1 illustrates the sinc function, the trigonometric cardinal
function, and (lower left) the small difference between them. The maximum pointwise
absolute error in the approximation
Cj(x) ≈sinc
·N(x −xj)
2
¸
(5.13)
is never worse than 0.05 even for N = 6; for larger N, the error falls as O(1/N). There
is clearly an intimate relationship between sinc series on x ∈[−∞, ∞] and trigonometric
interpolation on x ∈[0, 2π].
An analytical expression of this kinship is the identity:
C0(x; h)
≡
1
2 N sin(N x) cot( x / 2 )
(5.14)
=
∞
X
m=−∞
sinc
µx −2 π m
h
¶
In words, the trigonometric cardinal function is the result of duplicating an inﬁnite
number of copies of the sinc function, spacing them evenly over all space, and summing
as shown schematically in Fig. 5.3.
For comic relief, Fig. 5.1 [lower right] shows the graph of the cardinal function for
Lagrangian polynomial interpolation at the same grid points. The sinc function and the
trigonometric cardinal function both decay away from their peak so that f(xj) for some
particular j has a smaller and smaller inﬂuence as we move away from x = xj. In contrast,
the Lagrangian cardinal function is much larger near the endpoints than at x = π, the one
grid point where it differs from 0. The value of f(x) at that one point has a much larger
inﬂuence away from that point than in its neighborhood. This makes no sense at all and is
another manifestation of the Runge phenomenon.
The trigonometric cardinal function has the alternative complex representation
Cj(x) ≡1
N
N/2
X
k=−N/2
1
ck
exp[i k(x −xj)]
(5.15)
where ck = 1 except for k = ±N; c−N/2 = cN/2 = 2. Although the appearance of (5.15) is
wildly different from (5.10), the two deﬁnitions are in fact equivalent.

5.3. TRIGONOMETRIC INTERPOLATION
103
Figure 5.3: Top: the trigonometric cardinal function, shown over three periods. Bottom
three panels: three copies of the Whittaker cardinal function which are added, together
with similar copies spaced evenly over all space, to give the trigonometric cardinal function
shown at the top.
Since the approximation (5.9) is identical with the trigonometric interpolant SN(x), we
can use the cardinal functions directly to solve differential equations without explicitly using
the truncated Fourier series form at all. A linear differential equation Lu = f(x), becomes
the matrix problem
⃗⃗L ⃗u = ⃗f
(5.16)
where the matrix elements are given by
uj
≡
u (xj)
j = 0, 1, . . . , N −1
(5.17)
fi
≡
f(xi)
i = 0, 1, . . . , N −1
(5.18)
Lij
≡
[LCj(x)]|x=xi
i, j = 0, 1, . . . , N −1
(5.19)
Because the cardinal functions are so simple, it is easy to evaluate their derivatives.
Thus, introducing a generalization of the usual Kronecker δ-function notation as in Stenger

104
CHAPTER 5. CARDINAL FUNCTIONS
(1981), we ﬁnd
Cj(xi)
= δij
(5.20)
Cj,x(xi) ≡δ(1)
ij =



0
1
2(−1)i+j cot
h
(xi−xj)
2
i
i = j
i ̸= j
(5.21)
Cj,xx(xi) ≡δ(2)
ij =



−(2N2+1)
6
1
2
(−1)i+j+1
sin2[(xi−xj)/2]
i = j
i ̸= j
(5.22)
where δij is the usual Kronecker δ-function and where the subscript x denotes x-differentiation.
Thus, a general second order differential operator such as
L ≡a2(x) ∂
∂x2 + a1(x) ∂
∂x + a0(x)
(5.23)
is represented by a matrix ⃗⃗L whose elements are simply
Lij = a2(xi) δ(2)
ij + a1(xi) δ(1)
ij + a0(xi) δij
(5.24)
Non-periodic problems can always be transformed into a periodic problem on x ∈[0, π]
by the Chebyshev-to-Fourier mapping. Since we need only the cosine terms, rather than
a general Fourier basis, we can still apply (5.8) – (5.24) except that we drop all grid points
such that xj > π. The explicit boundary conditions
u(−1) = u(1) = 0
[“Dirichlet boundary conditions”]
(5.25)
become transformed into u(0) = u(π); we simply omit the cardinal functions corresponding
to those two points. (In the original non-periodic coordinate, these cardinal functions are
polynomials.)
Thus, in the cardinal function basis, it is just as easy to solve problems with Dirichlet
boundary conditions as to solve those with boundary conditions of periodicity. Unlike
the algorithm where the spectral coefﬁcients of the equivalent Chebyshev series are the
unknowns, it is not necessary to solve a matrix problem with two rows reserved to impose
(5.25) nor is it necessary to form new basis functions which are linear combinations of
Chebyshev polynomials. The cardinal function representation makes Dirichlet boundary
conditions a snap.2
Appendix F lists properties of trigonometric cardinal functions both for a general Fourier
series and for the special cases when the solution can be expanded in a Fourier cosine series
or a Fourier sine series. The only complication with the two special cases is that the deriva-
tive of a cosine series is a sine series, so the matrix of the second derivatives of the cosines at
the grid points is the product of the ﬁrst derivative sine matrix with the ﬁrst derivative co-
sine matrix. Assembling the differentiation matrices to all orders is quite trivial, however,
as long as this is kept in mind.
5.4
Cardinal Functions for Orthogonal Polynomials
It is quite easy to construct cardinal functions for general orthogonal polynomials. Recall
that the grid points are the zeros of φN+1(x). Thus, φN+1(x) is similar to what we need
2Neuman boundary conditions, that is to say, conditions on the derivative of u at the boundaries, require re-
serving two rows of the matrix for these conditions using the δ(1)
ij
matrix elements. The cardinal function repre-
sentation, however, is still just as easy to use as the truncated Chebyshev series.

5.4. CARDINAL FUNCTIONS FOR ORTHOGONAL POLYNOMIALS
105
except that it vanishes at all the grid points, and we want it to differ from 0 at x = xj. In
the vicinity of the j-th root, Taylor expansion gives
φN+1(x) ≈φN+1(xj) + φN+1,x(xj)(x −xj) + O
³
[x −xj]2´
(5.26)
Since the ﬁrst term on the right in (5.26) is 0, one can eliminate the root at x = xj and
normalize the value of the cardinal function to 1 at x = xj by deﬁning
Cj(x) ≡
φN+1(x)
φN+1,x(xj)(x −xj)
[Cardinal Function]
(5.27)
where subscript x denotes x-differentiation. This prescription works for Chebyshev poly-
nomials of the ﬁrst and second kinds, Legendre polynomials, Laguerre functions, Hermite
functions, etc.
As noted in Chapter 4, a useful alternative grid consists of the extrema of a basis function
together with the endpoints, the “Lobatto” grid. The cardinal functions for this are
Cj(x) ≡
(1 −x2) φN,x(x)
[(1 −x2
j) φN,x(xj)]x(x −xj)
j = 0, . . . , N
(5.28)
where we have assumed that the endpoints are at x = ±1. As in (5.26), the numerator is a
function of x while, except for the linear factor of (x −xj), all the terms in the denominator
C8
C7
C6
C5
Figure 5.4: Cardinal functions for the Legendre pseudospectral method on an 8-point Lo-
batto grid. The grid point associated with each cardinal function is solid; the other grid
points are marked by open circles. Only the cardinal functions associated with positive x
are shown since those for negative x are just the reﬂections of those illustrated.

106
CHAPTER 5. CARDINAL FUNCTIONS
Evenly Spaced
Legendre-Lobatto
Figure 5.5: Relationship between the evenly spaced grid and the endpoint-concentrated
Legendre-Lobatto grid. The points of both grids are marked by circles. The Legendre-
Lobatto grid is at the top.
are constants. It is often possible to simplify (5.28) so as to eliminate the second derivative
by using the differential equation which the orthogonal polynomials satisfy.
The shape of polynomial cardinal functions is very similar to that of their trigonometric
counterparts. The Chebyshev cardinal functions are in fact identical with the cosine car-
dinal functions except for the change of coordinate. This mapping causes the Chebyshev
cardinal functions to oscillate very rapidly near the endpoints and slowly near the center.
The cardinal functions for Gegenbauer polynomials of higher degree, such as the Legendre
polynomials PN(x), are qualitatively similar except that the interpolation points are a little
closer to the center of the interval, so the oscillations near the endpoints are larger than for
Chebyshev functions.
Our description of polynomial cardinal functions is brief because they can be used ex-
actly like their trigonometric counterparts. In particular, Dirichlet boundary conditions are
very easy to impose if the “extrema-plus-endpoints” (“Gauss-Lobatto”) grid is used, as in
(5.28), which is why this choice of interpolation points has become very popular.
The differentiation matrices for Chebyshev and Legendre cardinal functions, analogous
to δ(k)
ij
of the previous section, are given in Gottlieb, Hussaini, and Orszag (1984) and Ap-
pendix F.
Fig. 5.4 illustrates the cardinal functions for a low order Legendre discretization on the
Lobatto grid, a typical choice for spectral elements and h −p-ﬁnite elements. The wild
oscillations of power-of-x, non-trigonometric polynomials on an evenly spaced grid are
suppressed because, as illustrated in Fig. 5.5, the pseudospectral grid is not evenly spaced,
but has points concentrated near both endpoints.

5.5. TRANSFORMATIONS AND INTERPOLATION
107
5.5
Transformations and Interpolation
It is possible to apply the pseudospectral method using either the grid point values {u(xi)}
or the series coefﬁcients {an} as the unknowns. The relationship between the two for-
malisms is important because efﬁcient algorithms for nonlinear problems must jump back
and forth between the grid point representation and the truncated series.
For simplicity, assume that L u = f is a linear equation. Let the pseudospectral-generated
matrix problems take the equivalent forms
⃗⃗L ⃗u
=
⃗f
[grid point/cardinal function form]
(5.29)
⃗⃗H⃗a
=
⃗f
[series coefﬁcient form]
(5.30)
where the matrix elements of ⃗a are the coefﬁcients in the truncated sum
u(x) ≈
N
X
n=0
an φn(x)
(5.31)
and where the other matrix elements are given by
ui
≡
u(xi)
(5.32)
fi
≡
f(xi)
(5.33)
Lij
≡
(LCj[x])|x=xi
(5.34)
Hij
≡
(Lφj[x])|x=xi
(5.35)
where the {xi} are the interpolation points, the {φj(x)} are the spectral basis functions, and
the {Cj(x)} are the cardinal functions.
The coefﬁcients {an} and the grid point values are related through the following equa-
tion from Chapter 4, which we repeat:
⃗⃗M ⃗u = ⃗a
(5.36)
where the elements of ⃗⃗M are
Mij ≡φi (xj) wj
(φi, φi)
[transformation matrix u(xj) →ai]
(5.37)
where the {wj} are the Gaussian quadrature weights and where (φi, φi) denotes the inner
product of the i-th basis function with itself (Appendix A).
Comparing (5.36) with (5.29) and (5.30), we see that
⃗⃗L
=
⃗⃗H ⃗⃗M
(5.38)
⃗⃗H
=
⃗⃗L
⃗⃗
M−1
(5.39)
Thus, we can use the gridpoints as unknowns even if we only have subroutines to compute
the basis functions {φj(x)}, and don’t want the bother of writing codes to evaluate the
cardinal functions. We simply set up the matrix ⃗⃗H and then multiply it on the right by ⃗⃗M
to obtain ⃗⃗L. Conversely, we can convert from a cardinal function representation to a form
that uses the series coefﬁcients as the unknowns by multiplying the matrix ⃗⃗L by
⃗⃗
M−1. It is
not necessary to invert ⃗⃗M via Gaussian elimination because
⃗⃗
M−1 satisﬁes the equation
⃗u =
⃗⃗
M−1⃗a
(5.40)

108
CHAPTER 5. CARDINAL FUNCTIONS
This shows that the inverse transformation matrix has elements given by
M −1
ij
≡φj(xi)
[inverse transformation aj →u(xi)]
(5.41)
i. e.
⃗⃗
M−1 is simply the matrix that sums the spectral series to obtain grid point values of
the solution.
Consequently, we can move freely back and forth from one representation to another
merely by multiplying one square matrix by another. Such transformations-by-matrix are
dubbed, in both directions, the Matrix Multiplication Transform (MMT) and are discussed
further in Chapter 10, Sec. 4. Unfortunately, shift-of-representation is a relatively expensive
calculation: O(N 3) to calculate ⃗⃗L from ⃗⃗H or vice versa, and O(N 2) merely to calculate ⃗u
from ⃗a or the reverse.
For the special case of Fourier series and its clone, the Chebyshev expansion, the work
can be reduced by using the Fast Fourier Transform (FFT) discussed in Chapter 10.

Chapter 6
Pseudospectral Methods for
Boundary Value Problems
“One must watch the convergence of a numerical code as carefully as a father watching his
four year old play near a busy road.”
— J. P. Boyd
6.1
Introduction
The goal of this chapter is to apply what we have learned in the previous ﬁve chapters
to solving boundary value problems. Time-dependent equations require additional tech-
niques developed later. There will be some repetition, with ampliﬁcation, of key ideas
already presented.
It is sufﬁcient to restrict ourselves to linear boundary value equations. Nonlinear prob-
lems are usually solved through an iteration, the so-called Newton-Kantorovich method,
in which a linear differential equation is solved at each step (Appendices C and D).
6.2
Choice of Basis Set
Table A–1 is a ﬂow chart for choosing the basis set. On a sphere, use spherical harmonics
for latitude and longitude. If the solution is periodic, use Fourier series. If the domain
is ﬁnite, but u(x) is not a periodic function of x, Chebyshev polynomials are best. If the
interval is unbounded, i. e., one or both endpoints are at |x| = ∞, then use the appropriate
species of rational Chebyshev functions (TLn(x) or TBn(x)) (Chapter 17).
6.3
Boundary Conditions: Behavioral & Numerical
Boundary conditions may be divided into two broad categories: behavioral and numerical.
Periodicity is a behavioral condition: it demands that the solution u(x) have the property
that u(x) = u(x + 2 π) for any x, but this behavior does not impose any speciﬁc numerical
value upon u(x) or its derivatives at any particular point. Another behavioral condition is
109

110
CHAPTER 6. PSEUDOSPECTRAL METHODS FOR BVPS
that of being bounded and inﬁnitely differentiable at a point where the differential equation
is singular. In contrast, conditions such as u(−1) = 3 and u(1) + du/dx(0) = 1.7 are
numerical.
The signiﬁcance of these categories is that it is almost always necessary to explicitly im-
pose numerical boundary conditions. In contrast, behavioral conditions may be satisﬁed
implicitly by choosing basis functions such that each have the required property or behav-
ior.
For example, when the boundary conditions are that u(x) is periodic in x, then the ap-
propriate basis functions are the sines and cosines of a Fourier series. Since each basis
function is itself periodic, their sum will be periodic, too. Consequently, it is unnecessary
to explicitly impose periodicity on the numerical solution. Our choice of basis function has
implicitly satisﬁed the boundary conditions.
Similarly, the two-dimensional basis functions known as “spherical harmonics” auto-
matically have the proper behavior on the surface of a sphere. It is never necessary to
impose additional explicit constraints after choosing spherical harmonics to represent the
latitude/longitude dependence of functions in spherical coordinates.
When the problem is posed on an unbounded interval, the coefﬁcients of the equation
are usually singular at the inﬁnite endpoint or endpoints. As explained Chapter 17 on
inﬁnite interval problems, this usually implies that only one of the linearly independent
solutions of the differential equation is bounded and inﬁnitely differentiable at the end-
points. By choosing a basis of analytic functions, we force the numerical approximation
to have the desired behavior at inﬁnity. On a doubly inﬁnite interval, x ∈[−∞, ∞], the
rational Chebyshev functions TBn(x) are a good basis. If, for example, the exact solution
decays exponentially fast as |x| →∞, the differential equation will then force the numer-
ical solution to have the proper exponential decay even though the individual TBn(x) do
not decay at all!
Behavioral boundary conditions are possible on a bounded interval, too. The differen-
tial equation
(1 −x2) uxx −x ux + λ u(x) = 0
x ∈[−1, 1]
(6.1)
is singular at both endpoints. Nonetheless, u(x) may be nonsingular at x = ±1 if the eigen-
value λ is equal to any one of an inﬁnite number of discrete values. Because the Chebyshev
polynomials are individually analytic at the endpoints, their sum satisﬁes the behavioral
boundary condition of analyticity at x = ±1. Consequently, it is possible to solve this
singular differential equation, with an exponential rate of convergence, merely by substi-
tuting unmodiﬁed Chebyshev polynomials into (6.1) without any explicit constraints. In
fact, with λn = n2, the eigenfunctions of (6.1) are the Chebyshev polynomials Tn(x).
Numerical boundary conditions, in contrast, must be explicitly imposed. There are
two strategies: (i) reducing the number of collocation conditions on the residual of the
differential equation, and using rows of the pseudospectral matrix to explicitly impose the
constraint or (ii) modifying the problem (if need be) so that the boundary conditions of the
modiﬁed problem are homogeneous and then altering the basis set so that the basis functions
individually satisfy these conditions. We will refer to these two strategies as “boundary-
bordering” and “basis recombination”, respectively, and discuss them at length in the next
two sections.
In ﬁnite element theory, boundary conditions are classiﬁed as either “essential”, which
must be explicitly imposed, or “natural” conditions, which are automatically satisﬁed by
the approximate solution. This dual classiﬁcation is not quite the same as the division be-
tween “behavioral” and “numerical” conditions discussed here because in most instances,
both “essential” and “natural” conditions are numerical and the distinction is only be-
tween whether u(x) or its derivative is set equal to a particular number at the endpoints.

6.4. “BOUNDARY-BORDERING”
111
Nevertheless, from a programmer’s standpoint, this duality is the same: “behavioral” and
“natural” conditions can be ignored in the code whereas “numerical” and “essential” con-
ditions require work. It is for this reason that Boyd (1978b, 1987a, b) borrowed the ﬁnite
element terminology: for global expansion methods, “numerical” boundary conditions are
most deﬁnitely “essential”!
6.4
“Boundary-Bordering” for “Numerical” Boundary Con-
ditions
To generate a “boundary-bordered” pseudospectral matrix of dimension N for a second
order ordinary differential equation boundary value problem, we demand that the resid-
ual of the differential equation should vanish at (N −2) interpolation points on the interior
of the interval, and then allocate the top two rows of the matrix to impose the boundary
conditions. The reason for the name “boundary-bordering” is that the “border” of the ma-
trix — in this case, the ﬁrst and second rows — explicitly enforces the boundary conditions.
For example, suppose the problem is
uxx + q(x) u = f(x)
&
ux(−1) = α
and
u(1) = β
(6.2)
The Chebyshev grid is
xi = cos
µ
π i
N −1
¶
i = 1, 2, . . . , (N −2)
(6.3)
The matrix discretization of (6.2) is
⃗⃗L⃗a = ⃗F
(6.4)
where the elements of the column vector ⃗a are the Chebyshev coefﬁcients of u(x),
u(x) ≈
N
X
j=1
aj Tj−1(x)
(6.5)
and where
Li+2, j =
Tj−1, xx(xi) + q(xi) Tj−1(xi)
i = 1, . . . , (N −2)
(6.6)
j = 1, . . . , N
Fi+2
=
f(xi)
i = 1, . . . , (N −2)
(6.7)
where Tj−1,xx denotes the second x-derivative of the (j−1)-st Chebyshev polynomial. The
top two rows of the matrix impose the boundary conditions:
L1, j = Tj−1, x(−1)
&
F1 = α
(6.8a)
L2, j = Tj−1(1)
&
F2 = β
(6.8b)
where j = 1, . . . , N and subscript x denotes differentiation with respect to x.
Eqs. (6.6) to (6.8) easily generalize. A fourth order differential equation, for example,
would require four boundary rows instead of two. A Dirichlet boundary condition on
u(−1) would simply replace the ﬁrst derivative of the Chebyshev polynomials by the poly-
nomials themselves in (6.8a). The non-boundary elements of the square matrix ⃗⃗L, given by

112
CHAPTER 6. PSEUDOSPECTRAL METHODS FOR BVPS
here by (6.7), are always the contribution of the j-th basis function to the residual of the
differential equation at the i-th interpolation point where j is the column index and (i + 2)
is the row index. There are some subtleties for partial differential equations which will be
discussed later in the chapter.
The “boundary-bordering” method is applicable to even the most bizarre boundary
conditions. For a given N, this approach does give a slightly larger matrix (dimension N
versus (N −2) for a second order ODE) in comparison to the basis recombination method,
but for large N, this is compensated by the higher cost of calculating the matrix elements
in the latter technique.
6.5
“Basis Recombination” and “Homogenization of Bound-
ary Conditions”
If the problem
L u = f
(6.9)
has inhomogeneous boundary conditions, then it may always be replaced by an equivalent
problem with homogeneous boundary conditions, so long as the boundary conditions are
linear. The ﬁrst step is to choose a simple function B(x) which satisﬁes the inhomogeneous
boundary conditions. One may then deﬁne a new variable v(x) and new forcing function
g(x) via
u(x)
≡
v(x) + B(x)
(6.10)
g(x)
≡
f(x) −L B(x)
(6.11)
so that the modiﬁed problem is
L v = g
(6.12)
where v(x) satisﬁes homogeneous boundary conditions. For simplicity, (6.11) and (6.12)
implicitly assume that L is a linear operator, but (6.10) and this technique for “homogeniz-
ing the boundary conditions” are applicable to nonlinear differential equations, too, if the
boundary conditions are linear.
The shift function B(x) is arbitrary except for the constraint that it must satisfy all the
inhomogeneous boundary conditions. However, the simplest choice is the best: polyno-
mial interpolation of the lowest order that works. For example, consider a two-point ODE
boundary value problem with the mixed conditions
ux(−1) = γ
&
du
dx(1) −u(1) = δ
(6.13)
Assume
B(x) = Λ + Ωx
(6.14)
and then choose the two undetermined coefﬁcients by demanding that B(x) satisfy the
boundary conditions. For example, in case (ii)
dB
dx (−1) = γ
↔
Ω= γ
dB
dx (1) −B(1) = δ
↔
Ω−(Λ + Ω) = δ
→Λ = −δ
(6.15)

6.5. “BASIS RECOMBINATION”
113
Once B(x) has been found and the problem transformed to the new unknown v(x), the
next step is to actually do “basis recombination”: Choosing simple linear combinations of
the original basis functions so that these combinations, the new basis functions, individu-
ally satisfy the homogeneous boundary conditions. For example, suppose that
v(−1) = v(1) = 0
(6.16)
The identity Tn(cos(t)) = cos(nt) for t = 0, π implies
T2n(±1) = 1
&
T2n+1(±1) = ±1
(6.17)
so a good choice of basis functions such that φn(±1) = 0 for all n is
φ2n(x) ≡T2n(x) −1
n = 1, 2, . . .
(6.18a)
φ2n+1(x) ≡T2n+1(x) −x
n = 1, 2, . . .
(6.18b)
Note the indices in (6.18): Because of the two boundary constraints, T0(≡1) and T1(≡x)
are no longer independent basis functions, but rather are determined by the coefﬁcients of
all the higher functions.
The collocation points are the same as for boundary bordering: the (N −2) interior
points of an N-point Gauss-Lobatto grid. The residual is not evaluated at the endpoints
because the boundary conditions are implicitly used at these points instead.
We write
v(x) ≈
N−1
X
n=2
bn φn(x)
(6.19)
If we deﬁne a column vector ⃗b of dimension (N −2) whose i-th element is bi−1, then the
differential equation becomes the matrix problem
⃗⃗H⃗b = ⃗⃗G
(6.20)
where
Hij ≡φj+1,xx(xi) + q(xi) φj+1(xi)
i, j = 1, . . . , N −2
(6.21)
where the double subscript x denotes double x-differentiation and
Gi ≡g(xi)
i = 1, 2, . . . , (N −2)
(6.22)
After solving (6.20) to compute the coefﬁcients of the φ-series for v(x), it is trivial to
convert the sum to an ordinary Chebyshev series
v(x) ≡
N−1
X
n=0
an Tn(x)
(6.23)
by noting
an = bn
n ≥2
(6.24)
a0 = −
(2n)≤(N−1)
X
n=1
b2n
&
a1 = −
(2n+1)≤(N−1)
X
n=1
b2n+1
(6.25)

114
CHAPTER 6. PSEUDOSPECTRAL METHODS FOR BVPS
By using the identity
dpTn
dxp
¯¯¯¯
x=±1
= (±1)n+p
p−1
Y
k=0
n2 −k2
2k + 1 ,
(6.26)
one can derive similar basis sets for other boundary conditions. As an illustration, we give
a set of functions that individually satisfy homogeneous Neuman conditions:
φ2n(x)
≡





1
T2n(x) −
·
n2
(n + 1)2
¸
T2n+2(x)
n = 0
n = 1, 2, . . .
{φn,x(±1) = 0}
(6.27)
φ2n+1(x)
≡
T2n+1(x) −
·2n + 1
2n + 3
¸2
T2n+3(x)
n = 0, 1, . . .
This method is superior to “boundary-bordering” for eigenvalue problems whose bound-
ary conditions do not involve the eigenvalue because “basis recombination” gives a spectral
matrix which contains the eigenvalue in every row, and therefore can be attacked with stan-
dard library software. “Boundary-bordering” would give two rows which do not contain
the eigenvalue, and this wrecks some library eigenvalue-solvers.
“Basis recombination” also gives a smaller matrix than boundary bordering: the dimen-
sion of ⃗H is only (N −2) although the ﬁnal answer (6.23) is the sum of the ﬁrst N Chebyshev
polynomials. In practice, because the matrix elements for the modiﬁed basis functions are
more complicated to compute than those involving the unmodiﬁed basis functions of the
“boundary-bordering” method, this advantage is non-existent except for very small N. (In
Chapter 20, we show that “basis recombination” is almost always the method of choice for
analytical, paper-and-pencil or algebraic manipulation language calculations.)
In the general case, the great advantage of “basis recombination” is conceptual sim-
plicity. After we have shifted to the modiﬁed basis set, we can thenceforth ignore the
boundary conditions and concentrate solely on the differential equation. The form of the
pseudospectral matrix is the same for numerical boundary conditions as for behavioral
boundary conditions: All the rows are derived from setting the residual of the differential
equation equal to zero at a given collocation point.
In many situations, the differences between basis recombination and boundary border-
ing have little practical signiﬁcance. Karageorghis (1993b) has discussed the relationship
between basis recombination and boundary bordering formulations for the pseudospectral
method in rectangles.
6.6
Basis Recombination for PDEs: Transﬁnite Interpola-
tion
For partial differential equations, the principles are quite similar. Suppose, for example,
that on the sides of the unit square [−1, 1] × [−1, 1], the boundary conditions are that
u(−1, y) = fW (y), u(1, y) = fE(y), u(x, −1) = fS(x), u(x, 1) = fN(x)
(6.28)
We assume that the boundary conditions are continuous around the wall so that fW (−1) =
fS(−1), or in other words that two boundary functions which share a corner give the

6.7. THE CARDINAL FUNCTION BASIS
115
same values at that corner. (This condition is necessary to avoid strong singularities in
the corners; the solution may be weakly singular at the corners even when the boundary
conditions are continuous.) Then the so-called “transﬁnite” interpolation formula gives a
quadratic polynomial in x and y which satisﬁes the boundary conditions:
B(x, y)
≡
1 −x
2
fW (y) + x + 1
2
fE(y) + 1 −y
2
fS(x) + y + 1
2
fN(x)
−(1 −x)(1 −y)
4
u(−1, −1) −(1 −x)(y + 1)
4
u(−1, 1)
−(x + 1)(1 −y)
4
u(1, −1) −(x + 1)(y + 1)
4
u(1, 1)
(6.29)
The linear terms (ﬁrst row) are the same as for two independent one-dimensional inter-
polation problems. The second and third rows of quadratic terms correct for “interference”
between the linear terms in the ﬁrst row. Along the eastern boundary x = 1, for example,
B(1, y)
=
fE(y) + 1 −y
2
fS(1) + y + 1
2
fN(1) −1 −y
2
u(1, −1) −y + 1
2
u(1, 1)
=
fE(y)
(6.30)
as desired because the assumption of continuity around the boundary implies that fS(1) =
u(1, −1) and fN(1) = u(1, 1).
Nakamura (1996) gives a good treatment of transﬁnite interpolation with additional
generalizations of the concept.
6.7
The Cardinal Function Basis
A cardinal function basis can always be used in place of the Chebyshev polynomials:
u(x) =
N
X
j=1
uj Cj(x)
(6.31)
where the cardinal functions, as in Chapter 5, are deﬁned by the requirement that Cj(xi) =
1 if i = j and 0 otherwise. The unknowns uj are now the values of u(x) at the interpolation
points, i. e., uj ≡u(xj).
The cardinal basis is very convenient with Dirichlet boundary conditions. With the
“extrema-plus-endpoints” grid, one may enforce the boundary conditions v(x1) = v(xN) =
0 merely by omitting the two cardinal functions corresponding to the endpoints, simplify-
ing (6.31) for the new unknown v(x) to
v(x) ≈
N−1
X
j=2
vj Cj(x)
(6.32)
If we deﬁne a column vector ⃗v of dimension (N −2) whose i-th element is vi−1, then the
differential equation becomes the matrix problem
⃗⃗H⃗v = ⃗⃗G
(6.33)
where
Hij ≡Cj+1, xx(xi+1) + q(xi+1) Cj+1(xi+1)
i, j = 1, . . . , N −2
(6.34)

116
CHAPTER 6. PSEUDOSPECTRAL METHODS FOR BVPS
where the double subscript x denotes double x-differentiation and the elements of ⃗⃗G are
g(xi) as in (6.22). The Gauss-Lobatto grid is:
xi = cos
·π(i −1)
N −1
¸
i = 2, . . . , N −1
(6.35)
What is most striking, however, is how little is changed by the shift from the polyno-
mial basis to the cardinal function basis. In particular, the unknowns are the coefﬁcients
of a spectral series (either polynomial or cardinal function), the matrix elements of ⃗H are
identical except for the replacement of one set of basis functions by another, and the the
column vector on the right-hand side is unchanged.
The truth is that if the basis functions individually satisfy the boundary conditions, the
abstract formalism — the formulas for the matrix elements — are independent of the basis
set. Only the numerical values of the matrix elements change when we replace Chebyshev
polynomials by Legendre polynomials, or Tj(x) by the corresponding cardinal function.
The matrix problem is always
⃗⃗H⃗a = ⃗⃗G
(6.36)
where
Gi
=
g(xi)
(6.37)
Hij
=
(L φj)|x=xi
(6.38)
where g(x) is the inhomogeneous term in the differential equation, L is the operator of the
differential equation, and the notation in (6.38) means the elements of ⃗H are the result of
applying the operator L to the j-th basis function and then evaluating the resulting residual
at the i-th grid point. The column vector⃗a contains the unknown coefﬁcients of the spectral
series. In the cardinal function basis, these coefﬁcients are also the grid point values of u(x).
6.8
The Interpolation Grid
As explained in Chapter 4, every standard basis function has one or two optimal grids
associated with it. The Fourier, Chebyshev, and rational Chebyshev grids are given by an-
alytical formulas involving nothing more exotic than trigonometric functions (Appendix
F). When a given basis function has two “good” grids, the choice between them is strictly
one of convenience. For Legendre polynomials, Hermite functions, Laguerre functions
and spherical harmonics, the grid points are not known in analytical closed form except
for small N. (The Legendre-Lobatto grid up to nine points are given by previously un-
published analytical formulas in Appendix F.) However, numerical tables for these points
are given in mathematical handbooks such as Abramowitz and Stegun (1965) and may be
calculated ab initio using the subroutines given in Canuto et al. (1988), Appendix C.
6.9
Computing the Basis Functions and Their Derivatives
All the standard basis functions without exception (including Fourier ) may be computed via
three-term recurrence relations as given in Appendix A. These recurrences may be evalu-
ated as a single DO loop. What could be simpler?
Of course, to solve differential equations we also need the derivatives of the functions.
However, the derivative of the n-th Hermite polynomial is proportional to the (n−1)-st

6.9. COMPUTING BASIS FUNCTIONS & DERIVATIVES
117
Hermite polynomial. The Chebyshev and Legendre polynomials belong to a family of
polynomials known as the “Gegenbauer polynomials”, which may be labelled by a pa-
rameter α. The derivative of any member of this family is another polynomial within the
family: n is reduced by one while α is increased by 1. It follows that one may always evalu-
ate the derivatives of Chebyshev and Legendre polynomials to arbitrary order by three-term
recurrence. All the needed formulas are in Appendix A.
Texts tend to discuss these recurrences as if they were the only option because for Leg-
endre, Hermite, Laguerre, and spherical harmonics, they are the only option. For those
basis sets which are a disguised Fourier series, i. e. Chebyshev polynomials and the ra-
tional Chebyshev functions for inﬁnite and semi-inﬁnite intervals, we may alternatively
compute the basis functions and their derivatives using trigonometric functions.
If x is the argument of the Chebyshev polynomials and t the argument of the trigono-
metric functions, then
x = cos(t) ←→t = arccos(x)
x ∈[−1, 1]
&
t ∈[0, π]
(6.39)
Tn(x) = cos(nt)
(6.40)
dTn
dx =
· −1
sin(t)
¸ d
dt[cos(nt)] = nsin(nt)
sin(t)
(6.41)
d2Tn
dx2 =
· −1
sin(t)
¸ d
dt
½· −1
sin(t)
¸ d
dt[cos(nt)]
¾
(6.42)
=
−n2
sin2(t) cos(nt) +
½n cos(t)
sin3(t)
¾
sin(nt)
(6.43)
and so on, repeatedly applying the elementary identity d/dx ↔[−1/ sin(t)]d/dt when x
and t are connected via (6.39). The strategy for the rational Chebyshev functions is similar;
such change-of-coordinate tricks are so useful that we will devote a whole chapter to the
subject.
The ﬁrst table of Chapter 16 on coordinate-transformation methods gives a FORTRAN
routine for computing Tn(x) and its ﬁrst four derivatives. It contains only 11 executable
statements. All the details of the change-of-coordinate are buried in this subroutine; the
calling program is blissfully ignorant.
There is one minor complication: the derivative formulas have numerators and de-
nominators that are singular as t →0, π, which correspond to x →±1. Analytically, these
formulas have ﬁnite limits that can be derived by l’Hopital’s rule, which is simply the Tay-
lor expansion of both numerator and denominator about their common zero, but blind
numerical application of (6.40) and (6.42) will give overﬂow. In practice, this is no difﬁ-
culty because (6.26) is a simple analytical expression for the exact endpoint derivatives of
the p-th derivative of Tn(x) for arbitrary p. Consequently, we may avoid overﬂow merely
by adding an IF statement to switch to the boundary derivative formula at the endpoints.
After using recurrences early in my career (Boyd, 1978a) and trigonometric derivative
formulas in recent years, I personally ﬁnd the latter are simpler. However, the choice is
mostly a matter of habit and preference. The trigonometric method requires fewer loops,
but demands the evaluation of transcendentals; however, the cost of evaluating the basis
functions is usually a negligible fraction of total running time. The trigonometric formu-
las become less accurate near the boundaries because both numerator and denominator
are tending to 0, especially for the higher derivatives, but the derivative (Gegenbauer) re-
currences are mildly unstable, especially for the higher derivatives. In spite of these mild
deﬁciencies, however, both approaches are usually accurate to within one or two digits
of machine precision for ﬁrst and second order derivatives. Schultz, Lee and Boyd(1989)
show that the trigonometric form is a little more accurate than recurrence.

118
CHAPTER 6. PSEUDOSPECTRAL METHODS FOR BVPS
Both because it is my personal preference and also because this method has been largely
ignored in the literature, trigonometric derivative formulas are used in the sample program
at the end of the chapter.
It is most efﬁcient to write a single subroutine that will return arrays containing the
values of all N polynomials and their derivatives at a single point; this simultaneous com-
putation reduces the number of subroutine calls.
To implement basis recombination, it is easy to appropriately modify the basis-computing
subroutine. Spectral methods lend themselves well to “data-encapsulation”: the main pro-
gram never needs to know even the identity of the basis set — only that there is a subrou-
tine BASIS that can be called to return arrays with the values of the basis functions at a
given x.
In the cardinal basis, the trigonometric formulas are unnecessary. Analytical formulas
for derivatives at the grid points for the standard Fourier, Legendre and Chebyshev cardi-
nal functions are given in Appendix F.
6.10
Special Problems of Higher Dimensions: Indexing
To solve a boundary value problem in two dimensions, it is most efﬁcient to use a tensor
product basis, that is, choose basis functions that are products of one-dimensional basis
functions. Thus, on the unit square [−1, 1] × [−1, 1],
Φmn(x, y) ≡φm(x) φn(y)
m = 1, . . . , Nx & n = 1, . . . , Ny
(6.44)
As in one dimension, one may apply either “boundary-bordering” or “basis recombina-
tion” to deal with the boundary conditions. Similarly, the interpolation grid is a tensor
product, the Nx Ny points
⃗x ≡(xi, yj)
i = 1, . . . , Nx & j = 1, . . . , Ny
(6.45)
One complication is that the grid points, the basis functions, and the coefﬁcients of the
spectral series now require two indices. The rules of matrix algebra, however, allow only
one index for a vector and two for a square matrix, not four (i, j, m, n). The simplest
remedy is to write a short subroutine to perform the preprocessing step of collapsing two
indices into one and vice versa.
Thus, let ix and iy denote one-dimensional indices and let I vary over the range 1, 2, . . . , Nx Ny.
Let x(ix) and y(iy) denote functions that compute the points on the one-dimensional grids.
Then trace the double loop
I = 0
for ix = 1 to Nx, for iy = 1 to Ny
I = I + 1
XA(I) = x(ix),
YA(I) = y(iy)
MA(I) = ix,
NA(I) = iy
IA(MA(I),NA(I)) = I
end loops
For example, suppose Nx = Ny = 10. The loop will then compute four one-dimensional
arrays which each contain 100 elements. Each value of the “collapsed” index I speciﬁes
a unique point on the two-dimensional grid, and also a unique, two-dimensional basis
function. When we compute the 100 × 100 pseudospectral matrix, the 70th row of the
matrix is determined by evaluating the residual of the differential equation at the 70th
grid point. What are the x and y values of that grid point? XA(70) and YA(70), respectively.

6.10. HIGHER DIMENSIONS: INDEXING
119
Similarly, the 31-st column of the square matrix is the contribution of the 31-st basis function
to the differential equation residual at all the points on the grid. MA(31) and NA(31) give
us the subscripts (m, n) in (6.44) so that we can compute this basis function. In symbols,
⃗xI ≡(XA(I), Y A(I))
(6.46)
I = 1, . . . , Nx · Ny
ΦI(x, y) ≡φMA(I)(x) φNA(I)(y)
(6.47)
Thus, the four one-dimensional arrays associate a single index I with pairs of one-dimensional
indices of smaller range. The two-dimensional array IA is used to go in the opposite direc-
tion: to compute I given (m, n). This is useful in printing a table of the spectral coefﬁcients
as functions of m and n.
As discussed in Chapter 8, it is often possible to greatly reduce the work by exploit-
ing the symmetries of the problem. In higher spatial dimensions, these can become rather
complicated. Boyd (1986c) describes an eigenvalue problem with an eight-fold symmetry.
One may reduce the size of the basis by this same factor of eight by choosing a new basis,
formed from linear combinations of Chebyshev polynomials, which all possess the same
eight-fold symmetry as the solution. However, the symmetry-respecting basis is no longer
a simple tensor product basis.
Another motive for rejecting a tensor product basis is to apply a “circular” rather than
“rectangular” truncation. It is a little inconsistent to retain basis functions such as φ10(x) φ10(y)
while omitting functions such as φ11(x) φ0(y) because the latter is actually smoother than
the former. If we were using complex Fourier terms as the building blocks of our basis,
then exp(i[10x + 10y]) has a much larger total wavenumber than a deleted term such as
exp(i 11 x) where the total wavenumber of exp(imx + iny) is k ≡
√
m2 + n2. For this rea-
son, many prefer the “circular” truncation,
p
m2 + n2 ≤Nx
[“circular”]
(6.48)
instead of the simpler “rectangular” truncation, which keeps all basis functions whose one-
dimensional indices satisfy the inequalities
m ≤Nx
&
n ≤Ny
[“rectangular”]
(6.49)
As one might imagine, symmetry-modiﬁed basis sets and circular truncation generate a
complicated relationship between the one-dimensional indices (m, n) and the “collapsed”
index I. However, the double loop strategy makes it quite unnecessary to have an analytical
relationship between indices. It is merely necessary to insert the proper IF statements into
the preprocessing double LOOP (to skip the assignment statements if
p
ix2 + iy2 > Nx,
for example). The rest of the program — everything outside this preprocessing subroutine
and the code that computes the basis functions — is shielded from the complexities of the
modiﬁed basis set. The basis function subroutine never performs any index calculations;
given I, it reads the necessary values of (m, n) from the arrays MA(I) and NA(I).
It may seem silly to discuss such a humble matter as indexing in such detail, but the
philosophy of this book is ruthlessly practical. The reason that a multi-dimensional BVP
solver may take weeks or months to develop is not because of the intricacies of Sobolev
spaces, but because of the care and fussing that is needed to correctly use the !*#$%& [ex-
pletive deleted] matrix indices.

120
CHAPTER 6. PSEUDOSPECTRAL METHODS FOR BVPS
6.11
Special Problems of Higher Dimensions: Boundary Con-
ditions, Singular Matrices, and Over-Determined Sys-
tems
In two dimensions, a singular pseudospectral matrix seems to be a common experience.
Part of the problem is boundary conditions: the four corner points are each a part of two
different walls. Thus, imposing the condition that u = 0 at each of the Nx grid points
on the top and bottom walls and each of the Ny grid points on the sides does not lead to
(2 Nx + 2 Ny) independent conditions; the corners are counted twice. A similar problem
exists even for non-interpolating algorithms as shown by Eq. (14.8) of Gottlieb and Orszag
(1977).
Another difﬁculty, especially when using a symmetry-modiﬁed basis or a “circular”
truncation, is that some of the basis functions may lose linear independence on the grid.
(Note that circular truncation requires reducing the number of grid points to match the
reduction in the number of basis functions.) For example, T4(x) can be exactly interpolated
by basis functions of lower degree on a grid that contains only four points. In one dimen-
sion, it is easy to avoid such absurdities; with complicated basis sets in higher dimensions,
it may be quite difﬁcult (Haupt and Boyd, 1988). (A Galerkin method, with numerical
quadrature for the integrals, will solve these difﬁculties because one can use a rectangu-
larly truncated quadrature grid even if the basis set itself has a circular truncation.)
Schultz, Lee and Boyd (1989), who obtained a singular pseudospectral matrix in at-
tempting to solve the fourth order, two-dimensional partial differential equation for Stokes’
ﬂow in a box, evaded this problem by computing a least squares answer to the over-
determined linear algebra system.
Indeed, experience has shown that large pseudospectral matrices are often mildly ill-
conditioned even if non-singular. Fourteen decimal place precision or better is recom-
mended, but occasionally this is not enough. (Increasing N and also increasing order of
derivatives both amplify roundoff problems.) The Householder method, alias “QR” fac-
torization, has lower round-off error than Gaussian elimination, and thus may be a helpful
option for solving high order differential equations even if the pseudospectral matrix is
not over-determined. Numerical checks described in Lee, Schultz and Boyd (1989b) show
that the solution to the over-determined system has all the desirable properties of spectral
solutions: very rapid convergence and extremely high accuracy for moderate cost.
Thus, redundant boundary conditions, loss of linear independence on the grid, and
the weak ill-conditioning of very large pseudospectral systems are all difﬁculties that are
almost trivially removed. It is essential, however, that the reader be prepared for these
problems; the alternative is despair and cursing when a Gaussian elimination subroutine
bombs out with the error message: SINGULAR MATRIX.
6.12
Special Problems in Higher Dimensions: Corner Sin-
gularities
When the walls of a computational domain meet at a sharp angle — the corners of a rectan-
gle or a triangle as opposed to the ever-smooth walls of a circle — the solution to a partial
differential equation will almost invariably be singular at the corner. The classic example
is Poisson’s equation △u = −1 on the unit square with the boundary conditions that u = 0
on all four walls. Even though the boundary conditions are continuous, the coefﬁcients of
the differential equation and the forcing are constant, and the equation is linear, the solu-
tion is weakly singular. If we deﬁne a local polar coordinate system centered on one of the

6.13. MATRIX METHODS
121
corners, then the most strongly singular term is of the form
r2 log(r) sin(2θ)
(6.50)
This geometrical difﬁculty occurs only at sharp corners and has no one-dimensional coun-
terpart. If we “round” the corners even a little, then u(x, y) is smooth everywhere within
the domain including the boundaries. In the absence of rounding, however, the corner
singularities will dominate the asymptotic behavior of the Chebyshev coefﬁcients for sufﬁ-
ciently large (m, n), and the convergence will be algebraic rather than exponential.
However, articles such as Boyd (1986c) and Schultz, Lee and Boyd (1989) have already
shown that for relatively weak singularities like that in (6.50), the corner branch points
may be irrelevant unless one is interested in very high accuracy (greater than ﬁve decimal
places). Note that the function in (6.50) is everywhere bounded; only its higher derivatives
are inﬁnite at r = 0, and it is in this sense that the singularity is “weak”.
For stronger singularities, such as cracks in a solid material or obtuse angles such as
that in the oft-studied “L-shaped domain eigenvalue problem”, one needs special methods
and tricks. Changes-of-coordinate and “singularity-subtraction” are explained in Chapter
16 and “global sectorial elements” in Chapter 22. The generic recommendation is to ignore
the singularities unless either (i) one has prior knowledge that u(x, y) is discontinuous or
has other strongly pathological behavior or (ii) poor convergence and rapid variation of
the numerical solution near the corners suggests a posteriori that the solution is strongly
singular.
The vagueness of this advice is unsatisfactory. However, it is a fact of life that shock
waves and other types of discontinuities always require special treatment whether the ba-
sic algorithm is spectral, ﬁnite difference, or ﬁnite element. If the solution is sufﬁciently
well-behaved so that it can be computed by ﬁnite differences without tricks, then it can be
computed by unmodiﬁed spectral methods, too, even with corners.
6.13
Matrix methods
Because inverting the (dense) pseudospectral matrix is usually the rate-determining step,
we devote a whole chapter (Chapter 15) to good strategies for this. A couple of preliminary
remarks are in order.
First, if the total number of basis functions is small (N < 200), use Gaussian elimination.
The LU factorization of a 100 × 100 matrix requires less than a third of a second on a
personal computer with a megaﬂop or better execution rate, so there is no excuse for being
fancy. Even Boyd (1986c), which solves a two-dimensional nonlinear problem with 200
basis functions, used Gaussian elimination on a lowly IBM AT. For over-determined or
ill-conditioned systems, a QR factorization should be used instead.
For large, multi-dimensional problems, Gaussian elimination may be too expensive. In
this case, the iterations and multi-grid strategies described in Chapter 15 are very impor-
tant, perhaps essential. They are almost never justiﬁed for one-dimensional problems. No
one is awarded style points in numerical analysis: Keep-It-Simple,Stupid and use direct,
non-iterative Gaussian elimination or Householder’s method whenever possible.
6.14
Checking
The most reliable way to verify the correctness of a spectral code is to evaluate the residual
by an independent algorithm. The recommendation is to use ﬁnite differences with a very
small grid spacing h. Observe that since the pseudospectral approximation uN(x) is a

122
CHAPTER 6. PSEUDOSPECTRAL METHODS FOR BVPS
series expansion, we can evaluate it and its derivatives for arbitrary x, not merely at values
of x on the pseudospectral interpolation grid.
Thus, to verify that uN(x) is a good approximation to the solution to uxx+q(x)u = f(x),
evaluate
Rfd(x) ≡[uN(x + h) −2 uN (x) + uN(x −h)]
h2
+ q(x) uN(x) −f(x)
(6.51)
where h ∼O(1/1000). The ﬁnite difference residual should be small over the whole com-
putational interval, and especially small [equal to the ﬁnite differencing error] at the N
points of the pseudospectral grid.
There is one mild caveat: for high order differential equations, the residual may be
O(1) even when uN(x) is a terriﬁcally good approximation to u(x). For example, suppose
a differential equation of sixth order has an exact solution which is a trigonometric cosine
polynomial of degree 30. Suppose that the pseudospectral method exactly computes all of
the Fourier coefﬁcients except for a30, which is in error by 1×10−6 because of roundoff. The
maximum pointwise error of the approximation to u(x) is everywhere less than or equal to
1 × 10−6 [recall that all cosines are bounded by 1]. However, the sixth derivative of u30(x)
multiplies each coefﬁcient of u30(x) by n6. The error in u30,xxxxxx(x) is 306 × 10−6 = 729!
The residual will be large compared to one even though the pseudospectral solution is
terriﬁcally accurate.
It follows that calculating the residual of a numerical approximation is a very conser-
vative way to estimate its error. By “conservative”, we mean that the error in uN(x) will
usually be much smaller than the residual. If k is the order of the differential equation,
then Rfd(x) is typically O(N k) [Fourier] or O(N 2k) [Chebyshev] times the error in uN(x)
(Boyd, 1990c).
To verify the adequacy of a given truncation N, i. e. to estimate the error in u(x), there
are two good tactics. The reliable-but-slow method is to repeat the calculation with a differ-
ent value of N. The error in the run with larger N is smaller (probably much smaller) than
the difference between the two computations. The quick-and-dirty method is to simply
make a log-linear plot of |an| versus n. The error will be roughly the order of magnitude
of the highest computed Chebyshev coefﬁcient (or the magnitude of the “envelope” of the
coefﬁcients (Chapter 2) at n = N, if the an oscillate with n as they decay).
Deﬁnition 16 (IDIOT) Anyone who publishes a calculation without checking it against an iden-
tical computation with smaller N OR without evaluating the residual of the pseudospectral approx-
imation via ﬁnite differences is an IDIOT.
The author’s apologies to those who are annoyed at being told the obvious. However,
I have spent an amazing amount of time persuading students to avoid the sins in this
deﬁnition.
Gresho et al.(1993) describe an embarrassment in the published literature. The ﬂow
over a backward-facing step was used as a benchmark for intercomparison of codes at
a 1991 minisymposium. Except for the spectral element code, all programs gave steady,
stable ﬂow . Despite the disagreement, the spectral element team published their unsteady,
ﬂuctuating solutions anyway in the Journal of Fluid Mechanics. This prompted the Gresho et
al.(1993) team to reexamine the problem with multiple algorithms at very high resolution.
They found that spectral elements did indeed give unsteady ﬂow when the number of
elements was small and the degree N of the polynomials in each element was moderate.
However, when the resolution was increased beyond that of the Journal of Fluid Mechanics
paper, either by using more subdomains or very high N within each subdomain, the ﬂow

6.15. SUMMARY
123
Table 6.1: Checking Strategies
1. Geometric decrease of coefﬁcients an with n. (least reliable)
2. Finite difference residual (most conservative)
3. Varying the truncation N
became steady and in good agreement with the other ﬁnite difference and ﬁnite element
simulations. It is easy for even experienced and knowledgeable people to be fooled!
One must watch the convergence of a numerical code as carefully as a father watching
his four year old play close to a busy road.
The quick-and-not-so reliable tactic for estimating error is to simply look at the rate of
decrease of the spectral coefﬁcients (for a non-cardinal basis). If aN is only 10 or 100 times
smaller than a0, then the calculation is certainly accurate to no more than 1 decimal place
and may be completely in error. On the other hand, if aN is O(10−8)a0, then the solution is
probably accurate to many decimal places.
One must be cautious, however, because this is an optimistic means of estimating error.
To solve a differential equation of order k, one may need good accuracy in approximating
the k-th derivative, and this is hard to estimate from the series for u(x) itself. (A rough rule-
of-thumb is to multiply an by nk for Fourier or Chebyshev series.) A quick inspection of the
Chebyshev coefﬁcients is reliable for rejecting calculations whose accuracy is poor because
N is too small. Coefﬁcient-inspection is suggestive but not reliable for certifying that a
computation is highly accurate. When inspection suggests that a run might be accurate,
repeat with different N and be sure!
6.15
Summary
I assert that a well-organized pseudospectral code to solve a differential equation is only
a little harder to write than its ﬁnite difference counterpart. Table 6.2 illustrates a sample
program to support this contention. For clarity, comments are appended to the end of
many lines (although not allowed in FORTRAN) and also deleted some type conversion
statements.
Excluding comments, the output block, and the user-supplied functions which would
have to be included in a ﬁnite difference code, too, the program contains only 58 lines. A
two-dimensional boundary value solver would have an extra subroutine to compute the
auxiliary indexing arrays, and the basis subroutine would be slightly longer. Nevertheless,
one cannot escape the conclusion that solving BVP’s using spectral methods is simply not
very difﬁcult.
Real world nonlinear eigenvalue solvers, of course, may be rather complicated. How-
ever, the complexity comes from path-following algorithms (Appendices C & D), subrou-
tines to initialize the continuation, blocks of code to compute complicated equation coef-
ﬁcients and so on. These blocks would have to be included in the corresponding ﬁnite
difference or ﬁnite element codes as well.
It follows that approximating the derivatives in the differential equation is almost never
the hard part of writing a scientiﬁc code. Given that this is so, one might as well approxi-
mate the derivatives well instead of badly. One should solve the problem to high accuracy
so that one can then forget the numerics, banish truncation worries from the mind, and
concentrate on the physics of the solution. Pseudospectral methods do just this.

124
CHAPTER 6. PSEUDOSPECTRAL METHODS FOR BVPS
Table 6.2: A sample FORTRAN program for solving a two-point boundary value problem:
d2(x) uxx + d1(x) ux + d0(x) u = f(x)
x ∈[−1, 1]
u(−1) = α
u(1) = β
DIMENSION XI(20),APHI(20),G(20),H(20,20),UGRAPH(101)
COMMON/BASIS/PHI(20),PHIX(20),PHIXX(20)
PI = 3.14159...
C
SPECIFY PARAMETERS
ALPHA = 1.
[ u(-1) ]
BETA = -0.5
[ u(1) ]
N = 22
[No. of Chebyshev polynomials]
NBASIS = N - 2
[No. of basis functions φj(x); φj(±1) = 0]
C
COMPUTE THE INTERIOR COLLOCATION POINTS AND THE FORCING VECTOR G.
DO 100 I=1,NBASIS
XI(I)= COS(PI*I/(NBASIS+1))
X = XI(I)
B = ALPHA*(1-X)/2.+BETA*(1+X)/2. [Function added to v(x) so that
v(x) ≡u(x) −B(x) satisﬁes
homogeneous boundary conditions.]
BX = (-ALPHA + BETA)/2.
[x-derivative of B(x)]
G(I)=F(X) - D0(X)*B - D1(X)*BX
[modiﬁed inhomogeneous term]
100 CONTINUE
C
COMPUTE THE SQUARE MATRIX
DO 200 I=1,NBASIS
X = XI(I)
CALL BASIS(X,NBASIS)
[Compute all N basis functions & derivatives.
Results are returned via arrays in COMMON.]
DD0 = D0(X)
DD1 = D1(X)
[These three lines avoid needless calls to
DD2 = D2(X)
D0(x), etc., inside the J loop.]
DO 200 J=1,NBASIS
H(I,J)=DD2*PHIXX(J)+DD1*PHIX(J)+DD0*PHI(J)
200 CONTINUE
C
CALL A LINEAR ALGEBRA ROUTINE TO SOLVE THE MATRIX EQUATION
H * APHI = G
CALL LINSOLV(H,G,APHI,NBASIS)
C
The array APHI now contains the NBASIS coefficients of the
C
expansion for v(x) in terms of the basis functions φj(x).
C
We may convert these coefficients into those of the ordinary
C
Chebyshev series as described in Sec. 5, but this is optional.

6.15. SUMMARY
125
C
Make a graph of u(x) at 101 points by summing the basis function
C
[not Chebyshev] series.
UGRAPH(1) = ALPHA
UGRAPH(101) = BETA
DO 300 I = 2,100
X = -1 + (I-1)*0.02
CALL BASIS(X,NBASIS)
C
Recall that u(x) = v(x) + B(x) where v(x) is given by the
C
computed series and B(x) is the R. H. S. of the next line.
UGRAPH(I) = (ALPHA*(1-X) + BETA*(1+X))/2
DO 350 J=1,NBASIS
350 UGRAPH(I)=UGRAPH(I) + APHI(J) * PHI(J)
300 CONTINUE
[At the end of this loop, UGRAPH contains
the desired values of u(x) . . . input them to
your favorite plotter!]
END
SUBROUTINE BASIS(X,NBASIS)
COMMON/BASIS/PHI(20),PHIX(20),PHIXX(20)
C
After this call, the arrays PHI, PHIX, and PHIXX contain the
C
values of the basis functions (and their first two derivatives,
C
respectively, at X.
IF (ABS(X).LT.1) THEN [block below is executed only on the
interior. This IF branches to a later
block to evaluate functions at x = ±1.]
T = ACOS(X)
[T is the argument of the trig. functions]
C = COS(T)
S = SIN(T)
DO 100 I=1,NBASIS
N = I+1
TN = COS(N*T)
[Trig. form of TN(x)]
TNT = - N * SIN(N*T)
[Derivative of TN with respect to t]
TNTT= - N*N * TN
[Second t-derivative of TN]
C
Convert t-derivatives into x-derivatives
TNX = - TNT / S
[x-derivative of N-th Chebyshev polynomial.]
TNXX= TNTT/(S*S) - TNT*C/(S*S*S) [Second x-derivative]
C
Final step:
convert TNs into the basis functions φNs.
C
We subtract 1 from the even degree TN ′s, x from the odd degree
C
TN and 1 from the first derivative of the odd polynomials only
IF (MOD(N,2).EQ.0) THEN
PHI(I) = TN - 1.
PHIX(I) = TNX
ELSE
PHI(I) = TN - X
PHIX(I)= TNX - 1.

126
CHAPTER 6. PSEUDOSPECTRAL METHODS FOR BVPS
ENDIF
PHIXX(I) = TNXX
100 CONTINUE
ELSE
[Alternative formulas when X = ±1 ]
DO 200 I=1,NBASIS
PHI(I) = 0.
N = I+1
IF (MOD(N,2).EQ.0) THEN
PHIX(I)= SGN(X,1.)*N*N
ELSE
PHIX(I)= N*N - 1
ENDIF
PHIXX(I) = (SGN(X,1.))**N * N*N * (N*N-1.)/3.
200 CONTINUE
ENDIF
RETURN
END
[ADDITIONAL USER-SUPPLIED ROUTINES: D0(X), D1(X), D2(X), F(X) PLUS THE
LINEAR ALGEBRA ROUTINE LINSOLV.]

Chapter 7
Linear Eigenvalue Problems
“It is not the process of linearization that limits insight. It is the nature of the state that we
choose to linearize about.”
— Erik Eady
7.1
Introduction: the No-Brain Method
The default, almost-no-thinking-required method for solving linear eigenvalue problems is
summarized in Table 7.1. There are two difference from a linear boundary value problem:
(i) the matrix equation is solved by a different linear algebra library routine (eigensolve
instead of matrixsolve) and (ii) comparisons for two different N must be mode-by-mode.
There would seem to be no need for a separate chapter on this topic.
Indeed, often eigenproblems are very simple. Unfortunately, there are a variety of com-
plications that can arise. This chapter might be more appropriately titled: “Damage Con-
trol for Eigenproblems”. No need to read it when solving easy, standard Sturm-Liouville
eigenproblems, but as valuable as a lifevest and a waterproof radio after your code has
been torpedoed by one of the difﬁculties explained below.
Some of these traps, mines and torpedoes are the following:
1. The QR/QZ algorithm, which costs O(10N 3) for an N ×N matrix, may be too expen-
sive for multidimensional problems.
Table 7.1: Default Method for Eigenproblems
Step No.
Procedure
One
Apply spectral method to convert differential or integral equation
to a matrix problem, just as for BVP
Two
Call a matrix eigensolver from linear algebra library
(The QR/QZ algorithm is a robust blackbox that ﬁnds all eigenvalues
and eigenfunctions without user input except the matrix.)
Three
Repeat for different N. Trust only those eigenvalues and eigenfunctions
which are the same for both resolutions
127

128
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
2. Instead of a discrete, countable inﬁnity of eigenmodes, there may be a continuous
spectrum, or a few discrete modes plus a continuous spectrum.
3. It may be tedious to compare eigenvalues for different N to reject those which are
numerically inaccurate.
4. Generalized eigenproblems often have a couple of very large eigenvalues which are
physically spurious in the sense of resulting from inconsistent application of boundary
conditions.
5. In hydrodynamic stability theory, weakly unstable or neutral modes may be singular
or very nearly singular on the interior of the computational domain
6. The eigenparameter may occur as a polynomial in an otherwise linear problem.
7. High order differential equations seem to be quite common in eigenproblems and
may have poor numerical conditioning, i. e., large roundoff errors.
In the rest of this chapter, we explain how to survive these shipwrecks. First, though, we
begin with some basic deﬁnitions and comments on the “no-brain” strategy of Table 7.1.
7.2
Deﬁnitions and the Strengths and Limitations of the
QR/QZ Algorithm
Deﬁnition 17 (Eigenvalue Problem) A LINEAR EIGENVALUE problem is an equation of the
form
Lu = λMu
(7.1)
where L and M are linear differential or integral operators or are square matrices and λ is a number
called the EIGENVALUE. The boundary conditions, if any, are homogeneous so that Eq.(7.1) has
solutions only when λ is equal to a set of discrete values or is on a continuous range. When M is
the identity operator so the right side of (7.1) simpliﬁes to λu, the problem is said to be a regular
eigenvalue problem; otherwise, it is a “generalized” eigenproblem.
Deﬁnition 18 (Eigenvectors/Eigenfunctions) The solutions u to a linear eigenvalue problem
are called “EIGENVECTORS” (if the operators L and M are matrices) or “EIGENFUNCTIONS”
(if L and M are differential or integral operators). The eigenvectors are labelled by an index “j”,
the “MODE NUMBER”, which is usually chosen so that the corresponding discrete eigenvalues
are ordered from smallest to largest with the lowest j (usually either 0 or 1) corresponding to the
smallest eigenvalue. When the eigenfunctions exist for a continuous interval in λ (not possible
for matrix problems), the eigenfunctions are labelled by λ and are said to be “CONTINUOUS”
eigenfunctions.
A simple illustration of a differential eigenproblem, later dubbed “Example One”, is
uxx + λu = 0,
u(−1) = u(1) = 0
(7.2)
which has the exact eigenmodes
uj(x) =
½ cos
¡
j π
2 x
¢
,
j = positive odd integer
sin
¡
j π
2 x
¢
,
j = positive even integer
(7.3)

7.3. EIGENVALUE RULE-OF-THUMB
129
λj = j2 π2
4 ,
j = 1, 2, 3, . . .
(7.4)
When L and M are matrices, there is good and widely available software for solving
eigenproblems. Indeed, such commands are built-in to languages such as Matlab, Maple
and Mathematica. The Matlab command to ﬁnd both eigenfunctions and eigenvalues is
simply: [Eigenfunctions,Eigenvectors]=eig(L,M). FORTRAN subroutines to do the same
may be found in the public domain EISPACK and LINPACK libraries as well in proprietary
libraries like NAG and IMSL. These codes are very robust, and rarely fail except by being
too expensive.
Library software for the algebraic eigenproblem usually employs an algorithm called
the QZ method (for the generalized eigenproblem) or its cousin the QR scheme (for the
regular eigenproblem). The good news is that (i) these algorithms require as input nothing
but the square matrices that deﬁne the eigenproblem and (ii) reliably compute all the ma-
trix eigenvalues and eigenfunctions. The bad news is that QR/QZ is slow: for an N × N
matrix, the cost is O(10N 3) operations. This is an order of magnitude slower than Gaussian
elimination (LU factorization) of a dense matrix of the same size. Unlike almost all other
matrix algorithms, QR/QZ schemes cannot exploit matrix sparsity because zero elements
are all ﬁlled in as the algorithm proceeds.
Gary and Helgason (1970) pointed out that this implies: Hurrah for high order dis-
cretizations! The reason is that high order methods make it possible to resolve a given
number of eigenmodes with much smaller N than with lower order methods. Replacing
a 100-point second order computation by an equally accurate tenth order matrix which is
only 40 × 40 reduces the cost of the QR algorithm by a factor of 15!
Orszag (1971b) noted that Chebyshev pseudospectral methods are the ultimate in high
order, and reduce N still further from the values needed by the eighth and tenth order
ﬁnite difference methods of Gary and Helgason.
It is ironic: the QR/QZ algorithm has no direct connection with spectral methods. Nev-
ertheless, when this is the chosen matrix eigensolver, the QR algorithm cries out for a spec-
tral discretization.
On modern workstations, almost all one-dimensional and some two-dimensional and
three-dimensional eigenproblems can be solved efﬁciently by the pseudospectral/QZ com-
bination. Unfortunately, when one needs to resolve multidimensional modes with lots of
ﬁne structure, or worse still, needs to compute the eigenvalues throughout a multidimen-
sional parameter space, the QR algorithm may be unaffordable.
In later sections, we therefore describe two representative alternatives: the power and
inverse power methods. Both are “local” methods in the sense that they compute only one
eigenvalue at a time. In contrast, the QR/QZ method is “global” because it computes all N
matrix eigenvalues without requiring any input from the user except the matrices theme-
selves. With local methods, it is easy to miss eigenvalues; we offer some cautionary tales
below. However, the cost per point in parameter space is usually an order of magnitude
less than the QR scheme.
7.3
Numerical Examples and the Eigenvalue Rule-of-Thumb
Fig. 7.1 illustrates the errors in computing eigenvalues of Example One ( Eq. 7.2). The
error tolerance is of course both user-dependent and problem-dependent. For the sake of
discussion, we shall arbitrarily deﬁne a “good” eigenvalue as one whose absolute error is
less than or equal to 0.01, as marked by the horizontal dividing line in the graph.
By this criterion, the 16-point discretization returns seven “good” eigenvalues and nine
“bad” eigenvalues. Fig. 7.2 compares a “good” (top) and “bad” eigenfunction as computed

130
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
0
5
10
15
10
-15
10
-10
10
-5
10
0
10
5
mode number j
Absolute value of error in j-th eigenmode
0.01 error level
Figure 7.1: Example One: Absolute errors in the eigenvalues as given by a 16-point Cheby-
shev pseudospectral discretization.
The horizontal dividing line separates the “good”
eigenvalues from the “bad” where the “good” eigenvalues are deﬁned (arbitrarily) to be
those whose absolute error is 0.01 or less.
-1
-0.5
0
0.5
1
-1
-0.5
0
0.5
1
x
Solid: Numerical
N=16     15th mode
-1
-0.5
0
0.5
1
-1
-0.5
0
0.5
1
Circles: Exact
N=16      3rd mode
Figure 7.2: Example One: 16-point Chebyshev pseudospectral discretization. Exact (cir-
cles) and numerical (solid) approximations to the eigenmodes. Upper panel: Third Mode.
Lower panel: Fifteenth mode.

7.3. EIGENVALUE RULE-OF-THUMB
131
0
5
10
15
20
25
30
10
-15
10
-10
10
-5
10
0
10
5
mode number j
Absolute value of error in j-th eigenmode
0.01 error level
Figure 7.3: Example One: Absolute errors in the eigenvalues for 16-point (solid) and 32-
point (circles) Chebyshev pseudospectral discretization.
numerically with the corresponding exact modes. The third mode, because it oscillates
slowly with x, is well-resolved and the exact and numerical eigenfunctions are graphically
indistinguishable. The ﬁfteenth mode, however, is oscillating so rapidly that it cannot be
resolved by the ﬁrst sixteen Chebyshev polynomials. To be sure, T15(x) has ﬁfteen roots,
just like the exact ﬁfteenth mode, but the Chebyshev oscillations are not uniform. Instead,
T15(x) oscillates slowly in the center of the interval and very rapidly near to the endpoints,
in contrast to the uniform oscillations of the eigenmode it is vainly trying to mimic.
To resolve more eigenmodes, merely increase N as illustrated in Fig. 7.3, which com-
pares the errors for 16-point and 32-point calculations. The number of good eigenvalues
has risen from seven to sixteen. The graph is ﬂat for small j because of roundoff error. In
multiple precision, the errors for the ﬁrst three or four modes would be smaller than 10−15,
off the bottom of the graph!
For “nice” eigenvalue problems, this behavior is typical. To show this, consider a sec-
ond example which is posed on an inﬁnite interval and is solved using not the Chebyshev
polynomials but rather the “rational Chebyshev” functions TBn(x), which are a good basis
for an unbounded domain (Chapter 17).
EXAMPLE TWO:
uxx + (λ −x2) u = 0,
|u| →0 as x →∞
(7.5)
The exact eigenfunctions are the Hermite functions,
uj(x) = exp
µ
−1
2x2
¶
Hj(y)
(7.6)
where Hj is a polynomial of degree j, the j-th Hermite polynomial. The eigenvalues are
λj = 2j + 1,
j = 0, 1, 2, . . .
(7.7)
Fig. 7.4 shows that again the lowest few modes are accurately approximated. The inﬁ-
nite interval problem is harder than a ﬁnite interval problem, so there are only four “good”

132
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
0
5
10
15
10
-5
10
-4
10
-3
10
-2
10
-1
10
0
10
1
10
2
10
3
10
4
mode number  j
Absolute value of error in j-th eigenmode
0.01 error level
Figure 7.4: Example Two (Eigenfunctions of parabolic cylinder equation on an inﬁnite
interval): Absolute errors in the eigenvalues as given by a 16-point Rational Chebyshev
(TBn) discretization with the map parameter L = 4.
eigenvalues versus seven for the 16-point discretization of Example One. Fig. 7.5 shows
that the second eigenmode is well-approximated, but the seventh eigenmode is poorly
approximated. The most charitable comment one can make about the seventh numerical
eigenfunction is that it vaguely resembles the true eigenmode by having a lot of wiggles.
Fig. 7.6 conﬁrms that increasing N also increases the number of “good” eigenvalues, in this
case from four to ten.
It is important to note that for both examples, the approximation to the lowest mode
is extremely accurate with errors smaller than 10−11 for N = 32 for both examples. The
error increases exponentially fast with mode number j until ﬁnally the error is comparable in
magnitude to the eigenvalue itself.
These examples suggest the following heuristic.
Rule-of-Thumb 8 (EIGENVALUE RULE-OF-THUMB)
In solving a linear eigenvalue problem by a spectral method using (N + 1) terms in the truncated
spectral series, the lowest N/2 eigenvalues are usually accurate to within a few percent while the
larger N/2 numerical eigenvalues differ from those of the differential equation by such large amounts
as to be useless.
Warning #1: the only reliable test is to repeat the calculation with different N and compare the
results.
Warning #2: the number of good eigenvalues may be smaller than (N/2) if the modes have
boundary layers, critical levels, or other areas of very rapid change, or when the interval is un-
bounded.
Although this rule-of-thumb is representative of a wide class of examples, not just the
two shown above, nasty surprises are possible. We attempt a crude classiﬁcation of linear
eigenvalue problems in the next section.

7.3. EIGENVALUE RULE-OF-THUMB
133
-10
-5
0
5
10
-1
-0.5
0
0.5
1
x
Solid: Numerical
j=6 mode
-10
-5
0
5
10
-1
-0.5
0
0.5
1
Circles: Exact
j=1 mode
Figure 7.5: Example Two (Exact modes are Hermite functions): 16-point Rational Cheby-
shev pseudospectral method. Exact (circles) and numerical (solid) approximations to the
eigenmodes. Upper panel: Second Mode. Lower panel: Seventh mode.
0
5
10
15
20
25
30
10
-12
10
-10
10
-8
10
-6
10
-4
10
-2
10
0
10
2
10
4
mode number  j
Absolute value of error in j-th eigenmode
0.01 error level
Figure 7.6: Example Two (Inﬁnite Interval): Absolute errors in the eigenvalues for 16-point
(solid disks) and 32-point (open circles) TBn discretization.

134
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
7.4
Four Kinds of Sturm-Liouville Eigenproblems
and Continuous Spectra
Solving partial differential equations by separation-of-variables generates eigenproblems
of the form of Eq. 7.8 below. Sturm and Liouville showed in the mid-nineteenth century
that as long as the equation coefﬁcients p(x) and r(x) are positive everywhere on the in-
terval x ∈[a, b] and q(x) is free of singularities on the interval, then all eigenfunctions are
discrete and orthogonal. Such “nice” classical eigenproblems are very common in applica-
tions, but unfortunately do not exhaust all the possibilities. This motivated the following
classiﬁcation scheme.
Deﬁnition 19 (Sturm-Liouville Eigenproblems: Four Kinds)
A Sturm-Liouville eigenproblem is
[p(x)ux]x + {q(x) + λr(x)} u = 0,
x ∈[a, b]
(7.8)
subject to various homogeneous boundary conditions. There are four varieties in the classiﬁcation
scheme of Boyd(1981a):
• First Kind: p, q, r analytic everywhere on the interval
• Second Kind: p, q, r analytic everywhere on the interval except the endpoints.
• Third Kind: differential equation has singularities on the interior of the interval, but the
singularities are only “apparent”.
• Fourth Kind: differential equation and eigenfunctions are singular on the interior of the in-
terval.
SL problems of the First Kind are guaranteed to be “nice” and well-behaved. However,
problems of the Second Kind, which includes most eigenproblems on an unbounded do-
main, may be either regular, with a discrete inﬁnity of eigenvalues all of the same sign and
orthogonal eigenfunctions, or they may have only a ﬁnite number of discrete eigenvalues
plus a continuous eigenspectrum.
The differential equation satisﬁed by the Associated Legendre functions is a good il-
lustration of the Second Kind. The Legendre functions are the solutions on x ∈[−1, 1]
of
D2u + { λ(1 −x2) + E}u = 0
(7.9)
where the differential operator D is
D ≡(1 −x2) d
dx
(7.10)
The eigenfunctions are those solutions which are regular at the endpoints except perhaps
for a branchpoint:
u = P m
n (x),
λ = n(n + 1),
E = −m2
(7.11)
When derived from problems in spherical coordinates, x is the cosine of colatitude and the
periodicity of the longitudinal coordinate demands that m be an integer. Then Eq.(7.9) is
a regular Sturm-Liouville problem of the second kind and λ is the eigenvalue. For each
longitudinal wavenumber m, there is a countable inﬁnity of discrete eigenvalues: n must
be an integer with the further requirement n ≥|m|.

7.4. FOUR KINDS OF STURM-LIOUVILLE PROBLEMS
135
However, the same differential equation is also an important exactly-solvable illustra-
tion of the stationary Schroedinger equation of quantum mechanics with radically different
behavior: a continuous spectrum plus a ﬁnite number of discrete eigenmodes. The crucial
difference is that the roles of the parameters λ and E are interchanged in quantum me-
chanics: E is now the eigenvalue (“energy”) and λ measures the strength of the speciﬁed
potential.
The unimportant difference is that quantum problems are usually posed on an inﬁnite
interval, which requires the change of variable
x = tanh(y)
[“Mercator coordinate”]
(7.12)
The Legendre equation (7.9) becomes
uyy + { λ sech2(y) + E}u = 0,
y ∈[ −∞, ∞]
(7.13)
For all positive E, the equation has solutions which are everywhere bounded; these are
the continuous spectrum or “continuum”. Since the sech2 potential decays exponentially
fast to zero as |y| →∞, the continuum eigenmodes are asymptotically proportional to
exp(iE1/2).
The discrete modes are spatially localized around the origin and have negative E. In-
troducing the auxiliary parameter ν(λ) via
λ ≡ν (ν + 1)
(7.14)
the discrete eigenvalues are
Ej = −(ν −j)2, j = 0, 1, ..., jmax
(7.15)
where jmax is the largest integer smaller than ν, i. e., the number of allowed modes is one
plus the integer part of ν.
The good news is that both the continuum and discrete eigenmodes can be calculated
by spectral methods. The continuous spectrum requires special tricks; see Sec. 4 of Chapter
19 for an example. The discrete modes can be computed by exactly the same tricks as used
for the quantum harmonic oscillator, whose countable inﬁnity of modes are the Hermite
functions. The only complication is that the number of “good” modes is now ﬁxed, and
will not increase above jmax + 1 even if we used 10,000 spectral basis functions.
Laplace’s Tidal Equations are even trickier, an eigenproblem of the “Third Kind” in
Boyd’s terminology:
λu −xv −sζ
=
0
xu −λv + Dζ
=
0
su −Dv −ϵ λ (1 −x2)ζ
=
0
(7.16)
where x is the coordinate (cosine of colatitude) and D ≡(1 −x2)d/dx as for Legendre’s
equation, u and v are the horizontal ﬂuid velocities, and ζ is the sea surface height (in
oceanographic applications) or the pressure (in meteorological use). Depending on the
application, any of the set of three parameters (λ, s, ϵ) may be the eigenvalue where λ is the
nondimensional frequency, s is the zonal wavenumber and ϵ is “Lamb’s parameter”, which
is proportional to the depth of the water or (in meteorology) to the vertical wavelength.
The eigenproblem is of the Third Kind because for modes of low frequency, the differ-
ential system is singular at those latitudes (“inertial latitudes” or “critical latitudes”) where
λ = x. However, the eigenfunctions themselves are well-behaved and analytic even at the
inertial latitudes.

136
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
When the goal is to calculate the free tidal oscillations of a global ocean, s and ϵ are
known and the frequency is the eigenvalue. All modes are discrete and this case is rela-
tively uncomplicated.
For forced atmospheric tides, s and the frequency λ are known. However, the earliest
calculations agreed badly with observations, even the limited data of the 1930’s. All sorts
of imaginative (but wrong!) theories were proposed, but the correct explanation was given
independently after thirty years of confusion by Lindzen and by Kato. It had been assumed
by analogy with Sturm-Liouville eigenproblems of the First Kind that all the eigenvalues ϵ
were positive. Actually, because of the inertial latitudes, the diurnal tide also has an inﬁnite
number of modes with negative ϵ. One class of modes is oscillatory at low latitudes (be-
tween the inertial latitudes) and decays exponentially beyond the inertial latitudes as the
poles are approached. The other class of modes is conﬁned mostly poleward of the inertial
latitudes and has little amplitude in the tropics. The singularities of the differential equa-
tion are crucial even though the eigenfunctions themselves are paragons of mathematical
regularity.
A third application (O’Connor, 1995, 1996, Boyd, 1996c) is ocean oscillations in a basin
bounded by meridians where now the eigenparameter is the zonal wavenumber s. Com-
plex eigenvalues are possible, and merely describe oscillations whose amplitude decays
exponentially with increasing distance from the coast. The surprise, as yet unsupported by
rigorous proof, is that the eigenvalues are a mixture of a discrete and a continuous spec-
trum. In addition, unless s is an integer, the eigenfunctions have weak singularities at the
poles. This implies that for the spectral series of an eigenmode (using any standard basis),
the asymptotic rate of convergence is algebraic rather than exponential unless special tricks
such as an exponential change-of-coordinate are used (Chapter 16, Sec. 5).
Lastly, Boyd (1981a, 1982a, 1985a) has studied Sturm-Liouville eigenproblems of the
Fourth Kind such as
uxx + (1/x −λ)u = 0,
u(a) = u(b) = 0
(7.17)
where the interval x ∈[a, b] spans the origin. Superﬁcially, this looks like a self-adjoint SL
problem of standard form, which would be expected to have only real discrete eigenvalues.
In reality, the presence of the pole in the coefﬁcient of the undifferentiated term changes
everything. The pole must be interpreted as the limit
1/(x −iδ)
(7.18)
as δ tends to zero where δ represents viscosity. For non-zero δ, there is a small viscous
layer of thickness proportional to δ. Outside this layer, the eigenfunctions are effectively
inviscid. In the limit δ →0, the thickness of the viscous layer shrinks to zero and the
eigenfunctions are singular as x log(x) at x = 0. The eigenfunctions and eigenvalues are
both complex-valued; one must circle the branchpoint below the real axis to obtain the
branch which is the correct limit of the viscous solution.
The good news is that Boyd (1981a, 1982a) and Gill and Sneddon(1995, 1996) developed
special spectral methods to compute the singular eigenfunctions. The bad news is that
Boyd (1985a) showed that the author’s earlier papers had missed a root.
Clearly, Sturm-Liouville eigenproblems can be full of surprises. Hydrodynamic stabil-
ity problems, which are not self-adjoint and usually have complex-valued eigenvalues and
nearly-singular, complex-valued eigenfunctions, merely reiterate this theme: Eigenprob-
lems can be nasty, and it is terribly easy to be speared by internal layers or singularities, or
miss modes entirely.

7.5. CRITERIA FOR REJECTING EIGENVALUES
137
7.5
Winnowing the Chaff: Criteria for Rejecting Numeri-
cally Inaccurate or Physically Non-Existent Eigenvalues
It is always a good idea to repeat each calculation twice with different N to verify that
the solution is well-resolved. With eigenproblems, this is doubly important because, as
expressed by the Eigenvalue Rule-of-Thumb, many of the eigenvalues of the discretization
matrix are numerical nonsense unrelated to the eigenvalues of the underlying differential
or integral eigenproblem. To know how many modes are “good”, that is, have been com-
puted accurately, one must compare the list of eigenvalues for two different N and accept
only those which are the same (within some user-set tolerance) on both lists.
One difﬁculty is that if one is performing a large number of eigencalculations, comparing-
by-eye can lead to eyestrain, headaches, and a ﬁrm resolve to ﬁnd a new, more exciting pro-
fession like accounting or tax law. This is one motive for inventing some simple graphical
and numerical methods for reliably separating “good” eigenvalues from trash.
Another is that we often do not know a priori how many discrete eigenmodes even exist,
as illustrated by the Legendre equation.
Our recommended strategy is to make a plot on a logarithmic scale of the reciprocal of
the difference between corresponding eigenvalues as calculated at different resolutions N,
scaled by some measure of the size of the eigenvalues. The reciprocal of the difference is
plotted so that the “good” eigenvalues are at the top of the graph; a semilogarithmic plot is
recommended because the accuracy varies exponentially with mode number j as already
seen above. There are two minor complications.
0
20
40
60
80
10
0
10
2
10
4
10
6
10
8
10
10
10
12
10
14
mode number j
Legendre Eq.: 4 bound states     N=90, 120
Figure 7.7: The reciprocal eigenvalue drift ratios 1/δj,nearest(circles) and 1/δj,ordinal (x’s)
are plotted on a logarithmic scale versus mode number j for Legendre’s equation uyy +
{ 15.75 sech2(y) + E}u = 0 where E is the eigenvalue (the energy). The modes are ordered
by real part of E with j = 1 the smallest. For this case, there are precisely four bound states
which are the four numerical eigenvalues with E < 0.

138
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
First, the obvious scaling for the j-th eigenvalue is |λj| itself. However, an eigenvalue
may accidentally be very close to zero. Furthermore, for a “nice” Sturm-Liouville problem,
the eigenvalues typically grow as O(j2), but the difference between adjacent eigenvalues
grows only as fast as O(j). We can solve both these difﬁculties by deﬁning an “intermodal
separation” via
σ1
≡
|λ1 −λ2|
σj
≡
1
2 (|λj −λj−1| + |λj+1 −λj|) ,
j > 1
(7.19)
and then conservatively scale the eigenvalues by σj. (In the case of degeneracy, that is,
two or more eigenfunctions with the same eigenvalue, it is assumed that the differences in
Eq. (7.19) are taken between the non-degenerate modes nearest to mode j.)
Second, in many problems, the eigenvalue ordering is invariant when the resolution
is changed — at least after the eigenvalues for each run have been sorted by magnitude
or real part — and it is sufﬁcient to plot the reciprocal of what we shall dub the (scaled)
“ordinal” difference
δj,ordinal ≡|λj(N1) −λj(N2)| / σj
(7.20)
where the arguments denote the number of degrees of freedom N in the low and high
resolution computations. However, for many problems, such as Laplace’s Tidal Equation
(O’Connor, 1995, 1996, Boyd, 1996c), the well-resolved eigenvalues are not evenly spaced.
(Tidal oscillations fall into two main classes: Rossby waves, which have low frequency, and
gravity waves, which have high frequency. Thus, the gravest Rossby and gravity modes
(well-resolved) are separated by an inﬁnite number of higher Rossby modes of intermedi-
ate frequency, which are not as accurately computed.) For such more intricate relationships
between eigenvalue magnitude and the spatial scale of the wave, one needs to compare the
j-th low resolution mode with whatever eigenvalue of the high resolution computation
agrees most closely with it. This “nearest” difference (scaled) is
δj,nearest ≡
min
k∈[1,N2] |λj(N1) −λk(N2)| / σj
(7.21)
Fig. 7.7 is a plot of the scaled differences or “drift-with-N” for the equation solved by
the Associated Legendre equation using 90 and 120 rational Chebyshev functions on the
inﬁnite interval. The exact solution has four discrete modes plus a continuous spectrum.
The discrete modes of the spectral matrix cannot converge to the continuous spectrum, so
that the best we can do is to resolve the four discrete modes. The graph shows that with
N = 90, these modes are very well-resolved in the sense that these eigenvalues, scaled by
the smaller of |λj| or σj, change by less than one part in a million when the basis size is
increased to N = 120. For this case, the “ordinal ratio” would have been sufﬁcient be-
cause the discrete modes are the four smallest numerically computed eigenvalues at both
resolutions; the “ordinal” and “nearest” ratios are so close that the circles and x’s are super-
imposed. For the unresolved modes of the continuous spectrum (bottom of the graph), the
“nearest” ratios are consistently a little larger than the “ordinal” ratios. The reason is that
by coincidence, two inaccurate eigenvalues for different resolution may be rather close,
producing a nearest ratio which is small even though the spectral method is generating
random numbers for these modes. It is both quicker and less confusing to use the “or-
dinal” ratio wherever possible. As shown in Boyd(1996c), however, other eigenproblems
such as Laplace’s Tidal equation absolutely require the “nearest” ratio.
Fig. 7.7 is easy to interpret — four discrete modes, all the rest nonsense — because the
reciprocal ratios 1/δj are so many orders of magnitude larger for the “good” modes than

7.6. “SPURIOUS” EIGENVALUES
139
for the bad. A low precision ﬁnite difference calculation would be much more ambiguous
– is this eigenvalue real or just a numerical artifact that would jump around at higher
resolution?
7.6
The Curse of “Spurious” Eigenvalues
Generalized eigenproblems may have some eigenvalues which are physically spurious rather
than merely numerically underresolved. The difﬁculty was ﬁrst characterized by Gottlieb
and Orszag (1977, pg. 145), who noted “low modes are given accurately ... but there ap-
pear spurious unstable modes with large growth rates. Similar spurious unstable modes
appear in ﬁnite-difference solution of the Orr-Sommerfeld equation.” (pg. 145).
Much time and energy has been expended in the invention of slight modiﬁcations
to standard spectral methods to solve the “spurious eigenvalue” difﬁculty: Gottlieb and
Orszag (1977, pg. 143-146), Brenier, Roux and Bontoux(1986), Zebib(1987b), Gardner, Trog-
don and Douglass(1989), McFadden, Murray and Boisvert (1990), Huang and Sloan (1994),
and Dawkins, Dunbar, and Douglass (1998). However, a major theme of the chapter is that
convert-to-matrix methods always have lots of nonsense eigenvalues, so what is so special
about these “spurious eigenvalues”?
The short answer is that because the “spurious eigenvalues” are spurious due to mis-
represented physics, rather than mere underresolution of genuine eigenmodes, there are
some differences between them and the other unacceptable eigenvalues which are worth
discussing. Before we can discuss these differences, however, we must ﬁrst note that the
bland label “spurious eigenvalues”, used in many previous studies, is a semantic atrocity
because it blurs the distinction between these eigenvalues and those which are in error
merely because N is too small.
To correct this semantic sloppiness, we offer the following.
Deﬁnition 20 (SPURIOUS EIGENVALUES)
PHYSICALLY SPURIOUS EIGENVALUES are numerically-computed eigenvalues which
are in error because of misapplication of boundary conditions or some other misrepresentation of the
physics.
NUMERICALLY SPURIOUS EIGENVALUES are poor approximations to exact eigenvalues
because the mode is oscillating too rapidly to be resolved by N degrees of freedom. A given numeri-
cally spurious eigenvalue can always be computed accurately by using sufﬁciently large N.
An example, ﬁrst studied by Gottlieb and Orszag (1977, pg. 143-145), will help. The
equations for a viscous, incompressible ﬂuid can, in the limit of small amplitude and one-
dimensional ﬂow, be written as the system
ζt
=
νζxx
ζ
=
ψxx
(7.22)
where ν is the constant viscosity. The bounary conditions are
ψ(±1) = ψx(±1) = 0
(7.23)
Note that these are entirely on the streamfunction ψ with no boundary conditions on the
vorticity ζ. This system can be reduced to the single equation:
ψtxx = ν ψxxxx
(7.24)

140
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
The Galerkin method, called the “tau method” in Gottlieb and Orszag, is to write
ψ(t) ≈
N
X
j=0
an(t)Tn(x)
(7.25)
and then impose the N −3 conditions that the residual should be orthogonal, in the usual
Chebyshev inner product, to Tk(x) for k = 0, 1, . . . , N −4. These conditions are supple-
mented with the four boundary conditions (7.23).
Unfortunately, the resulting system of ODEs in time is a disaster wrapped in a catas-
trophe: all time-marching schemes for the system are unstable. Note that both (7.24) and
its Chebyshev discretization can be solved exactly by expansion in the solutions (exact or
Chebyshev-discretized, respectively) of the eigenvalue problem
νuxxxx = λuxx
(7.26)
where each mode depends upon time as exp(λt) where λ is the eigenvalue. The exact
eigenvalues of the original PDE are λ = −νµ where either µ = nπ or µ is any nonzero
root of tan µ = µ; the eigenvalues are negative real so that the exact eigenmodes all de-
cay monotonically with time. The Chebyshev discretized problem, however, has two pos-
tive real eigenvalues whose magnitude increases as roughly O(N 4). Thus, the Chebyshev-
discretized system of ODEs in time has two eigenmodes which blow up very fast, and no
time-marching scheme can forestall disaster.
These two physically-spurious eigenvalues arise because (7.24) is an “explicitly-implicit”
problem, that is, in order to apply standard software for solving the system of ordinary dif-
ferential equations in time, we must rewrite the equation as
ψt =
1
∂2xx
ψxxxx
(7.27)
The problem is that we impose four boundary conditions on the streamfunction ψ, consis-
tent with the fact that the differential equation is fourth order, but the differential operator
that must be inverted to compute the right-hand side of (7.27) is only of second order. In
general, a second order differential equation with four boundary conditions is insoluble. A
similar inconsistency arises when converting (7.26) from a generalized to a standard eigen-
problem:
ν 1
∂2xx
uxxxx = λu
(7.28)
This suggests – as McFadden, Murray and Boisvert (1990) have conﬁrmed through
many numerical experiments – that these physically spurious eigenvalues only arise for
generalized eigenproblems, and are absent for standard eigenproblems which do not in-
volve the inversion of a differential operator. Furthermore, this difﬁculty happens only for
non-periodic problems. In a periodic problem, one cannot have inconsistencies in the num-
ber of boundary conditions because the boundary condition of periodicity is the same for
differential operators of all orders. It is only generalized eigenproblems in non-periodic
geometry where physically spurious eigenvalues may arise.
Dawkins, Dunbar and Douglass (1998) have rigorously proved the existence of the large
positive eigenvalues for the eigenproblem (7.26). They show that the overspeciﬁcation of
boundary conditions technically creates two L2 eigenmodes of the differential eigenprob-
lem with inﬁnite eigenvalues, which the discretization approximates as positive eigenval-
ues of magnitude O(N 4).

7.6. “SPURIOUS” EIGENVALUES
141
Several remedies have been proposed, but all seem to be closely related, so we shall
describe only the variant due to Huang and Sloan (1994). Their spectral basis is composed
of Chebyshev-Lobatto cardinal functions on an N-point grid xk, k = 1, . . . , N. Dirichlet
homogeneous boundary conditions are imposed by omitting C1(x) and CN(x) from the
basis. The twist is that for (7.26), a non-standard basis is used to represent the fourth
derivatives:
hj(x) ≡(1 −x2)
(1 −x2
j)Cj(x)
(7.29)
where the Cj(x) are the standard cardinal functions. Note that the factor of (1−x2) enforces
the homogeneous Neuman condition so that a sum of hj from j = 2, . . . , N −1 must have
a double zero at both endpoints. The coefﬁcients of both basis sets are the same: the values
of u(x) at the interior grid points. However, the modiﬁed functions hk are used only to
represent the fourth derivative while the standard basis functions with “lazy” imposition
of boundary conditions (just two) are used for the second derivatives. Thus, the discrete
generalized eigenvalue problem ⃗A⃗u = λ ⃗B⃗u for Eq.(7.26) has the matrix elements
Aij = hj,xxxx(xi),
Bij = Cj,xx(xi)
(7.30)
where ⃗u is the column vector of grid point values {u(x2), . . . , u(xN−1)}.
This works, but the question still remains: With so many numerically underresolved
eigenvalues to battle, do a couple of physically spurious eigenvalues matter? We shall
offer three positive answers, each followed by a rejoinder.
The ﬁrst argument is that these physically spurious eigenvalues are very important
because they cause unconditional instability of time-marching schemes. However, this is
really an issue to be fought out in a discussion of time-marching. It is not a “spurious
eigenvalues” problem so much as it is a “screwing up the bounary conditions” problem.
Further, Gottlieb and Orszag note that “this version of the tau method [with physically
spurious eigenvalues] may be suitable for eigenvalue problems even though it is uncondi-
tionally unstable for the initial-value problem”.
Spurious modes are often generated when a system of equations is reduced to a single
equation, as often happens in setting up eigenproblems as illustrated by Eq.(7.26). The
most famous example of “spurious” modes is the generation of unreal pressure modes
when the equations of incompressible ﬂuid ﬂow are reduced to a single equation for the
pressure. Although there are no physical boundary conditions for the pressure, the Poisson-
like equation for it requires boundary conditions – and evaluating the Navier-Stokes equa-
tions at solid walls actually gives more boundary conditions than are needed.
The remedy is now well-understood: discretize the system, impose boundary conditions
on the system, and then reduce the system to a single equation after discretization. Another
important tactic is to use polynomials of different degrees where necessary. Again, the most
well-known illustration is the practice of approximating the pressure in incompressible
ﬂow by a polynomial whose degree is two less than that of the velocity. Similarly, Huang
and Sloan’s strategy approximates the second derivative using basis functions whose de-
gree is two less than that of the modiﬁed cardinal functions hj which are used for the fourth
derivative.
So, physically spurious eigenvalues do have some signiﬁcance because they imply tem-
poral instability. However, this is a well-understood phenomena now, and besides it is a
tale that belongs in another chapter. When the goal is only eigenvalues, temporal instabil-
ity does not matter.
The second argument in favor of modiﬁed eigenvalue-solving is that if the target is
unstable modes, then physically spurious modes of large positive real part might be con-
fused with genuine instabilities, and so waste a lot of time. However, as explained in the

142
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
previous section, this shouldn’t be a difﬁculty if one plots the change in eigenvalues with
resolution. The physically-spurious eigenvalues seem to scale as O(N 4) for most problems
and thus are among the very easiest “bad” eigenvalues to detect through sensitivity to N.
The third argument for purging physically spurious eigenvalues is that misrepresen-
tation of boundary conditions worsens the condition number of the matrices. This is per-
fectly true, and is particularly annoying since eigenproblems – again because of the reduc-
tion of a system of equations to one differential equation – often involve high order deriva-
tives. Since the derivatives of Chebyshev polynomials oscillate more and more wildly in
narrow boundary layers as the order of the derivative increases, Chebyshev differentiation
matrices become more and more ill-conditioned for problems with high order derivatives,
with or without physically spurious eigenvalues. We shall describe how to ameliorate this
ill-conditioning in the next section.
7.7
Reducing the Condition Number
One unpleasant difﬁculty with a Chebyshev or Legendre basis is that the derivatives of
the polynomials oscillate near the endpoints with increasing amplitude and decreasing
wavelength as the degree and order of differentiation increase. To be precise,
¯¯¯¯
dpTN
dxp (±1)
¯¯¯¯ ∼N 2p
p
Y
k=1
1
2k + 1
©
1 + O(1/N 2ª
(7.31)
In turn, this implies that the condition number of the Chebyshev and Legendre matrices for
a differential equation are O(N 2p). Thus, for a sixth order equation, the matrix is blowing
up as O(N 12), and the linear algebra subroutine is likely to crash spectacularly even for N
little larger than 10.
0
1
2
3
10
1
10
2
10
3
10
4
10
5
10
6
T   - T    Basis
 2j     0
t=arccos(x)
Heinrichs Basis
Figure 7.8: Absolute values of the second derivative of the highest basis function versus
the trigonometric argument t = arccos(x) for two different basis sets (N = 50 collocation
points). Upper curve: Each basis function is the difference of a Chebyshev polynomial
with either 1 or x. Its maximum is 6.9E5. Bottom curve: Heinrichs’ basis: φ50(x) = (1 −
x2) T49(x). The maximum is only 2.4E3.

7.7. REDUCING THE CONDITION NUMBER
143
10
1
10
2
10
1
10
2
10
3
10
4
10
5
10
6
10
7
N
Condition number
T   - T   Basis
 2j    0
(1-x*x)*T (x)
       j 
Figure 7.9: Solid: condition numbers for the matrices which discretize the second deriva-
tive operator in two different basis sets, plotted versus N, the size of the matrix. Top: the
“difference” basis in which each function is Tj(x) minus either 1 or x, depending on parity.
Bottom with circles: Heinrichs’ basis: φj(x) = (1 −x2) Tj(x). The condition number is
deﬁned to be the ratio of the largest to the smallest singular value of the matrix. The dotted
lines have slopes of N 4 (top) and N 2 (bottom), illustrating that the rate of growth of the
condition number closely follows these respective power laws.
Fortunately, there are a couple of remedies. Wilhelm Heinrichs (1989a, 1991b, 1991c)
observed that if we apply basis recombination to create basis functions that satisfy homo-
geneous boundary conditions, it is possible to choose particular sets that greatly reduce the
condition number. For example, suppose the target is to solve a second order differential
equation with the homogeneous Dirichlet boundary conditions u(±1) = 0. The simplest
choice of basis functions, and one that works very well except for N >> 100, is the “differ-
ence” basis
φ2j(x) ≡T2j(x) −T0,
φ2j−1(x) ≡T2j−1(x) −T1
(7.32)
but the second derivative of these is equal to that of a Chebyshev polynomial and thus this
basis gives poor condition number.
Heinrichs proposed instead
φj ≡(1 −x2)Tj,
j = 0, 1, . . .
(7.33)
The endpoint and near-the-endpoint values of the second derivatives of these functions,
which we shall dub the “Heinrichs” basis, are much smaller than those of the Chebyshev
polynomials or the difference basis: O(N 2) basis versus O(N 4). His reasoning is that the
second derivative of his basis functions is
φj,xx = (1 −x2)Tj,xx −4xTj,x −2Tj
(7.34)

144
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
Now Tj,xx is O(N 4) near the endpoints, but this is precisely where the factor (1 −x2) tends
to zero. The contribution of the ﬁrst derivative is not cancelled near the boundary, but since
the ﬁrst derivative is only O(N 2), the second derivative of the Heinrichs basis is no larger.
Fig. 7.8 compares the second derivatives of two basis functions of the same degree in
the two different basis sets. It is necessary to plot the absolute values on a logarithmic
scale, and to plot them versus the trigonometric coordinate t (= arccos(x)) because the
oscillations grow so rapidly in magnitude and wavelength near the endpoints that the
obvious plot of the second derivatives on a linear scale versus x shows little but some
wiggly, indecipherable spikes near x = ±1. The lower plot shows that the (1 −x2) factor in
the Heinrichs basis turns the magnitude back towards zero so that the maximum amplitude
is roughly the square root of the maximum for the “difference” basis. Fig. 7.9 shows that this
translates into a great difference in the condition number of the Chebyshev discretization
matrices for the second derivative: O(N 2) for the Heinrichs basis versus O(N 4) (ouch!) for
the “difference” basis.
There are a couple of little white lies hidden in these graphs. First, the Heinrichs’ basis
makes the condition number of the matrix which discretizes the undifferentiated basis worse.
The result is that when we convert uxx + λu = 0 into the standard matrix eigenproblem
⃗G⃗u = λ ⃗u with ⃗G = ⃗B−1⃗A where ⃗A is the discretization of the second derivative and ⃗B that
of the undifferentiated term, it turns out the condition number of ⃗G is almost identical for
the two basis sets. The other white lie is that for a second order problem, ill-conditioning
is a problem only when N > 100, which is to say it is not a problem.
For fourth order and higher order differential equations, however, ill-conditioning is
more of a problem, and the Heinrichs’ basis comes increasingly into its own. The idea
generalizes in an obvious way to higher order equations. For example, for a fourth order
problem with the boundary conditions u(±1) = ux(±1) = 0, the Heinrichs basis is
φj(x) ≡(1 −x2)2Tj(x)
(7.35)
where the quartic multiplier enforces a double zero at both endpoints and thus lowers the
condition number of the fourth derivative from O(N 8) to O(N 4).
Huang and Sloan (1994) propose a related strategy which is more suitable for a cardinal
function basis. For a fourth order problem, their cardinal functions are
Ck(x) = (1 −x2)2
(1 −x2
k)2
π(x)
πx(xk)(x −xk)
(7.36)
where π(x) is the product of monomial factors constructed from the interior points of the
usual Chebyshev-Lobatto grid:
π(x) ≡
N−1
Y
i=2
(x −xi)
(7.37)
After the usual spectral discretization using these basis functions to give the generalized
matrix eigenproblem ⃗A⃗u = λ ⃗B⃗u, Huang and Sloan multiply both matrices by the diagonal
matrices whose elements are
Djj = (1 −x2
j)2,
j = 2, . . . , N −1
(7.38)
Like Heinrichs’ improvement for the non-cardinal basis, Huang and Sloan’s method
reduces the condition number to its square root. For a differential equation of order p, the
condition number is reduced from O(N 2p) to O(N p). Thus, it is possible to solve differen-
tial equations of quite high order with large N.

7.8. THE POWER METHOD
145
Although we have chosen to discuss condition number in the midst of a chapter on
eigenproblems because condition number is measured as a ratio of eigenvalues, the Hein-
richs and Huang and Sloan basis sets can be equally well employed for high order BOUND-
ARY VALUE problems.
7.8
Alternatives for Costly Problems, I: The Power Method
When the QR/QZ algorithm is too expensive, one needs iteration schemes which compute
only a single eigenvalue at a time. The simplest is the “power method”, which can be
applied both to the matrix discretization of an eigenproblem and also to the original time-
dependent equations from which the eigenproblem was derived. A couple of examples
will make the idea clearer.
First, suppose the goal is to calculate hydrodynamic instabilities. The ﬂow is split into
a user-speciﬁed “basic state” plus a perturbation, which is assumed to be initially small
compared to the basic state but is otherwise unrestricted. The ﬂow is unstable if the per-
turbation ampliﬁes in time.
A useful illustration is the barotropic vorticity equation in a “beta-plane” approxima-
tion on a rotating planet:
ψxxt + ψyyt + ψx(ψxxy + ψyyy) −ψy(ψxxx + ψxyy) + βψx = 0
(7.39)
where ψ(x, y, t) is the streamfunction for two-dimensional ﬂow and β is the latitudinal
derivative of the Coriolis parameter. For simplicity, we shall consider only a basic state
which is independent of x, that is, denoting the basic state by upper case letters,
Ψ(y) = −
Z y
U(z)dz
(7.40)
where U(y) is the “mean ﬂow”, a jet moving parallel to the x-axis.
The time-dependent variant of the power method is to integrate the equations of motion
from an arbitrary initial condition until the fastest-growing mode completely dominates the
solution, at which point the solution is the desired eigenmode and its growth rate and
spatial translation rate are the imaginary and real parts of the complex-valued phase speed
c, which is the eigenvalue.
There are two variants. The ﬁrst is to linearize the equations of motion about the basic
state:
ψ = ψ′ +
Z y
U(z)dz,
ψ′ ∼O(ϵ),
ϵ << 1
(7.41)
Since the perturbation is assumed to be very small, we can always expand the equations
of motion in a power series in the amplitude ϵ of the perturbation; the linearized equation
of motion is simply the O(ϵ) term in this expansion. The linearized barotropic vorticity
equation, for example, is
ψ′
xxt + (β −Uyy)ψ′
x + U(y)(ψ′
xxx + ψ′
xyy) = 0
(7.42)
where the prime on ψ denotes the perturbative part of the streamfunction.
In the linearized equation, feedback from the perturbation to the basic state, as happens
for the fully nonlinear equations of motion, is suppressed. This is a detriment because it
restricts the model to the early stages of the instability when the perturbation is very small.
However, it is also a virtue. The linearized stability problem is completely speciﬁed by the
speciﬁcation of the basic state.

146
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
The second variant of the time-dependent power method is to solve the full, nonlinear
equations of motion by starting from a perturbation of amplitude ϵ and integrating until
the amplitude is O(a) where a >> ϵ, but a is still small compared to the basic state. The
result will be the same as that of solving the linearized problem (on the same time interval)
to within an absolute error of O(a2) [relative error O(a)] because this is the leading order of
the terms neglected in the linearization. One virtue of this method is that it is unnecessary
to create a second computer program, with slightly different (i. e., linearized) equations of
motion, to explore linearized stability. Another is that one can easily extend the integration
further in time to explore how nonlinear feedback alters the growth and structure of the
amplifying disturbances. The disadvantage is that if there are unstable modes of similar
growth rates, one may be forced to stop the integration (to keep a << 1) before the fastest
growing mode has become large compared to all other modes.
In either variant, the growth rate and amplitude are estimated by ﬁtting the approxi-
mation
ψ(x, y, t2) −ψ(x, y, t1)
≈
Ξ(y) exp(ikx) {−ikct2) −exp(−ikct1)}
+complex conjugate
(7.43)
where t1 and t2 are two large but otherwise arbitrary times and Ξ(y) gives the complex-
valued latitudinal structure of the instability while c is the complex phase speed and k the
x-wavenumber, which must also be determined from the perturbation for large time.
Because the ﬁtting is a little tricky, and it sometimes requires a huge number of time
steps before the fastest-growing mode dominates its slower-growing brethren, it is often
more convenient to convert the time-dependent equations into a matrix eigenproblem. The
justiﬁcation for this step is that as long as the linearized equations have coefﬁcients which
are independent of time, all discretizations of the spatial dependence will collapse the lin-
earized PDE into a system of ordinary differential equations in time of the form d⃗u/dt = ⃗A⃗u
where ⃗A is a square matrix whose elements are independent of time. The usual theory of
constant coefﬁcient ODEs, found in most undergraduate differential equation texts, then
asserts that the general solution is a superposition of the eigenmodes of ⃗A, each oscillating
as an exponential of time with a complex frequency which is the corresponding eigenvalue
of ⃗A, assuming these are all distinct. The matrix formulation of linearized stability theory
is simply the computation of these eigenvectors and eigenvalues of ⃗A.
When the coefﬁcients of the linearized PDE do not vary with all the spatial coefﬁcients,
then one can separate variables still further. For the barotropic vorticity equation, one can
expand the solution in a Fourier series in x; if linearized with respect to a mean current
which varies only with y, the x-wavenumbers are uncoupled. A large two-dimensional
eigenvalue problem therefore collapses into a set of differential eigenproblems in y only,
one for each wavenumber in x. Denoting the wavenumber by k, the eigenproblem is
ψyy +
½β −Uyy
U −c
−k2
¾
ψ = 0
(7.44)
(In a minor abuse of notation that is almost ubiquitous in the literature, ψ(y) is used for
the eigenfunction even though the same symbol has already been employed for the total
time-dependent streamfunction.)
The power method can be applied directly to the matrix form of an eigenvalue problem
by ﬁrst discretizing the differential operator and then multiplying through by the appro-
priate inverse matrix to convert the problem into a standard (as opposed to a generalized)
matrix eigenproblem:
⃗Au = λ⃗u
(7.45)

7.8. THE POWER METHOD
147
Note that if we assume that ⃗A has as complete set of eigenvectors ⃗ej and expand a vector
u0
u0 =
X
j=1
aj⃗ej
(7.46)
then the result of multiplying u0 by the square matrix ⃗A will be a vector whose eigencoef-
ﬁcients will be the same except that aj is multiplied by λj, the eigenvalue associated with
⃗ej:
⃗Au0 =
X
j=1
λjaj⃗ej
(7.47)
If we iterate by repeatedly multiplying by powers of ⃗A, it follows that as the iteration
number k increases, the eigencoefﬁcients will be multiplied by λk
j and therefore the eigen-
function associated with the eigenvalue of largest magnitude will more and more dominate
the k-th power of ⃗A. As it does so, the ratio ||⃗A⃗u||/||⃗u|| will tend more and more towards
the magnitude of the largest eigenvalue where || || denotes any reasonable matrix/vector
norm.
This suggests the following algorithm for computing the eigenfunction and eigenvalue
for the mode of largest (absolute value) of eigenvalue. First, choose an arbitrary starting
vector u0 and then divide it by its norm so as to rescale it to unit norm. (The algorithm will
fail if u0 is orthogonal to the target eigenmode, but if u0 is a column of numbers from a
random number generator, the probability of such failure is negligibly small.) Then, repeat
the following loop over the iteration number k until the eigenfunction and eigenvalue have
converged to within the user-chosen tolerance:
⃗uk+1
=
⃗A⃗uk,
k = 0, 1, . . .
λk+1
=
||uk+1||
(7.48)
⃗uk+1
=
⃗uk+1/ ||⃗uk+1||
This is simply the matrix form of the power method: iterate until the fastest-growing mode
dominates. The third line of the loop is meant in the sense of a computational assignment
statement rather than mathematical equality — uk+1 is replaced by the same vector divided
by its norm to rescale it to unit norm. This renormalization avoids overﬂow problems.
When λ is complex-valued, the second line must be replaced by the average of the element-
by-element division of the new eigenvector by the old:
λk+1 = (1/N)
N
X
j=1
uk+1,j/uk,j
(7.49)
The matrix power method can be applied to any matrix, whether connected with sta-
bility problems or differential eigenproblems or not. It is very fast and cheap per iteration
because the most costly step is merely a matrix-vector multiply, which is a highly vectoriz-
able operation. However, the power method has the disadvantage that it can ﬁnd only the
mode of largest absolute value of eigenvalue, which may not be the only mode of interest.
In stability problems, it is quite common to have two unstable modes whose growth rates
switch dominance at some point in parameter space. In such transition regions where two
modes have the same or almost the same growth rates, the power method will fail.
In the next section, we therefore describe another algorithm which ﬁxes many of the
defects of the power method, albeit at a much higher cost per iteration. First, though, we

148
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
-30
-20
-10
0
10
20
30
0
1
2
3
4
First Guess
-30
-20
-10
0
10
20
30
0
1
2
3
x
Dispersive
Transient
Soliton
Figure 7.10: Illustration of the power method applied to the KdV equation. The initializa-
tion (“ﬁrst guess”) is u = 4 exp(−x2/2). At t = 20, this has split into a dispersing transient
(which moves left) and a single soliton (which moves rightward).
must note that the power method is not limited only to instability problems or only to
linear eigenvalue problems.
For example, the power method is a good way to compute solitary waves of the Korteweg-
deVries (KdV) equation:
ut + uux + uxxx = 0
(7.50)
The solitary waves are the solutions to the nonlinear eigenvalue problem
(u −c)uX + uXXX = 0
(7.51)
where X ≡x −ct is the coordinate in a frame of reference which is travelling with the
wave and c is the phase speed. By the power method, the ODE nonlinear eigenproblem
can be bypassed and solitons computed directly from the time-dependent equation: Inte-
grating forward in time from an arbitrary initial condition until the dominant eigenmode
has separated itself from the transients.
In stability problems, the separation is by separation-by-amplitude: the dominant mode
is fastest-growing and therefore eventually becomes larger than the other modes every-
where in space. For the KdV equation, the separation is spatial: the dispersing transients
travel leftward (because the group velocity for small amplitude waves of all wavenumbers
is negative) whereas the velocities of all solitary waves are positive. Because the amplitude
of a solitary wave decreases exponentially fast with distance from the center of the soliton,
the overlap between a given solitary wave and the rest of the solution decreases exponen-
tially with time. Thus, even though there is no instability and the eigenvalue problem is
nonlinear, the power method converges geometrically for the KdV equation.

7.9. INVERSE POWER METHOD
149
7.9
Alternatives for Costly Problems, II: Inverse Power Method
The matrix variant of the power method has the disadvantage that it can ﬁnd only the mode
of largest eigenvalue. The inverse power method, also sometimes called simply “inverse
iteration”, lacks this limitation. The algorithm is to apply the ordinary power method to
the matrix
⃗M ≡(⃗A −Λ⃗I)−1
(7.52)
where⃗I is the identity matrix and Λ is a user-speciﬁed constant. The eigenvalues of ⃗M are
µj =
1
λj −Λ
(7.53)
where the λj are the eigenvalues of the original matrix ⃗A, so the largest eigenvalue of the
shifted-and-inverted matrix ⃗M is the reciprocal of whichever eigenvalue of A is closest to
the shift Λ. It follows that the inverse power method will converge geometrically to any
eigenvalue of the matrix ⃗A, provided we have a sufﬁciently good ﬁrst guess (and set Λ
equal to it).
As usual, the inverse is not explicitly computed. Instead, one iterates
(⃗A −Λk⃗I)⃗uk+1
=
⃗uk,
k = 0, 1, . . .
µk+1
=
(1/N)
N
X
j=1
uk+1,j/uk,j
(7.54)
Λk+1
=
1/µk+1 + Λk
(7.55)
⃗uk+1
=
⃗uk+1/ ||⃗uk+1||
The disadvantage of the inverse power method is that the cheap matrix-vector mul-
tiply is replaced by solving a matrix equation, which is O(N) more expensive (by direct
methods). However, as explained in Chapter 15, one can often solve the matrix equation
implicitly (and cheaply) through a preconditioned Richardson iteration instead.
The inverse power method is very powerful because it can be applied to compute any
eigenmode. Indeed, the routines in many software libraries compute the eigenfunctions
by the inverse power method after the eigenvalues have been accurately computed by a
different algorithm.
The power and inverse power algorithms are but two members of a wide family of
iterative eigenvalue solvers. The Arnoldi method, which does not require storing the full
matrix ⃗A, is particularly useful for very large problems. Although the algorithm is too
complicated to describe here, Navarra(1987) used Arnold’s method to solve geophysical
problems with as many as 13,000 spectral coefﬁcients.
7.10
Mapping the Parameter Space: Combining Global and
Local Methods
In stability calculations, one often wants to compute growth rates as a function of two
or more parameters as shown schematically in Fig. 7.11. The so-called “neutral curve”,
which is the boundary between stability and instability in parameter space, is usually an
important goal. Unfortunately, for problems such as the barotropic vorticity equation, the

150
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Parameter One
Parameter Two
Figure 7.11: Schematic of a stability calculation in a two-dimensional parameter space. The
unstable region is shaded; it is bounded by the “neutral curve”. To map the parameter
space, it is efﬁcient to use the QR/QZ algorithm to solve the matrix eigenproblem on a
coarse grid (large Q’s) and ﬁll in the gaps with an inexpensive local iteration, such as the
power or inverse power method, applied to the pseudospectral matrix (solid disks). This
dual strategy is much cheaper than using the QR/QZ algorithm everywhere (which has
an O(10N 3) cost versus O(N 2) for either the power method or the inverse power method
(with ﬁnite difference preconditioned iteration for the latter).) At the same time, it is much
safer than using a one-mode-at-a-time eigensolver everywhere because this may easily
miss important eigenmodes.
neutral curve is precisely where the linearized equation is singular on the interior of the
domain similar to a Sturm-Liouville eigenproblem of the Fourth Kind.
In the next section, we describe a good strategy for computing the eigenvalues even
when the differential equation is singular.
However, there is a more serious problem:
to map a two-dimensional parameter space on a relatively coarse 32 × 32 grid requires
solving more than a thousand cases. If the QR/QZ algorithm is used for each, this may
be prohibitively expensive, especially in multiple space dimensions, even though a good
workstation never sleeps.
However, it is easy to miss easy modes with a local iterative method. Many an arith-
murgist has traced one branch of unstable modes with loving care, only to ﬁnd, years later,
that another undiscovered mode had faster growth rates in at least part of the parameter
space. A safer strategy is to apply the expensive global algorithm (QR/QZ) on a coarse grid
and then “connect-the-dots” by using an iterative scheme as illustrated in Fig. 7.11.

7.11. DETOURING INTO THE COMPLEX PLANE
151
7.11
Detouring into the Complex Plane: Eigenproblems with
Singularities on the Interior of the Computational Do-
main
Hydrodynamic stability and wave problems often have solutions with branch points on
or near the computational domain. These singularities, usually called “critical latitudes”
or “critical points”, create severe numerical difﬁculties. However, a good remedy (Boyd,
1985a) is to make a transformation from the original variable y such that the problem is
solved on a curve in the complex y-plane rather than on the original interval on the real y-
axis. With the proper choice of map parameter, one can loop the curve of integration away
from the singularity so that it does not degrade numerical accuracy.
To illustrate, consider
uyy +
·1
y −λ
¸
u = 0
with u(a) = u(b) = 0;
a < 0 & b > 0
(7.56)
where λ is the eigenvalue. If a and b were of the same sign so that the singularity was
not on the interior of the interval, y ∈[a, b], then (7.56) would be a normal, self-adjoint
Sturm-Liouville problem. As it is, not only the differential equation but also the solution
are singular on the interior of the interval.
After we have made a simple linear stretching to shift the interval from [a, b] to [−1, 1],
an effective transformation for (7.56) is
y = x + i △(x2 −1)
(7.57)
where △is a (possibly complex) mapping parameter. We solve the problem using a Cheby-
shev series in x ∈[−1, 1] in the standard way. Because of the change of variable, however,
the real interval in x is an arc in the complex y-plane which detours away from the singu-
larity. Since u(y) has a branch point at y = 0, the choice of looping the contour above or
below the real y-axis is an implicit choice of branch cut. The correct choice can be made
only by a careful physical analysis; for geophysical problems, Boyd (1982c) explains that
the proper choice is to go below the real axis by choosing △> 0 in (7.57); this implicitly
forces the branch cut to lie in the upper half of the y-plane.
Fig. 7.12a shows the contour of integration (dashed) while Table 7.2 illustrates the re-
sults for (7.56). The basis functions are sums of Chebyshev polynomials which vanish at
the endpoints so that each φn(x) individually satisﬁes the boundary conditions at x = ±1.
Despite the singularity, only 6 basis functions — a 6×6 matrix eigenproblem — is sufﬁcient
to yield both the real and imaginary parts of the lowest eigenvalue to within an error of
less than 1.4%.
The rightmost column also is a personal embarrassment. Boyd (1981b) solved this same
problem using an artiﬁcial viscosity combined with an iterative ﬁnite difference method
— and missed two eigenvalues with very small imaginary parts (Modes 3 and 7 in the
table). The mapped Chebyshev procedure does not require an artiﬁcial viscosity or any ﬁrst
guesses; the QR algorithm will ﬁnd all the eigenvalues of the matrix eigenvalue problem
automatically.
It is also a method with a weakness in that the Chebyshev series for u(y) converges most
rapidly for real x — but this is an arc of complex y. How is one to interpret an imaginary
latitude? The series converges more and more slowly as we move away from the arc that
corresponds to real x and it must diverge at the singularity at y = 0. Therefore, the detour
into the complex plane is directly useful only for computing the eigenvalues.
Once we have λ, of course, we can use a variety of methods to compute the correspond-
ing eigenfunction. Power series expansions about the branch point at y = 0 in combination

152
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
Table 7.2: Eigenvalues of a Singular Sturm-Liouville Problem: The First 7 Eigenvalues of
uyy + {1/y −λ}u = 0 Subject to u(±6) = 0 as Computed Using the Complex Parabolic
Mapping y = x + i∆(x2 −1) with ∆= 1/2.
Note: N is the number of Chebyshev polynomials retained in the truncation. The errors for N < 40 are the differences
from the results for N = 40 for the modes shown. Modes that are wildly in error or violate the theorem that the imaginary
part of the eigenvalue is always positive have been omitted; thus only one eigenvalue is listed for N = 6 although the
Chebyshev-discretized matrix eigenproblem had ﬁve other eigenvalues.
n
λ(N = 6)
Error (N = 6)
λ(N = 20)
Error (N = 20)
λ(N = 40)
1
0.1268
1.4 %
0.125054
Negligible
0.125054
+ i 0.2852
0.09 %
+i 0.284986
Negligible
+ i 0.284986
2
-0.296730
Negligible
-0.296730
+ i 0.520320
Negligible
+ i 0.520320
3
-0.638802
Negligible
-0.638802
+i 0.000262
Negligible
+ 0.000262
4
-1.21749
0.0008 %
-1.21750
+ i 0.563350
0.0004 %
+ i 0.563349
5
-1.60228
0.024 %
-1.60190
+ i 0.007844
0.24 %
+ i 0.007825
6
-2.72598
+ i 0.490012
7
-3.10114
+ i 0.070176
with shooting for larger y should work quite well. Since λ is known, there is no need
for iteration; the Runge-Kutta method, initialized near y = 0 via the power series, will
automatically give u(a) = u(b) = 0. Still, it is unpleasant to be forced to compute the
eigenfunctions in a second, separate step.
For hydrodynamic instabilities which are strongly unstable, the critical points are at
complex y. As shown through a barotropic instability calculation in Boyd (1985b), the de-
tour into the complex y-plane may be unnecessary near the points of maximum growth.
However, most stability studies map the “neutral curve”, which is deﬁned to be the bound-
ary of the unstable region in parameter space. On the neutral curve, the critical points are
on the real axis just as for (7.56). Thus, the mapping trick, despite its inability to compute
the eigenfunctions, is very useful for stability calculations.
In more complicated cases, multiple critical points may require maps that loop both
above and below the real y-axis as shown in Fig. 7.12b. In addition, when the interval is
unbounded, it may be necessary to combine the complex detour with the stretching map
that transforms an inﬁnite interval into a ﬁnite interval so that we can apply Chebyshev
polynomials as shown in Fig. 7.12d. Boyd (1985b) gives a thorough discussion of these
variants.
Gill and Sneddon(1995, 1996) have given some useful extensions of Boyd’s paper. Their
ﬁrst article gives an analytic formula for optimizing the quadratic map: If there is only one
critical latitude and its location is y = yc, then the mapping y = x+i△(1−x2) is optimized
by
yc = −i
n
yc ±
p
y2c −1
o
/2
(7.58)
When more than one critical latitude is sufﬁciently close to the domain to be troublesome,
more complicated transformations are useful. Gill and Sneddon show that the cubic map-

7.11. DETOURING INTO THE COMPLEX PLANE
153
ping
y = x −(α + i)(β0 + β1x)(x2 −1)
(7.59)
is free of cusps and loops, that is, self-intersections, for all real values of the three parame-
ters α, β0, β1.
When the singularity is very close to an endpoint, Gill and Sneddon (1996a) show that
the quadratic map is still effective: Even with yc = 0.99, the pseudospectral error is pro-
portional to O(1.44−N). This can be improved still further by iterating the quadratic map
using an analytical formula for optimizing the composite transformation. However, each
iteration of the composition raises the order of the poles of the transformed solution, so
the composite map is useful only for large N and very high accuracy. In multiple preci-
sion, they give good illustrations of “cross-over”: the composite mapping, which is always
superior to the standard quadratic mapping in the asymptotic limit N →∞, is worse for
small N.
Gill and Sneddon (unpublished preprint) extends the analysis to semi-inﬁnite inter-
vals, weaving together ideas from Boyd(1987b) as well as Boyd(1985a). The good news is
that they obtained quite useful analytical formulas for optimizing two different families of
mappings. The theoretical estimates of the total error were not very accurate for reasonable
N, but the convergence rates were gratifyingly high for their test problems.
Singular problems, and other difﬁcult eigenproblems like the Orr-Sommerfeld equa-
tion, require much higher N than our ﬁrst example. (Although not singular for real y, the
Orr-Sommerfeld eigenfunctions have thin internal layers and boundary layers.) Neverthe-
less, with N ≥40 and a complex-plane mapping when needed, even nasty eigenproblems
can be solved with high accuracy.

(a)
(b)
(c)
(d)
Re(y)
Re(y)
Re(y)
Re(y)
Im(y)
Im(y)
Im(y)
Im(y)
154
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
Figure 7.12: Four representative mappings for coping with singularities on or near the in-
terior of the integration interval. For each case, the real and imaginary y-axes are shown as
solid lines, the transformed path of integration as a dashed line, the branch cut proceeding
away from the singularity as a cross-hatched line, and the singularities are x’s.
(a) The solution has a branch point on the real axis. (The original and transformed integra-
tion paths intersect at the boundaries, y = a, b.)
(b) Two singularities on y ∈[a, b] with branch cuts that must be taken in opposite direc-
tions (typical for a symmetric jet).
(c) Identical with (a) except for the presence of additional singularities near (but not on)
the interval which force the transformed path to hug the real axis.
(d) Identical with (a) except that the integration interval is inﬁnite. The mappings for un-
bounded intervals (Chapter 17) may be freely combined with detours in the complex y-
plane.

7.12. COMMON ERRORS
155
7.12
Common Errors: Credulity, Negligence, and Coding
“Credulity” is a shorthand for believing that a calculation is accurate when it in fact is
nonsense. It is easier to be fooled than one might imagine.
In graduate school, I solved an eigenproblem with Chebyshev polynomials and beamed
happily at the smooth graphs of the eigenmodes. To be sure, the eigenvalues did seem to
jump around a bit when the resolution was varied, but the graphs of even the higher modes
were so smooth – I walked around in a fool’s paradise for weeks. Actually, I was solving
a Sturm-Liouville problem of the Fourth Kind with a nasty singularity right on the expan-
sion interval. Enlightment came when I graphed the second derivative of the eigenmodes,
and found it resembled the ﬁngerpainting of a crazed pre-schooler. I recovered from this
ﬁasco by applying a change-of-coordinate as described earlier. Plotting the reciprocal of
differences in eigenvalues for two different numerical resolutions should protect one from
a similar blunder. Well, most of the time.
Boyd (1996b) solved the so-called “equatorial beta-plane” version of the tidal equations,
and obtained two modes whose eigenvalues, equal in magnitude but opposite in sign,
changed almost negligibly with N. One was the so-called “Kelvin” wave, which is known
to have the simplest structure of all tidal modes and therefore should indeed be resolved
most accurately by any numerical solution. The other, however, was a sort of “anti-Kelvin”
wave that has no counterpart in reality.
The proof lies in the graph: Fig. 7.13 shows the zonal velocity for the two modes. The
wild oscillations of the lower mode, which become only wilder with increasing N, show
that it is a numerical artifact. Yet its eigenvalue is unchanged through the ﬁrst twelve
nonzero digits when N is increased from 36 to 50!
Obviously, the prudent arithmurgist will compare the eigenmodes, and not merely the
eigenvalues, for different N, at least occasionally. As pilots say, even when ﬂying on in-
struments, it is a good idea to occasionally look out the window.
“Negligence” is a shorthand for missing important modes. The QR/QZ algorithm com-
putes all the eigenvalues of a given matrix, so with this method for the algebraic eigenvalue
problem, failure is possible for a given mode only by choosing N too small. When QR is
-1
-0.5
0
0.5
1
-1
-0.5
0
0.5
1
cos(colatitude)
velocity:scaled
Anti-Kelvin
-1
-0.5
0
0.5
1
0
0.5
1
1.5
2
velocity
True Kelvin
Figure 7.13: Example Two (Inﬁnite Interval): Absolute errors in the eigenvalues for 16-
point (solid disks) and 32-point (open circles) TBn discretization.

156
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
replaced by an iterative, ﬁnd-one-mode-at-a-time algorithm, however, it is very easy to
overlook eigenmodes even if N is large enough to resolve them.
Boyd (1985a) records an embarrassing example. By combining the QR algorithm with
a Chebyshev pseudospectral method and a detour into the complex plane, I found that
my earlier calculations (Boyd, 1981a) had missed the third and seventh eigenmodes. Oops!
The earlier work had combined a local iterative method with continuation in the parameter.
However, these modes have very small imaginary part, and the older numerical method,
which did not use a complex-plane mapping, was sufﬁciently inaccurate to miss them.
It really is a good idea to use the QR/QZ method whenever possible. If one must iterate,
one must worry over the workstation like a parent watching over a toddler asleep with a
high fever.
Coding errors have also sent eigenvalue computations into the Black Swamp of Pub-
lished Errors. Of course, the misplaced “if” statement or the ever-dangerous sign error
can imperil any kind of calculation. Galerkin calculations, however, seem to be especially
prone to slips.
A good program-checking strategy is to apply the code to a simple problem with a
known solution. Unfortunately for Galerkin algorithms, solvable test problems usually
have diagonal Galerkin discretization matrices, and therefore do not test the off-diagonal
elements at all.
In ye olden days when computers were young and full of vacuum tubes, it was common
to derive the Galerkin matrix elements by hand calculations using recurrence relations.
Fox & Parker (1968) and Fox, Hayes and Mayer (1973) are good exemplars of this old
style; these recurrences are used in Orszag’s (1971b) classic article and furnish a couple
of pages of appendix in Gottlieb and Orszag (1977). It is so beautiful and elegant, revealing
whatever sparsity is present in the Galerkin matrix, that it is still widely used.
Unfortunately, these recurrences are risky. Each change of problem, even from the tar-
get differential equation to a test equation, requires redoing much of the algebra. Conse-
quently, a successful test is no guarantee that the algebra – much of it different – is correct
for the target problem, too.
O’Connor (1995) applied recurrences to Laplace’s Tidal Equation. This seemed partic-
ularly appropriate because the exact Galerkin matrix is sparse. However, the published
article contains one spurious mode and slightly incorrect eigenvalues for all the others as
corrected in O’Connor (1996). I know of other examples where the published work even-
tually fell under suspicion, but cannot name names because the authors never found their
errors.
Galerkin-by-recurrence-relation has been used successfully, but one should be very cau-
tious. Exact quadrature is no excuse for taking risks.

7.12. COMMON ERRORS
157
Table 7.3: A Selected Bibliography of Spectral Calculations for Eigenproblems
References
Comments
Longuet-Higgins(1968)
Laplace’s Tidal Equation; spherical harmonics;
special continued fraction algorithm
for tridiagonal Galerkin matrix
Birkhoff&Fix(1970)
Fourier and Hermite function Galerkin methods
Orszag (1971b)
Chebyshev; 4th order Orr-Sommerfeld stability eqn.
Noted usefulness of spectral combined with QR/QZ
Fox&Hayes
Double eigenvalue problem: 2d order ODE with
&Mayers(1973)
3 boundary conditions and 2 eigenparameters
Boyd (1978a)
Chebyshev domain truncation for quantum quartic oscillator
Chebyshev curve-ﬁtting for analytical approximations
to eigenvalue
Boyd (1978c)
more remarks on Chebyshev/QR connection
Boyd (1978b)
Chebyshev, Fourier & spherical harmonic bases on sphere
Banerjee (1978)
Eigenvalue problem: quantum anharmonic operator
Banerjee et al. (1978)
Hermite func. ψn(αy) with variable α
Boyd (1981a)
Eigenproblem with interior singularity
Boyd (1982b, c)
Atmospheric waves in shear ﬂow
Liu&Ortiz(1982)
Singular perturbations; tau method
Boyd (1983d)
Analytic solutions for continuous spectrum (ﬂuids)
Lund&Riley(1984)
sinc basis with mapping for radial Schroedinger equation
Liu&Ortiz&Pun(1984)
Steklov PDE eigenproblem
Boyd (1985a)
Change-of-coordinate to detour around around interior
singularity into the complex plane
Brenier&Roux
Comparison of Chebyshev tau and Galerkin
&Bontoux(1986)
for convection
Liu&Ortiz(1986)
PDE eigenproblems; tau method
Liu&Ortiz(1987a)
complex plane; Orr-Sommerfeld equation
Liu&Ortiz(1987b)
powers of eigenparameter in ODE
Boyd (1987a)
TBn basis: x ∈[−∞, ∞]
Boyd (1987b)
TLn basis: x ∈[0, ∞], Charney stability problem
Eggert&Jarratt
sinc basis;ﬁnite and semi-inﬁnite intervals, too, through
&Lund(1987)
map singularities at end of ﬁnite interval
Zebib (1987b)
Removal of spurious eigenvalues
Navarra(1987)
Very large meteorological problem (up to 13,000 unknowns)
via Arnoldi’s algorithm
Lin & Pierrehumbert (1988)
Tensor product of TLn(z) ⊗TBm(y)
for two-dimensional baroclinic instability
Gardner&Trogdon
Modiﬁed tau scheme to remove “spurious” eigenvalues
&Douglas(1989)
Boyd (1990d)
Chebyshev computation of quantum scattering
(continuous spectrum)
Malik(1990)
Hypersonic boundary layer stability; spectral multidomain
Jarratt&Lund&Bowers(1990)
sinc basis; endpoint singularities, ﬁnite interval
McFadden&Murray
Elimination of spurious eigenvalues, tau method
&Boisvert(1990)

158
CHAPTER 7. LINEAR EIGENVALUE PROBLEMS
Table 7.3: Bibliography of Spectral Calculations for Eigenproblems[continued]
References
Comments
Boyd (1992a)
Arctan/tan mapping for periodic eigenproblems
with internal fronts
Falques & Iranzo (1992)
TLn and Laguerre, edge waves in shear
Su&Khomami (1992)
Two-layer non-Newtonian ﬂuids
Mayer&Powell(1992)
Instabilities of vortex trailing behind aircraft
One-dimensional in r in cylindrical coordinates
Integration along arc in complex plane for near-neutral modes
Khorrami&Malik (1993)
Spatial eigenvalues in hydrodynamic instability
Chen (1993)
TLn(x) basis for semi-inﬁnite interval; nonparallel ﬂow
Boyd (1993)
Symbolic solutions in Maple & REDUCE
Huang&Sloan(1994b)
Pseudospectral method; preconditioning
Boyd (1996b)
Legendre, quantum and tidal equations;
traps and snares in eigencalculations
Gill& Sneddon
Complex-plane maps (revisited) for eigenfunctions
(1995,1996)
singular on or near interior of (real) computational domain
Dawkins&Dunbar
Prove tau method, for uxxxx = λuxx, always has 2 spurious
&Douglass (1998)
eigenvalues larger than N4
O’Connor(1995,1996)
Laplace’s Tidal Equation in meridian-bounded basin
Sneddon (1996)
Complex-plane mappings for a semi-inﬁnite interval
Straughan&Walker(1996)
Porous convection; compound matrix & Chebyshev tau
Dongarra&Straughan
Chebyshev tau/QZ for hydrodynamic stability
&Walker(1996)
Comparisons: 4th order vs. lower order systems
Boomkamp&Boersma
Pseudospectral/QZ algorithm for eigenvalue problem;
&Miesen&Beijnon(1997)
stability of two-phase ﬂow; 3 subdomains

Chapter 8
Symmetry & Parity
“That hexagonal and quincuncial symmetry . . . that doth neatly declare how nature Ge-
ometrizeth and observeth order in all things”
— Sir Thomas Brown in The Garden of Cyrus (1658)
8.1
Introduction
If the solution to a differential equation possesses some kind of symmetry, then one can
compute it using a reduced basis set that omits all basis functions or combinations of basis
functions that lack this symmetry. The branch of mathematics known as “group theory” is
a systematic tool for looking for such symmetries. Group theory is a mandatory graduate
school topic for solid-state physicists, physical chemists, and inorganic chemists, but it is
also important in ﬂuid mechanics and many other ﬁelds of engineering.
However, in ﬂuid mechanics, the formal machinery of group theory is usually not
worth the bother. Most of the observed symmetries can be found by inspection or sim-
ple tests.
8.2
Parity
The simplest symmetry is known as “parity”.
Deﬁnition 21 (PARITY) A function f(x) is said to be SYMMETRIC about the origin or to pos-
sess “EVEN PARITY” if for all x,
f(x) = f(−x)
(8.1)
A function is said to be ANTISYMMETRIC with respect to the origin or to possess “ODD PAR-
ITY” if for all x,
f(x) = −f(−x)
(8.2)
A function which possesses one or the other of these properties is said to be of DEFINITE PARITY.
The word “PARITY” is used as a catch-all to describe either of these symmetries.
Note that trivial function f(x) ≡0 is of BOTH EVEN & ODD parity — the only function
with this property.
159

160
CHAPTER 8. SYMMETRY & PARITY
Parity is important because most of the standard basis sets — the sines and cosines of
a Fourier series, and also Chebyshev, Legendre and Hermite polynomials — have deﬁnite
parity. (The exceptions are the basis sets for the semi-inﬁnite interval, i. e., the Laguerre
functions and the rational Chebyshev functions TLn(y).) If we can determine in advance
that the solution of a differential equation has deﬁnite parity, we can HALVE the basis set
by using only basis functions of the SAME PARITY.
The terms of a Fourier series not only possess deﬁnite parity with respect to the origin,
but also with respect to x = π/2. Consequently, it is sometimes possible to reduce the
basis set by a factor of four for Fourier series if the differential equation has solutions that
also have this property of double parity. The most studied example is Mathieu’s equation,
whose eigenfunctions fall into the same four classes that the sines and cosines do.
Theorem 22 (PARITY OF BASIS FUNCTIONS)
(i) All cosines, {1, cos(nx)}, are SYMMETRIC about the origin.
All sines {sin(nx)} are ANTISYMMETRIC about x = 0.
(ii) The EVEN degree cosines {1, cos(2x), cos(4x), . . . } and the ODD sines {sin(x),
sin(3x), sin(5x), . . . } are SYMMETRIC about x = ±π/2.
The cosines of ODD degree {cos(x), cos(3x), cos(5x), . . . } and the sines of EVEN
degree {sin(2x), sin(4x), . . . } are ANTISYMMETRIC about x = ±π/2.
(iii) All orthogonal polynomials of EVEN degree (except Laguerre) are SYMMETRIC:
{T2n(x), P2n(x), C(m)
2n (x), and H2n(x)}.
All orthogonal polynomials of ODD degree (except Ln(y)) are
ANTISYMMETRIC.
(iv) The rational Chebyshev functions on the inﬁnite interval, TBn(y), have the same
symmetry properties as most orthogonal polynomials (EVEN parity for EVEN sub-
script, ODD parity for ODD degree), but the rational Chebyshev functions on the
semi-inﬁnite interval, y ∈[0, ∞], TLn(y), have no parity.
The double parity of the sines and cosines is summarized in Table 8.1 and illustrated in
Fig. 8.1.
PROOF: (i) and (ii) are obvious. (iii) is a consequence of the fact that all the polynomials
of even degree (except Laguerre) are sums only of even powers of x, and all those of odd
degree are sums of {x, x3, x5, . . . }. [This can be rigorously proved by induction by using
the three-term recurrences of Appendix A.] Eq. (iv) may be proved along the same lines as
(iii); each rational function TBn(y) has a denominator which is symmetric about the origin
and a numerator which is a polynomial of only even or only odd powers of y. Theorem 22
then follows from the theorem below.

8.2. PARITY
161
Table 8.1: Symmetry classes for trigonometric basis functions.
“Even” parity with respect to x = π/2 means that the functions are symmetric with respect
to that point, that is,
f (−x + π) = f (x)
←→
Even parity about
x = π
2
or equivalently, f(π/2 −y) = f(π/2 + y) for the shifted variable y = x −π/2.
Similarly, antisymmetry with respect to π/2 implies that
f (−x + π) = −f (x)
←→
Odd parity about
x = π
2
Parity with
respect to
Parity with
respect to
Trig. Functions
x = 0
x = π
2
cos([2n]x)
Even
Even
cos([2n + 1]x)
Even
Odd
sin([2n]x)
Odd
Odd
sin([2n + 1]x)
Odd
Even
These four symmetry classes are illustrated in Fig. 8.1. The dotted lines on each graph
denote the symmetry planes at the origin and at x = π/2.
Theorem 23 (PARITY OF THE POWERS OF X)
(i) All EVEN powers of x are SYMMETRIC about the origin:
{1, x2, x4, x6, . . . } are of EVEN PARITY
(ii) All ODD powers of x are ANTISYMMETRIC:
{x, x3, x5, x7, . . . }
are of ODD PARITY
PROOF: Replace xn by (−x)n and see what happens.
Although trivial to prove, this theorem justiﬁes both Theorem 22 and the following.
Theorem 24 (POWER SERIES WITH DEFINITE PARITY)
A function of EVEN parity, i. e. f(x) = f(−x) for all x, has a power series expansion contain-
ing only EVEN powers of x. A function of ODD parity, that is, one such that f(x) = −f(−x),
can be expanded in a power series that contains only ODD powers of x.
PROOF: Odd powers of x change sign under the replacement x →(−x), so it is impos-
sible for a function to be symmetric about the origin unless its power series contains only
even powers of x. (Note that the powers of x are all linearly independent; there is no way

162
CHAPTER 8. SYMMETRY & PARITY
Figure 8.1: Schematic of the four symmetry classes of the terms of a general Fourier series
along with the simplest member of each class. All Fourier functions can be classiﬁed ac-
cording to their symmetry with respect to (i) x=0 and (ii) x = π/2. These symmetry points
are marked by the dashed vertical lines.
that possible cancellations among various odd powers can keep them from violating the
symmetry condition for all x.). Similarly, even powers of x would wreck the condition of
antisymmetry except perhaps at a few individual points.
Theorem 25 (DIFFERENTIATION AND PARITY)
Differentiating a function f(x) which is of deﬁnite parity REVERSES the parity if the differ-
entiation is performed an ODD number of times and leaves the parity UNCHANGED if f(x) is
differentiated an EVEN number of times.
PROOF: A function of even parity has a power series that contains only even powers of
x by Theorem 24. Differentiating x2n gives (2n) x2n−1 which is an odd power of x for any
n. Similarly, differentiating x raised to an odd number gives x raised to an even power.
Differentiating twice, however, merely restores the original parity.
These four theorems are elementary, but useful. One way of determining the parity
of a function with respect to x = 0 is to calculate its power series expansion about that
point. One can show rigorously that a function f(x) must retain its parity, if any, outside
the radius of convergence of the power series.

8.2. PARITY
163
Figure 8.2: Schematic illustrating the decomposition of an arbitrary function into its sym-
metric [S(x)] and antisymmetric [A(x)] parts.
It is usually possible to determine if the solution to a differential equation has parity
without ﬁrst solving it by inspecting the coefﬁcients of the equation and the boundary con-
ditions. We need a few preliminary results ﬁrst.
Theorem 26 (PARITY DECOMPOSITION)
An arbitrary function f(x) can be decomposed into the sum of two functions of deﬁnite parity,
f(x) = S(x) + A(x)
(8.3)
where S(x) is symmetric about the origin [S(x) = S(−x) for all x] and A(x) is antisymmetric
[A(x) = −A(−x)]:
S(x)
≡
f(x) + f(−x)
2
[Symmetric]
(8.4)
A(x)
≡
f(x) −f(−x)
2
[Antisymmetric]
(8.5)
PROOF: It is trivial to verify that the sum of S(x) and A(x) correctly adds up to f(x)
since the terms in f(−x) cancel. It is just as simple to verify that S(x) is symmetric since
the subsitution x →(−x) gives us back the same function except that f(x) and f(−x) have
swapped places with respect to the plus sign.
Fig. 8.2 gives a graphical proof of the theorem for the unsymmetric function f(x) =
(cos(x) + sin(x))/
√
2.

164
CHAPTER 8. SYMMETRY & PARITY
Theorem 27 (SYMMETRY PROPERTIES of an ODE)
Consider an ordinary differential equation in the form
0
X
n=N
an(x)dnu
dxn = f(x)
(8.6)
Then u(x) is a symmetric function if and only if the boundary conditions are compatible with sym-
metry and if also either
(i) every even coefﬁcient in (8.6) is even and the coefﬁcient of every odd derivative has
odd parity and also f(x) is symmetric or
(ii) every even coefﬁcient in (8.6) is odd and the coefﬁcient of every odd derivative has
even parity and also f(x) is antisymmetric.
Similarly, u(x) is an antisymmetric function if and only if the boundary conditions change sign
under the replacement of x by (−x) and also if either
(iii) every coefﬁcient of an even derivative in (8.6) is odd and the coefﬁcient of every odd
derivative has even parity and also f(x) is symmetric or if
(iv) every even coefﬁcient in (8.6) is even and the coefﬁcient of every odd derivative has
odd parity and also f(x) is antisymmetric.
PROOF: We will illustrate the argument with a second order equation, but the theorem
is true for general N. The ODE is
a2(x) uxx + a1(x) ux + a0(x) u = f(x)
(8.7)
Split all the functions into their symmetric and antisymmetric parts as
u(x) = S(x) + A(x);
f(x) = s(x) + a(x)
(8.8)
a2(x) = S2 + A2
;
a1(x) = S1 + A1
;
a0(x) = S0 + A0
(8.9)
Deﬁne ˜u(x) ≡u(−x), which need not have any deﬁnite parity; this solves
a2(−x) ˜uxx −a1(−x) ˜ux + a0(−x) ˜u = f(−x)
(8.10)
If we add (8.10) to (8.7) and divide by 2, similar to the way the symmetric function S(x) is
created from an arbitrary f(x) in Theorem 26, then we obtain an equation in which all the
terms are symmetric. Similarly, subtracting (8.10) from (8.7) gives an equation in which all
terms are antisymmetric. These two coupled equations are
S2 Sxx + A2 Axx + S1 Ax + A1 Sx + S0 S + A0 A = s(x)
S2 Axx + A2 Sxx + S1 Sx + A1 Ax + S0 A + A0 S = a(x)
[Symm. Eqn.]
[Antisymm.]
(8.11)
We can solve this coupled pair of equations in no more operations than for the original
single differential equation (8.6) — but no fewer unless the coefﬁcients satisfy the symme-
try conditions of the theorem. If we assume that u(x) is purely symmetric so that A(x) ≡0,

8.3. MODIFYING THE GRID TO EXPLOIT PARITY
165
then (8.11) implies that S(x) must simultaneously satisfy two equations. This is an impos-
sible task for a single function unless one of the pair of equations degenerates into 0 = 0.
With A(x) ≡0, (8.11) is
S2(x) Sxx + A1(x) Sx + S0(x) S = s(x)
(8.12)
A2(x) Sxx + S1(x) Sx + A0(x) S = a(x)
(8.13)
There are only two possibilities. One is that {S2, A1, S0} are non-zero while {A2, S1, A0,
a(x)} are all 0. In words, this means that the coefﬁcients of the second derivative and the
undifferentiated term are symmetric about x = 0 while the coefﬁcient of the ﬁrst derivative
is antisymmetric; the forcing function f(x) must also be symmetric or 0. This is (i) of the
theorem. The alternative is that all the coefﬁcients and the forcing function in (8.12) are
zero, and this is (ii) of the theorem. The proof for antisymmetric u(x) is similar. Q. E. D.
Thus, we can predict in advance whether or not a linear differential equation with a
particular set of boundary or initial conditions will have solutions with deﬁnite parity. The
same line of reasoning can be extended to nonlinear ordinary differential equations and to
partial differential equations, too.
8.3
Modifying the Grid to Exploit Parity
When the basis set is halved because the solution has deﬁnite parity, the grid must be
modiﬁed, too, as illustrated in Fig. 8.3
For example, if we use a “half-basis” of cosines only, applying collocation conditions
on x ∈[−π, π] is disastrous. The reason is that because all the included basis functions
have deﬁnite parity and so, by assumption, does the residual, the collocation conditions at
x = −jh where h is the grid spacing are identical to the collocation conditions at x = jh
(except for a sign change if the residual is antisymmetric). It follows that the pseudospectral
matrix will be singular because it has only N/2 linearly independent rows; each row has
the same elements (or the negative of the elements) of one of the other rows in the square
matrix.
This disaster can be avoided by restricting the collocation points to half of the original
interval as shown by middle panel in Fig. 8.3. Similarly, if u(x) has double parity, one must
restrict the collocation points to x ∈[0, π/2], one quarter of the spatial period, in order to
avoid redundant collocation conditions.
8.4
Other Discrete Symmetries
Parity is by far the most useful of symmetries because it is the simplest. More exotic exam-
ples are possible, however.
In the language of group theory, symmetry with respect to the origin means that f(x)
is “invariant under the actions of the group C2 in the complex plane”. This is a highbrow
way of saying that we can rotate a symmetric function f(x) through 180 degrees in the
complex x-plane, which is equivalent to replacing x by −x, without changing anything.
Functions may also be invariant under Cn, the group of rotations through any multiple
of 360 degrees/n. For example, if a function is invariant under C4, then its power series
expansion is of the form
f(x) =
∞
X
n=0
a4nx4n
[invariant under C4]
(8.14)

Full Basis: All sines & cosines
No symmetry
- π
0
π
Half Basis: 
      cosines ONLY
 OR  sines  ONLY
Parity
0
π
Quarter Basis: 
       ODD cosines ONLY
 OR EVEN cosines ONLY
 OR ODD sines  ONLY
 OR EVEN sines ONLY
Double
Parity
0
π/2
166
CHAPTER 8. SYMMETRY & PARITY
Figure 8.3: Grids for Fourier series.
Although this invariance is not an automatic property of basis functions, it is straight-
forward to take linear combinations of Chebyshev polynomials (or whatever) which are
invariant under C4.
A real world example of such a function is the third derivative of the similarity solu-
tion for a laminar boundary layer at separation (Boyd, 1997a). Functions which have C3
symmetry in the complex x-plane or are the products of such functions with a power of x
include the Airy functions Ai(x) and Bi(x) and the general, unseparated similarity solution
for boundary layer ﬂow.
Rotational symmetry is sometimes found in connection with parity and/or reﬂection
symmetry. Fig. 8.4 shows a familiar example: a snowﬂake, which is not only invariant
under the “rotation” or “cyclic” group C6 but also possesses the property that each of its
six points is symmetric about its midpoint. In the language of group theory, snowﬂakes
belong to the “dihedral” group D6. The signiﬁcance of “dihedral” as opposed to “cyclic”
symmetry is the we can reduce the basis set still further as shown below:
Cn
:
basis set is {1, cos(nx), sin(nx), cos(2nx), sin(2nx), . . . }
Dn :
basis set is {1, cos(nx), cos(2nx), . . . }
where x is an angular coordinate. Unfortunately, dihedral symmetry is rare: Travelling
waves will disrupt this symmetry unless we shift to a coordinate system that is travelling
with the waves.
Two- and three-dimensional symmetries also exist, and some are not simple combina-
tions of one-dimensional symmetries. A famous example is the Taylor-Green vortex, which
has been widely studied as a model for a three-dimensional turbulent cascade. This is the

8.4. OTHER DISCRETE SYMMETRIES
167
Figure 8.4: Illustration of the discrete rotation group Cn [no mid-sector symmetry] and the
dihedral group Dn [symmetric about some axis in each sector] for various n. (After Weyl,
1952.)
ﬂow that develops from the initial condition:
u
=
sin(x) cos(y) cos(z)
v
=
−cos(x) sin(y) cos(z)
(8.15)
w
=
r
2
3 cos(x) cos(y) sin(z)
with boundary conditions of periodicity of 2π in all three coordinates and constant viscos-
ity. One can show that the symmetries inherent in the initial condition — u is antisymmet-
ric about x = 0 and symmetric about y = 0 and z = 0 — are preserved for all time, even
though the equations of motion are nonlinear. Consequently, the solution for all times can
be expanded as
u
=
∞
X
m=0
∞
X
n=0
∞
X
p=0
umnp(t) sin(mx) cos(ny) cos(pz)
v
=
∞
X
m=0
∞
X
n=0
∞
X
p=0
vmnp(t) cos(mx) sin(ny) cos(pz)
(8.16)
w
=
∞
X
m=0
∞
X
n=0
∞
X
p=0
wmnp(t) cos(mx) cos(ny) sin(pz)
The symmetries inherent (8.16) allow a reduction of a factor of eight in the total number
of basis functions since we need only half of the possible one-dimensional basis functions

168
CHAPTER 8. SYMMETRY & PARITY
in each of x, y, and z as factors for our three-dimensional functions. This alone is a huge
savings, but Appendix I of Brachet et al. (1983) shows that the ﬂow is also symmetric with
respect to rotations through 180 degrees about any of the three axes: (i) x = y = π/2 (ii)
x = z = π/2 and (iii) y = z = π/2. In mathematical terms, this implies that 7 out of every 8
coefﬁcients in (8.16) are zero: m, n, and p must differ by an even integer (including 0). The
ﬂow is also invariant under a rotation by 90 degrees about the vertical axis x = y = π/2,
but the computer code did not exploit this ﬁnal symmetry.
The total number of degrees of freedom is reduced by a factor of 64. The result is a three-
dimensional code which, at 643 unknowns per ﬁeld, is equivalent in accuracy to a general
spectral code with 256 grid points in each of x, y, and z. Even 643 taxed the memory of
the best supercomputer of 1983, the Cray-1, so that the coefﬁcients and the corresponding
grid point representations would not both ﬁt in core memory at the same time, forcing an
intricate data shuttle to disk storage.
Brachet et al. (1983) note: “The present work has been possible because of the develop-
ment of new algorithms that take advantage of the symmetries of the Taylor-Green ﬂow”.
The “new algorithm”, given in their Appendix III, is an efﬁcient FFT for real Fourier series
whose non-zero coefﬁcients are all odd degree such as {1, cos(x), cos(3x), cos(5x), . . . }.1
Boyd (1986c) exploits a two-dimensional symmetry that has no counterpart in one di-
mension. In addition to parity in both x and y, the solution of the nonlinear PDE known
as “Bratu’s equation” is invariant under the C4 rotation group, which is equivalent to the
replacement of x by y and y by x. His article shows how to exploit the combined dou-
ble parity/C4 symmetries to reduce the basis set by a factor of eight, which allowed him to
solve the nonlinear two-dimensional BVP to ﬁve decimal places on a 1985-vintage personal
computer.
Similarly, L. F. Richardson, who made great contributions to numerical analysis, the
theory of war and conﬂict, meteorology, and fractals, solved a two-dimensional partial
differential in 1908 without the aid of a digital computer. He attacked Laplace’s equation
in the unit square subject to the boundary condition V (x, y = ±1) = 1 on the top and
bottom boundaries while V (x = ±1, y) = 0 on the sides. As shown in Fig. 8.5, the square
can be divided into eight triangles by horizontal, vertical, and diagonal lines. The vertical
and horizontal lines are lines of symmetry: the solution is symmetric with respect to both
x = 0 and y = 0. The diagonals are lines of antisymmetry, but there is a subtlety: it is
V (x, y) −1/2, not V (x, y) itself, which is antisymmetric with respect to the diagonals:
V (x + δ, x) −1/2 = −{V (x, x + δ) −1/2}
(8.17)
where δ is arbitrary and similarly for the other diagonal (Fig. 8.6).
Marcus(1984a,b, 1990) employs a “reﬂect-and-shift” symmetry for the velocities that
halves the number of Fourier modes (and the cost!).
Weyl(1952) and Hargittai and Hargittai(1994) are good popular treatments of symmetry
in nature and art.
1Kida (1985) set a new “record” for symmetry by identifying a ﬂow in which storage requirements are only
1/192 of what they would be for a general Fourier series with the same resolution.

8.4. OTHER DISCRETE SYMMETRIES
169
-1
0
1
-1
0
1
x
V=1
V=1
V=0
V=1/2
∂V/∂ z=0
V=0
AAAAAAA
AAAAAAA
AAAAAAA
AAAAAAA
AAAAAAA
AAAAAAA
AAAAAAA
AAAAAAA
Figure 8.5: Richardson’s Laplace equation problem. By exploiting symmetry; it is sufﬁcient
to solve the problem only in the shaded triangle with the indicated boundary conditions.
Symmetry then gives the solution in the other seven triangles.
-1
-0.5
0
0.5
1
-1
-0.5
0
0.5
1
 0.1
 0.1
 0.2
 0.2
 0.3
 0.3
 0.4
 0.4
 0.5
 0.5
 0.6
 0.6
 0.7
 0.7
 0.8
 0.8
 0.9
 0.9
x
 0.5
 0.5
Figure 8.6: Solution to Richardson’s Laplace problem.

170
CHAPTER 8. SYMMETRY & PARITY
8.5
Axisymmetric, Hemispheric & Apple-Slicing Models
If a physical problem does not have exact symmetries like the Taylor-Green problem, it
may still be possible to obtain big savings by making the approximation that various sym-
metries exist. Although unacceptable in operational forecasting, approximate symmetries
are widely used in meteorological research.
The crudest approximation is axisymmetry: The ﬂow is independent of longitude. In
spectral terms, the three-dimensional atmospheric ﬂow can always be represented without
error as a Fourier series in longitude with Fourier coefﬁcients that are functions of latitude,
height, and time. The assumption of axisymmetry is equivalent to truncating the Fourier
series at N = 0, i. e. keeping only the constant term. The longitude-independent approxi-
mation is terrible for day-to-day forecasting, but gives useful insights into climate.
Another simpliﬁcation is the hemispheric model: A grid that spans only the northern
hemisphere is justiﬁed by the ﬁction that the ﬂow has equatorial parity. “Symmetry about
the equator” has a special meaning to a meteorologist: From the Navier-Stokes equations,
one can show that it is not possible for all three ﬂow variables to be simultaneously sym-
metric about the equator. For example, the (linearized) x-momentum equation is
ut −f v = −1
ρ px
(8.18)
Since the Coriolis parameter is antisymmetric about the equator, it follows that v must have
parity opposite to that of u and p. Hemispheric models using spherical harmonics therefore
use symmetric basis functions for u, vertical velocity w, and p, but employ antisymmetric
harmonics to expand the north-south velocity v and the potential vorticity q.
A third approach is “apple-slicing”: Assuming that the spectrum is dominated by one
longitudinal wavenumber, and keeping only that wavenumber and its harmonics in the
basis set. The theory of “baroclinic instability” shows that when the global weather pat-
terns are expanded in a Fourier series, the coefﬁcients do not monotonically decrease with
zonal wavenumber k but rather show a large peak in the range of k ≈6 −8. A crude-but-
quick spectral approach is to keep just zonal wavenumbers from the set {0, 8, 16, 24, . . .
}.
The reason for the name “apple-slicing” is that this sort of truncation is equivalent to
assuming that the earth can be cut into eight wedges, bounded by meridians, with identical
ﬂow on each wedge. Consequently, solving for the weather on a single wedge gives the
ﬂow on all the other wedges. The “apple-slicing” approximation is equivalent to assuming
that the weather is invariant under rotations through 360/m degrees for some integer m.
The spectral series in longitude is then
u =
X
j=0
umj(φ, z, t) eimjλ
(8.19)
Fig. 8.7 illustrates this idea.
Simmons and Hoskins (1975) show that their “apple-sliced” model with m = 8, which
they used for preliminary experiments, needed only 0.084 seconds on the CDC7600 per
time step versus the 0.67 seconds/time step of their full model, which kept all spherical
harmonics up to a zonal wavenumber of 21.
Apple-slicing is a very good way of testing new paramerization schemes, vertical reso-
lution and so on. Half a dozen “apple-sliced” experiments have the same cost as a single
full-basis simulation. The disadvantages are obvious: it only applies to special problems
where the spectrum is dominated by intermediate wavenumber, and it is usually a rather
crude approximation.

8.5. AXISYMMETRIC & APPLE-SLICING MODELS
171
Figure 8.7: Schematic of “apple-slicing” on the sphere.
(a) Side view; the dynamics in the shaded sector [which is the computational domain] is
assumed to repeat periodically in all the other sectors of the sphere.
(b) A polar projection with the north or south pole at the center of the diagram, illustrating
C5 symmetry in a contour plot of a variable such as pressure or zonal velocity.

Chapter 9
Explicit Time-Integration Methods
“ . . . In my experience, many people who do computing are reluctant to look at numbers.
At Stanford, the general level of our students has been pretty high, but . . . their main
weakness is in their inability to look at outputs and extract the meaningful information . . .
In fact, they are generally less efﬁcient than the assistants I used to have . . . in the ACE days
[1948], in spite of having far superior mathematical qualiﬁcations. Most of those assistants
had experience with desk computers and had learned to “look at numbers”.”
“I certainly do not want to suggest that the way to acquire this habit is to serve an
apprenticeship on desk computers, but we have yet to learn how to instill the relevant
knowledge.”
— James Wilkinson, interviewed in BYTE, Feb. ’85
9.1
Introduction
An “implicit” time-marching scheme is one which requires solving a boundary value prob-
lem at every time step. “Explicit” schemes give the solution at the next time level in terms
of an explicit formula: un+1 = stuff where “stuff” is terms that can be evaluated by using
the solution at previous time levels. Implicit schemes are always more costly per time step
than their explicit counterparts, but implicit schemes allow a long time step, which often
makes them more efﬁcient. Semi-implicit schemes, which treat some terms in the PDE ex-
plicitly so as to simplify the boundary value problem, have become the norm in operational
weather forecasting and climate prediction.
Unfortunately, there are some schemes which defy such simple classiﬁcations. Semi-
Lagrangian algorithms, which have very good front-resolving and stability properties, are
explicit, but one has to solve an auxiliary problem, as in implicit schemes. We will describe
such algorithms in Chapter 14. The Regularized Long Wave equation (water waves) and
the quasi-geostrophic equation (meteorology, oceanography, and plasma physics where it
is the “Hasegawa-Mima” equation) have a differential operator acting on the time deriva-
tive, and thus rather confusingly require the solution of a boundary value problem at every
time step even when the time-marching algorithm is explicit. (See Sec. 6 below.)
In this chapter, we focus on explicit time-marching schemes. We shall assume that
the spatial dependence has already been discretized by the pseudospectral or Galerkin
172

9.1. INTRODUCTION
173
algorithm so that the remaining problem is to integrate a system of ordinary differential
equations in time of the form
ut = F(u, x, t),
(9.1)
where u and F are vectors, either of grid point values or spectral coefﬁcients.
Explicit time-marching methods are inevitably limited by an unphysical, purely com-
putational instability ﬁrst identiﬁed by Courant, Friedrichs and Lewy in 1928.
Deﬁnition 22 (Courant-Friedrichs-Lewy (CFL) Instability)
When the timestep τ for an EXPLICIT time-marching method exceeds a limit τmax that depends
on the time-marching algorithm, the physics of the underlying partial differential equation, and the
spatial resolution, the error grows exponentially with time. This exponential error growth is the
CFL Instability. All explicit methods have a ﬁnite τmax, but many implicit methods (discussed in
later chapters) are stable for arbitrarily large timesteps.
To obtain a precise value for τmax, one must analyze each individual combination of
spatial and temporal discretizations for each speciﬁc problem. However, it is possible to
offer an estimate.
Rule-of-Thumb 9 (CFL STABILITY LIMIT: PHYSICS)
The maximum timestep is the same order of magnitude as the time scale for advection or dif-
fusion or wave propagation or whatever across the SMALLEST distance h between two grid points.
Thus, for wave propagation and for diffusion, the limits are
τmax = d
h
cmax
[Waves]
τmax = d′ν h2
[Diffusion]
(9.2)
where d, d′ are O(1) constants, cmax is the speed of the FASTEST-MOVING waves and ν is the
diffusion or viscosity coefﬁcient, and h is the SMALLEST distance between two adjacent grid point,
h ≡minj|xj −xj+1|
(9.3)
The two most popular time-integration methods (with spectral algorithms) are the fourth-
order Runge-Kutta (“RK4”) scheme, which is given in all elementary numerical analysis
texts, and the third-order Adams-Bashforth method, which is
un+1 = un + τ
½23
12 F (un, x, tn) −4
3 F
¡
un−1, x, tn−1¢
+ 5
12 F
¡
un−2, x, tn−2¢¾
(9.4)
where τ is the time step and where tn = n τ.
The Runge-Kutta algorithm is rather expensive because the fourth order version re-
quires evaluating the vector F four times per time step. Since F must be computed by
calculating spatial derivatives and nonlinear products, usually with extensive use of Fast
Fourier Transforms, the evaluation of F is the most costly part of any time-marching calcu-
lation. However, Runge-Kutta schemes have considerable virtues, too. First, RK4 is fourth
order, that is, has an error decreasing as O(τ 4): one does not wish to sacriﬁce the high ac-
curacy with which spatial derivatives are computed in a spectral method by combining it
with a lousy time-marching routine.1 Second, it is stable with a rather long time step com-
pared to other explicit methods for both wave propagation and diffusion. Third, Runge-
Kutta methods are “self-starting” and do not require a different time-marching scheme to
1There is a tendency for Runge-Kutta schemes to have relatively large errors near the boundaries when numer-
ical (as opposed to behavior) boundary conditions are imposed. This is not a serious problem and never arises
with a Fourier basis; some remedies are known (Fornberg, 1996).

174
CHAPTER 9. EXPLICIT TIME-INTEGRATION METHODS
compute the ﬁrst couple of time steps, as is true of Adams-Bashforth. Fourth, one may
freely vary the length of the time step as the ﬂow evolves because the algorithm is self-
starting. Fifth, for only a little extra expense, one can compute Runge-Kutta methods of
adjacent orders simultaneously to obtain error estimates that can be used to dynamically
and adaptively vary the time step. Most ODE libraries offer a routine in which RK4 and
RK5 are combined (“RK45”) to vary the time step on the ﬂy to keep the error within a
user-speciﬁed tolerance. In contrast to most other algorithms, it is not necessary for the
user to specify a time step; the adaptive RK code will automatically choose one so that the
calculation is stable.
There are a couple of caveats. If one does know the time step in advance, then it is much
faster to use RK4 with that τ and no adaptation. Also, although the library adaptive codes
are quite reliable and robust, the RK4/RK5 code occasionally blows up anyway if the time
scale shortens abruptly. Even so, RK4 and adaptive RK4/RK5 are good time-marching
methods when the cost of evaluating F(u, x, t) is not excessive.
The third order Adams-Bashforth scheme requires an initialization phase in which u1
and u2 are computed from the initial condition u0 by some other procedure, such as RK4 or
a ﬁrst or second order scheme with several short time steps. One must also specify the time
step τ since adaptively varying the time step, to allow the code to choose its own time step,
requires restarting the march with a different time step. However, AB3 is stable, robust
and less costly per time step than RK4. Consequently, it, too, is widely used. Durran (1991)
praises AB3 as the most efﬁcient of the many algorithms he compares in his very readable
review of dissipation and phase errors in time-marching schemes.
Many alternatives have also been tried. In ye olde days, leapfrog was very popular
because of its simplicity:
un+1 = un−1 + 2 τ F (un, x, tn)
[Leapfrog]
(9.5)
It has the disadvantage that the solution at odd time steps tends to drift farther and farther
from the solution for even time steps, so it is common to stop the integration every twenty
time steps or so and reinitialize with the ﬁrst order forward Euler method, or else average
un and un−1 together. The method is only second order even without the averaging or
Euler steps. It is also unstable for diffusion for all τ, so it was common in old forecasting
models to “lag” the diffusion by evaluating these terms at time level (n −1), effectively
time-marching diffusion by a ﬁrst order, forward Euler scheme instead of leapfrog. With
Chebyshev polynomials, leapfrog is also unstable even for the simple wave equation
ut + ux = 0,
(9.6)
which may be taken as a prototype for advection (Gottlieb, Hussaini and Orszag, 1984).
With Fourier series, leapfrog is okay, but its popularity has fallen like leaves in the ﬁrst
winter snow.
The second order Adams-Bashforth scheme
un+1 = un + τ
½3
2 F (un, x, tn) −1
2 F
¡
un−1, x, tn−1¢¾
(9.7)
has also been used with spectral methods, but has fallen from grace because it has a very
weak computational instability for all τ. The growth rate is so slow that AB2 is quite satis-
factory for short-time integrations, but for long runs, AB2 is slow poison.
Canuto et al. (1988) and Durran (1991) give good reviews of other explicit schemes.
Often, however, the major worry is adequate spatial resolution, especially in computa-
tional ﬂuid dynamics. A second or even ﬁrst order time marching scheme may then be

9.2. SPATIALLY-VARYING COEFFICIENTS
175
adequate and the time step τ will be chosen to be the largest step that is stable rather than
the largest that achieves a certain time-marching error.
In any event, the big worry is not choosing a time integration scheme, but rather ﬁnding
a cheap way to evaluate spatial derivatives. In the next section, we discuss the problem and
its cure.
9.2
Differential Equations with Variable Coefﬁcients
Trouble appears even for a simple problem like
ut + c(x) ux = 0
(9.8)
with periodic boundary conditions and the initial condition
u(x, t = 0) = q(x)
(9.9)
If c(x) = c, a constant, then the solution of (9.8) is the trivial one
u = q(x −c t)
(9.10)
(This illustrates a general principle: constant coefﬁcient differential equations are best solved
by special algorithms. We shall illustrate this point for Chebyshev solutions of non-periodic
problems when we discuss matrix-solving methods in Chapter 15, Sec. 10.)
When c(x) is variable, the obvious collocation algorithm is very expensive. With a
cardinal function basis {Cj(x)}, leapfrog is
un+1
j
= un−1
j
−2 τ c(xj)
(N−1
X
k=0
un
k Ck,x(xj)
)
j = 0, . . . , N −1
(9.11)
where the second subscript denotes differentiation with respect to x. This is identical with
a ﬁnite difference scheme except that the derivative is evaluated using N points instead
of just three. This N-point formula is much more accurate than three-point differences,
but also much more expensive. Since the sum in (9.11) has N terms and we must evaluate
such a sum at each of N grid points at each and every time step, the leapfrog/cardinal
method has an operation count which is O(N 2/time step). Ouch! An explicit-in-time/
ﬁnite-difference-in-space code has a cost of only O(N)/time step.
Galerkin’s method is no improvement unless c(x) is of special form. If c(x) is a trigono-
metric polynomial (or an ordinary polynomial if solving a non-periodic problem using
Chebyshev polynomials), then Galerkin’s method yields a sparse matrix, i. e.
the sum
analogous to (9.11) has only a small, N-independent number of terms. To show this, let
u(x) =
N−1
X
m=0
am(t) φm(x)
(9.12)
If the basis functions φn(x) are orthogonal, then the spectral form of (9.8) is
an+1
m
= an−1
m
−2 τ
(N−1
X
k=0
an
k(t) (φm, c(x) φk,x)
)
(9.13)
If c(x) is a polynomial, then the matrix
Mmk ≡(φm, c(x) φk,x)
(9.14)

176
CHAPTER 9. EXPLICIT TIME-INTEGRATION METHODS
Figure 9.1: Schematic for the leapfrog/Fourier pseudospectral method. The arrows show
how the algorithm processes grid point values of u(x) at time level n [lower double circle,
left side] to generate {u(xj)} at time level (n + 1) [upper double circle]. The algorithm pro-
ceeds in a counterclockwise direction. (Inspired by a diagram of Vichnevetsky & Bowles
(1982).)
will be sparse and banded. (An explanation for the banded structure will be given in later
chapters.) Unless c(x) has such a special form, however, the matrix ⃗⃗M is a full matrix, and
leapfrog/Galerkin method will also cost O(N 2) per time step.
This is poor in comparison to the O(N) operation count for a spatial ﬁnite difference
algorithm. We seem to be trapped between Scylla and Charybdis2, but the pseudospectral
and Galerkin’s method are costly for different reasons. The cardinal function representation
(9.11) is not bothered in the least by the fact that c(x) is a function of x instead of constant;
the value of c(x) is merely multiplied into the value of ux at the j-th grid point. What wrecks
the cardinal function method is that evaluating the derivative requires a sum over the values
of u at all the grid points.
In contrast, Galerkin’s method is untroubled by differentiation because the derivative
of a trigonometric function is always a trigonometric function. Consequently, if c(x) were
constant, the matrix M deﬁned by (9.14) would have only a single non-zero element in each
row: the Fourier-Galerkin representation of differentiation (to any order) is a diagonal ma-
trix. What ruins the Galerkin method is the need to multiply the derivative by a complicated
function and then reexpand the product as a series of basis functions.
The remedy is a hybrid algorithm — part cardinal function, part Galerkin’s. This combi-
nation is usually dubbed the “pseudospectral” method (even though it contains Galerkin
ideas) because this hybrid algorithm is the only practical way to solve time-dependent
problems with non-constant coefﬁcients and large N.
The basic idea is to modify (9.11), the cardinal function representation, in one crucial
2In Greek mythology, two monsters that guarded either side of the [narrow!] Straits of Messina between Sicily
and Italy.

9.3. THE SHAMROCK PRINCIPLE
177
respect. Instead of evaluating ∂u/∂x by summing up all the derivatives of the cardinal
functions, use
ux =
X
k
i k ak eikx
(9.15)
The coefﬁcients of the derivative can be evaluated from those of u(x) in only N operations.
We can then evaluate the derivative series (9.15) at each of the N grid points to obtain u(xj).
We may now extrapolate in time with a ﬁnal step that needs only O(N) operations:
un+1
j
= un−1
j
−2 τ c(xj) un
x(xj)
j = 0, . . . , N −1
(9.16)
This is more like it!
For Chebyshev algorithms, differentiation is also an O(N) operation in spectral space.
Let
dqu
dxq =
N
X
k
a(q)
k
Tk(x)
(9.17)
so that the superscript “q” denotes the coefﬁcients of the q-th derivative. These may be
computed from the Chebyshev coefﬁcients of the (q −1)-st derivative by the recurrence
relation (in descending order)
a(q)
N =
a(q)
N−1
= 0
(9.18)
a(q)
k−1
=
1
ck−1
n
2 k a(q−1)
k
+ a(q)
k+1
o
,
k = N −1, N −2, N −3, . . . , 1
where ck = 2 if k = 0 and ck = 1 for k > 0.
The one ﬂaw is that there are still two expensive procedures that must be executed at
each step: (i) the calculation of the coefﬁcients {ak} from the grid point values {u(xj)}
(interpolation) and (ii) the evaluation of the derivative from the series (9.15) at each of
the N grid points (summation). If we execute these two steps the easy way — by matrix
multiplication — both cost O(N 2) operations, and we are worse off than before.
What makes the hybrid pseudospectral method efﬁcient is that we can replace the
costly, rate-determing matrix multiplications by the Fast Fourier Transform (FFT) algo-
rithm. This requires only O(5N log2 N) real operations to compute either grid point values
from coefﬁcients or vice versa. The bad news is that the FFT is applicable only to Fourier
series and to its offspring-by-change-of-variable, Chebyshev polynomials; this is a major
reason for the primacy of Fourier and Chebyshev expansions over all their competitors.
The FFT has been the foundation for the modern rise of spectral methods and is there-
fore the theme of the next chapter.
Fig. 9.1 is a schematic of the pseudospectral algorithm. The ﬁgure shows clearly that we
jump back and forth between the grid point representations of u(x) [to multiply by c(x)]
and the spectral coefﬁcients [to differentiate u(x)].
9.3
The Shamrock Principle
A millenium and a half ago, a Welsh bishop named Patrick was chieﬂy responsible for
converting the Irish people from paganism to Christianity. According to tradition, the doc-
trine of the Trinity was an especially hard one to understand: One God, yet three Persons:
Father, Son and Holy Spirit.

u(x)
Analytical
 form
{an}
n=0,...,N
Spectral 
Coefficients
{u(xj)}
j=0,...,N
Grid Points 
Values
Interpolation
Summation
178
CHAPTER 9. EXPLICIT TIME-INTEGRATION METHODS
St. Patrick devised an ingenious audiovisual aid: a little plant called the shamrock,
rather like a clover but with squarish leaves, which grows wild all over the country. Pluck-
ing a shamrock, he said, “Look! It is one plant, but it has three leaves. Three can be One.”
Pseudospectral time-marching require a similar conceptual awakening:
Principle 1 (SHAMROCK PRINCIPLE) In the limit N →∞, the set of spectral coefﬁcients
{an} and the set of gridpoint values {u(xj)} are fully equivalent to each other and to the function
u(x) from whence they come. These three different, seemingly very different representations, are
really just a single function.
Fig. 9.2 shows a shamrock with each leaf appropriately labeled. The grid point values
and the spectral coefﬁcients of a function u(x) and the function itself are all equivalent to
one another. We must freely use whichever form is most convenient.
Figure 9.2: A visualization of the Shamrock Principle, or the trinity of spectral methods.
The ﬁrst N Chebyshev coefﬁcients, {an}, and the set of N values on the interpolating grid,
{u(xj)}, are equivalent to the analytical deﬁnition of u(x), represented by the top leaf, in the
sense that either of these two sets allows one to compute u(x) to arbitrarily high precision
in the limit N →∞.
Via interpolation, one may pass from the “grid point representation”, {u(xj)}, to the “spec-
tral” representation, {an}. Summation of the Chebyshev series transforms {an} →{u(xj)}.
9.4
Linear and Nonlinear
Reviews of spectral methods in hydrodynamics (e. g., Orszag and Israeli, 1974) often justify
the pseudospectral algorithm by showing the inefﬁciency of Galerkin’s method for nonlin-

9.5. EXAMPLE: KDV EQUATION
179
Table 9.1: MATLAB code for Right-Hand Side of the System of ODEs in Time
function F=KdVRHS(t,u);
global k kcub
a=ifft(u);
% Compute Fourier coefﬁcients an from grid point values u(xj)
ax=k .* a;
axxx = kcub .* a; % Compute coefﬁcients of 1st and 3rd derivative
ux=real(fft(ax));
uxxx=real(fft(axxx) ); % Reverse FFT to get grid point values
% of ﬁrst and third derivatives
F= - u .* ux - uxxx;
% RHS of KdV ODE system. Nonlinear term evaluated by
%pointwise multiplication of u by ux
% In a preprocessing step, either in the main program or in a subroutine called once,
% one must execute the following to initialize the vectors k and kcub with the product
% of i with the wavenumber k and with the (negative) of its cube, respectively
for j=1:(n/2), k(j)=-i*(j-1); end;
for j=(n/2+1):n, k(j)=-i*(j-1 - n); end
for j=1:n, kcub(j)=k(j)*k(j)*k(j), end
ear equations. This is a little misleading because the real problem is not the nonlinearity
per se, but rather the fact that coefﬁcients of the differential equation vary with x.
Consequently, Sec. 2 deliberately discussed a linear equation. The methodology is ex-
actly the same for a nonlinear problem.
9.5
The Time-Dependent KdV Equation: An Example
To illustrate explicit time-marching with spectral discretization in space, examine the Korteweg-
deVries (KdV) equation:
ut + u ux + uxxx = 0
(9.19)
subject to the boundary condition of spatial periodicity with period 2π:
u(x + 2π) = u(x)
(9.20)
for all x. If the grid point values of u are used for time-advancement, as in a ﬁnite difference
code, the system of ordinary differential equations in time is
u(xj, t)
dt
= Fj(t) ≡−u(xj, t) ux(xj, t) −uxxx(xj, t)
(9.21)
A complete code must create the initial conditions, declare parameters, loop forward
in time and call the Runge-Kutta subroutine. However, all these steps are necessary with
ﬁnite difference or ﬁnite element discretizations of x, too. The only part of the overall code
that needs any knowledge of spectral methods is the subroutine that computes the right-
hand side of the system of ODEs in time, that is, the vector F. A ﬁnite difference code can be
upgraded to spectral accuracy merely by replacing the subroutine which calculates F.
Table 9.1 shows a Fourier pseudospectral subroutine (in the language MATLAB) for
evaluating this vector of grid point values for the KdV equation. It calls “fft” and “ifft”,
which are built-in MATLAB Fast Fourier Transform routines. It employs MATLAB’s oper-
ation for elementwise multiplication of one vector by another vector, which is denoted by
“.*”. A FORTRAN 77 subroutine would be a little longer because the elementwise multi-
plications would have to be replaced by DO loops and so on. Nevertheless, the brevity of
the subroutine is startling.

180
CHAPTER 9. EXPLICIT TIME-INTEGRATION METHODS
The ﬁrst line computes the Fourier coefﬁcients, a vector a, by taking a Fourier Trans-
form. The second line computes the coefﬁcients of the ﬁrst and third derivatives by multi-
plying those of u(x) by (ik) and (−ik3), respectively. (It is assumed that in a preprocessing
step, the vectors “k” and “kcub” have been initialized with the appropriate wavenumbers).
The third step is to take inverse Fourier Transforms to convert these coefﬁcients for the
derivatives into the corresponding grid point values. The ﬁnal step is to add the grid point
values together to form the vector F. Note that the nonlinear term is evaluated by point-
by-point multiplication of the grid point values of u with those of ux.
Tables 9.2 and 9.3 are short bibliographies of the simplest class of time-marching prob-
lems: PDEs with periodic boundary conditions, solved by Fourier series.
Table 9.2: Time-Marching with a One-Dimensional Fourier Basis
References
Comments
Abe&Inoue (1980)
Korteweg-deVries (KdV) nonlinear wave equation
Chan&Kerkhoven (1985)
Explicit & semi-implicit schemes for KdV eqn.
Fl˙a (1992)
Energy-conserving scheme for Derivative-NLS equation
Fornberg(1975)
Hyperbolic equations
Fornberg&Whitham(1978)
Nonlinear waves.: KdV, MKdV, Benjamin-Ono & others
Fornberg (1987)
Elastic waves; comparisons with ﬁnite differences
Frutos et al. (1990)
“Good” Boussinesq;
Hamiltonian (symplectic) time-marching
Frutos&Sanz-Serna (1992)
4-th order time integration for KdV & other wave eqns.
Garc´ia-Archilla(1996)
‘Equal Width‘ equation
Guo&Manoranjan (1985)
Regularized Long Wave (RLW) equation
Herbst&Ablowitz (1992)
Sine-Gordon eqn.; numerical instabilities;
integrable-to-chaos transition because of numerical errors
Herbst&Ablowitz (1993)
Symplectic time-marching, numerical chaos,
exponentially small splitting of separatrices
If&Berg&Christiansen
Split-step spectral for Nonlinear Schr¨odinger Eq.
& Skovgaard(1987)
with absorbing (damping) boundary conditions
Li&Qin (1988)
Symplectic time-marching
Ma&Guo (1986)
Korteweg-deVries equation; uses “restrain operator”
Mulholland&Sloan(1991)
Filtering and its effects on solitons for RLW, KdV, etc.
Mulholland&Sloan(1992)
Implicit & semi-implicit with preconditioning
for wave equations
Nouri&Sloan(1989)
Comparisons between pseudospectral algorithms for KdV
Qin&Zhang (1990)
Multi-stage symplectic schemes for Hamiltonian systems
Salupere&Maugin
KdV; many-soliton ﬂows
&Engelbrecht&Kalda(1996)
Sanders&Katopodes
KdV; RLW, Boussinesq eqs.
&Boyd (1998)
Sanugi&Evans (1988)
Nonlinear advection equation
Sloan (1991)
Regularized Long Wave (RLW) eqn.
Wang (1991)
Hamiltonian systems and conservation laws
Weideman&James (1992)
Benjamin-Ono equation
Zheng&Zhang&Guo(1989)
SLRW equation

9.6. IMPLICITLY-IMPLICIT: RLW & QG
181
Table 9.3: A Selected Bibliography of Time-Marching with Multi-Dimensional Fourier
Bases
References
Comments
Chen et al.(1993)
Three-dimensional turbulence: 5123 resolution
Fox&Orszag(1973)
Two-dimensional turbulence
Fornberg (1977)
Two-dimensional turbulence in doubly periodic box
Ghosh&Hossain
2D MHD turbulence (non-quadratic nonlinearity)
&Matthaeus(1993)
Haidvogel(1977, 1983)
Review of quasi-geostrophic models
Hald(1981)
Navier-Stokes equations
Hua&Haidvogel(1986)
Quasi-geostrophic turbulence; details of algorithms
Hua(1987)
Review of quasi-geostrophic ocean models
Kosloff&Reshef
Elastic waves (seismology)
&Loewenthal(1984)
Ma&Guo(1987a)
Two-dimensional vorticity equation
Tan&Boyd(1997)
Two-dimensional generalization of quasi-geostrophic eq.
Boyd&Tan(1998)
Solitary vortices, topographic deformations
Rashid&Cao
Low Mach number compressible ﬂuid ﬂow
&Guo(1993, 1994a,b)
Vallis(1985)
Doubly-periodic quasi-geostrophic ﬂow
9.6
Implicitly-Implicit: the Regularized Long Wave equa-
tion and the Quasi-Geostrophic equation
Some partial differential equations have time derivatives multiplied by a differential oper-
ator L, i. e.,
L ut = G(u, x, t)
(9.22)
To restate this in the canonical form
ut = F(u, x, t),
(9.23)
we must solve a boundary value problem for F:
L F = G
(9.24)
For such an equation, it is as laborious to apply an explicit method as an implicit method
because one must solve a boundary value problem at every time step. Hence, we shall
dub such equations “implicitly-implicit” because the computational labor of an implicit
time-marching algorithm is inevitable.
Two examples are the Regularized Long Wave (RLW) equation of water wave theory,
{1 −∂xx}ut = −ux −uux
(9.25)
and the quasi-geostrophic equation of meteorology and physical oceanography,
{∂xx + ∂yy}ψt = ψy (ψxxx + ψxyy) −ψx (ψxxy + ψyyy)
(9.26)
When the boundary conditions are spatial periodicity, the inversion of the operator L is
trivial for both examples.
For the RLW equation, for example, the ﬁrst step is to evaluate
G(xj, t) = −(1 + u(xj) ) ux(xj)
(9.27)

182
CHAPTER 9. EXPLICIT TIME-INTEGRATION METHODS
The second step is compute the Fourier coefﬁcients gn by a Fast Fourier Transform (FFT).
In a Galerkin representation, the boundary value problem Eq.(9.24) is
(1 + n2)fn = gn
→fn =
gn
1 + n2
(9.28)
where the {fn} are the spectral coefﬁcients of F(u, x, t) and where we have the used the
fact that the second derivative of exp(inx) is −n2 exp(inx). An inverse FFT then gives the
grid point values of F.
Fourth order Runge-Kutta requires four evaluations of F per time step. One might
think that this need for four boundary value solutions per time step would make “implicitly-
implicit” equations rather expensive to solve. The irony is that both our examples were
originally proposed as cheaper alternatives to other PDEs that could be solved by fully ex-
plicit methods!
For the RLW equation, the resolution of the apparent paradox is that the differential op-
erator acting on ut drastically slows the phase speed of short waves, allowing a much longer
time step than for KdV without computational instability. The quasi-geostrophic equation
was invented for similar reasons and used for the ﬁrst computer weather forecasts in 1950.
It continued in use until 1965 when the ﬁrst CDC6600s made it possible to forecast with
the “primitive equations”.
However, modern semi-implicit algorithms allow as long a time step for the primitive
equations as for the quasi-geostrophic equation. The boundary value problem of the semi-
implicit code is just as cheap to solve as that for quasi-geostrophy. The difference is that
the primitive equations model allows more accurate forecasts because it does not ﬁlter out
low frequency gravity waves and Kelvin waves, as quasi-geostrophy does.
Similarly, the KdV equation has been exorcised of its former frightfulness by a combina-
tion of fast workstations, which can solve one-dimensional problems quickly even with a
tiny time step, and semi-implicit time-marching algorithms, which allow it to be integrated
as quickly as its understudy, the RLW equation.
One parenthetical note of caution: when the boundary conditions are not periodic and
the operator which is inverted is of lower order than the rest of the equation, some spatial
discretizations of implicitly-implicit equations can generate modes with inﬁnite eigenval-
ues due to imposing the full set of boundary conditions on the matrix that discretizes the
lower order operator. For such dangerous “L-lower-order-than-G” problems, there are
simple remedies which are described in the section on the “Spurious Eigenvalue” problem
in Chapter 7.
“Implicitly-implicit” equations, that is, PDEs which require the solution of a boundary
value problem even for explicit time-marching, are now falling from favor. Implicit and
semi-implicit algorithms, which will be discussed at length in later chapters, can do the
same even better. Smart algorithms have replaced clever approximation.

Chapter 10
Partial Summation, the Fast
Fourier and Matrix Multiplication
Transforms and Their Cousins
“The derivative calculation [by Matrix Multiplication Transform] is the single
most computationally intensive step [in my spectral element code]; as a result;
a ﬁve-fold reduction in Navier-Stokes solution time is obtained when standard
vectorized FORTRAN code is substituted with library matrix-matrix product
routines on the Cray X-MP. Similar performance improvements are obtained by
employing hand coded matrix-matrix products on the iPSC/VX and iPSC/860
hypercubes.”
— Paul F. Fischer in an unpublished report (1991)
10.1
Introduction
Spectral time-marching algorithms are prohibitively expensive for large N unless the pro-
gram jumps back and forth between the cardinal function basis and the Chebyshev polyno-
mial basis at every timestep. The transforms between one representation and the other are
usually the rate-determining parts of a spectral calculation. It is therefore vital to perform
these transforms efﬁciently.
The Fast Fourier Transform (FFT) is the most efﬁcient algorithm for one-dimensional
transformations. However, the biggest savings are realized by performing multidimen-
sional transforms by “partial summation”. Instead of summing a series, one point at a
time, by a single DO or FOR/NEXT loop running over the entire two-dimensional basis,
the transform is factored into a nested sequence of one-dimensional transforms. Partial
summation and the FFT are closely related because both are based on a “divide and con-
quer” strategy of breaking a sum into smaller parts, evaluating each separately, and then
recombining.
Both these wonder-transforms impose restrictions. The FFT is applicable only to Fourier
series and Chebyshev polynomials. Partial summation requires that both the basis set and
the grids be tensor products.
183

184
CHAPTER 10. PARTIAL SUMMATION, THE FFT AND MMT
We shall also describe alternatives to the FFT. The Matrix Multiplication Transform
(MMT) is simply Gaussian quadrature (to interpolate) and direct summation (to evaluate).
It turns out that the MMT is suprisingly competitive with the FFT for small to moderate N.
By exploiting parity, the cost of the MMT can be halved. This is very important for the non-
FFT basis sets, which is all basis sets except Fourier series and Chebyshev polynomials, and
the images of Fourier and Chebyshev under a change-of-coordinate.
Fast algorithms for non-FFT basis sets have been extensively studied for two different
reasons. The ﬁrst is to develop an efﬁcient transform for large N. For example, as the
resolution of weather forecasting models increases — the 2000 vintage has N = 512 —
the cost of the MMT transform for Associated Legendre functions becomes an increasingly
large fraction of the total cost of the forecast.
The second reason is to interpolate and sum on a “non-canonical” grid. Even with
Fourier and Chebyshev series, the FFT is useless if the grid points are spaced irregularly.
Unfortunately, semi-Lagrangian time-marching schemes, which have wonderful front-resolving
and stability properties, require just such an “off-grid” interpolation at every time step.
We shall therefore describe non-FFT fast transforms at some length.
10.2
Partial Summation in Two or More Dimensions
Orszag (1980) saved a factor of 10,000 (!!) in the running time of his turbulence code CEN-
TICUBE (128 × 128 × 128 degrees of freedom) merely by evaluating the multidimensional
spectral transforms through partial summation. We will illustrate the idea through a two-
dimensional example.
It is important to note that partial summation applies only when both the basis func-
tions and grid are tensor products of one-dimensional functions and grids, respectively,
as will be assumed throughout the rest of this section. Non-tensor product bases of low
polynomial order are widely (and successfully) employed for ﬁnite elements on triangu-
lar subdomains. However, the cost of summations and interpolations rises so rapidly that
triangular spectral elements are often implemented by mapping the physical triangle to a
computational square and applying a tensor product basis on the square. There is only one
reason for the mapping: to gain the enormous cost reductions possible, when N is large,
by partial summation.
To evaluate the sum
f(x, y) =
M−1
X
m=0
N−1
X
n=0
amn φm(x) ψn(y)
(10.1)
at an arbitrary point as a double DO loop, a total of MN multiplications and MN additions
are needed even if the values of the basis functions have been previously computed and
stored1.
Since there are MN points on the collocation grid, we would seem to require a total
of O(M 2N 2) operations to perform a two-dimensional transform from series coefﬁcients
to grid point values. Thus, if M and N are the same order-of-magnitude, the operation
count for each such transform increases as the fourth power of the number of degrees in
x — and we have to do this at least twice per time step. A ﬁnite difference method, in
contrast, requires only O(MN) operations per time step. Good grief! With M = N = 32,
the pseudospectral method would seem to be 1,000 times more expensive than a ﬁnite
difference method with the same number of grid points.
1When the basis functions are orthogonal polynomials or trigonometric functions, we can exploit three-term
recurrence relations to evaluate the double sum in O(MN) operations without prior computation of the basis
functions — but this still gives a cost of O(MN) per point.

10.2. PARTIAL SUMMATION
185
Table 10.1: Partial Summation in Two Dimensions
Goal: To evaluate f(x, y) = PM
m=1
PN
n=1 amnφm(x)ψn(y) at each point of the tensor prod-
uct grid (xi, yj) given the spectral coefﬁcients amn.
Cost ∼O(MN 2 + M 2N) Operations,
O(3MN + M 2 + N 2) Storage
%Comment: F(i,j)=f(xi, yj), A(m,n)= amn, PHI(i,m)=φm(xi),
% PSI(j,n)=ψn(yj), B(j,m)=α(j)
m
for m=1 to Mmax
for j=1 to Nmax
B(j,m)=0
For n=1 to Nmax
B(j,m)=B(j,m) + PSI(j,n)*A(m,n)
End triple loop in n,j,m
for j=1 to Nmax
for i=1 to Mmax
F(i,j)=0
for m=1 to Mmax
F(i,j)=F(i,j) + PHI(i,m)*B(j,m)
End triple loop in m,i,j
Note: The reverse grid-to-spectral transform may be evaluated
via partial summation in the same way.
Suppose, however, that we rearrange (10.1) as
f(x, y) =
M−1
X
m=0
φm(x)
(N−1
X
n=0
amn ψn(y)
)
(10.2)
Let the points of the collocation grid be given by the tensor product (xi, yj) where i =
0, . . . , M −1 and j = 0, . . . , N −1. A key to the partial summation method is to evaluate
the function on the full two-dimensional grid by ﬁrst pursuing the more limited goal of
evaluating f(x, y) along a single line parallel to the x-axis which passes through the M
grid points for which y = yj. Deﬁne the “line functions” via
fj(x) ≡f(x, yj)
[“Line Functions”]
(10.3)
It follows from (10.2) that
fj(x) =
M−1
X
m=0
φm(x) α(j)
m
(10.4)
where the constants α(j)
m are simply the value of the braces {} in (10.2) at y = yj:
α(j)
m ≡
N−1
X
n=0
amn ψn(yj)
m = 0, . . . , M −1
j = 0, . . . , N −1
(10.5)
There are MN coefﬁcients α(j)
m , and each is a sum over N terms as in (10.5), so the ex-
pense of computing the spectral coefﬁcients of the auxiliary functions fj(x) is O(MN 2).

186
CHAPTER 10. PARTIAL SUMMATION, THE FFT AND MMT
Each auxiliary function describes how f(x, y) varies with respect to x on a particular grid
line, so we can evaluate f(x, y) everywhere on the grid by evaluating each of the N aux-
iliary functions at each of M grid points in x. However, the auxiliary functions are one-
dimensional, so each can be evaluated at a single point in only O(M) operations. The cost
for the sums in (10.4) over the whole grid is therefore O(M 2N).
Conclusion: by deﬁning auxiliary “line” functions that represent the original function
for a particular y-value on the grid, we have reduced the cost from
O(M 2N 2)[direct sum]
→→→
O(M N 2) + O(M 2N)[partial sums],
(10.6)
a savings of a factor of O(N). Pseudocode for the transform is given in Table 10.1.
In three dimensions, the reward is even greater. Let
f(x, y, z) =
L−1
X
l=0
M−1
X
m=0
N−1
X
n=0
almn φl(x) φm(y) φn(z)
(10.7)
Direct summation costs O(L2 M 2 N 2). The partial summations must now be performed in
two stages. First, deﬁne the two-dimensional auxiliary functions
fk(x, y)
≡
f (x, y, zk)
k = 0, . . . , N −1
[“Plane functions”]
=
L−1
X
l=0
M−1
X
m=0
α(k)
lm φl(x) φm(y)
(10.8)
where
α(k)
lm =
N−1
X
n=0
almn φn(zk)
l = 0, . . . , L −1
m = 0, . . . , M −1;
k = 0, . . . , N −1
(10.9)
Since there are N auxiliary “plane” functions, each with LM coefﬁcients which must be
evaluated by summing over N grid points in z, the cost of forming the fk(x, y) is O(L M N 2).
To evaluate these two-dimensional auxiliary functions, use (10.3) – (10.5), that is, deﬁne
fjk(x)
≡
f(x, yj, zk)
j = 0, . . . , M −1
;
k = 0, . . . , N −1
=
L−1
X
l=0
β(jk)
l
φl(x)
[“Line functions”]
(10.10)
where
β(jk)
l
=
M−1
X
m=0
α(k)
lm φm(yj)
l = 0, . . . , L −1;
m = 0, . . . , M −1;
n = 0, . . . , N −1
(10.11)
Since there are MN one-dimensional “line” functions, and each has L coefﬁcients which
must be evaluated by summing over M terms as in (10.10), the expense of setting up the
fjk(x) is O(L M 2 N). The cost of evaluating these MN “line” functions at each of the L
points on each grid line requires summing over L terms, so the cost of performing the
sums in (10.9) is O(L2M N).
Conclusion: in three dimensions,
O(L2M 2N 2)
→→→→→
O(L M N 2) + O(L M 2N) + O(L2M N)
(10.12)

10.3. THE FAST FOURIER TRANSFORM: THEORY
187
When L = M = N, partial summation reduces the cost by O(N 2/3).
We have deliberately left the basis set unspeciﬁed because this argument is general, and
independent of the basis set. Even if the Fast Fourier Transform is inapplicable, we can still
apply partial summation.
Unfortunately, there is still a “transform” penalty: if we have N degrees of freedom
in each dimension, the cost of the spectral-to-grid transform will be a factor of N greater
than the total number of grid points, N d, where d is the dimension. A pseudospectral
time-marching scheme, alas, will require at least one spectral-to-grid transform and one
grid-to-spectral transform per time step. In contrast, an explicit ﬁnite difference method
has a per-time-step cost which is directly proportional to the number of grid points.
For small to moderate N, the smaller N of the pseudospectral method (to achieve a
given error) may outweigh the higher cost per-degree-of-freedom. Unfortunately, the ra-
tio Npseudospectral/Nﬁnitedifference for a given accuracy is independent of N [typically
1/2 to 1/5 as explained in Chapter 2, Sec. 14] whereas the cost per time step grows lin-
early with N. However, when the solution has sufﬁcient small-scale variability, large N is
needed even for moderate accuracy. Because of the factor-of-N “transform penalty”, the
pseudospectral method must invariably lose the competition for efﬁciency at a moderate
error tolerance when the required N is sufﬁciently large.
However, there is an escape: if the basis functions are trigonometric functions, Cheby-
shev polynomials, or rational Chebyshev functions, then the “transform penalty” can be
lowered still further by performing the one-dimensional transforms via the Fast Fourier
Transform. This reduces the “transform penalty” for FFT-able functions to log2 N. Since
the logarithm grows very slowly with N, Chebyshev and Fourier pseudospectral methods
easily defeat their ﬁnite difference brethren in the war of efﬁciency.
To avoid drowning in formulas, we have only discussed the spectral-to-grid transform
in this section. However, exactly the same trick can be applied in the opposite direction to
calculate the coefﬁcients from f(xi, yj).
10.3
The Fast Fourier Transform: Theory
The FFT is restricted to Fourier and Chebyshev functions, but it is extremely powerful
since it removes almost all of the “transform penalty” discussed in the previous section.
The standard FFT has a cost of (assuming N is a power of 2)
N-pt. complex FFT ∼5N log2[N] total real operations
(10.13)
where “total operations” includes both multiplications and additions. To sum the same
one-dimensional series by direct summation requires the multiplication of a column vector
(of coefﬁcients or grid point values) by a square matrix. The cost of this Matrix Multiplica-
tion Transform (MMT) is
N-pt. complex matrix transform ∼8N 2 real operations
(10.14)
Costs will later be analyzed more carefully, but it is obvious that at least for large N,
the FFT is much faster than the MMT. In addition, the FFT both vectorizes well (for Cray
supercomputers) and parallelizes well (for massively parallel machines like the IBM SP2).
Therefore, its cost-savings will only become larger as the relentless march to larger and
larger N continues.
All software libraries offer a variety of canned FFT routines, so it is never necessary to
write an FFT code from scratch. For example, Numerical Recipes (Press et al., 1986) gives a
complete listing of an FFT code in FORTRAN, C, or Pascal, depending on the edition. Both

188
CHAPTER 10. PARTIAL SUMMATION, THE FFT AND MMT
one-dimensional and two-dimensional FFTs are built-in commands in MATLAB. And so
it goes. Nevertheless, it is useful to understand the theoretical basis of the FFT, and to
appreciate its similarities to multi-dimensional partial summation
Deﬁne the discrete transform as
Xj =
N
X
k=1
xk exp
·
−i k
µ2 πj
N
¶¸
j = 1, . . . , N
(10.15)
and the inverse by
xk = 1
N
N
X
j=1
Xj exp
·
i k
µ2 πj
N
¶¸
k = 1, . . . , N
(10.16)
(The notation and treatment follow unpublished notes by P. N. Swarztrauber; see Swarz-
trauber(1986).) What is striking about (10.15) is that it is not in the form of a standard
complex Fourier series for which the sum variable would run over both the positive and
negative integers as in
uj =
N/2−1
X
m=−N/2
am exp
·
−i m
µ2 πj
N
¶¸
j = N/2, . . . , N/2 −1
(10.17)
One reason for this odd convention is that if we introduce the parameter
w ≡exp
µ
−i
·2 π
N
¸¶
,
(10.18)
we can rewrite (10.15) as a power series in w:
Xj =
N
X
k=1
xk wjk
j = 1, . . . , N
(10.19)
Now the key to our success with multi-dimensional sums was that the three-dimensional
basis functions could be factored into the product of three one-dimensional functions. The
key to the FFT is that powers of w can be factored, too.
For simplicity, suppose that N is even. We can then split {xk} into two sequences of
length N/2 which consist of the even and odd parts, respectively:
yk ≡x2k
;
zk ≡x2k−1
k = 1, . . . , N/2
(10.20)
These have their own transforms which are
Yj ≡
N/2
X
k=1
yk w2jk
;
Zj ≡
N/2
X
k=1
zk w2jk
j = 1, . . . , N/2
(10.21)
If we could somehow deduce the transform of the original sequence from {Yj} and {Zj},
we would save a factor of 2; when evaluated by matrix multiplication, the cost of a trans-
form of length N is N 2 operations, so the two half-transforms (10.21) cost N 2/4 + N 2/4 =
N 2/2.
We can retrieve the transform of the original sequence Xj by segregating the even and
odd terms in (10.19) and then applying the deﬁnitions of the half transform (10.21):
Xj
=
N/2
X
k=1
h
x2k wj(2k) + x2k−1 wj(2k−1)i
(10.22)
=
Yj + w−jZj
j = 1, . . . , N/2
(10.23)

10.3. THE FAST FOURIER TRANSFORM: THEORY
189
Table 10.2: A Selected Bibliography on the Fast Fourier Transform
References
Comments
Carse&Urquhart (1914)
[Historical] Early but efﬁcient FFTs (“Runge grouping”);
printed computing forms used in place of digital computers
Deville&Labrosse(1982)
FORTRAN listings and a little theory for Chebyshev FFT
in one, two, and three space dimensions
Brachet et al.(1983)
Efﬁcient odd cosine transform
Temperton (1983a)
Explains why inclusion of factors of 4 and 6 in factorization
of N reduces cost by 15% for N = 64
also shows simultaneous computation of many transforms
is highly vectorizable and parallelizable
Temperton (1983b)
Fast real-valued transforms
Temperton (1985, 1992)
General prime-number factorization of N
Press et al.(1986)
Program listing for FFT code: C, FORTRAN or Pascal
(Numerical Recipes)
Swarztrauber (1986)
Efﬁcient cosine (Chebyshev) and sine transforms
Canuto et al.(1988)
Appendix B with detailed theory and
FORTRAN programs for cosine, Chebyshev transforms
Swarztrauber (1987)
Parallel FFT
van Loan (1992)
Highly-regarded monograph on FFT
Swarztrauber (1993)
Vector spherical harmonics; also cosine & sine transforms
Pelz (1993)
Parallel FFTs for real data
Briggs&Henson(1995)
Excellent, readable book on the FFT and its applications
Fornberg(1996)
Careful discussion of Chebyshev transform, etc.
There is one minor snag: Yj and Zj are only deﬁned for j ≤N/2. However,
w−j−N/2 = −w−j,
which implies
Xj+N/2 = Yj −w−jZj
j = 1, . . . , N/2
(10.24)
Together, (10.22) and (10.24) gives Xj for j = 1, . . . , N from Yj and Zj which are deﬁned
only for j ≤N/2.
Thus, we can indeed save a factor of two (for N even) by splitting the transform into
two parts and computing the partial sums of each. The trick is the same as for the two-
dimensional sums of the previous section if the “y” coordinate is imagined as having only
two degrees of freedom.
If N = 2M, then we can repeat this factorizing trick M times (until the Zj and Yj are
trivial transforms of length 1), and save roughly a factor of 2 at each step. (A more careful
count reveals the log2(N) factor in (10.13).)
We can modify this factorizing trick by separating the original sequence into three parts
of length N/3, or ﬁve parts of length N/5, or seven parts of length N/7, etc., if N is divisible
by 3, 5, or 7, respectively. The most general library subroutines will factor an arbitrary
N into primes and then subdivide the sums appropriately. The factoring of N requires
additional overhead, and the splitting of the transform saves less and less time as the prime
factors become larger. Consequently, most hydrodynamics codes choose N to be a power
of 2, or a power of 2 multiplied by a single factor of 3.
The articles and books in Table 10.2 give additional theory and advice.

190
CHAPTER 10. PARTIAL SUMMATION, THE FFT AND MMT
10.4
Matrix Multiplication Transform (MMT)
and Matrix Multiplication Transform
with Parity (PMMT)
In the grid-point-to-spectral-coefﬁcients direction, the Matrix Multiplication Transform (MMT)
is simply Gaussian quadrature. For example, a four-point transform would be
a0
w1φ0(x1)
w2φ0(x2)
w3φ0(x3)
w4φ0(x4)
f1
a1
=
w1φ1(x1)
w2φ1(x2)
w3φ1(x3)
w4φ1(x4)
f2
a2
w1φ2(x1)
w2φ2(x2)
w3φ2(x3)
w4φ2(x4)
f3
a3
w1φ3(x1)
w2φ3(x2)
w3φ3(x3)
w4φ3(x4)
f4
where the wj are the Gaussian quadrature weights multiplied by normalization factors and
the φj(x) are the basis functions, which could be Fourier, Chebyshev, Hermite, Associated
Legendre, etc. (The normalization factors are chosen so the square matrix above is the
inverse of the square matrix below, i. e., such that aj = 1, all other coefﬁcients zero when
f(x) = φj(x); numerical values are given in the Appendices.)
The backward, spectral-to-grid-point MMT is merely summation of the interpolant,
such as
f1
φ0(x1)
φ1(x1)
φ2(x1)
φ3(x1)
a1
f2
=
φ0(x2)
φ1(x2)
φ2(x2)
φ3(x2)
a2
f3
φ0(x3)
φ1(x3)
φ2(x3)
φ3(x3)
a3
f4
φ0(x4)
φ1(x4)
φ2(x4)
φ3(x4)
a4
The cost of an MMT is that of a single matrix-vector multiply: 8N 2 real operations for
complex-valued matrices and vector and 2N 2 operations for real-valued matrices and vec-
tors. However, these cost estimates are a bit misleading. Vector supercomputers and RISC
workstations have the hardware to perform matrix-vector multiplies very efﬁciently. Fur-
thermore, because the matrix-vector multiply is a key building block of many algorithms,
assembly-langauge routines to perform it are available on many machines, which roughly
halves the execution time.
The cost of the MMT can be halved for any any basis set whose elements have deﬁnite
parity to give the faster PMMT algorithm.
Theorem 28 (PARITY MATRIX MULTIPLICATION (PMMT)) If all the elements of a basis
set have deﬁnite parity, that is, are all either symmetric or antisymmetric with respect to x = 0, then
one may halve the cost of a matrix multiplication transform from grid space to spectral coefﬁcients
or vice versa by using the following algorithm.
Suppose that the even degree basis functions are symmetric while the odd degree are antisym-
metric with respect to x = 0. Sum the series
fS(xi) =
N/2
X
n=0
a2n φ2n(xi)
&
fA(xi) =
N/2
X
n=0
a2n+1 φ2n+1(xi)
(10.25)
at half of the grid points: all those for positive x, for example. The sum of both halves of the series at
all points of the grid is then given by
f(xi) =
½ fS(xi) −fA(xi)
fS(xi) + fA(xi)
i = 1, . . . , N/2
i = (N/2) + 1, . . . , N
(10.26)

x=π/4 x=π/2 x=3π/4 x=π
x=0
x=-π/4 x=-π/2 x=-3π/4
fS= f4 (f3+f5)
2
(f2+f6)
2
(f1+f7)
2
f8
fA=
(f5-f3)
2
(f6-f2)
2
(f7-f1)
2
10.4. MATRIX MULTIPLICATION TRANSFORM
191
Figure 10.1: Schematic of how the grid point values of a general function f(x) can be
decomposed into grid point values of its symmetric part fS(x) and its antisymmetric
part fA. In the case illustrated, the eight-point interpolant of f by a weighted sum of
{1, cos(x), cos(2x), cos(3x), cos(4x), sin(x), sin(2x), sin(3x)} is replaced by the ﬁve point in-
terpolant of fS(x) by {1, cos(x), cos(2x), cos(3x), cos(4x)} and the three point interpolant of
fA(x) by {sin(x), sin(2x), sin(3x)}.
The cost is only O(N 2/2) multiplications plus an equal number of additions (ignoring terms linear
in N). This is half the cost of the standard N-point transform because we have split the problem
into two transforms of length N/2.
This “parity transform” is applicable to Legendre polynomials, Hermite functions, rational
Chebyshev function (TBn(x)) on the inﬁnite interval and all other basis sets whose elements are all
either even or odd with respect to x = 0. It is not applicable to Laguerre functions or the rational
Chebyshev functions on the semi-inﬁnite interval, TLn(x).
PROOF: As noted in Chapter 2, an arbitrary function f(x) may always be split into its
symmetric and antisymmetric parts, fS(x) and fA(x), respectively. fS(x) is the sum of the
even degree basis functions only, so it may be computed by summing only (N/2) terms,
and similarly for the antisymmetric component.
Fig. 10.1 illustrates the PMMT in the opposite direction, grid point values {fj} to spec-
tral coefﬁcients. The N = 4 general MMTs given above simplify to
a0
w3φ0(x3)
w4φ0(x4)
f2 + f3
a2
=
w3φ2(x3)
w4φ2(x4)
f1 + f4
and
a1
w3φ1(x3)
w4φ1(x4)
f3 −f2
a3
=
w3φ3(x3)
w4φ3(x4)
f4 −f1

192
CHAPTER 10. PARTIAL SUMMATION, THE FFT AND MMT
for the forward transform while the reverse transform is
(f3 + f2)/2
φ0(x3)
φ2(x3)
a0
(f4 + f1)/2
=
φ0(x4)
φ2(x4)
a2
(f3 −f2)/2
φ1(x3)
φ3(x3)
a1
(f4 −f1)/2
=
φ1(x4)
φ3(x4)
a3
plus
f1
(f1 + f4)/2 −(f4 −f1)/2
f2
(f2 + f3)/2 −(f3 −f2)/2
f3
=
(f3 + f2)/2 + (f3 −f2)/2
f4
(f4 + f1)/2 + (f4 −f1)/2
Because the terms of a general Fourier series satisfy a double parity symmetry, we can
apply the above reasoning twice to split a 24-point transform (for example) into four 6 × 6
matrix multiplies: one for the even cosines, one for the odd cosines, one for even sines, and
one for the odd sines.
Theorem 28 appeared on pg. 255 of the 1989 edition of this book, but Solomonoff (1992)
published a note on the same idea and factor-of-two savings. It is just as well that he did,
because later references to the PMMT are sparse and generally refer to Solomonoff’s paper.
However, parity-in-transforms has a long history.
Runge (1903, 1905, 1913) used this double-parity reduction as the ﬁrst two steps of
his transform, which is a variant of the FFT. Sir Edmund Whittaker had special comput-
ing forms printed for “Runge grouping” for his computing lab at Edinburgh (Carse and
Urquhart, 1914); this was computer programming before there were digital, electronic com-
puters!
Runge’s ideas were forgotten and the FFT was reinvented several times before the re-
discovery by Cooley and Tukey (1965).
No doubt the parity transform will be independently rediscovered many times. Halv-
ing both execution time and storage is a useful savings.
10.5
Costs of the Fast Fourier Transform: FFT versus PMMT
Table 10.3 lists the cost of various algorithms for one-dimensional transforms. All the FFT
variants have a cost which is O(N log2(N) while all the Matrix Multiplication Transforms
have costs which are O(N 2). Except for the complex FFT, the cost of the FFT is always
O((5/2)N log2(N) where N is the number of points which are actually transformed. For
an odd cosine transform which computes cos(x), cos(3x), ..., cos([2N −1x)}, i. e., N odd
cosines, only N points on x ∈[0, π/2] are needed. The periodic grid spans x ∈[−π, π] with
a total of 4N points, but it is N, not 4N, that appears in the cost estimate.
The reason that the table has so many entries is that there are several factors which can
reduce the total cost by a factor of two:
• real-valued data
• symmetry with respect to the origin
• symmetry with respect to π/2
• exploiting parity in matrix multiplication transforms

10.5. COSTS OF THE FAST FOURIER TRANSFORM
193
Table 10.3: FFT costs
Note:
all costs are expressed in terms of real operations for an N-point transform where N is the num-
ber of basis functions of the proper symmetry which are transformed; complex multiplications and ad-
ditions have been converted to their equivalent costs in real operations.
FFT is the Fast Fourier Trans-
form, MMT is the Matrix Multiplication Transform and PMMT is the MMT split into two smaller matrix-
vector multiplies, one for the symmetric part of the function or series and the other for the antisymmetric.
FFT of complex data
5N log2(N)
MMT of complex data
8N 2
PMMT of complex data
4N 2
FFT of real-valued data
(5/2)N log2(N)
MMT of real-valued data
2N 2
PMMT of real-valued data
N 2
FFT cosine,sine or Chebyshev transform
(5/2)N log2(N)
MMT cosine,sine or Chebyshev transform
2N 2
PMMT cosine,sine or Chebyshev transform
N 2
FFT odd cosine, odd sine or odd Chebyshev trans.
(5/2)N log2(N)
MMT odd cosine, odd sine or odd Chebyshev trans.
2N 2
To apply the full, complex-valued FFT on 4N points to compute the ﬁrst N odd cosines,
for example, costs eight times more than an efﬁcient odd cosine transform. One factor of
two is for real data, another for parity with respect to the origin (a cosine series), and the
third for parity with respect to x = π/2 (odd cosine series).
However, these formal operation counts must be interpreted with caution. First, the
FFT has a lot of nested operations which create overhead that is not apparent in the count of
multiplications and additions. The MMT is just a matrix-vector multiply, which is a simpler
algorithm. Second, both the FFT and the matrix-vector multiply are such fundamental
algorithms that assembly-language, highly optimized codes to perform them are available
for many machines. These are typically faster than a FORTRAN subroutine by a factor of
two. Third, the relative efﬁciency of the algorithms is hardware-dependent.
The net result is that for small and moderate N, the MMT is much more competitive
than operation counts indicate (Fig. 10.2), at least for single transforms. The graph also
illustrates the strong hardware and software dependence of the relative costs of the algo-
rithm. On the personal computer, the FFT matches the efﬁciency of MMT at about N = 48,
but on the Cray, not until N = 512, a difference of a factor of 10! Fornberg’s ﬁgure contains
another curve, not reproduced here, that shows the relative efﬁciency and execution times
are strongly dependent on software, too. The FFT in the Cray library is much faster than
its FORTRAN equivalent and lowers the point where the FFT and MMT curves meet from
N = 512 to N = 128.
Clive Temperton (private communication, 1998) has noted that in large models, one
can usually arrange to compute many one-dimensional FFTs simultaneously. For example,
in a multi-level weather forecasting model, the transforms of velocities, temperature and
so on at each level are independent (i. e., logically in parallel). One can then program
so that “the innermost loops of the code step ‘across’ the transform, so that all the messy
indexing is banished to the outermost loops ... [where the cost is amortized over many one-
dimensional transforms]. I bet the break-even point between FFT and PMMT is lower than
N = 8, perhaps even N = 2!” The algorithmic details are given in Temperton(1983a) where
it is shown that the multi-transform strategy is very efﬁcient for both vector (Cray-YMP)
and parallel machines. Indexing and if statements, Because they are logical and integer
operations, are omitted from the usual ﬂoating point operation counts, but are nevertheless

8
16
32
64 128 256 512
N
E-2
E-3
E-4
E-5
E-1
FFT
Matrix Mult.
Matrix Mult.
PC
FFT
Cray
CPU Time (secs.)
194
CHAPTER 10. PARTIAL SUMMATION, THE FFT AND MMT
Figure 10.2: A comparison of the execution times of the Chebyshev (or cosine) transform
by FFT versus Matrix Multiplication Transform (MMT). (Lower is better!) In each pair, the
execution time of the FFT is the solid curve while the MMT is marked with disks. The top
pair of graphs were obtain on an IBM personal computer with an Intel 486DX33 central
processor while the lower pair was run on a Cray X-MP. Data from Fig. F-3.1 of Fornberg
(1996). Note that the FFT curves are for a single one-dimensional transform. When many
transforms are computed simultaneously (logically in parallel, even if not necessarily im-
plemented on parallel hardware), the indexing can be done once and amortized over many
transforms, greatly reducing the cost per transform.
a major expense of one-at-a-time FFTs for small to moderate N.
Thus, simultaneous transforms may be much faster than a single transform, but only
if coded carefully — off-the-shelf library software is often not optimized to perform many
transforms in a single subroutine call using Temperton’s inner loop/outer loop strategy.
(Exceptions include a routine in the Cray Scientiﬁc Subroutine Library and Roland Sweet’s
VFFTPACK, which is available on the Web.) This reiterates the point made earlier: the
relative efﬁciencies of the MMT and FFT are highly hardware and software dependent.
The cost of the FFT can be greatly reduced by machine coding, simultaneous computation
of many transforms, exploitation of symmetries (such as foreknowledge that the grid point
values are real-valued) and so on.
Spectral element models, with typically N ∼8, use a Legendre basis and the MMT
without tears: for such small N, the FFT would probably be slower than the MMT so a
Chebyshev basis has no advantage over Legendre. Orszag (1980) estimated that using the
FFT instead of MMT only reduced the cost of his 1283 turbulence model by a factor of two.2
Still, a factor of two is a signiﬁcant savings for a supercomputer code. The virtues of the
Fast Fourier Transform will continue to improve as the relentless march to larger and larger
values of N continues.
2Secret confession: I have never used the FFT for a pseudospectral program in BASIC, only for large codes that
needed FORTRAN or MATLAB, and then only sometimes.

1/r + r.r’/r 3 
+...
FMM
10.6. GENERALIZED FFTS AND MULTIPOLE METHODS
195
10.6
Fast Multipole Methods, the Orszag Transform, and Other
Generalized FFTs
Fast Multipole Methods (FMM) were originally developed for problems in stellar dynam-
ics, such as the motion of N stars in a model of an evolving star cluster. The naive approach
is to compute the total force on the j-th star by adding up the forces exerted upon it by each
of the other stars individually. The cost is O(N 2) operations per time step, which is very
expensive when N ∼100, 000, as would be appropriate for a globular cluster.
The idea behind FMM is illustrated by the schematic (Fig. 10.3) of two interacting star
clusters. The thousands of stars in the right cluster can be replaced by a series expansion
which converges geometrically. Thus, to calculate the forces on the stars in the left cluster
due to stars in the right cluster, we only need to sum a few terms of the multipole series
instead of thousands of individual interactions. If the force of the left cluster on the right is
calculated similarly, then the cost is reduced by a factor of two, assuming that interactions
between stars in the same cluster are still computed individually. By careful partitioning
of the cluster and the use of many overlapping multipole expansions in a nested hierarchy,
one can reduce the cost to O(N log2(N)) — an enormous saving.
Boyd (1992c) pointed out that the FMM can also be applied to cardinal function series.
This means that (i) FMM can be used as a fast transform for Hermite, Laguerre, spherical
Figure 10.3: Calculating the gravitational forces exerted by two star clusters (top half) is
rather expensive because every star interacts with every other. The multipole expansion
replaces many individual stars by a few terms of a series, greatly reducing the cost of
computing the pull of the right cluster on the stars in the left. 1/r is simply the distance
from a star in the left cluster (different for each star) to the center of mass of the right cluster.
The lowest term is Newton’s approximation: all the mass pulls on external objects as if the
whole cluster were shrunk to a point at its center of mass.

196
CHAPTER 10. PARTIAL SUMMATION, THE FFT AND MMT
Table 10.4: A Selected Bibliography of Generalized FFTs
Note: “FD” is an abbreviation for ﬁnite difference.
References
Comments
Taylor,Hirsh,
Comparison of FFT with MMT & conjugate gradient
Nadworny(1981,1984)
to estimate penalty for nonstandard (non-FFT) grid
Orszag (1986)
Fast FFT for almost any function with 3-term recurrence
Greengard&Strain (1991)
Fast Gauss transform (useful with Green’s functions,etc.)
Alpert & Rokhlin (1991)
Fast Legendre-to-Chebyshev transform
S¨uli&Ware (1991,1992)
Nonequispaced fast transform
for semi-Lagrangian time-marching
Boyd (1992c)
Showed FFM could be applied to (i) non-Chebyshev basis
(ii) non-equispaced grid for Fourier and Chebyshev
Boyd (1992d)
off-grid interpolation through two-step algorithm
(i) FFT-to-ﬁne-grid (ii) Lagrange interpolation on ﬁne grid
Moore&Healy&Rockmore(1993)
O(N log2(N)) exact Fourier transform for nonuniform grid
Dutt&Rokhlin (1993,1995)
FMM nonequispaced FFT
Jakob-Chien & Alpert
FMM for spherical harmonics
(1997), Jakob (1993)
Anderson & Dahleh(1996)
Taylor series about nearest equispaced point for
off-grid interpolation. Also do reverse off-grid interpolation
(from irregular grid to Fourier coefﬁcients) by iteration
Driscoll&Healy&Rockmore(1997)
O(N log2(N)) transform for any orthogonal polynomials
harmonics and other functions for which the FFT is inapplicable and (ii) for Fourier series
and Chebyshev polynomials, the FMM provides a fast method for off-grid interpolation.
To illustrate the ﬁrst application, let the grid points xj be the roots of φN(x) and let
Cj(x) denote the corresponding cardinal function. Then
f(x)
=
N
X
j=1
fjCj(xi)
=
φN(x)
N
X
j=1
fj/φN,x(xj)
x −xj
(10.27)
by virtue of the general construction of cardinal functions given in Chapter 5. However,
the lower sum in (10.27) is of the same form as the electrostatic or gravitational potential of
a sum of point charges or masses with (fj/φN,x(xj)) playing the role of the charge of the
j-th object.
It is trivial to evaluate the cardinal function series to compute f(x) on the canonical grid
because the j-th cardinal function is zero at all grid points except x = xj, but the evaluation
of the cardinal series for the ﬁrst derivative costs O(N 2) operations. Differentiation of the
cardinal series gives
df
dx(xi)
=
φN,x(xi)
N
X
j=1
fj/φN,x(xj)
xi −xj
+ φN(x)
N
X
j=1
fj/φN,x(xj)
−(xi −xj)2
=
φN,x(xi)
N
X
j=1,i̸=j
fj/φN,x(xj)
xi −xj
(10.28)
since the second sum is zero except for contributing a singular term which cancels the
i = j term in the ﬁrst sum. (To avoid unpleasant cancellation of singularities, one could
have noted that since the i-th cardinal function has a maximum at x = xi, its derivative

xm1
xM
xm2
x
µ0/(x-xM)+ ...
10.6. GENERALIZED FFTS AND MULTIPOLE METHODS
197
Figure 10.4: The grid point contributions on a typical interval, x ∈[xm1, xm2], can be re-
placed by one or a few terms of a multipole expansion when the target point x is sufﬁciently
far away, such as any of the grid points (short vertical lines) pointed to by the black arrows.
is zero at that point and one can therefore omit the i-th term in the sum in (10.27) before
performing the differentiation.) Thus, differentiation is a sum of multipole form, too. The
common factor of φN,x(xi) is computed and stored during the initialization of the program.
The multipole idea, deﬁning the “charges” qj ≡fj/φN,x(xj), is to replace a portion of
the sum where j ∈[m1, m2] by a geometric series in inverse powers of (x −xM) where
M = (m1 + m2)/2. It is implicitly assumed that this particular series will be used only for
x = xi which are far from the interval [xm1, xm2] (Fig. 10.4). For different ranges of xi, one
must use different multipole series, which makes the bookeeping a bit tricky. Nevertheless,
the rewards are great when N is very large. Without approximation,
m2
X
j=m1
qj
(x −xj)
=
1
x −xM
m2
X
j=m1
qj
µ
1 + xM −xj
x −xM
¶−1
=
∞
X
k=0
µk
µ
1
x −xM
¶k+1
(10.29)
where the “multipole moments” are
µk =
m2
X
j=m1
qj (xM −xj)k
(10.30)
In practice, the inﬁnite series of multipoles (which is exact) must be truncated to just a
handful of multipoles, which requires some careful thought about error tolerances. One
drawback of FMM is that the cost increases roughly linearly with the number of correct
digits.
A number of variations on this “divide-and-conquer” strategy have been devised. Alpert
and Rohklin (1991) have developed a fast (i. e., O(N log2(N)) algorithm for converting a
Chebyshev series to a Legendre series or vice versa. The heart of the algorithm is that the
elements of the transformation matrix vary smoothly with row and column indices, which
allows one to replace blocks of the usual matrix-vector multiply by expanding the matrix
elements as low order polynomials in the indices and then reversing the order of sum-
mation. Although their scheme does not directly compute derivatives, one can evaluate

198
CHAPTER 10. PARTIAL SUMMATION, THE FFT AND MMT
derivatives using the regular FFT on the Chebyshev series, so their algorithm allows fast
solutions to differential equations using a Legendre basis. Unfortunately, their algorithm
does not generalize to Associated Legendre functions because, except for the special case
of Legendre polynomials, the Associated Legendre-to-Chebyshev matrix is not sufﬁciently
smooth.
However, a variety of other schemes have been invented to transform spherical har-
monics including Dilts (1985), Brown (1985), and Jakob (1993) and Jakob-Chien & Alpert(1997)
(Table 10.4). Orszag (1986) devised an ingenious algorithm which can be applied to almost
any series of functions which satisfy three-term recurrence relations. This includes all or-
thogonal polynomials plus some types of Bessel function series. Driscoll, Healy and Rock-
more (1997) have developed a faster transform that for any set of orthogonal polynomials.
Unfortunately, the FMM/Fast Generalized Transform revolution has been long on in-
genuity and short on applications to spectral methods. The reason is that although these
algorithms have costs which are O(N log2(N), the proportionality constant, which is (5/2)
for a Chebyshev FFT, is very large for these algorithms. When N is 10,000, as in stellar
simulations, these algorithms generate vast savings. For the N = 213 resolution of 1996
spherical harmonics forecasting models, the savings relative to the Matrix Multiplication
Transform are so small — and perhaps nonexistent — that the FMM and its brethren have
not been used. As N rises in hydrodynamics models, however, such algorithms will be-
come increasingly attractive as alternatives to the MMT for basis sets like spherical har-
monics for which no FFT is known.
10.7
Transforms on an Irregular, Nonequispaced Grid: “Off-
grid” Interpolation
In Semi-Lagrangian time-marching schemes (Staniforth and Cˆot´e, 1991, and Ritchie, 1987,
1988, 1991), one must interpolate velocities and other ﬁelds to the departure points of tra-
jectories, which are spaced irregularly with the respect to the ﬁxed, evenly spaced Fourier
grid (or the uneven Chebyshev grid). Because the spectral series must be summed at N
unevely spaced, irregularly distributed points, the Fast Fourier Transform cannot be used
even with a Fourier or Chebyshev basis. Worse still, this “off-grid” interpolation must be
performed every time step.
The naive strategy is to simply sum the spectral series term-by-term, but this costs
O(N 2) operations versus the O(N log2(N)) cost of an FFT. However, there is an added
cost: because the grid points shift from time step to time step, the sines and cosines or
Chebyshev polynomials cannot be precomputed during program initialization, but must
be computed afresh at each step. This means that the cost of the MMT is O(N 2) with a large
proportionality constant instead of the usual factor of two. Since all other steps in a Cheby-
shev or Fourier semi-Lagrangian code can normally be performed by FFT and other fast
procedures, the “off-grid” interpolation is the rate-determining step, the most expensive
step, in the entire algorithm.
Fortunately, ﬁve strategies for fast off-grid interpolation are known. The ﬁrst is to apply
the FMM; ﬁrst published by Boyd (1992c), the FMM/off-grid procedures have been sys-
tematically developed by Dutt and Rohklin (1993, 1994). The second strategy is a Cheby-
shev polynomial expansion procedure invented by S¨uli and Ware (1991, 1992). Anderson
and Dahleh (1996) devised a similar algorithm with Taylor series instead of Chebyshev
series; they are unique by also providing an efﬁcient algorithm for the reverse off-grid
transform (from grid point values at a set of irregularly spaced points to Fourier coefﬁ-
cients.) Moore, Healy and Rockmore(1993) invented a fast O(N log2(N)) algorithm for

FFT
10.7. OFF-GRID INTERPOLATION
199
discrete Fourier transforms on nonuniform grids. Ware (1998) is a good review with some
original comparisons between different algorithms.
Figure 10.5: Boyd’s off-grid interpolation scheme, illustrated through a Fourier basis. The
ﬁrst step is a standard FFT (arrow) from an evenly spaced coarse grid with N points to
a ﬁner grid (bottom). The second step is low order polynomial interpolation to obtain an
approximation at the off-grid point (marked by the large “X”), using a small number of
grid points centered on the target (heavy circles).
The fourth strategy is a two-part procedure: (i) interpolate to a ﬁne grid, typically with
3N points, from the N-point canonical grid and (ii) apply low order polynomial interpola-
tion or Euler summation of the cardinal series on the ﬁne grid. It is clear that polynomial
interpolation, using the 2M + 1 points nearest the target point, is relatively inexpensive
with a cost of O(M 2N) operations at most. (We say “at most” because for large M, the
usual Lagrangian formulas can be replaced by more sophisticated algorithms with some
saving.) However, if polynomial interpolation is performed on the original grid, much ac-
curacy is lost: the precision of a hundred-point approximation to derivatives is replaced by
perhaps a seven-point approximation to velocities at the departure points.
On the ﬁne grid, however, the shortest waves in the function being interpolated have a
wavelength equal to 6hfine, assuming hfine = h/3. Boyd shows that each increase in M
by one will reduce the error in interpolating the 6hfine waves by a factor of four; for other
wavelengths, the ratio is 1/ sin2(π h/Wavelength), which is even larger. By choosing the
proper combination of M and the ratio of hfine/h, one can recover spectral accuracy at a
cost which is proportional to O(N log2(N)). The cost of the interpolation to the ﬁne grid of
3N points is three times the cost of an FFT on N points, but this still gives a relatively small
proportionality constant. The programming is also much easier than the Fast Multipole
Method; Lagrangian interpolation and the FFT are the key building blocks, and both are
FORTRAN library software or built-in commands in MATLAB.

200
CHAPTER 10. PARTIAL SUMMATION, THE FFT AND MMT
10.8
Fast Fourier Transform: Practical Matters
The ﬁrst point is: It is never necessary to write an FFT routine yourself. Not only are FFTs
available in most software libraries, such as the NAG and IMSL libraries, and as a built-in
command in MATLAB, but also many books give FORTRAN or C codes (Canuto et al.,
1988, Appendix B, Fornberg, 1996, Appendix F, Press et al., 1986). All three books give
special FFTs for (i) real data (ii) cosine transforms and (iii) sine transforms.
The second point is that unfortunately there is no universally accepted convention for
the FFT. Some software deﬁnes it as the complex conjugate of what other routines compute;
others begin the summation with zero instead of one, and thus multiply the transform by
exp(2πi/N), etc. It is very important to carefully read the documentation (or comment
statements) in your chosen library software to understand what it is computing.
For example, most FFTs sum over wavenumbers from k = 1 to N (as in our Eq. (10.19)
above) instead of k = −N/2 to k = N/2 −1, which is the usual convention in solving
differential equations. The sum over positive wavenumbers is an “aliased” form in the
sense that k = (3/4)N and k = −N/4 have identical grid point values on a grid of only N
points, and similarly for all wavenumbers k > N/2. To correctly compute derivatives, one
must multiply the coefﬁcient of a wavenumber k > N/2 by its “alias” whose wavenumber
is on k ∈[−N/2, N/2].
There are many formulas for extracting an optimal cosine transform from a general,
complex FFT if a cosine transform is not available. Details are given in the books by Canuto
et al., Fornberg, and Briggs and Henson (1995).
10.9
Summary
• For large N and a basis of Fourier functions or Chebyshev polynomials or rational
Chebyshev functions, the most efﬁcient way to pass from grid points to spectral co-
efﬁcients or vice versa is through the Fast Fourier Transform (FFT)
• If the solution has symmetries, such as periodic data which can be represented by a
cosine series instead of a full Fourier series, these symmetries can be exploited by the
FFT.
• The cost of the FFT is approximately ((5/2) log2(N) for all transforms of real-valued
data including cosine, sine, odd cosine, odd sine and Chebyshev transforms if N is
interpreted as the appropriate fraction of points on the periodicity interval which are
actually transformed
• The FFT, usually in several forms including separate, optimized subroutines for the
sine and cosine transform, is available in most software libraries and is also given
in Numerical Recipes (Press et al., 1986, 1992) and in Appendix B of Canuto et al. and
Appendix F of Fornberg (1996).
• Both the grid-point-to-spectral coefﬁcient transform (interpolation) and the spectral-
to-grid transform (summation of spectral series) can be performed by a square ma-
trix/vector multiply at a cost of 2N 2 operations for real-valued data; this is the Matrix
Multiplication Transform (MMT).
• For small to moderate N, the Matrix Multiplication Transformation is more efﬁcient
than the FFT for Chebyshev and Fourier calculations.
• The “cross-over” point where the FFT becomes faster than MMT is highly dependent
on both hardware and software and may range from N = 8 to N = 512.

10.9. SUMMARY
201
• When many one-dimensional transforms are computed simultaneously, the cost of
the FFT can be greatly reduced by banishing the indexing to the outermost loops.
• The FFT is restricted to the Fourier basis, Chebyshev polynomials, and basis functions
obtained from these by a change of coordinates.
• The MMT can be applied to any orthogonal polynomial or Fourier basis including
Hermite functions, Laguerre functions and others for which the FFT is inapplicable.
• For basis sets whose elements have deﬁnite parity, the MMT can be split into two
transforms of size N/2 to obtain the Parity Matrix Multiplication Transformation
(PMMT), which costs only half as much as the MMT.
• Generalized FFTs, many based on the Fast Multipole Method (FMM), have been de-
veloped for most non-FFT basis sets.
• The generalized FFTs, although faster than MMT or PMMT in the asymptotic limit
N →∞, have such large proportionality constants p in cost estimates of the form
O(pN log2(N)) that these algorithms have only rarely been used in pseudospectral
calculations.
• Fast algorithms for interpolating to a set of N points which are spaced irregularly
with respect to the standard pseudospectral grid have been developed; these have
a cost of O(N log2(N)) like the FFT, but with a proportionality constant three or
four times larger than for the FFT. (Needed for semi-Lagrangian time-marching al-
gorithms, among others.)
• Deﬁnitions of the FFT vary; read your documentation carefully and adjust the output
of the library software to the transform you want to compute.

Chapter 11
Aliasing, Spectral Blocking, &
Blow-Up
“Blowup of an aliased, non-energy-conserving model is God’s way of protecting you from
believing a bad simulation.”
— J. P. Boyd
”If a problem ... for which the solution develops a singularity in ﬁnite time ... is simu-
lated with a ﬁxed resolution, then a dealiasing procedure is advisable. Moreover, if a fully
turbulent ﬂow is simulated with marginal resolution, then dealiasing may also be useful.”
– Canuto et al.(1988, pg. 123)
11.1
Introduction
On a grid of N points, Fourier components exp(ikx) with |k| > N/2 appear as low wavenum-
bers; the high wavenumber is said to be “aliased” to the low. Phillips (1959) attributed
the blowup of his model of the earth’s general circulation (1956) to an instability speciﬁ-
cally caused by aliasing. Because of his work, many modern codes employ a “dealiasing”
procedure or special numerical algorithms that conserve the discretized energy so that a
runaway to supersonic winds is impossible.
There are precursors to blow-up. One is the appearance of “2h” waves in physical
space, that is, waves whose wavelength is twice the grid spacing h. This is accompanied
by a tendency for the Fourier coefﬁcients to curl up near k = π/h, the “aliasing limit”; this
growth with k, instead of the expected decay, is called “spectral blocking”.
In this chapter, we review all these matters. Although “aliasing instability” and dealias-
ing algorithms are well-known, there is still a major controversy as to whether heroic mea-
sures to control aliasing and/or enforce strict energy conservation are helpful or merely
misleading.
11.2
Aliasing and Equality-on-the-Grid
Although our real topic is spatial aliasing, the most familiar examples of aliasing are in
frequency. In a TV western, watch the six-spoked wheels of the stagecoach as it begins to
202

11.2. ALIASING AND EQUALITY-ON-THE-GRID
203
ω = (2 π)  6 s-1
ω = (2 π)  30 s-1
frame 
#0
frame #1
frame 
#0
frame #1
Figure 11.1: Frequency aliasing. Both panels show the motion of the hands of two clocks as
recorded by a conventional movie camera, which takes a frame every 1/24 of a second. The
left clock hand is turning at a frequency of 6 revolutions/second, so if the hand is vertical
in frame 0, it will be a quarter-turn clockwise in frame 1. The right clock hand is rotating at
30 revolutions/second — ﬁve times faster. However, on ﬁlm, the two stopwatches appear
identical. The hand of the right watch has turned through one-and-a-quarter revolutions in
the 1/24 second interval between frames, so it, too, is pointing to “three o’clock” in frame
1.
The frequency of the high-speed stopwatch has been “aliased” to the lower frequency, 6
turns/second, because a person who watched the ﬁlm, even in slow motion, would see the
clock hand turn through only a quarter of a turn [versus the actual ﬁve quarters of a turn]
between frames.
move. If you look carefully, you may see the spokes turning in the wrong direction for a
few moments, then come to rest, and ﬁnally begin to rotate in the opposite sense. The same
phenomenon is seen when the propeller of an airplane is started from rest.
The reason for this highly unphysical behavior is that a movie camera cannot contin-
uously photograph a scene; instead, the shutter snaps 24 times per second. This discrete
sampling creates errors that are mathematically identical to those caused by interpolating
a continuous function on a discrete grid of points. Frequencies whose absolute values are
higher than |ω| = 2 π(12)s−1 cannot be properly represented with such a limited sampling.
Instead, the eye — and mathematics — interprets the high frequency as some lower fre-
quency on the range
ω ∈(2π)[−12, 12] s−1
(11.1)
Fig. 11.1 illustrates the problem. The two ﬁgures appear identical on ﬁlm — the clock
hand is pointing to 12 o’clock in frame #0 and to 3 o’clock in frame #1. The frequency in
the left frame is only ω = (2 π)6/s while it is ﬁve times higher in the right panel. The
discrete sampling is unable to distinguish between rotation through 90 degrees per frame
and rotation through a full turn plus 90 degrees. To the eye, the higher frequency appears
as the lower frequency ωA = ω −(2 π)24/s.
One can show that all frequencies outside the range given by (11.1) will be “aliased” to
a frequency within this range. The upper limit in (11.1) is a motion which rotates through
180 degrees between frames. It might seem as though only frequencies sufﬁciently high
to rotate through a full turn between frames would be aliased. However, if the clock hand
turns through, say, 190 degrees per frame, it is impossible to distinguish this motion from

204
CHAPTER 11. ALIASING, SPECTRAL BLOCKING, & BLOW-UP
one which rotates through - 170 degrees per frame. Indeed, it is these motions which rotate
through more than a half turn but less than a full turn per frame that produce the bizarre
effect of propellers and wheels (apparently) rotating in the wrong direction.
Our real interest is pseudospectral methods rather than cinematic trivia, but the geo-
metric argument is useful because it indicates that high frequencies are not aliased to arbi-
trary frequencies, or to some mix of frequencies. Instead, the aliasing is always through a
positive or negative multiple of one full turn/frame. This is obvious from inspecting the clock
diagram because the eye will always perceive the clock hand as having rotated through
less than half a turn per frame, either clockwise or counterclockwise, regardless of the true
speed of rotation. If the number of rotations (through 360 degrees) per frame is r, then the
viewer will interpret the frequency as
(r −m) turns/frame
(11.2)
where m is that integer (positive, negative, or zero) such that
|r −m| < 1
2
(11.3)
Exactly the same applies to spatial aliasing.
Deﬁnition 23 (ALIASING) If the interval x ∈[−π, π] is discretized with uniform grid spacing
h, then the wavenumbers in the trigonometric interpolant lie on the range k ∈[−K, K] where
K ≡π/h and is the so-called “aliasing limit” wavenumber. The elements of the Fourier basis are
exp[i k x] with k an integer. Higher wavenumbers k such that |k| > K will appear in the numerics
as if they were the wavenumbers
kA = k ± 2 m K
m = integer
(11.4)
where
kA ∈[−K, K]
(11.5)
The wavenumbers outside the range [−K, K] are said to be “aliased” to wavenumbers within
this range and kA is the “alias” of k.
Eq. (11.4) is merely a restatement of the error law (4.44) for trigonometric interpolation
(Theorem 19) in Chapter 4. There, we stated without proof that if we used N points in
trigonometric interpolation so that cos([N/2]x) was the most rapidly oscillating function
in the basis set, then the computed sine and cosine coefﬁcients, {bn} and {an} were con-
taminated by those neglected coefﬁcients of the exact series, {αn} and {βn}, as
an =
∞
X
m=−∞
α|n+mN|
[Aliasing Law for Cosines in
Trigonometric Interpolation]
(11.6)
(on the endpoint/trapezoidal rule grid) and similarly for the sine coefﬁcients. Because
K = N/2, (11.6) and (11.4) are equivalent. We have made good the lack of an analytical
proof of the theorem in Chapter 4 by here giving a geometric proof (through clock-faces).
Aliasing may also be stated directly in terms of sines and cosines. Two trigonometric
identities imply
cos([j + mN] x) = cos(jx) cos(mNx) −sin(jx) sin(mNx)
(11.7a)
sin([j + mN] x) = sin(jx) cos(mNx) + cos(jx) sin(mNx)
(11.7b)

11.3. “2 H-WAVES” AND SPECTRAL BLOCKING
205
for arbitrary j and m.
When j and m are integers and x is a point on the grid, xi =
2 π i/N, i = 0, 1, . . . , (N −1),
cos(mNxk) = cos
µ
m N 2πk
N
¶
= cos(2 πk m) = 1 all integral k, m
(11.8a)
sin(mNxk) = 0
all integral k, m
(11.8b)
In consequence,
cos(jx)
G= cos([j + mN] x)
G= cos([−j + mN] x)
j = 0, 1, . . .
(11.9a)
sin(jx)
G= sin([j + mN] x)
G= −sin([−j + mN] x)
j = 1, . . .
(11.9b)
where the “G” above the equals sign denotes that the equality is true only on the N-pt.
evenly spaced grid. Similar relationships exist for the interior (rectangle rule) grid, too.
This special notion of equality — linearly independent functions that are point-by-point
equal on the grid — is the essence of aliasing. Canuto et al. (1988, pg. 40) offer a graphic
illustration of (11.9).
Recall that the error in solving differential equations has two components: a truncation
error ET (N) and a discretization error ED(N). The truncation error is that of approximat-
ing an inﬁnite series as a sum of only N terms. However, there is a second source of error
ED(N) because the N spectral coefﬁcients that we explicitly compute differ from those of
the exact solution.
Aliasing is the reason for these differences in coefﬁcients. “Discretization error” and
“aliasing error” are really synonyms.
Aliasing can cause numerical instability in the time integration of nonlinear equations.
For example, a typical quadratically nonlinear term is
u ux
=


K
X
p=−K
ap eipx




K
X
q=−K
i q aq eiqx


(11.10)
=
2K
X
k=−2K
bk eikx
(11.11)
where the bk are given by a sum over products of the ak. The nonlinear interaction has
generated high zonal wavenumbers which will be aliased into wavenumbers on the range
k ∈[−K, K], creating a wholly unphysical cascade of energy from high wavenumbers to
low.
When there is a numerical instability, the earlier assertion that the truncation and dis-
cretization errors are the same order of magnitude is no longer correct; ED can be arbi-
trarily large compared to ET . (Note that the truncation error, which is just the sum of all
the neglected terms of the exact solution, is by deﬁnition independent of all time-stepping
errors.) The statement ED ∼O(ET ) is true only for stable numerical solutions.
11.3
“2 h-Waves” and Spectral Blocking
The onset of aliasing instability can often be detected merely by visual inspection because
the waves at the limit of the truncation — k = K — are preferentially excited.

64 x 64 x 64   
96 x 128 x 216   
206
CHAPTER 11. ALIASING, SPECTRAL BLOCKING, & BLOW-UP
Figure 11.2: Streamwise vorticity contours at t = 22.5 in a transition-to-turbulence model.
The low resolution results are in the left half of the ﬁgure; the high resolution at right. The
plot should be symmetric about the dashed line down the middle, so the differences be-
tween left and right halves are due almost entirely to numerical errors in the low resolution
solution (left). Redrawn from Fig. 6 of Zang, Krist and Hussaini (1989).
Deﬁnition 24 (TWO-H WAVES) Oscillations on a numerical grid which change sign between
adjacent grid points — and therefore have a wavelength equal to twice the grid spacing h — are
called “2h-waves”. They are the shortest waves permitted by the numerical grid.
Assertion: a solution with noticeable 2h-waves has almost certainly been damaged by aliasing
or CFL instability.
Fig. 11.2 is an illustration of 2h-waves in a three-dimensional simulation of transition-
to-turbulence. As the ﬂow evolves, it develops ﬁner and ﬁner structures and consequently
requires higher and higher resolution. When solved at ﬁxed resolution, 2h-waves appear
as seen in the left half of the ﬁgure. These are suppressed, without any of the special tricks
described below, merely by using higher resolution (right half of the ﬁgure), which is why
these special tricks are controversial.
The 2h-waves are a precursor to breakdown. Although the 643 model still captures
some features at the indicated time, the corresponding plot at the later time, t = 27.5
(Zang, Krist, and Hussaini, 1989), is much noisier and accuracy continues to deteriorate
with increasing time.
The time-dependent increase in 2h-waves must be matched by a growth in the corre-
sponding Fourier coefﬁcients, namely those near the aliasing limit K = π/h. This is shown
schematically in Fig. 11.3; an actual spectrum from the same transition-to-turbulence model
is illustrated at different times in Fig. 11.4. The latter graph shows clearly that spectral
blocking is a “secular” phenomenon, that is, it gets worse with time. A numerical simula-
tion which is smooth in its early stages, with monotonically decreasing Fourier or Cheby-
shev coefﬁcients, may be very noisy, with lots of 2h-waves and a pronounced upward curl
in the coefﬁcient spectrum, for later times.
This curl-up in the absolute values of the Fourier or Chebyshev spectrum near the high-
est resolvable wavenumber (or near TN(x)) has acquired the following name.

wavenumber  k
0
π /h
spectral
blocking
11.3. “2 H-WAVES” AND SPECTRAL BLOCKING
207
Figure 11.3: Schematic of “spectral blocking”. Dashed line: logarithm of the absolute values
of Fourier coefﬁcients (“spectrum”) at t = 0. Solid: spectrum at a later time. The dashed
vertical dividing line is the boundary in wavenumber between the decreasing part of the
spectrum and the unphysical region where the amplitude increases with k due to numerical
noise and aliasing. The corrupted coefﬁcients are marked with disks.
Deﬁnition 25 (SPECTRAL BLOCKING) If the spectral coefﬁcients, when graphed on the usual
logarithm-of-the-absolue value graph, rise with increasing wavenumber or degree near the highest
wavenumber or degree included in the truncation, then this is said to be “spectral blocking”.
The name was coined by ﬂuid dynamicists. In turbulence, nonlinear interactions cas-
cade energy from smaller to larger k. Very high wavenumbers, with |k| > O(kdiss) for some
dissipation-scale wavenumber kdiss, will be damped by viscosity, and the coefﬁcients will
fall exponentially fast in the dissipation range, k ∈[kdiss, ∞]. Unfortunately, kdiss for a
high Reynolds ﬂow can be so large that even a supercomputer is forced to use a trunca-
tion K << kdiss. Aliasing then blocks the nonlinear cascade and injects energy back into
smaller wavenumbers. This spurious reverse cascade affects all wavenumbers, but is es-
pecially pronounced near the truncation limit k = K because these wavenumbers have
little amplitude except for the erroneous result of aliasing. The numerical truncation has
“blocked” the cascade, and the blocked energy piles up near the truncation limit.
In some ways, the term is misleading because the tendency to accumulate numerical
noise near k = π/h is generic, and not merely a property of turbulence. Nevertheless,
this term has become widely accepted. It is more speciﬁc than “high wavenumber noise
accumulation”, which is what spectral blocking really is.

-2
-4
-6
-8
-10
-12
-14
-16
0
Wavenumber k
16
32
0
t=15.0
t=18.75
208
CHAPTER 11. ALIASING, SPECTRAL BLOCKING, & BLOW-UP
Figure 11.4: Spectral blocking in a three-dimensional transition-to-turbulence model. As
time increases, more and more resolution is needed; by t = 27.5, the vorticity contour plot
(for this 64 × 64 × 64 run) is a sea of noise. Redrawn from Fig. 4 (“z resolution spectra”) of
Zang, Krist and Hussaini (1989).
A wave equation with constant coefﬁcients will have a truncation error ET because the
exact solution is, except for special cases, an inﬁnite series whereas the numerical approx-
imation includes only a ﬁnite number of terms. However, the Fourier pseudospectral dis-
cretization of a linear, constant coefﬁcient wave equation does not display spectral blocking
because waves of different wavenumbers are represented exactly as Fourier coefﬁcients. If
the time step is sufﬁciently short, the Fourier algorithm will advect these components with-
out amplitude or phase error so that the high wavenumbers in the truncation will not grow,
but rather will remain the same in amplitude. The lack of amplitude and phase errors in
propagation and advection is one of the great virtues of spectral methods.
If the equation has spatially-varying coefﬁcients, either due to nonlinearity or to spa-
tial variations in the wave environment such as a change in the depth of the water, then
even a spectral method will have aliasing error. The product of an x-dependent coefﬁcient
with u(x) has a Fourier expansion with components outside the truncation limit which are
aliased to smaller wavenumbers.
Although some spectral blocking is almost inevitable in a long time integration of a
nonlinear system (unless the dissipation is large), there is also a really stupid way to gen-
erate spectral blocking: Use too large a time step. For an explicit time-marching scheme
for the diffusion equation, for example, the high wavenumbers become unstable before
the low wavenumbers as the time step is increased. It is thus possible to accurately and
stably integrate the low wavenumbers while the wavenumbers near the truncation limit
are spuriously amplifying because the time step is too long. Since these high wavenum-
ber components have exponentially small amplitudes at t = 0 (if the initial condition is
smooth), the amplitudes of the high wavenumber components will remain exponentially
small for a ﬁnite time interval. However, the instability will cause the graph of the ampli-
tudes of the spectral coefﬁcients (on a log-linear plot) to curl up more and more with time,
i. e., exhibit spectral blocking. This result of violating the Courant-Friedrichs-Lewy (CFL)
timestep may be dubbed “CFL Blocking” or alternatively, “Really Stupid Blocking”.

11.3. “2 H-WAVES” AND SPECTRAL BLOCKING
209
Fig. 11.5 is an illustration. There is nothing special about the partial differential equa-
tion, boundary conditions, or initial condition; spectral blocking can occur for any linear
equation when the phase speed or diffusion rate of a mode increases with wavenumber or
degree so that the CFL criterion for aj(t) becomes increasingly restrictive as j increases.
0
5
10
15
10
-6
10
-4
10
-2
Coeffs. vs. Wavenumber
wavenumber k
Absolute value of Fourier coefficients
Short Timestep
Long
Timestep
0
0.5
1
10
-6
10
-4
10
-2
10
0
time
Absolute value of Fourier coefficients
k=15
k=14
k=13
k=0
k=1
k=2
k=3
k=4
k=5
k=6
k=7
k=8
k=9
k=10
k=11
k=12
Coeffs. vs. Time
Figure 11.5: Spectral blocking in a LINEAR differential equation due to violation of the CFL
timestep limit for LARGE wavenumbers (although the small wavenumbers are STABLE).
The low wavenumbers k = 0, 1, 2, . . . , 11 for basis functions exp(ikx) are stable (as are the
corresponding negative wavenumbers, not shown), but the three highest wavenumbers
grow exponentially with time for the long timestep used (solid curve). The dashed line
illustrates the amplitudes of the exact solution, which are independent of time. The solid
curve was generated by the adaptive fourth/ﬁve order Runge-Kutta subroutine ode45 in
Matlab 5.2 with 12 subroutine calls on the time interval t ∈[0, 1.25]. Because the high
wavenumber Fourier coefﬁcients are initially very small, inaccuracies in integrating them
had only a negligible impact on the accuracy of the initial step and so the adaptive rou-
tine happily picked a time step which was unstable for the highest three wavenumbers.
When the calculation was repeated with much more frequent calls to the subroutine ode45,
the adaptive routine was forced to use a short timestep, and all wavenumbers were accu-
rately integrated. The PDE is the linear Benjamin-Davis-Ono equation, ut = −H(uxx)
where H is the linear operator known as the Hilbert transform; in wavenumber space,
H {exp(ikx)} = isign(k) exp(ikx). Arbitrarily, the spatial period was chosen to be 2π and
the initial condition was u(x, 0) = 2tanh(1)/(1 −sech(1) cos(x)).
The CFL criterion can sometimes be exceeded in the middle of an integration even
though the computation is stable at t = 0. The reason is that the advective time-stepping
limit depends on the maximum current, and this can increase during the time evolution of
a ﬂow. Fig. 11.6 shows contour plots of four different time levels in the evolution of a dipo-
lar vortex. At t = 10, the ﬂow is still perfectly smooth, but then 2h-waves develop in the
zone of intense shear between the two vortices and rapidly amplify until the calculation be-
comes nonsense. The culprit is not lack of spatial resolution or a blocked turbulent cascade,

210
CHAPTER 11. ALIASING, SPECTRAL BLOCKING, & BLOW-UP
-2
0
2
-2
-1
0
1
2
timestep 10
-2
0
2
-2
-1
0
1
2
timestep 12
-2
0
2
-2
-1
0
1
2
timestep 14
-2
0
2
-2
-1
0
1
2
timestep 16
Figure 11.6: Streamlines of the evolution of two contra-rotating vortices. (Negative con-
tours are dashed). At the tenth time step (upper left), the ﬂow is very smooth, but 2h-waves
appear at the twelfth step and amplify rapidly. Although spectral blocking is occurring in
the sense that the high wavenumbers are rapidly amplifying after the tenth step, the difﬁ-
culty is completely cured by merely halving the time step.
however: the calculation can be extended indeﬁnitely merely by halving the timestep.
Elsaesser(1966a) describes a similar example in numerical weather prediction. His Fig.
12 shows a forecast two time steps before overﬂow; like our Fig. 11.6 [timestep 14, lower
left panel], Elsaesser’s ﬂow is smooth everywhere except for one small region where 2h-
waves have appeared, and his difﬁculty was cured by shortening the time step from four
hours to three hours.
If the timestep is sufﬁciently short, however, spectral blocking can still arise, but only
due to spatially-varying coefﬁcients in the differential equation. Nonlinear terms are merely
a special case of spatially-varying coefﬁcients.
11.4
Aliasing Instability: History and Remedies
Three-dimensional hydrodynamic codes known as “general circulation models” (GCMs)
have become a major tool in understanding future climate, such as the effects of an increase
in greenhouse gases in the atmosphere. The ur-GCM, the ancestral Adam from whence all
later models came, was Phillips (1956). Starting from rest, and imposing no forcing except a
mean north-south temperature gradient (warm at the equator, cold at the poles), the model
spontaneously developed mean jets and travelling vortices rather closely resembling those
of the real atmosphere. Hurrah!
Unfortunately, after a few more days of model time, the winds became supersonic. The
GCM had blown up!
Phillips tried to stabilize his model by greatly decreasing both the time step and the

11.5. DEALIASING AND THE ORSZAG TWO-THIRDS RULE
211
spatial grid size, but at roughly the same time (about 20 days) the model blew up anyway.
Although his model employed ﬁnite differences, he reasoned spectrally. He noticed that
the ﬁrst warning of the impending disaster was the appearance of 2h-waves. In Fourier
space, this means that energy is building up near the aliasing limit,
K ≡π h
↔
wavelength = 2h
(11.12)
Now the hydrodynamic equations are quadratically nonlinear. The interaction of a wave
with |k| > K/2 with another wave of similar magnitude must generate waves with k > K.
However, these cannot be resolved on a grid with spacing h, but are instead “aliased” to
waves of lower wavenumber. Phillips conjectured that this spurious, high-to-low wavenum-
ber transfer of energy was the source of his instability.
He tested his hypothesis (Philips, 1959) by repeating his earlier experiment with a twist.
Every few steps, he calculated the Fourier transform of the grid point values of each ﬁeld
and then set the upper half of the resolved spectrum to zero. That is to say, he applied the
all-or-nothing ﬁlter
ak →[filtered]



ak
|k| < K/2
0
|k| > K/2
(11.13)
It worked! With this ﬁltering, it was possible to integrate his model for arbitrarily long
periods of time.
In a note less than a full page long, Orszag (1971a) pointed out that Phillips’ ﬁltering
was wasteful: if only the upper third of the spectrum were ﬁltered, aliasing would still be
eliminated. (To put it more precisely, aliasing would still occur, but only into wavenumbers
purged by the ﬁltering. Thus, all the surviving wavenumbers are alias-free.)
Akio Arakawa (1966) proposed another solution. Aliasing caused the discretized en-
ergy to grow without bound when it should be conserved. Arakawa therefore developed
a modiﬁed ﬁnite difference formula for the Jacobian operator (advection) which exactly
conserved the discretized energy. This also prevented aliasing instability.
Yet another remedy is to use special ﬁnite difference or spectral algorithms that have
been modiﬁed to better cope with fronts or shock waves. (The “synoptic scale” vortices in
Phillips’ GCM should form narrow fronts as they mature; it was during this “frontogene-
sis” stage that Phillips’ model went bad.)
All three strategies — ﬁltering, energy-conservation, and shock-resolution — have their
uses. However, if a ﬂow is being well-resolved by an exponentially-convergent spectral
model, shouldn’t the energy be conserved to a high approximation anyway? Are these
alias-ﬁxers really necessary? Moreover, it turns out that these remedies offer seductive
possibilities for self-deception. We will return to these difﬁcult questions after ﬁrst describ-
ing a couple of these procedures in more detail in the next two sections.
11.5
Dealiasing and the Orszag Two-Thirds Rule
Phillips suggested a dealiasing procedure: apply a spatial ﬁlter so as to suppress all waves
with wavelengths between 2h and 4h. For spectral methods, we ﬁlter by simply deleting
all the offending wavenumbers just before each transform to grid point values.
Orszag (1971a) showed that purging half the spectrum is wasteful. If we ﬁlter all waves
such that |k| > (2/3)K, then the quadratic interaction of two wavenumbers p, q that survive
the ﬁlter will alias only to wavenumbers that are purged. The reason is that the aliasing
shift in k must always be by a multiple of 2K (Fig. 11.7). The conclusion is that it is only
necessary to ﬁlter waves with wavelengths between 2 h and 3 h to suppress aliasing.

212
CHAPTER 11. ALIASING, SPECTRAL BLOCKING, & BLOW-UP
AAAAA
AAAAA
AAAAA
AAAAA
AAAAA
AAAAA
AAAAA
AAAAA
AAAAA
AAAAA
AAAAA
AAAAA
AAAAA
AAAAA
AAAAA
AAA
AAA
AAA
AAA
k ∈ [-(4/3) K,-K]
k ∈ [K,(4/3) K]
K
(2/3) K
- (2/3) K
FILTERED
UNFILTERED
k
0
- K
AAAAAA
AAAAAA
Figure 11.7:
The “Aliasing Wheel”.
The wavenumber k for Fourier basis functions
exp(i k x) is depicted as an angle in a polar coordinate system, scaled so that the basis
set k ∈[−K, K] spans the full circle. Orszag’s “Two-Thirds Rule” ﬁlter has no effect on
waves in the range k ∈[−(2/3)K, (2/3)K], but all Fourier coefﬁcients with |k| > (2/3)K
are set equal to zero at the end of each time step.
Quadratically nonlinear terms have Fourier components that span the range k
∈
[−(4/3)K, (4/3)K], which is represented by the double-headed arrow that completes one-
and-one-third complete turns of the circle.
As shown by the diagram, wavenumbers
on k ∈[K, (4/3)K] are aliased to k ∈[−K, −(2/3)K] (lower shaded band). Similarly,
wavenumbers on k ∈[−(4/3)K, −K] are aliased to k ∈[(2/3)K, K] (upper shaded area).
The ﬁltering removes all effects of aliasing because the misrepresented wavenumbers —
the shaded bands — lie within the “death zone” of the ﬁlter. The dotted horizontal ray is
the branch cut: all k > K or < −K will be aliased.
Rule-of-Thumb 10 (TWO-THIRDS RULE) To obtain an alias-free computation on a grid of N
points for a quadratically nonlinear equation, ﬁlter the high wavenumbers so as to retain only
(2/3)N unﬁltered wavenumbers.
This precept is alternatively (and confusingly) known as the “Three-Halves Rule” because to
obtain N unﬁltered wavenumbers, one must compute nonlinear products in physical space on a
grid of (3/2)N points.
This procedure is also called “padding” because one must add (N/2) zeros to the spectral coefﬁ-
cients before making the coefﬁcient-to-grid Fast Fourier Transform.
Whatever the name, the ﬁltering or padding is always performed just before taking coefﬁcient-
to-grid transforms so that the shortest unﬁltered waves on the grid have wavelength 3h.
A total of (3/2) N basis functions are used during intermediate stages of the calculation,
but only the lowest N wavenumbers are retained in the ﬁnal answer at each time level.
Two alternative deliasing methods have also been tried. Patterson & Orszag (1971)
evaluated grid point sums with a phase shift. However, this trick has fallen from favor
because it is always more expensive than the Two-Thirds Rule (Canuto et al. 1988, pg. 85).
Rogallo (1977, 1981, Rogallo and Moin, 1984), who is better known for inventing the
wing used in the ﬁrst modern hang-glider, showed that for a two-step time scheme, it is
possible to apply the phase shift method at negligible extra cost to reduce aliasing errors

11.6. ENERGY-CONSERVING: CONSTRAINED INTERPOLATION
213
to O([△t]2) of those of the standard pseudospectral method. This is very appealing, even
though a small residue of aliasing remains, but for a decade, it was never mentioned except
in Rogallo’s own work until praised by Canuto et al (1988).
Other strategies which control aliasing indirectly are described in the next section.
11.6
Energy-Conserving Schemes and
Skew-Symmetric Advection:
Interpolation with Constraints
Arakawa (1966) proposed a very different strategy: modifying the numerical algorithm so
that it exactly conserves the discretized energy. (By “energy”, we mean the total energy
of the model.) He reasoned that blow-up implies a spectacular (and wholly spurious) in-
crease in energy. If the discretized energy is constant, however, then supersonic winds are
obviously impossible.
Similarly, for Hamiltonian systems, one can use special time-marching schemes (“sym-
plectic” algorithms) which preserve the Hamiltonian structure even in discrete form. These
have been very useful in megayear-long integrations of solar system orbital dynamics
problems (Sanz-Serna and Calvo, 1994).
As noted by Canuto et al.(1988), it is often straightforward to obtain spectral schemes
which are energy-conserving. Indeed, Galerkin’s method is automatically energy-conserving
for some equations, such as for the barotropic vorticity equation with a triangular trunca-
tion of the spherical harmonic basis (Haltiner and Williams, 1980). However, for most
problems, pseudospectral schemes conserve the discrete energy only after (small) modiﬁ-
cations (Canuto et al., 1988, Secs. 4.5 and 4.6).
Zang (1991a) has shown that the most important such modiﬁcation is to use the skew-
symmetric form of advection for the Navier-Stokes equations. A skew-symmetric matrix
or differential operator is one whose eigenvalues are all pure imaginary. Skew-symmetry
is a property of advection operators and also the operators of wave equations: the imagi-
nary eigenvalues (paired with a ﬁrst order time derivative) imply that operator advects or
propagates without causing growth or decay. It is desirable to preserve skew-symmetry in
numerical approximation because pure advection and propagation is precisely what doesn’t
happen when a model is blowing up.
The usual forms of advection are
⃗u · ∇⃗u,
[Standard form]
⃗ω × ⃗u + ∇((1/2) ⃗u · ⃗u) ,
[Rotation form]
(11.14)
However, Zang (1991a) shows that skew-symmetry is preserved only by the more compli-
cated form
1
2 ⃗u · ∇⃗u + 1
2∇(⃗u ⃗u) ,
[Skew-Symmetric Advection]
(11.15)
where ∇(⃗u ⃗u) is a vector whose components are ∇· (⃗u uj) where uj is one of the three
vector components of ⃗u. The property of skew-symmetry also depends upon boundary
conditions, but we refer the reader to his paper for details.
Blaisdell, Spyropoulos and Qin(1996), through a mixture of theoretical analysis and
experiments for Fourier pseudospectral codes for turbulence and Burgers’ equation, offer
additional support for the skew-symmetric form. They show that this form cancels much
of the differentiation error of either the conservative form or the usual non-conservative
advection form for the largest aliased components.

214
CHAPTER 11. ALIASING, SPECTRAL BLOCKING, & BLOW-UP
More recently, a wide variety of algorithms have been developed to avoid spurious
oscillations near fronts and shock waves, such as Van Leer’s MUSCL scheme, Roe’s algo-
rithm, and the Piecewise-Parablic Method (Carpenter et al., 1990). These do not attempt
to control the energy, but rather use analytical theories of shock structure to suppress the
growth of 2h-waves.
Some of these schemes have the disadvantage of being more costly than conventional
schemes. Arakawa’s ﬁnite difference Jacobian requires twice as many operations as ap-
proximating the advection operation using standard differences. The Two-Thirds Rule re-
quires dumping (1/3) of the numerical degrees of freedom in each dimension, doing the
work of a grid which is say, 963 to obtain only a 643 set of nonzero spectral coefﬁcients.
Is the additional cost worth it? The answer, to borrow the title of a science ﬁction novel
by the Strugasky brothers, is Deﬁnitely Maybe.
Optimist’s Viewpoint: Energy-conserving and front-resolving schemes are interpolation-
with-physics-constraints. Instead of merely using the grid point values of a function, as if
it were completely arbitrary, these schemes exploit the fact that the function is not arbi-
trary, but rather is constrained by physics. Building constraints into interpolation schemes
is perfectly legitimate and should lead to an improved approximation.
Pessimist’s Viewpoint: The Arakawa scheme guarantees that the numerical solution
will stay bounded, but it does not guarantee that it is accurate. In Phillips (1956), for example,
the calculation blew up only at the stage where the baroclinic cells were forming fronts.
Since his coarse grid could not have resolved the fronts anyway, it can be argued that the
blow-up of his model really did him a favor by aborting the computation as soon as it
became inaccurate.
Similarly, dealiasing is a dumb idea: if the nonlinear interactions are so strong that a lot
of energy is being aliased, one probably needs to double the grid spacing.
Likewise, the PPM method and its cousins guarantee smoothness but not accuracy.
Who is right?
11.7
Energy-Conserving and Shock-Resolving Schemes: Dis-
cussion
The workshop published by Straka et al.(1993) computed a two-dimensional density cur-
rent using a wide variety of schemes. The comparison supports both the optimistic and
pessimistic viewpoints.
Fig. 11.8 compares a standard, second order ﬁnite difference method at various resolu-
tions. The most important point is that one needs a grid spacing h = 100m or less to get a
decent solution; the plot for h = 200m is ﬁlled with noise while the numerical solution for
h = 400m is completely useless.
Fig. 11.9 compares the high accuracy solution (the h = 25m solution from the previous
ﬁgure, which Straka et al. use as a benchmark) with standard ﬁnite differences and the PPM
scheme at h = 400. The optimist is encouraged because the PPM solution is still stable,
smooth, and resembles the accurate solution even though the grid spacing is very coarse.
The PPM’s incorporation of wave physics has made it far more successful at this resolution
than the ﬁnite difference scheme, which is junk. The spectral model was unstable at this
resolution.
However, the pessimist can ﬁnd solace, too, because the smoothness and stability of the
PPM solution is deceiving: it is not a very good numerical solution. Two smaller vortices
and several other features in the right half of the disturbance have been simply combined
into a single smooth vortex by PPM. The truth is that h = 400m is simply too coarse to
resolve the smaller features.

h=25m
h=400m
h=533m
h=266m
h=200m
h=133m
h=100m
h=33m
h=50m
h=66m
11.7. ENERGY-CONSERVING SCHEMES: DISCUSSION
215
Figure 11.8: Comparison of second order ﬁnite difference solutions at different grid spac-
ings h. The algorithm has no particular front-resolving or monotonicity properties. From
Straka et al.(1993) with permission of the authors and the American Meteorological Society.
At h = 200m, the spectral solution is noisy, but much more accurate than any of the
others in computing the total energy and enstrophy, even though it is not exactly energy-
conserving. PPM is smoother, but only because this algorithm has strong computational
dissipation, losing almost half the enstrophy at the time shown in the ﬁgures versus only
about 13% for the spectral code. At h = 100m, the spectral and PPM schemes are both
accurate, but the spectral method is considerably better than PPM at resolving the smaller
scale features and preserving energy and enstropy (Fig. 11.10).
The moral of this and similar comparisons is the following
Rule-of-Thumb 11 (DEALIASING/ENERGY-CONSERVING)
1. For well-resolved ﬂows, dealiasing and energy-conserving and front-resolving algorithms are
unnecessary. A spectral method will conserve energy to a very high accuracy and will faith-
fully resolve a shock zone or frontal zone with only two or three grid points within the zone.
2. For marginally-resolved ﬂows, dealiasing and other remedies may prevent blow-up and yield
acceptable results when blind application of spectral or other methods yields only a sea of
noise or worse. However, some ﬁne structure in the solution may be missed, and the special
algorithms can do nothing about this.
3. For poorly-resolved ﬂows, nothing helps, really, except using more grid points. Energy-
conserving and front-tracking schemes may generate smooth solutions, but these will only
vaguely resemble the true solution.
Special algorithms and tricks are “Plan B”, fallbacks to implement when the straightforward
algorithm isn’t working well and the computation already ﬁlls all the available computer memory.
Filtering and skew-symmetric advection are often useful; conserving energy is helpful; dealiasing is
a last resort because of its high cost in two or three dimensions. Front-resolving schemes are quite
useful for shocks.

Accurate Soln.
2d order FD: h=400 m
PPM: h=400 m
216
CHAPTER 11. ALIASING, SPECTRAL BLOCKING, & BLOW-UP
Figure 11.9: Comparison of the piecewise-parabolic method (PPM) at h = 400 [top] with
the standard second order ﬁnite difference model [bottom] at the same resolution and with
the highly accurate reference solution [middle]. Although the PPM solution is smooth and
has captured some of the features of the true solution, it has only two vortices instead of
three. Redrawn from Straka et al.(1993).
A turbulence calculation almost by deﬁnition is poorly resolved, so dealiasing is not
particularly rare for modelling such ﬂows. Even in turbulence, however, dealiasing is often
unnecessary; even in turbulence, dealiasing is not a cure for a ﬂow that is badly underre-
solved.
Aliasing error is likely to be important only when, as in Phillips’ pioneering model, the
calculation is becoming highly inaccurate. Aliasing blow-up has saved many modellers
from believing lousy simulations. There have been many energy-conserving calculations
published — it would be tactless to name names! — which have smooth solutions that are
complete nonsense.
11.8
Aliasing Instability: Theory
A number of papers have tried to identify speciﬁc mechanics for blow-up such as Briggs,
Newell and Sarie (1981). Aoyagi (1995) is a recent article with many references. These stud-
ies have successfully identiﬁed particular modes of instability for particular algorithms.
However, the studies have not been successful in developing any sort of general theory.
It may be that model blow-up, like any other train wreck, creates casualties of many sorts
and not any speciﬁc, aliasing-related injury.
Phillips (1959), who explained the blow-up of his model in terms of aliasing and the
resulting spurious, wrong-way transfer of energy, believed that he had diagnosed a speciﬁc
illness with a speciﬁc cure. He did not think that aliasing instability was merely a lack of
resolution because he repeated his GCM calculation with a much shorter time step and
spatial grid spacing and the model still blew up at about the same time!

ACCURATE 
SOLN.
PPM:
h=100 m
SPECTRAL:
h=100 m 
11.8. ALIASING INSTABILITY: THEORY
217
Figure 11.10: Comparison of spectral and piecewise-parabolic method (PPM) at h = 100m
with each other and the reference solution. From Strata et al.(1993).
However, his experiments do not completely resolve the issue. When a shock wave
forms, the solution is smooth for a ﬁnite time interval and then develops a jump discon-
tinuity which — in the absence of sufﬁcient viscosity — the numerical method cannot re-
solve. The transition from exponential accuracy to blow-up may be rapid, occurring on
a time scale short compared to the total time of integration. Even with an abrupt onset,
blow-up may be simply the result of underresolution of small scale features. 1 As we saw
earlier, spectral blocking can also be the result of too long a time step (although Phillips’
tests excluded this in his model.)
Spectral blocking would seem to support Phillips’ belief that aliasing instability is not
merely underresoution. If the ﬂow is evolving narrower and narrower fronts, one would
expect that the Fourier spectrum would ﬂatten out, rather than develop a curl at high
wavenumber. Actually, in simple one-dimensional PDEs like the Regularized Long Wave
equation and Burgers’ equation, this “ﬂatten-to-blow-up” scenario is observed. On a log-
linear plot, the coefﬁcients asymptote to a straight line for all t, implying that the conver-
gence rate is always geometric, but the slope of the asymptotic line becomes ﬂatter and
ﬂatter. When the plotted coefﬁcients asymptote to a horizontal line, i. e., the spectrum
resembles “white noise”, disaster is quick and spectacular.
In Phillips’ simulation, and also in the Zang-Krist-Hussaini transition-to-turbulence ex-
periment illustrated earlier, however, spectral blocking develops while the large scale fea-
tures are still well-resolved and the amplitude of the “blocked” wavenumbers is small
compared to that of low wavenumbers. Doesn’t this imply a numerical instability rather
than underresolution as the cause of blocking? Not necessarily.
Theories of two-dimensional and quasi-geostrophic turbulence predict that (i) the ﬂow
1Cloot, Herbst and Weideman, 1990, give a good discussion of a one-dimensional wave equation that develops
unbounded solutions in ﬁnite time. Their adaptive Fourier pseudospectral method increases N close to the time
of the singularity. This is a good strategy for ﬁghting blow-up when the model physics is taking a rapid turn for
the nasty.

wavenumber  k
0
π /h
spectrum
of energy-
containing
eddies
spectrum
of under-
resolved 
fronts
218
CHAPTER 11. ALIASING, SPECTRAL BLOCKING, & BLOW-UP
Figure 11.11: Solid: spectrum of energy-containing eddies (“synoptic eddies” in Phillips’
simulation). Circles: Fourier coefﬁcients of the unresolved fronts.
will spontaneously develop fronts too thin to be numerically resolved (if the viscosity is
very weak) and (ii) the energy spectrum will fall off as O(k−3) for wavenumbers smaller
than kdiss, the beginning of the dissipation range, where k is the total wavenumber. For
the Fourier coefﬁcients (as opposed to the energy, whose spectrum is proportional to the
absolute value squared of the Fourier coefﬁcients), this implies |ak| ∼O(1/k3/2). The crucial
point is that the Fourier coefﬁcients of a jump discontinuity (like a front or the “sawtooth”
function) decrease more slowly as O(1/k). The implication is that the fronts have rather
small energy, or otherwise the energy spectrum would decay as O(1/k2).
Thus, it is possible for the underresolved small features to contain little energy com-
pared to large, well-resolved features. Thus, spectral blocking in Phillips’ model could be
described (conjecturily) by Fig. 11.11.
On the other hand, Brown and Minion(1995), Minion and Brown(1997) and the stud-
ies reviewed by Aoyagi (1995) have identiﬁed some speciﬁc computational instabilities.
These seem to occur only for marginally-resolved or poorly-resolved ﬂow, thank good-
ness. When sideband resonance is the villain, the bland statement “too little resolution”
seems insufﬁcient. Perhaps with a little tinkering of the algorithm, it might be stabilized
against sideband resonace (or whatever) so that the integration could be extended without
a shift to a ﬁner spatial grid.
The theory of aliasing instability and blow-up is on the whole in a pretty sorry state. It
matters because many important ﬂows can only be marginally resolved, forcing the use of
energy-conserving algorithms, dealiasing and so on. We could ﬁght the instability much
better if we only understood what we were ﬁghting!
11.9
Summary
Spectral blocking, 2h-waves and blow-up are as much a problem today as in the time of
Phillips’ ﬁrst GCM experiment. The bad news is that despite Phillips’ own demonstration

log ak
log ak
Blow-Up
t
t
Smaller h;
Adaptive Schemes
Energy-conserving
Skew-symmetric
advection
Front-tracking: PPM
FCT,etc.
Spectral
Blocking
Filtering/Artificial 
Viscosity
Dealiasing; 2/3 Rule
11.9. SUMMARY
219
Figure 11.12: Schematic of the time evolution of a model from a smooth initial condition
(top left) to a ﬂow that has lost some accuracy to spectral blocking (middle left) before
blowing up (bottom left) and six types of remedies for spectral blocking and blow-up (right
arrows).
of the wrong-way energy cascade created by aliasing, the causes of blow-up are still not
well understood. The good news is that we have a quiver full of arrows to shoot at the
problem (Fig. 11.12).
The ﬁrst arrow is to increase the resolution. Phillips found that this didn’t help very
much, buying only a few hours of additional time. However, this may only reﬂect the fact
that frontogenesis happens very rapidly once the eddies have grown to a reasonable size. It
is dangerous to always blame blow-up on a numerical villain, a computational Bogeyman
named Aliasing Instability. It may just be that the ﬂow is physically generating features
whose width is 1/1000 of the size of the computational domain, and a model with N = 100
fails simply because it can’t resolve it.
Adaptive schemes are very useful in this context because often a ﬂow can be resolved
with rather small N over much of its lifetime before the front develops. With a variable
resolution, that is, a ﬁne grid around the front only, the narrow features may be resolved
with only moderate N. Cloot, Herbst, and Weideman (1990), Bayliss, Gottlieb, Matkowsky
and Minkoff (1989), Bayliss and Turkel(1992), Bayliss, Garbey and Matkowsky (1995) and

220
CHAPTER 11. ALIASING, SPECTRAL BLOCKING, & BLOW-UP
Augenbaum (1989, 1990) are illustrations.
The second arrow is ﬁltering or the use of an artiﬁcial, computational viscosity (Chapter
18, Sec. 20).
The third arrow is skew-symmetric advection. This forces the numerical discretization
of advection to provide pure translation without adding a little bit of spurious numerical
growth or decay. It seems to be helpful with marginally-resolved ﬂows.
The fourth arrow is an energy-conserving algorithm. Canuto et al. (1988, Sec. 4.6) give
an example of a magnetohydrodynamic ﬂow where this is helpful. Energy-conserving
schemes are likely to be useful for climate modelling, too, where the ﬂow is integrated
over a very long period of time. Symplectic integration schemes for Hamiltonian systems
conserve not only energy but the Hamiltonian structure.
The ﬁfth arrow is to use a front-resolving scheme like PPM or MUSCL or Flux-Corrected
Transport (FCT) or the like. Spectral generalizations of most of these algorithms are now
available.
The sixth arrow is the Two-Thirds Rule. This is really just a special case of ﬁltering, but
we list it separately because it is often discussed in the literature as something separate
with a different motive from conventional ﬁlters: to dealias a quadratically nonlinear com-
putation. However, Orszag’s procedure discards 1/3 of the numerical degrees of freedom
in one dimension, 5/9 in two dimensions and 19/27 in three dimensions. One pays a very
heavy price just to eliminate aliasing, so this is probably a last resort.
Note that the Two-Thirds Rule is an “all-or-nothing” ﬁlter: the coefﬁcients are unmod-
iﬁed or completely discarded. To resolve fronts and other narrow features, ﬁlters which
vary smoothly and continuously with wavenumber have become quite popular and success-
ful. Experience and some theory suggests that a smooth ﬁlter is better than a step function
(in wavenumber) like the Two-Thirds Rule. Since the higher wavenumbers are clobbered
by the ﬁlter anyway, one is likely to gain most of the beneﬁts of dealiasing.
There are two important things to remember before applying these remedies. The ﬁrst
is that for a well-resolved ﬂow, none of them are needed! A spectral code will do a very
good job of preserving the energy over a fairly long time simply because of its inherent ex-
ponential accuracy. It is only when the ﬂow develops fronts, shocks and other pathologies
that one ever needs to think about tinkering with the algorithm to enforce conservation of
the discrete energy. Otherwise, one is incurring extra cost, both your time and the com-
puter’s, for no particular gain.
The second point is that when these remedies succeed, they succeed dangerously. That
is to say, these interpolation-with-physics-constraints force the computed ﬂow to be smooth
and the energy to stay constant even when the numerical errors are large. If the eddies have
a characteristic scale of 1000 km, it is clear that a very coarse grid with h=5000 km cannot
possibly furnish an accurate solution. However, with an Arakwa-type energy-conserving
scheme, the numerical solution won’t blow up. Indeed, the dreadfully-underresolved so-
lution may look quite smooth, even though it’s nonsense.
For his thesis, a colleague ported the energy-conserving Arakawa-Mintz model from
the atmosphere to the ocean. Unfortunately, because ocean eddies have a diameter of O(100
km),which is very small compared to the width of an ocean basin, it was not possible to
explicitly resolve the eddies in 2 B. C. [Before Cray2]. However, it was possible to make a
short run at higher resolution. The horror! The horror! With smaller h, everything changed!
Nevertheless, the production run was published. Although it certainly had major er-
rors, my friend was unable to convince his advisor of this because the Arakawa scheme
(and viscosity) made the computed solutions look smooth even though the ﬂows were actu-
ally rubbish.
2The Cray-1, the ﬁrst supercomputer, was introduced in 1976.

11.9. SUMMARY
221
In contrast, a code which is resolving a ﬂow ought to approximately conserve energy
for a long time, even if this property is not explicitly built into the discretization. If the code
isn’t resolving the ﬂow, well, perhaps it ought to blow up.
Smoothness and energy conservation are like the shining glitter of gold. Perhaps it
really is gold, or perhaps it is only iron pyrites, “fool’s gold”, which gleams as brightly
but is worth almost nothing. The number-cruncher must be as suspicious of glitter as the
mineralogist.

Chapter 12
Implicit Time-Marching, the Slow
Manifold and Nonlinear Galerkin
Methods
“In the terminology which you graciously ascribe to me, we might say that
the atmosphere is a musical instrument on which one can play many tunes.
High notes are sound waves, low notes are long inertial [Rossby] waves, and
nature is a musician more of the Beethoven than of Chopin type. He much
prefers the low notes and only occasionally plays arpeggios in the treble and
then only with a light hand. The oceans and the continents are the elephants in
Saint-Saens’ animal suite, marching in a slow cumbrous rhythm, one step every
day or so. Of course there are overtones: sound waves, billow clouds (gravity
waves), inertial oscillations, etc., but these are unimportant and are heard only
at N. Y. U. and M. I. T.”
–Jule Charney (1917-1982) (from a 1947 letter to Philip Thompson)
12.1
Introduction
When the partial differential equation is linear and the “method of lines” is applied to
discretize the spatial dependence, the system of ordinary differential equations in time is
linear, too, and can be written
d⃗u
dt = ⃗Λ⃗u + ⃗f(t)
(12.1)
where ⃗Λ is a large square matrix of dimension N where N is the number of elements in the
column vector ⃗u and where ⃗f(t) is the discretization of the inhomogeneous terms in the
differential equation. (We assume that the boundary conditions have been dealt with by
basis recombination or whatever; the vector ⃗f may contain terms proportional to inhomo-
geneous boundary conditions in some or all of its elements.)
222

12.1. INTRODUCTION
223
The “conﬁguration space” of the model is just the N-dimensional space of the vector
⃗u, the spectral coefﬁcients or grid point values. The instantaneous state of the model is
a point in conﬁguration space; its evolution through time is a one-dimensional curve in
conﬁguration space, parameterized by the single coordinate t.
Eq.(12.1) is completely general and applies whether the spatial discretization is spectral,
ﬁnite difference or ﬁnite element and also whether the unknowns are grid point values or
Chebyshev polynomial coefﬁcients. In general, the elements of the matrix ⃗Λ are functions
of time. In most of this chapter, however, we shall make the further assumption that ⃗Λ is
independent of time.
In a world which is highly nonlinear and time-dependent, these assumptions would
seem drastic. Indeed, such approximations cannot capture the mysteries of solitary waves,
chaos, aliasing instability and a wide variety of other phenomenon. Nevertheless, such a
simpliﬁed model as (12.1) can teach us much about time-marching algorithms. The reason
is that accurate time-stepping requires a time step which is short compared to the time
scales on which the coefﬁcients of the differential equation and u itself are changing. This
implies that the matrix ⃗Λ will not change much between then and time t = t0 + τ where τ
is the timestep; otherwise, we should shorten the timestep.
The conceptual advantage of the linear-with-time-independent coefﬁcient approxima-
tion is that the linear, constant coefﬁcient ODE system (12.1) has the general solution
⃗u = exp(⃗Λt)⃗u0) + exp(⃗Λt)
Z t
exp(−⃗Λs) ⃗f(s) ds
(12.2)
where ⃗u0 ≡⃗u(t = 0). The matrix exponential is most easily interpreted by expanding ⃗u in
terms of the eigenvectors of the square matrix ⃗Λ. If
⃗Λ⃗ej = λj⃗ej
(12.3)
and
⃗u =
N
X
j=1
bj ⃗ej
(12.4)
then in terms of the eigenvector basis, ⃗Λ becomes a diagonal matrix, with its eigenvalues
λj as the diagonal elements, and the ODE system collapses to the uncoupled set of ordinary
differential equations
dbj
dt = λj bj + gj(t)
(12.5)
where gj(t) is the j-th coefﬁcient of the eigenexpansion of the forcing function ⃗f(t).
It follows that we can learn almost everything about time-marching schemes – to the
extent that neglecting nonlinearity and other time-dependence of the coefﬁcients of the
PDE is legitimate – by understanding how different algorithms integrate
du
dt = λu + f(t)
(12.6)
where all the unknowns are now scalars, not vectors. For a simple wave equation like
ut + cux = 0,
(12.7)

224
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
the usual Fourier basis (exp(ikx)) shows that the equation for each wavenumber is uncou-
pled with
λ = −ikc,
bk(t) = bk(0) exp(−ikct)
(12.8)
Other constant coefﬁcient wave equations similarly generate pure imaginary eigenvalues.
Advection does, too; note that the one-dimensional advection equation, also known as the
inviscid Burgers’ equation, is identical with 12.7 except that c →u.
In contrast, the diffusion equation
ut = uxx
(12.9)
generates negative real eigenvalues; in the Fourier basis, which is the eigenexpansion for the
diffusion equation,
λ = −k2; bk = bk(0) exp(−k2t)
(12.10)
In general, numerical algorithms fail to propagate and/or diffuse at the exact rate, cre-
ating computational dispersion and/or diffusion that is superimposed on whatever is in
the exact solution. One major theme of this chapter is that the choice of time-stepping al-
gorithms and time step are both strongly constrained by the question: How much error is
tolerable for a given component of the solution?
Before we turn to time-marching errors, however, it is useful to ﬁrst look brieﬂy at errors
due to spatial discretization.
12.2
Dispersion and Amplitude Errors Due to Spatial Dis-
cretization
It is easy to discuss the computational dispersion and dissipation of a Fourier basis: there
isn’t any! Advection is corrupted only by aliasing errors; if the Two-Thirds Rule is applied,
then advection is exact for all the unﬁltered wavenumbers.
If no ﬁltering is used, then advection is not exact even in a Fourier basis because of
aliasing errors; high wavenumbers near the truncation limit will not be correctly advected
by high wavenumber components of the velocity. However, high wavenumbers will be
advected exactly by low wavenumbers including the zero wavenumber component, which
is the mean ﬂow. Even in an aliased calculation, the total error in advection is small, which
is one reason why Fourier methods have become so popular for modelling turbulence in a
periodic box.
Unfortunately, the same is not so for ﬁnite difference methods. One simplifying prin-
ciple, much exploited by J. von Neumann, is that exp(ikx) is an eigenfunction of a ﬁnite
difference approximation just as it is for differential operators. Thus, backwards and cen-
tered difference approximations to the ﬁrst derivative,
du
dx
≈
u(x) −u(x −h)
h
[BACKWARDS]
≈
u(x + h) −u(x −h)
2h
[CENTERED]
(12.11)
give the approximations, when u = exp(ikx),
d exp(ikx)
dx
≈
(1 −exp(−ikh))
h
exp(ikx)
[BACKWARDS]
≈
i sin(kh)
h
exp(ikx)
[CENTERED]
(12.12)

12.2. DISPERSION AND AMPLITUDE ERRORS
225
The corresponding approximations to the true eigenvalue of the ﬁrst derivative operator
can be written as
λk
≈
ik + h
2 k2 + O(h2k3)
[BACKWARDS]
≈
ik −ih2
6 k3 + O(h4k5)
[CENTERED]
(12.13)
The leading terms in (12.13) correctly reproduce the exact eigenvalue of the ﬁrst deriva-
tive operator, which is ik. However, the backwards difference approximation has a second
term, the dominant error, which is proportional to the eigenvalue of the second derivative
operator, −k2. Indeed, it is explained in elementary numerical analysis texts that the error
for the one-sided and centered differences are proportional to the second and third deriva-
tives of the function being differentiated, respectively. It follows that one can give two
interpretations to the ﬁnite difference approximations to the wave equation ut + cux = 0.
The ﬁrst is that the replacing the space derivative by two-point backwards and centered
differences approximates that equation with errors of O(h) and O(h2), respectively. The
unconventional interpretation (equally correct) is that the differences formulas give second
and third order approximations to the modiﬁed wave equations:
ut + cux = ch
2 uxx
[BACKWARDS]
(12.14)
ut + cux = −ch2
6 uxxx
[CENTERED]
(12.15)
Whether one prefers to conceptualize using the “modiﬁed” equations (12.14), 12.15) or
the power series for the eigenvalues (12.13), the point is that the backwards difference errs
by providing an artiﬁcial computational diffusion. Diffusion is scale-selective, damping the
high wavenumbers much faster than low wavenumbers. The backwards difference (which
is the “upwind” difference for c > 0) is popular in hydrodynamics because the inherent
diffusivity reduces spectral blocking, that is, the build-up of noise at high wavenumbers
near the truncation limit. In the presence of marginally resolved fronts, the upwind differ-
ence approximation acts as a smoother. In contrast, the forward (“downwind”) difference
acts an “antidiffusion”, generating spectral blocking and blow-up. (Note that the waves
near the truncation limit are most strongly ampliﬁed by an “antidiffusion”.)
The centered difference is not dissipative to lowest order. However, the exact solution
to the original wave equation is nondispersive: all wavenumbers propagate with phase
speed c so that the initial disturbance translates without change in shape. The centered dif-
ference introduces a spurious computational dispersion. A crest in the initial condition will
disperse into many small ripples over time because of the O(h2) dispersion. When there
is a frontal zone, the lack of damping and the dispersion cause lots of small oscillations
to develop. Consequently, upwind differences are more popular than centered differences
when fronts are anticipated even though the centered difference is technically of higher
order.
With a Fourier basis, as already noted, we don’t have to worry about either computa-
tional dissipation or dispersion. Unfortunately, with the Chebyshev basis only the lowest
(2/π)N eigenvalues of an N-term Chebyshev approximation are good approximations to
the corresponding eigenvalues of the derivative operator. However, the error in the lower
eigenvalues is exponentially small in N, so the computational dissipation and dispersion
of a Chebyshev algorithm is very small compared to a ﬁnite difference algorithm.

−1
−0.5
0
0.5
1
0
1
2
3
4
τ λ
µ/ λ
226
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
Figure 12.1: Numerical/exact eigenvalue ratio, µ/λ, for the forward Euler solution to
du/dt = λu, plotted as a function of the scaled time step τλ. The horizontal dividing
line at µ/λ = 1 is the exact decay rate.
12.3
Time-Marching Errors and the
CFL Stability Limit for Explicit Schemes
Even when there is no error due to spatial discretization, as true with a Fourier basis, there
will be still be computational dispersion and/or dissipation because of time-marching er-
rors. The ODE which results from switching to a basis of the eigenvectors of the spatial
discretization operators is (12.6), which we repeat for clarity:
du
dt = λu + f(t)
(12.16)
The simplest explicit scheme is the “forward Euler” (FE) method:
un+1 = (1 + τλ) un + τ f(tn)
(12.17)
where the superscripts denote the time level (not powers) and τ is the time step.
If λ is negative, as for diffusion, then for sufﬁciently small τ, the FE solution damps out,
too. If f is a constant, then the ﬁnite difference solution will damp out to the steady state
u∞= −f/λ
(12.18)
which is exact.
The bad news is that the FE solution does not damp out at the correct rate. The exact
solution decays as exp(λt) whereas the ﬁnite difference solution decays towards the steady
state as exp(µt) where
µ = λlog(1 + τ λ)
τ λ
≈λ
½
1 + τ λ
2
+ . . .
¾
(12.19)

12.3. ERRORS & CFL LIMIT FOR EXPLICIT SCHEMES
227
Fig. 12.1 shows that the numerical solution damps out too rapidly; when τλ = −1, the
numerical damping rate is inﬁnitely large! When λ > 0, the ﬁnite difference solution grows
(as appropriate for “anti-diffusion”), but grows too slowly: at only 70 % of the true growth
rate when τλ = 1.
When τλ < −1 (not shown on the graph), something worse happens: the numerical
solution grows with time even though the exact solution decays. This sort of computational
instability was ﬁrst discovered by Courant, Friedrichs and Lewy (CFL) in 1928. In this case,
the “CFL Stability Criterion” is that τ < |1/λ| for computational stability.
Stability is usually presented as an “all-or-nothing” concept, but this is misleading.
First, nothing bad happens when τ > |1/λ| and λ > 0: the numerical solution blows
up, but the exact solution blows up, too. The only difﬁculty with τ > |1/λ| is that the nu-
merical solution is growing at only two-thirds or less of the true rate of growth, which is
usually an unacceptably large error.
Second, even when λ < 0, Fig. 12.1 shows that the error becomes large even before the
CFL criterion is violated. Blow-up seems to the modeller a disaster that appears discontin-
uously when the CFL criterion is exceeded, but really the instability is just the outlands of
a larger region where the time-stepping is inaccurate.
There is one good defense for marching with a time step which is close to the stability
limit: When the only goal is to approximate the steady-state, large errors in the decay rate
are irrelevant. As noted earlier, the Forward Euler method always gives the steady state
exactly. Consequently, it is perfectly sensible to solve the Poisson equation
uxx = f(x)
(12.20)
by applying the FE scheme to the diffusion equation
ut = uxx −f(x)
(12.21)
with a time step which is only a little below the stability limit. The steady-state limit of the
diffusion equation is the solution to the Poisson equation.
If, however, we wish to follow the decay of the transients to the steady state, then the
errors in the decay rate matter, and one should use a time step which is much shorter than
the stability limit.
The diffusion equation with a steady forcing has two time scales: the short time scale
on which transients decay towards the steady solution and the inﬁnitely long scale of the
steady solution and forcing. Inaccurate resolution of the “fast” time scale [decay] is okay
provided that one is only interested in the “slow” time scale. This line of reasoning leads
to the concept of the “slow manifold” which will dominate the second half of this chapter.
Other explicit time-marching schemes have stability limits which are similar to that of
the Forward Euler method:
τ < q/|λ|
(12.22)
where the constant q depends on the algorithm, but is always O(1). (For the Fourth-Order
Runge-Kutta (RK4) method, for example, q varies with arg(λ), but is no smaller than about
2.8.) Unfortunately, these time-stepping constraints can be rather severe.
For the diffusion equation, for example, the eigenvalues in a Fourier basis {exp(ikx)}
are λk = −k2. If we truncate to k ∈[−N/2, N/2], then it follows that the FE will be stable
for all wavenumbers only if
τ < 4/N 2
(12.23)
Thus, doubling N requires four times as many time steps to reach a given time. It follows
that applying an explicit time-marching scheme to the diffusion equation is not a very fast

228
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
way to solve Poisson equations: we need O(N 2) time steps to get a good approximation to
the steady state. Much faster iterations will be described in Chapter 15.
Chebyshev polynomials have an even more deplorable characteristic: their largest nu-
merical eigenvalues tend to be O(N 2j) where j is the order of the highest derivative. Thus,
an explicit time-marching scheme for the diffusion equation with Chebyshev spatial dis-
cretization is stable only when τ is O(1/N 4) or smaller. Ouch! For this reason, implict
and semi-implicit time-marching algorithms, which allow long time steps, are especially
important in the spectral world.
12.4
Implicit Time-Marching Algorithms
Implicit time-marching algorithms for du/dt = F(u, t) are formulas that require us to solve
a boundary value problem (BVP) at every time step to advance the solution to the next time
level. The reward for this costly BVP solution is that implicit methods are stable for much
longer time steps than explicit schemes.
There is a very wide range of implicit algorithms. Lie (1993) has successfully used
implicit Runge-Kutta schemes with spectral methods, for example, but implicit RK time-
stepping is rather expensive. The most popular implicit schemes include the Backward-
Differentiation Formulas (BDF) of of various orders and the “Crank-Nicholson” (CN) method.
The ﬁrst order BDF scheme is more commonly known as the “Backwards Euler” method
and also as the Adams-Moulton scheme of order one. The Crank-Nicholson scheme is also
known as the “Trapezoidal” method or the second order Adams-Moulton algorithm.
For du/dt = F(u, t) where both F and u may be vectors, these algorithms are
un+1 −un
τ
= F(un+1, tn+1)
[Backwards Euler (“BE”)]
(12.24)
(3/2)un+1 −2un + (1/2)un−1
τ
= F(un+1, tn+1)
[BDF2]
(12.25)
(11/6)un+1 −3un + (3/2)un−1 −(1/3)un−2
τ
= F(un+1, tn+1)
[BDF3]
(12.26)
25
12un+1 −4un + 3un−1 −4
3un−2 + 1
4un−3
τ
= F(un+1, tn+1) [BDF4]
(12.27)
un+1 −un
τ
= F(un+1, tn+1) + F(un, tn+1)
2
[Crank-Nicholson (CN)]
(12.28)
For the special case of the linear, scalar-valued ODE, du/dt = λu + f(t), it is easy to
solve the implicit formulas:
un+1 =
un
1 −τλ + τ f(tn+1)
1 −τλ
[BE]
(12.29)
un+1 = 1 + τλ/2
1 −τλ/2un + τ
2
f(tn+1) + f(tn)
1 −τλ/2
[CN]
(12.30)

12.5. SEMI-IMPLICIT METHODS
229
If λ is negative and real, then the solutions to the difference equations decay geometrically
to the steady state as exp(µt) where
µBE
λ
=
−log(1 + τλ)
τ λ
µCN
λ
=
−
log
³
1+τλ/2
1−τλ/2
´
τ λ
(12.31)
Since 1 + τλ must always be smaller than unity (since λ < 0), it follows that the logarithms
in (12.31) are always negative so that the ratios of µ/λ are always positive. In other words,
the numerical solutions decay, as does the true solution, for all τ ∈[0, ∞]. The conditional
stability of the Forward Euler scheme (where the condition is τ < 1/|λ|) has been replaced,
for these two implicit schemes, by unconditional stability.
It is left to the reader to demonstrate – if not already convinced by earlier numerical
analysis texts or courses – that the unconditional stability extends to λ anywhere in the left
half-plane including the imaginary axes, which is called the property of being “A-stable”.
Higher order schemes are not so well-behaved; BDF3 and BDF4, for example, are un-
stable for small imaginary λ. However, these algorithms are still sometimes used because
weak dissipation (ℜ(λ) < 0) is sufﬁcient to stabilize them. Fornberg(1996, Appendix G)
gives stability diagrams for a wide variety of schemes.
12.5
Semi-Implicit Methods
For nonlinear equations, an implicit algorithm has a high cost-per-timestep because one
must solve a nonlinear boundary value problem at every time step. For the Navier-Stokes
equations and for numerical weather forecasting and climate modelling, it is therefore com-
mon to use an algorithm in the following class.
Deﬁnition 26 (SEMI-IMPLICIT) If some terms in a differential equation are approximated by
an explicit scheme while others are approximated implicitly, then the resulting time-marching algo-
rithm is said to be SEMI-IMPLICIT.
For example, for the nonlinear PDE
ut = F(u, x, t) + L(u, x, t)
(12.32)
where F and L denote the nonlinear and linear parts of the differential equation, a popular semi-
implicit scheme is (“[AB3CN]”)
un+1
=
un + τ
½23
12 F (un, tn) −4
3 F
¡
un−1, tn−1¢
+ 5
12 F
¡
un−2, tn−2¢¾
+τ
2
©
L(un+1, tn+1) + L(un, tn)
ª
(12.33)
In general, the implicit and explicit schemes may be of the same or different order.
It may seem illogical to treat some terms explicitly while other terms implicitly, and
even more bizarre to use schemes of different orders, as in the AB3CN’s mix of third order
Adams-Bashforth with the Crank-Nicholson scheme, which is only second order. How-
ever, there are major advantages.
First, because the nonlinear term is treated explicitly, it is only necessary to solve a lin-
ear boundary value problem at each time step. Second, the viscous terms, which involve

230
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
second derivatives, impose much stiffer time step requirements (τ ∼O(1/N 4) for a Cheby-
shev basis) than the advective terms, which involve only ﬁrst derivatives and impose a
timestep limit proportional to 1/N 2. In other words, the semi-implicit algorithm stabilizes
the most dangerous terms. Third, in weather forecasting and other ﬂuid dynamics, ad-
vection is crucial. It is important to use a high order time-marching scheme with a short
timestep to accurately compute frontogenesis, turbulent cascades, advection of storm sys-
tems and so on. There is little advantage to treating the nonlinear terms implicitly because
a timestep longer than the explicit advective stability limit would be too inaccurate to be
acceptable.
Semi-implicit algorithms have therefore become almost universal in weather forecast-
ing and climate models.
12.6
Speed-Reduction Rule-of-Thumb
Rule-of-Thumb 12 (IMPLICIT SCHEME FORCES PHYSICS SLOWDOWN)
Implicit schemes obtain their stability by slowing down the time evolution of the numerical
solution so that explicit stability criteria are satisﬁed. In other words, if the implicit algorithm
approximates the true eigenvalue λ by µ where the homogeneous solution evolves as exp(λt), then
τ| µ(τ) | < O(1)
(12.34)
where τ is the time step. (Recall that the stability condition for the Forward Euler method is τ|λ| < 1
and for RK4 is τλ < 2.8.)
The Rule-of-Thumb has not been demonstrated for all possible implicit algorithms, but
no counterexamples have been published. The Rule-of-Thumb is also not quite a theorem
because it ignores the distinction between logarithmic growth and a constant.
For example, it is easy to show from (12.31) that
τ|µBE|
=
| log(1 + τλ)|
τ|µCN|
=
¯¯¯¯log
µ1 + τλ/2
1 −τλ/2
¶¯¯¯¯
(12.35)
Thus, the slowed-down numerical eigenvalue µ does not quite satisfy a stability require-
ment of the form
τ|µ| < q
(12.36)
for a constant q for all τ but only for q which is allowed to grow logarithmically with the
time step. However, when τ|λ| = 1000, that is, when the time step is 1000 times larger than
would be stable for the Forward Euler method, q < 8, that is, the homogeneous solution to
du/dt = λu + f(t) in the implicit difference schemes are evolving roughly 8/1000 times as
fast as for the exact solution.
Obviously, only a lunatic would use so long a time step if tracking evolution on the
time scale of 1/λ is physically signiﬁcant. This can be formalized as the following.
Rule-of-Thumb 13 (EXPLICIT-DEMANDING)
Suppose that the stability requirement for an explicit time-marching scheme for a time-dependent
PDE is, for some constant q,
τ|λmax| < q
(12.37)

12.7. SLOW MANIFOLD: METEOROLOGY
231
where, after discretization using N degrees of freedom for the spatial derivatives, λmax(N) is the
eigenvalue of the discretization matrix which is largest in magnitude. If it is important to follow
wave propagation, damping or other time behavior on the time scale of exp(iλmax t), then one
should use an EXPLICIT scheme with a time step which is SMALL compared to
τlimit ≡
q
|λmax| .
(12.38)
The ﬁrst point in justifying this Rule-of-Thumb is the observation that if τ ∼τlimit,
that is, if the time step is near the stability limit, then any explicit or implicit algorithm
will have large errors in following decay or propagation on a time scale of O(1/|λmax|). (It
may be highly accurate for slower components of the solution, but the Rule only applies
when these slow components are not enough, and one needs to accurately resolve the
fastest component, too.) It follows that we must use a time step which is small compared to
the stability limit to accurately track the dynamics of the fast component that imposes the
stability limit.
Given that the time step is so small, we may use either an implicit or explicit method.
Since implicit methods are usually much more expensive than explicit schemes for the
same time step, however, the second point is that it is usually cheaper to use an explicit
scheme.
There are some exceptions. First, implicit methods require solving a Boundary Value
Problem (BVP) at every time step, but if the basis is Fourier or spherical harmonics and
the operator of the BVP is constant coefﬁcient or a Laplace operator, solving the BVP may
be trivial. In that case, the Crank-Nicholson scheme, which is second order with a smaller
proportionality constant than most explicit schemes of the same order, is quite attractive.
Second, a Chebyshev basis usually generates some eigenvalues which are poor approxi-
mations to those of the corresponding differential operator. For the Laplacian, for example,
some of the Chebyshev eigenvalues are O(N 4), implying a time step which is no larger than
q/N 4 for an explicit scheme, while the ﬁrst N true eigenvalues are bounded by N 2. In this
case, stability is limited by garbage modes, that is, by large spurious eigenvalues whose
magnitude is unrelated to anything physical. It is sensible to use an implicit method with
a time step which is O(1/N 2) because then all the modes whose eigenvalues are good ap-
proximations to those of the differential operator will be integrated accurately in time; the
modes which are advanced with poor time accuracy are nonsense anyway.
Even so, it is clear that implicit methods must be used with discretion. In meteorology,
where implicit methods have been wisely employed for many years, this has led to the
concept of the “slow manifold”.
12.7
Slow Manifold: Meteorology
Weather forecasting is done by solving the “primitive equations”, which ﬁlter sound waves
so that only two important classes of waves remain. Rossby waves (and also nonlinear
advection, which has roughly the same time scale) are responsible for the travelling high-
pressure and low-pressure centers that are the large-scale weather. Gravity waves are gen-
erated by small-scale phenomena like thunderstorms and have frequencies an order of
magnitude higher than Rossby waves or the advective time scale.
Observations supply initial conditions for the numerical code. Rossby waves are well-
resolved by the radiosonde and satellite network, but gravity waves are not. However,
it has been known for many years that the amplitude of gravity waves, when averaged
over the globe, is very small compared to Rossby waves. If we imagine a conﬁguration

232
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
space of 3N dimensions where each coordinate is the amplitude of a wave mode in a nu-
merical model, then the instantaneous state of the atmosphere should lie close to the N-
dimensional subspace of pure Rossby wave motion with all the gravitational modes equal
to zero.
It follows that a good global forecasting model does not need to accurately track move-
ments in the whole phase space, but only ﬂow on the “slow manifold”. Implicit methods
are natural tools to integrate on the slow manifold. Their stability allows a long time step.
On the slow manifold – but only on the slow manifold – the long time step does not com-
promise the accuracy of the numerical solution.
Gravity waves limit the timestep for explicit algorithms to less than ten minutes. How-
ever, with an implicit or semi-implicit algorithm, one can make good ﬁve-day forecasts
with a timestep of an hour. Because of the errors introduced by subgridscale turbulence,
cumulus convection, photochemistry and so on, the total forecast error cannot be signiﬁ-
cantly reduced by using a shorter timestep.
Because the advective limit is roughly an hour and a timestep longer than an hour
would damage accuracy anyway, it is usual in forecasting to treat the nonlinear terms ex-
plicitly. The linear terms associated with gravity waves are treated implicitly, but in a
spherical harmonics basis, the (linear) BVP is easy to solve as explained in Chapter 18. The
semi-implicit algorithm costs only a little more per timestep than an explicit scheme, but
permits a time step six times longer.
Because the goal is to forecast only slow motion, implicit methods make sense for global
meteorology.
“Global” means a model whose goal is to forecast weather over a large area such as the
continental United States. In small areas (such as the rain shadow of a thunderhead), local
“fast” dynamics such as thunderstorms may be very important. (In densely-populated
areas, local Doppler radar and high-density instrument arrays can provide enough “fast”
data to make mesoscale modelling feasible locally, though not globally.) It follows that
so-called “mesoscale” models, which attempt to forecast severe weather for a few hours
ahead, must resolve the fast motion, not just the slow manifold, and therefore usually
employ explicit time-marching.
The concept of a “slow manifold” and the usefulness of implicit time-stepping methods
are situational.
12.8
Slow Manifold: General Deﬁnition and
Physical Examples
Many scientiﬁc problems have multiple time scales. A major branch of perturbation the-
ory, the “method of multiple scales”, exploits these different time scales. Implicit time-
marching schemes are a numerical strategy for doing the same thing.
As explained in the previous section, however, implicit methods are only sensible when
the goal is to track motion on the “slow manifold”.
Deﬁnition 27 (SLOW MANIFOLD)
In the phase space of a numerical model which allows motion on both a fast time scale and a slow
time scale, the SLOW MANIFOLD is the submanifold where the time evolution is on the longer
time scale only.
EXAMPLE ONE: “TRIVIAL” Slow Manifold: STEADY-STATE

12.8. SLOW MANIFOLD: DEFINITION & EXAMPLES
233
If a partial differential equation (and its discretization) have a steady state, then this is
the ultimate slow manifold. If we wish to integrate in time to allow the ﬂow to ﬁnd its own
way to the steady state, we may use inaccurate time-marching schemes because only the
ﬁnal steady state matters.
EXAMPLE TWO: FORCED LINEAR OSCILLATOR
du/dt + iu = f(ϵt),
ϵ << 1
(12.39)
The homogeneous solution of the oscillator, exp(−it), is the “fast” motion with a time scale
of unity; the O(1/ϵ) time scale of the forcing is the “slow” scale. The “slow manifold” is
that particular solution which varies only on the slow time scale; the general solution to
the ODE contains fast oscillations also.
Although the forced, linear oscillator seems too simple to be useful, it contains hidden
depth. First, the more general problem du/dt + iωu = f(ϵωt) can be converted into the
form of (12.39) merely by rescaling the time through t →ωt. Second, as noted in the ﬁrst
section, any linear partial differential equation with time-independent coefﬁcients can be
converted into the form of (12.39) by shifting to a basis of eigenfunctions of the matrix of
the discretized spatial derivatives.
Third, even a nonlinear problem can be cast in the form of (12.39) if the forcing f(ϵt) is
reinterpreted as a symbol for the nonlinear terms that couple different eigenmodes of the
linear part of the partial differential equation together. This point of view is popular in
weather forecasting because the nonlinear terms are an order of magnitude smaller than
the linear terms (for gravity modes); thus, global weather can be conceptualized as a sea of
independently propagating wave modes with weak wave-wave coupling.
Actually, the nonlinear interactions of the Rossby waves among themselves are rather
strong, but to a ﬁrst approximation the gravity waves are linear oscillators forced by the
nonlinear Rossby-Rossby interactions. These depend very weakly on the gravity waves
themselves, so that these Rossby-Rossby couplings may be regarded as external forcing for
the gravity waves.
These ideas are clariﬁed by the following.
EXAMPLE THREE: LK QUINTET
This model is described by Lorenz and Krishnamurthy (1987). It is obtained by truncat-
ing an atmospheric model to the most ruthless extreme that allows nontrivial interactions:
three Rossby modes and two gravity waves. If we denote the (large) Rossby amplitudes by
uppercase letters (U, V, W) and the (small) gravity mode amplitudes by (x, z) – note that
these are Fourier coefﬁcients and not velocities or coordinates – then the LK Quintet is
Ut
=
−V W + βV z −aU
Vt
=
UW −βUz −aV + F
Wt
=
−UV −aW
(12.40)
xt
=
−z −ax
zt
=
bUV + x −az
where subscript t denotes time differentiation and where (a, F, b, β) are constant parame-
ters. We shall mostly concentrate on the “inviscid” quintet, which is the special case that

0
20
40
60
80
-0.08
-0.06
-0.04
-0.02
0
0.02
0.04
0.06
0.08
0.1
Slow Modes
0
20
40
60
80
-5
-4
-3
-2
-1
0
1
2
3
4
5
x 10-3     Fast Modes
234
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
Figure 12.2: Example of solution to the “one-way coupled” inviscid LK Quintet (b = 1, β =
0 for the initial conditions [U, V, W, x, z] = [1/10, 0, −9/100, 0, 0]. Left panel: amplitudes of
the three Rossby waves. (i) U: Thickest curve (never changes sign). V : Medium thickness
(“tent-shaped”). W: Thinnest curve. Right panel: amplitudes of the two gravity waves
with x(t) as the thicker, larger amplitude curve.
the damping coefﬁcient a and the forcing F are both zero:
Ut
=
−V W + βV z
Vt
=
UW −βUz
Wt
=
−UV
(12.41)
xt
=
−z
zt
=
bUV + x
It is often convenient to set β = 0 to obtain the “one-way coupled” model because an exact
analytical solution has been given by Boyd(1994c).
A representative solution is shown in Fig. 12.2.
EXAMPLE FOUR: KdV Solitary Wave
The Korteweg-deVries equation is
ut + u ux + uxxx = 0
(12.42)
The general solution with spatially periodic boundary conditions consists of solitary waves
and quasi-sinusoidal travelling waves. The simplest solitary wave or “soliton” is an exact
nonlinear solution which steadily translates at a constant phase speed c:
usol(x, t) = 12ϵ2sech(ϵ [x −ct] + φ);
c = 4 ϵ2
(12.43)

0
0.5
1
1.5
2
2.5
-1
-0.5
0
0.5
1
time
Slow (thick curve) and fast (thin curve) parts
0
0.5
1
1.5
2
2.5
-1
-0.5
0
0.5
1
KdV equation: real part of exp(i 5 x)
12.8. SLOW MANIFOLD: DEFINITION & EXAMPLES
235
where ϵ and φ are constants. Strictly speaking, the soliton is deﬁned only for a spatially
unbounded interval, but its periodic generalization, called a cnoidal wave, is well approx-
imated by (12.43) when ϵ ∼O(1) or larger.
Figure 12.3: The real part of the Fourier coefﬁcient of exp(i5x) as a function of time for a
Korteweg-deVries (KdV) solution which is the sum of a solitary wave of unit phase speed
and a small amplitude sine wave of wave number k = 5. The amplitude has been scaled to
unity for the soliton contribution to this Fourier coefﬁcient.
If the initial conditions are slightly perturbed from a soliton, then the ﬂow will evolve
as a solitary wave plus small amplitude sine waves which satisfy the linear KdV equation:
usine(x, t) = α cos(k[x −k2 t])
(12.44)
More general solutions with multiple solitons and large amplitude non-soliton waves are
also possible, but for our purposes, it will sufﬁce to consider a small amplitude solitary
wave perturbed by very small sine waves. The interaction between the soliton and the rest
of the ﬂow, although not zero, can be neglected to a ﬁrst approximation.
Fig. 12.3 illustrates the time evolution of a typical Fourier coefﬁcient. The slow compo-
nent, shown separately in the lower panel, is the solitary wave. The fast component, which
controls the maximum time step for an explicit method, is the perturbing sine wave. The
crucial point is that because the frequency of a sine wave of wavenumber k grows rapidly
as k3, these small waves are extremely fast-moving.
If the goal is to resolve the fast sine waves, then one might as well use an explicit
method. If K is the maximum wavenumber, then one must use τ ∼O(1/K3) to accurately
track its propagation.
If the goal is only to understand the evolution of the solitary waves — historically true
of most KdV numerical studies — then one can use an implicit or semi-implicit scheme

236
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
with a much longer time step. For example, the fourth order Runge-Kutta method, which
has a rather large stability limit, is stable only when
τ < 2.8/K3
(12.45)
However, aK(t) varies due to the solitary wave as cos(Kct), which has a temporal period
of 2π/(K c). Thus, the largest timestep which is stable for RK4 is 2.2K2/c timesteps per
temporal period. For c = 1 and K = 16, this is 570 time steps per period, and the number
grows quadratically with K. Implicit algorithms allow one to accurately model the solitary
wave with a much longer time step than 1/570 of a temporal period.
There is actually a close relationship between this example and the forced linear oscil-
lator because the Fourier-Galerkin ODEs in time for the KdV equation are
dak
dt −ik3ak = −i
∞
X
m=−∞
ak−m am
(12.46)
This is identical in form to our second example (12.39) with ω = −k3 and with the nonlinear
terms in the inﬁnite series serving as the forcing for the k-th Fourier coefﬁcient. Of course,
one must be careful not to push the analogy too far because (12.46) is a coupled system, not
merely a single isolated ODE. However, for large k, the nonlinear self-interaction of ak can
be neglected and the forced linear oscillator is a good ﬁrst approximation.
12.9
Numerically-Induced Slow Manifolds:
The Stiffness of Chebyshev Differentiation
Matrices
As noted in the CFL Stability Limit Rule-of-Thumb in Chapter 9, the maximum timestep
is the same order of magnitude as the time scale for advection or diffusion or wave prop-
agation or whatever across the smallest distance h between two grid points. For wave
propagation and for diffusion, the limits are
τmax = d
h
cmax
[Waves]
τmax = d′ν h2
[Diffusion]
(12.47)
where d, d′ are O(1) constants and where cmax is the speed of the fastest-moving waves
and ν is the diffusion or viscosity coefﬁcient.
For Chebyshev and Legendre methods, these stability limits are very bad news because
these use highly nonuniform grids with the smallest h — right next to the endpoints —
being proportional to 1/N 2. In contrast, an evenly spaced grid has h = 2/N everywhere.
It follows that explicit time-marching schemes are subject to very short time step limits
when applied to ODEs derived from Chebyshev or Legendre spatial discretizations. For
this reason, implicit time-marching schemes are very widely used with Chebyshev and
Legendre spectral methods. The longest chapter in the book (Chap. 15) will focus on
efﬁciently solving the boundary value problems, such as those from implicit algorithms.
An even more pressing concern is: Are implicit schemes sufﬁciently accurate to resolve
everything that needs to be resolved when used with Chebyshev spatial discretizations?
An example is useful: the one-dimensional diffusion equation with homogeneous Dirichlet
boundary conditions is
ut = uxx + f(x);
u(−1) = u(1) = 0;
u(x, 0) = Q(x)
(12.48)

12.9. NUMERICALLY-INDUCED SLOW MANIFOLDS
237
where for simplicity f(x) is independent of time.
We can exploit symmetry by splitting u = S(x, t) + A(x, t) where S and A are u’s sym-
metric and antisymmetric parts with respect to x = 0. We can deﬁne symmetric cardinal
functions as a basis for S via
φj(x) ≡Cj(x) + C−j(x)
(12.49)
where the Cj(x; 2N) are the usual Chebyshev cardinal functions on the (2N + 2)-point
Lobatto grid, numbered so that the cardinal functions which are one at the endpoints are
C±(N+1).
The equation for the symmetric part is then reduced by the Chebyshev cardinal function
spatial discretization to
⃗St = ⃗D ⃗S + ⃗f
(12.50)
where the elements of the N-dimensional column vector ⃗S(t) are the time-dependent val-
ues of S(x, t) at each of the positive collocation points, excluding the endpoint x = 1, which
is omitted so that S(1, t) = 0 for all t to satisfy the boundary conditions, and ⃗f is similarly
the grid point values of f(x) for x ≥0. The elements of the square matrix ⃗D, which is the
discrete representation of the second derivative operator, are
Dij ≡φj,xx(xi),
i, j = 1, 2, . . . , N
(12.51)
where the boundary conditions have been implicitly included by omitting the cardinal
function and grid point associated with x = 1.
If we compute the eigenvectors and eigenvectors of ⃗D, we can switch to an eigenvector
basis. In terms of this, the second derivative matrix is diagonal and (12.50) reduces to the
uncoupled set of equations
dbj
dt = −λjbj + gj
(12.52)
which is identical to (12.5) except that we have changed the sign of the eigenvalue so that λj
is positive for diffusion; the {bj(t)} and {gj}are the spectral coefﬁcients in the eigenvector
basis. The solution is
⃗S(t) = ⃗f +
N
X
j=1
bj(0) exp(−λjt) ⃗ej
(12.53)
Table 12.1: Eigenvalues of the Second Derivative with Homogeneous Dirichlet Boundary
Conditions Including Both Symmetric and Antisymmetric Modes
Method
Eigenvalues λj, j = 1, 2, ..., N
max(λ)
Exact
j2π2 / 4
N 2π2 / 4
2d order Finite Difference
(N + 1)2 sin2 ³
jπ
2(N+1)
´
N 2
Chebyshev: Lobatto grid
accurate for j < N (2/π)
0.048 N 4
Chebyshev: Gauss grid
accurate for j < N (2/π)
0.303 N 4
Legendre: Gauss grid
accurate for j < N (2/π)
0.102 N 4

0
5
10
15
10 0
10 1
10 2
10 3
10 4
10
5
j
Solid: exact eigenvalues    Circles: Chebyshev
Slow Manifold
Fast Modes
238
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
Figure 12.4: The exact eigenvalues of the second derivative operator with homogeneous
Dirichlet boundary conditions on x ∈[−1, 1] are shown as the heavy solid line; the cor-
responding eigenvalues of the Chebyshev collocation matrix are the circles-with-thin-line.
Roughly (2/π) ≈0.64 of the Chebyshev eigenvalues — roughly 10 of the 16 eigenmodes
illustrated — are good approximations. Eigenvalues 11 to 16 are way off, and there is no
point in accurately tracking the time evolution of these modes of the Chebyshev pseu-
dospectral matrix because they have no counterpart in the solution of the diffusion equa-
tion. The slow manifold is composed of the modes left of the vertical dividing line whose
Chebyshev eigenvalues do approximate modes of the diffusion equation. The largest nu-
merical eigenvalue is about 56,000 whereas the largest accurately approximated eigenvalue
is only about 890, a ratio of roughly 64, and one that increases quadratically with N. Only
symmetric eigenmodes are shown.
The exact solution to the diffusion equation is of the same form except that the eigen-
vectors are trigonometric functions and the eigenvalues are different as given by the ﬁrst
line of Table 12.1. The good news of the table is: the ﬁrst (2/π)N eigenvalues are well-
approximated by any of the three spectral methods listed. This implies that we can follow
the time evolution of as many exact eigenmodes as we wish by choosing N sufﬁciently
large.
The bad news is: the bad eigenvalues are really bad because they grow as O(N 4) even
though the true eigenvalues grow only as O(N 2). In the parlance of ODE theory, the
Chebyshev-discretized diffusion equation is very “stiff”, that is, it has an enormous range
in the magnitude of its eigenvalues. The stability limit (set by the largest eigenvalue) is
very small compared to the time scale of the mode of smallest eigenvalue.
The slow manifold is the span of the eigenmodes which are accurately approximated
by the discretization, which turns out to be the ﬁrst (2/π)N modes for this problem. The
fast-and-we-don’t-give-a-darn manifold is the subspace in conﬁguration space which is
spanned by all the eigenmodes that are are poorly resolved by N Chebyshev polynomials
(Fig. 12.4).
However, the physics is also relevant: if only the steady-state solution matters, than the
slow manifold is the steady-state, and the time evolution of all modes can be distorted by
a long time step without error. The physics and numerics must be considered jointly in
identifying the slow manifold.

1
2
3
4
5
0
0
2
4
6
8
10
-2
-4
-6
-8
-10
TIME (days)
12.10. INITIALIZATION
239
Figure 12.5: The time evolution of the north-south wind at 50.40 N. on the Greenwich
meridian for the barotropic forecast of Richardson (1922). The dotted curve is the forecast
made from the raw data without initialization. The solid curve is not the result of a running
time average, but rather is the forecast from the initial conditions obtained by adjusting the
raw data onto the slow manifold. [Redrawn from Fig. 8c of Lynch(1992) with permission
of the author and the American Meteorological Society.]
12.10
Initialization
Meteorological jargon for the statement that “the large scale dynamics is near the slow
manifold” is to say that the ﬂow is “in quasi-geostrophic balance”. Unfortunately, raw
observational data is corrupted by random instrumentation and sampling errors which,
precisely because they are random, do not respect quasi-geostrophic balance. Initializ-
ing a forecast model with raw data generates a forecast with unrealistically large gravity
wave oscillations superimposed on the slowly-evolving large-scale dynamics (Daley, 1991,
Lynch, 1992, Fig. 12.5). The remedy is to massage the initial conditions by using an algo-
rithm in the following category.
Deﬁnition 28 (SLOW MANIFOLD INITIALIZATION)
A numerical algorithm for adjusting unprocessed initial values from a point in conﬁguration space
off the slow manifold to the nearest point on the slow manifold is called a SLOW MANIFOLD
INITIALIZATION or simply (especially in meteorology) an INITIALIZATION procedure.
Fig. 12.6 schematically illustrates initialization onto the slow manifold.
Meteorological simulations of large-scale weather systems can be subdivided into fore-
casting and climate modelling. For the latter, the model is run for many months of time
until it “spins up” to statistical equilibrium. The time-averaged temperature and winds
then deﬁne climate of the model. The choice of initial conditions is irrelevant because the
ﬂow will forget them after many months of integration; indeed, independence of the initial
conditions is an essential part of the very deﬁnition of climate.

Raw Data
Adjusted
Initial Conditions
240
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
Figure 12.6: Schematic of an initialization onto the slow manifold, which is shown as the
cross-hatched surface in a three-dimensional conﬁguration space. (A real conﬁguration
space might have millions of dimensions where each coordinate is a spectral coefﬁcient or
grid point value.)
A slow manifold initialization is unnecessary for a climate model. The inherent dissipa-
tion of the model gradually purges the fast transients, like white blood cells eating invading
germs. Similarly, the backwards Euler scheme, which damps all frequencies but especially
high frequencies, will pull the ﬂow onto the slow manifold for almost any physical system,
given long enough to work. The BE algorithm, viscosity, and other physical or computa-
tional damping mechanisms are a kind of “Poor Man’s Slow Manifold Initialization”.
When the ﬂow must be slow from the very beginning, however, stronger measures are
needed. Meteorologists have tried a variety of schemes including:
1. Modifying the partial differential equations so that the approximate equations sup-
port only “slow” motions (quasi-geostrophic and various “balanced” systems, re-
viewed in Daley, 1991).
2. “Dynamic initialization”, which is integrating a few steps forward in time, followed
by an equal number back to t = 0, using special algorithms designed to damp high
frequencies, rather than accurately integrate in time (Daley, 1991, Chap. 11).
3. Time-frequency ﬁltering via Laplace transforms (Lynch and Huang, 1992).
4. Method of multiple scales [“Normal mode initialization”] (Machenhauer, 1977, Baer,
1977, Baer and Tribbia, 1977).
Without assessing the relative merits of these schemes for operational forecasting, we shall
describe the method of multiple scales, or “normal mode initialization” as meteorologists
call it, because it provides the theoretical underpinning for the Nonlinear Galerkin meth-
ods.

12.11. THE METHOD OF MULTIPLE SCALES(BAER-TRIBBIA)
241
12.11
The Method of Multiple Scales:
The Baer-Tribbia Series
When a partial differential equation with both fast and slow modes is discretized through
Galerkin’s method using the normal modes as the spectral basis, the result is a system of
coupled ordinary differential equations in time that can be written
⃗St + i ⃗ωS . ∗⃗S
=
⃗fS(⃗S, ⃗F)
⃗Ft + i ⃗ωF . ∗⃗F
=
⃗fF (⃗S, ⃗F)
after partitioning the solution ⃗u into its slow and fast modes, ⃗S and ⃗F, respectively. (In
meteorology, ⃗S is the vector of amplitudes of the Rossby modes while ⃗F is the amplitude
of the gravity waves.) The symbol .∗is used to denote elementwise multiplication of two
vectors, that is, ⃗ωS . ∗⃗S is a vector whose j-th element is the product of the frequency of
the j-th mode, i. e., the j-th element of ⃗ωS, with the j-th element of ⃗S. The obvious way
to integrate on the slow manifold is to simply ignore the fast modes entirely and solve the
reduced system
⃗St + i ⃗ωS. ∗⃗S = fS(⃗S,⃗0)
(12.54)
Machenhauer (1977) pointed out that this is a rather crude approximation. The non-
linear interaction of the slow modes amongst themselves will create a forcing for the fast
modes. If the time scale for the slow modes is O(ϵ) compared to the fast frequencies, then
the second line of Eq. (12.54) implies that
⃗Fj ≈−i(⃗fF (⃗S,⃗0))j
ωj
(12.55)
to within a relative error of O(ϵ). This forced motion in the fast modes varies slowly with
time because it is forced only by the slow modes. Machenhauer showed that initializa-
tion schemes for weather forecasting were signiﬁcantly improved by computing the initial
values of the gravity modes from Eq.(12.55). If the gravity modes are initialized to zero,
then the forecast must include (thrice-accursed!) high frequency gravity waves to cancel
(at t = 0) the slow particular solution given by Eq.(12.55), and the forecast will resemble
the wiggly dotted curve in Fig. 12.5.
Baer(1977) and Baer and Tribbia (1977) observed that Machenhauer’s approximation
was really just the lowest order of a singular perturbation expansion in ϵ, derivable by the
so-called “method of multiple scales”. The underlying idea can be illustrated by computing
the perturbation series for a linear, uncoupled ODE:
du
dt = λu + f(ϵ t)
(12.56)
which is just Eq.(12.5) again except that we make one crucial assumption: that the forcing
varies slowly with time as measured by the small parameter ϵ which appears inside its
argument. (Implicitly, λ ∼O(1), but this is not crucial; the effective perturbation parameter
will turn out to be the ratio ϵ/λ which is the ratio of the “fast” and “slow” times scales for
the problem.)
It is convenient to introduce the slow time variable
T ≡ϵ t
(12.57)

242
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
The ODE becomes
ϵ du
dT = λ u + f(T)
(12.58)
It is then clear that lowest nontrivial approximation is the same as Machenhauer’s: ne-
glecting the time derivative so that there is an approximate balance between the two terms
on the right-hand-side. This approximation, however, is sensible only for motion on the
slow manifold or within O(ϵ) of the slow manifold; the homogeneous solution is the fast-
evolving function exp(λt), which is poorly approximated by neglecting the time derivative.
Deﬁning
u(T; ϵ) =
N
X
j=0
uj ϵj
(12.59)
we obtain
u0(T)
=
−f(T)/λ
u1(T)
=
du0/dT
λ
=
−df/dT
λ2
u2(T)
=
du1/dT
λ
=
−d2f/dT 2
λ3
and in general
uslow(T; ϵ) ∼−1
λ
N
X
j=0
djf
dT j
³ ϵ
λ
´j
(12.60)
This inﬁnite series is noteworthy for a couple of reasons. First, the asymptotic equality
sign is used because this is an asymptotic series that diverges except for special cases.
However, when ϵ/λ ∼O(1/10) as in meteorology, one can use six to ten terms of the series
to obtain an extremely accurate approximation, and the fact that the error would grow with
additional terms has no practical relevance.
The second is that the asymptotic series does not contain an arbitrary constant of inte-
gration. The general solution to this ﬁrst order ODE is
u(t) = A exp(λ/ t) + uslow(ϵ t; ϵ)
(12.61)
where A is an arbitrary constant determined by the initial condition. If we pick any old
u(0), then u(t) will be a mixture of fast and slow motion. Initialization onto the slow man-
ifold means setting u(0) = uslow(0; ϵ) so that A = 0.
The method is almost the same for the coupled system of fast and slow modes, Eq.(12.54),
except for two differences. First, only the time derivative of the “fast” components is ne-
glected so that the “Machenhauer” approximation is
⃗St + i ⃗ωS . ∗⃗S
=
⃗fS
i ⃗ωF . ∗⃗F
=
⃗fF
(12.62)

12.12. NONLINEAR GALERKIN METHODS
243
The system of ODEs has been replaced by a so-called “Differential-Algebraic” (DAE) set of
equations.
The second difference is that fS and fF are not pre-speciﬁed, known functions of time
but rather depend nonlinearly on the unknowns. Since the fast component is typically
small compared to the slow modes – if it wasn’t one would hardly be integrating near
the slow manifold — one can build the dependence on ⃗F into the perturbation theory.
However, the coupling between slow modes is often so strongly nonlinear than it cannot
be approximated. The DAE must usually be solved by numerical integration of the ODE
part plus algebraic relations which become increasingly complicated as one goes to higher
order.
Indeed, the difﬁculties of separating various orders in the perturbation theory esca-
late so rapidly with order that Tribbia(1984) suggested replacing perturbation by itera-
tion, which is easier numerically. With this simpliﬁcation, the Baer-Tribbia method and its
cousins are in widespread operational use in numerical weather prediction to adjust raw
observational data onto the slow manifold. (See the reviews in Daley, 1991.) Errico (1984,
1989a) has shown that the Machenhauer approximation [lowest order multiple scales] is a
good description of the relative magnitudes of terms in general circulation models, which
include such complications as latent heat release, chemistry and radiative transfer, pro-
vided that the label of “fast” mode is restricted to frequencies of no more than a few hours.
12.12
Nonlinear Galerkin Methods
Although the Baer-Tribbia series and related algorithms have been used almost exclusively
for initialization, the split into fast and slow modes applies for all time and is the basis for
the following class of algorithms.
Deﬁnition 29 (NONLINEAR GALERKIN) A numerical algorithm for discretizing a partial
differential equation is called a “Nonlinear Galerkin” scheme if the system of ODEs in time that
results from a conventional spatial discretization is modiﬁed to a Differential-Algebraic Equation
(DAE) system by replacing the ODEs for the time derivatives of the fast modes by the method of
multiple scales (in time).
Nonlinear Galerkin methods can be classiﬁed by the order m of the multiple scales approxima-
tion which is used for the algebraic relations. NG(0) is the complete omission of the fast modes
from the spectral basis. NG(1) is the lowest non-trivial approximation, known in meteorogy as the
“Machenhauer approximation”. For the single linear forced ODE, du/dt = λu + f(t), the ﬁrst
three approximations are
u
≡0
NG(0)
u
∼−f/λ
NG(1)
u
∼−f/λ −df/dt/λ2
NG(2)
(12.63)
Kasahara (1977, 1978) experimented with forecasting models in which the usual spher-
ical harmonic basis was replaced by a basis of the Hough functions, which are the normal
modes of the linear terms in the model. This was a great improvement over the old quasi-
geostrophic models, which ﬁltered gravity modes, because the Hough basis could include
some low frequency gravitational modes. However, it was still only an NG(0) approxima-
tion: high frequency Hough modes were simply discarded.
Daley (1980) carried out the ﬁrst experiments with NG(1) for a multi-level weather
prediction model. He found that the algorithm compared favorably with stanard semi-
implicit algorithms in both efﬁciency and accuracy. Unfortunately, the Nonlinear Galerkin
method was no better than semi-implicit algorithms either. Haugen and Machenhauer

244
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
Table 12.2: A Selected Bibliography of Nonlinear Galerkin Methods
Note: KS is an abbreviation for “Kuramoto-Sivashinsky” , FD for “ﬁnite difference”, “CN” for the Crank-
Nicholson scheme and “BDF” for Backward Differentiation time-marching schemes. Most articles with non-
spectral space discretizations are omitted.
Reference
Area
Comments
Kasahara (1977, 1978)
Meteorology
NG(0)
Daley (1980)
Meteorology
NG(1)
Daley (1981)
Meteorology
Review: normal mode
initialization
Foias et al.(1988)
Reaction-diffusion
Independent rediscovery;
& KS
call it
“Euler-Galerkin” method
Marion & T´emam(1989)
Dissipative systems
Independent rediscovery of NG
T´emam (1989)
Navier-Stokes
Recursive calculation
high order NG series
Jauberteau, Rosier
Fluid Dynamics
& T´emam(1990a,b)
Jolly, Kevrekidis
KS Eq.
Computation of inertial manifolds;
& Titi(1990, 1991)
Fourier
Dubois, Jauberteau
Fluids
Fourier, 2D, 3D
& T´emam (1990)
number of fast modes
adaptively varied
Foias et al.(1991)
KS, forced Burgers
Blow-up
T´emam (1991b)
Numerical analysis
Stability analysis
T´emam (1991a)
Fluid Mechanics
Review
Promislow
Ginzburg-Landau Eq.
numerical experiments;
& T´emam(1991)
higher order NG
T´emam (1992)
Review
Devulder & Marion(1992)
Numerical Analysis
Margolin & Jones(1992)
Burgers
NG with spatial FD
Pascal & Basdevant(1992)
2D turbulence
Improvements & efﬁciency tests
Gottlieb & T´emam(1993)
Burgers
Fourier pseudospectral
Foias et al.(1994)
KS
Blow-up
Garc´ia-Archilla
Numerical analysis
Comparisons of NG
& de Frutos(1995)
with other time-marching schemes
Garc´ia-Archilla(1995)
Numerical analysis
Comparisons of NG with other schemes
Boyd (1994e)
Numerical Analysis
Theory for inferiority
of NG to CN & BDF
Vermer&van Loon(1994)
chemical
NG(1) popular as PSSA:
kinetics
“Pseudo-steady-state approx.”
Debussche&Dubois
Homogeneous
&T´emam(1995)
turbulence
Jolly&Xiong(1995)
2D turbulence
Jones&Margolin
Comparison with Galerkin;
&Titi(1995)
forced Burgers & KS equations
Dubois&Jauberteau&Te´emam(1998)
Comprehensive review

12.13. WEAKNESSES OF THE NONLINEAR GALERKIN METHOD
245
0
0.2
0.4
0.6
0.8
1
0
0.2
0.4
0.6
0.8
1
ε τ
NG(1)
BE
CN
Figure 12.7: Relative errors in approximating the time derivative of exp(iϵt) as a function
of ϵ and the time step τ. The relative error in the Nonlinear Galerkin method, which sim-
ply discards the time derivative, is one independent of the time step (horizontal line). The
errors in the Backwards Euler (BE) and Crank-Nicholson (CN) implicit methods are func-
tions of the product of ϵ with τ and decrease linearly (circles) and quadratically (asterisks)
as ϵτ →0. However, even for ϵτ = 1 — only 2π grid points in time per temporal period —
the errors are still much smaller than NG(1).
(1993) also tried an NG scheme in combination with a semi-Lagrangian (SL) treatment of
advection. For long time steps (sixty minutes), the NG scheme was inaccurate unless two
Machenhauer-Tribbia iterations were used. This made the NG/SL combination a little less
efﬁcient than the semi-implicit SL algorithm which has now become very popular for both
global and regional models.
Nonlinear Galerkin methods were independently rediscovered by Roger T´emam and
his collaborators (Marion and T´emam, 1989, Jauberteau, Rosier, and T´emam, 1990) and also
by Foias et al.(1988). (Parenthetically, note that similar approximations under the name of
the “quasi-static” approximation or “pseudo-steady-state approximation” have also been
independently developed in chemical kinetics where the ratio of time scales often exceeds a
million (Vermer and van Loon, 1994)!). Table 12.2 describes a large number of applications.
The practical usefulness of Nonlinear Galerkin time-marching is controversial. Daley,
Haugen and Machenhauer (1993), Boyd (1994e), Garc´ia-Archilla(1995) and Garc´ia-Archilla
and de Frutos (1995) are negative Pascal and Basdevant (1992) conclude that NG is useful
in reducing costs for turbulence modelling; most of the other authors in Table 12.2 are also
optimistic about the merits of the Nonlinear Galerkin method.
12.13
Weaknesses of the Nonlinear Galerkin Method
In comparing the Nonlinear Galerkin method with implicit and semi-implicit schemes,
there are two key themes.

246
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
1. All temporal ﬁnite difference approximations have an accuracy which is proportional
to NG(1) multiplied by a constant times τ r where r is the order of the ﬁnite difference
method and τ is the timestep.
2. The computational complexity and expense of Nonlinear Galerkin methods, NG(m),
grows very rapidly with the order m.
Demonstrating the second assertion would take us too far aﬁeld, but it is really only com-
mon sense: NG schemes are derived by perturbation theory, and the complexity of almost
all perturbation schemes escalates like an avalanche. T´emam (1989) gives recursive for-
mulas for calculating high order NG formulas; Promislow and T´emam(1991) is unusual
in performing numerical experiments with high order NG schemes, that is, NG(m) with
m > 1. The special difﬁculty which is explained in these articles is that all NG schemes
higher than Machenhauer’s [NG(1)] approximation require the time derivative of the non-
linear terms which force the fast modes. There is no simple way to compute the time
derivative of order (m −1) as needed by NG(m), although complicated and expensive
iterations can be implemented.
The ﬁrst point is more fundamental. The sole error of Backwards Euler, Crank-Nicholson
and other time-marching schemes is that they approximate the time derivatives. Since
NG(1) approximates the time derivative by completely ignoring it, it follows that the error
in NG(1) is proportional to the accuracy of this assertion that the time derivative is small.
However, the relative smallness of the time derivative is an advantage for implicit time-
marching schemes, too, because their error in approximating the derivative is multiplied
by the smallness of the term which is being approximated.
For example, consider the simple problem
ut + iu = exp(iϵt)
(12.64)
for which the exact slow manifold (Boyd, 1994e, H.-O. Kreiss, 1991) is
uslow(t; ϵ) ≡−i
1
1 + ϵ exp(i ϵ t)
(12.65)
The exact derivative of the slow solution is i ϵ uslow. The relative errors in approximating
this, in other words, [ut(exact)−ut(approximate)]/ut(exact), are graphed as Fig. 12.7. Note
that because the complex exponential is an eigenfunction of the difference operators, the
slow manifold for all the approximation schemes (including NG(m)) is proportional to
exp(iϵt). This factor cancels so that the relative error is independent of time.
The most remarkable thing about the graph is the fact that even when the temporal
resolution is poor (no more than 6 points per period of the slow manifold), the humble
BE method has only half the error of NG(1) whereas the Crank-Nicholson scheme has
only 1/12 the error of NG(1). This seems little less than amazing because the BE and
CN methods are general time-stepping schemes that in theory can be applied to any time-
dependent problem. In contrast, the Nonlinear Galerkin method is specialized to track the
slow manifold only; it has no meaning for time-dependent problems with but a single time
scale. Why is the specialized method so bad compared to the general methods?
The answer is the obvious one that an approximation, even a bad one, is better than
no approximation at all. NG(1) is a non-approximation of the time derivative. In contrast,
implicit schemes try to accurately approximately ut as is also done by higher order (m > 1)
NG methods.
Of course, with a really long time step, the ﬁnite differencing schemes would give O(1)
errors, but this is insane. In practical applications, it is necessary to integrate the fast and
slow modes as a coupled system.
A time step which is long enough to make Crank-
Nicholson poorer than NG(1) for the fast modes will also do a terrible job of advancing

B
B
B
B
B
B
B
B
B
B
J
J
J
J
J
J
J
J
J
J
H
H
H
H
H
H
H
H
H
H
F
F
F
F
F
F
F
F
F
F
0.00001
0.0001
0.001
0.01
0.1
1
0.1
1
NG(0) ["truncation"]
NG(1) ["diagnostic"]
NG(2)
Crank-Nicholson
BDF2
Backwards-Euler
ε τ
12.13. WEAKNESSES OF THE NONLINEAR GALERKIN METHOD
247
Figure 12.8: Maximum pointwise errors in approximating the slow manifold of du/dt +
iωu = exp(i ϵ t), plotted versus the product of ϵ with τ. The ratio of ω/ϵ is ﬁxed at 1/10;
the errors for the Nonlinear Galerkin schemes, which are independent of the time step and
therefore appear as horizontal lines, are proportional to (ω/ϵ)m for NG(m).
the slow modes. Thus, it is always necessary to choose ϵτ < 1 in practice, and the implicit
schemes always triumph over NG(1).
It also true that if we compare implicit schemes with NG(m) in the limit m →∞for
ﬁxed time step and ratio of time scales ϵ, the NG scheme will be superior. This is illustrated
by Fig. 12.8, which compares NG schemes of various orders with implicit methods for a
particular value of ϵ. However, even though ϵ = 1/10, the Crank-Nicholson scheme is
better than NG(2) for all τ < 1/ϵ, that is, whenever there are more than six points per time
period of the slow manifold. Furthermore, because of the complexity of high order NG
methods, most Nonlinear Galerkin studies beginning with Daley (1980) have used NG(1)
only.
Garc´ia-Archilla and de Frutos (1995) have compared time-marching algorithms for some
simple nonlinear equations. Advection does not change the conclusion: “The results show
that for these problems, the non-linear Galerkin method is not competitive with either pure
spectral Galerkin or pseudospectral discretizations.” Haugen and Machenhauer (1993)
found that NG(1) was not competitive with the semi-implicit method for a time step of
an hour when advection was handled by a semi-Lagrangian scheme.
All this negative evidence raises the question: Why has so much work been done with
Nonlinear Galerkin methods? Part of the answer is that many of the articles in Table 12.2
report considerable cost-savings over conventional algorithms. (However, most studies

248
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
were restricted to explicit schemes versus NG schemes only.) A second answer is that
numerical analysts are as opinionated as soccer fans.
A third answer is that NG schemes are self-initializing. The Crank-Nicholson scheme
is a good method to track the slow manifold, yes, but it is powerless to follow the slow
manifold unless some external agency adjusts the initial conditions ﬁrst.
A fourth answer is that the Nonlinear Galerkin scheme is a very thoughtful algorithm.
In a problem with multiple time scales that evolves only on the slow time scale, the high
frequency modes are forced only by the slow modes. This, to lowest order, is what really
happens. The insight underlying NG schemes has led to interesting connections between
them and multigrid, hiearchical ﬁnite element bases, and a wide variety of other algorithms
as outlined in the many papers of T´emam and his collaborators. Perhaps in time, at least
in special cases, the inefﬁciencies so evident in Figs. 12.7 and 12.8 will be remedied.
12.14
Following the Slow Manifold with
Implicit Time-Marching:
Forced Linear Oscillator
To examine implicit algorithms experimentally, it is useful to consider same model as in
the previous section:
ut + iu = exp(iϵt)
(12.66)
which, writing u(t) = x(t) + i y(t), is equivalent to the pair of real-valued equations
xt −y = cos(ϵt)
&
yt + x = sin(ϵt)
(12.67)
The specialization to unit frequency is no restriction because if the frequency is some differ-
ent number ω, we can deﬁne a new time variable s by ωt = s, and then the homogeneous
solutions of Eq.(12.64) will oscillate with unit frequency in s. Note that this requires re-
deﬁning ϵ: the effective perturbation parameter for general ω is ϵ/ω, that is, the ratio of the
frequency of the forcing to the frequency of the homogeneous solution.
The specialization to a forcing function that is harmonic in time is a little restrictive, but
only a little, because very general forcing functions can be constructed by using Fourier
series or integrals to superpose components of the form of exp(iϵt) for various ϵ. However,
the exponential forcing is very convenient because it allows us to explicitly compute the
slow manifold not only for the differential equation but also for its approximation by NG
and various implicit time-marching schemes.
Fig. 12.9 shows the exact solution, the slow manifold, and the Crank-Nicholson ap-
proximation for an initial condition which excites both fast and slow motion. The timestep
τ = 1/ϵ, which is 2 π points per slow temporal period.
The fast component oscillates through ten periods on an interval where the Crank-
Nicholson scheme has only six points, so it is absurd to suppose the time-marching method
can accurately track the fast motion. Still, it fails in an interesting way. The CN scheme does
oscillate around the slow manifold, just like the exact solution. Its cardinal sin is that, as
asserted earlier in Rule-of-Thumb 6, it tremendously slows down the oscillation, approxi-
mating an oscillation of period 2π by an oscillation of period 2τ.
As asserted earlier, without a separate slow manifold initialization procedure, the Crank-
Nicholson scheme is useless for integrating motion that is supposed to be purely slow
motion. In contrast, the Backwards Euler scheme, which damps high frequencies, will
converge to the slow manifold eventually.

12.15. THREE PARTS TO MULTIPLE SCALE ALGORITHMS
249
When the initial conditions are on the slow manifold, the Crank-Nicholson scheme is
very good even with a coarse grid as illustrated in Fig. 12.10. The maximum error with
roughly six points per period is only 0.012.
12.15
Three Parts to Multiple Time Scale Algorithms: Iden-
tiﬁcation, Initialization, and Time-Marching on the Slow
Manifold
Computing slow solutions for a dynamical system that also allows fast motions requires
three key steps:
1. Identiﬁcation of the Slow Manifold
2. Initialization onto the Slow Manifold
3. Slow Manifold-Following Time-Stepping Algorithm.
Identiﬁcation of a slow manifold is both a problem in physics or engineering and a
problem in numerical analysis. The same system may or may not have a slow manifold,
depending on the situation and the goals of the modeller. The atmosphere, for example, has
a slow manifold for climate modelling and large-scale weather forecasting. Gravity waves,
convective plumes and small-scale vortices, which can be neglected in climate studies, are
essential to mesoscale meteorology (that is, small time-and-space scale studies). Therefore,
mesometeorology lacks a slow manifold. A forced diffusion problem has a slow manifold
— the steady state — if one is only interested in the long-time solution, but it has no slow
manifold if one wants to track the high frequency transients, too.
0
20
40
60
-1.5
-1
-0.5
0
0.5
1
1.5
Time
y
Figure 12.9: Imaginary part y(t) for the forced linear oscillator with ϵ = 1/10 and the initial
conditions x(0) = 0, y(0) = 0, which excite a mixture of fast and slow motion. Solid,
unlabelled curve: slow manifold. x’s: exact solution. Solid disks: the Crank-Nicholson
values.

250
CHAPTER 12. IMPLICIT SCHEMES & THE SLOW MANIFOLD
0
50
-10
-5
0
5
Time
1000* CN Errors
0
50
-0.5
0
0.5
Time
y
Figure 12.10: Left panel: Imaginary part y(t) for the forced linear oscillator with ϵ = 1/10
and the initial conditions x(0) = 0, y(0) = −1/(1 + ϵ), which excites only slow motion.
Solid, unlabelled curve: slow manifold (also the exact solution).
Solid disks: Crank-
Nicholson values. Right panel: errors in the Crank-Nicholson approximation, multiplied
by 1000.
Numerical errors can also make fast-evolving components of the discretized model very
uninteresting. Even if there is no physical slow manifold, there may be a numerics-induced
slow manifold where the slow components are those modes which can be accurately re-
solved by the Chebyshev discretization.
No kindergardener would be dumb enough to pursue a project without clear goals;
even at ﬁve, my son Ian is an enthusiastic planner. The availability of fast workstations
sometimes has a bad effect on inquiring minds of supposedly much superior maturity.
A common disease of adult numerical analysts is: Compute First, Think Later. But it is
very hard to get good results without ﬁrst asking: What do I really want from the model?
And what will the model allow me? It is from such metaphysical thinking that the slow
manifold can be identiﬁed.
Initialization onto the slow manifold is irrelevant in climate modelling and many other
problems where the dumb and mindless forces of dissipation are sufﬁcient to move the
problem onto the slow manifold soon enough for the modeller. For weather forecasting
and lots of other problems, however, damping works too slowly; one must ensure that the
initial data will lie on the slow manifold only by using some sort of initialization method.
The third step is to choose a numerical algorithm which is good at ignoring the fast
dynamics and accurately evolving the ﬂow along the slow manifold. The standard im-
plicit time-marching schemes usually meet this standard; explicit schemes don’t. How-
ever, implicit methods can sometimes fail because of problems of “consistency”, boundary-
splitting errors, and a few subtleties discussed in later chapters.
Slow manifold concepts have always been implicit in implicit time-marching schemes.
Curiously, however, these ideas have been glossed over in numerical analysis texts. In
meteorology, for example, gravity wave-ﬁltering approximations have been used since the

12.15. THREE PARTS TO MULTIPLE SCALE ALGORITHMS
251
late 1940s. However, the concept of the slow manifold was not formally deﬁned until
Leith(1980). And yet the notion of ﬁltering the gravity waves to leave only the slow ﬂow,
as embodied in Charney’s 1947 quasi-geostrophic equations of motion, is as goofy as a
Bugs Bunny cartoon unless the large-scale ﬂow in the atmospheric does lie on or very near
a subspace of purely slow motion in a phase space that allows both fast and slow dynamics.
In regard to time-marching algorithms, it is better to be explicit about the reason for
implicit. Otherwise, implicit algorithms become a kind of vague intuition, as unreliable as
a child’s belief that hiding under a blanket, because it keeps out the light, will also keep
out the thunder and lightning. Implicit algorithms are neither voodoo nor a lucky charm,
but an efﬁcient way to integrate along the slow manifold.

Chapter 13
“Fractional Steps” Time
Integration: Splitting and Its
Cousins
“Divide et impera” —-“Divide and conquer”
–Louis XI
“Bender’s Law: Different but reasonable schemes for the same problem require about the
same work.”
– Carl M. Bender
13.1
Introduction
Implicit time-marching algorithms are usually quite expensive per time step because of the
need to solve a boundary value problem at each time step. The exceptions are:
1. One (spatial) dimension.
2. Semi-implicit methods with a Fourier or spherical harmonics basis which require
solving only constant coefﬁcient boundary value problems; these are trivial in a
Galerkin formalism.
3. Problems which are periodic in all but one spatial dimension.
For spherical harmonic climate models, for example, it is only necessary to solve one-
dimensional boundary value problems (in height), one BVP for the vertical dependence
of each spherical harmonic coefﬁcient. But what is one to do for the vast number of prob-
lems which require solving multi-dimensional BVPs by means of Chebyshev polynomials
every timestep?
252

13.1. INTRODUCTION
253
Unsplit:
Simultaneous
Split:Sequential 
Diffusion
y-diffusion
x-diffusion
AAAAAAAA
AAAAAAAA
AAAAAAAA
AAAAAAAA
t=0
t=0
t=τ
t=τ
Figure 13.1: Splitting by dimension: a two-dimension process such as diffusion, which
causes a drop of food coloring to widen in all directions simultaneously (top), is treated as
two one-dimensional processes, happening one-after-the-other instead of simultaneously
(bottom).
One strategy is to use sophisticated matrix methods. For for constant coefﬁcient and
separable BVPs, there are special fast spectral algorithms. For non-separable BVPs, pre-
conditioned matrix iterations can be very effective.
The alternative is to attack and simplify before the spatial discretization is applied: The
“splitting” or “fractional step” family of algorithms.
Deﬁnition 30 (SPLITTING/FRACTIONAL STEPS) An implicit time-marching algorithm which
replaces simultaneous processes by sequential steps to increase efﬁciency is called a SPLITTING
or FRACTIONAL STEPS method. The split may be by dimensions: three-dimensional diffusion,
for example, may be split into three one-dimensional substeps of diffusion in the x-direction only fol-
lowed by diffusion in y and then z. The splitting may also be by physics: advection on one fractional
step, pressure adjustment (waves) on another, and diffusion/viscosity on a third.
The key idea of splitting, simultaneous-into-sequential, can be illustrated by the two-
dimensional diffusion equation, ut = uxx + uyy. If the matrices which are the spatial dis-
cretizations of the x and y derivatives are denoted by ⃗Λ1 and ⃗Λ2, then the exact solution

254
CHAPTER 13. SPLITTING & ITS COUSINS
is
⃗u(τ) = exp([⃗Λ1 + ⃗Λ2] τ) ⃗u(0)
(13.1)
Suppose, however, that we solve the pair of equations that results from assuming that the
solution diffuses in the x-direction ﬁrst and then in the y-direction (Fig. 13.1):
vt
=
vxx;
v(t = 0) = u(0)
wt
=
wyy;
w(t = 0) = v(τ)
(13.2)
The discretized solution is
w(τ) = exp(⃗Λ1 τ) exp(⃗Λ2 τ)
⃗
u(0)
(13.3)
In general, it is not automatic that these two solutions are the same because for matrices
(or linear operators), the usual exponential identity must be generalized to, for arbitrary
matrices ⃗A, ⃗B,
exp( ⃗A + ⃗B) = exp( ⃗A) exp( ⃗B) exp( −[ ⃗A, ⃗B]/2)
Weyl formula
(13.4)
where
[ ⃗A, ⃗B] ≡⃗A ⃗B −⃗B ⃗A
Commutator of ⃗A, ⃗B
(13.5)
However, if both ⃗A and ⃗B are proportional to the time step τ, then the commutator must
be O(τ 2). It follows that in the limit τ →0, the splitting system (13.2) provides at least a
ﬁrst-order-in-time approximation to the diffusion equation, regardless of how the time and
space derivatives are discretized. Furthermore, we can replace the matrices for diffusion
by any other pair of physical processes and the argument still applies.
The great advantage of splitting for the diffusion problem is that it requires only one-
dimensional boundary value problems. Even though we solve many such problems, one
BVP in x for each interior grid point in y, for example, this is still much cheaper than
solving a single two-dimensional BVP.
For the hydrodynamic equations, the advantage of splitting-by-process is that advec-
tion can be treated by a different algorithm than pressure adjustment, which in turn can be
different from diffusion. We need not even use the same spatial discretization; we can use
ﬁnite differences for diffusion and spectral methods for other parts (as in Lambiotte et al.,
1982, for example).
Because of these virtues, the splitting method, also known as the method of fractional
steps, was extensively developed in the Former Soviet Union as described in books by
Yanenko (1971) and Marchuk (1974). Strang (1968) independently invented this family of
algorithms, which are often called “Strang splitting” in the U. S. where these ideas caught
on more slowly. Although especially popular with spectral methods, splitting can be used
with ﬁnite difference or ﬁnite element spatial discretizations just as well, and indeed was
developed by Yanenko and Marchuk only for non-spectral methods.
Splitting sounds almost too wonderful to be true. Not quite, but there are snags. The
biggest is boundary conditions. Viscosity furnishes the highest derivatives for the Navier-
Stokes equations, so we cannot impose the usual rigid boundary conditions on the non-
viscous fractional steps. This can and does lead to growth of error at the boundaries. (This
problem does not arise in Fourier or spherical harmonics applications where there are no
boundaries.) However, at the price of sacriﬁcing the simplicity of straightforward splitting,
some good remedies have been developed. Splitting is still widely used.

13.2. FRACTIONAL STEPS FOR DIFFUSION
255
13.2
The Method of Fractional Steps for the Diffusion Equa-
tion
The great vice of the Crank-Nicholson method is that it is cheap only in one-dimension.
In two or three dimensions, even with a ﬁnite difference method, we must invert a large
matrix at each time step. With direct matrix-solving methods (LU factorization, also known
as Gaussian elimination), the cost per time step in two dimensions is O(N 4) and O(N 6)
operations for ﬁnite difference and spectral methods, respectively, where N is the number
of grid points in either x or y. Ouch! These costs can be greatly reduced by clever iterative
matrix-solvers as described later, but are still formidable.
The three-dimensional diffusion equation is
ut = uxx + uyy + uzz + g(x, y, z)
(13.6)
where g(x, y, z) is a known forcing function.
The method of fractional steps avoids inverting full matrices by advancing the solution
in one coordinate at a time. First, write
Λ = Λ1 + Λ2 + Λ3
(13.7)
where Λ1 = ∂xx, Λ2 = ∂yy, and Λ3 = ∂zz. Then the algorithm is
un+1/4 −un
τ
=
1
2Λ1
h
un+1/4 + uni
(13.8)
un+1/2 −un+1/4
τ
=
1
2Λ2
h
un+1/2 + un+1/4i
(13.9)
un+3/4 −un+1/2
τ
=
1
2Λ3
h
un+3/4 + un+1/2i
(13.10)
un+1 −un+3/4
τ
=
g
(13.11)
Each fractional step is the Crank-Nicholson method for a one-dimensional diffusion equa-
tion. Consequently, if Λ1 is generated by applying the usual three-point difference formula
to ∂xx, it is only necessary to invert tridiagonal matrices at each time step. As shown in Ap-
pendix B, a tridiagonal matrix may be inverted in O(N) operations. The operation count
for the fractional steps method is directly proportional to the total number of grid points
even in two or three dimensions; it lacks the O(N 2) penalty of the unsplit Crank-Nicholson
method (versus an explicit scheme).
The pseudospectral method, alas, generates non-sparse matrices — but it is far better to
invert 3N 2 matrices each of dimension N than a single matrix of dimension N 3 since the
expense of inverting a matrix scales as the cube of its dimension. Later, we shall discuss
cost-reducing iterations. An alternative direct method, faster but restricted to constant co-
efﬁcient differential operators, is to use Galerkin’s method. For this special case of constant
coefﬁcients, the Galerkin matrix is banded and cheap to invert as explained in the Chapter
15.
It is obvious that (13.8)–(13.11) is cheap; it is not so obvious that it is accurate. However,
eliminating the intermediate steps shows that the method of fractional steps is equivalent
to the scheme
un+1 = M(−τ)−1M(τ) un + τ M(−τ)−1g
(13.12)

256
CHAPTER 13. SPLITTING & ITS COUSINS
in whole time steps where the operator M is given by
M(τ) ≡1 + τ
2Λ + τ 2
4 {Λ1Λ2 + Λ1Λ3 + Λ2Λ3} + τ 3
8 Λ1Λ2Λ3
(13.13)
Eq. (13.12) is identical with the corresponding formula for the Crank-Nicholson scheme
except for the terms in τ 2 and τ 3 in the deﬁnition of M(τ). Because of cancellations, the
overall error in both the splitting method and Crank-Nicholson is O(τ 3) for u(x, y, z, t).
At ﬁrst glance, the entire premise of the method of fractional steps seems ridiculous.
Physically, diffusion is not a sequential process. However, if we consider only a small time
interval of length τ, then it is a good mathematical approximation to split the time interval
into three, and pretend that there is only diffusion in x on the ﬁrst fractional step, only
diffusion in y on the second, and only diffusion in z on the third. (Note that there are no
factors of (1/3) in (13.8)–(13.10): we allow each second derivative to diffuse over the whole
time interval even with the splitting-up.) Our ﬁction introduces extra error; the accuracy
for a given time step τ is poorer than that of the Crank-Nicholson method. However, it
is the same order-of-magnitude — O(τ 3). The cost-per-time-step of splitting is orders-of-
magnitude smaller than for the Crank-Nicholson scheme.
13.3
Pitfalls in Splitting, I: Boundary Conditions
Fractional step methods introduce some new difﬁculties peculiar to themselves. Variables
at fractional time levels are not solutions of the full set of original equations. What bound-
ary conditions should we impose on these intermediates?
For behavioral boundary conditions, this difﬁculty disappears because behavioral con-
ditions are never explicitly imposed. Instead, one merely expands all the unknowns, in-
cluding intermediates at fractional time levels, in Fourier series (for spatial periodicity) or
rational Chebyshev functions (on an inﬁnite interval).
Numerical boundary conditions require careful analysis, however. If the domain is rect-
angular and the boundary values are independent of time, then the treatment of boundary
conditions is straightforward. For simplicity, consider the two-dimensional heat equation.
With splitting, one must solve a two-point boundary value problem in x at each value
of y on the interior of the grid (Fig. 13.2). The values of u(0, y) and u(1, y) give us just
what we need, however. Similarly, the known values of u at the top and bottom of the
rectangle give the boundary conditions for the second splitting step: solving a set of two-
point boundary value problems in y, one for each value of x. The matrix representation
of the x-derivatives is a large matrix, but it decouples into independent subproblems as
illustrated in Fig. 13.3.
When the boundary conditions vary with time, we have troubles. The intermediates
in splitting — un+1/2, for example — do not correspond to the physical solution at t =
(n + 1/2)τ, but rather are merely intermediate stages in advancing the solution by a whole
time step.
When the domain is irregular, however, the proper boundary conditions require real
art. Spectral elements, which subdivide a complicated domain into many subdomains
only slightly deformed from rectangles, greatly alleviates this problem. Therefore, we re-
fer the curious reader to Yanenko (1971), who explains how to apply splitting with ﬁnite
differences to a problem with curvy boundaries.

13.3. PITFALLS IN SPLITTING, I: BOUNDARY CONDITIONS
257
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
Figure 13.2: In a split scheme, it is necessary to solve one-dimensional boundary value
problems on vertical and horizontal lines. One such (horizontal) line is marked by the four
circles which are the unknowns. Instead of a single 20x20 matrix, splitting requires (on this
6x7 grid) the solution of ﬁve 4x4 problems and four 5x5 problems.
Figure 13.3: Matrix of the second x-derivative: Dots denote nonzero matrix elements. There
is one block for each interior grid point in y. Each block is the matrix of a one-dimensional
boundary value problem in x.

258
CHAPTER 13. SPLITTING & ITS COUSINS
13.4
Pitfalls in Splitting, II: Consistency
The consistency problem is that stability does not necessarily guarantee accuracy. General
truth: absolutely stable methods gain their stability from being inaccurate for the rapidly-
varying components of the solution. For example, the Crank-Nicholson method achieves
stability by artiﬁcially slowing down the extremely fast decay of the high wavenumber
terms in the solution. This is acceptable if the only goal is the asymptotic, steady-state
solution, but we must always ask the engineering question: do we need to correctly model
the transient, too?
Even when only the steady state solution matters, we must still be careful because it is
possible that the inaccuracies of the absolutely stable method will poison the asymptotic
solution as well. Mathematicians describe this as a “lack of consistency”. Like stability,
consistency with the original differential equations may be either conditional — we get the
correct answer only if τ is sufﬁciently small — or absolute. The Crank-Nicholoson scheme
is “absolutely consistent” because it will correctly reproduce the asymptotic solution as
t →∞even if τ is very large.
The three-dimensional splitting method, alas, is only conditionally consistent with the
heat equation. To show this, write
u = T(x, y, z, t) + v(x, y, z)
(13.14)
where T(x, y, z, t) is the “transient” part of the solution and v(x, y, z) is the asymptotic
solution. It follows that
lim
t→0 T(x, y, z, t) ≡0
(13.15)
∇2v + g = 0
(13.16)
Similarly, the steady solution of the splitting equations will satisfy (from (13.12))
[M(−τ) −M(τ)] v = τ g
(13.17)
Recalling that
M(τ) ≡1 + τ
2Λ + τ 2
4 {Λ1Λ2 + Λ1Λ3 + Λ2Λ3} + τ 3
8 Λ1Λ2Λ3
(13.18)
we see that only the odd powers of τ survive the subtraction in (13.17) to give (after divid-
ing out a common factor of τ)
½
−Λ + τ 2
4 Λ1Λ2Λ3
¾
v = g
(13.19)
Oops! When τ is sufﬁciently small, we can neglect the second term in the {} in (13.19)
to obtain −Λv = g, which is just what we want. (Recall that Λ is the Laplacian operator.)
However, the “consistency” of the splitting-up scheme with the heat equation is not abso-
lute because for sufﬁciently large τ, the Λ1 Λ2 Λ3 term cannot be neglected, and we have in
fact calculated the steady-state solution to the wrong differential equation:
−∇2v + τ 2
4 vxxyyzz = g
(13.20)
The highest Fourier coefﬁcients will be contaminated by the extra term even if τ ∼O(h2).

13.5. OPERATOR THEORY OF TIME-STEPPING
259
To show this, denote the Fourier coefﬁcients of exp(ikx+imy +inz) for g and v by gkmn
and vkmn. Direct substitution into (13.20) implies
vkmn =
gkmn
k2 + m2 + n2 −(τ 2/4) (k2 m2 n2)
(13.21)
For waves near the aliasing limit, and assuming an equal grid spacing h in all directions,
kmax = mmax = nmax = π/h and
vkmn = h2
π2
gkmn
3 −(τ 2/h4)(π4/4)
k = kmax, m = mmax, n = nmax
(13.22)
which conﬁrms that the wavenumbers near the aliasing limit are seriously corrupted even
for τ = h2, a timestep sufﬁcient for the stability of explicit time-marching.
Fortunately, it is fairly straightforward to modify splitting to obtain a similar fractional
step method that is absolutely consistent (Yanenko, 1971). Note, however, that the offend-
ing term is the product of three operators; the splitting-up scheme is both absolutely stable
and absolutely consistent in two dimensions.
The spectral and pseudospectral schemes we will discuss later will always be consis-
tent. Nonetheless, it is a complication: every fractional step algorithm must be checked for
both stability and consistency.
13.5
Operator Theory of Time-Stepping
Now that we have seen splitting-up in a speciﬁc example, it is time to look at an abstract
formalism for general integration methods. For simplicity, consider the system of ordinary
differential equations in time given by
⃗ut = ⃗Λ ⃗u
(13.23)
where ⃗u is a column vector and ⃗Λ is a square matrix whose elements are independent of
time. As noted in the previous chapter, any method of discretizing a parabolic or hyper-
bolic PDE that is ﬁrst order in time will give a system like (13.23) so long as the equation is
linear and the coefﬁcients are independent of time.
The system (13.23) has the exact solution (assuming that ⃗Λ has a full set of eigenvectors)
⃗u ≡exp
³
⃗Λ t
´
⃗u0
(13.24)
where ⃗u0 is the column vector containing the initial conditions. We can interpret the matrix
exponential (and other functions-of-a-matrix) by expanding in a series of the eigenvectors
of ⃗Λ:
⃗Λ⃗ej = λj ⃗ej
(13.25)
(Note that we omit the minus sign included earlier in the chapter.)
⃗u =
N
X
j=1
uj ⃗ej
;
⃗u0 ≡
N
X
j=1
u0,j ⃗ej
(13.26)
Then
exp
³
⃗Λ t
´
⃗u0 =
N
X
j=1
exp (λjt) u0,j ⃗ej
(13.27)

260
CHAPTER 13. SPLITTING & ITS COUSINS
From this viewpoint, the problem of devising good time-stepping schemes is equivalent
to ﬁnding good ways of approximating the exponential of a matrix on the small interval
t ∈[0, τ]
(13.28)
The Euler method is the one-term Taylor series approximation:
exp
³
⃗Λτ
´
≈1 + τ⃗Λ + O
Ã
τ 2 ⃗Λ2
2
!
[Euler]
(13.29)
We could build higher approximations simply by taking more terms in the Taylor series.
However, if we can put upper and lower bounds on the eigenvalues of the matrix ⃗Λ, the
truncated Chebyshev series of the exponential is better. This has rarely been done when the
transient is interesting because one can usually obtain better time-stepping accuracy for the
same amount of work simply by applying (13.29) on a smaller interval. However, when the
prime goal is the asymptotic solution, the Chebyshev-of-the-exponential has been widely
used under the name of the Chebyshev iteration (Chap. 15).
The Crank-Nicholson (and higher order implicit methods) are examples of a third strat-
egy: so-called “Pad´e approximants”. These are rational functions which are chosen so that
their power series expansion matches that of the exponential function through however
many terms are needed to determine all the coefﬁcients in the Pad´e approximant. For ex-
ample, the [1, 1] approximant [linear polynomial divided by a linear polynomial] gives the
Crank-Nicholson scheme:
exp
³
⃗Λτ
´
≈
n
⃗I −(τ/2)⃗Λ
o−1 n
⃗I + (τ/2)⃗Λ
o
[Crank-Nicholson]
(13.30)
where ⃗I is the identity matrix. Taylor expanding gives
n
⃗I −(τ/2)⃗Λ
o−1 n
⃗I + (τ/2)⃗Λ
o
≈⃗I + τ⃗Λ + τ 2
2
⃗Λ2 + O(τ 3⃗Λ3)
(13.31)
which shows that the expansion in τ agrees with that of the exponential through the ﬁrst
three terms, thus demonstrating both that the Crank-Nicholson method is indeed the “[1,
1] Pad´e approximant” of the exponential and also that it is more accurate than Euler’s
scheme.
We can obviously generalize both the Euler and Crank-Nicholson methods by taking
more terms. For example, the “fourth order” Crank-Nicholson scheme is
exp
³
⃗Λτ
´
≈
½
⃗I −τ
2
⃗Λ + τ 2
12
⃗Λ2
¾−1 ½
⃗I + τ
2
⃗Λ + τ 2
12
⃗Λ2
¾
+ O(τ 5⃗Λ5)
(13.32)
(Calahan, 1967, and Blue and Gummel, 1970).
The obvious advantage of Pad´e approximants is that they remain bounded as τ →∞;
Eq. (13.32) generates a time-stepping algorithm which, like the Crank-Nicholson scheme,
is always stable as long as the eigenvalues of ⃗Λ are all negative. There is a second, less
obvious virtue: Pad´e approximants are almost always more accurate — sometimes very
much more so — than the Taylor series from which they are generated (Baker, 1975, Bender
and Orszag, 1978).
In more than one dimension, splitting enormously reduces costs since the denominator
in the rational approximations requires inverting a matrix which approximates a two- or
three-dimensional differential operator. Let us write
⃗Λ = ⃗Λ1 + ⃗Λ2
(13.33)

13.6. HIGH ORDER SPLITTING
261
where ⃗Λ1 and ⃗Λ2 are the matrix representations of one-dimensional operators that are eas-
ily inverted.
The Alternating-Direction Implicit scheme (ADI) is the fractional steps algorithm
⃗un+1/2 −⃗un
τ
=
1
2
h
⃗Λ1⃗un+1/2 + ⃗Λ2⃗uni
(13.34)
⃗un+1 −⃗un+1/2
τ
=
1
2
h
⃗Λ1⃗un+1/2 + ⃗Λ2⃗un+1i
(13.35)
The reason for the name “Alternating Direction” is that we treat one direction implicitly on
the ﬁrst half-step while treating the y-derivatives explicitly and then interchange the roles
of the two coordinates on the second half-step. If we introduce the auxiliary operators
⃗Bi(τ) ≡⃗I + τ
2
⃗Λi
i = 1, 2
(13.36)
where I is the identity matrix, then we can write the ADI scheme in whole steps as
⃗un+1 = ⃗B2(−τ)−1 ⃗B1(τ) ⃗B1(−τ)−1 ⃗B2(τ) ⃗un
(13.37)
Although this approximation to the exponential is the product of four factors, what
matters is that it still agrees with the Taylor expansion of the exponential. By using the
well-known series 1/(1+x) = 1−x+x2 + . . . , which is legitimate even when x is a matrix,
we ﬁnd that (13.37) is accurate to O(τ 2) just like the Crank-Nicholson scheme.
If the operators ⃗Λ1 and ⃗Λ2 commute, then we can swap ⃗B1(τ) and ⃗B2(τ) to obtain the
same scheme in a different form:
⃗un+1 = ⃗B2(−τ)−1 ⃗B2(τ) ⃗B1(−τ)−1 ⃗B1(τ) ⃗un
[Splitting]
(13.38)
This is the “splitting-up” form: ⃗un+1/2 = ⃗B1(−τ)−1 ⃗B1(τ) ⃗un and we have
⃗un+1/2 −⃗un
τ
=
1
2
⃗Λ1
³
⃗un+1/2 + ⃗un´
(13.39)
[Splitting]
⃗un+1 −⃗un+1/2
τ
=
1
2
⃗Λ2
³
⃗un+1 + ⃗un+1/2´
(13.40)
When the operators ⃗Λ1 and ⃗Λ2 do not commute, the splitting and ADI schemes are not
identical and splitting is only ﬁrst-order accurate in time.
13.6
Higher Order Splitting When the Split Operators Do
not Commute: Flip-Flop and Richard Extrapolation
There are two ways to recover second order accuracy when the operators do not commute.
The ﬁrst is to reverse the sequence of fractional steps on adjacent whole steps (“ﬂip-ﬂop”).
In other words, we solve the BVP in x ﬁrst and then that in y whenever n is even and then
solve the boundary value problem in y ﬁrst on every odd time step. The method is then
second order even with noncommuting Λ1 and Λ2, but with an effective time step of 2 τ
(rather than τ).
The other alternative is Richardson extrapolation (not be confused with Richardson’s
iteration of Chapter 15). This is a very general strategy for improving the accuracy of low
order methods. The basic idea is that if the error in a given algorithm is O(hr) for some

262
CHAPTER 13. SPLITTING & ITS COUSINS
r and sufﬁciently small h, then two computations with different h can be combined with
appropriate weights so that the leading error terms cancel to give an answer of higher
order.
Let ulow(2 τ) and uhigh(2 τ) denote the results of integrating from t = 0 to t = 2 τ with
a single time step of △t = 2 τ and with two steps of length △t = τ, respectively. For a ﬁrst
order method, the errors are
ulow(2τ)
=
uexact + 4 p τ 2 + O(τ 3)
(13.41)
uhigh(2 τ)
=
uexact + 2 p τ 2 + O(τ 3)
(13.42)
The numerical value of p is unknown, but the existence of an error which is quadratic in τ
is simply a deﬁnition of what it means for a scheme to “ﬁrst order in time”.1 It follows that
uRichardson(2 τ) ≡2 uhigh(2 τ) −ulow(2 τ) = uexact + O(τ 3)
(13.43)
uRichardson is second order because the weighted sum cancels the leading error terms in the
ﬁrst order approximations, uhigh and ulow. This extrapolation can be performed on every
sub-interval of length 2 τ to reﬁne the solution to second order accuracy as we march in
time.
Consequently, when the operators of different sub-problems do not commute, we can
always retrieve second order accuracy at the expense of additional programming. Often,
Richardson extrapolation is omitted because hydrodynamic calculations are usually lim-
ited in accuracy by spatial rather than temporal resolution. At the other extreme, Strain
(1995) has used repeated Richardson extrapolation of the modiﬁed Backwards Euler method
to create an implicit time-marching code in which the order is easily and adaptively varied.
13.7
Splitting and Fluid Mechanics
Our example is the shallow water wave equations:
Du
Dt −f v + φx
=
µ △u
(13.44)
Dv
Dt + f u + φy
=
µ △v
(13.45)
ϵDφ
Dt + ux + vy
=
0
(13.46)
where f is the Coriolis parameter and D/Dt denotes the total derivative:
D
Dt ≡∂
∂t + u ∂
∂x + v ∂
∂y
(13.47)
ϵ is a nondimensional combination of depth, planetary radius, rotation rate and the gravi-
tational constant, “Lamb’s parameter”.
The physical splitting is (Fig. 13.4)
Dun+1/3
dt
= 0
(13.48a)
Dvn+1/3
dt
= 0
[Advective Step]
(13.48b)
Dφn+1/3
dt
= 0
(13.48c)
1Over many time steps, the errors accumulate so that the total error on a ﬁxed interval in t is a linear function
of τ even though the error on a single step is quadratic in τ.

13.7. SPLITTING AND FLUID MECHANICS
263
Advection
un
un+1/3
Waves & Pressure 
Adjustment
un+2/3
Viscosity/Diffusion
un+1
Figure 13.4: Splitting by process: Advection, adjustment of ﬁelds (linear wave dynamics
and pressure), and viscosity and diffusion are split into three separate, one-after-the-other
processes.
un+2/3
t
−f vn+2/3 = −φn+2/3
x
(13.49a)
vn+2/3
t
+ f un+2/3 = −φn+2/3
y
[Pressure Step alias
(13.49b)
ϵ φn+2/3
t
+ un+2/3
x
+ vn+2/3
y
= 0
“Adjustment of Fields”]
(13.49c)
un+1
t
= µ △un+1
(13.50a)
vn+1
t
= µ △vn+1
[Diffusion Step]
(13.50b)
φn+1 = φn+2/3
(13.50c)
In each case, the solution at the previous fractional step provides the initial condition for
the equations that model the next physical process.
If we wish, we can apply an additional splitting to decompose the diffusion step into
a sequence of one-dimensional diffusion problems. However, it is usually a bad idea to

264
CHAPTER 13. SPLITTING & ITS COUSINS
attempt dimensional splitting for the “adjustment of ﬁelds” step because the Coriolis force
and wave dynamics strongly couple the coordinates. Splitting advection into separate x,
y and z advection is unnecessary because this subproblem is normally integrated by an
explicit method.
As noted earlier, the great advantage of splitting is that we can solve each fractional
step using a different numerical method. The advective step is almost always advanced
explicitly and the adjustment of ﬁelds is integrated implicitly. In engineering problems,
diffusion is usually marched in time by an implicit algorithm, but Marchuk (1974) barely
discusses diffusion because µ in his numerical weather prediction model is so small that
he can use an explicit method.
It is not even necessary to be consistent by using spectral or pseudospectral algorithms
for all sub-problems. Lambiotte et al. (1982) compute only the advection and pressure steps
pseudospectrally. Since µ is small for their high Reynolds ﬂow, they employ ﬁnite differences
to integrate the diffusive step.

Chapter 14
Semi-Lagrangian Advection &
Other Integrating Factor Methods
“Go with the ﬂow”
– New Age proverb
“... there is a mistaken belief that semi-Lagrangian schemes are only good for smooth
ﬂows.”
– Staniforth & Cˆot´e(1991), pg. 2211
14.1
Introduction: Concept of an Integrating Factor
An “integrating factor” is a transformation of the unknowns in a differential equation. The
most familiar example yields the solution of the general linear ﬁrst order ODE, which is
ux −q(x) u = f(x)
(14.1)
Let u(x) be replaced by the new unknown v(x) where
u(x) ≡I(x) v(x)
(14.2)
where the integrating factor is
I(x) ≡exp
µZ x
q(y) dy
¶
(14.3)
Substitution gives the transformed problem
I vx + q(x) I v −q(x) I v = f(x)
(14.4)
using Ix = q(x)I. Dividing by I(x) gives
vx = exp
µ
−
Z x
q(y) dy
¶
f(x)
(14.5)
265

266
CHAPTER 14. SEMI-LAGRANGIAN ADVECTION
Thus, the integrating factor has reduced the differential equation to a quadrature, i. e., v(x)
is the indeﬁnite integral of the right-hand side of (14.5):
v = A +
Z x
0
exp
µ
−
Z z
q(y) dy
¶
f(z) dz
(14.6)
where A = u(0).
Integrating factors come in all sorts of ﬂavors, like ice cream, but we shall concentrate
on two particular classes. The ﬁrst is when a time-dependent PDE can be written in the
form
ut = L u + M(u)
(14.7)
where L is a linear differential operator with spatial derivatives only and where M(u) is
an operator, possibly nonlinear, that contains everything else in the equation including the
forcing terms. The new unknown deﬁned by
u ≡exp(Lt) v
(14.8)
solves the simpliﬁed equation
vt = exp(−Lt) M(v)
(14.9)
Just as for the ﬁrst order ODE, the integrating factor has purged the transformed equation
of the differential operator L except through the exponential. This is sometimes a good
idea — and sometimes not.
The second class of integrating factors is to remove translation/advection by a change-
of-coordinates to a moving coordinate system. Formally, this change-of-coordinate can
be expressed in terms of operators, too. However, it is more convenient to perform the
change-of-coordinate directly.
The simplest case is to shift into a frame of reference which is moving at a constant
speed with respect to the original frame. For example,
ut + cux = f(x, t),
u(0, t) = g(t),
u(x, 0) = Q(x)
(14.10)
can be transformed by the shift
ξ ≡x −c t
↔
x = ξ + c t
&
u(x, t) ≡v(ξ, t)
(14.11)
into
vt = f(ξ + ct, t),
v(−ct, t) = g(t),
v(ξ, 0) = Q(ξ)
(14.12)
For the special case f = 0, this is clearly an improvement on the original solution because
then vt = 0 which implies that v is a function of ξ only, that is, u depends on (x, t) only as
the combination x −ct.
Semi-Lagrangian time-marching schemes remove nonlinear advection through a sim-
ilar but more complicated transformation. Such algorithms have so many good proper-
ties that they have become standard on two important geophysical models: the NCAR
Community Climate Model (CCM) and the operational forecasting code of the European
Centre for Medium Range Forecasting, which provides ﬁve-day global predications to an
18-nation consortium.
However, integrating factor schemes can also be a trap. The crucial distinction is that
integrating factors are useful only when the integrating factor removes an important part
of the dynamics. We will explain this through a couple of bad examples in the next section.
(This section can be skipped without loss of continuity.)
In the remainder of the chapter, we describe semi-Lagrangian schemes. We begin with
second order schemes, which are the easiest to describe, and then explain a number of
elaborations.

14.2. MISUSE OF INTEGRATING FACTOR METHODS
267
14.2
Misuse of Integrating Factor Methods
Our ﬁrst counterexample is the ODE which was used earlier to explain the concept of
the slow manifold:
ut + λu = f(ϵ t)
(14.13)
Assume λ/ϵ >> 1, i. e., that the ratio of the “fast” time scale to the slow time scale is
large, and also that the real part of λ is positive so that the homogeneous solution decays
exponentially with time. We shall further assume that the goal is to compute the slow
manifold of this equation, that is, the part which varies only on the same slow O(1/ϵ) time
scale as the forcing f.
Unfortunately, the time step for an explicit scheme is restricted by the fast time scale of
the homogeneous solution exp(−λt). Implicit methods and Nonlinear Galerkin methods
both remove this restriction, but have their own disadvantages. Is an integrating factor a
viable alternative?
Deﬁne a new unknown by
u = exp(−λ t)v(t)
(14.14)
The ODE becomes
vt = exp(λ t)f(ϵ t)
(14.15)
Hurrah! The term λu has been removed and with it the usual CFL time-step limitation. To
show this, let us analyze the Forward Euler method as applied to (14.15).
This scheme with time step τ and with superscript n denoting the time level is
vn+1 −vn
τ
= exp(λ n τ)f(ϵ n τ)
↔
vn+1 = vn + τ exp(λ n τ)f(ϵ n τ)
(14.16)
From an arbitrary starting value v0 and for the special case f(ϵt) = F, a constant,
vn
=
v0 + τ F {1 + exp(λ τ) + exp(2 λ τ) + . . . + exp([n −1] λ τ)}
=
v0 + τ F 1 −exp(n λ τ)
1 −exp(λ τ)
(14.17)
Because of the integrating factor transformation, vn is stable for arbitrarily large time steps
τ. To be sure, the solution is blowing up exponentially, but since the transformed forcing
is growing exponentially, a similar growth in v is okay.
The same solution in terms of the original unknown u is, using v0 ≡u0,
un = exp(−n λτ)u0 + τ F exp(−n λ τ) −1
1 −exp(λ τ)
(14.18)
In the limit that τ
→
0 and n →
∞such that t = n τ grows large, the Forward Eu-
ler/integrating factor solution simpliﬁes to
un
≈
τ F
−1
1 −(1 + λ τ + O(λ2 τ 2))
≈
F
λ {1 + O(λτ)}
(14.19)

268
CHAPTER 14. SEMI-LAGRANGIAN ADVECTION
where F/λ is the slow manifold for this problem. Thus, for sufﬁciently small time step, the
scheme does successfully recover the slow part of the solution as t →∞.
However, the whole point of the integrating factor is to use a long time step without the
bother of implicit or Nonlinear Galerkin methods. Since the stability limit of the Forward
Euler scheme without integrating factor is τmax = 1/λ, it is interesting to see how well the
integrating factor variant does for this τ. Unfortunately, substituting τ = τmax into (14.18)
gives
un ∼F
λ
1
−1 + exp(1) = 0.58F
λ ,
t →∞, τ = 1/λ
(14.20)
The good news is that the large time solution is proportional to the true slow manifold,
F/λ; the bad news is that the amplitude of the computational solution is barely half that of
the true solution even when τ is no larger than the largest time step that would be stable
in the absence of the integrating factor. When τ >> 1/λ, which is of course what we really
want if the integrating factor scheme is to compete with implicit schemes,
un ∼F
λ λ τ exp(−λ τ),
t →∞, λτ >> 1
(14.21)
which is exponentially small compared to the correct answer.
Thus, the integrating factor method is a dismal failure. If the time step τ = r τmax
where τmax = 1/λ is the stability limit for the Forward Euler method (without integrating
factor), then the Forward Euler/integrating factor algorithm gives a slow manifold which
is too small by a factor of r exp(−r). In contrast, implicit methods like Crank-Nicholson
and Backwards-Euler and also Nonlinear Galerkin schemes are accurate for the slow part
of the solution even for large r.
A second bad example is the Fourier pseudospectral solution to the KdV equation
ut + uux + uxxx = 0
(14.22)
when the goal is to model the formation and dynamics of solitary waves. For a soliton of
phase speed c, the coefﬁcient of exp(ikx) varies with time as exp(−ikct) which grows only
linearly with k. However, the equation also admits small amplitude waves whose phase
speeds grows as k3, so the stability limit for an explicit time-marching scheme is inversely
proportional to k3
max. The KdV equation is very “stiff” in the sense that one must use a
very short time step for stability reasons compared to the slow time scale of the dynamics
(i. e., the solitons) that one is actually interested in.
The remedy — well, sort of a remedy — is to use the integrating factor exp(−∂xxx t) to
remove the third derivative from the transformed equation:
vt + v exp(−∂xxxt) vx = 0
(14.23)
The stability limit of the modiﬁed equation is then controlled by nonlinear term, which
involves only a ﬁrst derivative and demands a time step inversely proportional to kmax
itself rather than to its cube.
The exponential-of-derivatives operator looks forbidding, but it can be interpreted in
the usual way as the exponential of the matrix that discretizes the third spatial derivative,
which in turn can be interpreted as multiplication of the k-th eigenvector of the derivative
matrix by the exponential of (−t) times the k-th eigenvalue. In a Fourier basis, this is
trivial because the basis functions, exp(ikx), are the eigenvalues of the derivative operator.
It follows that for any function v(x, t) with Fourier coefﬁcients vk(t),
exp(−∂xxxt) v(x, t) =
∞
X
k=−∞
exp(i k3t) vk exp(ikx)
(14.24)

14.3. SEMI-LAGRANGIAN ADVECTION: INTRODUCTION
269
To put it another way, the integrating factor method for the KdV equation is equivalent to
transforming the unknowns of the ODE system which comes from the usual Galerkin or
pseudospectral discretization. In place of the Fourier coefﬁcients ak(t) of u(x, t), use the
modiﬁed Fourier coefﬁcients (of v(x, t)) given by
vk(t) ≡exp(−ik3t) ak(t)
(14.25)
Unfortunately, this is really a terrible idea when the prime target is solitary waves. The
simplest counterexample is the special case that the exact solution is a solitary wave of
phase speed c. The exact Fourier coefﬁcients — before the integrating factor — are
ak = constant exp(−ikct)
(14.26)
and thus vary rather slowly in the sense that the frequency of the highest wavenumber
in the truncation grows only linearly with kmax. In contrast, the time dependence of the
transformed coefﬁcients is
vk(t) = constant exp(−ik3t −ikct)
(14.27)
which varies rapidly in the sense that the highest frequency after transformation grows as
k3
max. To accurately compute vkmax(t), a time step proportional to k3
max is necessary —
in other words, a time step as short as the explicit stability limit for the original, untrans-
formed KdV equation.
In discussing implicit methods, we have stressed repeatedly that their usefulness is
SITUATION-DEPENDENT. Implicit methods are good for computing KdV solitons because
they misrepresent only the high frequency transient while accurately computing the slow-
moving solitary waves. Integrating factor methods, in contrast, are bad for solitons because
the integrating factor extracts a high frequency motion that is not actually present in the
low frequency motion (i. e., the soliton) that we are computing. Thus, the usefulness
of integrating factor methods is also situation-dependent, but often inversely to implicit
methods.
Suppose our goal is to compute KdV solutions which are not solitons but rather a soup
of weakly interacting waves such that the Fourier components are approximately
ak = Ak(ϵt) exp(ik3t)
(14.28)
where the Ak are amplitudes that vary slowly under weak wave-wave interactions. Now
because the integrating factor method successfully removes the high frequency oscillations,
the transformed coefﬁcients are
vk(t) = Ak(ϵt)
(14.29)
These vary slowly with time, allowing a long time step. In contrast, implicit and Nonlinear
Galerkin methods as well as standard explicit schemes all require a very short time step
to be accurate for the high frequency motion. Weakly coupled wave systems (“resonant
triads” and their generalization) have been widely analyzed by theorists (Craik, 1985).
Thus, it is quite wrong to conclude that integrating factor methods are counter-productive
in numerical applications. Sometimes they are very valuable. The difference between the
two KdV cases is that in the ﬁrst (soliton) case, the integrating factor extracts a high fre-
quency dependence that was not actually present in the slow solutions (bad!) whereas in
the second (weakly interacting sine waves) case, the integrating factor extracts high fre-
quency motion that is an essential part of the desired solution (good!).

t5
t4
t3
t2
t1
t0
x
t5
t4
t3
t2
t1
t0
x
270
CHAPTER 14. SEMI-LAGRANGIAN ADVECTION
14.3
Semi-Lagrangian Advective Schemes: Introduction
A “semi-Lagrangian” (SL) time-marching algorithm is an integrating-factor method in
which the integrating factor is an advection operator that shifts into a coordinate system
that travels with the ﬂuid. In so doing, it borrows ideas from both the method of char-
acteristics and the Lagrangian coordinate formulation of ﬂuid mechanics. The “total” or
“particle-following” derivative of any quantity “q”, for simplicity given in two space di-
mensions, is
Dq
Dt ≡∂q
∂t + u ∂q
∂x + v ∂q
∂y
(14.30)
In the moving coordinate system, the total derivative becomes the ordinary partial time
derivative, and the advective terms disappear, buried in the change-of-coordinate.
The idea of tracing ﬂow by following the motion of individual blobs or particles of
ﬂuid is at least two centuries old. Particle-following coordinates are called “Lagrangian”
coordinates in ﬂuid mechanics. However, exclusive use of a Lagrangian coordinate system
is usually a disaster-wrapped-in-a-catastrophe for numerical schemes because the parti-
cle trajectories become chaotic and wildly mixed in a short period of time where “chaos”
is meant literally in the sense of dynamical systems theory even for many laminar, non-
turbulent ﬂows.1 Semi-Lagrangian (SL) algorithms avoid this problem (and earn the mod-
iﬁer “semi”) by reinitializing the Lagrangian coordinate system after each time step. The
usual choice is that the tracked particles are those which arrive at the points of a regular
Fourier or Chebyshev spatial grid at time tn+1. Since the departure points for these trajec-
tories at t = tn are generally not on the regular grid, we follow a different set of N particles
on each time interval of length τ where τ is the time step. In contrast, in a pure Lagrangian
coordinate system, one follows the evolution of the same N particles forever.
There are two advantages to an SL method:
1Trajectories of ﬂuid blobs are often chaotic even when the advecting velocity ﬁeld is laminar.
Figure 14.1: Left panel: Fluid mechanics in Lagrangian coordinates tracks the same set
of particles throughout all time. Right panel: Semi-Lagrangian methods. A new set of
particles to track is chosen at the beginning of each time step.

14.4. ADVECTION & METHOD OF CHARACTERISTICS
271
1. If the scheme is “multiply upstream”, a term deﬁned later, SL will be both stable
and accurate for time steps far greater than usual explicit limit. To be precise, the
advective time step limit disappears, and the maximum time step is then controlled
entirely by non-advective processes like viscosity and wave propagation.
2. SL methods are very good at resolving fronts and shock waves even in the absence
of artiﬁcial viscosity.
Because of these virtues, SL time-marching is now employed in the NCAR Community
Climate Model and the European Centre for Medium-Range Forecasting weather predic-
tion model. Neither is a toy model, as too often used to test algorithms; instead, both are
global, three-dimensional spherical harmonic models with lots of physics.
Simple semi-Lagrangian algorithms have at least ﬁve disadvantages:
1. Difﬁcult to parallelize (for “multiply upstream” schemes).
2. Not strictly conservative of mass, energy, etc.
3. Inherent computational dissipation (McCalpin, 1988)
4. Instability and inaccuracy for ﬂows over mountains.
5. More expensive per time step than most competing schemes because of the need for
• “off-grid” interpolation and
• ﬁxed point iteration.
None of these drawbacks, however, has proved fatal. In particular, conservative, shape-
preserving and low dissipation schemes have been recently developed, and the mountain
ﬂow or “orographic” problems have been solved, too.
Semi-Lagrangian method are designed to be especially good at advection. However,
the algorithms can be applied to the full Navier-Stokes equations without difﬁculty and
can be combined with other ideas. For example, in meteorology it is common to combine
semi-Lagrangian treatment of advection with a semi-implicit treatment of the viscous and
Coriolis force terms (“SL/SI” schemes).
Semi-Lagrangian time-stepping can be combined with any strategy for discretization of
the spatial coordinates.
14.4
A Brief Digression on the One-Dimensional and Two-
Dimensional Advection Equations and the Method of
Characteristics
The Navier-Stokes equations reduce to the so-called “advection equations” if we neglect
all processes except advection. Restricting ourselves to two-dimensions for simplicity, the
pure advection equations are
Du
Dt = 0
&
Dv
Dt = 0
(14.31)
or written in full, where (u, v) are the x and y velocities,
∂u
∂t + u ∂u
∂x + v ∂u
∂y
=
0
∂v
∂t + u ∂v
∂x + v ∂v
∂y
=
0
(14.32)

272
CHAPTER 14. SEMI-LAGRANGIAN ADVECTION
Figure 14.2: Contour plot in the space-time plane of the solution u(x, t) to the one-
dimensional advection equation, ut + uux = 0. The initial condition is sinusoidal; negative
contours are dashed. Where contours intersect, the solution becomes multi-valued and
ux →∞. The ﬂow is said to have “formed a front” or experienced “wave breaking”.
The reason that this drastically simpliﬁed system is interesting is that it can be solved ex-
actly by the “method of characteristics”. Semi-Lagrangian time-marching schemes, even
with all the complications of pressure and viscosity, etc., merely mimic the method of char-
acteristics.
The key observation is that the advection equations state that the velocities are con-
served following the motion. In other words, if we track the fate of a particular blob of
ﬂuid, perhaps marked with a dab of red dye, the velocity of that blob will remain constant
forever. Consequently, the trajectory of that blob and of all blobs is a straight line whose
slope in each spatial dimension is proportional to its velocity with respect to that coordi-
nate. (Fig. 14.2 is a one-dimensional illustration.) If the blob originates at x = ξ and y = η
at t = 0, then its trajectory is
x = ξ + Q(ξ, η) t,
&
y = η + S(ξ, η) t
(14.33)
where the initial conditions are
u(x, y, t = 0) = Q(x, y),
&
v(x, y, t = 0) = S(x, y)
(14.34)
The exact solution for the velocities is
u(x, y, t) = Q(ξ[x, y, t], η[x, y, t]),
&
v(x, y, t) = S(ξ[x, y, t], η[x, y, t])
(14.35)
In other words, the initial conditions furnish the exact solution for all time if the arguments
of the functions (Q, S) are replaced by the “characteristic coordinates” or simply “charac-
teristics”, (ξ, η).

14.5. THREE-LEVEL, 2D ORDER SEMI-IMPLICIT
273
Unfortunately, Eq.(14.33) gives explicit solutions only for (x, y) as a functions of the
characteristics. To evaluate the solutions at a particular point (x, y, t), we need it the other
way around. Thus, it is necessary to solve (14.33) to determine the departure point of a
given blob where the “departure point“ or “foot of the trajectory” is the location (ξ, η) of
the blob at t = 0. However, the equations that must be solved for the characteristics are
algebraic equations, which are much simpler than differential equations.
Semi-Lagrangian time-marching schemes also require computing the departure point
of a blob by solving a system of algebraic equations. However, this is fairly easy because
the blob moves only a short distance during a time interval of length τ where τ is the time
step. The change of coordinates (14.33) does not trivialize the dynamics of the full Navier-
Stokes equations, as it does for the pure advection equations, but it does remove advection
just as thoroughly.
14.5
The Simplest SL Scheme: Three-Level, Second Order
Semi-Implicit Method
A semi-Lagrangian scheme by itself is not very useful in meteorology because it only re-
moves the advective time step limit, which is much less severe than the restriction imposed
by the propagation of gravity waves. When combined with a semi-implicit treatment of the
non-advective terms, however, SL becomes very powerful as ﬁrst demonstrated by Robert
(1981, 1982).
Let the problem be
Du
Dt + G(u, t) = F(u, t)
(14.36)
where D/Dt denotes the total, particle-following derivative including the advective terms,
G is the sum of all terms which are to be treated implicitly while F represents all the terms
which can be treated explicitly. The basic three-level, second order SL/SI algorithm is
u+ −u−
2 τ
+ 1
2 (G+ + G−) = F 0
(14.37)
where the plus and minus signs denote the quantities evaluated at t = tn±1 and super-
script 0 denotes a quantity evaluated at t = tn. In form, this looks like a standard Crank-
Nicholson/explicit method except that (i) the advective terms are missing (ii) the CN-like
step is over a time interval of 2τ instead of τ where τ is the time step.
The magic is in the coordinate transform. For simplicity, assume one space dimension.
Let α(x) denote the displacement, over the time interval t ∈[tn, tn+1] of a particle that
arrives at point x at t = tn+1. Then for any vector appearing in (14.37),
u+
≡
u(x, tn + τ)
u0
≡
u(x −α, tn)
u−
≡
u(x −2 α, tn −τ)
(14.38)
When the spatial dependence is discretized, u, x, and α(x) all turn into vectors. The dis-
placement is deﬁned to be the solution of the algebraic equation
αj = τ u(xj −αj, tn)
(14.39)
where j is the integer index of the grid points.

u0
u-
α
2 α
tn+1
tn
tn-1
u+
x
274
CHAPTER 14. SEMI-LAGRANGIAN ADVECTION
The novelty of Eq.(14.39) is that when we move back one time level, we must simulta-
neously shift our spatial position by the displacement αj. The predicted value u(xj, tn+1)
is combined not with u at the same spatial location at the two previous time levels, but
rather with u for that same ﬂuid particle at earlier time levels as shown schematically in
Fig. 14.3. Advection is invisible in (14.37) because it is implicit in the coordinate transform,
that is, in the spatial shifts represented by α in (14.39).
This advection-hiding has two major advantages. First, since there is no advection in
the time extrapolation formula (14.37), there is no advective stability limit either. (The ex-
plicitly treated term F(u, t) may impose its own maximum time step, but in meteorological
applications, this is huge compared to the advective limit.) Second, the SL scheme is much
better at resolving steep fronts and shock waves than conventional schemes. The reason is
that the frontogenetic process, advection, is computed exactly by the method of character-
istics. In contrast, the treatment of an advective term like u ux in a conventional, non-SL
method depends on how accurately ux is approximated by spatial ﬁnite differences or a
pseudospectral formula — poorly in the neighborhood of a front.
SL schemes, alas, require two additional steps which are unnecessary in other algo-
rithms. First, one must evaluate u and other variables at x = xj −αj, which generally is
not on the canonical spectral grid. This problem of “off-grid” interpolation is sufﬁciently
important to warrant an entire section below. However, efﬁcient spectral off-grid interpo-
lation methods are now available.
Second, one must solve the algebraic equation (14.39) at each grid point to compute
the corresponding displacement. The good news is that because a ﬂuid blob only moves
a short distance over the short time interval of a single time step, a simple ﬁxed point
iteration is usually sufﬁcient. That is, denoting the iteration level by superscript m:
αm+1
j
= τ u(xj −αm
j , tn)
(14.40)
Figure 14.3: Schematic of a particle trajectory (solid curve) which arrives at one of the
points of the regular, evenly spaced computational grid at t = tn+1. The semi-Lagrangian
scheme approximates this trajectory by the dashed line, using the velocity at the midpoint
of the trajectory to estimate the displacement α during one time step. The SL algorithm
connects the values of u at three points along a trajectory (circles) rather than at a ﬁxed
value of x, as in a conventional scheme.

14.6. MULTIPLY-UPSTREAM SL
275
At the beginning of the time integration, one can take α0
j = 0; at later time steps, one can
initialize the iteration with αj(tn−1), that is, the displacement at the previous time level.
Experience and theory both suggest that one never needs to take more than two ﬁxed point
iterations except possibly at the start of the time integration where one might need three.
Each iteration increases the accuracy of the displacement by one more power of τ. The
iteration is guaranteed to converge so long as
τ | ux | < 1
(14.41)
This condition seems to be almost always met in practice though one might worry a bit
in the neighborhood of fronts where the slope ux is very large (Pudykiewicz, Benoit and
Staniforth, 1985).
The three-level SL/SI scheme generalizes easily to higher dimensions. In two dimen-
sions, let α(x, y) and β(x, y) denote the displacements in the x and y directions, respec-
tively. The three-level SL/SI method is
u+
ij
≡
u(xi, yj, tn + τ)
u0
ij
≡
u(xi −αij, yj −βij, tn)
u−
ij
≡
u(xi −2 αij, yj −2βij, tn −τ)
(14.42)
and similarly for the y-momentum equation. The displacements are the solutions to
αij = τ u(xij −αij, yij −βij, yij, tn)
&
βij = τ v(xij −αij, yij −βij, yij, tn)
(14.43)
where v is the y velocity.
14.6
Multiply-Upstream: Stability with a Very Long Timestep
We begin with three useful deﬁnitions.
Deﬁnition 31 (FOOT of a TRAJECTORY/DEPARTURE POINT)
The spatial location of the beginning of the trajectory of a ﬂuid particle at some time t, usually tn−1
for a three-level SL scheme or tn for a two-level method, is called the “FOOT of the TRAJECTORY”
or equivalently the “DEPARTURE POINT” of the trajectory. The goal of the ﬁxed point iteration
of the SL method is to compute the displacement and through it the “foot”.
Deﬁnition 32 (MULTIPLY-UPSTREAM)
A semi-Lagrangian method is “MULTIPLY-UPSTREAM” if the set of grid points used to interpo-
late the velocities in the computation of the “foot” of a trajectory is allowed to vary, relative to the
arrival point of the trajectory, so as to center on the foot.
Deﬁnition 33 (COURANT NUMBER)
The Courant number is a nondimensional parameter which is the ratio of the time step to the
smallest distance between two points on the spatial grid, multiplied by the maximum velocity:
Co ≡Umax
τ
min(h)
(14.44)
where Umax is the maximum ﬂuid velocity. Strictly speaking, this is an advective Courant number;
one can measure the maximum time step for wave propagation problems by deﬁning a “wave”
Courant number with the maximum advecting velocity replaced by the maximum phase speed c.
In either case, explicit methods are stable only when the Courant number is O(1) or less. In the
rest of this chapter, we shall use only the advective Courant number.

x
t
x
t
SINGLE GRID
MULTIPLY UPSTREAM
276
CHAPTER 14. SEMI-LAGRANGIAN ADVECTION
Figure 14.4: Schematic comparing the off-grid interpolation schemes of multiply upstream
and single grid semi-Lagrangian methods for a large Courant number, i. e., when the
particle travels through several grid points during the time interval t ∈[tn, tn+1]. The
circles show the points whose grid point values at time level tn−1 are used to interpolate
velocities and other quantities at the foot of the trajectory. The trajectory is the heavy curve.
Fig. 14.4 illustrates this deﬁnition. One major reason for the slow acceptance of semi-
Lagrangian schemes, which were used as early as Wiin-Nielsen (1959), Krishnamurti(1962)
and Sawyer (1963), is that the early algorithms interpolated the departure points of the
trajectory through xj by using (uj−1, uj, uj+1). That is to say, the “single grid” SL methods
used the same set of points centered on the arrival point xj irregardless of whether the foot
of the trajectory was near or far, left or right, of the arrival point.
The price for this inﬂexibility is that when the Courant number is greater than one,
single grid schemes use extrapolation rather than interpolation to estimate velocities, etc., at
the foot of the trajectory — and are unstable. Consequently, the old-style semi-Lagrangian
algorithms had time step restrictions which are just as strict as for conventional explicit
methods.
In contrast, multiply-upstream schemes are stable and accurate even for very large
Courant numbers. Indeed, as we shall see show in the next section, something very wierd
and wonderful happens: multiply-upstream methods become more accurate as the time
step increases!
Spectral and pseudospectral schemes are always multiply-upstream.2 Thus, spectral SL
algorithms can be used at high Courant number.
2This assertion is true if the interpolation to compute the foot is done spectrally; some weather forecasting
models inconsistently use low order polynomial interpolation to compute the foot, even though the rest of the
computation is spectral; such mixed schemes are not automatically multiply-stream.

2.2
2.6
3
0.75
0.8
0.85
0.9
0.95
1
x
-2
0
2
-1
-0.8
-0.6
-0.4
-0.2
0
0.2
0.4
0.6
0.8
1
x
14.7. NUMERICAL ILLUSTRATIONS & SUPERCONVERGENCE
277
14.7
Numerical Illustrations: Higher Accuracy for Longer
Time Step and Superconvergence
Fig. 14.5 compares the standard Fourier pseudospectral method with the semi-Lagrangian
method for the one-dimensional advection equation. This solution “breaks” at t = 1 and
has a jump discontinuity for all larger times. The time step τ = 1/2 for the semi-Lagrangian
scheme — much longer than is stable for the standard, explicit Fourier method — is such
that the numerical integration jumps from a very smooth ﬂow (a sine wave!) to a front in
just two time steps! Nevertheless, the semi-Lagrangian method gives a much smoother ap-
proximation to the front than the standard Eulerian coordinates algorithm, which blindly
approximates all derivatives by the usual Fourier pseudospectral formulas in complete
ignorance of both the method of characteristics and the hyperbolic character of the differ-
ential equation.
Fig. 14.6 shows the departure points and errors for the semi-Lagrangian calculation,
same case as the previous ﬁgure but at a later time when the errors have presumably wors-
ened. Even so, the error is quite small everywhere except for a narrow neighborhood of the
front. However, large relative error in a thin zone around the front is a weakness of almost
all front-resolving algorithms.
The bottom panels in Fig. 14.6 shows the same solution using ten times as many time
steps. This should reduce the error, since the method is second order, by a factor of 100.
Instead, the error is considerably worse. Why does a larger time step give smaller error?
Figure 14.5: Comparison of semi-Lagrangian/semi-implicit Fourier method (thick solid
curve) with standard Fourier pseudospectra method (thin line with circles) for the one-
dimensional advection equation [inviscid Burgers’ equation] , ut + uux = 0 for 64 grid
points, evolving from u(x, 0) = sin(x) and illustrated at t = 1. The right graph is just a
“zoom” or blow-up of the left plot. The semi-Lagrangian time step was τ = 1/2; the time
step for the standard method was determined by an adaptive 4th/5th order Runge-Kutta
subroutine and is not known except that it was much shorter than for SL scheme. The
solution “breaks” at t = 1, that is, would develop an inﬁnite slope at that time were it not
for the viscosity.

278
CHAPTER 14. SEMI-LAGRANGIAN ADVECTION
Particle Origins:
 ξ(x,t)
u(x,t=2),
2
1
0
0
π/2
π
π
π/2
0
.1
.01
.001
.0002
x
x
.1
.01
.001
.00020
π/2
π
u
x
π/2
2
1
0 0
π
ξ(x,t)
u(x,t=2):
τ=1/20
timestep= 1/2
timestep= 1/20
Figure 14.6: Semi-Lagrangian Fourier calculation of a moving shock wave in Burgers’ equa-
tion (in the limit of vanishing viscosity) with 64 points on x ∈[0, 2π]. u(x, 0) = sin(x). The
solution breaks, i. e., ﬁrst develops a near-discontinuity, at t = 1; the solution is shown at
t = 2. Left panels: the origins of the points which lie on the pseudospectral grid at t = 2,
i. e., the graph is a plot of ξ(x, t) ≡xj −αj versus xj. Right panels: error at t = 2. (A
spike of O(1) error at one point in both graphs has been truncated.) In the upper pair of
plots, the time step is τ = 1/2. Since the grid spacing is about 1/10, the Courant number
is roughly 5. Bottom panels: same as top except that the time step has been reduced by a
factor of 10. The main changes are (i) the gap in particle origins is much smaller and (ii) the
error has increased. Note that in the upper panels (where Co ≈5), the error is smaller than
1/100 almost everywhere; with the short time step, the error is larger than 1/100 almost
everywhere, and many points have errors of 1/10 or 1/20, even far from the shock.

0
1
2
0.6
0.8
1.0
1.2
2
1
0
0.6
0.8
1.0
1.2
x
x
14.7. NUMERICAL ILLUSTRATIONS & SUPERCONVERGENCE
279
The crucial data is in the left panel of each graph. When the time step is large, there
is a gap in the departure points in the sense that all trajectories originate at a considerable
distance from the front. This is important because the pseudospectral interpolation, which
for these ﬁgures was performed without smoothing or special tricks, becomes increasingly
inaccurate as the front is approached because of the oscillations of Gibbs’ phenomenon.
When the time step is small, some particles originate very close to the front, so the inter-
polation gives poor approximations to the velocities that advect the particles towards the
front from either side. The result is large errors.
SL schemes that use various low order polynomial interpolations suffer the same curse;
close proximity to a jump discontinuity is an ill wind for all approximation schemes. Nu-
merical experiments such as Kuo and Williams (1990) have conﬁrmed that SL methods
have their smallest errors as a function of time step for rather large time steps — a couple
of hours in meteorological applications.
Fig. 14.7 illustrates another odd property of SL schemes. If one plots only the grid point
values of a pseudospectral SL scheme, one ﬁnds, for moderate τ, a good approximation to
the exact solution. However, the Fourier series can be summed to evaluate u(x) at arbitrary
points not on the canonical grid. If we do this for many intermediate points, we obtain the
very oscillatory graph shown in the right panel. The pseudospectral solution is much better
on the grid than off.
Finite element methods often exhibit a similar “superconvergence” at the collocation
Figure 14.7: Same case as the two previous ﬁgures, but a “zoom” which shows only part of
the x-interval around the shock. In both panels, the dashed line is the exact solution. On
the left, the solid line-with-circles shows the semi-Lagrangian Fourier solution at the points
of the collocation grid. The solid-plus-crosses on the right is the same solution except that
the Fourier interpolant has been summed at many points between those of the collocation
grid. The semi-Lagrangian solution exhibits “overconvergence”, that is, the solution is
much more accurate AT the collocation points than BETWEEN them.

280
CHAPTER 14. SEMI-LAGRANGIAN ADVECTION
points. The existence of this phenomenon has been rigorously proved for some ﬁnite ele-
ment algorithms, but not as yet for spectral.
14.8
Two-Level SL/SI Algorithms
The three-level SL/SI is simple and robust, but it has drawbacks. The ﬁrst is that it re-
quires storing the solution at three different levels. The second is that the implicit terms
are treated with an effective time step of 2τ whereas a standard Crank-Nicholson scheme
would average the unknowns at time levels tn+1 and tn with a time step of τ and an error
four times smaller.
Fortunately, it is possible to replace Robert’s scheme with a two-level method that has
a much smaller proportionality constant. The key idea is to apply the three-level formula
with u−interpreted as the solution at time level tn rather than tn−1. The intermediate
velocity at t = (n + 1/2)τ is obtained by extrapolation from previously known values of
the velocity.
The displacements are calculated from
αj = (τ/2) uext(xj −αj, tn+1/2)
(14.45)
where α is deﬁned to be the displacement over a time interval of τ/2, subscript “ext” de-
notes a quantity which must be extrapolated and j is the index of (spatial) grid points.
The actual time-marching step for Du/Dt + G(u, t) = F(u, t) is identical in form to the
three-level scheme:
u+ + (τ/2)G+ = u−−(τ/2) G−+ (τ/2) F 0
ext
(14.46)
As before, u+ = u(x, tn + τ), but
F 0
ext
≡
F(x −α, tn+1/2)
u−
≡
u(x −2 α, tn)
(14.47)
The most widely used extrapolation formula is
uext(x, tn+1/2) = 15
8 u(x, tn) −10
8 u(x, tn−1) + 3
8 u(x, tn−2)
(14.48)
which Temperton and Staniforth (1987) found preferable to the two-level extrapolation
uext(x, tn+1/2) = (3/2)u(x, tn) −(1/2)u(x, tn−1)
(14.49)
It is possible to extrapolate along trajectories (that is, shifting x positions by the displace-
ment α as one moves back in time), but Temperton and Staniforth (1987) found it was more
accurate (and cheaper) to extrapolate along grid points.
Extrapolation has a bad effect on stability, as noted above. However, the two-level
method is stable if the extrapolation is done carefully. With complicated physics — moun-
tains, complicated temperature dependence and so on — it is sometimes necessary to add
extra damping, such as replacing Crank-Nicholson by the “theta” scheme (which is a lin-
ear combination of Crank-Nicholson with Backwards-Euler that weakly damps high fre-
quency). It is also a good idea to transfer as many terms as possible from the extrapolated,
explicit quantity F 0
ext to the implicitly-treated term G. These empirical ﬁxes are problem-
speciﬁc and model-speciﬁc, so we must defer the details to the papers catalogued in the
bibliographic table below.

14.9. NONINTERPOLATING SL & NUMERICAL DIFFUSION
281
The two-level scheme is in theory twice as cheap as the three-level scheme in the sense
that one can achieve the same level of time accuracy with twice as long a time step in the
two-level model as in the older algorithm. However, because the three-level scheme is
more stable and does not need time-extrapolation, it remains competitive with two-level
methods.
14.9
Noninterpolating SL Methods and Computational Dif-
fusion
The error in interpolating from the evenly spaced grid to the “feet” of trajectories is a source
of computational diffusion. McCalpin (1988) has given a thorough analysis for polynomial
interpolation schemes of various orders, but it would take us too far aﬁeld to reproduce his
analysis here. Instead, we shall offer only a heuristic argument.
Consider the simplest case: the pure advection equation in one dimension. The formula
for computing the new unknown in the three-level SL scheme is then
u(x, tn+1) = u(x −2α, tn−1)
(14.50)
Interpolation errors will add a small random component to the displacement α. Sometimes
the ﬂuid blob will be advected a little too far, sometimes not far enough, because interpo-
lation errors generate inexact particle velocities and displacements. To the SL scheme, the
foot of a trajectory is not known exactly, but only to within a line segment (or circle or
sphere) which is the size of the average interpolation error. The advected ﬁelds are blurred
by this randomness, and blurring is equivalent to a computational damping.
McCalpin’s analysis shows linear interpolation generates ordinary, second derivative
diffusion; cubic interpolation gives a biharmonic (fourth derivative) damping and so on.
For ocean models where the scale of the energy-containing eddies is an order of magni-
tude smaller than in the atmosphere, and the affordable number of grid points-per-eddy-
diameter correspondingly smaller, too, McCalpin argues that, arithmurgically speaking,
this computational diffusion would turn the seas into great viscous pools of honey.
Fig. 14.8 illustrates his point. The semi-Lagrangian solution is damped much more than
that of the standard pseudospectral method even though the explicit, physical viscosity is
the same.
Ritchie (1986) was thus motivated to invent a “non-interpolating” SL algorithm. The
basic idea is very simple. At large Courant number, split the advecting velocity into two
parts:
uj = uj,SL + uj,E
(14.51)
where uj,SL is chosen so that the “foot” of the trajectory is exactly on a point of the regular
grid when the particle is advected by uj,SL only. Of course, the actual foot of the trajectory
almost never coincides with a point of the regular grid, but this is not a serious limitation
since the SL algorithm is really just a transformation to a moving coordinate. There is
no law of nature or arithmurgy that says that the velocity of the coordinate change must
exactly match that of the ﬂuid.
However, Ritchie’s modiﬁed transformation eliminates only part of the advection, so
the remainder must be treated by the standard pseudospectral method, just as if we used
an Eulerian (ﬁxed grid/trajectory-ignoring) coordinate system throughout. It is important
to choose uj,SL to advect to the grid point nearest the actual foot of the trajectory so that
uj,E is as small as possible. The residual Courant number is then always less than one so

2
2.5
3
0.5
0.6
0.7
0.8
0.9
1
x
-2
0
2
-1
-0.5
0
0.5
1
x
Viscosity=h/2
282
CHAPTER 14. SEMI-LAGRANGIAN ADVECTION
Figure 14.8: Comparison of the semi-Lagrangian/semi-implicit Fourier method (thick
lower curve) with the standard Fourier pseudospectra method (upper curve with circles)
for Burgers’ equation, ut + uuxx = ν uxx where ν = h/2 and h = π/32 is the grid spacing.
The SL time step was τ = 1/2; that for the standard method was determined by an adap-
tive 4th/5th order Runge-Kutta subroutine. The solution from u(x, 0) = sin(x) “breaks”
at t = 1, that is, would develop an inﬁnite slope at that time were it not for the viscosity.
The solutions are shown at t = 2. In spite of the long time step, which tends to slow the
diffusion of the νuxx term (which is treated implicitly), the SL/SI algorithm is much more
strongly damped than the standard pseudospectral method, which treats the viscosity hon-
estly by using a short time step. The SL/SI damping comes primarily from interpolation
errors.
that the integration is stable with very long time steps where the residual Courant number
is
CoE ≡max(|uE|)
τ
hmin
(14.52)
where hmin is the smallest distance between any two points on the regular pseudospectral
grid.
Ritchie’s later papers (1987, 1988, 1991) show that the “non-interpolating” SL method
works just ﬁne with both spectral and ﬁnite difference spatial discretizations, even in three-
dimensional models. However, his idea has only partially replaced older SL algorithms.
There are two reasons. First, treating some of the advection by a non-SL scheme brings
back some of the disadvantages and poor front resolution of conventional methods. Sec-
ond, for atmospheric forecasting models, the resolution is sufﬁciently high and the length
of the integration is sufﬁciently short that damping is not a problem. However, climate
models, which are run at lower spatial resolution for long time integrations, may beneﬁt
from non-interpolating SL.
For example, his comparisons with non-SL models showed that at a resolution of “T106”,
then the standard for forecasting, both interpolating and non-interpolating SL models lost
only about 1% of the initial energy. This was actually better than the standard non-SL

14.10. OFF-GRID INTERPOLATION
283
spherical harmonics model of the European Centre for Medium-Range Weather Forecast-
ing, which lost about 3% of its energy due to an (unphysical) biharmonic damping which
is included to suppress small scale noise and give better front resolution. The SL models,
in spite of their inherent implicit computational dissipation, were actually less damping
than the non-SL algorithm because an explicit artiﬁcial viscosity was unnecessary for the
SL schemes.
At lower resolution, as in a climate model or an ocean model, Robert’s SL algorithm
is more disspative because the interpolation errors worsen as the grid coarsens. At T63,
Ritchie found that his non-interpolating model lost only 1% energy, but the interpolating
SL lost 5%.
Smolarkiewicz and Rasch (1990) have generalized non-interpolating SL schemes. They
show that their generalization can be applied to many existing, non-SL algorithms to relax
time step limitations while retaining good properties of the methods such as that of being
“positive-deﬁnite monotone”.
The conclusion is that non-interpolating SL may be very useful for ocean and climate
modelling, or whenever the resolution is sufﬁciently poor that interpolation errors create
too much damping. However, the errors are a function of the order of the interpolation as
well as the grid spacing. If one uses high order interpolation, such as fast spectral off-grid
interpolation, or even quintic polynomial interpolation, instead of the cubic interpolation
which is now the standard in atmospheric models, the computational diffusion is greatly
reduced. Thus, it is only in the context of speciﬁc problems with speciﬁc grid size and a
particular interpolation order that one can intelligently answer the question: Are interpo-
lating or non-interpolating schemes better?
14.10
Off-Grid Interpolation: Shape-Preserving, Conserva-
tion and All That
14.10.1
Off-Grid Interpolation: Generalities
Off-grid interpolation is rather expensive, if done in the obvious way. For spectral methods,
off-grid interpolation cannot be done by the Fast Fourier Transform because the departure
points are spaced irregularly between the points of the canonical grid. Summing an N-term
spectral series at each of N points costs O(N 2) operations.
There are two subproblems which require off-grid interpolation: (i) calculating the dis-
placements and (ii) calculating properties at departure points. The interpolation of mid-
trajectory velocities can be done by a lower order method than interpolating velocities,
temperatures, ozone concentration and so on at the departure points. The reason is that
the displacement is the velocity multiplied by the time step, and so errors in the displace-
ment are smaller than those in u itself.
It is much more important to interpolate accurately when calculating the properties of
a ﬂuid blob at its departure point. The reason is that errors in this step are not multiplied
by the time step, but rather are errors in the answer itself. An error of a tenth of a degree
in interpolating the temperature at the departure point will be carried through the entire
remainder of the computation.
The third comment is that SL schemes do not automatically conserve either mass or
energy, nor preserve the positive deﬁniteness of densities like mass and water vapor which
are always non-negative. It is possible to modify SL procedures to recover many of these
properties, but the “off-grid” interpolation is where the “conservation” and “positive deﬁ-
niteness” wars must be fought.

284
CHAPTER 14. SEMI-LAGRANGIAN ADVECTION
14.10.2
Spectral Off-grid
Spectrally-accurate off-grid interpolation algorithms include the following:
1. Fast Multipole Method (FMM) (Boyd, 1992c, Dutt & Rohklin, 1993, 1994)
2. Partial Chebyshev expansion method (S¨uli & Ware, 1991, 1992, Ware, 1991,1994)
3. Fine-grid Lagrange interpolation algorithm (Boyd, 1992)
As explained at greater length in Chapter 10, all three methods are asymptotically faster
than direct summation. (See the review by Ware, 1998). However, the proportionality
factors, which vary with the desired error tolerance, are always much greater than for the
Fast Fourier Transform.
The S¨uli-Ware algorithm is the only one that has been explicitly applied in semi-Lagrangian
calculations. It performed well in both one and two space dimensions.
Boyd’s ﬁne-grid polynomial interpolation algorithm is probably both the fastest and
the simplest to explain. The key idea is that low order polynomial interpolation can be
very accurate if performed on a sufﬁciently ﬁne grid. So, his ﬁrst step is to apply the FFT
to transform the data to a ﬁner grid than used for the rest of the calculations. One can then
use ordinary Lagrange interpolation or splines on the ﬁne grid with little loss of accuracy
compared to spectral off-grid interpolation on the original coarser grid.
His algorithm has not been explicitly used in semi-Lagrangian models to date. However,
the ECMWF forecasting model and the NCAR Community Climate Model both employ
his idea implicitly. For reasons of cost, and because fast off-grid interpolations were not yet
known at the time, the programmers used various forms of low-order interpolation and
hoped for the best. (Careful testing showed that this inconsistent use of low order off-grid
interpolation in a high order model does not signiﬁcantly degrade the overall forecast.)
However, these models employ dealiasing so that inner products are evaluated on a grid
which is much ﬁner than the actual number of spectral degrees of freedom. Thus, these
models implicitly use Boyd’s strategy.
The inconsistency between spectral calculation of derivatives and non-spectral off-grid
interpolation is in any event not as illogical as it seems. The reason is that to minimize
dispersion, it is important to have accurate computation of derivatives in the linear terms
which are not treated by semi-Lagrangian advection. The off-grid interpolation does not
have to approximate derivatives, but only the velocities themselves, which is easier.
There are two open questions about spectral off-grid interpolation. First, is it cost-
effective in a real climate or forecasting model, or is low order polynomial interpolation
sufﬁcient? The second is: can spectral semi-Lagrangian schemes be improved, when nar-
row fronts form, by skillful use of ﬁlters or sum-acceleration methods?
We discuss ﬁlters brieﬂy in Chapter 18, Sec. 20, but it is useful to at least hint at the
possibilities. In Fig. 14.9, there is a large spike of error in the immediate neighborhood
of the front in both panels; it is very difﬁcult to eliminate this because even a slight er-
ror (O(h)) in the location of the front will inevitably generate O(1) errors, although the
shape of the computed ﬂow may look very similar to the true ﬂow. Away from this small
neighborhood, however, Fig. 14.9 shows that ﬁltering can dramatically reduce errors in a
Fourier semi-Lagrangian method. There is only a little experience with ﬁltered spectral
semi-Lagrangian schemes, and ﬁlters themselves are a hot research topic. The graph sug-
gests that further work on ﬁltered semi-Lagrangian algorithms would be rewarding.
14.10.3
Low-order Polynomial Interpolation
Finite difference and low order ﬁnite element models commonly use polynomial interpo-
lation to approximate quantities off-grid. Cubic splines (Purnell, 1976) have been tried, but

- π
0
π
- π
1E-4
.001
.01
.1
0
π
.1
.01
.001
1E-4
Unfiltered
Filtered
14.10. OFF-GRID INTERPOLATION
285
Figure 14.9: Errors in the solution to the one-dimensional advection equation by Fourier
three-level semi-Lagrangian computation with N = 64 grid points and a time step τ = 1/2.
The initial condition is u(x, 0) = 1 −sin(x). Left: Vandeven ﬁlter of order p = 6. Right:
unﬁltered numerical solution.
the most common choice for interpolating particle properties (i. e., u−in the SL schemes
above) is cubic Lagrange interpolation. (Leslie and Purser, 1991, used quintic interpola-
tion.) There is less consistency in calculating displacements because as noted in the pre-
vious subsection, the forecast error is much less sensitive to errors in the velocity in the
ﬁxed-point iteration for α than to errors in u−, F 0, etc. Some therefore use linear interpo-
lation of u(x −α, tn) in calculating displacements. McDonald (1986) suggested a hybrid
strategy: linear interpolation on the ﬁrst ﬁxed-point iteration followed by cubic interpola-
tion on the second (and usually last) iteration.
Moisture has a very patchy distribution in the atmosphere; the air above the Mediter-
ranean Sea is very humid because the warm water evaporates like crazy, but the Mediter-
ranean Sea is bordered by the Sahara desert, which is not humid at all. Global spectral
models, with a resolution of only O(100 km), exhibit Gibbs’ phenomenon in the vicinity
of such moisture fronts. The resulting regions of negative water vapor are decidely un-
physical and have a bad effect on model climate. SL schemes do much better. (Rasch and
Williamson,1990b,1991 and Williamson, 1990).
The moisture transport problem has motivated studies which replace ordinary inter-
polation by a procedure in which the interpolant is adjusted by side constraints, such as
smoothness and positive-deﬁniteness. Such “quasi-monotone” or “shape-preserving” SL
schemes have been investigated by Williamson and Rasch(1989), Rasch and Williamson(1990a)
and Bermejo and Staniforth (1992).
Adjusted or constrained interpolation can also be used to enforce conservation of total
mass. Priestley (1993) and Gravel and Staniforth (1994) have generalized SL to be quasi-
conservative.

286
CHAPTER 14. SEMI-LAGRANGIAN ADVECTION
14.10.4
McGregor’s Taylor Series Scheme: an Alternative for Computing
Departure Points
The only disadvantage of polynomial interpolation is that if done accurately, it is rather
expensive, especially in multiple space dimensions. McGregor (1993) suggested an alter-
native procedure, which is to calculate the trajectory by a Taylor series in time about the
departure point. The catch is that because the trajectory is the goal, the time derivatives
must be total time derivatives. Thus, in one space dimension,
α = −τ u + τ 2
2
(ut + uux) −τ 3
6
µ ∂
∂t + u ∂
∂x
¶
(ut + uux) + . . .
(14.53)
Calculating the local time derivatives above is very hard. However, McGregor argues
that these can be neglected compared to the advective terms so that
α ≈−τu + τ 2
2 uux −τ 3
6 u ∂
∂x (uux) + . . .
(14.54)
where the velocities are to be evaluated at the spatial location of the arrival point at the
midpoint in time (tn for the three-level scheme, tn+1/2 for a two-level method).
His method is an order of magnitude cheaper than bicubic interpolation and accurate to
second order. Adding additional terms does not increase the formal time accuracy beyond
second order, but McGregor shows that empirically, including partial third order terms
does improve accuracy considerably for ﬁnite τ.
14.11
Higher Order SL Methods
Purser and Leslie (1994) have developed an efﬁcient third-order SL scheme. Earlier, Maday,
Patera and Rønquist (1990) and S¨uli and Ware (1991, 1992) and Ware (1991, 1994) have
developed a family of algorithms which can be extended to arbitrary order. Building on
Holly and Preismann (1977) and Yang and Hsu (1991), Yang, Belleudy and Temperville
(1991) developed a ﬁfth order accurate SL scheme.
The bad news is that these high order schemes are all rather complicated. The assump-
tion that a particle is advected at constant speed by the velocity at the midpoint of the
trajectory is sufﬁcient to give second order accuracy in time. At higher order, the displace-
ment on t ∈[tn−1, tn] is no longer the same as t ∈[tn, tn+1], and a simple ﬁxed point
iteration no longer gives direct access to the trajectory.
The Maday-Patera-Rønquist and S¨uli-Ware algorithms require solving auxiliary time-
marching problems, k problems for a (k + 1)-th order method. Maday et al. show that
one can “sub-cycle”, integrating these auxiliary advection problems with a short time step
while applying the implicit time-marching formulas (for non-advective terms) only over a
long time interval.
Even so, these algorithms are uncompetitive with the second order SL schemes for me-
teorological applications. We shall therefore not describe them in detail. These are likely
to become more important as resolutions improve so that time-truncation errors begin to
catch up with space truncation errors. The latter are currently much worse for forecasting
and climate models than the temporal differencing errors.
14.12
History and Relationships to Other Methods

14.12. HISTORY AND RELATIONSHIPS TO OTHER METHODS
287
Table 14.1: A Selected Bibliography of Semi-Lagrangian Methods
SL is an abbreviation for “semi-Lagrangian”; SI for “semi-implicit”.
Reference
Comments
Fjørtoft(1952, 1955)
First Lagrangian algorithm (meteorology)
Wiin-Nielsen (1959)
Earliest SL, at least in meteorology
Sawyer (1963)
coined “semi-Lagrangian”
Holly&Preissman (1977)
SL variant using Hermite interpolation (hydrology)
Haltiner&Williams(1980)
Good review of (singly-upstream) SL
Robert (1981, 1982)
Earliest pairing of SL with SI
Douglas&Russell(1982)
Invention of an SL scheme
Pironneau (1982)
Invention of SL as “transport-diffusion” algorithm
Bates&McDonald (1982)
First multiply-upstream SL
Bates (1984)
More efﬁcient multiply-upsteam SL
Morton (1985)
Invention of SL as “Lagrange-Galerkin” scheme
Robert&Yee&Ritchie(1985)
SL with SI
Pudykiewicz et al.(1985)
Convergence of ﬁxed point iteration
Temperton & Staniforth(1987)
Independent invention of two-level SL
McDonald & Bates (1987)
2d order accuracy through extrapolated velocities
Ritchie (1986)
Invention of “non-interpolating” SL
Ritchie (1987,1988,1991)
Non-interpolating SL applied to a sequence of
increasingly sophisticated spectral models
McCalpin (1988)
Analysis of dissipation inherent
in SL interpolation
McDonald&Bates(1989)
Showed SL with time-splitting was inaccurate
Bates&Semazzi&
Finite difference SL shallow water model
Higgins&Barros(1990)
Accuracy improved by avoiding time-splitting
Cˆot´e&Gravel&Staniforth(1990)
Finite-element SL with “pseudostaggering”
Williamson&Rasch(1989)
SL with shape-preserving (positive deﬁnite)
Rasch&Williamson(1990a)
advection
Rasch&Williamson(1990b,1991)
moisture transport in climate & weather models
Williamson(1990)
Purser&Leslie(1988,1991,1994)
Not spectral but improvements in SL
Leslie&Purser(1991)
latest article is 3rd order in time
Yang&Belleudy
Fifth order SL
&Temperville(1991)
Yang&Hsu(1991)
Improved Holly-Preismmann & Yanget al. schemes
Smolarkiewicz & Rasch(1990)
Generalization of non-interpolating SL; monotone
Maday&Patera&Rønquist(1990)
SL of arbitrarily high time-order
S¨uli&Ware(1991,1992)
Fourier and Chebyshev SL/SI, proofs and examples
Ware (1991,1994)
independent invention of arbitrary time-order SL
Baker&S¨uli&Ware(1992)
& fast off-grid interpolation scheme
Staniforth& Cˆot´e(1991)
Highly readable review
Gravel&Staniforth&Cˆot´e(1993)
Stability analysis

288
CHAPTER 14. SEMI-LAGRANGIAN ADVECTION
Table 14.1: Bibliography of Semi-Lagrangian Methods (continued)
Reference
Comments
Bermejo&Staniforth(1992)
Quasi-monotone SL
Priestley(1993)
Quasi-conservative SL
Gravel&Staniforth(1994)
Quasi-conservative SL for shallow-water system
McGregor(1993)
Inexpensive O(τ 2) formula for departure pts.
Pellerin&Laprise
Experiments with simple advection/
&Zawadzki(1995)
condensation system
Cˆot´e&Gravel
Extra time level scheme to defeat
&Staniforth(1995)
orographic resonance
Ritchie&Tanguay(1996)
Comparison of spatially averaged Eulerian
& Lagrangian treatments of mountains
B¨ottcher (1996)
Modiﬁed exponential splines for interpolation
Makar&Karpik(1996)
Periodic B-spline interpolation on sphere for SL;
comparisons with spectral methods
The Lagrangian (particle-tracking) formalism is a couple of centuries old. Fjørtoft (1952,
1955) showed that particle-tracking could be used for weather forecasting. However, We-
lander (1955) showed through a vivid and widely- reproduced graph that blobs of ﬂuid
were rapidly stretched and deformed into a very convoluted shapes. Today, we would
say that ﬂuids can be chaotically mixed, in the sense of “chaos” theory, and a blob of ﬂuid
initially bounded by a small square is bounded, for later times, by a “fractal” curve of
ever-increasing length.
Wiin-Nielsen (1959) therefore introduced a “semi-Lagrangian” scheme: just as in mod-
ern schemes, each set of particles is tracked only over a single small time interval of length
τ. A new set of particles is chosen for later time steps: those which will arrive at the
points of an evenly spaced grid. Later meteorological papers by Krishnamurthi (1962) and
Sawyer (1963) and others established that SL algorithms are useful, but did not identify
overwhelming advantages.
The method become much more popular when Robert (1981, 1982) showed how to
combine semi-Lagrangian advection with semi-implicit treatment of the other terms. This
launched an explosion of activity in meteorology which has continued to the present.
Bates and McDonald (1982) made another important advance by introducing “multiply-
upstream” CFL methods. These allowed the use of a time step which far exceeded the
advective limits of conventional explicit schemes.
Temperton and Staniforth (1987) and McDonald and Bates (1987) independently de-
vised two-level schemes of second order time accuracy. (Robert’s method required three
time levels while the earlier two-level algorithms of Bates and McDonald were only ﬁrst or-
der.) These allow a doubling of the time step with no loss of accuracy. However, two-level
schemes are somewhat less stable than Robert’s method, so several later articles have de-
scribed slight modiﬁcations, such as a “theta” treatment of the implicit schemes, a damping
of divergence, and so on to render such algorithms more stable and robust.
Ritchie (1986) developed the “non-interpolating” version of SL, and then applied it to
a hierarchy of increasingly complicated models in later papers. Smolarkiewicz and Rasch
(1990) have generalized this family of methods. Interpolating schemes are better for well-
resolved ﬂows, but non-interpolating SL may be very valuable in integrating climate and
ocean models at coarse resolution without excessive computational damping.
Williamson and Rasch(1989), Rasch Williamson(1990a), and Bermejo and Staniforth

14.13. SUMMARY
289
(1992) have studied “shape-preserving” or “quasi-monotone” algorithms. The key idea
is to replace ordinary interpolation by more exotic near-interpolation schemes that are con-
strained to preserve essential properties of the ﬂow such as smoothness and, for densities,
non-negativity.
Priestley (1993) and Gravel and Staniforth (1994) have generalized SL to be quasi-
conservative of mass. The slight adjustments to conserve the total ﬂuid mass are made
preferentially near the fronts where the Gibbs’ oscillations, which cause most of the mass
loss or gain, are concentrated.
Bates and McDonald (1982), Bates (1984), Bates et al.(1990), McDonald (1984, 1986, 1987)
and McDonald and Bates (1987, 1989) have developed ﬁnite difference SL models. Bates
et al.(1990) show that the “split-explicit” and other time-splitting schemes are not nearly
as accurate an unsplit semi-implicit algorithm for the long time steps used with SL codes.
Environment Canada has developed ﬁnite element SL models for forecasting (Cˆot´e, Gravel
and Staniforth, 1990).
One major difﬁculty is that ﬂow over mountains can trigger spurious, unphysical insta-
bility in SL/SI schemes. After much struggle, ways to ﬁx up SL to cope with topographic
instability have been found as explained in Cˆot´e, Gravel and Staniforth (1995).
SL schemes have also been independently invented under other names. “Particle-in-
cell” schemes and their close connection with SL have been discussed by Bermejo (1990),
who proves that a common particle-in-cell method is just SL with cubic spline off-grid
interpolation.
The family of methods known variously as the “characteristic Galerkin” or “Lagrange-
Galerkin” or “Eulerian-Lagrangian” was independently invented outside of meteorology
by Douglas and Russell(1982), Morton(1985) and Pironneau(1982). It has been greatly de-
veloped in the ﬁnite element world.
14.13
Summary
Semi-Lagrangian methods have been a big hit in meteorology, and under other names,
have had some success in engineering ﬂuid mechanics, too. Most of the thorny problems
have been solved but some issues remain.
First, can the ﬁxers which stabilize SL against topographic instabilities be simpliﬁed
and improved? Second, can high order off-grid interpolation improve, both in speed and
in conservation and shape-preserving properties, so that consistent spectral SL algorithms
become feasible for large models like weather forecasting codes? Third, can better and
simpler high-order-in-time SL methods be devised? Going beyond second order in time
seems to exact a heavy price.

Chapter 15
Iterative & Direct Methods for
Solving Matrix Equations
“Practice in numerical methods is the only way of learning it”
— H. Jeffreys and B. Jeffreys
“A good scientist is one who knows enough to steal from the best people”
— J. R. Holton
15.1
Introduction
For all but the simplest problems — those with coefﬁcients which are polynomials —
Galerkin’s method and the pseudospectral method lead to full matrices, unlike the sparse
systems of equations generated by ﬁnite difference and ﬁnite element algorithms. This
is particularly unfortunate since implicit and semi-implicit marching procedures require
solving a boundary value problem at each time step. Since the expense of Gaussian elimi-
nation grows as O(N 3) and N is O(1000) even in two dimensions with modest resolution,
spectral methods are prohibitively expensive for most problems without highly efﬁcient
iterative methods for solving the ensuing matrix equations.
For special problems, it is possible to replace iterations with direct methods. The Haidvogel-
Zang algorithm for separable partial differential equations is the theme of one section. When
the equation is constant coefﬁcient, one may sometimes obtain a sparse matrix by applying
Galerkin’s method as explained in another.
In most of the chapter, we will implicitly assume that the matrix is positive deﬁnite, that
is, all its eigenvalues are of the same sign. The reason is that most simple iterations fail
when this condition is not met. Fortunately, both preconditioning and multigrid usually
eliminate the divergence caused by a few eigenvalues of the wrong sign. We explain why
and also describe a difﬁcult case where none of our iterations can be expected to work.
Fortunately, such circumstances are very rare, and there are remedies even for problems
with an inﬁnite number of both positive and negative eigenvalues.
Lastly, we describe how these iterations can be directly extended to nonlinear prob-
lems. Two key themes that dominate earlier sections of the chapter, preconditioning and
iteration-as-marching-in-pseudotime, are important for nonlinear iterations, too.
290

15.2. STATIONARY ONE-STEP ITERATIONS
291
15.2
Iteration-as-Diffusion, Stationary One-Step Iterations
& the Richardson/Euler Iteration
If the operator L is positive deﬁnite, i. e. if all its eigenvalues are positive, then one way to
solve the boundary value problem
Lu = f
(15.1)
is to integrate the time-dependent equation
ut = −L u + f
(15.2)
with the same boundary conditions and an arbitrary initial condition. Eq. (15.2) is a gener-
alized diffusion equation. Some iterative methods are based directly on (15.2) and others
are not, but the analogy of iteration-is-diffusion is very useful because all iterative meth-
ods “diffuse” the error until the solution settles down into the steady-state equilibrium
described by (15.1).
Because L is positive deﬁnite, all eigenmodes of L must decay with time. If L has one
or more negative eigenvalues, or a complex eigenvalue with a negative real part, then the
corresponding mode will amplify — in words, (15.2) is unstable. Consequently, differential
equations with eigenvalues of both signs require special treatment, and we will assume L
is positive deﬁnite in this section and the next.
Eq. (15.2) seems to have made the problem more complex rather than simpler, but for
the generalized diffusion equation, an explicit scheme costs only O(N) operations per time
step. In contrast, solving the discretized boundary value problem through Gaussian elimi-
nation costs O(N 3) operations where N is the number of basis functions or grid points.
The simplest iterative method for (15.1) is to solve (15.2) by the ﬁrst order Euler method,
⃗un+1 = (⃗⃗I −τ ⃗⃗Λ) ⃗un + τ ⃗f
[Richardson/Euler/Jacobi]
(15.3)
where ⃗⃗Λ is the matrix which is the pseudospectral discretization of the differential operator
L. This was ﬁrst suggested by L. F. Richardson (1910). The parameter τ is the time step;
since we are only interested in the steady state solution, the best choice for τ is only a little
smaller than the time-stepping stability limit.
The Jacobi iteration, also described in many textbooks, is identical with Richardson’s if
the diagonal matrix elements of ⃗⃗Λ are rescaled to unity. Thus, the Jacobi and Richardson
iterations are conceptually identical. In this rest of the chapter, we omit the rescaling and
label this iteration with the name of Richardson.
Richardson’s iteration is the prototype for a whole family of methods known as “sta-
tionary one-step” iterations, which have the general form
⃗un+1 = ⃗⃗G ⃗un + ⃗k
[Stationary, One-Step]
(15.4)
where ⃗⃗G is a square matrix and ⃗k is a column vector. The iteration is quite useless unless it
reduces to an identity when un is the exact solution of ⃗⃗Λ ⃗u = ⃗f, so we have the constraint
⃗⃗G =⃗⃗I −⃗⃗R
−1⃗⃗Λ
;
⃗k = ⃗⃗R
−1 ⃗f
(15.5)
for some square matrix ⃗⃗R, but this still allows great diversity.

292
CHAPTER 15. MATRIX-SOLVING METHODS
Until the early 70’s, the Gauss-Seidel iteration and its reﬁnement, Successive Over-
Relaxation (SOR), were the stars. Unfortunately, they update matrix elements by using
a mixture of both old values and new ones already calculated on the same time level. Nei-
ther a vector processor nor the indirect pseudospectral algorithm (Sec. 4) can cope with
this mix, so we shall not discuss the Gauss-Seidel and SOR methods further.
In order to estimate the optimum τ and also to provide the framework for the general-
izations of Richardson’s method discussed later, we now turn to a bit of theory.
Matrix functions can always be evaluated, at least in principle, by using an expansion
in terms of the eigenfunctions of the matrix. If ⃗φn denotes the eigenvectors of the square
matrix ⃗⃗G with λn as the corresponding eigenvalues, then successive iterates of a stationary
one-step method will be related by
⃗un+1 =
N
X
j=1
λj un
j ⃗φj + ⃗k
(15.6)
where the un
j are the coefﬁcients of the expansion of ⃗un in the eigenvectors of ⃗⃗G. Deﬁne the
error at the n-th iteration as
⃗e(n) ≡⃗u −⃗un
[Error at n-th step]
(15.7)
Substituting this into (15.4) and recalling ⃗⃗Λ ⃗u = ⃗f gives
⃗e(n+1) ≡⃗⃗G⃗e(n)
(15.8)
Let ρ denote the magnitude of the largest eigenvalue of the iteration matrix ⃗⃗G, which is
called the “spectral radius” of the matrix and let φbiggest denote the corresponding eigen-
vector. For sufﬁciently large iteration number, the faster-decaying components of the error
will be negligible and
|⃗e(n)| ∼ρ |⃗e(n−1)|
as n →∞
(15.9)
with ⃗en ∼cφbiggest for some constant c. Thus, the rate of convergence is always geometric.
Optimizing an iteration is therefore equivalent to minimizing the spectral radius of the
iteration matrix. Let λmin and λmax denote the smallest and largest eigenvalues of ⃗⃗Λ, which
for simplicity we assume are real. Then for Richardson’s iteration, the corresponding eigen-
values γmin and γmax of the iteration matrix ⃗⃗G are
⃗⃗G ≡⃗⃗I −τ⃗⃗Λ
=⇒
γmin = 1 −τλmax
&
γmax = 1 −τλmin
(15.10)
Fig. 15.1 shows that the spectral radius is minimized when |γmin| = γmax, which gives
τ =
2
λmin + λmax
[Optimum τ; Richardson’s]
(15.11)
ρ(⃗⃗G)
=
λmax −λmin
λmax + λmin
[Smallest Spectral Radius]
(15.12)
≈
1 −2 λmin
λmax
λmin ≪λmax

15.3. PRECONDITIONING: FINITE DIFFERENCE
293
Figure 15.1: The relationship between the eigenvalues of the matrix Λ and those of the
Richardson’s iteration matrix, G ≡I −τΛ where I is the identity matrix and τ is the
“time step”. (a) The eigenvalues of Λ lie on the positive interval λ ∈[λmin, λmax]. (b) The
eigenvalues of G lie on λ ∈[(1 −τλmax), (1 −τλmin)]
One difﬁculty is that we normally do not know either λmin or λmax. However, we shall
see later that it is not too hard to estimate them, especially when using a preconditioner.
The other, far more serious problem is that typically,
λmax
∼
O(N 2) λmin
[2d order equations]
(15.13a)
λmax
∼
O(N k) λmin
[k-th order equations]
(15.13b)
independent of the number of spatial dimensions. This implies that for the commonest
case of a 2d order equation, log(ρ) ∼O(1/N 2), which in turn means that O(N 2) iterations
are needed to obtain even moderate accuracy. For a fourth order equation, the number of
iterations increases to O(N 4).
We will show in a later section that with heavy use of the FFT, it is possible to evaluate
each Richardson iteration in O(N 2 log N) operations in two dimensions, so the total cost
for a second order BVP is O(N 4 log N) operations (with a large proportionality constant).
Fortunately, it is possible to tremendously improve the efﬁciency of the Richardson
iteration through three modiﬁcations: (i) Chebyshev acceleration (ii) preconditioning and
(iii) multigrid. The ﬁrst was discussed in the ﬁrst edition of this book; the second and third
are described here. All three can be used either individually or in combination to accelerate
the rate of convergence of iteration schemes.
15.3
Preconditioning: Finite Difference
The reason that Richardson’s iteration converges with such lamentable slowness is that
λmax/λmin ≫1
(15.14)

294
CHAPTER 15. MATRIX-SOLVING METHODS
preconditioning is a strategy for replacing ⃗⃗Λ in the iteration by a new matrix
⃗⃗A ≡⃗⃗H
−1⃗⃗Λ
(15.15)
where the “preconditioning matrix” ⃗⃗H is chosen to meet two criteria:
1. ⃗⃗H must be easily invertible
2. The ratio of the largest eigenvalue of ⃗⃗A to the smallest must be much smaller than the
ratio for ⃗⃗Λ:
αmax/αmin ≪λmax/λmin
(15.16)
From the viewpoint of the second criterion alone, the ultimate preconditioning matrix
is ⃗⃗Λ itself since ⃗⃗A = ⃗⃗I, the identity matrix, whose eigenvalues are all one. Such a choice is
obviously insane because if we could easily compute ⃗⃗Λ
−1
, we would not need the iteration
in the ﬁrst place! Still, it is suggestive: What we want is a matrix that is much simpler than
⃗⃗Λ, but in some sense approximates it.
The preconditioning strategy of Orszag (1980) is to take ⃗⃗H to be the matrix of the usual
second order ﬁnite difference approximation to the differential operator ⃗⃗L for which ⃗⃗Λ is the
pseudospectral approximation1. It is obvious that inverting the “ﬁnite difference precondi-
tioning” is cheap. For a second order differential equation in one dimension, for example,
⃗⃗H is an ordinary tridiagonal matrix which can be inverted in O(8N) operations. Thus, the
rate-determining step is not computing the inverse of ⃗⃗H, but rather multipying ⃗u(n) by
the full matrix ⃗⃗Λ, which is O(N 2) without special tricks and and O(8N log2 N) even with
FFT methods. The harder question is: Do the eigenvalues of ⃗⃗H approximate those of ⃗⃗Λ
sufﬁciently well so that (15.16) is satisﬁed?
For the smallest eigenvalue, the answer is always and obviously: Yes. The reason is that
λmin corresponds to the lowest mode of the original differential equation. Unless N is very
small, both the ﬁnite difference and pseudospectral approximations will do a resoundingly
good job of resolving this mode, and therefore
αmin = 1
[Any ﬁnite difference preconditioning]
(15.17)
The situation, alas, is quite different for the higher modes because they will not be
resolved well by either the spectral or ﬁnite difference methods. Our only hope is that the
erroneous large eigenvalues of the spectral and ﬁnite difference matrices will be of the same
magnitude. It turns out that this is sometimes true and sometimes false, so it is necessary to
specialize to particular cases.
EXAMPLE: Consider the ordinary differential equation
a2(x) uxx + a1(x) ux + a0(x) u = f(x)
(15.18)
with the periodic boundary conditions u(x + 2 π) = u(x).
1This was suggested by D’yakonov (1961), who used a similar preconditioning to solve a non-separable PDE
through an iteration that required solving a separable PDE at each step.

15.3. PRECONDITIONING: FINITE DIFFERENCE
295
The unknowns are then u(xj) where xj = 2 π j/N, j = 0, 1, . . . , N −1. Let ⃗u denote
the column vector whose elements are the grid point values of u(x). The ﬁnite difference
approximation is
(⃗⃗H⃗u)j = a2(xj)uj+1 −2 uj + uj−1
(△x)2
+ a1(xj)uj+1 −uj−1
2△x
+ a0(xj) uj
(15.19)
where △x ≡2π/N.
The eigenfunctions ⃗u and eigenvalues αk of the matrix ⃗⃗A = ⃗⃗H
−1⃗⃗Λ satisfy the equation
⃗⃗Λ ⃗u = α ⃗⃗H ⃗u
(15.20)
Now if u(x) is a smooth function — a low eigenmode of the differential operator ⃗⃗L —
then both the ﬁnite difference and pseudospectral approximations will do a good job of
approximating it, and α ≈1 as already noted.
If N is sufﬁciently large, then the N-th eigenmode will oscillate very rapidly in com-
parison to a2(x). This justiﬁes the WKB approximation (Bender & Orszag, 1978). This
shows that the eigenmodes of large λ must locally resemble those of a constant coefﬁcient
equation, which are exp[i k x] for both the spectral and ﬁnite difference approximations.
Furthermore, if u(x) is highly oscillatory — a large ⃗⃗Λ mode — then
uxx ≫ux ≫u
(15.21)
which implies that the ﬁrst derivative and undifferentiated terms in the differential equation
are irrelevant to the eigenvalues αk for large k except when the coefﬁcient of the second
derivative is extremely small: (O[1/N] in comparison to the ﬁrst derivative, or O(1/N 2)
relative to the undifferentiated term.)
Substituting
uj = exp(i k xj)
(15.22)
into
a2(−k2) uj = αk a2
uj+1 −2uj + uj−1
(△x)2
(15.23)
gives
αk =
k2 [△x]2
4 sin2[(1/2) k △x]
(15.24)
Noting that k ∈[0, π/△x], the corresponding range of α is then
1 ≤α ≤π2
4 ≈2.5
[Second derivative]
(15.25)
for all modes, independent of the number of grid points N.
Success! The optimum choice of τ for Richardson’s method is
τ = 4
7
(15.26)
The error decreases by a factor of 7/3 = 2.333 for each Richardson’s iteration. Since Cheby-
shev series are but a Fourier cosine series in disguise, (15.25) and (15.26) also apply when
(15.18) is solved via Chebyshev polynomials.

296
CHAPTER 15. MATRIX-SOLVING METHODS
For fourth order derivatives, one can derive
1 ≤α ≤6
·
= π4
16
¸
(15.27)
which is good but not great. Orszag shows that if we write the problem
∇4u = f
(15.28)
as the equivalent system
¯¯¯¯
∇2
−1
0
∇2
¯¯¯¯
¯¯¯¯
u
v
¯¯¯¯ =
¯¯¯¯
0
f
¯¯¯¯
(15.29)
the pre-conditioned matrix equivalent to the operator K, deﬁned by the square matrix in
(15.29), has eigenvalues that satisfy
1 ≤α ≤2.5
(15.30)
When the highest derivative is odd, however, the preconditioned eigenvalues can be-
come arbitrarily large. (The preconditioned eigenvalues will also become enormous when
the highest derivative is even but has an extremely small coefﬁcient, such as high Reynolds
number ﬂow.) The operator ∂/∂x has the eigenvalues λk = i k for periodic boundary con-
ditions while the corresponding centered ﬁnite difference approximation has the eigenval-
ues (i sin[k△x]/△x) so that
αk ∼O
·
k△x
sin (k△x)
¸
(15.31)
Unfortunately, this is unbounded. If we ﬁlter the high wavenumber components and thus
impose the restriction
|k △x| < 2 π/3
[2/3’s rule]
(15.32)
versus the maximum resolvable wavenumber kmax = π/△x, then
1 ≤α ≤2.4
[First derivative; 2/3’s Rule Filter]
(15.33)
which is almost identical to that for the (unﬁltered) second derivative. The remedy is fa-
miliar because the ﬁlter is the same as the Orszag Two-Thirds Rule (Chapter 11, Sec. 5)
for dealiasing a quadratically nonlinear ﬂow: Filter out the highest one-third of the modes
by setting the large k components equal to zero immediately after taking any Fast Fourier
Transform from grid point values to spectral coefﬁcients.
Canuto et al. (1988, pg. 142–143) describe another alternative: a staggered grid. First or-
der derivatives (both ﬁnite difference and pseudospectral) are evaluated on a set of points
which is shifted from the grid on which u(x) itself is evaluated. The new grid points lie
halfway between the points of the original grid. All the necessary manipulations may be
performed by the FFT. The pre-conditioned eigenvalues are conﬁned to the very narrow
range [1, 1.5708]. The staggered grid is often useful, independent of preconditioning con-
siderations, to cope with the “pressure problem” in wall-bounded viscous ﬂows.
Funaro(1994, 1996) and Funaro and Russo(1993) have described an interesting variation
for convection-diffusion problems where the second derivative coefﬁcients are very small
compared to the ﬁrst derivatives. By using a second collocation grid with an “upwind”
shift, one can obtain a good preconditioner.

15.4. COMPUTING ITERATES: FFT/MATRIX MULTIPLICATION
297
In one dimension, ﬁnite difference (and ﬁnite element) preconditioning is cheap. How-
ever, in two or more dimensions, the LU factorization of ⃗⃗H is expensive. Fortunately, it is
often possible to use a different preconditioning which is much simpler than an “honest”
ﬁnite difference matrix and yet still approximates ⃗⃗Λ in some sense. This strategy — trading
a few extra iterations for a much lower cost per iteration — is the theme of Sec. 15.5.
Another difﬁculty is that some eigenvalues of ⃗⃗A may be complex-valued — systems
of differential equations in complicated, high Reynolds number ﬂows, for example. This
motivates the staggered pseudospectral grid of Hussaini & Zang (1984). One can almost
always ﬁnd a ﬁlter or a grid which will give a narrow range for the span of the eigenvalues
of the pre-conditioned matrix ⃗⃗A.
One technical complication for non-Fourier applications is that the ﬁnite difference
problem must be solved using the same unevenly spaced grid as employed by the pseu-
dospectral method. Fornberg (1988, 1996) describes a simple recursion for computing the
ﬁnite difference weights to all orders for an uneven grid. Alternatively, one can compute
and differentiate the Lagrange polynomial in Maple or Mathematica.
For example, if the grid points are xj, j = 1, 2, . . . , deﬁne
hj ≡xj+1 −xj,
j = 1, 2, . . .
(15.34)
The centered (unstaggered) ﬁnite difference approximations are
du
dx(xj) =
½
−
hj
hj−1(hj−1 + hj)
¾
uj−1 +
½
1
hj−1
−1
hj
¾
uj +
½
hj−1
hj(hj−1 + hj)
¾
uj+1
(15.35)
d2u
dx2 (xj) =
½
2
hj−1(hj−1 + hj)
¾
uj−1 −
½
2
hj−1 hj
¾
uj +
½
2
hj(hj−1 + hj)
¾
uj+1
(15.36)
Canuto et al. (1988) amplify on some of the points made here. They also brieﬂy discuss
ﬁnite element preconditioning.
15.4
Computing the Iterates:
FFT versus Matrix Multiplication
The rate-determining step in the Richardson iteration is the matrix product ⃗⃗Λ⃗u where
⃗⃗Λij ≡a2(xi) Cj,xx(xi) + a1(xi) Cj,x(xi) + a0(xi) Cj(xi)
(15.37)
for a second order ODE where the Cj(x) are the appropriate cardinal functions such that
Cj(xi) = δij. There are two options for evaluating the column vector which is the product
of ⃗⃗Λ with ⃗u. The ﬁrst is a matrix-vector multiply at a cost of about 2N 2 operations per
iteration. (We neglect the set-up cost of computing the elements of ⃗⃗Λ because this is done
only once.)
The alternative uses the Fast Fourier Transform. Note that
⃗⃗Λ⃗u
¶
i
≡a2 uxx + a1 ux + a0 u|x=xi
(15.38)

298
CHAPTER 15. MATRIX-SOLVING METHODS
Figure 15.2: Two methods for evaluating the matrix product ⃗⃗Λ ⃗u
The FFT of ⃗u gives the series coefﬁcients {an}. By differentiating the individual terms in
the spectral series, we obtain (in O(N) operations) the series coefﬁcients for the ﬁrst and
second derivatives.
The differentiation is trivial for a Fourier basis. For a Chebyshev series, one employs a
recurrence. If a(q)
n
denotes the Chebyshev coefﬁcients of the q-th derivative of u(x), then
cn−1 a(q)
n−1 −a(q)
n+1 = 2 n a(q−1)
n
n ≥1
(15.39)
where cn = 2 if n = 0 and cn = 1 for n > 0. Given the N coefﬁcients {a(q−1)
n
}, we initialize
by setting a(q)
N = a(q)
N−1 = 0 and then apply (15.39) in descending order to compute all the
coefﬁcients of the derivative.
Two FFT’s give ux(xi) and uxx(xi). Three multiplications and additions per grid point
complete the calculation of the vector (⃗⃗Λ⃗u). The rate-determining step is the cost of the
three FFT’s, which is only O(7.5N log2 N). The two options are shown schematically in
Fig. 15.2.
As explained in Chapter 10, for low to moderate resolution, matrix multiplication is as
good or better than the FFT. For large N, the FFT is best.
With the FFT and an efﬁcient preconditioning, we can solve a boundary value problem
in any number of dimensions at an expense which is O(total # of grid points) multiplied by
(log2 N) where N is the number of grid intervals in one coordinate.

15.5. ALTERNATIVE PRECONDITIONERS
299
15.5
Alternative Pre-Conditioners for Partial Differential Equa-
tions
In two or more dimensions, Orszag’s (1980) ﬁnite difference preconditioning, here dubbed
⃗⃗HF D, is much more expensive than in one coordinate. A sparse matrix direct method2
such as block tridiagonal elimination costs O(N 4) operations and O(N 3) storage even on a
two-dimensional N × N grid.
Zang, Wong, and Hussaini (1984) therefore experimented with alternatives. Their ⃗⃗HLU
and ⃗⃗HRS, are approximate LU factorizations of ⃗⃗HF D. As in an exact factorization, ⃗⃗L is lower
triangular and ⃗⃗U is upper triangular with diagonal elements all equal to unity.
In their ﬁrst preconditioning, ⃗⃗LLU is the lower triangular part of ⃗⃗HF D. (They do not
factor ⃗⃗HF D, merely identify its diagonal and lower triangular elements as the corresponding
elements of ⃗⃗LLU.) The elements of ⃗⃗ULU are chosen so that the product ⃗⃗LLU ⃗⃗ULU ≡⃗⃗HLU has
its two superdiagonals [elements with column numbers greater than the row numbers]
agree with those of ⃗⃗HF D. Their second approximate factorization is identical except that
the diagonal elements of ⃗⃗L are altered so that the row sums of ⃗⃗HRS equal the row sums of
⃗⃗HF D.
Both approximate factorizations can be computed recursively. For example, let the ﬁnite
difference approximation in two dimensions be of the form
Bjl uj,l−1 + Djl uj−1,l + Ejl ujl + Fjl uj+1,l + Hjl uj,l+1 = fjl
(15.40)
The three non-zero elements of the lower triangular matrix ⃗⃗L are
bjl = Bjl
;
djl = Djl
(15.41)
ejl = Ejl −bjl hj,l−1 −djl fj−1,l −α {bjl fj,l−1 + djl hj−1,l}
(15.42)
where α = 0 for the ﬁrst factorization, ⃗⃗HLU, and α = 1 for the second factorization, ⃗⃗HRS.
The non-zero elements of the upper triangular matrix (aside from the 1’s on the diagonal)
are
fjl = Fjl/ejl
;
hjl = Hjl/ejl
(15.43)
Note that we must march through the grid diagonally from top left to bottom right so that
we calculate the elements of ⃗⃗U before we need them for the computation of the diagonal
elements of ⃗⃗L.
What is striking about (15.41)–(15.43) is that there is no ﬁll-in: the approximate factor-
ization still gives only ﬁve non-trivial coefﬁcients per grid point for ⃗⃗L and ⃗⃗U together. This
is in marked contrast to the exact LU decomposition of ⃗⃗HF D, which can be computed via
the block tridiagonal algorithm: the N × N blocks of the factored ⃗⃗L & ⃗⃗U matrices are dense,
even though the blocks of ⃗⃗HF D are sparse, so that there are roughly 5N non-trivial matrix
2Unless the PDE is separable, in which case we should use the special spectral methods for this class of equa-
tions described in Sec. 15.11.

300
CHAPTER 15. MATRIX-SOLVING METHODS
elements per grid point. Because the ⃗⃗L and ⃗⃗U matrices of the approximate factorizations
are so sparse, the necessary backsolves can be performed in O(N 2) operations — that is to
say, the cost of inverting ⃗⃗HLU or ⃗⃗HRS is directly proportional to the total number of grid
points. This is the best that we could hope for, and implies that inverting ⃗⃗H will not be the
rate-determining part of the iteration since evaluating (⃗⃗Λ⃗u) is always more expensive.
The remaining issue is: How much does incomplete factorization increase the number
of iterations? This is inversely proportional to the “condition number”, κ ≡αmax/αmin.
As shown above, κ ≤2.4 for a second order equation for ﬁnite difference preconditioning.
Tables 15.1 and 15.2, show that κ is much larger for both approximations than for ⃗⃗HF D, and
worse, κ also increases with N.
Table 15.1: Extreme eigenvalues for the two-dimensional Chebyshev discretization of
∇2u = f. (From Zang et al., 1984)
H−1
F D
H−1
LU
H−1
RS
N
αmin
αmax
αmin
αmax
αmin
αmax
4
1.000
1.757
0.929
1.717
1.037
1.781
8
1.000
2.131
0.582
2.273
1.061
2.877
16
1.000
2.305
0.224
2.603
1.043
4.241
24
1.000
2.361
0.111
2.737
1.031
5.379
For calculations on a single grid, ⃗⃗HRS is clearly superior to ⃗⃗HLU. For N = 24, the asymp-
totic convergence rate for ⃗⃗HRS is about 67% of that for the ﬁnite difference preconditioning.
Because it is much cheaper per iteration, approximate factorization can drastically reduce
the cost for boundary value problems in two or more spatial dimensions.
Canuto et al. (1988) observe that these incomplete-LU decompositions are poor on vec-
Table 15.2: Condition Number κ for Preconditioned Chebyshev Operator in Two Dimen-
sions [κ ≡αmax/αmin]
Single-Grid
Multigrid
N
H−1
LU L
H−1
RS L
H−1
LU L
H−1
RS L
4
1.85
1.72
—
—
8
3.91
2.71
1.79
2.07
16
11.62
4.07
2.12
2.92
24
24.66
5.22
2.26
3.79

15.6. RAISING THE ORDER THROUGH PRECONDITIONING
301
tor and parallel machines because they require a lot of recursive [sequential] calculations.
They suggest perhaps ADI-type factorizations might be better, but so far, little has been
done.
Deville and Mund(1984, 1985, 1990, 1991, 1992) and Deville, Mund and Van Kemenade
(1994) and others have shown that ﬁnite elements are also a very effective preconditioner
for spectral methods. One may use ﬁnite elements on triangular elements as the precon-
ditioner even though the spectral approximation is deﬁned on a quadrilateral or a set of
quadrilateral subdomains. The condition number is even smaller than with ﬁnite differ-
ence preconditioning. Furthermore, efﬁcient parallelization of ﬁnite elements is a well-
researched and well-understood task.
We shall not discuss ﬁnite element preconditioning in detail because (i) the principles
are exactly the same as for ﬁnite difference preconditioning and (ii) a detailed treatment
would be too great a digression into ﬁnite elements. This lack of space, however, should not
be interpreted as implying that ﬁnite elements are in any way inferior to ﬁnite differences
for preconditioning.
15.6
Raising the Order Through Preconditioning
In the previous two sections, ﬁnite difference and ﬁnite element methods have been hum-
ble servants of the spectral method. One can also interpret the same preconditioned algo-
rithm from a perspective in which the spectral method is subservient.
Suppose one has a code to solve a boundary value problem using a second order
method. How can one obtain high accuracy without increasing the number of grid points
to a ridiculous extreme? Or even compute a crude answer when the low order scheme
needs more degrees of freedom than will ﬁt in the available memory?
The answer is to write one additional subroutine to evaluate the residual of the bound-
ary value problem using a high order method, such as a pseudospectral algorithm. If we set
up an iteration, repeatedly calling the low order BVP-solver with the output of the high or-
der residual as the inhomogeneous term in the boundary value problem, then the iteration
will converge to an answer of high order accuracy even though all but the residual-evaluator
uses only low order schemes. The overall procedure is identical with the preconditioned
spectral iteration described in the two previous sections.
In chess, the lowly pawn can be promoted to a queen, the most powerful piece, after
reaching the last row of the chessboard. In numerical analysis, preconditioned iterations
provide a way to promote a low order method to spectral accuracy. This promotion does
not require rewriting the low order code or negotiating a thicket of enemy chess pieces. It
merely needs a single subroutine that will take the grid point values of the unknown as
input, and return the residual as the output. The spectral algorithms can be completely
isolated and encapsulated in this single subroutine or module.
From this perspective, EVERY LOW ORDER BVP-SOLVER CONTAINS A SPECTRAL SOLVER
WITHIN IT.
15.7
Multigrid: An Overview
The reason that an un-conditioned Richardson’ iteration is so expensive is that the total
number of iterations,
Niter = T/τ
(15.44)
is large where τ is the time step and where T is the total integration time, that is, the time
required for the solution of the diffusion equation to relax to the steady state. The difﬁculty

302
CHAPTER 15. MATRIX-SOLVING METHODS
is that different components of the ﬂow drive the numerator and denominator of (15.44) in
opposite directions. To see this, consider the forced diffusion equation
ut = uxx + f
(15.45)
with periodic boundary conditions, u(x + 2 π) = u(x).
The time step τ must be very small because the explicit, one-step Euler’s method is
unstable unless
τ <
2
k2max
(15.46)
where kmax is the maximum x wavenumber. This constraint on τ is due to the high wavenum-
bers in the solution.
The time interval T is large because the low wavenumbers decay very slowly:
u = a1(0) e−t cos(x) + b1(0) e−t sin(x) + . . .
(15.47)
so T > 5 is necessary for even two decimal places of accuracy. The total number of itera-
tions, T/τ, is enormous both because the numerator is large and because the denominator
is small.
Multigrid exploits the fact that these two problems — large T, small τ — come from
different parts of the wavenumber spectrum. Since the high wavenumber components
decay very rapidly, the error in the large k Fourier coefﬁcients has disappeared in only a
fraction of the total integration interval. The multigrid principle is simple: throw them
away, and continue the integration with a smaller basis set and a larger time step.
The simplest choice is to halve the maximum wavenumber and quadruple the time step
at each stage because every grid point of the reduced grid is also a part of the original ﬁne
grid. So that each of the high wavenumber Fourier components will decay rapidly, we need
a time-step no larger than one-half the explicit stability limit. If we somewhat arbitrarily
choose to reduce the error in all Fourier components between kmax/2 and kmax by exp(−10),
then we must march 40 time steps with τ = τmin, and we will repeat this pattern of taking
40 time steps at each stage. (Fig. 15.3.)
Let K denote the multigrid iteration level. Then
kmax = 2K
[largest wavenumber at level K]
(15.48)
Table 15.3: A Selected Bibliography of Spectral Multigrid
References
Comments
Zang&Wong&Hussaini(1982,1984)
Incomplete LU factorizations as smoothers
Brandt&Fulton&Taylor(1985)
Periodic problems with meteorological applications
Streett&Zang&Hussaini(1985)
Transonic potential ﬂow (aerodynamics)
Schaffer&Stenger(1986)
sinc (Whittaker cardinal) basis
Phillips&Zang&Hussaini(1986)
Preconditioners
Zang&Hussaini(1986)
Time-dependent Navier-Stokes
Erlebacher&Zang&Hussaini(1988)
turbulence modeling
Nosenchuck&Krist&Zang(1988)
Parallel machine (“Navier-Stokes Computer”)
Heinrichs(1988a)
Line relaxation
Heinrichs(1988b)
Mixed ﬁnite difference and Fourier methods
deVries&Zandbergen(1989)
Biharmonic equation
Heinrichs(1992a)
Stokes ﬂow in streamfunction formulation
Heinrichs(1993c)
Navier-Stokes equation
Heinrichs(1993d)
reformulated Stokes equations

15.7. MULTIGRID: AN OVERVIEW
303
Figure 15.3: Schematic of multigrid iteration for the one-dimensional diffusion equation
with periodic boundary conditions. After a few iterations with shortest time step, τmin, the
coefﬁcients of the upper half of the Fourier series have already converged to their exact
values. We therefore store coefﬁcients 5, 6, 7, and 8 in the column vector which holds the
ﬁnal answer, halve the basis set, increase the time step by four, and resume iterating. Once
wavenumbers 3 and 4 have relaxed to their asymptotic values, we have the basis set and
increase the time step again, and so on.
is the largest wavenumber we keep on the K-th grid (and similarly for the y and z wavenum-
bers),
τ(K) =
1
22K
[time step at level K]
(15.49)
A single grid using τ = τmin requires 64 × 40 = 2560 time steps, and each step would
cost O(Nf) operations where Nf is the total number of grid points on the ﬁnest grid. With
multigrid, we need only 160 time steps [level K = 0 does not ﬁt on the diagram], and the
work is
Ntotal ∼O
µ
40 Nf
½
1 + 1
2 + 1
4 + 1
8
¾¶
operations
(15.50)
since each level uses a grid with only half as many points as its predecessor. The sum
{1 + 1/2 + 1/4 + 1/8 + . . . } is the geometric series which converges to 2. The total cost of
removing the error from all wavenumbers is at worst a factor of two greater than the cost of
relaxing to the correct solution for just the upper half of the wavenumber spectrum. Even
with kmax as small as 8, the savings is a factor of 32. In principle, the multigrid iteration

304
CHAPTER 15. MATRIX-SOLVING METHODS
is cheaper than an unpreconditioned Richardson’s iteration on a single grid by a factor of
O(N 2).
In more realistic problems, variable coefﬁcients in the differential equation couple the
high and low wavenumbers together. This makes it necessary to add a reverse cascade
in K: after the solution has been computed on the coarsest grid, one must interpolate to
a ﬁner grid, apply a few more iterations and repeat. Multigrid subroutines have rather
complicated control structures so that the program can iterate a sufﬁciently large number
of times on each level to ensure a successful transition to the next. It is usually unnecessary
to take 40 steps on each level when both a forward & backward cascade is used; three
iterations per level is more typical, but several ﬁne-to-coarse-to-ﬁne transitions are usual.
The pre-conditioned Richardson’s iteration shares with multigrid the property that the
NUMBER OF ITERATIONS is INDEPENDENT OF THE GRID SIZE. Consequently, it is probably
quite senseless to apply multigrid to a one-dimensional problem. In two dimensions, the
high cost of the ﬁnite difference preconditioning has inspired the approximate factoriza-
tions discussed in Sec. 15.5. Their condition number does increase with N, so multigrid
becomes increasingly superior as the number of grid points increases.
Note that multigrid is not a competitor to Richardson’s iteration or preconditioning.
Rather, multigrid is a strategy for accelerating Richardson’s iteration (with or without pre-
conditioning) or other iterations at the expense of additional programming and storage.
For further information, one can consult Zang, Wong, and Hussaini (1982, 1984), Brandt,
Fulton, and Taylor (1985), and Canuto et al. (1988). A very readable introduction to multi-
grid, although it discusses ﬁnite differences only, is the tutorial by W. Briggs (1987).
15.8
The Minimum Residual Richardson’s (MRR) Method
This improvement of the conventional Richardson’s method, attributed to Y. S. Wong in
Zang, Wong, and Hussaini (1982), has the great virtue that it is a parameter-free algorithm
that does not require guessing the minimum and maximum eigenvalues of the iteration
matrix. Unlike the Chebyshev acceleration of Richardson’s method, the MMR algorithm
does not perform poorly when the matrix has complex eigenvalues.
Indeed, the only
requirement for convergence of the Minimum Residual Richardson’s method is that the
eigenvalues of the (preconditioned) matrix lie strictly in the right half of the complex plane
(Eisenstat, Elman, and Schultz, 1983).
The basic step is identical with that of the preconditioned Richardson’s iteration for
⃗⃗A ⃗u = ⃗g:
⃗un+1 =
µ
⃗⃗I −τ ⃗⃗A
¶
⃗un + τ ⃗g
(15.51)
Like the Chebyshev-accelerated Richardson’s method, the MMR algorithm varies τ to op-
timize the rate of convergence. However, it does not set τ to a ﬁxed value that requires
knowledge of the eigenvalues of ⃗⃗A. Instead, the MRR varies τ on the ﬂy, making a new
choice at each iteration, so as to minimize the residual of the next iterate.
The residual ⃗rn is deﬁned by
⃗rn ≡⃗f −⃗⃗Λ ⃗u
(15.52)
where ⃗⃗Λ is the discretization of the differential operator L and where ⃗f is the array of grid
point values of f(x) in the boundary value problem
L u = f
(15.53)

15.8. MRR METHOD
305
The matrices of the MRR are related to ⃗⃗Λ and ⃗f through the preconditioning matrix ⃗⃗H via
⃗⃗A ≡⃗⃗H
−1 ⃗⃗Λ
(15.54a)
⃗g ≡⃗⃗H
−1 ⃗f
(15.54b)
The goal is to choose τ n so as to minimize the norm of the residual, i. e., create the smallest
possible value of
¡
⃗rn+1, ⃗rn+1¢
(15.55)
To compute the optimum τ, it is helpful to introduce the auxiliary vector
⃗zn ≡⃗⃗H
−1
⃗rn = ⃗⃗H
−1 ⃗f −⃗⃗H
−1⃗⃗Λ ⃗un
(15.56)
It is easy to show (try it!) that
⃗rn+1 = ⃗rn −τ ⃗⃗Λ ⃗zn
(15.57)
The solution to this minimization problem turns out to be the same as that of a series
expansion, so we brieﬂy digress for the following:
Theorem 29 (Mean-Square Minimization with a Truncated Series) Suppose the goal is to
approximate a function f(x) with a truncated series so as to minimize
(Rn, Rn)
(15.58)
where the residual (error) is
RN(x) ≡f(x) −
N
X
n=0
an φn
(15.59)
The choice that minimizes the mean-square error is
an = (f, φn)/(φn, φn)
(15.60)
INDEPENDENT of N so long as the basis functions are orthogonal.
Proof: Substitute the deﬁnition of Rn into (15.58) and then differentiate with respect to each
of the (N + 1) coefﬁcients in turn and set the result equal to 0. (Recall that the condition for
a function of N + 1 variables to be a minimum is that ∂(Rn, Rn)/∂a0 = ∂(Rn, Rn)/∂a1 =
. . . = ∂(Rn, Rn)/∂an = 0.) After the differentiations have been performed, (15.60) is obvi-
ous. QED
Eq. (15.60) is identical with the formula for the coefﬁcients of an inﬁnite series of or-
thogonal functions, (3.24). Although we are not performing a spectral expansion but rather
solving a matrix algebra problem via the MRR, comparison of (15.57) with (15.59) shows
that the minimization problem of choosing the “time step” τ n is identical in form to that of
computing a one-term, mean-square approximation to a function. Here, ⃗rn plays the role of
f(x) and ⃗⃗Λ ⃗zn is the “basis function”, impersonating φ0(x). The choice of τ that minimizes
the residual is therefore
τ n = (⃗rn, ⃗⃗Λ ⃗zn)/(⃗⃗Λ ⃗zn, ⃗⃗Λ ⃗zn)
(15.61)

306
CHAPTER 15. MATRIX-SOLVING METHODS
Deﬁnition 34 (Minimum Residual Richardson’s (MRR) Algorithm)
To solve the matrix problem
⃗⃗Λ ⃗u = ⃗f,
(15.62)
using the preconditioning matrix ⃗⃗H, given a ﬁrst guess u0):
Initialization:
r0
≡
⃗f −⃗⃗Λ u0
(15.63a)
z0
≡
H−1 r0
(15.63b)
and then repeat the following steps until convergence:
Iteration:
τ n
=
(rn, ⃗⃗Λ zn)/(⃗⃗Λ zn, ⃗⃗Λ zn)
(15.64a)
un+1
=
un + τ nzn
(15.64b)
rn+1
=
rn −τ n⃗⃗Λ zn
(15.64c)
zn+1
=
⃗⃗H
−1
rn+1
(15.64d)
The iteration converges as long as the eigenvalues of ⃗⃗H
−1⃗⃗Λ lie strictly in the right half of the complex
plane.
Because the only additional quantity needed at each step is the scalar τ n, which is computed by
two inexpensive inner products, the cost per iteration of the MRR is usually no more than a few
percent greater than that the unmodiﬁed Richardson’s method.
Fig. 15.4, from Canuto and Quarteroni (1985), compares the accuracy of the unmodiﬁed
Richardson’s method with the MRR method. The graphs are clear testimony to the power
of minimizing the residual: four iterations of Richardson’s method reduce the error by no
more than a single MRR iteration.
Both cases are difﬁcult in the sense that the ﬁrst derivative terms are very large so that
Orszag’s estimates for the condition number are too optimistic. (Recall that, following
Orszag, we neglected all derivatives except the highest in estimating the condition num-
ber.) Instead, Canuto and Quarteroni computed the exact condition numbers and used
them to optimize the Richardson’s method.
In real-life where the eigenvalues are not
known, one would try Orszag’s optimal timestep and the Richardson’s iteration would
blow up. Trial-and-error would eventually give a stable τ, but probably not one which is
optimal, so the graphs in Fig. 15.4 make the unmodiﬁed Richardson’s algorithm look better
than it would in practice.
In contrast, the MRR method is parameter-free, so the rapid convergence seen in Fig. 15.4
would always be achieved for these problems. This is particularly important for Case 2,
which is a two-dimensional boundary value problem where the preconditioning matrix
⃗⃗H is an incomplete factorization of the ﬁnite difference matrix, and therefore has a rather
large condition number.

15.9. DELVES-FREEMAN BLOCK-AND-DIAGONAL ITERATION
307
Figure 15.4: Convergence of Richardson’s iteration (dashed) versus the Minimum Resid-
ual Richardson’s method (solid) for two problems.
The y-axis is the logarithm of
q
(⃗r,⃗r )/(⃗f, ⃗f ) where the residual ⃗r ≡⃗f −⃗⃗Λ ⃗u as in the text and (, ) denotes the usual
matrix inner product. Taken from Canuto & Quarteroni (1985). The differential equation is
−[(1 + 10 x) ux]x = f(x). It was solved with 127 grid points on [−1, 1] and f(x) chosen so
the exact solution is u(x) = sin(πx).
15.9
The Delves-Freeman “Asymptotically Diagonal” Pre-
conditioned Iteration
The monograph by Delves and Freeman (1981) and the short review of Delves (1976) an-
alyze an alternative preconditioning which is based on two key ideas. The ﬁrst idea is to
precondition using a low order approximation to the Galerkin matrix. (In contrast, the ﬁnite
difference preconditioner is a low order grid point approximation.)
The second key idea is to exploit the matrix property of being “asymptotically diago-
nal”. Galerkin approximations are usually not “diagonally dominant” in the sense that is
so valuable in iterations for ﬁnite difference methods (Birkhoff and Lynch, 1984). However,
in many cases, the diagonal element of the j-th row of the Galerkin matrix does become
more and more important relative to the other elements in the same row and column as
j →∞. In this sense, the Galerkin matrix is “asymptotically diagonal”.
An example will clarify this concept. Consider the Fourier cosine-Galerkin solution of
uxxxx + q(x) u = f(x)
(15.65)
where u(x), q(x), and f(x) are all smooth, periodic functions symmetric about the origin.
(The symmetry is assumed only for simplicity.) The Galerkin discretization is
⃗⃗H⃗a = ⃗f
(15.66)
where ⃗a is the column vector containing the Fourier cosine coefﬁcients, ai, and
Hij
=
(cos[ix], [∂xxxx + q(x)] cos[jx])
(15.67)
fi
=
(cos[ix], f)
(15.68)

308
CHAPTER 15. MATRIX-SOLVING METHODS
Figure 15.5: Same as Fig. 15.4 except that the differential equation is
−[(1 + 10 x2y2)ux]x −[(1 + 10 x2y2)uy]y = f(x, y)
where f(x, y) is chosen so that the exact solution is u(x, y) = sin(πx) sin(πy).
where
(a, b) =
Z π
0
a(x) b(x) dx
(15.69)
The crucial point is that if we deﬁne
qij ≡(cos[ix], q(x) cos[jx])
(15.70)
then
Hij = j4 δij + qij
(15.71)
where δij is the usual Kronecker delta (=1 if i = j and 0 otherwise). The fourth derivative
contributes only to the diagonal elements and its contribution increases rapidly with the
row or column number. In contrast, the matrix elements of q(x) are O(1) at most3. It follows
that the rows and columns of the Galerkin matrix ⃗⃗H will be increasingly dominated by the
huge diagonal elements as i, j →∞.
Table 15.4 shows the Galerkin matrix for a particular (arbitrary) choice of q(x). To make
the diagonal dominance clearer, it is helpful to deﬁne a rescaled matrix ⃗⃗H via
hij =
Hij
p
Hii Hjj
(15.72)
3Note that |qij| ≤π max |q(x)| since the integral deﬁning these matrix elements is bounded by the maximum
of its integrand, multiplied by the length of the integration interval. This estimate is conservative: The qij for any
smooth q(x) decrease rapidly as either i, j, or both together increase.

15.9. DELVES-FREEMAN BLOCK-AND-DIAGONAL ITERATION
309
Table 15.4: The upper left 8 × 8 block of the Galerkin matrix ⃗⃗H. This particular case is the
Fourier cosine solution of uxxxx + [1 + 10 cosh(4 cos(x) + 0.4)] u = exp(−cos(x)).
i \ j
0
1
2
3
4
5
6
7
0
123.2
56.7
98.2
19.4
21.7
2.9
2.4
0.2
1
56.7
193.6
53.8
84.7
15.8
17.0
2.2
1.8
2
98.2
53.8
154.5
42.2
71.1
13.9
15.4
2.1
3
19.4
84.7
42.2
205.9
40.3
69.5
13.7
15.3
4
21.7
15.8
71.1
40.3
379.3
40.1
69.4
13.7
5
2.9
17.0
13.9
69.5
40.1
748.2
40.1
69.4
6
2.4
2.2
15.4
13.7
69.4
40.1
1419.2
40.1
7
0.2
1.8
2.1
15.3
13.7
69.4
40.1
2524.2
Table 15.5: The upper left 12 × 12 block of the rescaled Galerkin matrix ⃗h, multiplied by
1000.
i \ j
0
1
2
3
4
5
6
7
8
9
10
11
0
1000
367
712
122
100
10
6
0
0
0
0
0
1
367
1000
311
424
58
45
4
3
0
0
0
0
2
712
311
1000
236
294
41
33
3
2
0
0
0
3
122
424
236
1000
144
177
25
21
2
1
0
0
4
100
58
294
144
1000
75
95
14
12
1
1
0
5
10
45
41
177
75
1000
39
51
8
7
1
1
6
6
4
33
25
95
39
1000
21
28
4
4
0
7
0
3
3
21
14
51
21
1000
12
17
3
3
8
0
0
2
2
12
8
28
12
1000
8
11
2
9
0
0
0
1
1
7
4
17
8
1000
5
7
10
0
0
0
0
1
1
4
3
11
5
1000
3
11
0
0
0
0
0
1
0
3
2
7
3
1000

310
CHAPTER 15. MATRIX-SOLVING METHODS
which makes the diagonal elements of ⃗h equal to unity while preserving the symmetry of
the matrix. Table 15.5 shows ⃗h.
Unfortunately, ⃗⃗H is only “asymptotically diagonal” because when the row and column
indices are small, qij is the same order of magnitude as the diagonal elements. Delves and
Freeman (1981) showed that one can exploit “asymptotic diagonality” by partitioning the
Galerkin matrix ⃗⃗H into
⃗⃗H = ⃗⃗HD(M) + ⃗⃗HQ(M)
(15.73)
where ⃗⃗HD(M) is the upper left-hand M × M block of ⃗⃗H plus all the diagonal elements and
⃗⃗HQ contains all the off-diagonal elements outside the upper left M ×M block. When M = 3
and N = 6, for example,
⃗⃗HD =
¯¯¯¯¯¯¯¯¯¯¯¯
H11
H12
H13
0
0
0
H21
H22
H23
0
0
0
H31
H32
H33
0
0
0
0
0
0
H44
0
0
0
0
0
0
H55
0
0
0
0
0
0
H66
¯¯¯¯¯¯¯¯¯¯¯¯
(15.74)
⃗⃗HQ =
¯¯¯¯¯¯¯¯¯¯¯¯
0
0
0
H14
H15
H16
0
0
0
H24
H25
H26
0
0
0
H34
H35
H36
H41
H42
H43
0
H45
H46
H51
H52
H53
H54
0
H56
H61
H62
H63
H64
H65
0
¯¯¯¯¯¯¯¯¯¯¯¯
(15.75)
The Delves-Freeman iteration is then
⃗⃗HD ⃗an+1 = ⃗f −⃗⃗HQ ⃗an
(15.76)
or equivalently
⃗an+1 = ⃗an + ⃗⃗H
−1
D ⃗rn
&
⃗rn = ⃗f −⃗⃗H⃗an
(15.77)
which is identical in form to the preconditioned Richardson’s iteration. (Only the matrices
are different.)
One crucial observation is that because ⃗rn is the residual of the differential equation, we
do not need to explicitly multiply ⃗an by the full Galerkin matrix ⃗⃗H to compute it. Instead
— just as when using the grid point values as the unknowns — the Fast Fourier Transform
can be applied to evaluate ⃗rn indirectly. The cost of computing the residual is the same as
for the ﬁnite difference preconditioning.
To invert ⃗⃗HD(M), write ⃗⃗HD(M) in partitioned block form as
⃗⃗HD =
¯¯¯¯¯
⃗⃗Ω
⃗⃗0
⃗⃗0
⃗⃗Υ
¯¯¯¯¯
(15.78)
where ⃗⃗Ωis an M × M matrix, ⃗⃗Υ is a diagonal matrix whose elements are Υij = Hjjδij, and
the 0’s in (15.78) represent blocks of zeros. Then
⃗⃗H
−1
D =
¯¯¯¯¯¯
⃗⃗Ω
−1
⃗⃗0
⃗⃗0
⃗⃗Υ
−1
¯¯¯¯¯¯
(15.79)

15.9. DELVES-FREEMAN BLOCK-AND-DIAGONAL ITERATION
311
Figure 15.6: Norm of the corrections to the coefﬁcients for the Delves-Freeman iteration for
M = 1, 2, . . . , 8 where M is the size of the upper left block of HD. The top curve (iteration
diverges) is M = 1 (HD is diagonal). The rate of convergence increases monotonically with
M. The ODE is uxxxx + [1 + 10 cosh(4 cos(x) + 4)] u = exp(−cos(x)) [same example as
Tables 15.4 & 15.5]. Fourier cosine basis with N = 32.
where ⃗⃗Υ
−1
is the diagonal matrix whose elements are simply the reciprocals of the diagonal
elements of ⃗⃗H. Thus, the work in (15.79) is the cost of factoring an M × M dense matrix,
which is O([2/3]M 3), plus (N −M) divisions.
Thus, if M ≪N, the cost per iteration is dominated by the O(N log2 N) cost of com-
puting the residual ⃗rn via the Fast Fourier Transform — the same as for ﬁnite difference
preconditioning.
Fig. 15.6 shows that when M = 1 (topmost graph), the iteration diverges. This is strong
proof that the Galerkin matrix is not “diagonally dominant”! For M > 2, however, the
iteration converges geometrically just like all the other variants of Richardson’s method.
The rate of convergence increases rapidly with M, especially when M is small, so it
is a good idea to use a moderate value for M rather than the smallest M which gives
convergence.
The concept generalizes to partial differential equations and other basis sets, too. For ex-
ample, cos(kx) cos(my) is an eigenfunction of the Laplace operator, so the Fourier-Galerkin
representation of
∇2u + q(x, y) u = f(x, y)
(15.80)
is “asymptotically diagonal”. The only complication is that one should use the “speedome-
ter” ordering of unknowns so that the columns and rows are numbered such that the small-
est i, j correspond to the smallest values of
p
i2 + j2.
The Delves-Freeman idea works well with certain non-Fourier basis sets. For example,

312
CHAPTER 15. MATRIX-SOLVING METHODS
Hermite functions ψn(y) satisfy the eigenrelation
d2
dy2 ψn(y) =
£
y2 −(2n + 1)
¤
ψn(y)
(15.81)
The second derivative operator is not diagonal, but its n-dependent part contributes only
to the diagonal. This implies that the Hermite-Galerkin matrix for
uyy + q(y) u = f(y)
(15.82)
is asymptotically diagonal.
Unfortunately, there are complications for the most popular application — Chebyshev
polynomials — because the Chebyshev-Galerkin representation of derivatives is not di-
agonal. With sufﬁcient ingenuity, it is still possible to apply the same general idea or an
extension. For example, in the next section, we show that the Chebyshev solution of
uxx + q u = f(x)
(15.83)
may be converted into the solution of a bordered tridiagonal matrix (for constant q). When
q varies with x, the Galerkin matrix is dense, but “asymptotically tridiagonal”. One can
generalize ⃗⃗HD by replacing the diagonal matrix by a tridiagonal matrix; this block-plus-
tridiagonal matrix is still cheap to invert (Appendix B).
In multiple dimensions with a Chebyshev basis, the natural extension of the Delves-
Freeman method is to iterate using the Galerkin representation of a separable problem. As
explained below in Sec. 15.11, the Galerkin representation of a separable elliptic problem
has, with a little ingenuity, a simple form that allows very cheap iteration. The resulting it-
eration for nonseparable PDEs is preconditioned in spectral space. However, unlike Delves
and Freeman’s simple conception, the low degree basis functions are not treated differently
from the rest of the basis.
In multiple dimensions with a Fourier or spherical harmonics basis, a simple block-
plus-diagonal iteration of Delves and Freeman type may be very effective if the unknowns
are ordered so that the low degree basis functions are clustered in the ﬁrst few rows and
columns.
The Delves-Freeman algorithm can also be extended to nonlinear problems through the
Nonlinear Richardson’s Iteration strategy which is described in Sec. 15.14. Boyd(1997d) is
a successful illustration with a Fourier basis in one space dimension.
The moral of the story is that one can precondition either on the pseudospectral grid
or in spectral space. The residual may be evaluated by the Fast Fourier Transform equally
cheaply in either case. The decision between Orszag’s ﬁnite difference iteration and the
Delves-Freeman Galerkin iteration should be based on which of these choices leads to a
preconditioning matrix, ⃗⃗HD, which is more easily inverted for a given problem.
15.10
Recursions & Formal Integration: Constant Coefﬁcient
ODEs
Clenshaw (1957) observed that for simple constant coefﬁcient differential equations, Cheby-
shev non-interpolating methods generate sparse matrices. It is simplest to illustrate the idea
by example. Consider
uxx −q u = f(x)
(15.84)

15.10. RECURSIONS & FORMAL INTEGRATION: CONSTANT COEFFICIENT ODES313
where q is a constant. The pseudospectral discretization of Eq.(15.84) is dense. In con-
trast, Galerkin’s method (using Chebyshev polynomials as “test” functions, not boundary-
vanishing basis functions) gives a nearly triangular matrix. The reason is that
Tk,xx =
k−2
X
m=0
1
cm
k (k2 −m2) Tm(x)
(15.85)
where cm = 2 if m = 0 and cm = 1 otherwise and where the sum is restricted to poly-
nomials of the same parity as Tk(x). Consequently, (Tm, Tk,xx) = 0 for all m > (k −2).
Unfortunately, the cost of backsolving is still O(N 2). The problem is that the derivative of a
Chebyshev polynomial involves all Chebyshev polynomials of the same parity and lower
degree.
Clenshaw observed that the formula for the integral of a Chebyshev polynomial in-
volves just two polynomials while the double integral involves only three:
Z
Tn(x) dx = 1
2
½Tn+1(x)
n + 1
−Tn−1(x)
n −1
¾
n ≥2
(15.86)
This formula is actually equivalent to (15.39), the recurrence for computing the coefﬁcients
of df/dx from those of f(x). Clenshaw himself exploited (15.39) to manipulate the Galerkin
equations into tridiagonal form, but there are two other ways of obtaining the same result.
One is to apply the Mean-Weighted Residual method using the second derivatives of
the Chebyshev polynomials as the “test” functions. These derivatives are the Gegenbauer
polynomials of second order (as explained in Appendix A), so they are orthogonal, im-
plying that the contributions of the second derivative to the Galerkin’s matrix appear only
on the diagonal, and they are complete, implying that these Gegenbauer polynomials are
legitimate “test” functions. Via recurrence relations between Gegenbauer polynomials of
different orders, Tm(x) may be written as a linear combination of the three Gegenbauer
polynomials of degrees (m −2, m, m + 2) so that the Galerkin matrix has only three non-
zero elements in each row.
The third justiﬁcation — completely equivalent to the ﬁrst two — is to formally inte-
grate the equation twice to obtain
u −q
Z Z
u =
Z Z
f(t) + A + B x
(15.87)
where A and B are arbitary constants determined by the boundary conditions. If we then
demand that (15.87) should be orthogonal to T2(x), . . . , Tn(x), we obtain
an + q
½·
cn−2
4n(n −1)
¸
an−2 −
·
σn
2(n2 −1)
¸
an −
·
σn+2
4n(n + 1)
¸
an+2
¾
(15.88)
=
·
cn−2
4n(n −1)
¸
fn−2 −
·
σn
2(n −1)
¸
fn −
·
σn+2
4n(n + 1)
¸
fn+2
where σn = 1 for n < N −1 and 0 for all larger N and where the fn are the Chebyshev
coefﬁcients of the forcing function, f(x).
The resulting matrix contains two full rows to impose the boundary conditions, so it
is only quasi-tridiagonal. However, the methods for “bordered” matrices (Appendix B)
compute the coefﬁcients an in “roughly the number of operations required to solve penta-
diagonal systems of equations”, to quote Gottlieb & Orszag (1977, pg. 120). Canuto et al.
(1988) give a good discussion of generalizations to other boundary conditions and so on.
Clenshaw and others applied his recursive techniques to many different equations. If
the coefﬁcients are polynomials, the result will again be a banded matrix. If q includes a

314
CHAPTER 15. MATRIX-SOLVING METHODS
term in x2, the matrix is quasi-pentadiagonal. If q has a term in x4, the matrix is quasi-
heptadiagonal, and so on.
The most complete archive of early work is Chapter 5 of Fox & Parker (1968). The
authors point out that Clenshaw’s strategy not only creates sparsity, but also may improve
accuracy. The reason is that the Chebyshev series of a derivative always converges more
slowly than that of u(x) itself. After integration, accuracy is no longer limited by that of
the slowly convergent series for the second derivative, but only by that of u(x) itself.
Of course, as stressed many times above, factors of N 2 are irrelevant for exponentially
convergent approximations when N is large. The extra accuracy and sparse matrices pro-
duced by the double integration are most valuable for paper-and-pencil calculations, or
when N is small. In consequence, these integrate-the-ODE methods have gone rather out
of fashion.
Zebib (1984) is a return to this idea: he assumes a Chebyshev series for the highest
derivative (rather than u(x) itself) and obtains formulas for the contributions of lower
derivatives by applying (15.85). Although this procedure is complicated — especially for
fourth order equations — it both improves accuracy and eliminates very large, unphysical
complex eigenvalues from the Chebyshev discretization of the Orr-Sommerfeld equation
(Zebib, 1987b).
Coutsias, Hagstrom and Torres(1996) have extended Clenshaw’s method to all the stan-
dard orthogonal polynomials including Laguerre and Hermite polynomials. They also pro-
vide useful identities, recursions, and estimates of condition number. Clenshaw’s method
gives banded matrices when the coefﬁcients of the ODE are rational functions as well as
when the coefﬁcients are polynomials. Coutsias et al. show that by changing the coor-
dinate using a rational function, it is possible to resolve narrow boundary layers without
sacriﬁcing a banded matrix representation, as illustrated with numerical examples.
Thus, the integrate-the-ODE methods have a small but useful role in spectral methods
even today.
15.11
Direct Methods for Separable PDE’s
The earliest work on spectral methods for separable PDE’s is Haidvogel and Zang (1979).
They offer two algorithms for exploiting the separability, one iterative and one direct. We
shall discuss only the latter.
The key to the Haidvogel-Zang algorithm is a procedure which can also be applied to
one-dimensional problems, so we will begin with the ODE case. When
[ p(x) ux]x −q u = f(x)
(15.89)
is discretized, it generates the matrix problem
µ
⃗⃗Λx −q⃗⃗I
¶
⃗a = ⃗f
(15.90)
where⃗⃗I is the identity matrix. We could absorb the constant q into ⃗⃗Λx, of course, but have
split it off for future convenience.
If the collocation matrix ⃗⃗Λx is diagonalizable, we can write
⃗⃗Λx = ⃗⃗Ex ˜Λx ⃗⃗E
−1
x
(15.91)

15.11. DIRECT METHODS FOR SEPARABLE PDE’S
315
where ⃗⃗Ex is the matrix whose columns are the n eigenvectors of ⃗⃗Λx and where ˜Λx is the
diagonal matrix whose elements are the corresponding eigenvalues. Eq. (15.90) becomes
⃗⃗Ex (˜Λx −q⃗⃗I ) ⃗⃗E
−1
x ⃗a = ⃗f
(15.92)
Multiplying through by ⃗⃗E
−1
x
gives
(˜Λx −q⃗⃗I ) ⃗⃗E
−1
x ⃗a = ⃗⃗E
−1
x ⃗f
(15.93)
Deﬁne
⃗b ≡⃗⃗E
−1
x ⃗a
;
⃗g ≡⃗⃗E
−1
x ⃗f
(15.94)
Eq. (15.93) becomes the trivial problem
(λi −q) bi = gi
i = 0, . . . , N + 1
(15.95)
After solving (15.95), we obtain ⃗a from⃗b by multiplying the latter by ⃗⃗E.
Once the eigenvectors have been computed (in O[N 3] operations), each solution for
new values of q and/or ⃗f costs only O(6N 2) operations, that is, three multiplications of a
column vector by a square matrix. In the semi-implicit time-stepping algorithm of Orszag
and Patera (1982), this tactic is applied in the radial direction. It minimizes storage over
the more obvious technique of Gaussian elimination because the radial boundary value
problems are identical for different polar and axial wavenumbers except for a different
value of the constant q. Thus, they only need to store two matrices, ⃗⃗Ex and its inverse,
whereas with Gaussian elimination it would be necessary to store a matrix of the same size
for each pair of polar and axial wavenumbers (several hundred in all!).
This trick is also a direct method of attacking two-dimensional separable problems be-
cause the diagonalization still works even if q is a differential operator, not a constant, so long
as the operator involves only the other coordinate, y. If this condition is met, then ⃗⃗Ex and
⃗λx will be independent of y. For example, if
q ≡(s(y) ∂y) ∂y + t(y),
(15.96)
then if we discretize only the x-derivatives, (15.95) becomes a set of (N + 1) uncoupled
ordinary differential equations in y:
[s(y) bi,y]y + [t(y) −λi] bi(y) = −gi(y)
(15.97)
This is precisely what is generated by the analytical method of separation of variables,
applied to the original PDE. The condition that the discretized x-derivative matrix can
be diagonalized independent of y, which demands that the operator q involves only y
derivatives and functions of y, is just the condition that the original problem is separable.
In fact, the Haidvogel-Zang direct method is separation-of-variables.
An obvious question is: Why do we need this post-collocation variant of separation
of variables? The answer is that unless the boundary conditions are spatial periodicity, the
separation-of-variables eigenfunction series will have a slow, algebraic rate of convergence.
To obtain high accuracy, we need Chebyshev polynomials in x.4
4In fairness, sometimes Chebyshev series converge as slowly as eigenseries for time-dependent problems when
the initial conditions fail to satisfy sufﬁcient “compatibility conditions” at the boundaries (Boyd and Flyer, 1998).

316
CHAPTER 15. MATRIX-SOLVING METHODS
One way of looking at the Haidvogel-Zang procedure is that it is a method of solving
the set of (N + 1) coupled ordinary differential equations for the ai by making a “smart”
change-of-basis [in the space of (N + 1)-dimensional column vectors] to a new set of coef-
ﬁcients, the bi, such that the differential equations uncouple.
Solving N ordinary differential equations is still moderately expensive, but for Pois-
son’s equation (or any which is constant coefﬁcient in y), Haidvogel and Zang note that
Clenshaw’s method (previous section!) applies at a cost of N operations per ODE in y.
Thus, after an O(N 3) preprocessing step, we can solve a separable PDE for different f(x, y)
at a cost of O(N 2) per solution. The efﬁciency of the Haidvogel and Zang procedure can be
extended to equations with y-dependent coefﬁcients by using the preconditioned Richard-
son’s iteration as described in earlier sections. (Note that variable x-coefﬁcients are allowed
in either case.)
The preprocessing step, which is a one-dimensional eigenproblem, costs O(N 3) opera-
tions whereas fast direct ﬁnite difference methods require only O(N 2 log2 N) operations
where the tensor product grid has a total of N 2 points. However, on a 1997 personal
computer, the cost of solving an N = 100 one-dimensional eigenproblem was only half
a second! The preprocessing step was expensive in 1979, but not today.
If the separable elliptic problem is part of a semi-implicit time-marching algorithm,
then the cost of the O(N 3) preprocessing step for the spectral method is amortized over
thousands of time steps. The actual cost per time step is merely that for a single backsolve,
which is O(N 2) — directly proportional to the number of grid points — for both spectral
and ﬁnite difference methods.
Haldewang, Labrosse, Abboudi and Deville (1984) compared three algorithms for the
Helmholtz equation. The Haidvogel-Zang strategy is to diagonalize in two dimensions
and solve tridiagonal systems in the other, and proved the fastest. However, Haldewang
et al. found moderately severe roundoff problems with this method, losing ﬁve decimal
digits for N as small as 64.
Full diagonalization (in all three dimensions) was slightly slower but easier to program.
This algorithm became very popular in France and perhaps deserves a wider range of
applications.5
The third algorithm was a ﬁnite difference-preconditioned iteration. This is cheap for
separable problems because the preconditioning can be done using the special “fast direct
methods” for separable problems, which cost only O(N 3 log2(N)) operations on an N 3 grid
in three dimensions.6 The preconditioned iteration was an order of magnitude slower than
the Haidvogel-Zang procedure at all N, but the fast direct ﬁnite difference solver can be
used as a preconditioner for nonseparable problems. The iteration loses little accuracy to
round-off error even at very large N.
Liffman(1996) extended the Haidvogel-Zang eigenanalysis to incorporate very general
(Robin) boundary conditions. This has been widely used by the Nice group under the
name of “matrix diagonalization” since Ehrenstein and Peyret (1989).
Patera (1986) combined the Haidvogel-Zang algorithm with static condensation to cre-
ate a spectral element Poisson-solver with an O(N 5/2) operation count, but this algorithm
has largely been replaced by multigrid.
Siyyam and Syam(1997) offer a Chebyshev-tau alternative to the Haidvogel-Zang tech-
nique. Their experiments show that their method is faster, at least for large N, but their
algorithm has not been extended to PDEs with spatially-varying coefﬁcients.
5Because there are often several algorithms of roughly equal effectiveness for a given problem, numerical
analysis is prone to national and individual fashions that are determined more by accidents of education and
exposure than by rigorous mathematical justiﬁcation.
6The FISHPACK library, written by John Adams and available through the National Center for Atmospheric
Research, is an excellent collection of fast direct methods.

15.12. FAST ITERATIONS FOR ALMOST SEPARABLE PDES
317
Ierley(1997) has developed a similar fast algorithm for the Laplace operator in an arbi-
trary number of space dimensions. One key ingredient is to use Jacobi polynomials rather
than Chebyshev polynomials.
J. Shen (1994a,1995b) and Lopez and Shen(1998) developed Legendre-Galerkin schemes
which cost O(N 3) operations for second and fourth order constant coefﬁcient elliptic equa-
tions. With the basis φj(x) = Lj+2(x) −Lj(x), the weak form of the second derivative
is a diagonal matrix. He developed similar Chebyshev algorithms in Shen(1995a). Both
his Chebyshev and Legendre forms have condition numbers of O(N 4) for fourth order
problems, versus O(N 8) for some other spectral algorithms, so that it is possible to solve
the biharmonic equation with O(500) unknowns in each coordinate to high accuracy. His
Chebyshev algorithm costs O(N 4) for fourth order problems, but Bjørstad and Tjøstheim
(1997) developed an O(N 3) modiﬁcation, and made a number of further improvements in
both Legendre and Chebyshev algorithms for fourth order problems.
Braverman, Israeli, Averbuch and Vozovoi (1998) developed a Poisson solver in three
dimensions which employs a Fourier basis even though the boundary conditions are non-
periodic.
A clever regularization method restores an exponential rate of convergence,
which would normally be lost by non-periodic application of a Fourier series.
15.12
Fast Iterations for Almost Separable PDEs
D’yakonov(1961) and Concus and Golub (1973) noted that non-separable elliptic equations
can be solved very efﬁciently by using an iteration in which a separable differential equa-
tion is solved at each iteration. (Obviously, the coefﬁcients of the separable BVP are chosen
to approximate those of the nonseparable problem as closely as possible.)
Several groups have developed efﬁcient spectral algorithms for nonseparable elliptic
equations using a D’yakonov/Concus-Golub iteration. Guillard and Desideri(1990) com-
bined the Minimum Residual Richardson’s iteration with two different spectral precondi-
tioners that both solved separable problems. The more efﬁcient preconditioner required
computing eigenvalues and eigenvectors in a preprocessing step as in the Haidvogel and
Zang procedure. Strain(1994) solved non-separable periodic problems with a Fourier ba-
sis where the solution of the separable differential equation is almost trivial. Zhao and
Yedlin(1994) showed that the efﬁciency of solve-a-separable-PDE iterations is as good as
multigrid, at least sometimes. Dimitropoulus and Beris (1997) found that the combination
of a Concus-Golub iteration with a fast spectral Helmholtz solver did not always converge
for problems with strongly varying coefﬁcients. However, when this was embedded as an
inner iteration with the biconjugate gradient method, BiCGstab(m), as the outer iteration,
the result was a very robust and efﬁcient algorithm. Typically only two Concus-Golub it-
erations were needed between each outer iteration; the biconjugate gradient method never
needed more than nine iterations.
The title of this section, “almost separable”, is a little misleading. Although these iter-
ations converge most rapidly if the PDE is only a slight perturbation of a separable prob-
lem, the examples of Zhao and Yedlin, Strain, and Dimitropoulus and Beris show that
often the D’yakonov/Concus-Golub algorithm converges very rapidly even when the BVP
only vaguely resembles a separable problem. This is especially true when the iteration is
combined with other convergence-accelerating strategies such as the biconjugate gradient
method used as an outer iteration by Dimitropoulus and Beris.

318
CHAPTER 15. MATRIX-SOLVING METHODS
15.13
Positive Deﬁnite and Indeﬁnite Matrices
As noted in Sec. 2, it is very important that the pseudospectral matrix be positive deﬁnite
because most iterations are analogous to time-integration of the diffusion equation
⃗ut = −⃗⃗Λ ⃗u + ⃗f
(15.98)
where ⃗⃗Λ is the square matrix which is the discretization of the differential operator. If
⃗⃗Λ has only positive eigenvalues, then the solution of (15.98) will decay monotonically to
the desired steady-state which solves ⃗⃗Λ⃗u = ⃗f. However, if ⃗⃗Λ is indeﬁnite, that is, has
eigenvalues of both signs, then the negative eigenvalue modes will grow exponentially
with time and the iteration will diverge.
This would seem to be a very serious restriction because even so simple a problem as
the one-dimensional Helmholtz equation
−uxx −q u = f(x)
u(0) = u(π) = 0
(15.99)
with periodic boundary conditions has the eigenvalues
λn = n2 −q
n = 1, 2, . . .
(15.100)
The lowest eigenvalue is negative for q > 1, two eigenvalues are negative for q > 4, three
for q > 9, and so on. Richardson’s iteration would diverge.
Happily, both preconditioning and multigrid usually solve the problem of a ﬁnite num-
ber of small eigenvalues of the wrong sign. The reason that preconditioning is effective
is that the offending modes are the ones with the simplest spatial structure. If q = 8,
for example, only the modes sin(x) and sin(2x) are unstable. However, these modes are
precisely the ones which will be accurately resolved by both the ﬁnite difference and pseu-
dospectral approximations. Consequently, sin(x) and sin(2x) (or more precisely, the col-
umn vectors containing the grid point values of these functions) are both eigenvectors of
the pre-conditioned matrix ⃗⃗H
−1⃗⃗Λ with eigenvalues approximately equal to 1.
There is a snare: when q is very close to n2, one eigenvalue of ⃗⃗Λ may be very, very close
to zero — smaller in magnitude than the small error in the ﬁnite difference approximation
of this same mode. Canuto et al. (1988, pg. 143) show that the pre-conditioned eigenvalue
is
λ(p)
n
=
n2 −q
n2 sin2(n △x/2)/(n △x/2)2 −q
(15.101)
For ﬁxed q & n, λn(p) →1 in the limit △x →0. However, for ﬁxed △x, there is always
a range of q sufﬁciently close to n2 so that λ(p)
n
is negative and Richardson’s iteration will
then diverge for any time step.
Since the grid spacing △x always is small, one has to be rather unlucky for a pre-
conditioned iteration to diverge, but clearly, it can happen. It is encouraging, however,
that preconditioning will remove the problem of matrix indeﬁniteness most of the time.
Multigrid is intrinsically just an efﬁcient way of performing Richardson’s iteration. It
will therefore diverge due to matrix indeﬁniteness whenever Richardson’s would, too.
However, a common practice in multigrid — even when the matrix is positive deﬁnite — is
to apply Gaussian elimination instead of iteration on the coarsest grid. The obvious reason
is that when the coarse grid contains only nine points, Gaussian elimination is ridiculously

15.13. POSITIVE DEFINITE AND INDEFINITE MATRICES
319
cheap. The subtle, empirical reason is that using direct methods on the coarsest grid seems
to give additional stability and improved convergence rate to the whole iteration.
When the matrix is indeﬁnite but has only one or two negative eigenvalues, this practice
of Gaussian elimination on the coarsest grid is a life-saver. Although the coarse grid cannot
resolve the high modes of the operator, it can resolve — at least crudely — the lowest one
or two modes which (otherwise) would make the iteration diverge.
A little care is needed. If there are several unstable modes, one needs a coarsest grid
which has at least a moderate number of points.
There is, alas, a small class of problems for which neither multigrid nor precondition-
ing will help: those with an inﬁnite number of eigenvalues of negative sign. An example is
Laplace’s Tidal equation for waves in a semi-inﬁnite atmosphere (Chapman and Lindzen,
1970). The tidal equation is very messy because it includes complicated trigonometric
terms due to the earth’s sphericity. However,
uyy + (ω2 −y2) uzz = f(y, z)
(15.102)
u(±L, z) = 0
&
u(y, 0) = 0
&
u(y, z) bounded as z →∞
(15.103)
displays the same qualitative behavior.
Separation-of-variables gives the latitudinal eigenequation
uyy + λ (ω2 −y2) u = 0,
(15.104)
the parabolic cylinder equation. If the boundary L > ω, then (15.104) has an inﬁnite num-
ber of solutions with positive eigenvalues. The eigenmodes oscillate on y ∈[−ω, ω] and
decay exponentially for larger y; they may be accurately approximated by Hermite func-
tions (as is also true of the corresponding tidal modes). The vertical structure of these
modes is oscillatory.
There is also an inﬁnite number of modes with negative eigenvalues. These oscillate on
the intervals y ∈[−L, −ω] & y ∈[ω, L] and are exponentially small at y = 0. These modes
decay exponentially as z →∞.
Eq. (15.102) is rather peculiar: an equation of mixed elliptic-hyperbolic type. The bound-
ary conditions are also a little peculiar, too, in that either oscillatory or exponential behavior
is allowed as z →∞. Nevertheless, the linear wave modes of a rotating, semi-inﬁnite at-
mosphere are described by a mixed elliptic-hyperbolic equation similar to (15.102), and the
modes really do fall into two inﬁnite classes: one with λ > 0 and the other with λ < 0.
No iterative method has ever been successfully applied to these problems. Lindzen (1970),
Schoeberl & Geller (1977) and Forbes & Garrett (1976) have all obtained good results by
combining ﬁnite differences with banded Gaussian elimination.
Navarra(1987) combined ﬁnite differences in z with spherical harmonics in latitude. By
applying Arnoldi’s matrix-solving iteration, Navarra solved mixed-type boundary value
problems with as many as 13,000 unknowns.
In principle, indeﬁniteness may be cured by squaring the matrix, i. e.
⃗⃗Λ
T ⃗⃗Λ u = ⃗⃗Λ
T
f
(15.105)
where superscript “T” denotes the matrix transpose. The disadvantage of matrix-squaring
is that if the condition number of ⃗⃗Λ is O(N 2), then the condition number of the positive
deﬁnite matrix ⃗⃗Λ
T ⃗⃗Λ is O(N 4).
However, we have already seen that preconditioning is strongly recommended even
for the unsquared matrix. For ⃗⃗Λ and ⃗⃗Λ
T ⃗⃗Λ, ﬁnite difference preconditioning will give a

320
CHAPTER 15. MATRIX-SOLVING METHODS
condition number for the squared matrix which is O(1), independent of N. This tactic of
squaring the matrix should work even for the difﬁcult case of the Laplace Tidal equation,
provided that none of its eigenvalues are too close to zero7.
What if ⃗⃗Λ has complex eigenvalues? First, the transpose in (15.105) should be interpreted
as the Hermitian adjoint. Second, the Chebyshev acceleration of Richardson’s iteration (ﬁrst
edition of this book) should be avoided unless the imaginary parts are small. The Richard-
son’s iteration, with or without preconditioning, will still converge rapidly as long as the
real parts of the eigenvalues are all positive, and better still, so will its Minimum Residual
(MRR) variant. The imaginary parts of the λj simply mean that the decay will be oscillatory
instead of monotonic for some or all of the eigenmodes.
Alas, even squaring the matrix won’t help when the difﬁculty, as for the Helmholtz
equation (15.99), is an eigenvalue which is approximately zero. (Squaring the matrix makes
the corresponding eigenvalue even smaller!) Still, the conclusion is that iterative methods
can be applied — with a little care — to the vast majority of real-life problems including
those with eigenvalues of both signs.
15.14
Nonlinear Iterations & the Preconditioned Newton Flow
The usual strategy to solve a nonlinear boundary value or eigenvalue problem is, after
discretization, to apply Newton’s iteration. When the linear matrix problems of each New-
ton iteration are themselves solved by iteration, it is often desirable to avoid an iteration-
within-an-iteration by combining Newton’s iteration and the preconditioned Richardson’s
iteration into a single step. To do so, it is useful to employ a conceptual device that we used
to motivate Richardson’s method: interpreting an iteration as the temporal discretization
of a time-dependent problem8.
Newton’s iteration for the system of N equations
⃗r (⃗u) = 0
(15.106)
is
⃗⃗J(⃗un+1 −⃗un) = ⃗r(⃗un)
(15.107)
where ⃗⃗J is the usual Jacobian matrix whose elements are
Jij = ∂ri
∂uj
¯¯¯¯
⃗u=⃗un
(15.108)
This is identical with the result of integrating the system of differential equations
d⃗u
dT = −
Ã
1
⃗⃗J
!
⃗r
[“Newton ﬂow” equation]
(15.109)
by the Euler forward method with unit step in the pseudotime, T.
If we expand ⃗r(⃗u) in an N-dimensional Taylor series centered on a root ⃗u0, then (15.109)
becomes locally
d⃗u
dT
=
−1
⃗⃗J
·
⃗r(⃗u0) + ⃗⃗J(⃗u −⃗u0) + O
¡
(⃗u −⃗u0)2¢¸
(15.110)
=
−(⃗u −⃗u0) + O
¡
(⃗u −⃗u0)2¢
(15.111)
7To minimize the condition number, one should solve (15.105) as the system ⃗⃗Λy = f, ⃗⃗Λ
T
x = y.
8Chu(1988) is a good review of other examples of “Continuous realizations of Iterative Processes”, to quote
his title.

15.14. PRECONDITIONED NEWTON FLOW
321
In the language of the theory of differential equations, (15.111) is a linearization of the
nonlinear system about a critical point. The linearization shows that every root of ⃗r(⃗u) = 0
is a local attractor. The exact “Newton ﬂow” converges geometrically on the root since one
can prove without approximation that
⃗r(⃗u[T]) = e−T⃗r(⃗u[0])
(15.112)
Newton’s iteration actually converges much faster than (15.112); the number of correct
digits roughly doubles with each iteration. The reason for the faster convergence is that
if we ignore the quadratic terms in (15.111), Euler’s method with unit time step reduces
(⃗u −⃗u0) to 0 instead of to 36%(= exp(−1)) of its initial value. Thus, poor accuracy in
time integration brings us to the root faster than solving the Newton ﬂow accurately in
pseudotime.
Unfortunately, Newton’s method requires inverting the Jacobian matrix at each time
step. When ⃗r(⃗u) = 0 is the pseudospectral discretization of a differential equation, the
Jacobian matrix is dense and costly to invert.
Fortunately, if the Newton ﬂow is modiﬁed by replacing the inverse-Jacobian matrix by
a matrix which is nonsingular at the roots of ⃗r(⃗u), but is otherwise arbitrary, the roots of
⃗r(⃗u) are still critical points of the differential equation.
Not all approximations of the Jacobian matrix will succeed because the modiﬁcations
may turn some roots from attractors into repellors. Suppose, however, the inverse-Jacobian
is replaced by the inverse of a preconditioning matrix:
d⃗u
dT = −1
⃗⃗H
⃗r(⃗u)
[“Pre-conditioned Newton ﬂow”]
(15.113)
Linearization near a root gives
d⃗u
dT = −⃗⃗H
−1⃗⃗J(⃗u −⃗u0) + O
¡
(⃗u −⃗u0)2¢
(15.114)
Orszag (1980) showed that if ⃗⃗H is the ﬁnite difference approximation to ⃗⃗J, then all the
eigenvalues of (1/⃗⃗H)⃗⃗J will lie on the interval α ∈[1, 2.47] (as already explained in Sec. 4). If
the error (⃗u −⃗u0) is decomposed into the eigenvectors of (1/⃗⃗H)⃗⃗J, then the error in different
components must decay at rates ranging between exp(−T) and exp(−2.47 T).
Because of these varying rates of decay, it is not possible to ﬁnd a magic time step that
will keep the quadratic, digit-doubling convergence of Newton’s iteration. However, the
Euler forward scheme does give very rapid convergence: with a time step of 4/7, one can
guarantee that each component of the error will decrease by at least a factor of 2.33 at each
iteration — just as fast as for a linear problem. Since the ﬁnite difference matrix can be
inverted in O(1/N 2) of the cost for inverting the pseudospectral Jacobian where N is the
number of basis functions in each dimension, the preconditioned Newton ﬂow is much
cheaper than the classical Newton’s iteration.
The iterative form of (15.114) is
⃗⃗H(⃗un+1 −⃗un) = −τ ⃗r(⃗un)
[Nonlinear Richardson Iteration]
(15.115)
where ⃗⃗H is any acceptable preconditioning matrix for the Jacobian matrix and τ is the pseu-
dotime step. It is appropriate to dub (15.115) the “Nonlinear Richardson Iteration” because
it reduces to the standard Richardson iteration whenever ⃗r is a linear function of ⃗u.
This “preconditioned Newton ﬂow” derivation of (15.115) is taken from Boyd (1989a),
but the same algorithm was independently invented through different reasoning in the

322
CHAPTER 15. MATRIX-SOLVING METHODS
technical report by Streett and Zang (1984)9. Eq. (15.115) has probably been re-invented
half a dozen times.
Simple though it is, the Nonlinear Richarson’s Iteration (NRI) is very useful. It is silly
and expensive to apply Richardson’s iteration to solve the linearized differential equations
of a strict Newton method; one is then wasting many iterations to converge on an interme-
diate Newton iterate which is of no physical interest. With (15.115), every iteration reduces
the nonlinear residual and brings us closer to the root.
Numerical examples are given in Boyd (1989a).
15.15
Summary & Proverbs
MORAL PRINCIPLE #1: Never solve a matrix using anything but Gaussian elimination
unless you really have to.
This may seem strange advice to conclude a chapter mostly on iterative methods. Nev-
ertheless, it is more than a little important to remember that there are no style points in
engineering. Iterative methods, like mules, are useful, reliable, balky, and often infuriat-
ing. When N is small enough so that Gaussian elimination is practical, don’t fool around.
Be direct!
Note further that for constant coefﬁcient ordinary differential equations and for sepa-
rable partial differential equations, Galerkin/recurrence relation methods yield sparse ma-
trices, which are cheap to solve using Guassian elimination.
MORAL PRINCIPLE #2: Never apply an iteration without ﬁrst preconditioning it.
Well, almost never. However, un-preconditioned iterations converge very slowly and
are much less reliable because a single eigenvalue of the wrong sign will destroy them.
MORAL PRINCIPLE #3: Never use multigrid as a purely iterative method; apply Gaussian
elimination on the coarsest grid.
Besides being the difference between convergence and divergence if the matrix is indef-
inite, elimination on the coarsest grid seems to improve the rate of convergence even for
positive deﬁnite matrices.
Good, reliable iterative methods for pseudospectral matrix problems are now available,
and they have enormously extended the range of spectral algorithms. Iterations make it
feasible to apply Chebyshev methods to difﬁcult multi-dimensional boundary value prob-
lems; iterations make it possible to use semi-implicit time-stepping methods to computed
wall-bounded ﬂows. Nevertheless, this is still a frontier of intense research — in part be-
cause iterative methods are so very important to spectral algorithms — and the jury is still
out on the relative merits of many competing strategies. This chapter is not the last word
on iterations, but only a summary of the beginning.
9See also Canuto et al. (1988, pg. 390).

Chapter 16
The Many Uses of Coordinate
Transformations
“There are nine and sixty ways of constructing tribal lays”
— R. Kipling, In the Neolithic Age
16.1
Introduction
A change of coordinates is a popular tool in elementary calculus and physics. Such trans-
formations have an equally important role in spectral methods. In the next section, the
Chebyshev polynomial-to-cosine change-of-variable greatly simpliﬁes computer programs
for solving differential equations.
However, there are many other uses of mapping. In this chapter, we concentrate on
one-dimensional transformations, whose mechanics is the theme of Sec. 3. In Sec. 4, we
show how inﬁnite and semi-inﬁnite intervals can be mapped to [-1, 1] so that Chebyshev
polynomials can then be applied. When the ﬂow has regions of very rapid change —
near-singularities, internal boundary layers, and so on — maps that give high resolution
where the gradients are large can tremendously improve efﬁciency. We discuss a number of
speciﬁc cases in Secs. 5-7. In Sec. 8, we discuss two-dimensional mappings and singularity
subtraction for coping with “corner” singularities. Finally, in the last part of the chapter, we
give a very brief description of the new frontier of adaptive-grid pseudospectral methods.
16.2
Programming Chebyshev Methods
The Chebyshev polynomials can be computed via the 3-term recurrence relation
T0 ≡1
;
T1 ≡x
Tn+1 = 2 x Tn −Tn−1
n = 1, . . . .
(16.1)
This is numerically stable, and the cost is O(N) to evaluate all the polynomials through
TN at a given x. Since the derivatives of the Chebyshev polynomials are Gegenbauer poly-
nomials, it follows that we can evaluate these derivatives via three-term recurrences, too
323

324
CHAPTER 16. COORDINATE TRANSFORMATIONS
(Appendix A). Indeed, through a similar three-term recurrence derived from (16.1), (Fox &
Parker, 1968 and Boyd, 1978a), we can sum a Chebyshev series in O(N) operations without
evaluating the individual Tn.
As simple and effective as these recurrences are, however, it is often easier to exploit
the transformation
x = cos(t)
(16.2)
which converts the Chebyshev series into a Fourier cosine series:
Tn(x) ≡cos(nt)
(16.3)
By using the tables given in Appendix E, we can easily evaluate the derivatives of the
Chebyshev polynomials directly in terms of derivatives of the cosine and sine. For example
dTn(x)
dx
= n sin(nt)
sin(t)
(16.4)
This is just the trigonometric representation of n Un−1(x) where Un(x) is the Chebyshev
polynomial of the second kind deﬁned in Appendix A. Similarly
d2Tn(x)
dx2
=
1
sin3(t)
©
sin(t)
£
−n2 cos(nt)
¤
−cos(t) [−n sin(nt)]
ª
(16.5)
Table 16.1 is a short FORTRAN subroutine that computes the n-th Chebyshev polynomial
and its ﬁrst four derivatives. Its simplicity is remarkable.
One modest defect of (16.4) and (16.5) is that the denominators are singular at the end-
points. However, this is irrelevant to the Chebyshev “roots” grid because all grid points
are on the interior of the interval. The problem also disappears for the “extrema” (Gauss-
Lobatto) grid if the boundary conditions are Dirichlet, that is, do not involve derivatives.
When boundary derivatives are needed, one must modify the subroutine in Table 16.1
by adding an IF statement to switch to an analytical formula for the endpoint values of the
Chebyshev derivatives of all orders:
(i)
d
dx Tn(x) = n Un−1(x)
(16.6)
(ii)
dp Tn
dxp
¯¯¯¯
x=±1
= (±1)n+p
p−1
Y
k=0
n2 −k2
2 k + 1
(16.7)
Instead of using formulas like (16.3) to (16.5) to compute in the original coordinate x,
one may alternatively convert the original problem into an equivalent differential equa-
tions on t ∈[0, π] and then solve the result using a Fourier cosine series. For example,
uxx −q u = f(x)
u(−1) = u(1) = 0
x ∈[−1, 1]
(16.8)
becomes
sin(t) utt −cos(t) ut −q sin3(t) u = sin3(t) f(cos[t])
(16.9)
u(0) = u(π) = 0
t ∈[0, π]
Which of these two forms is simpler is a matter of taste. My personal preference is to
solve the problem in x, burying the trigonometric formulas in the subroutines that evaluate
derivatives.

16.3. THEORY OF 1-D TRANSFORMATIONS
325
Table 16.1: A sample subroutine to compute the Chebyshev polynomials and their deriva-
tives via the derivatives of the cosine functions.
SUBROUTINE BASIS(N,X,TN,TNX,TNXX,TNXXX,TNXXXX)
C
INPUT: X
(on interval [-1, 1] )
C
OUTPUT:
TN, TNX, TNXX, TNXXX, TNXXXX are the N-th Chebyshev
C
polynomials and their first four derivatives.
C
T is the trigonometric argument (on interval [0, pi]).
T = ACOS(X)
TN = COS(FLOAT(N)*T)
C
Derivatives of cos(Nt) with respect to t:
PT = - FLOAT(N) * SIN(FLOAT(N)*T)
PTT = - FLOAT(N)*FLOAT(N) * TN
PTTT = - FLOAT(N)*FLOAT(N) * PT
PTTTT = - FLOAT(N)*FLOAT(N) * PTT
C = COS(T)
S = SIN(T)
C
Conversion of t-derivatives into x-derivatives
TNX
= - PT / S
TNXX
= ( S*PTT - C * PT) / S**3
TNXXX
= (-S*S*PTTT + 3.*C*S*PTT - (3.*C*C + S*S) * PT )/S**5
TNXXXX = (S*S*S*PTTTT-6.*C*S*S*PTTT+(15.*C*C*S+4.*S*S*S) * PTT
1
- (9.*C*S*S+15.*C*C*C) * PT ) / S**7
RETURN
END
16.3
The General Theory of One-Dimensional Coordinate
Transformations
Let y denote the original coordinate and x the new variable where the two are related by
y = f(x)
(16.10)
Elementary calculus shows
d
dy =
1
f ′(x)
d
dx
(16.11)
where f ′ ≡df/dx. By iterating this formula, we obtain the formulas for higher deriva-
tives listed in Table E–1 in Appendix E. The remainder of that appendix is a collection of
derivative tables, generated via the computer language REDUCE, for several particular
mappings.
When a Fourier cosine series is mapped so as to create a new basis set, the orthogonality
relationship is preserved:
Z π
0
cos(mx) cos(nx) dx ≡
Z f(π)
f(0)
φm(y) φn(y)
f ′ (f −1[y]) dy;
(16.12)

326
CHAPTER 16. COORDINATE TRANSFORMATIONS
The Gaussian quadrature formula for the new interval with the ﬁrst-derivative-of-the-
inverse-of-f weight is simply the image of the rectangle rule or trapezoidal rule under the
mapping: the abscissas are unevenly spaced because of the change of coordinates, but the
quadrature weights are all equal.
To have the machinery for transforming derivatives is one thing; to know which map-
pings are useful for which problems is another. In the remainder of this chapter, we offer a
variety of illustrations of the many uses of mappings.
16.4
Inﬁnite and Semi-Inﬁnite Intervals
When the computational interval is unbounded, a variety of options are available, and
only some of them require a change-of-coordinate as discussed in much greater detail in
the next chapter. For example, on the inﬁnite interval y ∈[−∞, ∞], Hermite functions
or sinc (Whittaker cardinal) functions are good basis sets. On the semi-inﬁnite domain,
y ∈[0, ∞], the Laguerre functions give exponential convergence for functions that decay
exponentially as |y| →∞.
A second option is what we shall dub “domain truncation”: solving the problem on
a large but ﬁnite interval, y ∈[−L, L] (inﬁnite domain) or y ∈[0, L] (semi-inﬁnite) using
Chebyshev polynomials with argument (y/L) or (L/2)[1+y] ), respectively. The rationale is
that if the solution decays exponentially as |y| →∞, then we make only an exponentially-
small-in-L error by truncating the interval. This method, like the three basis sets mentioned
above, gives exponentially rapid convergence as the number of terms in the Chebyshev
series is increased.
However, there is a complication. If we ﬁx L and then let N →∞, the error in approxi-
mating u(x) on x ∈[−L, L] — call this the “series” error, ES — decreases geometrically fast
with N. Unfortunately, this is not the only source of error. The “domain truncation error”,
EDT (L), arises because u(±L) has some ﬁnite, non-zero value, but we imposed u(±L) = 0
on the numerical solution. It follows that to drive the total error (= ES + EDT ) to zero, we
must simultaneously increase both L and N. This in turn implies that the rate of decrease of
the total error with N is “subgeometric”. A full discussion is in Boyd (1982a).
The third option, and the only one that is strictly relevant to the theme of this chapter,
is to use a mapping that will transform the unbounded interval into [-1, 1] so that we
can apply Chebyshev polynomials without the artiﬁciality of truncating the computational
interval to a ﬁnite size. A wide variety of mappings are possible; an early paper by Grosch
and Orszag (1977) compared
y = −L log(1 −x)
“Logarithmic Map”
y ∈[0, ∞]
(16.13)
y = L(1 + x)/(1 −x)
“Algebraic Map”
x ∈[−1, 1]
(16.14)
The logarithmic map stretches the semi-inﬁnite interval so strongly that for a function
which decays exponentially with |y|, the change-of-coordinate creates a branch point at
x = 1 — and a Chebyshev series that converges rather slowly. Grosch and Orszag (1977)
and Boyd (1982a) offer compelling theoretical arguments that logarithmic maps will al-
ways be inferior to algebraic maps in the asymptotic limit N →∞. Paradoxically, however,
some workers like Spalart (1984) and Boyd (unpublished) report good results with an ex-
ponential map. The resolution of the paradox is (apparently) that exponentially-mapped
Chebyshev series approach their asymptotic behavior rather slowly so that for N ∼O(50)
or less, they may be just as good as algebraic maps.
Nevertheless, we shall discuss only algebraic maps here; more general maps are dis-
cussed in the next chapter. The logarithmic change-of-coordinate is like a time bomb — it
may not blow up your calculation, but theory shows that it is risky.

16.5. MAPS FOR ENDPOINT & CORNER SINGULARITIES
327
Like domain truncation and Hermite and Laguerre functions, algebraic mapping will
give exponential-but-subgeometric convergence if the function has no singularities on the
expansion interval except at inﬁnity and decays exponentially fast as y →∞.
The algebraic mapping (16.14) converts the Chebyshev polynomials in x into rational
functions in y, dubbed the TLn(y), deﬁned by
TLn(y) ≡Tn
µy −L
y + L
¶
(16.15)
It may seem a little pretentious to introduce a new symbol to represent these “rational
Chebyshev functions on the semi-inﬁnite interval” when they are merely Chebyshev poly-
nomials in disguise. However, that the Chebyshev polynomials themselves are merely
cosine functions in masquerade. We can alternatively deﬁne the “rational Chebyshev func-
tions” via
TLn
¡
L cot2 [t/2]
¢
≡cos(nt)
(16.16)
It follows that just as in Sec. 2, we can evaluate the derivatives of the TLn(y) in terms of
those of cos(nt) by using the transformation formulas given in Table E–6. The pseudospec-
tral grid points are simply the images under the map yi = L cot2(ti/2) of the evenly spaced
roots in t. (The Gauss-Lobatto or “extrema” grid is inconvenient because the mapping is
singular at the endpoints.) Thus, it is quite trivial to write programs to solve problems on
an unbounded interval.
We must not forget, however, that even though we may prefer to write our program to
solve the trigonometric version of the problem via a Fourier cosine series, the end result is
a series for u(y) as a sum of orthogonal rational functions, the TLn(y). The mapping has
interesting and important consequences discussed in Chap. 17. The key both to writing the
program and to understanding the subtleties of inﬁnite and semi-inﬁnite domains is the
change of coordinates.
16.5
One-Dimensional Maps to Resolve Endpoint & Corner
Singularities
The function
g(X) ≡
p
1 −X2
(16.17)
is bounded everywhere on X ∈[−1, 1], but because of the branch points, its Chebyshev
series converges with an algebraic convergence index of two:
p
1 −X2 = 2
π
(
1 −
∞
X
n=1
2
4n2 −1 T2n(X)
)
(16.18)
Throughout this section, we will assume that the singularities at the endpoints are “weak”
in the sense that the function is bounded at the endpoints.
Stenger (1981) pointed out that a mapping of X ∈[−1, 1] to y ∈[−∞, ∞] would heal
such “weak” endpoint singularities if and only if dX/dy decays exponentially fast as |y| →
∞. The grid spacing in the original coordinate, δX, is related to the grid spacing in y by
δX ≈dX
dy δy.
(16.19)

328
CHAPTER 16. COORDINATE TRANSFORMATIONS
The exponential decay of dX/dy implies a nearest neighbor separation near X = ±1 which
decreases exponentially with N, the number of grid points.
For example, under the mapping
X
=
tanh(y)
(16.20)
g(X)
=
q
1 −tanh2[y]
(16.21)
=
sech(y)
(16.22)
using the identity sech2(y) = 1 −tanh2(y). In startling contrast to its preimage, sech(y) is a
remarkably well-behaved function. Stenger (1981) shows that the sinc expansion of sech(y)
on y ∈[−∞, ∞] has subgeometric but exponential convergence with exponential index of
convergence r = 1/2. Boyd (1986a) shows that a Hermite series also has r = 1/2, but with
even faster convergence. A rational Chebyshev basis, TBj(y), also gives subgeometric
convergence.
The key is the tanh mapping (16.20); the choice of inﬁnite interval basis is secondary.
Table V of Boyd (1987a) shows that the sum of the ﬁrst sixteen symmetric TBn(arctanh[X])
gives an error of no more than 1 part in 300,000 for the approximation of
√
1 −X2. By
contrast, the same table shows that the error in the unmapped Chebyshev series (16.18)
to the same order is 1/50. The derivatives of sech(y) are all bounded (in fact, 0!) at the
endpoints whereas all derivatives of
√
1 −X2, even the ﬁrst, are unbounded.
The solutions to partial differential equations on domains with corners may have weak
singularities; the classic example is
∇2u = −1
(16.23)
on the square [−1, 1] × [−1, 1] with u ≡0 on all four walls. The solution has branch points
of the form
u = r2 log(r) sin(2θ) + less singular terms
(16.24)
near all four corners where r and θ are the radial and angular coordinates in a local polar
coordinate system centered on a particular corner. Stenger (1979) obtained ﬁve decimal
place accuracy for (16.23) using the mapping (16.20) (for both coordinates) plus a 33×33
grid with sinc functions. Thus, although a corner singularity would seem to cry out for
a two-dimensional mapping (as discussed later in this chapter), a simple tensor product
grid with the one-dimensional tanh-map applied independently to both x and y is usually
sufﬁcient.
One caveat is in order: when the singularity is weak, the branch point may be irrelevant
unless one needs many decimal places of accuracy. For Poisson’s equation, for example, the
corner branch points still permit an algebraic index of convergence of six — much weaker
than the square root, which gives an index of two. The result is that Boyd (1986c) found
that it was possible to match Stenger’s accuracy with only 136 basis functions of the proper
symmetry and no mapping.
Boyd (1988d) has elaborated this point by showing that there is a “cross-over” in N:
for smaller N, the mapping induces variable coefﬁcients in the differential equation, which
slow convergence, but for N > Ncross-over, the mapping reduces error. It is important to
apply asymptotic concepts asymptotically!
Nevertheless, it is gratifying that exponential mapping gives an “inﬁnite order” method
not only for approximating functions with weak endpoint singularities, but also for solving
differential equations — even though these solutions have unbounded derivatives in the

16.6. TWO-DIMENSIONAL MAPS & CORNER BRANCH POINTS
329
original coordinate. If the singularity is weak, try it ﬁrst without a mapping. If this fails, or
if the singularity is strong, i. e. produces an algebraic index of convergence of three or less,
apply a change-of-coordinate such that the original coordinate varies exponentially fast
with the new, computational coordinate. Lund and Riley (1984), Lund (1986), and Boyd
(1987a, 1988c) give further examples.
16.6
Two-Dimensional Maps & Singularity-Subtraction for
Corner Branch Points
A classic test for corner singularity-resolving algorithms is to compute the eigenvalues of
the so-called “L-shaped domain membrane” problem. The domain is the interior of the
region which is composed of three adjacent squares arranged in the shape of the letter L.
The eigenfunctions are strongly singular — all derivatives are unbounded — at the corner
where all three rectangles touch to form a 270-degree angle as measured from boundary to
boundary on the interior of the domain.
Mason (1967) showed that one could obtain superb accuracy from the Chebyshev pseu-
dospectral method after ﬁrst applying the two-dimensional mapping, invented by Reid
and Walsh (1965),
u = Re
n
z2/3o
&
v = Im
n
z2/3o
(16.25)
where u and v are new coordinates, x and y are the original coordinates, and z ≡x + iy.
This conformal mapping heals the singularity by mapping the 270-degree angle into a 180-
degree angle, i. e. a straight line. The solution is everywhere analytic on the boundaries as
a function of the new coordinate. The solution f(x, y) has a r2/3 branch point where r is
a local polar coordinate centered on the offending corner. However, f(u, v) is not patho-
logical because f(u[x, y], v[x, y]) has the (2/3)-power singularity built into the mapping
(16.25).
We refer to (16.25) as a “two-dimensional” mapping because it is not the result of in-
dependent, “tensor product” transformations of x and y, but rather strongly couples both
coordinates.
The mapping introduces several complications. One is that the original, L-shaped do-
main is mapped into the interior of a polygon with curved sides in the u −v plane. Mason
solves the mapped differential equation on the unit square, [−1, 1]×[−1, 1], which contains
the polygon. This allows him to use a basis whose elements are products of Chebyshev
polynomials in u with Chebyshev polynomials in v. Since parts of the square are mapped
into unphysical points outside the L-shaped domain by the inverse of (16.25), we have no
a priori way of excluding possible poles or branch points which would wreck the conver-
gence of the double Chebyshev series. Mason is able to prove, however, that the solution of
the mapped equation is analytic everywhere within the unit u-v rectangle. For a nonlinear
problem, alas, a similar proof would be difﬁcult or impossible.
The second problem is that the boundary condition f = 0 must be applied on the curved
sides of the polygon. Mason is able to impose the boundary conditions by writing the
unknown f(u, v) as
f(u, v) = Φ(u, v) g(u, v)
(16.26)
where Φ(u, v) = 0 on all sides of the polygon. He then expands g(u, v) as a double Cheby-
shev series with no additional boundary constraints imposed upon it. He was able to
successfully calculate the lowest eigenvalue to ﬁve decimal places by computing the corre-
sponding eigenvalue of an 81×81 matrix.

330
CHAPTER 16. COORDINATE TRANSFORMATIONS
Mason’s work is an excellent tour de force, but the use of a single mapping for the whole
domain is obviously complicated and demands both analytical and numerical ingenuity.
For this reason, Mason’s work has had few direct imitations. However, the Liverpool
school of “global element” enthusiasts has had great success in applying two-dimensional
mappings to parts of the domain. Separate Chebyshev series are then applied in each of
several subdomains (McKerrell, 1988, and Kermode, McKerrell, and Delves, 1985). This
work will be discussed in more detail in the chapter on domain decomposition methods.
An alternative to mapping is to augment the basis with singular functions chosen to
match the behavior of the corner singularities. Lee, Schultz, and Boyd (1988a) have applied
this to the ﬂow in a rectangular cavity; Boyd (1988d) gives one-dimensional illustrations.
Much earlier, this technique has been combined with ﬁnite element methods as reviewed
by Strang and Fix (1973). Although a rigorous theory is lacking, the method of singular
basis functions seems to work well. The only caveat is that one must use only a small
number of singular basis functions. The reason is that very weak branch points such as
xk log(x) where k is large can be approximated to many decimal places of accuracy by the
N Chebyshev polynomials in the basis. Thus, the corresponding singular basis functions
are indistinguishable from a sum of Chebyshev polynomials on a ﬁnite precision machine,
leading to poorly conditioned matrices. The moral is that one should use singular basis
functions only for mimicing those singularities which are so strong that the non-singular
(Chebyshev) part of the basis set cannot cope with them.
Both two-dimensional mappings and singular basis functions require precise knowl-
edge about the nature of the corner branch points. The exponential mapping is a brute
force technique which simply concentrates lots and lots of grid points near the boundaries.
It is thus the preferred method when the branch points are (i) too strong to be ignored and
(ii) the analytical form of the singularities is not known.
16.7
Periodic Problems with Concentrated Amplitude and
the Arctan/Tan Mapping
Many physical problems have solutions which are concentrated in a small portion of the
computational interval. The “cnoidal” waves of the Korteweg-deVries equation are a good
example. When the amplitude is small, this solution is indistinguishable from the cosine
function. As the amplitude increases, however, the crest of the wave becomes increasingly
tall and narrow. In the limit of inﬁnite amplitude, the cnoidal wave has the shape of a delta
function.
A change of coordinate which clusters the points of the pseudospectral grid in and
near the peak is a good strategy for such strongly “concentrated” solutions. Boyd (1978c)
describes a cubic-plus-linear stretching in conjunction with Chebyshev polynomials. Boyd
(1987c) describes similar changes-of-coordinate for use when the solution is periodic. The
latter article is worth discussing in greater detail because it illustrates how to choose a good
mapping.
For functions that are periodic in y with a period of π, Boyd (1987c) suggests
y = arctan(L tan(x))
x, y ∈[0, π]
(16.27)
Here, y is the original coordinate, x is the new numerical variable, and L is a constant (“map
parameter”) which can be chosen to give as little or as much stretching as desired. This
transformation has several advantages. First, the mapping function can be expressed in
terms of elementary transcendentals, that is, functions built-in to most compilers. Second,

y
π/4
π/2
−π/4
−π/2
-25000
25000
75000
125000
175000
225000
275000
0
16.7. PERIODIC PROBLEMS & THE ARCTAN/TAN MAP
331
Figure 16.1: The “bicnoidal” wave of the ﬁfth-degree Korteweg-deVries equation (Boyd,
1986b). Although the wave is spatially periodic, it is so sharply peaked about the center of
the interval and decays so rapidly (exponentially) towards the endpoints that it is wasteful
to use a Fourier spectral method with an evenly spaced grid.
the map has the equally trivial inverse
x = arctan
µ 1
L tan(y)
¶
(16.28)
This explicit inverse is valuable in evaluating the numerical solution at arbitrary values
of the original coordinate y. Third, the derivative of y(x) is a trigonometric polynomial
in x. This, together with (16.28), implies that differential equations whose coefﬁcients are
trigonometric polynomials in y will be transformed into differential equations whose co-
efﬁcients are still trigonometric polynomials in the numerical coordinate x — the map is
“polynomial coefﬁcient preserving”. Fourth, the mapping is periodic in the sense that
y(x) = x + P(x; L)
(16.29)
where P(x; L) is a periodic function of x whose Fourier series is given explicitly in Boyd
(1987c). Fifth, and perhaps most important, the mapping (16.27) is smooth so that it does
not create additional boundary layers or regions of rapid variation.
Figs. 16.1 and 16.2 illustrate the effectiveness of the mapping. Fig. 16.1 shows the graph
of the so-called “bicnoidal wave” of the Fifth-Degree Korteweg-deVries equation. Since
the function is graphically indistinguishable from 0 over half of the interval, it is obviously
wasteful to use an evenly spaced grid. Fig. 16.2 shows the logarithm of the relative error
(relative to the maximum of the wave) as a function of the number of terms in the Fourier
pseudospectral approximation for L = 1 (no change-of-coordinates) and L = 0.5. The
mapping allows one to achieve a given accuracy with roughly half the number of degrees
of freedom — and 1/8 the work — as without the mapping.

0
5
10
15
20
25
30
N
-18
-16
-14
-12
-10
-8
-6
-4
-2
0
Map with
L=1/2
No  Map
332
CHAPTER 16. COORDINATE TRANSFORMATIONS
Figure 16.2: The logarithm of the relative error as a function of the number N of Fourier
cosine functions without the use of a mapping and with the application of the arctan / tan
map with L = 1/2. The change-of-coordinate allows one to achieve the same accuracy with
roughly half the number of basis functions.
16.8
Adaptive Methods
Adaptive algorithms, which automatically compress and stretch the grid so as to resolve
boundary layers, shocks, and other regions of rapid change, have become a “hot topic” in
every area of numerical analysis. Table 16.2 catalogues spectral examples.
As a prototype, consider Burger’s equation with periodic boundary conditions:
ut + u uy + ν uyy = 0
(16.30)
Because of the damping, the solutions are always single-valued and never break, but for
small ν, u(x, t) may develop a moving layer of very steep gradient, a quasi-shock wave. An
obvious strategy is apply a transformation so that an evenly spaced grid in the computa-
tional coordinate x is mapped into a grid which has many grid points clustered around the
shock. Because the front is propagating and the equation is nonlinear, it is almost impossi-
ble to choose a mapping non-adaptively. From scale analysis, we might be able to estimate
the width of the frontal zone, but we cannot predict its exact location without ﬁrst solving
the problem.
We will discuss two different strategies for adaptation. The ﬁrst is to choose arclength s
along the solution curve u(x) as the new coordinate (White, 1982). This is always deﬁned
even if we set ν = 0; u may become a multi-valued function of x, but it is always a single-
valued function of arclength.
The second strategy is to choose a particular functional form for the mapping and re-
strict adaptation to the more modest goal of choosing the parameters. For example, the
arctan/tan mapping is
y = yf + arctan[L tan(x)]
(16.31)

16.8. ADAPTIVE METHODS
333
Table 16.2: A Selected Bibliography of Adaptive Pseudospectral Methods With and With-
out Mappings
References
Comments
Bayliss&Matkowsky(1987)
Arctan/tan mapping; combustion fronts
Guillard&Peyret(1988)
Flame fronts and Burgers’ equations
Bayliss&Gottlieb
Arctan/tan map
&Matkowsky&Minkoff(1989)
reaction/diffusion problems
Augenbaum (1989)
Adaption, based on Sobolev norm error indicators
for both Fourier and Chebyshev algorithms
Augenbaum(1990)
Multidomain adaptation; acoustic waves in discontinuous media
Bayliss&Kuske&Matkowsky(1990)
Parameters of arctan/tan map are allowed to vary
with the other spatial coordinate
Bayliss et al.(1994)
thermo-viscoplastics
Bayliss&Matkowsky(1992)
Arctan/tan map for nonlinear cellular ﬂames
Mavriplis(1994)
Adaptive meshes for spectral elements
Gauthier et al.(1996)
Moving interface with domain decomposition
Carcione(1996)
Adaptive mapping for elastic wave equation
Renaud&Gauthier(1997)
Both map and subdomain walls are moved
adaptively; compressible vortex roll-up
Mulholland,Huang&Sloan(1998)
Adaptive ﬁnite difference scheme deﬁnes map
for pseudospectral solution for problems with frontal zones
Black(1998)
spectral elements; map of seminﬁnite domain into ﬁnite interval
Table 16.3: A Few Mapping Functions
Note: y is the physical (unmapped) coordinate; x is the computational coordinate.
References
Change-of-Coordinate Functions
Bayliss&Matkowsky(1987)
y = β−1
β+1 + 1
λ arctan {αx −γ}
Bayliss&Matkowsky(1992)
β = arctan(α(1+γ))
arctan(α(1−γ))
λ = [(β + 1)/2] arctan (α(1 −γ))
4 parameters: α [width] γ [location], β, λ
Bayliss&Gottlieb
1 + 4
π arctan
n
α tan
³
π
4
h
β−x
βx−1 −1
i´o
& Matkowsky&Minkoff(1989)
2 parameters: α [width] β [location]
α > 0, −1 < β < 1
Guillard&Peyret(1988)
Flame fronts and Burgers’ equations
Augenbaum (1989, 1990)
y = (2/π) arctan ©
α ¡ π
2 X¢ª
X ≡(γ + x)/(γ + 1)
2 parameters: α[width] γ[location]
where yf and L are adaptively varied with time. The width parameter L(t) allows the
zone of high resolution to shrink or expand as needed. The shift parameter yf(t) allows
the center of the high resolution zone to track the front.
A simple tactic for determining yf and L is to demand that they minimize a “smooth-
ness” function such as
I(yf, L) ≈
Z π
0
|uxx|2 + |ux|2 dx
(16.32)
It is easy to solve such minimization problems via Newton’s method, but a ﬁrst guess is
needed. In a time-integration, we can use the known structure of the initial solution to
generate a ﬁrst guess. At later times, we use the optimum parameters for time level j as
the ﬁrst guess for minimizing the functional (16.32) at time level (j + 1). We then apply
(16.31) to generate the grid that will be used to march to time level (j + 2).

334
CHAPTER 16. COORDINATE TRANSFORMATIONS
The extra costs are obvious: We must integrate over the interval (to generate the func-
tional) and then interpolate (with spectral accuracy!) from the old grid to the new. One
harsh reality which has discouraged pseudospectral applications is that the Fast Fourier
Transform cannot be applied to interpolate from the old grid to the slightly stretched-and-
shifted new grid. We must use the slower “off-grid” interpolation methods described in
Chapter 10, Sec. 7. (A useful Rule-of-Thumb is that these schemes, whether Boyd’s or
multipole-based, cost roughly four times as much as an FFT of the same N.)
There are some good coping strategies. For example, one might shift into a coordinate
system moving at the approximate phase velocity of the front. One would then need to
update the mapping only every ten time steps, instead of every step, because the front will
not move very far relative to the center of the high-resolution zone in that short length of
time. Even so, pseudospectral adaptation is a rather costly business.
The philosophy is the same, however: to minimize the residual with respect to width-
and-shift parameters so as to optimize the pseudospectral solution. Adaptive grids are
very promising, but because of the extra overhead, it is important that the minimization be
carried out only occasionally as we march in time.
16.9
Chebyshev Basis with an Almost-Equispaced Grid:
Kosloff/Tal-Ezer Arcsine Map
Kosloff and Tal-Ezer(1993) and Tal-Ezer (1994) have reduced the severe time-step require-
ments of standard Chebyshev methods by using a mapping which distributes the grid
points more evenly over the interval y ∈[−1, 1]. Their choice is
y = arcsin([1 −β]x)
arcsin(1 −β)
(16.33)
where y is the original “physical” coordinate and x is the computational coordinate. This
is equivalent to replacing Chebyshev polynomials in y as the expansion functions by the
new, non-polynomial basis
φj(y) ≡Tj
µsin(py)
1 −β
¶
(16.34)
where p ≡arcsin(1−β). When β = 1, this basis reduces to the usual Chebyshev polynomi-
als. When β << 1, the collocation points, deﬁned as the roots or extrema of the Chebyshev
polynomials in the computational coordinate x, are much more uniformly spaced than
those of a standard Chebyshev grid.
Deﬁne the difference between the position of one grid point and its nearest neighbor:
δj ≡yj+1 −yj
(16.35)
The following theorem was proved by Kosloff and Tal-Ezer by substituting the appro-
priate expression for β into the transformation for y (16.33) and taking the limit N →∞.
Theorem 30 (KOSLOFF/TAL-EZER UNIFORMITY-of-GRID) If
β = C/N 2 + O(1/N 3)
(16.36)
where the number of grid points is N + 1, then
min δj ∼
π
√
π2 + 2C +
√
2C
2
N + O
µ 1
N 2
¶
(16.37)
where C is a constant.

16.9. ALMOST-EQUISPACED KOSLOFF/TAL-EZER GRID
335
Table 16.4: Theory and Applications of Kosloff/Tal-Ezer Mapping
References
Comments
Kosloff&Tal-Ezer (1993)
Introduction and numerical experiments
Tal-Ezer(1994)
Theory; optimization of map parameter
Carcione(1994a)
Compares standard Chebyshev grid with Kosloff/Tal-Ezer grid
Renaut&Frohlich(1996)
2D wave equations, one-way wave equation at boundary
Carcione(1996)
wave problems
Godon(1997b)
Chebyshev-Fourier polar coordinate model, stellar accretion disk
Renaut(1997)
Wave equations with absorbing boundaries
Don&Solomonoff(1997)
Accuracy enhancement and timestep improvement, especially
for higher derivatives
Renaut&Su(1997)
3rd order PDE; mapping was not as
efﬁcient as standard grid for N < 16
Don&Gottlieb(1998)
Shock waves, reactive ﬂow
Mead&Renaut(1999)
Analysis of Runge-Kutta time-integration
Hesthaven, Dinesen
Diffractive optical elements; chose β = 1 −cos(1/2)
& Lynov(1999)
to double timestep versus standard grid
Abril-Raymundo &
Theory and experiment for convergence
Garc´ia-Archilla(2000)
of the mapping
In words, the theorem states if β decreases sufﬁciently fast with N, then the ratio of the
largest to the smallest inter-grid distance can be bounded by a constant independent of N.
Though we shall not reproduce their graphs, Kosloff and Tal-Ezer calculate the eigenvalues
of the differentiation matrices and show that the great reduction in the non-uniformity
of the grid is indeed accompanied by an equally great reduction in the stiffness of the
matrix. This implies that their Chebyshev-with-a-map scheme requires an O(1/N) time
step (for a PDE which is ﬁrst order in space), no worse than a ﬁnite difference scheme on
an equispaced grid except for an N-independent proportionality factor.
Mead and Renaut (1999) have argued that the best choice is
βoptimum = 1 −cos(1/N) ↔β ≈
1
2 N 2
(16.38)
This in turn implies that
min δj ≈0.731
2
N + O
µ 1
N 2
¶
(16.39)
which is only slightly smaller than the minimum of 2/N for a uniformly spaced grid. The
tremendous increase in timestep which is thus allowed has created many happy users of
this change-of-coordinates as catalogued in Table 16.4.
The ﬂaw of the Kosloff/Tal-Ezer transformation is that if β decrease with N, then the
branch points of the mapping move closer and closer to the expansion interval as N in-
creases.
The map-induced branch points near the expansion interval deaccelerate the
convergence of the spectral series. It is easiest to see this by making the transformation
t = arccos(x) so the Chebyshev polynomials in x become a cosine series in t. The mapping
becomes
y = arcsin([1 −β] cos(t))
arcsin(1 −β)
(16.40)
The reason the trigonometric coordinate is convenient is that the convergence-slowing ef-
fects of a singularity are directly proportional to the imaginary part of ts where ts is the
location of the singularity.

336
CHAPTER 16. COORDINATE TRANSFORMATIONS
Theorem 31 (BRANCH POINTS of KOSLOFF/TAL-EZER MAP) In terms of the trigonomet-
ric coordinate t, the Kosloff/Tal-Ezer mapping has square root branch points at
ts = m π ± i arccosh(1 −β)
(16.41)
where m is an arbitrary integer. For small β, the all-important imaginary part of the location of the
branch points is given approximately by
| ℑ(ts)| ≈
√
2
p
β +
√
25
2 β3/2 + O(β5/2)
(16.42)
In particular, when β is chosen to vary inversely to the square of N, the number of Chebyshev grid
points,
| ℑ(ts)| ≈
√
2C 1
N + O(N −3/2),
N >> 1, β ∼C
N 2
(16.43)
Note that µ ≡ℑ(ts) is the “asymptotic rate of geometric convergence”; the exponential factor in
the usual N →∞approximation to the spectral coefﬁcients (Chapter 2) is exp(−µN), which in
this case is therefore
exp(−ℑ(ts) N) ∼exp(−
√
2C) + O(1/N)
(16.44)
which does NOT DECREASE WITH N.
PROOF: The mapping is singular where the argument of the arcsin in the numerator is
one. Using the identity cos(tr+itim) = cos(tr) cosh(tim)−i cos(tr) cosh(tim) and separating
real and imaginary parts, this is equivalent to the pair of equations
1 = (1 −β) cos(tr) cosh(tim)
&
0 = sin(tr) sinh(tim)
(16.45)
The second equation requires tr = 0, π or any other integral multiple of π. It follows that
without approximation tim = arccosh(1−β) as asserted in Eq. 16.41. Expanding the inverse
hyperbolic cosine for small β then gives the remaining two parts of the theorem. Q. E. D.
In the large-degree asymptotic approximation to the coefﬁcients of the Fourier series for
a function whose singularity nearest the real t-axis is at t = ts, the exponential-in-degree
factor is exp(−N |ℑ(ts)|) for the N-th coefﬁcient. If the imaginary part of the mapping
singularities is inversely proportional to N, then the exponential factor does not decrease
at all and the Kosloff/Tal-Ezer mapping has DESTROYED the SPECTRAL ACCURACY of the
Chebyshev algorithm.
To demonstrate this, Fig. 16.3 is a plot of the N-th Chebyshev or Fourier coefﬁcient for
the linear polynomial f(y) = y, which is simply T1(y) in the absence of the mapping. The
map parameter has been varied with N according to the optimum choice of Mead and
Renaut, β ≈1/(2N 2).
When β decreases more slowly with N than 1/N 2, the transformed Chebyshev series
still converges geometrically. Unfortunately, the timestep then increases more rapidly with
N than when β is O(1/N 2).
In spite of this, the Kosloff/Tal-Ezer mapping has many satisﬁed customers as cata-
logued in the table. However, the claim, made in the title of their paper, that the Kosloff/Tal-
Ezer method gives an O(1/N) time step limit is true only if one is willing to let spectral
accuracy go to the devil.
For this reason, Hesthaven, Dinesen and Lynov(1999), who are unwilling to sacriﬁce
spectral accuracy, choose
β = 1 −cos(1/2)
(16.46)

16.9. ALMOST-EQUISPACED KOSLOFF/TAL-EZER GRID
337
10
0
10
1
10
2
10
-4
10
-3
10
-2
10
-1
10
0
N
Kosloff/Tal-Ezer N-th coefficient of y
Figure 16.3: The N-the Chebyshev coefﬁcient versus N when the map parameter is varied
with N according to β = 1 −cos(1/N). (Note that the plotted numbers are not the coef-
ﬁcients of a single spectral expansion because the map parameter is different for each N.)
Only odd N are plotted because the even N coefﬁcients are all zero by symmetry. The dot-
ted curve is a graph of 1/N 2, which is asymptotically parallel to the solid line. Numerically,
the coefﬁcients of f(y) = y asymptote to 0.488/N 2: the usual exponential convergence of a
Chebyshev series has been destroyed by the change-of-coordinate.
This “accuracy-conservative” choice nevertheless allows twice the time step of an un-
mapped Chebyshev algorithm with no loss of accuracy or stability.
Thus, the controversy is only about the best choice of β. There is no doubt that the
Kosloff/Tal-Ezer mapping is useful and allows a longer time step.

Chapter 17
Methods for Unbounded Intervals
“The inﬁnite! No other question has ever moved so profoundly the spirit of man.”
— David Hilbert (1921)
17.1
Introduction
In this chapter, we discuss a variety of special tools for dealing with problems in inﬁnite
or semi-inﬁnite domains. When the problem is posed on y ∈[−∞, ∞], the alternatives
include: (i) sinc functions (ii) Hermite functions and (iii) algebraically mapped Chebyshev
polynomials (iv) exponentially mapped Chebyshev polynomials or (v) solving the prob-
lem on a large but ﬁnite interval, a technique we shall call “domain truncation”. On the
semi-inﬁnite interval y ∈[0, ∞], we can use (i) Laguerre functions or (ii) Chebyshev poly-
nomials with various mappings or (iii) domain truncation. In the rest of the chapter, we
will describe a number of particular choices of basis set.
Rule-of-Thumb 14 (PENALTIES of UNBOUNDED INTERVAL)
The unboundedness of a computational domain extracts two penalties:
1. The rate of convergence is usually SUBGEOMETRIC rather than geometric.
2. In addition to the truncation N, one must always choose some kind of scaling parameter L.
This second numerical parameter may be the size of a truncated computational domain, a map
parameter for a change-of-coordinate that transforms a ﬁnite interval to an inﬁnite domain,
or a scaling constant for the argument of the basis functions.
The third complication of inﬁnite intervals is that there are many good choices of spec-
tral basis. Consequently, we shall treat in turn sinc, Hermite, Laguerre, rational Chebyshev,
domain truncation, and Fourier series with a mapping. Which should one choose? The
good news is: It doesn’t much matter. All these basis sets work well. There are differences,
but only modest differences, in efﬁciency, ease of programming and the relationship be-
tween the basis sets and the solutions of particular classes of physical problems. Thus, all
of these basis sets are used widely.
The many options for unbounded domains fall into three broad categories:
1. Domain truncation (approximation of y ∈[−∞, ∞] by [−L, L] with L >> 1
338

17.2. DOMAIN TRUNCATION
339
2. Basis functions intrinsic to an inﬁnite interval (sinc, Hermite) or semi-inﬁnite (La-
guerre)
3. Change-of-coordinate (“mapping”) of the unbounded interval to a ﬁnite one, fol-
lowed by application of Chebyshev polynomials or a Fourier series
These three strategies are not completely distinct. One can always combine mapping of the
coordinate with domain truncation or any basis for an unbounded interval. Furthermore,
mapping is equivalent to creating new basis functions whose natural home is the inﬁnite
or semi-inﬁnite interval; these are simply the images of Chebyshev or Fourier functions
under the change-of-coordinate. Nevertheless, it is useful to keep these key strategies in
mind as these are mixed and matched to create good algorithms.
17.2
Domain Truncation
Deﬁnition 35 (DOMAIN TRUNCATION) If a solution u(y) decays rapidly in the direction or
directions for which the computational interval is unbounded (or asymptotes to a simple form), then
the exact solution can be calculated by solving the differential equation on a large but ﬁnite interval.
This strategy for unbounded domains is “domain truncation”.
17.2.1
Domain Truncation for Rapidly-decaying Functions
Domain truncation is the “no-brain” strategy for solving problems on an unbounded in-
terval because it requires no modiﬁcations of strategies for a ﬁnite interval. If the solution
u(y) decays exponentially with |y| for sufﬁciently large |y|, then the error in approximating
the inﬁnite interval by the ﬁnite interval y ∈[−L, L] will decrease exponentially with the
domain size L. We can then apply a standard Chebyshev, Legendre or Fourier basis on the
ﬁnite domain. The joys of applying existing software for a ﬁnite domain to an unbounded
computational interval should not be underestimated; programming time is much more
expensive than machine time.
To estimate the error in domain truncation, the following sufﬁces:
Deﬁnition 36 (DOMAIN TRUNCATION ERROR) The “domain truncation error” is
(i)
EDT (L) ≡|u(L)|
if |u(y)| ≤|u(L)| ∀|y| ≥L
(17.1)
or otherwise
(ii)
EDT (L) ≡max
|y|≥L(|u(y)|)
(17.2)
We are forced to use the phrase “estimate” because our deﬁnition of the domain truncation
error is merely the maximum value of the exact solution outside the limits of the truncated
interval. The error in the approximate solution to a differential equation is another matter,
and may be much larger than EDT (L). However, the Assumption of Equal Errors asserts
that max |u(y) −uN(y)| ∼O(EDT (L)) for most real-world problems, even though one can
contrive examples for which this is not true. In the rest of the chapter, we shall use EDT (L)
as our sole measure of the numerical error induced by truncating the computational inter-
val.
There are a couple of subtleties even in this most obvious and unsubtle method. The
ﬁrst is that if L is ﬁxed while the number of basis functions N tends to ∞, the error will not
converge to zero, but rather to EDT (L). It follows that to improve accuracy, both the size of
the domain L and the number of basis functions N must increase simultaneously.

340
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
This increase in L moves the poles and branch points of u(y) closer to the real y-axis
after [−L, L] has been rescaled to [−1, 1] for the application of a Chebyshev polynomial
basis (or whatever). This movement-of-the-singularities reduces the rate of convergence
of the Chebyshev series. Thus, when N is doubled, the logarithm of the total error is not
doubled, but is increased by a smaller amount because of the increase in L with N. As N
and L jointly increase, the error decreases to zero at a subgeometric rate in N. (If L could
be ﬁxed, then the error would decrease geometrically in N as for a ﬁnite interval, but this,
alas, is only a dream when the problem is posed on an unbounded domain.)
The second subtlety is that it is more efﬁcient to use an ordinary Fourier series instead
of Chebyshev polynomials, even though the former is prone to the wild oscillations of
Gibbs’ Phenomenon at y = ±L. The reason is that the amplitude of the Gibbs’ overshoot is
0.09|u(L) −u(−L)|/N (Boyd, 1988e), that is to say, the size of the wiggles is proportional to
but smaller than the magnitude of u(y) at the ends of the interval, i. e., the domain trunca-
tion error EDT (L). It follows that the effects of Gibbs’ Phenomenon are always smaller (by
O(1/N)) than the domain truncation error, and thus negligible. The Fourier basis is better
because for a given N, it has a higher density of points (by a factor of π/2) at the center
of the interval than the Chebyshev collocation grid, which wastefully clusters points near
y = ±L where u(y) is very small.
Domain truncation is a good because of its simplicity. However, it can improved further
by combining it with a mapping as shown by Weideman and Cloot (1990), and explained
later in this chapter. Furthermore, domain truncation is more sensitive to the choice of
the domain size L than the rational Chebyshev functions are to the choice of their map
parameter L (Boyd, 1982a, 1987a, 1987b).
17.2.2
Domain Truncation for Slowly-Decaying Functions
If u(y) decays as an inverse power of |y|, instead of exponentially, it is often still possible
to obtain high accuracy from domain truncation by altering the boundary conditions to
match the analytic, asymptotic form of the slowly-decaying solution. For example, Corral
and Jim´enez(1995) developed an analytic irrotational correction to apply domain domain
to a ﬂow which is unbounded in one coordinate. Rennich and Lele(1997) have applied a
three-dimensional Fourier series to a vortical ﬂow which is unbounded in two coordinates,
extending Corral and Jim´enez’s method to an additional dimension. The analytical bound-
ary condition makes it possible to use a computational domain of modest size even though
the decay of the irrotational part of the vorticity is rather slow, which would otherwise
demand a huge domain.
Domain truncation-with-matching is not the only option for slowly-decaying functions.
Algorithms that combine inﬁnite interval basis sets with special asymptotic-mimicing basis
functions are the themes of Sec. 13 in this chapter (illustrated by the J0 Bessel function) and
Sec. 4 in Chapter 19 (wave scattering).
17.2.3
Domain Truncation for Time-Dependent Wave Propagation:
Sponge Layers
When waves evolve far from boundaries, it is common to idealize the geometry as an
inﬁnite, boundary-free domain. Standard inﬁnite interval basis sets have troubles because
the waves do not decay for large |y|; instead, some waves simply propagate out of the
region of interest. Domain truncation is a popular alternative. However, the usual Dirichlet
boundary conditions are equivalent to rigid boundaries, which would reﬂect the waves
back towards y = 0 like a mirror. The physics for large |y| must therefore be modiﬁed to
absorb the waves.

17.3. WHITTAKER CARDINAL OR “SINC” FUNCTIONS
341
For simple wave equations (or for wave equations which asymptote to linear, con-
stant coefﬁcient differential equations for large |y|), this modiﬁcation can be accomplished
merely by altering the boundary conditions. For example, if the waves have the asymp-
totic spatial structure exp(±iky) for some wavenumber k where the plus sign describes
outward-propagating waves for positive y, then the right boundary condition can be mod-
iﬁed to
∂u
∂y −iku = 0
at y = L
(17.3)
and similarly at the left boundary. This Robin condition ﬁlters the inward-propagating
wave, thus allowing waves to pass through the boundary from small y to y > L without
reﬂection.
Unfortunately, this simple strategy fails if the far ﬁeld waves are a mixture of wavenum-
bers or vary non-sinusoidally. It is possible to generalize this “propagate-through-the-
boundary” idea; there has been much recent work on so-called “one-way wave equations”,
but it would take us too far aﬁeld to describe it here.
A second option is to add an artiﬁcial damping which is negligible for small y (where
the real physics happens) but is allowed to increase exponentially fast for large y. The
ends of the computational domain then soak up the waves like a sponge soaking up water;
this is called the “sponge layer” method. Any old boundary conditions at y = ±L will
do because the waves that reﬂect from the computational boundaries will never make it
back to vicinity of the origin. If, Berg, Christiansen and Skovgaard(1987) and Zampieri
and Tagliani(1997) are spectral examples.
The Fourier basis, used by If et al., is superior to a Legendre or Chebyshev basis because
the high resolution of the orthogonal polynomials near y = ±L is completely wasted when
these regions are “sponges”.
There is one peril in “sponge layers”: If the artiﬁcial viscosity increases too rapidly,
accuracy may be awful. If the damping coefﬁcient is discontinuous, then the wave equation
no longer has analytic coefﬁcients and the spectral series will converge only at an algebraic
rate. However, even if the viscosity is an analytic function, the sponge layer may fail to
be a good absorber if the damping increases too rapidly with |y|. The reason is that if the
damping varies more rapidly than the wave, the wave will be partially reﬂected — any
rapid variation in the wave medium or wave equation coefﬁcients, whether dissipative or
not, will cause strong partial reﬂection. The physically-interesting region around y = 0 will
then be corrupted by waves that have reﬂected from the sponge layers.
Fortunately, it turns out that if ϵ is deﬁned to be the ratio of the length scale of the wave1
to the length scale of the dissipation, then the reﬂection coefﬁcient is exponentially small
in 1/ϵ (Boyd, 1998b). It follows that if both the length scale of the artiﬁcial viscosity and the
domain size are systematically increased with the number of spectral coefﬁcients N, then
the amplitude of reﬂected waves at y = 0 will decrease exponentially fast with N. Thus, if
implemented carefully, the sponge layer method is a spectrally-accurate strategy.
17.3
Whittaker Cardinal or “Sinc” Functions
Sir Edmund Whittaker (1915) showed that functions which (i) are analytic for all ﬁnite real
y and (ii) which decay exponentially as |y| →∞along the real axis could be approximated
as sums of what are now called “Whittaker cardinal” or “sinc” functions. The convergence
is exponential but subgeometric with an exponential convergence index usually equal to 0.5.
1The wave scale is 1/k, i. e., the local wavelength divided by 2π.

342
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
(That is, the error typically decreases proportional to exp(−qN 1/2) for some positive con-
stant q.)
f(y) ≈
N/2
X
j=−N/2
f(yj) Cj(y)
(17.4)
where
Cj(y; h)
≡
sinc[(y −jh)/h]
(17.5)
sinc(y)
≡
sin(πy)
πy
(17.6)
and where the points of the associated collocation grid are
yj ≡j h
(17.7)
The coefﬁcients of the expansion are simply the values of f(y) on the grid because the basis
functions are also cardinal functions with the property
Ci(yj; h) = δij
(17.8)
What is most striking about (17.4) is that we must choose two independent parameters
to determine the approximation: (i) the truncation N and (ii) the scaling factor h. On a ﬁnite
interval, only one parameter — the truncation N — would sufﬁce. This complication is not
special to sinc series: all spectral methods on an inﬁnite or semi-inﬁnite interval require us
to specify a scaling parameter of some sort in addition to N.
Spectral methods on an inﬁnite or semi-inﬁnite interval have other subtleties, too. A
truncated Chebyshev series is exact on a ﬁnite interval only when f(x) is a polynomial;
what makes it useful is that one can approximate any function by a polynomial of suf-
ﬁciently high degree. The analogous statement for sinc expansions is that the Whittaker
cardinal series is exact for so-called “band-limited” functions; sinc series are effective for
general functions that decay exponentially as |y| →∞because one can approximate ar-
bitrary functions in this class with arbitrary accuracy by a band-limited function of sufﬁ-
ciently large bandwidth.
“Band-limited” functions are deﬁned in terms of Fourier integrals, which are yet an-
other way of representing a function on an inﬁnite interval:
f(y) =
1
√
2π
Z ∞
−∞
F(ω) e−iωy dω
[Fourier integral]
(17.9)
The Fourier transform F(ω) is analogous to the function a(n) that gives the coefﬁcients of
an ordinary Fourier or Chebyshev series except that a(n) is meaningful only for integer n
whereas F(ω) is a continuous function of ω.
In the same way that series coefﬁcients a(n) are computed by an integral which is the
product of f(t) with the basis functions,
F(ω) =
1
√
2π
Z ∞
−∞
f(y) eiωy dy
[Inverse Transform]
(17.10)
An exponentially convergent numerical scheme to compute either the forward or inverse
transform is to replace the inﬁnite limits of integration by ±W for some sufﬁciently large
W and then apply the rectangle rule or trapezoidal rule. We do not offer a separate chapter

17.3. WHITTAKER CARDINAL OR “SINC” FUNCTIONS
343
or even a section on Fourier integrals because this algorithm is equivalent to a Fourier series
pseudospectral method with a very large period.
Communications engineers have introduced a special name for a truncated Fourier in-
tegral because electronic devices have maximum and minimum frequencies that physically
truncate the ω-integration.
Deﬁnition 37 (BAND-LIMITED FUNCTIONS)
A function fW (y) is said to be BAND-LIMITED with BANDWIDTH W if it can be repre-
sented as the TRUNCATED Fourier integral
fW (y) =
1
√
2π
Z W
−W
F(ω)e−iωy dω
(17.11)
In the world of Fourier integrals, band-limited functions are the analogues of polyno-
mials. For any degree N, polynomials are “entire functions”, that is to say, have no singu-
larities for any ﬁnite x in the complex x-plane. Even so, a polynomial may be an extremely
accurate approximation to a function that has poles or branch points. The resolution of this
apparent contradiction is that the polynomial is a good representation of f(x) only on an
interval which is free from singularities; the inﬁnities must be elsewhere. In a similar way,
“band-limited” functions are always “entire functions”, too. This does not alter the fact
that any function f(y), even if it has singularities for complex y, can be approximated for
real y to within any desired absolute error by a band-limited function of sufﬁciently large
bandwidth.
Eq. (17.4) and (17.8) show that the sinc series interpolates to f(y) at every point of
the grid. However, this hardly guarantees a good approximation; recall the Runge phe-
nomenon for polynomials. For band-limited functions, success is assured by the following.
Theorem 32 (SHANNON-WHITTAKER SAMPLING THEOREM)
If fW (y) is a BAND-LIMITED function of bandwidth W, then the Whittaker cardinal series is
an EXACT representation of the function if h ≤π/W where h is the grid spacing:
fW (y) =
∞
X
j=−∞
f
µπj
W
¶
sinc
µWy
π
−j
¶
(17.12)
PROOF: Stenger (1981) or Dym and McKean (1972).
As noted above, band-limited functions are rather special. However, under rather mild
conditions on f(y), one can prove that F(ω) will decrease exponentially with |ω|, so the
error in writing f(y) ≈fW (y) decreases exponentially with W, too. Thus, (17.12) really
implies that we can use Whittaker cardinal functions to approximate any function f(y)
that has a well-behaved Fourier transform.
Deﬁnition 38 (SINC EXPANSION OF A FUNCTION) An approximation to a function f(y)
of the form
f(y) =
N/2
X
j=−N/2
f(hj) sinc
µy −jh
h
¶
+ EW (h) + EDT (Nh)
(17.13)
is called the SINC EXPANSION of f(y) where h is the grid spacing.

344
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
The error EW (h) is called the “grid-spacing” or “bandwidth” error. It arises because the grid
points are spaced a ﬁnite distance h apart. Equivalently, since the sinc expansion is exact even with
a non-zero h if f(y) is band-limited with a sufﬁciently large W, we may say that this error is caused
by (implicitly) approximating f(y) by a band-limited function fW (y) with W = π/h.
The error EDT (Nh) is the “grid-span” or “domain truncation” error. It arises because we must
truncate the inﬁnite series to limits of ±N/2 for some ﬁnite N. This is equivalent to interpolating
f(y) on a grid of (N + 1) points that span only a portion of the interval [−∞, ∞]. This error is
O(f[hN/2]).
Figure 17.1: The ×’s mark the evenly spaced interpolation points used with sinc functions
to solve problems on y ∈[−∞, ∞]. It can be shown that for most situations, best results
are obtained by choosing a grid spacing h proportional to
√
N where N is the number of
grid points. This implies that interval spanned by the grid points — the “grid span” —
imcreases simultaneously as the neighbor-to-neighbor distance decreases.
Fig. 17.1 is a schematic of the optimum relationship between h and N. If we keep h
ﬁxed, and merely use a larger and larger number of terms in (17.12), our approximation
will converge not to f(y) but to fW (y), and we are stuck with the ﬁxed error |f(y) −fW (y)|
even with million grid points. Conversely, if we only decrease h and truncate the sum in
(17.12) by omitting all grid points such that |yj| > L for ﬁxed L, we would be left with
an O(f[L]) error even if the grid spacing is ridiculously small. Because of the need to
simultaneously increase L and decrease h, the error is O(exp[−p
√
N]) for a typical function
like f(y) = sech(y): Subgeometric convergence with exponential index of convergence =
1/2.
There are several alternatives for representing functions on inﬁnite or semi-inﬁnite in-
tervals, but they do no better. Sub-geometric convergence is a way of life when the interval
is unbounded. The grid of Gaussian quadrature points for the Hermite functions, for ex-
ample, automatically becomes both wider (in total span) and more closely spaced as N
increases as shown in Fig. 17.2. There is always this need to serve two masters — increas-
ing the total width of the grid, and decreasing the spacing between neighboring points —
for any method on an unbounded interval. The cardinal function series differs from or-
thogonal polynomial methods only in making this need explicit whereas it is hidden in the
automatic behavior of the interpolation points for the Hermite pseudospectral algorithm.
For more information about sinc numerical algorithms, consult the review article by
Stenger (1981) and the books by Lund and Bowers (1992) and Stenger (1993) or the articles
in Table 17.1.

17.3. WHITTAKER CARDINAL OR “SINC” FUNCTIONS
345
Table 17.1: A Selected Bibliography of Sinc (Whittaker Cardinal) Applications
References
Comments
Whittaker(1915)
A few words from our founder: theory only
Stenger (1979)
Boundary value problems
Lundin (1980)
Nonlinear PDE boundary value problem
Stenger (1981)
Review article; theory plus numerical applications
Saffman&Szeto(1981)
Vortex stability
Lund&Riley(1984)
Sinc with mapping to solve radial Schroedinger equation
Elliott&Stenger(1984)
Numerical solution of singular integral equations
Robinson&Saffman (1984)
Nonlinear eigenvalue problem in 2 space dimensions
Lund (1986)
Symmetrization of sinc-Galerkin matrix
Boyd (1986b)
Shows that exponential mapping of Stenger to inﬁnite
interval is key to solving problems with
endpoint singularities on [−1, 1];
sinc basis is effective, but other
inﬁnite interval bases work just as well
Schaffer&Stenger (1986)
Multigrid iteration with sinc
Bowers & Lund(1987)
Singular Poisson equations
Eggert&Jarratt&Lund(1987)
Finite and semi-inﬁnite intervals, too, through mapping;
singularities at end of ﬁnite interval
Lewis&Lund&Bowers(1987)
Sinc in both x and t for parabolic PDE
McArthur&Bowers&Lund(1987a)
Second order hyperbolic PDEs
McArthur&Bowers&Lund(1987a)
Numerical methods for PDEs
Bialecki(1989, 1991)
Boundary value problems
Lund&Bowers&McArthur (1989)
Elliptic PDEs
Smith&Bowers&Lund(1989)
Fourth order problems in control theory
Jarratt&Lund&Bowers(1990)
Sinc basis; endpoint singularities , ﬁnite interval
Lund&Vogel (1990)
Inverse problem for parabolic PDE
Boyd (1991f)
Sinc solution of boundary value problems with a banded
matrix obtained by Euler sequence acceleration
Smith&Bogar&Bowers&Lund(1991)
Fourth order differential equations
Lund&Bowers&Carlson(1991)
Boundary feedback stabilization (control theory)
Smith&Bowers(1991)
Inverse problem for Euler-Bernoulli beams
Smith&Bowers&Lund(1992)
Inverse problem for Euler-Bernoulli beams
Boyd (1992c)
Fast Multipole Method provides a fast sinc transform
Boyd (1992d)
Fast off-grid sinc interpolation
Lund & Bowers (1992)
Monograph
Stenger (1993)
Monograph
Yin (1994)
Poisson equation through tensor-product sinc basis
Koures (1996)
Coulomb Schroedinger equation

346
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
Appendix F gives formulas for the derivatives of the Whittaker cardinal functions at the
grid points. The ﬁrst derivative matrix is skew-symmetric while the second derivative is
symmetric (Stenger, 1979). These are desirable properties. Skew-symmetry implies that all
eigenvalues of the ﬁrst derivative matrix are pure imaginary; thus the sinc discretization
of the one-dimensional advection equation, ut + cux = 0, is nondissipative. Similarly, the
symmetry of the second derivative matrix implies that all eigenvalues are real; the sinc
discretization of the diffusion equation gives a system of ODEs in time whose eigenmodes
all decay monotonically in time.
The sinc expansion is the easiest of all pseudospectral methods to program and to un-
derstand. One weakness, shared with the Hermite functions, is that the Whittaker cardinal
series is useful only when f(y) decays exponentially as |y| →∞. In contrast, the TBn(y)
will give rapid, exponential convergence for functions which decay algebraically with |y| or
asymptote to a constant, provided certain conditions are met. Thus, the mapped Cheby-
shev polynomials have a wider range of applicability than the sinc expansion.
A more serious weakness of sinc series is that — unlike the mapped Chebyshev func-
tions — they cannot be summed via the Fast Fourier Transform. This is especially unfortu-
nate for time-dependent problems and for iterative solution of multi-dimensional bound-
ary value problems.
A third limitation is that sinc functions do not give the exact solution to any classical
eigenvalue problem (to my knowledge). In contrast, the Hermite functions are the ide-
alized or asymptotic solutions to many physical problems. Thus, the Whittaker cardinal
functions, despite their simplicity, have not eliminated the competing basis sets discussed
in the next two sections.
The “Big Sky School” of Stenger, Lund, and their students have applied the sinc expan-
sion to problems on a ﬁnite interval with endpoint singularities — always in combination
with a map that exponentially stretches the bounded domain to an inﬁnite interval. As ex-
plained in Chap. 16, Sec. 5, this is a good strategy for coping with endpoint branch points.
Eggert, Jarratt, and Lund (1987) also compute some solutions without endpoint singulari-
ties, but this is not recommended. Chebyshev series are much more efﬁcient when u(x) is
analytic at the boundaries.
In summary, it is best to regard the Whittaker cardinal functions as a good basis for
[−∞, ∞] only. Although it has some important defects in comparison to Hermite and
rational Chebyshev functions, the sinc series is the simplest and it converges just as fast as
the alternatives.
17.4
Hermite functions
The members of this basis set are deﬁned by
ψn(y) ≡e−0.5 y2 Hn(y)
(17.14)
where Hn(y) is the Hermite polynomial of degree n. Like the familiar Chebyshev poly-
nomials, the n-th Hermite polynomial is of degree n. The members of the set satisfy a
three-term recurrence relation. The derivative of Hn(y) is simply (2 n Hn−1), so it is easy to
use Hermite functions to solve differential equations.
Unlike most other sets of orthogonal functions, the normalization constants for the Her-
mite functions increase exponentially with n, so it is difﬁcult to work with unnormalized
functions without encountering overﬂow (unless N is very small). In contrast, normalized
Hermite functions satisfy the bound
| ¯ψn(y)| ≤0.816
all n, all real y
(17.15)

17.4. HERMITE FUNCTIONS
347
Table 17.2: Hermite Function Theory & Applications
References
Comments
Hille(1939, 1940a,b, 1961)
Convergence theorems
Englemann&Feix
1D Vlasov eq. (plasma physics); Fourier in x
& Minardi&Oxenius(1963)
Hermite in velocity coordinate u
Grant&Feix(1967)
Fourier-Hermite for 1D Vlasov equation
Fokker-Planck collision term to improve Hermite convergence
Armstrong(1967)
1D Vlasov equation; Fourier-Hermite Galerkin
Hermite truncation reduced with increasing time to mitigate
slow convergence of Hermite part of tensor basis
Birkhoff&Fix(1970)
Eigenproblems
Joyce&Knorr
1D Vlasov eq.; Fourier-Hermite basis compared with
&Meier(1971)
double Fourier & method-of-moments (!)
Anderson (1973)
Time-dependent model of the tropical ocean
Moore & Philander (1977)
Equatorial waves and jets in the ocean (review)
Shoucri&Gagn´e(1977)
2D Vlasov; tensor Hermite basis in velocity
ﬁnite differences in space; plasma physics
Bain (1978)
Convergence theorems
Banerjee (1978)
Eigenvalue problem: quantum anharmonic operator
Banerjee et al. (1978)
ψn(αy) with variable α
Boyd (1980b)
Rate of convergence theorems
Boyd (1984a)
Asymptotic theory for Hermite coefﬁcients through
steepest descent and the calculus of residues
Tribbia (1984)
Hough-Hermite Galerkin method
Boyd & Moore (1986)
Euler sequence acceleration of algebraically-converging
Hermite series with applications to oceanography
Marshall & Boyd (1987)
Equatorial ocean waves
Smith(1988)
Hermite-Galerkin model of tropical ocean
Funaro & Kavian (1991)
Time-dependent diffusion problems
Weideman (1992)
Hermite differentiation matrices are well-conditioned
Holvorcem(1992)
Summation methods for Hermite series including
Holvorcem&Vianna(1992)
Green’s functions, which depend on two variables
Vianna&Holvorcem(1992)
Boyd (1992c)
Fast Multipole Methods provide fast Hermite transform
Boyd (1993)
Hermite methods in symbolic manipulation languages
Tang (1993)
Gaussian functions; role of the scale factor
Holloway(1996a,b)
Vlasov-Maxwell equations (plasma physics)
Introduces “asymmetric” Hermite basis, which is very
efﬁcient for this application
Tse&Chasnov(1997)
Hermite for vertical coordinate
Convection in unstable layer surrounded by
unbounded stable layers; Fourier in x, y
Schumer&Holloway(1998)
1D Vlasov equation; Hermite-Fourier basis
asymmetric Hermite is unstable; standard Hermite is good
with use of anti-ﬁlamentation ﬁltering

348
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
where the overbar denotes that the ψn(y) have been normalized. As for Chebyshev and
Fourier series, this bound (17.15) implies that the error in truncating a Hermite series is
bounded by the sum of the absolute values of all the neglected terms.
The optimum pseudospectral points are the roots of the (N+1)-st Hermite function. The
points are not exactly evenly spaced — the outermost points are a little farther apart than
the separation between points near y = 0 — but the asymptotic approximations to the Her-
mite functions show that the Hermite grid does not differ very much from the sinc grid
as shown in Fig. 17.2. In the previous section, we found that it was necessary to simul-
taneously (i) decrease the spacing between adjacent grid points and (ii) increase the span
between the outermost points on the grid if the sinc series was to give increasing accuracy
as N increased. Exactly the same thing happens with the Hermite grid: the separation be-
tween grid points decreases as 1/
√
N while the span of the grid increases as
√
N. It is not
necessary to choose h and the span of the grid explicitly; using the roots of the Hermite
function as the grid points automatically insures the correct behavior.
Fig. 17.3 illustrates the ﬁrst six (normalized) Hermite functions.
However, it is still necessary to pick a scaling factor α since we can can always use
ψn(αy) as the basis set for any ﬁnite α. This freedom does not exist for a ﬁnite interval, but
after a change of scale in y, an inﬁnite domain is still an inﬁnite domain. Banerjee (1978)
and Banerjee et al.(1978), Boyd (1984a), and Tang(1993) have discussed the choice of scale
factor. The theory (Boyd, 1984a) involves heavy use of steepest descent to asymptotically
approximate the Hermite coefﬁcient integrals as n →∞. One general conclusion is impor-
tant since it is also true of mapped Chebyshev methods: The optimum α is a function of
N. A good choice of scaling parameter for N = 5 is a mediocre choice for N = 50; at least
for the cases studied, α should increase with N.
The rates-of-convergence theory for Hermite functions is now well-developed for a ﬁxed
(N-independent) scale factor α. It is worth summarizing since it indicates the subtleties in-
troduced by the unboundedness of the expansion interval. We must begin with a deﬁnition
because the rate of convergence depends not only on the location of singularities, as true of
all expansions, but also upon the rate at which the function f(y) decays as |y| tends to inﬁn-
ity.
Figure 17.2: The pseudospectral grid for Hermite functions. For all N, the grid points are
the roots of the (N+1)-st Hermite polynomial. The grid spacing varies slightly, but is almost
uniform over the interval. The grid closely resembles the sinc grid: when N is quadrupled,
the span of the grid points is roughly doubled and the grid spacing is halved.

17.4. HERMITE FUNCTIONS
349
Figure 17.3: Graphs of the ﬁrst 6 Hermite functions, ψn(y).

350
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
Deﬁnition 39 (ORDER OF REAL AXIS DECAY)
The ORDER of REAL AXIS DECAY k is the least upper bound of j for which
f(y) = O
³
e−p|y|j´
(17.16)
for some constant p as |y| →∞along the real axis. The function is said to be “SUB-GAUSSIAN”
or “SUPER-GAUSSIAN” respectively if
k < 2
[“SUB-GAUSSIAN”]
(17.17)
k > 2
[“SUPER-GAUSSIAN”]
(17.18)
Theorem 33 (HILLE’S HERMITE WIDTH-OF-CONVERGENCE)
(i) The domain of convergence of a Hermite series is the inﬁnite STRIP about the real y-axis bounded
by
|Im(y)| = w
(17.19)
(ii) For an ENTIRE function, that is, f(y) which has no singularities except at inﬁnity, the width is
w =
(
∞
0
if k > 1
if k < 1
(17.20)
(iii) For SINGULAR functions, let τ denote the absolute value of the imaginary part of the location
of that singularity which is closest to the real y-axis, and let p denote the constant in the deﬁnition
of real axis decay. Then
w =





τ
smaller of [p, τ]
0
if k > 1
if k = 1
if k < 1
(17.21)
Theorem 34 (HERMITE RATE-OF-CONVERGENCE)
(i) If the strip of convergence has a ﬁnite width w, then
an ∼O
³
e−w√2n+1´
,
(17.22)
that is, subgeometric convergence with exponential convergence index r = 0.5.
(ii) For entire functions, the exponential convergence index r is
r
=
k/(2 [k −1])
(SUPER-GAUSSIAN, that is, k > 2)
(17.23)
r
=
k/2
(SUB-GAUSSIAN, that is, k < 2)
(17.24)
(iii) Geometric convergence is possible only for entire functions and only for these two cases:
(a)
f(y) has k = 2
[Gaussian decay; p need not equal 1/2]
(17.25)
(b)
f(y) is Super-Gaussian (k > 2) and the scaling factor α is varied
(17.26)
with the truncation N as described in Boyd (1984a)

17.4. HERMITE FUNCTIONS
351
(iv) If the function f(y) decays ALGEBRAICALLY with y so that
f(y) ∼O
¡
1/|y|δ¢
as
|y| →∞
(17.27)
and if the function has p continuous derivatives on [−∞, ∞] (with the (p+1)-st derivative contin-
uous except at a ﬁnite number of points), then
an ∼O
µ 1
nq/2
¶
(17.28)
where
q = smaller of [p + 3/2, δ −5/6]
(17.29)
Eq. (17.28) only gives a lower bound on the convergence rate; it is known that the Hermite
coefﬁcients for f(y) ≡1 converge as O(n−1/4) even though (17.28) can guarantee only that the
coefﬁcients will diverge no faster than n5/12.
Part (i) was proved by Hille (1939, 1940a,b), (ii) and (iii) by Boyd (1984a), and (iv) by Bain
(1978).
Whew! These theorems are rather complicated, but they do illustrate a couple of im-
portant themes that seem to apply to other types of expansions, too. First, the rate of
convergence depends on how rapidly or how slowly f(y) decays as |y| →∞. When k > 1,
that is to say, when the function is decaying faster than an exponential whose argument is
linear in y, the singularities will determine the width of the strip of convergence, just as for
a Chebyshev series on a ﬁnite interval. When k < 1, however, the slowness of the real axis
decay has a more devasting effect on convergence than do the poles and branch points;
when k = 1, either the rate of decay or the location of the nearest pole may determine the
width of the strip of convergence.
Second, for entire functions the convergence is fastest when f(y) is decaying at the same
rate as the exp(−0.5y2) factor built into the basis functions: Supergeometric convergence is
possible for this case. The series converges more and more slowly, however, as the rate of
decay varies more and more from that of exp(−0.5y2), regardless of whether the variation
is to decay more rapidly (as a “Super-Gaussian”) or more slowly (“Sub-Gaussian”).
Third, functions which decay algebraically with y have Hermite series whose coefﬁ-
cients decrease algebraically with n. (Note that (17.28) gives only a lower bound on the
algebraic index of convergence, so further work is needed). It is striking that whereas the
continuity of one additional derivative would increase the algebraic index of convergence
by 1 for a Chebyshev series, it increases the algebraic index by only (1/2) for a Hermite
series — in other words, we gain only a factor of 1/
√
N for each additional continuous
derivative for Hermite. This is another penalty of the unboundedness of the interval. The
spacing between adjacent collocation points decreases only as 1/
√
N, so (17.28) is not too
surprising.
Weideman(1992) shows that the spectral radius of the Hermite differentiation matrices
is O(
√
N) for the ﬁrst derivative and O(N) for the second derivative. This is equivalent
to the statement that the maximum timestep for an explicit time-marching algorithm for
a PDE which is second order in space is τmax ∼O(1/N). The reason is that the Hermite
collocation points, which are almost uniformly spaced as for a Fourier or ﬁnite difference
scheme, have an average grid spacing which increases only as N 1/2 instead of N because
the span of the grid points is also increasing as O(N 1/2). If we solved the same problem
using Fourier domain truncation with the domain size L increasing as O(N 1/2), then the
Fourier grid would be almost indistinguishable from the Hermite grid and the maximum
timestep would also decrease as slowly as O(1/N).

352
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
Thus, for the same N and for grid points spanning the same interval [−L, L], Hermite
algorithms, the sinc method, Fourier domain truncation, and ﬁnite differences with domain
truncation all have similar timestep limits.
Weideman(1992) has proved that Hermite differentiation matrices have additional prop-
erties that are numerically desirable. Both the Galerkin and collocation ﬁrst derivative
matrices have purely imaginary eigenvalues while the second derivative matrices have
only real, negative eigenvalues. All these matrices are well-conditioned. In addition, the
Galerkin matrices are banded and are either skew-symmetric (ﬁrst derivative) or symmet-
ric (second derivative) for the orthonormal basis.
Although we can evaluate the Hermite functions and their derivatives through a three-
term recurrence — hardly a major programming challenge — the grid points must be
looked up in a mathematical handbook. Consequently, Hermite functions are not as easy
to program as sinc or rational Chebyshev functions.
The latter have the major advantage that they may be evaluated via the Fast Fourier
Transform. Orszag(1986), Boyd(1992c) and Dutt and Rokhlin(1993) have devised fast trans-
forms applicable to Hermite functions. However, these are much more expensive than a
standard FFT (at least a factor of four for N ∼O(100)), and none of these algorithms has yet
been applied to any purpose except self-demonstration. The inapplicability of the standard
FFT is another black mark against Hermite functions.
One virtue of Hermite functions is that these are (i) the exact eigenfunctions of the quan-
tum mechanical harmonic oscillator and (ii) are the asymptotic eigenfunctions for Mathieu’s
equation, the prolate spheroidal wave equation, the associated Legendre equation, and
Laplace’s Tidal equation. The reason for this special role is that the Hermite functions
solve the eigenvalue problem
uyy +
£
λ −y2¤
u = 0
u(−∞) = u(∞) = 0
(17.30)
where λ is the eigenvalue. If we replace (17.30) by the more general equation
uyy +
£
λ −y2 + p(y)
¤
u = 0,
(17.31)
the exponential decay u(y), forced by the −y2 term, makes p(y) irrelevant, at least if this
perturbation is small near y = 0. It follows that (17.30) is “generic” in the sense that its
solutions will approximate those of (17.31) for small but otherwise arbitrary p(y).
This close connection with the physics makes Hermite functions a natural choice of
basis functions for many ﬁelds of science and engineering. One modern area of great in-
terest is equatorial oceanography and meteorology. One or two Hermite functions give
very accurate approximations to equatorially-trapped waves when linearized about a rest-
ing state. The same functions have been very valuable in solving equatorial jet and wave
reﬂection problems as reviewed in Moore and Philander(1977).
The Vlasov-Maxwell equation of plasma physics has been another important applica-
tion. The velocity u is not an unknown, as in conventional hydrodynamics, but is an inde-
pendent coordinate. This is important because the usual ﬂuid advection term is multiplica-
tion by u in the Vlasov equation, and the Galerkin representation is a banded matrix, elimi-
nating a slow Hermite grid-to-spectral transform. The u-derivatives also generate a sparse
matrix representation because the derivative of the j-th Hermite function is a weighted
sum of the (j −1)-st and (j + 1)-th Hermite functions. As a result, the Vlasov equation —
although variable coefﬁcient — may be integrated at a cost which is linear in the Hermite
truncation N, versus a quadratic dependence when Hermite functions are applied to the
Navier-Stokes equations.
The irony is: Although the close connection between simple models and Hermite func-
tions motivated these numerical studies in equatorial ﬂuid dynamics and plasma physics,

17.5. SEMI-INFINITE INTERVAL: LAGUERRE FUNCTIONS
353
there are serious problems with straightforward application of the Hermite Galerkin method.
In equatorial oceanography, the difﬁculty is that for many important problems such as
Yoshida’s 1959 model of an equatorial jet and Moore’s theory for reﬂection from an east-
ern boundary, the ﬂow decays algebraically with latitude so that the Hermite coefﬁcients
decay algebraically, too. This slow convergence can be ﬁxed by applying sum acceleration
methods (Boyd and Moore, 1986, and Holvorcem, 1992).
Similarly, early calculations in plasma physics were bedeviled by ﬁlamentation in the
velocity coordinate, which necessitated N >> 100 to compute the solution for large times.
This was solved by a ﬁlter introduced by Klimas(1987) and Klimas and Farrell(1994), who
used a tensor product Fourier basis instead of a Fourier-Hermite scheme. Holloway(1996a,b)
and Schumer and Holloway(1998) showed that the convergence rate is greatly improved
by scaling the Hermite functions by a constant. (This is a good strategy for general applica-
tions, too, as suggested by Boyd(1984a) and Tang(1993).) The scaled-and-ﬁltered Hermite
algorithm is very effective for the Vlasov equation as shown by Holloway and Schumer.
The irony is that both modiﬁcations pull the numerical solution away from the unﬁltered
and unscaled analytical approximation which motivated the choice of Hermite functions
in the ﬁrst place.
17.5
Laguerre Functions: Basis for the Semi-Inﬁnite
Interval
The Laguerre functions are a complete orthogonal basis for the domain x ∈[0, ∞]. They are
close cousins of the Hermite functions and have a similar form: the product of a decaying
Table 17.3: A Selected Bibliography of Laguerre Function Theory & Applications
References
Comments
My Name Is Legion
Many applications in quantum chemistry
Schwartz(1963)
Effects of singularities on rate-of-convergence
Francis(1972)
Vertical structure in weather forecasting model
using Ln, not Laguerre function, as basis.
Showed this scheme needs prohibitively short timestep
Hoskins(1973)
Comment on Francis; Legendre basis requires a
constraint which Laguerre does not
Gottlieb&Orszag(1977)
Wave equation and heat equation
Maday&Pernaud-Thomas
Theory; hyperbolic PDEs
&Vandeven (1985)
Phillips&Davies(1988)
Semi-inﬁnite spectral elements
Mavriplis(1989)
Legendre spectral elements coupled with
one semi-inﬁnite element with Laguerre
Coulaud&Funaro
Elliptic PDEs in exterior domains
&Kavian(1990)
Funaro (1990b,1992b)
Theory
Boyd (1992c)
Fast Multipole Methods provide fast Laguerre transform
Iranzo&Falqu´es (1992)
Comparisons with rational Chebyshev TLn
Good examples & attention to practical details
DeVeronico & Funaro
Spectral elements for wave propagation with Laguerre basis
& Reali(1994)
for the end elements, which extend to inﬁnity
Khabibrakhmanov&Summers(1998)
Generalized Laguerre for nonlinear equations
Black(1998)
spectral element alternative to Laguerre: employs the mapping
of Boyd(1987b) from semi-inﬁnite domain into ﬁnite interval

354
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
exponential with a polynomial:
φn(x) ≡exp(−x/2) Ln(x), n = 0, 1, . . .
(17.32)
where Ln(x) is the n-th Laguerre polynomial. Three-term recurrence relations for evaluat-
ing both the basis functions and their derivatives are given in Appendix A.
If a function f(x) decays exponentially as |x| →∞, then the Laguerre series for f will
usually converge exponentially fast within the largest parabola, with focus at the origin,
which is free of singularities of f(x). However, it seems likely that very rapidly growing
or decaying functions, such as an exponential-of-an-exponential, may have series that con-
verge only on the positive real x-axis. However, we have not seen any investigation of this
in the literature.
We will not discuss Laguerre functions in detail because (i) their theory is very similar to
Hermite functions and (ii) there have been few applications of Laguerre functions outside
of quantum mechanics as indicated by the brevity of Table 17.3. Within quantum chemistry,
however, there have been lots and lots of applications.
The reason is that the Laguerre functions are the exact radial factors for the eigen-
functions of the hydrogen atom. In the Linear Combinations of Atomic Orbitals (LCAO)
method, basis functions are constructed by using hydrogenic orbitals centered on the ﬁrst
atom plus hydrogenic orbitals centered on the second atom and so on. Thus, Laguerre
functions (multiplied by spherical harmonics) are the building blocks for many Galerkin
computations of molecular structures as explained in Chapter 3. The hydrogen s-orbitals,
which were employed to approximate the H+
2 ion in Chapter 3, are actually just the lowest
Laguerre functions, φ0(r/[a0/2]) where a0 is the Bohr radius of the hydrogen atom.
Just as for Hermite functions, the Laguerre basis always implicitly contains a scale fac-
tor – in this case, the Bohr radius.
Iranzo and Falqu´es (1992) give detailed comparisons between Laguerre functions and
the rational Chebyshev functions for the semi-inﬁnite interval (Sec. 11 below). Some theory
is given in Funaro’s (1992) book and his two earlier articles listed in Table 17.3.
Mavriplis (1989) is unusual in employing Laguerre polynomials – without the expo-
nential – as the basis. This unorthodoxy makes it easier to match the Laguerre series with
Legendre polynomial series in a spectral element (domain decomposition) computation.
However, it is has the disadvantage that the absolute error of her solution is unbounded as
x →∞.
This seems disastrous, but really is not. The true is that no standard basis can resolve
an inﬁnite number of oscillations with a ﬁnite number of basis functions. The Hermite
or Laguerre function or rational Chebyshev series for a function like exp(−x) cos(x) must
inevitably have large relative error at inﬁnity because the function continues to oscillate for
all x whereas a truncated sum of basis functions must have only a ﬁnite number of zeros,
and will therefore vary monotonically for some sufﬁciently large x. However, the absolute
error is small everywhere because both the exact solution and the numerical approximation
(except for Mavriplis’ scheme) are exponentially small where the relative error is not small.
The Laguerre polynomial series is guilty of only making this breakdown in relative er-
ror, which is hidden in other methods, obvious through a large absolute error. This break-
down is also present, though implicit, with all the other standard basis sets.
The only way out is to add special basis functions to a standard series as explained in
Sec. 13.

17.6. NEW BASIS SETS VIA CHANGE OF COORDINATE
355
17.6
Mapping Methods: New Basis Sets Through a Change
of Coordinates
By using a transformation that maps an inﬁnite interval into a ﬁnite domain, it is possible
to generate a great variety of new basis sets for the inﬁnite interval that are the images
under the change-of-coordinate of Chebyshev polynomials or Fourier series. This strategy
is merely a generalization of the particular map x = cos(t), which transforms the cosine
functions into the Chebyshev polynomials.
An inﬁnite variety of maps is possible, but one can make some useful points by consid-
ering three particular classes of mappings, each illustrated by an example:
1. “Logarithmic maps”:
y = arctanh(x),
x ∈[−1, 1]
(17.33)
2. “Algebraic maps”
y =
L x
√
1 −x2 ,
x ∈[−1, 1]
(17.34)
3. “Exponential maps”
y = sinh(Lt),
t ∈[−π, π]
(17.35)
where y ∈[−∞, ∞]. The names for these families of maps are chosen by how rapidly y
increases with x →±1.
Grosch & Orszag(1977) and Boyd (1982a) were big boosters of algebraic mappings.
These lead to the rational Chebyshev functions, described in the next seven sections. Their
strength is that they are “minimalist” mappings, creating a not-very-violent change from
one coordinate to the other, and they have optimal properties in the limit N →∞for ﬁxed
L.
Nevertheless, the other two families of mappings are useful, too. The logarithmic map-
pings have the disadvantage that well-behaved functions on the inﬁnite interval are turned
into nasty functions on x ∈[−1, 1]. For example, the mapping y = arctanh(x) transforms
sechα(y) →(1 −x2)α
(17.36)
The Hermite and rational Chebyshev series for the hyperbolic secant function converge
exponentially fast for any positive α, even non-integral α. However, the function (1 −x2)α
has branch points at both endpoints unless α is an integer.
The arctanh mapping is useful almost entirely in the reverse direction, transforming
functions with endpoint singularities at the ends of a ﬁnite interval into well-behaved func-
tions on the inﬁnite interval. One can then apply a standard inﬁnite interval basis to obtain
very accurate solutions to singular problems (Chap. 16, Secs. 5).
There is one exception: in the theory of solitary waves and of shocks, there are many
perturbation series which involve only powers of the hyperbolic secant and/or tangent.
The arctanh mapping (with L = 1) transforms these polynomials in hyperbolic functions
of y into ordinary polynomials in x, making it easy to compute these expansions to high
order (Boyd, 1995a, 95j).
The exponential maps go so far to the opposite extreme that they are inferior to the
algebraic maps in the limit N →∞. Cloot and Weideman(1990, 1992), Weideman and
Cloot(1990) and Boyd (1994b) have shown that the Weideman and Cloot map (17.35) is

356
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
nevertheless extremely efﬁcient in real world situations because the asymptotic limit is
approached very, very slowly with N. We will illustrate the effectiveness of the Weideman-
Cloot change-of-coordinate later in the chapter. First, though, we shall turn to algebraic
mappings where there has been much wider experience.
17.7
Algebraically Mapped Chebyshev Polynomials: TBn(y)
These basis functions are deﬁned on the interval y ∈[−∞, ∞] by
TBn(y) ≡Tn(x) ≡cos(nt)
(17.37)
where the coordinates are related via
y
=
L x
√
1 −x2
;
x
=
y
p
L2 + y2
(17.38a)
y
=
L cot(t)
;
t
=
arccot(y/L)
(17.38b)
The ﬁrst 11 TBn(y) are listed in Table 17.5. As one can see from the table or from the
right member of (17.38a), the TB2n(y) are rational functions which are symmetric about y =
0. The odd degree TB2n+1(y) are antisymmetric and are in the form of a rational function
divided by a left-over factor of
p
L2 + y2. We shall refer to all these basis functions as
the “rational Chebyshev functions on an inﬁnite interval” even though the odd degree
members of the basis are not rational. Fig. 17.4 illustrates the ﬁrst four odd TBn(y). Note
that the map parameter merely changes the y-scale of the wave (the oscillations become
narrower when L increases) without altering the shape, so these graphs for L = 1 apply for
all L if we replace y by (y/L).
Figure 17.4: Graphs of the ﬁrst four rational Chebyshev functions on x ∈[−∞, ∞]. Because
the odd degree TBn(y) are all antisymmetric about y = 0, they are illustrated only for
positive y. All asymptote to 1 as y →∞.

17.7. RATIONAL CHEBYSHEV FUNCTIONS: TBN
357
Table 17.4: A Selected Bibliography of Rational Chebyshev Functions
References
Comments
Grosch&Orszag(1977)
Algebraic map: inﬁnite interval in y to x ∈[−1, 1]
Tn(x) basis, equivalent to rational Chebyshev in y
Boyd (1982a)
Steepest descent asymptotics for spectral coefﬁcients
Christov (1982)
Rational functions related to TBn;
application to rational solution of Burgers-like model
Cain&Ferziger&Reynolds(1984)
Map inﬁnite interval to ﬁnite through y = Lcotan(x)
and apply Fourier in x; equivalent to TBn(y)
Boyd (1985a)
Change-of-coordinate to detour around interior
singularity into the complex plane
Boyd (1987a)
Theory and asymptotics for TBn
Boyd (1987b)
Theory & examples for semi-inﬁnite interval: TLn
Boyd (1987c)
Quadrature on inﬁnite and semi-inﬁnite intervals
Lin & Pierrehumbert (1988)
Tensor product of TLn(z) ⊗TBm(y)
for two-dimensional baroclinic instability
Boyd (1990a)
Theory; relation of TBn to other rational basis sets
Christov&Bekyarov(1990),
Nonlinear eigenvalue (soliton); basis is cousin of TBn
Bekyarov&Christov(1991)
Boyd (1990b,1991a,1991d,
TBn/radiation function basis for nonlocal solitons
1991e,1995b,1995j)
Boyd (1990d)
TBn/radiation function basis for quantum scattering
(continuous spectrum)
Boyd (1991d,1995a)
TBn for nonlinear eigenvalue (soliton)
Weideman&Cloot(1990)
Comparisons with the Weideman-Cloot sinh-mapping
Cloot (1991)
Comparisons with solution-adaptive mapping
Cloot&Weideman (1992)
Comparisons with the Weideman-Cloot sinh-mapping;
adaptive algorithm to vary the map parameter with time
Liu&Liu&Tang(1992,1994)
TBn to solve nonlinear boundary value problems for
heteroclinic (shock-like) & homoclinic (soliton-like) solutions
Falqu´es&Iranzo(1992)
Edge waves in the ocean with TLn
Boyd (1993)
Algebraic manipulation language computations
Chen (1993)
Eigenvalues (hydrodynamic stability) using TLn
Weideman(1994a,1994b,1995a)
Error function series, good for complex z, using
basis {(L + iz)/(L −iz)}n, n = −∞, ∞
Weideman(1995b)
Hilbert Transform computation via {(L + iz)/(L −iz)}n
Compares well with alternative Fourier algorithm.
Boyd (1996c)
Legendre, quantum and tidal equations;
traps and snares in eigencalculations
Gill&Sneddon(1995,1996a,1996b)
Complex-plane maps (revisited) for eigenfunctions
singular on or near interior of (real) computational domain
Sneddon (1996)
Complex-plane mappings for a semi-inﬁnite interval
Yang&Akylas(1996)
TBn/radiation function basis for nonlocal solitons
Matsushima&Marcus(1997)
Polar coordinates: radial basis is rational functions
which are images of associated Legendre functions
to defeat the “pole problem”

358
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
Table 17.5: Rational Chebyshev functions for the inﬁnite interval: TBn(y).
(For map parameter L = 1).
n
TBn(y)
[Symmetric about y = 0]
0
1
2
(y2 −1)/(y2 + 1)
4
(y4 −6y2 + 1)/(y2 + 1)2
6
(y6 −15y4 + 15y2 −1)/(y2 + 1)3
8
(y8 −28y6 + 70y4 −28y2 + 1)/(y2 + 1)4
10
(y10 −45y8 + 210y6 −210y4 + 45y2 + 1)/(y2 + 1)5
[Antisymmetric about y = 0]
1
y/(y2 + 1)1/2
3
y(y2 −3)/(y2 + 1)3/2
5
y(y4 −10y2 + 5)/(y2 + 1)5/2
7
y(y6 −21y4 + 35y2 −7)/(y2 + 1)7/2
9
y(y8 −36y6 + 126y4 −84y2 + 9)/(y2 + 1)9/2

17.7. RATIONAL CHEBYSHEV FUNCTIONS: TBN
359
Figure 17.5: Schematic showing the mapping relationships between the rational functions
TBn(y), the Chebyshev polynomials Tn(x), and the Fourier functions cos(nt). The large
arrows indicate the mappings that transform one set of basis functions into another. Each
series converges within the cross-hatched region; the mappings transform the boundaries
of one region into those of another.
Fig. 17.5 shows the mappings between y, x, and t and the relationships between the
basis functions in each coordinate and their domains of convergence. The series converges
within the largest shaded area that does not contain a singularity of the function being
expanded.
The rational Chebyshev functions are orthogonal on [−∞, ∞] with the weight function
(for L = 1) of 1/(1 + y2). However, the easiest way to program is to use the trigonometric
representation. The necessary derivative conversion formulas are given in Appendix E.
The earliest use of these functions (without a special notation) is Boyd (1982a). How-
ever, Grosch & Orszag (1977) implicitly used the same basis by mapping to the interval
x ∈[−1, 1] and applying ordinary Chebyshev polynomials in x. The most complete treat-
ment is Boyd (1987a).
These orthogonal rational functions have many useful properties. For example, if the
differential equation has polynomial or rational coefﬁcients, one can show [by converting the
equation from y to the trigonometric argument t and using trigonometric identities] that
the corresponding Galerkin matrix will be banded. A fuller discussion is given in Boyd
(1987a).
The rate of convergence of the TBn(y) series is normally exponential but subgeomet-
ric. In the same way that the convergence domain of both sinc and Hermite expansions
is a symmetric strip parallel to the real y-axis, the domain of convergence for the rational
Chebyshev functions is the exterior of a bipolar coordinate surface in the complex y-plane
with foci at ±iL as shown in the left panel of Fig. 17.5. In words, this means that if f(y) is
rational with no singularity at ∞, then the TBn(y) expansion of f(y) will converge geomet-
rically. The closer the poles of f(y) are to those of the mapping at ±iL, the more rapid the
convergence.
In practice, geometric convergence is rare because the solutions of most differential

360
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
Figure 17.6: Graphical construction, devised by Mark Storz, of the interpolation points
for the rational Chebyshev functions which are orthogonal on y ∈[−∞, ∞]. The evenly
spaced grid points on the semicircle of unit radius (dots) become the roots of the TBn(y)
(×’s) on the line labelled “y”. L is the map parameter
equations are singular at inﬁnity. This limits the convergence domain of the TBn(y) to the
real y-axis and reduces the convergence rate from geometric to subgeometric. Nonetheless,
the rational Chebyshev functions are still an extremely useful basic set, easy to program
and just as efﬁcient as the Hermite and sinc expansions in almost all cases.
Fig. 17.6 is Storz’ graphical construction of the interpolation grid. Note that — in con-
trast to Chebyshev polynomials — the smallest distance between adjacent grid points is
O(1/N). This implies that the explicit time-stepping restrictions will be no more severe for
these orthogonal rational functions than when ﬁnite differences replace them as proved by
Weideman (1992).
He shows that rational Chebyshev differentiation matrices have good properties: like
those of Hermite functions, the Galerkin matrices are banded and the ﬁrst derivative is
skew-symmetric while the second derivative is symmetric. The corresponding collocation
matrices are full matrices without symmetry. However, Weideman argues that the pseu-
dospectral differentiation matrices are “asymptotically normal” in the sense that determin-
ing timestep limits from the eigenvalues of the differentiation matrices is legitimate.
In contrast, the Legendre polynomial differentiation matrices are highly non-normal.
The concept of “pseudoeigenvalues” is needed to realistically estimate timesteps (Trefethen
and Trummer, 1987, Trefethen, 1988, Reddy and Trefethen, 1990, and Trefethen et al., 1993).
Weideman (1992, 1994a, 1994b, 1995a, 1995b) is but one of several authors who ﬁnd it
convenient to work with complex-valued forms of the rational Chebyshev functions. Chris-
tov (1982) and Christov and Bekyarov (1990), for example, use linear combinations of the
functions
ρn ≡
1
√π
(iy −1)n
(iy + 1)n+1 ,
n = 0, ±1, ±2, . . .
(17.39)
These functions were introduced by Norbert Weiner as the Fourier transforms of Laguerre
functions (Higgins, 1977). Boyd (1990a) shows that with the change-of-coordinate y =
cot(t), these complex-valued functions are simply the terms of a Fourier series in t, or
the difference of two such functions, and thus are mathematically equivalent to the TBn
deﬁned here or the SBn which will be deﬁned in the section after next. One may use
whatever form of the rational Chebyshev functions is convenient; we prefer the TBn basis
deﬁned above.
Matsushima and Marcus (1997) have introduced an interesting variant: rational func-
tions which are the images of associated Legendre functions rather than Chebyshev poly-

17.8. BEHAVIORAL VERSUS NUMERICAL BOUNDARY CONDITIONS
361
nomials. Although this sacriﬁces the applicability of the Fast Fourier Transform, the ra-
tional associated Legendre functions, when used as radial basis functions in polar coor-
dinates, have no “pole problem”. This means that when using an explicit time-marching
algorithm, one can use a time step an order of magnitude larger than with a rational Cheby-
shev basis. For boundary value or eigenproblems, or when the time-marching method is
implicit, this advantage disappears, so the rational associated Legendre functions are use-
ful for one restricted but important niche: explicit time-integrations of unbounded domains
in polar coordinates.
17.8
Behavioral versus Numerical Boundary Conditions
In Chap. 6, Sec. 3, we brieﬂy discussed two kinds of boundary conditions: “behavioral”
and “numerical”. When a problem is periodic, the boundary conditions are behavioral,
that is to say, we require that the solution has the behavior of spatial periodicity. We can-
not specify in advance what values u(y) will take at the ends of the interval. In contrast,
when we solve a non-periodic boundary value problem, we usually must explicitly impose
numerical constraints such as u(−1) = α, u(1) = β. Behavioral boundary conditions, like
what are called “natural” conditions in ﬁnite element theory, do not require any modiﬁca-
tions to the basis set. The sines and cosines of the Fourier series, for example, automatically
and individually have the behavior of periodicity. In contrast, numerical boundary condi-
tions are “essential”, to again borrow a label from ﬁnite element theory: They must be
imposed as explicit constraints.
Boundary conditions at inﬁnity may usually be treated as either “behavioral” or “nu-
merical”. This ﬂexibility is useful because there are advantages and drawbacks to both
approaches. We will describe each in turn.
Although a general theorem is lacking, it is usually true that the behavioral condition of
boundedness at inﬁnity is sufﬁcient to uniquely determine the solution. The reason is that
the differential equation is usually singular at inﬁnity so that only one of the many linearly
independent solutions is bounded at that point. If we use an unmodiﬁed series of TBn(y)
as the basis, the series will automatically converge to that solution which is ﬁnite at inﬁnity
in the same way that a trigonometric series will automatically converge to that solution
which is periodic.
It is rather ironic, but, because we can ignore the boundary conditions in setting up the
pseudospectral or Galerkin’s matrix, the singularity of the differential equation at inﬁnity
actually makes the problem easier instead of harder, as one might have expected. The same
thing is usually true of endpoint singularities when the interval is ﬁnite. The Chebyshev
polynomials and the Associated Legendre functions, for example, both solve second order
Sturm-Liouville differential equations which are singular at x = ±1. The ODE
p
1 −x2
hp
1 −x2 ux
i
x + λ u = 0
(17.40)
has solutions which are analytic at ±1 only when (i) λ = n2 and (ii) u(x) is Tn(x). If
one blindly applies a Chebyshev basis to (17.40) — without explicitly imposing boundary
conditions — the eigenvalues of the pseudospectral or Galerkin’s matrix will nonetheless
converge to n2 and the corresponding matrix eigenfunctions will have all but one element
equal to zero.
Gottlieb and Orszag (1977, pg. 32) point out that it is precisely such singular Sturm-
Liouville problems that furnish the best basis sets: Because we need not impose bound-
ary conditions on the solutions of (17.40) [except the implicit one of being analytic at the
endpoints], the Chebyshev polynomials will give geometric convergence for all functions

362
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
independent of their boundary behavior, so long as f(x) is analytic at the endpoints. When
the eigenfunctions of a Sturm-Liouville problem have to satisfy speciﬁc numerical bound-
ary conditions such as u(±1) = 0, series of these eigenfunctions converge geometrically
only for equally speciﬁc and special classes of functions.
Rule-of-Thumb 15 (Behavioral Boundary Conditions at Inﬁnity) If the desired solution of
a differential equation is the only solution which is bounded at inﬁnity, then one may usually obtain
exponential accuracy by using an unmodiﬁed series of the rational functions TBn(y).
If this doesn’t work, or doesn’t work well, one can always explicitly impose the constraint that
u(y) vanishes at inﬁnity, but usually this is an unnecessary waste of programming hours.
The best way to explain this rule-of-thumb is by means of a speciﬁc example. The
differential equation (Boyd, 1987b)
y uyy + (y + 1) uy + λ u = 0
y ∈[0, ∞]
(17.41)
is deﬁned on the semi-inﬁnite interval [0, ∞], and therefore strictly belongs in Sec. 12, but
it illustrates behavioral boundary conditions very well. The problem is singular both at the
origin and at inﬁnity. Eq. (17.41) has solutions which are analytic at both endpoints only
when (i) λ = n where n is an integer ≥0 and (ii) u(y) is the (n-1)-st Laguerre function.
When we expand u(y) as a series of the rational functions TLn(y) without the imposition
of boundary conditions, it works — but just barely. With N = 40, the lowest numerical
eigenfunction agrees with u(y) = exp(−y), the exact answer, only to a couple of decimal
places. The correct eigenvalue (λ = 1) is mirrored by a pair of complex conjugate eigen-
values with real parts approximately equal to 1 and imaginary parts on the order of 0.01.
For so large an N, this is astonishingly poor accuracy.
The rub is that the other linearly independent solution of (17.41) when λ is a positive
integer does blow up as |y| →∞— but only as a power of y rather than exponentially. The
remedy is to make a change-of-unknown to a new variable w(y) deﬁned by
w = exp(y/2) u(y)
(17.42)
which is the solution of
y wyy + wy +
·
−1
2 −1
4 y + λ
¸
w = 0
(17.43)
The exact eigenvalues are unchanged by the transformation except for the disappearance
of λ = 0, which corresponds to the trivial eigenfunction u(y) ≡1. After the change-
of-unknown (17.42), N = 40 gives 12 accurate eigenvalues, and these are all real. From
(17.42), we see that the offending second solutions of (17.43) blow up exponentially, rather
than algebraically, as |y| →∞, and the unmodiﬁed spectral series has a much easier time
separating the true eigenfunctions from the unbounded solutions.
We see why the rule-of-thumb is not a theorem; it still applies to (17.41) in principle,
but is extremely inefﬁcient for this problem without the change-of-unknown. Eq. (17.41)
combines two types of behavioral boundary conditions in a single example: the solution
must be bounded at both endpoints even though one is ﬁnite and the other at ∞.
There seems to be no simple theorem that covers all eventualities. Gottlieb and Orszag
(1977, pg. 152–153) discuss a Sturm-Liouville eigenproblem whose solutions are the J7(y)
Bessel functions. The boundary condition at y = 0 is that u(y) be analytic in spite of the fact
that the differential equation is singular there. Blindly applying Chebyshev polynomials
gives an approximation that converges on the true eigenvalue as N increases; indeed, with
N = 26, the approximation is exact to ﬁve decimal places! The only problem is that when

17.9. STRATEGY FOR SLOWLY DECAYING FUNCTIONS
363
we impose the boundary conditions u(0) = uy(0) = 0 with the same N, we obtain eleven
decimal places.2
The conclusion is that in coping with behavioral boundary conditions, one should be
ﬂexible, prepared to modify the basis set or explicitly impose constraints if need be. “Usu-
ally”3, however, treating boundary conditions at inﬁnity as “behavioral” or “natural” is
successful. Boyd (1987a, b) gives a dozen examples; except for (17.41), using the uncon-
strained TBn(y) or TLn(y) gave many decimal places of accuracy with a small number of
basis functions.
Nevertheless, it is possible to treat inﬁnity as a numerical boundary condition by impos-
ing
u(∞) = 0
(17.44)
because the solutions to most problems decay as y →∞. The programming is more com-
plex because the basis must be modiﬁed. On the other hand, if the solution is zero at one
or both endpoints, we can reduce the size of the basis set without a loss of accuracy by
switching to new basis functions which also vanish at the boundaries.
Indeed, if u(x) decays exponentially fast, then it is true that
dku
dyk (∞) = 0
(17.45)
for any ﬁnite k. Thus, we have the theoretical ﬂexibility to impose an arbitrary number of
endpoint zeros on the basis.
In practice, this freedom should be used cautiously. If all the basis functions have high
order zeros at the endpoints, they will all be almost indistinguishable from zero — and each
other — over a large part of the interval. This may give numerical ill-conditioning. Merilees
(1973a) shows that Robert’s suggested basis functions for the sphere — an ordinary cosine
series multiplied by sinm(θ) to mimic the m-th order zero of the corresponding spherical
harmonic — is disastrously ill-conditioned for large m. Furthermore, imposition of high
order zeros complicates the programming.
Nonetheless, Boyd (1988f) obtained good accuracy for the Flierl-Petviashvili monopole,
discussed in Appendix D, by applying the basis
φ2n(y) ≡TB2n(y) −1
(17.46)
which vanishes as 1/y2 as |y| →∞. The analytical one-basis function approximation was
sufﬁciently accurate to serve as a good ﬁrst guess for the Newton-Kantorovich iteration.
The N=1 Chebyshev approximation — u(y) ≡a constant — was considerably less accurate!
17.9
Expansions for Functions Which Decay Algebraically
with y or Asymptote to a Constant
The rational function
f(y) ≡
1
1 + y2
(17.47)
2The singularity of the differential equation at the origin actually forces the ﬁrst six derivatives of J7(y) to
vanish at the origin, but it is not necessary to impose all these constraints to obtain very high accuracy.
3A pure mathematician would loathe the word “usually”, but as Briggs et al. (1981) note, “numerical analysts
are the academic world’s greatest plumbers.”

364
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
is rather harmless, but both Hermite series and sinc expansions fail miserably in approxi-
mating it. The trouble with the former is that the Hermite functions all decay exponentially
(like Gaussians) for very large y. One can show that the transition from oscillation to decay
occurs for the n-th Hermite function at the “turning points” given by
yt = ±
√
2n + 1
(17.48)
Now f(100) is still as large as 1/10,000, so it follows that to obtain four decimal place
accuracy for (17.47), we need to have a Hermite basis large enough so that at least some of
the Hermite functions have turning points at |y| = 100 or larger. Eq. (17.48) implies that
we need at least 5,000 Hermite functions to achieve this — a ridiculously large number. As
explained in Sec. 3, the Hermite series of a function which decays algebraically with |y| will
have coefﬁcients an that decay algebraically with n.
The sinc expansion is similarly in trouble: the coefﬁcients of the Whittaker cardinal se-
ries are f(jh), and for a slowly decaying f(y) and a reasonably small grid spacing h, it
follows that f(jh) will not be small until j is huge — in other words, we must keep a pre-
posterously large number of sinc functions in the series to obtain even moderate accuracy.
The orthogonal rational basis functions, however, have no such problem. Inspecting
Table 17.5, we see that
f(y) ≡1
2 {TB0(y) −TB2(y)}
(17.49)
if L = 1. Even if we choose a different map parameter, the change of variable y = L cot(t)
shows that
f(y[t]) =
1 −cos2(t)
1 + (L2 −1) cos2(t)
(17.50)
which has no singularities for any real t and therefore has a geometrically convergent
Fourier cosine series. The TBn(y) expansion of f(y) has the same coefﬁcients as the Fourier
series (in t) of f(y[t]), so it follows that it, too, must converge geometrically for arbitrary,
real L.
Therefore, the RATIONAL CHEBYSHEV FUNCTIONS ARE THE BASIS SET OF CHOICE
FOR f(y) THAT DECAY ALGEBRAICALLY RATHER THAN EXPONENTIALLY WITH y,
OR WHICH ASYMPTOTE TO A CONSTANT AS y →∞. There are limits; if f(y) blows
up, even linearly with y, as y →∞, then its image under the mapping y →t will be inﬁnite
at t = 0, and neither the Fourier series nor the TBn(y) expansion will even be deﬁned. As
long as f(y) is ﬁnite, however, then an exponentially convergent series of rational Cheby-
shev functions is at least a possibility.
We have to be content with the vague phrase “is a possibility” because we need more
speciﬁc information about the asymptotic behavior of the function. If we consider the
function
g(y) ≡
1
(1 + y2)1/3
(17.51)
then since
y = L cot(t) ≈L/t
t ≪1
(17.52)
it follows that image of (17.51) under the mapping (17.52) will behave like
g(y[t]) ≈t2/3
t ≪1
(17.53)

17.9. STRATEGY FOR SLOWLY DECAYING FUNCTIONS
365
Table 17.6: Examples of functions which asymptote to a constant or decay algebraically
with y. These illustrate the four classes of functions that have both symmetry with re-
spect to y = 0 (denoted by S for symmetric and A for antisymmetric in the column labeled
“Code”) and also have asymptotic expansions which contain only even or only odd pow-
ers of 1/y (indicated by E or O in the “Code” column). The third and fourth columns give
the mathematical forms of these symmetries. The rightmost column indicates the restricted
basis set that is sufﬁcient to represent all u(y) that fall into this symmetry class.
u(y[t])
u(y)
Asymptotic Form
Parity with
respect to y=0
Code
Basis Set
cos(t)
y
p
1 + y2
∼y
|y| + O
µ 1
y2
¶
u(y) = −u(−y)
A & E
TB2n+1
cos(2t)
y2 −1
y2 + 1
∼1 + O
µ 1
y2
¶
u(y) = u(−y)
S & E
TB2n
sin(t)
1
p
1 + y2
∼1
|y| + O
µ 1
|y|3
¶
u(y) = u(−y)
S & O
Odd sines SB2n
sin(2t)
2y
1 + y2
∼2
y + O
µ 1
y3
¶
u(y) = −u(−y)
A & O
Even sines SB2n+1
and the Fourier and TBn(y) series will converge algebraically (an ∼O(1/n5/3)) because of
the branch point at t = 0.
There are a couple of remedies. One, discussed in Boyd (1987a), is to examine the
general Fourier series in the trigonometric coordinate t. If the asymptotic behavior of f(y)
may be represented as a series of the inverse odd powers of y, then the sine series will
converge exponentially fast. The images of the sines under the inverse mapping deﬁne a
new basis set, SBn(y) ≡sin {(n + 1)[arccot(y/L)]} for n = 0, 1, 2, . . . .4 These functions,
which are rational in y, are never needed except to approximate a function which is decaying
algebraically as |y| →∞. Even then, they may be unnecessary if f(y) may represented as
series of inverse even powers of y for |y| ≫1. Table 17.6 summarizes the cases.
The SBn(y; L) can be computed directly by introducing Y ≡y/L and then applying
the three-term recurrence
SB0 =
1
√
1 + Y 2 ,
SB1 =
2Y
1 + Y 2 ,
SBn+1 = 2
Y
√
1 + Y 2 SBn −SBn−1
(17.54)
The second option is to apply a mapping. For example, the “bad” function (17.51) has
the geometrically converging series
1
(1 + y2)1/3 =
∞
X
n=0
a2n TB2n(y1/3)
(17.55)
which is equivalent to mapping the problem from y to the trigonometric coordinate t using
y = L cot(t3).
4The indexing convention for the SB has been adjusted from the ﬁrst edition of this book so that SB0 is the
lowest basis function and the even degree SB are symmetric with respect to y = 0.

366
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
Similarly, a change-of-coordinate will redeem Hermite and sinc series if the mapping
transforms algebraic decay into exponential decay as noted by Eggert, Jarratt, and Lund
(1987). An example on the semi-ﬁnite interval:
y = exp(x) −1
y & x ∈[0, ∞]
(17.56)
Decay as O(1/y), for example, becomes decay as O(exp[−x]).
Nevertheless, if one is forced to accept the burden of a mapping, it is far simpler to solve
the transformed problem using a Fourier series rather than something more complicated
like Hermite or sinc expansions. Consequently, the earlier assertion remains true: the best
way to approximate algebraically decaying functions is to use a rational Chebyshev series,
which is a Fourier series with a change-of-coordinate. However, the possibility of applying
sinc and Hermite functions even to “bad” cases like algebraic decay is again a reminder of
the tremendous power of mappings.
17.10
Numerical Examples for the Rational Chebyshev
Functions
In oceanography, the steady north-south current of the “Yoshida jet” solves
vyy −y2v = y
(17.57)
For large y,
v(y) ∼−1
y
(17.58)
This slow, algebraic decay with |y| destroys both Hermite series and sinc expansions. Be-
cause v(y) is an antisymmetric function with odd powers of 1/y, Table 17.6 implies that the
TBn(y) will fail, too. However, the mapping from y to t will still succeed provided that
we use a sine series instead of the usual cosine series to solve the transformed differential
equation. Fig. 17.7 shows the exact solution and the 2-point, 3-point, and 4-point colloca-
tion approximations. The N = 6 series listed in the table is indistinguishable from the exact
solution to within the thickness of the curve.
Table 17.7 lists the coefﬁcients for various numbers of interpolation points. As always,
the error is the sum of two contributions. The truncation error is the neglect of all coef-
ﬁcients an with n > N; the missing coefﬁcients are represented by dashes. In addition,
those coefﬁcients that are calculated differ from those of the exact solution. As we read
a row from left to right, however, we can see this “discretization error” decrease as each
coefﬁcient converges to its exact value as N increases.
Note that because v(y) is antisymmetric, only odd basis functions (sin(t[y]), sin(3t[y]),
sin(5t[y]), etc.) were used in the expansion. All the collocation points were on the interior
of y ∈[0, ∞] (instead of [−∞, ∞]) for the same reason.

17.10. NUMERICAL EXAMPLES: RATIONAL CHEBYSHEV FUNCTIONS
367
Figure 17.7: The latitudinal velocity v(y) for the “Yoshida jet”. The map parameter L = 3.
SBn were used instead of the more common TBn to capture the very slow 1/y decay of
v(y) with spectral accuracy.
Table 17.7: The coefﬁcients of the spectral series for the Yoshida jet v(y) as computed using
various numbers of collocation points with a basis of odd SB functions.
n
2 pts.
3 pts.
4 pts.
7 pts.
21 pts.
1
-0.47769
-0.388976
-0.394428
-0.395329
-0.395324
3
0.199475
0.179639
0.176129
0.179237
0.179224
5
— —
-0.050409
-0.04471
-0.051163
-0.051147
7
— —
— —
0.001399
0.002620
0.002651
9
— —
— —
— —
0.003856
0.003740
11
— —
— —
— —
-0.000541
-0.000592
13
— —
— —
— —
-0.000452
-0.000446
15
— —
— —
— —
— —
0.000060

368
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
The second example is
uyy +
h
n(n + 1) sech2(y) + 1
i
u = Pn(tanh[y])
(17.59)
where n is an integer ≥0 and Pn(x) is the n-th Legendre polynomial.
Eq. (17.59) is merely Legendre’s differential equation transformed from x ∈[−1, 1]
to y ∈[−∞, ∞] via y = arctanh(x). On the ﬁnite interval, the differential equation is
singular at both endpoints. The boundary conditions are that the solution must be analytic
at x = ±1 in spite of the singularities. The Legendre polynomials are the only solutions
that satisfy this requirement, and only when n is an integer.
The solutions of the transformed equation (17.59) asymptote to the constant 1 as y →∞
for all n and to either 1 (even n) or -1 (odd n) as y →−∞. The coefﬁcients of the Hermite
series for such a function would decay as 1/n1/4 at the fastest. However, a rational Cheby-
shev expansion is extremely effective. The boundary conditions are natural (behavioral)
both before and after the arctanh-mapping, so it is not necessary to impose any constraints
on the TBn(y).
Fig. 17.8 compares the exact solution (solid line) with the sixteen-point pseudospec-
tral approximation for the case n = 12. Because P13(tanh[y]) is symmetric about y = 0,
only symmetric basis functions were used, and the sixteen-point approximation included
T30(y). The approximation for N = 38 (20 collocation points, all with y ≥0), was indistin-
guishable from the exact solution to within the thickness of the curve.
Figure 17.8: Solid curve: P12(tanh[y]) where P12(x) is the Legendre polynomial. Dotted
curve: numerical approximation by solving the transformed Legendre differential equation
using 16 symmetric basis functions, i. e. TB0(y), TB2(y), TB4(y), . . . , TB30(y).

17.11. SEMI-INFINITE INTERVAL: RATIONAL CHEBYSHEV TLN
369
17.11
Rational Chebyshev Functions on y ∈[0, ∞]: the TLn(y)
These basis functions are deﬁned by
TLn(y) ≡Tn(x) = cos(nt)
(17.60)
where the argument of the rational Chebyshev functions, y, is related to the argument of
the Chebyshev polynomials, x, and the argument of the trigonometric functions, t, via
y
=
L(1 + x)
1 −x
↔
x
=
y −L
y + L
(17.61)
y
=
L cot2
µ t
2
¶
↔
t
=
2 arccot
µr y
L
¶
(17.62)
The ﬁrst few functions are given explicitly in Table 17.8. The pseudospectral interpolation
points are
y = L cot2
µti
2
¶
↔
ti ≡(2i −1) π
2N + 2
i = 1, . . . , N + 1
(17.63)
Table 17.8: Rational Chebyshev functions for the semi-inﬁnite interval: TLn(y).
n
TLn(y; L)
0
1
1
(y −L)/(y + L)
2
(y2 −6yL + L2)/(y + L)2
3
(y −L)(y2 −14yL + L2)/(y + L)3
4
(y4 −28Ly3 + 70L2y2 −28L3y + L4)/(y + L)4
We will discuss these functions only brieﬂy because their characteristics are very similar
to those of the rational Chebyshev functions on y ∈[−∞, ∞] and Boyd (1987b) gives a
thorough treatment. If f(y) is rational with no singularity at ∞, then the TLn(y) series will
have geometric convergence. Usually, however, the solution will be singular at inﬁnity so
that convergence will be subgeometric.
If the differential equation has polynomial or rational coefﬁcients (in y), the Galerkin
matrix will be banded.
If f(y) asymptotes to a constant or decays algebraically with y as y →∞, then the
TLn(y) series may still have an exponential rate of convergence. A series of Laguerre
functions, however, will converge very poorly unless f(y) decays exponentially for y ≫1.
In a modest difference from the TBn(y) case, the map (17.62) shows that a cosine series in
t will give rapid convergence if f(y) has an asymptotic series as y →∞in inverse negative
powers of y. The sines are needed only to represent half-integral powers of y.
Boyd (1982b) offers guidelines for optimizing the map parameter L, but some trial-
and-error is inevitable. (The simplest criterion is: choose L to roughly equal the scale of

370
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
variation of the solution.) Fortunately, the accuracy is usually quite insensitive to L so long
as it is of the same order-of-magnitude as the optimum value. In the next section, we offer
an illustration.
17.12
Numerical Examples for Mapped Chebyshev
Methods on a Semi-Inﬁnite Interval
Example #1: Laguerre Eigenvalue Problem
uyy +
·1
y −1
4 −λ
y
¸
u = 0
(17.64a)
u(y) analytic and bounded at both y = 0 and y = ∞
(17.64b)
where λ is the eigenvalue. The exact solution is
u
=
exp
³
−y
2
´
y L1
n(y)
(17.65a)
λ
≡
n,
n an integer ≥0
(17.65b)
where L1
n(y) denotes the ﬁrst order Laguerre polynomial of degree n. Since the boundary
conditions are “behavioral” at both endpoints, unmodiﬁed TLn(y) are a good basis. The
(N + 1) × (N + 1) pseudospectral matrix always has (N+1) eigenvalues, but the (N+1)-st
eigenfunction of the original differential equation is always oscillating too rapidly to be
resolved by interpolation using only (N+1) points. Consequently, we face the difﬁculty
— inevitable for any eigenvalue problem, whether on a ﬁnite or unbounded interval —
that the lowest few eigenvalues of the matrix are good approximations to those of the
differential equation whereas the larger matrix eigenvalues are numerical artifacts.
Fig. 17.9 shows the number of “good” eigenvalues computed with 41 collocation points
as a function of the map parameter L where a “good” eigenvalue is arbitarily deﬁned as
one within 0.05 of the exact eigenvalue (17.65b). Because N is large and the eigenfunctions
are entire, the theory of Boyd (1982a) argues that L should be fairly large, and the graph
conﬁrms it. (Loptimum = 32.) It is reassuring, however, that taking L too large or small by
a factor of 2 still yields at least N/3 “good” eigenvalues. It is striking that the lowest two
eigenvalues are accurately calculated for L anywhere between 1 and 512, a range of three
orders-of-magnitude!
Example #2: Global Expansion of the K-Bessel Function, i. e.
f(r) ≡r K1(r)
on
r ∈[0, ∞]
(17.66)
where K1(r) is the usual imaginary Bessel function. Library software for evaluating this
function normally employs (i) a power series representation with logarithmic terms for
small r and (ii) an asymptotic series in inverse powers of r for r ≫1. Our goal is much
more ambitious: to use mapping to obtain a single expansion that is accurate for all r ≥0.
The Bessel function K1 has a simple pole at the origin, but the factor of r in (17.66) re-
moves this so that f(r) is ﬁnite. However, no multiplicative factor can remove the log(r),
which itself multiplies an inﬁnite series in r. Fortunately, since f(r) is bounded at the ori-
gin, we can use the exponential mapping trick introduced by Stenger. Since K1(r) decays
as exp(−r) for large r, it is convenient to use a mapping which is linear in r for large r
since we do not have any unusual problem at ∞. Therefore, we ﬁrst apply the change of
coordinate
r = arcsinh(ey)
(17.67)

17.12. NUMERICAL EXAMPLES: CHEBYSHEV FOR SEMI-INFINITE INTERVAL
371
Figure 17.9: The number of “good” eigenvalues of the Laguerre equation as a function
of the map parameter L. A “good” eigenvalue is arbitrarily deﬁned as one whose abso-
lute error is less than 0.05. All runs used 41 collocation points and the basis functions
TL0(y), . . . , TL40(y) on the interval y ∈[0, ∞].
to transform to y ∈[−∞, ∞] and then apply the TBn(y). Although it is a little confusing
to use the Chebyshev rational functions on the inﬁnite interval in solving a problem which
was originally deﬁned on a semi-inﬁnite domain, this example does illustrate the power of
mappings.
The end result, after conversion back to the original coordinate r, is an approximation
of the form
r K1(r)
=
0.534 −0.6 TB1(log[sinh(r)]) −0.068 TB2(log[sinh(r)])
(17.68)
+
0.125 TB3(log[sinh(r)]) + 0.032 TB4(log[sinh(r)])
−
0.032 TB5(log[sinh(r)]) + terms smaller than 0.01
Because we are resolving a logarithmic singularity at r = 0, a good choice of L must be
much smaller than for the previous example. Fig. 17.10 shows the result with map param-
eter L = 4: the logarithm of the error to base 10 is graphed against N, the truncation.
The approximation is almost too good. If the series converged geometrically, then the
curve would approximate a straight line. The actual graph is a fairly good approximation
to a straight line — but one can rigorously prove that the rate of convergence must be subge-
ometric because r K1(r) is singular at both endpoints. A careful look shows that the curve is
beginning to ﬂatten out a bit near the right edge of the graph; the slope would tend to zero
from above if we extended the graph to sufﬁciently large N. This would be rather foolish,
however, because N = 24 already gives six decimal place accuracy, and within the range
illustrated, the subgeometrically convergent series does a remarkably good job of imitating
the straight line rate-of-decrease-of-error that is the spoor of geometric convergence on a
log-linear plot.
This example serves to remind us that theoretical ideas about orders and rates of con-
vergence are almost always asymptotic estimates. In this case, the concept of “subgeomet-

372
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
Figure 17.10: The base-10 logarithm of the error bound as a function of n, the degree of
the highest TBn(y), in the representation of the function f(r) ≡r K1(r) on r ∈[0, ∞]. To
resolve the logarithmic singularity at the origin, r is mapped into the inﬁnite interval y ∈
[−∞, ∞] via r = arcsinh(exp[y]) and the result is expanded using the rational Chebyshev
functions in the new coordinate y. The n-th error bound is the sum of the absolute values
of all coefﬁcients am with m > n; this is a slight overestimate of the actual maximum
pointwise error on r ∈[0, ∞].
ric” convergence gives a misleading picture of how rapidly the error decreases for small
and moderate N. Boyd (1978a, Table VIII) offers another amusing illustration.
17.13
Functions Which Oscillate
Without Exponential Decay at Inﬁnity
Despite the effectiveness of the mappings and basis sets illustrated above and in the journal
articles mentioned earlier, there are still classes of problems where further research is badly
needed. When a function f(y) oscillates as y →∞, there is no difﬁculty as long as the
function also decays exponentially fast with y. It is unnecessary for the basis functions to
Table 17.9: A Bibliography of Spectral Solutions to Oscillate-at-Inﬁnity Problems
References
Comments
Boyd (1987b)
Theory & TLn expansions of amplitude and phase
for J0 Bessel function
Boyd (1990b,1991a,1991d,
TBn/radiation function basis for nonlocal solitons
1991e,1995b,1995j)
Boyd (1990d)
TBn/radiation function basis for quantum scattering
(continuous spectrum)
Yang&Akylas(1996)
Weakly nonlocal solitary waves

17.13. STRATEGY: OSCILLATORY, NON-DECAYING FUNCTIONS
373
resolve thousands and thousands of wavelengths since the function is negligibly small
outside a region that includes only a few alternations in sign.
When f(y) decays algebraically with y, the TBn(y) and TLn(y) still converge rapidly
as long as either (i) the function does not oscillate or (ii) the frequency of the oscillations
dies out as y →∞. However, if the function decays slowly, but the rate of oscillation does
not, then a conventional expansion is in big trouble.
A prototype is the Bessel function
J0(y) ∼
r 2
πy
½·
1 −
9
128 y2 + O
¡
y−4¢¸
cos
³
y −π
4
´
+
·
−1
8y + O
¡
y−3¢¸
sin
³
y −π
4
´¾
(17.69)
for y ≫1. It is not possible for a ﬁnite number of basis functions to resolve an inﬁnite
number of oscillations. Because J0(y) decays in magnitude only as 1/√y, if we fail to
resolve the oscillation between y = 200π and y = 202π, for example, we will make an error
of O(1/
√
200π) = 0.04. To accurately approximate the ﬁrst hundred wavelengths, however,
would take several hundred TLn(y). So many basis functions for only 4% accuracy!
Library software avoids this problem by using two approximations: the asymptotic
expansion (17.69) for large y and a power series for small y. It is not possible to extend
the large y expansion to y = 0 since the series in 1/y are divergent. If we wish to obtain a
“global” approximation, that is to say, a single expansion accurate for all of y ∈[0, ∞], we
Figure 17.11: The functions a(y) and φ(y) in the approximation
√1 + y J0(y) ≈a(y) cos(y −π/4 −φ[y])
which is uniformly accurate for y ∈[0, ∞].

374
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
must mimic the asymptotic expansion (17.69). Boyd (1987b) assumed the double series
p
1 + y J0(y) ≈cos
³
y −π
4
´ M
X
n=0
an TLn(y) + sin
³
y −π
4
´
N
X
n=0
bn TLn(y)
(17.70)
and computed the coefﬁcients by interpolation at (M + N + 2) points, spaced as in (17.63).
With M = 15 and N = 5, the maximum absolute error was less than 0.00001 everywhere
on the entire semi-inﬁnite interval.
In some respects, there is nothing mysterious about this: the expansion (17.70) is a
faithful mirror of the asymptotic series and the TLn(y) converge rapidly for functions with
asymptotic series in negative powers of y. However, the success is also rather surpris-
ing (and encouraging) because (17.70) is a blind leap off a cliff. There is no convergence
theory whatsoever for basis sets composed of mixtures of sines and cosines multiplied
by the TLn(y). Since the cos(y −π/4) and sin(y −π/4) factors are still rapidly oscillat-
ing for large y while the rational Chebyshev functions have each smoothly asymptoted
to 1, there is no reason to suppose that a distribution of points that is optimum for the
TLn(y) alone will capture the much more complicated (and rapidly varying) behavior of
the rational-Chebyshev-multiplied-by-a-cosine used to compute the coefﬁcients in (17.70).
We can make a strong case, via the WKB approximation from whence (17.69) came, that
J0(y) has an accurate approximation in the form of (17.70). We have no theory, however, to
indicate precisely how to compute those coefﬁcients.
In point of fact, the simple-minded interpolation is somewhat ill-conditioned, and it
was not possible to obtain more than ﬁve decimal places of accuracy when computing in
sixteen decimal place arithmetic. A Galerkin-type procedure (although it, too, was some-
what ill-conditioned) achieved 2 × 10−7 accuracy. Perhaps the ill-conditioning could be
removed by using the Euler summation method to more accurately evaluate the Galerkin’s
integrals, which have highly oscillatory integrands. Fig. 17.11 shows the “amplitude” a(y)
and “phase” φ(y) when elementary trigonometric identities are used to rewrite (17.70) as
p
1 + y J0(y) = a(y) cos
³
y −π
4 −φ[y]
´
(17.71)
Similar difﬁculties arise in quantum scattering (Boyd, 1990d), in which the incoming,
transmitted, and reﬂected waves all propagate even at spatial inﬁnity, and in the theory of
weakly nonlocal solitary waves, which decay from a large central core to small amplitude
oscillations of constant amplitude (Boyd, 1995b, 1998b). An alternative strategy, similar in
spirit to the method described above but different in detail, is to use a standard rational
Chebyshev basis (or whatever) and augment it with one or two special “radiation func-
tions”, which have the correct oscillations-at-inﬁnity built into them. Thisis discussed in
the Chap. 19, Secs. 4 and 5.
17.14
Weideman-Cloot Sinh Mapping
Weideman and Cloot(1990) introduced the mapping
y = sinh(Lt),
y ∈[−∞, ∞] & t ∈[−π, π]
(17.72)
They apply a Fourier pseudospectral method in the new coordinate t. Since the image of
t ∈[−π, π] is y ∈[−ymax, ymax] where ymax is ﬁnite, their scheme combines both mapping
and domain truncation in a single algorithm. Weideman and Cloot(1990), Cloot(1991),
Cloot and Weideman (1992) and Boyd (1994b) offer both theoretical and empirical evidence

17.14. WEIDEMAN-CLOOT SINH MAPPING
375
that this Fourier-domain-truncation-with-mapping is as effective as the rational Chebyshev
basis, or better, in many applications.
The crucial point is that because ymax ≡sinh(Lπ) grows exponentially fast with L,
very small increases in L produce large decreases in the domain truncation error EDT ≡
|u(ymax)|. There is also a series truncation error ES(N) that arises because the Fourier se-
ries in t must be truncated. Since the Fourier coefﬁcients decrease geometrically for most
functions, it follows that log |ES| is roughly O(N) for ﬁxed L. To keep the domain trun-
cation error as small as the series truncation error, however, we must increase L with N
so that log |EDT | is also O(N). However, because the sinh-map increases the size of the
computational domain exponentially fast with L, it follows that increasing L logarithmically
with N will ensure that the domain truncation error falls off geometrically with N.
The bad news is that increasing L will move the singularities of u(y[t]) closer to the real
t-axis. As explained in Chapter 2, the pole or branch point whose location has the smallest
imaginary part controls the rate of convergence of the Fourier series. If the convergence-
limiting singularity is at t = ts, then log |ES(N)| ∼−|ℑ(ts)| N. It follows that a logarithmic
increase of L with N will cause a logarithmic decrease in |ℑ(ts)| so that log |ES| and also
the total error (series plus domain truncation) must decrease no faster than
log |E| ∼O
µ
N
log(N)
¶
(17.73)
Boyd (1994b) dubs this “quasi-geometric” convergence because it fails to be truly geometric
only because of the logarithm.
Cloot and Weideman (1990) show further that if we optimize L so that the domain
truncation and series truncation errors are roughly the same and decrease as rapidly as
possible in lockstep at N →∞, then the optimum L has a remarkably simple form for a
large class of functions For example, suppose that u(y) is such that
EDT ∼exp(−Ayr
max),
ymax >> 1
(17.74)
and has a convergence-limiting singularity (that is, the pole or branch point whose location
has the smallest imaginary part of all the singularities of the function) at y = ys. Applying
the mapping and then simplifying under the assumption that L >> 1 gives,
log(EDT ) ∼−A 2−r exp(rπL)
(17.75)
log(ES) ∼−N |ℑ(ys)|
L
(17.76)
The sum EDT + ES is minimized as N →∞by
Lopt ∼1
π log(N 1/r) + O(log(log(N)))
(17.77)
In contrast, rational Chebyshev series have subgeometric convergence. For a func-
tion like sech(Ay), the asymptotic analysis of Boyd(1982b) shows Lopt ∼1.07N 1/3/A and
log |ES| ∼−1.47N 2/3, which is subgeometric convergence with exponential index of con-
vergence 2/3. The optimum map parameter depends upon A, the width parameter of u(y),
whereas the optimum L for the Cloot-Weideman mapping depends only upon N.
Fig. 17.12 shows that for sech(y), the Weideman-Cloot sinh-mapped Fourier algorithm
gives much smaller errors for the same number of degrees of freedom. However, it also
shows a problem. The asymptotic estimate for the best map parameter for the rational
Chebyshev basis, L ∼3.8, is fairly close to the bottom of the curve of the actual maximum

376
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
0
1
2
10
-12
10
-11
10
-10
10
-9
10
-8
10
-7
10
-6
10
-5
10
-4
10
-3
L/Lopt (WC)
0
5
10
10
-12
10
-11
10
-10
10
-9
10
-8
10
-7
10
-6
10
-5
10
-4
10
-3
L
Figure 17.12: Errors in the rational Chebyshev series (left panel) and the Weideman-Cloot
algorithm for the function u(y) = sech(y) for various map parameters L (left graph) or
domain parameters L (right). Lopt ≡(1/π) log(N) is Cloot and Weideman’s own estimate
of the best L. Twenty-two rational Chebyshev functions were used for the left panel; the
same number of cosine functions for the right graph.
pointwise error versus L, and the error in the TB series is not very sensitive to L anyway.
However, L = 1 in the Weideman-Cloot method gives only one-third the number of correct
digits obtainable by using L only 30% larger; the Weideman-Cloot method is much more
sensitive to L.
This sensitivity difference between mapping and domain truncation was noted by Boyd
(1982b). With domain truncation, the total error is the sum of two terms which grow or
decay differently with L: the domain truncation error EDT decreases with L while the
error in the N-term series increases with L. The total error has the sharp pointed shape
of the letter “V” on a graph of error versus L. For entire functions, the rational Chebyshev
basis is better because there is only the series error, and the graph of error versus L is ﬂat
at the minimum.
Unfortunately, when u(y) has a singularity, the error for the TB basis is also the sum of
two unrelated terms; one is the series truncation error associated with the singularity, the
other depends on how rapidly u(y) decays with |y| for large |y|. Consequently, the curve on
the left of Fig. 17.12 is V-shaped. However, the penalty for underestimating the optimum
L is less drastic for the rational Chebyshev basis than for the sinh-map.
One difﬁculty in estimating L for the sinh-mapping is that the relative error in the lead-
ing order approximation to Lopt is log (|ℑ(ys)| π r 2r/A) / log(N), which is rather large un-
less N is huge. Indeed, although the leading order estimate is technically independent of
A, the width of sech(Ay), it is actually a good idea to make a preliminary linear change-of-
coordinate so that A ∼O(1) in the new coordinate. Otherwise, the simple approximation
Lopt ∼(1/π) log(N) may be useless until N is ridiculously large.
Fig. 17.13 illustrates the spectral coefﬁcients for the two methods. The map parame-
ters were deliberately chosen to be optimal (empirically) for N = 44, but the coefﬁcients
are graphed to much larger N. For both methods, the coefﬁcients decrease roughly geo-
metrically until N is slightly larger than that for which these map parameters are optimal,
and then both series ﬂatten out. The Fourier series runs into a wall and becomes very ﬂat
because the coefﬁcients for N > 50 are those of Gibbs’ Phenomenon, controlled by the

17.15. SUMMARY
377
0
20
40
60
80
100
10
-16
10
-14
10
-12
10
-10
10
-8
10
-6
10
-4
10
-2
10
0
j
Fourier or Chebyshev coefficients
TB
Weideman-Cloot
Figure 17.13: Absolute values of spectral coefﬁcients for the rational Chebyshev series
(solid) and the Cloot-Weideman algorithm (disks) for the function f(y) = sech(y). The
dashed line is a ﬁt to the leading coefﬁcients of the TB series.
jump discontinuity at t = π whose magnitude is the domain truncation error. The ratio-
nal Chebyshev series ﬂattens out, as shown by comparison with the dashed dividing line,
which was chosen to match the slope of the coefﬁcients aj for j < 40. However, the error
continues to decrease exponentially fast, albeit at a subgeometric rate. The curves provide
some useful empirical guidance for optimizing L as expressed by the following:
Rule-of-Thumb 16 (OPTIMIZING INFINITE INTERVAL MAP PARAMETER)
Plot the coefﬁcients aj versus degree on a log-linear plot. If the graph abruptly ﬂattens at some N,
then this implies that L is TOO SMALL for the given N, and one should increase L until the ﬂatten-
ing is postponed to j = N.
Fig. 17.14, which is identical to Fig. 17.12 except for a different u(y) and N, illustrates
how difﬁcult it is make rigid rules about the superiority of one method over another. For
the function u(y) = sech(y) cos(3y), the smallest errors attainable for a given N are roughly
the same for each choice of basis. One would probably be more comfortable using the
rational Chebyshev basis because it is less sensitive to the choice of the map parameter.
For solving model time evolution equations, Weideman and Cloot (1990) concluded
that the sinh-map gave the smallest errors and was most efﬁcient when the width of the
solution changes little with time. However, the rational Chebyshev basis was superior
when the width of the solution varied greatly with time. Both authors have continued to
employ both schemes in their own later work.
Their own inability to choose one over the other reiterates a key theme: on the inﬁnite
and semi-inﬁnite intervals, there are a lot of good choices, but no perfect choice.
17.15
Summary
When the target solution u(y) decays exponentially as the coordinate tends to inﬁnity, there
are many good spectrally-accurate algorithms. Sinc functions are the simplest, Hermite
and Laguerre functions have the closest connection with the physics for some classes of
problems, rational Chebyshev functions and the Weideman-Cloot sinh-mapped Fourier

378
CHAPTER 17. METHODS FOR UNBOUNDED INTERVALS
0
1
2
10
-7
10
-6
10
-5
10
-4
10
-3
L/Lopt (WC)
0
5
10
15
10
-7
10
-6
10
-5
10
-4
10
-3
L
Figure 17.14: Errors in the rational Chebyshev series (left panel) and the Weideman-Cloot
algorithm for the function u(y) = sech(y) cos(3y) for various map parameters L or domain
parameters L/Lopt where Lopt ≡(1/π) log(N) is the Cloot and Weideman’s own estimate
of the best L. Twenty-two rational Chebyshev functions were used for the left panel; the
same number of cosine functions for the right graph.
scheme exploit the Fast Fourier Transform. We have not made a general recommenda-
tion about the “best” basis because there is no compelling reason to choose one basis over
another that applies to all cases.
When the function u(y) decays as an inverse power of y, then rational Chebyshev func-
tions are the clear favorite. This basis is equivalent to making a change of coordinate, such
as y = Lcot(t) for the inﬁnite interval, and then applying a Fourier basis in the new coordi-
nate t. However, one must analyze the asymptotics of the solution carefully to ensure that
the function u(y[t]) is well-behaved in t. If u(y) decays slowly but as some fractional power
of y, then one can still obtain spectral accuracy. However, one must modify the cotangent
mapping so that u(y) is inﬁnitely differentiable everywhere in the new coordinate t.
Another class of nasty problems is when a function deﬁned on a semi-inﬁnite interval
is singular at one endpoint or on or near the interior of the interval. The singularities can
be resolved by combining the ideas of this chapter with those of the previous chapter. For
an endpoint singularity, for example, one can map the semi-inﬁnite interval to t ∈[0, π]
using a change-of-coordinate that clusters the grid points with a spacing that decreases
exponentially near the singular endpoint y = 0 as illustrated by the series for K1 Bessel
function above. Similarly, one can choose the map to detour around a singularity on the
interior of the interval whether the interval is ﬁnite or unbounded.
When u(y) decays to an oscillation rather than to zero as |y| →∞, the best strategy is
to use special basis functions, added to a standard inﬁnite interval basis, which match the
oscillations, leaving the standard basis to approximate the part of the function which de-
cays without oscillation. We have illustrated this strategy using the amplitude-and-phase
approximations to the J0 Bessel function. However, the same idea works well in quantum
scattering and computations of weakly nonlocal solitary waves.
For all basis sets on an unbounded interval, there is a scale factor or map parameter that
(if chosen properly) matches the width of the basis functions to the width of the solution.
One must use much narrower basis functions to compute the structure of a molecule than
to compute a solitary wave approximation to the Great Red Spot of Jupiter, which is 40,000

17.15. SUMMARY
379
km across.
For Whittaker cardinal functions, the scaling factor is the grid spacing. When Cheby-
shev polynomials are mapped from [−1, 1] to [−∞, ∞] to give the rational basis functions
denoted by TBn(y), the scaling factor is the map parameter L. The Hermite functions do
not explicitly contain a free parameter, but we always have the option of performing the
expansion in terms of ψn(αy) instead of ψn(y) where α is an arbitrary scaling factor. The
proper choice of α is just as important to maximizing the efﬁciency of the Hermite series
as is a good choice of L for mapped Chebyshev polynomials. When the domain is un-
bounded, there is always, either explicitly or implicitly, a scale parameter to be chosen.

Chapter 18
Spherical, Cylindrical, Toroidal &
Elliptical Geometry
“The book of nature is written in the characters of geometry”
— Galileo Galilei
18.1
Introduction
Cylindrical and spherical geometry require special theory, special grids, and special basis
functions. There is no easy road to compute ﬂows on the surface of a sphere or solve a
partial differential equation on the interior of a disk.
The heart of the problem is that at the origin of a polar coordinate system, or at the north
and south poles of the surface of a sphere, the lines of constant polar angle or constant
longitude converge in a single point. This convergence-of-meridians has two unfortunate
consequences. First, there is a severe time-stepping limit, the so-called “pole problem”.
Second, the differential equation is almost invariably singular at this convergence point
even when the solution is everywhere smooth and inﬁnitely differentiable.
In this chapter, we hope to initiate the reader into the mysteries of disk and sphere. In
the ﬁrst part, we discuss polar coordinates. In the second, we concentrate on latitude and
longitude, the coordinates of the surface of a sphere. As explained in the next section, polar,
cylindrical, spherical, and toroidal coordinates are very closely related: there is really only
one species of “pole problem”, manifesting itself as a disease in four different coordinate
systems.
Spectral algorithms for all these coordinates have been developed. The numerical tech-
nology has become so mature that spectral methods for weather forecasting and climate
modelling have conquered a global empire embracing more countries than that of Caesar
or Alexander. Nevertheless, as the century ends and massively-parallel computing gathers
momentum, spherical harmonic models are under siege. As we describe the techniques,
we shall narrate both the virtues and faults of each spectral and non-spectral option and
let the reader be his own prophet.
380

18.2. POLAR, CYLINDRICAL, TOROIDAL, SPHERICAL
381
θ=π/4
θ=0
θ=π
θ=5π/4
θ=π/2
θ=3π/2
θ=7π/4
θ=3π/4
r
θ
Figure 18.1: Left: Deﬁnitions of radius r and angle θ for a typical point (black disk) in polar
coordinates. Right: In polar coordinates, the contours of constant radius r are concentric
circles. The contours of constant angle θ are semi-inﬁnite rays through the origin (thick
lines).
18.2
Polar Coordinates and Their Relationship to Cylindri-
cal, Spherical and Toroidal Coordinates
In polar coordinates, a point is speciﬁed by the radius r, which is the distance from the
origin to point, and the angle θ, as illustrated in the left side of Fig. 18.1. The Cartesian
coordinates x and y are connected to polar coordinates through the relation
x = r cos(θ),
y = r sin(θ)
(18.1)
The contours of constant radius r are concentric circles centered on the origin. The isolines
of polar angle θ are semi-inﬁnite rays all converging at the origin as shown on the right of
Fig. 18.1.
Cylindrical coordinates are obtained by adding a third coordinate z which measures
distance along a vertical axis perpendicular to the plane deﬁned by polar coordinates. The
isosurfaces of constant r are cylinders. The rays of constant θ now converge at every point
on the vertical axis. Each plane of constant z is a two-dimensional surface where points are
located by polar coordinates.
Toroidal coordinates are obtained by wrapping the cylinder around into the shape of
a bagel or doughnut. The surfaces of constant r are now tori, and the coordinate z, now
renamed the “toroidal angle” λ (Fig. 18.3), is always cyclic.
In spherical coordinates, the radial coordinate is now the distance from the origin to a
point in three dimensions rather than two, and the surfaces of constant radius are spheres.
Latitude and longitude, as on any geographical map, locate points on the surface of a
given sphere. (Actually, in scientiﬁc applications, it is customary to replace latitude by
“colatitude”, which is latitude minus π/2, but this is merely a convention that does not
alter the pole problem.)
A “polar cap” is a small region centered on either the north or the south pole, bounded
by colatitude θ = θ0 where θ0 is small. The polar cap is a slightly puckered disk. As
θ0 →0, that is, as the polar cap becomes smaller and smaller, the polar cap becomes ﬂatter
and ﬂatter. In the limit, the convergence of meridians (lines of constant longitude) at the

382
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Table 18.1: Spectral Methods in a Disk or Cylinder
Note: Exterior ﬂows and solutions in an unbounded domain are listed in the next table.
References
Comments
Mercier & Raugel (1982)
Theoretical justiﬁcation for pole conditions
in mixed spectral/ﬁnite element [in French]
Orszag&Patera (1983)
Robert-type basis in polar coordinates
Tan(1985)
3D Poisson equation in cylinder
Randriamampianina&
ﬂows with buoyancy and rotation
Bontoux&Roux(1987)
in a cylinder (in French)
Lewis&Bellan(1990)
Symmetry conditions for scalars & vectors
across r = 0 in cylindrical coordinates
Eisen&Heinrichs
mapped unit disk onto rectangle
&Witsch(1991)
and imposed pole conditions
Bouaoudia&Marcus (1991)
Robert basis (now obsolete)
Pulicani&Ouazzani(1991)
3D ﬂow and diffusion in cylinder
Huang &Sloan(1993b)
singularity analysis; good discussion of
ﬁnite difference preconditioning
Bessel eigenproblem & Poisson eq. in a disk
Launaye et al.(1994)
axisymmetric 2D crystal growth in a cylinder
Van Kemenade&Deville(1994b)
spectral elements; non-Newtonian ﬂow
Godon&Shaviv(1993,1995)
Chebyshev in r; Fourier in θ
Godon(1995,1996abc,1997a,b)
astrophysics problems
Godonet al.(1995)
accretion disk boundary layers
Priymak(1995),Priymak&Miyazaki(1998)
Turbulence
Fornberg(1995)
Chebyshev/Fourier basis with strong polar ﬁltering
Matsushima and Marcus(1995)
One-Sided Jacobi basis
Raspo& Ouazzani &
Multidomain scheme for axisymmetric ﬂow within
Peyret(1994,1996)
a cylinder
Shen(1997)
fast algorithms for Poisson eq. and related
operators in disk or cylinder
Verkley(1997a,1997b)
One-sided Jacobi basis; hydrodynamics
Matsushima&Marcus(1997)
unbounded vortical ﬂows, polar coordinates
Lopez&Shen(1998)
Navier-Stokes equations with fast algorithms
for the semi-implicit time marching
north pole is indistinguishable from the convergence of the rays of constant θ at the origin
in polar coordinates.
Thus, the special difﬁculties caused by the convergence of isolines of an angular coor-
dinate at a single point are identical in all four coordinate systems.
18.3
Polar Coordinates: Apparent Singularity at the Origin
and Boundary Condition at the Origin
The second consequence of the convergence of the meridians is that differential equations
are singular at r = 0. For example, the Laplace operator is
∇2 ≡∂2
∂r2 + 1
r
∂
∂r + 1
r2
∂2
∂θ2
(18.2)
Thus, the coefﬁcients of the ﬁrst radial derivative and second polar derivative are both
singular at r = 0. And yet, when the Laplacian is written in Cartesian coordinates, it is
constant coefﬁcient:
∇2 ≡∂2
∂x2 + ∂2
∂y2
(18.3)

18.4. POLAR COORDINATES: PARITY THEOREM
383
A simple function like f(x, y) = x2 + y2 has a Laplacian which is a constant. What could
be less singular!
The resolution of the paradox is that the singularities of the Laplace operator, when
written in polar coordinates, are only “apparent”. The solution to a differential equation is
usually smooth and inﬁnitely differentiable at the pole.
To avoid evaluating differential equation coefﬁcients where they are inﬁnite, the spec-
tral grid usually excludes the origin. This is only a trivial complication, however; the inter-
esting issue is: How does one impose boundary conditions at the origin?
For ﬁnite difference methods, one must normally impose explicit, numerical boundary
conditions, based on careful analysis of the behavior of the solution near the origin, at the
grid point nearest r = 0. For spectral methods, however, the singularity actually simpli-
ﬁes the algorithm. To a spectral method, the boundary condition at the origin is behavioral
rather than numerical: the correct behavior is that the solution should be analytic at the
origin even though the coefﬁcients of the differential equation are not. Since the terms of
a spectral series are individually analytic, it follows that a Chebyshev or similar series in
radius automatically satisﬁes the boundary condition at r = 0, and no additional explicit
conditions are necessary. If the differential equation were not singular at r = 0, it would
be necessary (for a second order equation) to impose an explicit numerical boundary con-
dition at the origin. Thus, the singularity of the coordinate has ironically simpliﬁed the use
of a spectral method.
For best results, one must respect the parity symmetry at the origin which is explained
in the next two sections. However, one only needs to constrain the spectral series through
a numerical boundary condition at the outer boundary of the disk. If one applies polar
coordinates to an inﬁnite domain, then both boundary conditions are behavioral, and no
conditions need to be explicitly imposed on the spectral series.
18.4
Polar Coordinates: Parity Theorem
Theorem 35 (Polar Coordinates: Parity in Radius) In polar coordinates where r is radius and
θ is angle, expand an arbitary function as a Fourier series in θ:
f(r, θ) =
∞
X
m=0
fm(r) cos(mθ) + gm(r) sin(mθ)
(18.4)
Suppose that f(r, θ) is a SCALAR or the z-velocity in cylindrical coordinates or is the product of
r with the radial or tangential components of a vector in polar coordinates. Then if the function is
analytic at r = 0, continuity of the function and its derivatives demands the following:
(i) fm(r) and gm(r) have m-th order zeros at r = 0.
(ii) If m is EVEN, then fm(r) and gm(r) are both SYMMETRIC about r = 0 and their power series
contain only EVEN powers of r.
(iii) If m is ODD, then fm(r) and gm(r) are both ANTISYMMETRIC about r = 0 and their power
series contain only ODD powers of r.
Proof: A geometric argument for spherical coordinates is given in Sec. 18.8 below. This
visual argument applies also to polar coordinates because latitude and longitude become a
local polar coordinate system in a small neighborhood of the north and south poles. Here,
we present a different line of proof, couched as an informal, heuristic argument. Because

384
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
there seems to have been much confusion about this theorem in the literature and multiple
rederivations of its conclusions, we give this argument in some detail, but the rest of this
section can be skipped without loss of continuity. A careful, rigorous proof is given in
Eisen, Heinrichs &Witsch(1991).
First, note that any function f(x, y) which is analytic at and near x = y = 0 can be
locally approximated, to any desired accuracy, by a bivariate polynomial of sufﬁciently
high order. (Indeed, a double Taylor series will sufﬁce). Substituting x = r cos(θ) and
y = r sin(θ), it follows that a bivariate polynomial in r cos(θ) and r sin(θ) will sufﬁce as a
proxy for f(r, θ) to any desired accuracy. The monomials that appear in this polynomial
approximation have properties described by the following two lemmas.
Lemma 1 (Polar Wavenumbers of Cartesian Powers) Let “polar wavenumber m” denote the
Fourier terms cos(mθ) or sin(mθ). When a monomial
Mjk ≡xj yk
(18.5)
in powers of the Cartesian coordinates x and y is converted into polar coordinates and expanded as
a Fourier series in the polar angle θ, polar wavenumber m will only appear in the expansion of the
monomial if the total degree of the monomial is greater than or equal to m, that is, if
d ≡j + k ≥m
(18.6)
Proof: A monomial of total degree d can be written, expressing the sine and cosine as
complex exponentials, in the form
xjyk ≡rj+k (−i)k
2d
d
Y
n=1
(exp(iθ) ± exp(−iθ) )
(18.7)
The crucial fact is that each exponential in the product is proportional to polar wavenumber
one, that is, to exp(±iθ). To obtain a term of wavenumber 7, for example, for example, it is
necessary to multiply such wavenumber one terms together at least 7 times. This requires
that the number of factors in the product is at least 7. Since the number of factors is the
total degree d, it follows that the total degree of the monomial must be at least 7. The same
reasoning applies to arbitrary wavenumber m.
The factor of rd in front of the product in Eq. (18.7) then immediately implies the fol-
lowing.
Lemma 2 (Radial Degree of Cartesian Powers) A Cartesian monomial xjyk is proportional to
rd where d ≡j + k is the total degree of the monomial.
Because of Lemma 1, it follows that a Cartesian monomial will contain terms like cos(mθ) or
sin(mθ) only if it is proportional to rd where d ≥m.
Together, these lemmas show that the terms proportional to either cos(mθ) or sin(mθ)
must also be proportional to rm, and thus the coefﬁcients of these terms in the Fourier
series of f(r, θ) must have an m-th order zero at r = 0.
The parity of the Fourier coefﬁcients with respect to r = 0 follows from a third lemma.
Lemma 3 (Monomial Parity) A monomial xjyk, when expanded as a Fourier series in polar
angle θ, is a trigonometric polynomial of degree j + k which contains contains only those polar
wavenumbers of the same parity as the degree d = j+k. That is, if d is odd, then the Fourier series of
xjyk contains only {cos(dθ), sin(dθ), cos([d−2]θ), sin([d−2]θ), cos([d−4]θ), sin([d−4]θ), . . . , }.
Odd polar wavenumbers m are thus multiplied only by odd powers of r, and even powers only
by even.

18.5. RADIAL BASIS SETS AND RADIAL GRIDS
385
Proof: The product
xjyk ≡rj+k (−i)k
2d
d
Y
n=1
(exp(iθ) ± exp(−iθ) ) ,
(18.8)
can be expanded into terms of the form exp(inθ) where n depends on how many factors
of exp(iθ) and how many factors of its complex conjugate are combined in a given term.
The term of highest polar wavenumber is exp(idθ) when all d exponentials exp(iθ) are
combined. The crucial point is that when exp(iθ) is replaced by its complex conjugate
exp(−iθ), which is the other term inside each factor in the product, the degree j is lowered
by two. Thus, all wavenumbers j in the expansion of the product will be of the same parity,
either even or odd, as the total degree d.
The radial dependence of the monomial xjyk is rd where d is the sum of j and k. If
d is even, then rd is symmetric with respect to r = 0. (We have already seen that if d
is even, then all the Fourier coefﬁcients of the monomial are of even polar wavenumber,
too.). Similarly, if d is odd, then its radial factor rd is antisymmetric (i. e., odd parity) with
respect to r = 0. Thus odd powers of r are paired only with cos(mθ) and sin(mθ) where m
is odd and even powers of r are paired only with even m.
The parity theorem has major implications for the choice of grids and basis functions as
explained in the next section.
18.5
Radial Basis Sets and Radial Grids
On a ﬁnite domain in radius, which can be always be normalized to r ∈[0, 1] by a linear
change-of-coordinate, there are several options (where m denotes the angular wavenum-
ber):
1. Bessel Functions: Jm(jm,j r) cos(mθ), sin(mθ)
2. Polar Robert Functions: rm Tj(r), j = 0, 1, 2, . . .
3. Shifted Chebyshev Polynomials of Linear Argument:
Tj(2r −1), j = 0, 1, 2, . . .
4. Shifted Chebyshev Polynomials of Quadratic Argument:
Tj(2r2 −1), (m even), r Tj(2r2 −1), (m odd), j = 0, 1, 2, . . .
5. Unshifted Chebyshev Polynomials of Appropriate Parity:
T2j(r) cos(2mθ), T2j−1(r) cos([2m −1]θ], j = 0, 1, 2, . . .
6. One-Sided Jacobi Polynomials:
rm P 0,|m|
j
(2r2 −1) cos(mθ), sin(mθ)
The “cylindrical harmonics” are
J m
n (r, θ) ≡Jm (jm,n r)
½ cos(mθ)
sin(mθ)
(18.9)
where there are two basis functions, one proportional to cos(mθ) and the other to sin(mθ),
for all pairs of integers (m, n) with m > 0 and where jm,n denotes the n-th zero of the m-th
Bessel function Jm(r). The cylindrical harmonics are popular in engineering because these
are the eigenfunctions of the Laplace operator in polar or cylindrical coordinates, which
made it easy in the old pre-computer days to apply a Galerkin method. However, as noted

386
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
by Gottlieb and Orszag(1977), the Bessel series usually converges only at an algebraic rate.
(An analysis of the precise rate of convergence is given in Boyd and Flyer(1999).)
Bouaoudia and Marcus(1991) developed a fast transform for the polar “Robert” func-
tions, which mimic the spherical basis invented by Robert(1966):
φm,n(r, θ) = rm Tn(r)
½ cos(mθ)
sin(mθ)
(18.10)
where n is restricted to have the same parity (i. e., even or odd) as m. Unfortunately,
Merilees(1973a) showed that the analogous spherical basis is horribly ill-conditioned and
therefore useless except at very low resolution. The problem is that for large m and small
n, the basis functions are zero over almost all the interval because of the rm factor; note that
rm = exp(m log(r)) ≈exp(−m(1 −r)) for r ≈1, and thus decays exponentially fast away
from the boundary at r = 1. In the narrow region around r = 1 where the small n functions
are non-zero, T0, T2 and other low degree basis functions vary so slowly that φm,0 ≈φm,2,
destroying the linear independence of the functions in the basis. Marcus abandoned the
polar Robert functions in his later work, and instead went to One-sided Jacobi polynomials
as explained below.
The third bad option is to expand fm(r) as a series of Shifted-Chebyshev polynomials
with a linear argument:
T ∗
j (r) ≡Tj(2r −1),
r ∈[0, 1]
(18.11)
where the asterisk is the usual notation for the Shifted-Chebyshev polynomials. The reason
that this option is bad is that the Shifted-Chebyshev grid has points clustered near both
r = 0 and r = 1. However, the disk bounded by r = ρ has an area which is only the
fraction ρ2 of the area of the unit disk. Near the origin, points are separated by O(1/N 2).
It follows that the high density of points near the origin is giving high resolution of only a
tiny, O(1/N 4)-in-area portion of the disk. Unless the physics imposes near-singularities or
high gradients near the origin, clustering grid points at r = 0 is a bad idea. And even in this
special situation of small-scale features near the origin, it is conceptually better to regard
the use of Shifted-Chebyshev polynomials as “mapping to resolve large gradients near the
origin” rather than “Shifted-Chebyshev polynomials are a good general representation for
radial dependence”.
Fig. 18.2 compares the Shifted-Chebyshev series (dashed) with two other options. The
shallow slope of the coefﬁcients of the Shifted-Chebyshev series shows that one needs
roughly twice as many terms to obtain a given degree of accuracy with the Shifted-Chebyshev
polynomials as with the alternatives.
The Shifted-Chebyshev polynomials of quadratic argument and the Parity-Restricted
Chebyshev polynomials, which are also shown in the ﬁgure, both work well, but generate
only a single curve on the graph. The reason is that these two options, although seemingly
very different, are in fact the same because of the identity
Tj(2r2 −1) ≡T2j(r),
∀j, r
(18.12)
The grid with parity uses rparity
j
= cos(tj/2) whereas the shifted grid with quadratic argu-
ment has rj = {(1 + cos(tj))/2}1/2 where the tj are an evenly spaced grid on the interval
t ∈[0, π] for Lobatto, Chebyshev-roots, or Radau grids. (The Radau grid includes r = 1 but
not r = 0.) The trigonometric identity
cos
µ t
2
¶
=
r
1 + cos(t)
2
(18.13)

18.5. RADIAL BASIS SETS AND RADIAL GRIDS
387
shows that
rparity
j
= rj,
∀j
(18.14)
Thus, both the basis functions and the interpolation grid are identical for these two meth-
ods. The distance between adjacent points close to origin is O(1/N).
Nevertheless, when there is a large number M of points in the polar angle θ and N
points in radius, the distance between adjacent gridpoints on the circle of radius r1, the
smallest radial gridpoint, will be O(1/(MN)). Since the explicit time-stepping limit is
roughly the amount of time required for advection or diffusion from one grid point to
the next, it follows that the Parity-Restricted Chebyshev polynomials will give a time step
limit which is O(1/(MN)) for advective stability and O(M −2N −2) for diffusion. Ouch! On
the sphere, this motivates the choice of spherical harmonics as the basis, which eliminates
this “pole problem” of a very short time-step. A similarly-motivated basis for the disk is
described in the next section.
18.5.1
One-Sided Jacobi Basis for the Radial Coordinate
Matsushima and Marcus(1995) and Verkley(1997a,1997b) independently proposed One-
Sided Jacobi polynomials, multiplied by rm:
φm
n (r, θ) ≡W m
n (r)
½ cos(mθ)
sin(mθ)
(18.15)
where in Verkley’s notation
W m
n (r) ≡rm P 0,m
(n−m)/2(2r2 −1),
m = 0, 1, 2, . . . ;
n = m, m + 2, m + 4, . . .
(18.16)
where P 0,m
k
(s) is the Jacobi polynomial of degree k of order (0, m) in its argument s. (Note
that because s ≡2r2 −1, the Jacobi part of the basis function is of degree (n −m) in r.)
This basis function explicitly enforces all the constraints of the parity theorem; each basis
function is symmetric in r for even m and odd in r for odd m. The factor of rm ensures that
each basis function has an m-th order zero at the origin. Verkley(1997a, Table 1) provides
the explicit form of these basis functions for small n and m.
The Jacobi polynomials are orthogonal so that
Z 1
−1
P α,β
k
(s)P α,β
k′ (s)(1 −s)α(1 + s)βds = 0,
k ̸= k′
(18.17)
Changing variables from s to r and setting α = 0, β = m gives
Z 1
0
P 0,m
k
(2r2 −1)P 0,m
k′
(2r2 −1)r2mrdr = 0,
k ̸= k′
(18.18)
or in other words,
Z 1
0
W m
n (r)W m
n′ (r) rdr = 0,
n ̸= n′
(18.19)
These Jacobi polynomials of order (0, m) are “one-sided” in the sense that the weight
function in Eq.(18.18) diminishes rapidly (as r2m) as the origin is approached, but varies
only slightly near the outer edge of the disk. If the Jacobi polynomials oscillated uniformly

388
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
in r like the Robert functions, they would be nearly-dependent and ill-conditioned like the
Robert functions. The orthogonality constraint, however, forces the polynomials of differ-
ent degree to be as independent as possible. This requires that the polynomials oscillate
mostly near r = 1: the roots of the basis functions move closer and closer to the outer
boundary for ﬁxed degree as the order m increases.
The one-sideness is the magic. The basis functions of high wavenumber m are the
villians that describe the fast tangential advection or diffusion that limits the timestep.
However, the radial parts of these basis functions, if one-sided Jacobi polynomials, have
only negligible amplitude close to the origin where the grid points are close. The rapid
advection or diffusion is suppressed, and a much longer timestep is possible.
As with spherical harmonics, discussed later, there are two options for truncating the
basis: “rectangular” and “triangular”. A rectangular truncation employs the same num-
ber of radial basis functions for each angular wavenumber m. It is the easiest to program,
but has fallen from grace in spherical coordinates. The triangular truncation decreases the
number of radial basis functions by m with each increase in m until the highest wavenum-
ber has but a single radial basis function. It has been shown for spherical harmonics that
this gives the most uniform resolution (and allows the longest timestep) of any truncation
that includes a given maximum zonal wavenumber M. This property of “equiareal resolu-
tion”, deﬁned formally below in Sec. 18.13, has not been proved for the One-Sided Jacobi
basis, but it seems plausible that a triangular truncation is preferable here, too.
The usual strategy of choosing the roots of the polynomials as the interpolation points
does not work here because the zeros of the P (0,m)
k
are different for each polar wavenumber
m. To take transforms in θ, we need the unknowns deﬁned on a single set of radial grid
points. Therefore, one is forced to abandon a pseudospectral strategy and instead apply
a Galerkin method. The integration points are the Legendre-Radau grid which includes
r = 1 but not r = 0. To avoid quadrature errors, it is necessary to use more grid points than
unknowns, but the transform from radial grid point values to coefﬁcients can be still be
expressed as the multiplication of a vector of grid point values or coefﬁcients by a matrix,
albeit now a rectangular matrix.
These basis functions, unlike the spherical harmonics they mimic, are not eigenfunc-
tions of Laplace operator. However, both Matsushima and Marcus(1995) and Verkley(1997a)
derive recurrence relations which allow the Laplacian to be inverted by solving a penta-
diagonal matrix problem. Similarly, derivatives can be evaluated at an operation count
directly proportional to the number of spectral coefﬁcients in the truncation. Overall, the
efﬁciency of this basis is roughly the same as for spherical harmonics. Indeed, the algorith-
mic connection with spherical harmonics is so close that Verkley’s shallow-water solver
for the disk is merely a rewrite of a previous code that solved the same hydrodynamic
equations on the surface of a sphere via spherical harmonics.
Unfortunately, the Jacobi basis shares the vices of spherical harmonics. First, there is no
Fast Fourier Transform for the Jacobi polynomials, so all radial transforms from grid point
values to spectral coefﬁcients must be done by Matrix Multiplication Transform (MMT).
This costs O(N 2) for each wavenumber m versus only O(N log2(N)) for an FFT. (Trans-
forms in θ are still done by FFT, thank goodness.)
Second, the messy recurrence relations and basis functions require some investment of
both learning time and programming time. (We may hope that someday the necessary
subroutines will become widely available in software libraries, and then this objection will
disappear).
There is one profound difference from spherical harmonics, however. The One-sided
Jacobi basis has the usual high density of grid points near r = 1 where grid points are sepa-
rated in r by O(1/N 2). With a triangular truncation so that the maximum polar wavenum-
ber M is equal to N, the tangential distance between grid points on the outermost ring is

18.5. RADIAL BASIS SETS AND RADIAL GRIDS
389
0
2
4
6
8
10
10
-12
10
-10
10
-8
10
-6
10
-4
10
-2
10
0
degree j
Chebyshev Expansions of J0
Tj(2 r - 1)
Tj(2 r2 - 1),
T2j(r)
Figure 18.2: Chebyshev expansions of the Bessel function J0(r). The slowly-convergent
series (dashed) is the expansion in Shifted-Chebyshev polynomials: T ∗
j (r) ≡Tj(2r −1).
The two good techniques are (i) an expansion in Shifted-Chebyshev polynomials with a
QUADRATIC argument Tj(r2) = Tj(2r2 −1) and (ii) an expansion in the EVEN Chebyshev
polynomials without a shift: T2j(r). These two options generate only a single curve be-
cause (i) and (ii) are in fact IDENTICAL because of the identity Tj(2r2 −1) = T2j(r).
also O(1/N 2). This implies that the One-sided Jacobi basis has not completely solved the
difﬁculty of a restrictive timestep; indeed, if the time scales for tangential advection or dif-
fusion near the origin are similar to the time scales for radial advection or diffusion near
the boundary, then the switch from a Chebyshev basis to the Jacobi basis will not increase
the time step at all.
Nevertheless, this basis has worked well in Matsushima and Marcus(1995) and Verkley
(1997a,b).
18.5.2
Boundary Value & Eigenvalue Problems on a Disk
When there is no timestep, the pressure to use One-Sided Jacobi basis functions in radius is
greatly reduced. Orszag(1974) and Boyd(1978c) have shown that satisfying all the pole con-
ditions is not terribly important to numerical efﬁciency; a regular Chebyshev basis seems
to work just ﬁne. (Their papers actually solve problems on the sphere, but because the
polar caps are well-approximated by small disks, their conclusions should apply to polar
coordinates, too.) Matsushima and Marcus(1995) show by solving the eigenproblem whose
exact solution is the Jm Bessel function that the Jacobi basis can reach a given error toler-
ance with only half as many coefﬁcients as the Parity-Restricted Chebyshev polynomials
when m = 50. However, in a Fourier-Chebyshev series in two dimensions, the Fourier
series in m usually converges rapidly, so the Chebyshev basis is converging slowly only
for wavenumbers whose amplitude is negligible anyway.
Our recommendation for boundary and eigenvalue problems is to try a Chebyshev
basis ﬁrst. If the speed of the resulting (rather easy-to-program) code is unsatisfactory,
the One-Sided Jacobi basis can be used as a fallback with the Chebyshev program used to
check the newer and much more intricate Jacobi code.

390
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Table 18.2: Cylindrical or Polar Coordinates: Unbounded Domain or External to a Cylinder
References
Comments
Zebib(1987a)
Stability of ﬂow past a cylinder
Don&Gottlieb(1990)
unsteady ﬂow past a cylinder
Deane & Kevrekidis
spectral elements; low order basis of
&Karniadakis & Orszag(1991)
empirical orthogonal eigenfunctions
Mayer&Powell(1992)
Eigenvalue calculation of stability of trailing
vortex through domain truncation
Mittal & Balachandar(1996)
ﬂow past elliptic cylinder in elliptic coordinates
good discussion of boundary conditions,
blending inﬂow & outﬂow
Blackburn&Henderson(1996)
ﬂow past a vibrating cyclinder
Matsushima&Marcus(1997)
Unbounded domain including the origin;
2D and 3D vortex ﬂows
18.5.3
Unbounded Domains Including the Origin in Cylindrical Coor-
dinates
Matsushima&Marcus(1997) have extended their earlier work by applying an algebraic
change-of-coordinate in r to map an unbounded domain into a disk. They then apply the
One-Sided Jacobi basis described above. Like the rational basis TBj for the inﬁnite interval
described in Chapter 17, the Matsushima-Marcus basis functions are rational functions of
r ∈[0, ∞].
The alternative is the even TB functions for even polar wavenumber m and the TB2j−1(r)
for odd m: a Parity-Restricted Rational Chebyshev basis. The simpler functions are prefer-
able for boundary and eigenvalue problems, but the Matsushima-Marcus basis may give
faster convergence and allow a longer timestep.
Flows exterior to a cylinder in an unbounded domain have been the subject of much
study, both analytical and numerical. Exterior ﬂows are free of the pole problem, but im-
posing boundary conditions on a ﬂow at large radius can be tricky. We have therefore
collected some illustrations in Table 18.2.
18.6
Annular Domains
Flow in an annulus that does not include the origin is free from the pole problem. We
recommend a Fourier basis in the angle θ and a standard Chebyshev basis in the radial
coordinate r. In three dimensions, one should use a Chebyshev basis in the axial coordinate
z unless periodic boundary conditions in z are imposed, in which case a Fourier basis is
greatly preferable.
There is little difference between annular ﬂow and channel ﬂow except that cylindri-
cal coordinates introduce an r-dependent “metric” factor into the Laplace operator, etc.,
whereas the Laplace operator has constant coefﬁcients in Cartesian coordinates. The usual
methods for separable partial differential equations, discussed in Chapter 15, Sec. 11, still
apply.
For most practical purposes, however, an annular channel is simply a straight channel
which is periodic in the downstream direction. A standard Fourier/Chebyshev basis is
best. Some representative works are listed in Table 18.3.

18.7. SPHERICAL COORDINATES: AN OVERVIEW
391
Table 18.3: Annular Flows
References
Comments
Marcus(1984a,1990)
Taylor-Couette ﬂow
Le Qu´er´e &Pecheux(1989,1990)
axisymmetric convection; bifurcations
Chaouche(1990a)
axisymmetric ﬂows;
Chaouche et al.(1990)
inﬂuence matrix method
Randriamampianina(1994)
3D ﬂow; vorticity-vector-potential
18.7
Spherical Coordinates: An Overview
The pattern of latitude and longitude lines on the surface of the sphere is, near the poles,
the same as that of a polar coordinate system in a disk. So, it is hardly surprising that there
are many similarities between cylindrical coordinates and spherical coordinates. However,
there are important differences.
One is that a sphere has two poles rather than one. A second, more important difference
is that the surface of a sphere has no boundaries. This has the profound consequence that
spherical basis sets automatically and individually satisfy the behavioral boundary condi-
tions on the sphere. In contrast, it is necessary to impose numerical boundary conditions at
the boundary circle of the disk.
A third difference is that for the sphere, there is an “obvious” basis set, the spherical har-
monics, which are nearly ideal. Spherical harmonics give equiareal resolution, exponential
convergence, and trivial inversion of the Laplace operator, which is the eigenoperator for
these functions. In contrast, the obvious basis for the disk, the cylindrical harmonics, are
Bessel functions of radius with only a poor, algebraic rate of convergence. One can match
most of the good properties of spherical harmonics by using the One-Sided Jacobi basis for
the disk, but these are not eigenfunctions of the Laplace operator.
The fourth difference is that the number of simulations in a cylinder is fairly modest
compared to the large body of work that has been done in spherical coordinates for weather
forecasting, climate modelling, mantle convection and stellar ﬂows. For this reason, we
shall discuss spectral methods on the sphere in great detail.
18.8
The Parity Factor for Scalars: Sphere versus Torus
Topologically, the sphere is a two-dimensional manifold of genus zero while the torus
(“doughnut”) is of genus one. Ironically, however, it is easier to compute on the surface
of a torus than the surface of a sphere.
Science ﬁction writers have described toroidal planets (Boyd, 1981c, 1984c) and plasma
physicists solve ﬂows in tori to model the ring-shaped fusion generators known as toka-
maks (Schnack et al., 1984). In this section, we will discuss a two-dimensional basis for the
surface of a torus. However, one may deﬁne a three-dimensional orthogonal coordinate
system (“toroidal coordinates”, Morse and Feshbach, 1953) in which the third coordinate
is radial distance from the surface of a torus to its centerline.
Fig. 18.3 illustrates toroidal geometry. To stress the analogue with the sphere, we use λ,
which is longitude-like, for the “toroidal” angle and θ, which is analogous to colatitude, for
the “poloidal” angle. All physical solutions must be periodic with a period of 2π in both
coordinates. As shown in the lower half of the ﬁgure, it is trivial to “ﬂatten” the torus by
making a slit through a meridian, bending the cut torus into a cylinder, and then making a
second cut parallel to the “equator” to unwrap the cylinder into a rectangle.

392
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Figure 18.3: Toroidal coordinates. (a) The torus. (b) The torus developed into a rectangle.
Because the geometry is periodic in both coordinates, the natural basis set on the torus
is a double Fourier series, i. e. any function on the surface of the torus can be expanded as
f(λ, θ)
=
∞
X
m,n
acc
mn cos(mλ) cos(nθ) +
∞
X
m,n
acs
mn cos(mλ) sin(nθ)
(18.20)
+
∞
X
m,n
asc
mn sin(mλ) cos(nθ) +
∞
X
m,n
ass
mn sin(mλ) sin(nθ)
If f(λ, θ) is free of singularities on the torus, then the series (18.20) will converge expo-
nentially. Schnack, Baxter, and Caramana (1984) is a good illustration of a code (in plasma
physics) that employs a two-dimensional Fourier series in toroidal coordinates.
The sphere is more complex because it is not a surface that can be unwrapped or “de-
veloped” into a cylinder. Its geometry is fundamentally different from that of the periodic
rectangle shown in Fig. 18.3b. To expand a scalar function on the sphere, we need only
half the terms in the general double Fourier series shown above. To explain which half,
however, requires us to look down on the north pole of the sphere and ﬂatten the “polar
cap” region into a disk with a local polar coordinate system as shown in Fig. 18.4.

18.8. THE PARITY FACTOR FOR SCALARS: SPHERE VERSUS TORUS
393
Figure 18.4: Polar projections showing the positive (H) and negative (L; cross-hatched) re-
gions for a term gm(θ) sin(mλ) in the Fourier expansion of a function. The one-dimensional
graphs on the right show how gm(θ) must vary along the short, pole-crossing line segments
marked on the polar plots.
(a) Zonal wavenumber m is odd. The pole-crossing line segment has one end where sin(mλ)
is negative and the other where sin(mλ) is positive. To avoid a discontinuity, gm(θ), must
be antisymmetric about the pole.
(b) Zonal wavenumber m is even, so sin(mλ) is positive everywhere along the pole-crossing
segment. To avoid a discontinuity, gm(θ) must be symmetric about the pole.
Note that f(λ, θ) can be written in the form
f(λ, θ) =
∞
X
m=0
fm(θ) cos(mλ) +
∞
X
m=1
gm(θ) sin(mλ)
(18.21)
The two diagrams in Fig. 18.4 schematically illustrate two typical terms in the sums: one
for m odd (top) and the other for m even (bottom). Let us follow gm(θ) sin(mλ) along a
meridian over the pole.
Fig. 18.4a shows that when m is odd, the component gm(θ) sin(mλ) must always change
sign as the pole is crossed.
This sign change depends only on the fact that the zonal
wavenumber m is odd, and is quite independent of the details of gm(θ) and also of whether
m = 1, 3, 5, . . . so long as m is odd. This implies that gm(θ) sin(mλ) must have a jump dis-
continuity at the pole unless
gm(0) = gm(π) = 0
[m odd]
(18.22)
The same diagram applies to fm(θ) cos(mλ) by rotating it through π/2 degrees, so the
same reasoning implies that fm(θ) must have zeros at both poles for all odd longitudinal
wavenumbers m.

394
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
This argument can be extended to higher latitudinal derivatives to show that ALL EVEN
derivatives of fm(θ) and gm(θ) must vanish at both poles. The Fourier series for these func-
tions could in principle include both sin(nθ) and cos(nθ) terms, but whereas the sine terms
individually have all even derivatives zero at the poles, the sum of the cosine terms would
be constrained by an inﬁnite number of constraints. Reexpansion of a spherical harmonic
series into double Fourier series shows that the trivial solution to these constraints is in fact
the only solution: the colatitude cosine coefﬁcients are always zero when the longitudinal
wavenumber m is odd. The series (18.20) (or one of its derivatives) will have a discontinuity
in f(λ, θ) unless fm(θ) and gm(θ) are the sums of Fourier sine series in θ when the zonal
wavenumber m is odd.
When m is even, Fig. 18.4b shows that the function must have the same value on a given
meridian on either side of the pole. The analytical proof is that if we compare two points
that are at equal distances from the poles, but on opposite sides, θ = δ for both points, but
λ differs by π. When m is even, sin(mλ) = sin(m[λ + π]), so
gm(δ) sin(mλ) = gm(δ) sin(m[λ + π])
for any δ, λ [m = 0, 2, 4, . . . ]
(18.23)
as shown in the meridional slice graphed on the right side of Fig. 18.4b. However, if this
function is symmetric with respect to the pole on the line segment marked in the ﬁgure, it
follows that its derivative must be antisymmetric. (Recall from Chapter 8 that differenti-
ation is a parity-reversing operation.) However, an antisymmetric function is zero at the
point of symmetry, in this case, the pole.
It follows that
d gm
dθ (0) = d gm
dθ (π) = 0
[m even]
(18.24)
Extending this argument to higher derivatives shows that all the sine coefﬁcients must be
zero when m is even.1
Thus, a scalar function f(λ, θ) that has no singularities on the sphere may be expanded
as an exponentially convergent Fourier series of the special form
f(λ, θ)
=
∞
X
m=0, 2, 4, ...
n=0
{ ac
mn cos(mλ) + as
mn sin(mλ) } cos(nθ)
+
∞
X
m=1, 3, 5, ...
n=1
{ bc
mn cos(mλ) + bs
mn sin(mλ) } sin(nθ)
(18.25)
The identity
sin(θ) cos(n θ) = 1
2 {sin([n −1]θ) + sin([n + 1]θ)}
(18.26)
shows that equivalently, one can replace sin(nθ) by a basis whose elements are {sin(θ)
cos(nθ)}. [Exercise for the reader: Derive the relationship between the Fourier coefﬁcients
for these two alternative forms of the sine series.] For historical reasons, this sin(θ) -times-
a-cosine series representation is often used to replace sin(nθ) in the terms in the second line
of (18.25). This extracted factor of sin(θ) for m odd is the “parity factor”.
1The argument that zero derivatives to all orders implies zero coefﬁcients is not rigorous because a C∞func-
tion such as exp(−1/[θ(π −θ)]) has zero derivatives to all orders at the poles. However, such functions can
be represented on θ ∈[0, π] by either a cosine series or sine series with a subgeometric but exponential rate of
convergence. Thus it is true, even when such exceptions are considered, that one needs only latitudinal Fourier
terms of a single parity to approximate fm(θ) and gm(θ).

18.9. PARITY II: HORIZONTAL VELOCITIES & OTHER VECTOR COMPONENTS
395
We added the restriction “for a scalar function” in stating (18.25) because the arguments
for a vector function such as the wind velocities are more complicated as explained in the
next section. The conclusions are similar, however: to represent the components of a vector,
one needs only half a general Fourier series, and which components in θ must be kept is
different for even and odd zonal wavenumber.
18.9
Parity II: Horizontal Velocities & Other Vector Compo-
nents
Computing the spherical harmonic expansions of vectors on the sphere is a little tricky.
As explained in Orszag (1974) the three Cartesian velocity components, ux, uy, and uz, all
transform like scalars, that is, may all be expanded directly in spherical harmonics2. The
same is true for the radial velocity ur in spherical components. (A meteorologist would call
ur the “vertical” component.) However, the horizontal velocity components uλ ≡dλ/dt
and uθ ≡dθ/dt transform differently. As noted by Robert (1966), uλ and uθ should be
expanded as 1/ sin(θ) times a spherical harmonic series.
For this reason, most spherical harmonics models replace the zonal and meridional
velocities by
U
≡
uλ sin(θ) =
∞
X
m,n
umn Y m
n (λ, θ)
[modiﬁed east-west wind]
(18.27)
V
≡
uθ sin(θ) =
∞
X
m,n
vmn Y m
n (λ, θ)
[modiﬁed north-south wind]
(18.28)
Orszag (1974) gives an analytical proof of (18.27) and (18.28). We instead will offer a graph-
ical justiﬁcation.
Fig. 18.5 illustrates a polar cap view of a typical ﬂow generated by a Cartesian velocity
component which is function of spherical components with even wavenumber — in this
particular case, a ﬂow which is a constant, independent of all three spatial coordinates.
When we decompose this ﬂow into spherical velocity components as shown in the two
lower panels, we ﬁnd that the zonal velocity and meridional velocity components are both
of odd zonal wavenumber. For this example of wavenumber one velocities, each has a
single nodal meridian, shown by the dotted line, where the ﬁeld is zero. This interchange
of even wavenumber for odd wavenumber and vice versa when we decompose a Cartesian
vector component into spherical vector components explains why the parity factor for uλ
and uθ for odd m is just what we expect for a scalar quantity for even m — none.
When we inspect a polar view of an odd wavenumber portion of a scalar quantity as
in Fig. 18.4a, we observe that it changes sign as we cross the poles while moving on a
meridian. We argued that the colatitude dependence of the scalar had to be antisymmetric
about θ = 0 — that is, like sin(θ) — so the scalar would not have a jump discontinuity at
the poles. Why does this argument fail for uλ and uθ for odd m? The answer is that these
spherical vector components actually are discontinuous at the poles!
If we look again at the upper left of Fig. 18.5, we note that what is interpreted as a
westward ﬂow in the top of the disk is an eastward ﬂow in the bottom half (opposite
hemisphere). The wind velocity, however, does not go to zero at the pole — the magnitude
and direction of the ﬂow are independent of coordinate. If we embed a ﬁxed Cartesian
2Warning: in this section, subscripts will be used to denote a particular component of a vector and not differ-
entiation with respect to that coordinate.

396
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Figure 18.5: Polar cap view of a ﬂow parallel to the Cartesion x-axis, chosen to be represen-
tative of even zonal wavenumber. In this case, the zonal wavenumber is zero — the ﬂow
is independent of position.
When decomposed into vector components, however, both the zonal and meridional ve-
locity have odd zonal wavenumber, in this case, m = 1. To avoid a discontinuity at the pole,
both spherical velocity components must be symmetric about the pole even though a scalar
quantity of odd wavenumber would have to be antisymmetric.
coordinate system in the globe so that the origin is at the north pole, then along the y-axis
the north-south ﬂow is zero and
|uλ| = |ux|
for λ = ±π
2 , all θ
[y-axis]
(18.29)
so that the magnitude of the zonal velocity is independent of θ along the whole meridian.
The only way that this constancy of magnitude can be reconciled with the change of sign
is if uλ has a jump discontinuity as the pole is crossed:
uλ =





−ux
λ = π
2
ux
λ = −π
2
all θ
[y-axis]
(18.30)
This in turn requires that we omit the sin(θ) parity that is needed for well-behaved quanti-
ties of odd zonal wavenumber (such as scalars).
It is important to note, however, that this discontinuity is caused by a change in math-
ematical interpretation rather than a physical variation in the ﬂow itself. In Fig. 18.5, the
wind as measured by an anemometer never changes either magnitude or direction. What
does change is that we interpret the same wind as an eastward wind on one side of the
pole but as a westward current on the other side. Thus, the prescription against a physical

18.9. PARITY II: HORIZONTAL VELOCITIES & OTHER VECTOR COMPONENTS
397
discontinuity remains in force, and nothing in this section should be (mis)interpreted as
implying otherwise.
The meridional velocity component has a similar jump discontinuity on the x-axis (and
every other meridian except the y-axis where uθ ≡0). The modiﬁed velocity components
U and V in contrast, are continuous across the poles — another reason for preferring them
to uλ and uθ. However, the radial velocity is not discontinuous as we cross the pole: up
away from the center of the earth is still up.
Figure 18.6: Same as previous ﬁgure except that the Cartesian velocity is now a function
of odd zonal wavenumber, in this case, m = 1. The spherical velocity components are
the sums of terms of even zonal wavenumber. To avoid polar discontinuities, the velocity
components must vanish at the poles. A scalar quantity of similar zonal wavenumber would
be symmetric with respect to the poles.
Fig. 18.6 illustrates the situation when the spherical velocity components are of even
zonal wavenumber. For the case shown, the zonal velocity is eastward over the whole
globe. The meridional velocity alternates in sign, but if we follow a meridian over the
pole, we ﬁnd that a poleward ﬂow is a poleward ﬂow on both sides of the pole. However,
this in turn requires that uθ decrease smoothly to zero as the pole is approached along any
meridian. This in turn requires the parity factor, sin(θ). This may be seen in the analytical
expressions for uθ and uθ at the bottom of Fig. 18.6.
Swarztrauber (1981, 1993) presents some good illustrations of discontinuities in hori-
zontal wind ﬁelds. His proposed remedy, vector spherical harmonics, will be discussed in
Sec. 18.22.

398
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
18.10
The Pole Problem: Spherical Coordinates
The Courant-Friedrichs-Levy criterion for the stability of explicit time-stepping algorithms
is that
△t < △x
c
(18.31)
where c is the speed of the fastest waves allowed by the differential equations being solved
and △x is the smallest spatial grid interval. One reason why nearly-uniform ﬁnite difference
or ﬁnite elements grids are popular is that △x is roughly the same everywhere so that the
time-step limit is not unduly expensive.
On a sphere, the simplest tactic is to use latitude and longitude as coordinates and apply
an even grid spacing in λ and θ. Denoting the radius of the sphere by a, the rub is that the
distance △x between two grid points on a circle of colatitude θ is
△x = a sin(θ) △λ
(18.32)
which tends to zero at the poles as shown graphically in Fig. 18.7.
Figure 18.7: A grid with uniform spacing in latitude and longitude as viewed from Polaris,
the Pole Star. The meridians (lines of constant longitude) all converge at the pole. Conse-
quently, △x →0 as the pole is approached, even though △λ is constant. The very small
grid spacing near the pole is the “pole problem”: One must use a very, very short time
step, or the numerical ﬂow will violate the Courant-Friedrichs-Levy criterion and become
unstable.
The result is that a time step which is stable and reasonable for tropical and temper-
ate latitudes — typically 10 minutes for a fully explicit, “primitive equations” numerical
weather prediction model — will give instability near the poles. As the run continues, this
localized instability will gradually spread equatorward like a cancer until the whole globe
is consumed with numerical error.
One remedy is an artiﬁcially high viscosity near the poles. Heavy damping destroys
the accuracy of the model at high latitudes, but it is known that high latitudes have little
physical inﬂuence on lower latitudes, and few complaints about inaccurate local forecasts
have come from polar bears.
The alternative is to attack the root of the problem, which is that, close to the poles, the
resolution in longitude is needlessly high. Why use very small △x near the poles when the
accuracy of the model as a whole is constrained by the much poorer resolution everywhere

18.11. SPHERICAL HARMONICS: INTRODUCTION
399
else? The high zonal wavenumber components of the solution are the only ones that be-
come unstable. Therefore, the preferred methods for solving the “pole problem” are based
on lowering zonal resolution near the poles.
One approach, used in the GFDL-Princeton General Circulation Mode, is to selectively
delete grid points from the latitude-longitude grid at high latitudes. This is messy to pro-
gram. Worse still, the grid becomes irregular and the resulting uncentered ﬁnite difference
approximations are not very accurate.
A second alternative is a zonal-scale-selective ﬁltering at high latitudes. This is merely a
variant of the artiﬁcial polar damping technique, of course, but a scale-selective dissipation
is physically reasonable in a way that a scale-independent ﬁltering is not. The reason is
that the model cannot resolve the very short longitudinal scales of the damped components
except near the poles. There is no reason to mourn the damping of zonal wavenumber 30 at
85 degrees of latitude where its associated zonal scale is only 20 km when the longitudinal
resolution at the equator is as coarse as 200 km.
The third alternative is to use a spectral or pseudospectral method with spherical har-
monics as the basis set. Because of the close connection between the spherical harmonics
and the geometry of the sphere, this basis set plays no favorites with respect to latitude: the
spherical harmonics have the property of “equiareal resolution” on the sphere as explained
in Sec. 18.13 below.
To be sure, the spherical harmonics are more complicated to program than simple ﬁnite
differences on a uniform latitude-longitude grid. But if one wants to survive the cancerous
instabilities of the “pole problem”, one is forced to use something more complicated than a
uniform λ - θ grid.
18.11
Spherical Harmonics: Introduction
Spherical harmonics ﬁx the pole problem, contain the proper “parity factors”, and offer
exponential convergence for functions that are inﬁnitely differentiable on the sphere. Un-
fortunately, spherical harmonics are more complicated than any of the other basis sets in
common use because they are two-dimensional. We will later discuss icosahedral grids and
near-uniform triangularizations to emphasize that this difﬁculty is unavoidable: there is no
way to solve problems on the sphere that does not require some complicated programming
and careful attention to detail.
The spherical harmonics are
Y m
n (λ, θ) ≡eimλ P m
n (θ)
m, n non-negative integers
such that n ≥m
(18.33)
Y −m
n
(λ, θ) ≡e−imλ P m
n (θ) (−1)m
Thus, in longitude, the spherical harmonics are merely a Fourier series. Eq. (18.33) dis-
plays the Fourier series written in the form of complex exponentials; some authors prefer
ordinary sines and cosines in λ, but the difference is only one of convention.
The functions P m
n (θ), the “associated Legendre functions” of order [zonal wavenum-
ber] m and degree n, are where all the complications lie. They are deﬁned by
P m
n (θ) ≡sinm(θ) Cm
n−m(cos[θ])
(18.34)
where the Cm
n (cos[θ]) are the “Gegenbauer polynomials”3. The subscript denotes the de-
gree of the polynomial; the coefﬁcients of the polynomials are different for each different
zonal wavenumber m.
3Warning: The superscript m used in this section is related to the superscript m′ of Appendix A via m=m′-1/2.

400
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
The factor sinm(θ) in (18.34) has a three-fold signiﬁcance. First, recall that sin2k(θ) ≡
(1−cos2[θ])k = a ﬁnite Fourier cosine series with 2k terms. Thus, all the associated Legendre
functions with m even may be written in terms of a Fourier cosine series. However, when
m is odd, one factor of sin(θ) cannot be converted into a cosine polynomial, and [combining
sin(θ) with the cosine polynomial via the usual trigonometric identities] P m
n (θ) is a (ﬁnite)
Fourier sine series. Thus, sinm(θ) is the “parity factor” discussed earlier in the chapter; it
is automatically built into the spherical harmonics.
The second signiﬁcance of the sine factor is that it implies that the spherical harmonics
have an m-th order zero at the poles — a multiple root in colatitude whose degree is de-
termined by the wavenumber in longitude. It is this high-order zero which enables spher-
ical harmonics to avoid the pole problem: the basis functions of high zonal wavenumber
m would have wastefully high longitudinal resolution at high latitudes except that the
sinm(θ) factor forces these spherical harmonics to have negligible amplitude near the poles.
The third consequence of the sinm(θ) factor is that modes with large m and (n−m) ≪m
have little amplitude outside a narrow band centered on the equator. This justiﬁes the
Hermite function asymptotic approximation discussed later.
The deﬁnition of the “degree” n in (18.34) seems rather peculiar in that the degree of the
Gegenbauer polynomial is (n −m); it would seem much more natural to deﬁne the degree
of the spherical harmonic to equal that of the polynomial. However, the convention shown
in (18.34) has become universally adopted because this deﬁnition of degree-of-harmonic
simpliﬁes almost all other descriptions of the associated Legendre functions.
The most important of these is truncation: what cutoffs on m and n are most efﬁcient?
As will be explained below, one can prove that the spherical harmonics give equal resolu-
tion of all areas of the globe if and only if the truncation is triangular, that is, the retained
basis functions satisfy the inequalities
|m| ≤N
and
n ≤N
“triangular truncation”
(18.35)
for some integer N as illustrated in Table 18.4. A triangular truncation up to and including
wavenumber N is usually denoted by the shorthand of “T” plus the numerical value of N.
A “TN” truncation retains a total of (N + 1)2 spherical harmonics.
The Gegenbauer polynomials satisfy an orthogonality relation that can be expressed in
two illuminating ways:
Z π
0
Cm
k (cos[θ]) Cm
j (cos[θ]) sin2m(θ) dθ
=
0
if
j ̸= k
(18.36)
Z 1
−1
Cm
k (µ) Cm
j (µ) (1 −µ2)m dµ
=
0
if
j ̸= k
(18.37)
First, note that both forms of orthogonality apply only to different polynomials of the same
zonal wavenumber m. With the spherical harmonics, one is not dealing with a single set of
orthogonal polynomials, but rather with a countable inﬁnity of sets.
Second, (18.36) shows a fourth role for the factor of sinm(θ) in (18.34): when two asso-
ciated Legendre functions of the same m are multiplied together, they collectively supply
the sin2m(θ) weight factor in (18.36). Thus, the associated Legendre functions of the same
order m are orthogonal on θ ∈[0, π] with a weight function of unity.
When written in terms of µ = cos(θ), the Gegenbauer polynomials are ordinary (rather
than trigonometric) polynomials. Eq. (18.37) shows that the Gegenbauer family includes
the Chebyshev and Legendre polynomials as the special cases m = −1/2 and m = 0. Like
other orthogonal polynomials, the Gegenbauer polynomials and their derivatives may be

18.11. SPHERICAL HARMONICS: INTRODUCTION
401
Table 18.4: An illustration of allowed combinations (m, n) for the spherical harmonics Y m
n .
The X’s show the modes that retained in a triangular truncation with a cutoff at N = 3
(“T3”); the O’s show the modes that are added when the cutoff is increased to N = 5
(“T5”). The total number of modes is (N + 1)2 in a TN truncation.
m →
-5
-4
-3
-2
-1
0
1
2
3
4
5
n
↓
0
X
1
X
X
X
2
X
X
X
X
X
3
X
X
X
X
X
X
X
4
O
O
O
O
O
O
O
O
O
5
O
O
O
O
O
O
O
O
O
O
O
evaluated for arbitrary m and n via three-term recurrence relations. Handbooks on mathe-
matical functions are stuffed with such identities, so we shall here focus on the qualitative
properties of the basis functions.
One important property is that as m increases, the roots of the n-th degree polynomial
move closer and closer to the origin (equator). Since basis functions give good resolution
where they are oscillating and poor resolution where they vary slowly and monotonically,
it follows that the high order Gegenbauer polynomials give good resolution near the equa-
tor and poor resolution near the poles — exactly what is needed to avoid the pole problem
and give uniform resolution over the whole globe. [When we consider a triangular trunca-
tion of harmonics, the small m functions resolve the small polar cap region; the large areas
near the equator are resolved through the combined efforts of all the harmonics.]
Recall that an N-term orthogonal polynomial series minimizes the mean square of the
error where the error is weighted by the weighting function in the orthogonality integral.
The weight function (1 −µ2)m tolerates large error near the poles for the sake of higher
accuracy near the origin.
Another consequence of this stress on the interior is that when the Gegenbauer polyno-
mials are normalized so that the integrals in (18.36) and (18.37) are unity when j = k, one
ﬁnds that
max
x∈[−1, 1] | ˜Cm
k (x)| ∼O
³
km+1/2´
(18.38)
where the tilde over Cm
k denotes the normalized Gegenbauer polynomials. In other words,
Eq. 18.36 implies that the maximum values of a normalized polynomial are large compared
to its O(1) average value on the interval x ∈[−1, 1]. This implies that the amplitude of the
polynomial’s oscillations is highly nonuniform (in contrast to the Chebyshev polynomials,
whose maxima and minima are all the same). The amplitude increases rapidly as one ap-
proaches either pole. However, these oscillations of the polynomials are tempered by the
decay of the sinm(θ) factor as we move away from the equator so that the associated Leg-
endre function rather resembles a Hermite function — that is, to say, there is a band around

402
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Figure 18.8: Schematic of typical spherical harmonics. The “zonal” harmonics have zero
zonal wavenumber and their latitudinal structure is that of the ordinary Legendre polyno-
mials Pn(cos θ) where θ is colatitude. The “sectoral” harmonics are the modes which have
no latitude circles as nodal lines. The “sectoral” harmonics of high zonal wavenumber
are equatorially trapped and have negligible amplitude outside the tropics. The “tesseral”
harmonics are the general case.
the equator where it oscillates with many (roughly) equal crests and troughs; outside this
band, P m
n (cos[θ]) simply decays monotonically to zero. (This band is very narrow if n ≈m
and m ≫1 but extends almost all the way to poles if (n −m) is not small in comparison to
m.) For the special case of the so-called “zonal harmonics”, m = 0, the band of oscillations
is global and the high latitude “decay zones” do not exist. Fig. 18.8 schematically illustrates
typical spherical harmonics.
18.12
Legendre Transforms and Other Sorrows
18.12.1
FFT in Longitude/MMT in Latitude
In longitude, spherical harmonics are just a Fourier series. The optimum longitudinal grid
is therefore evenly spaced. Since two-dimensional transforms are most efﬁciently per-
formed as a nested sequence of one-dimensional partial sums or transforms, irregardless of
how these one-dimensional sums are evaluated, the longitudinal partial sums are invari-
ably evaluated via the FFT. In latitude, however, it is necessary to use Gaussian quadrature,
which is slower [O(N 2) versus O(N log2 N)].

18.12. LEGENDRE TRANSFORMS AND OTHER SORROWS
403
The optimum Gaussian quadrature abscissas for a given wavenumber are the roots of
an m-th order Gegenbauer polynomial. However, because we must calculate transforms
in both λ and θ, it is necessary to use the same points in colatitude for all m. Thus, the
spherical grid is the direct product of an evenly spaced Fourier grid in longitude with the
quadrature abscissas for Gauss-Legendre integration. (These grid points in colatitude are
the roots of a Legendre polynomial, and must be recalculated whenever the resolution is
changed.)
Orszag (1974) makes the comment “ . . . the goal of numerical simulations is accurate
reproduction of physical hydrodynamics; it is not clear, at least to the author, that quadratic
conservation properties [and other means of suppressing aliasing at the expense of addi-
tional operation] have very much to do with the attainment of that goal.” Chen(1993) has
performed numerical experiments suggesting that dealiasing is simply a waste of com-
puter resources if the wavenumbers near N are appropriately ﬁltered. However, his con-
clusion is controversial in the sense that models in Eulerian coordinates require such strong
ﬁltering near the aliasing limit that the upper third of the wavenumber spectrum is largely
destroyed as it would be in a dealiased scheme. Most spherical harmonics models, espe-
cially those using Eulerian rather than semi-Lagrangian advective schemes, are de-aliased.
However, the semi-Lagrangian treatment of advection has allowed explicit dealiasing
to be dropped from the current ECMWF operational forecasting model. The nonlinear ad-
vective terms are never directly evaluated in a semi-Lagrangian method; instead, ﬂuid is
advected through the method of characteristics and the resulting ﬁelds are interpolated
to the pseudospectral grid. Aliasing is not completely eliminated by semi-Lagrangian ad-
vection, but it is greatly weakened, and the inherent dissipation is sufﬁcient to suppress
aliasing instability. Nevertheless, we shall describe de-aliased models in what follows.
With a total of 2N + 1 degrees of freedom in longitude, we need at least 2N + 1 grid
points in λ, but it is customary to use 3N + 1 points so as to eliminate aliasing according
to the 3/2’s rule. In colatitude, each spherical harmonic in a triangular truncation is a
polynomial in cos(θ) [or such a polynomial multiplied by sin(θ)] of degree at most N. For
m = ±N, the degree of the polynomial is furnished entirely by the sin|m|(θ) factor; for
m = 0, it is the degree of the Gegenbauer polynomial, but for all m, the degree is at most N.
In expanding the quadratically nonlinear terms, we must evaluate integrals of the product
of three harmonics, so the total degree of the integrands we must perform is never larger
than 3N. It follows that we need a minimum of (3/2)N grid points in colatitude to evaluate
these integrals exactly and thus again avoid aliasing.
18.12.2
Substitutes and Accelerators for the MMT
Spherical harmonics have one great fault: slow transforms for Associated Legendre func-
tions in latitude. This vice has has inspired a quest for alternatives which has lasted more
than three decades and counting. In longitude, the spherical harmonics are just a Fourier
series. All grid-to-coefﬁcient and coefﬁcient-to-grid transforms for spherical harmonics
(and alternatives to them) employ a Fourier series in longitude and the Fast Fourier Trans-
form in this coordinate. It is only the transform in latitude which is troublesome because
the FFT is inapplicable to Associated Legendre series.
The reason that the Legendre transform is important is that spectral algorithms require
repeated jumps from grid point values to coefﬁcients and back again at each time step. At
the end of the twentieth century, spherical harmonic weather forecasting models use the
Matrix Multiplication Transform (MMT) to jump from Legendre coefﬁcients to grid point
values and back again. For each zonal wavenumber m, this multiplication of a vector by a
dense matrix requires O(N 2) operations. It follows that the cost is very large compared to
the O(N log2(N)) expense of an FFT. For many years, there has been a feeling that eventu-

404
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
ally N would grow so large that spherical harmonics models would become prohibitively
expensive, forcing a switch to ﬁnite elements or other non-spectral algorithms.
Reality is different from expectation. The highest resolution forecasting code at the time
of writing (1998) is the T639 model of the European Centre for Medium-Range Weather
Forecasting (ECMWF), which is being tested but will not be operational for another couple
of years. Although N = 639, the Legendre transforms still consume only 19% of the run-
ning time of the model. How is this possible? The short answer is that even though there is
no algorithm as nifty as the FFT for Legendre series, there are several tricks for accelerating
the MMT which have so far saved spherical harmonics from obsolesence:
1. Parity Matrix Multiplication Transform (PMMT)
2. The Vectorizability and Parallelizability of Matrix Multiplication
3. Reduced Polar Grid
4. Complicated Physics and Chemistry in Weather Forecasting Models
5. Schuster-Dilts Triangular Matrix Acceleration
6. Generalized Fast Fourier Transforms
18.12.3
Parity and Legendre Transforms
Because the Associated Legendre functions are all either symmetric or antisymmetric with
respect to the equator, a transformation from grid point values to N spectral coefﬁcients
(or the reverse) can always be split into two subproblems of size N/2. Thus, after ﬁrst
applying the FFT to transform from grid point values in latitude and longtitude to the grid
point values of zonal wavenumber m, a set of grid point values fm(θ) can be combined into
components symmetric and antisymmetric with respect to the equator (where colatitude
(θ = latitude −π/2) by taking sums and differences:
f S
m(θ) ≡1
2 (fm(θ) + fm(π −θ)) , f A
m(θ) ≡1
2 (fm(θ) −fm(π −θ)) , θ ∈[0, π/2]
(18.39)
Each collection of grid point values of deﬁnite parity can then be transformed by a matrix
multiplication into the corresponding even or odd Legendre coefﬁcients. Each rectangular
transformation matrix has only half the rows and half the columns of the original, non-
parity-exploiting transformation, but there are two smaller transformations to be taken.
If we ignore the O(N) cost of taking sums and differences compared to the O(N 2) of the
matrix-vector multiplications of the transformations themselves, parity saves exactly a fac-
tor of two. Symmetry is discussed in greater detail in Chapter 8.
18.12.4
Hurrah for Matrix/Vector Multiplication
The multiplication of a vector by a matrix is one of the most fundamental operations of
linear algebra. Because of this, it is an operation which is often coded as a blazingly fast
assembly language program in software libraries. An assembly language routine will typ-
ically speed up the matrix/vector multiplication by a factor of two.
Furthermore, supercomputers with vector-processing hardware, such as the Cray 1 and
its arithmurgical descendants, process the matrix/vector multiplication very efﬁciently.
Indeed, it is not an exaggeration to say that the vector hardware is built primarily to do
this one operation as efﬁciently as possible. Because this operation requires no conditional
statements, branching, or any other overhead, Legendre transforms can be computed on

18.12. LEGENDRE TRANSFORMS AND OTHER SORROWS
405
vector hardware at very close to the machine’s optimum ﬂoating point execution rate. In
contrast, the sparse matrix operations of ﬁnite differences require a lot of starting-and-
stopping: one cannot exploit the holes in a sparse matrix without working very hard to
inform the hardware of where the holes are. Because of this, when ﬁnite difference and
spherical harmonics codes are compared in terms of ﬂops (that is, ﬂoating point operations
per second), the spherical harmonics program usually has a much higher ﬂop rate, much
closer to the machine’s theoretical optimum, than a ﬁnite difference code. Thus, although
the spherical harmonic code may require a much larger number of ﬂoating point operations
for a given N than a ﬁnite difference or ﬁnite element code, the wall-clock “grind time” may
be about the same.
Similarly, the multiplication of a dense matrix by a vector is a speedy process on a mas-
sively parallel machine. A matrix/vector multiply is actually just a set of independent
vector-vector multiplications, one for each row. Furthermore, the MMT matrix elements
are computed in a preprocessing step. It follows that on a massively parallel machine, it is
easy to subdivide the matrix/vector multiply among processors by assigning one or more
rows to each processor. To initiate the parallel computation, it is only necessary to broad-
cast the vector of grid point values to each processor simultaneously, and all ﬂoating point
operations can then be executed in parallel. Again, because the matrix/vector multiplica-
tion is the fundamental operation of linear algebra, there are very good assembly language
routines and carefully designed algorithms for each type of hardware.
The conclusion is that in high performance computing, Legendre transforms-by-matrix
are much more efﬁcient and less costly than operation counts would suggest. In a computer
science course, one may only be asked to add up multiplications and additions, but in the
real world, it is important to look at the clock.
18.12.5
Reduced Grid and Other Tricks
Hortal and Simmons(1991) and Courtier and Naughton (1994) showed that one could re-
duce the cost of a spectral model by systematically deleting points from the tensor product
grid near the poles with little loss of accuracy. The reductions are not large (perhaps 30%),
but to paraphrase the late U. S. Senator Dirksen: “A billion multiplications here, a billion
additions there — pretty soon you’re talking about real savings.”
Swarztrauber(1996) has carefully compared a large number of different formulations of
spherical harmonic methods to show that by proper organization, one can minimize the
number of Legendre transforms that are needed on each step of the algorithm.
18.12.6
Schuster-Dilts Triangular Matrix Acceleration
Schuster(1903) discovered that the dense matrix/vector multiplication of the usual Gaussian-
quadrature PMMT could be replaced by multiplication by a triangular matrix to reduce the
cost by a factor of two. Dilts(1985) independently reinvented this technique. The ﬁrst part
of the algorithm is a two-dimensional FFT to transform from a grid which is evenly spaced
in both latitude and longtitude to the coefﬁcients of a two-dimensional Fourier series. The
second step is to multiply the Fourier coefﬁcients by an upper triangular matrix to convert
the Fourier coefﬁcients to spherical harmonic coefﬁcients.
Because of the familiar identity Tj(cos(θ)) ≡cos(jθ), the Fourier series in latitude can
be equally well be regarded as a Chebyshev series in the variable x ≡cos(θ) where θ is
colatitude. This interpretation is conceptually useful because it shows that the function
of the triangular matrix is to convert from one polynomial basis (Chebyshev) to another
polynomial basis (associated Legendre). These conversion is done one zonal wavenumber

406
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
at a time. To simplify the discussion, we shall illustrate only the case of zonal wavenumber
m = 0 (ordinary Legendre polynomials).
One important point is that the transformation respects parity. Thus, the even degree
Fourier coefﬁcients in latitude transform only to even degree spherical harmonics, and
similarly odd transforms only to odd.
First, split the the θ-dependent coefﬁcient of the m = 0 Fourier series into components
symmetric and antisymmetric with respect to the equator as in Eq.(18.39). Let the symmet-
ric part have the Chebyshev polynomial expansion
f S
m(x) =
3
X
j=0
b2jT2j(x)
(18.40)
=
b0 + b2(2x2 −1) + b4(8x4 −8x2 + 1) + b6(32x4 −48x4 + 18x2 −1)
which is equivalent to a cosine series in θ where x = cos(θ) where θ is colatitude. (For
simplicity, we take only four terms, but the method can be extended to arbitrary order.)
Our goal is to convert this to the corresponding Legendre series:
f S
m(x)
=
3
X
j=0
a2jP2j(x)
=
a0 + a2
½3
2x2 −1
2
¾
+ a4
½35
8 x4 −15
4 x2 + 3
8
¾
(18.41)
+a6
½231
16 x6 −315
16 x4 + 105
16 x2 −5
16
¾
The expansion of the j-th Chebyshev polynomial in terms of Legendre polynomials has
the coefﬁcients (Tj, Pk)/(Pk, Pk) where (p, q) denotes the unweighted integral of p(x) q(x)
from -1 to 1. Substituting this into the Chebyshev series and collecting Legendre terms, one
ﬁnds
⃗a = ⃗M⃗b
(18.42)
where ⃗a and ⃗b are column vectors containing the Legendre and Chebyshev coefﬁcients,
respectively, and where the elements of the square matrix ⃗M are
Mij ≡
Z 1
−1
dx T2j−2(x)P2i−2(x) /
Z 1
−1
dx P2i−2(x)P2i−2(x),
i, j = 1, 2, . . .
(18.43)
Because the expansion of a polynomial of degree j requires only the Legendre polynomials
of degree j and lower, the matrix ⃗M is upper triangular.
For example, if the expansions are truncated at sixth degree, only P6 in the Legendre
expansion and T6 in the Chebyshev series contain a term proportional to x6. It follows that
32x6b6 = (231/16)x6a6 or in other words M44 = 512/231. Similarly, only two terms in each
series contain terms proportional to x4. This implies 8b4 −48b6 = (35/8)a4 −(315/16)a6.
Since a6 is already known, this can be rewritten as a4 = (8/35){8b4 −(48/11)b6}. Similarly,
a2 can be computed as a weighted sum of b2, b4 and b6 and a0 as a weighted sum of four

18.12. LEGENDRE TRANSFORMS AND OTHER SORROWS
407
coefﬁcients. The necessary multipliers are the upper 4 x 4 block of the matrix M:
¯¯¯¯¯¯¯¯¯¯¯¯¯¯
a0
a2
a4
a6
¯¯¯¯¯¯¯¯¯¯¯¯¯¯
=
¯¯¯¯¯¯¯¯¯¯¯¯¯¯
1
−1
3
−1
15
−1
35
0
4
3
−16
21
−4
21
0
0
64
35
−384
385
0
0
0
512
231
¯¯¯¯¯¯¯¯¯¯¯¯¯¯
¯¯¯¯¯¯¯¯¯¯¯¯¯¯
b0
b2
b4
b6
¯¯¯¯¯¯¯¯¯¯¯¯¯¯
(18.44)
Similar matrices give the transform from the Chebyshev (latitudinal Fourier) series for
the antisymmetric m = 0 Legendre polynomials and for the associated Legendre functions
of all higher m. The savings is only about a factor of two; note that the cost of the FFT
in latitude is negligible compared to the cost of the triangular matrix/vector multiply in
the limit N →∞. However, this is an adequate reward for implementing a very simple
algorithm. (Healy, Rockmore, Kostelec and Moore, 1998, amusingly call this the “semi-
naive” algorithm precisely because it is so simple.)
Curiously, this algorithm has been never been used in an operational forecasting or cli-
mate code. One reason is that one must store the elements of a different triangular matrix
for each equatorial parity and each m, which adds up to a lot of storage. A more signiﬁ-
cant reason is that the Schuster-Dilts algorithm requires grid point values at evenly spaced
points in θ, which is a Chebyshev grid in x = cos(θ). The usual PMMT algorithm uses
points on the Legendre grid. Because a typical forecasting or climate code is O(50, 000)
lines of code, it is not trivial to rewrite a model to accept a different grid, even though
the two grids are very similar and most of the chemistry and hydrologic cycle, etc., are
evaluated point-by-point.
18.12.7
Generalized FFT: Multipoles and All That
As reviewed in Chapter 10, generalizations of the Fast Fourier Transform have been devel-
oped which replace the O(N 2) cost of a Legendre transform (for a given zonal wavenum-
ber) by a cost proportional to O(N log2(N)) operations — the same as for the Fast Fourier
Transform. Orszag’s (1986) method exploits the three-term recurrence relation satisﬁed by
the Associated Legendre Functions. Boyd(1992c) and Dutt&Rokhlin(1993, 1995) indepen-
dently observed that Fast Multipole Methods could also be applied. Recently, Rockmore et
al.(1998) have developed a very sophisticated algorithm speciﬁcally for spherical harmon-
ics.
The bad news is that these algorithms have a huge proportionality constant compared
to the FFT. As a result, none of the generalized FFTs has ever been used in an operational
climate or weather forecasting model. However, as forecasting resolutions climb above
T400, these algorithms may become faster than the PMMT, and perhaps in time replace it.
18.12.8
Summary
The relative slowness of the PMMT (Parity-Exploiting Matrix Multiplication Transform)
for transforming the latitudinal basis functions is the great inefﬁciency-maker for spherical
harmonics algorithms. However, clever tricks, as catalogued above, have kept the spherical
harmonics from obsolesence.

408
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Table 18.5: Legendre Transforms Bibliography
References
Comments
Schuster(1903)
Triangular matrix multiplication transform
Dilts (1985)
Modern reinvention of Schuster’s scheme
Brown (1985)
Fast spherical harmonic transform
Orszag (1986)
Fast transform for any basis satisfying
3-term recurrence relation
Elowitz&Hill
Compares fast transforms of Dilts (1985),Brown (1985)
&Duvall (1989)
but conclusion is false
Alpert&Rokhlin(1991)
Fast Legendre-to-Chebyshev transform;
does not generalize to associated Legendre
Boyd (1992c)
Showed FMM could be applied to non-Chebyshev basis
Dutt&Rokhlin (1993,1995)
FMM nonequispaced FFT
Jakob-Chien&Alpert(1997)
Grid-to-spherical-harmonics-to-grid
Yarvin&Rokhlin(1998)
projective ﬁlter for longitude/latitude
time-dependent double Fourier series
Foster&Worley(1997)
Comparison of parallel spherical harmonic transforms
Healy&Rockmore&
Fast spherical harmonic transform;
Kostelec&Moore(1999)
freeware at www.cs.dartmouth.edu/ geelong/sphere
Swarztrauber&Spotz(2000)
“Weighted Orthogonal Complement” algorithm reduces
Spotz&Swarztrauber(2000)
storage by O(N); faster than alternatives
because algorithm mostly stays in the on-chip cache
18.13
Equiareal Resolution and the Addition Theorem
Deﬁnition 40 (Equiareal Resolution) A numerical algorithm which has the property that its
numerical characteristics are invariant to a rotation of the north pole of the coordinate system so
that features of a given size are resolved equally well or badly regardless of whether they are located
at the poles, equator, or anywhere in between.
A so-called “triangular truncation” of a spherical harmonic basis has this property be-
cause of the following theorem and its corollaries.
Theorem 36 (ADDITION THEOREM:) Let (λ′, θ′) denote longitude and latitude as measured
relative to a set of coordinate axes rotated with respect to the original axes. Let (λ, θ) denote the
angles measured relative to the original, unrotated coordinate system. Then
Y m
n (λ′, θ′) =
n
X
m′=−n
D(n)
mm′(R) Y m′
n (λ, θ)
(18.45)
where the coefﬁcients D(n)
mm′ are functions of the rotation angle.
COROLLARY 1: The spherical harmonics of degree n form a (2n+1)-dimensional representation of
the continuous rotation group.
COROLLARY 2: A triangular truncation of spherical harmonics, that is, keeping only those har-
monics such that
n ≤N
all m
(18.46)
gives equal resolution to equal areas on the globe, regardless of where those areas are located.
PROOF: Eq. (18.45) is a classical result discussed in most quantum mechanics texts such as
Merzbacher (1970).

18.14. SPHERICAL HARMONICS: LIMITED-AREA MODELS
409
The ﬁrst corollary is merely a way of restating the theorem in the jargon of group theory.
When we rotate the pattern that is a particular spherical harmonic Y m
n , we create a new
function of latitude and longitude. Like all such functions, this may be expanded in a
spherical harmonics series, but there is no obvious reason why these series should not
contain an inﬁnite number of terms. The theorem shows, however, that the series contains
at most (2n+1) terms, and all the non-zero harmonics have the same degree n as the function
that is rotated. Thus, the spherical harmonics of degree n form a closed subset under rotation
through arbitrary angles — and this is what is required to form a “representation of the
rotation group”.
The collection of spherical harmonics that are retained in a “triangular truncation”
therefore are closed under rotation, too. This implies the property of equiareal resolution.
In the words of Orszag (1974), “The basic mathematical reason is that, under arbitrary ro-
tations, expansions truncated at harmonics of degree N remain truncated at degree N so
that the resolution of such series must be uniform over the sphere.”
18.14
Variable Resolution Spherical Harmonics Models
“Limited-area” weather forecasting models offer the advantages of very high resolution
over a small portion of the earth’s surface — higher than would be affordable if this resolu-
tion were extended over the entire globe. Most national weather services run limited-area
models targeted at the country that pays for them. Limited-area models are also used to
track tropical hurricances, which have such small scales that it is difﬁcult for uniform res-
olution global models to track them accurately.
One obvious strategy is to employ a dense but uniform grid over a small portion of the
globe and specify inﬂow-outﬂow conditions at the sides, usually from climate data or from
interpolation of a global model. Such non-global limited-area codes are in wide use, but
there are difﬁculties. One is that specifying lateral boundary conditions turns out be very
hard; rather elaborate blending procedures are necessary to avoid corruption of the high-
resolution data within the domain by the low-resolution data at the boundaries. Moreover,
as models incorporate more and more physics and chemistry, it has become increasingly
painful to maintain two completely separate models, one global and one limited-area, us-
ing different numerical schemes, tuning parameters and so on.
An alternative is to use the global model as the limited-area model, too. This can be
done by a smooth change of coordinates that maps the surface of the sphere into itself. In
physical space, the transformed grid has a high density of points over the region of interest,
but decreases to lower and lower density as one moves away from the target region. No
artiﬁcial sidewall boundary conditions are needed because there are no sidewalls. A single
model can be used for both global and regional forecasting by switching on or off a few
metric factors in the evaluation of derivatives.
Schmidt(1977, 1982) proposed a conformal sphere-to-sphere mapping which he tested
successfully in a simple code. With reﬁnements, this has been adopted by M´et´eo-France
for its primary operational weather forecasting code (“Arpege”) as described by Courtier
& Geleyn(1988), Courtier et al.(1991), and D´equ´e&Piedelievre(1995). Hardiker(1997) has
shown that such mappings are equally effective for tracking hurricanes.
These variable-resolution models have been sufﬁciently successful that the desire to
combine global and regional models into a single code is not a major threat to continued use
of spherical harmonics for weather forecasting. Rather, the big Thing-That-Goes-Bump-in-
the-Night is the switch to massively parallel machines, which may or may not be happy
doing PMMTs for very large N.

410
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Table 18.6: Variable Resolution Spherical Harmonic Models
References
Comments
Schmidt(1977,1982)
Conformal mapping to give high local resolution
to track cyclones
Courtier&Geleyn(1988)
Variable resolution (mapped) weather prediction
Courtier et al.(1991)
Arpege project at M´et´eo-France:
global weather model with high resolution in Europe
D´equ´e&Piedelievre(1995)
Experience with Arpege variable resolution weather model
Hardiker(1997)
Conformal mapping for variable resolution
18.15
Spherical Harmonics and Physics
The spherical harmonics are the eigenfunctions of the two-dimensional Laplacian operator
∇2Y m
n = −n(n + 1) Y m
n
(18.47)
where
∇2 ≡∂2
∂θ2 + cot(θ) ∂
∂θ +
·
1
sin2(θ)
¸ ∂2
∂λ2
(18.48)
Because of this, the spherical harmonics are fundamental solutions to many problems in
physics.
In geophysics, for example, Haurwitz (1940) showed that the streamfunction for lin-
ear, barotropic Rossby waves was proportional to a spherical harmonic, that is to say, the
spherical harmonics are the quasi-geostrophic normal modes of the earth’s atmosphere.
Similarly, Longuet-Higgins (1968) has shown that for gravity waves in the barotropic limit,
the velocity potential is proportional to a spherical harmonic. In both cases, elementary
identities show that the velocities and other quantities may be written as pairs of spherical
harmonics.
Barrett (1958) observed that since the (purely westward) phase velocity is
cphase = −
2 Ω
n (n + 1)
[Rossby-Haurwitz waves]
(18.49)
one may synthesize a uniformly propagating disturbance from an arbitrary sum of spheri-
cal harmonics of the same degree n. In particular, an “eccentric” spherical harmonic, that is,
a spherical harmonic rotated so that its pole at some arbitrary latitude θp, is a steadily prop-
agating Rossby wave because of the addition theorem of Sec. 18.13. In more recent times,
such rotated spherical harmonics have been the basis for constructing nonlinear modons
in spherical geometry as explained by Tribbia(1984b).
One could multiply these examples with dozens from other ﬁelds (Morse and Fesh-
bach, 1953). This close and intimate connection between the spherical harmonics and the
physics, as well as their good numerical properties, have helped to make spherical har-
monics popular.
18.16
Asymptotic Approximations I: Polar-Cap and Bessel
Functions
At high latitudes,
cos(θ) ≈1
&
sin(θ) ≈θ
θ ≪1
(18.50)

18.16. ASYMPTOTIC APPROXIMATIONS, I
411
and the horizontal Laplacian operator becomes
∇2 ≈∂2
∂θ2 + 1
θ
∂
∂θ + 1
θ2
∂2
∂λ2
(18.51)
which is identical in form with the Laplacian in plane polar coordinates if we identify θ
with radius r and λ with the polar angle. For a given zonal wavenumber m, the second
λ-derivative in (18.51) becomes multiplication by (−m2) and the eigenequation ∇2Y m
n
=
−n(n + 1) becomes Bessel’s equation:
µ d2
dθ2 + 1
θ
d
dθ +
½
k2 −m2
θ2
¾¶
Jm(kθ) = 0
(18.52)
where
k ≡
p
n (n + 1)
(18.53)
A more heuristic (but equally correct) way of justifying this planar, polar coordinate
approximation is to simply look down on a globe from above one of the poles. As one
moves closer and closer to the poles, the sphere ﬂattens into a plane, and the meridians
form a network of radial lines.
Since this “polar-cap” approximation becomes exact near the pole, the Bessel functions
must be consistent with the known behavior of the spherical harmonics at the pole. We
note that Jm(r) has an m-th order zero at r = 0 — mimicing the m-th order zero of Y m
n at
the pole. If we expand Y m
n as a power series in θ, we ﬁnd that the expansion contains only
every other power of θ; even powers of θ when m is even and odd powers of θ (because of
the “parity factor”, sin(θ)) when m is odd. Similarly, the expansion of Jm(r) is in alternating
powers of r; since the expansion begins with rm, the powers are the odd powers of r when
m is odd and the even powers of r when m is even.
The Bessel function (for m > 0) rises monotonically to a turning point at r ≈m and
then oscillates for larger values of its argument. Fig. 18.9 illustrates three typical Bessel
functions. The turning colatitude is
θt ≈
m
p
n (n + 1)
[“turning colatitude”]
(18.54)
When m is roughly equal to n (recall that n cannot be smaller than m), then the predicted
turning latitude is θt ≈1, that is, only about 30 degrees from the equator. The polar cap
approximation is not accurate that close to the equator, so what the Bessel approximation
tells us in this case is simply that the spherical harmonic has most of its amplitude at low
latitudes (where we shall use a different approximation given in the next section). Near the
pole, the Bessel approximation is still valid — but the behavior of both Jm(kθ) and Y m
n is
dominated by the m-th order zero at the pole, so the polar cap approximation does not tell
us anything we did not already know.
When n ≫m, however, the predicted turning point is close to the poles and the Bessel
approximation is more useful. There is some region equatorward of θt where the Bessel
approximation is legitimate, and we can use the asymptotic approximation
Jm
³
[n(n+1)]
1
2 θ
´
∼
·
4
π2n(n+1) θ2
¸ 1
4
cos
½
[n(n+1)]
1
2 θ −(2m+1) π
4
¾
θ ≫θt
(18.55)
Eq. (18.55) shows explicitly that a spherical harmonic oscillates equatorward of its turning
latitude. It also shows that the amplitude of the oscillation decreases in the direction of
the equator (as 1/
√
θ) — the maximum of the harmonic is just equatorward of the turning
latitude.
The “polar-plane” approximation, which invented by B. Haurwitz, has been systemat-
ically developed for geophysical applications (Bridger and Stevens, 1980).

412
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Figure 18.9: Three Bessel functions, illustrating the behavior of spherical harmonics near
the pole, r = 0. Note that J10(r), which is representative of high degree harmonics, has a
“turning latitude” at about r = 10: the function is exponentially decaying towards the pole
for small r, and oscillatory for larger r. (r ≡
p
n(n + 1) θ increases toward the equator.)
18.17
Asymptotic Approximations, II: High Zonal Wavenum-
ber & Hermite Functions
Abramowitz & Stegun (1965) give the asymptotic approximation
P m
m+n′[cos(θ)]
∼
q exp(−1
2 mφ2) Hn′(√m φ)
(18.56)
m →∞, n′ ﬁxed, φ ∼O
µ 1
√m
¶
where q is a constant, φ is latitude [not colatitude] and Hn′ is the usual Hermite polynomial.
This approximation is complementary to that of the previous section. First, the “polar cap”
approximation is accurate only for high latitudes while (18.56) is limited to a band around
the equator. Second, the Bessel approximation becomes more useful when n ≫m whereas
the Hermite formula is most accurate when m ≫n′, that is, in the limit of large zonal
wavenumber for ﬁxed n′ where n′ is the number of zeros of the harmonic (excluding those
at the poles).
With a triangular truncation at degree N, there are but two harmonics with zonal
wavenumber N, and their common latitudinal structure is, according to (18.56), given
by the Gaussian, exp(−
√
N φ2). Now the highest zonal wavenumber would impose the

18.17. ASYMPTOTIC APPROXIMATIONS, II
413
Figure 18.10: A comparison of the exact associated Legendre function, P 9
9 (φ) [solid] with
its asymtotic approximation, the Hermite function exp(−[9/2] φ2) [dashed]. φ is colatitude
& φ = π/2 is the equator.
strictest requirement on the time step if we expanded the unknowns in a double cosine
series (instead of spherical harmonics)– but zonal wavenumber N does not translate into
a very small longitudinal grid interval near the poles for the spherical harmonics because
the Gaussian has an exponentially small amplitude near the pole. The equatorial conﬁne-
ment embodied in (18.56) is how the “pole problem” is avoided when we use spherical
harmonics to integrate time-dependent equations.
Figs. 18.10 and 18.11 show that the Hermite approximation is not uniform in degree
n (or n′); as n increases for ﬁxed zonal wavenumber, the harmonic becomes wider and
wider in latitude and (18.56) becomes less and less accurate. However, inspecting Fig. 18.11
more carefully, we note that even as the approximation becomes numerically less accurate,
it remains qualitatively correct in the sense that the harmonic oscillates close to the equator
and then decays monotonically towards the poles on the far side of the turning latitudes.
[One may in fact obtain a very accurate approximation to P 9
13 merely by replacing √m in
(18.56) by 3.33 to narrow the Hermite function.]
One obvious question is: what is the physical reason for this equatorial conﬁnement of
spherical harmonics with (n −m) ≪m? Fig. 18.12 shows a ray-tracing argument that
makes the trapping at least plausible. Because of the spherical geometry, a ray that leaves
the equator at say a 45 degree angle (that is, moving in a north-east direction) will not reach
the poles if it moves in a straight line on the sphere, that is, if the ray moves as a geodesic.
When the zonal wavenumber is large in comparison to the latitudinal wavenumber, i. e.
m ≫(n −m), then the equivalent ray is almost parallel to the equator and the turning
latitude is only a short distance from the equator.
To be sure, this argument is only heuristic. We have not attempted to justify ray-tracing.
Indeed, the spherical harmonics often appear in electrostatic and gravitational problems
where no rays are evident. However, this refraction-by-geometry is a real and physically
important effect in many wave problems. Boyd (1985b) gives a geophysical discussion.

414
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Figure 18.11: A comparison of the exact P 9
13(φ) [solid] with its asymptotic approximation,
exp[−(9/2)φ2] H4(3φ), which is shown as the dashed curve. For a given zonal wavenumber
[m = 9 for both this ﬁgure and its predecessor], the approximation worsens with increasing
degree, but remains qualitatively accurate even for fairly large degree.
18.18
Software: Spherical Harmonics
John Adams and Paul N. Swarztrauber of the National Center for Atmospheric Research
have written a very comprehensive software library to compute spherical harmonics, their
derivatives, transforms from grid point values to spectral coefﬁcients, interpolation from
an evenly spaced latitudinal grid to the Gaussian grid employed by forecasting models,
and computation and manipulation of vector spherical harmonics.
SPHEREPACK 3.0
is now available at http://www.scd.ucar.edu/css/software/spherepack. A shallow water
model, complete with a full suite of test cases, and a three-dimensional global circulation
model are also available from NCAR, complete with documenation.

18.18. SOFTWARE: SPHERICAL HARMONICS
415
Figure 18.12: Schematic of the behavior of rays trapped on the surface of a sphere. In
the absence of other refractive mechanisms, the rays follow geodesics, that is, great cir-
cle trajectories. The illustrated ray cannot propagate poleward of the dotted circles: it is
latitudinally conﬁned.

416
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
18.19
Semi-Implicit Spherical Harmonic Methods for the Shal-
low Water Wave Equations
Real forecasting models have three spatial dimensions, but since the radial (vertical) coor-
dinate is irrelevant to spherical harmonics, we will discuss the simpler case of the shallow
water wave equations, which are two-dimensional in space, based on the classic paper of
Bourke (1972).
The shallow water equations may be written in the form
⃗Vt
=
−(ζ + f)⃗k × ⃗V −∇
µ
φ′ + 1
2
⃗V · ⃗V
¶
(18.57a)
φ′
t
=
−∇· (φ′ ⃗V ) −Φ D
(18.57b)
where ζ is the vorticity [strictly, the vertical component of the vorticity vector], f is the
Coriolis parameter, ⃗k is a unit vector in the vertical direction, ⃗V is the horizontal velocity
vector, and D is the divergence of ⃗V . The height ﬁeld has been split into a mean part,
Φ, and deviations from the mean, φ′, because these parts will be treated differently in the
time-marching algorithm.
The major problem in Eq. (18.57) is that its free oscillations are composed of two sets of
waves with wildly disparate time scales: (i) slow, low-frequency Rossby motions and (ii)
high frequency gravity waves. Existing data networks cannot adequately resolve the grav-
ity waves, and these high frequency motions have little effect on weather or climate. From
the perspective of global weather modelling, the gravity waves are simply noise. Unfor-
tunately, this noise shortens the maximum stable time step for an explicit time differencing
scheme from about 60 minutes to 10 minutes.
For this reason, so-called “semi-implicit” time marching schemes (Chapter 12) have
become very popular in meteorology. A small set of terms which are essential to the (linear)
propagation of gravity waves are treated implicitly, but most of the linear terms and all the
nonlinear terms are handled explicitly. This makes it possible to increase the time step by
a factor of six with no signiﬁcant loss of accuracy and without the iterations that would be
needed in a fully implicit code.
One major reason why spherical harmonics have carried the ﬁeld in meteorology is that
these expansions allow very simple and efﬁcient semi-implicit time-stepping algorithms.
The two crucial tricks are to (i) decompose the horizontal velocity into the contributions of
a scalar streamfunction ψ and scalar velocity potential χ via
⃗V ≡⃗k × ∇ψ + ∇χ
(18.58)
and (ii) replace the horizontal momentum equations by a vorticity equation and a diver-
gence equation, which are obtained by taking the curl and divergence of (18.57a), respec-
tively:
ζt
=
−∇·
h
(ζ + f) ⃗V
i
[vorticity eq.]
(18.59)
Dt =
⃗k · ∇×
h
(ζ + f) ⃗V
i
−∇
µ
φ′ + 1
2
⃗V · ⃗V
¶
[divergence eq.]
(18.60)
This vorticity/divergence form is useful in part because of the exact relations
ζ = ∇2ψ
&
D = ∇2χ
(18.61)

18.19. SEMI-IMPLICIT: SHALLOW WATER
417
Since the spherical harmonics are the eigenfunctions of the Laplacian, (18.61) is equivalent
to the statement that the spherical harmonic coefﬁcients of ζ and D are directly propor-
tional to those of ψ and χ, respectively. Thus, the vorticity and divergence equations plus
the “height” equation (18.59) form a closed set of three equations in three unknowns: ψ, χ,
and φ′. Furthermore, all the unknowns are scalars and may be expanded directly in spher-
ical harmonics.
The second virtue of the vorticity-streamfunction procedure is that a semi-implicit algo-
rithm for the shallow water set requires implicit treatment of only (i) the ∇2φ′ term in the
divergence equation and (ii) the ∇2χ(= D) term in the height equation. With a ﬁnite dif-
ference model, one would have to solve two Poisson equations at every time step because
φ′ and χ appear only in the form of the Laplacian operator acting upon these unknowns.
With a spectral model using spherical harmonics (but only spherical harmonics!), we do
not have to invert the Laplacian because the spherical harmonics are its eigenfunctions:
the Laplacian applied to a spherical harmonic is equivalent to multiplying that harmonic
by −n(n + 1) where n is the degree of the harmonic.
This in turn leads to the third trick: applying Galerkin’s method instead of the pseu-
dospectral algorithm. Normally, the latter is simpler and easier to program, but a pseu-
dospectral application of spherical harmonics would require inverting large matrices at
every time step.
The fourth trick is to introduce the modiﬁed velocity components U(≡uλ sin[θ]) and
V (≡uθ sin[θ]); although not unknowns, they are useful auxiliary quantities for evaluating
the nonlinear terms. If we expand
ψ =
N
X
m=−N
N
X
n=|m|
ψmn Y m
n
(18.62)
and similarly for the other ﬁelds, identities and recurrence relations for the spherical har-
monics and (18.58) show that the coefﬁcients of U and V are
Umn
=
(n −1) Dmn ψm,n−1 −(n + 2) Dm,n+1 ψm,n+1 + im χmn
(18.63)
Vmn
=
−(n −1) Dmn χm,n−1 + (n + 2) Dm,n+1 χm,n+1 + im ψmn
(18.64)
where
Dmn ≡
r
n2 −m2
4 n2 −1
(18.65)
The ﬁfth trick is the pseudospectral strategy of evaluating the nonlinear terms in grid-
point space rather than by forming convolution sums or inner products of the spherical
harmonic coefﬁcients. First, the series for ∇2ψ, φ′, U, and V are evaluated on a latitude
and longitude grid. [Note that the coefﬁcients for the ∇2ψ are those for ψ multiplied by
−n(n+1).] Then the ﬁve needed nonlinear products are formed: U∇2ψ, V ∇2ψ, Uφ′, V φ′,
and [(U 2+V 2)/2] by multiplying the gridpoint values of the factors. Finally, these products
are reexpanded in spherical harmonics.
In a fully pseudospectral treatment, we omit the step of expanding the nonlinear prod-
ucts in basis functions and instead advance the calculation in time on the grid point values.
However, here it is better to advance the spectral coefﬁcients in time. The reason is that the
linear terms in the shallow water wave equations — including the critical terms that we
wish to treat implicitly — involve the Laplacian operating on an unknown. If we use the
spherical harmonics rather than the equivalent cardinal functions as the unknowns, then
the Laplacians are reduced to factors of −n(n + 1) multiplying the coefﬁcients.

418
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
The end result is to convert the shallow water wave equations to the set of ordinary
differential equations in time:
−n (n + 1) dψmn
dt
= 1
2
½
⟨imAm, P m
n ⟩−
¿
Bm, dP m
n
dµ
À¾
(18.66a)
+ [n (n −1) Dmn χm,n−1 + (n + 1)(n + 2) Dm,n+1 χm,n+1 −Vmn]
−n (n + 1) dχmn
dt
= 1
2
½
⟨imBm, P m
n ⟩+
¿
Am, dP m
n
dµ
À¾
(18.66b)
−[n (n −1) Dmn ψm,n−1 + (n + 1)(n + 2) Dm,n+1 ψm,n+1 + Umn]
+ n (n + 1)
·1
2 ⟨Em, Pn⟩+ φmn
¸
dφmn
dt
= −1
2 ⟨imCm, P m
n ⟩−
¿
Dm, dP m
n
dµ
À
+ Φ n (n + 1) χmn
(18.66c)
where µ = cos(θ), and Am(µ), Bm(µ), Cm(µ), Dm(µ), and Em(µ) are the coefﬁcients
of the longitudinal Fourier series of the nonlinear terms: U∇2ψ, V ∇2ψ, Uφ′, V φ′, and
(U 2 + V 2)/2, respectively, and the inner product is
⟨a(µ), b(µ)⟩≡
Z 1
−1
a(µ) b(µ)
1 −µ2
dµ
(18.67)
The inner products are evaluated by Gaussian quadrature using the model grid points,
which are the roots of the Legendre polynomials, Pn(µ).
There are many variants to the semi-implicit time-stepping, but the important point is
that all terms are treated explicitly in (18.66) except for φmn(t) in the divergence equation,
(18.66b), and χmn(t) in the height equation, (18.66c). More details are given in Bourke
(1972, 1974) and Bourke et al. (1977). A well-documented and intensively tested shallow
water code is available from the National Center for Atmospheric Research. The same
algorithm is used in the three-dimensional climate model, the CCM3, which is publicly
available at http://neit.cgd.ucar.edu/cms/ccm3/.
The shallow water wave equations are inviscid, but it is trivial to add viscous damping.
The viscosity operator is the Laplacian and the spherical harmonics are its eigenfunctions.
18.20
Fronts and Topography: Smoothing/Filters
18.20.1
Fronts and Topography
Fluid ﬂows spontaneously develop narrow, curved regions of very large gradients. These
regions are known as “fronts” in geophysics and “shocks” in aerospace and plasma physics.
The frontal zones narrow to jump discontinuities in the limit of zero viscosity. For phys-
ically reasonable viscosities, which are very small, the frontal zones are much narrower
than the separation between grid points. Therefore, it is necessary to apply some kind of
ﬁltering to prevent computational catastrophe.
Another curse is peculiar to meteorology. The topography of the earth’s surface varies
on a wide variety of scales including scales far below that which can be resolved by a global
model. Worse still, the topography has a discontinuous ﬁrst derivative at the coasts where
the non-zero slope of land abruptly gives way to the zero slope of the oceans. (Of course,
the ocean is continually rippled by waves, but on the scale of a global forecasting model,

18.20. FRONTS AND TOPOGRAPHY: SMOOTHING/FILTERS
419
  


yy
zz
{{
||
  


yy
zz
{{
||
  




yy
zz
{{
{{
||
||
Real
Gibbs
Figure 18.13: Left: The real world. The lower boundary for an atmospheric model is the
jagged surface of the land (black) plus the ﬂat surface of the ocean (confetti-shading). The
boundary has a discontinuous slope at the coast. Right: “Gibbs” world. When the lower
boundary of the atmosphere is approximated by a ﬁnite sum of spherical harmonics, large
valleys are created in the ocean. The frowning ﬁsh had better learn to breathe air!
these wind-induced ripples are negligible.) It follows that if the topography is expanded
as a series of spherical harmonics, the expansion will have only an algebraic rate of con-
vergence with large Gibbs ripples. (These ripples are sometimes called “spectral ringing”.)
Even at high resolution, the partial sums of the topography may have undulating valleys
one hundred meters deep in the oceans, as illustrated in the cartoon Fig. 18.13.
Both fronts and topography require smoothing or ﬁltering of spectral series. For fronts,
the ﬁltering is applied at every time step as an artiﬁcial dissipation. Since front problems
are intimately connected with spectral blocking, aliasing instability, and other difﬁculties
described at length in Chapter 11, we shall concentrate on the difﬁculty peculiar to mete-
orology, which is the highly irregular lower boundary of the ﬂuid. The topography needs
to be ﬁltered only once in a pre-processing step. However, the mechanics of making good
ﬁlters is similar for both once-only and every-step ﬁltering.
18.20.2
Mechanics of Filtering
If Q(λ, θ) denotes a function on the surface of a sphere with spherical harmonic coefﬁcients
Qm
n , then its ﬁltrate QF can be represented in spectral space as
QF (λ, θ) ≡
∞
X
n=0
n
X
m=−n
σnm Qm
n Y m
n (λ, θ)
(18.68)
where the σnm are the ﬁlter coefﬁcients. QF can also be represented in physical space as an
integral:
QF (λ, θ) ≡
Z 2π
0
dλ′
Z π
0
sin(θ′)dθ′ w(λ′, θ′) Q(λ′, θ′)
(18.69)
where the primed coordinates denote latitude and longitude in a coordinate system that
has been rotated so that the point (λ, θ) is the north pole of the rotated coordinate system.
The reason for this apparently complicated tactic of a different coordinate system inside
the integral for each point is justiﬁed by a theorem proved by Sardeshmuhk and Hoskins

420
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
(1984): if the weight function w(λ′, θ′) is “isotropic”, that is, a function only of the distance
from the point where Q is evaluated inside the integral to the point where QF is being
computed, then w is a function only of θ′ in the rotated coordinate system. Furthermore, if
the ﬁlter is isotropic, they prove that the weights σnm must be a function of n only, that is,
must be the same for all spherical harmonics of the same subscript.
Sardeshmukh and Hoskins note that truncation of a spectral series is just a special case
of ﬁltering in which all the ﬁlter weights are either one or zero. The triangular truncation
of order N, usually denoted as “TN”, is the isotropic ﬁlter
σnm =
½
1
n ≤N
0
otherwise [triangular truncation]
(18.70)
The rhomboidal truncation, which keeps the same number of basis functions for each zonal
wavenumber [superscript] m, is not isotropic — another reason why it has fallen from
grace.
For an isotropic ﬁlter, the weight function varies only with θ′ in the integral representa-
tion of QF . It can therefore be expanded as a one-dimensional series of ordinary Legendre
polynomials (Sardeshmukh and Hoskins, 1984):
w(θ′) = 1
4π
∞
X
n=0
σn (2n + 1)Pn(cos(θ′)
(18.71)
In the limit that all σn = 1, this is just the Legendre series for the Dirac delta function.
When the series is truncated, the weight function is a ﬁnite Legendre approximation to the
delta-function (Fig. 18.14).
Unfortunately, this approximation for ﬁnite N is rather ugly. It resembles a Bessel func-
tion with a maximum at the origin and oscillations that decrease very slowly with radius.
Thus, values of Q far from the point (λ, θ) have a strong inﬂuence on the values of QF at
that point. A weight function that decays rapidly and monontonically is much more reason-
able than one with wiggles and slow decay, as produced by truncation.
In this sense, truncating a series is a rather stupid idea: a ﬁltered approximation, if the
ﬁlter weights are chosen properly, is much more reasonable. But how are the weights to be
chosen?
18.20.3
Spherical splines
Truncation of a spectral series generates an approximation which is the best possible in a
least-squares sense. The reason that the truncated series is unsatisfactory is that the ap-
proximation is very wiggly. Ocean valleys are both ugly and unphysical!
The remedy is to compute an approximation which minimizes a “cost” function that
not only penalizes least-square error, but also excessive wiggles. Spherical splines of order
k are a weighted sum of spherical harmonics which minimizes the cost function
J ≡
Z
Ω
dΩ( Q(λ, θ) −QN(λ, θ))2 + α
Z
Ω
dΩ
¡
∇2kQN
¢2
(18.72)
where Ωdenotes the surface of the sphere and the approximation QN is
QN =
N
X
n=0
n
X
m=−n
am
n Y m
n (λ, θ)
(18.73)
When the parameter α = 0, the cost function is the usual mean-square error and QN is
the unﬁltered truncation of the series. As α > 0 increases, the cost function depends more

18.20. FRONTS AND TOPOGRAPHY: SMOOTHING/FILTERS
421
and more on the smoothness of the approximation since wiggles imply large coefﬁcients
for high degree spherical harmonics. Recalling that
∇2Y m
n = −n(n + 1)Y m
n
(18.74)
it follows that high degree coefﬁcients contribute disproportionately to the second term
in the cost function. The cost can only be minimized by reducing the wiggles, that is, by
reducing the large n coefﬁcients, even though this slightly increases the mean-square error.
One can prove that the minimum of the cost function is rigorously given by
am
n =
bm
n
1 + αn2k(n + 1)2k
(18.75)
where the bm
n are the usual unﬁltered spherical harmonic coefﬁcients.
Lindberg and Broccoli(1996) have applied spherical splines to topography. Wahba(1990)
reviews the general theory. The method can be generalized by replacing a single power of
the Laplacian in the second term by a weighted sum of Laplacians to make the weights
in Eq.(18.75) almost anything that one pleases. Almost any reasonable choice — Lindberg
and Broccoli set k = 1 so that the smoothness penalty was the mean-square norm of the
Laplacian — will produce a smoother approximation than truncation.
-0.2
0
0.2
-0.2
0
0.2
0
200
400
600
800
Unsmoothed weight
Figure 18.14: Mesh plot of the weight function for an unﬁltered truncation of a spherical
harmonics series. (N = 100.)

422
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
18.20.4
Filter Order
It is convenient to describe the properties of a ﬁlter in terms of a continuous function σ
such that the discrete weights are given by σ for arguments ranging between zero and one:
σn = σ
µ
n
N + 1
¶
,
n = 0, 1, 2, . . . , N
(18.76)
Deﬁnition 41 (Filter Order) A ﬁlter is said to be of ORDER “p” if
σ
µ j
N
¶
∼O
µ 1
N p
¶
,
N →∞, ﬁxed j
(18.77)
or equivalently, if 1 −σ is an analytic function that has a (p −1)-st order zero at the origin.
The concept of the order is important for two reasons. First, if the function is inﬁnitely
differentiable so that its spectral series is converging exponentially fast, then it is both nec-
essary and sufﬁcient for the ﬁlter order to be p so that the errors produced by the ﬁltering
are O(1/N p) where N is the truncation. Put another way, it is desirable to use a ﬁlter of
high order to avoid throwing away the advantages of a high order method when comput-
ing smooth solutions. Second, when the solution is not smooth and its unﬁltered series
converges only at an algebraic rate, it has been shown that, at least in one dimension, one
can recover the true solution to within O(1/N p) by using a ﬁlter of order p at any ﬁxed
distance away from the singularity of the solution (Vandeven, 1991).
The bad news is that the proportionality constant in Vandeven’s theorem is propor-
tional to the p-th power of distance from the singularity, so that ﬁltering, at least ﬁltering
through weighted partial sums, is unable to avoid O(1) errors in the immediate neighbor-
hood of the front or shock. This is not too surprising because a slight shift in the location
of a jump discontinuity implies that a small region that should be on the low side of the
jump is placed on the high side, creating a pointwise error equal to the magnitude of the
jump. Away from the discontinuity where the solution is smooth, however, we can ﬁlter
the slowly convergent series to recover the function to arbitrarily high order — if and only
if we use a high order ﬁlter.
Vandeven shows that to be truly p-th order, a ﬁlter σ(ζ) must have also have a (p −1)-st
order zero at ζ = 1. Spherical smoothing splines, even for large order k, technically ﬂunk
these conditions. So also does the exponential ﬁlter favored by Hoskins(1980),
σ(exponential)(ζ) ≡exp(−constant(n(n + 1))k ζ)
(18.78)
If, however the ﬁlter weights are exponentially small for the high n coefﬁcients, the ζ = 1
conditions are approximately satisﬁed. Spherical splines (for high powers k of the Laplace
operator) and the exponential ﬁlter thus work as high order ﬁlters in practice.
Vandeven himself devised a ﬁlter which satisﬁed all the conditions of his theorem
exactly. Unfortunately, his “ultimate” ﬁlter is an incomplete beta function. Boyd(1996c)
showed that there is a close relationship between Vandeven’s ﬁlter and the two hundred-
year old series acceleration method of Euler. He also demonstrated that both can be ap-
proximated quite accurately by an analytical function that satisﬁes Vandeven’s conditions
exactly, the “Erfc-Log” ﬁlter:
σErfc−Log(θ; p) ≡1
2erfc


2p1/2 θ
s
−log(1 −4θ
2)
4θ
2



(18.79)
where
θ ≡|θ| −1
2
(18.80)

18.20. FRONTS AND TOPOGRAPHY: SMOOTHING/FILTERS
423
18.20.5
Filtering with Spatially-Variable Order
Boyd(1995e) shows that the optimum order p for a function with a discontinuity is an in-
creasing function of distance from the singularity. This is consistent with the philosophy of
Flux-Corrected Transport algorithms for ﬂows with shocks: low order method around the
shock, a higher order method farther away. For a Fourier series with a spatial period of 2π,
the optimal order is
poptimum(x) = 1 + N
d(x)
2π
(18.81)
where d(x) is the distance from point x to the singularity. (This distance is calculated by
interpreting the interval x ∈[0, 2π] as a circle.)
As a one-dimensional example, consider the “sawtooth” function deﬁned by
Sw(x) ≡
½ x/π
x ∈[−π, π]
Sw(x + 2πm)
|x| ≥π, m = integer
(18.82)
which has the very slowly converging Fourier series
Sw(x) ≡2
π
∞
X
j=1
(−1)j+1
j
sin(jx)
∀x
(18.83)
Fig. 18.15 shows ﬁltering of both ﬁxed order and spatially-varying order. With 100
terms, the accuracy is greater than 1/100,000 over 90% of the spatial interval. Fig. 18.16 is
a zoom plot showing a small portion of the spatial interval. It is indeed possible to recover
spectral accuracy outside of a small neighborhood of the discontinuity. The best ﬁlter is of
spatially-varying order and is of high order away from the discontinuity.
18.20.6
Topographic Filtering in Meteorology
A wide variety of ﬁlters have been employed to smooth topography for spherical harmon-
ics models. Because they are high order ﬁlters, the exponential ﬁlter of Hoskins(1980) and
Sardeshmukh and Hoskins(1984) and the spherical splines of Lindberg and Broccoli(1996)
look good, at least when the tunable order parameter is sufﬁciently large. Bouteloup(1995)
employed an optimization approximation very similar to spherical splines, but with more
elaborate smoothness penalties. In contrast, Navarra, Stern and Miyakoda’s (1994) Cesaro
ﬁlter is a low order ﬁlter and therefore tends to smooth even the largest spatial scales too
much. However, Navarra et al. nevertheless obtained a smoothed topography that was
much more satisfactory than the truncated, unﬁltered series, which emphasizes that for
a function with a discontinuity or discontinuous slope, almost any ﬁltering is better than
none.
The spurious ocean valleys have been especially annoying to numerical modellers be-
cause darn it, one really ought to be able to represent a ﬂat ocean surface as a ﬂat surface.
A child with a ruler and a pencil can draw an approximation much better than the trun-
cated spherical harmonics series! This suggested to Navarra, Stern and Miyakoda(1994),
Bouteloup(1995) and Lindberg and Broccoli(1996) that it would be desirable to employ a
non-isotropic ﬁlter which is strong over water, and weak over land. Lindberg and Broccoli,
for example, restricted the integral of the Laplacian to water only so that the approximation
was penalized for oscillations over water, where it should be ﬂat, but not over land, where
the oscillations might represent the real hills and valleys.
This differential land/water ﬁlter is sound strategy. However, distance from the singu-
larity — for topography, it is distance from the coast where the slope of the atmospheric
boundary is discontinuous — also should control the order p of the ﬁlter.

424
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Table 18.7: Filtering and Smoothing on the Sphere
References
Comments
Hoskins(1980)
exponential ﬁlter
Sardeshmukh&Hoskins(1984)
Isotropy Theorem; exponential ﬁlter
Hogan&Rosmond(1991)
comparison of several ﬁlters;
applied Lanczos ﬁlter to Navy forecast model
Navarra&Stern
2D isotropic ﬁlter (Cesaro); 2D physical space
&Miyakoda(1994)
ﬁlter applied to oceans only
Bouteloup(1995)
optimization method with multiple penalty constraints
Lindberg&Broccoli(1996)
spherical spline; orography & precipitation
Gelb(1997)
Gegenbauer regularization, restricted to discontinuities
Gelb&Navarra(1998)
parallel to either latitude or longitude lines
Clearly, there is a need for further experimentation and creativity. Gelb (1997) and
Gelb and Navarra(1998) used an ingenious regularization procedure which replaces a high
order spherical harmonic series by a low order Gegenbauer polynomial series. Unfortu-
nately, their method requires that the discontinuities lie on the walls of a rectangle or a
union of rectangles. In its present state, the Gegenbauer method is not sufﬁciently gen-
eral to accomodate real topography. However, this strategy, which can be applied to other
spectral series, is still under rapid development and perhaps its present deﬁciencies will
be overcome. In any event, it shows that the algorithm developers have not yet run out of
ideas.
0
0.2
0.4
0.6
0.8
1
10
-15
10
-10
10
-5
10
0
x / π
p=8
x-Varying
Order
Errors in ErfcLog Filter for Sawtooth Function
Figure 18.15: Errors in ErfcLog-ﬁltered, 100-sine approximations to the piecewise linear or
“sawtooth” function. Thin line: ﬁxed ﬁlter order p = 8. Thick line: optimal, spatially-
varying p.

18.21. RESOLUTION OF SPECTRAL MODELS
425
0.9
0.92
0.94
0.96
0.98
1
10
-5
10
-4
10
-3
10
-2
10
-1
10
0
x / π
100 Fourier terms
Errors in Spatially-Varying ErfcLog Filter: Sawtooth
Figure 18.16: Zoom plot of the errors in ErfcLog-ﬁltered (one hundred term) sine series for
the sawtooth function. The discontinuity of Sw(x) is at x = π (right edge of the graph).
The thin solid curve shows the error when the order p is varied with distance from the dis-
continuity in an optimal way. The thick dashed curve is an upper bound or “envelope” for
the errors, showing (on this log-linear plot) that the error falls exponentially with distance
from the singularity at x = π.
18.21
Resolution of Spectral Models
Filtering and dealiasing raise an obvious question: How small are the features that a spec-
tral model can resolve with a given N (Laprise, 1992, and Lander and Hoskins, 1997)?
The central argument of Lander and Hoskins is that a graph of spectral coefﬁcients
versus degree n can be divided into three regions. (For a Fourier series, n is wavenumber;
for spherical harmonics, n is the subscript of the harmonic Y m
n .) These regions are:
1. “Unresolved scales” < −−−−> “Dealiasing pad”
N < n < 3
2 N
(18.84)
2. “Unbelievable scales” < −−−−> “Discretization-addled” wavenumbers
NP < n < N
(18.85)
3. “Believable scales”
n ≤NP
(18.86)
The “dealiasing pad” or what Lander and Hoskins call simply the “unresolved scales”
arise because the usual weather forecasting model has roughly three-halves as many points
in each of latitude and longitude as the truncation N. This allows the integrals of the

426
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Galerkin method to be evaluated without error and is consistent with the Orszag Two-
Thirds Rule for removing aliasing error. However, these wavenumbers with n > N are not
retained in the truncation.
Lander and Hoskins’ “unbelievable scales” are those wavenumbers which are kept in
the trucation, but are untrustworthy. Unfortunately, spectral coefﬁcients near the trun-
cation N are corrupted by a wide variety of errors. The schematic illustrates three such
error-mechanisms, labelled in italic fonts.
First, if a time-dependent hydrodynamics model is not strongly damped, it tends to
develop accumulate noise near the truncation limit, causing the graph of spectral coefﬁ-
cients to develop an upward curl, as shown by one of the dashed curves in Fig. 18.17.
Second, if the model incorporates a strong artiﬁcial viscosity, then the spectral coefﬁcients
may be damped to unrealistically small amplitude as shown by the downward curling
dashed curve. If damping is chosen correctly, the computed coefﬁcients will curl neither
up nor down, but will be of roughly the correct order of magnitude. However, “ correct
magnitude” is as unsatisfactory to the arithmurgist as to the brain surgeon.
In addition to these sources of error, there is a third coefﬁcient-addling inﬂuence which
is always present, even for one-dimensional boundary value problems: the “discretization
error” ED deﬁned by Deﬁnition 9 in Chapter 2 and illustrated in Tables 3.1 and 3.2. This
error arises because the coefﬁcients that we compute are always inﬂuenced by the coef-
ﬁcients that are not computed. Consequently, all the calculated coefﬁcients have absolute
errors which are the order of magnitude of the truncation error ET , which is the mag-
nitude of the uncomputed coefﬁcients for n > N. Because the low degree coefﬁcients are
large compared to the truncation error, their relative error is small and these spectral coefﬁ-
cients are “believable”. The coefﬁcients near the truncation limit, however, are of the same
magnitude as the discretization error ED, and therefore have such large relative errors as to
be “unbelievable”.
Lander and Hoskins suggest two strategies. One is to ﬁlter the wind and pressure, etc.,
that are input to the physics parameterizations to include only the “believable” scales. This
will increase cost, but reduce noise.
Their second strategy is that the physical parameterizations of chemistry, hydrologic
cycle and so on should be computed only on a coarse grid restricted to these believable
scales. (This explains the notation for the boundary of these wavenumber, NP — “P” for
parameterizations and also “P” for physics.) Instead, it is the usual practice to compute the
chemistry and physics on the entire grid. Although the ozone concentration on such a ﬁne
grid could be in principle be expanded with harmonics up to N = (3/2)N, only coefﬁcients
in the triangular truncation TN are ever calculated. Since the non-hydrodynamic calcula-
tions account for at least half the total running time, one could gain much by restricting
chemistry and physics to the “believable” scales only.
One drawback of Lander and Hoskins’ second strategy is the need to interpolate to and
from the coarse grid [where the parameterizations are evaluated] to the ﬁne grid [used
to compute nonlinear products]. However, the parameterizations are so expensive that it
seems likely that there would be signiﬁcant savings even so. Furthermore, the ﬁne scales
of the ozone, water vapor and so on force the dynamics at “unbelievable” scales; the high
resolution parameterizations may actually be reducing accuracy! However, neither of their
suggestions has been tested in a real code.
One important practical issue is: What is NP , the highest believable wavenumber? Lan-
der and Hoskins discuss ﬁve choices. Their preference is for a length scale rG which is
deﬁned in terms of the “point spread function”. [discrete approximation to the Dirac delta-
function] as the distance from its global maximum to the ﬁrst minimum . This is equivalent

18.21. RESOLUTION OF SPECTRAL MODELS
427
to
NP ≈0.63N
≈(3/2)
2.4 N
(18.87)
This would reduce the total number of points for the non-hydrodynamic parameterizations
by a factor of 5.76 = 2.42.
However, Lander and Hoskins hedge, and suggest that sometimes a larger NP may be
desirable for safety’s sake. The truth is that “believability” is likely to be highly problem-
dependent and model-dependent. Nevertheless, it is only by understanding that there are
three regions in the wavenumber spectrum that we can hope to make rational choices in
model architecture, ﬁlters and so on.
N
(3/2)N
NP
Unresolved
Scales
Unbelievable
Scales
Believable
Scales
Spectral
Blocking
Artificial
Damping
Discretization
Error    ED
Figure 18.17: Schematic of Fourier or spherical harmonics coefﬁcients versus degree N.
The thick solid line shows the exact coefﬁcients for n ≤N; the dotted line shows the exact
coefﬁcients which are neglected when the series is truncated at degree N. The “believable”
coefﬁcients are accurate; the length scales of the corresponding spherical harmonics deﬁne
the “believable scales”. The “unbelievable” scales are corrupted by numerical difﬁculties.
Three villians (labelled in italics) are illustrated by thick dashed curves, which show how
the computed coefﬁcients are distorted by each pathology. The absolute errors for the
discretization error are roughly the same for all coefﬁcients in the truncation (thin jagged
line), but the relative errors are large only for n ≈N.

428
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
18.22
Vector Basis Functions: Vector Spherical Harmonics &
Hough Functions
When solving a system of equations for a vector of unknown ﬁelds, there is no reason
why one cannot use vector basis functions. The eigenmodes of the linearized system will
normally be vectors themselves. If the modes differ drastically — for example, the grav-
ity wave oscillations of the shallow water wave equations have very high frequencies in
comparison to the Rossby modes — than it may be possible to greatly improve numerical
efﬁciency by choosing vector basis functions that mimic the important modes. When we
expand all the unknowns in the shallow water or primitive equations in spherical harmon-
ics, it is not possible to discriminate in any way between the gravity and Rossby modes.
One can discriminate using vector basis functions.
Several alternatives to ordinary (scalar) spherical harmonics have been discussed. Swarz-
trauber (1981, 1993) and Swarztrauber and Kasahara (1985) have described two different
varieties of “vector spherical harmonics”. The basic strategy is to transform the spherical
components to the corresponding Cartesian components (which are always continuous)
and then expand in (scalar) spherical harmonics. It is convenient to label Swarztrauber’s
new basis set the “vector spherical harmonics” even though he takes pain to note that
this term has been previously applied to a different set: the eigenfunctions of the vector
Helmholtz equation. Swarztrauber has written library software (“SPHEREPACK”) to com-
pute his new basis functions and has applied them to Laplace’s tidal equations, which are
the linearized shallow water wave equations.
Shen and Wang(1999) have recently proposed a new vector spherical harmonic/Legendre
algorithm for the primitive equations. The theoretical analysis and numerical experiments
are promising, but their algorithm has not yet been used for meteorological applications.
The second approach, suggested by T. W. Flattery for data analysis but developed for
time-integration by A. Kasahara, is to use the vector eigenfunctions of Laplace’s tidal equa-
tions as the basis set. In three dimensions, separation-of-variables shows that after the ver-
tical dependence has been eliminated, the two-dimensional equations are simply Laplace’s
tidal equations with a different equivalent depth parameter for each vertical mode. Thus,
although the basis set is two-dimensional, these functions of latitude and longitude be-
come the three-dimensional normal modes when multiplied by the proper vertical struc-
ture function.
The motive for this choice of basis set is that these so-called Hough functions are inti-
mately connected with the physics. In particular, to ﬁlter gravity waves, which are “noise”
insofar as the forecast is concerned, one may simply omit the gravity wave Hough modes
from the basis set.
There are alternatives for eliminating the gravity waves; the most famous is the quasi-
geostrophic approximation, which drops terms from the shallow water wave equations
such that the simpliﬁed partial differential equations have only Rossby waves as their free
modes of oscillation. Unfortunately, the errors in quasi-geostrophy (and its generaliza-
tions) are large at low latitudes. Furthermore, deleting terms from the differential equation
is an all-or-nothing approach: the only choice is between models that allow all gravity
modes or none at all.
In contrast, Hough models allow selectivity. There are a few gravity waves with rel-
atively low frequencies which can be retained in a trucation of the Hough basis, but are
always excluded by the quasi-geostrophic approximation.
One obvious difﬁculty is that the Hough functions are the eigenmodes of the linearized
equations, but the dynamics of the global atmosphere is strongly nonlinear. One may well

18.23. RADIAL/VERTICAL COORDINATE: SPECTRAL OR NON-SPECTRAL?
429
ask: Doesn’t the nonlinearity produce such strong mode-mode coupling, such strong dis-
tortions of the normal modes themselves, as to invalidate the physical interpretation of the
Hough modes as the gravitational and Rossby oscillations of the atmosphere?
The answer to this question is: Yes, but not so as to diminish the usefulness of Hough
functions as a basis set. The reason is that because of the great differences between Rossby
and gravity waves, the couplings produced by nonlinearity are primarily between modes
in the same class — Rossby with Rossby, gravity with gravity. What is important for se-
lectively ﬁltering gravity waves is not whether a particular Rossby Hough function closely
resembles a free oscillation as observed in the real atmosphere. Rather, what matters is that
even with nonlinearity, dissipation, and other complications, the Rossby Hough functions
are, to a good approximation, a complete set for expanding the low-frequency, weakly di-
vergent motions that dominate weather and climate and this set is orthogonal to the gravity
Hough functions. The Rossby-to-gravity coupling is weak.
Kasahara (1977, 1978) has clearly demonstrated the feasibility of integrating the hydro-
dynamic equations using Hough functions. It is important to note that one can resolve
a slow ﬂow with roughly one-third the number of degrees of freedom of a conventional
spherical harmonics model since there are two gravity modes for every Rossby Hough
function. However, like Swarztrauber’s equally feasible vector basis set, Kasahara’s Hough
functions have not yet caught on, except for the middle atmosphere model of Callaghan et
al.(1999).
There is a technical reason for this: when the number of vertical levels is large, the eigen-
values for the higher vertical modes (what meteorologists call the “equivalent depths” of
the modes) become very small. This disrupts the clear separation between Rossby and
gravity waves which exists for the lowest few vertical modes and is the motive for choos-
ing a Hough basis in the ﬁrst place.
18.23
Radial/Vertical Coordinate: Spectral or Non-Spectral?
18.23.1
Basis for Axial Coordinate in Cylindrical Coordinates
For cylindrical coordinates, the z-axis is not cyclic, so Chebyshev polynomials (if the cylin-
der is bounded in z) or rational Chebyshev functions (if the cylinder is unbounded) are
best. Thus, a cylindrical basis is usually double Chebyshev (in r and z) and Fourier in the
angle θ.
18.23.2
Axial Basis in Toroidal Coordinates
Toroidal coordinates are similar to cylindrical except that the vertical axis is closed upon
itself to form a circle instead of an inﬁnite line. Because this closure-into-a-circle forces the
“toroidal angle” λ to be cyclic, one should always use an ordinary Fourier series in this
coordinate. Thus, a toroidal basis is Fourier in θ, Fourier in λ, and Chebyshev in the third
coordinate, which is radial distance from the center of the torus.
18.23.3
Vertical/Radial Basis in Spherical Coordinates
Although spherical harmonics have been extremely popular in atmospheric science, such
models almost invariably use ﬁnite difference approximations in the vertical. It is not that
the idea of a vertical series has been tried and found wanting, but rather it has not been
tried. Francis(1972) and Hoskins(1973) explored Laguerre functions (for an atmosphere of

430
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
semi-inﬁnite depth), but found that explicit time step limits would be very severe. Machen-
hauer and Daley(1972, 1974) and Eliassen and Machenauer (1974) experimented with Leg-
endre polynomials in depth, but had to use ad hoc modiﬁcations; this work was never
published in a journal.
Kasahara and Puri(1981) and Mizzi, Tribbia and Curry(1995) tried the eigenfuctions
of the so-called “vertical structure equation” as the basis functions in height. Mizzi et al.
found that the rate of convergence was lamentably slow compared to the expansion of
test solutions in Chebyshev or Legendre polynomials. This is hardly surprising: using
normal modes for a problem with numerical boundary conditions is akin to using a Fourier
basis for a non-periodic problem and gives the same slow, algebraic rate of convergence.
(Indeed, for idealized temperature proﬁles, the normal modes are sine functions.)
And there the matter has rested except for Shen and Wang(1999). In contrast, Mar-
cus and Tuckerman (1987a, b), Mamun and Tuckerman (1995) and Glatzmaier(1984, 1988)
have computed the ﬂows in a rotating spherical annulus using Chebyshev polynomials in
radius. Glatzmaier’s algorithm was so successful that it has been used for studies of stellar
dynamos, mantle convection, and the atmosphere of a gas giant planet totalling at least
thirty-ﬁve articles and book chapters. Because Glatzmaier’s algorithm has been used so
widely, it is worth brieﬂy describing here.
18.24
Stellar Convection in a Spherical Annulus: Glatzmaier
(1984)
This model simulates stellar convection by solving the anelastic equations of motion for a
spherical shell heated from below. The inner wall is at 0.53 of the solar radius and the outer
wall at 0.93 of the solar radius so that there are seven scale heights within the shell.
The latitude-longitude basis was spherical harmonics in a triangular T31 truncation.
The radial basis was Chebyshev polynomials up to and including T16(r).
The time-integration scheme was semi-implicit. The explicit Adams-Bashforth scheme
was applied to all terms except diffusion, which was treated implicitly with the Crank-
Nicholson scheme. Without magnetic forces, the cost was about 1.0 sec per timestep on a
CRAY-1.
The implicit Crank-Nicholson scheme does not require splitting because the spheri-
cal harmonics are eigenfunctions of the horizontal part of the diffusion operator. Because of
this, it is only necessary to solve a one-dimensional boundary value problem in radius only
to implement the Crank-Nicholson method. Ordinarily, this would require storing the
LU decomposition of O(L2) Chebyshev collocation matrices, one for each horizontal basis
function. However, the eigenvalue of the diffusion equation is - n(n + 1), independent of
the zonal wavenumber m. Consequently, Glatzmaier is only obliged to perform (N +1) LU
decompositions in a preprocessing stage and then store these thirty-two 17 x 17 matrices
throughout the run. The cost of the backsolves for the Crank-Nicholson treatment of diffu-
sion is O(L2N 2) whereas the number of gridpoints is only O(L2N), so we have lost a factor
of N relative to a ﬁnite difference method. This will be only a small part of the overall work
– this is a very complicated set of equations because of the magnetic and Coriolis forces –
unless N is a good deal larger than 17.
The smallness of N is a tribute to the accuracy of pseudospectral methods. The density
varies by a factor of exp(−7) over the shell,4 and there are viscous boundary layers at both
the top and the bottom, but seventeen grid points in radius sufﬁce. The model does not use
a variable grid because the built-in quadratic stretching of the Chebyshev grid is sufﬁcient.
4This is the physical meaning of the statement that the shell is “seven scale heights” thick.

18.25. NON-TENSOR GRIDS: ICOSAHEDRAL, ETC.
431
Glatzmaier reports that a test calculation with N = 65 differed from the results for N = 17
by only 2 % after 300 time steps.
Although meteorological spherical harmonics codes are almost always dealiased, the
stellar convection model is aliased; no 2/3’s rule here! Glatzmaier states the position of that
large group of modellers who ignore aliasing: “An unaliased method, which would require
signiﬁcantly more computer time and memory, would ensure that the error due to the
truncation of the harmonics is normal [i. e., orthogonal ] to the retained set of harmonics.
However, a truncation error would still exist... If the two methods [aliased and unaliased]
produce solutions that are not negligibly different, both solutions are bad. Only when
enough harmonics are retained so that both methods produce negligibly different solutions
are the solutions good”.
The incompressibility constraint is enforced by decomposing the three dimensional ve-
locity into
⃗v = ⃗∇× ⃗∇× (W ˆr) + ⃗∇× (Zˆr)
(18.88)
where ˆr is a unit vector in the radial direction and (⃗∇×) denotes the curl. Through elemen-
tary vector identities, one may verify that the divergence of (18.88) is zero. The functions
W and Z are scalar, and generate the “poloidal” and “toroidal” components of the ﬂow.
The incompressibility has reduced the number of scalar functions needed to specify the
ﬂow from three to two, and similarly for the magnetic ﬁeld, which is also nondivergent
(unless the Sun has magnetic monopoles!) This poloidal/toroidal decomposition is the
three-dimensional, spherical analogue of the usual vorticity streamfunction formulation,
but the pressure is not eliminated and remains one of the six unknowns: W, Z, the two
similar magnetic functions, p, and the entropy s.
The continued presence of the pressure as an unknown creates a problem. At the rigid
boundaries, the constraints of no normal ﬂow and no stress imply four conditions on W,
which satisﬁes only a second order equation in r. However, the pressure p also satisﬁes a
second order equation, and there are no intrinsic boundary conditions on p. Glatzmaier
therefore treats part of the radial diffusion for W explicitly by including the terms that
depend on p. He then demands that p have whatever values at the boundary are necessary
to make the explicit terms for W equal to zero so that W remains consistent with the four
boundary conditions upon it.
This sounds awkward when expressed in words; it is not a lot of laughs for the pro-
grammer either. The pressure is a perpetual nuisance in models which lack a prognostic
equation for p. Pressure gradients appear in the governing equation, just as gradients of
the velocity do, but we have physical boundary conditions only on ⃗v. The pressure is a
passive quantity which varies so that the incompressibility constraint is always satisﬁed,
and we have to live with this awkwardness.
18.25
Non-Tensor Grids: Icosahedral Grids and the Radio-
laria
Spherical harmonics, in which every part of the globe directly inﬂuences every other part,
have always alarmed proponents of parallel computing because of the need to share lots
of grid point values between different processors of a massively parallel machine. This has
not become a difﬁculty as early as expected because even at T639 resolution, preliminary
tests have shown that Legendre transforms cost only 19% of the overall CPU time using 48
vector processors. (The model at T213 resolution runs quite efﬁciently on 500 processors of
a Cray T3E.) Nevertheless, there has been a search for ﬁnite difference and ﬁnite element

432
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
alternatives to spherical harmonics. Unfortunately, the globe imposes special difﬁculties
even on low-order methods: there is no free lunch on the sphere.
One obvious alternative to pseudospectral methods is to simply lay down an evenly
spaced grid or triangulation of the sphere and use ﬁnite differences or ﬁnite elements.
Unfortunately, an evenly spaced grid and a triangulation composed of identical triangles
are both impossible except at very low resolution.
The choice of an evenly spaced latitude-longitude grid creates a severe pole problem
for all non-spherical harmonic schemes, both low order differences and high order spectral
methods, unless (i) the time-stepping is fully implicit, which is prohibitively expensive or
(ii) strong ﬁltering is applied near the poles.
The other grid option is to abandon a tensor grid and instead simply spread grid points
as uniformly as possible over the sphere. As reviewed by Saff & Kuijlaars(1997), this turns
out to be very difﬁcult.
The problem was identiﬁed by Leonard Euler in the middle of the eighteenth century,
but it ﬁrst became important in science when marine biologists on H. M. S. Challenger
dredged up samples of microscopic ocean life a century ago. Fig. 18.18 shows the “radio-
laria”, Aulonia hexagona. At ﬁrst glance, the siliceous skeleton appears composed of an even
net of hexagons. One might imagine that one could circumscribe the skeleton with a globe
and subdivide each hexagon into six equilateral triangles to obtain a uniform triangulation
of the sphere, or compute ﬁnite differences directly on the hexagonal grid. Unfortunately,
the appearance of a uniform net of hexagons is an illusion. W. D’Arcy Thompson (1917)
shows that every such hexagonal array must have 12 pentagons inserted in the lattice.
The vertices of the ﬁve Platonic solids, in contrast, are uniformly spaced. However,
the icosahedron, with twelve vertices and twenty equilateral triangles, is the Platonic solid
with the largest number of sides. One can hardly hope to model the weather well with just
twelve grid points!
The best one can hope for is to create an almost uniform triangulation. Baumgardner and
Frederickson (1985) show how one can use the icosahedron as a starting point for covering
the globe with little triangles. Each of the twenty sections is bounded by a triangle of
identical size, but the triangles within each icosahedral face are of different sizes.
Table 18.8: Gridpoint Methods on the Sphere Bibliography
References
Comments
Taylor (1995)
proves spherical harmonics interpolation problem
is insoluble;
expansion must be computed
by integration with extra points
Sloan(1995)
interpolation and “hyperinterpolation” on sphere
Baumgardner&Frederickson(1985)
Icosahedral/triangular grid
Heikes&Randall(1995a,b)
Twisted icosahedral grid
Ronchi&Iacono
New ﬁnite differences (“cubed sphere”)
& Paolucci(1997)
compared with spherical harmonic code
Ranˇci´c&Purser
Expanded cube grid: comparisons of
Mesinger(1996)
gnomonic and conformal coordinates
Purser&Rancic(1997)
Finite difference grid based on conformal octagon
Swarztrauber&Williamson
icosahedral grid; 3D Cartesian method
&Drake(1997)
projected onto the surface of a sphere
Thuburn(1997)
icosahedral-hexahedral ﬁnite difference grid
Saff & Kuijlaars(1997)
Popular review of the mathematical difﬁculties
in computing nearly-uniform grids on the sphere
Stuhne&Peltier(1999)
icosahedral grid

18.26. ROBERT BASIS FOR THE SPHERE
433
Figure 18.18: The skeleton of aulonia hexagona. After Growth and Form by W. D’Arcy Thomp-
son (1917). Although the lattice appears to be composed entirely of hexagons, Thompson
showed that there must be at least a dozen pentagons, too. It is impossible to embed the
sphere in a lattice of identical polygons when the number of polygons is greater than 20.
These nearly-uniform grids work well — as evident in the picture of the radiolaria, the
degree of non-uniformity is so small as to be almost invisible when the number of grid
points is large. The rub is that the grid nevertheless is non-uniform and this leaves two
problems: (i) programming is much more difﬁcult than for a uniform grid and (ii) the ac-
curacy of ﬁnite differences deteriorates because the grid is not entirely regular. In addition,
recent models have been bedeviled by stability problems and spurious excitation of lon-
gitudinal wavenumber ﬁve disturbances. Heikes and Randall(1995a,b) used a “twisted”
icosahedral grid which respects the parity symmetry with respect to the equator, but at
the expense of more complication. Algorithms that replace the icosahedron with another
Platonic solid, such as a cube or octagon, have been tried, too (Table 18.8).
All of these variants work, but all are messy and most have required some tweaking.
These faults of almost-uniform grid methods are some consolation for the intricacies of
spherical harmonics.
18.26
Spectral Alternatives to Spherical Harmonics, I: Robert
Functions
The Fast Fourier Transform (FFT) converts grid point values of a function to its Fourier
coefﬁcients in only O(N log2 N) operations. Since the spherical harmonics are an ordinary
Fourier series in longitude, we can apply the FFT in λ, but not to the Gegenbauer polyno-
mials in θ. This inspired serious efforts in the late 60’s and early 70’s to ﬁnd substitutes for
the latitudinal basis functions.

434
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Andr´e Robert suggested the basis functions
sin|m|(θ) cos(nθ)
[“modiﬁed Robert functions”]
(18.89)
These basis functions reproduce the polar behavior of the spherical harmonics. The high
order zeros for large wavenumber m eliminate the “pole problem”; one can integrate using
(18.89) with a fairly large time step and no special tricks. Merilees (1973a) pointed out
the fatal ﬂaw of the “Robert” functions: they are horribly ill-conditioned. The problem is
that for large m, the sin|m|(θ) factor is zero except in a narrow boundary layer around the
equator. Within this layer
cos(nθ) ≈1 −n2θ2
2
≈1
if |θ| ≪1
(18.90)
so that the lowest few Robert functions are graphically indistinguishable for large m. This
translates into large round-off errors when a function is expanded in terms of these (al-
most) linearly dependent functions. The result is that the Robert functions have never
been employed for large-scale numerical models.
18.27
Spectral Alternatives to Spherical Harmonics, II: Parity-
Modiﬁed Fourier Series
Merilees (1973b) and Orszag (1974) have discussed parity-modiﬁed Fourier series in which
the latitudinal dependence of the zonal wavenumber m component of a scalar function is
expanded in the form
fm(θ) = sins(θ)
∞
X
n=0
an cos(nθ)
(18.91)
where
s ≡
(
0
m even
1
n
odd
(18.92)
The pseudospectral grid points are
θi ≡π (2i −1)
2N
i = 1, . . . , N,
(18.93)
that is, an evenly spaced grid with all points on the interior of θ ∈[0, π]. This implies
that we may freely divide out sins(θ) and then apply the FFT (a Fast Cosine Transform,
actually). The coordinate singularities of the differential operators at θ = 0 and π cause no
major problems because we do not need to evaluate any quantities at the poles.
One obvious concern is that the spherical harmonics (and all well-behaved functions on
the sphere) have m-th order zeros at the poles whereas the modiﬁed Fourier basis functions
in (18.91) have at most a ﬁrst order root. However, to quote Orszag (1974): “The detailed
behavior expressed by the sin|m|(θ) factor is usually of little direct interest in a numerical
simulation . . . The above argument suggests that surface harmonic-series contain much
information on the behavior of functions near the poles that is not of primary interest.”
Boyd (1978b) offers an amusing illustration of Orszag’s point by applying the pseudospec-
tral method with 60 basis functions to calculate the eigenvalues of the two-dimensional

18.28. PROJECTIVE FILTERING FOR LATITUDINAL FOURIER SERIES
435
Table 18.9: Spectral Alternatives to Spherical Harmonics: Bibliography
Note: “Double Fourier” denotes a Fourier basis in both latitude and longitude.
References
Comments
Robert (1966)
“Robert” function basis, but these are very ill-conditioned
Merilees (1973a)
Ill-conditioning of “Robert” basis sinm(θ) cos(nθ)
Merilees (1974)
Double Fourier series with high latitude ﬁltering
Orszag (1974)
Comparison of spherical harmonics with double Fourier series
Boyd (1978b)
Comparison of Chebyshev, Fourier & Associated Legendre
for boundary value and eigenvalue problems
Yee(1981)
Poisson equation on sphere; double Fourier basis
Spotz&Taylor
high-latitude-ﬁltered double Fourier series
& Swarztrauber(1998)
Shen(1999)
double Fourier basis
Cheong(2000, 2001)
double Fourier series
Laplacian, i. e. the spherical harmonics themselves, for m = 49. Although the 60 term ap-
proximation may have at most 61 zeros (counting multiplicity and the two roots of sin(θ))
and the spherical harmonics have 98 + (n −m) roots, the lowest twenty eigenvalues are
calculated to within an accuracy of 1 part in 70 million.
For so-called “jury” problems, that is to say, for boundary value and eigenvalue prob-
lems, Boyd (1978b) argues that the parity-modiﬁed Fourier series is the best basis set. It is
much easier to program than spherical harmonics and the accuracy does not seem poorer.
For time-dependent or “marching” problems, however, the “pole” problem returns in
full force. Orszag (1974) has shown that the time-step limits for realistic calculations will
be quite severe. He suggested several remedies. First, one may apply a polar ﬁltering ev-
ery ten or twenty time steps. Second, one may split the convective terms into (i) a surface
harmonic of degree 2 that gives the ﬂow over the poles and (ii) the rest of the convective
terms and then treat (i) implicitly; the bulk of the terms, i. e. (ii), may be treated explic-
itly without instability because (ii) does not involve ﬂow over the pole. Third, treating
viscous terms implicitly — almost always necessary with spectral and pseudospectral al-
gorithms — tends to stabilize the convective terms, too, at least for a Backwards-Euler or
other implicitly-dissipative scheme.
Even so, longitude/latitude double Fourier series have been little used for time-dependent
calculations in the quarter-century after Orszag’s article. Part of the reason is inertia; as ex-
plained earlier, the relatively slow cost of associated Legendre transforms has not been
a major liability for spectral models even at the highest resolution employed in weather
forecasting at the dawn of the third millenium, T639.
In recent years, however, double Fourier series have made a comeback in the articles
of Shen(1999), Cheong(2000, 2001) and Spotz, Taylor and Swarztrauber(1998). Spotz et al.,
for example, revived an idea of Merilees(1974) with an improved ﬁlter, and showed that
latitudinal Fourier series can be both fast and accurate when the polar ﬁltering is strong
enough.
18.28
Grid-to-Spherical-Harmonics-to-Grid Projective Filter
for Time-Dependent Latitudinal Fourier Series
The ultimate polar ﬁlter is to transform grid point values on a tensor product latitude/longitude
grid to a triangular truncation of spherical harmonics and then sum the spectral series to
obtain a different set of grid point values. The output of the fore-and-back transform will

436
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
inherit the equiareal resolution property of spherical harmonics. The pole problem is com-
pletely suppressed.
This combination of transforms has been described as both a “spherical ﬁlter” and a
“projection” in the literature; we shall call it a “projective ﬁlter”. The reason for the termi-
nological confusion is that the projective ﬁlter is different from other ﬁlters in that its pur-
pose is not to provide artiﬁcial viscosity or suppress small-scale noise and aliasing instabil-
ity. Rather, the grid-to-spectral half of the projective ﬁlter is a non-dissipative transform. It
is, in the usual parlance of functional analysis, a “projection” of the function f(λ, θ) onto the
subspace spanned by the spherical harmonics. The spectral-to-grid half of the transform
is merely a summation of the truncated series. The grid-to-grid transform is more than a
projection (because it is a summation, too), but in some sense less than a ﬁlter (because the
only ﬁltering is a truncation).
The weakness of a latitude/longitude Fourier method is that projective ﬁltering has a
cost which is the same order of magnitude as an Associated Legendre transform. However,
because only the unknowns themselves must be projectively ﬁltered — no derivatives need
be transformed — double Fourier algorithms have the potential of extending the lifetime
of global spectral methods on the sphere for at least another decade.
The method which Spotz and Swarztrauber (2000) label both “naive” and “standard”
is to compute both halves of the projective ﬁlter through separate Parity Matrix Multipli-
cation Transforms (PMMT) in latitude. (All transformations in longitude are performed
by the Fast Fourier Transform (FFT), which convert grid point values into functions fm(θ)
which describe how the coefﬁcient of cos(mλ) or sin(mλ) varies with colatitude.) The ad-
jective “Parity” means that grid point values of f(θ) are ﬁrst split into components that
are symmetric and antisymmetric with respect to the equator θ = π/2 through f S ≡
{ f(θ) + f(π −θ) } and f A ≡{ f(θ) −f(π −θ) }. Each component is then projectively
ﬁltered separately; the even and odd parity ﬁltrates are recombined by adding their grid
point values in the northern hemisphere and subtracting the ﬁltered values of f A from the
ﬁltrate of f S in the southern hemisphere.
Yarvin and Rokhlin(1998) noted that one could reduce the cost by 25 % by combining
the forward and backward transform matrices into a single N × N matrix for small m
while performing the forward and backward transforms separately for large m. (Note
that the forward and backward transform matrices are rectangular with smaller dimension
(N −m); for the extreme of m = N, the transform matrices are only vectors; two vector-
vector multiplies are obviously cheaper than an N × N matrix-vector multiply.)
Swarztrauber and Spotz (2000) developed the “Weighted Orthogonal Complement”
projective ﬁlter which has only half the cost of the “naive”/“standard” method and only
two-thirds the expense of Yarvin and Rokhlin’s “direct” method. Better yet, they prove
that the WOC matrices can be written as subsets of a couple of “master” matrices, reduc-
ing storage for transform/projection matrices from O(N 3) to only O(N 2).
For the shallow water wave equations, nine Legendre transforms are needed at each
time step with a spherical harmonic basis. With a double Fourier expansion and the WOC
projective ﬁlter, the transform cost is reduced to the equivalent of only three Legendre
transforms.
Jakob-Chien and Alpert(1997) developed a projective ﬁlter based on Fast Multipole
Method (FMM) ideas; this was improved by Yarvin and Rokhlin(1998). As with other
multipole transforms, the FFM projective ﬁlter is faster than the WOC or any MMT-type
method in the limit N →∞, but the cross-over point where the FMM scheme is faster is
likely to be at very large N.
Spotz and Swarztrauber(2000) carefully compare all these projective ﬁlters for various
N, both with and without the application of the Two-Thirds Rule. (Dealiasing truncation
reduces the advantages of the newer MMT schemes relative to the “naive” method.) They

18.29. SPECTRAL ELEMENTS ON THE SPHERE
437
Table 18.10: Projective Filters Bibliography
References
Comments
Jakob-Chien&Alpert(1997)
Grid-to-spherical-harmonics-to-grid
Yarvin&Rokhlin(1998)
projective ﬁlter for longitude/latitude
time-dependent double Fourier series
Swarztrauber&Spotz(2000)
“Weighted Orthogonal Complement” algorithm reduces
Spotz&Swarztrauber(2000)
storage by O(N); faster than alternatives
because algorithm mostly stays in the on-chip cache
Cheong(2001)
Approximate projective ﬁlter (hyperviscosity)
which combines damping with projection
ﬁnd that their WOC algorithm is faster than the “direct” and “standard” PMMT and the
FMM at least up to N = 200. The WOC method is moderately faster than formal operation
counts would suggest; the very low storage of the WOC leads to more efﬁcient utilization
of the on-chip cache memory of current machines. The WOC method also parallelizes very
well.
Cheong(2001) employs an alternative: Polar ﬁltering by a combination of fourth order
and sixth order hyperviscosity. Recall that Y m
n is an eigenfunction of the two-dimensional
Laplace operator on the surface of the sphere with the eigenvalue λn = −n(n+1). It follows
that a dissipation which is proportional to a high power of the Laplacian can be tuned to
strongly damp all spherical harmonics with n > N while having only a slight effect on
harmonics retained within a triangular truncation. The Fourier-Galerkin discretization of
the Laplace operator is a tridiagonal matrix, so the ﬁlter is very fast.
In contrast to the Spotz-Swarztrauber and FMM methods, Cheong’s hyperviscosity is
not an exact projection onto spherical harmonics. Since most time-dependent models re-
quire a little scale-dependent dissipation for noise-suppression anyway, an approximate
projective ﬁlter is satisfactory. However, there has not been a detailed comparison of the
relative speed and accuracy of exact projective ﬁlters versus approximate ﬁlters that damp
and project simultaneously.
Swarztrauber and Spotz (2000) note, “The goal of an O(N 2 log N) harmonic spectral
method remains elusive; however, the “projection” method provides a new avenue of re-
search. Perhaps the development of a fast projection [projective ﬁlter] will prove to be
easier than the development of a fast harmonic transform.” Sufﬁcient progress has al-
ready been made to encourage the development of double Fourier methods on the sphere.
However, as of 2000, latitude/longitude Fourier series have not yet been applied to an
operational forecasting or climate model.
18.29
Spectral Elements on the Sphere
Another alternative to global spectral methods is domain decomposition. A moderately
high order Legendre series is used in each subdomain, and then the pieces are stitched
together as in ﬁnite elements to obtain a global approximation. The great virtue of spec-
tral elements is that each subdomain can be assigned to a different processor of a multi-
processor machine. The articles listed in Table 18.11 show that the algorithm parallelizes
very well, and seems promising for both atmospheric and oceanic modelling.

438
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Table 18.11: Spectral Elements on the Sphere Bibliography
References
Comments
Ma(1992,1993a,b)
Ocean basin models
Iskandarani&Haidvogel
global ocean model
&Boyd(1995)
Levin&Iskandarani
ocean model
&Haidvogel(1997)
Taylor&Tribbia &
atmospheric model;
Iskandarani(1997)
shallow water equations
Curchitser&Iskandarani
Ocean modelling on a variety of
& Haidvogel(1998),
massively parallel computers
Haidvogel&Curchitser
&Iskandarani &Hughes
&Taylor(1997)
18.30
Spherical Harmonics Besieged
Although spherical harmonics are the discretization of choice for the ECMWF forecasting
model, the NCAR Community Climate model, and Glatzmaier’s stellar convection and
mantle ﬂow simulations at the turn of the milllenium, this spectral basis is under attack on
two fronts. The ﬁrst assault is from massively parallel (MP) computing. The worry is that
global basis sets of any kind, and spherical harmonics with their slow Legendre transforms
in particular, will become lamentably inefﬁcient when the number of processors is huge.
As a result, a number of national weather services have switched to ﬁnite element or other
local, low order algorithms. Some American research groups, such as those at NASA,
employ ﬁnite difference codes almost exclusively.
Table 18.12: Comparisons of Finite Difference with Spectral Models: Bibliography
References
Comments
Doron&Hollingsworth
Weather forecasting
&Hoskins&Simmons(1974)
Hoskins&Simmons(1975)
Comparison of spherical harmonic/differences in z
with 3D ﬁnite difference weather forecasting code
Simmons&Hoskins(1975)
Spectral vs. ﬁnite-differences: growing baroclinic wave
Merilees et al.(1977)
FD with polar ﬁltering compared with pseudospectral
Browning&Hack
ﬁnite differences of 2d, 4th, and 6th order
&Swarztrauber(1988)
compared with spherical harmonics
Held&Suarez (1994)
2d/4th ﬁnite difference; climate model
Gustafsson&McDonald(1996)
HIRLAM grid point vs. spectral semi-Lagrangian;
models are similar in accuracy and efﬁciency
Fornberg&Merrill(1997)
Double Fourier vs. spherical harmonics vs. 2d & 4th
order differences for a very smooth solution
Spotz&Taylor
Comparisons of compact 4th order differences with
& Swarztrauber(1998)
spherical harmonics and ﬁltered double Fourier
So far, however, the MP/low order assault has not yet carried the fort although some
of the outworks have fallen. In the ﬁrst place, ingenious coding and the inherent efﬁciency
of matrix multiplication has made spectral codes run fast even on machines with moderate
parallelism (forty-eight processors). (See, for example, Drake et al.(1995) and other articles
in a special issue of Parallel Computing, vol. 21, number 10.) Because the architecture of
twenty-ﬁrst century machines is still in a state of ﬂux, it is impossible to say whether the

18.31. ELLIPTIC AND ELLIPTIC CYLINDER COORDINATES
439
spherical harmonics are doomed or whether ingenuity will continue to make them com-
petitive. Second, the new ﬁnite order methods on the sphere have a shorter history than
spherical harmonics, and consequently many schemes are still nagged by stability prob-
lems and also by their low accuracy for smooth, large scale structures that are much better
resolved by spectral codes.
Most of the studies in Table 18.12 which have compared ﬁnite difference and spectral
codes have found the latter were better. However, Held and Suarez(1994) have claimed
that a low order difference model is just as accurate and runs faster; Gustafsson and Mc-
Donald(1996) report a tie. The meteorological community is applying more sophisticated
benchmark tests including both smooth and discontinuous solutions, so these controver-
sies will eventually be resolved. In the meantime, spherical harmonics models soldier on.
The second assault is the replacement of spherical harmonics by an alternative high
order method. Spectral elements, which allow the work to be split among many processors
without sacriﬁcing high accuracy, have great promise (Table 18.11. However, only two
groups, one each in meteorology and oceanography, are developing such models. Two-
dimensional Fourier series are very promising, too (Spotz, Taylor and Swarztrauber, 1998,
and Fornberg and Merrill, 1997, Shen, 1999, and Cheong, 2000). However, work to date
has been conﬁned to the shallow water wave equations — two-dimensional, no clouds, no
chemistry. It seems likely that one or both of these alternatives will someday be used for
operational forecasting, but when is very murky.
The third assault is from conservative, shock-resolving van Leer/Roe schemes, which
have become very popular in aerodynamics. The Lin and Rood algorithm (1996) has gained
a wide following. However, experience with such low-order-but-conservative schemes is
still limited.
The only conclusion we can make at the turn of the twenty-ﬁrst century is: the siege
continues.
18.31
Elliptic and Elliptic Cylinder Coordinates
Two-dimensional elliptic coordinates (µ, η) are deﬁned by
x = cosh(µ) cos(η)
&
y = −sinh(µ) sin(η)
(18.94)
where x and y are the usual Cartesian coordinates in the plane. The reason for the name
“elliptic” is that the surfaces of constant µ are all ellipses with foci at x = ±1 along the
x-axis as illustrated in Fig. 2-16 of Chapter 2. At large distances from these foci, the ellipses
degenerate into circles and elliptical coordinates become ordinary polar coordinates. In
this limit, µ ≈log(r) where r is the polar radius and η ≈θ, the polar angle.
Elliptic cylinder coordinates add a vertical coordinate z which is perpendicular to the
x-y plane. These three-dimensional coordinates generalize elliptic coordinates in the same
way that cylindrical coordinates extend polar coordinates to three dimensions. Since the
z-axis is straight, one should use either Chebyshev polynomials or rational Chebyshev
functions for z, just as for cylindrical coordinates.
Because the quasi-angular coordinate η is cyclic, all functions are periodic in η, which
implies a Fourier basis in η. However, the coordinate singularity implies that µ-dependent
Fourier coefﬁcients have deﬁnite parity, just as for spherical and polar coordinates. How-
ever, there are intriguing differences because the singular coordinate µ = 0 is a singular
line (the whole interval x ∈[−1, 1]) rather than a single point.

440
CHAPTER 18. SPHERICAL & CYLINDRICAL GEOMETRY
Theorem 37 (ELLIPTICAL COORDINATES: PARITY in QUASI-RADIAL COORD.)
If F(µ, η) is an analytic scalar function which is expanded as
F(µ, η) =
∞
X
m=0
fm(µ) cos(mη) + gm(µ) sin(mη)
(18.95)
then continuity of F(µ, η) and all its derivatives at µ = 0 implies:
(i) fm(µ) is symmetric with respect to µ = 0 for all m
(ii) gm(µ) is antisymmetric for all m
Thus, one should expand the coefﬁcients of cos(mη) as even Chebyshev polynomials in µ while
the sine terms should be represented as a sum of odd polynomials only.
PROOF: All functions in two dimensions can be approximated to arbitrary accuracy as
polynomials in the Cartesian coordinates x and y. This in turn implies that any well-
behaved function can be written as a sum of the powers
xjyk = cosj(η) sink(η) coshj(µ) sinhk(µ)
(18.96)
The parity of xjyk with respect to both η and µ is controlled entirely by k. If k is even,
then sink(η) and sinhk(µ) are both symmetric functions; if k is odd, then (18.96) is also odd
in both elliptic coordinates. Now a function which is symmetric in η may be expanded as
a cosine series in η. The fact that even parity in η ←→even parity in µ implies that all
the cosine coefﬁcients must be symmetric in µ, which is proposition (i). Similar reasoning
implies (ii).
One could alternatively prove the theorem by showing that it is necessary for continuity
of F(µ, η) and all its derivative across the coordinate singularity at µ = 0. (By singularity,
we mean that differential equations in elliptical coordinates have coefﬁcients that are sin-
gular at µ = 0; the solution is analytic on that line segment.)
Boyd and Ma(1990) and Mittal and Balachandar(1996) are ﬂuid mechanics applications
of spectral methods in elliptic coordinates, Fourier in η and Chebyshev polynomials in µ.
18.32
Summary
The end-of-the-century state of the art is a mixture of the known and unknown. The known
includes: coping with coordinate singularities and implementing stable, fast algorithms in
spherical, cylindrical or polar coordinates and in some related coordinate systems; these
methods run well on coarse-grained parallel computers with sixteen or fewer processors.
One unknown is: Can the Legendre transform be accelerated to keep spherical harmon-
ics or One-Sided Jacobi polynomials competitive at very large N? Another unknown is:
Can spherical harmonics schemes and related algorithms be efﬁciently adapted to massively-
parallel machines? Will spherical harmonics be replaced by latitude-and-longitude Fourier
series or spectral elements? Will spectral methods of all kinds be routed by low order ﬁnite
difference or ﬁnite element methods for weather forecasting and climate modelling?
In the areas of this chapter, the Age of Exploration is still not over.

18.32. SUMMARY
441
Table 18.13: Reviews, Books, and Model Descriptions
References
Comments
Bourke&McAvaney
Comprehensive review, describing spherical harmonics code which is the
&Puri&Thurling(1977)
basis for ECMWF forecast and NCAR climate models
Haltiner&Williams(1980)
one chapter on spherical harmonic methods
Sela (1980, 1995)
Reviews of National Meteorological Center (USA) forecast model
Daley(1981)
Review concentrating on normal mode initialization
for weather prediction models on sphere
Gordon&Stern(1982)
Description of GFDL global circulation model
Kanamitsu et al.(1983)
Description of the operational model
of the Japanese Meteorological Agency
Boer et al.(1984)
Review of Canadian Climate Centre model
Jarraud &Baede (1985)
lengthy review of atmospheric codes
Daley(1991)
Monograph about data analysis, initialization and
other issues for weather prediction
Hogan&Rosmond(1991)
U. S. Navy global operational spectral code
Jakob-Chien &
seven benchmark problems for shallow water eqs.;
&Hack&Williamson(1995)
fronts, waves, Gibbs’ wiggles

Chapter 19
Special Tricks
“If it works once, it’s a trick. If it works twice, it’s a method. If it works three times, it’s a
law.”
— Source Unknown
“Card tricks are as important in numerical analysis as in stage magic.”
— J. P. Boyd
19.1
Introduction
In this chapter, we give brief, self-contained descriptions of a number of ideas that are use-
ful even if they are applicable only under special circumstances. These special tricks can be
safely skipped by the reader who is interested only in the major themes of spectral meth-
ods. Nonetheless, the assertion that “numerical analysis is as much an art as a science” has
become a proverb. Much of the reason is precisely because special technques are the best
way of solving certain exotic problems; card tricks, if we may so dub the ideas illustrated
in this chapter, are as important in computation as in conjuration.
Besides the special algorithms collected in this chapter, we have discussed a number of
useful tricks elsewhere including the following.
First, one can use nonlinear degrees-of-freedom, such as width or shape parameters,
in solving differential equations. Recall that when the numerical solution is approximated
by a series, uN(x) is a linear function of the unknown series coefﬁcients, a0, . . . , aN. But
it need not always be so. Nonlinear unknowns were used with great success in the H+
2
ion (Chapt. 3, Sec. 7) and the Korteweg-deVries soliton (Appendix G of the ﬁrst edition
of this book). (An especially good candidate as a nonlinear degree-of-freedom is a width
parameter that matches the scale of the basis functions to the width of the solution.)
Second, the standard methods of Chapt. 17 for solving problems on an inﬁnite interval
will fail unless the oscillations in u(x) decay exponentially as |x| →∞. (This condition
may be met either because u(x) itself decays exponentially, with or without oscillations,
or because the oscillations rapidly decay even though u(x) asymptotes to a constant or
its mean value decreases algebraically with |x|.) If u(x) oscillates with slowly decaying
amplitude as |x| →∞, then all standard methods fail because the rational Chebyshev
442

19.2. SIDEBAND TRUNCATION
443
functions (or whatever) are being asked to faithfully mimic an inﬁnite number of crests
and troughs. Chapt. 17, Sec. 13, shows that one may solve this problem, at least for the
Bessel functions Jn(x), by computing two simultaneous series: one for the amplitude and
one for the phase of the oscillation.
The Bessel double expansion is a particular case of a very general strategy: modifying
a standard basis set by using special functions that match the pathological behavior of the
solution. Other examples are described in Secs. 5, 6, and 7 below.
Third, when the solution is singular or nearly singular on the interior of an interval, one
can detour around the branch point by integrating on an arc in the complex plane. This de-
vice, very useful for computing weakly unstable eigenvalues in hydrodynamic instability
theory, is described in Chapt. 7, Sec. 11.
Fourth, when u(x) has regions of steep gradient, one can use a change-of-coordinate to
cluster grid points in the frontal region. Chapt. 13 describes a wide variety of real-valued
mappings; transformations for spatially periodic problems are in Sec. 7 and adaptive grids
are explained in Sec. 9.
These ideas and those explained below are only a sampler. No doubt the reader will
invent his own variations.
19.2
Sideband Truncation
Normally, we truncate a spectral expansion by including all basis functions up to a certain
cutoff, beginning with φ0(x). For special problems, however, this may be inefﬁcient. The
large eigenfunctions of Mathieu’s equation furnish a good example. These solve
uxx + [λ −2 q cos(2x)] u = 0
(19.1)
subject to the condition of periodicity with period 2π with λ as the eigenvalue and q as a
constant parameter.
When q = 0, the eigenvalues and eigenfunctions are
λn = n2
;
u0 = 1;
un(x) = sin(nx)
or
cos(nx)
(19.2)
For non-zero q, the unperturbed solutions are still good approximations to those of the full
Mathieu problem, (19.1), whenever n2 ≫q. If n = 15, for example, the spectral coefﬁcient
with the largest amplitude will not be a0 or a1, but a15. If we use the most drastic possible
truncation — one term! — then sin(15 x) or cos(15 x) must be that term.
One can show by using the trigonometric identity
cos(2x) cos(nx) = 0.5 {cos[(n + 2)x] + cos[(n −2)x]}
(19.3)
(and its analogue for sin(nx)) that the perturbation, 2 q cos(2x), will only couple Fourier
terms whose degrees differ by two and are of the same type, either sines or cosines. The
eigenfunctions of Mathieu’s equation therefore fall into four separate classes. The eigen-
functions of each class can be computed independently of the eigenfunctions of the other
three classes.
These four groups of eigenfunctions illustrate the double-parity symmetry of Fourier
functions (Chapter 8, Sec. 2). Each eigenfunction has deﬁnite parity both with respect to
x = 0 and with respect to x = π/2. The little table below lists the four classes in the
conventional notation. The middle column gives the double-parity symmetry of each class
with the parity with respect to x = 0 listed ﬁrst. The third column lists the Fourier functions
that sufﬁce to represent all modes in a given class; each of these basis functions has the same
double symmetry as the Mathieu functions.

444
CHAPTER 19. SPECIAL TRICKS
15
13
11
17 19 21 23 25
9
7
3
Fourier degree n
Figure 19.1: Absolute values of the Fourier coefﬁcients of the Mathieu function, ce15(x),
when the parameter q = 10. This is the motive for the “sideband truncation”: only ﬁve of
the coefﬁcients are non-negligible, but they are not the coefﬁcients of the lowest ﬁve Fourier
terms.
ce2n(x)
. . .
Even-Even symmetry
. . .
{1, cos(2x), cos(4x) . . . }
ce2n+1(x)
. . .
Even-Odd symmetry
. . .
{cos(x), cos(3x), cos(5x) . . . }
se2n(x)
. . .
Odd-Odd symmetry
. . .
{sin(2x), sin(4x), sin(6x) . . . }
se2n+1(x)
. . .
Odd-Even symmetry
. . .
{sin(x), sin(3x), sin(5x) . . . }
For small q, one can show via perturbation theory that an±2 is O(q), an±4 is O(q2), an±6 is
O(q3) and so on. The coefﬁcient an±4 is only O(q2) because (19.3) shows that the pertur-
bation cannot couple these components directly to cos(nx), but only to the much smaller
components, cos[(n ± 2)x].
Fig. 19.1 illustrates these remarks by plotting the absolute value of the Fourier cosine
coefﬁcients for ce15(x) for q = 10 (Lowan et al., 1951). We do not need 1 or cos(2x) or cos(4x)
in our basis set (for this eigenvalue and this value of q) because their coefﬁcients are very,
very small. The important basis functions are those which are oscillating on nearly the
same scale as the dominant basis function, cos(nx).
Deﬁnition 42 (SIDEBAND TRUNCATION)
When the basis set is restricted to basis functions of the form φn±m(x) where m ≪n, this is
said to be a “SIDEBAND TRUNCATION”.
The basis function φn(x), normally the function with the largest coefﬁcient, is the “fundamen-
tal” and the other basis functions in the truncation are the “SIDEBANDS”.
When we apply Galerkin’s method with a sideband truncation to ﬁve basis functions,
the resulting matrix problem is of the form

19.2. SIDEBAND TRUNCATION
445
[λ −(n −4)2]
−q
0
0
0
an−4
.. . . . . . . . . . . . . . . .. . . . . . . . . .. . . . . . . . . . . . . . . ..
0
... [λ −(n −2)2]
−q
0
...
0
an−2
...
...
0
...
−q
[λ −n2]
−q
...
0
an
...
...
0
...
0
−q
[λ −(n + 2)2] ...
−q
an+2
...
...
.. . . . . . . . . . . . . . . .. . . . . . . . . .. . . . . . . . . . . . . . . ..
0
0
0
−q
[λ −(n + 4)2]
an+4
= ⃗0
(19.4)
Eq. (19.4) applies to all four classes of basis functions provided that n ≥7. The condition
for a nontrivial solution is that the determinant of the 5 × 5 matrix in (19.4) should equal
0, which gives a quintic equation to determine λ. If we truncate to just the fundamental
plus two sidebands, then the “secular determinant” is that of the inner 3 × 3 block in (19.4)
which is enclosed by dots.
The polynomial equations that determine λ are
P3(λ; q, n)
≡
λ3 −(3 n2 + 8)λ2 + (3 n4 −2 q2 + 16)λ
(19.5)
+
8 q2 −16 n2 + 2 n2q2 + 8 n4 −n6
plus a similar equation for the 5 × 5 determinant (not displayed). Since we are interested
in the mode whose unperturbed eigenvalue is n2 and since the eigenvalue is changed only
a little bit by the perturbation provided that n2 ≫q, we do not need to apply a general
polynomial equation solver to P3(λ) and P5(λ). Instead, we can apply Newton’s iteration
once to obtain an accurate analytical solution in the form
λ = λ0 + δ
(19.6)
where
λ0 ≡−n2
(19.7)
The 3 × 3 truncation gives
δ3
=
−
P3(λ0)
dP3(λ0)/dλ
(19.8)
=
4 q2
q2 + 8 n2 −8
(19.9)
and similarly1
δ5 =
32 q4 + 512 q2n2 −1024 q2
3 q4 −896 q2 + 64 n2q2 + 1024 n4 −5120 n2 + 4096
(19.10)
Fig. 19.2 compares δ3(q) and δ5(q) with the exact correction to the eigenvalue for n = 15.
Although we have included no cosines lower than cos(11x), the 5 × 5 sideband truncation
is almost indistinguishable from the exact eigenvalue correction for q ≤25.
When q/n2 is large, the perturbation is so strong that the non-negligible sidebands ex-
tend all the way to the lowest mode, thus implicitly reverting to a normal spectral expan-
sion. “Sideband truncation” has only a limited range of applicability.
1The determinants and the Newton’s iteration were evaluated using the algebraic manipulation language
REDUCE

446
CHAPTER 19. SPECIAL TRICKS
0
5
10
15
20
25
0
0.5
1
1.5
q
Eigenvalue correction
δ5
δ3
Figure 19.2: A comparison of the exact eigenvalue correction, δ(q), for the mode ce15 with
the three-basis-function and ﬁve-basis-function approximations computed in the text. The
ﬁve-term approximation, δ5(q), is almost indistinguishable from the exact δ(q).
Nevertheless, there are other physical problems where this trick is useful. An exam-
ple would be the direct (as opposed to perturbative) calculation of “envelope solitons”
(Boyd, 1983a, b, c). There are many interesting phenomena which can be modelled by a
fast “carrier” wave modulated by a slowly-varying “envelope” or amplitude; a sideband
truncation is appropriate for all of them.
19.3
Special Basis Functions, I: Corner Singularities
When the computational domain has sharp angles, the PDE solution is usually weakly
singular at such angles or corners. As noted in Chap. 16, mapping methods are often very
effective in dealing with corner singularities because the solution is bounded even at the
corners. However, mappings rob resolution from the interior of the domain to squeeze
more grid points near the walls. A better option, at least in theory, is to subtract the branch
points from the solution so that the Chebyshev series is only required to represent the non-
singular part of u(x, y).
Schultz, Lee, and Boyd (1989) describe an illuminating example: the wall-driven in-
compressible ﬂow in a two-dimensional rectangular cavity. The velocity is discontinuous
at the upper corners where the moving wall meets two stationary boundaries. The result is
that if one deﬁnes a local polar coordinate system (r1, θ1) centered on the upper left-hand
corner, the ﬂow is singular there with the strongest branch point taking the form
ψs1 =
r1
h
θ1(cos θ1 −π
2 sin θ1) −
¡ π
2
¢2 sin θ1
i
π2
4 −1
(19.11)
plus a similar form for the other upper corner.
When the streamfunction is partitioned as
ψ(x, y) = ψa(x, y) + ψs(x, y)
(19.12)
where ψs(x, y) includes the two singular terms of the form of (19.11) and ψa(x, y) is ex-
panded as a 30×30 two-dimensional Chebyshev series, the streamfunction for zero Reynolds’

19.3. SPECIAL BASIS FUNCTIONS, I: CORNER SINGULARITIES
447
number is accurate to at least 1 part in 10,000,000,000, relative to its maximum. The singularity-
subtraction has added at least six decimal places of accuracy for this truncation.
The remarkable thing about this accuracy is that the driven cavity ﬂow has weaker
singularities at the lower corners, too. Moffatt (1964) showed that as the corners are ap-
proached, the ﬂow becomes more and more linear because the velocities tend to zero (rel-
ative to the walls). This near-corner linearity allowed him to show that the ﬂow consists
of an inﬁnite sequence of eddies of rapidly diminishing size and intensity – the so-called
“Moffatt eddies”. Because the singular term (19.11) is driven directly by the wall, it is com-
pletely known. However, the “Moffatt eddies” are driven by the large eddy in the center
of the cavity, so the “Moffatt eddies” are known only to within multiplicative constants
which must be determined by matching to the interior ﬂow.
This problem illustrates two general themes. The ﬁrst is that one can generally deter-
mine the form of the singular basis functions, as in (19.11), by a linear asymptotic analysis
even when the problem as a whole is strongly nonlinear.
The second theme is that weak singularities may often be ignored. The “Moffatt eddies”
are described by functions with branch points, but neither ψ nor its ﬁrst couple of deriva-
tives are unbounded. The result is that one can obtain ten decimal place accuracy without
applying special tricks to these corner eddies.
Which corner branch points can be ignored and which should be represented by singu-
lar basis functions depends on (i) the target accuracy and (ii) the strength of the nonlinear-
ity.
If the goal is thirty decimal place accuracy, for example, one could greatly improve
efﬁciency by supplementing the Chebyshev basis by special functions in the form of Mof-
fatt eddies of undetermined strength. The greater the target accuracy, the more singular
functions that should be included in the spectral basis set.
The strength of the nonlinearity is important, too. Boyd (1986) solved another problem,
the two-dimensional Bratu equation, which has corner singularities. He showed that as the
amplitude becomes larger, the solution series converges more and more slowly. The corner
singularities become less and less important in this same limit.
Schultz, Lee and Boyd (1989) show that the same is true of the driven cavity ﬂow. As
the Reynolds number increases, the ﬂow develops interior fronts. These regions of steep
gradients are smoothed by viscosity so that the ﬂow is analytic everywhere in these frontal
zones — in contrast to the corner eddies, which are genuinely pathological at the corners.
Nevertheless, the Chebyshev series converges more and more slowly as the internal fronts
become steeper. Unless the target accuracy is greater than ten decimal places, these internal
fronts are a greater numerical challenge than resolving the Moffatt eddies in the corners.
For many problems, the spectral coefﬁcients are the sum of two or more indepen-
dent contributions. The corner singularities, because their contributions decay only alge-
braically with n, must dominate in the limit n →∞. However, if the corner branch points
are weak and the internal fronts are strong, the exponentially decaying contributions from
the complex poles or branch points associated with the fronts may be larger than the contri-
butions of the corner singularities for all n < ncross-over. For example, consider a Chebyshev
coefﬁcient which depends on n as
an ∼10 exp
³
−n
3
´
+ 0.000001
n5
(19.13)
A pure mathematician would be content with the statement that an ∼0.000001/n5 in the
limit n →∞. The numerical analyst is called to a higher standard: the exponentially-
decaying term in (19.13) is larger than the second, algebraically decaying term for all n <
120.

448
CHAPTER 19. SPECIAL TRICKS
Boyd (1987e, 1988d) gives other vivid examples of this competition between competing
numerical inﬂuences. Each problem exhibits a “cross-over truncation” where the slope
of the error as a function of N dramatically changes. Boyd (1988d) is a one-dimensional
application of singular basis functions to resolve logarithmic endpoint singularities.
The driven cavity ﬂow and the Bratu equation both exhibit a similar tug-of-war be-
tween branch points of different strengths and different nearness-to-the-square. When the
corner singularities win, singular basis functions are extremely helpful.
19.4
Special Basis Functions, II: Wave Scattering
The scattering of waves incident upon a reﬂector is another problem where special radia-
tion functions are very useful (Boyd, 1990d). To illustrate this idea, we solve the quantum
mechanics problem of the scattering of a sine wave by a potential well in one dimension.
The physical background is described in Morse and Feshbach (1953). The Schr¨odinger
equation for a potential energy V (x) is, letting k2 denote the energy,
ψxx +
£
k2 −V (x)
¤
ψ = 0
(19.14)
It is implicitly assumed that V (x) →0 as |x| →∞so that the asymptotic solution is a plane
wave of wavenumber k.
The scattering problem is to calculate the transmitted and reﬂected waves when a plane
wave of unit amplitude is incident from the left. The wavefunction ψ has the asymptotic
behavior
ψ
∼
eikx + α(k) e−ikx
x →−∞
(19.15a)
ψ
∼
β(k) eikx
x →∞
(19.15b)
where the ﬁrst term in (19.15a) is the incident wave (the forcing), the second term is the
reﬂected wave, and (19.15b) is the transmitted wave. The complex coefﬁcients α(k) and
β(k) are unknowns; the primary goal is to calculate the reﬂection coefﬁcient R deﬁned by
R ≡|α|2
(19.16)
If V (x) decays exponentially fast as |x| →∞, then ψ(x) tends to its asymptotic forms
(19.15) exponentially fast, too. The rational Chebyshev functions, TBn(x), are a natural and
exponentially convergent basis for representing the difference between ψ and its asymp-
totic forms.
Unfortunately, the rational Chebyshev functions cannot represent the asymptotic si-
nusoidal waves themselves. Because the sine waves do not decay in amplitude, a small
absolute error on the inﬁnite interval is possible if and only if a moderate number of ra-
tional functions can faithfully represent an inﬁnite number of crests and troughs. This is
too much to ask of rational Chebyshev functions, sinc functions, Hermite functions, or any
standard basis set.
However, one can retrieve spectral accuracy for the entire problem by supplementing
the rational Chebyshev functions by a pair of special “radiation” functions.
First, deﬁne two real functions, C(x) and S(x), by the requirement that each solves
(19.14) and has the boundary behavior
C(x)
→
cos(kx)
as
x →−∞
(19.17a)
S(x)
→
sin(kx)
as
x →−∞
(19.17b)

19.4. SPECIAL BASIS FUNCTIONS, II: WAVE SCATTERING
449
Since these are linearly independent, the general solution of (19.14) is a linear combination
of these two functions. Comparing (19.17) with (19.15a) shows that
ψ = (1 + α) C(x) + i (1 −α) S(x)
(19.18)
To compute α and β, we need the asymptotic behavior of C(x) and S(x) as x →∞. Since
V (x) →0 in this limit (by assumption), it follows that their most general asymptotic be-
havior must take the form
C(x)
∼
γ1 cos(kx) + γ2 sin(kx)
x →∞
(19.19a)
S(x)
∼
σ1 cos(kx) + σ2 sin(kx)
x →∞
(19.19b)
Once we have calculated the four parameters (γ1, γ2, σ1, σ1), we can match (19.19) to
(19.15b) to determine the four unknowns, the real and imaginary parts of α and β.
To compute C(x) and S(x), we write
C(x) = cos(kx) + ˜C(x)
&
S(x) = sin(kx) + ˜S(x)
(19.20)
˜C(x) =
N−3
X
n=0
an TBn(x) + aN−2 H(x) cos(kx) + aN−1 H(x) sin(kx)
(19.21)
where
H(x) ≡1
2 (1 + tanh(x))
(19.22)
is a smoothed approximation to a step function. The expansion for ˜S(x) is identical in form
with that for ˜C(x). The two “radiation basis functions” have the asymptotic behavior
H(x) cos(kx) →
(
0
as
x →−∞
cos(kx)
as
x →∞
(19.23)
and similarly for the other function. Because these basis functions are “one-sided”, they
vanish as x →−∞and are irrelevant to the asymptotic behavior of C(x) in this limit. In
the opposite limit, x →∞, one ﬁnds that as N increases,
aN−2 →γ1 −1
&
aN−1 →γ2
N →∞
(19.24)
Similarly, the two radiation coefﬁcients for ˜S(x) converge to σ1 and σ2 −1. Thus, the
coefﬁcients of the radiation functions give the needed constants in the asymptotic approx-
imations for C(x) and S(x).
Substituting (19.20) into (19.14) shows that
˜Cxx +
£
k2 −V (x)
¤ ˜C = V (x) cos(kx)
(19.25)
The differential equation for ˜S(x) is identical except that cos(kx) on the right side of (19.25)
must be replaced by sin(kx). To solve (19.25), we apply the pseudospectral method with
the usual N interpolation points for the rational Chebyshev basis:
xi ≡L cot
µπ [2i −1]
2N
¶
i = 1, . . . , N
(19.26)

450
CHAPTER 19. SPECIAL TRICKS
where L is a constant map parameter (=2 in the example below). Because the problems
for ˜C(x) and ˜S(x) differ only in the inhomogeneous term, it is necessary to compute and
LU-factorize only a single square matrix whose elements are
Hij ≡φj,xx(xi) +
©
k2 −V (xi)
ª
φj(xi)
(19.27)
where the {φj(x)} are the basis functions deﬁned above: rational Chebyshev functions
plus two special radiation functions The factorized matrix equation must be solved twice
(Appendix B) with different inhomogeneous terms:
fi ≡V (xi) cos(kxi),
[ ˜C]
gi ≡V (xi) cos(kxi),
[ ˜S]
(19.28)
Matching (19.19) to (19.15b) shows that α is the solution of the 2 × 2 real system
(γ1 + σ2)
(σ1 −γ2)
Re(α)
(σ2 −γ1)
=
(γ2 −σ1)
(γ1 + σ2)
Im(α)
−(σ1 + γ2)
(19.29)
The rate-determing step is to invert a single N × N square matrix: O([2/3]N 3) multiplica-
tions and additions.
Table 19.1 shows the results for the particular case
V (x) = −v sech2(x)
(19.30)
for v = 1 and various wavenumbers k. The exact reﬂection coefﬁcient for this potential is
R =
1 + cos(2π
p
v + 1/4)
cosh(2πk) + cos(2π
p
v + 1/4)
(19.31)
Because of the hyperbolic function in (19.31), the reﬂection coefﬁcient is exponentially
small in 1/k. This is a general feature of scattering from a potential well, and not something
special to a sech2 potential. Because of this, one must solve the Schroedinger equation to
very high accuracy to compute even a crude approximation to R for large k. Otherwise, the
tiny reﬂection coefﬁcient will be swamped by numerical error.
Thus, spectral methods – with spectral accuracy – are very valuable for scattering prob-
lems.
19.5
Special Basis Functions, III:
Weakly Nonlocal Solitary Waves
This idea of special “radiation basis functions” can be applied to many other types of wave
problems where the solution asymptotes to a sinusoidal wave rather than to zero. Boyd
(1991a, 1990b, 1991d, 1991e, 1995b, 1995h, 1995j) describes applications to “non-local soli-
tary waves” and other nonlinear waves.
19.6
Root-Finding by Means of Chebyshev Polynomials:
Lanczos Economization and Ioakimidis’ Method
The standard numerical strategy for solving f(x) = 0 is to approximate f(x) by something
simpler which can be solved explicitly, usually a local approximation in the vicinity of a
“ﬁrst guess” for the root. In Newton’s method, the approximation is a linear Taylor series

19.6. ROOT-FINDING BY CHEBYSHEV POLYNOMIALS
451
Table 19.1: The exact and numerical reﬂection coefﬁcients R for the sech2 potential as com-
puted using 48 rational Chebyshev functions and two radiation functions.
k
Rnumerical
Rexact
Absolute Error
0.3
0.423097
0.423097
2.7E−8
0.6
0.0774332
0.0774332
2.6E−8
0.9
0.0121005
0.0121005
−3.1E−8
1.2
0.00184535
0.00184535
−9.5E−10
1.5
0.000280391
0.000280376
1.5E−8
1.8
0.000042562
0.000042576
−1.3E−8
2.1
0.000006471
0.000006465
6.1E−9
2.4
0.000000978
0.000000982
−3.2E−9
2.7
0.000000151
0.000000149
1.5E−9
3.0
0.000000022
0.000000023
−8.6E−10
expansion about x = xi. In the secant method, the approximation is the linear polynomial
that interpolates f(x) at x = xi and xi−1. The Cauchy and Muller methods are the same
except that the approximations are the quadratic Taylor series and quadratic interpolat-
ing polynomial. Halley’s scheme uses the [1, 1] Pad´e approximant, which is that ratio of
one linear polynomial over another whose Taylor expansion matches that of f(x) through
quadratic terms. Shafer suggests using higher order Pad´e approximants: the [2,3] gives a
ﬁfth-order method, but requires only solving a quadratic (the numerator) to ﬁnd the root.
An obvious generalization is to use Chebyshev polynomials if the root can be localized
in a narrow region. C. Lanczos used a simple argument to localize the root of a cubic
polynomial within a ﬁnite interval, converted the polynomial into a Chebyshev series on
the interval, and then solved the N = 2 truncation of the Chebyshev series, which is a
quadratic polynomial.
Boyd (1995f) applied this strategy of “Lanczos economization”2 to nonlinear eigenvalue
problems. The goal is to ﬁnd the root of the determinant of a system of linear equation
when the matrix elements depend nonlinearly on the eigenparameter x. The cost of eval-
uating f(x) is very expensive if the dimension of the matrix is large – O(106) for a 100 x
100 matrix. It therefore is useful to evaluate the determinant on an interval in x and then
compute the roots by ﬁnding those of the Chebyshev approximant.
The most reliable methods for ﬁnding all roots on an interval unfortunately require fre-
quent evaluations of f(x). One such robust strategy is to compute f(x) on a large number
of points (say one thousand!), look for sign changes, and then reﬁne the roots thus located
2“Lanczos economization” is usually applied in a somewhat narrower sense to the process of converting a
truncated power series to a Chebyshev series of the same order, truncating to the lowest acceptable degree, and
then converting back to an ordinary polynomial to obtain an approximation that is cheaper to evaluate and more
uniform than the higher-degree polynomial from whence it came. The root-ﬁnding algorithm described here is
similar in the sense that a function which is expensive to evaluate is replaced by a truncated Chebyshev series
that is much cheaper.

452
CHAPTER 19. SPECIAL TRICKS
by Newton’s method. This would be hideously expensive if we worked directly with f(x).
An N-term Chebyshev approximant can be evaluated in O(N) operations, however, so that
one can graph the expansion at a thousand points for perhaps less cost than evaluating the
original function just once.
Lanczos economization can be applied to ﬁnd roots of functions of two or even three
unknowns, but unfortunately it is unworkable – unless the degree of the Chebyshev inter-
polant is very low – in higher dimensions. The other Chebyshev-based rootﬁnding tech-
nique, due to Ioakimidis , is unfortunately to limited to a small number of unknowns also.
Nevertheless, it is an illuminating and clever application of Chebyshev ideas.
Suppose that f(x) has only a single root on x ∈[a, b]. Let ρ denote the (unknown!)
location of the root. The integral
I ≡
Z b
a
x −ρ
f(x)
1
√
1 −x2 dx
(19.32)
can be integrated with exponential accuracy by a Chebyshev quadrature because the zero
in f(x) cancels that in the numerator. It follows that the results of Gauss-Chebyshev and
Chebyshev-Lobatto quadrature must differ by an amount exponentially small in N
IGauss(N) = ILobatto + O(exp(−qN))
(19.33)
for some positive constant q (neglecting powers of N and other algebraic factors of N mul-
tiplying the exponential) where
IGauss(N) ≡
N
X
j=1
wG
j
(xG
j −ρ)
f(xG
j )
(19.34)
and similarly for the Lobatto quadrature, which uses the “endpoints-and-extrema” grid
instead of the “interior” grid where the wj are the quadrature weights. Neglecting the
exponential error terms, we can rearrange the terms in the equation IGauss = ILobatto to
obtain
ρ



N
X
j=1
Ã
wG
j
f(xG
j
−
wL
j
f(xL
j )
!

=



N
X
j=1
Ã
xG
j
wG
j
f(xG
j ) −xL
j
wL
j
f(xL
j )
!


(19.35)
Dividing by the sum on the left gives an explicit formula for the root ρ as a ratio of weighted
values of f(x). For Chebyshev quadrature with the usual Chebyshev weight function in
the integral Eq.(19.32), the weights are all identical except for the two endpoints, and the
quadrature points for both grids combined are the images of an evenly spaced grid under
the cosine mapping. This greatly simpliﬁes the ﬁnal approximation to the root to
ρ =



2N
X
j=0
” (−1)j
xj
f(xj)


/



2N
X
j=0
” (−1)j
1
f(xj)



(19.36)
where the double prime on the sums denotes that the ﬁrst and last terms in both the nu-
merator and denominator should be multiplied by (1/2) and
xj = 1
2
½
(a + b) −(a −b) cos
µ j π
2N
¶¾
(19.37)
Fig. 19.3 shows that for a typical example, the convergence of the approximation with
N is indeed geometric. Ioakimidis (unpublished preprint) has shown that the idea can be
generalized to ﬁnd the roots of a pair of equations in two unknowns.

19.7. HILBERT TRANSFORM
453
0
5
10
15
20
25
30
10
-12
10
-10
10
-8
10
-6
10
-4
10
-2
10
0
N
errors
f=sin(x-pi/4)/ sqrt(1+10 x**2)
Figure 19.3: Absolute value of the absolute error in approximating the root nearest the
origin of the function sin(x −π/4)/(1 + 10 x2)1/2 using the quadrature interval [-1, 1] in
Ioakimidis’ non-iterative Chebyshev root-ﬁnding algorithm. The number of evaluations of
f(x) is 2N + 1 where N is the order of the method.
19.7
Spectrally-Accurate Algorithms for the Hilbert Trans-
form
The Hilbert transform of a function f(x) is deﬁned as the Principal Value (PV) integral
H{f}(y) ≡1
π PV
Z ∞
−∞
f(x)
x −y dy
(19.38)
If f(x) ∈L2(−∞, ∞), then the Hilbert transform is in the function space L2 also. The
Hilbert transform is important in signal processing, optics, and water waves. For example,
the famous Benjamin-Ono equation, which has solitary wave solutions, is
ut + uux + H{uxx} = 0
(19.39)
For functions that decay exponentially fast in |x|, there are at least three Hilbert trans-
form algorithms whose accuracy increases exponentially but subgeometrically with N, the
number of degrees of freedom:
1. sinc quadrature (Stenger(1981); ﬁrst proposed by Kress and Martensen):
H{f}(y) ≈h
π
N
X
j=−N
f(jh) cos(π[y −jh]/h) −1
y −jh
(19.40)
where h is the grid spacing
2. Fourier method (Weideman and James, 1992):
H{f}(y) = F −1 {i sgn(k)F{f}(k)}
(19.41)
where F denotes the Fourier transform and F −1 is the inverse transform.

454
CHAPTER 19. SPECIAL TRICKS
3. Rational Chebyshev series (Weideman, 1995b, Weideman and James, 1992))
H{f}(y) =
∞
X
j=−∞
i sgn(j)ajρj(y)
(19.42)
where
f(y) =
∞
X
j=−∞
ajρj(y)
(19.43)
ρj ≡
(1 + ix)j
(1 −ix)j+1
(19.44)
The Fourier algorithm is the easiest to program. In words, the procedure is to take
the Fast Fourier Transform of f(x), multiply wavenumber k by sgn(k), and then take the
inverse Fast Fourier Transform of the result.
19.8
Spectrally-Accurate Quadrature Methods
19.8.1
Introduction: Gaussian and Clenshaw-Curtis Quadrature
The “quadrature problem” is to evaluate an integral such as
I ≡
Z b
a
f(x)w(x)dx
(19.45)
by an approximation of the form
I ≈
N
X
j=1
wj f(xj)
(19.46)
Here, w(x) ≥0 is a user-chosen weight function and f(x) is a smooth but otherwise arbi-
trary function. The “quadrature weights” wj are invariably different from the values of w(x)
evaluated at the “quadrature abscissas” xj. However, both quadrature weights and abscis-
sas are independent of f(x), and depend only on the interval [a, b] and the weight function
w(x).
To obtain spectral accuracy, the underlying strategy of all algorithms discussed here is
to expand f(x) as a truncated spectral series and then integrate term-by-term, analytically.
For each weight function w(x) and choice of interval, x ∈[a, b], there is a unique choice
of basis set such that the spectral integration yields a “Gaussian quadrature” or “Gauss-
Jacobi integration” scheme. As has already been discussed in Chapter 4, Sec. 3, when
w ≡1 and x ∈[−1, 1], for example, the ordinary Legendre polynomials are the basis which
gives a Gaussian quadrature.
The special advantage of Gaussian quadrature is that the N-point formula is exact when
f(x) is a polynomial of degree (2N + 1) or less that. That is, Gaussian quadrature is exact
(ignoring roundoff) when the degree of the polynomial is twice the number of quadrature
points. Non-Gaussian quadratures are also possible, such as that obtained by using the
Chebyshev roots as abscissas for a weight function w(x) = 1. The disadvantage of a non-
Gaussian scheme is that such a quadrature is exact only for polynomials of degree (N −1),
that is, only about half the degree for which Gaussian quadrature is error-free.

19.8. SPECTRALLY-ACCURATE QUADRATURE METHODS
455
Clenshaw and Curtis(1960) pointed out, however, that non-Gaussian schemes could
have some advantages over Gaussian quadrature. First, the Gaussian abscissas are the
roots of transcendental polynomials, which must be computed or looked up in tables. In
contrast, the roots and quadrature weights for Chebyshev polynomials are given by simple
analytical formulas. Second, for all Gaussian quadratures, when the integral is computed
twice using different N to check for accuracy, the evaluations of f(x) for the ﬁrst compu-
tation are completely useless for the second computation. The reason is that for Gaussian
integration formulas, the abscissas for a given N never equal the abscissas of a different
N (except for the endpoints). This is unfortunate when the integrand f(x) is expensive to
evaluate. In contrast, for certain Chebyshev polynomial schemes, previous evaluations of
f(x) can be recycled when N is doubled. This inexpensive adaptive quadrature schemes
which double N until two successive approximations to the integral agree to within a user-
speciﬁed tolerance, or satisfy other criteria for accuracy explained below.
Thus, “Clenshaw-Curtis” quadratures have the twin virtues of simplicity and easy and
inexpensive adaptivity.
19.8.2
Clenshaw-Curtis Adaptivity
Clenshaw and Curtis(1960) noted that the Chebyshev-Lobatto grid of (N + 2) points
xj = cos
µ
πj
N + 1
¶
,
j = 0, 1, . . . , (N + 1)
(19.47)
has the property that when N + 1 is doubled, all points on the old grid are also part of the
new, higher resolution grid. This allows inexpensive computation of the same integral for
multiple resolutions because it is only necessary to evaluate f(x) on the ﬁnest grid, and
this provides all the evaluations of f needed for the coarser grids, too.
The Chebyshev polynomials are the images of cosine functions under the mapping
x = cos(t). Thus, the Clenshaw-Curtis grid is an evenly spaced grid in the trigonometric
coordinate t. Although also evenly spaced in t, the usual Chebyshev “interior” or “roots”
grid does not have the property that the points at small N are contained in points of higher
N, so Clenshaw and Curtis rejected it in favor of the Lobatto, endpoints-and-extrema grid.
Automatic adaptivity also requires an estimate for the error EN. Several possibilities
have been described in the literature, such as Clenshaw and Curtis’ own estimate: the
maximum of the absolute value of the three highest degree coefﬁcients of the Chebyshev
series of the indeﬁnite integral of f. However, the simplest and most conservative is
Eestimate
N
≡| IN −IN/2 |
(19.48)
where IN and IN/2 denote the (N + 2)-point and (N + 1)/2 + 1-point approximations to
the integral I. In words, when N + 1 is doubled, the error is almost certainly less than the
difference between two successive estimates of the integral, provided that this difference is
small. Gentleman(1972a), who discusses and compares several estimates, says, ”Consider-
able experience with the subroutine CQUAD (Gentleman, 1972c), however, indicates that
this simple estimate [Eq.(19.48)] appears unusually realistic here [for quadrature]. ... The
naive estimate also has the advantage that when the integral is being computed to essen-
tially full-word accuracy, a reasonable indication of the representational rounding error in
the answer is frequently given. The alternative error estimates ... ignore this — often to
one’s embarrassment.”
We agree whole-heartedly. Computers have improved greatly in the 26 years since his
article was published, and there is little excuse for trading reliability for a slightly smaller
value of the maximum value of N.

456
CHAPTER 19. SPECIAL TRICKS
His comment on rounding error is a reminder that spectral methods are so accurate that
machine precision will limit accuracy rather than theoretical rates of convergence. The dif-
ference between IN and IN/2 cannot decrease below ten or one hundred times the machine
epsilon, that is, the minimum error of a single ﬂoating point operation on a given species of
computer (usually about 10−16 on most contemporary machines). In contrast, a theoretical
estimate can be smaller than machine-epsilon, which is meaningless unless one calculates
using multiple precision arithmetic.
The strategy for adaptive quadrature is simple: pick a starting value of N, compute an
approximation, double N + 1, compute another approximation, compare the difference to
the desired error tolerance, and then double N + 1 again and again until two successive
approximations differ by a satisfactorily tiny amount.
19.8.3
Mechanics
Boyd(1987c) has given a general treatment for Curtis-Clenshaw quadrature that embraces
the inﬁnite and semi-inﬁnite intervals as well as x ∈[−1, 1]. The ﬁrst step is to transform
the interval in x to the trigonometric coordinate t. The second step is to approximate the
integral by an evenly spaced quadrature formula on the interval t ∈[0, π]. The quadrature
weights are simply the integrals of the trigonometric cardinal functios with the “metric”
factor that results from the change of coordinates. The results may be summarized as
follows:
1. x ∈[−1, 1]: The transformation of the integral is
x
=
cos(t)
(19.49)
I
=
Z 1
−1
f(x)dx =
Z π
0
f(cos(t)) sin(t) dt
(19.50)
The quadrature approximation is
IN
≡
N
X
j=1
wj f(cos(tj))
(19.51)
tj
≡
πj/(N + 1),
j = 1, 2, . . . , N
(19.52)
wj
≡
sin(tj)
2
N + 1
N
X
m=1
sin(mtj) [1 −cos(mπ)]/m
(19.53)
2. x ∈[0, ∞]: The transformation of the integral is (Boyd, 1987b, and Chapter 17), using
the same map as yields the TL rational Chebyshev basis:
x
=
L cot2(t/2),
L is a user-choosable constant
(19.54)
I
=
Z ∞
0
f(x)dx =
Z π
0
f(L cot2(t/2)) 2L
sin(t)
[1 −cos(t)]2 dt
(19.55)
The quadrature is
IN
≡
N
X
j=1
wj f(L cot2(tj/2))
(19.56)
tj
≡
πj/(N + 1),
j = 1, 2, . . . , N
(19.57)
wj
≡
2L
sin(tj)
[1 −cos(tj)]2
2
N + 1
N
X
m=1
sin(mtj) [1 −cos(mπ)]
m
(19.58)

19.8. SPECTRALLY-ACCURATE QUADRATURE METHODS
457
3. x ∈[−∞, ∞]: The transformation of the integral is (Boyd, 1987b, and Chapter 17),
using the same map as yields the TB rational Chebyshev basis:
x
=
L cot(t),
L is a user-choosable constant
(19.59)
I
=
Z ∞
0
f(x)dx =
Z π
0
f(L cot(t)) 2L
1
sin2(t) dt
(19.60)
The quadrature is
IN
≡
N
X
j=1
wj f(L cot(tj))
(19.61)
tj
≡
πj/(N + 1),
j = 0, 1, . . . , N + 1
(19.62)
wj
≡
½ Lπ/[sin2(tj)(N + 1)],
0 < j < (N + 1)
Lπ/[sin2(tj)(2N + 2)],
j = 0 and j = N + 1
(19.63)
Because the transformed integrals have integrands which are antisymmetric with respect
to t = 0 for the ﬁnite and semi-inﬁnite intervals, Boyd expanded the product of f with the
metric factor in terms of sine cardinal functions. Thus, the endpoint are omitted for these
two cases so that each uses only the N interior points of the (N + 2)-point Lobatto grid.
Alternatively, one may expand only f as a Chebyshev or Fourier series and then evalu-
ate integrals of the products of the cardinal functions with the metric factor, which is sin(t)
for the ﬁnite interval. This requires two additional evaluations of f, but raises the degree
of f for which the approximation is exact only by one. The quadrature weights given by
Fraser and Wilson (1966) as their Eq. (4.3).
Clenshaw and Curtis (1960) and Gentleman(1972a, b, c) prefer to compute the Cheby-
shev series for f(x) ﬁrst by a Fast Fourier transform and then integrate term-by-term
through a recurrence formula. This is an O(N log2(N)) procedure whereas the cost of eval-
uating the weights through Boyd’s method is O(N 2). Since these weights need only be
computed once for a given N, however, we recommend Boyd’s procedure.
19.8.4
Integration of Periodic Functions and the Trapezoidal Rule
Every student of numerical analysis learns the trapezoidal rule, and learns that the error is
O(1/N 2) where N is the number of grid points. Indeed, this estimate of only second order
accuracy is correct for non-periodic functions. However, when the integrand f(x) is periodic
and inﬁnitely differentiable for all real x and the integration interval coincides in length with
the spatial period P, the trapezoidal rule becomes spectrally accurate.
Theorem 38 (TRAPEZOIDAL RULE ERROR for PERIODIC INTEGRANDS)
Th
trapezoidal rule approximation to the integral of a function f(x) on the interval x ∈[−P/2, P/2]
is
Z P/2
−P/2
f(x)dx ≡IN = h



f(−P/2) + f(P/2)
2
+
N−1
X
k=−(N−1)
f (−P/2 + hk)



(19.64)
h ≡P/N is the grid spacing. If f(x) has the Fourier series
f(x) ≡1
2 α0 +
∞
X
n=1
αn cos
µ
n2π
P x
¶
+
∞
X
n=1
βn sin
µ
n2π
P x
¶
,
x ∈[−P/2, P/2],
(19.65)

458
CHAPTER 19. SPECIAL TRICKS
then the error in the trapezoidal rule is given without approximation as
EN ≡
Z P/2
−P/2
f(x)dx −IN = −P {αN + α2N + α3N + . . . }
(19.66)
If f(x) is non-periodic, then the Fourier coefﬁcients decrease as O(1/N 2) and the trapezoidal
rule is only second-order accurate, as taught in elementary numerical analysis texts.
If f(x) is periodic with period P and analytic on the interval x ∈[−P/2, P/2], then the Fourier
coefﬁcients are exponentially small in N and the trapezoidal rule is spectrally accurate.
Proof: The error series follows trivially from Theorem 19 because the integral is also the
constant in the Fourier series. The rest of the theorem follows from the Fourier convergence
theory for non-periodic and periodic functions described in Chap. 2. Q. E. D.
It is important to note that since the trapezoidal rule uses an evenly spaced grid, the
Clenshaw-Curtis adaptivity still applies.
19.8.5
Inﬁnite Intervals and the Trapezoidal Rule
If f(x) is a function that decays exponentially fast with |x|, then integrals on the inﬁnite
interval can be performed with spectral accuracy by applying the trapezoidal rule on a
large but ﬁnite interval through “domain truncation” (Sec 17.2). The approximation is the
same as Eq.(19.64),
Z ∞
−∞
f(x)dx ≈IN ≡h
(
f(−P/2) + f(P/2)
2
+
N−1
X
k=1
f (−P/2 + hk)
)
(19.67)
where
|I −IN| ∼max
|x|>L(|f(x)|) + O(αN)
(19.68)
where αN is again the N-th Fourier coefﬁcient when f(x) is expanded as a Fourier series
on the interval x ∈[−P/2, P/2]. Note that because f(x) is exponentially small at the ends
of the (large!) interval x ∈[−P/2, P/2], it is quite unnecessary for f(x) to be periodic, and
the discontinuity in the Fourier series at the ends of the interval will be O(f(P/2)) and
therefore exponentially small if we have chosen a sufﬁciently large P.
Because of its simplicity, the trapezoidal rule is usually preferable to the TB-integration
formula (19.61). However, the latter can be sometimes applied to integrands that decay
only as an inverse power of x whereas the trapezoidal rule is always restricted to expo-
nentially decaying f. Its accuracy is also more sensitive to the choice of P than is the
TB-integration rule to the choice of map parameter L (Boyd, 1982a). However, because
numerical integration is fairly cheap task, this sensitivity of the trapezoidal rule is rarely a
problem.
19.8.6
Singular Integrands
Integrals with integrable singularities can be computed to spectral accuracy by making a
change of coordinates. For example, suppose that the function is singular at both ends of
the interval x ∈[−1, 1]. Make the change of variable
x = tanh(z/L)
(19.69)

19.8. SPECTRALLY-ACCURATE QUADRATURE METHODS
459
0
100
200
300
400
10
-10
10
-5
10
0
N
Error in Tanh Rule
∫-1
1  (1-x 2)-3/4  dx
sum of (1-x k
2)-3/4
sum of sech(zk)1/2
Figure 19.4: An illustration of the exponential convergence of the tanh-rule where N is the
number of grid points. The integrand (1 −x2)−3/4 is singular at both endpoints. After the
change of coordinates to x = tanh(x/L) where L is arbitrarily chosen to be one here, the
integral is converted to a nonsingular integral on z ∈[−∞, ∞]. The “tanh rule” is simply
the trapezoidal rule, applied on a large but ﬁnite interval in z. The tanh rule is sensitive to
roundoff. When the integrand is expressed in terms of sech(z), one can obtain better than
ten decimal place accuracy (thick, solid curve). However, when the integrand is computed
in its original form (1−x2)−3/4, the tanh rule gives only three correct digits (dashed curve).
The difﬁculty with (1−x2)−3/4 is that near the endpoints where x2 ≈1, this is the fractional
power of the small difference of two much larger terms, generating large roundoff error.
(Note that the tanh rule has an exponentially high density of points, i. e., lots of points, in
these endpoint regions of strong cancellation.)
where L is a user-choosable scaling factor. Noting that dx/dz = (d/dz)tanh(z/L) = (1/L)sech2(z/L),
it follows that
I ≡
Z 1
−1
f(x) dx = 1
L
Z ∞
−∞
f (tanh(z/L)) sech2(z/L)dz
(19.70)
If f(x) blows up more slowly than a ﬁrst order pole as x →1, that is, f(x) grows no faster
than (1 −x)−α for some α < 1 and similarly at the other endpoint, then (i) the original
integral in x is ﬁnite and (ii) the transformed integral converges because the sech2 factor,
which arises from the change of coordinates, decays faster than f (tanh(z/L)) grows as
|z| →∞.
To recover an exponential rate of convergence, the transformed integral can be approx-
imated by any spectrally-accurate quadrature for the inﬁnite interval. The simplest is the

460
CHAPTER 19. SPECIAL TRICKS
trapezoidal rule, which becomes
IN
≡
h
L
½f(tanh(−P/(2L)) + f(tanh(P/(2L))
2
sech2(P/(2L))
+
N−1
X
k=1
f (tanh(−P/(2L) + hk/L)) sech2 (−P/(2L) + hk/L)
)
(19.71)
where h ≡P/N is the grid spacing in the new coordinate z and where P is chosen sufﬁ-
ciently large that the integrand is negligible at z = P/(2L). This formula is usually called
the “tanh” rule for obvious reasons.
When the integral is singular at a point x = a in the interior of the integration interval,
one should split the integral into two and apply the tanh rule separately to each piece. If
there is only a single singularity, one can replace the tanh mapping by a similar exponential
mapping onto a semi-inﬁnite integral.
19.8.7
Sets and Solitaries
Sometimes, one needs to repeatedly integrate a large set of integrals which fall into a com-
mon class. For this case, the most efﬁcient procedure is to estimate how large N must be by
computing a few members of the class for several different N. One may then use the small-
est acceptable N for all the remaining integrals. Since most computations are performed
for ﬁxed N, Gaussian quadrature is the cheapest way to integrate a whole set of integrals.
When one needs to integrate a single, solitary integral, then an adaptive procedure
like the Curtis-Clenshaw strategy is more efﬁcient. The non-Gaussian spectral quadrature
schemes described above are then very effective.

Chapter 20
Symbolic Calculations: Spectral
Methods in Algebraic
Manipulation Languages
“[A computer] can arrange and combine its numerical quantities exactly as if they were
letters or any other general sysmbols; and in fact it might be possible to bring out its
results in algebraic notation, were provisions made accordingly.”
– Augusta Ada Byron, Countess of Lovelace (1844)
“Originally, the calculation [of the Bondi metric problem in general relativity] had
required something like six months by hand ... the computer calculation, using
REDUCE2, required only 90 seconds on a CDC-7600 ... and corrected six errors in the
published manual derivation.”
– R. A. d’Inverno (1976)
20.1
Introduction
Computer algebra has had a strange and checkered history. The notion of manipulating
symbols instead of merely numbers is as old as the concept of the computer itself as shown
by the quote from the Countess of Lovelace. Algebraic manipulation (AM) languages such
as REDUCE and MACSYMA have been available for more than twenty years. And yet the
spread of applications of algebraic manipulation has been, to use the punning words of a
1979 reviewer, “a case of creeping ﬂow”. Two decade later, the ﬂow is still creeping, but
with a noticeably smaller viscosity.
Several problems have retarded the growth of “AM” languages. First, symbolic cal-
culations are best done interactively with a live human watching the stream of formulas
materialize on the screen, and intervening as needed with substitution and simpliﬁcation
rules. Symbolic manipulation was therefore a rather and slow painful business on screen-
less, teletype terminals. Second, AM programs are terrible memory hogs; many research
461

462
CHAPTER 20. SYMBOLIC CALCULATIONS
projects were prematurely truncated through running out of storage. Third, symbolic ma-
nipulation is inherently an order-of-magnitude more expensive than numerical manipula-
tion: a number is a number is a number (with apologies to Gertrude Stein), but a symbolic
variable must be tagged with all sorts of baggage to indicate precisely what the symbol
symbolizes. Any bold soul who wants to push the state of the art in calculating perturba-
tion series will sadly turn away from Maple and Mathematica to slog through the agonies
of writing a FORTRAN program to do the same job – the numerical program will be ten
times as long, but it may run 100 times faster and require only a tenth the storage to reach
a given perturbation order.
Paradoxically, however, it is as certain as tomorrow’s sunrise that algebraic manipula-
tion will triumph in the end. The scientist of the twenty-ﬁrst century will use AM every-
day, and will no more be able to imagine life without Maple or Mathematica or their ilk
than his counterpart of the 30’s could imagine designing without a slide rule. It seems un-
likely, after twenty years of waiting, that algebraic manipulation will ever become the major
computational tool for more than a tiny fraction of scientiﬁc projects. As more and more
engineers have AM on their desks, however, algebraic manipulation will likely become an
indispensable tool for small, “scratchpad” calculations of the kind we do every day.
It follows that symbolic spectral codes will always remain few compared to spectral
models that manipulate only numbers. Nevertheless, there are several reasons why spec-
tral algorithms and algebraic manipulation languages are an especially favorable pairing.
First, interpolatory and non-interpolatory spectral methods both manipulate polyno-
mials and trigonometric functions, which are precisely what REDUCE, Maple, and Mathe-
matica multiply, divide, differentiate, and integrate most easily. Second, spectral methods
have always been used at low order to compute analytical solutions to simple problems (Fin-
layson, 1973). Computer algebra greatly extends the “analytic range” of spectral methods
to more complex problems and higher resolution. Third, a major use of symbolic manip-
ulation has been to compute perturbation series. In many applications, the perturbation
series is a spectral series (Rand, 1984; Rand and Armbruster, 1987; Mills, 1987; Haupt and
Boyd, 1988, 1991).
In the remainder of this chapter, we discuss the striking differences between numeri-
cal and symbolic spectral methods. When calculating by hand or by REDUCE, one must
apply very different rules to choose the most efﬁcient method, the optimum strategy. In-
deed, many of the precepts for numerical calculations must be reversed or inverted when
the number of degrees of freedom is small and the goal is not a table or a graph but an
algebraic expression. The next two sections discuss such “inversions”. The fourth section
is a catalogue of the little tricks and devices that are important in writing efﬁcient pro-
grams. Sec. 5 describes several examples. The ﬁnal section is a summary of the current
state-of-the-art and lists several open problems.
20.2
Strategy
Table 20.1 summarizes four strategies for symbolic calculations. All spectral methods sub-
stitute a series with unknown coefﬁcients aj into the differential equation to obtain the
so-called residual function, R(x; a0, a1, . . . , aN−1) where N is the number of basis func-
tions in the approximation. If the trial solution uN(x) were exact, then the residual would
be zero for all x. With a truncated spectral approximation, the best we can do (barring
special cases) is to make the residual as small as possible in some sense.
The most widely used discretization strategy for numerical applications is known var-
iously as “collocation”, “orthogonal collocation”, “discrete ordinates” or the “pseudospec-
tral” method. One obtains N equations in N unknowns by demanding that the residual

20.2. STRATEGY
463
Table 20.1: Precepts for spectral methods: Numerical (N >> 1) versus Symbolic (N small)
SYMBOLIC [N ∼O(3)]
NUMERICAL [N >> 1]
Galerkin or Methods of Moments
Collocation
Legendre or Gegenbauer or Powers
Chebyshev polynomials
Polynomialization
Unnecessary
(i)Fourier and rational Chebyshev =⇒Chebyshev
(ii)Transcendental data and forcing =⇒Polynomial
Rationalization
(i)Collocation at rational points
(i) Collocation at roots
of TN, which are irrational
(ii)Replace irrational numbers
(ii) Unnecessary
&ﬂoating point numbers by rational numbers
function should be zero at each of N interpolation points. In contrast, the Galerkin method
demands that the residual should be orthogonal to each of the ﬁrst N basis functions. The
accuracy difference between the two discretization strategies is negligible for large N, so
collocation is usually preferred because of it requires fewer computations and less pro-
gramming (Chapter 4).
For small N, however, Galerkin’s method may be two or three times more accurate than
collocation. To put it another way, the rule of thumb quoted in Chapter 3, Sec. 9, is that
the Galerkin solution with N = m is usually as accurate as the pseudospectral solution
with N = m + 1 or m + 2, provided that the solution is sufﬁciently smooth that a small
N is sufﬁcient to resolve it. Since the complexity of a symbolic answer usually grows
exponentially with N, we must reverse the usual precept, and suggest that for calculations
in Maple or REDUCE, etc., one should use Galerkin’s method wherever possible.
Unfortunately, when a problem is cursed with an exponential nonlinearity as for the
Bratu equation, uxx + exp(u) = 0, Galerkin’s method may be completely unfeasible. How-
ever, it may be still be possible to get a simple but accurate answer by using collocation, as
in Boyd (1986c), Finlayson (1973) and our Example Two.
In ﬂoating point computations, it is almost always necessary, unless N is very small,
to represent both the basis functions and the weight functions as orthogonal polynomials.
Because algebraic manipulation languages compute in exact, rational arithmetic wherever
possible and also because N is very small, one may use the equivalent powers of x as
both basis functions and as the Galerkin test functions, in which case Galerkin’s method is
usually called the “method of moments”. Numerical ill-conditioning, which is a perennial
worry in high resolution number-crunching, is almost never a worry in symbolic manipu-
lation.
A second issue is the choice of the basis functions. As explained in Chapter 2, the
Chebyshev and Legendre polynomials are part of a large family (“Gegenbauer polynomi-
als”) which are orthogonal on the interval [-1, 1] with weight function w(x) = (1 −x2)α.
The Chebyshev polynomials are the special case α = −1/2; the Legendre are α = 0, i. e., no
weighting at all. The Chebyshev weighting, heavily biased towards the endpoints, is op-
timum for expanding general functions; the Legendre error is smaller than the Chebyshev
over most of the interval, but is much larger (roughly by O(N 1/2) ) near the endpoints as
illustrated in Sec. 13 of Chapter 2.
The solution to a boundary value problem is not arbitrary, however; its boundary be-
havior is strongly constrained by the boundary conditions. Therefore – especially for an
approximation with a very small number of degrees of freedom – it is preferable to replace
Chebyshev polynomials by Legendre polynomials or perhaps even Gegenbauer polyno-
mials of larger α (Finlayson, 1973). If α is a positive integer, there is the further beneﬁt that

464
CHAPTER 20. SYMBOLIC CALCULATIONS
the Galerkin integrals are simpler because of the absence of the square root of the Cheby-
shev weight, increasing the probability that the integration routines, built-in to all major
algebraic languages, will be able to perform the integrations analytically.
The third strategic suggestion has no counterpart in numerical calculations: It is to
convert all transcendental functions to polynomials. A Fourier cosine series, for example,
can be converted into a Chebyshev series by making the change of variable t = arccos(x)
and using the identity Tn(x) = cos(nt) for all n. The rational Chebyshev functions, which
are a basis for inﬁnite and semi-inﬁnite domains (Chapter 17), are also just Chebyshev
polynomials after a change of variable. Similarly, powers of sech(x), which often arise in
soliton theory, can be “polynomialized” by deﬁning z = tanh(x) and applying the identity
sech2(x) = 1 −tanh2(x) = 1 −z2. Lastly, transcendental coefﬁcients of a differential
equation can be approximated by polynomials. The error in
cos([π/2]x) ≈1 −0.4967(πx/2)2 + 0.03705(πx/2)4,
(20.1)
for example, is less 0.0009 on x ∈[−1, 1].
It is often convenient to delay “polynomialization” until an intermediate stage. Maple,
for example, can differentiate and multiply trigonometric polynomials and then convert
them to a standard Fourier series through the “combine(expression,trig)” command. How-
ever, it has no command to pick off the coefﬁcients of a Fourier series, so polynomializa-
tion through a command like “subs(z=cos(x),z**2=cos(2*x), z**3=cos(3*x), expression)” is
essential to exploiting the “coeff” command, which does return a particular coefﬁcient of a
polynomial.
Algebraic manipulation languages are more efﬁcient at calculations with integers and
rational numbers than ﬂoating point numbers, so the fourth strategy is “rationalization”,
that is, converting ﬂoating point numbers to rational numbers.
The usual collocation
points, for example, are the irrational roots or extrema of the (N + 1)-st basis function.
When collocation, as opposed to the preferred Galerkin method, is necessary, it is usually
better to approximate an irrational collocation point such as (1/5)1/2 = 0.44721 . . . by a
rational number such as 4/9 = 0.444 . . . . For small N, the error is small. Other ﬂoating
point numbers in the boundary conditions, differential equation, etc., should usually be
“rationalized” too.
Arnold (1983) shows that for any irrational number µ, there exists a sequence of rational
approximations, p/q, which converge to µ. The error of a given member of the sequence is
less than the reciprocal of the square of the denominator, i. e.,
|µ −p/q| < 1/q2
(20.2)
The well-known approximation π ≈355/113, which has a relative error of less than 10−6,
was long thought to be very special. What (20.2) shows, in words, is that for any µ, there ex-
ists an approximation with a three-digit denominator and six-digit accuracy. The sequence
of optimum rational approximations can be computed by an algorithm known variously as
the “Euclidean algorithm”, “algorithm of continued fractions”, or “the algorithm of stretch-
ing the noses” (Arnold, 1983). The ﬂoating point coefﬁcients in (20.1) can be approximated
by 75/151 and 1/27, for example, with errors of only 0.00011 and 0.000014, respectively.
There are two major exceptions to “rationalization”. First, when the answer depends
only a single irrational such as 21/2, it may be more efﬁcient to carry a symbolic variable
ROOT2 through the remainder of the algebra than to replace it by a rational number. The
second is that rationalization may be unnecessary if the later stages of the computation
have to be done numerically, as often happens. It is not, alas, unusual to see hundred
digit numbers when a long calculation is performed in exact arithmetic (“integer swell”) as
shown in Table 20.5 below. The precepts in Table 20.1 should be interpreted as suggestions
and guidelines rather than commandments. Let common sense be the highest law!

20.3. EXAMPLES
465
Table 20.2: Maple program for Example One: Linear BVP with Boundary Layer
u:= (1-x*x) * (a0 + a1*x*x + a2*x**4 + a3*x**6);
R4:=tau*tau*diff(u,x,x) - u + 1;
eq0:=integrate(R4,x=-1..1); eq1:=integrate(R4*x*x, x=-1..1);
eq2:= integrate(R4*x**4, x=-1..1); eq3:= integrate(R4*x**6, x=-1..1);
solve( eq0, eq1, eq2, eq3, a0, a1, a2, a3 );
A couple of other important pieces of advice have been omitted from the table because
they are not inversions of usual practice. First, exploiting parity and other symmetries
(Chapter 8) is always highly advantageous in numerical calculations. The sort of simple,
idealized problems that are amenable to symbolic spectral methods are precisely the kind
of problem that are most likely to have symmetries. Therefore, the standard precept: Look
for Symmetry! is redoubled for symbolic computations.
Second, one may impose boundary conditions through either “boundary-bordering”
or “basis recombination” as explained in Chapter 6. In symbolic calculations, the latter is
strongly preferred because incorporating the boundary conditions into the basis functions
may halve the number of degrees of freedom, and enormously reduce the complexity of the
algebraic formula which is the answer. Furthermore, it is particularly easy to incorporate
homogeneous boundary conditions into a symbolic answer: for homogeneous Dirichlet
conditions: Multiply the trial solution by (1 −x2).
20.3
Examples
All examples were programmed in REDUCE or Maple. The choice of languages has no
particular signiﬁcance except that both are widely used and the author knows them.
Example One: Linear ODE BVP (Carrier & Pearson, 1968)
ϵ2uxx −u = −1;
u(−1) = u(1) = 0
(20.3)
where ϵ is a constant. The exact solution is
u(x) = 1 −cosh(x/ϵ)/ cosh(1/ϵ)
(20.4)
Because u(x) is symmetric, we shall assume an expansion in even powers of x. Fur-
ther, we incorporate the homogeneous boundary condition into the series. Arbitrarily, we
choose N = 4:
u4(x) = (1 −x2)
©
a0 + a2x2 + a4x4 + a3x6ª
(20.5)
Substituting (20.5) into (20.3) gives the residual function
R4
≡
ϵu4,xx −u4 + 1
(20.6)
=
1 −
©
[1 + 2ϵ2]a0 −2ϵ2a2
ª
+
©
a0 −[1 + 12ϵ2]a1 + 12ϵ2a2
ª
x2
+
©
a1 −[1 + 30ϵ2]a2 + 30ϵ2a3
ª
+
©
a2 −[1 + 56ϵ2]ϵ2a3
ª
x6 + a3x8
Because u(x) has a boundary layer of width O(ϵ) – all the variation of u(x) is close to the
endpoints – we shall not include a factor of (1 −x2) in the Galerkin conditions, but instead
demand that the unweighted integrals of R4 with each of the ﬁrst four even powers of x
should be zero:
Z 1
−1
x2j R4(x; a0, a1, a2, a3)dx = 0,
j = 0, 1, 2, 3
(20.7)

466
CHAPTER 20. SYMBOLIC CALCULATIONS
Table 20.3: The maximum pointwise errors in the four-term Legendre approximation as a
function of the parameter ϵ for Example One: Linear BVP with Boundary Layer
ϵ
L∞error
1/20
0.081
3/40
0.030
1/10
0.012
3/20
0.0046
1/5
0.00040
1/4
0.000099
3/10
0.000028
4/10
0.0000033
1/2
0.00000056
3/4
1.7E-8
1
1.3E-9
This gives four equations in four unknowns. This can be cast as a matrix equation of the
form H A = F and solved in REDUCE by the single statement A:=(1/H)*F. A REDUCE
program for general 2d order BVPs is Table 17-1 of the ﬁrst edition of this book (Boyd,
1989a); the equivalent Maple program is Table 20.2;.
The solution is
a0
=
3(43243200ϵ6 + 2162160ϵ4 + 27720ϵ2 + 31)/D(ϵ)
a1
=
33(327600ϵ4 + 41)/D(ϵ)
a2
=
429(840ϵ2 −13)/D(ϵ)
a3
=
6435/D(ϵ)
(20.8)
D(ϵ) = 128(2027025ϵ8 + 945945ϵ6 + 51975ϵ4 + 630ϵ2 + 1)
(20.9)
Observe that the residual function R4 – and therefore the elements of the matrix equa-
tion – are quadratic in ϵ. The coefﬁcients of the spectral series aj are rational functions of ϵ
with numerator and denominator polynomials of degree no higher than the degree of ele-
ments of H multiplied by N, that is 2 · 4 = 8. This rational dependence upon a parameter
is not special to this equation, but is a consequence of the following.
Theorem 39 (MATRICES WHOSE ELEMENTS DEPEND on a PARAMETER)
Let the
elements of a matrix H of dimension N be polynomials in a parameter ϵ of degree at most k and let
A denote the column vector which solves HA = F where F is a column vector whose elements are
polynomials in ϵ of degree at most m. Then (i) det(H) is a polynomial in ϵ of degree at most Nk.
(ii) The elements of A are rational functions of ϵ. The degree of the numerator is k(N −1) + m; the
degree of the denominator is kN.
The proof is a trivial consequence of Cramer’s Rule for solving matrix equations (Vino-
grade, 1967, pg. 60) and the deﬁnition of a determinant (op. cit., pg. 169). Q. E. D.
The boundary layer is so narrow for ϵ = 1/10 that the half-width of the layer is only
0.07, that is, 50% of the drop of u(x) from its maximum to zero occurs between x = 0.93 and
x = 1. Nevertheless, the maximum pointwise error of the four-term Legendre-Galerkin
approximation is only 0.017. Table 20.3 shows that the error is no worse than 8% even for ϵ
as small as 1/20.

20.3. EXAMPLES
467
Like all spectral approximations, u4(x; ϵ) is highly uniform in the coordinate x, but this
does not imply uniformity in the parameters. In this example, the error is highly non-
uniform in the parameter ϵ.
Example Two: The Quartic Oscillator of Quantum Mechanics
The special challenge of this eigenvalue problem is that it is posed on an inﬁnite inter-
val.
uyy + (E −y4)u = 0,
y ∈[−∞, ∞]
(20.10)
with the boundary condition
|u| →0
as |y| →∞
(20.11)
where E is the eigenvalue, the energy of the quantum bound state. The rational Chebyshev
functions described in Boyd (1987a) and in Chapter 17 are a good basis set for the inﬁnite
interval. To “polynomialize” these rational functions and simplify the integrals, make the
change of variable
y = Lx/
p
1 −x2
(20.12)
where L is a user-choosable constant (“map parameter”). By using the chain rule or Table
E-5 here, this change-of-coordinate transforms the problem into
(1 −x2)4 ©
(1 −x2)uxx −3xux
ª
/L2 +
©
(1 −x2)2E −L4x4ª
u = 0
(20.13)
x ∈[−1, 1],
u(±1) = 0
(20.14)
The rational Chebyshev functions are converted into ordinary Chebyshev polynomials by
this transformation, so both the inﬁnite interval and rational basis functions are swept
under the rug by the mapping (20.12).
The solution is not very sensitive to the map parameter L as long as it roughly matches
the scale of the basis functions to the width of u(x); we somewhat arbitrarily set L = 2.
One can prove that the eigenfunctions of (20.10) are all symmetric (for even mode num-
ber) or antisymmetric (for odd mode number). To compute the lowest few symmetric
modes, we set
u = (1 −x2){a1 + a2x2 + a3x4 + a4x6 + a5x8}
(20.15)
Table 20.4: Maple program for Example Two: Quartic Oscillator
Q:=1-x*x; L:=2; # L=map parameter;
u:=(1-x*x)*(a1+a2*x*x+a3*x**4+a4*x**6+a5*x**8);
R:=Q**4 *(Q*diff(u,x,x)-3*x*diff(u,x) )/(L*L) + (lamb*Q*Q - L**4 * x**4 )*u;
# E is a Maple reserved symbol, so we use “lamb” for the eigenvalue
# To use Gegenbauer polynomials of ﬁrst order instead of Legendre,
# multiply the integrand in the loop by (1-x*x);
for ii from 1 by 1 to 5 do eq.ii:=integrate(x**(2*ii-2)*R,x=-1..1); od:
with(linalg); J:=matrix(5,5);
for ii from 1 by 1 to 5 do for j from 1 by 1 to 5 do
J[ii,j]:=coeff(eq.ii,a.j,1);
od;
od;
secdet:=simplify(det(J)); # secdet=D(E)
Eigenvalue:=fsolve(secdet,lamb);

468
CHAPTER 20. SYMBOLIC CALCULATIONS
Table 20.5: Errors for Example Two: Quartic Oscillator
Exact
w(x) = 1: Legendre
w(x) = (1 −x2): Gegenbauer
n
Eexact
Enumerical
Error
Enumerical
Error
0
1.060
1.065
0.005
1.061
0.001
2
7.456
7.655
0.199
7.423
-0.033
4
16.26
17.38
1.12
17.17
0.91
6
26.528
64.32
Huge
42.53
Huge
8
37.92
715.66
Huge
330.7
Huge
We converted the differential equation into a 5-dimensional matrix problem by de-
manding that the integral of the residual with the test functions {1, x2, x4, x6, x8} should
be 0. Since the matrix equation is homogeneous, it has a solution only if its determinant
D(E) = 0. The vanishing of this “secular determinant”, to borrow the usual terminology
of quantum mechanics, determines the eigenvalue E.
Table 20.4 is a short Maple program which produces
D(E) = 1 −1.143E + 0.203E2 −0.0102E3 + 0.000124E4 −0.000000153E5
(20.16)
after the coefﬁcients have been converted to ﬂoating point numbers. The exact determi-
nant, given in Boyd (1993), illustrates “integer swell”: the coefﬁcients are ratios of as many
as 29 digits divided by 35 digits. Table 20.5 lists the roots, the exact eigenvalues (from Ben-
der and Orszag, 1978, pg. 523), and the absolute errors. As is usual in numerical solutions
to eigenvalue problems, the lowest numerical eigenvalue is very accurate, the eigenvalues
up to roughly N/2 are of decreasing accuracy, and the upper few eigenvalues of the N = 5
matrix bear no useful resemblance to those of the differential equation. The accuracy of the
lowest root is quite good for such a low order approximation. For comparison, we redid
the problem with the inner product weight of (1 −x2) instead of 1. As suggested in the
previous section, there is a striking improvement in accuracy, at least for the lowest two
modes.
Example Three: Branching (Bifurcation) for the Fifth-Order KdV Equation
The twist in this problem (Boyd, 1986a) is that the equation depends nonlinearly on the
eigenparameter a. This is a serious complication for conventional software, but computer
algebra problems are indifferent as to whether the matrix is linear or nonlinear in a.
The problem is to compute a solution to the homogeneous, linear equation
−∆xxxxx −c∆x + {U(x; a)∆}x = 0
(20.17)
∆(x) = ∆(x + 2π)
∀x
(20.18)
where U(x; a) is the “cnoidal wave” of the Fifth-Order Korteweg-deVries equation (FKdV),
that is, a spatially periodic solution to the nonlinear eigenvalue problem
−Uxxxxx −cUx + UUx = 0
(20.19)
U(x) = U(x + π)
for all x
(20.20)
where c(a) is the eigenvalue and the one-parameter family of cnoidal waves is parame-
terized by a, the amplitude of cos(2x) in the Fourier series for U(x; a). The physical back-
ground is rather complicated (Boyd, 1986a), but the salient facts are these. The cnoidal

20.3. EXAMPLES
469
waves which solve (20.19) have a period of π, are symmetric with respect to x = 0, and
exist for all real values of a. For sufﬁciently large amplitudes, (20.19) also has “bicnoidal”
solutions which have a period of 2π – double that of the cnoidal waves – and two peaks
ﬂanking the origin. For some value of a, the bicnoidal waves are a subharmonic bifurcation
from the cnoidal wave. Away from the bifurcation, the linearized equation for small per-
turbations to the cnoidal wave, (20.17), has no solution except the trivial one. At the bifur-
cation point, however, (20.17) has a nontrivial eigensolution because the solution to (20.19)
is no longer unique. The cnoidal and bicnoidal solutions coexist at the bifurcation; near
but not actually at the bifurcation point, the bicnoidal wave is approximately described by
ubicnoidal(x) ≈U(x; a) + g∆(x) for some constant g where ∆(x) is the eigensolution (with
zero eigenvalue) of (20.17).
To determine the bifurcation point, we must ﬁrst compute U(x; a) and then substitute
the result into (20.17). When the linearized equation is discretized by a spectral method,
the resulting matrix equation will have a nontrivial solution if and only if the determinant
∆(a) = 0. Thus, the bifurcation point a = abifurcation can be found by computing the roots
of the determinant ∆(a).
To compute the cnoidal wave, we could apply the spectral method to (20.19) followed
by one or two Newton’s iteration. It turns out, however, that the bicnoidal wave bifurcates
at such a small amplitude that the cnoidal wave is adequately approximated at the bifur-
cation point by the ﬁrst two terms of its perturbation series (“Stokes’ expansion”) (Boyd,
1986a):
U(x; a) ≈a cos(2x) + [a2/960] cos(4x)
(20.21)
c(a) ≈−16
©
1 −a2/30720
ª
(20.22)
Exploiting the known symmetry of ∆(x), we assume a Fourier series and choose N = 4:
∆(x) ≈a1 cos(x) + a2 cos(2x) + a3 cos(3x) + a4 cos(4x)
(20.23)
Because the equation contains only odd derivatives of ∆, all the cosines are turned into
sines. Therefore, we demand that the residual should be orthogonal to the ﬁrst four sine
functions, which converts (20.17) into the 4 x 4 matrix system
−28800 −960a + a2
0
−960a −a2
0
a1
0
0
0
0
−1920a
a2
=
0
−960a −a2
0
124800 + a2
0
a3
0
0
−960a
0
460800 + a2
a4
0
(20.24)
In a standard eigenvalue problem, the matrix elements are all linear functions of the
eigenparameter a, but here the elements are quadratic in a. Nevertheless, taking the deter-
minant of (20.24) gives a polynomial in a which can be solved for the bifurcation point:
∆(a) = a2 (3a3 + 860a2 + 124800a + 3744000)
(20.25)
The only nonzero root is abifurcation = −39.10; the exact value is -39.37, an error of only
0.7%.
The other real root, a = 0, is the limit point of the cnoidal wave, legitimate but irrelevant
and trivial.
The checkerboard of zeros in the Galerkin matrix implies that even and odd terms in the
cosine series are uncoupled; we could have obtained the same answer by keeping only the
cos(x) and cos(3x) terms in (20.23) as done in Boyd (1986a). Overlooking a symmetry will

470
CHAPTER 20. SYMBOLIC CALCULATIONS
never give an incorrect answer, but it will give an unduly complicated and inaccurate one
for a given N. We would have obtained a similar checkerboard of zeros for Example Three
if we had not assumed a symmetric basis set to compute symmetric eigenmodes only.
Example Four: Reduction of a Partial Differential Equation to a Set of Ordinary Differ-
ential Equations: An Unorthodox Derivation of the Korteweg-deVries Equation
Spectral methods can be applied to reduce partial differential equations directly to an
algebraic system for the spectral coefﬁcients. Sometimes, as illustrated by this example, it is
more useful to apply the spectral method only in one coordinate, reducing the problem to
a system of ordinary differential equations in the remaining dimension. The ODE system
can often be solved analytically, sometimes even when it is nonlinear as here.
To illustrate the possibilites, we analyze the travelling-wave solutions of the so-called
“Ageostrophic Equatorial Wave” or “AEW” equation (Boyd, 1991b):
uxx + uyy −y2u −u/c −yu2/c = 0,
x, y ∈[−∞, ∞]
(20.26)
|u(x, y)| →0 as |y| →∞
(20.27)
and various boundary conditions in x. The phase speed c is the eigenvalue In the limit of
inﬁnitesimal amplitude, this nonlinear eigenvalue problem has solutions of the form
u(x, y) = cos(kx) ψn(y),
c = −1/(2n + 1 + k2)
(20.28)
where ψn(y) is the n-th Hermite function. This suggests that the Hermite functions, which
individually satisfy the latitudinal boundary condition of decay, would be a good spectral
basis set.
The Hermite functions have deﬁnite parity with respect to y = 0, the equator, and one
can show that the nonlinear term does not disrupt this symmetry. Therefore, to look for
general, nonlinear solutions which are antisymmetric with respect to y = 0, it is sufﬁcient
to assume an expansion in the Hermite functions of odd n only:
u ≈A1(x)2y exp(−0.5y2) + A3(x)
©
8y3 −12y
ª
exp(−0.5y2)
(20.29)
Table 20.6: Maple Listing for Example Four: Reduction of a Partial Differential Equation
u:=exp(-y*y/2)*(a1(x)*2*y + a3(x)*(8*y*y*y-12*y));
R:=diff(u,x,x)+diff(u,y,y)-y*y*u-u/c-y*u*u/c;
# Next substitution is necessary because the presence of x-operators;
# will defeat the y-integration routine. This is a workaround.;
R:=subs(diff(a1(x),x,x)=A1xx,diff(a3(x),x,x)=A3xx,a1(x)=A1,a3(x)=A3,R);
integrand1:=R*2*y*exp(-y*y/2);
integrand3:=R*(8*y*y*y-12*y)*exp(-y*y/2);
# More workarounds. First, we apply Maple simpliﬁcation &;
# expansion operators. Then, we use a special Maple command to do;
# the integrations term by term;
integrand1:=expand(simplify(integrand1)); integrand3:=expand(simplify(integrand3));
eq1:=0: eq3:=0:
for piece in integrand1 do eq1:=eq1+integrate(piece,y=0..inﬁnity) od:
for piece in integrand3 do eq3:=eq3+integrate(piece,y=0..inﬁnity) od:
eq1:=expand(eq1); eq3:=expand(eq3);
# Pick off the coefﬁcient of A1xx, A3xx, and call them div1, div3;
div1:=coeff(eq1,A1xx,1); div3:=coeff(eq3,A3xx,1);
eq1:=expand(simplify(eq1/div1)); eq3:=expand(simplify(eq3/div3));
eq1f:=evalf(eq1); eq3f:=evalf(eq3);

20.3. EXAMPLES
471
and similarly at higher order. By applying the usual Galerkin method, we obtain (for N =
2) the set of two coupled nonlinear equations in two unknowns:
A1,xx
−(3 + 1
c)A1
−1
c 1.09A2
1 −1
c 1.45A1A3 −1
c 19.8A2
3 = 0
A3,xx
−(7 + 1
c)A3
−1
c 5.93A2
3 −1
c 1.65A1A3 −1
c 0.0302A2
1 = 0
(20.30)
The Maple listing is Table 20.6.
This example demonstrates one of the strengths of algebraic manipulation: Correction
of errors in hand calculations. The set (20.30) was originally given in Boyd (1989e), but
with the coefﬁcient of A1A3 in the second equation equal to 0.82 instead of the correct
value shown above. The error was found only when the derivation was repeated using
computer algebra.
When (20.30) is further approximated by setting one or the other of the unknowns to
zero, the result is the travelling-wave form of the Korteweg-deVries equation. The general
solution of this N = 1 approximation is an elliptic function; limiting cases are inﬁnitesimal
cosine waves (which recovers (20.28)) and solitary waves.
When both modes are retained, the result is the system (20.30) which cannot be analyti-
cally solved. However, “maximally simpliﬁed” models like the two-mode system are often
very useful in illuminating complicated behavior. E. N. Lorenz employed this philosophy
in modelling two-dimensional convection by a system of three ordinary differential equa-
tions which had been previously derived by B. A. Saltzman. Lorenz’ discovery of chaos
in this system, which now bears his name, was a great milestone in the theory of chaotic
dynamics, strange attractors, and fractals. Similarly, Boyd (1989e) shows that a two-mode
model is the smallest which displays the “weakly nonlocal” solitary waves of the full AEW
equation.
The single-mode approximation, which is just the KdV equation, is usually obtained
by a very different route which employs the singular perturbation technique known as
the “method of multiple scales” (Bender and Orszag, 1978, Boyd, 1980c). The end result,
though, is identical with applying the spectral method with a single basis function. The
perturbative analysis is really just a systematic way to answer the question: When is a
one-mode approximation justiﬁed? The answer is that when the solitary wave is very
wide with a length scale which is O(1/ϵ) and an amplitude of O(ϵ2) where ϵ << 1 is a
small parameter, then the nonlinear terms coupling A1(x) with A3(x) will be small. The
self-interaction term cannot be neglected, however, if the corresponding linear term is also
small, i. e., of O(ϵ4). This happens when the phase speed differs from the k = 0 (“long
wave”) limit of the linear phase speed by an amount of O(ϵ2). It is also necessary to use a
spectral basis whose functions have the structure of the inﬁnitesimal waves, i. e., Hermite
functions for this example.
The formal justiﬁcation for small ϵ is heartening, but experience with the method of
multiple scales (and few-mode models) is that both are often qualitatively accurate even
when ϵ ∼O(1), that is, far outside their region of formal accuracy (Bender and Orszag,
1978, Finlayson, 1973). The symbolic spectral method is a very quick and general alterna-
tive to the perturbation theory.
The only caveat is one illustrated by all the examples above: To get the most out of
the spectral method (or any other solution algorithm), it is important to understand the
physics. Does u(x) have a boundary layer? Is it smooth so that small N will be okay, or does
it have a complicated structure that will require very large N (and probably make symbolic
calculations unfeasible)? Is some choice of basis functions, such as Hermite functions for
the AEW equation, particularly well-matched to the solutions? Computer algebra and
numerical calculations are not alternatives to analysis but merely its extension.

472
CHAPTER 20. SYMBOLIC CALCULATIONS
20.4
Summary and Open Problems
There has been considerable progress in marrying spectral methods with algebraic ma-
nipulation languages as summarized here and in the review, (Boyd, 1993). None of the
guidelines should be interpreted too rigidly; a couple of examples deliberately broke some
of the precepts of earlier sections to emphasize the need for common sense.
The major open problem is coping with nonlinearity. The examples above show some
success, but only for fairly easy problems. Perturbation expansions or a single Newton
iteration may be essential in obtaining an answer which is simple enough to be useful.
Fox and Parker (1968) summarize a large body of hand calculations which exploited
recurrence relations of the Chebyshev polynomials instead of Galerkin’s method. These
recurrences signiﬁcantly improve accuracy for small N. This line of attack has been contin-
ued by Ortiz and his students as reviewed in Chapter 21. The Galerkin method is simpler
and more general, so we have omitted these alternative Chebyshev algorithms from this
discussion. However, these recurrences lend themselves well to symbolic computations.
Algebraic manipulation is still dominated by a “perturbation-and-power series” men-
tality. However, there is much more to symbolic mathematics than perturbation series or
the derivation of exact algebraic relationships. The main algorithms of this work, spec-
tral methods and Newton’s iteration, are still badly underutilized in symbolic calculations.
Perhaps some readers will change this.

Chapter 21
The Tau-Method
“I never, never want to be a pioneer . . . It’s always best to come in second, when you can
look at all the mistakes the pioneers made — and then take advantage of them.”
— Seymour Cray
21.1
Introduction
The tau-method is both an algorithm and a philosophy. It was invented by Cornelius Lanc-
zos in the same (1938) paper that gave the world the pseudospectral method.
As an algorithm, the tau-method is a synonym for expanding the residual function as
a series of Chebyshev polynomials and then applying the boundary conditions as side
constraints. Thus, it is indistinguishable from what we have earlier described as Galerkin’s
method with “boundary bordering”. The formal deﬁnition is the following.
Deﬁnition 43 (Tau-Method) A mean-weighted residual method is a TAU-METHOD if the “test
functions” are the Chebyshev polynomials and the inner product is the usual Chebyshev integral
inner product.
For example, to solve a second order ODE with u(−1) = u(1) = 0, the τ-method would
impose the constraints
(Tm, R(x; a0, . . . , aN) = 0
m = 0, . . . , N −2
(21.1)
N
X
n=0
an Tn(±1) = 0
(21.2)
where the {an} are the Chebyshev coefﬁcients of u(x) and R(x; a0, . . . , aN) is, as usual,
the residual function obtained by substituting the truncated Chebyshev series into the dif-
ferential equation.
In contrast, Canuto et al. (1988) prefer to apply the label “Galerkin” only to that mean
weighted residual method that chooses the “test” functions to be basis functions that satisfy
the homogeneous boundary conditions. For example,
(φm, R(x; b2, . . . bN) = 0
m = 2, . . . , N
(21.3)
473

474
CHAPTER 21. THE TAU-METHOD
where the basis functions are
φ2n(x) ≡T2n(x) −1
;
φ2n+1(x) ≡T2n+1(x) −x
(21.4)
These two methods do give slightly different answers because the two highest-degree con-
straints in (21.3) involve the inner product of the residual with TN−1(x) and TN(x) whereas
the highest Chebyshev polynomial multiplying the residual in the tau-method inner prod-
uct (21.1) is only TN−2(x). For this reason, this terminological distinction is popular in
the literature (Gottlieb and Orszag, 1977, for example). However, the accuracy differences
between the “tau” and “Galerkin” methods are likely to be negligible.
At the end of the chapter, we will return to issues of nomenclature.
First, however, we shall discuss the philosophy of the τ-method. Lanczos recognized
that there are two ways of attacking a differential equation. The obvious approach is to
compute an approximate solution to the exact, unmodiﬁed differential equation. The sec-
ond is to compute the exact solution to a modiﬁcation of the original differential equation.
If the “modiﬁcation” is small, then the solution to the modiﬁed problem will be a good
approximation to that of the original problem.
This second strategy — to solve approximate equations exactly — is the philosophy of the
τ-method. In the next section, we shall apply this tactic to approximate a rational function.
In Sec. 3, we shall extend this philosophy to differential equations. Finally, in Sec. 4, we
shall discuss Lanczos’ “canonical polynomials”, which have been the jumping-off point
for a long series of papers by E. L. Ortiz and his collaborators.
21.2
τ-Approximation for a Rational Function
Suppose the goal is to approximate a rational function f(x) by a polynomial fN of degree
N. Let
f(x) = Pp(x)/Qq(x)
(21.5)
where P(x) and Q(x) are polynomials of degree p and q, respectively. Substituting f →fN
and multiplying through by Q(x) gives
fN(x) Q(x) = P(x)
(21.6)
which has only polynomials on either side of the equal sign. At ﬁrst glance, it appears
that we could compute the (N + 1) coefﬁcients of fN(x) merely by matching powers of
x. However, the degree of fN(x)Q(x) is (N + q); thus, we have more conditions on the
coefﬁcients of fN(x) than we have unknowns to satisfy them.
Lanczos observed that there is an exact, polynomial solution to the perturbed problem
fN(x) Q(x) = P(x) + ϵ(x)
(21.7)
where ϵ(x) is a polynomial of degree (N + q) with q undetermined coefﬁcients. Eq. (21.7)
has polynomials of degree (N + q) on both sides with a total of (N + q + 1) unknowns.
Matching the powers of x in (21.7) gives a set of (N + q + 1) linear equations to determine
the unknown coefﬁcients of fN(x) and ϵ(x).
The secret to success is to choose ϵ(x) — more accurately, to choose N + 1 of the (N +
q + 1) coefﬁcients of ϵ(x) — such that the perturbation is small in some appropriate sense.
The obvious choice is to set all ϵj = 0 for j ≤N. In this case, fN(x) is the usual power
series approximation to f(x).The trouble with this choice is that ϵ(x) is highly non-uniform;
because it is O(xN+1) for small |x|, this “power series perturbation” is very, very small near

21.2. τ-APPROXIMATION FOR A RATIONAL FUNCTION
475
the origin and then grows rapidly for larger x. The result is that (i) the accuracy of fN(x)
is similarly non-uniform (good for small |x| and increasingly bad as |x| increases) and (ii)
the error may be huge. Indeed, if |x| is larger than the absolute value of any of the roots
of the denominator, Q(x), then the approximation (which is just a truncated power series)
will diverge as N →∞even if f(x) is bounded and smooth for all real x.
Lanczos’ second key observation is that the Chebyshev polynomials oscillate as uni-
formly as possible on their canonical interval, [-1, 1]. It follows that if we deﬁne
ϵ(x) =
N+q
X
j=N+1
τj Tj(x)
[“Lanczos perturbation”]
(21.8)
the perturbation will spatially uniform in magnitude on x ∈[−1, 1] and so will the error
|f(x) −fN(x)|.
Of course, the error may still be large if the coefﬁcients τj are large. However, observe
that the coefﬁcients of ϵ(x) are simply those of the smooth function fN(x) Q(x) −P(x). We
saw in Chapter 2 that the coefﬁcients of any well-behaved function fall off exponentially
fast with N (for sufﬁciently large N), so that it follows that the τj will be exponentially
small, too, at least for N ≫1.
If we write
fN(x) ≡
N
X
n=0
fn Tn(x)
(21.9)
then the fn are determined by solving the linear equations
N
X
i=0
(Ti, Tj Q) fj = (Ti, P)
i = 0, . . . , N
(21.10)
where
τj = (Tj, P −fN Q)
j = N + 1, . . . , (N + q)
(21.11)
Several points are important.
First, it is not necessary to explicitly compute the τ-
coefﬁcients in order to determine the approximation fN(x); (21.11) is a second, separate
step that can be applied only after fN(x) has already been computed.
Second, the τ-approximation is not simply the Chebyshev expansion of f(x); the solu-
tion of the linear system (21.10), whose matrix elements are inner products of polynomials,
is usually different from the coefﬁcient integrals of the Chebyshev series of f(x), which
are the inner products of the Chebyshev polynomials with the rational function f(x). As
N →∞, of course, the differences between the τ-approximation, the Chebyshev series,
and the pseudospectral interpolant decrease exponentially fast with N.
Third, (21.10) is not the way Lanczos himself performed the calculation. In his time B. C.
(Before Computers), it was more convenient to represent fN(x) as an ordinary polynomial,
expand the Chebyshev polynomials in ϵ(x) as powers of x, and then match the powers
of x. This saved work, but it required simultaneously determining both fN(x) and ϵ(x).
Lanczos’ variant obscures the fact that it is possible to determine fN(x) independently of the
perturbation ϵ(x) if one represents all quantities as Chebyshev polynomials.
Fourth, the τ-coefﬁcients are useful for a posterior error analysis because
f(x) −fN(x) = ϵ(x)
Q(x) ≤
1
min |Q(x)|
N+q
X
j=N+1
|τ|
(21.12)

476
CHAPTER 21. THE TAU-METHOD
if we can ﬁnd a lower bound on Q(x) on x ∈[-1, 1]. In practice, this error analysis, although
highly praised in Fox & Parker (1968), is not useful in the age of microcomputers: it is easier
to simply evaluate the difference between f(x) and fN(x) for a large number of points and
take the maximum.
Furthermore, the τ-method is not normally the method of choice even for generating a
Chebyshev approximation to a given f(x). Numerically evaluating the inner products of
f(x) with the polynomials, i. e. the usual Chebyshev series, is easy and avoids the costly
inversion of a matrix. The τ-method is only useful in conjuction with algebraic manipula-
tion methods for small N where one wants an approximation with rational coefﬁcients or
where f(x) may contain symbolic parameters, making (21.11) more attractive.
Nevertheless, Lanczos’ philosophy of exactly solving a perturbed problem is useful in
other areas of applied mathematics. The technique that evolved from that philosophy is
still useful even today for solving differential equations.
21.3
Differential Equations
It is not possible to solve
ux + u = 0
&
u(−1) = 1
(21.13)
exactly as a polynomial. The residual function R(x; a0, . . . , aN) is a polynomial of degree
N, too, but the initial condition provides one constraint, leaving only N free coefﬁcients
in uN(x) to force the (N + 1) coefﬁcients of R(x) to vanish. Lanczos observed that the
modiﬁed problem
vx + v = τ TN(x)
&
v(−1) = 1
(21.14)
does have a unique solution. As before, if we take the inner product of (21.14) with each
of the ﬁrst N Chebyshev polynomials and reserve the ﬁrst row to impose the boundary
condition, we obtain an (N + 1) × (N + 1) system to determine the coefﬁcients of the
Chebyshev series for v(x) — independent of τ. We shall not bother to write down this
matrix equation because it is identical with “Galerkin’s method with boundary bordering”
as deﬁned in Chapter 3.
This example is solved in Fox & Parker by expanding TN(x) as an ordinary polyno-
mial and matching powers of x. This is more efﬁcient for hand calculation even though it
ignores the orthogonality of the Chebyshev polynomials and makes it necessary to deter-
mine τ simultaneously with the coefﬁcients of the power series representation of v(x). We
obtain the same answer either way; the important point is that the perturbation on the R.
H. S. in (21.14) is a Chebyshev polynomial, which guarantees spectral accuracy. In contrast,
perturbing (21.13) by a forcing proportional to xN would give a solution which would be
the ﬁrst (N + 1) terms of the power series of exp(−x −1), the exact solution.
Just as for the rational function, the error can be bounded by a function proportion to
τ. Just as for the rational function, this error analysis is usually not worth the bother.
For more complicated differential equations, the same principle applies except that it
may be necessary to use many τ terms or even an inﬁnite series.
21.4
Canonical Polynomials
Lanczos observed that one strategy for bypassing the cost of inverting an (N + 1) by (N +
1) matrix is to use what he dubbed the “canonical” polynomials. Note that for (21.13),

21.4. CANONICAL POLYNOMIALS
477
Table 21.1: A Selected Bibliography of Tau Methods
References
Comments
Lanczos(1938)
Invention of the tau method
Wragg(1966)
Lanczos-tau method for Stefan problem
Ortiz(1969)
Namasivayam&Ortiz(1981)
Best approximation and PDEs via tau method
Ortiz&Samara(1981,1983)
Operational approach: ODEs, eigenvalue eqs.
Liu&Ortiz&Pun(1984)
Steklov’s PDE eigenvalue problem
Ortiz&Pun(1985)
Nonlinear PDEs
Liu&Ortiz(1986)
PDEs through the tau-lines method
Ito&Teglas(1986,1987)
Legendre-tau for functional differential equations
and linear quadratic optimal control
Ortiz(1987)
Review: singular PDEs and tau method
da Silva(1987)
Review
Ortiz&Pham Ngoc Dinh(1987)
Recursions for nonlinear PDEs
Liu&Ortiz(1987a)
High order ODE eigenvalue problems; Orr-Sommerfeld Eq.
Liu&Ortiz(1987b)
Nonlinear dependence of linear ODE on eigenparameter
Liu&Ortiz(1989)
Functional-differential eigenvalue problems
Hosseini Ali Abadi
Non-uniform space-time elements for tau
& Ortiz(1991b)
simulation of solitons
Khajah&Ortiz(1992)
functional equations
Namasivayam&Ortiz(1993)
Error analysis for tau method
Khajah&Ortiz(1993)
Rational approximations via tau method
El-Daou & Ortiz
Uniﬁed approach to tau-method and
& Samara(1993)
Chebyshev expansions
El-Daou & Ortiz(1993)
Error analysis
El-Daou & Ortiz(1994a)
Recursive collocation with canonical polynomials
El-Daou & Ortiz(1994b)
Collocation/tau; weighting subspaces
Ortiz(1994)
Review
Dongarra&Straughan
Eigenvalue calculations
&Walker(1996)
Straughan&Walker(1996)
Compound matrix and tau for eigenproblems
in porous convection
Siyyam&Syam(1997)
Poisson equation
Froes Bunchaft(1997)
Extensions to theory of canonical polynomials
El-Daou&Ortiz(1997)
Existence & stability proofs for singular perturbation
problems, independent of perturbation parameter ϵ
it is trivial to obtain the solution when the R. H. S. is a power of x. These “canonical
polynomials” pj(x) are deﬁned as the solutions of
pj, x + pj = xj
;
pj(−1) = 1
(21.15)
Since each is the exact, power series solution to a simple problem, they can be computed
recursively.
Now TN(x) is a sum of powers of x, so it follows that the τ-solution of 21.14) is a sum
of the canonical polynomials. If we write
TN(x) =
N
X
j=0
tN,j xj
(21.16)
then
v(x) = τ
N
X
j=0
tN,j pj(x)
(21.17)

478
CHAPTER 21. THE TAU-METHOD
We then choose τ so that the boundary condition is satisﬁed — in this case, this requires
τ = 1/ P tN,j — and v(x) is completely determined. Since each pj(x) may be computed in
O(N) operations via recursion and since there are N polynomials, the total cost is O(N 2)
— a huge savings over the O(N 3) cost of matrix inversion.
The method of canonical polynomials is less efﬁcient when one needs several τ terms
instead of a single Chebyshev polynomial as sufﬁced for (21.13). Furthermore, the canoni-
cal polynomials are problem-dependent, and thus must be recomputed from scratch for each
differential equation.
Nevertheless, E. L. Ortiz and his collaborators have solved many problems including
nonlinear partial differential equations by combining the τ-method with the technique of
“canonical polynomials”. He and his group have made many reﬁnements to extend the
range of Lanczos’ ideas. The relevant articles are described in the bibliography. However,
the canonical polynomials method has never been popular outside of his group.
21.5
Nomenclature
We have not used this nomenclature of “tau-method” earlier in the book because from a
programmer’s viewpoint, the distinction is between “basis recombination” (=Galerkin’s)
and “boundary bordering” (=tau-method). The accuracy difference between (21.1) and
(21.3) is usually negligible. Furthermore, these same options of “basis recombination” and
“boundary bordering” also exist for collocation methods (although in this case, the accu-
racy difference is not merely small but zero). Lastly, when the test functions are different
from the basis functions, the label preferred by the ﬁnite element community is “Petrov-
Galerkin” rather than “tau-method”.

Chapter 22
Domain Decomposition Methods
“We stress that spectral domain decomposition methods are a recent and rapidly evolving
subject. The interested reader is advised to keep abreast of the literature.”
— Canuto, Hussaini, Quarteroni, and Zang (1988)
22.1
Introduction
The historical trend in both ﬁnite difference and ﬁnite element methods has been the re-
placement of second order schemes by higher order formulas. Indeed, ﬁnite elements have
ﬁssioned into “h-type” and “p-type” strategies. The former improve accuracy by reducing
the grid spacing while p, the order of the method, is kept ﬁxed. In contrast, “p-type” codes
partition the domain into a few large pieces (ﬁxed h) and reﬁne the solution by increasing
the degree p of the polynomial within each element.
In the last few years, the trend in spectral methods has been in the opposite direction:
to replace a global approximation by local polynomials deﬁned only in part of the domain.
Such piecewise spectral methods are almost indistinguishable from p-type ﬁnite elements.
These techniques are variously called “global elements”, “spectral elements”, “spectral
substructuring”, and a variety of other names. Since “domain decomposition pseudospec-
tral and Chebyshev-Galerkin methods” is rather a jawbreaker, we shall use “spectral ele-
ments” as a shorthand for all the various algorithms in this family.
There are several motives for “domain decomposition” or “substructuring”. One is
that spectral elements convert differential equations into sparse rather than dense matrices
which are cheaper to invert. A second is that in complicated geometry, it may be difﬁcult
or impossible to map the domain into a rectangle or a disk without introducing artiﬁcial
singularities or boundary layers into the transformed solution. Mapping the domain into
multiple rectangles and/or disks is much easier. A third reason is that mapping into secto-
rial elements can eliminate “corner singularities”.
It seems improbable that spectral elements will ever completely chase global expan-
sions from the ﬁeld, any more than higher order methods have eliminated second order
calculations. Nevertheless, they have become a major part of spectral algorithms and, as
noted in the quote above, an important research frontier.
479

480
CHAPTER 22. DOMAIN DECOMPOSITION METHODS
22.2
Notation
Ωwill denote the total domain, ∂Ωits boundary, and Ωj, j = 1, . . . , M, will denote its M
subdomains. Nj will denote the degree of the polynomial used to approximate u on the
j-th subdomain, and N ≡N1 + N2 + · · · NM is the total number of degrees of freedom on
the global domain. The numerical solution will be denoted by uN while uj will indicate
the restriction of the numerical solution to the j-th subdomain. In spectral elements, we
approximate u(x) by a collection of separate approximations which are each valid only
on a particular subdomain and are undeﬁned elsewhere. Thus, uN(x) is the collection of
polynomials while uj(x) is a single polynomial deﬁned only on Ωj.
22.3
Connecting the Subdomains: Patching
Deﬁnition 44 (PATCHING) Subdomains are connected by “PATCHING” if the solutions in dif-
ferent elements are matched along their common boundary by requiring that u(x) and a ﬁnite num-
ber of its derivatives are equal along the interface.
The number of matching conditions is the number that is necessary to give a unique solution in
each subdomain. As a rule-of-thumb, two matching conditions are equivalent to a single numerical
boundary condition. Thus, one must match both u(x) and du/dx at an interface for a second order
differential equation.
For ordinary differential equations and for elliptic partial differential equations, patch-
ing is usually straightforward. For example, suppose the goal is to solve a second order
ordinary differential equation on the interval x ∈[−1, 1] by splitting the segment into two
subintervals: [−1, d] & [d, 1]. If one knew u(d) [in addition to the usual Dirichlet boundary
conditions, u(−1) = α and u(1) = β], then the original problem would be equivalent to
two completely separate and distinct boundary value problems, one on each subinterval,
which could be solved independently of one another.
Unfortunately, we are rarely given three boundary conditions for a second order prob-
lem! However, by demanding that both u and du/dx are continuous at x = d, we obtain
two interface conditions which, together with the Dirichlet conditions at x = ±1, give a to-
tal of four constraints. This is precisely what is needed to uniquely determine the solution
of two otherwise independent boundary value problems of second order.
To be speciﬁc, let Ωdenote the interval x ∈[a, b] and
L u ≡q2(x) uxx + q1(x) ux + q0(x) u = f(x)
in Ω
(22.1)
u(a) = α
&
u(b) = β
(22.2)
The two-element subdomain solution may be mathematically expressed as
L u1 = f
in Ω1
&
u1(a) = α
(22.3)
and
L u2 = f
in Ω2
&
u2(b) = β
(22.4)
with the interface conditions
u1(d)
=
u2(d)
(22.5a)
u1,x(d)
=
u2,x(d)
(22.5b)

22.4. WEAK COUPLING OF ELEMENTAL SOLUTIONS
481
where the subscript “x” denotes differentiation with respect to x.
Patching for hyperbolic equations is more complex. The simplest such equation is
ut + c ux = 0
[“One-Dimensional Advection Eq.”]
(22.6)
on x ∈[a, b] where (c > 0)
u(a, t)
=
uL(t)
(22.7)
u(x, 0)
=
u0(x)
(22.8)
which has the exact solution
u(x, t) =





u0(x −c t)
x > (a + c t)
uL
µ
t −x −a
c
¶
x ≤(a + c t)
(22.9)
Thus, u(x, t) at a given point x0 is inﬂuenced only by events “upstream”, that is, by the
forcing and initial condition for x < x0. The solution at x = x0 is unaffected by downstream
values of the initial condition.
The numerical strategy which conforms to the mathematics of the exact solution is to
solve the wave equation independently on each element, one at a time, beginning at the left
boundary. The computed solution at the right of the j-th element provides the left-hand
boundary forcing for the (j+1)-st element.
If instead one uses an averaged interface condition such as
∂uN
∂t
+ c
2
∂uj
∂x + c
2
∂uj+1
∂x
= 0
at x = dj
(22.10)
the calculation may be unstable, at least if the number of grid points in element j is greater
than that in (j+1). Eq. (22.10) would seem to be stupid almost beyond belief since it both
increases the computational work and misrepresents the mathematics of the original prob-
lem. One would never want to apply (22.10) to a single scalar equation like (22.6). However,
when we solve a system of equations with waves travelling both to the left and the right, it
may be difﬁcult to apply anything better than ( 22.10).
The best approach, as reviewed by Canuto et al. (1988) and Kopriva (1986, 1987, 1989a,
1998, 1999), is to diagonalize the operator of the system of differential equations — either
exactly or approximately — so as to separate right-running and left-running waves. One
may then separately apply “upwind” conditions on each wave component. This is still
very much a research frontier.
22.4
The Weak Coupling of Elemental Solutions: the Key to
Efﬁciency
An important theme is that solutions on different subdomains are connected only through
the interface matching conditions, (22.5). Almost all spectral element methods exploit this
weak element-to-element coupling.
To illustrate how and why, consider a linear, second order different equation, i. e. (22.1)
and (22.2). Instead of just two subintervals as in the previous section, however, divide the
interval x ∈[a, b] into M subdomains. Let dj denote the boundary between element (j-1)
and element j and deﬁne
Uj ≡u(dj)
(22.11)

482
CHAPTER 22. DOMAIN DECOMPOSITION METHODS
Figure 22.1: Schematic of the interval [a, b] split into subdomains. The element boundaries
are denoted by dj; the values of u(x) at these boundaries are denoted by Uj. The solution
on the j-th element, uj(x), is the sum of a particular integral pj(x) plus the weighted con-
tributions of the homogeneous solutions hLj(x) and hRj(x). The schematic illustrates the
boundary conditions satisﬁed by each component.
The condition of continuity of u(x) at the domain boundaries may be enforced implicitly by
demanding that both uj−1(x) and uj(x) equal Uj at x = dj. These deﬁnitions are illustrated
in Fig. 22.1.
The solution on the j-th element, uj(x), can always be written as the sum of a particular
integral pj(x) plus two homogeneous solutions. One always has the freedom to choose
the particular integral so that it vanishes at both elemental boundaries. One may similarly
choose the homogeneous solutions so that one — call it hLj(x) — is equal to one at the
left domain boundary and zero at the other while hRj(x) is non-zero at the right boundary
but not at the left wall. If the differential equation is L u = f, these three components are
deﬁned by
L pj(x) = f
&
pj(dj−1) = pj(dj) = 0
[particular integral]
(22.12)
L hLj = 0
&
hLj(dj−1) = 1
&
hLj(dj) = 0
(22.13a)
[homogeneous solutions]
L hRj = 0
&
hRj(dj−1) = 0
&
hRj(dj) = 1
(22.13b)

22.4. WEAK COUPLING OF ELEMENTAL SOLUTIONS
483
These components are schematically shown in Fig. 22.1.
It follows that the general solution to the differential equation can be written — without
approximation — as
uj(x) = pj(x) + Uj−1 hLj(x) + Uj hRj(x)
(22.14)
This decomposition is useful because one can numerically compute all the particular in-
tegrals and homogeneous solutions intra-elementally — that is, calculate each pj(x) or
hLj(x) or hRj(x) independently of the solutions on all the other elements. The boundary
value problems deﬁned by (22.12) and (22.13) are completely uncoupled.
Unfortunately, the elemental solutions uj(x) are not completely speciﬁed because (22.14)
contains (M + 1) unknown parameters, Uj, the values of u(x) at the domain boundaries.
The two end values are determined by the boundary conditions for the original problem:
u(a) = α
→
U0 = α
&
u(b) = β
→
UM = β
(22.15)
The remaining domain boundary values of u(x) are determined by the requirement of con-
tinuity of the ﬁrst derivative at each of the (M −1) interior domain walls. This gives, using
primes to denote differentiation,
h′
Lj Uj−1 +
£
h′
Rj −h′
L, j+1
¤
Uj −h′
R, j+1 Uj+1 = p′
j+1 −p′
j
j = 1, . . . , M −1
(22.16)
where all functions are evaluated at x = dj. The reason that this matrix system is tridi-
agonal, soluble in only O(8M) multiplications and additions, is that only four different
homogeneous solutions, two for element (j −1) and two for element j, enter the conti-
nuity condition at x = dj. There are only three unknowns in each row of (22.16) because
Uj[≡u(dj)] is the coefﬁcient of both hRj(x) and hL,j+1(x).
Thus, the cost of coupling elements together via continuity of u(x) and du/dx is trivial.
The real work is in computing the particular and homogenous solutions on each element.
This may be done by whatever method — indeed, by whatever subroutine — one would
have employed to solve the boundary value problem by a single Chebyshev series on the
whole interval.
To compare the global expansion with the subdomain procedure, assume that the global
series has N degrees of freedom while N/M spectral coefﬁcients are used on each subdo-
main. If the cost to solve a boundary value problem with ν Chebyshev coefﬁcients is O(ν3)
operations and O(ν2) storage — true if the pseudospectral method is combined with Gaus-
sian elimination — then the relative costs are
Global:
O(N 3)
ops.
&
O(N 2)
store
(22.17a)
Subdomain:
M O([N/M]3) ops.
&
M O([N/M]2) store
(22.17b)
The spectral element method is cheaper by a factor of
1/M 2
operations
&
1/M
storage
(22.18)
These are enormous factors if M ≫1! Of course, to retain the high accuracy of spectral
elements, one must keep N/M ≥6 (or so). Furthermore, more efﬁcient methods for solv-
ing the boundary value problems, such as the preconditioned iterations discussed earlier,
would reduce the competitive advantages of the subdomain strategy versus the use of a
single global expansion. Nevertheless, even if (22.18) is a little optimistic, it still dramatizes
the potential of “spectral substructuring”.

484
CHAPTER 22. DOMAIN DECOMPOSITION METHODS
The key to efﬁciency is that most of the work is reduced to solving boundary value
problems intra-elementally, i. e. (22.12) & (22.13). If we assumed M different expansions
on each of the M elements and then lumped all the collocation, boundary, and continuity
conditions into a single matrix of dimension N, the subdomain method would be just as
expensive as using a single global expansion — and not as accurate. An efﬁcient spectral
element code is one that solves the global problem in two stages. The ﬁrst is to solve
many uncoupled smaller problems within each element. The second stage is to couple the
elemental solutions together into a single, continuous global solution.
22.5
Variational Principles
The heart of the variational formulation is to multiply the differential equation residual by
a test function and then integrate-by-parts so that a term like φi(x) φj,xx(x) becomes trans-
formed into the product of ﬁrst derivatives. When the basis functions are very low order
polynomials, this trick is important. For example, a popular ﬁnite element basis is com-
posed of piecewise linear polynomials, the so-called “tent” or “chapeau” functions. Since
the second derivative of these functions is identically zero, it is not possible to solve second
order equations with “tent” functions by collocation. After integration-by-parts, however,
the piecewise linear polynomials give second order accuracy.
For example, the self-adjoint boundary value problem
−[p(x) ux]x + q(x) u = f(x)
u(−1) = u(1) = 0
(22.19)
is equivalent to minimizing the functional
I(v) ≡
Z 1
−1
n
p(x) [vx]2 + q(x) v2 −2 v f(x)
o
dx
(22.20)
over the class of functions v(x) such that v(−1) = v(1) = 0. In practice, (22.20) is minimized
over a ﬁnite dimensional space of basis functions, {φj, j = 1, . . . , N}. The coefﬁcients of
the series for u(x) are determined by solving the matrix equation ⃗⃗H⃗a = ⃗F where
Hij ≡(φi,x, p φj,x) + (φi, q φj)
(22.21)
Fi ≡(φi, f)
(22.22)
(r, s) ≡
Z 1
−1
r(x) s(x) dx
(22.23)
Although (22.21) is justiﬁed by the calculus of variations, it is obvious that (22.21) is iden-
tical with the usual Galerkin matrix element except for use of the integration-by-parts
Z 1
−1
φi
¡
−[ p φj, x]x
¢
dx
→
Z 1
−1
φi, x p φj, x
(22.24)
(The boundary term, (φi(1) p(1) φj, x(1) −φi(−1) p(−1) φj, x(−1)), is zero because the basis
functions satisfy the boundary conditions (22.19).)
As noted above, the variational form is essential to successful use of piecewise func-
tions of ﬁrst degree to solve differential equations of second order. As the degree of the
polynomials increases, however, the advantage of the variational form becomes smaller
and smaller. This is the reason that the integrated-by-parts form (22.21) is rarely used with

22.6. CHOICE OF BASIS & GRID
485
global spectral methods; in comparison to the standard Galerkin procedure, the variational
matrix is not worth the bother.
The domain decomposition/variational principle strategy allows considerable ﬂexi-
bility. Delves and Hall (1979) add additional terms to the variational functional (22.20)
(“global elements”) so that the basis functions need not even be continous at the element
boundaries.
As the resolution is increased, however, the discontinuities in u decrease
rapidly, and the order-of-magnitude of these jumps is never larger than that of the maxi-
mum pointwise error.
Patera (1984), who dubbed his method “spectral elements”, takes a middle ground. His
basis functions belong to C0, that is, are continuous. However, continuity of the ﬁrst and
higher derivatives at inter-element boundaries is only approximate.
Phillips and Davies (1988), who also use the term “spectral elements”, employ basis
functions that are at least C1. Their basis explicitly satisﬁes all boundary conditions and
also obeys the element-interface conditions that are required to specify a unique solution
to the (undiscretized) problem.
The higher the degree of continuity, the smaller the matrix which discretizes the differ-
ential equation. With Delves’ and Hall’s “global elements”, the basis has extra degrees of
freedom — the freedom to be discontinuous on inter-element boundaries — which are ex-
plicitly eliminated in Phillips’ and Davies’ method. Furthermore, the variational functional
is simpler when the basis functions are C1 because the functional lacks the extra terms that
are needed to enforce continuity of u(x) if the basis functions are not continuous. Thus, in
principle, using basis functions with continuous ﬁrst derivatives would be optimum. In
practice, computing and manipulating basis functions in C1 may be very difﬁcult if the ge-
ometry is complicated, so the choice of the degree of continuity of the basis set must be left
to individual discretion. However, the C0 basis has become the most popular (Karniadakis
and Sherwin, 1999).
22.6
Choice of Basis & Grid: Cardinal versus Orthogonal
Polynomial, Chebyshev versus Legendre,
Interior versus Extrema-and-Endpoints Grid
Phillips and Davies (1988) use ordinary Chebyshev polynomials as the intra-element basis,
but it is far more common to use the Chebyshev or Legendre cardinal functions. The reasons
are similar to those that have made the pseudospectral method popular for global spectral
methods. The issue of Tn(x) versus cardinal function is not very important for boundary
value problems if the matrix problem is solved by direct methods, but — as true of global
algorithms — it is of paramount important when time-integration or iteration is applied.
In older books on ﬁnite elements such as Strang and Fix (1973), only a non-cardinal basis
was used. The drawback is that because the piecewise polynomials are not orthogonal,
the time derivatives for the differential equation du/dt = f(u, x, t) were multiplied, in
discretized form, by the so-called “mass matrix” ⃗⃗M. That is, the ﬁnite element method
converted a partial differential equation into the coupled system of ordinary differential
equations
⃗⃗M d⃗a
dt = . . .
(22.25)
where the ellipsis ( . . . ) denotes an unspeciﬁed right-hand side and where the elements of

486
CHAPTER 22. DOMAIN DECOMPOSITION METHODS
⃗⃗M are
Mij ≡(φi, φj)
“mass matrix”
(22.26)
In a non-cardinal basis, ﬁnite element methods are always implicit in the sense that one
must backsolve using the LU-factorization of the “mass matrix” at every time step.
If one shifts to a cardinal function basis and applies collocation instead of integration,
however, the new mass matrix is diagonal. This pseudospectral approach is essential for
efﬁcient, explicit time-integration, just as for global Chebyshev methods.
“Spectral elements” began with a Chebyshev basis, but Legendre polynomials have
become popular, too. One reason is that the usual drawbacks of Legendre polynomials —
collocation points that are not known in closed form, poorer accuracy near the boundaries,
and so on — are less important for polynomials of moderate degree than when N is large.
A more compelling reason is that the variational principle employs inner products with a
weight function of unity. Because the Chebyshev polynomials are orthogonal with respect
to a weight function of 1/
√
1 −x2, it is more awkward to use them instead of Legendre
polynomials while still remaining faithful to the variational principle.
Either basis, however, works just ﬁne; the difference between them seems to have more
to do with mathematical tidiness than with efﬁciency. The variational formalism is popular,
but collocation with either Chebyshev or Legendre polynomials is successful, too.
As noted earlier, there are two standard collocation grids for Chebyshev polynomials:
(i) the “roots” or “Gauss-Chebyshev” grid, whose points are the zeros of TN(x) and (ii) the
“extrema-and-endpoints” or “Gauss-Chebyshev-Lobatto” grid, which includes the roots of
the derivative of TN(x) plus the endpoints ±1. As shown in Chapter 2, both have equally
good theoretical properties and the choice between them is usually a matter of preference.
With spectral elements, however, the “extrema-and-endpoints” or “Lobatto” grid is
much more popular than the roots grid. The reason is that one must explicitly match so-
lutions along inter-element boundaries. In the variational formalism, it is awkward to im-
pose continuity on the basis sets, apply the isoparameteric mapping described in Sec. 10,
and so on if none of the grid points coincides with the element walls. However, Schumack,
Schultz, and Boyd (1989) have found that the roots grid is just as accurate as the Lobatto
grid for computing Stokes’ ﬂows.
Nevertheless, the Legendre basis with Lobatto grid has become the canonical choice for
spectral elements. The cardinal functions, derivative matrix and grid points are all given
in Appendix F, Sec. 10.
22.7
Patching versus Variational Formalism
Canuto et al.
(1988) show that the differences between the patching & variational ap-
proaches to spectral elements are small. Indeed, the variational principle can be expressed
in terms of patching and vice versa if the two formalisms are appropriately generalized.
For example, the variational method is equivalent to patching if the condition of conti-
nuity of du/dx at inter-element boundaries, (22.5b), is replaced by
u1,x(d) −u2,x(d) + w0 R1(d) + wN2 R2(d)
(22.27)
where R1 and R2 are the differential equation residuals in elements 1 and 2 and where w0
and wN2 are the ﬁrst and last weights of the Gauss-Lobatto quadrature. Since the quadra-
ture weights are O(1/N 2
i ) and the residuals are very small if the numerical solution is ac-
curate, it follows that (22.27) is only a small perturbation of (22.5b). Further, the magnitude
of the residual terms in (22.27) is always the same order of magnitude as the error in the
numerical solution: exponentially small.

22.8. MATRIX INVERSION
487
Thus, whether one applies (22.5b) or (22.27) is irrelevant to accuracy. It is obvious, how-
ever, that (22.27) is harder to program and also harder to explain and justify. In practice,
one would always either apply patching in the standard form (22.5b) or apply the varia-
tional principle as explained in Sec. 5. The only use of (22.27) is conceptual: it shows that
patching is very close to the variational formalism without being identical.
In a similar way, the variational method can mimic patching if the variational principle
is slightly modiﬁed. Again, however, the modiﬁcations do not raise or lower the order
of the method. There is no compelling reason for choosing patching over the variational
approach or vice versa; it is a matter of preference and taste.
22.8
Matrix Inversion
As reviewed by Canuto et al. (1988), linear algebra methods used with spectral elements
include:
(i) Alternating Schwarz method
(ii) Static condensation
(iii) Inﬂuence matrix method
(iv) Conjugate gradient and
(v) Multigrid.
The Schwarz algorithm deﬁnes overlapping elements and then iterates to match the solu-
tions in different subdomains. Canuto & Funaro (1988) report great success and Schwarz
iteration has become popular with ﬁnite difference methods, too.
“Static condensation” is a two-stage application of Gaussian elimination. On a given
subdomain, the numerical solution has both internal and external degrees of freedom. The
external degrees of freedom are those which can be computed only simultaneously with
the corresponding quantities for all the other elements. For the second order ordinary
differential equation of Sec. 4, for example, the general solution can be written as
uj(x) = pj(x) + Uj−1 hLj(x) + Uj hRj(x)
x ∈[dj−1, dj]
(22.28)
where Uj ≡u(xj) and the particular solution pj(x) and the homogeneous solutions, hLj(x)
& hRj(x), satisfy (22.12) and (22.13). The internal degrees of freedom are the polynomial
coefﬁcients of pj(x), hLj(x) & hRj(x). These coefﬁcients are “internal” because one can
compute these three functions on the j-th element without using any information outside
the j-th element. This is possible because these three functions are arbitrarily assigned
boundary values of either 1 or 0.
The external degrees of freedom are the values of uj(x) on the boundaries of the ele-
ment, Uj. These can be determined only by matching the elemental solutions across the
global domain to form a single continuous solution.
The ﬁrst stage of static condensation is to eliminate the internal degrees of freedom. The
second stage is to solve a reduced matrix system (i. e. (22.16)) for the external degrees of
freedom. The dimension of this “condensed” system is small in comparison to N, the total
number of degrees of freedom, resulting in huge savings.
The inﬂuence matrix method, which is the theme of the next section, is very similar to
static condensation. Both are direct methods that perform as much of the work as possible
within each element before solving a matrix problem of moderate size to link the piecewise
polynomials together.
The conjugate gradient and multigrid algorithms are iterations. However, both share
a common philosophy with the direct methods: exploit the weak inter-element coupling
through heavy use of intra-element operations. As emphasized in Sec. 4, this strategy is
fundamental to all spectral element procedures.

488
CHAPTER 22. DOMAIN DECOMPOSITION METHODS
Both multigrid and a conjugate gradient-like algorithm have already been discussed
in an earlier chapter. However, Rønquist & Patera (1987b) and Maday & Munoz (1988)
have shown that the incomplete-factorizations employed with global Chebyshev multigrid
are unnecessary for Legendre spectral elements. Instead, a simple pointwise Richardson’s
iteration (which these authors label with Jacobi’s name) is extremely effective, at least for
simple problems.
It is usual to abandon iteration when multigrid has descended to a grid with only a
small number of points and solve the matrix problem on the coarsest grid via Gaussian
elimination. In Rønquist & Patera (1987b), the multigrid/Richardson’s iteration polyalgo-
rithm is applied only within each element. The direct-solution-on-the-coarsest-grid is the
step at which the various elemental solutions are matched together. Thus, the non-iterative
part of multigrid is identical with the second stage of static condensation or the inﬂuence
matrix algorithm described below.
22.9
The Inﬂuence Matrix Method
If we knew the values of u(x, y) on the walls of an element, then the problem on that
subdomain would be completely self-contained. If we had a subroutine that solved the
differential equation using a global spectral series, we could call this subprogram once and
be done.
The difﬁculty is that when one or more of the walls of an element is an internal bound-
ary, the values of u(x, y) on that wall are unknown. Nevertheless, if we discretize the bound-
ary, we can calculate the inﬂuence of each boundary point on the rest of the solution. This
calculation of “inﬂuence” requires nothing more nor less than calling the subroutine to
solve the Dirichlet problem on the j-th element.
Let the elliptic equation be
L u = f
(22.29)
For simplicity, assume homogeneous Dirichlet conditions. (If the boundary conditions
are inhomogeneous, we may always modify u and f to recast the problem so that the
boundary conditions are homogeneous as described in Chapter 6, Secs. 5 and 6). The “dis-
crete boundary Green’s functions on the j-th element”, which we shall call the “elemental
Green’s functions” for short, are deﬁned as the pseudospectral solutions of
Lγi = 0
on
(x, y) ∈Ωj
(22.30a)
γi(xk, yk) = δik
(xk, yk) ∈∂Ωj
(22.30b)
In words, each function γi(x, y) vanishes at all but one of the points on the boundary of
the element. Strictly speaking, we should add subscripts “j” to both the boundary Green’s
functions and to the boundary point labels to specify the j-th element, but we have sup-
pressed these for simplicity. We shall append the element index below wherever needed to
avoid confusion.
In addition, it is usually necessary to cover the domain with curved quadrilaterals and
then map each into the unit square as described in the next section. After such a trans-
formation, L, f, Ωj, and ∂Ωj should have tildes to denote that they have been altered by
the mapping. For simplicity, such tildes have been omitted. The mapping is important,
however, and forms the theme of the next section.
To enforce continuity of u(x) at the inter-element boundaries, it is helpful to assemble
the elemental Green’s functions into global Green’s functions that display the total inﬂu-
ence of a given boundary point. Let K denote an index that runs over all interior boundary

3
1
2
1
2
3
4
22.9. THE INFLUENCE MATRIX METHOD
489
Figure 22.2: Schematic of an L-shaped domain which has been divided into three square
elements. The boundaries between elements are shown by dotted lines. The grid points
on the interior of these intra-element boundaries are shown by numbers in circles. We need
four “boundary elemental Green’s functions”. The Green’s function G2(x, y) is equal to
one at boundary grid point 2 and is zero at each of the other three circled points. G2 is
also zero at all grid points on the boundaries of the L-shaped domain (not marked). The
cross-hatching shows the two elements where G2(x, y) is non-zero.

490
CHAPTER 22. DOMAIN DECOMPOSITION METHODS
points and let J(K) and J′(K) denote the elements whose common wall contains the point
labelled by K. Fig. 22.2 schematically illustrates this system for an L-shaped domain par-
titioned into three elements. The index K runs from 1 to 4. The point with K = 2, for
example, lies on the boundary between elements 1 and 2, so that J(2) = 1 and J′(2) = 2.
Further, let i(K) and i′(K) denote the label of the K-th point in the local number system
on the elements j = J(K) and j = J′(K). Then, taking j(x, y) to denote the number of the
element which contains the point (x, y),
GK(x, y) ≡







γi(K),J(K)
j = J(K)
0
j ̸= J(K), J′(K)
γi′(K),J′(K)
j = J′(K)
(22.31)
At corner points where four domains come together, the deﬁnition of GK must be general-
ized to include four non-zero pieces.
We also must compute a single particular integral pj(x, y) for each element; these solve
L pj = f
x, y ∈Ωj
&
pj = 0
on
∂Ωj
(22.32)
Then
u(x, y) =
Kmax
X
K=1
uK GK(x, y) +
M
X
j=1
pj(x, y)
(22.33)
where Kmax is the total number of interior boundary points (=4 in Fig. 22.2), M is the num-
ber of subdomains, and uK denotes the value of u(x, y) at the K-th boundary point. Eq.
(22.33) is the two-dimensional generalization of (22.28); hLj(x) and hRj(x) are the elemen-
tal boundary Green’s functions for that one-dimensional example.
The usual patching conditions are that both u and its derivatives should be continuous
at all boundary points. (Strictly speaking, one wants continuity along the whole interval of
each inter-element boundary, but with any discretization, the best one can do is to impose
such conditions only at the grid points.) The GK(x, y) are constructed to be continuous at
the boundary points. The particular integrals pj(x, y) are all zero at the boundary points
and therefore are continuous also. Thus, the only non-trivial conditions are those on the
derivatives.
Imposing continuity of the normal derivative, that is, the derivative in the direction per-
pendicular to the wall, gives us one condition at each of the Kmax interior boundary points.
These continuity conditions give a matrix problem of dimension Kmax to determine the free
parameters in (22.33), which are the uK. Note that because Kmax ≪N, the dimension of
this element-coupling matrix system is relatively small.
Naturally, one wants continuity of the tangential derivative, too. However, continuity
of u implies that the numerical solutions in two neighboring elements agree at each of
the boundary points along their common wall. It follows that if we expand ui and uj as
one-dimensional functions of the coordinate tangential to the wall, their interpolating poly-
nomials will be identical. It follows that the derivatives tangential to the wall are forced
to match because ui and uj match along the wall. (For simplicity, this argument assumed
that the number of boundary points is the same for each element, but this assumption may
be relaxed without altering the conclusion: the jump in the tangential derivative across the
wall is either zero or spectrally small.)
At a corner point, this argument fails. It seems that one would need to explicitly im-
pose continuity of the derivatives with respect to both x and y, which would give more
conditions than unknowns uK, creating an overdetermined matrix system. It turns out,

22.10. TWO-DIMENSIONAL MAPPINGS & SECTORIAL ELEMENTS
491
however, that it is sufﬁcient to impose continuity of either derivative at a corner point; the
jump in the other derivative will be spectrally small (Canuto et al., 1988, pg. 454).
Once the uK have been found, the R. H. S. of (22.33) is completely known. The matrix
systems which must be solved to determine the solution within each element are rather
small: the dimension is Nj, the number of grid points that lie in the interior (and not on
the boundaries) of the j-th element. In most practical applications, Nj ≈50–100 (Rønquist
& Patera, 1987b).
22.10
Two-Dimensional Mappings & Sectorial Elements
Spectral elements, like ﬁnite elements, may accomodate very irregular or complicated ge-
ometry through mapping. Each element is square in the computational coefﬁcients (r, s),
but may be a highly distorted quadrilateral in physical space where the coordinates are
(x, y).
The mapping mechanics are a straightforward (if messy) extension of the one-dimensional
transformations of Chapter 16. One writes
x = F(r, s)
&
y = G(r, s)
r, s ∈[−1, 1]
(22.34)
and then applies the chain rule to transform derivatives with respect to the physical coor-
dinates x and y into derivatives with respect to the computational coordinates (Table E.9,
Appendix E).
The simplest map is that which transforms the rectangle [ax, bx] × [ay, by] in physical
space into the unit square:
x = 1
2 [(bx + ax) + (bx −ax) r]
&
y = 1
2 [(by + ay) + (by −ay) s]
(22.35)
However, one is free to use analytical maps of almost any form desired.
When the geometry is so complex so that a closed-form mapping for each element can-
not be found, the usual strategy is to employ a so-called “isoparametric mapping”. The
mapping functions F(r, s) and G(r, s) are approximated by double Chebyshev series of
the same order as will be used for the solution u(x, y), i. e.
x =
N
X
i=0
N
X
j=0
Xij Ci(r) Cj(s)
(22.36)
where the Ci are the usual cardinal functions on the “Lobatto” grid (Appendix F, Sec. 6),
plus a similar expansion for y(r, s).
The earliest strategies for coping with curving boundaries were quite crude. A circle
might be approximated by an octagon, or a curving boundary replaced by a zigzag of line
segments that alternately paralleled the x and y axis so that the computational domain was
a union of rectangles. As higher order ﬁnite elements were developed, such crudeness
was no longer adequate: the poor approximation to the boundary would erase the high
accuracy inherent in the basis set. At the other extreme, using an eighth order polynomial
for the map functions while employing only a fourth order basis for u(x, y) is also stupid;
the numerical solution cannot resolve the ﬁne structure in the mapping functions. The
isoparametric strategy is the common-sense tactic of approximating all parts of the problem
— solution & mapping functions — by polynomials of the same order.
Generating numerical grids is a complex topic in and of itself; (Thompson, Warsi, and
Mastin, 1985). However, when the geometry is not complex, or when the number of ele-
ments is sufﬁciently large, it is not difﬁcult to devise a systematic strategy for mapping the
whole domain, one curvilinear quadrilateral at a time.

492
CHAPTER 22. DOMAIN DECOMPOSITION METHODS
The “Global Element School” (Delves & Hall, 1979, Delves & Phillips, 1980, Kermode,
McKerrell & Delves, 1985, Delves et al., 1986, and McKerrell, 1988) have creatively used
mapping to neutralize corner singularities. The basic strategy, which is borrowed from
Wait, is to map a sectorial or triangular element in physical space into the unit square in the
computational coordinates r and s using a map which is designed to remove a speciﬁc type
of singularity.
To explain this strategy, it is convenient to use the polar coordinates (in physical space)
ρ ≡
p
x2 + y2
&
θ = arctan
³y
x
´
(22.37)
where ρ = 0 is the location of the boundary corner where u(x, y) is singular. To apply the
method, one must be able to characterize the branch point using local analysis. Assume,
for example, that the singularity is of the form
u(x, y) = [constant] ρwf(θ) + less singular functions
(22.38)
for some non-integral constant w.
When the element in (x, y) is the sector
ρ ∈[0, α]
&
θ ∈[0, β]
(22.39)
where α is the radius of the sector and β is the sector’s angular width, then the mapping
which (i) transforms the sector into the unit square and (ii) neutralizes a singularity of the
form of (22.38) is
ρ
=
α
·1 + r
2
¸1/w
(22.40a)
θ
=
β
2 (1 + s)
(22.40b)
The original Cartesian coordinates are given by x = ρ(r) cos(θ[s]) and y = ρ(r) sin(θ[s] ).
The polar form is very useful, however, because it shows that ρw becomes a linear function
of the computational coordinate r, and thus is nonsingular in the (r-s) plane.
Similarly, one can choose a triangular element in the x-y (physical) plane. To deﬁne
the element, specify sides of length A and B which intersect at the origin with an angle
β between them, oriented so that the side of length A is parallel to the x-axis. Then a
“desingularizing” mapping is
ρ
=
·1 + r
2
¸1/w r
(1 −s)2B2 + (1 + s)2A2 + 2 (1 −s2)AB cos(β)
4
(22.41a)
θ
=
arctan
½
B sin(β)(1 −s)
B cos(β)(1 −s) + A(1 + s)
¾
(22.41b)
Neither (22.40) nor (22.41) is unique; many other choices of mappings are possible. The
point is that if one knows the degree of the corner branch and if one is willing to accept
the extra programming complexity of additional element shapes and mappings, spectral
elements can eliminate corner singularities.
22.11
Prospectus
The geometries of nature and engineering are both complicated, full of arcs and spirals and
web-like networks of beams and curving cylinders. It is far easier to ﬁt a complicated shape

22.11. PROSPECTUS
493
by an assemblage of many triangles or curved quadrilaterals than by a single deformed
square. It is for this reason that ﬁnite elements have become so popular.
However, as computers grow in speed and power, second order methods become less
and less satisfactory. After all, Sir Robert Southwell and his colleagues de G. Allen and
Vaisey were applying fourth order methods with desktop calculators half a century ago.
The future of science and engineering is likely to be domain decomposition strategies
that use polynomials of medium order — sixth to eighth degree, say — on each element.
Nevertheless, the fundamentals of spectral series are independent of N, the degree of
the polynomial, and also independent of whether the domain of the polynomial is the
whole domain of the problem, or merely a subdomain. Like Newtonian mechanics, spec-
tral methods will surely endure rapid, perhaps even revolutionary change. Like Newto-
nian mechanics, what has been described in these twenty-two chapters will not be replaced,
but merely extended.

Chapter 23
Books and Reviews
“Aun Aprendo” — “I am still learning”
—– Francisco de Goya (1746-1828), written on a sketch drawn in his old age
Table 23.1: Books and Reviews on Spectral Methods
Books
Bernardi&Maday(1992)
250 pp.
In French; mathematical theory
Boyd(1989,2000)
665 pp.
Text & Encyclopedia; elementary mathematical level
Canuto, Hussaini,
500 pp.
Half algorithms and practice, half theory
Quarteroni&Zang(1987)
Available in paperback and hardcover
Delves&Freeman(1981)
275 pp.
Theory of Chebyshev-Galerkin methods and
block-and-diagonal (“Delves-Freeman”) matrix iterations
Finlayson(1972)
410 pp.
Low order pseudospectral & Galerkin
lots of examples from ﬂuids and chemical engineering
Fornberg(1996)
200 pp.
Classical pseudospectral; very practical
Available in paperback and hardcover
Fox&Parker(1968)
200 pp.
Very readable, but its Galerkin-by-recurrence and
differential-eq.-through-double-integration are now rare
Funaro, D. (1992)
300 pp.
Variational and approximation theory plus algorithms;
one chapter on domain decomposition
Funaro, D. (1997)
210 pp.
Spectral elements; readable description of the
variational theory; many numerical examples
Gottlieb & Orszag(1977)
150 pp.
Mix of examples and stability theory
Guo(1998)
200 pp.
Proofs; highly mathematical
Karniadakis&Sherwin(1999)
448 pp.
Quadrilateral and triangular spectral elements
Mercier(1989)
200 pp.
Translation, without updating, of earlier book in French
Review Articles
Bert&Malik(1996)
28 pp.
Pseudospectral as high order ﬁnite differences under
the name “differential quadrature”; mechanics applications
Delves(1976)
13 pp.
Integral and differential equations; Chebyshev basis
block-and-diagonal (Delves-Freeman) matrix iterations
Fornberg&Sloan(1994)
65 pp.
Chebyshev & Fourier single-domain
Givi&Madnia(1993)
44 pp.
Spectral methods in combustion
Gottlieb,Hussaini&Orszag(1984)
54 pp.
Single-domain pseudospectral
Hussaini,Kopriva&Patera(1989)
31 pp.
Chebyshev & Fourier single-domain
Jarraud&Baede(1985)
41 pp.
Spectral methods in numerical weather prediction
Maday&Patera(1987)
73 pp.
Spectral elements; ﬂuids
Robson & Prytz(1993)
31 pp.
Pseudospectral as the “discrete ordinates” method
physics applications
Fischer&Patera(1994)
44 pp.
Spectral elements on massively parallel machines
494

Appendix A
A Bestiary of Basis Functions
“Talk with M. Hermite: he never invokes a concrete image; yet you soon perceive that the
most abstract entities are for him like living creatures.”
— Henri Poincar´e
A.1
Trigonometric Basis Functions: Fourier Series
Applications:
All problems with periodic boundary conditions
Interval:
x ∈[−π, π]
or
x ∈[0, 2 π]
(Because of the periodicity, these two intervals are equivalent.)
General Fourier Series:
f(x) = a0 +
∞
X
n=1
an cos(nx) +
∞
X
n=1
bn sin(nx)
(A.1)
a0
=
(1/2π)
Z π
−π
f(x)dx
an
=
(1/π)
Z π
−π
f(x) cos(nx)dx
bn
=
(1/π)
Z π
−π
f(x) sin(nx)dx
(A.2)
495

496
APPENDIX A. A BESTIARY OF BASIS FUNCTIONS
If f(x) is symmetric about x = 0, one needs only the cosine terms, giving a Fourier
cosine series. If f(x) is antisymmetric about the origin, that is, f(x) = −f(−x) for all x,
then one needs only the sine terms. One should halve the computational interval to avoid
applying redundant collocation conditions, i. e.
Interval:
x ∈[0, π]
or
x ∈
h
−π
2 , π
2
i
Fourier Cosine Series
or Fourier Sine Series
If f(x) has deﬁnite symmetry with respect to both x = 0 and x = π/2, then one needs
only the even or odd terms of a Fourier cosine or sine series as explained in Chapter 8. For
these “quarter-Fourier series” in which one uses only the cosine terms with even n, or the
sine terms of even n, then
Interval:
x ∈[0, π/2]
“Quarter-Wave” Series with Deﬁnite Parity
with Respect to Both x = 0 and x = π/2
Collocation Points:
xi =





π i/N
π i/N
πi/(2N)
i = 1, . . . , 2N
i = 1, . . . , N
i = 1, . . . , N
(General)
(Symmetric or Antisymmetric)
(Quarter-Wave [Double Symmetry])
(A.3)

A.2. CHEBYSHEV POLYNOMIALS: TN(X)
497
A.2
Chebyshev Polynomials: Tn(x)
Applications:
Any problem whatsoever.
Weight:
ρ(x) ≡
1
√
1 −x2
(A.4)
Inner Product:
Z 1
−1
Tm Tn
√
1 −x2 dx =





0
π
π/2
m ̸= n
m = n = 0
m = n ̸= 0
(A.5)
Standardization:
Tn(cos[t]) = cos(nt)
(A.6)
Inequality:
|Tn(x)| ≤1
for all n, all on [−1, 1]
(A.7)
Three-Term Recurrence:
T0 ≡1
;
T1(x) ≡x
(A.8)
Tn+1(x) = 2 x Tn(x) −Tn−1(x)
n ≥1
(A.9)
Differentiation rules:
(i) Use the deﬁnition of Tn(x) in terms of the cosine, (A.6), and Table E–2 [RECOM-
MENDED because of its simplicity]. For example,
dTn
dx
=
n sin(nt)
sin(t)
(A.10)
d2Tn
dx2
=
−n2 cos(nt)
sin2(t)
+ n cos(t) sin(nt)
sin3(t)
(A.11)
where t = arccos(x).
(ii) Use the relationship between the Chebyshev and Gegenbauer polynomials, which
is
dm
dxm Tn(x) = n 2m−1 (m −1)! C(m)
n−m(x)
(A.12)
dpTn
dxp
¯¯¯¯
x=±1
= (±1)n+p
p−1
Y
k=0
n2 −k2
2k + 1
(A.13)

498
APPENDIX A. A BESTIARY OF BASIS FUNCTIONS
(iii) Compute the Chebyshev series for the derivative from that for u(x) itself. Let
dqu
dxq =
N
X
k
a(q)
k
Tk(x)
(A.14)
so that the superscript “q” denotes the coefﬁcients of the q-th derivative. These may be
computed from the Chebyshev coefﬁcients of the (q −1)-st derivative by the recurrence
relation (in descending order)
a(q)
N =
a(q)
N−1
= 0
(A.15)
a(q)
k−1
=
1
ck−1
n
2 k a(q−1)
k
+ a(q)
k+1
o
,
k = N −1, N −2, N −3, . . . , 1
where ck = 2 if k = 0 and ck = 1 for k > 0.
Notes:
(i) d
dx Tn(x) = n Un−1(x)
(A.16)
Higher order differentiation is mildly ill-conditioned as discussed by Breuer and Ever-
son (1992), Huang and Sloan (1992), Merryﬁeld and Shizgal (1993) and Bayliss, Class and
Matkowsky (1994). Heinrichs (1991) has suggested a partial remedy: Basis recombination.
Integration:
Z x
dy Tn(y) =
½ Tn+1(x)
2(n + 1) + Tn−1(x)
2(n −1)
¾
,
n ≥2
(A.17)
Flyer (1998) gives asymptotic upper bounds for the coefﬁcients in the Chebyshev series
for the iterated integral of arbitrary order as well as a discussion of integration identities in
general.
Karageorghis (1988a, b) has analyzed the Chebyshev coefﬁcients of the general order
derivative and of its moments.
Collocation Points: either of the two choices
xi
= cos
·(2i −1)π
2N
¸
i = 1, . . . , N
[“Roots” or
“Gauss-Chebyshev”]
(A.18)
xi
= cos
·
πi
N −1
¸
i = 0, . . . , N −1
[“Extrema-plus-Endpoints”
or “Gauss-Lobatto”]
(A.19)
Differential Equation (Sturm-Liouville Problem)
(1 −x2) d2Tn
dx2 −xdTn
dx + n2Tn = 0,
n = 0, 1, 2, . . .
(A.20)

A.3. CHEBYSHEV POLYNOMIALS OF THE SECOND KIND: UN(X)
499
A.3
Chebyshev Polynomials of the Second Kind: Un(x)
Applications:
Proportional to ﬁrst derivative of Chebyshev polynomials of the ﬁrst
kind. Rarely used as a basis set.
Interval:
x ∈[−1, 1]
Weight:
ρ(x) ≡
p
1 −x2
(A.21)
Inner Product:
Z 1
−1
Um(x) Un(x)
p
1 −x2 dx =
³π
2
´
δmn
(A.22)
Standardization:
Un(1) = n + 1
(A.23)
Trigonometric Form:
Un(cos θ) ≡sin[(n + 1)θ]
sin θ
(A.24)
Inequality:
|Un+1(x)| ≤n + 1
for all n, all x on [-1, 1]
(A.25)
Three-Term Recurrence and Starting Values:
U0(x) ≡1
;
U1(x) ≡2 x
(A.26)
Un+1(x) = 2 x Un(x) −Un−1(x)
n ≥1
(A.27)
Differentiation Rules:
(i) Use trigonometric form (A.24)
(ii) Use relationship between Chebyshev & Gegenbauer polynomials
dm
dxm Un(x) = 2m m! C(m+1)
n−m (x)
(A.28)
Collocation Points:
xi = −cos
·
iπ
N + 1
¸
;
i = 1, 2, . . . , N
(A.29)

500
APPENDIX A. A BESTIARY OF BASIS FUNCTIONS
A.4
Legendre Polynomials: Pn(x)
Applications:
Spectral elements; alternative to Chebyshev polynomials for non-periodic
problems; also the axisymmetric spherical harmonics for problems in spherical geometry.
Interval:
x ∈[−1, 1]
Weight:
ρ(x) ≡1
Inner Product:
Z 1
−1
Pm Pn dx =
2
2 n + 1 δmn
(A.30)
Endpoint Values:
Pn(±1) = (±1)n,
dPn/dx(±1) = (±1)n−1 n(n + 1)/2
(A.31)
Inequalities:
|Pn(x)| ≤1
|dPn/dx| ≤n(n + 1)/2
for all n, all x ∈[−1, 1]
(A.32)
Nonuniformity:
Pn(0) = 1 · 3 · · · (n −1)
2 · 4 · · · (n)
∼
p
2/(π n),
n even
(A.33)
Asymptotic Approximation as n →∞for ﬁxed t:
Pn(cos(t)) ∼
s
2
nπ sin(t) sin
n
(n + 1/2)t + π
4
o
+ O(n−3/2)
(A.34)
Three-Term Recurrence and Starting Values:
P0 ≡1,
P1(x) = x
(A.35)
(n + 1) Pn+1(x) = (2 n + 1) x Pn(x) −n Pn−1(x)
(A.36)
Differentiation:
Use relationship between Legendre and Gegenbauer Polynomials
dm
dxm Pn(x) = 1 · 3 · 5 · · · (2m −1) C(m+1/2)
n−m
(x)
(A.37)
Phillips(1988) gives the Legendre coefﬁcients of a general-order derivative of an in-
ﬁnitely differentiable function.
Collocation Points (Gaussian Quadrature Abscissas):
Not known in closed form for general N; see pgs.
916–919 of Abramowitz & Ste-
gun(1965), NBS Handbook. Analytical expressions for up to 9-point grids are given in Ap-
pendix F.

A.4. LEGENDRE POLYNOMIALS: PN(X)
501
If
f(x) ≡
∞
X
n=0
anPn(x),
xf(x) ≡
∞
X
n=0
bnPn(x)
(A.38)
df
dx ≡
∞
X
n=0
a(1)
n Pn(x),
d2f
dx2 ≡
∞
X
n=0
a(2)
n Pn(x)
(A.39)
then the coefﬁcients of the derived series are given in terms of the coefﬁcients of f(x) itself
as
Multiplication by x:
bn =
n
2n −1 an−1 + n + 1
2n + 3 an+1,
n ≥1
[b0 = 0]
(A.40)
First Derivative:
a(1)
n
= (2n + 1)
∞
X
p=n+1,p+nodd
ap
(A.41)
Second Derivative:
a(2)
n
= (n + 1/2)
∞
X
p=n+2,p+neven
{p(p + 1) −n(n + 1)} ap
(A.42)

502
APPENDIX A. A BESTIARY OF BASIS FUNCTIONS
A.5
Gegenbauer Polynomials
Applications:
Spherical geometry as the latitudinal factors for the spherical harmonics,
Gottlieb et al regularization of Gibbs’ Phenomenon
Alternative name: “Ultraspherical” polynomials
Interval:
x ∈[−1, 1]
Weight Function:
ρ(x) =
¡
1 −x2¢m−1/2
(A.43)
Inner Product:
Z 1
−1
C(m)
n
C(m)
n
(1 −x2)m−1/2 dx = π 21−2m Γ(n + 2m)
n! (n + m) Γ(m)2
≡hm
n
(A.44)
Expansion Coefﬁcients of a Function f(x)
f(x) =
∞
X
j=0
am
j Cm
j (x)
(A.45)
am
j ≡
1
hm
j
Z 1
−1
f(x) Cm
j (x) (1 −x2)m−1/2 dx
(A.46)
where hm
j is deﬁned by A.44 and where the Gegenbauer polynomials are not orthonormal,
but standardized as in A.49.
Expansion of Complex Exponential
exp( i π ω x) =
∞
X
j=0
f m
j
Cm
j (x)
(A.47)
f m
j
= ij Γ(m)
µ 2
π ω
¶m
(j + m) Jj+m( π ω )
(A.48)
Standardization:
C(m)
n
(1) = Γ(n + 2m)
n! Γ(2m)
(A.49)

A.5. GEGENBAUER POLYNOMIALS
503
Asymptotics of Endpoint Values
Cn
n(1) ∼
r
1
3 π n
µ27
4
¶n
,
n →∞
[m = n]
(A.50)
Cm
n (1)
∼
(n + 1)2m−1 1
√π
µ 1
m
¶2m−1/2
exp {2 m [1 −log(2) ] } ,
ﬁxed m, n →∞
(A.51)
Inequality:
|C(m)
n
(x)| ≤C(m)
n
(1)
for m > 1/2, x ∈[−1, 1]
(A.52)
Uniformity Ratio
ρ2n(m) ≡Cm
2n(1)
|Cm
2n(0)| = Γ(2n + 2m) n! Γ(m)
(2n)! Γ(2m) Γ(n + m)
(A.53)
ρ2n(2n) ≡C2n
2n(1)
|C2n
2n(0)| =
Γ(6n) n!
2n Γ(4n) Γ(3n)
(A.54)
Three-Term Recurrence:
C(m)
0
≡1
;
C(m)
1
(x) ≡2 m x
(A.55)
(n + 1) C(m)
n+1(x) = 2 (n + m) x C(m)
n
(x) −(n + 2m −1) C(m)
n−1(x)
(A.56)
Note: the recurrence relation is weakly unstable for m > 0, and the instability increases
as m increases. Consequently, library software usually calculates the spherical harmonics
using a different, more complicated recurrence relation (see book by Belousov, 1962). How-
ever, our own numerical experiments, perturbing the recurrence relation by ϵρ(n) where
ρ(n) is a different random number between 0 and 1 for each m, have shown the maximum
error for all x and all polynomial degrees < 100 is only 263 ϵ for m = 24.5 and 1247ϵ for
m = 49.5. Nehrkorn (1990) found the same through his more detailed experiments. This
suggests that the recurrence relation is actually quite satisfactory if a relative error as large
as 1.E-10 is acceptable.
Differentiation Rule:
d
dxC(m)
n
(x) = 2 m C(m+1)
n−1
(x)
(A.57)
Phillips and Karageorghis (1990) derive formulas for the coefﬁcients of integrated ex-
pansions of Gegenbauer polynomials.
Collocations Points (Gaussian Quadrature Abscissas):
See Davis & Rabinowitz, Methods of Numerical Integration. Canuto et al. (1988) give
a short FORTRAN subroutine to compute the Lobatto grid for general order in their Ap-
pendix C.

504
APPENDIX A. A BESTIARY OF BASIS FUNCTIONS
Special Cases:
Tn(x)
=
³n
2
´
C(0)
n (x)
[Chebyshev]
(A.58)
Pn(x)
=
C(1/2)
n
(x)
[Legendre]
(A.59)
Un(x)
=
C(1)
n (x)
[Chebyshev of the 2d Kind]
(A.60)
Gegenbauer Polynomials: Explicit Form
Cm
0
=
1;
Cm
1 (x) = 2m x
Cm
2
=
2m(1 + m) x2 −m
Cm
3
=
½8
3m + 4m2 + 4
3m3
¾
x3 −2m(1 + m)x
Cm
4
=
µ2
3m4 + 4m3 + 22
3 m2 + 4m
¶
x4 −(2m3 + 6m2 + 4m)x2 + 1
2m(1 + m)
Cm
5
=
µ 4
15m5 + 8
3m4 + 28
3 m3 + 40
3 m2 + 32
5
¶
x5
−
µ4
3m4 + 8m3 + 44
3 m2 + 8m
¶
x3 + (m3 + 3m2 + 2m)x
(A.61)
Endpoint values
Cm
0 (1)
=
1;
Cm
1 (1) = 2m
Cm
2 (1)
=
m + 2m2;
Cm
3 (1) = 4
3m3 + 2m2 + 2
3m
Cm
4 (1)
=
2
3m4 + 2m3 + 11
6 m2 + 1
2m
Cm
5 (1)
=
4
15m5 + 4
3m4 + 7
3m3 + 5
3m2 + 2
5m
(A.62)

A.6. HERMITE POLYNOMIALS: HN(X)
505
A.6
Hermite Polynomials: Hn(x)
Applications:
doubly inﬁnite interval;
f(x) →0
as
|x| →∞
Basis Functions:
φn(x) ≡exp[−x2/2] Hn(x)
(A.63)
Interval
x ∈[−∞, ∞]
(A.64)
Weight:
ρ(x) ≡exp[−x2]
(A.65)
Inner Product:
Z ∞
−∞
e−x2 Hm(x) Hn(x) dx = δmn
√π 2nn!
(A.66)
Standardization:
Hn(x) = 2n xn + · · ·
(A.67)
Three-Term Recurrence and Starting Values:
H0 ≡1
;
H1(x) ≡2 x
(A.68)
Hn+1(x) = 2 x Hn(x) −2 n Hn−1(x)
(A.69)

506
APPENDIX A. A BESTIARY OF BASIS FUNCTIONS
Differentiation Rules:
dHn
dx ≡2 n Hn−1(x)
all n
(A.70)
Collocation Points (Gaussian Abscissas): Abramowitz & Stegun(1965), NBS Handbook, pg.
924 , Davis and Rabinowitz, Numerical Integration.
The orthonormal Hermite functions ψn such that
R ∞
−∞ψn(x)2dx = 1 for all n may be com-
puted by
ψ0 ≡π−1/4 exp(−(1/2)x2)
;
ψ1(x) ≡
√
2 x ψ0
(A.71)
ψn+1(x) =
q
2
n+1 x ψn(x) −
q
n
n+1 ψn−1(x)
(A.72)
and the derivatives ψn,x from
ψ0,x ≡−xψ0
;
ψ1,x(x) ≡−x ψ1 +
√
2x ψ0
(A.73)
ψn+1,x = −x ψn+1 +
√
2 n ψn
(A.74)
The orthonormal Hermite functions are better-conditioned than their unnormalized coun-
terparts.
Inequality:
|ψn(x)| =≤0.816 ∀x
(A.75)
Expansion of a Gaussian:
exp(−x2) =
∞
X
m=0
a2m ψ2m(x)
(A.76)
a2
=
(−1)m π1/4p
2/3
√
2m!
6m m!
(A.77)
∼
(−1)m 0.9709835
1
3m (2m)1/4 ,
m →∞
(A.78)

A.7. RATIONAL CHEBYSHEV FUNCTIONS: TBN(Y )
507
A.7
Rational Chebyshev Functions on an Inﬁnite Interval:
TBn(y)
Applications:
Doubly inﬁnite interval
Interval:
y ∈[−∞, ∞]
Let L denote a constant map parameter, user-chosen to match width of the function to
be expanded. (Some experimentation may be necessary.) Then
Chebyshev deﬁnition:
TBn(y) = Tn
Ã
y
p
L2 + y2
!
(A.79)
Trigonometric deﬁnition:
TBn(y)
=
cos
³
n arccot
³ y
L
´´
(A.80)
=
cos(nt)
(A.81)
where
y = L cot(t)
←→
t = arccot
³ y
L
´
(A.82)
Weight:
ρ(y) ≡
L
L2 + y2
(A.83)
Inner Product:
Z ∞
−∞
TBm(y) TBn(y)
·
L
L2 + y2
¸
dy =





π
0
π/2
m = n = 0
m ̸= n
m = n > 1
(A.84)
Asymptotic Behavior:
TBn(y) ∼1
as |y| →∞
for all n
(A.85)
(Note that this basis set may usually be applied without modiﬁcation to compute
solutions that tend to 0 as |y| →∞.)
Derivatives:
Apply the trigonometric form (A.81) in combination with Table E–4.
References: Boyd (1987a).

508
APPENDIX A. A BESTIARY OF BASIS FUNCTIONS
A.8
Laguerre Polynomials: Ln(x)
Applications:
Semi-Inﬁnite interval;
f(x) →0 as x →∞
Laguerre functions (the basis set):
φn(x) ≡exp[−x/2] Ln(x)
(A.86)
Interval:
x ∈[0, ∞]
Weight:
ρ(x) ≡exp[−x/2]
(A.87)
Inner Product:
Z ∞
0
e−x Lm(x) Ln(x) dx = δmn
(A.88)
Standardization:
Ln(x) = (−1)n
n!
xn + · · ·
(A.89)
Inequality:
|φn(x)| = |exp(−x/2) Ln(x)| ≤1
(A.90)
Three-Term Recurrence and Starting Values:
L0(x) = 1
;
L1(x) = −x + 1
(A.91)
(n + 1) Ln+1(x) = {(2 n + 1) −x} Ln(x) −n Ln−1(x)
(A.92)
Differential Relations:
dm
dxm Ln+m(x) = (−1)m L(m)
n
(x)
(A.93)
where the L(m)
n
(x) are the generalized Laguerre polynomials. These can be computed by
using the recurrence
L(m)
0
(x) ≡1
;
L(m)
1
(x) ≡1 + m −x
(A.94)
(n + 1) L(m)
n+1(x) = {(2n + m + 1) −x} L(m)
n
(x) −(n + m) L(m)
n−1(x)
(A.95)
Collocation Points:
Abramowitz & Stegun(1965), NBS Handbook, pg. 923.

A.9. RATIONAL CHEBYSHEV FUNCTIONS: TLN(Y )
509
A.9
Rational Chebyshev Functions on Semi-Inﬁnite Inter-
val: TLn(y)
Interval:
y ∈[0, ∞]
(Generalization: r ∈[r0, ∞] by substituting y = r −r0 in all formulas below.) Let L de-
note a constant map parameter, user-chosen to match width of the function to be expanded.
(Some experimentation may be necessary.) Then
Chebyshev deﬁnition:
TLn(y) ≡Tn
µy −L
y + L
¶
(A.96)
Trigonometric deﬁnition:
TLn(y)
≡
cos
·
2 n arccot
µr y
L
¶¸
(A.97)
≡
cos(nt)
(A.98)
where
y ≡L cot2
µ t
2
¶
←→
t = 2 arccot
µr y
L
¶
(A.99)
Weight function:
ρ(y) ≡
1
y + L
s
L
y
(A.100)
Z ∞
0
TLm(y; L) TLn(y; L)
(
1
y + L
s
L
y
)
dy =





π
0
π/2
m = n = 0
m ̸= n
m = n > 0
(A.101)
Derivatives:
Apply trigonometric form (A.98) in Table E–6.
References: Boyd (1987b).

510
APPENDIX A. A BESTIARY OF BASIS FUNCTIONS
Table A.1: Flow Chart on the Choice of Basis Functions
If
Basis Set is
f(x) is periodic
Fourier series
f(x) is periodic & symmetric about x = 0
Fourier cosine
f(x) is periodic & antisymmetric about x = 0
Fourier sine
x ∈[a, b] & f(x) is non-periodic
Chebyshev polys.
Legendre polys.
y ∈[0, ∞] & f(y) decays exponentially as y →∞
TLn(y)
Laguerre functions
y ∈[0, ∞] & f(y) has asymptotic series
in inverse powers of y
TLn(y) only
y ∈[−∞, ∞] & f(y) decays exponentially as y →∞
TBn(y)
sinc functions or
Hermite functions
y ∈[−∞, ∞] & f(y) has asymptotic series
in inverse powers of y
TBn(y) only
f(λ, θ) is a function of latitude and longitude
spherical harmonics

A.10. GRAPHS OF CONVERGENCE DOMAINS IN THE COMPLEX PLANE
511
A.10
Graphs of Convergence Domains in the Complex Plane
Regions of convergence of various basis sets in the complex plane along with the expansion
interval appropriate to that basis. The cross-hatching indicates the region within which the
series converges. If f(x) denotes the function being expanded, then there is usually a pole
or branch point of f(x) on the curve bounding the region of convergence. In all cases,
the function f(x) has no singularities inside the convergence region; the size of the region
of convergence is thus controlled by the poles and branch points of the function which is
being approximated.
The shapes of the curves that bound that convergence regions, however, are determined
entirely by the basis set. Thus, a Chebyshev series always converges within a certain ellipse
while diverging outside that ellipse, but whether the ellipse is large or small depends on
the singularities of f(x), and which one is closest to the interval x ∈[−1, 1].
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAA
AAAA
Re(x)
AAA
AAA
AAA
AAA
Im(x)
FOURIER
Figure A.1: The convergence boundary for a Fourier series is the pair of straight lines,
Im(x) = constant
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
AAAAAAAAAAAAA
Re(x)
AAA
AAA
AAA
AAA
Im(x)
CHEBYSHEV
LEGENDRE
GEGENBAUER
Figure A.2: Chebyshev, Legendre, and Gegenbauer polynomials of all orders: ellipse with
foci at x = ±1. The foci are marked by black disks.

512
APPENDIX A. A BESTIARY OF BASIS FUNCTIONS
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAA
AAAA
Re(x)
AAA
AAA
AAA
AAA
Im(x)
HERMITE
SINC
x  ∈  [− ∞, ∞ ]
Figure A.3: Hermite & sinc functions: straight lines, Im(x) = constant
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAA
AAAA
Re(x)
AA
AA
AA
AA
Im(x)
TBn(x)
x  ∈  [− ∞, ∞ ]
Figure A.4: TBn(x): pair of circles, the contours of “bipolar” coordinates in the complex
x-plane

A.10. GRAPHS OF CONVERGENCE DOMAINS IN THE COMPLEX PLANE
513
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
AAAA
AAAA
Re(x)
AA
AA
AA
Im(x)
LAGUERRE
x  ∈  [0, ∞ ]
Figure A.5: Laguerre functions: parabola with focus at x = 0
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
AAAA
AAAA
Re(x)
AA
AA
AA
AA
Im(x)
TLn(x)
x  ∈  [0, ∞ ]
Figure A.6: TLn(x): quartic curve with no standard name

Appendix B
Direct Matrix-Solvers
“When iterating, three things may happen and two of them are bad.”
— J. P. Boyd (paraphrase of football proverb)
In football, the three fates of a forward pass are “completion” (good), “incomplete” (bad) and “interception” (very
bad). Similarly, an iteration may converge, may converge too slowly to be useful, or diverge.
B.1
Matrix Factorizations
The most efﬁcient “direct” way to solve a matrix equation is to ﬁrst simplify the square
matrix to a special factored form and then perform a “backsolve”. A “direct” method is a
non-iterative algorithm; iterative matrix-solvers are discussed in Chapter 15 above.
The three most useful factorizations are (i) the product of two triangular matrices ⃗L
and ⃗U, usually called the “LU” factorization (or “Crout reduction”) (ii) the product of a
“lower triangular” matrix ⃗L and its transpose [“Choleski factorization”], possible only for a
symmetric matrix and (iii) the product of an “orthogonal” matrix ⃗Q with an upper triangular
matrix ⃗R, commonly called the “QR” decomposition. The relative costs and merits of these
three methods are given Table B.1.
Very robust library software is available for all these algorithms, so the user need never
write his own. However, a little knowledge of matrix properties is important in choosing
the most efﬁcient subroutine.
Triangular matrices and the LU and Cholesky factorizations are deﬁned by following.
Table B.1: Cost of Matrix-Solving Methods for Dense (Full) Matrices
Note: In the cost estimates, N is the size of the (dense) matrix which is factored. The algo-
rithms all require equal numbers of additions/subtractions and multiplications/division;
the numbers are the sums of all operations.
Name
Factorization Cost
Backsolve Cost
Comments
LU
2
3 N3
2N2
Default method
Cholesky
1
3 N3
2N2
Cheaper than LU, but only
applies to symmetric matrices
QR
4
3 N3
4 N2
Good for ill-conditioned matrices, but
twice as costly as LU
514

B.1. MATRIX FACTORIZATIONS
515
Deﬁnition 45 (TRIANGULAR MATRIX) A matrix ⃗A is said to be in LOWER TRIANGULAR
or UPPER TRIANGULAR form, respectively, if
Aij = 0
whenever
j > i
[LOWER TRIANGULAR]
(B.1)
Aij = 0
whenever
i < j
[UPPER TRIANGULAR]
(B.2)
In other words, on one side, either the upper or lower, of the diagonal row of elements Aii, a trian-
gular matrix ⃗A has nothing but elements whose values are zero.
Theorem 40 (LU DECOMPOSITION OF A MATRIX) If its determinant is non-zero, then an
otherwise arbitary matrix ⃗⃗A can always be factored into the product of a lower triangular matrix ⃗⃗L
and an upper triangular matrix ⃗⃗U. For 4×4 matrices, for example,
l11
0
0
0
l21
l22
0
0
l31
l32
l33
0
l41
l42
l43
l44
1
u12
u13
u14
0
1
u23
u24
0
0
1
u34
0
0
0
1
=
a11
a12
a13
a14
a21
a22
a23
a24
a31
a32
a33
a34
a41
a42
a43
a44
(B.3)
If the matrix ⃗⃗A is REAL, SYMMETRIC, and POSITIVE DEFINITE, then it can factored into
⃗⃗L ⃗⃗L
T
= ⃗⃗A
[Cholesky decomposition]
(B.4)
where superscript T denotes the transpose. The Cholesky decomposition needs only half the number
of operations and half the storage of the standard LU decomposition.
PROOF: The elements of ⃗⃗L and ⃗⃗U [uii ≡1] are given explicitly by
lij = aij −
j−1
X
k=1
lik ukj
i ≥j
(B.5a)
uij = 1
lii
(
aij −
i−1
X
k=1
lik ukj
)
i < j
(B.5b)
which is nothing more than a restatement of the fact that the elements of ⃗⃗A are given by
the matrix product of ⃗⃗L and ⃗⃗U. The elements are computed in the order
li1, u1j; li2, u2j; . . . , li,N−1, uN−1,j; lNN,
that is, we compute one column of ⃗⃗L, then the corresponding row of ⃗⃗U, and return to
evaluate the next column of ⃗⃗L and so on. Q. E. D.
The proof ignores pivoting, which is rarely necessary for matrices arising from spectral
or ﬁnite element discretizations. Good reviews of Gaussian elimination and factorization
are given in Conte and de Boor (1980) and Forsythe and Moler (1967).
The matrices which are the Chebyshev or Legendre pseudospectral discretizations of
derivatives may be somewhat ill-conditioned, that is, generate a lot of round-off error in
the LU method, when N is large (> 100) and/or the order of the derivatives is high (third
derivatives or higher). One remedy is to use a different factorization

516
APPENDIX B. DIRECT MATRIX-SOLVERS
Theorem 41 (QR Factorization)
• An arbitrary matrix ⃗⃗A, even if rectangular or singular, can always be factored as the product
of an orthogonal matrix ⃗⃗Q multiplied on the right by a triangular matrix ⃗⃗R. (A matrix is
“orthogonal” or “unitary” if its transpose is also its inverse.)
• The matrix ⃗⃗Q is (implicitly) the product of a series of rank-one orthogonal matrices (“House-
holder transformations”). Because all transformations are unitary, QR factorization is much
more resistant to accumulation of roundoff error than the LU factorization.
• It is expensive to explicitly compute ⃗⃗Q. To solve ⃗⃗A⃗x = ⃗b, one alternative is to apply the
Householder transformations simultaneously to both ⃗⃗A and ⃗b to transform the matrix into
⃗⃗R and the vector into ⃗⃗Q
T ⃗b. The solution ⃗x is then computed by backsolving the triangular
system ⃗⃗R⃗x = ⃗b.
• Alternatively, one can use the “semi-normal equations”: one multiplication of a vector by a
square matrix followed by two triangular backsolves:
⃗⃗R
T ½
⃗⃗R⃗x
¾
= ⃗⃗A
T ⃗b
(B.6)
This has less numerical stability (to roundoff) than the “Q-and-R” or “simultaneous trans-
formation” approach, so the semi-normal backsolve is usually repeated with ⃗b replaced by
⃗b −⃗⃗A⃗x, the residual of the linear system, to provide one step of “iterative reﬁnement”.
• ⃗⃗R is a Cholesky factor of ⃗⃗A
T ⃗⃗A, that is
⃗⃗R
T ⃗⃗R = ⃗⃗A
T ⃗⃗A
(B.7)
This implies that the QR factorization doubles the bandwidth of a banded matrix; the ratio of
(QR cost)/(LU cost) is even bigger for sparse matrices than the ratio of two for dense matrices.
• If ⃗⃗A contains even a single full row, ⃗⃗R will be a dense matrix.
• For overdetermined systems, the “normal equations” ⃗⃗A
T ⃗⃗A⃗x = ⃗⃗A
T ⃗b and the QR factoriza-
tion will both give bounded solutions if the columns of ⃗⃗A are all linearly independent (“full
column rank”). However, accumulation of roundoff error is often disastrous in the normal
equations; QR factorization is much more stable.
• If the matrix is intrinsically singular, and not merely apparently singular because of accu-
mulated roundoff, ⃗⃗R will have one or more zero diagonal elements and the QR algorithm will
fail.
QR may be a useful fallback algorithm when LU software crashes with a message like
“Matrix is nearly singular”. However, my personal experience is that 95% of the occur-
rences of an ill-conditioned pseudospectral matrix arise because of a coding error. Dennis
and Schnabel (1983) give a brief and readable treatment of QR.
Deﬁnition 46 (SPARSE & DENSE) A matrix ⃗⃗A is said to be SPARSE if most of its matrix el-
ements are zero. A matrix whose elements are all (or mostly) non-zero is said to be DENSE or
FULL.

B.1. MATRIX FACTORIZATIONS
517
Figure B.1: Schematic of sparse matrix with disks representing nonzero matrix elements.
The heavy curves are the “skyline” which bounds the non-zero elements; it is (by deﬁ-
nition) symmetric with respect to the diagonal of the matrix. The right half of the ﬁgure
shows that the lower and upper triangular factors of a matrix have the same “skyline”.
Spectral methods usually generate dense matrices (alas!). The costs of the factorizations
for such dense matrices are given in Table B.1. However, domain decomposition generates
sparse matrices (with a few dense blocks). Galerkin discretizations of special differential
equations, (usually constant coefﬁcient and linear) , also generate sparse matrices (Chapter
15, Sec. 10). The LU and Cholesky factorizations can then be modiﬁed to omit operations
on the zero elements, thereby greatly reducing cost.
Because matrix sparsity occurs in many patterns and can generate enormous savings, a
huge literature on “sparse matrix” methods has arisen. We cannot possibly do it justice in
an appendix, but must instead refer the reader to a good book on numerical linear algebra.
However, some patterns are so common that it is worthwhile to brieﬂy describe them here.
The most general sparse matrix software which can be explained in simple terms is a
“skyline solver”. Kikuchi (1986) gives both FORTRAN and BASIC codes and also a good
explanation of the rather complicated “skylines” that can arise from ﬁnite element and
spectral element discretizations. The concept of the “skyline”, which is deﬁned formally
below , is important because it is preserved by LU factorization as also illustrated in the
graph.
Deﬁnition 47 (SKYLINE of a MATRIX) Let all the nonzero elements of a matrix ⃗A satisfy the
inequality
Aij, Aji = 0 ∀|i −j| ≥σ(i)
where σ(i) is chosen to be as small as possible for each i. Then σ(i) is the “SKYLINE” of the matrix
⃗A.
The crucial point is that if the matrix is sparse, many of the operations above involve
only elements known to be zero. The cost of the factorization can be greatly reduced by
replacing the upper limits on the sums by the skyline function σ(i).
The factorization allows the original problem
⃗⃗A ⃗x = ⃗f
(B.8)
to be written without approximation as
⃗⃗L⃗g = ⃗f
(B.9)
⃗⃗U ⃗x = ⃗g
(B.10)

518
APPENDIX B. DIRECT MATRIX-SOLVERS
The “backsolve” step is to compute ⃗x from these triangular matrix equations in O(2N 2)
operations through the recursions (“backsolve” steps)
g1 = 1
l11
f1
(B.11)
gi = 1
lii


fi −
i−1
X
j=1
lij gj



i = 2, 3, . . . , N
(B.12)
xN = gN
(B.13)
xi = gi −
N
X
j=i+1
uij xj
i = (N −1), (N −2), . . . , 2
(B.14)
Like the LU factorization, the backsolve step can also be greatly reduced in cost by exploit-
ing the sparsity of the matrix ⃗A: eliminating operations on elements known a priori to be
zero.
In many cases, a general skyline solver is inefﬁcient because the matrix has very simple
patterns of sparsity. We describe three useful special cases of sparse matrices in the next
four sections.
B.2
Banded Matrix
Deﬁnition 48 (BANDWIDTH OF A MATRIX) A matrix ⃗⃗A is said to be of BANDWIDTH
(2m + 1) if its elements satisfy the equation
aij = 0
for all
|i −j| > m
(B.15)
The special case m = 1 has at most three non-zero elements in each row (or column) and is called
“TRIDIAGONAL”. The special case m = 2 has at most ﬁve non-zero elements in each row and is
called “PENTADIAGONAL”.
Theorem 42 (LU DECOMPOSITION: BANDED MATRIX) The LU decomposition of a ma-
trix of bandwidth (2m + 1) has factors which are of the same bandwidth, (2m + 1), in addition to
being triangular.
The cost of performing an LU decomposition is
# multiplications = N(m2 + m)
(B.16)
# additions = Nm2
(B.17)
Eqs. (B.5) through (B.13) still apply; we merely truncate the sums to reﬂect the bandwidth of ⃗⃗A,
⃗⃗L, and ⃗⃗U.
A number of special cases are collected in Table B.2.
PROOF: The bandwidth preserving property can be shown directly from (B.5).

B.2. BANDED MATRIX
519
Table B.2: Operation Counts for Gaussian Elimination.
There are two steps in solving a matrix equation: (i) the LU factorization of the square
matrix ⃗⃗A, which must be repeated whenever ⃗⃗A is altered and (ii) the backsolve, which must
be repeated for each different column vector ⃗f. The costs for each step are shown separately
below because it is common (in semi-implicit time stepping algorithms, for instance) to
perform only a single LU factorization followed by many backsolves (one per time step).
Below, we list the costs for general m under the simplifying assumptions that (i) N ≫m
where N is the dimension of the matrix and (ii) multiplications and divisions are equally
costly and additions and subtractions are equally costly. Warning: all entries assume piv-
oting is unnecessary.
(a) Full matrix
LU factorization:
N 3/3 mults.
&
N 3/3 adds.
Backsolve:
N 2 mults.
&
N 2 adds.
(b) Banded matrix of bandwidth m
LU factorization:
N(m2 + m) mults.
&
Nm2
adds.
Backsolve:
N(2m + 1) mults.
&
N(2m) adds.
(c) Special bandwidths.
The ﬁrst number listed in each pair is the number of multiplications or divisions; the second
is the number of additions and subtractions.
m
Name
LU total
Backsolve
LU+Backsolve
1
[Tridiagonal]
2N & N
3N & 2N
5 N mult. & 3 N add.
2
[Pentadiagonal]
6N & 4N
5N & 4N
11 N mult. & 8 N add.
3
[Heptadiagonal]
12N & 9N
7N & 6N
19 N mult. & 15 N add.
4
[Enneadiagonal]
20N & 16N
9N & 8N
29 N mult. & 24 N add.
5
[Hendecadiagonal]
30N & 25N
11N & 10N
41 N mult. & 35 N add.
6
[Tridecadiagonal]
42N & 36N
13N & 12N
55 N mult. & 48 N add.

520
APPENDIX B. DIRECT MATRIX-SOLVERS
B.3
Matrix-of-Matrices Theorem
Theorem 43 (MATRICES WHOSE ELEMENTS ARE MATRICES)
All the ordinary rules of matrix multiplication and factorization, including the LU decomposi-
tion for full and banded matrices, still apply when the elements of the matrix are themselves matrices,
provided one is careful about the non-commutativity of matrix multiplication.
PROOF: Matrix operations (addition, subtraction, multiplication, and division) obey ex-
actly the same rules as those for ordinary numbers except that division must be interpreted
as multiplication by the inverse matrix and multiplication and division are not commuta-
tive. It follows that formulas like (B.5) – (B.13) will remain true when the aij, lij, and uij
are matrices so long as we do not reverse the order of any factors. The division by lii in
(B.11) was written as left multiplication by the inverse of lii precisely for this reason. Q. E.
D.
This matrix-of-matrices concept has many interesting applications. In the next two sec-
tions, we shall discuss a couple.
B.4
Block-Banded Elimination: the “Lindzen-Kuo” Algo-
rithm
When the usual second order ﬁnite differences are applied to a second order boundary
value problem in two dimensions1, the result is a matrix of dimension (MN) × (MN).
When the differential equation is everywhere elliptic and sufﬁciently well-behaved, the
matrix problem may be quite efﬁciently solvable through Successive Over-Relaxation or
some other iterative method. However, the iterations usually diverge if the matrix is not
positive deﬁnite, and this can happen even for a harmless Helmholtz equation like
△u + K u = f
(B.18)
for constant K where K is sufﬁciently large and positive. (However, multi-grid iterations
may work even for an indeﬁnite matrix if Gaussian elimination is used on the coarsest
grid.)
An alternative is to apply Gaussian elimination (Lindzen and Kuo, 1969) in such a way
as to exploit the “block-banded” structure of the matrix. By “block-banded” we mean
that the matrix is tridiagonal if we group square blocks of dimension M × M together.
Alternatively, we can simply treat the “block-banded” matrix as an ordinary banded matrix
of bandwidth 3M, but it is conceptually simpler and algorithmically more efﬁcient to use
the block structure instead.
The history of the Lindzen-Kuo note is rather illuminating. Although the method is
often called the “Lindzen-Kuo” method in geophysics since most applications in that area
trace their ancestry back to their note, band LU factorization is a very obvious idea. They
themselves eventually found an earlier reference in Richtmyer (1957) but chose to write a
note anyway because most numerical analysis texts did not discuss Gaussian elimination
even in the context of one-dimensional boundary value problems, preferring “shooting”
instead.
1The same is true in three dimensions, but we will discuss only two dimensions for simplicity — and because
the matrices are usually too large for this method to be practical in three dimensions.

B.4. BLOCK-BANDED ELIMINATION: THE “LINDZEN-KUO” ALGORITHM
521
The reason for this is not that block-banded elimination doesn’t work, but rather that it
is difﬁcult to prove that it does. Lindzen and Kuo found empirically, however, that block-
banded elimination is very robust. It worked for “stiff” one-dimensional problems with
many alternating regions of exponential and oscillatory behavior, applied with as many
as 2000 grid points. It was equally successful in solving two-dimensional boundary value
problems of mixed elliptic-hyperbolic type. I have used the method with great success
myself, including cases in which one dimension was treated with ﬁnite differences and the
other with Chebyshev polynomials.
Second order ﬁnite differences give, for a one dimensional boundary value problem, an
ordinary tridiagonal matrix. For a two-dimensional BVP, these methods generate a block
tridiagonal matrix, that is to say, a matrix which is in the same form as a tridiagonal matrix
of dimension N except that each “element” is itself a matrix of dimension M where M is
the number of grid points in the second coordinate.
The beauty of the “matrix-of-matrices” concept is that it implies we can solve both one-
and two-dimensional problems by exactly the same algorithm. Since tridiagonal and block
tridiagonal matrices are so important in applications — in particular, they are generated by
Chebyshev methods in a number of important special cases — it is useful to write down
explicit formulas.
Since there are no more than three non-zero elements or blocks in each matrix, it is
helpful to denote each by a symbol with a single subscript. The LU factorization is
α1
0
0
0
b2
α2
0
0
0
b3
α3
0
0
0
b4
α4
1
δ1
0
0
0
1
δ2
0
0
0
1
δ3
0
0
0
1
=
a1
c1
0
0
b2
a2
c2
0
0
b3
a3
c3
0
0
b4
a4
(B.19)
for the 4×4 case. Note that the “subdiagonal” elements bi are identical with the “subdiag-
onal” of L, so we only have to compute two elements (or M × M matrices) for each of the
N rows of ⃗⃗L and ⃗⃗U.
The solution of the tridiagonal problem
⃗⃗A ⃗x = ⃗f
(B.20)
is then
α1 = a1
(B.21)
g1 = (α1)−1 f1
(B.22)
δi = α−1
i
ci
i = 1, . . . , N −1
(B.23)
αi+1 = ai+1 −bi+1 δi
(B.24)
gi+1 = (αi+1)−1 [fi+1 −bi+1 gi]
(B.25)
and the backward recurrence
xN = gN
(B.26)
xj = gj −δj xj+1
j = N −1, N −2, . . . , 1
When this is applied to block tridiagonal matrices, we have a problem: the inverse of
a sparse matrix is generally a full matrix. Consequently, even if the block matrices ai, bi,

522
APPENDIX B. DIRECT MATRIX-SOLVERS
and ci are themselves tridiagonal, as would be true with ﬁnite differences in both direc-
tions, all the δi and all the αi matrices except α1 are full matrices. For this reason, a mixed
pseudospectral-ﬁnite difference algorithm is very appealing (Boyd, 1978c); we sacriﬁce noth-
ing by using collocation with M points since the matrices generated during Gaussian elim-
ination will be full anyway, regardless of whether ai, bi, and ci are sparse (ﬁnite difference)
or full (pseudospectral).
Above, we segregated the LU factorization on the left and the steps for the backsolve
on the right because if we are only going to compute a single solution for a given matrix
⃗⃗A, it is most efﬁcient to compute the back-solve intermediate, ⃗g, on the same forward pass
in which we convert the αi. That way, we only need to store the δi matrices at a cost of
(NM 2) memory cells. This method is simpler even for a one dimensional problem since
the complete solution is computed with just two DO loops.
To compute many solutions with the same matrix ⃗⃗A but different ⃗f — the normal sit-
uation in an implicit time-stepping code — then one would perform the steps on the left
only once, and solve for ⃗g and ⃗x in a separate subroutine. Unfortunately, this needs the LU
factors of the αi in addition to the δi, requiring 2NM 2 storage.
The rate-determining step is solving αiδi = ci, which requires Gaussian elimination on
a total of N matrices at a cost of O(NM 3). This is obviously much more expensive than
an optimized iterative method, which is O(NM log M). Each back-solve requires O(NM 2)
operations.
It goes without saying that block-elimination is a method of last resort; iterative meth-
ods are always much faster when they can be applied. However, geophysical wave equa-
tions are often of mixed elliptic-hyperbolic or lack the property of positive deﬁniteness
even when everywhere elliptic. The great strength of the block LU algorithm is that it is
very robust. It always gives a solution even for those ghastly equations of mixed type2. It is
very successful in one-dimensional problems where “shooting” or even “parallel shooting”
would fail.
Geophysical applications include Lindzen (1970), Lindzen & Hong (1974), Forbes and
Garrett (1976), and Schoeberl & Geller (1977).
B.5
Block and “Bordered” Matrices: the Faddeev-Faddeeva
Factorization
When Galerkin’s method with Chebyshev polynomials is applied to
uxx + K u = f(x)
(B.27)
where K is constant, the result (after a little algebra) is almost a tridiagonal matrix (Chap-
ter 15, Sec. 10). (Actually, two tridiagonal matrices since we would normally split f(x) into
symmetric and antisymmetric parts (Chapter 8) because the alternative is solving a pen-
tadiagonal matrix of twice the dimension and half its elements equal to zero.) Although
most rows of one of these two Galerkin matrices do contain only three non-zero elements,
we must use one row of each matrix to impose the boundary condition, and this row has
all non-zero elements.
There are two ways to deal with this. First, one can use the formulas for the general LU
decomposition to show that the property of having just one full row can be preserved by
the LU factorization. Consequently, one can apply (B.5)–(B.13) in such a way that all the
2At least for geophysical problems with so-called “inertial” or “critical” latitudes.

B.5. BLOCK AND “BORDERED” MATRICES
523
sums are taken over just two elements except for one row where the sum runs over all N
elements.
The second way is “matrix-bordering” (Faddeev & Faddeeva, 1963, Strang & Fix, 1973
). To solve
⃗⃗A ⃗x = ⃗f,
(B.28)
write ⃗⃗A in the block form
⃗⃗A =
⃗⃗A11
⃗⃗A12
⃗⃗A21
⃗⃗A22
(B.29)
where the ⃗⃗Aij are themselves matrices. The blocks can be of different sizes provided they
follow the pattern shown below where m is an integer such that 1 ≤m < N
⃗⃗A11 : m × m
⃗⃗A12 : m × (N −m)
⃗⃗A21 : (N −m) × m
⃗⃗A22 : (N −m) × (N −m)
(B.30)
For example, if ⃗⃗A is tridiagonal except for a full row at the bottom, we can pick ⃗⃗A11 to be
the (N −1) × (N −1) tridiagonal matrix. Then the dimensions of the blocks are
⃗⃗A11 : (N −1) × (N −1)
⃗⃗A12 : (N −1) × 1
⃗⃗A21 : 1 × (N −1)
⃗⃗A22 : 1 × 1
(scalar!)
(B.31)
⃗⃗A can be written as the product of matrices ⃗⃗L and ⃗⃗U of block form, too:
⃗⃗L11
0
⃗⃗L21
⃗⃗L22
⃗⃗U11
⃗⃗U12
⃗⃗0
⃗⃗U22
=
⃗⃗A11
⃗⃗A12
⃗⃗A21
⃗⃗A22
(B.32)
where both ⃗⃗L & ⃗⃗U are triangular and
⃗⃗L11 ⃗⃗U11 = ⃗⃗A11
(B.33)
⃗⃗L21 ⃗⃗U11 = ⃗⃗A21
(B.34)
⃗⃗L11 ⃗⃗U12 = ⃗⃗A12
(B.35)
⃗⃗L22 ⃗⃗U22 = ⃗⃗A22 −⃗⃗L21 ⃗⃗U12
(B.36)
Optionally, one can force the diagonal blocks of ⃗⃗U to be identity matrices, but this would
save no labor. To solve (B.35), we must compute the LU factorization of ⃗⃗A11 anyway. Con-
sequently, the program is simpler and no less efﬁcient if we choose ⃗⃗U11 to be one of the
usual LU factors of ⃗⃗A11. Taking the transpose of (B.34) gives
⃗⃗U
T
11 ⃗⃗L
T
21 = ⃗⃗A
T
21
(B.37)

524
APPENDIX B. DIRECT MATRIX-SOLVERS
which can be easily solved for ⃗⃗L21 since the transpose of ⃗⃗U11 is a lower triangular matrix.
We then can solve (B.33)–(B.36) in sequence to obtain the block factorization of ⃗⃗A.
The crucial point is that if ⃗⃗A11 is banded, then ⃗⃗L11 and ⃗⃗U11 will be banded also. Thus, if
⃗⃗A11 is tridiagonal, as in Orszag and Kells(1980), we can ﬁnd its factors in O(N) operations.
The remaining steps cost O(N) operations for the same reason. The fact that ⃗⃗A21 is a full
row implies that ⃗⃗L21 will be full also, but the extra expense is only O(N).
L. M. Delves has developed spectral iterations which require inverting matrices with an
m × m full block for ⃗⃗A11 but with zeros in all elements outside this block except along the
main diagonal (Delves and Freeman, 1981). The work is O((2/3)m3+kN log2 N) operations
per iteration; if m ≪N and the number of iterations is not too large, this is much faster
than solving the full N × N matrix problem via Gaussian elimination. At present, Delves’
spectral/block iteration method is the fastest for solving integral equations via Chebyshev
polynomials. It can be applied to differential equations, too. Details are given in the mono-
graph by Delves and Freeman (1981) and Chapter 15.
B.6
Cyclic Banded Matrices (Periodic Boundary Conditions)
For periodic boundary conditions, ﬁnite difference methods — useful as pseudospectral
pre-conditioners — generate so-called “cyclic” banded matrices.
Outside the diagonal
band, the only non-zero elements are those in a small triangular region in the upper right
corner. Temperton (1975) and Navon (1987) describe matrix factorizations for cyclic ma-
trices. However, these are unnecessary for periodic problems with parity: the symmetries
give rise to ordinary banded banded matrices — very helpful when using ﬁnite differences
to precondition an iteration with a Fourier cosine or Chebyshev pseudospectral
B.7
Parting shots
• Always use a direct, rather than an iterative method, if you can afford it. Direct
methods almost always work; iterative schemes sometimes fail.
• Iterative methods are considerably less robust for real-world problems than for the
idealized problems in the textbooks of mathematicians.
• Hotellier proved in 1944 that Gaussian elimination (LU factorization) could magnify
roundoff error by 4N where N is the size of the matrix. This would seem to make it
impossible to solve matrix problems with N > 40 even in seventeen decimal place
arithmetic! However, this worst case is exceedingly rare in practice. In numerical
analysis, there is sometimes an enormous gap between what can be proven and what
actually happens.
• Clever matrix-of-a-matrix methods have lowered the asymptotic cost of solving a
dense matrix from O(N 3) operations to O(N 2.376). L. N. Trefethen has a $100 bet with
P. Alfeld that the exponent will lowered to O(N 2+ϵ) for arbitrarily small ϵ by 2006.
However, these new algorithms have huge proportionality constants. Consequently,
Gaussian elimination is the best unless N is really, really huge. A numerical analyst’s
concept of efﬁciency is the N →∞limit, which may have little to do with engineering
reality.

B.7. PARTING SHOTS
525
Trefethen and Bau(1997) give more information about roundoff and asymptotically
cheap algorithms.
Karageorghis and Paprzycki(1996, 1998), and earlier papers by Karageorghis and col-
laborators, describe efﬁcient direct methods even for the somewhat complicated matrices
generated by spectral domain decomposition.

Appendix C
The Newton-Kantorovich Method
for Nonlinear Boundary &
Eigenvalue Problems
“Nature and Nature’s laws were hid in night. God said: Let Newton be! and all was light.”
— Alexander Pope (1688–1744)
“ . . . with his prism and silent face . . . a mind forever voyaging through strange seas
of thought, alone.”
— William Wordsworth (of Sir Isaac Newton)
C.1
Introduction
Most algorithms for solving nonlinear equations or systems of equations are variations of
Newton’s method. When we apply spectral, ﬁnite difference, or ﬁnite element approxima-
tions to a nonlinear differential equation, the result is a nonlinear system of algebraic equations
equal in number to the total number of degrees of freedom, regardless of whether the de-
grees of freedom are the grid point values of the solution, {u(xi)}, or the coefﬁcients of
the spectral series for u(x), {an}. We must then apply Newton’s method — or something
equivalent to it — to iterate from a ﬁrst guess until the numerical solution is sufﬁciently
accurate.
There are several practical difﬁculties. First, we need a ﬁrst guess — this is a universal
problem, and no choice of iteration scheme can eliminate it. Second, Newton’s method
requires the elements of the “Jacobian matrix” of the system of equations. If we write the
system as
Fi(a0, a1, . . . , aN) = 0
i = 0, . . . , N
(C.1)
then the elements of the Jacobian matrix ⃗⃗J are
Jij ≡∂Fi/∂aj
i, j = 0, . . . , N
(C.2)
526

C.1. INTRODUCTION
527
It is usually messy and time-consuming to calculate the Jacobian, which must (in a strict
Newton’s method) be recomputed at each iteration. Third, each iteration requires inverting
the Jacobian. If we let ⃗a(i) denote the vector of the spectral coefﬁcients at the i-th iteration,
then
⃗a(i+1) = ⃗a(i) −⃗⃗J
−1 ⃗⃗F
(C.3)
where ⃗F is the vector whose elements are the equations of the system and where both ⃗F
and ⃗⃗J are evaluated using ⃗a = ⃗a(i). This may be the most expensive step of all since the
Jacobian matrix — at least with pseudospectral methods — is usually a full matrix, so it
costs O(N 3) operations to determine each iterate from its predecessor.
Resolving the ﬁrst difﬁculty requires the “continuation” method discussed below, but
we can often reduce the magnitude of the second and third problems by applying New-
ton’s method directly to the original differential equation, and then applying the spectral
method to convert the resulting iterative sequence of linear differential equations into the
corresponding linear matrix problem. When Newton’s method is applied directly to a
differential equation — rather than to algebraic equations — it is often called the “Newton-
Kantorovich” method.
The justiﬁcation for the ordinary Newton’s method is a Taylor expansion followed by
linearization. If we wish to solve f(x) = 0, then assuming we have a good guess for a root,
x ≈x(i), we can Taylor expand f(x) to obtain
f(x) = f(x(i)) + fx(x(i))
h
x −x(i)i
+ O
µh
x −x(i)i2¶
(C.4)
If our guess is sufﬁciently good, we can ignore the quadratic terms and treat (C.4) as a linear
equation for x,
x(i+1) = x(i) −f(x(i))
fx
¡
x(i)¢
(C.5)
This is identical with (C.3) except for the extension from one unknown to many.
To illustrate the generalization known as the Newton-Kantorovich method, consider
the ﬁrst order differential equation
ux = F(x, u[x])
(C.6)
Suppose we have an iterate, u(i)(x), which is a good approximation to the true solution
u(x). Taylor expand (C.6) about this function:
ux = F
³
x, u(i)[x]
´
+ Fu
³
x, u(i)[x]
´ h
u(x) −u(i)(x)
i
+ O
µh
u −u(i)i2¶
(C.7)
where Fu denotes the derivative of the function F(x, u) with respect to u. This implies that
the linear differential equation for the next iterate is
u(i+1)
x
−{Fu}u(i+1) = F −Fu u(i)
(C.8)
where F and Fu are both evaluated with u = u(i). Equivalently, we can solve a differential
equation for the correction to the iterate by deﬁning
u(i+1)(x) ≡u(i)(x) + △(x)
(C.9)

528
APPENDIX C. NEWTON ITERATION
Then △(x) is the solution of
△x −{Fu}△=
n
F −u(i)
x
o
(C.10)
Since Taylor expansions about a function instead of a point may be unfamiliar, a brief ex-
planation is in order. Technically, operations on functionals, which we may loosely deﬁne
as “functions of a function”, are described by a branch of mathematics called “functional
analysis”. The most elementary and readable introduction is a little paperback by W. W.
Sawyer (1978).
The punchline is this: the linear term in a generalized Taylor series is actually a linear op-
erator. In (C.3), the operator is multiplication by the Jacobian matrix. In (C.10), the operator
is the differential operator that is applied to △(x) to generate the L. H. S. of the equation. In
either case, this linear operator is known as a “Frechet derivative”. The general deﬁnition
is the following.
Deﬁnition 49 (FRECHET DERIVATIVE) Given a general nonlinear operator N(u), which may
include derivatives or partial derivatives, its FRECHET DIFFERENTIAL is deﬁned by
Nu△≡lim
ϵ→0
N(u + ϵ △(x)) −N(u)
ϵ
(C.11)
which is equivalent to
Nu △≡∂N(u + ϵ △)
∂ϵ
¯¯¯¯
ϵ=0
(C.12)
The numerical result, Nu△, is the FRECHET DIFFERENTIAL of the operator N in the direction
△while Nu is the FRECHET DERIVATIVE and is a linear operator.
This deﬁnition is an algorithm for computing the ﬁrst order Taylor term. We merely
multiply △(x) by a dummy variable ϵ and then take the partial derivative of N(u, x; ϵ)
with respect to ϵ in the usual way, that is, with u and x kept ﬁxed. The dummy variable ϵ
takes us away from the complicated world of functional analysis into the far simpler realm
of ordinary calculus.
The need for the “direction △(x)” in the deﬁnition of the Frechet differential can be
seen by expanding u(x) in a spectral series. The operator equation N(u) = 0 becomes a
system of nonlinear algebraic equations. When a function depends upon more than one
unknown, we cannot specify “the” derivative: we have to specify the direction. The Frechet
differential is the “directional derivative” of ordinary multi-variable calculus.
What is important about the Frechet derivative is that it gives the linear term in our
generalized Taylor expansion: for any operator N(u),
N(u + △) = N(u) + Nu(u) △+ O(△2)
[Generalized Taylor Series]
(C.13)
For the special case in which N(u) is a system of algebraic equations,
⃗⃗F
³
⃗a + ⃗△
´
= ⃗⃗F (⃗a) + ⃗⃗J ⃗△+ O
³
⃗△2´
(C.14)
the Frechet derivative is the Jacobian matrix ⃗⃗J of the system of functions ⃗F (⃗a).
With this deﬁnition in hand, we can easily create a Newton-Kantorovich iteration for
almost any equation, and we shall give many examples later. An obvious question is: Why

C.2. EXAMPLES
529
bother? After all, when we apply the pseudospectral method (or ﬁnite difference or ﬁnite
element algorithms) to the linear differential equation that we must solve at each step of
the Newton-Kantorovich iteration, we are implicitly computing the Jacobian of the system
of equations that we would have obtained by applying the same numerical method ﬁrst,
and then Newton’s method afterwards.
There are two answers. First, it is often easier to write down the matrix elements in
the Newton-Kantorovich formalism. If we already have a subroutine for solving linear
differential equations, for example, we merely embed this in an iteration loop and write
subroutines deﬁning F(x, u) and Fu(x, u). It is easy to change parameters or adapt the
code to quite different equations merely by altering the subroutines for F(x, u), etc.
The second answer is that posing the problem as a sequence of linear differential equa-
tions implies that we also have the theoretical machinery for such equations at our disposal.
For example, we can apply the iterative methods of Chapter 15, which solve the matrix
problems generated by differential equations much more cheaply than Gaussian elimina-
tion.
In principle, we could use all these same tricks even if we applied Newton’s method
second instead of ﬁrst — after all, we are always in the business of solving differential
equations, and reversing the order cannot change that. Conceptually, however, it is much
simpler to have the differential equation clearly in view.
C.2
Examples
The second order ordinary differential equation
uxx = F(x, u, ux)
(C.15)
generates the iteration
△xx −Fux△x −Fu△= F −u(i)
xx
(C.16)
where F and all its derivatives are evaluated with u = u(i) and ux = u(i)
x , and where △(x),
as in the previous section, is the correction to the i-th iterate:
u(i+1)(x) ≡u(i)(x) + △(x)
(C.17)
The Frechet derivative is more complicated here than for a ﬁrst order equation because u(x)
appears as both the second and third arguments of the three-variable function F(x, u, ux),
but the principle is unchanged.
For instance, let
F(x, u, ux) ≡α(ux)2 + exp(x u[x])
(C.18)
The needed derivatives are
Fu(x, u, ux) = x exp(x u)
(C.19)
Fux(x, u, ux) = 2 α ux
(C.20)
We can also extend the idea to equations in which the highest derivative appears non-
linearly. Norton (1964) gives the example
u uxx + A(ux)2 + B u = B
·
20 + 1
12 sin(πx)
¸
(C.21)

530
APPENDIX C. NEWTON ITERATION
which, despite its rather bizarre appearance, arose in analyzing ocean waves. We ﬁrst
deﬁne N(u) to equal all the terms in (C.21). Next, make the substitution u →u + ϵ△and
collect powers of ϵ. We ﬁnd
N(u + ϵ △) =
©
u uxx + A(ux)2 + B u −B
£
20 + 1
12 sin(πx)
¤ª
(C.22)
+ϵ {u △xx + uxx △+ 2 A ux △x + B △} + ϵ2 n
△△xx + A (△x)2o
To evaluate the Frechet derivative, we subtract the ﬁrst line of the R. H. S. of (C.22) — the
term independent of ϵ — and then divide by ϵ. When we take the limit ϵ →0, the term in
ϵ2 disappears as we could have anticipated directly from its form: it is nonlinear in △, and
the whole point of the iteration is to create a linear differential equation for △. Thus, the
Frechet derivative is equal to the linear term in the expansion of N(u + ϵ△) in powers of ϵ,
and this is a general theorem. Our generalized Taylor series is then
N(u + △) ≈N(u) + Nu(u) △
(C.23)
and equating this to zero gives
Nu(u) △= −N(u)
(C.24)
which is
u(i) △xx + 2 A u(i)
x △x + (u(i)
xx + B) △
(C.25)
= −
½
u(i) u(i)
xx + A(u(i)
x )2 + B u(i) −B
·
20 + 1
12 sin(πx)
¸¾
Inspecting (C.25), we see that the R. H. S. is simply the ϵ-independent term in the power
series expansion of N(u + ϵ△). The L. H. S. is simply the term in the same series which
is linear in ϵ. Once we have recognized this, we can bypass some of the intermediate steps
and proceed immediately from (C.22) to (C.25). The intermediate equations, however, are
still conceptually important because they remind us that the iteration is simply a generalized
form of Newton’s method.
We have not discussed boundary conditions, but these are usually obvious. If the ﬁrst
guess satisﬁes the boundary condition, then we can safely impose homogeneous boundary
conditions on △(x) at all iterations. However, we must be careful to impose conditions that
are consistent with those on u(x). If we have Dirichlet conditions, u(−1) = α, u(1) = β,
then we would set △(±1) = 0. With Neuman conditions on u(x), du/dx(−1) = α and
du/dx(1) = β, then we would impose d△/dx(±1) = 0. Finally, periodic boundary condi-
tions, i. e. using a Fourier series, should be imposed on △(x) if the problem speciﬁes such
conditions for u(x).
The Newton-Kantorovich method applies equally well to partial differential equations
and to integral equations. For example,
uxx + uyy +
q
u2x + u2y = 0
(C.26)
generates the iteration
△xx + △yy +
ux △x + uy △y
r³
u(i)
x
´2
+
³
u(i)
y
´2
(C.27)
−
(
u(i)
xx + u(i)
yy +
r³
u(i)
x
´2
+
³
u(i)
y
´2
)

C.3. EIGENVALUE PROBLEMS
531
We can create an iteration even for the most bizarre equations, but the issues of whether
solutions exist for nonlinear equations, or whether they are smooth even if they do exist,
are very difﬁcult — as difﬁcult as the Newton-Kantorovich method is elementary.
C.3
Eigenvalue Problems
When the equation is nonlinear, the distinction between eigenvalue and boundary value
problems may be negligible. A linear boundary value problem has a solution for arbitrary
forcing, but a linear eigenvalue problem has a solution only for particular, discrete values
of the eigenparameter. It is rather different when the eigenvalue problem is nonlinear.
For example, the periodic solutions of the Korteweg-deVries equation (“cnoidal waves”)
and the solitary waves (also called “solitons”) of the same equation satisfy the differential
equation
uxxx + (u −c) ux = 0
[Korteweg-deVries Eq.]
(C.28)
where c is the eigenvalue. The KDV equation can be explicitly solved in terms of the so-
called elliptic cosine function, and this makes it possible to prove that solutions exist for a
continuous range of c:
u(−∞) = u(∞) = 0
:
Solitary waves exist for any c > 0
(C.29)
u(x) = u(x + 2π)
:
Cnoidal waves exist for any c > −1.
(C.30)
What makes it possible for the eigenparameter to have a continuous range is that for a
nonlinear differential equation, the relative magnitude of different terms changes with the
amplitude of the solution. For the Korteweg-deVries problem, the wave amplitude for either
of the two cases is a unique, monotonically increasing function of c.
For other problems in this class, the wave amplitude need not be a monotonic function
of a nor is the solution necessarily unique. For example, if we replace the third degree term
in (C.28) by a ﬁfth derivative, one can show (Boyd, 1986b) that in addition to the usual
solitons with a single peak, there are also solitons with two peaks, three peaks, etc. (The
multi-peaked solitons are actually bound states of the single-peaked solitons.)
The existence of solutions for a continuous range of the eigenparameter, instead of merely
a set of discrete values of c, is a common property of nonlinear equations. It follows that
to compute a solution to (C.28), for example, one can simply choose an almost-arbitrary
value of c — “almost-arbitrary” means it must be larger than the cutoffs shown in (C.29)
and (C.30) — and then solve it by the Newton-Kantorovich method as one would any other
boundary value problem. The equation for the correction △(x) to u(i)(x) is
△xxx + (u(i) −c) △x + u(i)
x △= −u(i)
xxx + (u(i) −c) u(i)
x
(C.31)
The only possible complication in solving (C.31) is that the operator on the L. H. S.
has two eigensolutions with zero eigenvalue. In a word, (C.31) does not have a unique
solution. The physical reason for this is that the solitons of the Korteweg-deVries equation
form a two-parameter family.
The ﬁrst degree of freedom is translational invariance: if u(x) is a solution, then so is
u(x + φ) for arbitrary constant φ. If we Taylor expand u(x + φ) and keep only the ﬁrst term
so as to be consistent with the linearization inherent in (C.31), then
u(x + φ) = u(x) + φdu
dx + O(φ2)
(C.32)

532
APPENDIX C. NEWTON ITERATION
must be a solution of the linearized Korteweg-deVries equation for arbitrary φ. It follows
that the solution of (C.31) is not unique, but is determined only to within addition of an
arbitrary amount of
△1(x) ≡du
dx
(C.33)
which therefore is an eigenfunction (with zero eigenvalue) of the linear operator of (C.31).
Fortunately, the solitons are symmetric about their peak. The derivative of a symmetric
function is antisymmetric. It follows that the column vector containing the spectral coef-
ﬁcients of du/dx is not a linear eigenfunction of the discretized form of (C.31) when the
basis set is restricted to only symmetric basis functions (either cosines, in the periodic case,
or even degree rational Chebyshev functions on the inﬁnite interval).
The second degree of freedom is that if u(x) is a solution of (C.28), then so is
v(x) = −ϵ + (1 + ϵ) u
¡√
1 + ϵ x
¢
(C.34)
for arbitrary ϵ. (In technical terms, the KdV equation has a continuous Lie group symmetry,
in this case, a “dilational” symmetry.) Again, we must Taylor expand v(x) so as to remain
consistent with the linearization inherent in (C.31). We ﬁnd that the other eigenfunction
[the O(ϵ) term in (C.34)] is
△2(x) ≡−1 + u(x) + x
2
du
dx
(C.35)
We can exclude △2(x) on the inﬁnite interval by imposing the boundary condition
u(±∞) = 0. Adding a term proportional to △2(x), although consistent with the differ-
ential equation (C.31), would violate the boundary condition because △2(x) asymptotes to
a non-zero constant at inﬁnity. In a similar way, we can remove the non-uniqueness for the
periodic case by imposing the condition that the average of u(x) over the interval is 0. The
simplest way to implement this condition is to omit the constant from the basis set, using
only the set {cos(nx)} with n > 0 to approximate the solution.
Once we have computed the soliton or cnoidal wave for a given c, we can then take that
single solution and generate a two-parameter family of solutions by exploiting these two
Lie group symmetries. Thus, the translational and dilational symmetries are both curse
and a blessing. The symmetries complicate the calculations by generating two eigenmodes
with zero eigenvalues. However, the symmetries are also a blessing because they reduce
the number of parameters by two.
For some differential equations, solutions exist only for discrete values of the eigenpa-
rameter. An example is van der Pol’s equation:
utt + u = Γ ut (1 −u2)
[Van der Pol’s Eq.]
(C.36)
If we replaced the term in the () by a constant, then (C.36) would describe a harmonic
oscillator which was damped or excited depending on the sign of the constant. Because this
“constant” in (C.36) is actually a function of u(x), we see that the solution of the nonlinear
equation is self-excited when u is small and self-damping when u is large. When (C.36) is
given an arbitary initial condition, the solution eventually settles down to a nonlinear limit
cycle in which the damping and self-excitation balance out over the course of one period of
the cycle to create a permanent, self-sustaining oscillation.
We can solve for the period and structure of the limit cycle as a nonlinear eigenvalue
problem by adopting the following device. Let ω denote the (unknown) frequency of the
limit cycle. If we make the change of variable
x ≡ωt,
(C.37)

C.3. EIGENVALUE PROBLEMS
533
then the limit cycle will automatically be periodic with a period of 2π and we can compute
a solution by assuming a Fourier series in x1. The problem is then
ω2uxx + u = Γ ω ux(1 −u2)
(C.38)
In contrast to the undamped Korteweg-deVries equation, it is not possible to pick an
arbitrary value of ω and ﬁnd a solution. The reason is that the tug-of-war between the
damping and the self-excitation normally has only a single solution for a given value of
the parameter Γ. It is not possible to have arbitrarily large amplitudes for u, for example,
because the equation would then be damped over almost the whole cycle. If we started
the calculation with a very large value of u(t = 0), we would ﬁnd that u(t) would quickly
decay into a limit cycle of moderate amplitude and a unique frequency ω. Consequently,
just as in a linear eigenvalue problem, we must vary both u(x) and the eigenparameter ω
until we have obtained a unique solution.
Van der Pol’s equation happens to also have the property of translational invariance. In
this respect, it is like the Korteweg-deVries equation: its solution is not unique, but rather
is a continuous family, and the linearized differential equation of the Newton-Kantorovich
has an eigenvalue with zero eigenfunction. Thus, the matrix which is the pseudospectral
discretization of the linearized ODE will be almost singular [exactly singular in the limit
N →∞] and the iteration will diverge unless we add additional constraints or conditions
to restrict the solution to a unique member of the continuous family of solutions.
Translational invariance may be destroyed by imposing a phase condition such as
ux(x = 0) = 0
[Phase Condition]
(C.39)
which demands that the origin be either a maximum or a minimum of u(x). For the KdV
solutions, it is possible to impose (C.39) implicitly by restricting the basis set to functions
which are symmetric about x = 0.
However, because of the presence of both even and odd order derivatives in van der
Pol’s equation, its solution is not symmetric about any point and we cannot impose a phase
condition by restricting the basis set; we have to use both sines and cosines. To obtain a
unique solution, we must therefore impose the phase condition (C.39) explicitly.
Since a solution does not exist for arbitary ω, but only for one particular frequency, we
must retain ω as an additional unknown. Thus, if we apply the pseudospectral method
with N coefﬁcients and N interpolation points, we must solve an (N + 1) × (N + 1) matrix
equation at each iteration. The (N +1)-st row of the matrix is the spectral form of (C.39);
the (N +1)-st unknown is δω, the correction to the frequency at the i-th iteration.
The Newton-Kantorovich iteration is a modest generalization of that used for earlier
examples. We make the simultaneous replacements
u(x)
−→
u(x) + ϵ △(x)
(C.40a)
ω
−→
ω + ϵ (δ ω)
(C.40b)
in (C.38), collect powers of ϵ, and then the iteration, as for the other examples, consists of
equating the ﬁrst order terms (divided by ϵ) to the negative of the zeroth order terms. In
particular, if we write (C.38) in the symbolic form
uxx = F (x, u, ux, ω)
(C.41)
then the linearized differential equation is
△xx −Fux△x −Fu △−Fω(δ ω) = −
n
u(i)
xx −F
o
(C.42)
1Note that time-periodic solutions, usually with the frequency as an eigenparameter, are an exception to the
usual rule that spectral methods are applied only to spatial coordinates.

534
APPENDIX C. NEWTON ITERATION
where F and all its derivatives are evaluated with u = u(i) and ω = ω(i). The only extra
term is the derivative with respect to ω. We expand △(x) as a Fourier series with a total of
N terms, demand that (C.42) is satisﬁed at N interpolation points, add the spectral form of
the phase condition, and then solve the linear matrix equation for the column vector whose
ﬁrst N elements are the N spectral coefﬁcients of △(x) and whose (N+1)-st element is (δω).
We then add the corrections to u(i) and ω(i) and repeat the iteration until it has converged.
It should be clear, as stressed at the end of the preceding chapter, that the Newton-
Kantorovich method is always applicable and the iteration can always be derived by very
elementary methods. (“Elementary” is a euphemism for freshman calculus! Functional
analysis is not needed). However, the differences between the Korteweg-deVries and van
der Pol cases, the need to impose phase conditions in some problems but not others, the
possibility that the eigenparameter may assume a continuous range of values or just one —
all in all, they show that the subject of nonlinear differential equations is very complicated.
It is important to thoroughly understand the particular problem you are trying to solve
because the range of possibilities — no solution, a solution only for a discrete value of a
parameter, solution for a continuous range of values of the parameter — is rather large.
The only sure statement is this: given a sufﬁciently good ﬁrst guess, the Newton-
Kantorovich method will always compute a solution of the indicated form if it exists. If
the solution does not exist, or you have left out phase conditions so that the solution of the
numerical problem is not unique, the iteration will (probably!) diverge, or the pseudospec-
tral matrix for the iteration differential equation will be a singular matrix.
C.4
Summary
SUCCESS: Given a sufﬁciently good ﬁrst guess, the Newton-Kantorovich method will con-
verge. Furthermore, the asymptotic convergence will be quadratic in the sense that the
magnitude of the correction △(i+1) will be roughly the square of the magnitude of △(i) for
sufﬁciently large i.
Notes: (i) The quadratic convergence does not occur until the iteration is close to the ﬁnal
solution (ii) The corrections will not decrease indeﬁnitely, but will “stall out” at some very
small magnitude which is determined by the roundoff of the computer — typically O(10−12
to 10−14). (iii) The iteration is self-correcting, so it is possible to have small errors in solving
the linearized ODE while still obtaining the correct answer. The signature of such errors
is geometric rather than quadratic convergence. (iv) The iteration does not converge to the
exact solution to the differential equation, but only to the exact solution of the N-basis
function discretization of the differential equation. Remember to vary N and compare!
FAILURE: Newton’s method may diverge because of the following:
(i) Insufﬁciently accurate ﬁrst guess.
(ii) No solution exists for the nonlinear problem.
(iii) A family of solutions, parameterized by a continuous variable, exists, rather than a
single, unique solution.
(iv) Programming error.
Notes: (i) Close to a “limit” or “bifurcation” point as discussed in Appendix D, a very
accurate ﬁrst guess is needed. (ii) Small perturbations may sometimes drastically modify
nonlinear solutions; perturbing the KdV equation (C.28) so as to make the coefﬁcients vary
with x will destroy the translational invariance, and reduce an inﬁnite number of solutions
to either one or none, depending upon whether one can ﬁnd a soliton such that the ﬁrst

C.4. SUMMARY
535
Table C.1: Nonlinear Boundary Value Problems Solved by Spectral Methods: A Select Bib-
liography
References
Comments
Boyd(1986c)
FKdV bicnoidal; Fourier pseudospectral
Yang&Keller(1986)
Fourier/ﬁnite difference algorithm for pipe ﬂow; good use of
pseudoarclength continuation to follow multiple branches
Van Dooren&Janssen(1989)
period-doubling for forced Dufﬁng equation
Fourier Galerkin
Haupt&Boyd(1988, 1991)
FKdV cnoidal waves; KdV double cnoidal wave
Boyd(1989b)
review; many examples
Boyd & Haupt(1991)
Fourier pseudospectral
Heinrichs(1992d)
quasi-linear elliptic problems
Boyd(1995h)
multiple precision; ﬁnite difference preconditioned
nonlinear Richardson’s iteration; nonlocal solitons
Mamun&Tuckerman(1995)
good discussion of how a time-marching code can
be easily modiﬁed to a Nonlinear Richardson’s iteration
nonlinear steady ﬂow between concentric spheres
Yang&Akylas(1996)
weakly nonlocal capillary-gravity solitons
Boyd (1997b)
Camassa-Holm “peakons”; TB pseudospectral
Boyd (1998c)
monograph on solitons; 3 chapters on spectral methods
Nicholls(1998)
water waves; Fourier in 2 horizontal coords.
Schultz&Vanden-Broeck &
spectral boundary integral; Newton continuation;
Jiang&Perlin(1998)
water waves with surface tension
order perturbation is orthogonal to the eigenfunctions. (iii) Too many solutions is as bad as
too few: one must add “side” conditions like (C.39) until a unique solution is obtained. (iv)
Because Newton’s iteration is self-correcting, a code may pass tests for some parameters —
and then fail in a different parameter range. Geometric convergence, that is, ∥△(i+1) ∥/ ∥
△(i) ∥∼ρ for some constant ρ < 1, indicates that the Jacobian matrix is inconsistent with
the N equations which are being solved. (This is true if the iteration is a “honest” Newton’s
method with recomputation of the linearized differential equation at each step; if the same
linearized ODE is used at every iteration to save money, then geometric convergence is the
expected price for this modiﬁcation of Newton’s method.)

Appendix D
The Continuation Method
“Creeps in this petty pace from day to day”
— W. Shakespeare, Macbeth
D.1
Introduction
Iterative methods have the vice that they must be initialized with an approximate solution.
The “continuation” method is a strategy for systematically constructing a ﬁrst guess and
tracing a branch of solutions.
The basic idea is very simple. Suppose that a problem depends upon a parameter α.
Suppose further that we know the solution u0 for α = 0. We can then compute u(α = δ) by
applying the Newton or Newton-Kantorovich iteration with u(0)(δ) = u0, provided that δ
is sufﬁciently small. Similarly, we can set u(0)(2 δ) = u(δ), and so on: at each step, we use
the solution for u(n δ) as the ﬁrst guess for calculating u([n + 1] δ).
The better our guess, the faster the iteration will converge. The basic scheme can be
reﬁned by using the linear extrapolation:
u(0)([n + 1] δ) = u(n δ) + δ {u(n δ) −u([n −1] δ)}
(D.1)
In summary,
[Analytical solution]
−−−−−→
u(α = 0)
(D.2)
u(0)
−−−−−→
u(0)(δ)
Newton iteration
−−−−−−−−−−−→
u(δ)
(D.3)
(
u([n −1] δ)
u(n δ)
)
Linear Extrapolation
−−−−−−−−−−−−→u(0)([n + 1] δ)
Newton’s iter.
−−−−−−−−−→u([n + 1] δ)
(D.4)
In words, we have the following.
536

D.2. EXAMPLES
537
Deﬁnition 50 (CONTINUATION METHOD) This procedure solves the equation
N(u; α) = 0
(D.5)
for u by marching in small steps in α. N is the nonlinear operator and α is the parameter. The
march begins with a known solution — typically, a linear solution which can be found analytically
or numerically — and applies an iteration to compute u at each value of α, USING PREVIOUSLY
COMPUTED VALUES OF u FOR SMALLER α TO EXTRAPOLATE A FIRST GUESS FOR
THE SOLUTION AT THE CURRENT α.
N may include derivatives or integrations, and may represent a system of nonlinear equations.
The unknown u may be the solution to either an algebraic equation or system of equations, or the
solution to a differential equation or system of such equations.
Strictly speaking, “continuation method” should be “continuation methods” in Deﬁ-
nition 50 because the basic idea of parameter-marching to obtain the ﬁrst guess can be
applied with a wide variety of iteration and extrapolation schemes. We can always replace
Newton’s method by the secant method, for example; since the latter has a smaller radius
of convergence than Newton’s, the price we must pay is a smaller maximum step in α.
Similarly, to deﬁne better extrapolation formulas, we can use either ODE integration
schemes or higher-order Lagrangian interpolation in α — very carefully since interpolation
may diverge as the degree of the interpolating polynomial becomes large, especially when
extrapolating.
The ODE methods are based on differentiating N(u[α], α) with respect to α to obtain
Nu(u, α) uα + Nα = 0
(D.6)
For the special case that N(u, α) is a single algebraic equation, (D.6) is the ﬁrst order ordi-
nary differential equation
du
dα = −∂N(u, α)/∂α
∂N(u, α)/∂u
[“Davidenko equation”]
(D.7)
Given a single initial condition such as u(α = 0) = u0, we can apply our favorite Runge-
Kutta or predictor-corrector method in α to trace the solution branch.
This differential-equation-in-the-parameter is named after Davidenko who ﬁrst observed
that nonlinear algebraic equations could be solved by integrating an ODE or system of
ODE’s in the parameter. When extended to systems of M nonlinear equations in M un-
knowns, u and N become M-dimensional vectors and ∂N/∂u becomes the Jacobian ma-
trix whose elements are given by ∂Ni/∂uj. Integrating (D.7) is then relatively expensive
because one must compute du/dα by Gaussian elimination.
In principle, Newton’s method can be completely replaced by the integration of the
Davidenko equation. However, the errors in a Runge-Kutta scheme will gradually accu-
mulate as we march, so it is a good idea to periodically apply Newton’s method so as to
reinitialize the march with a u(α) that is accurate to full machine precision.
D.2
Examples
Let the goal be to solve the polynomial equation
P(x; α) = 0
(D.8)

538
APPENDIX D. THE CONTINUATION METHOD
where α is a parameter. Let x0 be a root which is known for α = 0. We can trace this
solution branch x(α) emanating from the point (x0, 0) by solving the ODE initial-value
problem
dx
dα = −∂P(x; α)/∂α
∂P(x; α)/∂x
(D.9a)
x(0) = x0
(D.9b)
For example,
P(x; α) ≡αx2 −2 x + 1
−→
(D.10)
∂P/∂α = x2
(D.11)
∂P/∂x = 2αx −2
(D.12)
As α →0, this collapses into the linear equation (−2x + 1) = 0, which has the unique
solution x = 1/2. We can trace x(α) away from α = 0 by solving
dx
dα = −
x2
2(α x −1)
(D.13a)
x(0) = 1
2
(D.13b)
Polynomials have multiple solutions, but we can apply the same method to trace all the
roots. For small α, one can easily show that
x2(α) ≈2
α
α ≪1
(D.14)
which can be used to initialize the same differential equation, (D.13a), for small α to trace
the second solution for all α for which this root is real.
Two difﬁculties arise. First, what happens when two roots of the polynomial coincide?
The answer is that the simple marching procedure will probably fail. There are good strate-
gies for dealing with “limit points” and “bifurcation points”, explained in later sections.
The second problem is to obtain the ﬁrst guess for continuation, and we turn to this next.
D.3
Initialization Strategies
To apply continuation, we need a solution for α = 0 or equivalently, a ﬁrst guess which
is sufﬁciently close so that the Newton-Kantorovich method will convert the guess into a
solution. Strategies for obtaining this needed solution or ﬁrst guess include the following:
(i) a linear or perturbative solution
(ii) invention of an artiﬁcial marching parameter and
(iii) low-order collocation.
The ﬁrst strategy may be illustrated by cnoidal waves of the so-called FKdV equation.
The ODE and boundary conditions are
−uxxxxx + (u −c)ux = 0
(D.15)
u(x + 2 π) = u(x)
(D.16)

D.3. INITIALIZATION STRATEGIES
539
where c is the phase speed. For small amplitude, the nonlinear term can be ignored and
solving the linearized equation gives
u(x) ≈a cos(x)
;
c ≈−1,
a << 1
(D.17)
which can be used to initialize the march. The most obvious marching parameter is the
phase speed c, but we can also deﬁne the coefﬁcient of cos(x) in the Fourier expansion of
u(x) to be the amplitude a, and march in a. Fig. D.1 shows c(a).
Since dc/da varies much more rapidly for small amplitude than for large, it is efﬁcient to
employ a variable step-size in the marching parameter a. One could, for example, monitor
the number of Newton’s iterations that are required at each value of a. When it falls below
a cutoff, one could automatically double the step-size. When the number of Newton’s
iterations is large, one may automatically halve the step-size. Library ODE-solvers, such
as might be applied to the Davidenko equation, use similar strategies.
Unfortunately, in the vicinity of a limit point, du/dα →∞, so no variable step-size
strategy will work. However, there are other remedies as explained in the next section.
The second strategy of inventing an artiﬁcial continuation parameter may be applied to
solve a polynomial equation
R(x) = 0
(D.18)
for all its N roots. There is an inﬁnite variety of choices, but Wasserstrom (1973) deﬁnes
P(x; α) ≡αR(x) + (1 −α)[xN −1]
(D.19)
When α = 0, the roots of P(x; α) are the N roots of unity. When α = 1, P(x; 1) = R(x).
When α is a physical parameter, we usually graph x(α). When α is an artiﬁcial marching
parameter, however, the intermediate values of x(α) are simply thrown away. Fig. D.2
Figure D.1: Phase speed c versus amplitude a for the cnoidal wave of the ﬁfth-degree
KdV equation, taken from Boyd (1986b). For small amplitude, the differential equation is
linear and c ≈−1 while u(x) ≈a cos(x). This linear solution can be used to initialize the
continuation method, which can then march to arbitrarily large amplitude in small steps.

540
APPENDIX D. THE CONTINUATION METHOD
Figure D.2: An illustration of the continuation method for a polynomial of degree 25.
(a) Trajectories of the coefﬁcients of the polynomials as functions of the marching parameter
α.
(b) Trajectories of the roots of the polynomial.
This example and graphs are taken from Wasserstrom (1973).

D.3. INITIALIZATION STRATEGIES
541
shows how the roots vary with α for a 25-th degree polynomial taken from Wasserstrom
(1973).
Is this a good way to solve polynomial equations? If there is a single solution of physical
interest and if α is a physical parameter, then continuation is very efﬁcient. When roots
x(α) collide as α varies, the continuation is defeated. However, for complex trajectories,
this is very unlikely. The technical jargon is that (D.19) is a “probability-one homotopy”
(Li, 1987, and Morgan, 1987). What this means is that if one picks the coefﬁcients of R(x)
as random complex-valued numbers, the probability of root-collision is inﬁnitesimal.
Unfortunately, the situation is different when the trajectories are real. If R(x) has any
complex roots, then continuation from a polynomial P(x; α) which has only real roots
will inevitably fail because pairs of roots must merge before separating as a complex con-
jugate pair. Thus, one needs a complex-valued embedding strategy like Wasserstrom’s.
Furthermore, near-collisions will cause problems if the roots pass sufﬁciently close, and the
probability of such near-collisions is not zero — although it is very small.
For a single polynomial equation, the simplest strategy is the Traub-Jenkins package
which is available in most software libraries. For systems of polynomial equations, how-
ever, little library code exists and the continuation strategy is quite attractive as described
in the book by Morgan (1987).
For a differential equation such as
Wrr + 1
r Wr −W −W 2 = 0
W →0 as |r| →∞
(D.20)
which is known as the “Petviashvili monopole vortex” problem in geophysical ﬂuid dy-
namics, linearization fails because the linearized problem has only the solutions K0(r),
which is singular at the origin, and I0(r), which is unbounded for large r. This problem
is “essentially nonlinear” in the sense that the nonlinear term is necessary to remove the
singularity at the origin.
The physical background of this problem shows that the solution qualitatively resem-
bles exp(−r). One way to exploit this is to deﬁne an artiﬁcial forcing function to be the
residual of the trial solution exp(−r), that is,
f(r) ≡
· ∂2
∂r2 + 1
r
∂
∂r −1 −e−r
¸
e−r
(D.21)
If we solve perturbed problem
urr + 1
r ur −u −u2 = (1 −α) f(r)
(D.22)
then Newton’s iteration will converge for α = 0 because exp(−r) is, by construction, the ex-
act solution. As we march in small steps in α, u(r; α) is slowly deformed from exp(−r)(α =
0) to the Petviashvili monopole, W(r)(α = 1).
This method of the “artiﬁcial forcing function” has a broad range of usefulness. It helps
to choose a trial solution that qualitatively resembles the true solution because u(r; α)
varies less between α = 0 and α = 1, but this is by no means mandatory.
A variant is to choose the forcing function for simplicity such as a constant δ:
urr + 1
r ur −u −u2 = δ
(D.23)
For small δ, the perturbed differential equation has two solutions: (i) the monopole (large
amplitude) and (ii) the artiﬁcial (small amplitude) solution which may be calculated by

542
APPENDIX D. THE CONTINUATION METHOD
ignoring the nonlinear term, solving the resulting linear BVP, and then using the linear so-
lution to initialize Newton’s iteration. If we are lucky, these two solution branches, u1(r; δ)
and u2(r; δ) will join at a limit point, δ = δlimit. Because of the critical point, marching in
δ will never “turn the corner” around the limit point onto the upper branch; this tactic of
a constant forcing function is practical only when combined with “pseudoarclength con-
tinuation”, which is brieﬂy described below. Glowinski, Keller, and Reinhart (1985) have
successfully applied this method to a problem very closely related to (D.20).
The third numerical strategy for obtaining a ﬁrst guess is to compute a crude solution
using a very low order approximation which can be obtained in closed form. For example,
if one can invent a two-parameter guess, one can then make a contour plot of the residual
when this trial solution is substituted into the differential equation, and pick the parame-
ters that minimize the residual. A more direct tactic in this same spirit is to apply low order
collocation.
For example, the solution of (D.20) is (a) symmetric1 and (b) vanishes as |r| →∞. It
follows that if we solve this using the orthogonal rational Chebyshev functions TBn(r),
discussed in Chapter 17, then we need only the symmetric (even n) basis functions. Fur-
ther, we can create new basis functions which individually satisfy the boundary conditions
at inﬁnity by taking linear combinations of the TBn(r). In particular, choosing φ0(r) ≡
TB2(r) −TB0(r) and truncating the basis to just this single function gives the approxima-
tion
W(r) ≈a0
2
1 + [y/L]2
(D.24)
where L is the user-choosable map parameter associated with the TBn(r). Choosing L = 2,
which is known to be reasonable from calculating the expansion of functions that decay
as exp(−r), and applying the one-point pseudospectral algorithm gives a linear equation
whose solution is a0 = −1. The resulting approximation has a maximum error of about
16% of the maximum of the monopole, but it is sufﬁciently close so that Newton’s iteration
with many basis functions will converge. Boyd (1986c) and Finlayson (1973) give other
examples.
It goes without saying that this approach is more risky than the slow, systematic march
of continuation in an artiﬁcial parameter. It is also much cheaper in machine time in the
sense that if it works, low-order collocation may obviate the need for continuation, at least
in non-physical parameters. There is also the satisfaction of “making friends with the func-
tion”, to use Tai-Tsun Wu’s poetical phrase: brute force numerical computation is often no
better at giving insight into the physics or the structure of the solution than television is at
giving insight into real human behavior.
D.4
Limit Points
Deﬁnition 51 (LIMIT POINT) If N(u; α) = 0 is a single nonlinear equation with a solution
branch u(α), then a LIMIT POINT occurs wherever
Nu(u[α]; α) = 0
;
Nα(u[α]; α) ̸= 0
(D.25)
The Davidenko equation implies that an equivalent deﬁnition is
du
dα →∞
as
α →αlimit
(D.26)
1In cylindrical coordinates, the r-dependent coefﬁcients of the terms in the Fourier series in polar angle θ are
symmetric about r = 0 for even wavenumber (including the axisymmetric term) and the coefﬁcients of odd
wavenumber are antisymmetric in r as explained in Chapter 18.

D.4. LIMIT POINTS
543
Two distinct solution branches u1(α) and u2(α) meet at a limit point, and exist only on one side
of the limit point. That is, if u1(α) and u2(α) exist for α ≤αlimit, then they do not exist (as real
solutions) for α > αlimit.
Newton’s iteration must fail at and near a limit point because the iteration is attracted equally
to both branches, and responds by converging to neither.
When N(u; α) is a system of equations, (D.26) still applies. The interpretation of (D.25) is
that (i) the determinant of the Jacobian matrix Nu is zero and (ii) the column vector Nα does not lie
in the range of Nu so that the matrix equation Nu du/dα = −Nα has no bounded solution.
As an example, the simple algebraic equation
(u −1/2)2 + α2 = 1
(D.27)
has limit points at α = ±1 where u = 1/2. This is merely the equation of a circle in the
u-α plane as shown in Fig. D.3, but nonetheless it is impossible to trace the entire curve in
a single pass by marching in α. By using a variable step-size, we can come as close to the
limit point as we want, but we can never turn the corner and march from the lower branch
onto the upper branch using small steps in either α or u.
However, it is trivial to write the equation of the circle in (D.28) in parametric form as
u = cos(t) + 1/2
;
α = sin(t)
(D.28)
Both u and α are continuous, single-valued functions of t so that we can trace both branches
of the solution in one continuous path if we march in t. The new continuation parameter t
is the arc-length along the solution curve.
It is usually impossible to analytically deﬁne the arclength as in (D.28), but H. B. Keller
and various collaborators(Keller, 1977, Decker and Keller, 1980, Chan, 1984, and Glowinski,
Figure D.3: Solution curve u(α) for a quadratic equation. The two limit points are marked
by ×’s. There, as indicated on the right, the solution curve is tangent to a vertical line
(dashed) and du/dα = ∞. For −1 < α < 1, there are two solutions for a given α. At the
limit points, these upper and lower branches meet. Unable to decide whether to converge
to the upper or lower branch, Newton’s iteration diverges at the limit points.

544
APPENDIX D. THE CONTINUATION METHOD
Keller and Reinhart, 1985, and Keller, 1992) have developed a “pseudo-arclength continu-
ation method” which can follow a solution smoothly around a limit point. The “globally
convergent homotopy” methods reviewed by Li (1987) are very similar. We postpone a
discussion until Sec. 6.
D.5
Bifurcation points
As in the previous section, the deﬁnition below and the examples are restricted to a single
equation in a single unknown.
Deﬁnition 52 (BIFURCATION POINT) This is a point in parameter space where two branches
cross. The formal deﬁnition for a single equation N(u; α) = 0 is that a bifurcation point occurs
whenever
Nu(u[α]; α) = 0
&
Nα(u[α]; α) = 0,
(D.29)
which differs from the deﬁnition of a limit point in that both derivatives are 0 instead of just one.
Newton’s method fails in the vicinity of a bifurcation point; the iteration literally cannot decide
which branch of the two branches to converge to.
For a system of equations N(u) = 0 where u is a vector of unknowns, (D.29) become the
conditions that (i) the Jacobian matrix Nu has a vanishing determinant and (ii) Nα is within the
range of Nu so that the matrix equation Nudu/dα = −Nα has bounded solution even though the
Jacobian matrix is singular.
An example is the quadratic equation
u2 −2 u −α(α −2) = 0
(D.30)
Figure D.4: Same as Fig. D.3 except that the quadratic has been altered so that its solution
branches have a bifurcation point instead of a pair of limit points. At a bifurcation point,
two branches cross. As at a limit point, Newton’s iteration cannot converge to either one
but instead diverges. Unlike a limit point, however, all branches have a ﬁnite slope du/dα
at a bifurcation point. A limit point is one where branches merge; a bifurcation point is one
where branches cross.

D.5. BIFURCATION POINTS
545
Figure D.5: Schematic of “shooting a bifurcation point”. Newton’s iteration converges
when the ﬁrst guess is within the cross-hatched region. Unfortunately, this convergence
region shrinks to zero width at the bifurcation point. However, linear extrapolation from
the left “x” will give a ﬁrst guess as indicated by the right “x”. This lies within the conver-
gence zone on the far side of the bifurcation point. Newton’s iteration will converge from
a guess of the point marked by the right “x”, and one may then apply continuation to trace
out the whole solution branch to the right of the bifurcation point. The only complication
is the issue of how far to proceed along the straight line when extrapolating beyond the
bifurcation point; some trial-and-error may be needed.
whose two roots are
u1(α) = α
;
u2(α) = 2 −α
(D.31)
The bifurcation point is located at α = 1 where u1 = u2 and the two branches cross. The
ODE in α for (D.30) is
du
dα = α −1
u −1
(D.32)
At the limit point, the denominator of (D.32) tends to 0 — but so does the numerator.
The slope du/dα is always ﬁnite. Consequently, although we cannot compute u(α) at the
bifurcation point, we can calculate either branch without using a small step-size even at
points very near α = αbifurcation.
Fig. D.5 shows how it is possible to, in Keller’s words, “shoot the bifurcation point”.
The radius of convergence of Newton’s method (in u) shrinks to 0 at the bifurcation point,
but expands on either side. Consequently, if we use a rather large step in α, we can jump
from the region of convergence on one side of the bifurcation point to the corresponding
region on the other side. We do not need tricks like “pseudoarclength continuation” near
a bifurcation point.
A harder task is to shift to the other branch, that is, to jump from u1(α) to u2(α). By
using a local Taylor approximation near the bifurcation point (all the needed terms can

546
APPENDIX D. THE CONTINUATION METHOD
be computed numerically), we can obtain a ﬁrst guess for points on the other branch very
close to the bifurcation. All one needs is a single point on u2(α); one may then trace the rest
of the branch by ordinary continuation. Seydel (1988) and Keller (1992) are good references.
D.6
Pseudoarclength Continuation
As noted in Sec. 4, a major problem for continuation in a physical parameter α is the ex-
istence of limit points where du/dα →∞. In pseudoarclength continuation, both u and α
are taken as functions of a new parameter s which approximates arclength along the so-
lution curve in the u-α plane. The gradient (du/ds, dα/ds) is always ﬁnite so there are no
inﬁnities.
The arclength is deﬁned by approximating the solution curve u(α) by many short line
segments. In the limit that the segments become inﬁnitely short, the sum of the length of
the segments between two points on the curve is the arclength between those points.
Mathematically, suppose that the solution curve is speciﬁed parametrically, i. e.
u = u(t)
&
α = α(t)
(D.33)
Let △t denote the change in t between the endpoints of one of the inﬁnitesimal line seg-
ments that we use to measure arclength. Let △u and △α denote changes in u and α be-
tween the ends of the segment. By the Pythagorean theorem,
(△s)2 = (△u)2 + (△α)2
(D.34)
which, dividing by △t and then taking the limit, is
µds
dt
¶2
=
µdu
dt
¶2
+
µdα
dt
¶2
(D.35)
Our goal is to parameterize the solution curve in terms of the arclength so that t ≡s.
This implies that the L. H. S. of (D.35) is one, and this in turn gives a constraint which can
be applied to “inﬂate” our system of M unknowns, u(α), into a system of M +1 unknowns
(u(s), α(s)) by giving us the (M+1)-st nonlinear equation:
µdu
ds
¶2
+
µdα
ds
¶2
= 1
[“Arclength Constraint”]
(D.36)
For simplicity, we have written u as a scalar, but the only change if u is a vector is that
(du/ds)2 = (du1/ds)2 + (du2/ds)2 + . . . , i. e. is the usual scalar product of the vector du/ds
with itself.
There is one modest complication: (D.36) involves the s-derivatives of u and α rather
than these quantitities themselves. Strictly speaking, when u is a vector of dimension M,
the system N(u; α) = 0 plus (D.36) is a system of (M+1) equations in (2M+2) unknowns!
However, H. Keller, who invented this technique, pointed out that we are not interested
in the arclength for its own sake, but rather as a computational device for evading limit
points. It follows that it is legitimate to approximate the s-derivatives in (D.36) in any way
such that u(s) & α(s) become the unknowns. When such approximations are made, s is
no longer exactly equal to the arclength, but is merely an approximation to it. It is for this
reason that this family of algorithms is called “pseudoarclength” continuation.
Many approximations are possible. The simplest is a forward ﬁnite difference approxi-
mation to (some of) the derivatives in (D.36), which gives
S1(u, α; s) = 0
(D.37a)
S1 ≡du(s0)
ds
[u(s0 + δs) −u(s0)] + dα(s0)
ds
[α(s0 + δs) −α(s0)] −δs
(D.37b)

D.6. PSEUDOARCLENGTH CONTINUATION
547
where s0 is a constant which is normally the value of the arclength at the previous step of
the continuation, and δs ≡s −s0.
An alternative is useful in overcoming a drawback of standard pseudoarclength con-
tinuation: Because s is the marching parameter and α is an unknown, there is no simple
way to compute u(α) at a given “target” value of α. The problem is that we do not know
which value of s corresponds to the target α. However, if we generalize (D.37) to
Sθ ≡θdu
ds [u(s0 + δs) −u(s0)] + (2 −θ)dα
ds [α(s0 + δs) −α(s0)] −δs
(D.38)
then Sθ(θ = 1) = S1. However, when θ = 0, (D.38) becomes an approximation to
µdα
ds
¶2
= 1
[θ = 0],
(D.39)
that is, s becomes identical with α. We have switched back to α as the marching parameter,
and it is trivial to march to a desired “target” value of α.
Thus, it is possible to switch from ordinary continuation (in α) to pseudosarclength
continuation in s and back again merely by changing θ. In the vicinity of a limit point, of
course, taking θ = 0 will lead to disaster, but very close to a limit point, we have no hope
of marching to a target α anyway. There may not even be a solution if αtarget > αlimit. Away
from a limit point, however, we can apply pseudosarclength continuation to march close
to a target value of α and then switch to θ = 0 to march directly to αtarget on the ﬁnal step.
In any event, Newton’s iteration for the arclength continuation requires solving the
(M + 1) × (M + 1) matrix equation which in block form is
Nu
Nα
Su
Sα
△u
△α = −N(u; α)
−S(u; α)
(D.40)
When u is an M-dimensional vector, Nu is the M × M Jacobian matrix whose elements are
(Nu)ij ≡∂Ni/∂uj. Similarly, Nα is the M-dimensional column vector whose elements are
(Nα)i ≡∂Ni/∂α, Su is the M-dimensional row vector with (Su)j ≡∂S/∂uj, and Sα is a
scalar.
The one minor technical complication is that elements of S require the s-derivatives of
u and α. Fortunately, we can obtain them in two steps. First, solve the system
Nu
Nα
0
1
du/dt
dα/dt = 0
1
(D.41)
which modiﬁes only the R. H. S. and the last row of (D.40). Second, rescale du/dt and dα/dt
via
µdu
ds , dα
ds
¶T
= (du/dt, dα/dt)T
p
[du/dt]2 + 1
(D.42)
The justiﬁcation for (D.41)–(D.42) is that along the solution curves, N(u[t], α[t]) = 0
where t is any parameter that parameterizes the solution curve. It follows that dN/dt ≡0,
but this is merely the top M rows of (D.41). This condition, dN/dt = 0, gives only M con-
straints on (M+1) unknowns, so to obtain a system with a unique solution, we arbitrarily
demand that dα/dt = 1, which is expressed by the bottom row of (D.41). For small dis-
placements along the solution curve, the parameter t must be proportional to s so that the
t-derivatives of u and α are proportional to the desired s-derivatives. We can determine
the proportionality constant by recalling that the length of the vector (du/ds, dα/ds)T is
unity, which implies (D.42).
Thus, the overall algorithm may be summarized as:

548
APPENDIX D. THE CONTINUATION METHOD
1. Generate a ﬁrst guess for u & α. [Predictor step]
2. Apply Newton’s method to compute u & α by repeatedly solving the (M+1)×(M+1)
matrix problem (D.40). [Corrector step]
3. Modify the last row of the square matrix and the R. H. S. of (D.40) to give (D.41).
Solve (D.41) and apply the rescaling (D.42) to compute du/ds and dα/ds.
4. Increase s →s + δs and return to 1.
When s = 0, the ﬁrst guess is usually α = α0, u = u0(α0) where u0 is a known analytical
solution (often a linear solution). For larger s, the simplest predictor is
u(s0 + δs) ≈u(s0) + du(s0)
ds
δs
&
α(s0 + δs) ≈α(s0) + dα(s0)
ds
δs
(D.43)
but many alternatives are possible. Bank & Chan (1986) point out that a good predictor
can greatly reduce the computation time by reducing the number of Newton iterations and
apply a rather ad hoc but effective procedure that requires solving two simultaneous equa-
tions in two unknowns. Generating a good ﬁrst guess is still a subject of active research,
but (D.43) is safe and reliable.
If the ﬁrst guess for s = 0 is exact, one may skip the Newton’s iteration for this one
parameter value. If, however, the march is initialized with an approximate solution, then
(D.40) cannot be applied because it requires s-derivatives which we do not yet know. The
remedy is to modify (D.40) by replacing the last row by of the square matrix by (0 1)T
and setting the last element of the R. H. S. equal to 0. This modiﬁed matrix problem is
then the classical Newton’s iteration with u as the unknown and α ﬁxed; once u(α = α0)
has been reﬁned to the desired degree of accuracy, one may compute the corresponding s-
derivatives in step 3 and solve (D.40) without modiﬁcation at all later points on the solution
curve.
The extra computation required by pseudoarclength continuation versus the classic
Newton’s method is very minor, especially when M ≫1. By solving (D.40) and (D.41)
via the 2 × 2 block decomposition which is described in Appendix B, one may solve (D.41)
for the s-derivatives without having to recompute the full LU decomposition of a large
matrix; the factorization of the Jacobian matrix Nu, which is the costly step, can be applied
to both (D.40) and (D.41).
The block-factorization fails near limit points because the Jacobian matrix Nu is singular
at a limit point. This is not a serious difﬁculty in practice, however. Near the limit point,
the solution varies with s proportional to the singular (zero eigenvalue) eigenfunction of
the Jacobian anyway, so the 2×2 block solution of (D.41) will give the correct s-derivatives
even very near the limit point.
Unfortunately the accuracy of the Newton’s step (D.40) is degraded if the block fac-
torization is used too near a limit point. The remedy is to switch to standard Gaussian
elimination for the entire inﬂated system. The beauty of the pseudoarclength continuation
method is precisely that the inﬂated, (M+1)-dimensional matrix system is not singular even
when the M-dimensional Jacobian matrix is. Bank & Chan (1986) describe a method for
obtaining accurate solutions via block-factorization for (D.40), but it would take us too far
aﬁeld to describe their technique in detail.
It is important to note that pseudoarclength continuation eliminates only limit points.
At bifurcation points, continuation still has difﬁculties. However, we can “shoot” the bifur-
cation points as described in the previous section. It is comforting, however, that Keller has
found that “shooting” tends to be easier with arclength continuation than with standard
continuation.

D.6. PSEUDOARCLENGTH CONTINUATION
549
Seydel (1988) is a good treatment of continuation, limit points, and bifurcation points
which assumes only an undergraduate mathematical background: ordinary differential
equations, partial derivatives, and matrix algebra. Keller (1992) is an outstanding mix of
review and research papers at a higher mathematical level.

Appendix E
Change-of-Coordinate Derivative
Transformations
“A Chebyshev polynomial is a Fourier cosine in disguise”
— J. Boyd
In many problems, it is useful to replace the original coordinate y by a new variable x:
y = f(x)
(E.1)
One common application is to convert a Chebyshev series in y into a Fourier cosine series
in x, in which case f(x) ≡cos(x). In this appendix, we collect (mostly unpublished) tables
that are useful in transforming derivatives. The ﬁrst is for general f(x); the later tables are
for a variety of important special mappings. For example, the ODE
a2(y) uyy + a1(y) uy + a0(y) u = g(y)
(E.2)
becomes
a2(f[x])f1(x) uxx −f2(x) ux
f1(x)3
+ a1(f[x]) ux
f1(x) + a0(f[x]) = g(f[x])
(E.3)
where, in a notation used throughout the tables,
fn(x) ≡dnf
dxn
(E.4)
Transformation of Orthogonality Integral
Z π
0
cos(mx) cos(nx) dx ≡
Z f(π)
f(0)
φm(y) φn(y)
f1 (f −1[y]) dy;
(E.5)
550

551
Table E.1: Transformation of derivatives under a general mapping y = f(x).
un,y =
1
f 2n+1
1
{bn,n un,x + bn,n−1 un−1,x + · · · }
where fn is the n-th derivative of the map f(x); the bn,k are below.
uy =
1
f1(x) ux
uyy =
1
f1(x)3 {f1 uxx −f2 ux}
uyyy
£
×1/f 5
1
¤
ux
uxx
uxxx
−f3 f1 + 3 f 2
2
−3 f2f1
f 2
1
uyyyy
£
×1/f 7
1
¤
ux
uxx
uxxx
uxxxx
−f4 f 2
1 + 10 f3 f2 f1 −15 f 3
2
−4 f3 f 2
1 + 15 f 2
2 f1
−6 f2 f 2
1
f 3
1
uyyyyy
£
×1/f 9
1
¤
ux
uxx
uxxx
uxxxx
uxxxxx
−f5 f 3
1 + 15 f4 f2 f 2
1
−5 f4 f 3
1
−10 f3 f 3
1
−10 f2 f 3
1
f 4
1
+10 f 2
3 f 2
1 −105 f3 f 2
2 f1
+60 f3 f2 f 2
1
+45 f 2
2 f 2
1
+105 f 4
2
−105 f 3
2 f1

552
APPENDIX E. CHANGE-OF-COORDINATE DERIVATIVE TRANSFORMATIONS
Table E.1: Transformation of derivatives under a general mapping y = f(x) [CONTIN-
UED]
uyyyyyy
£
×1/f 11
1
¤
ux
uxx
uxxx
uxxxx
uxxxxx
+1260 f3 f 3
2 f1
−840 f3 f 2
2 f 2
1
+210 f3 f2 f 3
1
+105 f 2
2 f 3
1
−15 f2 f 4
1
−280 f 2
3 f2 f 2
1
+945 f 4
2 f1
−420 f 3
2 f 2
1
−20 f3 f 4
1
−210 f4 f 2
2 f 2
1
+70 f 2
3 f 3
1
−15 f4 f 4
1
+35 f4 f3 f 3
1
+105 f4 f2 f 3
1
+21 f5 f2 f 3
1
−6 f5 f 4
1
−945 f 5
2 −f6 f 4
1
uxxxxxx
f 5
1
Table of Tables
Table #
y-Interval
Mapping
E.1:
y = f(x)
[General Map]
E.2:
[−1, 1]
y = cos(x)
Tn(y) ↔cos(nx)
E.3:
y = arccos(x)
cos(ny) ↔Tn(x)
E.4:
[−∞, ∞]
y = L cot(x)
TBn(y) ↔cos(nx)
E.5:
[−∞, ∞]
y = Lx/
√
1 −x2
TBn(y) ↔Tn(x)
E.6:
[0, ∞]
y = L cot2(x/2)
TLn(y) ↔cos(nx)
E.7:
[0, ∞]
y = L(1 + x)/(1 −x)
TLn(y) ↔Tn(x)
E.8:
[−∞, ∞]
y = arctanh(x)
E.9:
x = f(r), y = g(s)
[General Two-Dimensional Map]

553
Table E.2: Transformations of derivatives for the mapping y = cos(x) which converts a
Chebyshev series in Tn(y) into a Fourier cosine series in cos(nx).
uy = −
1
sin(x) ux
uyy =
1
sin3(x) {sin(x) uxx −cos(x) ux}
uyyy
£
×1/ sin5(x)
¤
ux
uxx
uxxx
−sin2 −3 cos2
+3 cos sin
−sin2
uyyyy
£
×1/ sin7(x)
¤
ux
uxx
uxxx
uxxxx
−15 cos3 −9 cos sin2
+4 sin3 +15 cos2 sin
−6 cos sin2
sin3
uyyyyy
£
×1/ sin9(x)
¤
ux
uxx
uxxx
uxxxx
uxxxxx
−9 sin4 −105 cos4
+105 cos3 sin
−10 sin4
+10 cos sin3
−sin4
−90 cos2 sin2
+55 cos sin3
−45 cos2 sin2
uyyyyyy
£
×1/ sin11(x)
¤
ux
uxx
uxxx
uxxxx
uxxxxx
−225 cos sin4
+64 sin5
−420 cos3 sin2
105 cos2 sin3
−15 cos sin4
−1050 cos3 sin2
+735 cos2 sin3
−195 cos sin4
+20 sin5
uxxxxxx
−945 cos5
+945 cos4 sin
sin5

554
APPENDIX E. CHANGE-OF-COORDINATE DERIVATIVE TRANSFORMATIONS
Table E.3: Transformations of derivatives for the mapping y = arccos(x) , which converts a
Fourier cosine series in y into a Chebyshev series in x. (This is the inverse of the mapping
of Table E.2.) To simplify the tables, we used the auxiliary parameter: Q(x) ≡1 −x2
uy = −
p
Q ux
uyy = Q uxx −x ux
uyyy =
p
Q {−Q uxxx + 3 x uxx + ux}
uyyyy = Q2 uxxxx −6 Q x uxxx + (3 −7 Q) uxx + x ux
uyyyyy =
p
Q
©
−Q2 uxxxxx + 10 Q x uxxxx + (25 Q −15) uxxx −15 x uxx −ux
ª
uyyyyyy = Q3 uxxxxxx −15 x Q2 uxxxxx + (45 Q −65 Q2) uxxxx
+(90 x Q −15 x) uxxx + (31 Q −15) uxx −x ux

555
Table E.4: Transformations of derivatives for the mapping y = L cot(x) which converts a
rational-Chebyshev series in TBn(y) into a Fourier cosine series in cos(nx), y ∈[−∞, ∞]
and x ∈[0, π]. L is a constant, the “map parameter”.
uy = −sin2(x)
L
ux
uyy = sin3(x)
L2
{sin(x) uxx + 2 cos(x) ux}
uyyy
£
× sin4(x)/L3¤
ux
uxx
uxxx
8 sin2 −6
−6 cos sin
−sin2
uyyyy
£
× sin5(x)/L4¤
ux
uxx
uxxx
uxxxx
24 cos −48 cos sin2
36 sin −44 sin3
12 cos sin2
sin3
uyyyyy
£
× sin6(x)/L5¤
ux
uxx
uxxx
uxxxx
uxxxxx
−384 sin4
400 cos sin3
140 sin4
−20 cos sin3
−sin4
+480 sin2 −120
−240 cos sin
−120 sin2
uyyyyyy
[× sin7 /L6]
ux
uxx
uxxx
uxxxx
uxxxxx
uxxxxxx
3840 cos sin4
1800 sin
1200 cos sin2
300 sin3
30 cos sin4
sin5
−3840 cos sin2
−6000 sin3
−1800 cos sin4
−340 sin5
+720 cos
+4384 sin5
[× sinq /Lp] denotes that all entries in the box below must be multiplied by this factor.

556
APPENDIX E. CHANGE-OF-COORDINATE DERIVATIVE TRANSFORMATIONS
Table E.5: Transformations of derivatives for the mapping y = L x/
√
1 −x2 where L is a
constant map parameter. This transformation converts a series of TBn(y) into a Chebyshev
series in x, that is, TBn(y) = Tn(x), ∀n, y ∈[−∞, ∞], x ∈[−1, 1]. Deﬁning the auxiliary
parameter Q(x) ≡1 −x2 greatly simpliﬁes the tables.
uy =
p
Q Q ux/L
uyy = Q2 {Q uxx −3 x ux} /L2
uyyy =
p
Q Q2 ©
Q2 uxxx −9 x Q uxx + (12 −15 Q) ux
ª
/L3
uyyyy = Q3 ©
Q3 uxxxx −18 x Q2 uxxx + (75 Q −87 Q2) uxx
+(105 x Q −60 x) ux} /L4
uyyyyy =
p
Q Q3 ©
Q4 uxxxxx −30 x Q3 uxxxx + (255 Q2 −285 Q3) uxxx
+x Q(975 Q −660) uxx + (360 −1260 Q + 945 Q2) ux
ª
/L5
uyyyyyy = Q4 ©
Q5 uxxxxxx −45 x Q4 uxxxxx + Q3(645 −705 Q) uxxxx
+x Q2(4680 Q −3465) uxxx + Q (6300 −18585 Q + 12645 Q2) uxx
−x (2520 −11340 Q + 10395 Q2) ux
ª
/L6

557
Table E.6: Transformations of derivatives for the mapping y = L cot2(x/2) which converts
a rational-Chebyshev series in TLn(y) into a Fourier cosine series in cos(nx).
L is a
constant, the “map parameter”. Note that all sines and cosines in the table have arguments
of (x/2), not x.
Note: the [× sinq /{2nLp cosr}] denotes that all entries in the box below must be multiplied
by this common factor.
uy = −{sin3(x/2)/[L cos(x/2)]} ux
uyy =
sin5(x/2)
2 L2 cos3(x/2)
n
2 cos
³x
2
´
sin
³x
2
´
uxx +
h
3 −2 sin2 ³x
2
´i
ux
o
uyyy
£
× sin7(x/2)/{4 L3 cos5(x/2)}
¤
ux
uxx
uxxx
−8 sin4 +20 sin2 −15
12 cos sin3 −18 cos sin
4 sin4 −4 sin2
uyyyy
£
× sin9 /{8 L4 cos7}
¤
ux
uxx
uxxx
uxxxx
−48 sin6 +168 sin4
88 cos sin5 −232 cos sin3
48 sin6 −120 sin4
−8 cos sin5
−210 sin2 +105
+174 cos sin
+72 sin2
+8 cos sin3
uyyyyy
£
× sin11 /{16 L5 cos9}
¤
ux
uxx
uxxx
uxxxx
uxxxxx
−384 sin8 +1728 sin6
800 cos sin7
560 sin8
−160 cos sin7
−16 sin8
−3024 sin4
−2960 cos sin5
−2080 sin6
+400 cos sin5
+32 sin6
+2520 sin2 −945
+3900 cos sin3
+2660 sin4
−240 cos sin3
−16 sin4
−1950 cos sin
−1140 sin2

558
APPENDIX E. CHANGE-OF-COORDINATE DERIVATIVE TRANSFORMATIONS
Table E.7: Transformations of derivatives for the mapping y = L(1 + x)/(1 −x) + r0 where
y ∈[r0, ∞] and x ∈[−1, 1]. This is similar to the map of Table E.6 except that it takes
the semi-inﬁnite interval in y to the standard interval for Chebyshev polynomials (rather
than that for Fourier series). Deﬁning the auxiliary parameter Q(x) ≡x2 −2x + 1 greatly
simpliﬁes the tables. Note that the translation of the origin given by r0 disappears when
the mapping is differentiated, and therefore all entries below are independent of r0.
uy = ux
Q
2 L
uyy = {Q uxx + 2 (x −1) ux} Q
4 L2
uyyy = {Q uxxx + 6 (x −1) uxx + 6 ux} Q2
8 L3
uyyyy =
©
Q2 uxxxx + 12 (x −1) Q uxxx + 36 Q uxx + 24 (x −1) ux
ª
Q2
16 L4
uyyyyy =
©
Q2uxxxxx + 20 (x−1) Q uxxxx + 120 Q uxxx + 240 (x−1) uxx
+120 ux}
Q3
32 L5
uyyyyyy =
©
Q3 uxxxxxx + 30 (x −1) Q2 uxxxxx + 300 Q2 uxxxx
+1200 (x −1) Q uxxx + 1800 Q uxx + 720 (x −1) ux}
Q3
64 L6

559
Table E.8: Transformation of derivatives for the mapping y = L arctanh(x) which converts
polynomials in sech(y/L) and tanh(y/L) into ordinary polynomials in x. In particular,
tanh(y/L) = x & sech2(y/L) = 1 −x2
The auxiliary parameter is Q(x) ≡1 −x2
uy = ux
Q
L
uyy = {Q uxx −2 x ux} Q
L2
uyyy =
©
Q2 uxxx −6 x Q uxx + (4 −6 Q) ux
ª Q
L3
uyyyy =
©
Q3 uxxxx −12 x Q2 uxxx + Q (28 −36 Q) uxx + x (24 Q −8) ux
ª Q
L4
u5y =
©
Q4 uxxxxx −20 x Q3 uxxxx + Q2 (100 −120 Q) uxxx
+x Q (240 Q −120) uxx + (16 −120 Q + 120 Q2) ux
ª Q
L5
u6y =
©
Q5 uxxxxxx −30 x Q4 uxxxxx + Q3 (260 −300 Q) uxxxx
+x Q2 (1200 Q −720) uxxx + Q (496 −2160 Q + 1800 Q2) uxx
−x (32 −480 Q + 720 Q2) ux
ª Q
L6

560
APPENDIX E. CHANGE-OF-COORDINATE DERIVATIVE TRANSFORMATIONS
Table E.9: Transformation of derivatives under a general mapping x = f(r), y = g(s)
J ≡frgs −fsgr
(E.6)
∂u
∂x = gsur −grus
J
,
∂u
∂y = −fsur + frus
J
(E.7)
uxx
=
gsgsurr −2grgsurs + grgruss
J2
−uy
gsgsgrr −2grgsgrs + grgrgss
J2
−ux
gsgsfrr −2grgsfss + grgrfss
J2
(E.8)
uyy
=
fsfsurr −2frfsurs + frfr ∗uss
J2
−uy
fsfsgrr −2frfsgrs + frfrgss
J2
−ux
fsfsfrr −2frfsfss + frfrfss
J2
(E.9)
Jr = frrgs + frgrs −frsgr −fsgrr; ,
Js = frsgs + frgss −fssgr −fsgrs;
(E.10)
uxy
=
((frgs + fsgr)urs −frgruss −fsgsurr)
J2
+
½(frgss −fsgrs)
J2
+ (fsgsJr −frgsJs)
J3
¾
ur
+
½(fsgrr −frgrs)
J2
+ (frgrJs −fsgrJr)
J3
¾
us
(E.11)

Appendix F
Cardinal Functions
[of the Whittaker cardinal function, sinc(x)]: “a function of royal blood . . . whose distin-
guished properties separate it from its bourgeois brethren.”
— Sir Edmund Whittaker (1915)
F.1
Introduction
The cardinal functions Cj(x) for a given type of interpolation (trigonometric, polynomial,
etc.) and for a set of interpolation points xi are deﬁned by the requirement that
Cj(xi) = δij
i, j = 1, . . . , N
(F.1)
where δij is the usual Kronecker delta symbol deﬁned by
δij ≡
(
1
i = j
0
i ̸= j
[Kronecker delta]
(F.2)
There is no universal terminology; other authors refer to the cardinal functions as the “car-
dinal basis”, “Lagrange basis”, or “the fundamental polynomials of interpolation”.
⃗δk denotes the matrix of the k-th derivative at the interpolation points:
(δk)ij ≡dkCj
dxk
¯¯¯¯
x=xi
(F.3)
The tables use the auxiliary column vectors deﬁned by:
cj ≡
(
2
j = ±N
1
otherwise
&
pj ≡
(
2
j = 0 or N
1
otherwise
(F.4)
561

562
APPENDIX F. CARDINAL FUNCTIONS
F.2
General Fourier Series: Endpoint Grid
Taken from Gottlieb, Hussaini, and Orszag(1984).
Grid points:
xi = π i
N
i = 0, . . . , 2N −1
(F.5)
Cardinal Funcs.:
Cj(x)
≡
1
2N sin[N(x −xj)] cot[0.5(x −xj)]
(F.6)
≡
1
2 N
N
X
k=−N
1
ck
exp[ik(x −xj)]
(F.7)
1st Derivative:
(δ1)ij ≡
(
0
i = j
0.5(−1)i−j cot[0.5(xi −xj)]
i ̸= j
(F.8)
2d Derivative:
(δ2)ij ≡
(
−(1 + 2N 2)/6
i = j
0.5(−1)i−j+1/ sin2[0.5(xi −xj)]
i ̸= j
(F.9)

F.3. FOURIER COSINE SERIES: ENDPOINT GRID
563
F.3
Fourier Cosine Series: Endpoint Grid
xi = π i
N
i = 0, . . . , N
[(N+1) degrees of freedom]
(F.10)
Ccos
j
(x) ≡









(−1)j+1
sin(x) sin(Nx)
pj N[cos(x) −cos(xj)]
2
N pj
N
X
m=0
1
pm
cos(mxj) cos(mx)
(F.11)
where pj = 2 if j = 0 or N and pj = 1 if j = 1, . . . , N −1.
1st Deriv.: (N + 1) × (N + 1) matrix
dCcos
j
dx
¯¯¯¯
x=xi
≡(δcos
1 )ij ≡
(
(δ1)ij
j = 0 or N
(δ1)ij + (δ1)i,2N−j
otherwise
(F.12)
where ⃗δ1 is the ﬁrst derivative matrix for a general Fourier series (F.8).
Alternative 1st Derivative:
(δcos
1 )ij ≡











0
i = 0 or i = N, all j
0.5 cot(xj)
i = j; j = 1, . . . , N −1
(−1)j+1 sin(xi) cos(Nxi)
pj[cos(xi) −cos(xj)]
i ̸= j, 0, N
(F.13)
2d Derivative:
⃗δcos
2
≡⃗δsin
1
⃗δcos
1
(F.14)
where ⃗δsin
1
is the ﬁrst derivative matrix for a Fourier sine series, deﬁned in the next subsec-
tion.

564
APPENDIX F. CARDINAL FUNCTIONS
Quadrature formula: If f(x) = f(−x), then
Z π
0
f(x) dx ≈
N
X
i=0
wi f(xi)
(F.15)
where the xi are given by (F.10) and where the weights are
wi ≡
(
π/N
i = 1, 2, . . . , N −1
π/(2N)
i = 0 or i = N
(F.16)
These weights are identical with those of the usual trapezoidal rule, but the accuracy for
this special case of a periodic, symmetric function is exponentially accurate. The quadrature is
exact if f(x) is a trigonometric cosine polynomial of degree at most N (where the number
of interpolation points is N + 1).

F.4. FOURIER SINE SERIES: ENDPOINT GRID
565
F.4
Fourier Sine Series: Endpoint Grid
xi = π i
N
i = 1, . . . , N −1
[(N-1) degrees of freedom]
(F.17)
Note: by symmetry, a Fourier sine series must vanish at x = 0 & π, so there are only
(N −1) degrees of freedom. We can deﬁne the derivative matrix as one of dimension
(N +1)×(N +1) for use in computing the even derivatives of a cosine series [by extending
(F.17) to include i = 0 and i = N], but in applying collocation to compute a solution in the
form of a sine series, we should use only the interior points.
Cardinal Funcs:
Csin
j (x) ≡(−1)j+1 sin(xj) sin(Nx)
N[cos(x) −cos(xj)]
j = 1, . . . , N −1
(F.18a)
Csin
j (x) ≡2
N
N−1
X
m=1
sin(mxj) sin(mx)
j = 1, . . . , N −1
(F.18b)
1st Deriv.: (N + 1) × (N + 1) matrix
¡
δsin
1
¢
ij ≡
(
0
j = 0 or N
(δ1)ij −(δ1)i,2N−j
otherwise
(F.19)
where δ1 is the ﬁrst derivative matrix for a general Fourier series, deﬁned in (F.8), and
where cj is deﬁned by (F.4). An equivalent deﬁnition of the sine derivative is
Alternative 1st Deriv:
¡
δsin
1
¢
ij ≡











0
j = 0 or N
−0.5 cot(xj)
i = j
(−1)i+j+1 sin(xj)
cos(xi) −cos(xj)
otherwise
(F.20)
2d Deriv:
⃗δsin
2
= ⃗δcos
1
⃗δsin
1
(F.21)

566
APPENDIX F. CARDINAL FUNCTIONS
Exponentially Accurate Quadrature:
If f(x) = −f(−x), then
Z π
0
f(x) dx =
X
i=1
wi f(xi)
(F.22)
where the xi are deﬁned by (F.17) and the weights are given by
wi ≡2
N
N−1
X
m=1
1
m sin(mxi)[1 −cos(mπ)]
(F.23)
This quadrature formula is exact if f(x) is a trigonometric sine polynomial of degree (N−1)
or less; note that (N −1) is the actual number of quadrature abscissas.

F.5. COSINE CARDINAL FUNCTIONS: INTERIOR GRID
567
F.5
Cosine Cardinal Functions on the Interior (Rectangle Rule)
Grid
Previously unpublished.
Grid points:
xi = (2i −1) π
2N
[N degrees of freedom]
(F.24)
Ccos
j
(x)
≡
(−1)j+1
cos(Nx) sin(xj)
N[cos(x) −cos(xj)]
(F.25)
=
2
N
N
X
m=0
1
pm
cos(mxj) cos(mx)
(F.26)
where the 1/pm term means that the m = 0 and m = N terms in the sum should be divided
by (1/2).
Quadrature Rule:
If f(x) is a periodic but symmetric function with a period of 2π, then
Z π
0
f(x) dx ≈
N
X
j=1
wj f(xj)
(F.27)
where the quadrature weights are given by
wj ≡π
N
[“Rectangle Rule”]
(F.28)
independent of j. Although the “rectangle rule” is rather crude [O(1/N 2)] accuracy for
integrating non-periodic integrals, it is has an error that decreases exponentially fast with N
when applied to an integrand which is (i) periodic and (ii) symmetric about the origin.

568
APPENDIX F. CARDINAL FUNCTIONS
F.6
Sine Cardinal Functions on the Interior (Rectangle Rule)
Grid
Previously unpublished.
Grid points:
xi = (2i −1)π
2 N
[N degrees of freedom]
(F.29)
Csin
j (x)
≡
sin(Nxj) cos(Nx) sin(x)/(N[cos(x) −cos(xj)])
(F.30a)
=
2
N
N
X
m=1
1
cm
sin(mxj) sin(mx)
(F.30b)
where the 1/cm term means that the m = N term in the sum should be divided by (1/2).
Quadrature Rule:
If f(x) is a periodic but antisymmetric function with a period of 2π, then
Z π
0
f(x) dx ≈
N
X
j=1
wj f(xj)
(F.31)
where the quadrature weights are given by
wj ≡
2
N 2 sin(Nxj) sin2
µNπ
2
¶
+ 4
N
N−1
X
m=1
1
m sin(mxj) sin2 ³mπ
2
´
(F.32)

F.7. SINC(X): WHITTAKER CARDINAL FUNCTION
569
F.7
Sinc(x): Whittaker cardinal function
These are employed to represent functions on the interval x ∈[−∞, ∞]. It is necessary to
simultaneously (i) decrease the spacing h between neighboring interpolation points and (ii)
increase the number of sinc functions retained in the expansion to obtain higher accuracy
for a given f(x). The function being expanded must decay as |x| →∞. The formulas are
taken from Stenger(1981).
Grid points:
xi = h i
i = 0, ±1, ±2, . . .
(F.33)
Cardinal Functions:
Cj(x) ≡sinc
µx −jh
h
¶
(F.34)
where
sinc(x) ≡sin(πx)
πx
(F.35)
1st Derivative:
h
³
δsinc
1
´
i,i+n =
(
0
n = 0
(−1)n+1/n
n ̸= 0
(F.36)
2d Derivative:
h2 ³
δsinc
2
´
i,i+n =
(
−π2/3
n = 0
−2(−1)n/n2
n ̸= 0
(F.37)
h3 ³
δsinc
3
´
i,i+n =
(
0
n = 0
(−1)n+1 £
6/n3 −π2/n
¤
n ̸= 0
(F.38)
h4 ³
δsinc
4
´
i,i+n =
(
π4/5
n = 0
4(−1)n[π2/n2 −6/n4]
n ̸= 0
(F.39)
h5 ³
δsinc
5
´
i,i+n =
(
0
n = 0
(−1)n+1[π4/n −20π2/n3 + 120/n5]
n ̸= 0
(F.40)
h6 ³
δsinc
6
´
i,i+n =
(
−π2/7
n = 0
−6(−1)n[π4/n2 −20π2/n4 + 120/n6]
n ̸= 0
(F.41)
Fourier representation:
sinc(x) ≡1
2 π
Z π
−π
exp(±ikx) dk
(F.42)

570
APPENDIX F. CARDINAL FUNCTIONS
F.8
Chebyshev Polynomials: Extrema & Endpoints (“Gauss-
Lobatto”) Grid
Taken from Gottlieb, Hussaini, and Orszag(1984).
Grid points:
xi = cos
µπ i
N
¶
i = 0, . . . , N
(F.43)
Cardinal Funcs:
Cj(x)
≡
(−1)j+1
(1 −x2)
cjN 2(x −xj)
dTN(x)
dx
(F.44a)
=
2
N pj
N
X
m=0
1
pm
Tm(xj) Tm(x)
(F.44b)
where pj = 2 if j = 0 or N and pj = 1 if j = 1, . . . , N −1; cj = 1 if |j| < N; c±N = 2.
1st Derivative:
³
δCheb
1
´
ij ≡dCj
dx
¯¯¯¯
x=xi
=











(1 + 2N 2)/6
i = j = 0
−(1 + 2N 2)/6
i = j = N
−xj/[2(1 −x2
j)]
i = j; 0 < j < N
(−1)i+jpi/[pj(xi −xj)]
i ̸= j
(F.45)
where p0 = pN = 2, pj = 1 otherwise.
Higher Derivative:
⃗δCheb
k
=
³
⃗δCheb
1
´k
(F.46)
where the exponent k denotes the usual matrix multiplication of k copies of the ﬁrst deriva-
tive matrix.
Note: The ﬁrst derivative matrix is not antisymmetric (with respect to the interchange of i
and j) and the second derivative matrix is not symmetric. This makes it difﬁcult to prove
stability theorems for time-integration methods (Gottlieb et al., 1984).

F.9. CHEBYSHEV POLYNOMIALS: INTERIOR OR “ROOTS” GRID
571
F.9
Chebyshev Polynomials: Interior or “Roots” Grid
Grid Points:
xi = cos
µ
π 2i −1
2N
¶
i = 1, . . . , N
(F.47)
Cardinal Functions:
Cj(x)
≡
TN(x)
T ′
N(xj) [x −xj]
(F.48)
≡
cos(Nt) sin(tj)
N sin(Ntj)[cos(t) −cos(tj)]
(F.49)
where the T ′
N is the x-derivative of TN(x) and where in the trigonometric form, t = arccos(x)
and tj = arccos(xj) where the branch is chosen so that 0 ≤t ≤π.
1st Derivative:
dCj
dx
¯¯¯¯
x=xi
≡(δ1)ij =







0.5 xj/(1 −x2
j)
i = j
(−1)i+j
q
(1 −x2
j)/(1 −x2
i )
xi −xj
i ̸= j
(F.50)
Second Derivative:
d2Cj
dx2
¯¯¯¯
x=xi
≡(δ2)ij =









x2
j
(1 −x2
j)2 −
N 2 −1
3(1 −x2
j)
i = j
(δ1)ij
½
xi
1 −x2
i
−
2
xi −xj
¾
i ̸= j
(F.51)

572
APPENDIX F. CARDINAL FUNCTIONS
F.10
Legendre Polynomials: Extrema & Endpoints Grid (“Gauss-
Lobatto”)
These data are from Gottlieb, Hussaini, & Orszag(1984).
Grid points:
x0 = −1
&
xN = 1
&
the (N-1) roots of dPN/dx
(F.52)
Cardinal Functions:
Cj(x) ≡
−(1 −x2)
N(N + 1)PN(xj)(x −xj)
dPN(x)
dx
(F.53)
Quadrature weights:
wj ≡
2
N(N + 1) {PN(xj)}2
(F.54)
First Derivative Matrix:
µ
δLeg
1
¶
ij
=











(1/4)N(N + 1)
i = j = 0
−(1/4)N(N + 1)
i = j = N
0
i = j & 0 < j < N
PN(xi)/[PN(xj)(xi −xj)]
i ̸= j
(F.55)
Four-Point Interpolation
P3 = −3
2x + 5
2x3,
dP3
dx = −3
2 + 15
2 x2
(F.56)
Table F.1: Grid points and weights for 4-point Legendre-Lobatto
xj
wj
±1
-
1/6
0.166666666666667
±0.447213595499958
±
p
1/5
5/6
0.833333333333333

F.10. LEGENDRE POLYNOMIALS: GAUSS-LOBATTO GRID
573
Five-Point Interpolation
P4 = 3
8 −15
4 x2 + 35
8 x4,
dP4
dx = −15
2 x + 35
2 x3
(F.57)
Table F.2: Grid points and weights for 5-point Legendre-Lobatto
xj
wj
±1
-
1/10
0.1
±0.654653670707977
±
p
3/7
49/90
0.544444444444444
0
-
32/45
0.711111111111111
Six-Point Interpolation
P5 = 15
8 x −35
4 x3 + 63
8 x5;
dP5
dx = 15
8 −105
4 x2 + 315
8 x4
(F.58)
Table F.3: Grid points and weights for 6-point Legendre-Lobatto
Notes: Variants for weights: w(±0.765) = 9/(20 + 10/
√
7) and w(±0.285) = 9/(20 −10/
√
7).
xj
wj
±1
-
1/15
0.066666666666667
±0.765055323929464
±
q
(7 + 2
√
7)/21
1
15{P5(xj)}2
0.378474956297847
±0.285231516480645
±
q
(7 −2
√
7)/21
1
15{P5(xj)}2
0.554858377035486
Seven-Point Interpolation
P6 = −5
16 + 105
16 x2 −315
16 x4 + 231
16 x6,
dP6
dx = 105
8 x −315
4 x3 + 693
8 x5
(F.59)
Table F.4: Grid points and weights for 7-point Legendre-Lobatto
Notes: Variants for weights: w(±0.8302) = 43923/(175
n
3 + 7
√
15
o2
) and
w(±0.468) = 43923/(175
n
−3 + 7
√
15
o2
).
xj
wj
±1
-
1/21
0.047619047619047
±0.830223389627857
±
q
(15 + 2
√
15)/33
1
21{P6(xj)}2
0.276826047361566
±0.468848793470714
±
q
(15 −2
√
15)/33
1
21{P6(xj)}2
0.431745381209862
0
-
256
525
0.487619047619048

574
APPENDIX F. CARDINAL FUNCTIONS
Eight-Point Interpolation
P7
=
−35
16x + 315
16 x3 −693
16 x5 + 429
16 x7
(F.60)
dP7
dx
=
−35
16 + 945
16 x2 −3465
16 x4 + 3003
16 x6
(F.61)
Table F.5: Grid points and weights for 8-point Legendre-Lobatto
Notes: r = 320
√
55/265837 and φ = arccos(
√
55/30) . xj in the expression for the weights denotes the corre-
sponding grid point.
xj
wj
±1
-
1/28
0.035714285714285
±0.871740148509606
±
r
2r1/3 cos
³
φ
3 +
5
13
´
1
28{P7(xj)}2
0.210704227143506
±0.591700181433142
±
r
2r1/3 cos
³
φ
3 +
5
13 + 4π
3
´
1
28{P7(xj)}2
0.341122692483504
±0.209299217902479
±
r
2r1/3 cos
³
φ
3 +
5
13 + 2π
3
´
1
28{P7(xj)}2
0.412458794658704
Nine-Point Interpolation
P8
=
35
128 −315
32 x2 + 3465
64 x4 −3003
32 x6 + 6435
128 x8
(F.62)
dP8
dx
=
−315
16 x + 3465
16 x3 −9009
16 x5 + 6435
16 x7
(F.63)
Table F.6: Grid points and weights for 9-point Legendre-Lobatto
Notes: r = 448
√
91/570375 and φ = arccos(
√
91/154) . xj in the expression for the weights denotes the corre-
sponding grid point.
xj
wj
±1
-
1/36
0.027777777777777
±0.899757995411460
±
r
2r1/3 cos
³
φ
3 +
7
15
´
1
36{P8(xj)}2
0.165495361560805
±0.677186279510737
±
r
2r1/3 cos
³
φ
3 +
7
15 + 4π
3
´
1
36{P8(xj)}2
0.274538712500161
±0.363117463826178
±
r
2r1/3 cos
³
φ
3 +
7
15 + 2π
3
´
1
36{P8(xj)}2
0.346428510973046
0
-
4096
11025
0.371519274376417
Canuto, Hussaini, Quarteroni and Zang (1988), Appendix C, give a short FORTRAN
program to compute the Legendre-Lobatto points for general degree.

Appendix G
Transformation of Derivative
Boundary Conditions
“Pseudospectral algorithms are simply N-th order ﬁnite differences in disguise.”
— J. P. Boyd
One modest complication in applying boundary conditions imposed on the derivatives
of the solution is that the mapping functions which relate the derivatives in the original co-
ordinate y to those of the new coordinate x are usually singular at the endpoints. However, it
is straightforward to obtain the correct conditions via l’Hopital’s Rule, which is equivalent
to making power series expansions about the endpoint and then taking x →endpoint.
To illustrate, consider mapping that converts Chebyshev polynomials in y into cosines
in x.
y = cos(x)
y ∈[−1, 1]
&
x ∈[0, π]
(G.1)
The method, however, can be applied to any of the mappings discussed above.
Suppose that the boundary conditions are
uy(1) = α
&
uyy(1) = β
(G.2)
Now from Table E.2,
uy = −
ux
sin(x)
(G.3)
The complication is that as y →1, x →0, and the denominator of (G.3) is 0.
However, u(y) is mapped into u(cos[x]) which is always symmetric about both x = 0
and x = π. This in turn implies that all the odd derivatives of u(y[x]) with respect to x must
vanish at both endpoints. Thus, the R. H. S. of (G.3) is ﬁnite because both its numerator and
denominator vanish. To calculate the limit at the endpoint, write the Taylor expansions
ux(x)
≈
ux(0) + x uxx(0) + O(x2)
|x| ≪1
(G.4)
≈
x uxx(0) + O(x3)
(G.5)
since all the odd derivatives vanish. Since
sin(x) ≈x −x3
6 + O(x5)
(G.6)
575

576
APPENDIX G. TRANSFORMATION OF DERIVATIVE BOUNDARY CONDITIONS
one ﬁnds
uy(y) ≈−x uxx(0)/x + O(x2)
|x| ≪1
(G.7)
which, after cancelling the common power of x, implies that the correct boundary condi-
tion is
uy(1) = −uxx(0)
(G.8)
Thus, THE CORRECT WAY TO IMPOSE THE BOUNDARY CONDITION ON THE FIRST
DERIVATIVE WITH RESPECT TO y IS TO IMPOSE IT ON THE SECOND DERIVATIVE
WITH RESPECT TO x, i. e.
uxx(0) = −α = −uy(1)
(G.9)
Similarly, for the second derivative, note
uyy =
1
sin2(x) uxx −cos(x)
sin3(x) ux
(G.10)
Via Taylor expansions,
uyy ≈
½ 1
x2 + 1
3
¾ ½
uxx(0) + x2
2 uxxxx(0)
¾
−
½ 1
x3 + O(x)
¾ ½
x uxx(0) + x3
6 uxxxx(0)
¾
(G.11)
uyy(1) ≡1
3 {uxx(0) + uxxxx(0)}
(G.12)
which means that on the transformed problem in x, we should impose the boundary con-
dition that
uxxxx(x = 0) = 3β + α = 3 uyy(y = 1) + uy(y = 1)
(G.13)

Glossary
“Like Adam, naming the birds and the ﬂowers”
— J. J. Sylvester
[of his invention of many mathematical terms]
ALGEBRAIC CONVERGENCE: If the ALGEBRAIC INDEX OF CONVERGENCE for a
series is ﬁnite, then the series has “algebraic convergence”. If an ∼1/nk, n →∞for
some ﬁnite k, then the series has “algebraic convergence”.
ALGEBRAIC INDEX OF CONVERGENCE k: This index k is the largest number for which
lim
n→∞|an| nk < ∞
where the an are the series coefﬁcients. The usual proof that a given function has
algebraic index of convergence k is to apply k integrations-by-parts to the coefﬁcient
integrals. If this process of integration-by-parts can be repeated indeﬁnitely so that
the equation is true for arbitrarily large k, then the convergence is “inﬁnite order” or
“exponential”. If the coefﬁcients an ∼1/nk, n →∞, then k is the “algebraic index of
convergence”.
ANTISYMMETRIC: If a function is such that f(x) = −f(x) for all x, it is said to be “AN-
TISYMMETRIC with respect to the origin” or to be of “odd PARITY”.
ARITHMURGY: Synonym for “number-crunching”. (From the Greek αρθµoσ, “number”,
and –ϵργoσ, “working”.)
ASSUMPTION OF EQUAL ERRORS: This empirical principle, which cannot be rigor-
ously proved but is supported by strong heuristic arguments and by practical expe-
rience, states the “discretization error” and the “truncation error” are of the same
order-of-magnitude. Whenever it is true, one can estimate the total error in a spectral
calculation merely by estimating the truncation error, which is usually much easier
to estimate than the discretization error. (Chap. 2.)
ASYMPTOTIC RATE OF GEOMETRIC CONVERGENCE: If a series has GEOMETRIC
CONVERGENCE, that is, if
|an| < exp(−nµ)
all n,
then the “asymptotic rate of geometric convergence” is the largest µ for which the
above bound is true. The asymptotic rate of convergence is undeﬁned for series with
algebraic or subgeometric convergence.
577

578
Glossary
BANDED (MATRIX): A label applied to a matrix whose elements Aij are all zero except
for diagonal bands around the main diagonal, that is, Aij = 0 if |i −j| > m for some
m. (Appendix B.)
BANDWIDTH (of a MATRIX): If the elements Aij = 0 unless |i −j| ≤m, then (2m + 1)
is the BANDWIDTH of the BANDED MATRIX.
BASIS FUNCTIONS: The members of a BASIS SET. Examples of basis functions are the
Chebyshev polynomials and the Hermite functions (and in general all the classes of
functions described in Appendix A).
BASIS RECOMBINATION: A strategy for satisfying numerical boundary conditions in
which the original basis set, such as Chebyshev polynomials, is replaced by a new
basis composed of linear combinations of the original basis functions such that each
member of the new basis individually satisﬁes the boundary conditions. The alterna-
tive strategy is BOUNDARY BORDERING. (Chap. 6, Sec. 4.)
BASIS SET: The collection of functions which are used to approximate the solution of a
differential equation. The Fourier functions {1, cos(nx), sin(nx) for n = 1, 2, . . . }
and the Chebyshev polynomials {Tn(x), n = 0, 1, . . . } are two examples of basis
sets.
BEHAVIORAL BOUNDARY CONDITION: A boundary condition that imposes a cer-
tain behavior on the solution rather specifying a numerical constraint. Examples of
behavioral boundary conditions include: (i) periodicity with a certain period L (ii)
boundedness and inﬁnite differentiability at a point where the coefﬁcients of the dif-
ferential equation are singular. It is usually possible to satisfy such conditions by
proper choice of basis function. For example, the sines and cosines of a Fourier series
are periodic, so no further action is needed to enforce periodicity on the solution.
BIFURCATION POINT: A point where two branches of a solution u(α) cross. Synonym
is “crossing point”. For both α > α limit and α < α limit, two different solutions exist
which meet at the bifurcation point. Newton’s method fails at a bifurcation point,
but it is possible to “shoot the bifurcation point” or switch branches as explained in
Appendix D. (When “bifurcation” is used in a broader sense, a “crossing point” is
also called a “trans-critical bifurcation”. )
BLOCKING, SPECTRAL: See SPECTRAL BLOCKING.
BOUNDARY BORDERING : A strategy for satisfying boundary conditions in which
these are imposed as explicit constraints in the matrix problem which is solved for
the spectral coefﬁcients. Some of the collocation or Galerkin conditions on the resid-
ual are replaced by a “border” of rows which impose the constraints. The major
alternative is BASIS RECOMBINATION. (Chap. 6.)
CHOLESKY FACTORIZATION: Factorization of a SYMMETRIC matrix into the product
LLT where L is lower triangular and LT is its transpose; Cholesky factorization re-
quires only half as many operations as the usual LU factorization. (Appendix B.)
COLLOCATION: Adjective for labelling methods which determine the series coefﬁcients
by demanding that the residual function be zero on a grid of points. In this book, a
synonym for PSEUDOSPECTRAL and for METHOD OF SELECTED POINTS. Else-
where in the literature, this adjective is also applied to certain ﬁnite element methods.

Glossary
579
COLLOCATION POINTS: the grid of points where the residual function must vanish.
Synonym for INTERPOLATION POINTS.
COMPATIBILITY CONDITIONS: A countably inﬁnite set of constraints on the initial
conditions of a time-dependent partial differential equation which are necessary for
the solution to be analytic everywhere in the space-time domain. Example: an incom-
pressible ﬂow will be strongly singular at t = 0 if the initial condition is divergent
at some point in the ﬂuid, and will have discontinuities (vortex sheets) at rigid walls
if the initial velocity does not satisfy the no-slip boundary condition of vanishing at
the walls. If the initial ﬂow does not satisfy additional constraints, the ﬂow will be
singular, but more weakly in the sense of having more derivatives than if the nondi-
vergence and no-slip constraints are violated. The constraints are different from each
partial differential equation.
COMPLETENESS: A basis set is “complete” for a given class of functions if all functions
within the class can be represented to arbitrarily high accuracy as a sum of a sufﬁ-
ciently large number of basis functions.
CROUT REDUCTION: Solution of a matrix equation by direct LU FACTORIZATION.
DARBOUX’S PRINCIPLE: Theorem that for a function f(x), the asymptotic form of the
spectral coefﬁcients an as n →∞are controlled by the singularities (poles, branch
points, etc.) of f(x). (Theorem 1.)
DENSE MATRIX: A matrix whose elements are mostly nonzero so that the zero elements
do not offer any structure which can be exploited to reduce the cost of LU factoriza-
tion. A synonym for FULL MATRIX; the opposite of a SPARSE MATRIX.
DIFFERENTIAL QUADRATURE/DIFFERENTIAL CUBATURE: Almost a synonym for
“PSEUDOSPECTRAL”. The DQ method, like the pseudospectral, uses difference for-
mulas, based on either trigonometric or polynomial interpolation, in which every
point on the grid (or every point on a coordinate line in multiple dimensions) con-
tributes to the approximation at every point on the grid (or coordinate line). The
difference from the pseudospectral method is that the distribution of points is com-
pletely arbitrary in theory. (In practice, the roots of Chebyshev polynomials are com-
monly used, making DQ identical with Chebyshev pseudospectral.) Differential Cu-
bature is a multi-dimensional scheme which does not use a tensor product basis, but
instead approximates derivatives using the grid point values at every point of the
two-dimensional or three-dimensional grid. (This is expensive!).
DIRECT MATRIX METHOD: A non-iterative algorithm for solving a matrix equation, as
in the phrase “fast direct methods”. Examples include Gaussian elimination, Crout
reduction, Cholesky factorization, LU factorization, skyline solver, and static conden-
sation (Appendix B).
DISCRETE ORDINATES METHOD: Synonym for “PSEUDOSPECTRAL” or “COLLO-
CATION” method. (This term is most common among physicists and chemists.)
DISCRETIZATION ERROR: This is the difference between the ﬁrst (N +1) coefﬁcients of
the exact solution and the corresponding coefﬁcients as computed using a spectral or
pseudospectral algorithm with (N +1) basis functions. It is distinct from (but usually
the same order-of-magnitude as) the “truncation error”. (Def. 9.)

580
Glossary
DOMAIN TRUNCATION: A method of solving problems on unbounded domains by re-
placing the interval y ∈[−∞, ∞] by y ∈[−L, L]. If |u(±L)| decays exponentially
with L, then it is possible to obtain solutions of arbitrary accuracy by choosing L
sufﬁciently large. (Chap. 17.)
ENVELOPE OF THE COEFFICIENTS: A smooth, monotonically decreasing curve which
is a tight bound on oscillatory Chebyshev or Fourier coefﬁcients {an} in the sense that
the absolute value of the coefﬁcients is arbitrarily close to the envelope inﬁnitely often
as n →∞. (Borrowed from wave theory, where the “envelope of a wave packet” has
the identical meaning.)
ENVELOPE OF THE INTERPOLATION ERROR: The envelope ρ is deﬁned by
ρ ≡EI(x; N)
ΦN(x)
where EI(x; N) is the interpolation error and ΦN(x) is the function whose roots are
the interpolation grid. (Boyd, 1990c.)
EQUAL ERRORS, ASSUMPTION OF: This empirical principle, unprovable but supported
by strong heuristic arguments and practical experience, states that the “DISCRETIZA-
TION ERROR” and “TRUNCATION ERROR” and “INTERPOLATION ERROR” are
the same order of magnitude. (Chap. 2.)
ESSENTIAL BOUNDARY CONDITION: A boundary condition is “essential” if it must
be explicitly imposed on the approximation to the solution of a differential equa-
tion; usually, essential boundary conditions are NUMERICAL BOUNDARY CONDI-
TIONS, that is, require the solution u or its derivative to equal a certain number or
function on the boundary.
EXPLICIT (TIME-MARCHING): A time-integration scheme in which the solution at the
next time level is given by an explicit formula that does NOT require solving a bound-
ary value problem. (See also IMPLICITLY-IMPLICIT.) (Chap. 9.)
EXPONENTIAL CONVERGENCE: A spectral series possesses the property of “exponen-
tial convergence” if the error decreases faster than any ﬁnite inverse power of N as
N, the number of terms in the truncated series, increases. Typically, the series coefﬁ-
cients decrease as O(exp[−pnr]) for some positive constants p and r. A synonym for
“inﬁnite order convergence”.
EXPONENTIAL INDEX OF CONVERGENCE: If the series coefﬁcients an satisfy
an ∼O[s exp(−q nr)],
n →∞
where s, q, and r are constants, then r is the “exponential convergence index”. Alter-
native deﬁnitions are given in Chap. 2 as Def. 4.
FFT: Abbreviation for FAST FOURIER TRANSFORM. (Chap. 10.)
FINITE ELEMENT METHOD: A class of algorithms in which the domain is divided into
subdomains and the solution is approximated by a different polynomial on each sub-
domain. At high order, these piecewise approximations must be constructed by the
same strategies as for global spectral methods, and are therefore called SPECTRAL
ELEMENTS or “h-p” ﬁnite elements.
FOLD POINT: Synonym for LIMIT POINT.

Glossary
581
GEOMETRIC CONVERGENCE: A series whose coefﬁcients are decreasing
an ∼α(n)pn ↔α(n) exp[−n | log(p)|])
n →∞
|p| < 1
has the property of “geometric convergence” where α(n) denotes a function that
varies algebraically, rather than exponentially, with n such as a power of n. The
reason for the name is that the terms of a geometrically convergent series can always
be bounded by those of a geometric series, that is, by the terms of the power series
expansion of α/(β + x) for some α and β where these are constants. (All convergent
power series have geometric convergence. All Chebyshev series for functions which
have no singularities on x ∈[−1, 1] (including the endpoints) also have geometric
convergence).
GIBBS OSCILLATIONS: When a function with a discontinuity or a discontinuity in a
derivative of some order is approximated by a spectral series truncated at N terms,
the sum of the truncated series oscillates with a wavelength which is O(1/N). These
oscillations are also called “SPECTRAL RINGING”.
GIBBS PHENOMENON: When a function with a discontinuity is approximated by a
spectral series truncated at N terms, the sum of the truncated series overshoots the
true value of the function at the edge of the discontinuity by a ﬁxed amount (ap-
proximately 0.089 times the height of the jump), independent of N. GIBBS PHE-
NOMENON also includes GIBBS OSCILLATIONS.
GLOBAL ELEMENT: (Now rare.) Sometimes a synonym for SPECTRAL ELEMENTS,
often used in a narrower sense to label elements which are discontinuous at inter-
element boundaries.
h-p FINITE ELEMENT: See SPECTRAL ELEMENT.
IMBRICATE SERIES: An inﬁnite series for a spatially periodic function which is the su-
perposition of an inﬁnite number of evenly spaced identical copies of a “pattern”
function A(x). It may be shown that all periodic functions have imbricate series in
addition to their Fourier expansions, and often the imbricate series converge faster.
Imbricate series may be generalized to an arbitrary number of dimensions.
IMPLICIT (TIME-MARCHING): A time-integration scheme in which it is necessary to
solve a boundary-value problem to compute the solution at the new time level. The
Crank-Nicholson method is an example. (Chap. 12.)
IMPLICITLY-IMPLICIT: A label for a time-dependent partial differential equation in which
the time derivative is multiplied by a differential operator L so that it is necessary to
solve a boundary value problem at every time step even to apply an explicit time-
marching scheme. (Chap. 9.)
INFINITE ORDER CONVERGENCE: A spectral series possesses the property of “inﬁ-
nite order convergence” if the error decreases faster than any ﬁnite inverse power
of N as N, the number of terms in the truncated series, increases. A synonym for
“exponential convergence”.
INTERPOLANT: An approximation PN−1(x) whose free parameters or coefﬁcients are
chosen by the requirement that
f(xi) = PN−1(xi)
i = 1, . . . , N
at a set of N grid points. The process of computing such an approximation is INTER-
POLATION.

582
Glossary
ISOLA: For a nonlinear equation that depends upon two parameters, α and τ, an “isola”
is a one-parameter family of solutions, parameterized by some quantity s, such that
(α(s), τ(s)) is a simple closed curve in the α−τ plane. (From Latin “insula”, “island”,
through Italian “isolato”, “isolate”.)
JURY PROBLEM: Numerical slang for a boundary value problem in one or more dimen-
sions. The reason for the name is that when discretized by any reasonable difference
or spectral scheme, the solution must be computed on the entire grid simultaneously.
All the boundary and interior values render a “verdict” on the solution at each point.
See also MARCHING PROBLEM.
LANCZOS-TAU METHOD: Technique for solving differential equations which computes
an exact solution to an approximate differential equation. (The differential equation is
perturbed in such a way that an exact solution of the perturbed problem is possi-
ble.) This philosophy is opposite to the usual strategy of computing an approximate
solution to the original, exact differential equation. (Chap. 21.)
LIMIT POINT: A point where a solution u(α) of a nonlinear equation curves back so that
there are two solutions for α on one side of α = α limit and no solutions on the other
side of the limit point. As the limit point is approached, du/dα →∞. Special methods
[“pseudoarclength continuation” or “globally convergent homotopy”] are needed to
“turn the corner” and march from the lower branch through the limit point onto the
upper branch or vice versa. Synonyms are “FOLD POINT”, “TURNING POINT”,
and “SADDLE-NODE BIFURCATION”. (Appendix D.)
MARCHING PROBLEM: Arithmurgical slang for a time-dependent problem. It is not
necessary to compute the solution through the entire space-time plane at once. In-
stead, one can march from one time level to the next, computing over all space at
ﬁxed t independently of the unknown future. See also JURY PROBLEM.
METHOD OF SELECTED POINTS: Synonym for PSEUDOSPECTRAL & ORTHOGONAL
COLLOCATION. (Now rare.)
MMT: MATRIX MULTIPLICATION TRANSFORM: This is N-point interpolation using
N-point Gaussian quadrature or summation of an N-point spectral series at each of
the N grid points. In either direction, the transform is computed by multiplying
an N-dimensional column vector by an N-dimensional square matrix. (PMMT is the
same except that the transform is split into two multiplications by (N/2)-dimensional
square matrices to exploit parity. (Chap. 10.)
NATURAL BOUNDARY CONDITION: A boundary condition is “natural” if it need not
be explicitly imposed, but rather is implicitly satisﬁed by the choice of basis functions.
Examples include periodicity (implicit in Fourier basis) and analyticity at an endpoint
where the coefﬁcients of the differential equation are singular (implicit in Chebyshev
basis).
NON-INTERPOLATING: (i) Adjective used to label that family of spectral methods which
do not employ an auxiliary interpolation grid to compute the series coefﬁcients.
Galerkin’s method and the Lanczos-tau method are examples (ii) Label for a semi-
Lagrangian time-marching scheme invented by Ritchie (Chap. 14.)
NUMERICAL BOUNDARY CONDITION: A constraint such as u(−1) = −0.5 which in-
volves a number. It is always necessary to modify either the basis set or the Galerkin
or pseudospectral matrix to enforce such conditions.

Glossary
583
ORTHOGONAL COLLOCATION: A collocation method in which the grid points are the
roots or extrema of the basis functions. Synonym for PSEUDOSPECTRAL.
PARITY: A symmetry of functions such that either f(x) = f(−x) for all x (“SYMMETRIC
with respect to the origin”) or f(x) = −f(−x) for all x (“ANTISYMMETRIC with
respect to the origin”. A symmetric function is said to be of “even parity” while an
antisymmetric function is said to be of “odd parity”.
PERIODIC: A function f(x) is “periodic” with period L if and only if
f(x + L) = f(x)
for all x.
PMMT: PARITY MATRIX MULTIPLICATION: Same as the MMT except parity is ex-
ploited by taking sums and differences of the input vector to compute its symmetric
and antisymmetric parts and each is transformed separately by a matrix-vector mul-
tiplication. The two transforms are combined to give the transform of the original
unsymmetric series or set of grid point values. (Chap. 10.)
PRECONDITIONING: A technique for accelerating the convergence of an iteration for
solving Λx −f by changing the iteration matrix to H−1Λ. The matrix H is the “pre-
conditioning matrix” and is chosen to be an approximation to Λ (in the sense of hav-
ing approximately the same eigenvalues), but is much less expensive to invert than Λ.
(Chap. 15.)
PSEUDOSPECTRAL: an algorithm which uses an interpolation grid to determine the co-
efﬁcients of a spectral series. Synonyms are ORTHOGONAL COLLOCATION &
METHOD OF SELECTED POINTS.
RESIDUAL FUNCTION: When an approximate solution uN is substituted into a differ-
ential, integral, or matrix equation, the result is the RESIDUAL function, usually de-
noted R(x; a0, a1, . . . , aN). The residual function would be identically zero if the
approximate solution were exact. (Chap. 1.)
RULE OF THREE NAMES: Every term in this glossary has at least two synonyms.
SEMI-IMPLICIT (TIME-MARCHING): a time-integration method that treats some terms
implicitly and others explicitly. Such algorithms are very common in hydrodynam-
ics where diffusion is treated implicitly but the nonlinear advection is explicit; this
avoids inverting large systems of nonlinear algebraic equations at each time step.
SEMI-LAGRANGIAN: A family of time-marching algorithms for ﬂuid mechanics which
use the method of characteristics to integrate the advection terms while employing
conventional strategies for the rest. Excellent shock resolution; now widely employed
in numerical weather forecasting. (Chap. 14.)
SEPARABLE: An adjective applied to a partial differential (PDE) equation which denotes
that the PDE can be split into a sequence of ordinary differential equations including
Sturm-Liouville eigenproblems. The procedure for reducing a PDE to ODEs is the
METHOD of SEPARATION of VARIABLES.
SKEW-SYMMETRIC: A matrix ⃗⃗A is SKEW-SYMMETRIC if and only if its tranpose is its
negative, that is, ⃗⃗A
T
= −⃗⃗A. All eigenvalues of a skew-symmetric matrix are pure
imaginary or zero. Similarly, an operator is skew-symmetric if its adjoint is its nega-
tive; it, too, has pure imaginary eigenvalues.

584
Glossary
SKYLINE SOLVER: An algorithm for the LU FACTORIZATION of a SPARSE matrix which
omits nonzero operations. It is a generalization of a BANDED matrix solver because
the “skyline” allows for different numbers of nonzero elements in different rows (Ap-
pendix B).
SPARSE MATRIX: A matrix whose elements are mostly zero. The opposite of a DENSE
or FULL MATRIX.
SPECTRAL: (i) A catch-all term for all methods (including pseudospectral techiques) which
expand the unknown as a series of global, inﬁnitely differentiable expansion func-
tions. (ii) In a narrower sense, it denotes those algorithms that use only the expansion
functions and their integrals and recurrence relations (as opposed to pseudospectral
methods, which need the values of the functions on a grid of interpolation points).
[Deﬁnition (ii) is not used in this book.]
SPECTRAL BLOCKING: The (spurious) accumulation of energy at or near the smallest
resolved scales. Common in nonlinear hydrodynamics; also arises when the CFL
limit is violated only for the shortest resolvable scales. The signature of spectral
blocking is that the log |an| rises instead of falls with n near n = N, the truncation
limit. The usual remedy is to add a little dissipation which is highly scale-selective,
damping only wavenumbers or coefﬁcients close to the truncation limit. (Chap. 11.)
SPECTRAL ELEMENT METHOD: A technique in which the computational domain is
subdivided into several subintervals or blocks and then separate spectral series are
employed on each interval. It differs from the SUBDOMAIN method only by em-
ploying a variational principle and integration-by-parts to more closely parallel ﬁnite
element algorithms.
SPECTRAL RINGING: Spurious, small scale oscillations which appear when a function
with a discontinuity or discontinuous slope is approximated by a truncated spectral
series; synonym for GIBBS’ OSCILLATIONS.
SPONGE LAYER: To absorb waves near the ends of a ﬁnite interval y ∈[−L, L] when
domain truncation is used to simulate an inﬁnite spatial interval, a large artiﬁcial
viscosity is often added in the neighborhood of y = ±L. The regions of large damping
are called “sponge layers” because they absorb the waves so that the center of the
domain is uncorrupted by spurious waves reﬂected from y = ±L.
STATIC CONDENSATION: A direct method for solving the matrix equations which re-
sult from ﬁnite element or spectral element discretizations. As a ﬁrst step, the degrees
of freedom internal to each element are eliminated in favor of the grid point values
on subdomain walls. This generates a dense matrix of much smaller size than the
original sparse matrix, which is then solved by standard LU factorization.
SUBDOMAIN SPECTRAL METHOD: Instead of solving the problem by using a single
series which is valid over the whole domain, the computational region is split into
several smaller regions or “subdomains”. A separate Chebyshev or Legendre expan-
sion is then deﬁned on each subdomain, and the expansions are matched together at
the subdomain boundaries. There are many variants of this strategy, depending upon
whether a variational principle is or is not used and also upon how the algorithm en-
forces continuity from one subdomain to the next. See also SPECTRAL ELEMENTS.
(Chap. 22.)

Glossary
585
SUBGEOMETRIC CONVERGENCE: There are three equivalent deﬁnitions. (i) The se-
ries converges exponentially fast with n, but too slowly for the coefﬁcients to be
bounded in magnitude by c exp(−pn) for any positive constants c and p. (ii) The
index of exponential convergence r < 1. [r = 1 is “geometric convergence”.]
(iii)
lim
n→∞log(|an|)/n = 0
Subgeometrically-converging series are the expansions of functions which are singu-
lar but inﬁnitely differentiable at some point (or points) on the expansion interval
(often at inﬁnity). In mathematical jargon, such weakly singular functions “are in
C∞, but not CΩ.”
SUPERGEOMETRIC CONVERGENCE: If the coefﬁcients can be bounded by
|an| ≤O{s exp[−(n/j) log n]}
for sufﬁciently large n and some constants s and j, then the convergence rate is “su-
pergeometric”. This is possible only when the function being expanded is an “entire”
function, that is, one which has no singularities anywhere in the complex plane ex-
cept at ∞.
SUPERIOR LIMIT: For a sequence {an}, the superior limit or supremum limit is writ-
ten lim sup{an} and denotes the lower bound of the almost upper bounds of the se-
quence. (A number is an almost upper bound for a sequence if only a ﬁnite number
of members of the sequence exceed the “almost upper bound” in value.) Strictly
speaking, deﬁnitions of convergence rates should be expressed in terms of superior
limits, rather than ordinary limits, to allow for oscillations and zeros in the sequence
as n →∞. A synonym is “supremum limit”.
SYMMETRIC: (i) [Of a matrix]: Aij = Aji. (Appendix B.) The longer but more precise
term “CENTROSYMMETRIC” is sometimes used as a synonym. (ii) [Of a function
f(x)]: f(x) = f(−x) for all x. (Chap. 8.)
TAU-METHOD: A mean weighted residual method for which the weighting functions are
the Chebyshev polynomials. Also called the LANCZOS TAU-METHOD. (Chapt. 21.)
TENSOR PRODUCT BASIS: A multi-dimensional basis whose elements are the products
of one-dimensional basis elements. In two dimensions,
Φmn(x, y) ≡φm(x) ψn(y)
TENSOR PRODUCT GRID: A multi-dimensional grid whose MN points are formed from
the corresponding one-dimensional grids:
xij ≡(xi, yj)
i = 1, . . . , M
&
j = 1, . . . , N
TRUNCATION ERROR: The error made by neglecting all coefﬁcients an in the spectral
series such that n > N for some “truncation” N.
WEAKLY NONLOCAL SOLITARY WAVE: A steadily-translating, ﬁnite amplitude wave
that decays to a small amplitude oscillation (rather to zero) as one moves away from
the core of the disturbance.

Index
adaptive coordinate transformations, see
coordinate transformations,adaptive
algebraic convergence
calculation of the index for ODE so-
lution, 43
examples
half-wave rectiﬁer function, 22
sawtooth function, 21
index of, deﬁned, 25
algebraic manipulation language, see sym-
bolic manipulation language and
spectral methods
aliasing
deﬁned, 204
equality on the grid (
G=), 205
two-h waves, 206
aliasing instability
dealiasing, 211–216
energy-conserving schemes and, 213–
216
history, 210
skew-symmetric advection and, 213
theory, 216–218
Two-Thirds Rule for Dealiasing, 211–
213, 220
arithmurgy, 577
Assumption of Equal Errors
deﬁned, 32
asymptotic rate of convergence
deﬁned, 27
asymptotic spectral coefﬁcients
Chebyshev polynomials, 50
Fourier, 45
Table: Rate vs. Singularity Type, 60
asymptotically diagonal, deﬁned, 307
band-limited functions, 343
basis functions, special, 446–450
basis functions,choice of, 9, 109
basis recombination, see boundary condi-
tions,basis recombination
Benjamin-Davis-Ono (BDO) Eq., 209
bifurcation point, 544
boundary conditions, 10
absorbing, 341
basis recombination, 64, 112–115
behavioral versus numerical, 75, 109–
111, 361
boundary-bordering, 111–112
coordinate transformation of bound-
ary conditions on derivatives, 575–
576
homogenization of boundary condi-
tions, 112–114
polar coordinates, at origin, 383
boundary layer, 57
Resolution Rule-of-Thumb, 59
symbolic manipulation example, 465
cardinal functions
general orthogonal polynomials, 104
polynomial, deﬁned, 83
pseudospectral Chebyshev ODE-solving,
115
Whittaker, see sinc function
Chebyshev polynomials
asymptotic coefﬁcients, calculation of,
49
cardinal functions, “roots” grid, 571
cardinal functions, Lobatto grid, 570
collected identities, 497–498
computation by recurrence, 323
computation of and its derivatives by
trigonometric formulas, 324, 553
convergence theory, 46
deﬁnition-by-mapping, 46
ellipse of convergence, 48
recurrence for coefﬁcients of deriva-
tive of Chebyshev series, 298
Chebyshev polynomials of the Second Kind
collected identities, 499
collocation, see pseudospectral
compatibility conditions, 41
condition number, 142
586

INDEX
587
continuation method, see nonlinear alge-
braic equations,continuation method
convergence domains in the complex plane
Theorem, 35
coordinate transformations
adaptive, 332–334
complex-plane detour, 151–153
for boundary conditions on deriva-
tives, 575–576
general one-dimensional theory, 325
Kosloff/Tal-Ezer nearly-equispaced Cheby-
shev method, 334–336
spatially periodic, 330
sphere-to-sphere maps, 409
Tables of derivative transformations,
550–552
transﬁnite interpolation, 114
two-dimensional derivative Table, 560
corner singularities, 37–41
one-dimensional mappings for, 327–
329
singular basis functions for, 446–448
two-dimensional mappings for, 329
Courant-Friedrichs-Lewy (CFL) Compu-
tational Instability
deﬁned, 173
eigenvalue analysis, 227
Rule-of-Thumb, 173
cylindrical coordinates, see polar coordi-
nates
Darboux’s Principle, 19
example, 33–34
theorem, 32
Davidenko equation, see nonlinear alge-
braic equations,Davidenko equa-
tion method
dealiasing, see aliasing instability,dealiasing
Deﬁnitions
algebraic index of convergence, 25
aliasing, 204
asymptotic rate of convergence, 27
band-limited functions, 343
bifurcation point, 544
continuation method, 537
Courant number, 275
Courant-Friedrichs-Lewy (CFL) Insta-
bility, 173
dense matrix, 516
discretization error, 31
domain truncation, 339
domain truncation error, 339
eigenvectors/eigenfunctions, 128
envelope of spectral coefﬁcients, 30
equiareal resolution, 408
exponential convergence, 25
exponential index of convergence, 26
Foot of a trajectory/departure point,
275
Four Kinds of Sturm-Liouville Eigen-
problems, 134
Frechet derivative, 528
geometric convergence, 26
idiot, 122
inﬁnite order convergence, 25
interpolation, 81
interpolation error, 31
limit point, 542
linear eigenvalue problem, 128
Method of Model Functions, 31
multiply upstream (semi-Lagrangian
scheme), 275
order of real axis decay, 350
parity, 159
patching, 480
periodicity, 20
sideband truncation, 444
sinc expansion of a function, 343
skyline of a matrix, 517
slow manifold, 232
slow manifold initialization, 239
sparse matrix, 516
spectral blocking, 207
spectral convergence, 25
splitting/fractional steps, 253
Spurious Eigenvalues, 139
subgeometric convergence, 26
supergeometric convergence, 26
tau-method, 473
triangular matrix, 515
truncation error, 31
two-h waves, 206
direct matrix-solving methods, 514–525
banded matrix, 518, 519
block and bordered matrices, 522
block-tridiagonal matrices, 521
for constant coefﬁcient ODEs, 313
for discretizations of separable PDEs,
314
matrix-of-a-matrix strategies, 520–524
Table of Costs: LU, LLT , QR, 514
discretization error

588
INDEX
deﬁned, 31
domain truncation, see unbounded inter-
val,domain truncation
ease of programming, 4
eigenvalue example
Associated Legendre equation, 135
Hermite (parabolic cylinder) eigen-
problem, 131
Laplace’s Tidal Equation, 74
eigenvalue problems, 74–75, 127–158
“spurious” eigenvalues, 139–142, 182
Bibliography Table, 157
common mistakes, 155–156
continuous spectrum, 135, 136
four kinds of Sturm-Liouville prob-
lems, deﬁned, 134
inverse power method, 149
local (one-mode-at-a-time) methods,
deﬁned, 129
local versus global methods, 149
power method, 145–148
quartic oscillator in Maple, 467
rejecting inaccurate eigenvalues, 137–
139
Rule-of-Thumb, 132
subharmonic bifurcation of FKdV cnoidal
wave, 468
Table of “No-Brain” method, 127
elliptical coordinates
spectral methods in, 439–440
envelope of spectral coefﬁcients, deﬁned,
30
exponential convergence
deﬁned, 25
index of, deﬁned, 25
rates of, deﬁned, 26
Fast Fourier Transform (FFT)
advantages of simultaneous compu-
tation of many transforms, 193
Bibliography Table, 189
perils and advantages of library soft-
ware, 200
Table of costs, 193
theory, 187–189
Fast Fourier Transform, generalized, see
transforms (grid/spectral & in-
verse),Generalized FFTs
Fast Multipole Methods (FMM) and pseu-
dospectral method, 195–198
Fast Multipole Methods (FMM) for asso-
ciated Legendre transforms, 407
ﬁlters/smoothers
aliasing remedy, 211–213
spherical harmonic series, 418–424
Two-Thirds Rule, 212
ﬁnite difference methods
comparison with spectral, 6, 55, 73
computational diffusion, 225
computational dispersion, 225
ﬁnite element method comparisons, 4, 5
Fourier Asymptotic Coefﬁcient Expansion
(FACE), 41
Fourier series
calculation of asymptotic coefﬁcients,
45
cardinal functions, 562–568
coefﬁcient integrals, 20
complex form, 20
convergence domain, 45
Truncation Error Bound Theorem, 50
fractional steps, see time-marching,splitting
Frechet derivative, 528
Galerkin method, 67–80
comparison with pseudospectral, 95
relationship with singular perturba-
tion theory, 471
sparse matrices for constant coefﬁcient
ODEs, 313
Gegenbauer polynomials
collected identities, 502–504
convergence theory, 54
in spherical harmonics, 399–402
geometric convergence
deﬁned, 26
examples
imbricated Lorentzian, 23
grid point representation, see also cardinal
functions
h/p-ﬁnite elements, see spectral elements
Hasegawa-Mima Eq., see quasi-geostrophic
Eq.
Hermite functions
as inﬁnite interval basis, 346–353
Bibliography Table, 347
collected identities, 505–506
Hille’s Width-of-Convergence Theo-
rem, 350
Rate-of-Convergence Theorem, 350

INDEX
589
high order derivatives, special problems
of, 142
Hilbert transforms, spectral algorithms for
computing, 453
inﬁnite interval, see unbounded domain
inﬂuence matrix method
spectral elements, 488–491
integrating factor
deﬁned, 265
misuse of, 267–269
integration, numerical, see quadrature
Integration-by-Parts Coefﬁcient Bound
application to differential equation,
43
theorem, 42
interpolation
cardinal functions for, 98–108
Cauchy Polynomial Interpolation Er-
ror Theorem, 85
Chebyshev, 95
spatial uniformity of accuracy, 101
coefﬁcients of interpolant via quadra-
ture, 92
divergence of (Runge Phenomenon),
83
halving grid and basis due to parity,
165
Lagrangian, 82–86
off-grid, 198–199, 283–286
transﬁnite, 114
trigonometric, see trigonometric inter-
polation
interpolation error
deﬁned, 31
Ioakimidis’ root-ﬁnding algorithm, 452
iteration
computing iterates by FFT, 298
for indeﬁnite matrices, 318–320
for nearly-separable PDEs, 317
for nonlinear equations, 320–322
inferior to direct methods for separa-
ble PDEs, 315
Minimum Residual Richardson’s (MRR),
304–306
Moral Principles, 322
multigrid, see multigrid
Nonlinear Richardson, 321
preconditioned Newton ﬂow, 321
preconditioning, see preconditioning
Richardson, deﬁned, 291
Richardson, optimum pseudotimestep
for, 292, 295
Stationary One-Step, deﬁned, 291
when not to iterate, 322
iterations
Delves-Freeman, 307–312
Korteweg-deVries (KdV) Eq.
cnoidal waves, computation of, 531–
532
Fourier pseudospectral time-marching
code, 179
integrating factors for, 268
slow manifold of, 234
Laguerre functions, 353–354
Bibliography Table, 353
collected identities, 508
Lanczos economization, 451
Least Squares Method, 62
Legendre polynomials
cardinal functions, Lobatto grid, 572–
574
collected identities, 500–501
convergence theory, 52–54
limit point, 542
matrix diagonalization for solving sepa-
rable PDEs, 316
Matrix Multiplication Transform (MMT),
91, 108, 190–194
cost versus FFT, 192
Mean Weight Residual (MWR) Method
deﬁned, 61
Mercator coordinate, deﬁned, 135
Model Functions, Method of, 54
deﬁned, 31
Moments, Method of, 62
multigrid, 301–304
Bibliography Table, 302
for spectral elements, 488
nonlinear algebraic equations
bifurcation point (for solution branch),
544
continuation method, 536–549
continuation method, deﬁned, 537
Davidenko equation method, 537
initializing strategies, 538–542
limit point (for solution branch), 542–
544
Newton iteration, 526–529

590
INDEX
pseudoarclength continuation, 546–
549
nonlinear boundary value problems
Newton-Kantorovich iteration, 527–
531
nonlinear eigenvalue problems
KdV cnoidal wave, 531
Newton-Kantorovich iteration, 531–
534
van der Pol Eq. limit cycle, 532
Nonlinear Galerkin algorithm
Bibliography Table, 244
deﬁned, 243
weaknesses, 245–248
nonlinearity, 13
orders of convergence
algebraic, deﬁned, 25
exponential, deﬁned, 25
graphical interpretation, 27–30
inﬁnite order, deﬁned, 25
spectral, deﬁned, 25
p-type ﬁnite elements, see spectral elements
Pad´e approximants, 260
parallel computation, 9
parity, see symmetry, parity
Parity Matrix Multiplication Transform (PMMT),
190–194
partial summation (multi-dimensional grid-
to-spectral transform), 184–187
periodicity
deﬁnition, 20
polar cap
deﬁned, 381
polar coordinates
annular (ring-shaped) domains, 390
apparent singularities at origin, 383
Bibliography Table, 382
Bibliography Table: annular domains,
391
Bibliography Table:Unbounded Do-
main or External to Cylinder, 390
boundary conditions in, 383
One-Sided Jacobi polynomial basis for,
387
parity in radius, 383–385
radial basis sets and grids, 385–390
spectral methods in, 381–390
unbounded domain, 390
preconditioning (of iteration)
as easy way to raise ﬁnite differences
to spectral accuracy, 301
by ﬁnite difference matrix, 293–297
by ﬁnite element matrices, 301
by incomplete LU factorizations of ﬁ-
nite difference matrix, 299
by small block-and-diagonal Galerkin
matrix, 307
for nonlinear problems, 321
pseudoarclength continuation, 546–549
pseudospectral method
boundary conditions, see boundary con-
ditions
checking by decrease of coefﬁcients,
123
checking by varying trunction N, 123
checking through ﬁnite difference resid-
ual, 121
choice of basis functions, 109
choice of interpolation grid, 116
common mistakes, 155
comparisons with ﬁnite differences,
see ﬁnite difference methods,comparison
with spectral
deﬁned, 62
derivatives, computing, 116
Fast Multipole Method (FMM), and,
196
halving grid and basis due to parity,
165
inferior to Galerkin for constant co-
efﬁcient ODEs, 313
slow manifold: Chebyshev differen-
tiation matrix, 236–238
special difﬁculties of high order deriva-
tives, 142
zero phase and amplitude errors in
Fourier basis, 224
quadrature,spectrally-accurate
Clenshaw-Curtis adaptive, 455
Gaussian (Gauss-Jacobi) Theorem, 87
mechanics of non-Gaussian, 456
non-Gaussian inﬁnite interval, 456, 458
of periodic integrands, 457
of singular integrands, 459
quasi-geostrophic Eq.
time-marching, 181
Quasi-Sinusoidal Rule-of-Thumb, 54
rational Chebyshev functions SB, 365

INDEX
591
rational Chebyshev functions TB, 356–361
Bibliography Table, 357
collected identities, 507
eigenvalue example, 131
expansions of functions that decay al-
gebraically at inﬁnity, 363–366
numerical examples, 366–368
Table of derivative-computing formu-
las, 555
Table of Explict Basis Functions, 358
rational Chebyshev functions TL, 327, 369–
370
collected identities, 509
numerical examples, 370–372
Table of derivative-computing formu-
las, 557
Table of Explict Basis Functions, 369
Regularized Long Wave (RLW) Eq.
time-marching, 181
Richardson extrapolation, 261
Richardson iteration, see iteration,Richardson,
deﬁned
Robert functions (spherical basis), 434
root-ﬁnding by Chebyshev algorithms, 450–
452
Rule-of-Thumb
Teller’s Law, 54
Assumption of Equal Errors, 32
Behavioral Boundary Conditions at
Inﬁnity, 362
Boundary Layer Resolution Require-
ment, 59
CFL Stability Limit: Physics, 173
Dealiasing/Energy-Conserving, 215
Eigenvalue, 132
Explicit-Demanding, 230
Implicit Scheme Forces Physics Slow-
down, 230
Last Coefﬁcient Error Estimate, 51
Optimizing Inﬁnite Interval Map Pa-
rameter, 377
Penalties of Unbounded Interval, 338
Quasi-Sinusoidal Resolution Require-
ment, 55
Two-Thirds Rule (for dealiasing), 212
Witch-of-Agnesi Resolution Estimate,
57
Runge Phenomenon, see interpolation,divergence
of
sawtooth function, 21
scattering of waves
special basis functions for, 448–450
semi-implicit, see time-marching,semi-implicit
semi-inﬁnite interval, see unbounded do-
main
semi-Lagrangian (SL) time-marching
accuracy improves with increasing time
step, 279
advantages and disadvantages, 271
Bibliography Table, 287
computational diffusion of, 281
iteration for departure points, 275
methods of characteristics and, 272
noninterpolating variants, 281
off-grid interpolation for, 283
three-level SI scheme, 273
two-level SI scheme, 280
separable PDEs
Haidvogel-Zang direct method, 314
Shamrock Principle, 178
sideband truncation, 443–446
sinc function
as inﬁnite interval basis, 341–346
Bibliography Table, 345
connection with trigonometric inter-
polation, 102
deﬁned, 99
derivative formulas, 569
expansions in, 343–344
singular basis functions, 330
skew-symmetric advection, 213
slow manifold
deﬁned, 232
forced linear oscillator, 233
initialization onto, 239–243
Korteweg-deVries equation, 234
Lorenz-Krishnamurthy Quintet, 233
multiple scale perturbation theory and,
241
numerically-induced, 236
steady-state (trivial slow manifold),
233
three-part strategy, 249
tracking with implicit scheme, 248
weather forecasting, 231–232
spectral blocking
deﬁned, 207
delayed blow-up, 210
frontogenesis and, 217
linear example, 209
remedies for, 218

592
INDEX
spectral coefﬁcients
integral for, 305
spectral coefﬁcients, computation by ma-
trix multiplication, see Matrix Mul-
tiplication Transform(MMT)
spectral convergence
deﬁned, 25
spectral elements
Bibliography Table:Surface of Sphere,
438
cardinal basis (only) gives diagonal
mass matrix, 485
choice of basis, 486
choice of grid, 486
deﬁned, 479
degree of inter-element continuity, 485
inﬂuence matrix method, 488–491
matrix inversion, 487
patching versus variational formal-
ism, 486
sectorial elements, 492
spherical coordinates, 437
two-dimensional maps, 491
variational formalism, 484–485
weak element-to-element coupling, 481–
484
spherical coordinates
“pole problem” (severe CFL limit), 398
Bibliography Table: Gridpoint Meth-
ods, 432
Bibliography Table: Legendre trans-
forms, 408
Bibliography Table: spectral elements,
438
Bibliography Table: variable resolu-
tion, 410
Glatzmaier stellar/mantle convection
model, 430
mapping of sphere into a sphere, 409
non-tensor and icosahedral grids, 432
parity factor, 393–397
parity-modiﬁed Fourier series in lat-
itude, 434
radial coordinate basis & grid, 429
resolution and unresolved scales, 425–
427
Robert basis functions, 434
slow Legendre transforms in latitude,
402–407
spectral elements, 437
spherical harmonics, see spherical har-
monics
variable resolution (limited-area) mod-
els, 409
vector basis functions, 428
spherical harmonics
Addition Theorem/Group Property,
408
alternatives to spherical harmonics,
433
asymptotic approximations near equa-
tor, 412
asymptotic approximations near poles,
411
Bibliography Table: Alternatives to
Spherical Harmonics, 435
Bibliography Table: comparisons with
ﬁnite differences, 438
Bibliography Table: Reviews & Model
Descriptions, 441
comparisons with ﬁnite differences,
438
deﬁned, 399
equiareal resolution property, 409
PMMT in latitude, 404
reduced grid (near-pole deletions), 405
shallow water wave algorithm, 416
software and libraries, 414
triangular truncation table, 401
triangular truncation, deﬁned, 400
triangular versus rectangular trunca-
tion, 388
spherical projective ﬁlter
Bibliography Table: Projective Filters,
437
splitting, see time-marching,splitting
sponge layer, 341
subgeometric convergence
deﬁned, 26
examples
Fourier series, 23
supergeometric convergence
deﬁned, 26
symbolic manipulation language and spec-
tral methods, 95, 114, 461–472
symbolic manipulation language example,
2
symbolic manipulation language: Table
of Precepts, 463
symmetry
halving grid and basis due to parity,

INDEX
593
165
multi-dimensional, 166
parity, 159–165
rotation and dihedral groups, 165
tau-method
Bibliography Table, 477
canonical polynomials, 478
deﬁned, 473
for approximating a rational function,
474
linear differential equation, 476
Taylor-Green vortex, 166
Theorems
Asymptotic Equality of Coefﬁcients
if Singularities Match, 32
Cauchy Interpolation Error, 85
Chebyshev Asymptotic Rate of Con-
vergence, 49
Chebyshev Ellipse-of-Convergence, 48
Chebyshev Interpolation and its Er-
ror Bound, 95
Chebyshev Minimal Amplitude, 85
Chebyshev Truncation, 47
Convergence Domain in Complex Plane,
35
Darboux’s Principle:Singularities Con-
trol Convergence, 32
Differentiation and Parity, 162
Elliptical Coordinates: Parity in Quasi-
Radial Coordinate, 440
Fourier Interpolation Error, 94
Fourier Truncation Error Bound, 50
Gaussian Quadrature (Gauss-Jacobi
Integration), 87
Hermite Rate-of-Convergence, 350
Hille’s Hermite Width-of-Convergence,
350
Inner Product for Spectral Coefﬁcients,
66
Integration-by-Parts Coefﬁcient Bound,
42
Interpolation by Quadrature, 92
Legendre Rate of Convergence, 52
LU Decomposition of a Banded Ma-
trix, 518
Matrices Whose Elements Are Matri-
ces, 520
Matrices Whose Elements Depend on
a Parameter, 466
Mean-Square Minimization with a Trun-
cated Series, 305
Orthogonality under the Discrete In-
ner Product, 90
Parity Decomposition, 163
Parity Matrix Multiplication Transform
(PMMT), 190
Parity of Basis Functions, 160
Parity of the Powers of x, 161
Polar Coordinates: Parity in Radius,
383
Power Series with Deﬁnite Parity, 161
Shannon-Whittaker Sampling Theo-
rem, 343
Singularities of the Solution to a Lin-
ear ODE, 36
Strip of Convergence, Fourier Series,
45
Symmetry Properties of an ODE, 164
Trapezoidal Rule Error for Periodic
Integrands, 457
Trigonometric Interpolation, 93
Three-Halves Rule, see Two-Thirds Rule
time-dependent problems, 15, 16
time-marching
(Adams-Moulton 2d order) implicit
scheme, see time-marching,Crank-
Nicholson
A-stable property, 229
Adams-Bashforth scheme, 3rd order
(AB3), 173
Adams-Bashforth, 2d order (AB2), 174
Adams-Bashforth/Crank-Nicholson (AB3CN)
semi-implicit scheme, 229
Adams-Moulton 1st order implicit scheme,
see time-marching,Backwards Eu-
ler
adaptive Runge-Kutta (RK45), 174
Alternating-Direction Implicit (ADI),
261
Backward Differentiation (BDF) im-
plicit schemes, 228
Backwards Euler (BE) implicit scheme,
228
Bibliography Table: Fourier basis, multi-
dimensional, 181
Bibliography Table: Fourier basis, one-
dimensional, 180
consistency of schemes, 258
Crank-Nicholson (CN) implicit scheme,
228

594
INDEX
Crank-Nicholson, fourth order, 260
Explicit-Demanding Rule-of-Thumb,
231
hybrid grid point/Galerkin algorithm,
176
Implicit Scheme Forces Physics Slow-
down Rule-of-Thumb, 230
implicit schemes, 228–229
implicitly-implicit problems, 181
KdV Eq. example (Fourier basis), 179
leapfrog, 174
operator theory of, 259
Runge-Kutta, 4th order (RK4), 173
semi-implicit, deﬁned, 229
semi-Lagrangian (SL), see semi-Lagrangian
splitting for diffusion, 255–256
splitting for ﬂuid mechanics, 263
splitting, basic theory, 252–254
splitting, boundary difﬁculties, 256
splitting, high order for noncommut-
ing operators, 262
trapezoidal implicit scheme, see time-
marching,Crank-Nicholson
toroidal coordinates
basis functions for, 392
deﬁned, 381
illustrated, 391
transﬁnite interpolation, 114
transforms (grid/spectral & inverse)
Fast Fourier Transform (FFT), see Fast
Fourier Transform
Generalized FFTs, 195–198
Bibliography Table, 196
Matrix Multiplication Transform (MMT),
see Matrix Multiplication Trans-
form, 190
partial summation, 184–187
to points off the grid, 198–199
triangular truncation, see spherical harmon-
ics,triangular truncation
trigonometric interpolation, 93
cardinal functions, 101–104
inﬁnite series for interpolant coefﬁ-
cients, 93
solving differential equations (BVP),
103
truncation error
deﬁned, 31
two-h waves, 206
Two-Thirds Rule, see aliasing instability,Two-
Thirds Rule for Dealiasing
preconditioning odd derivatives, 296
unbounded domain
behavioral versus numerical bound-
ary conditions, 361–363
comparison of logarithmic, algebra and
exponential maps, 355
domain truncation, 326, 339–340
functions that decay algebraically at
inﬁnity, 363–366
functions with non-decaying oscilla-
tions, 372–374
Hermite basis (y ∈[−∞, ∞]), 346–
353
need to pick scaling or map parame-
ter, 338, 348, 369, 378
rational Chebyshev TBn(y ∈[−∞, ∞]),
356–361
rational Chebyshev TLn (y ∈[0, ∞]),
369
sinc basis (y ∈[−∞, ∞]), 341–346
Weideman-Cloot map(y ∈[−∞, ∞]),
374–377
Van der Pol equation, 532–534
weak form of a differential equation, 68
weakly nonlocal solitary waves
special basis functions for, 450
weather forecasting, numerical
Lorenz-Krishnamurthy Quintet, 233
multiple scales perturbation & itera-
tion, 243
slow manifold, 231–232

