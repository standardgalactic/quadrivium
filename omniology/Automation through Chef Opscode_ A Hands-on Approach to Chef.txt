www.allitebooks.com

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
For your convenience Apress has placed some of the front 
matter material after the index. Please use the Bookmarks 
and Contents at a Glance links to access them. 
 
 
 
 
 
www.allitebooks.com

v
Contents at a Glance
About the Authors ............................................................................ xv
About the Technical Reviewers ...................................................... xvii
Acknowledgments .......................................................................... xix
Introduction .................................................................................... xxi
Chapter 1: Introduction
 
■
 .................................................................. 1
Chapter 2: The Chef Server
 
■
 ........................................................... 21
Chapter 3: Installation
 
■
 .................................................................. 27
Chapter 4: Workstation
 
■
 ................................................................. 43
Chapter 5: Nodes
 
■
 .......................................................................... 49
Chapter 6: Working with Knife
 
■
 ..................................................... 61
Chapter 7: Cookbooks
 
■
 .................................................................. 87
Chapter 8: Using Cookbooks
 
■
 ....................................................... 119
Chapter 9: Developing a Cookbook
 
■
 ............................................. 153
Chapter 10: Lightweight Resource Providers
 
■
 ............................. 169
Chapter 11: High Availability
 
■
 ...................................................... 179
Chapter 12: Cloud Provisioning Using Chef
 
■
 ................................ 193
Chapter 13: Troubleshooting and Debugging
 
■
 ............................. 219
Index .............................................................................................. 233
www.allitebooks.com

xxi
Introduction
Automation through Opscode Chef provides an in-depth understanding of chef, which 
is written in Ruby and Erlang for coniguration management, cloud infrastructure 
management, system administration, and network management. 
Targeted at administrators, consultants, and architects, the book guides them 
through the advanced features of the tool that are necessary for infrastructure 
automation, DevOps automation, and reporting. he book presumes knowledge of Ruby 
and Erlang, which are used as reference languages for creating recipes and cookbooks 
and as a refresher to help the reader get on speed with the low of book. 
he book provides step-by-step instructions on the installation and coniguration of 
chef, usage scenarios of chef, in infrastructure automation with common scenarios such 
as virtual machine provisioning, OS coniguration for Windows, Linux, and Unix, and 
provisioning and coniguration of web servers like Apache along with popular databases 
like MySQL. 
It further elaborates on the creation of recipes and cookbooks, which help in the 
deployment of servers and applications to any physical, virtual, or cloud location,  
no matter the size of the infrastructure. 
he book covers advanced features like LWRPs (lightweight resource providers) and 
knife and also contains several illustrative sample cookbooks on MySQL, Apache, and 
CouchDB deployment using a step-by-step approach.
www.allitebooks.com

1
CHAPTER 1
Introduction
In this chapter we briefly discuss the concept of infrastructure as code and DevOps. 
We also touch upon Chef and Ruby and cover some of the use cases of Opscode Chef 
and how it is being leveraged to solve technical problems faced by IT (information 
technology) departments.
Infrastructure as Code
The advent of public cloud computing has revolutionized the software development 
world. Small companies with a good idea can leverage the pay-per-use model provided 
by the public cloud computing companies and setup their infrastructure quickly and 
without any upfront costs.
For the traditional IT enterprises, the public cloud brings in cost advantages, 
flexibility, and the agility to setup their infrastructure environments very quickly  
without waiting for the ordering, procurement, and setup cycles involved in traditional 
datacenter setup.
Most of the public cloud providers deliverAPIs (application programming 
interfaces), which expose the features and functionality of the underlying cloud. Thus  
the infrastructure that typically used to be a setup and configuration activity in traditional 
datacenters has now become programmable through APIs.
The infrastructure components like Network, Firewalls, Compute, and Storage are 
exposed to programmers through APIs and can be consumed through command lines, 
REST APIcalls, and so on.
The large-scale infrastructure used by cloud providers and Internet scale companies 
like Google, Facebook, and Twitter needs a very different approach to setup, monitoring, 
and management from a typical enterprise with a few thousand servers.
Some of the provisioning and deployment models applicable for large-scale Internet 
infrastructure are very different from the typical enterprise use cases. The number of 
applications and servers are more homogeneous in an online business than the number 
of applications and diversity of infrastructure found in an enterprise.
Although AWS (Amazon Web Services) does not share details on its capacity or  
the addition of capacity, it states that it is adding capacity equivalent to what Amazon.com 
had in 2005 daily. This kind of massive capacity buildup and management of millions of 
virtual machines leveraging technologies, processes, and tools built for a smaller scale are 
not possible.
www.allitebooks.com

CHAPTER 1 ■ INTRODUCTION
2
The public cloud is built on principles of scaled-out architecture. Thus, rather than 
adding computer resources to a virtual machine, applications quickly spin new machines 
when the demand increases and gracefully shut down machines when the demand 
decreases. This has become essential since cloud providers charge the customer on the 
basis of metered usage of services. Thus, if you are using a virtual machine in a cloud 
environment for a few hours, you will only be billed for the hours of usage.
The cloud providers provide integrations and APIs for making the up scaling and 
downscaling of resources simple and easy to do. Customers benefit by having capacity 
when needed and getting billed for what they use.
Today, a range of new technologies has emerged which makes the task of managing 
large-scale infrastructure and application landscape much easier.
Infrastructure as a code emerged in the last few years because of advancement in 
two technologies and the rise of consumer IT companies. Cloud computing and new web 
frameworks made it simpler and easier to develop out scale applications and created 
technologies that enabled infrastructure as a code.
The cloud and the new web frameworks have essentially democratized innovation 
and IT. No longer do you need expensive equipment and a datacenter setup to start your 
innovative company. The cloud provides seemingly limitless capacity to fulfill the needs 
of developers and startup with zero capital expenditure. You can be up and running on 
a prototype using your credit card. Thus smaller companies now can compete with their 
larger competitors, and the advantage that large organizations have by virtue of capital 
and infrastructure no longer remains a differentiator.
The idea of the cloud and the newer web development languages and frameworks 
was all about simplicity. The cloud made it simple for organizations to setup 
infrastructure, and the new web frameworks and languages like Ruby on Rails made it 
simpler, easier, and faster to develop applications.
Startup companies also have to operate within tight budgets; they do not have the 
luxury of spending money on operations and operations teams. Thus, the developers had 
to find a way to make operations as automated as possible, and the convergence of all  
the new technologies, along with the needs of developer communities and large-scale  
Internet companies, resulted in the fructification of the concepts of DevOps and 
infrastructure as code.
A lot of changes have led to this new breed of configuration management tools that 
help in automating your infrastructure. These tools help you in maintaining a blueprint of 
your infrastructure by breaking it down into components that interact with each other so 
that you can deploy it whenever you want.
It is important to understand that “infrastructure” does not mean infrastructure in 
the traditional IT definition, which is network devices, servers, firewalls, and so on. By 
infrastructure, we mean a collection of components that are used to deliver a service to 
the end user. The components can be virtual machines, network settings, configuration 
files, software packages, applications, processes, users, and so on.
Jesse Robins describes the goal of infrastructure as code:
“Enable the reconstruction of the business from nothing but a source code 
repository, an application data backup, and bare metal resources.”
www.allitebooks.com

CHAPTER 1 ■ INTRODUCTION
3
Thus, infrastructure as code tools like chef came into picture. Chef enables 
developers to assemble and consume infrastructure components similarly to the way 
software components are designed, assembled, and consumed.
Figure 1-1 shows the different types of components of infrastructure.
File 1
File 2
User
Package
Service
Figure 1-1. Infrastructure components 
Infrastructure components are abstracted similarly to the way abstract classes and 
interfaces work in a software module.
Chef and other automation tools allow you to define objects and methods for an 
object; as an example, you may add and remove methods for installing packages.
The beauty of this approach is that the administrators of the end systems do not have 
to worry about the implementation details of how each component is deployed by the 
system and can focus on the exact task to be achieved.
Infrastructure is created as a blueprint in a software system which is executed by 
a provider on the end device. The provider provides the execution code based on the 
capabilities of the end device. Thus, the abstraction of the provider brings simplicity, and 
the developers can reuse the providers as per the needs of the application. The provider 
model encapsulates the execution aspects of the end system, and thus it greatly simplifies 
the work of the administrator.
Once the blueprint has been created, the same model can be applied multiple times 
to multiple similar endpoints.
The automation aspects of these tools also allows the endpoints to be audited 
to a specific baseline, and if the end points state is different than what it should be, 
systems like chef can automatically bring the end point back to the expected state of 
configuration.
The blueprint can be used to create various environments easily and quickly, and 
you can easily provision development, test, QA, and production environments using chef.
Without infrastructure as code and tools like chef, it would take days of effort from 
multiple teams to create these environments.
www.allitebooks.com

CHAPTER 1 ■ INTRODUCTION
4
The additional benefit of this approach is that the complete environment becomes 
documented and modeled in a tool. Thus, using chef as a tool helps organizations to 
have a scalable and agile approach to configuration management and the deployment 
of infrastructure components. Automation using configuration automation tools like 
chef would save precious man-hours, which can be utilized for service improvement and 
the creation of new services. This also leads to significant cost savings as well as higher 
quality of service because of fewer human errors.
Overview
Chef is a framework that makes it easy to manage your infrastructure. Chef was initially 
written in Ruby, but the latest version is a mixture of Erlang and Ruby. A single chef server 
can handle upto 10,000 nodes.
With chef, we can
Manage both our physical and cloud servers.
•฀
Create perfect clones of our environments.
•฀
Easily configure applications that require knowledge about your 
•฀
infrastructure via ‘Search.’
Once we have automated our infrastructure with chef, we can replicate the whole 
infrastructure very easily. Chef can be mainly broken down into three components.
Server: The chef server holds the configuration data for each and 
•฀
every node registered with it.
Workstation: A workstation basically holds the local chef 
•฀
repository.
A node is a client that is registered with the chef server. It has an 
•฀
agent known as chef client installed on it.
Cookbooks, covered in Chapter 7 also are a very important part of chef. Cookbooks 
are the basic building blocks of chef. They hold the type of configuration that needs to be 
done on a node. Each cookbook defines a complete scenario, like package installation 
and configuration.
Nodes
A node can be termed a “virtual” or a “physical” server that is managed by chef. A node 
can also be on the cloud. A node needs to have an agent, known as chef client, installed 
on it. The agent is used to interact with the chef server. Ohai is a built-in tool that comes 
with chef and is used to provide node attributes to the chef client so that a node can be 
configured. There are basically two types of nodes that chef can manage.
www.allitebooks.com

CHAPTER 1 ■ INTRODUCTION
5
1. 
Cloud-based: It is basically a node that is hosted on any of 
the cloud providers (e.g., Amazon or Windows Azure). There 
is a chef CLI (command line interface) known as knife which 
can be used to create instances on the cloud. Once deployed, 
these nodes can be managed with the help of chef.
2. 
Physical: It can be hardware or a virtual machine that exists in 
our own environment.
There are mainly two important components of a node.
1. 
Chef client: An agent that runs on each node. The agent 
contacts the chef server and pulls the configuration that needs 
to be done on the node. Its main functions include
a. 
Registering the node with the chef server.
b. 
Downloading the required cookbook in the local cache.
c. 
Compiling the required recipes.
d. 
Configuring the node and bringing it to the expected state.
2. 
Ohai: Chef client requires some information about the node 
whenever it runs. Ohai is a built-in tool that comes with chef 
and is used to detect certain attributes of that particular node 
and then provide them to the chef client whenever required. 
Ohai can also be used as a stand-alone component for 
discovery purposes. Ohai can provide a variety of details from 
networking to platform information.
Workstation
A workstation is a system that is used to manage chef. There can be multiple workstations 
for a single chef server. A workstation has the following functionalities:
Developing cookbooks and recipes.
•฀
Managing nodes.
•฀
Synchronizing the chef repository.
•฀
Uploading cookbook and other items to the chef server.
•฀
There are mainly two important components of a workstation.
1. 
Knife: A command line tool used to interact with the chef 
server. The complete management of the chef server is done 
using knife. Some of the functions of knife include
www.allitebooks.com

CHAPTER 1 ■ INTRODUCTION
6
a. 
Managing nodes
b. 
Uploading cook books and recipes
c. 
Managing roles and environments
2. 
Local chef repository: Chef repository is a repository where 
everything related to the chef server/nodes is stored.
Server
There is a centrally located server which holds all the data related to the chef server; 
this data includes everything related to the server (i.e., cookbooks, the node object, and 
metadata for each and every node registered to the chef server). 
The agent (chef client) runs on each and every node, and it gets the configuration  
data from the server and then applies the configuration to a particular node. This approach 
is quite helpful in distributing the effort throughout the organization rather than on a 
single server.
There are three different types of chef server.
Enterprise chef
•฀
Open source chef
•฀
Chef solo
•฀
Enterprise Chef
Enterprise chef is the paid version of the chef server which comes with two types of 
installations: one is on-premise installation (i.e., in your datacenter behind your own 
firewall) and the other is the hosted version in which chef is offered as a service hosted 
and managed by Opscode.
The major difference between the enterprise version and the open source version 
is that the enterprise version comes with high-availability deployment support and has 
additional features on reporting and security.
Open Source Chef
The open source chef has most of the capabilities of the enterprise version. However, this 
version of chef server also has certain limitations. The open source version of chef can 
be installed only in stand-alone mode (i.e., it is not available in the hosted model). The 
open source chef components need to be installed on a single server, and it doesn’t offer 
the levels of security available in the enterprise version. It also doesn’t provide reporting 
capabilities like the enterprise version.
www.allitebooks.com

CHAPTER 1 ■ INTRODUCTION
7
ChefSolo
Chefsolo comes with the chef client package and is used to manage a node without any 
access to the server. It runs locally on any node, and it requires the cookbook or any of its 
dependencies to be present on the node itself. This is generally used for testing purposes.
Cookbooks
A cookbook is a basic unit of configuration and policy definition in chef. A cookbook 
essentially defines a complete scenario. As an example, a cookbook for Apache or Tomcat 
would provide all details to install and configure a fully configured Apache or Tomcat server.
A cookbook contains all the components that are required to support the installation 
and configuration of an application or component, including
Files that need to be distributed for that component.
•฀
Attribute values that should be present on the nodes.
•฀
Definitions so that we need not write the same code again and again.
•฀
Libraries which can be used to extend the functionality of chef.
•฀
Recipes that specify the resources and the order of execution of code.
•฀
Templates for file configurations.
•฀
Metadata which can be used specify any kind of dependency, 
•฀
version constraints, and so on.
Chef mainly uses Ruby as its reference language for writing cookbooks and recipes. 
For writing specific resources, we used extended DSL (Domain Specific Language).
Chef provides an extensive library of resources which are required to support various 
infrastructure automation scenarios. The DSL provided by chef can also be extended to 
support additional capabilities or requirements.
Figure 1-2 shows the basic chef components and how they are used in automation.

CHAPTER 1 ■ INTRODUCTION
8
Figure 1-3 shows the chef components in detail.
Figure 1-2. Basic structure of chef

CHAPTER 1 ■ INTRODUCTION
9
The Value of Chef
With chef, you can automate your whole infrastructure and rebuild the whole 
environment very easily. Chef can automate every task that we perform manually in 
our datacenter in our daily routine and can save lots of time. Figure 1-4 shows a typical 
environment. We can delete and launch any instance at a point in time, and we do this 
manually, but with chef we can automate the whole process.
Figure 1-3. Chef components in detail

CHAPTER 1 ■ INTRODUCTION
10
Why Chef?
As explained previously, chef gives your infrastructure the flexibility, speed, and 
efficiency you have always wanted. Automation through chef can provide the speed and 
agility needed by business today to compete. Chef can be used to quickly provide IT 
solutions and repeatable configurations with minimal human intervention.
Automating your infrastructure with chef could help you to deploy features in 
minutes rather than days. Chef can manage any number of servers without much 
complexity, and thus it helps you in managing your infrastructure easily, at less cost,  
and while avoiding human errors.
Chef helps your enterprise in moving to public clouds and complements the public 
cloud model by providing integrations with major public cloud providers.
Core Principles of Chef
Chef is a highly configurable and extensible tool with immense power in the hands of 
administrators to automate their infrastructure. It provides flexibility, agility, and speed to 
administrators, and they can leverage the tool the way they best deem fit in their scenarios.
The main principles on which chef works are
Idempotence
•฀
Thick client, thin server
•฀
Order of execution
•฀
Memcache
Mysql slave
Mysql master
Web Sphere
app
Zabbix
1
2
3
4
5
6
8
9
10
11
12
7
Figure 1-4. A fully automated infrastructure

CHAPTER 1 ■ INTRODUCTION
11
Idempotence
Idempotence means that a chef recipe can run multiple times on the same system and 
the return will be identical. Chef ensures that the configuration changes to the end system 
(node) are done when the underlying configuration differs from the desired state and no 
changes are made to the system if they are not needed.
Thus, administrators can define the end configurations, and chef will ensure that the 
nodes have the desired configuration on them.
Thick Client, Thick Server
Chef uses an agent known as chef client to interact with the chef server. 
The chef agent does the heavy lifting; it downloads the required files from the chef 
server onto a local cache. The chef client is responsible for compiling the client-side code, 
and then the code is executed by the agent on the node.
The thick client approach of chef makes it highly scalable, since the heavy lifting is 
done by the agent on each node and not on the server. This makes chef an ideal candidate 
for large-scale Internet application deployment and management.
Order of Execution
The compilation of recipes on the node is done in the exact order that is specified. The 
code execution of the agent is also done in the order that it is specified.
Thus, it is important to ensure that the correct order of execution is followed in the 
creation of recipes, so that the desired results are correct.
This approach makes sure that a prerequisite is met first so it becomes easier to 
manage.
Who Uses Chef?
Chef is being used very widely. One of chef’s biggest customers is Facebook. Many 
Internet companies and enterprises use chef today to automate their infrastructure 
environments.
Key Technologies
In this section, we discuss some of the technologies that are used in chef—mainly,  
Ruby and Erlang.
Ruby
Ruby is a simple object-oriented programming language which has been developed 
and designed in such a way that it is easy to read and understand, and it behaves in a 
predictable fashion. Ruby was developed and designed by Yukihiro “Matz” Matsumoto of 
Japan in 1995 and is influenced by scripting languages like Python, Perl, Smalltalk, Eiffel, 

CHAPTER 1 ■ INTRODUCTION
12
Ada, and Lisp. Ruby borrows heavily from Perl, and the class library is an object-oriented 
reorganization of Perl’s functionality. Ruby was launched for the general public in 1995, 
and since then it has drawn devoted coders worldwide. Ruby became famous in 2006 and 
has been widely used since then. 
Chef mainly uses Ruby as its reference language for writing cookbooks and recipes, 
with an extended DSL. Here we discuss some of the basic concepts of Ruby that might be 
needed while using chef.
Variables
Variables are used to store any kind of value, which can be a string or an integer, which is 
then used reference purposes. We need to declare a variable and then assign a value to 
that variable, which can be done with the help of assignment operator (=). For example, if 
we need to assign a numeric value to a variable, X, we would do the following:
 
X=20
 
This would create a variable, X, and would assign a value of 20 to it.
Figure 1-5 shows assigning values to four different variables. It would create four 
variables (a, b, c, and d) with values of 10,20,30, and 40, respectively.
Figure 1-6. Assigning values to variables using parallel assignment
Figure 1-5. Assigning values to variables
Ruby also supports parallel assignment of variables. The same result can be achieved 
more quickly, using parallel assignment.
Figure 1-6 shows this operation.

CHAPTER 1 ■ INTRODUCTION
13
Working with Strings
Ruby uses the string object to store strings. The string object can also be used to call a number 
of methods. These methods can be used to manipulate a string in many ways. To create a new 
empty string, we use the new method of the string object as shown in Figure 1-7.
Figure 1-7. Creating an empty string
Figure 1-8. Creating a string with some value
Figure 1-9. Creating a string with some value (kernel method)
If we want to create a new string with some value, we can pass an argument in the 
new method as shown in Figure 1-8.
There is another way to create a string which uses the string method provided by 
kernel, as shown in Figure 1-9.
The best thing about Ruby is that it takes care of many things. We can create a string 
by simply declaring it as shown in Figure 1-10.
Figure 1-10. Initializing a string with some value (direct declaration)
We can use both single quotes (‘) and double quotes (“) to delimit stings in Ruby. 
However, there is a difference in both. Double quotes are used when we want to interpret 
escaped characters like tabs or newlines while single quotes are used when we need to 
print the actual sequence.
Figure 1-11 depicts the difference between the two.

CHAPTER 1 ■ INTRODUCTION
14
Ruby can be easily embedded in a string. Figure 1-12 illustrates this process.
Figure 1-11. Working with single and double quotes
Figure 1-12. Accessing a variable
Figure 1-13. Initializing an empty array
We need to use double quotes if we want to embed Ruby in a string. Single quotes 
won’t work in this case.
Arrays
Like a string, a Ruby array is also an object which can contain a single item or more. 
These items can be a string, an integer, or a fixnum. We can create an array in Ruby using 
a number of mechanisms. We can create an uninitialized array in Ruby using the new 
method of array class shown in Figure 1-13.
Figure 1-13 creates an array named days_of_month with nothing in it.
We can also create an array with a fixed number of elements in it by passing the size 
as an argument (see Figure 1-14).
Figure 1-14. Initializing an array with five elements

CHAPTER 1 ■ INTRODUCTION
15
Figure 1-14 will create an array of five elements with no value in it. If we need to add 
some data to the array, many options are available (see Figure 1-15). One of them would 
be to place the same data in each element during the array creation process
Figure 1-16. Populating different value in each element of an array
Figure 1-15. Initializing an array with some value
We can also create an array by using the [] method of the array class and specifying 
the elements one after one as shown in Figure 1-16.
We can access any element of a Ruby array by referencing the index of the element. 
For example, see Figure 1-17 if you want to access the second element of the array created 
in Figure 1-16.
Figure 1-17. Accessing an object in an array
Operators
Ruby has a number of classified operators.
Assignment operators
•฀
Math operators
•฀
Comparison operators
•฀
Bitwise operators
•฀
In Ruby, as in other languages, a number of arithmetic operators can be used to 
perform a number of functions. Table 1-1 provides a list of these operators.

CHAPTER 1 ■ INTRODUCTION
16
Figure 1-18 shows the use of the division operator; if we don’t want the result to be 
truncated then we need to express at least one of the operands as a float.
Table 1-1. Arthimetic Operators
Operator
Function
+
Used to add the variables on both sides of the operator.
-
Used to subtract the right side operand from the left side operand.
*
Used to multiply the values on both sides of the operator.
/
Used to divide the left hand operand by right hand operand.
%
Used to divide the left hand operand by right hand operand and return  
the remainder.
**
Used to perform exponential calculation on operators.
Figure 1-18. Working with operators
If we need to compare two variables then we need to use comparison operators. 
Table 1-2 shows a list of comparison operators available in Ruby.
Table 1-2. Comparison Operators
Operator
Function
==
It is used to check equality. The output would be a true or a false.
.eql?
It has the same functionality as == operator.
!=
It is used to check for inequality. The output would be false in case equality 
and true in case of equality.
<
Used to compare two operands. The output will be true if the first operand 
is less than the second one and false otherwise.
>
Used to compare two operands. The output will be true if the first operand 
is greater than the second one and false otherwise.
>=
Used to compare two operands. The output will be true if the first operand 
is greater than or equal to the second one and false otherwise.
<=
Used to compare two operands. The output will be true if the first operand 
is less than or equal to the second one and false otherwise.
www.allitebooks.com

CHAPTER 1 ■ INTRODUCTION
17
Figure 1-19 shows the use of comparison operators.
Figure 1-19. Working with operators
Ruby bitwise operators allow operations to be performed on numbers at the bit level.
Methods
Methods in Ruby are used to organize your code in a proper way. Ruby also promotes the 
reuse of code so that we do not write the same code again and again.
Ruby helps in organizing your code into groups to call said code whenever required.
The following piece of code shows a typical method:
 
def name( arg1, arg2, arg3, ... )
   .. ruby code ..
   return value
end
Erlang
Overview
Erlang is a general-purpose concurrent programing language that is mainly used to build 
highly available and scalable real-time systems. Erlang is being widely used in many 
industries like telecom, e-commerce, and so on. It has a system that provides built-in 
support for concurrency, fault tolerance, and distribution.
Along with being a programming language, Erlang also focuses on high reliability 
and concurrency. Erlang can perform dozens of task at a time. It uses an actor model 
to achieve it (i.e., each actor is treated as a separate process in a virtual machine). For 
example, consider yourself to be an actor in Erlang’s world: you would be a person sitting 
alone in a dark room waiting for a message, and as soon as you receive a message you 
provide a valid response.

CHAPTER 1 ■ INTRODUCTION
18
With the help of this actor model, Erlang is able to perform tasks at a faster rate, 
which in turn makes it faster. We can treat this actor model as a world where everyone can 
perform a few distinct tasks and just wait to receive a proper message. It means everyone 
is dedicatedly working on a specific task and not concerned about what other people are 
upto. To achieve this, we write processes (actors) in Erlang, and these actors do not share 
any kind of information. Every communication that is taking place is traceable, safe, and 
explicit. The ability of Erlang to scale, recover, and organize code makes it more awesome.
The main reason Erlang is able to scale so easily is that the nature of the process is 
very light, and a large number of processes exist. Although it is not required to use all of 
them at a time, you have them as a backup and can use them if required.
Evolution and History
In 1984, CSLabs at Ericsson conducted on going research on various languages and 
methodology approaches that were best suited for the applications in telephony domains. 
A few techniques were rule-based programming, imperative programming, declarative 
programming, and object oriented programming.
There are some properties that telephony domains demand, such as
•฀
Grained concurrency: Typical telecommunication involves large 
equipment, complex real-time systems, and various activities 
which should occur concurrently and are handled by processes or 
threads.
•฀
Asynchronous message passing: This is a basic requirement of 
telephone systems. Asynchronous message passing gives ways to 
distribute processing.
The research done on varieties of languages finally confirmed that building a scalable 
and distributed telephony application cannot be done by using any of the languages or 
with any of the methodologies. There are some parts of an application which can be best 
programmed in one methodology and other parts in using some other methodology.
The primary aim of this research was to develop a style of programming which 
can lead to beautiful code, and which will also help programmers gain efficiency when 
writing bug-free code.
Erlang Creation
Joe Armstrong started another experiment with Prolog, and gave the name Erlang to this 
new experimental language after the Danish mathematician Agner Krarup Erlang, creator 
of the Erlang loss formula. Erlang can be defined as a concurrent functional programming 
language which mainly follows two traditions (see Figure 1-20).

CHAPTER 1 ■ INTRODUCTION
19
•฀
Functional and logic programming languages: Erlang inherits 
lists, pattern making, atoms, catch and throw, and so on, from 
these languages. Examples of these types of languages are Lisp, 
Miranda, Haskel, and ML.
•฀
Concurrent programming languages: Erlang uses features 
like process communication modules and processes from these 
types of languages. Examples of these types of languages include 
Modula, Chill, and Ada. 
Erlang was created while keeping in mind various designs that are ideal for 
telephony applications. It contains features like concurrency, OS independent, garbage 
collection, tail recursion, different data types and collections, support selective message 
receive statement, asynchronous message passing, and default error handling.
Erlang Features
Concurrency
Erlang implements concurrency independent of the operating system. Processes in 
Erlang have no shared memory. Different processes in Erlang communicate to each 
other by sending and receiving messages asynchronously. These processes are very 
Concurrent Functional
programming Language
Erlang
Concurrent System
programming Language
like Ada, Module or Chill
Functional Programing languages like ML
or Miranda
Figure 1-20. How Erlang evolved

CHAPTER 1 ■ INTRODUCTION
20
lightweight; hence hundreds and thousands of process can run at a time, but their 
memory requirement varies dynamically. Erlang is useful for applications that require 
response time of order of milliseconds
Distributed
Erlang supports transparent distribution. An Erlang program can run on more than one 
machine which may each have different operating systems running. Erlang processes on 
one node and communicates a different process on another node using asynchronous 
message passing.
Sequential Erlang
The syntax of Erlang is quite similar to that of ML. It has data types like numbers, lists, and 
tuples and it uses pattern matching to select between alternatives. Recursion is used to 
construct loops.
Robust
When an Erlang process crashes it will only crash the process, not the entire system. 
Erlang processes can monitor each other so that if there is an error in one process, others 
can receive the error message. This also provides monitoring processes to take corrective 
actions like restart transactions, for example. In distributed systems, nodes can be 
configured to provide failover scenarios. Due to this feature of Erlang we are able to design 
soft-fail systems. For example, an error in the call of a telecommunication system will bring 
down that call only and not the entire system.
Software Upgrading in Running Systems
This function in Erlang can be performed without disturbing the current state of the 
system. We can directly change the code in the running system which means we can 
upgrade a system without disturbing the currently running operations.
The newly spawned process will use the new version of the module while the 
ongoing process will use the old one and remain undisturbed.
Portability
Erlang has been developed mainly in C, so it is available on most of the operating systems 
that can run C.

21
CHAPTER 2
The Chef Server
This chapter covers Chef server and its components in detail. First we cover the different 
types of chef servers and then move on to discuss the components of the open source 
chef server.
The Chef Server
The chef server is the server component of the Opscode chef tool. The server is a 
centralized location where data related to chef is stored.
The data that is stored on the server includes cookbooks, node objects, and any policy 
that needs to be applied on any node. Each node registered with the chef server has an 
agent known as chef client installed on it. The agent contacts the chef servers and pulls 
the configuration that needs to be applied on the node. The chef client is responsible for 
execution of the actual code on the node. Chef is a thick client architecture tool that enables 
the client to do the heavy lifting. Due to this approach the effort is distributed throughout 
the infrastructure nodes and not on a single server.
Types of Chef Server
Chef servers can be classified into three types.
1. 
Hosted enterprise chef
2. 
Enterprise chef
3. 
Open source chef server
Hosted Enterprise Chef
This type of chef server is a paid version and is offered as a service. As the name suggests, 
it is a cloud-based, highly available, and scalable version of chef. It has all the capability 
of chef and one can just sign up to use it. It has to be accessed via the Internet. Thus, a 
hosted enterprise chef is a great way for enterprises to leverage a fully supported and hosted 
version, such as cloud computing, for their applications. The managed offering frees the 
enterprise to focus its efforts on its core applications rather than installing, configuring, and 
managing chef.

CHAPTER 2 ■ THE CHEF SERVER
22
Enterprise Chef
This version of chef is the same as the hosted version. The only difference between them 
is that this one needs to be installed in the enterprise data centers and is not available as a 
hosted and managed offering.
In terms of technical capabilities, it is the same as the hosted version. It also has 
dedicated support directly from chef and features such as RBAC (Role-Based Access 
Control), built-in support for high availability, and so on.
Open Source Chef Server
This is a free version of the chef server which has many of the capabilities of the 
enterprise version but also some limitations. It does not include support directly from 
chef but has support from the chef community. The customer needs to manage the 
chef instances. High availability and scalability are not offered out of the box. Any data 
migration or patching also needs to be done by the user.
Extra Functionalities in Enterprise Chef
Enterprise chef has all the functionalities of the open source chef server along with the 
following features:
•฀
Improved RBAC: Enterprise chef comes with built-in RBAC, which 
is used to configure fine-grained permissions for users. This is an 
important requirement for any automation tool from a security 
perspective.
•฀
Built-in support for high availability: Enterprise chef comes with 
multiple installation options. The enterprise version of chef can 
be installed in a stand-alone mode and also in a high-availability 
mode. High availability can be a key requirement for some of the 
enterprises.
•฀
Push client jobs: The server can push the configuration to a client 
node in enterprise chef. In open source chef server the chef client 
needs to pull the data.
•฀
Improved management console for ease of administration.
•฀
Monitoring and reporting: Reporting and monitoring features 
are enhanced in enterprise chef; while in open source we have 
minimal monitoring and reporting.
•฀
Support directly from chef: It has support directly from chef.

CHAPTER 2 ■ THE CHEF SERVER
23
Components of Open Source Chef Server
The previous versions of chef were written in Ruby. Chef 11 was released in early 2013. 
One of the major changes was that the API (application programming interface) server 
was written in Erlang.
Erlang is a functional programming language that has many good features, like 
fault tolerance, concurrency, and high scalability, and it can also work in distributed 
environments. Due to the massive scalable nature of Erlang, it is used in telecom software 
and other high-performance real-time systems.
Due to this change and leveraging the Erlang language, this version of chef is more 
scalable and provides higher performance.
Figure 2-1 shows the various components that are part of a chef server and how they 
are connected to one another.
Search Index/
Chef Solr
Postgres ql
Cookbooks
WebUI
Erchef
Bookshelf
Nginx
Message Queues
Figure 2-1. Working of the chef server
Nginx
Nginx is a popular open source http server and reverse proxy. Nginx is a high-performance 
http server which can handle heavy workload websites.

CHAPTER 2 ■ THE CHEF SERVER
24
Nginx is leveraged by chef as the http server and every request that comes to the 
chef server is routed to Nginx. Then, Nginx forwards the request based on the type of 
request. If it’s a cookbook-related–request then it is forwarded to Bookshelf. Bookshelf 
then forwards the request to Erchef, and it is handled accordingly. Any request coming is 
finally handled by Erchef.
Bookshelf
Bookshelf is a component of chef which holds the cookbooks in the chef server. All 
cookbooks that are uploaded to the chef server are stored in Bookshelf. The cookbook 
contains different types of files, from templates to recipes, and so on. Bookshelf also 
maintains different versions of the cookbooks.
The content in Bookshelf is stored using the checksum; the files are updated only 
if the checksum changes. Bookshelf uses flat files to store the content and the content is 
separate from the search index repositories.
Figure 2-2 shows how cookbooks are typically stored in the cookbook content. The 
path where these files are located is/var/opt/chef-server/bookshelf/data/bookshelf/.
Figure 2-2. How cookbook files are stored
WebUI
The web interface of the chef server is a Ruby on Rails 3.0 application.
Figure 2-3 shows the web interface of a chef server. This is the screen that appears 
when you open the web interface for the first time.

CHAPTER 2 ■ THE CHEF SERVER
25
Web UI provides the graphical interface for the administrator and users to work with 
the chef tool.
Erchef
The core API of the chef server is written in Erlang and is known as Erchef. As it is written 
in Erlang it is much faster compared to its previous versions. The previous versions were 
written in Ruby. This version is also compatible with the previous version of the server. 
The cookbooks that were written for the previous versions will work in this version also.
The new version provides higher performance and scalability and it was one of the 
reasons for rewrite of the API server using Erlang.
Message Queue
Chef uses RabbitMQ for queueing the messages. RabbitMQ is one of the leading open 
source message queueing platforms. The messages that are received by the chef server 
are sent to the search index using the Message Queue.
All the messages are added to a queue; the chef expander pulls these messages from 
the RabbitMQ queue, changes them to the required format, and then sends them to the 
chef solr for indexing. Chef solr is a search engine which exposes its Rest API for indexing.
By using message queues, high workloads can be handled through the queue 
mechanism and then eventually indexed and made available through the index.
Chef Solr
Chef Solr is the search engine in chef. It wraps Apache solr and exposes its REST API for 
searching and indexing. Apache solr is an open source search platform that provides 
search capabilities with features like dynamic clustering and integrations with databases. 
It is fault tolerant and highly reliable. Solr is written in Java and runs as a stand-alone  
full-text search server within a servlet container such as Jetty. Solr uses the Lucene Java 
search library at its core for full-text indexing and search, and it has REST-like  
Figure 2-3. Web interface of the chef server

CHAPTER 2 ■ THE CHEF SERVER
26
HTTP/XML and JSON (JavaScript Object Notation) APIs that make it easy to use from 
virtually any programming language. Solr’s powerful external configuration allows it to 
be tailored to almost any type of application without Java coding, and it has an extensive 
plug-in architecture when more advanced customization is required.
Postgresql
Postgresql is a leading open source RDBMS (relational database management system). 
This forms the database for the chef tool.
Postgresql is used to store the data related to the chef server. The current version of 
chef uses postgresql version 9.2.x. By default, chef creates a database named Opscode_Chef. 
Figure 2-4 shows the structure of the database.
Figure 2-4. Structure of database
Table 2-1. Ports Used by Chef
Service
Port Used
Erchef
8000
ChefServer-WebUI
9462
Postgresql
5432
RabbitMQ
5672
Chef Solr
8983
Bookshelf
4321
Nginx
443/80
Ports
Table 2-1 shows the list of ports that the chef server utilizes.
www.allitebooks.com

27
CHAPTER 3
Installation
This chapter discusses the Installation and configuration of open source chef server.
Install the Chef Server
Prerequisite
System Requirements
Some of the important system requirements that need to be fulfilled before we install the 
chef server are
Users: Chef server requires a local user and group to be created.  
•฀
It will create them automatically if proper privileges are given,  
but if we don’t have a restricted access to the environment then 
we need to create them manually.
FQDN: The server should have a complete and fully qualified 
•฀
domain name (FQDN), and it should be resolvable. If we are 
working in a production environment we should go for a DNS 
(Domain Name System) entry.
Git: Git must be installed on the server so that it is able to 
•฀
maintain the revisions of internal services.
NTP: As the chef server is sensitive to click drift, the server should 
•฀
be connected to an NTP server.
Apache Qpid: The daemon should be disabled on CentOS and 
•฀
Red Hat systems.
Make sure your firewall is configured properly.
•฀
Hardware Prerequisite
If we are going to use our chef server for testing purposes, it can be installed on an  
m1.small instance on AWS (Amazon Web Services). It can also be installed on a local 
virtual machine with 1GB of RAM. 

CHAPTER 3 ■ INSTALLATION
28
If we are going for a production environment, then the desired configuration is
RAM—4GB
•฀
Cores—4 with 2.0GHz Intel/AMD CPUs
•฀
Disk space—5GB in /opt and 5GB free in /var
•฀
The following operating systems support the chef server:
Operating System
Version
Architecture
Ubuntu
10.04, 10.10, 11.04, 
11.10, 12.04, 12.10
X86_64 and i686
Enterprise Linux
5,6
X86_64
Hostname
The main prerequisite for chef server is that the hostname of the server should be set 
before installing the server. The hostname should meet certain conditions. 
1. 
The hostname should be an FQDN and should include the 
domain suffix as well.
2. 
It should be resolvable. For a production environment, we 
should go for a DNS entry; in a testing environment we can 
make an entry in /etc/hosts to ensure that the hostname is 
resolvable.
To check whether you have configured the hostname properly, run the 
"hostname"command. The output should be similar to what we see in Figure 3-1.
Figure 3-1. Verifying a hostname
Figure 3-2. Verifying that a hostname is resolvable
To check whether your hostname is resolvable, run the "hostname –f" command. 
The output should be similar to what we see in Figure 3-2.

CHAPTER 3 ■ INSTALLATION
29
Installation
In this section we demonstrate the Installation of chef server version 11.x.
Steps
Several steps need to be taken to install the open source chef server. 
The first step is to download the chef server installer available on the chef web site.
Go to the following link and download the OS-relevant setup as shown in Figure 3-3.
www.getChef.com/Chef/install/
Figure 3-3. Downloading the chef server(1) 
In the chef server tab, select the operating system (OS), its version, and its 
architecture. A list of the chef server versions will come up. Select a version. The 
download link for the selected version will come up as shown in Figure 3-4. Click the link 
to start downloading. Make the selections as shown in Figure 3-4 as we will be installing 
the chef open source version on RHEL (Red Hat Enterprise Linux).

CHAPTER 3 ■ INSTALLATION
30
We will be installing the chef server on a machine with the RHEL OS. Install the rpm 
downloaded on the machine as shown in Figure 3-5.
Figure 3-4. Downloading the chef server(2)
Figure 3-5. Installing the chef server
When the rpm is installed the next step is to run a command that will configure the 
chef server. Run the following command (see Figure 3-6):
 
$ Chef-server-ctl reconfigure
 

CHAPTER 3 ■ INSTALLATION
31
The foregoing command will install the chef server with default settings. If we need 
some custom settings, then we need to create a file from which the chef server will fetch 
the settings. We discuss this topic in detail in the section “Configuration.” When the 
configuration is complete you will see a screen similar to the one in Figure 3-7.
Figure 3-6. Configuring the chef server
Figure 3-7. \Configuration completed

CHAPTER 3 ■ INSTALLATION
32
To check whether our Installation completed successfully, run the following 
command (see Figure 3-8):
 
$ Chef-server-ctl test
 
Figure 3-8. TestingInstallation of chef server
Figure 3-9. Testing successful
This is a built-in command that comes with chef. Whenever you invoke the 
command, it will run a test against the installed chef server and verify whether everything 
is working fine.
A screen similar to the one in Figure 3-9 will let you know if the Installation is working 
properly. 

CHAPTER 3 ■ INSTALLATION
33
Now, open the WebUI of the chef server using the IP (Internet protocol) address or 
the FQDN of the server. You will find a screen similar to the one in Figure 3-10.
Installation on a Virtual Machine
In this scenario we will install the chef server on a virtual machine. The following 
requirements are necessary to proceed with the Installation: 
A computer running VMware workstation with a configured 
•฀
virtual machine running RHEL 6.0.
A working browser on the computer running the workstation.
•฀
A bridged adaptor to configure our chef server.
•฀
The IP or the FQDN of the virtual machine in order to access the 
•฀
chef server.
Steps
The steps are similar to those of installing the chef server on a server.
First, download the chef server package on the virtual machine.
Go to the following link and download the OS-relevant setup as shown in Figure 3-11.
 
www.getChef.com/Chef/install/
 
Figure 3-10. Web interface of chef server

CHAPTER 3 ■ INSTALLATION
34
In the chef server tab, select the OS, its version, and its architecture. A list of the 
chef server versions will come up. Select a version. Figure 3-12 shows the download link 
that will come up for the selected version. Click the link to start downloading. Make the 
selections as shown in Figure 3-11, as we will be installing the chef open source version 
on RHEL.
Figure 3-11. Selection an appropriate Version of Chef-Server
Figure 3-12. Downloading the chef server
We would be installing the chef server on a machine with RHEL OS. Install the rpm 
downloaded on the machine as shown in Figure 3-13.

CHAPTER 3 ■ INSTALLATION
35
Once you have installed the rpm, the next step is to run a command that will 
configure the chef server. Use the following command, as shown in Figure 3-14:
 
$ Chef-server-ctl reconfigure
 
Figure 3-13. Installing the chef server
Figure 3-14. Configuring the chef server
The aforementioned command will install the chef server with default settings.  
If we need some custom settings we need to create a file from which the chef server will 
fetch the settings. We discuss this topic in detail in the section “Configuration.” When the 
configuration is complete you will get a screen similar to the one in Figure 3-15.
Figure 3-15. Configuration completed

CHAPTER 3 ■ INSTALLATION
36
To check whether our Installation completed successfully, run the following 
command as shown in figure 3-16:
 
$ Chef-server-ctl test
 
Figure 3-16. TestingInstallation of chef server
Figure 3-17. Testing successful
This is a built-in command that comes with chef. Whenever the command is 
invoked, it will run a test against the installed chef server and will verify whether 
everything is working fine or not. 
You will see a screen similar to the one in Figure 3-17 if the Installation is working 
properly.
Now the next step would be to set the network adapter of your virtual machine to 
bridged. It should look similar to what we see in Figure 3-18.
www.allitebooks.com

CHAPTER 3 ■ INSTALLATION
37
Restart the network services of the virtual machine and run ifconfig command to 
get the IP address of the virtual machine as shown in Figure 3-19.
Figure 3-18. Set network adapter as bridged
Figure 3-19. Restarting network services

CHAPTER 3 ■ INSTALLATION
38
Open the web browser and access your chef server. You will see a screen similar the 
one in Figure 3-20.
Figure 3-20. Web interface of the chef server
Use the default login credentials available to access the chef server. Now we have set 
up a chef server on a virtual machine.
File System locations
Chef server uses the following file locations for installing chef. 
•฀
/opt/Chef-server: This directory is used for Installation.
•฀
/etc/Chef-server: This directory is used for storing the key files 
and the API configuration.
•฀
/var/opt/Chef-server: All the services in chef are here.
•฀
/var/log/Chef-server: This directory is used for storing the logs.
Configuration
The chef server is installed with default configuration settings. If we need to update any 
configuration settings, then we need to create a Chef-server.rb file and specify the 
settings that we need to modify. 

CHAPTER 3 ■ INSTALLATION
39
After specifying the settings, we need to run the Chef-server-ctl reconfigure 
command to apply these settings. 
The configuration file is located at /etc/Chef-server/Chef-server.rb. 
These settings are optional and are required only if we want to change the default 
settings. 
Some of the important settings that can be modified are mentioned in the Table 3-1.
The following settings can be added to the Chef-server.rb file to tune it:
Table 3-1. Settings available in chef-server.rb
Setting
Description
api_fqdn
It is used to define the FQDN of the server. The value should be 
same as the FQDN for the server.
bookshelf[‘vip’]
The virtual IP address. Default value: node[‘fqdn’]. (This setting 
is related to the bookshelf service.)
Bootstrap
Default value: true.
notification_email
Default value: info@example.com.
Optional Settings
The following settings are often used for performance tuning open source chef in 
largerInstallations. When changes are made to the Chef-server.rb file, the open source 
chef must be reconfigured by running the Chef-server-ctl reconfigure command.
Bookshelf
Bookshelf services can be tuned by changing the following setting:
Setting
Description
bookshelf[‘vip’]
The virtual IP address. Default value:node[‘fqdn’].

CHAPTER 3 ■ INSTALLATION
40
Chef Expander
The following setting is often modified from the default as part of the tuning effort for the 
opscode-expander service:
Setting
Description
Chef_expander[‘nodes’]
The number of allowed worker processes. The opscode-
expander service runs on the back end and feeds data to 
the opscode-solr service, which creates and maintains 
search data used by the server. Additional memory may 
be required by these worker processes depending on 
the frequency and volume of chef client runs across the 
organization, but only if the back-end machines have 
available CPU and RAM. Default value: 2.
Chef Solr
The following settings are often modified from the default as part of the tuning effort for 
the opscode-solr service:
Setting
Description
Chef_solr[‘heap_size’]
The amount of memory available to Apache Solr. If there 
is not enough memory available, search queries made by 
nodes to Apache Solr may fail. The amount of memory that 
must be available also depends on the number of nodes 
in the organization, the frequency of search queries, and 
other characteristics that are unique to each organization. In 
general, as the number of nodes increases, so will the amount 
of memory.
If Apache Solr is running out of memory, the /var/log/
opscode/Chef_solr-solr/current log file will contain 
SEVERE: java.lang.OutOfMemoryError: Javaheap space.
The default value should work for many organizations with 
fewer than 25 nodes. Suggested value: 256 for every 25 nodes. 
For example, an organization with 300 nodes should have this 
value should set to 3072.
Chef_solr[‘max_field_
length’]
The maximum field length (in number of tokens/terms). If a 
field length exceeds this value, Apache Solr may not be able 
to complete the building of the index. Default value: 100000 
(increased from the Apache Solr default value of 10000).

CHAPTER 3 ■ INSTALLATION
41
Update Frequency
At the end of every chef client run, the node object is saved to the server. From the server, 
each node object is then added to the SOLR search index. This process is asynchronous. 
By default, node objects are committed to the search index every 60 seconds or every 
1000 node objects, whichever occurs first.
When data is committed to the Apache Solr index, all incoming updates are blocked. 
If the duration between updates is too short, it is possible for the rate at which updates are 
asked to occur to be faster than the rate at which objects can be actually committed.
For open source chef, the following settings are configurable in the Chef-server.rb file:
Setting
Description
Chef_solr[‘commit_interval’]
The frequency (in seconds) at which node objects 
are added to the Apache Solr search index. Default 
value: 60000 (every 60 seconds).
Chef_solr[‘max_commit_docs’]
The frequency (in documents) at which node 
objects are added to the Apache Solr search index. 
Default value: 1000 (every 1000 documents).
erChef
To tune the opscode-erChef service, the following settings can be changed:
Setting
Description
erChef[‘db_pool_size’]
This setting specifies the number of open connections to 
the database server that are maintained by opscode-erChef 
service. The default value is 20. This should be changed 
along with the postgresql[‘max_connections’] setting.
erChef[‘s3_url_ttl’]
This setting specifies the timeout for chef client. The default 
time out is 900.
Postgresql
The tuning of postgresql service can be done by changing the following settings:
Setting
Description
postgresql 
[‘max_connections’]
The setting specifies the maximum number of allowed 
concurrent connections to the database server. This value 
should only be tuned when the ErChef[‘db_pool_size’] value 
used by the opscode-erChef service is modified. Default value 
for the max_connections is 200.

CHAPTER 3 ■ INSTALLATION
42
WebUI
The following setting can be modified from the default as part of the tuning effort for the 
opscode-webui service:
Setting
Description
Chef_server_webui 
[‘worker_processes’]
This setting specifies the number of allowed worker 
processes. This setting should be increased or decreased 
based on the number of users in an organization who use 
the server web user interface. The default value for the 
worker_processes is 2.

43
CHAPTER 4
Workstation
A workstation can be defined as a system on which we have chef client installed, and 
which has knife configured properly. A workstation holds a local repository for chef 
server. It is a place where all the development work takes place, and then that work is 
uploaded to the chef server. It provides an interface to interact with the chef server. The 
main functions of a workstation can be
Uploading the items from the local chef repository to the  
•฀
chef server.
Installing chef on the nodes using a knife bootstrap operation.
•฀
Creating cookbooks.
•฀
Creating roles/environments or any other policies and then 
•฀
uploading them to the chef server.
Managing nodes using knife.
•฀
Prerequisite
Before we start with the installation, we must make sure we meet the prerequisites 
required to install and configure a workstation properly.
A working chef server with which we will configure our 
•฀
workstation.
Chef client requires at least 512MB of RAM, 15GB storage, and 
•฀
one vCPU (virtual CPU) running properly.
The node should be able to interact with the chef server via 
•฀
HTTPS.
Ruby should be installed (1.8.7 + versions).
•฀
For testing purposes we can use a t1.micro instance on AWS (Amazon Web Services) 
to run chef client. However, for a production client we should use instances with at least 
2GB of RAM and 15GB of storage.

CHAPTER 4 ■ WORKSTATION
44
Operating System Support
Table 4-1 lists the operating systems (OSs) that currently support chef client.
Table 4-1. List of Operating Systems That Support Chef Client
Operating System
Version
Architecture
Debian
6 and above
i686, x86_64
Enterprise Linux
5.x, 6.x
i686, x86_64
Mac OS X
10.6, 10.7
x86_64
openSUSE
12.1
i686, x86_64
Solaris
5.9
Sparc
5.10. 5.11
i386, sparc
SUSE Enterprise
11.2
i686, x86_64
Ubuntu
10.04, 10.10, 11.04, 11.10, 12.04, 12.10
i686, x86_64
Windows
2003 R2, 2008
i686, x86_64
2008 R2, 2012
x86_64
Install and Configure a Workstation
In order to configure a workstation properly, several steps are necessary. Here we 
demonstrate the configuration of a workstation on an Enterprise Linux-based OS. The 
same steps can be used to configure it on any other OS.
1. 
Identify the operating system.
2. 
Install the chef client package.
3. 
Copy the validator.pem and admin.pem from to the chef server.
4. 
Configure knife.
5. 
Install git (optional).
6. 
Copy the knife configuration and key files in the chef repository.
7. 
Verify the workstation configuration.
We cover each and every step in detail in the upcoming sections.
Identify the Operating System
This step mainly includes identifying the OS, which will help us in installing the relevant 
package on the system.

CHAPTER 4 ■ WORKSTATION
45
Install the Chef Client Package
There are two options to install the chef client package.
1. 
Use the script provided by chef, which will install the latest 
version available.
2. 
Download the relevant version and install it using a  
suitable method.
Go to www.getChef.com/Chef/install/.
Visit the chef client tab and select your OS and its architecture. You will find two ways 
to install the package, as shown in Figure 4-1, and you can use either method to install the 
package. We demonstrate here by using the second method.
Figure 4-1. Downloading the chef package
Select the chef version and download it to the machine on which we will configure 
the workstation.
After downloading the installer, run it using a relevant method based upon your 
OS. For Windows, right-click and run as administrator and install (see Figure 4-2). For 
Enterprise Linux, download the rpm and install it.

CHAPTER 4 ■ WORKSTATION
46
Verify the installation by typing chef client –v at the command line. It should return 
something like what we see in Figure 4-3.
Figure 4-2. Installing the chef package
Figure 4-3. Verifying installation
Copy the Key Files from the Chef Server
The workstation needs some keys and configuration files to connect and authenticate 
with the chef server. The following items are required:
Knife configuration file (
•฀
Knife.rb): It can be created using the 
knife configure command. We demonstrate this in the next 
section.
Knife user key file: It can be created using the knife configure 
•฀
command.
Chef validator key: This is a private key that is generated by the 
•฀
chef server when we configure it for the first time. We need to 
manually copy this file to .chef folder on the workstation.
Configure Knife
We demonstrate by configuring knife to an open source chef server. Run the knife 
configure command to configure the workstation and create the knife configuration file. 
Figure 4-4 shows this operation.
www.allitebooks.com

CHAPTER 4 ■ WORKSTATION
47
The following inputs are required to configure knife:
The path (for Linux 
•฀
/root/.chef and for Windows c:/users/user/.
chef) to keep the configuration file.
The URL (uniform resource locator) of the chef server: It can be 
•฀
the IP (Internet provider) or the FQDN (fully qualified domain 
name) of the server. FQDN is preferred over IP.
Client name for API (application programming interface). The 
•฀
admin user to be used with knife.
Validation client name: Chef validator client that is automatically 
•฀
created with chef.
Location of validation key.
•฀
Path to a chef repository.
•฀
Install Git (Optional)
Git is required on the workstation if we want to clone the repository on github provided 
by Opscode. If we don’t want to do so, then we can create our own chef repository. This 
step is an optional, required only if we want to clone the repository provided by chef.
Figure 4-4. Configuring knife

CHAPTER 4 ■ WORKSTATION
48
Place the Knife Configuration and Key Files in  
the .Chef Directory
By default, Chef looks for the knife configuration in the .Chef directory (for Linux  
/root/.chef and for Windows c:/users/user/.chef). So, you need to place the 
following items in that directory:
The knife configuration file
•฀
The chef validator key file
•฀
The user to be used to make the API calls
•฀
Verify the Workstation Configuration
To verify that our workstation is properly configured we run a test command.
Knife client list.
The command will list all the clients registered with chef server. The output will be 
similar to what we see in Figure 4-5.
Figure 4-5. Verifying that chef is installed properly

49
CHAPTER 5
Nodes
A node can be defined as a server that is managed by chef. It can be either a virtual or a 
physical server. “Managed by chef” means that the server has a chef client installed on it 
and that it is able to communicate with the chef server.
In this chapter, we try to cover all aspects related to a node. We also cover the 
installation and configuration of a node.
Types of Nodes
Nodes can be of different types. They can be virtual, physical, or cloud based. We 
consider two types of nodes here: cloud based and physical or virtual servers.
Cloud-based nodes refer to the nodes that are hosted on any of the cloud providers, 
such as AWS (Amazon Web Services), Microsoft Windows Azure, or any other cloud 
provider. We can provision these types of nodes using knife. Once the nodes are created 
chef can easily manage them.
A physical server can be a virtual machine or a server or any device that can send, 
receive, and forward information. In simpler terms, it is a device that can communicate 
with the chef server and has chef client installed and configured.
Node Names
The node_name is used as a part of the authentication process of the chef server.
The node name can be anything, but should be unique within a chef organization.
We can provide the node name in the client configuration file (client.rb). By 
default, chef uses Ohai to get the node name and it is the FQDN (fully qualified domain 
name) of the server.
Using the FQDN as the node name, and then allowing Ohai to collect this 
information during each chef run is the recommended approach and the easiest way to 
ensure that the names of all nodes across the chef organization are unique.

CHAPTER 5 ■ NODES
50
Manage Nodes
Nodes can be managed in chef using various approaches. They can be managed using 
knife or using the management console that chef provides.
We can use knife to manage the nodes. Managing covers creating, 
•฀
editing, tagging, listing, and so on.
We can use knife plug-ins to provision nodes.
•฀
We can also manage nodes using the management console.
•฀
Chef Client
Chef client is an agent installed on the node, and with its help, the nodes communicate 
with the chef server. Whenever chef client is run on a node, it follows certain steps.
The Chef Run
Chef run basically defines the steps that take place whenever chef client is invoked. 
Figure 5-1 shows the various steps that occur during a typical chef run.

CHAPTER 5 ■ NODES
51
We discuss each step in detail.
Whenever chef client is run, the following steps occur:
1. 
Get configuration details
2. 
Authenticate with chef server
3. 
Rebuild on the node object
4. 
Expand the run list
Figure 5-1. Chef run

CHAPTER 5 ■ NODES
52
5. 
Download the cookbooks on the node
6. 
Reset node attributes
7. 
Identify resources
8. 
Configure the node
9. 
Update the node object
We cover each step in detail in the following sections.
Get Configuration Details
The client configuration file (Client.rb) is used to store the configuration details. The 
configuration includes the node name with which the node (client) is registered with the 
chef server. We can provide the node name in the client configuration file if we want the 
node to be registered with some specific name. If we don’t provide anything in the client 
configuration file, then the node is registered with the FQDN.
Authenticate with Chef Server
To make sure that requests received by chef server are from a known source, it uses an 
RSA encryption mechanism. The node name is taken into consideration while generating 
the certificate. Whenever the chef client runs for the first time on the node, it takes the 
identity of chef validator to generate the RSA key for the node. When we configure a node, 
a public and a private key are generated for each node and the server keeps the public key 
while the node keeps the private key. Each request that comes from a node to the server 
comes in encrypted HTTP headers form which is decrypted using the public key.
Rebuild on the Node Object
The chef client downloads the node object from the chef server to the node. The node 
object is a JSON (JavaScript Object Notation) file which contains details like run list, 
node-specific attributes (if any), and some other information about that node.
Expand the Run List
The run list in the node object containing the details about every role/recipe that will be 
applied to the node is expanded and then placed in the order in which it will be applied 
to the node. The recipe that occurs first in the run list will be applied first, and so on.
Download the Cookbooks on the Node
In chef, the processing takes place at the client. So whenever the chef client runs, it downloads 
all the cookbooks in the run list of the node to the local cache of the node and then 
compiles them. If any file has changed, chef client downloads the new version of the file 
and deletes the previous version. The files include recipes, resources, libraries, and so on.

CHAPTER 5 ■ NODES
53
Reset Node Attributes
The next step in the chef run is to reset all the node attributes. The attributes are loaded 
from roles, environments, recipes, Ohai, and attribute files according to their precedence 
level and are updated on the node object. Chef has various types of precedence levels. 
Attributes are applied in chef in the following order, 1 being the lowest precedence and 
16 the highest. Table 5-1 also describes the same thing in a different way, where 1 is the 
lowest precedence level and 15 is the highest.
Table 5-1. Attribute precedence level
Attribute Files
Node/Recipe
Environment
Role
Default
1
2
3
4
Force_default
5
6
Normal
7
8
Override
9
10
11
12
Force_override
13
14
Automatic
15
Identify Resources
The next step is to identify the resources that would be required for successful compilation 
of the recipes. All the definitions and libraries are loaded so that the Ruby classes and  
the pseudo resources are available at the time of compilation. The recipe/recipes are 
loaded and the blocks within these recipes are evaluated. The recipes are evaluated in a 
top-down approach.
Configure the Node
The next step is to configure the node using the information that has been collected in the 
aforementioned steps. The resources that were identified in the previous steps are now 
mapped to a provider that will perform the desired action. The provider is responsible for 
completing the necessary action.
Update the Node Object
The final step is for the chef run to update the node object on the chef server. This action 
takes place when all the other actions have been completed. The chef client updates the 
node object that was built during the chef run on the chef server. This object would be 
used during the next chef run. Thus, the latest version information on a node is available 
in the chef server after every configuration of the node.

CHAPTER 5 ■ NODES
54
Install and Configure the Node
In order to configure a node properly, several steps are necessary. We demonstrate the 
configuration of a node on an Enterprise Linux-based operating system. The same steps 
can be used to configure it on any other operating system:
1. 
Identify the operating system
2. 
Install the chef client package
3. 
Copy the key files from the chef server
Identify the Operating System
This step mainly includes identifying the operating system (OS) which will help us in 
installing the relevant package on the system.
The OSs listed in Table 5-2 currently support chef client.
Table 5-2. Operating Systems Supporting Chef Client
Operating System
Version
Architecture
Debian
6
i686, x86_64
Enterprise Linux
5, 6
i686, x86_64
Mac OS X
10.6, 10.7
x86_64
openSUSE
12.1
i686, x86_64
Solaris
5.9
sparc
5.10. 5.11
i386, sparc
SUSE Enterprise
11.2
i686, x86_64
Ubuntu
10.04, 10.10, 11.04, 11.10, 
12.04, 12.10
i686, x86_64
Windows
2003 R2, 2008
i686, x86_64
2008 R2, 2012
x86_64
Install the Chef Client Package
There are two options to install the chef client package:
1. 
We can directly use the script provided by chef, which will 
install the latest version available.
2. 
We can download the relevant version and install it using a 
suitable method.

CHAPTER 5 ■ NODES
55
Go to www.getchef.com/chef/install/.
Visit the chef client tab and select your OS and its architecture.
You can use any of the methods just described to install the chef client.
Figure 5-2 demonstrates installation using the second method. Select the chef 
version and download it to the machine on which we will configure the node.
Figure 5-2. Downloading the chef package
Figure 5-3. Installing the chef package
After downloading the installer, run it using a relevant method based upon your OS. 
For Windows, double-click and install (see Figure 5-3). For Enterprise Linux, download 
the rpm and install it.
Verify the installation by typing chef-client –v at the command line. It should return 
something like what we see in Figure 5-4.

CHAPTER 5 ■ NODES
56
Copy the Key Files from the Chef Server
The node needs some keys and configuration files to connect and authenticate with the 
chef server. The following items are required:
Client configuration file (
•฀
Client.rb): You can create it using the 
knife configure command.
Chef validator key: This is a private key that is generated by the 
•฀
chef server when we configure it for the first time. We need to 
manually copy this file to the workstation.
Bootstrap
Bootstrapping is a process whereby when a new node gets into the environment. It gets 
configured based on the policies and configuration required for that role.
As explained in earlier chapters, the chef server is the centralized location where all 
data is stored. The data stored includes the node object and the cookbooks that define the 
configuration and policies.
Thus, the client node uses the chef client to connect to the chef server and download 
the configuration details from the chef server. The chef client does the heavy lifting and 
processing to do the configuration changes required on the node. Thus, at the end of 
configuration, the chef node has the desired configuration based on the policies and role. 
The chef client only makes the required changes to the node and does not make any 
changes if nothing is required to be changed on the node.
The steps required to bootstrap a node are as follows:
1. 
Identify the FQDN or IP address for the node.
2. 
Run the knife bootstrap command.
3. 
Verify the node on the chef server.
The first step in bootstrapping is to identify the configured FQDN or IP address 
assigned to a node.
The knife bootstrap command requires the FQDN or the IP address of the node in 
order to complete the bootstrap operation.
After you identify the IP address and FQDN, the administrator has to run the knife 
bootstrap command.
knife bootstrap IP –x username –P password –sudo.
The command installs chef on the end client and runs chef client on the node.
The last step in this exercise is to verify that the client is now configured and available 
in the chef server for further management (see Figure 5-5). The following command is 
used to verify the installation of chef-client and its configuration in the chef-server.
Figure 5-4. Verifying installation
www.allitebooks.com

CHAPTER 5 ■ NODES
57
Figure 5-5. Verifying bootstrapping
knife client show name_of_node.
The chef server will return something as shown in Figure 5-5.
If something similar to what is shown in Figure 5-5 is returned, then chef has 
successfully been installed on your node.
Configuring 
Chef client uses a configuration file (Client.rb) to store the configuration. This file is 
loaded every time we run chef client. If we are working on a Linux-based box, this file is 
normally stored at /etc/chef/client.rb and on a Windows-based server the location is 
c:/chef/client.rb.
Various settings can be done via this file. Table 5-3 discusses some of the important 
options available in the configuration file.
Table 5-3. Configuration settings available
Setting
Description
chef_server_url
This is one of the important options of this file. It is used to 
specify the address of the chef server.
chef_server_url “https://10.98.241.28”
client_key
Chef uses a key to authenticate itself to the chef server. Client 
key will be generated during the first chef client run. This 
option is used to specify the location of the key file. For example:
client_key “/etc/chef/client.pem”
client_registration_retries
This option is used to specify the number the number of 
attempts that should be made by a chef client to register 
itself with the chef server. The default value is 5.
environment
This option is used if we want our node to be in a specific 
environment. For example,
environment “testing.”
(continued)

CHAPTER 5 ■ NODES
58
Setting
Description
http_proxy
This option is used if our environment is using a proxy for 
http connections.
For example:
http_proxy “http://yourproxy.com:8080”
http_proxy_pass
If our proxy is using a password for connection, then we 
need to specify this option.
There is no default value for this option. For example:
http_proxy_pass “1234567890.”
http_proxy_user
If our proxy is using a username for connection, then we 
need to specify this option.
There is no default value for this option. For example:
http_proxy_user “my_username”
http_retry_count
The number of retry attempts. Default value: 5. For example:
http_retry_count 5
http_retry_delay
The delay (in seconds) between retry attempts. Default 
value: 5. For example:
http_retry_delay 5
https_proxy
This option is used if our environment is using a proxy for 
https connections.
For example:
https_proxy “http://yourproxy.com:8080”
interval
This option is used to specify the time after which chef 
client should run.
For example: interval 3000
json_attribs
Use to override attributes that are set from other locations, 
such as from within a cookbook or by a role. The value 
must be entered as JSON data. For example:
json_attribs nil
log_level
It is used to specify the level at which logging should be 
done. For example:
log_level :debug
Table 5-3. (continued)
(continued)

CHAPTER 5 ■ NODES
59
(continued)
Setting
Description
log_location
This option is used to specify the location of the log file. 
The default value is STDOUT.
For example:
log_location STDOUT
no_proxy
This option is used to specify the list of URLs that do not 
need a proxy.
For example:
no_proxy “test.com”
node_name
This option is used to specify the name with which the 
node would be registered with the chef server. If we do not 
supply this value, then the FQDN of the server is taken.
For example:
node_name “mynode.com”
node_path
The location in which to look for node-specific recipes. 
This has the default value of :/var/chef/node.  
For example:
node_path “/var/chef/node”
rest_timeout
The time (in seconds) after which an HTTP REST request 
will time out. This has the default value: 300. For example:
rest_timeout 300
splay
A number (in seconds) to add to the interval that is used to 
determine the frequency of chef client runs. This number 
can help prevent server load when there are many clients 
running at the same time. Default value: nil. For example:
Splay
ssl_ca_file
The file in which the OpenSSL key is saved. This setting is 
generated automatically by chef and most users will not 
need to modify it. For example:
ssl_ca_file nil
ssl_ca_path
The path to where the OpenSSL key is located. This setting 
is generated automatically by chef and most users will not 
need to modify it. For example:
ssl_ca_path nil “/etc/ssl/certs”
Table 5-3. (continued)

CHAPTER 5 ■ NODES
60
Setting
Description
ssl_client_cert
The OpenSSL X509 certificate. This setting is generated 
automatically by chef and most users will not need to 
modify it. For example:
ssl_client_cert “”
ssl_client_key
The OpenSSL X509 key. This setting is generated 
automatically by chef and most users will not need to 
modify it. For example:
ssl_client_key “”
umask
The file mode creation mask. This has the default value: 
0022. For example:
umask 0022
validation_client_name
This option is used to specify the name of the validation 
client. A validation client is created automatically when 
we install the chef server. This client is used to register any 
node on the chef server.
For example:
validation_client_name “chef-validator”
validation_key
This option is used to specify the location of the  
validation key.
For example:
validation_key “/etc/chef/validation.pem”
Table 5-3. (continued)

61
CHAPTER 6
Working with Knife
Knife is a command line utility that comes with chef and is used to interact with the chef 
server which is used to manage chef. Management in chef includes many tasks.
Managing nodes
•฀
Uploading cookbooks and recipes from the local chef repository 
•฀
to the chef server
Managing roles
•฀
Managing environments
•฀
Managing cloud resources which include provisioning on AWS 
•฀
(Amazon Web Services), Azure, or any other cloud provider
Bootstrapping chef on nodes
•฀
Along with the aforementioned tasks, chef can be used to perform many other tasks 
which we discuss in the upcoming sections of this chapter.
Working with Knife
Knife executes its functions from a workstation and is used to interact with the chef 
server and also with your infrastructure (see Figure 6-1). The interaction with the 
workstation and the chef server is done using the REST API (application programming 
interface) that is used by a chef client. The workstation configuration includes knife 
configuration, but if we want to change or modify anything, we can directly do it in the 
knife configuration file.

CHAPTER 6 ■ WORKING WITH KNIFE
62
There are many subcommands available with knife that are used to manage chef 
(Figures 6-2 and 6-3). We discuss some of them in the following sections. Knife –help can 
be used to see options common to all subcommands.
Figure 6-1. List of options available with knife
Figure 6-2. List of commands available with knife (1)

CHAPTER 6 ■ WORKING WITH KNIFE
63
You can use the knife subcommand –help to see the options available to that 
subcommand.
All the commands in knife are structured in a similar way. They have the form NOUN 
verb NOUN (options). Chef server uses RESTful API. The chef server API is RESTful. The 
options available for the verb part are
Create (create)
•฀
List and show (read)
•฀
Edit (update)
•฀
Delete (destroy)
•฀
 
knife sub-command [argument] [options]
 
Some of the knife commands require the environment variable EDITOR to edit or 
create some objects, so it’s recommended to have it before using knife.
 
export EDITOR=vi
Figure 6-3. List of commands available with knife (2)

CHAPTER 6 ■ WORKING WITH KNIFE
64
Bootstrap
A bootstrap is a process by which we install chef client on a target node. This command 
takes the IP (Internet provider) or the FQDN (fully qualified domain name) of the node as 
an input and installs the chef client package on it.
The syntax for this command is as follows:
 
knife bootstrap FQDN_or_IP_ADDRESS (options)
 
We will discuss some of the important options available in the bootstrap command.
 
--bootstrap-proxy PROXY_URL
 
This command requires Internet connectivity to be present on the node system.  
If the node is using proxy to connect to the Internet, then we need to specify this option.
 
--bootstrap-version VERSION
 
We use this option if we want to install a specific version of chef. By default, it installs 
the latest version.
 
-G GATEWAY, --ssh-gateway GATEWAY
 
The bootstrap command uses SSH to install chef. We use this option if our network 
has SSH, an SSH gateway configured, and direct SSH to our target node is blocked or  
not allowed.
 
-i IDENTITY_FILE, --identity-file IDENTITY_FILE
 
We adopt this option if we are using key-based authentication for SSH rather than a 
username and password.
 
-j JSON_ATTRIBS, --json-attributes JSON_ATTRIBS
 
We use this option if we want to specify some custom attributes on the first chef run.
 
-N NAME, --node-name NAME
 
We use this option to specify the node name by which it would be registered with the 
chef server. If we don’t specify this option, the FQDN of the node would be used.
 
--[no-]host-key-verify
 
We use this option to skip the host key verifications. It is enabled by default.
 
-p PORT, --ssh-port PORT
 

CHAPTER 6 ■ WORKING WITH KNIFE
65
We use this option to specify the port to be used for SSH. If we don’t specify anything, 
Port 22 would be used.
 
-P PASSWORD, --ssh-password PASSWORD
 
We use this option to provide the password that would be used to log in to the 
instance.
 
-r RUN_LIST, --run-list RUN_LIST
 
We use this option to specify the list of recipes/roles or both to be applied to the 
node in a comma-separated format.
 
--sudo
 
If you use this option, then the bootstrap operation will be executed using sudo.
 
-x USERNAME, --ssh-user USERNAME
 
We use this option to specify the username that would be used by knife to log in to 
the instance.
Figure 6-4 shows the list of options available with the bootstrap subcommand.
Figure 6-4. List of options available with knife bootstrap subcommand

CHAPTER 6 ■ WORKING WITH KNIFE
66
Client
We use the client subcommand to manage the clients that are registered with the chef 
server. Many options are available, which we discuss here one by one.
The syntax for this command is as follows:
 
knife client (options)
 
Figure 6-5 shows the options available in knife client subcommand.
Figure 6-5. List of options available with knife client subcommand
Figure 6-6. Deleting multiple clients
Bulk Delete
We use this option to delete any client registered with the chef server that matches a 
regular expression. Figure 6-6 shows an example.
Create
We use the create option to create a new client. Whenever we run this command, it 
generates a new RSA key pair for the client. The server will store the public key and the 
private would be displayed as an output. Figure 6-7 shows an example.
www.allitebooks.com

CHAPTER 6 ■ WORKING WITH KNIFE
67
The following details are required in order to create an API client:
Name – The name with which the client would be registered.
Public-key – A RSA key pair that would be auto-generated.
Validator – Whether the client would be a validator or not. A validator is a special 
type of client which is used to register new clients to the chef server.
Admin – Whether the client would have administration privileges or not. It can either 
be true or false.
Delete
This argument is passed if we want to delete only a single registered API client. We need 
to provide the name with which the client is registered. Figure 6-8 shows an example.
Figure 6-7. Creating an API client
Figure 6-8. Deleting a client
The syntax for this command is as follows:
 
knife client delete client_name 
Edit
We use this option if we want to edit the details of an already registered API client. We 
need to set the environment editor variable before using this option. Knife will use that 
editor to open the node object and we can edit the detail we want to. Knife then directly 
uploads the changes to the server. Figure 6-9 shows an example.

CHAPTER 6 ■ WORKING WITH KNIFE
68
The syntax for this command is as follows:
 
knife client edit client_name 
List
We use this option to view the list of clients registered with the chef server. Using his 
option will return a list of registered clients. Figure 6-10 shows an example.
Figure 6-9. Editing a client
Figure 6-10. List of registered clients
The syntax for this command is as follows:
 
knife client list 

CHAPTER 6 ■ WORKING WITH KNIFE
69
Reregister
We normally use this option when we delete the client key from the client and we want 
a new key to be generated. It will regenerate the RSA key pair for the client. Figure 6-11 
shows an example.
Figure 6-11. Reregistering a client
The syntax for this command is as follows:
 
knife client reregister client_name 
Show
This option will display the information available about a client. Figure 6-12 shows what 
this information will look like.

CHAPTER 6 ■ WORKING WITH KNIFE
70
The syntax for this command is as follows:
 
knife client show client_name 
Configure
We can use the configure command to configure a workstation and client. We have already 
covered these things in previous chapters. We can create the knife configuration file  
(Knife.rb) and client configuration file (Client.rb) using this command. Figures 6-13 and 
6-14 show how to use the command and the options available with the command.
Figure 6-13. Configuring a client
Figure 6-12. Viewing a client

CHAPTER 6 ■ WORKING WITH KNIFE
71
Figure 6-14. Listing of options available with knife configure
The syntax for this command is as follows:
 
knife configure (options)
 
The following options are available in this command.
 
--client DIRECTORY
 
We use this option to specify the client directory where the client configuration file 
would be placed. It reads from the knife configuration file and writes relevant information 
to the client configuration file.
 
-i, --initial
 
We use this option to create an API client that would be used by knife for 
authorization.
 
-r REPO, --repository REPO
 
We use this option to provide the path of the local chef repository.
Cookbook
We use the cookbook subcommand to interact with cookbooks that are located on the 
chef server or on the local chef repository (see Figure 6-15).

CHAPTER 6 ■ WORKING WITH KNIFE
72
Figure 6-15. Listing of options available with the knife cookbook subcommand
Figure 6-16. Creating a cookbook
The syntax for this command is as follows:
 
knife cookbook [Argument] (options)
 
We discuss the arguments available in this subcommand one by one in the following 
sections.
Bulk Delete
We use this argument if we want to delete cookbooks that match certain patterns. The 
Regex should be written within quotes.
The syntax for this argument is as follows:
 
knife cookbook bulk delete "REGEX"
Create
We use this argument to create a cookbook in the local repository (see Figure 6-16). It 
will create a list of directories and files necessary for a cookbook. We can then upload the 
cookbook to the chef server.

CHAPTER 6 ■ WORKING WITH KNIFE
73
Figure 6-17. Deleting a cookbook
The syntax for this command is as follows:
 
knife cookbook create COOKBOOK_NAME (options)
 
Delete
We use this subcommand if we want to delete a cookbook or any version of a cookbook 
from the chef server (see Figure 6-17).
The syntax for this command is as follows:
 
knife cookbook delete cookbook_name
 
Download
We use this subcommand to download a cookbook from the chef server (see Figure 6-18).
Figure 6-18. Downloading a cookbook
The syntax for this command is as follows:
 
knife cookbook download COOKBOOK_NAME [COOKBOOK_VERSION] (options) 
List
We use this argument to list the cookbooks that are present on the chef server. It will list 
the latest versions of the cookbooks that are available (see Figure 6-19).

CHAPTER 6 ■ WORKING WITH KNIFE
74
The syntax is as follows:
 
knife cookbook list 
Show
We used this argument to view the information about a cookbook or any file associated 
with the cookbook present on the chef server (see Figure 6-20).
Figure 6-19. Listing cookbooks
Figure 6-20. Viewing a version
The syntax for this argument is as follows:
 
knife cookbook show COOKBOOK_NAME [COOKBOOK_VERSION] [PART...] [FILE_NAME] 
(options) 

CHAPTER 6 ■ WORKING WITH KNIFE
75
Figure 6-21. Testing a cookbook
Figure 6-22. Uploading a cookbook
Test
We use this argument if we want to check a cookbook for syntax errors. This argument 
verifies every file present in the cookbook directory ending with a .rb or a .erb extension.
Figure 6-21 shows the syntax for this argument.
Upload
We require the upload argument if we want to upload any cookbook or associated files 
from the local repository to the chef server (see Figure 6-22).
The syntax for the upload argument is as follows:
 
knife cookbook upload [COOKBOOK_NAME...] (options) 
Cookbook Site
We use this subcommand if we want to directly use the cookbooks that Opscode provides.
The syntax for this command is as follows:
 
knife cookbook site [argument] (options)
 
The following arguments are available in this subcommand:
Download
•฀
Install
•฀
List
•฀
Search
•฀

CHAPTER 6 ■ WORKING WITH KNIFE
76
Share
•฀
Show
•฀
UnShare
•฀
Download
We use this argument if we want to download any cookbook available on the chef server.
This argument has the following syntax:
 
knife cookbook site download COOKBOOK_NAME [COOKBOOK_VERSION] (options)
 
It will download the cookbook in the directory we are working as a tar file. Extract the 
file and upload it to the chef server for further use.
Install
We use this argument if we want to install any cookbook to a local git repository.
Using this argument does the following:
Creates a new branch for tracking the upstream.
•฀
Removes all the previous versions of cookbook from the branch 
•฀
(if any).
Downloads the cookbook from 
•฀
https://cookbooks.opscode.com 
in the tar.gz format.
Untars the downloaded cookbook and commits its contents to git 
•฀
and creates a tag.
Merges the newly created branch into the master branch.
•฀
This process allows the upstream cookbook in the master branch to be modified 
while letting git maintain changes as a separate patch. When an updated upstream 
version becomes available, those changes can be merged while maintaining any local 
modifications.
This argument has the following syntax:
 
knife cookbook site install COOKBOOK_NAME [COOKBOOK_VERSION] (options)
List
It is used to view the list of cookbooks that are available in the community.
This argument has the following syntax:
 
knife cookbook site list

CHAPTER 6 ■ WORKING WITH KNIFE
77
Search
This is used in case we want to search any cookbook available. It will return a list of 
cookbooks that match the search criteria.
The syntax for this argument is as follows:
 
knife cookbook site search SEARCH_QUERY (options)
Show
It can be used to view any information about any cookbook that Opscode provides.
The syntax for this argument is as follows:
 
knife cookbook site show COOKBOOK_NAME [COOKBOOK_VERSION] 
Data Bag
Data bags are objects that are stored as a global variable and can be accessed from the 
chef server. This subcommand allows us to create or edit a data bag or any data bag item 
(see Figure 6-23).
Figure 6-23. List of options available with knife data bag subcommand
The syntax for this command is as follows:
 
knife data bag [Argument] (options) 
Delete
This command is used in case we want to delete any object from the chef server. It can be 
any node, any cookbook, or anything else (see Figure 6-24).

CHAPTER 6 ■ WORKING WITH KNIFE
78
Figure 6-24. List of options available with knife delete subcommand
The syntax for this command is as follows:
 
knife delete [pattern...] (options)
 
This subcommand has the following options:
Download
The download subcommand can be used to download any data that exists on the chef 
server (see Figure 6-25). This data can include cookbooks, nodes, roles, and environments.

CHAPTER 6 ■ WORKING WITH KNIFE
79
The syntax for this command is as follows:
 
knife download [PATTERN...] (options)
Environment
Environments in chef are a way to group nodes in chef. We can have environment-specific 
attributes. The environment subcommand can be used to manage the environments 
that already exist on the chef server or can be used to create new servers also  
(see Figure 6-26).
Figure 6-25. List of options available with the knife download subcommand
Figure 6-26. List of options available with knife environment subcommands

CHAPTER 6 ■ WORKING WITH KNIFE
80
The syntax for this command is as follows:
 
knife environment [Argument] (options)
Node
Any server registered with the chef server can be referred to as a node. The node 
subcommand of knife can be used to manage the nodes that are registered with the chef 
server (see Figure 6-27). It can also be used to create a new node.
Figure 6-27. List of options available with knife node subcommand
The syntax for this command is as follows:
 
knife node [argument] (options)
Recipe List
This subcommand is used to view the recipes that are present on the chef server (see 
Figure 6-28). By default, it will return all the recipes present and we can reduce the 
count by providing a Regex in the search query.

CHAPTER 6 ■ WORKING WITH KNIFE
81
The syntax for this command is as follows:
 
knife recipe list REGEX
Role
Roles are a way to define certain process or patterns. A role is a collection of run list and 
some attributes. For example, a MySQL server role can consist of a MySQL server recipe 
and any custom attributes.
We use the knife subcommand to manage the roles that exist on the chef server 
(see Figure 6-29).
Figure 6-28. List of options available with knife recipe subcommands
Figure 6-29. List of options available with the knife role subcommand

CHAPTER 6 ■ WORKING WITH KNIFE
82
Usage is as follows:
The syntax for this command is as follows:
 
Knife role [Argument] (options)
Search
We use the search command to search the information that is indexed on the chef server 
(see Figure 6-30). Searches can be employed using the management console.
Figure 6-30. List of options available with knife search subcommand
Show
We use the show command if we want to view anything that is stored on the chef server 
(see Figure 6-31).

CHAPTER 6 ■ WORKING WITH KNIFE
83
Figure 6-31. List of options available with knife show subcommand
The syntax for this command is as follows:
 
knife show [PATTERN...] (options)
e.g. – knife show roles,
Knife show cookbooks
SSH
We use this command if we want to invoke parallel SSH commands on a number of 
nodes, based upon a search query (see Figure 6-32).

CHAPTER 6 ■ WORKING WITH KNIFE
84
The syntax for this command is as follows:
 
knife ssh Search_Query SSH_Command (options)
 
Following are the options available with the subcommand:
 
-a SSH_ATTR, --attribute SSH_ATTR
 
We us this option to specify the attributes that would be used for opening SSH 
connections.
 
-C NUM, --concurrency NUM
 
This option is used to specify the maximum number of concurrent connections.
 
-G GATEWAY, --ssh-gateway GATEWAY
 
We use this option if our network has an SSH gateway configured.
 
-i IDENTITY_FILE, --identity-file IDENTIFY_FILE
 
We use this option if we are using key-based authentication.
 
-p PORT, --ssh-port PORT
 
Figure 6-32. List of options available with the knife SSH subcommand

CHAPTER 6 ■ WORKING WITH KNIFE
85
We use this option to specify the port that would be used for SSH. By default, a 22 
port is used.
 
-P PASSWORD, --ssh-password PASSWORD
 
We use this option to pass the password that would be used for SSH into the node.
 
-x USER_NAME, --ssh-user USER_NAME
 
We use this option to pass the username that would be used for SSH.
Tag
We use this subcommand if we want to add a custom description to our nodes on the chef 
server, to group them based on the custom description (see Figure 6-33).
Figure 6-33. List of options available with knife tag subcommands
The syntax for this command is as follows:
 
knife tag [arguments]
 
create—knife tag create 
•฀
NODE_NAME
delete—knife tag delete 
•฀
NODE_NAME
list—knife tag list 
•฀
NODE_NAME

CHAPTER 6 ■ WORKING WITH KNIFE
86
Upload
This subcommand is used to upload anything from the local chef repository to the chef 
server (see Figure 6-34).
Figure 6-34. List of options available with knife upload subcommands
The syntax for this command is as follows:
 
knife upload [Pattern..] (options)
 

87
CHAPTER 7
Cookbooks
This chapter covers different aspects related to cookbooks.
Cookbooks are the fundamental unit of configuration in chef. Cookbooks determine 
what gets deployed on the client.
Basics of Cookbooks
A cookbook is the basic unit of configuration and policy definition in chef. It defines a 
complete scenario for the deployment and configuration of an application.
As an example, a cookbook for Apache or Tomcat would provide all details to install 
and configure a fully configured Apache or Tomcat server.
A complete cookbook is one that contains all the components required to support 
the installation and configuration of an application or component.
It defines the files that need to be distributed for that component 
•฀
onto the client.
It defines the attribute values that should be present on the nodes.
•฀
It provides definitions for reusability of code.
•฀
It provides libraries which can be used to extend the functionality 
•฀
of chef.
It provides recipes that specify the resources and the order of 
•฀
execution of code on the client.
It provides templates for file configurations.
•฀
It provides metadata which can be used specify any kind of 
•฀
dependency, version constraints, and so on.
We use Ruby as the reference library in chef. For writing specific resources we can 
use extended DSL (Domain Specific Language).
Let’s discuss the structure and content of a cookbook in detail.

CHAPTER 7 ■ COOKBOOKS
88
Cookbook Directory Structure
Figure 7-1 shows the typical directory structure of any cookbook.
Figure 7-1. Directory structure of a cookbook
Figure 7-2. Working of a cookbook
The following sections cover all aspects related to the cookbook.
Figure 7-2 shows the working of a cookbook.
Recipes
Recipes are the configuration units in chef that are actually deployed on the client and  
are used to configure the system. They are written in Ruby DSL. Recipes are normally  
a collection of resources with a bit of Ruby code.

CHAPTER 7 ■ COOKBOOKS
89
A recipe
Helps in configuring the nodes.
•฀
Is stored in a cookbook.
•฀
Can be used in any other recipe.
•฀
Is authored in Ruby.
•฀
Is executed in a top-down approach.
•฀
Working with Recipes
In this section we discuss the various approaches that are useful while creating recipes.
Using Data Bags in a Recipe
Data bags are a global JSON (JavaScript Object Notification) 
•฀
variable that can store any kind of data but are normally used to 
store passwords. We can access data bags from the chef server. 
Chef also indexes them so that they can be easily accessed.
The content of a data bag can be used within a recipe. Figure 
•฀
7-3 
shows what the data inside a data bag looks like.
Figure 7-3. Contents of a data bag
We can access the created data bag in the recipe using the following syntax:
 
item = data_bag_item("application", "my_application")
 
where application is the name of the data bag and my_application is the object name.
We can use a Ruby hash to access data bag items.
 
item["repository"]  #=> "git://github.com/test/my_application.git"
 
We can also create a data bag using knife as shown in Figure 7-4.

CHAPTER 7 ■ COOKBOOKS
90
Encrypting Data Bag items
Any item created in a data bag is not encrypted by default, but for creating any sort of 
secured environment we should encrypt our data bag items. We can achieve the same by 
creating a secret key. Here we use open SSL to create a secret key.
 
openssl rand –base64 512 | tr –d '\r\n' > Secret_key
 
The foregoing command will create a secret key named Secret_key by generating a 
random number. 
Store Keys on Nodes
We can store the encryption key in a file and copy the file to the node that requires it  
(see Figure 7-5). We need to pass the location of the file inside an attribute.
Figure 7-4. Creating a databag
Figure 7-5. Storing keys
The EncryptedDataBagItem.load method expects the secret key as the third 
argument; we can use EncryptedDataBagItem.load_secret to use the secret file contents 
and then pass them.
Using Search Results in a Recipe
Chef server maintains an index of your data (environments, nodes, roles). Search index 
easily allows you to query the data that is indexed and then use it within a recipe.
There is a specified query syntax that supports range, wildcard, exact, and fuzzy. 
Search can be done from various places in chef; it can be within a recipe, it can be 
from the management console. 
The search engine in a chef installation is based on Apache Solr.

CHAPTER 7 ■ COOKBOOKS
91
We can use the result of a search query in a recipe. The following code shows an 
example of using a simple search query in a recipe:
 
search(:node, "attribute:value")
 
The result of a search query can be stored in variable and then can be used anywhere 
within a recipe. 
The search query in Figure 7-6 will return the servers with the role dbserver and then 
will render the template for all those servers.
Figure 7-6. Searching in a recipe
Use Ruby in Recipes
Recipes are written in Ruby, so anything that can be done within Ruby can be done within 
a recipe. We cover some of the important concepts in the following sections.
Assign a Value to a Variable
We use the ‘=’ operator to assign a value. 
The following code shows an example of the ‘=’ operator.
 
package_name = "apache2"
 
It will create a variable named package_name with value “apache2”.
Using the Case Statement
We use the case statement when we need to compare an expression and, based upon it, 
execute certain code. 
Figure 7-7 shows a piece of code that demonstrates the use of case statement within 
a recipe.

CHAPTER 7 ■ COOKBOOKS
92
Check for a Condition
We use the ‘if’ expression to check the ‘true or false’ condition in a chef recipe.
Figure 7-8 shows a piece of code that checks if the node platform is Ubuntu or 
Debian and will execute the code accordingly.
Figure 7-8. Checking for a condition
Figure 7-9. Using ‘unless’ statement
Figure 7-7. Using case statement
Unless Expression
We use the ‘unless’ expression to execute a piece of code when the result is FALSE. 
Figure 7-9 shows an example. If the platform version is anything other than 5.0, then 
the code will be executed.
Include Recipes in Recipes
A recipe can be included in any other recipe by using the include_recipe keyword. 

CHAPTER 7 ■ COOKBOOKS
93
The resources of the recipe that is included will be executed in the same order in 
which they appear in the original recipe. A recipe can be included in another recipe using 
the following syntax:
 
include_recipe "apache2::mod_ssl"
 
We can include a recipe within a recipe any number of times, but it will be processed 
only for the first time and after that it will be ignored.
Apply Recipes to Run List
If we need to apply any recipe then it needs to be added to the run list using a suitable 
name which is defined by the cookbook directory structure. 
For example, a cookbook might have the following structure:
 
cookbooks/
        mysql/
                recipes/
                        default.rb
                        server.rb
 
One is the default recipe which has the same name as that of the cookbook and other 
recipe is server.rb. Figure 7-10 shows the syntax of a run list.
Figure 7-10. Specifying the run list
Exception Handlers and Log Files
We can write the output of a recipe to a log file. This can be achieved using the Chef::Log. 
There can be various levels of logging which include debug, warn, info, fatal, and error.
The following code can be used to capture some information:
 
Chef::Log.info('some useful information')
Tags
A tag describes a node in a customized way and then we can group our nodes based on 
that description.

CHAPTER 7 ■ COOKBOOKS
94
You can check whether or not your machines have a tag. You can also add or remove 
tags at any point by using the following command. 
 
tag('mytag')
 
Tagging can be done using various modes including from knife and from within a 
recipe. We can use the following code to check whether or not a machine is tagged:
 
tagged?('mytag')
 
To return true or false use
 
tagged?[array of nodes]
 
We can use the following untag command to remove the tag from any node:
 
untag('mytag')
 
See Figure 7-11 for an example.
Figure 7-11. Example
The output would be as follows:
 
[Wed, 12Jul 2014 22:23:45 +0000] INFO: Hey I'm a server
[Wed, 12 Jul 2014 22:23:45 +0000] INFO: I don't have a tag.
Recipe DSL
Recipe DSL is mainly Ruby DSL and we use it to declare resources within a recipe. 
We use the methods in the recipe DSL to find out the value of a specific parameter, 
and then, based on that value, chef takes an action. Anything that can be done with Ruby 
can be done in a recipe.

CHAPTER 7 ■ COOKBOOKS
95
We can use attributes, search results, and data bags in the recipe DSL. We can also 
use the helper methods available. The helper methods are
•฀
platform?
•฀
platform_family?
•฀
value_for_platform
•฀
value_for_platform_family
Let’s discuss these four helper methods in detail.
Platform?
We use Ohai to detect the value of the node[‘platform’] parameter during every chef run. 
We use the platform method in a recipe to run platform-specific actions.
We can use the “platform” method in a recipe with the following syntax:
 
platform?("parameter","parameter")
 
We can provide one or more than one parameter in a comma-separated list. Typically, 
we use this method along with conditional Ruby (Case, if, or elseif) (e.g., see Figure 7-12).
Figure 7-12. Using platform? method in a recipe
With this method we can create a single cookbook which can be used on multiple 
operating systems (OSs).
platform_family?
We use the platform_family? method when we want to execute some actions for a specific 
platform family. We use Ohai to detect the platform_family? attribute. The actions will be 
executed if one of the listed parameters matched the node['platform_family'].
We can use it in the recipe with the following syntax:
 
platform_family?("parameter","parameter")
 
We can provide more than one value of parameters using a comma-separated list.
We also use this method along with conditional Ruby, so that a single cookbook is 
used on multiple platforms (e.g., see Figure 7-13).

CHAPTER 7 ■ COOKBOOKS
96
Figure 7-13. Using platform_family? method in a recipe
Figure 7-14. Using value_for_platform? method in a recipe
Figure 7-15. Using value_for_platform? method in a recipe
value_for_platform?
We use this method in a recipe with a hash of a particular value based on node['platform'] 
and node['platform_version']. Ohai provides the value during each chef run.
We can use it in the recipe with the following syntax:
 
value_for_platform( ["platform"] => { ["version"] => value } )
 
We can provide one or more than one value for platform in a comma-separated list, 
and version specifies the version of that platform.
If each value only has a single platform, then the syntax is as shown in Figure 7-14.
It there is more than one platform, the syntax will be as shown in Figure 7-15. 

CHAPTER 7 ■ COOKBOOKS
97
The code shown in Figure 7-16 will set the value of package_name variable as httpd if 
that platform is CentOS or Red Hat and Apache2 if platform is Debian or Ubuntu.
Figure 7-16. Using value_for_platform? method in a recipe
value_for_platform_family?
We use this method in a recipe with a hash to select value based on node 
['platform_family'] attribute detected by Ohai. 
We can use it in a recipe with the following syntax:
 
value_for_platform_family({ platform_family => value })
 
We can provide one or more than one platform_family using a comma-separated list.
If there is a single platform for each value, then the syntax is as shown in Figure 7-17.
Figure 7-17. Using value_for_platform_family? method in a recipe
If the value has more than one platform, then the syntax is as shown in Figure 7-18.

CHAPTER 7 ■ COOKBOOKS
98
The code shown in Figure 7-19 will set the value of the package variable to  
httpd-devel if the platform_family is Red Hat or Fedora or Suse and the value would  
be “apache-dev” if the platform_family is Debian.
Figure 7-18. Using value_for_platform_family? method in a recipe
Figure 7-19. Using value_for_platform_family? method in a recipe
Resources and Providers
Resources are the chunks of Ruby blocks that you declare in your recipe and that actually 
help in configuring the system. A resource helps us to define the actions that we want our 
recipe to do. These actions can be anything like installing a package or starting a service. 
The action is completed with the help of a provider. 
During a chef run the resources are identified and mapped to a provider. The provider 
then executes that action. The resources define the current state of system and the state in 
which we want the system to be. Providers are used to define the steps to bring the system 
into that state.
An action is decoupled from the steps required to complete that action, which means 
that a provider exists for each of the paths that are required to complete the action. This is 
important because a single action may require different steps, depending on the platform 
of the system on which the action is being taken.
For example, “install a package” is a single action. To install a package onto various 
platforms, the steps required for each of those platforms may be different and may 
require different providers. On a Red Hat or CentOS machine a provider will use the Yum 
package provider to get the package installed and on a Debian or an Ubuntu machine, a 
provider will use the APT package installer.

CHAPTER 7 ■ COOKBOOKS
99
The Chef::Platform class maps providers to platforms (and platform versions). 
We use Ohai to get the information about the platform. Based upon that data we can 
identify the correct provider and then execute the action.
For example, see the resource shown in Figure 7-20.
Figure 7-20. Example of a resource
Resources Syntax
A resource has four components.
Type
•฀
Name
•฀
Attribute (one or more)
•฀
Action (one or more)
•฀
The syntax for a resource is as follows:
 
type "name" do
        attribute "value"
        action :type_of_action
end
 
The code in Figure 7-21 can be used to install version 1.16.1 of the tar package.
Figure 7-21. Example of a resource used for installing a package

CHAPTER 7 ■ COOKBOOKS
100
There are predefined actions and attributes for each resource in chef and there is a 
default value for most of the attributes.
Some attributes are available to all resources; these are sometimes referred to as 
“meta” attributes and they are commonly used to send notifications to other resources or 
to set up conditional execution rules. 
There is a default value for each action. We need to specify only the nondefault 
behaviors of actions and attributes.
Attributes associated with resources are not the same as attributes associated with 
nodes.
Resources
We can use a number of inbuilt chef resources in configuration. We discuss some of the 
important chef resources here.
Cookbook_file
We use this resource if we want to transfer any file with our cookbook. It transfers the files 
available in the files/default subdirectory of the cookbook to any specified path. We can 
use this resource on any platform.
We can use the cookbook_file resource in a recipe as shown in Figure 7-22.
Figure 7-22. Using the cookbook_file resource
For example,
 
cookbook_file "test" do
  path "/root/test"
  action :create
end
 
This would copy the test file to /root/test.
where
•฀
cookbook_file is an inbuilt chef resource and it will use 
Chef::Provider::CookbookFile provider during the chef run.
“name” is used to specify the name with which the file will be 
•฀
stored on the node.

CHAPTER 7 ■ COOKBOOKS
101
attribute is used to provide any attributes that are available with 
•฀
this resource.
action is the execution that will be done on the node.
•฀
The following actions are available with this resource: 
Create: This is the default action. We use it to create a file.
•฀
Create_if_missing: We use this action when we need to create a 
•฀
file only when it doesn’t already exist.
Delete: We use this action if we want to delete a file.
•฀
There are many attributes available with the resource. Some of the important 
attributes are
Backup. We use this attribute to specify the number of backups 
•฀
that should be kept for a file. The default value is 5.
Cookbook. We use this attribute to specify the name of the 
•฀
cookbook, if the file is present in some other cookbook.
Path. We use this attribute to specify the path of the file.
•฀
cron
We use this resource to manage the cron entries. This resource requires access to a 
crontab program to work properly.
We can use the cron resource can be used in a recipe as shown in Figure 7-23.
Figure 7-23. Using the cron resource
For example,
 
cron "test" do
  hour "3"
  minute "30"
  command "/bin/test"
end        
 

CHAPTER 7 ■ COOKBOOKS
102
This would run a program at the specified interval.
where
cron is an inbuilt chef resource and it will use the 
•฀
Chef::Provider::Cron provider during the chef run.
“name” is used to provide the name with which the cron entry will 
•฀
be created.
attribute is used to provide one or more attributes that the 
•฀
resource will use.
action is the actual execution that will be done on the node.
•฀
The following actions are available in the cron resource: 
Create: We use this action to create in the crontab file.
•฀
Delete: We use this action to delete any entry from the  
•฀
crontab file.
Some of the important attributes available with the cron resource are:
Day: We use this option to specify the day of the month on which 
•฀
the job should run. The options available are 1–31.
Hour: We use this option to specify at which hour (0–23) your job 
•฀
should run. Ute
Minute: We use this option to specify the minute (0–59) at which 
•฀
the cron entry should run.
Weekday: We use this option to specify the day of the week on 
•฀
which your job should run. The value can vary from 0–6 where  
0 = Sunday.
Directory
We use this resource to manage a directory. Chef should have the permission to the 
directory that will be managed.
We can use the directory resource in a recipe with the syntax shown in Figure 7-24.
Figure 7-24. Using the directory resource

CHAPTER 7 ■ COOKBOOKS
103
where
directory is an inbuilt chef resource and it will use the 
•฀
Chef::Provider::Directory provider during the chef run.
“name” is used to provide the complete path to the directory.
•฀
attribute is used to provide one or more attributes that the 
•฀
resource will use.
action is the actual execution that will be done on the node.
•฀
The following actions are available in the directory resource: 
Create: We use this action to create any directory.
•฀
Delete: We use this action to delete any directory.
•฀
Some of the important attributes available with this resource are
Mode: We use the mode attribute to set the permission of the 
•฀
directory. We need to specify the permissions in octal mode.
Owner: We use the owner attribute to specify the user who will be 
•฀
the owner of that directory.
Recursive: The value for this attribute can be true or false. We use 
•฀
it to specify whether the directory created or deleted will be done 
recursively or not.
env
The env resource is a Windows-specific resource and we use it to manage environment 
variables.
We can use the env resource in a recipe with the syntax shown in Figure 7-25.
Figure 7-25. Using the env resource

CHAPTER 7 ■ COOKBOOKS
104
For example,
 
env "Test" do
  value "C:\\test\\test.exe"
end
 
It would create an environment variable named Test with the provided value.
where
env is an inbuilt chef resource and it will use the 
•฀
Chef::Provider::env provider during the chef run.
“name” is used to provide the name with which the variable will 
•฀
be created.
attribute is used to provide one or more attributes that the 
•฀
resource will use.
action is the actual execution that will be done on the node.
•฀
The following actions are available in this resource:
Create: We use this action if we want to create a new environment 
•฀
variable.
Delete: We use this action if we want to delete any environment 
•฀
variable.
Modify: We use this action in case we want to edit an environment 
•฀
variable that already exists.
Some of the important attributes available with this resource are
•฀
Delim: We use this attribute to specify the delimiter that will be 
used to separate multiple values.
•฀
Key_name: We use this attribute to specify the name of the key 
which be managed.
•฀
Value: We use this attribute to set the value of key_name.
execute
We use the execute resource in case we want to execute a command. Idempotency is not 
maintained by this resource by default. If we want to maintain the idempotency we need 
to use the not_if and only_if parameters.
We can use the execute resource in a recipe with the syntax shown in Figure 7-26.

CHAPTER 7 ■ COOKBOOKS
105
For example,
 
execute "environment" do
  command "source /etc/environment"
end
 
This would reload the /etc/environment file.
where
execute is an inbuilt chef resource and it will use the 
•฀
Chef::Provider::execute provider during the chef run.
“name” is used to provide the name of the command that will run.
•฀
attribute is used to provide one or more attributes that the 
•฀
resource will use.
action is the actual execution that will be done on the node.
•฀
The following actions are available with this resource:
Run: This is the default action and it indicates that the command 
•฀
should run.
Nothing: This action specifies that the command should not run 
•฀
directly but should run only if some other resource specifies it.
Some of the important attributes available with this resource are
Command: The command that will be executed.
•฀
Cwd: We use this option if we want a command to be executed 
•฀
from a certain directory.
Environment: We use this option to set the environment variable 
•฀
that will be set before running the commands.
Timeout: We use this option to specify the time a command will 
•฀
wait before timing out.
User: We use this option to specify the user with which the 
•฀
command should run.
Figure 7-26. Using the execute resource

CHAPTER 7 ■ COOKBOOKS
106
file
We use this resource in case we need to manage the files that are present on a node.
We can use the file resource in a recipe (as shown in Figure 7-27).
Figure 7-28. Using the file resource
Figure 7-27. Using the file resource
where
file is an inbuilt chef resource and it will use the 
•฀
Chef::Provider::file provider during the chef run.
“name” is used to provide the name of the file.
•฀
attribute is used to provide one or more attributes that the 
•฀
resource will use.
action is the actual execution that will be done on the node.
•฀
The screenshot in Figure 7-28 shows how we can use the file resource. 
The following actions are available in the file resource:
Create: This is the default action and we use it to create a file.
•฀
create_if_missing: We use this action in case we want to create a 
•฀
file only if it is not present.
Delete: We use this action to delete a file.
•฀
Touch: We use this action to update the access and the file 
•฀
modification time for a file.

CHAPTER 7 ■ COOKBOOKS
107
Some of the important attributes available with this resource are
Backup: We use this attribute to specify the number of backups 
•฀
that should be kept for a file.
Content: We use this attribute to specify the string that will be 
•฀
written to a file.
Path: We use this attribute to specify the complete path of the file.
•฀
package
We use this resource to manage packages. The resource uses the native functionality of 
the OS to install the packages on the nodes. Although there are OS-specific chef resources 
that can be used to manage packages, we recommend using the package resource 
wherever possible.
We can use the package resource in a recipe with the syntax shown in Figure 7-29
Figure 7-29. Using the package resource
where
package is an inbuilt chef resource and it will use the 
•฀
Chef::Provider::package provider during the chef run.
“name” is used to provide the name of the package.
•฀
attribute is used to provide one or more attributes that the 
•฀
resource will use.
action is the actual execution that will be done on the node.
•฀
The following actions are available with the package resource:
Install: This is the default action and we use it to install any 
•฀
package.
Upgrade: We use this action in case we want to upgrade any 
•฀
package to the latest version.
Reconfig: We use this action in case we want to reconfigure any 
•฀
package. There should be a response file for this action.

CHAPTER 7 ■ COOKBOOKS
108
Remove: We use this action in case we want remove any installed 
•฀
package.
Purge: We use this action if we want to purge a package. If used, it 
•฀
will remove the package as well as the configuration file related to 
the package.
Some of the important attributes that are available with this resource are
•฀
Flush_cache: We use this attribute if we want to flus the yum 
cache before or after any installation.
•฀
Package_name: We use this option to specify the name of the 
package to be installed.
Source: This is an optional attribute and we use it to specify the 
•฀
source for providers that use a local file.
Version: We use this option if we want to install any specific 
•฀
version of a package.
powershell_script
This is a Windows-specific resource. We use this resource if we want execute a script 
using powershell. This resource is similar to many chef resources with small tweaks. 
This resource will create a temporary file rather than running it inline. The commands 
executed with this resource are not idempotent by default; we can use the not_if and 
only_if meta parameters to maintain the idempotency.
We can use the powershell_script resource in a recipe with the syntax shown in 
Figure 7-30.
Figure 7-30. Using the powershell_script resource
where
powershell_script is an inbuilt chef resource and it will use the  
•฀
Chef::Provider::PowershellScript provider during the chef run.
“name” is used to provide the name of the PowerShell Script.
•฀

CHAPTER 7 ■ COOKBOOKS
109
attribute is used to provide one or more attributes that the 
•฀
resource will use.
action is the actual execution that will be done on the node.
•฀
The screenshot in Figure 7-31 shows how to use the powershell_script resource.
Figure 7-31. Using the powershell_script resource
Figure 7-32. Using the remote_file resource
The following actions are available in the powershell_script resource:
Run: This is the default action. It will run the specified script.
•฀
Nothing: We use this action if we do not want the resource to be 
•฀
executed directly.
Some of the important attributes available with this resource are
Code: We use the attribute to specify the set of commands to be 
•฀
executed.
Command: We use this attribute to specify the name of the 
•฀
command to execute.
Flags: We use this option to pass the command line flags.
•฀
remote_file
We use this resource if we want to transfer a file from a remote location to the node.  
The functioning of this resource is similar to that of the file resource.
We can use it in a recipe with the syntax shown in Figure 7-32

CHAPTER 7 ■ COOKBOOKS
110
where
remote_file is an inbuilt chef resource and it will use the 
•฀
Chef::Provider::RemoteFile provider during the chef run.
“name” is used to provide the name and location of the  
•฀
remote file.
attribute is used to provide one or more attributes that the 
•฀
resource will use.
action is the actual execution that will be done on the node.
•฀
The screenshot in Figure 7-33 shows how we can use this resource in a recipe.
Figure 7-33. Using the remote_file resource
The following actions are available in the remote_file resource:
Create: We use this action to download the file from the remote 
•฀
source to the node.
Create_if_missing: We also use it to download the file from the 
•฀
remote source to the node but only if the file is missing.
Some of the important attributes available with this resource are
Backup: We use this attribute to specify the number of backups 
•฀
that should be kept for the file.
Checksum: This is an optional setting and we use it if we don’t 
•฀
need the file to be downloaded again. It will check the checksum.
Source: We use this attribute to specify the source from which the 
•฀
file should be downloaded.
script
We use this resource to execute the scripts. We can choose the interpreter we want to use. 
It creates a temporary file and executes the file rather than running it inline.
The commands that are executed by this resource are not idempotent by nature; to 
maintain idempotency we need to use the not_if and only_if meta parameters.
We can use script in a recipe with the syntax shown in Figure 7-34

CHAPTER 7 ■ COOKBOOKS
111
where
script is an inbuilt chef resource and it will use the 
•฀
Chef::Provider::Script provider during the chef run.
“name” is used to provide the name with which the script will run.
•฀
attribute is used to provide one or more attributes that the 
•฀
resource will use.
action is the actual execution that will be done on the node.
•฀
The following actions are available with this resource:
Run: This is the default action and it indicates that the command 
•฀
should run.
Nothing: This action specifies that the command should not run 
•฀
directly but should run only if some other resource specifies it.
Some of the important attributes available with this resource are
Command: The command that will be executed.
•฀
Cwd: We use this option if we want a command to be executed 
•฀
from a certain directory.
Environment: We use this option to set the environment variable 
•฀
that will be set before running the commands.
Timeout: We use this option to specify the time a command will 
•฀
wait before timing out.
User: We use this option to specify the user with which the 
•฀
command should run.
service
We use this resource to manage any service on a node.
The syntax for using the service resource in a recipe is shown in Figure 7-35.
Figure 7-34. Using the script resource

CHAPTER 7 ■ COOKBOOKS
112
where
service is an inbuilt chef resource and it will use the provider 
•฀
based on the OS of the node.
“name” is used to provide the name of the service.
•฀
attribute is used to provide one or more attributes that the 
•฀
resource will use.
action is the actual execution that will be done on the node.
•฀
The following actions are available with this resource:
Enable: We use this action if we want to enable a service  
•฀
on startup.
Disable: We use this action to disable a service.
•฀
Start: We use this action to start a service.
•฀
Stop: We use this action to stop a service.
•฀
Restart: We use this action to restart a service.
•฀
Reload: We use this action to reload the configuration files  
•฀
for a service.
Some of the important attributes available with this resource are
Reload_commmand: The command that will be used to reload 
•฀
the service.
Restart_command: The command that will be used to restart  
•฀
the service.
Service_name: The name of the service that will be managed.
•฀
Start_command: The command that will be used to start  
•฀
the service.
Stop_command: The command that will be used to stop  
•฀
the service.
Figure 7-35. Using the service resource

CHAPTER 7 ■ COOKBOOKS
113
Template
We use this resource if we want to manage the contents of a file. It stores files in an 
erb (Embedded Ruby) template. We normally store templates in the template/default 
available in the cookbook subdirectory.
We can use the template resource in the recipe as shown in Figure 7-36.
Figure 7-36. Using the template resource
For example,
 
template "/etc/nginx.conf" do
  source "nginx.conf.erb"
end
 
We use this resource to configure a file from a template
where
template is an inbuilt chef resource and it will use the 
•฀
Chef::Provider::Template provider during the chef run.
“name” is used to provide the name of the template file.
•฀
attribute is used to provide one or more attributes that the 
•฀
resource will use.
action is the actual execution that will be done on the node.
•฀
Following are the actions that are available with this resource:
Create: This is the default action and we use it to create a file.
•฀
Create_if_missing: This action will create a file if the file doesn’t exist.
•฀
Some of the important attributes available with this resource are
Backup: We use this option to specify the number of backups that 
•฀
should be kept for a file.
Path: We use this attribute to provide the complete path to the file.
•฀
Source: We use this option to specify the location of the source file.
•฀
Variable: We use this option to provide variables in the template file.
•฀

CHAPTER 7 ■ COOKBOOKS
114
Attributes Files
Attribute are used to override the settings on any node. During each chef run, the 
attributes on a node are compared to those in the cookbook and then, depending upon 
the precedence level, the settings are done.
The attribute file is located in the attributes subdirectory of the cookbook. During 
each chef run, the attributes in the attributes files are evaluated against the node object.
For example, the mysql cookbook contains the following attribute file (called 
default.rb):
 
default["mysql"]["data_dir"]          = "/opt/local/lib/mysql"
default["mysql"]["port"] = ""3306"
 
The use of the node object is implicit here. The following example is equivalent to 
the previous one:
 
node.default["mysql"]["data_dir"]          = "/etc/apache2"
node.default["mysql"]["port"] = '3306'
 
Chef server keeps the attributes indexed so that they are easy to access.
Attributes Types
The following types of attributes are available:
Default
•฀
Force_default
•฀
Force_override
•฀
Normal
•฀
Override
•฀
Automatic
•฀
Attributes Methods
Various attribute methods can be used in the attribute files of the cookbook or directly in 
a recipe. The various attribute methods that are available are
Override
•฀
Default
•฀
Normal
•฀
There is one more method, attribute?, that is available and is used to check the 
value of an attribute.
We can use the attribute?() method  in an attributes file as shown in Figure 7-37.

CHAPTER 7 ■ COOKBOOKS
115
Similarly, we can use it in a recipe as shown in Figure 7-38.
Figure 7-37. Using attributes
Figure 7-38. Using attributes in recipes
Precedence
During a chef run, saved attributes are retrieved from the chef server and are merged 
with the attributes on the local system. The attribute type and the source of the attribute 
determine which attribute values have priority over others.
In general, use the default attributes as much as possible (or even all the time). 
The merge order for attribute precedence will do most of the work, yet leaving many 
levels of precedence available for the situations in which they are truly necessary.
Attribute values are applied in the following order (from low to high priority): 1 being 
the lowest and 15 being the highest.

CHAPTER 7 ■ COOKBOOKS
116
In other words, an automatic attribute takes precedence over a forced override 
attribute, a forced override attribute takes precedence over an override attribute, an 
override attribute takes precedence over a normal attribute, and so on.
Definitions
Definitions are used to create new resources by combing the existing resources. Usually 
we use definitions when we are repeating a pattern of resources. Definition is not a 
resource or a lightweight resource but is actually a collection of two or more resource 
declarations.
There is a separate directory where we create definitions.
A definition is never declared into a cookbook. 
There are mainly three components of a definition.
The name of the resource.
•฀
The arguments (one or more than one) that will be used to set the 
•฀
value for the parameters.
A hash that would be used to accessing parameters and  
•฀
their values.
If we do not set any value for a parameter, we use the default value.
The syntax of a definition is as shown in Figure 7-39.
Figure 7-40. Using definitions
Figure 7-39. Using definitions
Figure 7-40 shows an example of a definition with name apache_site with ‘action’ as 
a parameter and ‘enable’ as its argument.  

CHAPTER 7 ■ COOKBOOKS
117
Libraries
A library is a way to increase chef functionality. We can implement a Ruby class directly 
and then use it in our recipe. There is a separate directory for library where we create 
libraries. A library once defined is available to be used anywhere in the cookbook. 
The basic syntax of a library is shown in Figure 7-41.
Figure 7-41. Defining libraries
Figure 7-42. Using libraries
Figure 7-43. Creating a library
This syntax can be used in a recipe with the code shown in Figure 7-42.
For example, we could create a simple library that extends Chef::Recipe::,  
as shown in Figure 7-43.

CHAPTER 7 ■ COOKBOOKS
118
We can use this library in a recipe as shown in Figure 7-44.
Figure 7-44. Using Library in recipe
Figure 7-45. Metadata
Metadata
We use metadata to store certain information about the cookbook. We use the file 
metadata.rb to provide this information. The file is located in the cookbook directory.
The following things can be specified in the cookbook. Figure 7-45 shows the 
metadata file of the build-essential cookbook.
A metadata can be used to specify the following important things:
Dependencies: If the cookbook is dependent on any other 
•฀
cookbook.
Description: What is the cookbook actually doing.
•฀
Supported OS list.
•฀
Name of the cookbook.
•฀
Version of the cookbook.
•฀

119
CHAPTER 8
Using Cookbooks
In the previous chapter, we discussed the important components related to a cookbook. 
In this chapter we use some cookbooks available from the community. We download and 
deploy these cookbooks on a node. We have picked up important cookbooks from the 
community and will try to explain exactly how to use them.
MySQL(4.1.2)
This program installs and configures the MySQL client or server. Different recipes are 
defined for installing and configuring the MySQL server on different platform machines.
Platform
The following platforms support this cookbook:
Debian/Ubuntu
•฀
CentOS 5.x,6.x, Red Hat 5.x,6.x, Fedora(18.x,19.x,20.x)
•฀
Mac OS X (Using homebrew)
•฀
Dependencies
Requires Opscode’s OpenSSL cookbook for secure password 
•฀
generation.
Prerequisite
Client machine must have a running Internet connection.
•฀
Cookbook Download
You can download the cookbook on the workstation in your corresponding cookbooks 
directory, inside your chef repo, on your knife workstation from the Opscode community 
web site (see Figure 8-1), by running the following command on your knife workstation:
 
Knife cookbook site download mysql
 

CHAPTER 8 ■ USING COOKBOOKS
120
The downloaded cookbook will be in '.tar.gz'. The cookbook can be extracted 
from here (see Figure 8-2).
Figure 8-1. Download MySQL cookbook from Opscode community
Figure 8-2. Extracting the cookbook
Once we extract the cookbook, we can move to the next step of uploading the 
cookbook to the chef server.
Cookbook Upload
For setting up a MySQL server on a node, we first have to set the attribute values 
according to our setup. Certain attributes need to be changed before running the chef 
client on the node.
In your chef repo directory on your knife workstation, go to the cookbooks folder and 
open the MySQL cookbook directory, open 'attributes/server.rb' file in the editor of 
your choice. Set the values for the following attributes:
Default ['mysql']['port'] = 3306 (or any other as per your 
settings)

CHAPTER 8 ■ USING COOKBOOKS
121
In the 'attributes/server_rhel.rb', set the values for following attributes:
default 
•฀
['mysql']['server']['basedir'] = '/usr'
default 
•฀
['mysql']['server']['tmpdir'] = ['/tmp']
default 
•฀
['mysql']['server']['directories']['run_dir']  
= '/var/run/mysqld'
default 
•฀
['mysql']['server']['directories']['log_dir']  
= '/var/lib/mysql'
default 
•฀
['mysql']['server']['directories']['slow_log_dir']  
= '/var/log/mysql'
default 
•฀
['mysql']['server']['directories']['confd_dir']  
= '/etc/mysql/conf.d'
default 
•฀
['mysql']['server']['service_name'] = 'mysqld'
default 
•฀
['mysql']['server_root_password'] = 'rootpass'
You upload the cookbook (see Figure 8-3) to the chef server using knife (see Figure 8-3). 
Once you upload the cookbook (along with its dependencies), you can add it to the run list of 
the node.
 
Knife cookbook upload mysql 
Figure 8-3. Uploading the cookbook
Client Run
For the purpose of this book, a node ‘chef testing’ has been preconfigured and is 
utilized here.
Add the recipe to the run list of the node from your knife workstation (see Figure 8-4), 
and run chef client on the configured node.
Figure 8-4. Adding cookbook to the run list

CHAPTER 8 ■ USING COOKBOOKS
122
Knife node run_list add node_name ‘recipe[mysql]’
Now, we run the chef client on the configured node (see Figure 8-5).
Figure 8-5. Running chef client
Figure 8-6. Creating log directory for MySQL
Figure 8-7. Creating MySQL configuration file

CHAPTER 8 ■ USING COOKBOOKS
123
After the client run has been ended (see Figure 8-10), we can check on the specified 
port to see whether the MySQL service is running (see Figure 8-11).
 
lsof –i :3306
 
Figure 8-8. Updating the content of my.conf (from template)
Figure 8-9. Starting MySQL service and setting root password

CHAPTER 8 ■ USING COOKBOOKS
124
Once the cookbook has been converged and all the resources have been updated, 
you can access your MySQL database admin by logging in as user 'mysql'.
Figure 8-12 is a snapshot of the '/etc/mysql_grants.sql' file which sets the 
password for the root user and also specifies other grant table permissions.
Figure 8-12. Mysql_grants file
Figure 8-10. Chef client run end
Figure 8-11. Checking MySQL service

CHAPTER 8 ■ USING COOKBOOKS
125
You can see the password you specified in the attributes. Now you can log in to the 
MySQL console using this password and user as root (see Figure 8-13).
 
mysql –u root –p 'your_password_here' 
Figure 8-13. Log in to the MySQL console
Nginx(2.4.2)
Platform
This cookbook is supported on the following platforms:
Ubuntu 10.04, Ubuntu 12.04
•฀
CentOS 5.8, 6.3
•฀
Dependencies
The following cookbooks are direct dependencies because they’re used for common 
“default” functionality:
Build essential (for 
•฀
nginx::source)
Ohai (for 
•฀
nginx::ohai_plugin)
Prerequisite
Client machine must have a running Internet connection.
•฀

CHAPTER 8 ■ USING COOKBOOKS
126
Cookbook Download
You can download the cookbook (see Figure 8-14) in your corresponding cookbooks 
directory inside your chef repo on the workstation, from the Opscode community web 
site, by running the following command on your knife workstation:
 
knife cookbook site download nginx 
Figure 8-14. Downloading the cookbook
Figure 8-15. Extracting the cookbook
The downloaded cookbook will be in '.tar.gz'. You can extract the cookbook from 
here (see Figure 8-15).
 
tar –xvf nginx-2.5.0.tar.gz 

CHAPTER 8 ■ USING COOKBOOKS
127
Client Run
Add the recipe to the run list of the node from your knife workstation, and run chef client 
on the configured client node.
 
knife node run_list add node_name 'recipe[nginx]'
 
Once you extract the cookbook, we can move to the next step of uploading the 
cookbook to the chef server.
Cookbook Upload
Edit the following configuration attributes on your cookbook and upload them to the chef 
server once again, before running the chef client.
In your chef repo directory on your knife workstation, go to the cookbooks folder and 
open Nginx cookbook directory and open 'attributes/default.rb' file in the editor of 
your choice. Set the values of the following attributes (these are the values used for the 
purpose of this book) according to your settings:
default 
•฀
['nginx']['dir']          = '/etc/nginx'
default 
•฀
['nginx']['script_dir']   = '/usr/sbin'
default 
•฀
['nginx']['log_dir']      = '/var/log/nginx'
default 
•฀
['nginx']['binary']       = '/usr/sbin/nginx'
default 
•฀
['nginx']['default_root'] = '/var/www/nginx-
default'
default 
•฀
['nginx']['upstart']['foreground'] = true
default 
•฀
['nginx']['pid'] = '/var/run/nginx.pid'
We upload the cookbook to the chef server using knife (see Figure 8-16). Once 
you upload the cookbook (along with its dependencies), you can add it to the run list 
of the node.
 
knife cookbook upload nginx 
Figure 8-16. Uploading the cookbook

CHAPTER 8 ■ USING COOKBOOKS
128
There’s some redundancy in that the config handling hasn’t been separated from the 
installation method (yet), so use only one of the recipes, default or source.
For the purpose of this book, we have used the default recipe. Run the chef client on 
the node.
Chef client (see Figures 8-18 – 8-21)
Figure 8-18. - Creating ohai_plugins directory
Figure 8-19. Setting up directory permissions and merging into node attributes
Figure 8-17. Adding the recipe to the run_list

CHAPTER 8 ■ USING COOKBOOKS
129
Figure 8-20. Creating and updating content of epel definition file in /etc/yum.repos.d
Figure 8-21. Enabling the epel repository
Now, the code to install and configure Nginx will run and all the required directories 
and configuration files will be created. (see Figures 8-22 – 8-29).
Figure 8-22. Creating and configuring directory settings

CHAPTER 8 ■ USING COOKBOOKS
130
Figure 8-23. Creating sites-available directory
Figure 8-24. Creating/updating nxensite file
Figure 8-25. Setting directory permissions on /usr/sbin/nxensite file
Figure 8-26. Creating/updating nxdissite template

CHAPTER 8 ■ USING COOKBOOKS
131
Figure 8-29. Client finish
Figure 8-27. Creating/updating nginx.conf file
Figure 8-30. Checking if the service is running
Figure 8-28. Sites-available configuration file
At the end of client run, the recipe starts the nginx service.
We can check (see Figure 8-30) that Nginx is listening on port 80 by running the 
following command:
 
lsof –i :80 

CHAPTER 8 ■ USING COOKBOOKS
132
Figure 8-31. Nginx Configuration directory
Figure 8-32. Nginx log directory
Figure 8-31 shows the configuration directory which is created at 'etc/nginx' 
location. In the configuration directory, we can see different directories such as sites 
available, sites enabled, and the Nginx configuration file that were created by the recipes 
during the chef client run.
 
cd /etc/nginx
ls 
We create the log directory (see Figure 8-32) for nginx server at '/var/log/nginx'.
 
cd /var/log/nginx 
Finally, to confirm that the Nginx server is successfully installed and working, you 
can visit the Nginx web page (see Figure 8-33) by entering the IP address of the node on 
which the n.ginx server is installed.
Figure 8-33. Verifying Nginx install

CHAPTER 8 ■ USING COOKBOOKS
133
Figure 8-34. Downloading the Squid cookbook
Squid(0.4.0)
Platform
The following platforms support this cookbook:
Amazon (> = 0.0.0)
•฀
CentOS (> = 0.0.0)
•฀
Debian (> = 0.0.0)
•฀
Fedora (> = 0.0.0)
•฀
Red Hat (> = 0.0.0)
•฀
Scientific (> = 0.0.0)
•฀
Suse (> = 0.0.0)
•฀
Ubuntu (> = 0.0.0)
•฀
Cookbook Download
You can download the cookbook for installing and configuring the Squid proxy server in 
the corresponding cookbooks directory inside your chef repo on your knife workstation, 
from the Opscode community web site, by running the following command on your knife 
workstation:
 
Knife cookbook site download squid 
The cookbook you downloaded is in 'tar.gz' format. You have to extract the 
cookbook from here (see Figure 8-35), as follows:
 
tar –xvf squid-0.4.0.tar.gz
 

CHAPTER 8 ■ USING COOKBOOKS
134
Cookbook Upload
In your chef repo directory on your knife workstation, go to the cookbooks folder and 
open Squid cookbook directory and open 'attributes/default.rb' file in the editor of 
your choice. Set the values of the attributes according to your settings. Following are the 
values used for the purpose of this book.
•฀
node['squid']['port']=' 3128'
Network caching proxy: 
•฀
node['squid']['network'] = 'your ip 
address range'
You can also change the listen interface and cache memory size for the proxy server 
by changing the following attributes in default.rb:
default 
•฀
['squid']['listen_interface'] = 'eth0'
default 
•฀
['squid']['cache_size'] = '100'
default 
•฀
['squid']['cache_mem'] = '2048'
Upload the cookbook (see Figure 8-36) to the chef server from your knife 
workstation, from inside the chef repo directory.
 
knife cookbook upload squid
 
Figure 8-35. Extracting the file

CHAPTER 8 ■ USING COOKBOOKS
135
Add the cookbook to the run list of the node (see Figure 8-37), and run chef client to 
install and configure Squid cache.
 
Knife node run_list add node_name 'recipe[squid]' 
Figure 8-36. Uploading the cookbook
Figure 8-37. Adding the cookbook to the run_list
Client Run
Now, we run the chef client (see Figure 8-38) on the node on which we want to install and 
configure the Squid proxy server (see Figure 8-39).
Figure 8-38. Chef client run start

CHAPTER 8 ■ USING COOKBOOKS
136
Figure 8-39. Squid install
Figure 8-40. Create mime.conf
Figure 8-41. Create squid.conf

CHAPTER 8 ■ USING COOKBOOKS
137
Figure 8-44. Service status
Figure 8-42. Setting directory permissions and enabling service
Figure 8-43. Chef client finish
Once the client run has finished, we can determine if the Squid server was installed 
successfully by checking the Squid service (see Figure 8-44).
 
service squid status 

CHAPTER 8 ■ USING COOKBOOKS
138
Wordpress(2.1.0)
Platform
The following operating systems support this cookbook:
CentOS (> = 0.0.0)
•฀
Debian (> = 0.0.0)
•฀
Fedora (> = 0.0.0)
•฀
Oracle (> = 0.0.0)
•฀
Red Hat (> = 0.0.0)
•฀
Scientific (> = 0.0.0)
•฀
Ubuntu (> = 0.0.0)
•฀
Windows (> = 0.0.0
•฀
Dependencies
This cookbook is dependent on the following cookbooks:
MySQL, Version > = 1.0.5
•฀
PHP, Version > = 0.0.0
•฀
Apache2, Version > = 0.99.4
•฀
IIS, Version > = 1.6.2
•฀
OpenSSL, Version > = 0.0.0
•฀
Database, Version > = 1.6.0
•฀
Build essential, Version > = 0.0.0
•฀
Prerequisite
Client machine must have a running Internet connection.
•฀
Cookbook Download
You can download the cookbook (see Figure 8-45) in your corresponding cookbooks 
directory inside your chef repo, on the knife workstation, from the Opscode community 
web site, by running the following command on your knife workstation:
 
knife cookbook site download wordpress
 

CHAPTER 8 ■ USING COOKBOOKS
139
Figure 8-45. Downloading the cookbook
Figure 8-46. Extracting the cookbook
The cookbook that is downloaded is in 'tar.gz' format. The cookbook has to be 
extracted from here (see Figure 8-46), as follows:
 
tar –xvf wordpress-2.1.0.tar.gz 
Cookbook Upload
In your chef repo directory on your knife workstation, go to the cookbooks folder and 
open Wordpress cookbook directory and open 'attributes/default.rb' file in the 
editor of your choice. Set the values of the attributes according to your settings. Following 
are the values used for the purpose of this book.
You can mention your own database name, user, and password, or you can use 
the defaults.
default 
•฀
['wordpress']['db']['name'] = "wordpressdb"
default 
•฀
['wordpress']['db']['user'] = "wordpressuser"
default 
•฀
['wordpress']['db']['pass'] = nil

CHAPTER 8 ■ USING COOKBOOKS
140
If you want to allow the multisite features for your Wordpress site, you can set the 
corresponding attribute value.
default 
•฀
['wordpress']['allow_multisite'] = false
For the purpose of this book, we have set this attribute to 'false'. Now, upload the 
cookbook to the chef server (see Figure 8-47) by running the following command on your 
knife workstation, inside the chef repo directory:
 
knife cookbook upload wordpress 
Figure 8-48. Adding the cookbook to the run list
Figure 8-47. Uploading the cookbook
After you have uploaded the cookbook, add the cookbook to the run list (see Figure 8-48) 
of the node on which Wordpress is to be installed, using knife while inside the chef  
repo directory.
 
knife node run_list add node_name wordpress 
Client Run
Now, we run the chef client on the node on which we want to install and configure 
Wordpress (see Figure 8-49). The chef client command can be run from any location on 
the node file system. (However, it is recommended to run from the user’s home folder or 
the /root location).

CHAPTER 8 ■ USING COOKBOOKS
141
Figure 8-49. Client run start
Figure 8-50. Installing support package autoconf

CHAPTER 8 ■ USING COOKBOOKS
142
Figure 8-51. Installing support packages
Figure 8-52. Installing MySQL database

CHAPTER 8 ■ USING COOKBOOKS
143
Figure 8-53. Installing and configuring Wordpress
Figure 8-54. Creating wp-config.php file

CHAPTER 8 ■ USING COOKBOOKS
144
Figure 8-55. Chef client run finish
Now, go to a web browser and open the webadmin ui page for your Wordpress 
installation (see Figure 8-56).
 
http://your_ip_address 
Figure 8-56. Verifying installation

CHAPTER 8 ■ USING COOKBOOKS
145
Tomcat(0.15.0)
The following platforms support this cookbook:
Platform
Amazon (> = 0.0.0)
•฀
CentOS 6+
•฀
Debian (> = 0.0.0)
•฀
Fedora (> = 0.0.0)
•฀
Red Hat 7+
•฀
Ubuntu (> = 0.0.0)
•฀
Dependencies
Java, Version (> = 0.0.0)
•฀
OpenSSL, Version (> = 0.0.0)
•฀
Cookbook Download
You can download the cookbook (see Figure 8-57) for installing and configuring the 
Tomcat Server  from the Opscode cookbook community site in the cookbooks directory 
inside your chef repo, on your knife workstation, as follows:
 
Knife cookbook site download tomcat 
Figure 8-57. Downloading the cookbook
The downloaded cookbook is in 'tar.gz' format. Figure 8-58 shows the extraction 
of the cookbook
 
tar –xvf squid-0.4.0.tar.gz 

CHAPTER 8 ■ USING COOKBOOKS
146
Cookbook Upload
In your chef repo directory on your knife workstation, go to the cookbooks folder and 
open Tomcat cookbook directory and open 'attributes/default.rb' file in the editor of 
your choice.
Following are some important attributes whose values should be set according to the 
local setup. We use the values specified for the purpose of this book; they can be changed 
in the default.rb attribute file accordingly.
node 
•฀
["tomcat"]["port"] – 8080
node 
•฀
["tomcat"]["proxy_port"] – nil
The rest of the attribute values can be used as mentioned in the cookbook.
Upload the cookbook (see Figure 8-59) using the following command:
 
knife cookbook upload tomcat 
Figure 8-58. Extracting the cookbook
Figure 8-59. Uploading the cookbook

CHAPTER 8 ■ USING COOKBOOKS
147
Now, add the recipe to the run list of the node on which Tomcat is to be installed and 
configured (see Figure 8-60).
 
knife node run_list add node_name 'recipe[tomcat]' 
Figure 8-60. Adding recipe to run list
Figure 8-61. Chef client start
Client Run
Now, we run the chef client on the node on which we want to install and configure 
Tomcat (see Figure 8-61). The chef client command can be run from any location on the 
node file system. (However, it is recommended to run from the user’s home folder or 
the /root location.

CHAPTER 8 ■ USING COOKBOOKS
148
Figure 8-63. Setting Java environment variables
Figure 8-62. Installing Java

CHAPTER 8 ■ USING COOKBOOKS
149
Figure 8-64. Installing the Tomcat package
Figure 8-65. Installing and configuring Tomcat

CHAPTER 8 ■ USING COOKBOOKS
150
Figure 8-66. Creating the Tomcat configuration file
Figure 8-67. Setting read-write permissions on configuration file

CHAPTER 8 ■ USING COOKBOOKS
151
Figure 8-68. Chef client finish
Figure 8-69. Verifying service status
Once the client run is finished, we check the port 8080 to check whether the Tomcat 
service is running (see Figure 8-69).
service tomcat6 status
Now, you can go to a web browser and visit the UI using the IP address of the node 
on port 8080 (see Figure 8-70).
 
http://your_ip_address:8080
 

CHAPTER 8 ■ USING COOKBOOKS
152
Figure 8-70. Verifying installation
We have tried to cover whatever you need in order to use cookbooks. In the next 
chapter we start with the development of cookbooks.

153
CHAPTER 9
Developing a Cookbook
In this chapter, we walk you through the process of creating a cookbook. The chapter 
covers all important aspects of developing cookbooks.
Developing Your First Cookbook
Chef uses cookbooks to configure systems the way the administrator wants them to be 
configured.
We will assume that you have a chef server, a workstation, and a node already configured.
Cookbooks are created on the workstation using knife and are then uploaded to the 
chef server using knife.
We demonstrate the creation of a basic nginx cookbook that installs the Nginx web 
server on our node.
Figure 9-1 demonstrates how we will proceed in this chapter.
Creating A cookbook
Writing Recipes
Adding Template
Adding an Attribute
Updating Metadata
Uploading The Cookbook
Figure 9-1. Flow of the chapter

CHAPTER 9 ■ DEVELOPING A COOKBOOK
154
The general syntax for creating a cookbook is
 
knife cookbook create cookbook_name
 
Since we are creating an nginx cookbook, we will run the following command,  
as shown in Figure 9-2: 
knife cookbook create nginx
 
Figure 9-2. Creating a cookbook
Figure 9-3. Cookbook Directory Structure
Any knife command has to be executed from a workstation only.
The command would create a list of directories that are necessary for a cookbook, as 
shown in Figure 9-3.

CHAPTER 9 ■ DEVELOPING A COOKBOOK
155
The cookbook will be created in the directory specified in the knife configuration 
file. By default the directory in Windows is c:/chef/cookbooks and in Linux is  
/var/chef/cookbooks.
We will start our cookbook with the biggest chunk of configuration (i.e., the recipe).
Writing a Recipe
Go to the recipe subdirectory in the nginx cookbook directory. You will find a file named 
default.rb. This is the file that references the nginx recipe, and this is where we will add 
our code, as shown in Figure 9-4.
Figure 9-4. Listing the default recipe
Whenever you create a cookbook with knife it creates a default recipe. This recipe is 
executed whenever you add the cookbook to the run list of any node. Open the default.
rb file in the text editor of your choice. There may be a commented header in the file as 
shown in Figure 9-5.
Figure 9-5. Content of a recipe
The first thing we need to make sure of is that we install the nginx package on the 
node. We can achieve this using the package resource as shown in Figure 9-6.

CHAPTER 9 ■ DEVELOPING A COOKBOOK
156
The code in Figure 9-6 will use the native functionality based upon the operating 
system and will install the nginx package on it. If nginx is already installed on the node, 
then chef agent will do nothing and it will not be reinstalled.
After installing the package, we would like to start the service and enable the service 
on startup. This can be achieved using the service resource. The piece of code in Figure 9-7 
will help us in achieving that goal.
Figure 9-6. Adding a resource to our recipe
Figure 9-7. Adding another resource
Figure 9-8. Adding the cookbook_file resource
We have included two items in the action. The enable action will enable the nginx 
service on startup, and the start action will start the nginx service after installing the package.
After making sure that the package is installed and the service is running properly, 
we need to create a file that will be hosted on our nginx server. We will create a file and 
will use a cookbook_file resource to distribute the file.
The code shown in Figure 9-8 displays this.
We are done with the recipe writing. You can save and close your recipe. The final 
recipe should look like the one shown in Figure 9-9.

CHAPTER 9 ■ DEVELOPING A COOKBOOK
157
Creating the Index File
We have used the cookbook_file resource, which will look for the index.html file in 
the files directory of the cookbook. If the file is not present, then the cookbook will not 
be compiled properly, so we need to create the index file. Go to the nginx/files/default 
subdirectory and create the index file as shown in Figure 9-10.
Figure 9-9. The Recipe
Figure 9-10. Writing a recipe

CHAPTER 9 ■ DEVELOPING A COOKBOOK
158
Changing the Metadata
This is an optional but recommended step in order to create a cookbook. The 
metadata file is present in the cookbook subdirectory. By default, it looks like the 
example shown in Figure 9-11. We can add or change this file as per the requirement. 
We can change the cookbook version and other things. Also, metadata can be used to 
provide any dependencies.
Figure 9-11. Changing the metadata
Figure 9-12. Uploading the cookbook
Uploading the Cookbook
The next step would be to upload the cookbook to the chef server so that it can be 
deployed on any client. This can be easily done with the help of knife as shown in 
Figure 9-12.
 
knife cookbook upload nginx 
Running the Cookbook
After the cookbook has been uploaded to the chef server, we need to add it to the run 
list of the node on which we want to deploy it. This can be done with the help of knife, as 
shown in Figure 9-13. These commands are executed from a workstation.
 
knife node run_list add node_name cookbook_name
 

CHAPTER 9 ■ DEVELOPING A COOKBOOK
159
The next step would be to run the chef client on the node to see the cookbook 
execution (see Figure 9-14). Whenever we install chef client it automatically gets added to 
the path, and thus it can run from anywhere.
Figure 9-13. Adding to run list
Figure 9-14. Running chef client
To check whether your cookbook has been deployed successfully (see Figure 9-16), 
open a web browser and enter http://ipaddressofyourserver. You should be able to 
view the contents of the index page.
Figure 9-15. Chef client finished

CHAPTER 9 ■ DEVELOPING A COOKBOOK
160
Add an Attribute
Now we will add an attribute to our recipe. An attribute can be used to change the default 
settings on the node. We will change the listen port of nginx. By default, nginx services 
run on port 80. We will change the port to 82. To change the listen port, add an attribute 
in the default.rb file present in the attributes subdirectory as shown in Figure 9-17.
Figure 9-16. Checking whether cookbook is successfully deployed
Figure 9-17. Adding an attribute
Add a Resource to the Default Recipe
The next step would be to add a template resource to our recipe which will help us in 
rendering the configuration file. A cookbook template is an Embedded Ruby (ERB) 
template that is used to generate files based on the variables and logic contained within 
the template. Templates may contain Ruby expressions and statements and are a great 
way to manage configuration files across an organization.
Add the template resource as shown in Figure 9-18.

CHAPTER 9 ■ DEVELOPING A COOKBOOK
161
This would render the default.conf.erb file present in templates/default 
subdirectory and copy it to /etc/nginx/conf.d/default.conf. We can manage the 
permissions of the file using the attributes available in the template resource. Refer to 
Chapter 7 for more on this topic.
Add the Template File
We also need to add the template file that would be rendered. Create a file in the 
templates/default subdirectory as shown in Figure 9-19.
Figure 9-18. Adding a template resource
Figure 9-19. Adding a template file
At the time of rendering, the listen port will take from the attribute file by default. The 
attribute defined earlier is passed on to the template as shown in the code.
The attributes can also be provided in an environment or in roles, and they would be 
taken according to the precedence level.
Uploading and Running the Cookbook
Upload the cookbook again to the chef server so that the changes are updated. Run chef 
client again on the node to apply the changes (see Figures 9-20 and 9-21).

CHAPTER 9 ■ DEVELOPING A COOKBOOK
162
Knife commands are executed from a workstation and chef client can run on any 
node that is under management of chef.
To test whether your changes have been applied, open a web browser and try 
opening http://ipaddressofyourserver. An error will come up.
Now try opening http://ipaddressofyourserver:82 and it will open the index page 
as shown in Figure 9-22.
Figure 9-20. Testing cookbooks
Figure 9-21. Changing the configuration
Figure 9-22. Testing cookbook
Using Environments
An environment is a way to group our nodes; we can have environment-specific 
attributes. We can use environments to map the organization’s policies.

CHAPTER 9 ■ DEVELOPING A COOKBOOK
163
Chef creates a default environment and puts every node in it by default. We 
can modify the environment later on by editing the node object. An environment 
can be created using knife or the management console. This time, we will create the 
environment using the management console.
After a login to the management console, click the environments tab as shown in 
Figure 9-23.
Figure 9-23. Creating the environment
Click create to create a new environment. Provide a name for your environment and 
add some description to it (see Figure 9-24).
Figure 9-24. Creating an environment
We can add cookbook version constraints if we want to. We will keep it empty for 
now. This is used if we want certain configuration on nodes in a particular environment.
The next step is to add some attributes that will be overridden during the next chef 
run (see Figure 9-25).

CHAPTER 9 ■ DEVELOPING A COOKBOOK
164
Click create environment to create the environment. After the environment has been 
created, we will edit it using knife and add an override attribute to override the listen port 
for nginx. This would open up the environment object located on the chef server in the 
EDITOR environment variable (see Figure 9-26).
Figure 9-25. Creating an environment
Figure 9-26. Editing an environment

CHAPTER 9 ■ DEVELOPING A COOKBOOK
165
Save the file and it will be updated on the server. The file gets updated on the chef 
server database directly. The next step is to change the environment of our node so that 
the attributes are overridden. Go to the nodes tab in the management console and select 
the node you want to edit. We can also change a node’s environment using knife  
(see Figure 9-27).
Figure 9-27. Changing a node’s environment(1)
Click edit and select the environment from the dropdown as shown in Figure 9-28.
Figure 9-28. Changing a node’s environment(2)

CHAPTER 9 ■ DEVELOPING A COOKBOOK
166
Click the save node button to save the changes you made.
Now run chef client on the node to check whether the attribute is getting overridden. 
Run chef client on the node where we will deploy the nginx server (Figure 9-30).
Figure 9-30. Changing the configuration file
Figure 9-29. Changing a node’s environment
To test whether your changes have been applied, open a web browser and try 
opening http://ipaddressofyourserver:85. The index page should come up as shown 
in figure 9-31.

CHAPTER 9 ■ DEVELOPING A COOKBOOK
167
We have demonstrated how environments can be used to manage our nodes.  
The implementation of environments is specific to an organization’s policies and processes. 
With chef, it becomes simple and easy to manage different environments. As an example, 
an organization may have Development, Test, QA, and production environments, each 
with different guidelines and policies. A single chef cookbook can be overridden to 
provide different attributes for different environments without changing the code in the 
cookbook. Thus, environments provide an easy mechanism to change or override the 
configuration based on the environment to which a node belongs.
Figure 9-31. Testing the changes

169
CHAPTER 10
Lightweight Resource 
Providers
This chapter discusses lightweight resource providers (LWRPs). They are a way to 
enhance the functionality of chef to provide new integrations which are not provided for 
out-of-box in chef.
Lightweight Resource Providers
A resource is something that defines the action that needs to be taken and a provider is 
something that executes that action.
To implement the functionality of a resource and provider in a recipe which is not 
an inbuilt resource provider, you can create your own LWRPs. You can use custom Ruby 
codes and inbuilt chef resources to create an LWRP.
LWRPs help in achieving the core objective of chef which is idempotence. One can 
achieve this state using scripts or recipes by leveraging “if”-type constructs to choose 
when to run the script; however, this process becomes fairly complex to manage.
LWRPs help us in achieving idempotence for complex and scalable infrastructure to 
provide reliable configuration management.
LWRPs are loaded from files that are saved in the following cookbook subdirectories:
Directory
Description
providers/
The subdirectory in which lightweight providers are located.
resources/
The subdirectory in which lightweight resources are located.
The name of the cookbook and the name of the files in the resources/ and 
providers/ subdirectories determine the naming patterns of LWRPs.

CHAPTER 10 ■ LIGHTWEIGHT RESOURCE PROVIDERS
170
For example, if a cookbook named example was downloaded to the chef repository,  
it would be located under /cookbooks/example/. If that cookbook contained two resources 
and two providers, the following files would be part of the resources/ directory: 
Files
Resource Name
Generated Class
default.rb
Example
Chef::Resource::Example
custom.rb
Custom
Chef::Resource::ExampleCustom
And the following files would be part of the providers/ directory: 
Files
Provider Name
Generated Class
default.rb
Example
Chef::Provider::Example
custom.rb
Custom
Chef::Provider::ExampleCustom
Chef-Maintained LWRPs
Chef maintains a number of LWRPs. We will discuss some of the important LWRPs 
maintained by the Opscode community. These are available in cookbooks. If we need to 
use them, we need to download the cookbook from the community, upload the cookbook 
to our chef server, and then use them in our custom recipes.
Cookbook
Description
apt
This cookbook is used to configure APT (Advanced Packaging Tool) 
for managing APT preferences and repositories.
aws
AWS refers to Amazon Web Services. This cookbook can be used to 
manage the resources that are running in AWS cloud.
chef_handler
This cookbook is used for exception handling. It distributes and 
enables the exception and report handlers.
cron  
Cron is used to schedule something in Unix. This cookbook is used 
to install cron and start its service.
daemontools
Daemontools are used to manage Unix services. This cookbook is 
used to install and configure daemontools.
firewall
This cookbook is used to maintain the firewall rules.
homebrew 
Homebrew is a package manager for Mac OS. This cookbook helps 
us to install and configure Homebrew.
iis
This is a Windows-based cookbook and can be used to install and 
configure IIS (Internet Information Services) server.
(continued)

CHAPTER 10 ■ LIGHTWEIGHT RESOURCE PROVIDERS
171
Cookbook
Description
lvm
This cookbook is used to install the LVM2 package and then 
manage LVM.
nginx
This cookbook is used to install and configure Nginx from source 
code or package and then set up configuration handling.
php
This cookbook can be used to install and configure PHP and 
custom modules for PHP.
postfix
This cookbook can be used to install and configure Postfix.
powershell 
This cookbook is used to install the Powershell module on 
Windows servers.
rabbitmq 
This cookbook will install the RabbitMQ-server.
squid
This cookbook is used to install and configure Squid as a caching 
proxy server.
sudo
This cookbook is used install sudo and then configure  
the/etc/sudoers file.
windows
This cookbook can be used for the built-in Windows commands.
yum
This cookbook is used for the yum configuration file.
Creating an LWRP
This section will demonstrate how to create an LWRP. We will create an LWRP to 
download Wordpress setup, extract it to the desired location, and then delete the 
downloaded file.
1. 
The first step is to create a cookbook in which we will create 
the resource and provider. Create a cookbook named  
wp_setup using the knife.  We execute the following command 
from a workstation:
 
knife cookbook create wp_setup
 
2. 
The command creates the files and directories that are 
required for developing a cookbook (see Figure 10-1). The 
cookbook will be created in the local chef repository. 
(continued)

CHAPTER 10 ■ LIGHTWEIGHT RESOURCE PROVIDERS
172
3. 
The resource directory is where we create our resource. Create 
a default.rb file in the resource directory. In the default.rb, 
write the following code:
 
actions :extract, :remove
attribute :wp_url, :kind_of=> String, default:  
"https://wordpress.org/latest.tar.gz"
attribute :wp_path, :kind_of=> String, default: "/var/www"
 
In this code sample, we are defining the following:
Actions: this defines the actions that need to be taken in this 
•฀
particular resource. In this case, we are defining two actions: 
extract and remove.
Attribute: here we define the attributes that will be passed to 
•฀
the resource. In this example, we are passing an attribute called 
wp_url, which is kind_of string and is a default parameter. The 
value of this parameter is the download location of the Wordpress 
web site tar file.
A default attribute is specified in the resource file so that if an attribute is not specified 
in the recipe or attribute file, chef client will take the default value from the resource file.
4. 
The next step after defining the resource is to map the actions 
that we have defined to actual execution code which is 
defined in the provider.
When the chef client identifies a custom resource, it will look for the related actions 
method in the provider.
Create a default.rb file under the folder named providers of wp_setup cookbook.
In this file, we define the actions to be performed.
Create methods for the custom actions specified in the resource file.
 
def whyrun_supported?
  true
end
 
Figure 10-1. Directory structure

CHAPTER 10 ■ LIGHTWEIGHT RESOURCE PROVIDERS
173
We use the whyrun method if we want chef client to tell the changes that would be 
applied to the node without actually applying them when it is run in whyrun mode. Its 
value can be true or false. For this example, we will set this value to true. To run the chef 
client in whyrun mode, run Chef-client –W.
Now we need to define the code that will be executed on calling of actions that we 
defined in the resources. First we will define the extract action. We will use Ruby and 
inbuilt chef resources to define the complete set of actions.
In this method we are using the File.exists? method to check if there is an existing 
Wordpress folder to achieve idempotency.
Chef::Log class is used to log entries in the log file.
A new_resource.updated_by_last_action method notifies the LWRP if the node has 
successfully updated. True or false is passed as an argument to this method to notify the 
execution of LWRP.
The converge_by is a wrapper method used when the chef client runs in whyrun 
mode and displays a message about that block of code.
 
if ::File.exists?("#{new_resource.wp_path}/wordpress")
 
   Chef::Log.info "#{ @new_resource } already exists - nothing to do."
   new_resource.updated_by_last_action(false)
 
else
 
converge_by("Downloading wordpress file") do
The remote_file is an inbuilt chef resource that downloads the file from a certain URL 
(uniform resource locator) to the node.
 
remote_file "#{new_resource.wp_path}/wordpress.tar.gz" do
 
   source "#{new_resource.wp_url}"
   action :create
 
end
 
Bash is also an inbuilt chef resource that is used to run bash scripts. We are using the 
bash resource to extract the downloaded Wordpress file.
 
bash "extracting wordpress" do
 
     code <<-EOH
     cd /var/www
     mkdir wordpress
     tar -xvf wordpres.tar.gz wordpress
     EOH
 
end
 

CHAPTER 10 ■ LIGHTWEIGHT RESOURCE PROVIDERS
174
The following snippet shows the whole code clubbed together:
 
action :extract do
 
 if ::File.exists?("#{new_resource.wp_path}/wordpress")
 
   Chef::Log.info "#{ @new_resource } already exists - nothing to do."
   new_resource.updated_by_last_action(false)
 
 else
 
 converge_by("Downloading wordpress file") do
 
 remote_file "#{new_resource.wp_path}/wordpress.tar.gz" do
 
  source "#{new_resource.wp_url}"
  action :create
 
 end
 
 bash "extracting wordpress" do
 
   code <<-EOH
   cd /var/www
   mkdir wordpress
   tar -xvf wordpres.tar.gz wordpress
   EOH
 
  end
 
 end
 
 new_resource.updated_by_last_action(true)
 
 end
 
end
 
Action: remove: This method contains the inbuilt file resource which will delete the 
Wordpress installation file.
Chef::Log class is used to log entries in the log file.
The new_resource.updated_by_last_action method notifies the LWRP if the node 
has successfully updated. True or false is passed as argument to this method to notify the 
execution of LWRP.
converge_by is a wrapper method used when chef client runs in whyrun mode and 
displays a message about that block of code.

CHAPTER 10 ■ LIGHTWEIGHT RESOURCE PROVIDERS
175
File is an inbuilt chef resource that has an action delete, which will delete any file.
 
action :remove do
 
 unless ::File.exists?("#{new_resource.wp_path}/wordpress.tar.gz")
 
  Chef::Log.info "#{ @new_resource } file deleted - nothing to do."
  new_resource.updated_by_last_action(false)
 
 else
 
 converge_by("removing the compressed wordpress file") do
 
  file "#{new_resource.wp_path}/wordpress.tar.gz" do
  action :delete
 
  end
 
  directory "/root/chefdemo" do
 
   action :create
 
  end
 
 end
 
 new_resource.updated_by_last_action(true)
 
 end
 
end
 
5. 
You can use the resource name in the recipe once the resource 
and provider are in place. Since we created the resource and 
provider in default.rb files, the resource name will be the 
cookbook’s name. If the resource and provider have a name 
other than default.rb, that name has to be appended to the 
cookbook name while using it in the recipe.
 
syntax: cookbookname_resourcename
wp_setup "extracting wordpress" do
wp_path node[:wordpress][:path]
wp_url node[:wordpress][:url]
action :extract
end
 

CHAPTER 10 ■ LIGHTWEIGHT RESOURCE PROVIDERS
176
wp_setup "deleting the installation file" do
wp_path node[:wordpress][:path]
action :remove
end
 
6. 
The attributes wp_path and wp_url are passed using the 
attribute file.
 
default[:wordpress][:url] =  
"https://wordpress.org/latest.tar.gz"
default[:wordpress][:path] = "/var/www"
 
7. 
Upload the cookbook to chef server using knife (see Figure 10-2). 
Knife commands are executed from a workstation.
 
knife cookbook upload wp_setup
 
Figure 10-2. Uploading the cookbook
8. 
Run the chef client on the node (see Figure 10-3). 
Figure 10-3. Running chef client

CHAPTER 10 ■ LIGHTWEIGHT RESOURCE PROVIDERS
177
9. 
Confirm the chef client run (see Figure 10-4) by browsing the 
Wordpress directory under the /var/www folder.
 
Figure 10-4. Verifying installation

179
CHAPTER 11
High Availability
The open source chef server does not offer high availability by default. Therefore, we 
recommend an enterprise chef production environment, which comes with options for 
high availability.
In this chapter, we talk about high availability (Database and Application Layer) that 
can be achieved in the open source version. We set up high availability on AWS (Amazon 
Web Services) instances.
Prerequisite
It is necessary to have two servers with chef installed. Communication is allowed between 
the two servers on required ports. An ELB (Elastic Load Balancer) would route the traffic 
between two instances.
Setting Up HA
The first thing in setting up high availability (HA) is to identify the things we need to 
replicate for setup. 
The following things are required to be replicated in open source chef server:
1. 
Database replication
2. 
Bookshelf directory replication (cookbooks replication)
The database used in open source chef is Postgresql, and we will be using native 
functionality of postgresql (i.e., streaming replication) to set up database replication.
Streaming Replication
Streaming replication continuously ships and applies the WAL XLog to the standby 
servers. The streaming replication uses continuous archiving to create a cluster 
configuration with one or more standby servers that can take over if the primary server 
fails. This is known as a warm standby or log shipping. 

CHAPTER 11 ■ HIGH AVAILABILITY
180
In streaming replication, the primary and the standby servers work together. The 
primary server operates in continuous archiving mode, while each standby server 
operates in continuous recovery mode, reading the WAL files from the primary server. 
No changes to the database tables are required to enable this capability, so it offers 
low-administration overhead compared to some other replication solutions.
The impact on the primary server performance is low in this configuration.
We will be setting up streaming replication using a third-party tool, repmgr, which 
automates certain manual steps.
The first thing you have to do is check that chef server is installed on both the servers 
and is running fine (see Figures 11-1 and 11-2). Run the following command to check: 
 
chef-server-ctl status 
Figure 11-1. Chef server status on 1st server
Figure 11-2. Chef server status on 2nd server
Setting Up Repmgr
Repmgr requires you to install GCC (GNU Compiler Collection) on the chef server. Install 
it first before continuing (see Figure 11-3). 

CHAPTER 11 ■ HIGH AVAILABILITY
181
Download the repmgr package from repmgr’s web site (see Figure 11-4). Internet is 
required to complete this process.
Figure 11-3. Installing GCC
Figure 11-4. Downloading repmgr
The downloaded file is a tar file. Untar the file (see Figure 11-5).

CHAPTER 11 ■ HIGH AVAILABILITY
182
The next step is to install repmgr (see Figure 11-6). Go to the repmgr directory.
Figure 11-5. Extracting repmgr
Figure 11-6. Installing repmgr
Repmgr requires the postgres directory to be available in the path. To do this, export 
the path (see Figure 11-7). 

CHAPTER 11 ■ HIGH AVAILABILITY
183
Add the following directory to your path:
 
/opt/chef-server/embedded/bin/
 
To install repmgr (see Figure 11-8), use the following command (see Figures 11-8 
and 11-9):
 
make USE_PGXS=1
make USE_PGXS=1 install 
Figure 11-7. Exporting the path
Figure 11-8. Installing repmgr

CHAPTER 11 ■ HIGH AVAILABILITY
184
Installation is complete. To verify the installation (see Figure 11-10), run the 
following command: 
 
repmgr -V 
Figure 11-9. Installing repmgr
Figure 11-10. Verifying the installation
This process needs to be repeated on the slave node as well. Repeat the steps of 
installing repmgr.
Master Node Settings
On the master node, go to the postgre data directory (see Figure 11-11). The default 
directory created by chef is as follows: 
 
/var/opt/chef-server/postgresql/data 
Figure 11-11. Postgre directory

CHAPTER 11 ■ HIGH AVAILABILITY
185
Open the postgresql.conf file and edit the listen_addresses field so that we are able 
to connect to the master server from the slave server (see Figure 11-12).
Figure 11-12. Changing the configuration file
The next thing to edit in the configuration file is the wal_level (see Figure 11-13). 
Change it to hot_standby. wal_level determines how much information is written to 
the WAL. In hot_standby level, the same information is logged as with archive, plus 
information needed to reconstruct the status of running transactions from the WAL. 
 
wal_level = 'hot_standby' 
Figure 11-13. Changing the configuration file
As streaming replication uses archiving to create logs, we need to enable archiving 
on the master server (see Figure 11-14). The archive command can be anything which 
would do nothing. Here we are using cd. You can also use any other command.
 
archive_mode = on
archive_command = 'cd.'       
 

CHAPTER 11 ■ HIGH AVAILABILITY
186
After the archiving, change the setting seen in Figure 11-15, which will change the 
number of sender processes that would ship the log.
 
max_wal_senders = 10
wal_keep_segments = 5000      
Figure 11-14. Setting up archiving
Figure 11-15. Changing the configuration file
The configuration changes have been done. Now we need to set up the trust so that the 
master server will accept connections from the standby server (see Figure 11-16). Edit  
the pg_hba available in the /var/opt/chef-server/postgresql/data directory and add the 
ip/subnets from where you want to add trust.
Figure 11-16. Setting up trust

CHAPTER 11 ■ HIGH AVAILABILITY
187
Restart the chef server on the master node to apply the changes (see Figure 11-17).
Figure 11-17. Restarting the chef server
Run the following command to verify that the configuration on the master server is 
fine (see Figure 11-18):
 
ps aux | grep postgre 
Figure 11-18. Verifying a master configuration
A process should come up with description ‘wal writer process’.
Slave Node Settings
For setting up the streaming replication, we need to clone the data directory of the master 
server on the standby server (see Figure 11-19). 

CHAPTER 11 ■ HIGH AVAILABILITY
188
Change the permission of the pg_xlog folder. The folder in present in the data 
directory. The path to the directory is /var/opt/chef-server/postgresql/data.
Restart the chef server to see the changes (see Figure 11-22).
Figure 11-20. Cloning complete
Figure 11-21. Cloning complete
Clear the data directory on the slave node and run the following command:
 
repmgr -D /var/opt/chef-server/postgresql/data/ -d opscode_chef -p 5432 -U 
opscode-pgsql -R root --verbose standby clone $masterip
 
Where masterip is the IP (Internet protocol), address of the master node.
-D – The data directory. (The default directory is 
•฀
/var/opt/chef-
server/postgresql/data)
-d – The database to clone.
•฀
-p – Port on which server is running on the master node.
•฀
-U – The user of the database.
•฀
-R – The user with which keyless SSH is present.
•฀
Figure 11-19. Cloning the master server

CHAPTER 11 ■ HIGH AVAILABILITY
189
Figure 11-22. Restarting the chef server
Figure 11-23. Verifying the configuration
To verify that the slave configuration is complete, run the command shown in 
Figure 11-23.
A process should come up with the description ‘wal receiver process’.
Verifying
To verify that your replication has been set up, create a test database on the master server 
(see Figure 11-24). 
Figure 11-24. Creating a database
List the database on the master server (see Figure 11-25).

CHAPTER 11 ■ HIGH AVAILABILITY
190
Figure 11-25. Listing databases on the master server
Figure 11-26. Listing databases on the slave server
List the database on the slave server (see Figure 11-26). The database that was 
created on the master would be shown in the slave node as well (test).
Cookbook Replication
For the cookbook replication, we can use any shared file system. The directory that needs 
to be shared among the two servers is
 
/var/opt/chef-server/bookshelf/data
 
Please make sure that the permissions of the folder are the same on the master and 
the slave nodes. 
As the streaming replication sets up the database replication in a primary-secondary 
mode, we need to make sure that chef client requests are routed to the primary server or 
else they will not be completed.
The clients will connect to both the chef servers through a load balancer and will 
connect to the secondary server in case the primary is down.

CHAPTER 11 ■ HIGH AVAILABILITY
191
What we did is just a workaround for HA. We still need to set up failover/failback, 
which will be done manually or can be automated using scripts. In case one of the 
database servers fails, the other one is brought up to take the workload. In case of the 
failure of the chef server, the other one takes up the load of the application server which is 
down since all configuration and cookbooks are available to both of the servers.
Enterprise Chef HA
Enterprise chef comes with different types of deployment scenarios. One of them is built-
in support for HA. It has a fully automated failover for stateful components. The whole 
architecture of chef is divided into two tiers. 
First would be the web facing tier, which handles the user interface, and the API 
(application programming interface) requests that come to the chef server.
The second tier is the application tier or the back-end tier,  which handles the data 
storage and retrieval, which consist of
CouchDB
•฀
PostgreSQL
•฀
Opscode solr
•฀
RabbitMQ
•฀
Redis
•฀
Cookbook data
•฀
The failover of the application tier or the back-end tier is achieved using the 
following:
DRBD (Distributed Replication Block Device) is used to manage 
•฀
the block-level replication.
A primary and backup cluster election using VRRP (Virtual Router 
•฀
Redundancy Protocol) over unicast TCP/IP and Keepalived.
A virtual IP address to the primary server, maintained based on 
•฀
the results of the election done by Keepalived.
The web tier or the front-end tier is a load balancer. Chef recommends a hardware 
load balancer with SSL offloading and round robin as the load balancing algorithm  
(see Figure 11-27). 

CHAPTER 11 ■ HIGH AVAILABILITY
192
Figure 11-27. HA in enterprise chef

193
CHAPTER 12
Cloud Provisioning  
Using Chef
Provisioning Using Vagrant and Chef
Until now we have seen how to leverage chef to provision and configure application 
and database environments. In this chapter we introduce our readers to how Vagrant 
and chef can work together to bring up complete environments including the virtual 
infrastructure.
Vagrant is an open source infrastructure provisioning solution that integrates with 
VMware, AWS, VirtualBox, and other hypervisor and cloud environments to provision 
virtual and cloud infrastructure.
After provisioning of the cloud or virtual infrastructure through Vagrant, chef can be 
used to deploy and configure the application servers and databases on the virtual machine.
Thus a combination of Vagrant and chef can provide immense benefits to enterprises 
looking to automate the infrastructure and environment and build use cases.
Just as chef has a concept of recipe, Vagrant has the concept of a Vagrantfile which 
provides the configuration details for the virtual machine or cloud infrastructure.
A much used use case of the Vagrant tool is to create disposable infrastructure and 
environments for developers and testers. As development and test environments need 
frequent provisioning and deprovisioning, the power of Vagrant to quickly assemble the 
required infrastructure helps the infrastructure and automation teams in fulfilling the 
demands of the development and test teams.
With its integrations to various hypervisors and cloud providers the same Vagrant tool 
can be used to provision the infrastructure in premise virtual infrastructure and the cloud.
Technically, Vagrant is a Ruby-based application. Vagrant can be easily deployed as a 
virtual machine on VirtualBox or VMware workstation.
Vagrant can quickly deploy the environment using a single command “vagrantup” 
once the Vagrant tool is up and running and is configured with correct Vagrantfile.
Providers and Provisioners
The development environment can be configured using Vagrant’s providers and 
provisioners.

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
194
Providers are the virtual machine solutions such as VirtualBox, VMWare,  
Amazon AWS, and Digital Ocean.
Provisioners are used to manage the configuration in your development 
environment. Chef and puppet are few examples of provisioners used by Vagrant. Using 
provisioners you can automate the application configuration process on a Vagrant box.
Installing Vagrant
Vagrant works on Windows (32 bit and 64 bit), Linux Debian (32 bit and 64 bit),  
Linux rpm based (32 bit and 64 bit), and MAC OS X (32 bit and 64 bit) environments.
Install Virtual Box
Vagrant works with virtual box in the back end. So, before installing Vagrant, virtual box 
has to be installed in your system. Virtual box has to be installed on a workstation and not 
on any virtual machine.
Go to www.virtualbox.org/wiki/Downloads. Download and install the latest virtual 
box software.
Install Vagrant on Windows
1. 
Go to www.vagrantup.com/downloads. 
2. 
Download the Vagrant Windows MSI installer package  
(see Figure 12-1). 
Figure 12-1. Downloading Vagrant

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
195
3. 
Run the installer (see Figure 12-2). 
Figure 12-2. Running the Vagrant Installer
4. 
Click next. 
Figure 12-3. Installing Vagrant

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
196
5. 
Accept the license and click next. 
Figure 12-5. Selecting a Installation Directory
6. 
Enter the destination folder for Vagrant and click next. 
Figure 12-4. Accepting the Terms

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
197
7. 
Click install. 
Figure 12-6. Installing Vagrant
8. 
Click finish. 
Figure 12-7. Finishing installation

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
198
Verifying Vagrant Installation
Open the windows command prompt and check the Vagrant version to make sure it is 
installed in your system (see Figure 12-8).
1. 
vagrant –v 
Figure 12-8. Verifying installation
Figure 12-9. Adding Vagrant box directly
Configuring Vagrant
Vagrant Boxes (OS Images)
Vagrant uses the notion of “boxes” to describe preconfigured base virtual machines  
from which we can work. Creating a virtual machine from scratch is a tedious and  
time-consuming process. Vagrant, on the other hand, creates a virtual machine quickly  
by cloning the preconfigured virtual machines. These preconfigured base images are 
termed as boxes in Vagrant.
You can download Vagrant boxes (Linux based) based on your requirement from 
here www.vagrantbox.es/.
Note
 
■
 Install git bash on your system to work with Vagrant on Windows since Windows 
command line does not support SSH protocol.
Two Methods to Download Vagrant Box
1. 
Download and add the Vagrant base box (see Figure 12-9) 
with preconfigured chef using the following command:
 
#syntax vagrant box add {boxname} {box provider url}
vagrant box add ubunt12.04 http://files.vagrantup.com/precise32.box
 
Vagrant boxes will be downloaded to the users/.vagrant.d/boxes folder.

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
199
2. 
Download the box directly from https://files.vagrantup.com  
to your file system and you can add that box to Vagrant by 
specifying the local file system path (see Figure 12-10).
 
vagrant box add vagrant_demo C:\Users\Administrator\centos\CentOS-6.4-i386-v.box 
Figure 12-11. Creating a Vagrantfile
Figure 12-10. Adding vagrant box from file system
Vagrantfile
The next step is to configure Vagrant using a Vagrantfile. 
1. 
The first step is to create a root directory. A few configurations 
related to Vagrant will be relative to this directory
2. 
Mention the kind of box and provisioners you need to have in 
your environment in the Vagrantfile.
3. 
Vagrantfile can be created using vagrant-init command. This 
command will create a Vagrantfile in your current directory. 
Adding the existing box title to the vagrant-init command 
will create a Vagrantfile with the configuration details of the 
mentioned box.
 
#syntax vagrant init {box-title}
 
vagrant init ubunt12.04
 
The foregoing command creates a Vagrantfile (see Figure 12-11) based on the base 
box titled ubunt12.04.

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
200
Provisioning a New Instance
You can start the virtual machine (see Figure 12-12) using “vagrant up” command. When 
you use this command, make sure that your present working directory is the directory 
which contains the Vagrantfile.
Here we are using centos box which has already been downloaded using “vagrant 
box add” command. The Vagrantfiles relative to centos box are present inside the  
c:/users/centos folder.
Connecting to a Virtual Machine
The virtual machine (VM) which got spun up by Vagrant can be connected using the 
“vagrant ssh” command. This command will drop you into a full-fledged SSH session.  
By default, a Vagrant VM will have username and password “vagrant.”
Figure 12-12. Starting a virtual machine

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
201
The network details are fetched from the Vagrantfile. You can have a host-only access 
static IP or dynamic IP allocated by the public network.
Also, you can spin up multiple VMs using one Vagrantfile by defining more than one 
VM in the Vagrantfile. By default there will be only a box definition inside a Vagrantfile 
(e.g., config.vm.box = "vagrantdemo"). SSH access can be made to individual VMs 
using the name given in the definition.
When multiple VMs are launched using a single Vagrantfile, the SSH command 
should include the VM name to connect to it (see Figure 12-13).
Figure 12-13. Connecting to a virtual machine
Note
 
■
 All the commands related to the virtual machine have to be run from the root 
folder of the VM.
Suspending the Virtual Machine
By suspending the VM, you can get a point in time state of the virtual machine  
(see Figure 12-14). The Vagrant “suspend” command will not shut down the machine 
completely; you can resume the VM anytime.

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
202
Halting the Virtual Machine
“Vagrant halt” command shuts down the VM (see Figure 12-15). You can provide –f 
switch to forcefully shut down the machine. You have to execute this command from the 
root folder of the VM.
Figure 12-14. Suspending a virtual machine
Figure 12-15. Halting a virtual machine
Destroying the Virtual Machine
“Vagrant destroy” command will stop the VM and destroys all the resources associated 
with it (see Figure 12-16). Once you issue the destroy command, it will ask for 
confirmation to destroy the VM.
Figure 12-16. Destroying a virtual machine
Installing Vagrant Plug-Ins
The following command can be executed from anywhere. Plug-ins are necessary to 
integrate Vagrant with other services like AWS, Azure, Hyper-V, and so on.
Command: vagrant plugin install <name>
Vagrant plug-ins will be installed from RubyGems and this command also updates 
the existing gem. The command “vagrant plugin update” is specifically used to update 
the plug-in. You can also install multiple plug-ins by providing multiple names with the 
command.

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
203
Vagrant Provisioning Using Chef
Provisioners in Vagrant let you automatically install and configure software on the 
Vagrant machine as part of the “vagrantup” process. If you want to just use Vagrant SSH 
and install the software by hand, that will work. By using provisioners you can automate 
the repeatable tasks. To use provisioners, make sure that the particular provisioner 
is included in the Vagrant box you download. For example, if you want to use chef 
provisioner, use a box that contains chef client.
The configuration for provisioning by default will be commented out in the 
Vagrantfile. We have to work on this file and fill in the required details for chef to work 
with Vagrant. The file will look as shown in Figures 12-17 and 12-18. This file will be 
present in the root folder you created for the VM.
Figure 12-17. Vagrantfile(1)

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
204
Chef Solo Provisioner
Using chef solo provisioner you can provision a guest OS using chef solo. All the 
configurations needed for chef solo have to be mentioned in the Vagrantfile.
Options
This section lists the complete set of available options for the chef solo provisioner. More 
detailed examples of how to use the provisioner are available here.
Note that only the chef solo specific options are shown in the following list. There 
is also a large set of common options available with both the chef solo and chef client 
provisioners.
cookbooks_path (string or array): A list of paths to where cookbooks are stored. 
By default this is “cookbooks,” expecting a cookbooks folder relative to the Vagrantfile 
location.
data_bags_path (string): A path where data bags are stored. By default, no data bag 
path is set.
environments_path (string): A path where environment definitions are located. By 
default, no environments folder is set.
environment (string): The environment you want the chef run to be a part of. This 
requires Chef 11.6.0 or later, and it requires the environments_path to be set.
recipe_url (string): URL to an archive of cookbooks that chef will download and use.
roles_path (string or array): A list of paths where roles are defined. By default, it is 
empty. Multiple role directories are only supported by Chef 11.8.0 and later.
Figure 12-18. Vagrantfile(2)

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
205
Specifying a Run List
The run list specified in the Vagrantfile will be configured when the “vagrantup” 
command is issued.
 
Vagrant.configure("2") do |config|
  config.vm.provision "chef_solo" do |chef|
    chef.add_recipe "httpd"
  end
end
 
This will make Vagrant run chef solo with the “httpd” cookbook. The cookbook 
has to be present in the cookbooks directory of your VM’s root directory. The directory 
structure should look as shown in Figure 12-19.
Figure 12-19. Directory structure
Specifying Roles
You can specify chef roles in a Vagrantfile. By default, Vagrant will look for the roles 
directory in the VM’s root folder. You can specify the path if the roles folder is in some 
other location.
 
Vagrant.configure("2") do |config|
  config.vm.provision "chef_solo" do |chef|
    chef.roles_path = "vagrant_roles"
    chef.add_role("webserver")
  end
end

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
206
Using Data Bags
You can use data bags with chef solo provisioner. Data bags can be used inside recipes 
that chef solo uses. By default, Vagrant will search for the data bags folder in the VM root 
directory.
 
Vagrant.configure("2") do |config|
  config.vm.provision "chef_solo" do |chef|
    chef.data_bags_path = "data_bags"
  end
end
Specifying Node Name
You can set a custom node name by mentioning the node_name option. 
 
Vagrant.configure("2") do |config|
  config.vm.provision "chef_solo" do |chef|
    chef.node_name = "node_name"
  end
end
Custom JSON Data
Additional configuration data for chef attributes can be passed in to chef solo.
You can also pass parameters using JSON (JavaScript Object Notation) in the chef 
solo provisioner.
 
Vagrant.configure("2") do |config|
  config.vm.provision "chef_solo" do |chef|
      chef.json = {
      "httpd" => {
        "listen_address" => "10.0.1.5"
      }
    }
  end
end
Provisioning Chef Client 
Using chef client provisioner you can provision a Vagrant guest VM which will be 
registered to the existing chef server. You have to mention the validation key and chef 
server URL in the Vagrantfile. By default the chef client will look for the validation key 
in the VM root directory. If it is not present in the root directory, you have to provide the 
path of the validation key in the validation_key_path parameter.
 

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
207
Vagrant.configure("2") do |config|
  config.vm.provision "chef_client" do |chef|
    chef.chef_server_url = "https://my_chef_server.com:443/"
    chef.validation_key_path = "validation_key.pem"
  end
end
Adding Run List
You can override the run list specified by chef server by providing run list in the 
Vagrantfile. The run lists and recipes added to the Vagrantfile will be pulled from the chef 
server and applied to the Vagrant VM. 
 
Vagrant.configure("2") do |config|
  config.vm.provision "chef_client" do |chef|
    # Adding a recipe
    chef.add_recipe "apache"
    # adding a role
    chef.add_role "web"
  end
end
Deleting the Node Details
Once a client is registered with the chef server, two entries are registered in the chef 
server, a node object and a client entry. These entries have to be deleted for Vagrant VM 
which is to be destroyed. It can be done by setting the values of two parameters to true.
 
chef.delete_node = true
chef.delete_client = true
Verifying Chef Client Registration with Chef Server
1. 
Run chef client command from the vagrant box by connecting 
using Vagrant SSH command to ensure that your vagrant  
box has been successfully registered with the chef server  
(see Figure 12-20). 
Figure 12-20. Verifying chef client installation

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
208
AWS and Chef Provisioning Using Vagrant
Installing the Plug-ins
The following plug-ins have to be installed in Vagrant for instance and chef client 
provisioning on AWS (see Figure 12-21):
1. 
vagrant-aws 
Figure 12-21. Installing Vagrant AWS plug-in
2. 
vagrant-omnibus
This plug-in is used to install chef client on the target AWS instance using the chef 
omnibus installer (see Figure 12-22).
Figure 12-22. Installing vagrant-omnibus plug-in
Adding the AWS Box to Vagrant
Install a Vagrant box set with an AWS provider (see Figure 12-23) using the following URL:
 
https://github.com/mitchellh/vagrant-aws/raw/master/dummy.box 
Figure 12-23. Adding a AWS bos to Vagrant

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
209
Vagrantfile for AWS Provisioner
The Vagrantfile for AWS provisioning should mention the following configurations in 
the screenshot (see Figure 12-24). By default, it launches instance to EC2-classic, and if 
EC2-classic is not available in that region, it will be launched in the default VPC (virtual 
private cloud). For deploying instances in VPC, the following three attributes have to be 
mentioned in the Vagrantfile:
 
aws.private_ip_address = "10.10.10.10"
aws.security_groups = ["sg-123z212d"]
aws.subnet_id = "subnet-23b9e7h1" 
Figure 12-25. Provisioning a machine on AWS(1)
Figure 12-24. Vagrantfile for AWS provisioning
Save the Vagrantfile and use the “vagrantup --provider=aws” command to provision 
AWS instance with chef client (see Figures 12-25 and 12-26). You have to execute this 
command from the root folder.

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
210
You will be able to see the machine being provisioned in the AWS console  
(see Figure 12-27).
Log in to your instance and run chef client. It should be able to interact with the chef 
server as shown in Figure 12-28.
Figure 12-26. Provisioning a machine on AWS(2)
Figure 12-27. Machine provisioned
Figure 12-28. Chef client run

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
211
Figure 12-29. Installing plug-in
Provisioning Using Knife
Knife EC2 Plug-ins
The knife EC2 plug-in is used to manage or create instances on AWS. In the upcoming 
section we cover the installation, configuration, use of the plug-in.
Installing the Plug-in
Chef expects the knife plug-in to be located in the /opt/chef/embedded/bin directory. 
Any plug-in for knife can be installed using the following syntax:
 
/opt/chef/embedded/bin/gem install plugin_name
 
To install the knife EC2 plug-in (see Figure 12-29) run the following command:
 
/opt/chef/embedded/bin/gem install knife-ec2 
Configuring
After you complete the installation, the next step is to configure the plug-in so that your 
plug-in is able to communicate with your AWS account (see Figure 12-30).

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
212
Enter the access key and secret key for your account using the following syntax in the 
knife configuration file:
Knife[:aws_access_key_id] = "Your_Access_Key"
Knife[:aws_secret_access_key] = "Your_Secret_key"
Once you complete the configuration, we are ready to use the plug-in. See  
Figure 12-31 for the available commands in the EC2 plug-in.
Figure 12-30. Configuring the EC2 plug-in
Figure 12-31. Commands available
To view the list of instances in your account, run the following command.
 
Knife ec2 server list
 
This command would list out the servers in us-east1 region by default. If we want  
to list out the servers in any other region, we can do it using the –region option  
(see Figure 12-32).

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
213
To view the type of instances available for our account, run the following command:
 
Knife ec2 flavor list
 
This would list out the type of instances available in your account (see Figure 12-33).
Figure 12-33. Type of instances available
Figure 12-32. Listing the servers

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
214
The next step is to provision the server on EC2 (see Figure 12-34). We will use the 
knife EC2 server to create a command for the same.
Figure 12-34. Provisioning an instance(1)
Some of the important options needed in order to provision any instance are
-f or -flavor: The type of instance to provision.
•฀
-region: The region in which our instance will be provisioned.
•฀
-I or –image: The image to use while provisioning the instance.
•฀
-G or –groups: The name of the security group that would be 
•฀
attached to our instance. If we want to attach more than one 
security group we can provide them in a command-separated 
format. These groups should be present in our account.
-S or –ssh-key – The key that would be used to log in to our 
•฀
instance. This key should be created before running the 
command.
-x: This option is used to specify the username that would be used 
•฀
to log in to the instance. 
After the instance is provisioned, the details would be displayed on the console  
(see Figure 12-35).
Figure 12-35. Provisioning an instance(2)

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
215
To verify that your provisioning has been completed, go to the AWS console  
(see Figure 12-36).
Figure 12-37. Installing plug-in
Figure 12-36. Verifying
Knife Azure Plug-ins
Chef expects the knife plug-in to be located in the /opt/chef/embedded/bin directory. 
Any plug-in for knife can be installed using the following syntax:
 
/opt/chef/embedded/bin/gem install plugin_name
 
To install the knife Azure plug-in (see Figure 12-37), run the following command:
 
/opt/chef/embedded/bin/gem install knife-azure 

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
216
Configuring
After you have completed the installation, the next step is to configure the plug-in (see 
Figure 12-38) so that your plug-in is able to communicate with your Azure account.
Figure 12-38. Configuring the Azure plug-in
Enter the access key and secret key for your account using the following syntax in the 
knife configuration file:
Knife[:azure_publish_setting_file] = "/path_to_file"
Once you have completed the configuration, we are ready to use the plug-in. 
Figure 12-39 shows the commands available in the Azure plug-in.
Figure 12-39. List of commands available
To view the list of images available in your account, run the following command:
 
Knife azure image list
 
This command would list out the images available in all the regions (see Figure 12-40).

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
217
The next step is to provision the server on Azure. We will use the knife Azure server 
to create a command for the same.
Some of the important options needed in order to provision any instance (see 
Figure 12-41) are
-azure-dns-name: The DNS (Domain Name System)that would 
•฀
be given to our instance
-azure-source-image: The image that would be used to provision 
•฀
the instance.
-I or –image: The image to use while provisioning the instance.
•฀
–winrm-password: The password that would be used to log in to 
•฀
the instance.
-winrm-user: This option is used to specify the username that 
•฀
would be used to log in to the instance.
-u: This option is used to specify the UDP (User Datagram 
•฀
Protocol) ports that would be opened on the instance.
-Z: This option is used to specify the size of the VM. 
•฀
Figure 12-40. Listing the images

CHAPTER 12 ■ CLOUD PROVISIONING USING CHEF 
218
Figure 12-41. Provisioning an instance
After the instance is provisioned, the details would be displayed on the console.
To verify that your provisioning has been completed (see Figure 12-42), go to the 
Azure console.
Figure 12-42. Verifying the server provisioned

219
CHAPTER 13
Troubleshooting  
and Debugging
Chef Troubleshooting and Debugging
After having gone through the installation, configuration, and development aspects of 
chef, let’s now look at how we can troubleshoot and debug if something doesn’t work 
in the chef environment. In this chapter, we look at common themes in debugging and 
troubleshooting a chef environment.
Debugging Chef Client Run
Several approaches can be used to debug a chef client run.
Running Chef Client with an Empty Run List
At times, you may have issues with a chef client run; it may not run a recipe or may not 
behave as it should for chef runs.
Running the chef client with an empty run list will tell us whether the chef client 
failed because of recipes in the run list of the node, the chef client configuration of the 
node, or the issues with connectivity between the chef server and the client.
If chef client fails with an empty run list, it can be for one of the following reasons:
1. 
Ports required for a chef client are blocked by a firewall or 
the network connectivity between the server and the client is 
unavailable. Running an empty run list will indicate whether 
the connection has become timed out or there is a network 
down error (see Figure 13-1).

CHAPTER 13 ■ TROUBLESHOOTING AND DEBUGGING 
220
2. 
The user does not have permissions to run chef client. When 
users do not have the required permissions on the chef client, 
they get a permission denied error (see Figure 13-2).
Figure 13-1. Chef client run
Figure 13-2. Permissions error
3. 
There is an invalid validation key or invalid client.rb file to 
access the chef server. In the case of an invalid client.rb file 
or invalid validation key, you will see the connection refused 
error (see Figure 13-3).
Figure 13-3. Configuration file missing
4. 
For a hosted chef, if the client node is behind proxy, invalid 
proxy settings can lead to failed chef client runs (see 
Figure 13-4). Due consideration should be given to correct 
proxy configuration to ensure that it allows connection 
between chef client and chef server.
Figure 13-4. Proxy setting error

CHAPTER 13 ■ TROUBLESHOOTING AND DEBUGGING 
221
Running Chef Client in Debug Mode
Running chef client in debug mode (see Figure 13-5) will give you the verbose output 
of each and every action executed by the chef client. You can specify the log level in 
the client.rb file get the output in a client.log file or you can run the debug level 
command directly from the terminal.
Figure 13-5. Debugging chef client
There are three main levels for debugging chef client runs.
1. 
Info: To run chef client in this mode run chef-client –l info.
2. 
Debug: To run chef client in this mode run chef-client –l debug.
3. 
Warn: To run chef client in this mode run chef-client –l warn.
Using Chef Client Log Files
The log file location has to be mentioned in the client.rb file present inside /etc/chef 
folder. Use the following parameter in the client.rb file to set the log details.
 
log_location "/var/log/chef/chef-client.log
 
Once the chef client run is finished, you can get insight about the chef client run 
from the log file (see Figure 13-6).

CHAPTER 13 ■ TROUBLESHOOTING AND DEBUGGING 
222
Types of Log Errors
A log file starts with the internal chef logs. Following are the types of warning and errors 
you find in the log file:
WARN: You get a warning when you have situations like an 
empty run list.
FATAL: This indicates that the chef resource has failed to 
execute. You can find what failed using the ERROR level in the 
log file.
ERROR: This indicates that the chef client was unable to load 
the exception handlers, when it fails to execute a resource, or 
when a package installation fails.
Using Chef Handler Cookbook
Chef handler is a cookbook that helps in handling exceptions happening during a chef 
client run. This cookbook can be obtained from the chef community cookbooks. This 
cookbook has a chef_handler lightweight resource provider. This cookbook can be used 
to make product specific handlers, so that the chef client will handle the exceptions in the 
way that you specify in your cookbooks with chef_handler resource.
Put the recipe chef_handler at the start of the node’s run list to make sure that 
custom handlers are loaded early on in the chef run and available for the other recipes.
Download the chef_handler cookbook using knife (see Figure 13-7).
 
Knife cookbook download chef_handler
 
Figure 13-6. Using log files

CHAPTER 13 ■ TROUBLESHOOTING AND DEBUGGING 
223
Untar the cookbook and Upload the cookbook to the chef server.
 
Knife cookbook upload chef_handler
 
Add the chef_handler recipe to the nodes run list (see Figure 13-8).
Figure 13-7. Downloading chef handler cookbook
Figure 13-8. Adding the cookbook to the run list
You can include the chef_handler libraries in your recipes by including the  
chef_handler recipe to your custom recipe. The chef_handler dependency has to be 
added to your cookbooks metadata.
 
include_recipe 'chef_handler'
Debugging Recipes Using Logs
Chef logs can be used to debug recipes. During a chef client run, the logs are written to 
the log file specified in the client.rb file. For debugging information, chef client has to 
run in debug mode. This can be set in the client.rb file using log_level parameter value 
to :debug.
Common Errors
Cookbook Not Found 
We get this error if a cookbook is added to the run list of a node but the cookbook is not 
present on the server. In this case the chef client will fail and “cookbook does not exist on 
the server” will appear as shown in Figure 13-9.

CHAPTER 13 ■ TROUBLESHOOTING AND DEBUGGING 
224
This error can be resolved by adding the cookbook with a relevant name  
(see Figures 13-10 and 13-11) to the run list of the node.
Figure 13-9. Cookbook not found
Figure 13-10. Adding the cookbook with the right name
Figure 13-11. Error resolved
Package Installation Error
If the package installation has any errors (see Figure 13-12), you can find the error in the 
log file with the package name associated with it.

CHAPTER 13 ■ TROUBLESHOOTING AND DEBUGGING 
225
This error can occur for any of the following reasons:
Repository not configured.
•฀
Package with that name does not exist in the repository.
•฀
This error can be resolved by configuring the repository and ensuring it is reachable. 
Also, you must provide a valid name for the package.
Using a Log Resource
A log resource can be used inside recipes to write to log files. For example, if you want to  
log an entry when a particular data bag item is used in your recipe, you can use the log 
resource in the data bag block to do that. Log resource uses Chef::Provider::Log::ChefLog 
during the chef client run. The screenshot in Figure 13-13 shows how to use the breakpoints 
in recipes.
Figure 13-12. Unable to install package
Figure 13-13. Using the log resource
Debugging Recipes Using Chef Shell
Chef shell is a recipe debugging tool which runs as an interactive ruby session. Using chef 
shell, you can run a recipe on debugging mode to trace the errors.

CHAPTER 13 ■ TROUBLESHOOTING AND DEBUGGING 
226
Configuring Chef Shell
The chef shell has three modes:
1. 
Stand-alone: it is the default mode and no cookbooks will  
be loaded in this mode. Chef shell stand-alone mode  
(see Figure 13-14) can be started using chef shell command.
Figure 13-14. Stand-alone mode of chef shell
2. 
Chef solo: in this mode, the chef shell will have the chef solo 
functionalities (see Figure 13-15). In this mode, chef shell will 
load the chef solo cookbooks and JSON (Java Script Object 
Notations) attributes. You can activate the chef solo mode 
using “chef shell –s” command.
Figure 13-15. Chef solo mode of chef shell
3. 
Chef client: in this mode, the chef shell will have the chef 
client functionalities (see Figure 13-16). To use this mode you 
have to place a chef-shell.rb file with few parameters inside 
the /etc/chef folder.

CHAPTER 13 ■ TROUBLESHOOTING AND DEBUGGING 
227
You can run the recipes from the nodes run list in debugging mode and you can  
trace errors in the recipe (see Figure 13-17). You can activate the chef client mode using 
“chef shell –z” command.
Figure 13-16. Chef client mode of chef shell
Figure 13-17. Running recipes
Whenever the chef shell is loaded in chef client mode, all the recipes in the nodes 
run list will be loaded to the cache. You can debug the recipes in the run list using run 
chef command (see Figure 13-18).
Figure 13-18. Debugging recipes
Debugging Recipes Using Breakpoint Resource
You can do block level debugging using breakpoint resource (see Figure 13-19). While 
testing cookbooks include the breakpoint resource after every resource block to have a 
block level debugging.

CHAPTER 13 ■ TROUBLESHOOTING AND DEBUGGING 
228
To debug a recipe with breakpoint, change the chef shell mode to recipe mode  
(see Figure 13-20) using “recipe_mode” command and run the chef client using the 
“run_chef” command.
Figure 13-19. Debugging recipes using breakpoint resource
Figure 13-20. Debugging recipes using breakpoint resource with chef shell
The “run_chef” command will run the recipe until the breakpoint specified in 
the recipe. Once you have debugged until the breakpoint, run the “chef_run.resume” 
command to resume the chef client run from the breakpoint (see Figure 13-21).
Figure 13-21. Resuming the chef client

CHAPTER 13 ■ TROUBLESHOOTING AND DEBUGGING 
229
Troubleshooting Chef Client
Chef Client Fails to Run a Recipe Successfully at  
Bootstrapping
Run chef client to set up the connection with the chef server. It will run with an empty run 
list. After it is connected, log in to http://yourcherver.com:443, add the roles/recipes to 
the client node, and run the chef client from the client again.
Reregistering a Removed Client
The reregistration process is required if the client is unable to authenticate itself with 
the chef server. To reregister a removed client from the chef server, remove the  
client.pem file from /etc/chef folder and run the chef client on the node. Before 
running the chef client, make sure that the node object of the removed client is also 
removed from the chef server.
Issues Registering Chef Client with the Server
While registering a node with chef server, the registration might fail for the following 
reasons:
1. 
The client name already exists in the chef server  
(see Figure 13-22): this issue can be fixed by deleting the 
existing client name from the server.
Figure 13-22. The client name that exists in error
2. 
Invalid chef server URL (uniform resource locator)  
(see Figure 13-23): check whether the chef server URL is 
specified correctly in the client.rb file of the node.

CHAPTER 13 ■ TROUBLESHOOTING AND DEBUGGING 
230
3. 
Invalid validation key (Figure 13-24): check whether the 
validation key specified in the client.rb file and the validation 
key that is present inside the /etc/chef folder are valid.
Figure 13-24. The invalid validation key
Figure 13-23. The URL not valid error

CHAPTER 13 ■ TROUBLESHOOTING AND DEBUGGING 
231
Removing chef node from a server:
 
knife client delete NODENAME
knife node delete NODENAME
 
On an affected node, remove the client.pem file and run the chef client again.
 
sudo rm /etc/chef/client.pem
sudo chef-client
Clock Synchronization Error
This error happens when your client node’s clock drifts from the actual time by more 
than 15 minutes (see Figure 13-26). You can fix this by syncing your clock with an NTP 
(Network Time Protocol) server. Run the chef client after synching the clock.
401 Unauthorized Errors
401 Unauthorized errors happen (see Figure 13-25) for the following reasons:
1. 
Incorrect client.pem file: this error can be rectified by 
deleting the existing client.pem file from the /etc/chef folder 
and reregistering the node with the chef server.
Figure 13-25. Authentication error

CHAPTER 13 ■ TROUBLESHOOTING AND DEBUGGING 
232
No Such File or Directory: /etc/chef/validation.pem
This error happens when the validation key is not present in the default /etc/chef folder. 
This can be rectified by copying the validator key from the chef server to the nodes /etc/
chef folder.
Cannot Find Config File
This error happens when the client.rb file is not present in the default chef directory 
on the node (see Figure 13-27). You can work around this issue by adding the path to of 
client.rb file using –c switch.
 
chef-client -c C:\chef\client.rb
 
Figure 13-27. Not able to find the client configuration file
Figure 13-26. A clock sync error

A, B









Amazon web services (AWS), 49
Application programming  
interface (API), 47
Attribute iles
deinition, 114
methods, 114–115
precedence, 115–116
types, 114
C









Chef server, 1
automated infrastructure, 9
compilation, 11
deinition, 21
description, 10
Erlang
Asynchronous message  
passing, 18
features, 19
Grained concurrency, 18
overview, 17
portability, 20
Facebook, 11
features, 22
infrastructure as a code, 2
internet companies  
and enterprises, 11
knife (see Knife)
nodes, 4
cloud-based, 5
components, 5
physical, 5
open source chef server
Bookshelf, 24
ChefSolr, 25
cookbook iles, 24
Erchef, 25
message queue, 25
Nginx, 23
ports, 26
Postgresql, 26
structure, 26
WebUI, 24
working of, 23
overview of, 4
principles, 10
chefclient, 11
chefserver, 11
idempotence, 11
Ruby
arrays, 14
methods, 17
operators, 15
strings, 13
variables, 12
server
chefsolo, 7
cookbook, 7
enterprise chef, 6
open source chef, 6
types
enterprise chef, 22
hosted enterprise chef, 21
open source chef server, 22
Vagrant provisioning
chef solo provisioner, 204
JSON, 206
node_name option, 206
node object, 207
roles, 205
run list, 205, 207
using chef client, 206
using data bags, 206
Index
233

Vagrantile, 203–204
veriication, 207
working principles, 5
Cloud provisioning
Knife Azure Plug-ins
installation, 215
Knife azure image  
list command, 216–217
syntax, 215–216
veriication, 218
Knife EC2 Plug-ins
coniguration ile, 212
installation, 211
Knife ec2 lavor list command, 213
Knife ec2 server list  
command, 212
type of instances, 213–214
usage, 211
veriication, 215
vagrant tool (see Vagrant)
Coniguration ile (Client.rb), 57
Cookbooks, 119
application/component, 87
attribute, 160
creation, 154
directory structure of, 154
attribute iles (see Attribute iles)
deinitions, 116
library, 117
metadata, 118
recipes (see Recipes)
resources and providers (see 
Resources and providers)
working principles, 88
environment
coniguration, 166
creation, 163
edit, 164
nodes, 165
testing, 167
low chart, 153
index ile creation, 157
metadata, 158
MySQL (see MySQL)
Nginx
coniguration ile, 131
default function, 125
directory permissions, 130
downloading, 126
epel deinition, 129
installations, 132
internet connection, 125
log directory, 132
nxensite ile, 130
ohai_plugins directory, 128
platform support, 125
run list, 127
uploading, 127
run list, 158
Squid, 133
chef client run, 135
directory permissions, 137
downloading, 133
installations, 136
mime.conf creation, 136
platforms support, 133
uploading, 134
subcommand, 71
bulk delete, 72
creation, 72
delete, 73
download, 73, 76
installation, 76
list, 73, 76
search, 77
show, 74, 77
test, 75
upload, 75
template ile, 160–161
testing, 162
Tomcat
chef client, 147
downloading, 145
ile coniguration, 150
installation, 148, 152
Java environment variables, 148
package, 149
platform, 145
read-write permissions, 150
uploading, 146
uploading, 158
Wordpress
client running, 140
downloading, 138
installation, 143–144
internet connection, 138
package autoconf, 141–142
systems support, 138
uploading, 139–140
wp-conig.php ile, 143
writing recipes, 155
234
■฀INDEX
Chef server (cont.)

D









Debugging
breakpoint resource, 227
chef client mode, 227
chef client run, 219
chef handler cookbook, 222–223
chef logs, 223
chef solo mode, 226
cookbook error, 223–224
log errors types, 222
log ile, 221–222
log resource, 225
package installation, 224
permissions error, 220
proxy error, 220
resolved error, 224
running chef client, 219–221
stand-alone mode, 226
tools, 225
Domain Name System (DNS), 217
E, F, G









Enterprise chef HA, 191–192
Erlang
asynchronous message passing, 18
concurrent programming  
languages, 19
features
concurrency, 19
distribution, 20
robust, 20
sequential, 20
functional and logic programming 
languages, 19
grained concurrency, 18
overview, 17
H









High availability (HA)
Elastic load balancer (ELB), 179
enterprise chef
application tier/back-end tier, 191
web tier, 191
setup, 179
streaming replication, 179
chef server, 180
cookbook, 190
description, 180
master node, 184
repmgr, 180
slave node, 187
veriication, 189
warm standby/log shipping, 179
I








Installation
chef server
coniguration, 31
downloading, 29
foregoing command, 31
RHEL OS, 30
testing, 32
web interface, 33
ile locations, 38
Bookshelf services, 39
chef-server.rb ile, 39
opscode-erChef service, 41
opscode-expander service, 40
opscode-solr service, 40
opscode-webui service, 42
postgresql service, 41
SOLR search index, 41
hardware prerequistie, 27
hostname command, 28
system requirements, 27
virtual machine
built-in command, 36
chef server package, 33–34
coniguration, 35
ifconig command, 37
network adapter, 37
RHEL, 34
testing, 36
web interface, 38
J









JavaScript Object Notation (JSON), 52
JavaScript Object Notiication (JSON), 89
K









Knife
bootstrap subcommand, 64
client subcommand
creation, 66
delete, 67
edit, 67
235
■฀INDEX

list, 68
multiple deletion, 66
reregister, 69
show, 69
conigure command
client coniguration (Client.rb), 70
knife coniguration (Knife.rb), 71
cookbook subcommand, 71
bulk delete, 72
creation, 73
delete, 73
download, 73, 76
installation, 76
list, 74, 76
search, 77
show, 74, 77
test, 75
upload, 75
data bag subcommand, 77
delete subcommand, 77
download subcommand, 78
environment subcommand, 79
node subcommand, 80
recipes subcommand, 80
role subcommand, 81
search command, 82
show command, 82
SSH command, 83
tag subcommand, 85
upload subcommand, 86
working principles, 61
L









Lightweight resource providers (LWRPs)
chef maintainence, 170
creation
Action:remove:method, 174
cookbook uploading, 176
default attribute, 172
directory structure, 172
run bash scripts, 173
run chef client, 176
Veriication, 177
whyrun method, 173
wp_path attribute, 176
wp_url attribute, 176
wrapper method, 173–174
description, 169
directories, 169–170
M









Metadata, 118
MySQL
chef testing
chef client running, 122
grant table, 124
log directory creation, 122
logging admin, 124
log in, 125
root password, 123
run end, 124
run list, 121
downloading, 119
internet connection, 119
password generation, 119
platforms support, 119
uploading, 120
N, O, P, Q









Nodes
coniguration
Bootstrapping, 56–57
chef client package, 54–56
chef validator key, 56
client coniguration ile  
(Client.rb), 56–57
FQDN, 56
OS identifyication, 54
policies, role, 56
deinitions, 49
managed node
attributes, 53
chef client, 50
chef run, 50–51
client coniguration ile, 52
cookbooks, 52
resources identiier, 53
RSA encryption mechanism, 52
run list, 52
update method, 53
node_name, 49
types, 49
R









Recipes
assignment operator, 91
case statement, 91–92
data bags creation, 89–90
236
Knife (cont.)
■฀INDEX

DSL, 94
platform_family method, 95
platform method, 95
value_for_platform_family 
method, 97–98
value_for_platform method, 96
exception handlers and log iles, 93
if expression, 92
include_recipe keyword, 92
run list, 93
searching in, 91
secret key, 90
Storing keys, 90
tag, 93–94
unless expression, 92
Resources and providers
components, 99–100
cookbook_ile resource, 100
crontab program, 101
deinition, 98
directory, 102–103
env, 103–104
execute command, 104
iles, 106
package, 107–108
platform class maps, 99
powershell_script, 108–109
remote_ile, 109
script, 111
service, 111–112
template, 113
Ruby, 11
array, 14
methods, 17
operators
arithmetic operators, 16
bitwise operators, 17
comparison operators, 16
math operators, 15
string, 13
variables, 12
S









Streaming replication, 179
chef server, 180
cookbook, 190
description, 180
master node
archiving, 186
coniguration, 185
postgre directory, 184
restarting, 187
trust setup, 186
veriication, 187
repmgr setup, 180
downloading, 181
extracting, 182
install GCC, 181
path directory, 183
postgres directory, 182
veriication, 184
slave node
cloning, 188
restarting, 189
veriication, 189
veriication, 189
T









Troubleshooting, 219
authentication error, 231
chef server registering, 229
client coniguration ile, 232
clock sync error, 232
reregistration process, 229
run chef client, 229
unauthorized errors, 231
validation key, 230, 232
U









Uniform resource locator (URL), 47, 229
User Datagram Protocol (UDP), 217
V









Vagrant
AWS and Chef
plug-ins installation, 208
Vagrantile, 209
coniguration
Vagrant boxes (Linux based), 198
Vagrantile, 199
VM (see Virtual machine (VM))
deinition, 193
installation
veriication, 198
virtual box, 194
Windows, 194
Plug-Ins installation, 202
providers, 194
provisioners, 194
usage, 193
237
■฀INDEX

Virtual machine (VM)
installation
built-in command, 36
chef server package, 33, 35
coniguration, 35
ifconig command, 37
network adapter, 37
RHEL, 34
testing, 36
web interface, 38
Vagrant
destroy command, 202
halt command, 202
ssh command, 200–201
suspend command, 201
up command, 200
W, X, Y, Z









Workstation
prerequisite, 43
coniguring knife, 46–47
Identifying operating system, 44
installation and coniguration, 44
installation chef client package, 45
install git (optional), 47
installing chef package, 46
keys and coniguration iles, 46
knife coniguration in the chef 
directory, 48
operating system support, 44
relevant method, 45
veriication, 48
238
■฀INDEX

Automation through 
Chef Opscode
A Hands-on Approach to Chef
Navin Sabharwal
Manak Wadhwa

Automation through Chef Opscode
Copyright © 2014 by Navin Sabharwal and Manak Wadhwa
his work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part 
of the material is concerned, speciically the rights of translation, reprinting, reuse of illustrations, 
recitation, broadcasting, reproduction on microilms or in any other physical way, and transmission 
or information storage and retrieval, electronic adaptation, computer software, or by similar or 
dissimilar methodology now known or hereafter developed. Exempted from this legal reservation are 
brief excerpts in connection with reviews or scholarly analysis or material supplied speciically for 
the purpose of being entered and executed on a computer system, for exclusive use by the purchaser 
of the work. Duplication of this publication or parts thereof is permitted only under the provisions 
of the Copyright Law of the Publisher’s location, in its current version, and permission for use must 
always be obtained from Springer. Permissions for use may be obtained through RightsLink at the 
Copyright Clearance Center. Violations are liable to prosecution under the respective Copyright Law.
ISBN-13 (pbk): 978-1-4302-6295-4
ISBN-13 (electronic): 978-1-4302-6296-1
Trademarked names, logos, and images may appear in this book. Rather than use a trademark 
symbol with every occurrence of a trademarked name, logo, or image we use the names, logos, and 
images only in an editorial fashion and to the beneit of the trademark owner, with no intention of 
infringement of the trademark.
he use in this publication of trade names, trademarks, service marks, and similar terms, even if they 
are not identiied as such, is not to be taken as an expression of opinion as to whether or not they  
are subject to proprietary rights.
While the advice and information in this book are believed to be true and accurate at the date of 
publication, neither the authors nor the editors nor the publisher can accept any legal responsibility 
for any errors or omissions that may be made. he publisher makes no warranty, express or implied, 
with respect to the material contained herein.
Publisher: Heinz Weinheimer 
Lead Editor: Saswata Mishra
Technical Reviewers: Kalyan Kumar and Piyush Pandey
Editorial Board: Steve Anglin, Mark Beckner, Ewan Buckingham, Gary Cornell, Louise Corrigan, 
Jonathan Gennick, Jonathan Hassell, Robert Hutchinson, Michelle Lowman,  
James Markham, Matthew Moodie, Jef Olson, Jefrey Pepper, Saswata Mishra,  
Douglas Pundick, Ben Renow-Clarke, Dominic Shakeshaft, Gwenan Spearing, Matt Wade, 
Steve Weiss
Coordinating Editor: Mark Powers
Copy Editor: Lori Jacobs
Compositor: SPi Global
Indexer: SPi Global
Artist: SPi Global
Cover Designer: Anna Ishchenko
Distributed to the book trade worldwide by Springer Science+Business Media New York,  
233 Spring Street, 6th Floor, New York, NY 10013. Phone 1-800-SPRINGER, fax (201) 348-4505,  
e-mail orders-ny@springer-sbm.com, or visit www.springeronline.com. Apress Media, LLC is a 
California LLC and the sole member (owner) is Springer Science + Business Media Finance Inc 
(SSBM Finance Inc). SSBM Finance Inc is a Delaware corporation. 
For information on translations, please e-mail rights@apress.com, or visit www.apress.com. 
Apress and friends of ED books may be purchased in bulk for academic, corporate, or promotional 
use. eBook versions and licenses are also available for most titles. For more information, reference 
our Special Bulk Sales–eBook Licensing web page at www.apress.com/bulk-sales.
Any source code or other supplementary material referenced by the author in this text is available 
to readers at www.apress.com/9781430262954. For detailed information about how to locate your 
book’s source code, go to www.apress.com/source-code/.

Dedicated to the people I love and God whom I trust.
—Navin
Dedicated to all the people who have supported me in  
diicult times and have helped me grow into the individual  
who I am today, God, and the people I love.
—Manak

vii
Contents
About the Authors ............................................................................ xv
About the Technical Reviewers ...................................................... xvii
Acknowledgments .......................................................................... xix
Introduction .................................................................................... xxi
Chapter 1: Introduction
 
■
 .................................................................. 1
Infrastructure as Code ............................................................................. 1
Overview ................................................................................................. 4
Nodes........................................................................................................................4
Workstation ..............................................................................................................5
Server .......................................................................................................................6
The Value of Chef .................................................................................... 9
Why Chef? ............................................................................................. 10
Core Principles of Chef .......................................................................... 10
Idempotence ...........................................................................................................11
Thick Client, Thick Server .......................................................................................11
Order of Execution ..................................................................................................11
Who Uses Chef? .................................................................................... 11
Key Technologies ................................................................................... 11
Ruby ........................................................................................................................11
Erlang .....................................................................................................................17

■฀CONTENTS
viii
Chapter 2: The Chef Server
 
■
 ........................................................... 21
The Chef Server ..................................................................................... 21
Types of Chef Server ...............................................................................................21
Extra Functionalities in Enterprise Chef .................................................................22
Components of Open Source Chef Server ..............................................................23
Chapter 3: Installation
 
■
 .................................................................. 27
Install the Chef Server ........................................................................... 27
Prerequisite ............................................................................................................27
Installation ..............................................................................................................29
Installation on a Virtual Machine ............................................................................33
File System locations..............................................................................................38
Conﬁguration ......................................................................................... 38
Optional Settings ....................................................................................................39
Chapter 4: Workstation
 
■
 ................................................................. 43
Prerequisite ........................................................................................... 43
Operating System Support......................................................................................44
Install and Conﬁgure a Workstation ........................................................................44
Chapter 5: Nodes
 
■
 .......................................................................... 49
Types of Nodes ...................................................................................... 49
Node Names .......................................................................................... 49
Manage Nodes ...................................................................................... 50
Chef Client ..............................................................................................................50
The Chef Run ..........................................................................................................50
Install and Conﬁgure the Node .............................................................. 54
Identify the Operating System ................................................................................54
Bootstrap ................................................................................................................56
Conﬁguring  ............................................................................................................57

■฀CONTENTS
ix
Chapter 6: Working with Knife
 
■
 ..................................................... 61
Working with Knife ................................................................................ 61
Bootstrap ................................................................................................................64
Client ......................................................................................................................66
Conﬁgure ................................................................................................................70
Cookbook ................................................................................................................71
Cookbook Site .........................................................................................................75
Data Bag .................................................................................................................77
Delete .....................................................................................................................77
Download ................................................................................................................78
Environment ...........................................................................................................79
Node .......................................................................................................................80
Recipe List ..............................................................................................................80
Role.........................................................................................................................81
Search ....................................................................................................................82
Show .......................................................................................................................82
SSH .........................................................................................................................83
Tag ..........................................................................................................................85
Upload.....................................................................................................................86
Chapter 7: Cookbooks
 
■
 .................................................................. 87
Basics of Cookbooks ............................................................................. 87
Cookbook Directory Structure ............................................................... 88
Recipes ...................................................................................................................88
Resources and Providers ........................................................................................98
Attributes Files .....................................................................................................114
Deﬁnitions ............................................................................................................116
Libraries ................................................................................................................117
Metadata ..............................................................................................................118

■฀CONTENTS
x
Chapter 8: Using Cookbooks
 
■
 ....................................................... 119
MySQL(4.1.2) ....................................................................................... 119
Platform ................................................................................................................119
Dependencies .......................................................................................................119
Prerequisite ..........................................................................................................119
Cookbook Download .............................................................................................119
Cookbook Upload ..................................................................................................120
Client Run .............................................................................................................121
Nginx(2.4.2) ......................................................................................... 125
Platform ................................................................................................................125
Dependencies .......................................................................................................125
Prerequisite ..........................................................................................................125
Cookbook Download .............................................................................................126
Cookbook Upload ..................................................................................................127
Client Run .............................................................................................................127
Squid(0.4.0) ......................................................................................... 133
Platform ................................................................................................................133
Cookbook Download .............................................................................................133
Cookbook Upload ..................................................................................................134
Client Run .............................................................................................................135
Wordpress(2.1.0) ................................................................................. 138
Platform ................................................................................................................138
Dependencies .......................................................................................................138
Prerequisite ..........................................................................................................138
Cookbook Download .............................................................................................138
Cookbook Upload ..................................................................................................139
Client Run .............................................................................................................140

■฀CONTENTS
xi
Tomcat(0.15.0)..................................................................................... 145
Platform ................................................................................................................145
Dependencies .......................................................................................................145
Cookbook Download .............................................................................................145
Cookbook Upload ..................................................................................................146
Client Run .............................................................................................................147
Chapter 9: Developing a Cookbook
 
■
 ............................................. 153
Developing Your First Cookbook .......................................................... 153
Writing a Recipe .................................................................................. 155
Creating the Index File ........................................................................ 157
Changing the Metadata ....................................................................... 158
Uploading the Cookbook ..................................................................... 158
Running the Cookbook ........................................................................ 158
Add an Attribute .................................................................................. 160
Add a Resource to the Default Recipe ................................................. 160
Add the Template File .......................................................................... 161
Uploading and Running the Cookbook ................................................ 161
Using Environments ............................................................................ 162
Chapter 10: Lightweight Resource Providers
 
■
 ............................. 169
Lightweight Resource Providers ......................................................... 169
Chef-Maintained LWRPs .......................................................................................170
Creating an LWRP ................................................................................ 171

■฀CONTENTS
xii
Chapter 11: High Availability
 
■
 ...................................................... 179
Prerequisite ......................................................................................... 179
Setting Up HA ...................................................................................... 179
Streaming Replication ..........................................................................................179
Cookbook Replication ...........................................................................................190
Enterprise Chef HA .............................................................................. 191
Chapter 12: Cloud Provisioning Using Chef
 
■
 ................................ 193
Provisioning Using Vagrant and Chef .................................................. 193
Providers and Provisioners .................................................................. 193
Installing Vagrant ................................................................................. 194
Install Virtual Box ..................................................................................................194
Install Vagrant on Windows ..................................................................................194
Verifying Vagrant Installation ................................................................................198
Conﬁguring Vagrant ............................................................................. 198
Vagrant Boxes (OS Images) ..................................................................................198
Two Methods to Download Vagrant Box ...............................................................198
Vagrantﬁle ............................................................................................................199
Provisioning a New Instance ................................................................................200
Connecting to a Virtual Machine ...........................................................................200
Suspending the Virtual Machine ...........................................................................201
Halting the Virtual Machine ..................................................................................202
Destroying the Virtual Machine .............................................................................202
Installing Vagrant Plug-Ins ....................................................................................202
Vagrant Provisioning Using Chef ......................................................... 203
Chef Solo Provisioner ...........................................................................................204
Options .................................................................................................................204
Specifying a Run List ............................................................................................205
Specifying Roles ...................................................................................................205

■฀CONTENTS
xiii
Using Data Bags ...................................................................................................206
Specifying Node Name .........................................................................................206
Custom JSON Data ...............................................................................................206
Provisioning Chef Client  .......................................................................................206
Adding Run List ....................................................................................................207
Deleting the Node Details .....................................................................................207
Verifying Chef Client Registration with Chef Server .............................................207
AWS and Chef Provisioning Using Vagrant .......................................... 208
Installing the Plug-ins ...........................................................................................208
Adding the AWS Box to Vagrant ............................................................................208
Vagrantﬁle for AWS Provisioner ............................................................................209
Provisioning Using Knife ...................................................................... 211
Knife EC2 Plug-ins ................................................................................................211
Knife Azure Plug-ins .............................................................................................215
Chapter 13: Troubleshooting and Debugging
 
■
 ............................... 219
Chef Troubleshooting and Debugging .................................................. 219
Debugging Chef Client Run ................................................................. 219
Running Chef Client with an Empty Run List ........................................................219
Running Chef Client in Debug Mode .....................................................................221
Using Chef Client Log Files ...................................................................................221
Types of Log Errors ...............................................................................................222
Using Chef Handler Cookbook ..............................................................................222
Debugging Recipes Using Logs ........................................................... 223
Common Errors .....................................................................................................223
Using a Log Resource ...........................................................................................225
Debugging Recipes Using Chef Shell .................................................. 225
Conﬁguring Chef Shell ..........................................................................................226
Debugging Recipes Using Breakpoint Resource ..................................................227

■฀CONTENTS
xiv
Troubleshooting Chef Client ................................................................ 229
Chef Client Fails to Run a Recipe Successfully at Bootstrapping .........................229
Reregistering a Removed Client ...........................................................................229
Issues Registering Chef Client with the Server ....................................................229
401 Unauthorized Errors ..................................................................... 231
Clock Synchronization Error .................................................................................231
No Such File or Directory: /etc/chef/validation.pem .............................................232
Cannot Find Conﬁg File .........................................................................................232
Index .............................................................................................. 233

xv
About the Authors
Navin Sabharwal is an Innovator, hought Leader, Author, and Consultant in the areas 
of cloud computing and lifecycle management, DevOps, automation, and coniguration 
management tools such as chef, Puppet, BMC CLM, HP CDA, IBM Jazz, ITOps, runbook 
automation, and software product development.
Navin has been involved in the creation of IP Development & Service Delivery in the 
areas of cloud computing, AWS, Azure, data center automation, DevOps, and IT analytics.
Manak Wadhwa holds a master’s degree in information technology from Indian Institute 
of Information Technology and has been working as DevOps engineer in HCL for the past 
two years. He has also worked with various data center automation tools such as chef, 
Puppet, and Ansible.
Manak has also been working on various public cloud platforms which include  
AWS and Azure. 
.

xvii
About the Technical 
Reviewers
Kalyan Kumar is the Chief Technologist for HCL Technologies–ISD and leads all the 
Global Technology Practices.
In his current role Kalyan is responsible deining Architecture & Technology Strategy, 
New Solutions Development & Engineering across all Enterprise Infrastructure, Business 
Productivity, Uniied Communication Collaboration & Enterprise Platform/DevOps 
Service Lines. Kalyan is also responsible for Business and Service Delivery for Cross 
Functional Services & SIAM for HCL across all service lines globally.
Kalyan is widely acknowledged as an expert and path-breaker on BSM/ITSM & IT  
Architecture and Cloud Platforms and has developed many IPs for the company in 
these domains. He is also credited with building HCL MTaaSTM Service from the 
scratch, which has a multi-million turnover today and a proprietary benchmark for 
Global IT Infrastructure Services Delivery. His team is also credited with developing 
the MyCloudSM platform for Cloud Service Management & MyDevOps, which is a 
pioneering breakthrough in the Utility Computing and Hybrid Agile Ops Model space.  
He has been presented with many internal and industry awards for his thought 
leadership in the IT Management space.
Kalyan also runs the HCL ISD IPDEV Incubator Group where he is responsible  
for incubating new services, platforms and IPs for the company. Additionally,  
he co-authored the Book Process Excellence for IT Operations: A practical guide to  
IT Service Management (http://tinyurl.com/k7u3wyf).
Kalyan has spoken at many prestigious industry platforms and is currently actively 
engaged in the Partner Advisory Board of CA Technologies, and IBM Cloud & Smarter 
Infrastructure BOA.
In his free time Kalyan likes to jam with his band Contraband as a  
drummer /percussionist and reviews Consumer Technology Gadgets and follows  
Cricket Games diligently. Kalyan lives in New Delhi, India with his family. He can be 
followed on Twitter @KKLIVE and at Linkedin (http://www.linkedin.com/in/kalyankumar).
Piyush Pandey is currently working as Track Lead at HCL Comnet, where he oversees 
the DevOps, Service Automation and Cloud Lifecycle Management Practice for HCL’s 
UK oice. He is responsible for designing automation solutions for enterprise IT 
infrastructure management. In the past four years, he has developed enterprise tools 
for the public cloud (AWS, Azure, Google Compute); Automation tools (BMC, HP CA, 
Microsoft, Puppet, Chef, and Cobbler); orchestration tools (BMC AO, Microsoft System 
Center Orchestrator, and VMWare orchestrator); and monitoring tools (Nagios, Zenoss, 
and SCOM).

xviii
■฀ABOUT THE TECHNICAL REVIEWERS
He has worked to provide Automation Solutions for Fortune 500 clients such as 
AstraZeneca, News International, Cummins, Ingram Micro, SGX, GulfStream and Xerox. 
He holds a Bachelor’s degree in computer engineering from NSIT Delhi.

xix
Acknowledgments
Special thanks to Himanshu Tyagi, Bibin W, Piyush Pandey, and Rohit Sharma for all their 
help and support. Also, this book would not have been possible without Saswata Mishra, 
Mark Powers, and the rest of the team at Apress. It has been wonderful to work with the 
Apress team.
hanks for the motivation and review by Kalyan Kumar, who has been instrumental 
in guiding us through the journey on automation.
Special thanks to Dheeraj Raghav and Rajendra Prasad who used their creativity to 
make the book images look beautiful. 

