Operating System Design
Douglas Comer
The Xinu Approach
Second Edition

Operating System Design 
The Xinu Approach
Second Edition


Operating System Design
Douglas Comer
The Xinu Approach
Second Edition

UNIX is a registered trademark in the United States and other countries, licensed exclusively through X/Open Company, Ltd. Linux is a registered trade-
mark of Linus Torvalds. In the United States, Linux is a trademark registered to Linus Torvalds. Microsoft Windows is a trademark of Microsoft Cor-
poration. Microsoft is a registered trademark of Microsoft Corporation. Solaris is a trademark of Sun Microsystems, Incorporated. MIPS is a registered 
trademark of MIPS Technologies, Inc. IBM is a registered trademark of International Business Machines. Mac is a trademark of Apple, Inc. Intel is a 
registered trademark of Intel Corporation. Galileo is a registered trademark of Intel Corporation. mini-PCI Express is a trademark of Intel Corporation. 
ARM is a registered trademark of ARM Limited. Other trademarks are the property of their respective owners.
CRC Press
Taylor & Francis Group
6000 Broken Sound Parkway NW, Suite 300
Boca Raton, FL 33487-2742
© 2015 by Taylor & Francis Group, LLC
CRC Press is an imprint of Taylor & Francis Group, an Informa business
No claim to original U.S. Government works
Version Date: 20141204
International Standard Book Number-13: 978-1-4987-1244-6 (eBook - PDF)
This book contains information obtained from authentic and highly regarded sources. Reasonable efforts have been made to publish reliable data and 
information, but the author and publisher cannot assume responsibility for the validity of all materials or the consequences of their use. The authors and 
publishers have attempted to trace the copyright holders of all material reproduced in this publication and apologize to copyright holders if permission 
to publish in this form has not been obtained. If any copyright material has not been acknowledged please write and let us know so we may rectify in any 
future reprint.
Except as permitted under U.S. Copyright Law, no part of this book may be reprinted, reproduced, transmitted, or utilized in any form by any electronic, 
mechanical, or other means, now known or hereafter invented, including photocopying, microfilming, and recording, or in any information storage or 
retrieval system, without written permission from the publishers.
For permission to photocopy or use material electronically from this work, please access www.copyright.com (http://www.copyright.com/) or contact 
the Copyright Clearance Center, Inc. (CCC), 222 Rosewood Drive, Danvers, MA 01923, 978-750-8400. CCC is a not-for-profit organization that provides 
licenses and registration for a variety of users. For organizations that have been granted a photocopy license by the CCC, a separate system of payment 
has been arranged.
Trademark Notice: Product or corporate names may be trademarks or registered trademarks, and are used only for identification and explanation without 
intent to infringe.
Visit the Taylor & Francis Web site at
http://www.taylorandfrancis.com
and the CRC Press Web site at
http://www.crcpress.com

To my wife, Chris, and our children, Sharon and Scott


Contents
xix
Preface
xxiii
About the Author
3
Chapter 1 Introduction And Overview
1.1 
Operating Systems     3
1.2 
Approach Used In The Text     5
1.3 
A Hierarchical Design     5
1.4 
The Xinu Operating System    7
1.5 
What An Operating System Is Not     8
1.6 
An Operating System Viewed From The Outside     9
1.7 
Remainder Of The Text     10
1.8 
Perspective     11
1.9 
Summary     11
15
Chapter 2 Concurrent Execution And Operating System Services
2.1 
Introduction     15
2.2 
Programming Models For Multiple Activities     16
2.3 
Operating System Services     17
2.4 
Concurrent Processing Concepts And Terminology     17
2.5 
Distinction Between Sequential And Concurrent Programs     19
2.6 
Multiple Processes Sharing A Single Piece Of Code     21
2.7 
Process Exit And Process Termination     23
2.8 
Shared Memory, Race Conditions, And Synchronization     24
2.9 
Semaphores And Mutual Exclusion     28
2.10 
Type Names Used In Xinu     30
2.11 
Operating System Debugging With Kputc And Kprintf     31
2.12 
Perspective     32
2.13 
Summary     32

viii
Contents
37
Chapter 3 An Overview Of The Hardware And Runtime Environment
3.1 
Introduction     37
3.2 
Physical And Logical Organizations Of A Platform     38
3.3 
Instruction Sets     38
3.4 
General-purpose Registers     39
3.5 
I/O Buses And The Fetch-Store Paradigm     41
3.6 
Direct Memory Access     42
3.7 
The Bus Address Space    42
3.8 
Bus Startup And Configuration     43
3.9 
Calling Conventions And The Runtime Stack    44
3.10 
Interrupts And Interrupt Processing    47
3.11 
Vectored Interrupts     48
3.12 
Exception Vectors And Exception Processing     48
3.13 
Clock Hardware     49
3.14 
Serial Communication     49
3.15 
Polled vs. Interrupt-driven I/O     49
3.16 
Storage Layout     50
3.17 
Memory Protection     51
3.18 
Hardware Details And A System On Chip Architecture    51
3.19 
Perspective     52
3.20 
Hardware References     52
57
Chapter 4 List And Queue Manipulation
4.1 
Introduction     57
4.2 
A Unified Structure For Linked Lists Of Processes    58
4.3 
A Compact List Data Structure     59
4.4 
Implementation Of The Queue Data Structure     61
4.5 
Inline Queue Manipulation Functions     62
4.6 
Basic Functions To Extract A Process From A List     63
4.7 
FIFO Queue Manipulation     65
4.8 
Manipulation Of Priority Queues    68
4.9 
List Initialization     70
4.10 
Perspective     71
4.11 
Summary     72
75
Chapter 5 Scheduling And Context Switching
5.1 
Introduction     75
5.2 
The Process Table     76
5.3 
Process States     79
5.4 
Ready And Current States     80

Contents        
ix
5.5 
A Scheduling Policy     80
5.6 
Implementation Of Scheduling     81
5.7 
Deferred Rescheduling     85
5.8 
Implementation Of Context Switching     85
5.9 
State Saved In Memory     86
5.10 
Context Switch Operation     87
5.11 
An Address At Which To Restart A Process    91
5.12 
Concurrent Execution And A Null Process    92
5.13 
Making A Process Ready And The Scheduling Invariant     93
5.14 
Other Process Scheduling Algorithms     94
5.15 
Perspective     95
5.16 
Summary     95
99
Chapter 6 More Process Management
6.1 
Introduction     99
6.2 
Process Suspension And Resumption     99
6.3 
Self–suspension And Information Hiding     100
6.4 
The Concept Of A System Call     101
6.5 
Interrupt Control With Disable And Restore    103
6.6 
A System Call Template     104
6.7 
System Call Return Values SYSERR And OK     105
6.8 
Implementation Of Suspend     105
6.9 
Suspending The Current Process    107
6.10 
The Value Returned By Suspend     107
6.11 
Process Termination And Process Exit     108
6.12 
Process Creation     111
6.13 
Other Process Manager Functions     115
6.14 
Summary     117
123
Chapter 7 Coordination Of Concurrent Processes
7.1 
Introduction     123
7.2 
The Need For Synchronization     123
7.3 
A Conceptual View Of Counting Semaphores    125
7.4 
Avoidance Of Busy Waiting     125
7.5 
Semaphore Policy And Process Selection     126
7.6 
The Waiting State     127
7.7 
Semaphore Data Structures     128
7.8 
The Wait System Call     129
7.9 
The Signal System Call     130
7.10 
Static And Dynamic Semaphore Allocation     131
7.11 
Example Implementation Of Dynamic Semaphores     132

x
Contents
7.12 
Semaphore Deletion     133
7.13 
Semaphore Reset     135
7.14 
Coordination Across Parallel Processors (Multicore)    136
7.15 
Perspective     137
7.16 
Summary     137
143
Chapter 8 Message Passing
8.1 
Introduction     143
8.2 
Two Types Of Message Passing Services    143
8.3 
Limits On Resources Used By Messages     144
8.4 
Message Passing Functions And State Transitions     145
8.5 
Implementation Of Send     146
8.6 
Implementation Of Receive     148
8.7 
Implementation Of Non-Blocking Message Reception     149
8.8 
Perspective     149
8.9 
Summary     150
153
Chapter 9 Basic Memory Management
9.1 
Introduction     153
9.2 
Types Of Memory     153
9.3 
Definition Of A Heavyweight Process     154
9.4 
Memory Management In Our Example System     155
9.5 
Program Segments And Regions Of Memory    156
9.6 
Dynamic Memory Allocation     157
9.7 
Design Of The Low–level Memory Manager     158
9.8 
Allocation Strategy And Memory Persistence     159
9.9 
Keeping Track Of Free Memory     159
9.10 
Implementation Of Low–level Memory Management     160
9.11 
Data Structure Definitions Used With Free Memory    161
9.12 
Allocating Heap Storage     162
9.13 
Allocating Stack Storage     165
9.14 
Releasing Heap And Stack Storage     167
9.15 
Perspective     170
9.16 
Summary     170
175
Chapter 10 High-level Memory Management and Virtual Memory
10.1 
Introduction     175
10.2 
Partitioned Space Allocation     176 
10.3 
Buffer Pools     176
10.4 
Allocating A Buffer     178

Contents        
xi
10.5 
Returning Buffers To The Buffer Pool     179 
10.6 
Creating A Buffer Pool     181
10.7 
Initializing The Buffer Pool Table     183
10.8 
Virtual Memory And Memory Multiplexing     184 
10.9 
Real And Virtual Address Spaces    185
10.10 Hardware For Demand Paging     186
10.11 Address Translation With A Page Table     187 
10.12 Metadata In A Page Table Entry     188
10.13 Demand Paging And Design Questions     189 
10.14 Page Replacement And Global Clock     190 
10.15 Perspective     191
10.16 Summary     191
195
Chapter 11 High-level Message Passing
11.1 
Introduction     195
11.2 
Inter–process Communication Ports     195 
11.3 
The Implementation Of Ports     196
11.4 
Port Table Initialization     197 
11.5 
Port Creation     199
11.6 
Sending A Message To A Port     200
11.7 
Receiving A Message From A Port     202 
11.8 
Port Deletion And Reset     204
11.9 
Perspective     207 
11.10 Summary     207
211
Chapter 12 Interrupt Processing
12.1 
Introduction     211
12.2 
The Advantage Of Interrupts     212 
12.3 
Interrupt Processing     212
12.4 
Vectored Interrupts     213
12.5 
Integration Of Interrupts And Exceptions    214 
12.6 
ARM Exception Vectors Using Code     215
12.7 
Assignment Of Device Interrupt Vector Numbers     219 
12.8 
Interrupt Dispatching     220
12.9 
The Structure Of Interrupt Software     221 
12.10 Disabling Interrupts     223
12.11 Constraints On Functions That Interrupt Code Invokes    225 
12.12 The Need To Reschedule During An Interrupt     225
12.13 Rescheduling During An Interrupt     226 
12.14 Perspective     227
12.15 Summary     228

xii
Contents
233
Chapter 13 Real-time Clock Management
13.1 
Introduction     233 
13.2 
Timed Events     234
13.3 
Real-time Clocks And Timer Hardware     234 
13.4 
Handling Real-time Clock Interrupts     235 
13.5 
Delay And Preemption     236
13.6 
Implementation Of Preemption     237
13.7 
Efficient Management Of Delay With A Delta List     238 
13.8 
Delta List Implementation     239
13.9 
Putting A Process To Sleep     241 
13.10 Timed Message Reception     244
13.11 Awakening Sleeping Processes     248 
13.12 Clock Interrupt Processing     249 
13.13 Clock Initialization     251
13.14 Perspective     254 
13.15 Summary     255
259
Chapter 14 Device–independent Input And Output
14.1 
Introduction     259
14.2 
Conceptual Organization Of I/O And Device Drivers    260 
14.3 
Interface And Driver Abstractions     261
14.4 
An Example I/O Interface     262
14.5 
The Open-Read-Write-Close Paradigm     263
14.6 
Bindings For I/O Operations And Device Names     264 
14.7 
Device Names In Xinu     265
14.8 
The Concept Of A Device Switch Table     265
14.9 
Multiple Copies Of A Device And Shared Drivers    266 
14.10 The Implementation Of High–level I/O Operations     269 
14.11 Other High–level I/O Functions     271
14.12 Open, Close, And Reference Counting     275 
14.13 Null And Error Entries In Devtab    277
14.14 Initialization Of The I/O System    278 
14.15 Perspective     283
14.16 Summary     283
287
Chapter 15 An Example Device Driver
15.1 
Introduction     287
15.2 
Serial Communication Using UART Hardware     287 
15.3 
The Tty Abstraction     288
15.4 
Organization Of A Tty Device Driver    289

Contents        
xiii
15.5 
Request Queues And Buffers     290
15.6 
Synchronization Of Upper Half And Lower Half     291 
15.7 
UART Hardware FIFOs And Driver Design     292 
15.8 
The Concept Of A Control Block    293
15.9 
Tty Control Block And Data Declarations     293 
15.10 Minor Device Numbers     296
15.11 Upper–half Tty Character Input (ttygetc)    297 
15.12 Upper–half Tty Read Function (ttyread)    298 
15.13 Upper–half Tty Character Output (ttyputc)    300 
15.14 Starting Output (ttykickout)     301
15.15 Upper–half Tty Multiple Character Output (ttywrite)     302 
15.16 Lower–half Tty Driver Function (ttyhandler)     303
15.17 Output Interrupt Processing (ttyhandle_out)     306 
15.18 Tty Input Processing (ttyhandle_in)     308
15.19 Tty Control Block Initialization (ttyinit)     315 
15.20 Device Driver Control (ttycontrol)     317
15.21 Perspective     319 
15.22 Summary     320
325
Chapter 16 DMA Devices And Drivers (Ethernet)
16.1 
Introduction     325
16.2 
Direct Memory Access And Buffers     325 
16.3 
Multiple Buffers And Rings     326
16.4 
An Example Ethernet Driver Using DMA     327 
16.5 
Device Hardware Definitions And Constants     328 
16.6 
Rings And Buffers In Memory    331
16.7 
Definitions Of An Ethernet Control Block    333 
16.8 
Device And Driver Initialization     336
16.9 
Reading From An Ethernet Device    343 
16.10 Writing To An Ethernet Device    347
16.11 Handling Interrupts From An Ethernet Device    349 
16.12 Ethernet Control Functions     352
16.13 Perspective     353 
16.14 Summary     354
357
Chapter 17 A Minimal Internet Protocol Stack
17.1 
Introduction     357
17.2 
Required Functionality     358
17.3 
Simultaneous Conversations, Timeouts, And Processes    359 
17.4 
A Consequence Of The Design     359
17.5 
ARP Functions     360

xiv
Contents
17.6 
Definition Of A Network Packet    371 
17.7 
The Network Input Process    373
17.8 
Definitions For IP     377 
17.9 
IP Functions     377
17.10 Definition Of The UDP Table     388 
17.11 UDP Functions     389
17.12 Internet Control Message Protocol     403 
17.13 Dynamic Host Configuration Protocol     404 
17.14 Perspective     412
17.15 Summary     413
417
Chapter 18 A Remote Disk Driver
18.1 
Introduction     417
18.2 
The Disk Abstraction     417
18.3 
Operations A Disk Driver Supports     418
18.4 
Block Transfer And High–level I/O Functions     418 
18.5 
A Remote Disk Paradigm     419
18.6 
The Important Concept Of Caching     420 
18.7 
Semantics Of Disk Operations     421
18.8 
Definition Of Driver Data Structures     421 
18.9 
Driver Initialization (rdsinit)     427
18.10 The Upper–half Open Function (rdsopen)     430
18.11 The Remote Communication Function (rdscomm)     432 
18.12 The Upper–half Write Function (rdswrite)     435
18.13 The Upper–half Read Function (rdsread)     438 
18.14 Flushing Pending Requests     442
18.15 The Upper–half Control Function (rdscontrol)     442 
18.16 Allocating A Disk Buffer (rdsbufalloc)     445
18.17 The Upper–half Close Function (rdsclose)    447
18.18 The Lower–half Communication Process (rdsprocess)     448 
18.19 Perspective     453
18.20 Summary     454
459
Chapter 19 File Systems
19.1 
What Is A File System?    459
19.2 
An Example Set Of File Operations     460 
19.3 
Design Of A Local File System    461
19.4 
Data Structures For The Xinu File System    461 
19.5 
Implementation Of The Index Manager     462 
19.6 
Clearing An Index Block (lfibclear)     467
19.7 
Retrieving An Index Block (lfibget)     468

Contents        
xv
19.8 
Storing An Index Block (lfibput)     469
19.9 
Allocating An Index Block From The Free List (lfiballoc)     471 
19.10 Allocating A Data Block From The Free List (lfdballoc)     472 
19.11 Using The Device-Independent I/O Functions For Files     474 
19.12 File System Device Configuration And Function Names     474 
19.13 The Local File System Open Function (lfsopen)     475
19.14 Closing A File Pseudo-Device (lflclose)     483 
19.15 Flushing Data To Disk (lfflush)     483
19.16 Bulk Transfer Functions For A File (lflwrite, lflread)     486 
19.17 Seeking To A New Position In the File (lflseek)    488
19.18 Extracting One Byte From A File (lflgetc)     489 
19.19 Changing One Byte In A File (lflputc)     490
19.20 Loading An Index Block And A Data Block (lfsetup)     492 
19.21 Master File System Device Initialization (lfsinit)     496
19.22 Pseudo-Device Initialization (lflinit)     497 
19.23 File Truncation (lftruncate)     499
19.24 Initial File System Creation (lfscreate)     501 
19.25 Perspective     503
19.26 Summary     504
509
Chapter 20 A Remote File Mechanism
20.1 
Introduction     509
20.2 
Remote File Access     509 
20.3 
Remote File Semantics     510
20.4 
Remote File Design And Messages     510
20.5 
Remote File Server Communication (rfscomm)     518 
20.6 
Sending A Basic Message (rfsndmsg)     520
20.7 
Network Byte Order     522
20.8 
A Remote File System Using A Device Paradigm     522 
20.9 
Opening A Remote File (rfsopen)     524
20.10 Checking The File Mode (rfsgetmode)     527 
20.11 Closing A Remote File (rflclose)     528
20.12 Reading From A Remote File (rflread)     529 
20.13 Writing To A Remote File (rflwrite)     532 
20.14 Seeking On A Remote File (rflseek)     535
20.15 Character I/O On A Remote File (rflgetc, rflputc)     536 
20.16 Remote File System Control Functions (rfscontrol)     537 
20.17 Initializing The Remote File System (rfsinit, rflinit)     541 
20.18 Perspective     543
20.19 Summary     543

xvi
Contents
547
Chapter 21 A Syntactic Namespace
21.1 
Introduction     547
21.2 
Transparency And A Namespace Abstraction     547 
21.3 
Myriad Naming Schemes     548
21.4 
Naming System Design Alternatives     550 
21.5 
Thinking About Names Syntactically    550 
21.6 
Patterns And Replacements     551
21.7 
Prefix Patterns     551
21.8 
Implementation Of A Namespace     552
21.9 
Namespace Data Structures And Constants     552
21.10 Adding Mappings To The Namespace Prefix Table     553 
21.11 Mapping Names With The Prefix Table     555
21.12 Opening A Named File     559 
21.13 Namespace Initialization     560
21.14 Ordering Entries In The Prefix Table     562 
21.15 Choosing A Logical Namespace    563
21.16 A Default Hierarchy And The Null Prefix    564 
21.17 Additional Object Manipulation Functions     564
21.18 Advantages And Limits Of The Namespace Approach     566 
21.19 Generalized Patterns     566
21.20 Perspective     567 
21.21 Summary     568
573
Chapter 22 System Initialization
22.1 
Introduction     573
22.2 
Bootstrap: Starting From Scratch     573
22.3 
An Example Of Booting Over A Network     574 
22.4 
Operating System Initialization     575
22.5 
Xinu Initialization     576 
22.6 
Xinu System Startup     579
22.7 
Transforming A Program Into A Process    583 
22.8 
Perspective     584
22.9 
Summary     584
589
Chapter 23 Subsystem Initialization And Memory Marking
23.1 
Introduction     589
23.2 
Self-initializing Modules     590
23.3 
Self-initializing Modules In A Concurrent System    591 
23.4 
Self-initialization In The Presence Of Reboot     593
23.5 
Initialization Using Accession Numbers     593

Contents        
xvii
23.6 
A Generalized Memory Marking Scheme     595
23.7 
Data Declarations For The Memory Marking System     596 
23.8 
Implementation Of Marking     598
23.9 
Perspective     599 
23.10 Summary     599
603
Chapter 24 Exception Handling
24.1 
Introduction     603
24.2 
Terminology: Faults, Checks, Traps, And Exceptions     603 
24.3 
Vectored Exceptions And Maskable Interrupts     604
24.4 
Types Of Exceptions     604 
24.5 
Handling Exceptions     605
24.6 
Exception Vector Initialization     606
24.7 
Panic In The Face Of Catastrophic Problems     606 
24.8 
Implementation Of Panic     607
24.9 
Perspective     607 
24.10 Summary     608
611
Chapter 25 System Configuration
25.1 
Introduction     611
25.2 
The Need For Multiple Configurations     611 
25.3 
Configuration In Xinu     613
25.4 
Contents Of The Xinu Configuration File     613 
25.5 
Computation Of Minor Device Numbers     616 
25.6 
Steps In Configuring A Xinu System    616
25.7 
Perspective     617 
25.8 
Summary     617
621
Chapter 26 An Example User Interface: The Xinu Shell
26.1 
Introduction     621
26.2 
What Is A User Interface?    622
26.3 
Commands And Design Principles     622
26.4 
Design Decisions For A Simplified Shell     623 
26.5 
Shell Organization And Operation     623
26.6 
The Definition Of Lexical Tokens     624
26.7 
The Definition Of Command-Line Syntax    625 
26.8 
Implementation Of The Xinu Shell     625
26.9 
Storage Of Tokens     628
26.10 Code For The Lexical Analyzer     629

xviii
Contents
26.11 The Heart Of The Command Interpreter    633
26.12 Command Name Lookup And Builtin Processing     641 
26.13 Arguments Passed To Commands     641
26.14 Passing Arguments To A Non-builtin Command     643 
26.15 I/O Redirection     646
26.16 An Example Command Function (sleep)     647 
26.17 Perspective     649
26.18 Summary     650
Appendix 1   Porting An Operating System 
653
A1.1 Introduction     653
A1.2 Motivation: Evolving Hardware     654
A1.3 Steps Taken When Porting An Operating System     654 
A1.4 Programming To Accommodate Change     660
A1.5 Summary     662
Appendix 2   Xinu Design Notes 
663
A2.1 Introduction     663 
A2.2 Overview     663
A2.3 Xinu Characteristics     664 
A2.4 Xinu Implementation     665
A2.5 Major Concepts And Implementation    667
669
Index

Preface
Building a computer operating system is like weaving a fine tapestry. In each
case, the ultimate goal is a large, complex artifact with a unified and pleasing design,
and in each case, the artifact is constructed with small, intricate steps. As in a tapestry, 
small details are essential because a minor mismatch is easily noticed — like stitches in 
a tapestry, each small piece added to an operating system must fit the overall design. 
Therefore, the mechanics of assembling pieces forms only a minor part of the overall 
process; a masterful creation must start with a pattern, and all artisans who work on the 
system must follow the pattern.
Ironically, few operating system textbooks or courses explain underlying patterns 
and principles that form the basis for operating system construction. Students form the 
impression that an operating system is a black box, and textbooks reinforce the 
misimpression by explaining operating system features and focusing on how to use 
operating system facilities. More important, because they only learn how an operating 
system appears from the outside, students are left with the feeling that an operating sys-
tem consists of a set of interface functions that are connected by a morass of mysterious 
code containing many machine-dependent tricks.
Surprisingly, students often graduate with the impression that research on operating 
systems is over: existing operating systems, constructed by commercial companies and 
the open source community, suffice for all needs. Nothing could be further from the 
truth. Ironically, even though fewer companies are now producing conventional operat-
ing systems for personal computers, the demand for operating system expertise is rising 
and companies are hiring students to work on operating systems. The demand arises 
from inexpensive microprocessors embedded in devices such as smart phones, video 
games, wireless sensors, cable and set-top boxes, and printers.
When working in the embedded world, knowledge of principles and structures is 
essential because a programmer may be asked to build new mechanisms inside an 
operating system or to modify an operating system for new hardware. Furthermore, 
writing applications for embedded devices requires an appreciation for the underlying 
operating system — it is impossible to exploit the power of small embedded processors 
without understanding the subtleties of operating system design.
This book removes the mystery from operating system design, and consolidates the 
body of material into a systematic discipline. It reviews the major system components, 
and imposes a hierarchical design paradigm that organizes the components in an order-
ly, understandable manner. Unlike texts that survey the field by presenting as many al-
ternatives as possible, the reader is guided through the construction of a conventional 
process-based operating system, using practical, straightforward primitives. The text 
begins with a bare machine, and proceeds step-by-step through the design and imple-

xx
Operating System Design
mentation of a small, elegant system. The system, called Xinu, serves as an example
and a pattern for system design.
Although it is small enough to fit into the text, Xinu includes all the components 
that constitute an ordinary operating system: memory management, process manage-
ment, process coordination and synchronization, interprocess communication, real-time 
clock management, device-independent I/O, device drivers, network protocols, and a file 
system. The components are carefully organized into a multi-level hierarchy, making 
the interconnections among them clear and the design process easy to follow. Despite 
its size, Xinu retains much of the power of larger systems. Xinu is not a toy — it has 
been used in many commercial products by companies such as Mitsubishi, Lexmark, 
HP, IBM, and Woodward (woodward.com), Barnard Software, and Mantissa Corpora-
tion. An important lesson to be learned is that good system design can be as important 
on small embedded systems as on large systems and that much of the power arises from 
choosing good abstractions.
The book covers topics in the order a designer follows when building a system. 
Each chapter describes a component in the design hierarchy, and presents example 
software that illustrates the functions provided by that level of the hierarchy. The ap-
proach has several advantages. First, each chapter explains a successively larger subset 
of the operating system than the previous chapters, making it possible to think about the 
design and implementation of a given level independent of the implementation of 
succeeding levels. Second, the details of a given chapter can be skipped on first reading 
— a reader only needs to understand the services that the level provides, not how those 
services are implemented. Third, reading the text sequentially allows a reader to under-
stand a given function before the function is used to build others. Fourth, intellectually 
deep subjects like support for concurrency arise early, before higher-level services have 
been introduced. Readers will see that the most essential functionality only occupies a 
few lines of code, which allows us to defer the bulk of the code (networking and file 
systems) until later when the reader is better prepared to understand details and refer-
ences to basic functions.
Unlike many other books on operating systems, this text does not attempt to re-
view every alternative for each system component, nor does it survey existing commer-
cial systems. Instead, it shows the implementation details of one set of primitives, usu-
ally the most popular set. For example, the chapter on process coordination explains 
semaphores (the most widely accepted process coordination primitives), relegating a 
discussion of other primitives (e.g., monitors) to the exercises. Our goal is to remove 
all the mystery about how primitives can be implemented on conventional hardware. 
Once the essential magic of a particular set of primitives is understood, the implementa-
tion of alternative versions will be easy to master.
The Xinu code presented in the text runs on many hardware platforms. We will 
focus on two low-cost experimenter boards that use two popular processor architectures: 
a Galileo board that contains an Intel (x86) processor and a BeagleBone Black that con-
tains an ARM processor. The paradigm is that a programmer uses conventional tools 
(editor, compiler, and linker) to create a Xinu image. The image is then loaded onto a 
target board, and the board boots the Xinu operating system.

Preface        
xxi
The book is designed for advanced undergraduate or graduate-level courses, and
for computing professionals who want to understand operating systems. Although there
is nothing inherently difficult about any topic, covering most of the material in one 
semester demands an extremely rapid pace usually unattainable by undergraduates. Few 
undergraduates are adept at reading code, and fewer still understand the details of a run-
time environment or machine architecture. Thus, they need to be guided through the 
chapters on process management and process synchronization carefully. Choosing 
items to omit depends largely on the background of students who take the course. If 
time is limited, I recommend covering Chapters 1–7 (process management), 9 (basic 
memory management), 12 (interrupt processing), 13 (clock management), 14 (device-
independent I/O), and 19 (file systems). If students have taken a data structures course 
that covers memory management and list manipulation, Chapters 4 and 9 can be 
skipped. It is important for students to understand that most operating systems include 
network communication. If they will take a separate course in networking, however, 
they can skip Chapter 17 on network protocols. The text includes chapters on both a re-
mote disk system (18) and a remote file system (20); one of the two can be skipped. 
The chapter on a remote disk system may be slightly more pertinent because it intro-
duces the topic of disk block caching, which is central in many operating systems.
In grad courses, class time can be spent discussing motivations, principles, trade-
offs, alternative sets of primitives, and alternative implementations. Students should 
emerge with a firm understanding of the process model and the relationship between in-
terrupts and processes as well as the ability to understand, create, and modify system 
components. They should have a complete mental model of the entire system, and 
know how all the pieces interact. Two topics should be included in both graduate and 
undergraduate courses: the important metamorphosis that occurs during startup when a 
sequential program is transformed into a process, and the transformation in the shell 
when a sequence of characters on an input line become string arguments passed to a 
command process.
In all cases, learning improves dramatically if students have hands-on experience 
with the system. The low cost of the boards we have selected (they are available for
less than $50 US) means each student can afford to purchase a board and the cables 
needed to connect it to a laptop or other development computer. Ideally, they can start 
to use the system in the first few days or weeks of the class before they try to under-
stand the internal structure. Chapter 1 provides a few examples and encourages experi-
mentation. (It is surprising how many students take operating system courses without 
ever writing a concurrent program or using system facilities.) Many of the exercises 
suggest improvements, experiments, and alternative implementations. Larger projects 
are also possible. Examples that have been used with various hardware include: a pag-
ing system, mechanisms to synchronize execution across computers, and the design of a 
virtual network. Other students have transported Xinu to various processors or built de-
vice drivers for various I/O devices. Of course, a background in programming is as-
sumed — working on the code requires a knowledge of the C programming language 
and a basic understanding of data structures, including linked lists, stacks, and queues.

xxii
Operating System Design
At Purdue, we have a lab with an automated system providing access to the experi-
menter boards. A student uses cross-development tools on a conventional Linux system 
to create a Xinu image. The student then runs an application that uses the lab network 
to allocate one of the boards, load the image onto the board, connect the console line
from the board to a window on the student’s screen, and boot the image. Because the 
hardware is inexpensive, a lab can be constructed at very low cost. For details, contact 
the author or look on the website:
www.xinu.cs.purdue.edu
I owe much to my experiences, good and bad, with commercially available operat-
ing systems. Although Xinu differs internally from existing systems, the fundamental 
ideas are not new. Many basic ideas and names have been taken from Unix. However, 
readers should be aware that many of the function arguments and the internal structure 
of the two systems differ dramatically — applications written for one system will not 
run on the other without modification. Xinu is not Unix.
I gratefully acknowledge the help of many people who contributed ideas, hard 
work, and enthusiasm to the Xinu project. Over the years, many graduate students at 
Purdue have worked on the system, ported it, and written device drivers. The version in 
this book represents a complete rewrite, and many students at Purdue contributed. As 
we updated the code, we strove to preserve the elegance of the original design. Rajas 
Karandikar and Jim Lembke created drivers and the multi-step downloading system 
used on the Galileo. Students in my operating systems class, including Andres Bravo, 
Gregory Essertel, Michael Phay, Sang Rhee, and Checed Rodgers, found problems and 
contributed to the code. Special thanks go to my wife and partner, Christine, whose 
careful editing and suggestions made many improvements throughout.
Douglas Comer

About the Author
Douglas Comer, Distinguished Professor of Computer Science at Purdue Universi-
ty, is an internationally recognized expert on computer networking, the TCP/IP proto-
cols, the Internet, and operating systems design. The author of numerous refereed arti-
cles and technical books, he is a pioneer in the development of curriculum and labora-
tories for research and education.
A prolific author, Dr. Comer’s popular books have been translated into sixteen 
languages, and are used in industry as well as computer science, engineering, and busi-
ness departments around the world. His landmark three-volume series Internetworking 
With TCP/IP revolutionized networking and network education. His textbooks and in-
novative laboratory manuals have shaped and continue to shape graduate and undergra-
duate curricula.
The accuracy and insight of Dr. Comer’s books reflect his extensive background in 
computer systems. His research spans both hardware and software. He has created the 
Xinu operating system, written device drivers, and implemented network protocol 
software for conventional computers as well as network processors. Software that has 
resulted from Dr. Comer’s research has been used by industry in a variety of products.
Dr. Comer has created and teaches courses on network protocols, operating sys-
tems, and computer architecture for a variety of audiences, including courses for en-
gineers as well as academic audiences. His innovative educational laboratories allow 
him and his students to design and implement working prototypes of large, complex 
systems, and measure the performance of the resulting prototypes. He continues to 
teach at companies, universities, and conferences around the world. In addition, Dr. 
Comer consults for industry on the design of computer networks and systems.
For twenty years, Professor Comer served as editor-in-chief of the research journal 
Software — Practice and Experience. While on an extended leave from Purdue, he
served as Vice President of Research at Cisco Systems. He is a Fellow of the ACM, a 
Fellow of the Purdue Teaching Academy, and a recipient of numerous awards, includ-
ing a Usenix Lifetime Achievement award.
Additional information about Dr. Comer can be found at:
www. cs. purdue. edu/ people/ comer
and information about his books can be found at:
www.comerbooks.com


Chapter Contents
1.1 
Operating Systems, 3
1.2 
Approach Used In The Text, 5
1.3 
A Hierarchical Design, 5
1.4 
The Xinu Operating System, 7
1.5 
What An Operating System Is Not, 8
1.6 
An Operating System Viewed From The Outside, 9
1.7 
Remainder Of The Text, 10
1.8 
Perspective, 11
1.9 
Summary, 11


1
Introduction And Overview
Our little systems have their day.
— Alfred, Lord Tennyson
1.1 Operating Systems
Hidden in every intelligent device and computer system is the software that con-
trols processing, manages resources, and communicates with peripherals such as display 
screens, disks, computer networks, and printers. Collectively, the code that performs 
control and coordination chores has been referred to as an executive, a monitor, a task 
manager, and a kernel; we will use the broader term operating system.
Computer operating systems are among the most complex objects created by 
mankind: they allow multiple computational processes and users to share a processor 
simultaneously, protect data from unauthorized access, and keep independent 
input/output (I/O) devices operating correctly. The high-level services an operating 
system offers are all achieved by executing intricately detailed, low-level hardware in-
structions. Interestingly, an operating system is not an independent mechanism that 
controls a computer from the outside — it consists of software that is executed by the 
same processor that executes applications. In fact, when a processor is executing an ap-
plication, the processor cannot be executing the operating system and vice versa.
Arranging mechanisms that guarantee an operating system will always regain con-
trol after an application runs complicates system design. The most impressive aspect of
an operating system, however, arises from the difference in functionality between the 
services offered and underlying hardware: an operating system provides impressively 
high-level services over extremely low-level hardware. As the book proceeds, we will 
understand how crude the underlying hardware can be, and see how much system 
software is required to handle even a simple device such as the serial I/O device used
3

4 
Introduction And Overview 
Chap. 1
for a keyboard or mouse. The philosophy is straightforward: an operating system
should provide abstractions that make programming easier rather than abstractions that 
reflect the underlying hardware. Thus, we conclude:
An operating system is designed to hide low-level hardware details
and to create an abstract machine that provides applications with
high-level services.
Operating system design is not a well-known craft. In the beginning, because 
computers were scarce and expensive, only a few programmers had an opportunity to 
work on operating systems. By the time advances in micro-electronic technology re-
duced fabrication costs and made personal computers available, operating systems had 
become commodities, and few programmers need to work on them. Interestingly, mi-
croprocessors have become so inexpensive that most electronic devices are now con-
structed from programmable processors rather than from discrete logic. As a result, 
designing and implementing software systems for microprocessors and microcontrollers 
is no longer a task reserved for a few specialists; it has become a skill expected of com-
petent systems programmers.
Fortunately, our understanding of operating systems has grown along with the 
technology we use to produce new machines. Researchers have explored fundamental 
issues, formulated design principles, identified essential components, and devised ways 
that components can work together. More important, researchers have identified 
abstractions, such as files and current processes, that are common to all operating sys-
tems, and have found efficient implementations for the abstractions. Finally, we have 
learned how to organize the components of an operating system into a meaningful struc-
ture that simplifies system design and implementation.
Compared to its early counterparts, a modern system is simple, clean, and portable.
A well-designed system follows a basic pattern that partitions software into a set of
basic components. As a result, a modern system can be easier to understand and modi-
fy, can contain less code, and has less processing overhead than early systems.
Vendors that sell large commercial operating systems include many extra software 
components along with an operating system. For example, a typical software distribu-
tion includes compilers, linkers, loaders, library functions, and a set of applications. To 
distinguish between the extras and the basic system, we sometimes use the term kernel 
to refer to the code that remains resident in memory and provides key services such as 
support for concurrent processes. Throughout the text, we will assume the term operat-
ing system refers to the kernel, and does not include all additional facilities. A design 
that minimizes the facilities in a kernel is sometimes called a microkernel design; our 
discussions will concentrate on a microkernel.

Sec. 1.2        Approach Used In The Text 
5
1.2 Approach Used In The Text
This book is a guide to the structure, design, and implementation of operating sys-
tem kernels. Instead of merely surveying extant systems, listing their features, and 
describing functionality abstractly, the book takes an engineering approach. It explains 
how to construct each OS abstraction, and shows how the individual abstractions can be 
organized into an elegant, efficient design.
Our approach provides two advantages. First, because the text covers every part of 
the system, a reader will see how an entire system fits together, not merely how one or 
two parts interact. Second, because source code is available for all pieces described in 
the text, no mystery remains about any part of the implementation — a reader can ob-
tain a copy of the system to examine, modify, instrument, measure, extend, or transport 
to another architecture. By the end of the book, a reader will see how each piece of an 
operating system fits into the design, and will be prepared to understand alternative 
design choices.
Our focus on implementation means that the software forms an integral part of the 
text. In fact, the code provides a centerpiece for discussion; one must read and study
the program listings to appreciate the underlying subtlety and engineering detail. The 
example code is minimal, which means a reader can concentrate on concepts without 
wading through many pages of code. Some of the exercises suggest improvements or 
modifications that require a reader to delve into details or invent alternatives; a skillful 
programmer will find additional ways to improve and extend the system.
1.3 A Hierarchical Design
If designed well, the interior of an operating system can be as elegant and clean as 
the best application program. The design described in this book achieves elegance by 
partitioning system functions into eight major categories, and organizing the com-
ponents into a multi-level hierarchy. Each level of the system provides an abstract ser-
vice, implemented in terms of the abstract services provided by lower levels. The ap-
proach offers a property that will become apparent: successively larger subsets of the 
levels can be selected to form successively more powerful systems. We will see how a 
hierarchical approach provides a model for designers that helps reduce complexity.
Another important property of our approach arises from runtime efficiency — a 
designer can structure pieces of an operating system into a hierarchy without introduc-
ing extra overhead. In particular, our approach differs from a conventional layered sys-
tem in which a function at level K can only invoke functions at level K – 1. In our 
multi-level approach, the hierarchy only provides a conceptual model for a designer —
at runtime, a function at a given level of the hierarchy can invoke any of the functions 
in lower levels directly. We will see that direct invocation makes the entire system effi-
cient.

6 
Introduction And Overview 
Chap. 1
Figure 1.1 illustrates the hierarchy used in the text, gives a preview of the com-
ponents we will discuss, and shows the structure into which all pieces are organized.
HARDWARE
MEMORY MANAGER
PROCESS MANAGER
PROCESS COORDINATION
INTERPROCESS COMMUNICATION
REAL-TIME CLOCK MANAGER
DEVICE MANAGER AND DEVICE DRIVERS
INTERMACHINE COMMUNICATION
FILE SYSTEM
APPLICATION PROGRAMS
Figure 1.1  The multi-level organization used in the text.

Sec. 1.3        A Hierarchical Design 
7
At the heart of the hierarchy lies the computer hardware. Although not part of the 
operating system itself, modern hardware includes features that allow tight integration 
with an operating system. Thus, we think of the hardware as forming level zero of our 
hierarchy.
Building out from the hardware, each higher level of operating system software 
provides more powerful primitives that shield applications from the raw hardware. A 
memory manager controls and allocates memory. Process management forms the most 
fundamental component of the operating system, and includes a scheduler and context 
switch. Functions in the next level constitute the rest of the process manager, providing 
primitives to create, kill, suspend, and resume processes. Just beyond the process 
manager comes a process coordination component that implements semaphores. Func-
tions for real-time clock management occupy the next level, and allow application 
software to delay for a specified time. On top of the real-time clock level lies a level of 
device-independent I/O routines that provide familiar services, such as read and write. 
Above the device routines, a level implements network communication, and the level 
above that implements a file system. Application programs occupy the highest concep-
tual level of the hierarchy — an application has access to all the facilities provided by 
lower levels.
The internal organization of a system should not be confused with the services the 
system provides. Although components are organized into levels to make the design
and implementation cleaner, the resulting hierarchical structure does not restrict system 
calls at runtime. That is, once the system has been built, facilities from all levels of the 
hierarchy can be exposed to applications. For example, an application can invoke sema-
phore functions, such as wait and signal, that reside in the process coordination level 
just as easily as it can invoke functions such as putc that reside in an outer level. Thus, 
the multi-level structure describes only the internal implementation, and does not res-
trict the services the system provides.
1.4 The Xinu Operating System
Examples in the book are taken from the Xinu† operating system. Xinu is a small, 
elegant system that is intended for use in an embedded environment, such as a cell 
phone or an MP3 player. Typically, Xinu is loaded into memory along with a fixed set
of applications when the system boots. Of course, if memory is constrained or the 
hardware architecture uses a separate memory for instructions, Xinu can be executed 
from Flash or other read-only memory. In a typical system, however, executing from 
main memory produces higher performance.
Xinu is not a toy; it is a powerful operating system that has been used in commer-
cial products. For example, Xinu was used in pinball games sold under the
Williams/ Bally brand (the major manufacturer), Woodward Corporation uses Xinu to 
control large gas/steam and diesel/steam turbine engines, and Lexmark Corporation used 
Xinu as the operating system in its printers until 2005. In each case, when the device 
was powered on, the hardware loaded a memory image that contained Xinu.
                                †The name stands for Xinu Is Not Unix. As we will see, the internal structure of Xinu differs completely
from the internal structure of Unix (or Linux). Xinu is smaller, more elegant, and easier to understand.

8 
Introduction And Overview 
Chap. 1
Xinu contains the fundamental components of an operating system, including: 
process, memory, and timer management mechanisms, interprocess communication fa-
cilities, device-independent I/O functions, and Internet protocol software. Xinu can 
control I/O devices and perform chores such as reading keystrokes from a keyboard or 
keypad, displaying characters on an output device, managing multiple, simultaneous 
computations, controlling timers, passing messages between computations, and allowing 
applications to access the Internet.
Xinu illustrates how the hierarchical design that is described above applies in prac-
tice. It also shows how all the pieces of an operating system function as a uniform, in-
tegrated whole, and how an operating system makes services available to application 
programs.
1.5 What An Operating System Is Not
Before proceeding into the design of an operating system, we should agree on what 
we are about to study. Surprisingly, many programmers do not have a correct intuitive 
definition of an operating system. Perhaps the problem arises because vendors and 
computer professionals often apply the terminology broadly to refer to all software sup-
plied by a vendor as well as the operating system itself, or perhaps confusion arises be-
cause few programmers access system services directly. In any case, we can clarify the 
definition quickly by ruling out well-known items that are not part of the operating sys-
tem kernel.
First, an operating system is not a language or a compiler. Of course, an operating 
system must be written in some language, and languages have been designed that incor-
porate operating systems features and facilities. Further confusion arises because a 
software vendor may offer one or more compilers that have been integrated with their 
operating system. However, an operating system does not depend on an integrated 
language facility — we will see that a system can be constructed using a conventional 
language and a conventional compiler.
Second, an operating system is not a windowing system or a browser. Many com-
puters and electronic devices have a screen that is capable of displaying graphics, and 
sophisticated systems permit applications to create and control multiple, independent 
windows. Although windowing mechanisms rely on an operating system, a windowing 
system can be replaced without replacing the operating system.
Third, an operating system is not a command interpreter. Embedded systems often 
include a Command Line Interface (CLI); some embedded systems rely on a CLI for all 
control. In a modern operating system, however, the command interpreter operates as 
an application program, and the interpreter can be changed without modifying the 
underlying system.
Fourth, an operating system is not a library of functions or methods. Almost all 
application programs use library functions, and the software found in libraries can offer 
significant convenience and functionality. Some operating systems even employ an op-
timization that allows code from a library to be loaded in memory and shared among all

Sec. 1.5        What An Operating System Is Not 
9
applications. Despite the close relationship, library software remains independent of the 
underlying operating system.
Fifth, an operating system is not the first code that runs after a computer is 
powered on. Instead, the computer contains firmware (i.e., a program in non-volatile 
memory) that initializes various pieces of hardware, loads a copy of the operating sys-
tem into memory, and then jumps to the beginning of the operating system. On a PC, 
for example, the firmware is known as the Basic Input Output System (BIOS). We will 
learn more about bootstrapping in Chapter 22.
1.6 An Operating System Viewed From The Outside
The essence of an operating system lies in the services it provides to applications.
An application accesses operating system services by making system calls. In source
code, a system call appears to be a conventional function invocation. At runtime, how-
ever, a system call and a conventional function call differ. Instead of transferring con-
trol to another function, a system call transfers control to the operating system, which 
performs the requested service for the application. Taken as a set, system calls establish 
a well-defined boundary between applications and the underlying operating system that 
is known as an Application Program Interface (API)†. The API defines the services 
that the system provides as well as the details of how an application uses the services.
To appreciate the interior of an operating system, one must first understand the 
characteristics of the API and see how applications use the services. This chapter intro-
duces a few fundamental services, using examples from the Xinu operating system to il-
lustrate the concepts. For example, the Xinu function putc writes a single character to a 
specified I/O device. Putc takes two arguments: a device identifier and a character to 
write. File ex1.c contains an example C program that writes the message “hi” on the 
console when run under Xinu:
//** eexx11..cc -- mmaaiinn **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** mmaaiinn
--
WWrriittee ""hhii"" oonn tthhee ccoonnssoollee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
mmaaiinn((vvooiidd))
{{
ppuuttcc((CCOONNSSOOLLEE,, ’’hh’’));;
ppuuttcc((CCOONNSSOOLLEE,, ’’ii’’));;
ppuuttcc((CCOONNSSOOLLEE,, ’’\\nn’’));;
}}
                                †The interface is also known as a system call interface or the kernel interface.

10 
Introduction And Overview 
Chap. 1
The code introduces several conventions used throughout Xinu.  The statement:
##iinncclluuddee <<xxiinnuu..hh>>
inserts a set of declarations into a source program that allows the program to reference 
operating system parameters. For example, the Xinu configuration file defines symbolic 
constant CONSOLE to correspond to a console serial device a programmer uses to in-
teract with the embedded system. Later, we will see that xinu.h contains a series of 
#include statements that reference files needed by the Xinu system, and we will learn 
how names like CONSOLE become synonymous with devices; for now, it is sufficient 
to know that the include statement must appear in any Xinu application.
To permit communication with an embedded system (e.g., for debugging), the seri-
al device on the embedded system can be connected to a terminal application on a con-
ventional computer. Each time a user presses a key on the computer’s keyboard, the 
terminal application sends the keystroke over the serial line to the embedded system. 
Similarly, each time the embedded system sends a character to the serial device, the ter-
minal application displays the character on the user’s screen. Thus, a console provides 
two-way communication between the embedded system and the outside world.
The main program listed above writes three characters to the console serial device: 
“h”, “i”, and a line feed (known as NEWLINE). The line feed is a control character that 
moves the cursor to the beginning of the next line. Xinu does not perform any special 
operations when the program sends control characters — control characters are merely 
passed on to the serial device just like alphanumeric characters. A control character has 
been included in the example to illustrate that putc is not line-oriented; in Xinu, a pro-
grammer is responsible for terminating a line.
The example source file introduces two important conventions followed throughout
the book. First, the file begins with a one-line comment that contains the name of the
file (ex1.c). If a source file contains multiple functions, the name of each appears on
the comment line. Knowing the names of files will help you locate them in a machine-
readable copy of Xinu. Second, the file contains a block comment that identifies the 
start of each function (main). Having a block comment before each function makes it 
easy to locate functions in a given file.
1.7 Remainder Of The Text
The remainder of the text proceeds through the design of a system that follows the 
multi-level organization that Figure 1.1 illustrates. Chapter 2 describes concurrent pro-
gramming and the services an operating system supplies. Successive chapters consider 
the levels in roughly the same order as they are designed and built: from the innermost 
outward. Each chapter explains the role of one level in the system, describes new 
abstractions, and illustrates the details with source code. Taken together, the chapters 
describe a complete, working system and explain how the components fit together in a 
clean and elegant design.

Sec. 1.7        Remainder Of The Text 
11
Although the bottom-up approach may seem awkward at first, it shows how an 
operating system designer builds a system. The overall structure of the system will start 
to become clear by Chapter 9. By the end of Chapter 14, readers will understand a 
minimal kernel capable of supporting concurrent programs. By Chapter 20, the system 
will include remote file access, and by Chapter 22, the design will include a complete 
set of operating system functions and code to initialize the entire system.
1.8 Perspective
Why study operating systems? It may seem pointless because commercial systems 
are widely available and relatively few programmers write operating system code. 
However, a strong motivation exists: even in small embedded systems, applications run 
on top of an operating system and use the services it provides. Therefore, understand-
ing how an operating system works internally helps a programmer appreciate concurrent 
processing and make sensible choices about system services. In some cases, the 
behavior of application software can only be understood, and problems can only be 
solved, by understanding how an operating system manages concurrent process execu-
tion.
The key to learning operating systems lies in persistence. A concurrent paradigm 
requires you to think about computer programs in new ways. Until you grasp the
basics, it may seem confusing. Fortunately, you will not be overwhelmed with code —
some of the most important ideas are contained neatly in a few lines of code. Once you 
understand what’s going on, you will be able to read operating systems code easily, 
understand why process coordination is needed, and see how functions work together. 
By the end of the text, you will be able to write or modify operating systems functions.
1.9 Summary
An operating system provides a set of convenient, high-level services over low-
level hardware. Because most applications use operating system services, programmers 
need to understand operating system principles. Programmers who work on embedded 
devices need to understand operating system design more deeply. Using a hierarchical 
structure can make an operating system easier to design, understand, and modify.
The text takes a practical approach. Instead of merely describing commercial sys-
tems or listing operating system features, it uses an example system, Xinu, to illustrate 
how a system can be designed. Although it is small and elegant, Xinu is not a toy — it 
has been used in commercial products. Xinu follows a multi-level design in which 
software components are organized into eight conceptual levels. The text explains one 
level of the system at a time, beginning with the raw hardware and ending with a work-
ing operating system.

12 
Introduction And Overview 
Chap. 1
EXERCISES
1.1 
Should an operating system make hardware facilities available to application programs?
Why or why not?
1.2 
What are the advantages of using a real operating system in examples?
1.3 
What are the eight major components of an operating system?
1.4 
In the Xinu multi-level hierarchy, can a function in the file system code use a function in
the process manager? Can a function in the process manager use a function in the file sys-
tem? Explain.
1.5 
Explore the system calls available on your favorite operating system, and write a program
that uses them.
1.6   Various programming languages have been designed that incorporate OS concepts such as
processes and process synchronization primitives. Find an example language, and make a
list of the facilities it offers.
1.7 
Search the web, and make a list of the major commercial operating systems that are in use.
1.8  Compare the facilities in Linux and Microsoft’s Windows operating systems. Does either
one support functionality that is not available in the other?
1.9 
The set of functions that an operating system makes available to application programs is
known as the Application Program Interface or the system call interface. Choose two ex-
ample operating systems, count the functions in the interface that each makes available, and 
compare the counts.
1.10 Extend the previous exercise by identifying functions that are available in one system but
not in the other. Characterize the purpose and importance of the functions.
1.11 How large is an operating system? Choose an example system, and count the lines of
source code used for the kernel.

Chapter Contents
2.1 
Introduction, 15
2.2 
Programming Models For Multiple Activities, 16
2.3 
Operating System Services, 17
2.4 
Concurrent Processing Concepts And Terminology, 17
2.5 
Distinction Between Sequential And Concurrent Programs, 19
2.6 
Multiple Processes Sharing A Single Piece Of Code, 21
2.7 
Process Exit And Process Termination, 23
2.8 
Shared Memory, Race Conditions, And Synchronization, 24
2.9 
Semaphores And Mutual Exclusion, 28
2.10 
Type Names Used In Xinu, 30
2.11 
Operating System Debugging With Kputc And Kprintf, 31
2.12 
Perspective, 32
2.13 
Summary, 32


2
Concurrent Execution And 
Operating System Services
From an article on a new operating system for the
IBM PC: Real concurrency — in which one program 
actually continues to function while you call up and 
use another — is more amazing but of small use to the 
average person. How many programs do you have 
that take more than a few seconds to perform any 
task?
— New York Times, 25 April 1989
2.1 Introduction
This chapter considers the concurrent programming environment that an operating 
system provides for applications. It describes a model of concurrent execution, and
shows why applications that operate concurrently need mechanisms to coordinate and 
synchronize. It introduces basic concepts, such as processes and semaphores, and ex-
plains how applications use such facilities.
Instead of describing operating systems abstractly, the chapter uses concrete exam-
ples from the Xinu system to illustrate concepts such as concurrency and synchroniza-
tion. The chapter contains trivial applications that capture the essence of concurrent ex-
ecution in a few lines of code. Later chapters expand the discussion by explaining in 
detail how an operating system implements each of the facilities described.
15

16 
Concurrent Execution And Operating System Services 
Chap. 2
2.2 Programming Models For Multiple Activities
Even small computing devices are designed to handle multiple tasks at the same 
time. For example, while a voice call is connected, a cell phone can display the time of 
day, accept text messages, and allow the user to adjust the volume. More complex 
computing systems allow a user to run multiple applications that execute at the same 
time. The question arises: how should the software in such systems be organized? 
Three basic approaches can be used:
d Synchronous event loop
d Asynchronous event handlers
d Concurrent execution
Synchronous event loop. The term synchronous refers to events that are coordinat-
ed. A synchronous event loop uses a single, large iteration to handle coordination.
During a given iteration of the loop, the code checks each possible activity and invokes 
the appropriate handler. Thus, the code has a structure similar to the following:
while (1) { /* synchronous loop runs forever */
Update time-of-day clock;
if (screen timeout has expired) {
turn off the screen;
}
if (volume button is being pushed) {
adjust volume;
}
if (text message has arrived) {
Display notification for user;
} 
...
}
Asynchronous event handlers. An asynchronous paradigm is used in systems 
where the hardware can be configured to invoke a handler for each event. For example, 
the code to adjust volume might be placed in memory at location 100, and the hardware 
is configured so that when the volume button is pressed, control transfers to location 
100. Similarly, the hardware can be configured so that when a text message arrives, 
control transfers to location 200, and so on. A programmer writes a separate piece of 
code for each event, and uses global variables to coordinate the interactions. For exam-
ple, if a user presses the mute button, the code associated with the mute event turns off 
the audio and records the status in a global variable. Later, when the user adjusts the 
volume, code associated with the volume button checks the global variable, turns on the 
audio, and changes the global variable to indicate that audio is on.

Sec. 2.2        Programming Models For Multiple Activities 
17
Concurrent execution. The third paradigm used to organize multiple activities is 
the most significant: software is organized as a set of programs that each operate con-
currently. The model is sometimes called run-to-completion because each computation 
appears to run until it chooses to stop. From a programmer’s point of view, concurrent 
execution is a delight. Compared to synchronous or asynchronous events, concurrent 
execution is more powerful, easier to understand, and less error-prone.
The next sections describe operating systems that provide the support needed for 
concurrency, and characterize the concurrent model. Later chapters examine the under-
lying operating system mechanisms and functions that enable a concurrent programming 
model.
2.3 Operating System Services
What are the main services that an operating system supplies? Although the de-
tails vary from system to system, most systems supply the same basic services. The 
services (with the chapters of the text that describe them) are:
d Support for concurrent execution (5–6)
d Facilities for process synchronization (7)
d Inter-process communication mechanisms (8 and 11)
d Dynamic memory allocation (9)
d Management of address spaces and virtual memory (10)
d High-level interface for I/ O devices (13–15)
d Network and Internet communication (16–17)
d A file system and file access facilities (19–21)
Concurrent execution is at the heart of an operating system, and we will see that 
concurrency affects each piece of operating system code. Thus, we begin by examining 
the facilities an operating system offers for concurrency, and use concurrency to show 
how an application program invokes services.
2.4 Concurrent Processing Concepts And Terminology
Conventional programs are called sequential because a programmer imagines a 
computer executing the code statement by statement; at any instant, the machine is exe-
cuting exactly one statement. Operating systems support an extended view of computa-
tion called concurrent processing. Concurrent processing means that multiple computa-
tions can proceed “at the same time.”
Many questions arise about concurrent processing. It is easy to imagine N in-
dependent programs being executed simultaneously by N processors (i.e., N cores), but 
it is difficult to imagine a set of independent computations proceeding simultaneously

18 
Concurrent Execution And Operating System Services 
Chap. 2
on a computer that has fewer than N processing units. Is concurrent computation possi-
ble even if a computer has a single core? If multiple computations each proceed simul-
taneously, how does the system keep one program from interfering with others? How 
do the programs cooperate so that only one takes control of an input or output device at 
a given time?
Although many processors do incorporate some amount of parallelism, the most 
visible form of concurrency, multiple independent applications that execute simultane-
ously, is a grand illusion. To create the illusion, an operating system uses a technique, 
called multitasking or multiprogramming — the operating system switches the available 
processor(s) among multiple programs, allowing a processor to execute one program for 
only a few milliseconds before moving on to another. When viewed by a human, the 
programs all appear to proceed. Multitasking forms the basis of most operating sys-
tems. The only exceptions are systems used in basic embedded devices, such as a 
simplistic remote control used with a television, and safety-critical systems, such as 
flight avionics and medical device controllers. In such cases, designers use a synchro-
nous event loop rather than a multitasking system, either to reduce cost or to guarantee 
that tight time constraints can be met absolutely.
Systems that support multitasking can be divided into two broad categories:
d Timesharing
d Real-time
Timesharing. A timesharing system gives equal priority to all computations, and 
permits computations to start or terminate at any time. Because they allow computa-
tions to be created dynamically, timesharing systems are popular for computers that hu-
man users operate. A timesharing system allows a human to leave an email application 
running and a background application playing music while using a browser to view a 
web page. The chief characteristic of a timesharing system is that the amount of proc-
essing a computation receives is inversely proportional to the load on the system — if N 
computations are executing, each computation receives approximately 1 / N of the avail-
able processor cycles. Thus, as more computations appear, each proceeds at a slower 
rate.
Real-time. Because it is designed to meet performance constraints, a real-time sys-
tem does not treat all computations equally. Instead, a real-time system assigns priori-
ties to computations, and schedules the processor carefully to ensure that each computa-
tion meets its required schedule. The chief characteristic of a real-time system arises 
from its ability to give the processor to high-priority tasks, even if other tasks are wait-
ing. For example, by giving priority to voice transmission, a real-time system in a cell 
phone can guarantee that the conversation is uninterrupted, even if a user runs an appli-
cation to view the weather or an application to play a game.
Designers of multitasking systems have used a variety of terms to describe a single 
computation, including process, task, job, and thread of control. The terms process and 
job often connote a single computation that is self-contained and isolated from other 
computations. Typically, a process occupies a separate region of memory, and the 
operating system prevents a process from accessing the memory that has been assigned

Sec. 2.4        Concurrent Processing Concepts And Terminology 
19
to another process. The term task refers to a process that is declared statically. That is,
a programming language allows a programmer to declare a task similar to the way one 
declares a function. The term thread refers to a type of concurrent process that shares 
an address space with other threads. Shared memory means that members of the set can 
exchange information efficiently. Early scientific literature used the term process to 
refer to concurrent execution in a generic sense; the Unix operating system popularized 
the idea that each process occupied a separate address space. The Mach system intro-
duced a two-level concurrent programming scheme in which the operating system al-
lows a user to create one or more processes that each operate in an independent region 
of memory, and to create multiple threads of control within each process. Linux fol-
lows the Mach model. To refer to a Linux-style process, the word Process is written 
with an uppercase P.
Because it is designed for an embedded environment, Xinu permits processes to 
share an address space. To be precise, we might say that Xinu processes follow a 
thread model. However, because the term process is widely accepted, we will use it 
throughout the text to refer generically to a concurrent computation.
The next section helps distinguish concurrent execution from sequential execution 
by examining a few applications. As we will see, the difference plays a central role in 
operating system design — each piece of an operating system must be built to support 
concurrent execution.
2.5 Distinction Between Sequential And Concurrent Programs
When a programmer creates a conventional (i.e., sequential) program, the program-
mer imagines a single processor executing the program step-by-step without interruption 
or interference. When writing code that will be executed concurrently, however, a pro-
grammer must take a different view and imagine multiple computations executing 
simultaneously. The code inside an operating system provides an excellent example of 
code that must accommodate concurrency. At any given instant, multiple processes 
may be executing. In the simplest case, each process executes application code that no 
other process is executing. However, an operating system designer must plan for a situ-
ation in which multiple processes have invoked a single operating system function, or 
even a case where multiple processes are executing the same instruction. To further 
complicate matters, the operating system may switch the processor among processes at 
any time; in a multitasking system, no guarantee can be made about the relative speed 
at which a given computation will proceed.
Designing code to operate correctly in a concurrent environment provides a tough 
intellectual challenge because a programmer must ensure that all processes perform the 
intended function correctly, no matter what operating system code they execute or in 
which order they execute. We will see how the notion of concurrent execution affects 
each line of code in an operating system.
To understand applications in a concurrent environment, consider the Xinu model. 
When it boots, Xinu creates a single concurrent process that starts running the main pro-

20 
Concurrent Execution And Operating System Services 
Chap. 2
gram. The initial process can continue execution by itself, or it can create additional 
processes. When a new process is created, the original process continues to execute, 
and the new process executes concurrently. Either the original process or a new process 
can create additional processes that execute concurrently.
As an example, consider the code for a concurrent main program that creates two 
additional processes. Each of the two new processes sends characters over the console 
serial device: the first process sends the letter A, and the second sends the letter B. File 
ex2.c contains the source code, which consists of a main program and two functions, 
sndA and sndB.
//** eexx22..cc -- mmaaiinn,, ssnnddAA,, ssnnddBB **//
##iinncclluuddee <<xxiinnuu..hh>>
vvooiidd
ssnnddAA((vvooiidd)),, ssnnddBB((vvooiidd));;
//**------------------------------------------------------------------------------------------------------------------------------------------------
** mmaaiinn
--
EExxaammppllee ooff ccrreeaattiinngg pprroocceesssseess iinn XXiinnuu
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
mmaaiinn((vvooiidd))
{{
rreessuummee(( ccrreeaattee((ssnnddAA,, 11002244,, 2200,, ""pprroocceessss 11"",, 00)) ));;
rreessuummee(( ccrreeaattee((ssnnddBB,, 11002244,, 2200,, ""pprroocceessss 22"",, 00)) ));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ssnnddAA
--
RReeppeeaatteeddllyy eemmiitt ’’AA’’ oonn tthhee ccoonnssoollee wwiitthhoouutt tteerrmmiinnaattiinngg
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
ssnnddAA((vvooiidd))
{{
wwhhiillee(( 11 ))
ppuuttcc((CCOONNSSOOLLEE,, ’’AA’’));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ssnnddBB
--
RReeppeeaatteeddllyy eemmiitt ’’BB’’ oonn tthhee ccoonnssoollee wwiitthhoouutt tteerrmmiinnaattiinngg
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
ssnnddBB((vvooiidd))
{{
wwhhiillee(( 11 ))
ppuuttcc((CCOONNSSOOLLEE,, ’’BB’’));;
}}

Sec. 2.5        Distinction Between Sequential And Concurrent Programs 
21
In the code, the main program never calls either function directly. Instead, the 
main program calls two operating system functions, create and resume. Each call to 
create forms a new process that will begin executing instructions at the address speci-
fied by its first argument. In the example, the first call to create passes the address of 
function sndA, and the second call passes the address of function sndB.† Thus, the code 
creates a process to execute sndA and a process to execute sndB.  Create establishes a 
process, leaves the process ready to execute but temporarily suspended, and returns an 
integer value that is known as a process identifier or process ID. The operating system 
uses the process ID to identify the newly created process; an application uses the proc-
ess ID to reference the process. In the example, the main program passes the ID re-
turned by create to resume as an argument. Resume starts (i.e., unsuspends) the proc-
ess, allowing the process to begin execution. The distinction between normal function 
calls and process creation is:
A normal function call does not return until the called function com-
pletes. Process creation functions create and resume return to the 
caller immediately after starting a new process, which allows execu-
tion of both the existing process and the new process to proceed con-
currently.
In Xinu, all processes execute concurrently. That is, execution of a given process 
continues independent of other processes unless a programmer explicitly controls in-
teractions among processes. In the example, the first new process executes code in 
function sndA, sending the letter A continuously, and the second executes code in func-
tion sndB, sending the letter B continuously. Because the processes execute concurrent-
ly, the output is a mixture of As and Bs.
What happens to the main program? Remember that in an operating system, each 
computation corresponds to a process. Therefore, we should ask, “What happens to the 
process executing the main program?” Because it has reached the end of the main pro-
gram, the process executing the main program exits after the second call to resume. Its 
exit does not affect the newly created processes — they continue to send As and Bs. A 
later section describes process termination in more detail.
2.6 Multiple Processes Sharing A Single Piece Of Code
The example in file ex2.c shows each process executing a separate function. It is 
possible, however, for multiple processes to execute the same function. Arranging for 
processes to share code can be essential in an embedded system that has a small 
memory. To see an example of processes sharing code, consider the program in file 
ex3.c.

†Other arguments to create specify the stack space needed, a scheduling priority, a name for the process,
the count of arguments passed to the process, and (when applicable) the argument values passed to the proc-
ess; we will see details later.

22 
Concurrent Execution And Operating System Services 
Chap. 2
//** eexx33..cc -- mmaaiinn,, ssnnddcchh **//
##iinncclluuddee <<xxiinnuu..hh>>
vvooiidd
ssnnddcchh((cchhaarr));;
//**------------------------------------------------------------------------------------------------------------------------------------------------
** mmaaiinn
--
EExxaammppllee ooff 22 pprroocceesssseess eexxeeccuuttiinngg tthhee ssaammee ccooddee ccoonnccuurrrreennttllyy
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
mmaaiinn((vvooiidd))
{{
rreessuummee(( ccrreeaattee((ssnnddcchh,, 11002244,, 2200,, ""sseenndd AA"",, 11,, ’’AA’’)) ));;
rreessuummee(( ccrreeaattee((ssnnddcchh,, 11002244,, 2200,, ""sseenndd BB"",, 11,, ’’BB’’)) ));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ssnnddcchh
--
OOuuttppuutt aa cchhaarraacctteerr oonn aa sseerriiaall ddeevviiccee iinnddeeffiinniitteellyy
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
ssnnddcchh((
cchhaarr
cchh
//** TThhee cchhaarraacctteerr ttoo eemmiitt ccoonnttiinnuuoouussllyy
**//
))
{{
wwhhiillee (( 11 ))
ppuuttcc((CCOONNSSOOLLEE,, cchh));;
}}
As in the previous example, a single process begins executing the main program. 
The process calls create twice to start two new processes that each execute code from 
function sndch. The final two arguments in the call to create specify that create will 
pass one argument to the newly created process and a value for the argument. Thus, the 
first process receives the character A as an argument, and the second process receives 
character B.
Although they execute the same code, the two processes proceed concurrently 
without any effect on one another. In particular, each process has its own copy of argu-
ments and local variables. Thus, one process emits As, while the other process emits 
Bs. The key point is:
A program consists of code executed by a single process of control.
In contrast, concurrent processes are not uniquely associated with a 
piece of code; multiple processes can execute the same code simul-
taneously.

Sec. 2.6        Multiple Processes Sharing A Single Piece Of Code 
23
The examples provide a hint of the difficulty involved in designing an operating 
system. Not only must each piece be designed to operate correctly by itself, the
designer must also guarantee that multiple processes can execute a given piece of code 
concurrently without interfering with one another.
Although processes can share code and global variables, each process must have a 
private copy of local variables. To understand why, consider the chaos that would
result if all processes shared every variable. If two processes tried to use a shared vari-
able as the index of a for loop, for example, one process might change the value while 
another process was in the midst of executing the loop. To avoid such interference, the 
operating system creates an independent set of local variables for each process.
Function create also allocates an independent set of arguments for each process, as
the example in file ex3.c demonstrates. In the call to create, the last two arguments
specify a count of values that follow (1 in the example), and the value that the operating 
system passes to the newly created process. In the code, the first new process has char-
acter A as an argument, and the process begins execution with formal parameter ch set 
to A. The second new process begins with ch set to B. Thus, the output contains a 
mixture of both letters. The example points out a significant difference between the 
sequential and concurrent programming models.
Storage for local variables, function arguments, and a function call 
stack is associated with the process executing a function, not with the 
code for the function.
The important point is: an operating system must allocate additional storage for 
each process, even if the process shares the same code that another process or processes 
are using. As a consequence, the amount of memory available limits the number of 
processes that can be created.
2.7 Process Exit And Process Termination
The example in file ex3.c consists of a concurrent program with three processes: 
the initial process and the two processes that were started with the system call create. 
Recall that when it reaches the end of the code in the main program, the initial process 
ceases execution. We use the term process exit to describe the situation. Each process 
begins execution at the start of a function. A process can exit by reaching the end of 
the function or by executing a return statement in the function in which it starts. Once 
a process exits, it disappears from the system; there is simply one less computation in 
progress.
Process exit should not be confused with normal function call and return or with 
recursive function calls. Like a sequential program, each process has its own stack of 
function calls. Whenever it executes a call, an activation record for the called function 
is pushed onto the stack. Whenever it returns, a function’s activation record is popped

24 
Concurrent Execution And Operating System Services 
Chap. 2
off the stack. Process exit occurs only when the process pops the last activation record 
(the one that corresponds to the top-level function in which the process started) off its 
stack.
The system routine kill provides a mechanism to terminate a process without wait-
ing for the process to exit. In a sense, kill is the inverse of create — kill takes a process
ID as an argument, and removes the specified process immediately. A process can be 
killed at any time and at any level of function nesting. When terminated, the process 
ceases execution and local variables that have been allocated to the process disappear; 
in fact, the entire stack of functions for the process is removed.
A process can exit by killing itself as easily as it can kill another process. To do
so, the process uses system call getpid to obtain its own process ID, and then uses kill
to request termination:
kill( getpid() );
When used to terminate the current process, the call to kill never returns because the
calling process exits.
2.8 Shared Memory, Race Conditions, And Synchronization
In Xinu, each process has its own copy of local variables, function arguments, and 
function calls, but all processes share the set of global (external) variables. Sharing data 
is sometimes convenient, but it can be dangerous, especially for programmers who are 
unaccustomed to writing concurrent programs. For example, consider two concurrent 
processes that each increment a shared integer, n. In terms of the underlying hardware, 
incrementing an integer requires three steps:
d Load the value from variable n in memory into a register
d Increment the value in the register
d Store the value from the register back into the memory location for n
Because the operating system can choose to switch from one process to another at
any time, a potential race condition exists in which two processes attempt to increment
n at the same time. Process 1 might start first and load the value of n into a register.
But just at that moment, the operating system switches to process 2, which loads n, in-
crements the register, and stores the result. Unfortunately, when the operating system 
switches back to process 1, execution resumes with the original value of n in a register. 
Process 1 increments the original value of n and stores the result to memory, overwrit-
ing the value that process 2 placed in memory.
To see how sharing works, consider the code in file ex4.c. The file contains code
for two processes that communicate through a shared integer, n†. One process repeat-
edly increments the value of the shared integer, while the other process repeatedly prints 
the value.

†The code uses the type name int32 to emphasize that variable n is a 32-bit integer; a later section ex-
plains conventions for type names.

Sec. 2.8        Shared Memory, Race Conditions, And Synchronization 
25
//** eexx44..cc -- mmaaiinn,, pprroodduuccee,, ccoonnssuummee **//
##iinncclluuddee <<xxiinnuu..hh>>
vvooiidd
pprroodduuccee((vvooiidd)),, ccoonnssuummee((vvooiidd));;
iinntt3322
nn == 00;;
//** GGlloobbaall vvaarriiaabblleess aarree sshhaarreedd bbyy aallll pprroocceesssseess
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
mmaaiinn
--
EExxaammppllee ooff uunnssyynncchhrroonniizzeedd pprroodduucceerr aanndd ccoonnssuummeerr pprroocceesssseess
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
mmaaiinn((vvooiidd))
{{
rreessuummee(( ccrreeaattee((ccoonnssuummee,, 11002244,, 2200,, ""ccoonnss"",, 00)) ));;
rreessuummee(( ccrreeaattee((pprroodduuccee,, 11002244,, 2200,, ""pprroodd"",, 00)) ));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** pprroodduuccee
--
IInnccrreemmeenntt nn 22000000 ttiimmeess aanndd eexxiitt
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
pprroodduuccee((vvooiidd))
{{
iinntt3322
ii;;
ffoorr(( ii==11 ;; ii<<==22000000 ;; ii++++ ))
nn++++;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ccoonnssuummee
--
PPrriinntt nn 22000000 ttiimmeess aanndd eexxiitt
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
ccoonnssuummee((vvooiidd))
{{
iinntt3322
ii;;
ffoorr(( ii==11 ;; ii<<==22000000 ;; ii++++ ))
pprriinnttff((""TThhee vvaalluuee ooff nn iiss %%dd \\nn"",, nn));;
}}
In the code, global variable n is a shared integer that is initialized to zero. The
process executing produce iterates 2000 times, incrementing n; we call the process the

26 
Concurrent Execution And Operating System Services 
Chap. 2
producer. The process executing consume also iterates 2000 times. It displays the
value of n in decimal; we call the process executing consume the consumer.
Try running file ex4.c — its output may surprise you. Most programmers suspect
that the consumer will print at least a few, perhaps all, of the values between 0 and
2000, but it does not. In a typical run, n has the value 0 for the first few lines; after
that, its value becomes 2000.† Even though the two processes run concurrently, they
do not require the same amount of processor time per iteration. The consumer process 
must format and write a line of output, an operation that requires hundreds of machine 
instructions. Although formatting is expensive, it does not dominate the timing; output 
does. The consumer quickly fills the available output buffers, and must wait for the 
output device to send characters to the console before it can proceed. While the con-
sumer waits, the producer runs. Because it executes only a few machine instructions 
per iteration, the producer runs through its entire loop and exits in the short time it takes 
the console device to send a line of characters. When the consumer resumes execution 
again, it finds that n has the value 2000.
Production and consumption of data by independent processes is common. The 
question arises: how can a programmer synchronize producer and consumer processes 
so the consumer receives every data value produced? Clearly, the producer must wait
for the consumer to access the data item before generating another. Likewise, the con-
sumer must wait for the producer to manufacture the next item. For the two processes 
to coordinate correctly, a synchronization mechanism must be designed carefully. The 
crucial constraint is:
In a concurrent programming system, no process should use the pro-
cessor while waiting for another process.
A process that executes instructions while waiting for another is said to engage in 
busy waiting. To understand our prohibition on busy waiting, think of the implementa-
tion. If a process uses the processor while waiting, the processor cannot be executing 
other processes. At best, the computation will be delayed unnecessarily, and at worst, 
the waiting process will use all the available processor cycles in a single-core system, 
and will wind up waiting forever.
Many operating systems include coordination functions that applications can use to 
avoid busy waiting. Xinu provides a semaphore abstraction — the system supplies a
set of system calls that allow applications to operate on semaphores and to create sema-
phores dynamically. A semaphore consists of an integer value that is initialized when 
the semaphore is created and a set of zero or more processes that are waiting on the 
semaphore. The system call wait decrements a semaphore and adds the calling process 
to the set of waiting processes if the result is negative. The system call signal performs 
the opposite action by incrementing the semaphore and allowing one of the waiting 
process to continue, if any are waiting. To synchronize, a producer and consumer need 
two semaphores: one on which the consumer waits and one on which the producer 
waits. In Xinu, semaphores are created dynamically with the system call semcreate, 

†The example assumes a 32-bit architecture in which each operation affects the entire 32-bit integer;
when run on an 8-bit architecture, some bytes of n may be updated before others.

Sec. 2.8        Shared Memory, Race Conditions, And Synchronization 
27
which takes the desired initial count as an argument, and returns an integer identifier by 
which the semaphore is known.
Consider the example in file ex5.c†. The main process creates two semaphores, 
consumed and produced, and passes them as arguments to the processes it creates. Be-
cause the semaphore named produced begins with a count of 1, wait will not block the 
first time it is called in cons2. So, the consumer is free to print the initial value of n. 
However, semaphore consumed begins with a count of 0, so the first call to wait in 
prod2 blocks. In effect, the producer waits for semaphore consumed before increment-
ing n to guarantee that the consumer has printed it. When the example executes, the 
producer and consumer coordinate, and the consumer prints all values of n from 0 
through 1999.
//** eexx55..cc -- mmaaiinn,, pprroodd22,, ccoonnss22 **//
##iinncclluuddee <<xxiinnuu..hh>>
vvooiidd
pprroodd22((ssiidd3322,, ssiidd3322)),, ccoonnss22((ssiidd3322,, ssiidd3322));;
iinntt3322
nn == 00;;
//** VVaarriiaabbllee nn hhaass iinniittiiaall vvaalluuee zzeerroo
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
mmaaiinn
--
PPrroodduucceerr aanndd ccoonnssuummeerr pprroocceesssseess ssyynncchhrroonniizzeedd wwiitthh sseemmaapphhoorreess
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
mmaaiinn((vvooiidd))
{{
ssiidd3322
pprroodduucceedd,, ccoonnssuummeedd;;
ccoonnssuummeedd == sseemmccrreeaattee((00));;
pprroodduucceedd == sseemmccrreeaattee((11));;
rreessuummee(( ccrreeaattee((ccoonnss22,, 11002244,, 2200,, ""ccoonnss"",, 22,, ccoonnssuummeedd,, pprroodduucceedd)) ));;
rreessuummee(( ccrreeaattee((pprroodd22,, 11002244,, 2200,, ""pprroodd"",, 22,, ccoonnssuummeedd,, pprroodduucceedd)) ));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** pprroodd22
--
IInnccrreemmeenntt nn 22000000 ttiimmeess,, wwaaiittiinngg ffoorr iitt ttoo bbee ccoonnssuummeedd
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
pprroodd22((
ssiidd3322
ccoonnssuummeedd,,
ssiidd3322
pprroodduucceedd
))
{{
iinntt3322
ii;;

†Section 2.10 on page 30 explains the type sid32 used in the code to declare a semaphore ID.

28 
Concurrent Execution And Operating System Services 
Chap. 2
ffoorr(( ii==11 ;; ii<<==22000000 ;; ii++++ )) {{
wwaaiitt((ccoonnssuummeedd));;
nn++++;;
ssiiggnnaall((pprroodduucceedd));;
}}
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ccoonnss22
--
PPrriinntt nn 22000000 ttiimmeess,, wwaaiittiinngg ffoorr iitt ttoo bbee pprroodduucceedd
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
ccoonnss22((
ssiidd3322
ccoonnssuummeedd,,
ssiidd3322
pprroodduucceedd
))
{{
iinntt3322
ii;;
ffoorr(( ii==11 ;; ii<<==22000000 ;; ii++++ )) {{
wwaaiitt((pprroodduucceedd));;
pprriinnttff((""nn iiss %%dd \\nn"",, nn));;
ssiiggnnaall((ccoonnssuummeedd));;
}}
2.9 Semaphores And Mutual Exclusion
Semaphores provide another important purpose, mutual exclusion. Two or more 
processes engage in mutual exclusion when they cooperate so that only one of them ob-
tains access to a shared resource at a given time. For example, suppose two executing 
processes each need to insert items into a shared linked list. If they access the list con-
currently, pointers can be set incorrectly. Producer–consumer synchronization does not 
handle the problem because the two processes do not alternate accesses. Instead, a 
mechanism is needed that allows either process to access the list at any time, but 
guarantees mutual exclusion so that one process will wait until the other finishes.
To provide mutual exclusion for use of a resource such as a linked list, the 
processes create a single semaphore that has an initial count of 1. Before accessing the 
shared resource, a process calls wait on the semaphore, and calls signal after it has com-
pleted access. The calls to wait and signal can be placed at the beginning and end of 
the functions designed to perform the update, or they can be placed around the lines of 
code that access the shared resource. We use the term critical section to refer to the 
code that cannot be executed by more than one process at a time.

Sec. 2.9        Semaphores And Mutual Exclusion 
29
For example, file ex6.c shows a function that adds an item to an array that is
shared by multiple concurrent processes. The critical section consists of the single line:
sshhaarreedd[[nn++++]] == iitteemm;;
which adds the item to the array and increments the count of items. Thus, the code for 
mutual exclusion only needs to surround one line of code. In the example, the critical 
section has been placed in a function, additem, which means the calls to wait and signal 
occur at the beginning and end of the function.
The code in additem calls wait on semaphore mutex before accessing the array, and 
calls signal on the semaphore when access is complete. In addition to the function, the
file contains declarations for three global variables: an array, shared, an index for the 
array, n, and the ID of the semaphore used for mutual exclusion, mutex.
//** eexx66..cc -- aaddddiitteemm **//
##iinncclluuddee <<xxiinnuu..hh>>
ssiidd3322
mmuutteexx;;
//** AAssssuummee iinniittiiaalliizzeedd wwiitthh sseemmccrreeaattee
**//
iinntt3322
sshhaarreedd[[110000]];;
//** AAnn aarrrraayy sshhaarreedd bbyy mmaannyy pprroocceesssseess
**//
iinntt3322
nn == 00;;
//** CCoouunntt ooff iitteemmss iinn tthhee aarrrraayy
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
** aaddddiitteemm
--
OObbttaaiinn eexxcclluussiivvee uussee ooff aarrrraayy sshhaarreedd aanndd aadddd aann iitteemm ttoo iitt
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
aaddddiitteemm((
iinntt3322
iitteemm
//** IItteemm ttoo aadddd ttoo sshhaarreedd aarrrraayy
**//
))
{{
wwaaiitt((mmuutteexx));;
sshhaarreedd[[nn++++]] == iitteemm;;
ssiiggnnaall((mmuutteexx));;
}}
The code assumes that global variable mutex will be assigned the ID of a sema-
phore before any calls to additem occur. That is, during initialization, the following 
statement was executed:
mutex = semcreate(1);
The code in file ex6.c provides a final illustration of the difference between the
way one programs in sequential and concurrent environments. In a sequential program,
a function often acts to isolate changes to a data structure. By localizing the code that

30 
Concurrent Execution And Operating System Services 
Chap. 2
changes a data structure in one function, a programmer gains a sense of security — only 
a small amount of code needs to be checked for correctness because nothing else in the 
program will interfere with the data structure. In a concurrent execution environment, 
isolating the code into a single function is insufficient. A programmer must guarantee 
that execution is exclusive because interference can come from another process execut-
ing the same function at the same time.
2.10 Type Names Used In Xinu
Data declarations in the code above illustrate conventions used throughout the text. 
For example, semaphores are declared using the type name sid32. This section explains 
the reasoning for the conventions.
Two important questions arise when programming in C. When is it appropriate to 
define a new type name? How should a type name be chosen? The questions require 
careful thought because types fill two conceptual roles.
d  Size. A type defines the storage associated with a variable and the
set of values that can be assigned to the variable.
d Use. A type defines the abstract meaning of a variable and helps a
programmer know how a variable can be used.
Size. The sizes of variables are especially important in an embedded system be-
cause a programmer must design data structures that fit in the memory available. Fur-
thermore, choosing a size that does not match the underlying hardware can result in 
unexpected processing overhead (e.g., arithmetic operations on large integers can re-
quire multiple hardware steps). Unfortunately, C does not specify the exact size of con-
crete types, such as int, short, and long. Instead, the size of items depends on the 
underlying computer architecture. For example, a long integer can occupy 32 bits on 
one computer and 64 bits on another computer. To guarantee sizes, a programmer can 
define and use a set of type names, such as int32, that specify data size.
Use.  The classic purpose of a type arises from the need to define the purpose of a 
variable (i.e., to tell how the variable is used). For example, although semaphore IDs 
are integers, defining a type name such as sid32 makes it clear to anyone reading the 
code that a variable holds a semaphore ID and should only be used where a semaphore 
ID is appropriate (e.g., as an argument to a function that operates on a semaphore).
Thus, although it consists of an integer, a variable of type sid32 should not be used as a 
temporary value when computing an arithmetic expression, nor should it be used to 
store a process ID or a device ID.
Include files further complicate type declarations in C. In principle, one would ex-
pect each include file to contain the type, constant, and variable declarations related to a 
single module. Thus, one would expect to find the type for a process identifier declared 
in the include file that defines items related to processes. In an operating system, how-
ever, many cross-references exist among modules. For example, we will see that the in-

Sec. 2.10        Type Names Used In Xinu 
31
clude file for semaphores references the process type, and the include file for processes 
references the semaphore type.
We have chosen an approach in which types accommodate the need to define size
as well as the need to define use. Instead of using the C form of char, short, int, and
long, the code uses the types that Figure 2.1 lists.

Type 
Meaning

byte 
unsigned 8-bit value

bool8 
8-bit value used as a Boolean

int16 
signed 16-bit integer

uint16 
unsigned 16-bit integer

int32 
signed 32-bit integer

uint32 
unsigned 32-bit integer








































Figure 2.1  Basic type names for integers used throughout Xinu.
For types that correspond to operating system abstractions, each name combines a 
short mnemonic that identifies the purpose plus a numeric suffix that identifies the size. 
Thus, a type that defines a semaphore ID to be a 32-bit integer has been assigned the 
name sid32, and a type that defines a queue ID to be a 16-bit integer has been assigned 
the name qid16.
To permit cross-references of types among modules, a single include file, kernel.h, 
contains declarations for all type names, including the types listed in Figure 2.1. Thus, 
each source file must include kernel.h before referencing any type name. In particular, 
an include for kernel.h must precede the include statements for other modules. For con-
venience, a single include file, xinu.h, includes all header files used in Xinu in the 
correct order.
2.11 Operating System Debugging With Kputc And Kprintf
The examples in this chapter use Xinu functions putc and printf to display output
on the CONSOLE. Although such functions work well once an operating system has
been completed and tested, they are not used during construction or debugging because 
they require many components of the operating system to function correctly. What do 
operating system designers use?
Designers use polled I/O. That is, a designer creates a special I/O function that 
does not need interrupts to be working. Following Unix tradition, we call the special 
function kputc (i.e., a version of putc suitable for use inside the operating system ker-
nel).  Kputc takes a character, c, as an argument and performs four steps:

32 
Concurrent Execution And Operating System Services 
Chap. 2
d Disable interrupts
d Wait for the CONSOLE serial device to be idle
d Send character c to the serial device
d Restore interrupts to their previous status
Thus, when a programmer invokes kputc, all processing stops until the character 
has been displayed. Once the character has been displayed, processing resumes. The 
important idea is that the operating system itself does not need to be working because 
kputc manipulates the hardware device directly.
Once kputc is available, it is easy to create a function that can display formatted 
output. Again following Unix tradition, we call the function kprintf. Basically, kprintf 
operates exactly like printf except that instead of invoking putc to display each charac-
ter, kprintf invokes kputc.†
Although it is not important to understand the exact details of how polled I/O
operates, it is essential to use polled I/O when debugging:
Whenever they modify or extend the operating system, programmers 
should use kprintf to display messages rather than printf.
2.12 Perspective
Concurrent processing is one of the most powerful abstractions in computer sci-
ence. It makes programming easier, less error prone, and in many cases, yields higher 
overall performance than code that attempts to switch among tasks manually. The ad-
vantages are so significant that once concurrent execution was introduced, it rapidly be-
came the primary choice for most programming.
2.13 Summary
An understanding of an operating system begins with the set of services the system 
provides to applications. Unlike a conventional, sequential programming environment, 
an operating system provides concurrent execution in which multiple processes proceed 
at the same time. In our example system, as in most systems, a process can be created
or terminated at runtime. Multiple processes can each execute a separate function, or 
multiple processes can execute a single function. In a concurrent environment, storage 
for arguments, local variables, and a function call stack are associated with each process 
rather than with the code.

†Debugging operating system code is difficult because disabling interrupts can change the execution of a 
system (e.g., by preventing clock interrupts). Thus, a programmer must be extremely careful when using
kprintf.

Sec. 2.13        Summary
33
Processes use synchronization primitives, such as semaphores, to coordinate execu-
tion. Two primary forms of coordination are producer–consumer synchronization and 
mutual exclusion.
EXERCISES
2.1 
What is the API an operating system provides, and how is the API defined?
2.2 
To what does multitasking refer?
2.3 
List the two basic categories of multitasking systems, and state the characteristics of each.
2.4 
What characteristics are generally associated with the terms process, task, and thread?
2.5 
How is a process ID used?
2.6 
How does calling function X differ from calling create to start a process executing function
X?
2.7  The program in file ex3.c uses three processes. Modify the code to achieve the same
results using only two processes.
2.8  Test the program in file ex4.c repeatedly. Does it always print the same number of zeroes?
Does it ever print a value of n other than 0 or 2000?
2.9 
In Xinu, what is the difference in storage between global variables and local variables?
2.10 Why do programmers avoid busy waiting?
2.11  Suppose three processes attempt to use function additem in file ex6.c at the same time. Ex-
plain the series of steps that occur, and give the value of the semaphore during each step.
2.12  Modify the producer–consumer code in file ex5.c to use a buffer of 15 slots, and have the
producer and consumer synchronize in such a way that a producer can generate up to 15 
values before blocking and a consumer can extract all values in the buffer before blocking. 
That is, arrange for the producer to write integers 1, 2, ... in successive locations of the 
buffer, wrapping around to the beginning after filling the last slot, and have the consumer 
extract values and print them on the console. How many semaphores are needed?
2.13  In file ex5.c, the semaphore produced is created with a count of 1. Rewrite the code so
produced is created with a count of 0 and the producer signals the semaphore once before 
starting the iteration. Does the change affect the output?
2.14 Find the documentation for the serial port (or console device hardware) on a platform to
which you have access. Describe how to construct a polled I/O function, kputc() that uses
the device.


Chapter Contents
3.1 
Introduction, 37
3.2 
Physical And Logical Organizations Of A Platform, 38
3.3 
Instruction Sets, 38
3.4 
General-purpose Registers, 39
3.5 
I/O Buses And The Fetch-Store Paradigm, 41
3.6 
Direct Memory Access, 42
3.7 
The Bus Address Space, 42
3.8 
Bus Startup And Configuration, 43
3.9 
Calling Conventions And The Runtime Stack, 44
3.10 
Interrupts And Interrupt Processing, 47
3.11 
Vectored Interrupts, 48
3.12 
Exception Vectors And Exception Processing, 48
3.13 
Clock Hardware, 49
3.14 
Serial Communication, 49
3.15 
Polled vs. Interrupt-driven I/O, 49
3.16 
Storage Layout, 50
3.17 
Memory Protection, 51
3.18 
Hardware Details And A System On Chip Architecture, 51
3.19 
Perspective, 52
3.20 
Hardware References, 52


3
An Overview Of The 
Hardware And Runtime 
Environment
One machine can do the work of fifty ordinary men.
No machine can do the work of one extraordinary
man.
— Elbert Hubbard
3.1 Introduction
Because it deals with the details of devices, processors, and memory, an operating 
system cannot be designed without knowledge of the capabilities and features of the 
underlying hardware. Throughout the text, we will use two example hardware plat-
forms: a Galileo and a BeagleBone Black. The platforms each consist of a small, low-
cost circuit board that includes a processor, memory, and a few I/O devices. The pro-
cessors on the boards employ well-known instruction sets: the Galileo uses Intel’s in-
struction set that is known as x86, and the BeagleBone Black uses an ARM instruction 
set. We will see that most operating system functions are identical on the two architec-
tures. However, the use of two platforms will allow a reader to compare how low-level 
OS system functions, such as a context switch, differ between a CISC (Complex In-
struction Set Computer) architecture and a RISC (Reduced Instruction Set Computer) 
architecture.
The remainder of the chapter provides an overview of the two hardware platforms, 
describing pertinent features of the processors, memories, and I/O devices. The chapter
37

38 
An Overview Of The Hardware And Runtime Environment 
Chap. 3
explains enough of the architecture, memory addressing, runtime stack, interrupt mecha-
nisms, and device addressing to allow a reader to understand the discussions that fol-
low. Although the chapter focuses on specific boards, the basic concepts apply broadly 
to most computer systems.
3.2 Physical And Logical Organizations Of A Platform
Physically, the platforms we are using each consist of a single, self-contained cir-
cuit board that uses a separate power cube. Most of the major components are con-
tained in a single VLSI chip that is known as a System on Chip (SoC).† Because the
boards are intended for use in experimental systems, they come completely assembled.
Like most computers, our platforms each include a serial console — a character-
oriented device that the operating system uses to issue information messages, report er-
rors, and interact with a user.‡ The Galileo has a (nonstandard) connector for its serial 
console. Thus, one must obtain a special cable. Although it has serial hardware on the 
board, the BeagleBone Black does not have a connector. Instead, a user must purchase 
a converter that connects to GPIO pins on the board. To interact over a serial console, 
a user can connect the serial line through a cable to a conventional computer (e.g., to 
the USB connection to a laptop or desktop), and then run an application that sends char-
acters to the console line and displays the results. Information about a serial connection 
and instructions describing how to attach a serial connector can be found on the web 
site:
http:// www.xinu.cs.purdue.edu
For now, it is sufficient to know that once an operating system is loaded on one of the 
platforms, a user can run an application that sends keystrokes to the platform and 
displays output from the platform.
Logically, the platforms follow the same overall architecture as most general-
purpose computer systems. The components on the SoC include a processor, memory 
interface, and I/O device interfaces. Among other devices, each board includes an Eth-
ernet network interface that allows the board to connect to a local network or the Inter-
net. Figure 3.1 illustrates the conceptual organization.
3.3 Instruction Sets
Recall from the above discussion that the Galileo board implements an Intel in-
struction set and the BeagleBone Black implements an ARM instruction set. Except for
a few special cases, an operating system does not need to focus on the instruction set 
because most OS functions are written in C, and a compiler generates the appropriate 
code. Thus, instruction set details will only be important for a handful of functions that 
are written in assembly language.
                                †See page 51 for an explanation of the difference between the boards and the underlying SoC. 
‡Technically, a serial console uses the RS-232 standard.

Sec. 3.3        Instruction Sets
39
system backplane
serial 
console 
interface
main 
memory 
(RAM)
onboard 
flash 
memory
processor
Ethernet 
network 
interface
USB 
host
interface
USB 
client 
interface
external I/O connections
Figure 3.1 The logical organization of major components in the example
platforms.
In practice, the platforms each include additional hardware features that are not 
shown in the figure. For example, the BeagleBone Black provides graphics and floating 
point accelerators and an HDMI interface; the Galileo provides a mini-PCI Express in-
terface and an interface for a micro-SD card. However, we are only concerned with the 
hardware features most pertinent to an operating system. For now, we will focus on the 
overall design of each component and how the components fit together. Later chapters 
discuss additional details, explain how an operating system interacts with the hardware, 
and provide examples.
3.4 General-purpose Registers
Most computer architectures provide a small set of general-purpose registers. We 
think of registers as temporary, high-speed storage that can be used in arithmetic, logi-
cal, and data movement instructions. A register can hold an integer, a pointer, or other 
data value. Because registers are much faster than memory, a compiler keeps frequently 
used variables in registers, and only writes values back to memory when the register is 
needed for another variable.
Hardware registers play a key role in operating system design because they form
part of the state of a computation. That is, the hardware provides a single set of
general-purpose registers, and each computation uses the registers. To support con-
current processes, an operating system must provide each process with the illusion that 
it has complete control over the registers. From a process’s point of view, once the 
process can store a value in register X, the value will remain until the process changes 
it. We know that an operating system switches the processor among multiple processes. 
To preserve the illusion when switching from one process to another, the operating sys-
tem must save a copy of the values that the first process had placed in all the registers, 
and load the registers with the values the second process was using when it last had

40 
An Overview Of The Hardware And Runtime Environment 
Chap. 3
control of the processor. In Chapter 5, we will see exactly how an operating system
saves and restores copies of registers. For now, it is sufficient to understand that the 
hardware contains one copy of registers that all processes share.
3.4.1  Galileo (Intel)
The Galileo board follows the traditional 32-bit Intel architecture. In addition to an 
internal program counter and floating point registers, the processor has eight general-
purpose registers. For our purposes, each register is 32 bits wide.† Figure 3.2 lists the 
registers on an Intel processor by giving the name used to reference a register and the 
meaning assigned.

Name 
Use

EAX 
Accumulator

EBX 
Base

ECX 
Count

EDX 
Data

ESI 
Source Index

EDI 
Destination Index

EBP 
Base Pointer

ESP 
Stack Pointer




















































Figure 3.2 The general-purpose registers in the Galileo board (Intel) and the
meaning of each.
In practice, the Intel instruction set allows a programmer to access subparts of re-
gisters. For example, the hardware allows a programmer to treat some of the 32-bit re-
gisters as pairs of 16-bit registers. That is, instructions can access the low-order 16 bits 
or the high-order 16 bits of a register without changing the other part. In fact, some in-
structions allow a programmer to reference individual bytes of a register. However, 
such details will not be important except in special cases, such as system startup.
Registers can be used as operands in instructions, or can point to an operand in 
memory. Despite being classified as general-purpose, individual registers are assigned 
specific uses by the hardware and/or compiler. For example, the ESP register serves as 
a pointer to a runtime stack. The stack can be used as temporary storage during compu-
tation (e.g., by pushing intermediate results and popping them later), and is essential 
during function invocation because the activation record for a called function is pushed 
on the stack during a function call, and popped off the stack when the function returns.
                                †Xinu runs in protected mode; an x86 processor has other modes, such as a 64-bit mode, with more
general-purpose registers.

Sec. 3.4        General-purpose Registers 
41
3.4.2  BeagleBone Black (ARM)
The BeagleBone Black follows the traditional 32-bit ARM architecture, which has
15 general-purpose registers plus a program counter. The program counter contains the 
address of the instruction that will be executed next, and is only changed during a jump. 
Figure 3.3 lists the 32-bit registers on an ARM processor, aliases, and their typical use.†

Name 
Alias 
Use

R0 – R3 
a1 – a4 
Argument registers

R4 – R11 
v1 – v8 
Variables and temporaries

R9 
sb 
Static base register

R12 
ip 
Intra procedure call scratch register

R13 
sp 
Stack pointer

R14 
lr 
Link register used for return address

R15 
pc 
Program counter





























































Figure 3.3 The general-purpose registers and the program counter in the
BeagleBone Black (ARM) and the meaning of each.
3.5 I/O Buses And The Fetch-Store Paradigm
We use the term bus to refer to a mechanism that provides the primary path
between the processor and other components, namely the memory, I/O devices, and
other interface controllers. Bus hardware uses a fetch-store paradigm in which the only 
operations are fetch, to move data from a component across the bus to the processor, 
and store, to move data from the processor across the bus to a component. For exam-
ple, when it needs to access memory, the processor places a memory address on the bus 
and issues a fetch request to obtain the corresponding value. The memory hardware 
responds to the request by looking up the address in memory, placing the data value on 
the bus, and signalling the processor that the value is ready. Similarly, to store a value 
in memory, the processor places an address and value on the bus and issues a store re-
quest; the memory hardware extracts the value and stores a copy in the specified 
memory location. Bus hardware handles many details of the fetch-store paradigm, in-
cluding signals that the processor and other components use to communicate and control 
access to the bus. We will see that an operating system can use a bus without knowing 
many details of the underlying hardware.
The example systems use memory-mapped I/O, which means that each I/O device
is assigned a set of addresses in the bus address space. The processor uses the same
                                †The ARM architecture has eight additional floating point registers that are not listed here because they
are not directly relevant to process management.

42 
An Overview Of The Hardware And Runtime Environment 
Chap. 3
fetch-store paradigm to communicate with I/O devices as with memory. We will see
that communication with a memory-mapped I/O device resembles data access. First,
the processor computes the address associated with a device. Second, to access the de-
vice, the processor either stores a value to the address or fetches a value from the ad-
dress.
3.6 Direct Memory Access
Higher-speed I/O devices (e.g., an Ethernet device) offer Direct Memory Access 
(DMA), which means the device contains hardware that can use the bus to communicate 
directly with memory. The key idea is that DMA allows I/O to proceed quickly be-
cause it does not interrupt the processor frequently nor does it require the processor to 
perform each data transfer. Instead, a processor can give the I/O device a list of opera-
tions, and the device proceeds from one to the next. Thus, DMA allows a processor to 
continue running processes while a device operates.
As an example, consider how an Ethernet device uses DMA. To receive a packet,
the operating system allocates a buffer in memory and starts the Ethernet device. When
a packet arrives, the device hardware accepts the packet and makes multiple bus
transfers to move a copy into the buffer in memory. Finally, once the entire packet has 
been transferred, the device interrupts the processor. Sending a packet is equally effi-
cient: the operating system places the packet in a buffer in memory and starts the de-
vice. The device uses the bus multiple times to fetch the packet from the buffer in 
memory. The device then transmits the packet on the network and interrupts the pro-
cessor after the entire packet has been transferred.
We will see that the DMA hardware on the example platforms allows a processor
to request multiple operations. In essence, the processor creates a list of packets to be
sent and a list of buffers to be used for incoming packets. The network interface
hardware uses the lists to send and receive packets without requiring the processor to 
restart the device after each operation. As long as the processor consumes incoming 
packets faster than they arrive and adds fresh buffers to the list, the network hardware 
device will continue to read packets. Similarly, as long as the processor continues to 
generate packets and add them to the list, the network hardware device will continue to 
transmit the packets. Later chapters explain additional DMA details, and the example 
code illustrates how a device driver in the operating system allocates I/O buffers and 
controls DMA operations.
3.7 The Bus Address Space
Each of the platforms uses a 32-bit bus address space, with addresses ranging from 
0x00000000 through 0xFFFFFFFF. Some of the addresses in the bus address space 
correspond to memory, some to FlashROM, and others to I/O devices. The next sec-
tions provide more detail.

Sec. 3.7        The Bus Address Space 
43
Memory. On each system, memory is divided into 8-bit bytes, with a byte being 
the smallest addressable unit. The C language uses the term character in place of byte 
because each byte can hold one ASCII character. Although a 32-bit bus can address 4 
Gbytes total, not all possible addresses are assigned. The Galileo contains an 8 Mbyte 
Legacy SPI Flash (used to store firmware, such as a bootstrap loader), 512 Kbytes of 
SRAM, 256 Mbytes of DRAM, and between 256 and 512 Kbytes of storage for Ar-
duino sketches. Note that the largest item, the DRAM, occupies only 6.25% of the ad-
dress space. The BeagleBone Black contains a 4 Gbyte Flash memory (used to store 
firmware), and 512 Mbytes of DRAM. In the case of a BeagleBone Black, the DRAM 
occupies 12.5% of the bus address space, meaning that many addresses are not as-
signed.
Do unassigned bus addresses cause a problem? The hardware allows addresses to 
remain unassigned provided the addresses are not referenced. If the processor attempts
to access an unassigned address, however, the hardware raises an exception.† For ex-
ample, a bus exception can occur if a Xinu process overflows an array or generates an 
incorrect pointer and then tries to dereference the pointer. The important point is:
Referencing an unassigned bus address, such as an address beyond
the physical memory, will cause the hardware to create an exception.
3.8 Bus Startup And Configuration
How should memory modules and devices be assigned addresses in the bus address
space? Two methods are used:
d Static address assignment
d Dynamic address assignment
The example platforms illustrate the two methods: the BeagleBone Black uses stat-
ic assignment, and the Galileo uses dynamic assignment.
Static address assignment. Often used by small, embedded systems, static means 
that all details of the hardware configuration are chosen when the hardware is designed. 
That is, a hardware designer chooses a set of peripheral devices, and assigns each a 
unique address on the bus. The hardware designer passes the assignments to an operat-
ing system designer, who must configure the operating system to match the underlying 
hardware. Extreme care must be taken — if the operating system does not match the 
hardware exactly, the system will not operate correctly (i.e., may not even be able to 
boot). Static configuration has the advantage of increased runtime efficiency, but the 
disadvantages of less generality and susceptibility to human error.
Dynamic address assignment. Dynamic assignment means that when a system 
boots, an operating system, with the support of the bus hardware and platform firmware, 
must discover devices and memories attached to the bus. Each component attached to 
the bus is assigned a unique identifier that specifies the vendor and the specific 
                                †Chapter 24 discusses exception handling.

44 
An Overview Of The Hardware And Runtime Environment 
Chap. 3
hardware type. An operating system probes the bus to determine which components are 
present. Each component returns its ID. For example, an operating system can deter-
mine the type and size of each memory module that has been installed as well as the ex-
act bus address assigned to each module. A bus that supports dynamic assignment has 
the advantage of increased generality because a single operating system image can run 
on a variety of hardware configurations. However, dynamic assignment makes both bus 
hardware and operating system code more complex.
Chapter 25 discusses operating system configuration in more detail, and shows an 
example of configuration; chapters on device mechanisms and drivers show how a sys-
tem contends with static and dynamic address assignment.
3.9 Calling Conventions And The Runtime Stack
We will see that operating systems rely heavily on mechanisms for function invo-
cation. When they invoke operating systems services, applications use function calls. 
Thus, function calls define operating system services. Furthermore, when it switches 
context from one process to another, an operating system must handle the situation 
where the processes have each made a series of nested function calls. Thus, an operat-
ing system designer must understand the details of function invocation. The following 
paragraphs define key concepts and mechanisms related to function invocation.
Calling conventions. The steps taken during a function call and return are known 
as calling conventions. The term convention arises because the hardware does not dic-
tate all details. Instead, the hardware design places some constraints on possible ap-
proaches, and leaves final choices to a compiler writer. We will see that because it calls 
functions to process interrupts and switch from one running process to another, an 
operating system must understand and follow the same conventions as the compiler.
Arguments and argument passing. When a function is called, the caller supplies a 
set of actual arguments that correspond to formal parameters. A variety of argument 
passing mechanisms have been used in commercial processors. The example platforms 
illustrate two common approaches: placing arguments on the stack and passing argu-
ments in general-purpose registers.
Runtime stack and stack frame contents. A statically scoped language, such as C, 
uses a runtime stack to store the state associated with a function call. The compiler al-
locates enough space on the stack to hold an activation record for the called function. 
The allocated space is known as a stack frame. Each activation record contains space 
for the local variables associated with the function, temporary storage needed during 
computation, a return address, and other miscellaneous items. We assume the stack 
grows downward from higher memory addresses to lower memory addresses. A com-
piler generates code needed to create a stack frame. The compiler computes the size 
needed for local variables as well as the size needed for auxiliary items, such as the 
temporary space used to save the contents of registers (so the function can use the regis-
ters for computation and then restore their original values before returning to the caller). 
We will see that when it creates a new process, an operating system needs to construct a

Sec. 3.9        Calling Conventions And The Runtime Stack 
45
stack frame for the process’s initial function. Thus, the operating system needs to know 
exactly how a stack frame is laid out, including the location of arguments and the return 
address. Examples will clarify the concept. In the examples below, we assume a gcc 
compiler; the calling conventions used by other compilers may differ in minor ways.
3.9.1  Galileo (Intel)
On an Intel processor, before invoking a function, a caller pushes registers EAX, 
ECX, and EDX on the stack, pushes the arguments in reverse order, and then executes a 
call instruction, which pushes the return address on the stack. Code in the called func-
tion pushes EBP, EBX, EDI, and ESI, and pushes space for the local variables. When 
the call returns, values are popped from the stack in reverse order. Figure 3.4 illustrates 
values on the top of the stack immediately after a function call (remember that a stack 
grows downward).
EBP
ESP
Saved EAX 
Saved ECX 
Saved EDX
Argument N 
. . .
Argument 2 
Argument 1
Return address
Saved EBP 
Saved EBX
Saved EDI 
Saved ESI
Local variable K 
. . .
Local variable 2 
Local variable 1
pushed by calling function
pushed by called function
set by the called function
after EBP is saved on the stack
pushed by the call instruction; 
removed by the ret instruction
stack pointer just before the 
call instruction is executed
Figure 3.4  The stack on an Intel processor when a function is called.

46 
An Overview Of The Hardware And Runtime Environment 
Chap. 3
3.9.2  BeagleBone Black (ARM)
On an ARM processor, the first four arguments to a function are passed in registers 
a0 – a3 (i.e., registers r0 – r4). Arguments beyond the first four are passed on the 
stack. To call a function, the caller executes a BL (branch and link) instruction. When 
the BL executes, the hardware places the return address in register r14. The called
function must save registers it will use; typically, the called function pushes copies of 
r14 – r4 onto the stack, and then pushes the CPSR (status) register. Figure 3.5 illus-
trates values on the top of the stack immediately after a function call (remember that a 
stack grows downward). In the figure, the top of the stack only contains space for local 
variables beyond the first seven. By convention, the first seven local variables are 
stored in registers 4 through 8, 10, and 11.
In fact, the set of saved registers varies across versions of the ARM architecture. 
Furthermore, if a program uses floating point, the floating point registers must also be 
saved and restored.
Argument K 
. . .
Argument 6 
Argument 5
Saved r14 
Saved r13 
Saved r12 
Saved r11 
Saved r10
Saved r9 
Saved r8 
Saved r7 
Saved r6 
Saved r5 
Saved r4
Saved CPSR
Local variables 
beyond the first 
seven, if any
sp
pushed by calling function 
if needed
pushed by called function
stack pointer just before the 
BL instruction is executed 
saved value of return address
Figure 3.5  The stack on an ARM processor when a function is called.

Sec. 3.9        Calling Conventions And The Runtime Stack 
47
3.10 Interrupts And Interrupt Processing
Modern processors provide mechanisms that allow external I/O devices to inter-
rupt the processor when they need service. In most cases, processor hardware has a 
closely related exception mechanism that is used to inform the software when an error
or fault occurs (e.g., an application attempts division by zero or references a page in vir-
tual memory that is not present in memory). From an operating system’s point of view, 
interrupts are fundamental because they allow the processor to perform computation at 
the same time I/O proceeds.†
Any of the I/O devices connected to a bus can interrupt the processor when the de-
vice needs service. To do so, the device places a signal on one of the bus control lines. 
During normal execution of the fetch-execute cycle, hardware in the processor monitors 
the control line and initiates interrupt processing when the control line has been sig-
naled. In the case of a RISC processor, the main processor does not usually contain the 
hardware to handle interrupts. Instead, a co-processor interacts with the bus on behalf 
of the main processor.
Whatever interrupt mechanisms a processor uses, the hardware or the operating
system must guarantee that:
d The entire state of the processor, including the program
counter and status registers, is saved when an interrupt occurs
d The processor runs the appropriate interrupt handler processor,
which must have been placed in memory before the interrupt 
occurs
d When an interrupt finishes, the operating system and hardware
provide mechanisms that restore the entire state of the proces-
sor and continue processing at the point of interruption
Interrupts introduce a fundamental idea that pervades an entire operating system.
An interrupt can occur at any time, and an operating system can switch from one proc-
ess to another during an interrupt. The consequence is that other processes can run at
any time.
To prevent problems caused by concurrent processes trying to manipulate shared 
data, an operating system must take steps to avoid switching context. The simplest way
to prevent other processes from executing consists of disabling interrupts. That is, the 
hardware includes an interrupt mask mechanism that an operating system can use to 
control interrupts. On many hardware systems, if the interrupt mask is assigned a value 
of zero, the processor ignores all interrupts; if the mask is assigned a non zero value, 
the hardware allows interrupts to occur. On some processors, the hardware has indivi-
dual interrupt bits for each device, and on others, the mask provides a set of eight or 
sixteen levels, and each device is assigned a level. We will see that many operating 
system functions disable interrupts while they manipulate global data structures and I/O 
queues.
                                †Later chapters explain how an operating system manages interrupt and exception processing, and show
how the high-level I/O operations a user performs relate to low-level device hardware mechanisms.

48 
An Overview Of The Hardware And Runtime Environment 
Chap. 3
3.11 Vectored Interrupts
When a device interrupts, how does the hardware know the location of the code 
that handles the interrupt? The hardware on most processors uses a mechanism known 
as vectored interrupts. The basic idea is straightforward: each device is assigned a 
small integer number: 0, 1, 2, and so on. The integers are known as interrupt level 
numbers or interrupt request numbers. The operating system creates an array of 
pointers in memory known as an interrupt vector, where the ith entry in the interrupt 
vector array points to the code that handles interrupts for the device with vector number 
i. When it interrupts, a device sends its vector number over the bus to the processor. 
Depending on the processor details, either the hardware or the operating system uses the 
vector number as an index into the interrupt vector, obtains a pointer, and uses the 
pointer as the address of the code to run.
Because it must be configured before any interrupts occur, an operating system ini-
tializes the interrupt vector at the same time devices are assigned addresses on the bus. 
The assignment of interrupt level numbers usually employs the same paradigm as ad-
dress assignment. A manual assignment means a human assigns a unique interrupt level 
number to each device and then configures the interrupt vector addresses accordingly. 
An automatic approach requires bus and device hardware that can assign interrupt levels 
at runtime. To use the automatic approach, an operating system polls devices at startup, 
assigns a unique interrupt level number to each device, and initializes the interrupt vec-
tor accordingly. Automatic assignment is safer (i.e., less prone to human error), but re-
quires more complex hardware in both the devices and the bus. We will see examples 
of static and automatic interrupt vector assignment.
3.12 Exception Vectors And Exception Processing
Many processors follow the same vectored approach for exceptions as they use for 
interrupts. That is, each exception is assigned a unique number: 0, 1, 2, and so on.
When an exception occurs, the hardware places the exception number in a register. The 
operating system extracts the exception number, and uses the number as the index into 
an exception vector. A minor difference occurs between the way processor hardware 
handles interrupts and exceptions. We think of an interrupt as occurring between two 
instructions. Thus, one instruction has completed and the next instruction has not be-
gun. However, an exception occurs during an instruction. Thus, when the processor re-
turns from the exception, the program counter has not advanced, and the instruction can 
be restarted. Restarting is especially important for page fault exceptions — when a 
page fault occurs, the operating system must read the missing page from memory, set 
the page table, and then execute the instruction that caused the fault a second time.

Sec. 3.13        Clock Hardware 
49
3.13 Clock Hardware
In addition to I/O devices that transfer data, most computers include hardware that
can be used to manage timed events. There are two basic forms:
d Real-time clock
d Interval timer
Real-time clock. A real-time clock circuit consists of hardware that generates a
pulse regularly (e.g., 1000 times per second). To turn a real-time clock circuit into a
real-time clock device, the hardware is configured to interrupt the processor on each 
pulse. A real-time clock device does not keep any counters, does not store the time of 
day, and may not have an adjustable cycle time (e.g., the pulse rate may be determined 
by a crystal that must be replaced to change the rate).
Interval timer. Conceptually, an interval timer consists of a real-time clock circuit
that pulses at regular intervals connected to a counter that computes a tally of pulses
plus a comparator circuit that compares the tally to a threshold value. An operating sys-
tem can specify a threshold value and can reset the counter to zero. When the counter 
reaches the threshold value, the interval timer interrupts the processor. The advantage 
of an interval timer lies in its efficiency. Instead of interrupting continuously, an inter-
val timer can be configured to wait until an event should occur. Of course, interval tim-
er hardware is more complex than a real-time clock.
3.14 Serial Communication
Serial communication devices are among the simplest I/O devices available, and 
have been used on computers for decades. Each of the example platforms contains an 
RS-232 serial communication device that is used as a system console. The serial
hardware handles both input and output (i.e., the transmission and reception of charac-
ters). When an interrupt occurs, the processor examines a device hardware register to 
determine whether the output side has completed transmission or the input side has re-
ceived a character. Chapter 15 examines serial devices, and shows how interrupts are 
processed.
3.15 Polled vs. Interrupt-driven I/O
Most I/O performed by an operating system uses the interrupt mechanism. The 
operating system interacts with the device to start an operation (either input or output), 
and then proceeds with computation. When the I/O operation completes, the device in-
terrupts the processor, and the operating system can choose to start another operation.
Although they optimize concurrency and permit multiple devices to proceed in 
parallel with computation, interrupts cannot always be used to perform I/O. For exam-

50 
An Overview Of The Hardware And Runtime Environment 
Chap. 3
ple, consider displaying a startup message for a user before the operating system has in-
itialized interrupts and I/O. Also consider a programmer writing operating systems 
code. It may be desirable to allow I/O even though it may be necessary to leave inter-
rupts disabled during debugging. In either case, interrupts cannot be used.
The alternative to interrupt-driven I/O is known as polled I/O. When using polled 
I/O, the processor starts an I/O operation, but does not enable interrupts. Instead, the 
processor enters a loop that repeatedly checks a device status register to determine 
whether the operation has completed. We have already seen an example of how an 
operating system designer can use polled I/O when we examined functions kputc and 
kprintf in Chapter 2.
3.16 Storage Layout
When it compiles a program, a C compiler partitions the resulting image into four
memory segments:
d Text segment
d Data segment
d Bss segment
d Stack segment
The text segment, which includes code for the main program and all functions, oc-
cupies the lowest part of the address space. The data segment, which contains all ini-
tialized data, occupies the next region of the address space. The uninitialized data seg-
ment, called the bss segment, follows the data segment. Finally, the stack segment oc-
cupies the highest part of the address space and grows downward. Figure 3.6 illustrates 
the conceptual organization.
text
data
bss
stack
free space
etext 
edata 
end
lowest address 
SP
Figure 3.6  Illustration of memory segments created by a C compiler.
The symbols etext, edata, and end in the figure refer to global variables that the 
loader inserts into the object program. The names are initialized to the first address 
beyond the text, data, and bss segments, respectively. Thus, a running program can 
determine how much memory remains between the end of the bss segment and the 
current top of stack by subtracting the address of end from the stack pointer, SP.
Chapter 9 explains memory allocation for multiple processes in Xinu. Although all 
processes share the text, data, and bss segments, a separate stack segment must be allo-

Sec. 3.16        Storage Layout
51
cated for each process. If three processes are executing, the stacks are allocated con-
tiguously from the highest memory address downward as Figure 3.7 illustrates.
As the figure indicates, each process has its own stack pointer. At a given time, 
the stack pointer for process i must point to an address within the stack that has been al-
located for process i. Later chapters explain the concept in detail.
text
data
bss
heap
process 1 
stack
process 2 
stack
process 3 
stack
free
etext 
edata 
end
lowest address
SP1
SP2
SP3
Figure 3.7  Illustration of memory with stack segments for three processes.
3.17 Memory Protection
The memory hardware available on the example platforms includes mechanisms 
that an operating system can use to protect one process from another and to protect the 
operating system from application processes. For example, applications can be config-
ured to run in user mode, which means they cannot read or write kernel memory. When 
an application makes a system call, control transfers to the kernel and the privilege level 
is increased to kernel mode until the call returns. The key to understanding protection 
is to remember that control can only transfer to the operating system at the specific en-
try points that the operating system designer provides. Thus, a designer can ensure that 
an application only receives carefully controlled services.
Like many other embedded systems, our example code avoids the complexity and 
runtime overhead of memory protection. Instead the code runs completely in a
privileged mode, without memory protection. The lack of protection means a program-
mer must be careful because any process can access any memory location, including the 
memory allocated to operating system structures or memory allocated to another 
process’s stack. If a process overflows the allocated stack area, the process’s runtime 
stack will overwrite data in another process’s stack.
3.18 Hardware Details And A System On Chip Architecture
Both hardware platforms use a System on Chip (SoC) approach. That is, a single
VLSI chip contains the processor, memories, and a set of I/O interfaces. For example,
the Intel Galileo contains a Quark SoC. We have chosen to emphasize the boards rath-
er than the underlying SoC because a given board can be less general than the SoC.
For example, the Quark design allows multiple cores and has multiple copies of some
I/O interfaces. However, the version of the SoC on the Galileo board provides only
one core and one Ethernet connection. Similarly, the ARM architecture is more general 
than the version available on the BeagleBone Black.

52 
An Overview Of The Hardware And Runtime Environment 
Chap. 3
Despite our focus on complete boards rather than the SoC, much of the material in 
the text generalizes to other boards that use the same SoC. For example, the context 
switch code used with the Galileo also runs on other x86 platforms, and the context 
switch code used on the BeagleBone Black also runs on other ARM platforms.
3.19 Perspective
The hardware specifications for a processor or I/O device contain so many details
that studying them can seem overwhelming. Fortunately, many of the differences
among processors are superficial — fundamental concepts apply across most hardware 
platforms. Therefore, when learning about hardware, it is important to focus on the 
overall architecture and design principles rather than on tiny details.
In terms of operating systems, many hardware details affect the overall design. In 
particular, the hardware interrupt mechanism and interrupt processing dominate many 
parts of the design. Intellectually, however, the most significant item to appreciate is 
the stunning disparity between the primitive facilities the hardware offers and the high-
level abstractions an operating system supplies.
3.20 Hardware References
General information about the BeagleBone Black, including a photo and links to a
Getting Started page and other materials can be found on the web site:
http://beagleboard.org/black
Details about the processor and SoC can be found on:
http://www.ti.com/product/am3358
and a data sheet for the SoC is available at:
http://www.ti.com/lit/pdf/spruh73
A general introduction to the Galileo and other platforms that use the Quark SoC
can be found at:
http://www.intel.com/galileo
Information about the Galileo development board, including a photo and links to sites 
with more detail, can be found at:
http://www.intel.com/content/www/us/en/intelligent-systems/galileo/galileo-overview.html

Exercises
53
EXERCISES
3.1 
Some systems use a programmable interrupt address mechanism that allows the system to
choose the address to which the processor jumps when an interrupt occurs. What is the ad-
vantage of a programmable interrupt address?
3.2  DMA introduces the possibility of unexpected errors. What happens if a DMA operation
that transfers N bytes of data begins at a memory location less than N bytes from the
highest memory address?
3.3  Read about hardware that uses multi-level interrupts. Should an interrupt at one level be
able to interrupt the system while it is processing an interrupt from another level? Explain.
3.4  What are the advantages of the memory layout shown in Figure 3.7? Are there disadvan-
tages? What other layouts might be useful?
3.5 
Embedded hardware often includes multiple interval timer devices, each with its own inter-
rupt vector. Why might multiple timers be helpful? Can a system with only a single timer 
accomplish the same tasks as a system with multiple timers? Explain.
3.6 
If you are familiar with an assembly language, read about the calling conventions that are
used to permit recursive function calls. Build a function that makes recursive calls, and 
demonstrate that your function works correctly.
3.7 
On an Intel platform, the program counter (i.e., the instruction pointer register) cannot be
read directly. Devise x86 assembly language code that determines the value indirectly by 
using instructions that manipulate the instruction pointer.


Chapter Contents
4.1 
Introduction, 57
4.2 
A Unified Structure For Linked Lists Of Processes, 58
4.3 
A Compact List Data Structure, 59
4.4 
Implementation Of The Queue Data Structure, 61
4.5 
Inline Queue Manipulation Functions, 62
4.6 
Basic Functions To Extract A Process From A List, 63
4.7 
FIFO Queue Manipulation, 65
4.8 
Manipulation Of Priority Queues, 68
4.9 
List Initialization, 70
4.10 
Perspective, 71
4.11 
Summary, 72


4
List And Queue 
Manipulation
As some day it may happen that a victim must be
found, I’ve got a little list ....
— W. S. Gilbert
4.1 Introduction
Linked list processing is fundamental in operating systems, and pervades each 
component. Linked structures enable a system to manage sets of objects efficiently 
without searching or copying. As we will see, managing lists of processes is especially 
important.
This chapter introduces a set of functions that form the backbone of a linked list 
manipulation system. The functions represent a unified approach — a single data struc-
ture and a single set of nodes used by all levels of the operating system to maintain lists 
of processes. We will see that the data structure includes functions to create a new list, 
insert an item at the tail of a list, insert an item in an ordered list, remove the item at 
the head of a list, or remove an item from the middle of a list.†
The linked list functions are easy to understand because they assume that only one 
process executes a list function at a given time. Thus, a reader can think of the code as 
being part of a sequential program — there is no need to worry about interference from 
other processes executing concurrently. In addition, the example code introduces 
several programming conventions used throughout the text.
                                †Although linked list manipulation is usually covered in texts on data structures, the topic is included
here because the data structure is unusual and because it forms a key part of the system.
57

58 
List And Queue Manipulation 
Chap. 4
4.2 A Unified Structure For Linked Lists Of Processes
A process manager handles objects called processes. Although at any time a proc-
ess appears on only one list, a process manager moves a process from one list to anoth-
er frequently. In fact, a process manager does not store all details about a process on a
list. Instead, the process manager merely stores a process ID, a small, nonnegative in-
teger used to reference the process. Because it is convenient to think of placing a proc-
ess on a list, we will use the terms process and process ID interchangeably throughout 
the chapter.
An early version of Xinu had many lists of processes, each with its own data struc-
ture. Some consisted of first-in-first-out (FIFO) queues, and others were ordered by a
key. Some lists were singly linked; others needed to be doubly linked to permit items
to be inserted and deleted at arbitrary positions efficiently. After the requirements had 
been formulated, it became clear that centralizing the linked-list processing into a single 
data structure would reduce code size and eliminate many special cases. That is, in-
stead of six separate sets of linked list manipulation functions, a single set of functions 
was created to handle all situations.
To accommodate all cases, a representation was selected with the following proper-
ties:
d All lists are doubly linked, which means a node points to its prede-
cessor and successor.
d Each node stores a key as well as a process ID, even though a key
is not used in a FIFO list.
d Each list has head and tail nodes; the head and tail nodes have the
same memory layout as other nodes.
d Non-FIFO lists are ordered in descending order; the key in a head
node is greater than the maximum valid key value, and the key
value in the tail node is less than the minimum valid key.
Figure 4.1 illustrates the conceptual organization of a linked list data structure by
showing an example list with two items.
–
–
4
25
2
14
HEAD
TAIL
previous process key 
next
greater than maximum key 
less than minimum key
Figure 4.1 The conceptual organization of a doubly-linked list containing
processes 4 and 2 with keys 25 and 14, respectively.

Sec. 4.2        A Unified Structure For Linked Lists Of Processes 
59
As expected, the successor of the tail and the predecessor of the head are null.
When a list is empty, the successor of the head is the tail and the predecessor of the tail
is the head, as Figure 4.2 illustrates.
–
–
HEAD 
TAIL
greater than maximum key 
less than minimum key
Figure 4.2  The conceptual form of an empty linked list.
4.3 A Compact List Data Structure
One of the key design goals in an embedded system involves reducing the memory 
used. Instead of using a conventional implementation of a linked list, Xinu optimizes
the memory required in two ways:
d Relative pointers
d Implicit data structure
To understand the optimizations, it is important to know that most operating sys-
tems place a fixed upper bound on the number of processes in the system. In Xinu, 
constant NPROC specifies the number of processes, and process identifiers range from 0 
through NPROC – 1. In most embedded systems, NPROC is small (less than 100); we 
will see that a small limit makes each optimization work well.
Relative pointers. To understand the motivation for relative pointers, consider the 
space a conventional pointer occupies. On a 32-bit architecture, each pointer occupies 
four bytes. If the system contains fewer than 100 nodes, however, the size required can 
be reduced by placing nodes in contiguous memory locations and using a value between 
0 and 99 as a reference. That is, the nodes can be allocated in an array, and the array 
index can be used instead of a pointer.
Implicit data structure. The second optimization focuses on omitting the process
ID field from all nodes. Such an omission is feasible because:
A process appears on at most one list at any time.
To omit the process ID, use an array implementation and use the ith element of the array
for process ID i. Thus, to put process 3 on a particular linked list, insert node 3 onto
the list. Thus, the relative address of a node is the same as the ID of the process being 
stored.

60 
List And Queue Manipulation 
Chap. 4
Figure 4.3 illustrates how the linked list in Figure 4.1 can be represented in an ar-
ray that incorporates relative pointers and implicit identifiers. Each entry in an array
has three fields: a key, the index of the previous node, and the index of the next node.
The head of the list has index 60, and the tail has index 61.
..
.
..
.
..
.
KEY 
PREV 
NEXT
0 
1 
2 
3 
4 
5
60 
61
25
60
2
14
4
61
MAXKEY 
MINKEY
–
–
4
2
NPROC – 1
each row corresponds 
to a single process
pairs of rows form the 
head and tail of a list
Head of example list
Tail of example list
conceptual boundary
Figure 4.3  The list from Figure 4.1 stored in the queue table array.
Because a NEXT or PREV field contains a relative pointer (i.e., an array index), the
size of the field depends on the size of the array. For example, if the array contains
fewer than 256 items, a single byte can be used to store an index.
Xinu uses the term queue table to refer to the array. The key to understanding the 
structure is to observe that array elements with an index less than NPROC differ from 
elements with a higher index. Positions 0 through NPROC–1 each correspond to one 
process in the system; positions NPROC and higher are used to hold head and tail 
pointers for lists. Such a data structure is only feasible because the maximum number 
of processes and the maximum number of lists are each known at compile time and a 
process can only appear on one list at a given time.

Sec. 4.4        Implementation Of The Queue Data Structure 
61
4.4 Implementation Of The Queue Data Structure
To place process i on a list, the node with index i is linked into the list. A closer
look at the code will make the operations clear. In Xinu, the queue table pictured above
is named queuetab, and declared to be an array of qentry structures. File queue.h con-
tains the declarations of both queuetab and qentry:
//** qquueeuuee..hh -- ffiirrssttiidd,, ffiirrssttkkeeyy,, iisseemmppttyy,, llaassttkkeeyy,, nnoonneemmppttyy
**//
//** QQuueeuuee ssttrruuccttuurree ddeeccllaarraattiioonnss,, ccoonnssttaannttss,, aanndd iinnlliinnee ffuunnccttiioonnss
**//
//** DDeeffaauulltt ## ooff qquueeuuee eennttrriieess:: 11 ppeerr pprroocceessss pplluuss 22 ffoorr rreeaaddyy lliisstt pplluuss **//
//**
22 ffoorr sslleeeepp lliisstt pplluuss 22 ppeerr sseemmaapphhoorree
**//
##iiffnnddeeff NNQQEENNTT
##ddeeffiinnee NNQQEENNTT
((NNPPRROOCC ++ 44 ++ NNSSEEMM ++ NNSSEEMM))
##eennddiiff
##ddeeffiinnee EEMMPPTTYY
((--11))
//** NNuullll vvaalluuee ffoorr qqnneexxtt oorr qqpprreevv iinnddeexx
**//
##ddeeffiinnee MMAAXXKKEEYY
00xx77FFFFFFFFFFFFFF
//** MMaaxx kkeeyy tthhaatt ccaann bbee ssttoorreedd iinn qquueeuuee
**//
##ddeeffiinnee MMIINNKKEEYY
00xx8800000000000000
//** MMiinn kkeeyy tthhaatt ccaann bbee ssttoorreedd iinn qquueeuuee
**//
ssttrruucctt
qqeennttrryy
{{
//** OOnnee ppeerr pprroocceessss pplluuss ttwwoo ppeerr lliisstt
**//
iinntt3322
qqkkeeyy;;
//** KKeeyy oonn wwhhiicchh tthhee qquueeuuee iiss oorrddeerreedd
**//
qqiidd1166
qqnneexxtt;;
//** IInnddeexx ooff nneexxtt pprroocceessss oorr ttaaiill
**//
qqiidd1166
qqpprreevv;;
//** IInnddeexx ooff pprreevviioouuss pprroocceessss oorr hheeaadd
**//
}};;
eexxtteerrnn
ssttrruucctt qqeennttrryy
qquueeuueettaabb[[]];;
//** IInnlliinnee qquueeuuee mmaanniippuullaattiioonn ffuunnccttiioonnss **//
##ddeeffiinnee qquueeuueehheeaadd((qq))
((qq))
##ddeeffiinnee qquueeuueettaaiill((qq))
((((qq)) ++ 11))
##ddeeffiinnee ffiirrssttiidd((qq))
((qquueeuueettaabb[[qquueeuueehheeaadd((qq))]]..qqnneexxtt))
##ddeeffiinnee llaassttiidd((qq))
((qquueeuueettaabb[[qquueeuueettaaiill((qq))]]..qqpprreevv))
##ddeeffiinnee iisseemmppttyy((qq))
((ffiirrssttiidd((qq)) >>== NNPPRROOCC))
##ddeeffiinnee nnoonneemmppttyy((qq))
((ffiirrssttiidd((qq)) <<
NNPPRROOCC))
##ddeeffiinnee ffiirrssttkkeeyy((qq))
((qquueeuueettaabb[[ffiirrssttiidd((qq))]]..qqkkeeyy))
##ddeeffiinnee llaassttkkeeyy((qq))
((qquueeuueettaabb[[ llaassttiidd((qq))]]..qqkkeeyy))
//** IInnlliinnee ttoo cchheecckk qquueeuuee iidd aassssuummeess iinntteerrrruuppttss aarree ddiissaabblleedd **//
##ddeeffiinnee iissbbaaddqqiidd((xx))
((((((iinntt3322))((xx)) << 00)) |||| ((iinntt3322))((xx)) >>== NNQQEENNTT--11))

62 
List And Queue Manipulation 
Chap. 4
The queuetab array contains NQENT entries. As Figure 4.3 indicates, an important 
implicit boundary occurs between element NPROC–1 and element NPROC. Each ele-
ment below the boundary corresponds to a process ID, and elements queuetab[NPROC] 
through queuetab[NQENT] correspond to the heads or tails of lists.
File queue.h introduces several features of C and conventions used throughout the 
book. Because the name ends in .h, the file will be included in other programs (“h”
stands for header). Such files often contain the declarations for global data structures, 
symbolic constants, and inline functions (macros) that operate on the data structures. 
File queue.h defines queuetab to be an external variable (i.e., global), which means that 
every process will be able to access the array. The file also defines symbolic constants 
used with the data structure, such as constant EMPTY that is used to define an empty 
list.
Symbolic constant NQENT, which defines the total number of entries in the 
queuetab array, provides an example of conditional definition. The statement #ifndef 
NQENT means “compile the code down to the corresponding #endif, if and only if 
NQENT has not been defined previously.” Thus, the code in queue.h assigns a value to 
NQENT only if it has not been defined previously. The value assigned,
NPROC+4+NSEM+NSEM
allocates enough entries in queuetab for NPROC processes plus head and tail pointers 
for NSEM semaphore lists, a ready list, and a sleep list. Conditional compilation is 
used to permit the size of the queuetab array to be changed without modifying the .h 
file.
The contents of entries in the queuetab array are defined by structure qentry. The
file contains only a declaration of the elements in the queuetab array; Chapter 22 ex-
plains how data structures are initialized at system startup. Field qnext gives the rela-
tive address of the next node on a list, field qprev points to the previous node, and field 
qkey contains an integer key for the node. When a field, such as a forward or backward 
pointer, does not contain a valid index value, the field is assigned the value EMPTY.
4.5 Inline Queue Manipulation Functions
The functions isempty and nonempty are predicates (i.e., Boolean functions) that 
test whether a list is empty or not empty, given the index of its head as an argument. 
Isempty determines whether a list is empty by checking to see if the first node on the

Sec. 4.5        Inline Queue Manipulation Functions 
63
list is a process or the list tail; function nonempty makes the opposite test. To under-
stand the test, remember that the first NPROC entries in the queuetab array each
correspond to a process. All the other nodes are either a list head or tail. Therefore,
testing whether an item on a list is a process only requires comparing the item’s index 
to NPROC — the node is a process if its index is less than NPROC. The important 
point to note is that the test for an empty or nonempty queue are extremely efficient.
The other inline functions are also easy to understand. Function firstkey returns the
key of the first process on a list, and function lastkey returns the key of the last process
on a list. Function firstid returns the ID of the first process on a list. That is, the func-
tion returns the queuetab index of the first process on a list.
Usually, the queue functions are applied to nonempty lists. However, the imple-
mentation has a useful property: a list always has a head and tail, even if the list is emp-
ty. Thus, the functions described above can be applied to an empty list without causing 
a runtime error. For example, when firstkey is applied to an empty list, the function re-
turns the key of the node following the head, which will be the tail. Thus, the function 
will return the key from the tail, MINKEY. Similarly, extracting the ID of the first node 
in an empty list will never cause an array reference to be out-of-bounds because the tail 
node has a valid ID. Finally, extracting the first key of an empty list will never cause 
an error because the qkey field is always initialized, even in the head and tail nodes.
4.6 Basic Functions To Extract A Process From A List
Consider extracting a process from a list.† Recall that extracting an item from the 
head of a FIFO queue results in removing the item that has been in the queue the long-
est. For a priority queue, extracting from the head produces an item with highest priori-
ty. Similarly, extracting an item from the tail of the queue produces an item with 
lowest priority. As a result, we can construct three basic functions that are sufficient to 
handle extraction:
d  getfirst — extract the process at the head of a list
d  getlast — extract the process at the tail of a list
d getitem — extract a process at an arbitrary point
The code for the three basic functions can be found in file getitem.c.
                                †A later section considers inserting a process into a list.

64 
List And Queue Manipulation 
Chap. 4
//** ggeettiitteemm..cc -- ggeettffiirrsstt,, ggeettllaasstt,, ggeettiitteemm **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ggeettffiirrsstt
--
RReemmoovvee aa pprroocceessss ffrroomm tthhee ffrroonntt ooff aa qquueeuuee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ppiidd3322
ggeettffiirrsstt((
qqiidd1166
qq
//** IIDD ooff qquueeuuee ffrroomm wwhhiicchh ttoo
**//
))
//** RReemmoovvee aa pprroocceessss ((aassssuummeedd
**//
//**
vvaalliidd wwiitthh nnoo cchheecckk))
**//
{{
ppiidd3322
hheeaadd;;
iiff ((iisseemmppttyy((qq)))) {{
rreettuurrnn EEMMPPTTYY;;
}} 
hheeaadd == qquueeuueehheeaadd((qq));;
rreettuurrnn ggeettiitteemm((qquueeuueettaabb[[hheeaadd]]..qqnneexxtt));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ggeettllaasstt
--
RReemmoovvee aa pprroocceessss ffrroomm eenndd ooff qquueeuuee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ppiidd3322
ggeettllaasstt((
qqiidd1166
qq
//** IIDD ooff qquueeuuee ffrroomm wwhhiicchh ttoo
**//
))
//** RReemmoovvee aa pprroocceessss ((aassssuummeedd
**//
//**
vvaalliidd wwiitthh nnoo cchheecckk))
**//
{{
ppiidd3322 ttaaiill;;
iiff ((iisseemmppttyy((qq)))) {{
rreettuurrnn EEMMPPTTYY;;
}} 
ttaaiill == qquueeuueettaaiill((qq));;
rreettuurrnn ggeettiitteemm((qquueeuueettaabb[[ttaaiill]]..qqpprreevv));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ggeettiitteemm
--
RReemmoovvee aa pprroocceessss ffrroomm aann aarrbbiittrraarryy ppooiinntt iinn aa qquueeuuee
**------------------------------------------------------------------------------------------------------------------------------------------------

Sec. 4.6        Basic Functions To Extract A Process From A List 
65
**//
ppiidd3322
ggeettiitteemm((
ppiidd3322
ppiidd
//** IIDD ooff pprroocceessss ttoo rreemmoovvee
**//
))
{{
ppiidd3322
pprreevv,, nneexxtt;;
nneexxtt == qquueeuueettaabb[[ppiidd]]..qqnneexxtt;;
//** FFoolllloowwiinngg nnooddee iinn lliisstt
**//
pprreevv == qquueeuueettaabb[[ppiidd]]..qqpprreevv;;
//** PPrreevviioouuss nnooddee iinn lliisstt
**//
qquueeuueettaabb[[pprreevv]]..qqnneexxtt == nneexxtt;;
qquueeuueettaabb[[nneexxtt]]..qqpprreevv == pprreevv;;
rreettuurrnn ppiidd;;
}}
Getfirst takes a queue ID as an argument, verifies that the argument identifies a 
nonempty list, finds the process at the head of the list, and calls getitem to extract the 
process from the list. Similarly, getlast takes a queue ID as an argument, checks the ar-
gument, finds the process at the tail of the list, and calls getitem to extract the process. 
Each of the two functions returns the ID of the process that has been extracted.
Getitem takes a process ID as an argument, and extracts the process from the list in 
which the process is currently linked. Extraction consists of making the previous node 
point to the successor and the successor point to the previous node. Once a process has 
been unlinked from a list, getitem returns the process ID as the value of the function.
4.7 FIFO Queue Manipulation
We will see that many of the lists a process manager maintains consist of a First-
In-First-Out (FIFO) queue. That is, a new item is inserted at the tail of the list, and an
item is always removed from the head of the list. For example, a scheduler can use a
FIFO queue to implement round-robin scheduling by placing the current process on the 
tail of a list and switching to the process on the head of the list.
Functions enqueue and dequeue, found in file queue.c, implement FIFO operations 
on a list. Because each list has both a head and tail, both insertion and extraction are 
efficient. For example, enqueue inserts a process just prior to the tail of a list, and de-
queue extracts an item just after the head of the list. Dequeue takes a single argument 
that gives the ID of the list to use. Enqueue takes two arguments: the ID of the process 
to be inserted and the ID of a list on which to insert it.

66 
List And Queue Manipulation 
Chap. 4
//** qquueeuuee..cc -- eennqquueeuuee,, ddeeqquueeuuee **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt qqeennttrryy
qquueeuueettaabb[[NNQQEENNTT]];;
//** TTaabbllee ooff pprroocceessss qquueeuueess
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
eennqquueeuuee
--
IInnsseerrtt aa pprroocceessss aatt tthhee ttaaiill ooff aa qquueeuuee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ppiidd3322
eennqquueeuuee((
ppiidd3322
ppiidd,,
//** IIDD ooff pprroocceessss ttoo iinnsseerrtt
**//
qqiidd1166
qq
//** IIDD ooff qquueeuuee ttoo uussee
**//
))
{{
qqiidd1166
ttaaiill,, pprreevv;;
//** TTaaiill && pprreevviioouuss nnooddee iinnddeexxeess **//
iiff ((iissbbaaddqqiidd((qq)) |||| iissbbaaddppiidd((ppiidd)))) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
ttaaiill == qquueeuueettaaiill((qq));;
pprreevv == qquueeuueettaabb[[ttaaiill]]..qqpprreevv;;
qquueeuueettaabb[[ppiidd]]..qqnneexxtt
== ttaaiill;;
//** IInnsseerrtt jjuusstt bbeeffoorree ttaaiill nnooddee **//
qquueeuueettaabb[[ppiidd]]..qqpprreevv
== pprreevv;;
qquueeuueettaabb[[pprreevv]]..qqnneexxtt == ppiidd;;
qquueeuueettaabb[[ttaaiill]]..qqpprreevv == ppiidd;;
rreettuurrnn ppiidd;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ddeeqquueeuuee
--
RReemmoovvee aanndd rreettuurrnn tthhee ffiirrsstt pprroocceessss oonn aa lliisstt
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ppiidd3322
ddeeqquueeuuee((
qqiidd1166
qq
//** IIDD qquueeuuee ttoo uussee
**//
))
{{
ppiidd3322
ppiidd;;
//** IIDD ooff pprroocceessss rreemmoovveedd
**//
iiff ((iissbbaaddqqiidd((qq)))) {{
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((iisseemmppttyy((qq)))) {{
rreettuurrnn EEMMPPTTYY;;
}}

Sec. 4.7        FIFO Queue Manipulation 
67
ppiidd == ggeettffiirrsstt((qq));;
qquueeuueettaabb[[ppiidd]]..qqpprreevv == EEMMPPTTYY;;
qquueeuueettaabb[[ppiidd]]..qqnneexxtt == EEMMPPTTYY;;
rreettuurrnn ppiidd;;
}}
Function enqueue calls isbadpid to check whether its argument is a valid process
ID. The next chapter shows that isbadpid consists of an inline function that checks
whether the ID is in the correct range and that a process with that ID exists.
File queue.c includes xinu.h, which includes the complete set of Xinu include files:
//** xxiinnuu..hh -- iinncclluuddee aallll ssyysstteemm hheeaaddeerr ffiilleess **//
##iinncclluuddee <<kkeerrnneell..hh>>
##iinncclluuddee <<ccoonnff..hh>>
##iinncclluuddee <<pprroocceessss..hh>>
##iinncclluuddee <<qquueeuuee..hh>>
##iinncclluuddee <<rreesscchheedd..hh>>
##iinncclluuddee <<mmaarrkk..hh>>
##iinncclluuddee <<sseemmaapphhoorree..hh>>
##iinncclluuddee <<mmeemmoorryy..hh>>
##iinncclluuddee <<bbuuffppooooll..hh>>
##iinncclluuddee <<cclloocckk..hh>>
##iinncclluuddee <<ppoorrttss..hh>>
##iinncclluuddee <<uuaarrtt..hh>>
##iinncclluuddee <<ttttyy..hh>>
##iinncclluuddee <<ddeevviiccee..hh>>
##iinncclluuddee <<iinntteerrrruupptt..hh>>
##iinncclluuddee <<ffiillee..hh>>
##iinncclluuddee <<rrffiilleessyyss..hh>>
##iinncclluuddee <<rrddiisskkssyyss..hh>>
##iinncclluuddee <<llffiilleessyyss..hh>>
##iinncclluuddee <<eetthheerr..hh>>
##iinncclluuddee <<nneett..hh>>
##iinncclluuddee <<iipp..hh>>
##iinncclluuddee <<aarrpp..hh>>
##iinncclluuddee <<uuddpp..hh>>
##iinncclluuddee <<ddhhccpp..hh>>
##iinncclluuddee <<iiccmmpp..hh>>
##iinncclluuddee <<ttffttpp..hh>>
##iinncclluuddee <<nnaammee..hh>>
##iinncclluuddee <<sshheellll..hh>>

68 
List And Queue Manipulation 
Chap. 4
##iinncclluuddee <<ddaattee..hh>>
##iinncclluuddee <<pprroottoottyyppeess..hh>>
##iinncclluuddee <<ddeellaayy..hh>>
##iinncclluuddee <<ppccii..hh>>
##iinncclluuddee <<qquuaarrkk__eetthh..hh>>
##iinncclluuddee <<qquuaarrkk__ppddaatt..hh>>
##iinncclluuddee <<qquuaarrkk__iirrqq..hh>>
##iinncclluuddee <<mmuullttiibboooott..hh>>
##iinncclluuddee <<ssttddiioo..hh>>
##iinncclluuddee <<ssttrriinngg..hh>>
Combining the set of header files into a single include file helps programmers be-
cause it ensures that all pertinent definitions are available and guarantees that the set of 
include files are processed in a valid sequence. Later chapters consider the contents of 
each include file.
4.8 Manipulation Of Priority Queues
A process manager often needs to select from a set of processes the process that
has highest priority. Consequently, the linked list routines must be able to maintain
lists of processes that each have an associated priority. In our example system, a priori-
ty is an integer value assigned to the process. In general, the task of examining a proc-
ess with highest priority is performed frequently compared with the tasks of inserting
and deleting processes. Thus, a data structure used to manage lists of processes should
be designed to make finding the highest priority process efficient compared to insertion
or deletion.
A variety of data structures has been devised to store a set of items that can be 
selected in priority order. Any such data structure is known generically as a priority
queue. Our example system uses a linear list to store a priority queue where the priority 
of a process serves as a key in the list. Because the list is ordered in descending order 
by key, the highest priority process can always be found at the head of the list. Thus, 
finding the highest priority process takes constant time. Insertion is more expensive be-
cause the list must be searched to determine the location at which a new item should be 
inserted.
In a small embedded system where one only expects two or three processes to be
on a given priority queue at any time, a linear list suffices. For a large system where
many items appear in a given priority queue or where the number of insertions is high 
compared to the number of times items are extracted, a linear list can be inefficient. An 
exercise considers the point further.
Deletion from an ordered list is trivial: the first node is removed from the list. 
When an item is inserted, list order must be maintained.  Insert, which is shown below, 
inserts a process on a list ordered by priority. The function takes three arguments: the 
ID of a process to be inserted, the ID of a queue on which to insert the process, and an

Sec. 4.8        Manipulation Of Priority Queues 
69
integer priority for the process. Insert uses the qkey field in queuetab to store the
process’s priority. To find the correct location in the list, insert searches for an existing 
element with a key less than the key of the element being inserted. During the search, 
integer curr moves along the list. The loop must eventually terminate because the key 
of the tail element contains a value less than the smallest valid key. Once the correct 
location has been found, insert changes the necessary pointers to link the new node into 
the list.
//** iinnsseerrtt..cc -- iinnsseerrtt **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
iinnsseerrtt
--
IInnsseerrtt aa pprroocceessss iinnttoo aa qquueeuuee iinn ddeesscceennddiinngg kkeeyy oorrddeerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
iinnsseerrtt((
ppiidd3322
ppiidd,,
//** IIDD ooff pprroocceessss ttoo iinnsseerrtt
**//
qqiidd1166
qq,,
//** IIDD ooff qquueeuuee ttoo uussee
**//
iinntt3322
kkeeyy
//** KKeeyy ffoorr tthhee iinnsseerrtteedd pprroocceessss **//
))
{{
iinntt1166
ccuurrrr;;
//** RRuunnss tthhrroouugghh iitteemmss iinn aa qquueeuuee**//
iinntt1166
pprreevv;;
//** HHoollddss pprreevviioouuss nnooddee iinnddeexx
**//
iiff ((iissbbaaddqqiidd((qq)) |||| iissbbaaddppiidd((ppiidd)))) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
ccuurrrr == ffiirrssttiidd((qq));;
wwhhiillee ((qquueeuueettaabb[[ccuurrrr]]..qqkkeeyy >>== kkeeyy)) {{
ccuurrrr == qquueeuueettaabb[[ccuurrrr]]..qqnneexxtt;;
}} 
//** IInnsseerrtt pprroocceessss bbeettwweeeenn ccuurrrr nnooddee aanndd pprreevviioouuss nnooddee **//
pprreevv == qquueeuueettaabb[[ccuurrrr]]..qqpprreevv;;
//** GGeett iinnddeexx ooff pprreevviioouuss nnooddee
**//
qquueeuueettaabb[[ppiidd]]..qqnneexxtt == ccuurrrr;;
qquueeuueettaabb[[ppiidd]]..qqpprreevv == pprreevv;;
qquueeuueettaabb[[ppiidd]]..qqkkeeyy == kkeeyy;;
qquueeuueettaabb[[pprreevv]]..qqnneexxtt == ppiidd;;
qquueeuueettaabb[[ccuurrrr]]..qqpprreevv == ppiidd;;
rreettuurrnn OOKK;;
}}

70 
List And Queue Manipulation 
Chap. 4
4.9 List Initialization
The functions described above all assume that although it may be empty, a given 
queue has been initialized. We now consider the code that creates an empty list. It is 
appropriate that the code to create an empty list occurs at the end of the chapter because 
it brings up an important point about the design process:
Initialization is the final step in design.
It may seem strange to defer initialization because a designer cannot postpone 
thinking about initialization altogether. However, the general paradigm can be stated as 
follows: first, design the data structures needed when the system is running, and then 
figure out how to initialize the data structures. Partitioning the “steady state” aspect of 
the system from the “transient state” helps focus the designer’s attention on the most 
important aspect, and avoids the temptation of sacrificing good design for easy initiali-
zation.
Initialization of entries in the queuetab structure is performed on demand as entries
are needed. A running process calls function newqueue to create a new list. The sys-
tem maintains a global pointer to the next unallocated element of queuetab, which
makes it easy to allocate the list.
In theory, the head and tail of a list could be allocated from any of the unused en-
tries in queuetab. In practice, however, choosing arbitrary locations would require a
caller to store two items: the indices of the head and tail. To optimize storage, we make 
the rule that:
The head and tail nodes for a list, X, are allocated from successive 
locations in the queuetab array, and list X is identified by the index of 
the head.
In the code, newqueue allocates a pair of adjacent positions in the queuetab array
to use as head and tail nodes, and initializes the list to empty by pointing the successor
of the head to the tail and the predecessor of the tail to the head.  Newqueue assigns the 
value EMPTY to unused pointers (i.e., the successor of the tail and the predecessor of 
the head). When it initializes a list, newqueue also sets the key fields in the head and 
the tail to the maximum and minimum integer values, respectively, with the assumption 
that neither value will be used as a key. Only one allocation function is needed because 
a list can be used to implement a FIFO queue or a priority queue.
Once it finishes with initialization, newqueue returns the index of the list head to 
its caller. The caller only needs to store one value because the ID of the tail can be 
computed by adding 1 to the ID of the head.

Sec. 4.9        List Initialization 
71
//** nneewwqquueeuuee..cc -- nneewwqquueeuuee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
nneewwqquueeuuee
--
AAllllooccaattee aanndd iinniittiiaalliizzee aa qquueeuuee iinn tthhee gglloobbaall qquueeuuee ttaabbllee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
qqiidd1166
nneewwqquueeuuee((vvooiidd))
{{
ssttaattiicc qqiidd1166
nneexxttqqiidd==NNPPRROOCC;;
//** NNeexxtt lliisstt iinn qquueeuueettaabb ttoo uussee **//
qqiidd1166
qq;;
//** IIDD ooff aallllooccaatteedd qquueeuuee
**//
qq == nneexxttqqiidd;;
iiff ((qq >> NNQQEENNTT)) {{
//** CChheecckk ffoorr ttaabbllee oovveerrffllooww
**//
rreettuurrnn SSYYSSEERRRR;;
}} 
nneexxttqqiidd ++== 22;;
//** IInnccrreemmeenntt iinnddeexx ffoorr nneexxtt ccaallll**//
//** IInniittiiaalliizzee hheeaadd aanndd ttaaiill nnooddeess ttoo ffoorrmm aann eemmppttyy qquueeuuee **//
qquueeuueettaabb[[qquueeuueehheeaadd((qq))]]..qqnneexxtt == qquueeuueettaaiill((qq));;
qquueeuueettaabb[[qquueeuueehheeaadd((qq))]]..qqpprreevv == EEMMPPTTYY;;
qquueeuueettaabb[[qquueeuueehheeaadd((qq))]]..qqkkeeyy
== MMAAXXKKEEYY;;
qquueeuueettaabb[[qquueeuueettaaiill((qq))]]..qqnneexxtt == EEMMPPTTYY;;
qquueeuueettaabb[[qquueeuueettaaiill((qq))]]..qqpprreevv == qquueeuueehheeaadd((qq));;
qquueeuueettaabb[[qquueeuueettaaiill((qq))]]..qqkkeeyy
== MMIINNKKEEYY;;
rreettuurrnn qq;;
}}
4.10 Perspective
Using a single data structure for process lists makes it possible to create general-
purpose linked list manipulation functions, which reduce the size of the code by avoid-
ing duplication. Using an implicit data structure with relative pointers reduces the 
memory used. For small embedded systems, compacting code and data is necessary. 
What about systems that have plenty of memory? Interestingly, a general principle ap-
plies: unless care is taken, successive generations of software expand to fill whatever 
memory is available. Thus, thinking carefully about a design is always important: there 
are never sufficient resources to justify wasteful inefficiency.

72 
List And Queue Manipulation 
Chap. 4
4.11 Summary
The chapter describes a set of linked-list functions used to store processes. In our 
example system, linked lists of processes are kept in a single, uniform data structure, 
the queuetab array. Functions that manipulate lists of processes can produce FIFO 
queues or priority queues. All lists have the same form: they are doubly linked, each 
has both a head and tail, and each node has an integer key field. Keys are used when 
the list is a priority queue; keys are ignored if the list is a FIFO queue.
The implementation uses a single array for all list elements — an entry in the array 
either corresponds to a process or to a list head or tail. To reduce the size required, the 
Xinu implementation uses relative pointers and an implicit data structure. In addition, 
the head and tail of a list are allocated sequentially, allowing a single relative pointer to 
identify both the head and tail.
EXERCISES
4.1 
In what sense is the queue structure described here an implicit data structure?
4.2 
If priority values range from –8 to +8, how many bits are required to store each key in
queuetab?
4.3 
Create a separate set of functions that allows one to create a singly-linked list, and insert
items in either FIFO or priority order. By how much does the second set of routines in-
crease memory usage? Does having a separate set of routines decrease processor usage? 
Explain.
4.4  Does insert work correctly for all possible key values? If not, for which key(s) does it fail?
4.5   Implement functions to manipulate lists using pointers instead of indices into an array of
structures. What is the difference in memory space and processor time?
4.6 
Compare the complexity of functions like isempty implemented with pointers and with ar-
ray indexing.
4.7 
Larger systems sometimes use a data structure known as a heap to contain a priority queue.
What is a heap? Will its use be more or less expensive than an ordered, doubly linked list 
when the list size is between 1 and 3?
4.8 
Functions getfirst, getlast, and getitem do not check whether their argument is a valid queue
ID. Modify the code to insert the appropriate checks.
4.9 
The code generated to convert a subscript into a memory address may use multiplication.
Try padding the size of a qentry to a power of two bytes, and examine the resulting code to
see if the compiler uses a shift instead of multiplication.
4.10 In the previous exercise, measure a series of insertions and deletions to determine the
difference in speed between the padded and unpadded versions of the data structure.
4.11  If a structure contains data items that are not multiples of four bytes on an architecture with
strict word alignment (e.g., some RISC architectures), the code a compiler generates to ac-
cess a structure member may include masking and shifting. Try altering the fields of qen-
try so that members are aligned on machine word boundaries, and examine the impact on 
the size of the queue table and the resulting code for accessing members.

Chapter Contents
5.1 
Introduction, 75
5.2 
The Process Table, 76
5.3 
Process States, 79
5.4 
Ready And Current States, 80
5.5 
A Scheduling Policy, 80
5.6 
Implementation Of Scheduling, 81
5.7 
Deferred Rescheduling, 85
5.8 
Implementation Of Context Switching, 85
5.9 
State Saved In Memory, 86
5.10 
Context Switch Operation, 87
5.11 
An Address At Which To Restart A Process, 91
5.12 
Concurrent Execution And A Null Process, 92
5.13 
Making A Process Ready And The Scheduling Invariant, 93
5.14 
Other Process Scheduling Algorithms, 94
5.15 
Perspective, 95
5.16 
Summary, 95


5
Scheduling And Context 
Switching
What is called a sincere work is one that is endowed 
with enough strength to give reality to an illusion.
— Max Jacob
5.1 Introduction
An operating system achieves the illusion of concurrent execution by rapidly 
switching a processor among several computations. Because the speed of the computa-
tion is extremely fast compared to that of a human, the effect is impressive — multiple 
activities appear to proceed simultaneously.
Context switching, which lies at the heart of the juggling act, consists of stopping 
the current process, saving enough information so it may be restarted later, and starting 
another process. What makes such a change difficult is that the processor cannot be 
stopped during a context switch — the processor must continue to execute the code 
that switches to a new process.
This chapter describes the basic context switching mechanism, showing how an 
operating system saves the state information from one process, chooses another process 
to run from among those that are ready, and relinquishes control to the new process.
The chapter describes the data structure that holds information about processes that are 
not currently executing, and explains how the context switch uses the data structure. 
For the present, we will ignore the questions of when and why processes choose to 
switch context. Later chapters answer the questions, showing how higher levels of the 
operating system use the context switch described here.
75

76 
Scheduling And Context Switching 
Chap. 5
5.2 The Process Table
An operating system keeps all information about processes in a data structure 
known as a process table. A process table contains one entry for each process that 
currently exists. We will see that a new entry must be allocated each time a process is 
created and an entry is removed when a process terminates. Because exactly one proc-
ess is executing at any time, exactly one of the entries in a process table corresponds to 
an active process — the saved state information in the process table is out of date for 
the executing process. Each of the other process table entries contains information 
about a process that has been stopped temporarily. To switch context, the operating 
system saves information about the currently running process in its process table entry, 
and restores information from the process table entry corresponding to the process it is 
about to execute.
Exactly what information must be saved in the process table? The system must 
save any values that will be destroyed when the new process runs. Consider the stack. 
Because each process has its own separate stack memory, a copy of the entire stack 
need not be saved. However, when it executes, a process will change the hardware 
stack pointer register. Therefore, the contents of the stack pointer register must be 
saved when a process temporarily stops executing, and must be restored when the proc-
ess resumes execution. Similarly, copies of other general-purpose registers must be 
saved and restored. In addition to values from the hardware, an operating system keeps 
meta-information in the process table. We will see how operating system functions use 
the meta-information for resource accounting, error prevention, and other administrative 
tasks. For example, the process table on a multi-user system stores the user ID of the 
user who owns the process. Similarly, if the operating system places policy limits on 
the memory that a process can allocate, the limit might be placed in the process table. 
The details of items in the process table will become clear in later chapters as we exam-
ine operating system functions that operate on processes.
Like most operating systems, our example system places a fixed upper bound on 
the maximum number of active processes. In the code, constant NPROC specifies the 
bound; the process table, proctab, consists of an array with NPROC entries. Each entry 
in proctab consists of a procent structure that defines the information kept for a process. 
Figure 5.1 lists key items found in a process table entry.
Throughout the operating system, each process is identified by an integer process
ID. The following rule gives the relationship between process IDs and the process
table:
A process is referenced by its process ID, which is the index of the 
proctab entry that contains the process’s saved state information.

Sec. 5.2        The Process Table 
77
                                                            Field 
Purpose
                                                            prstate 
The current status of the process (e.g., whether
the process is currently executing or waiting)
                                                            prprio 
The scheduling priority of the process
                                                            prstkptr 
The saved value of the process’s stack pointer
when the process is not executing 
                                                            prstkbase 
The address of the highest memory location in
the memory region used as the process’s stack
                                                            prstklen 
A limit on the maximum size that the process’s
stack can grow
                                                            prname 
A name assigned to the process that humans
use to identify the process’s purpose
                                                            
























































Figure 5.1  Key items found in the Xinu process table.
As an example of using a process ID, consider how the code finds information
about a process. The state information for a process with ID 3 can be found in proc-
tab[3], and the state information for a process with ID 5 can be found in proctab[5].
Using the array index as an ID makes locating information efficient. Of course, using
an array index has a disadvantage: once a process terminates, the process ID will be 
reused the next time the array entry is used. We will see that the implementation tries 
to maximize the time between reuse of an ID. An alternative, used in some operating 
systems, allocates process IDs from a much larger set. Doing so has the advantage of 
not reusing IDs as frequently, but the disadvantage of requiring a mapping between an 
ID and a process table slot. One of the exercises suggests an alternative that combines 
the advantages of both approaches.
Each entry in proctab is defined to be a struct of type procent. The declaration of 
struct procent can be found in file process.h along with other declarations related to 
processes. Some fields in the process table contain information that the operating sys-
tem needs to manage the process (e.g., the information needed to free the process’s 
stack memory when the process completes). Other fields are used only for debugging. 
For example, field prname contains a character string that identifies the process; the 
field is not used except when a human tries to debug a problem or understand the 
current set of processes and to which computation each corresponds.

78 
Scheduling And Context Switching 
Chap. 5
//** pprroocceessss..hh -- iissbbaaddppiidd **//
//** MMaaxxiimmuumm nnuummbbeerr ooff pprroocceesssseess iinn tthhee ssyysstteemm **//
##iiffnnddeeff NNPPRROOCC
##ddeeffiinnee NNPPRROOCC
88
##eennddiiff
//** PPrroocceessss ssttaattee ccoonnssttaannttss **//
##ddeeffiinnee PPRR__FFRREEEE
00
//** PPrroocceessss ttaabbllee eennttrryy iiss uunnuusseedd
**//
##ddeeffiinnee PPRR__CCUURRRR
11
//** PPrroocceessss iiss ccuurrrreennttllyy rruunnnniinngg
**//
##ddeeffiinnee PPRR__RREEAADDYY
22
//** PPrroocceessss iiss oonn rreeaaddyy qquueeuuee
**//
##ddeeffiinnee PPRR__RREECCVV
33
//** PPrroocceessss wwaaiittiinngg ffoorr mmeessssaaggee
**//
##ddeeffiinnee PPRR__SSLLEEEEPP
44
//** PPrroocceessss iiss sslleeeeppiinngg
**//
##ddeeffiinnee PPRR__SSUUSSPP
55
//** PPrroocceessss iiss ssuussppeennddeedd
**//
##ddeeffiinnee PPRR__WWAAIITT
66
//** PPrroocceessss iiss oonn sseemmaapphhoorree qquueeuuee
**//
##ddeeffiinnee PPRR__RREECCTTIIMM
77
//** PPrroocceessss iiss rreecceeiivviinngg wwiitthh ttiimmeeoouutt
**//
//** MMiisscceellllaanneeoouuss pprroocceessss ddeeffiinniittiioonnss **//
##ddeeffiinnee PPNNMMLLEENN
1166
//** LLeennggtthh ooff pprroocceessss ""nnaammee""
**//
##ddeeffiinnee NNUULLLLPPRROOCC
00
//** IIDD ooff tthhee nnuullll pprroocceessss
**//
//** PPrroocceessss iinniittiiaalliizzaattiioonn ccoonnssttaannttss **//
##ddeeffiinnee IINNIITTSSTTKK
6655553366
//** IInniittiiaall pprroocceessss ssttaacckk ssiizzee
**//
##ddeeffiinnee IINNIITTPPRRIIOO
2200
//** IInniittiiaall pprroocceessss pprriioorriittyy
**//
##ddeeffiinnee IINNIITTRREETT
uusseerrrreett //** AAddddrreessss ttoo wwhhiicchh pprroocceessss rreettuurrnnss
**//
//** IInnlliinnee ccooddee ttoo cchheecckk pprroocceessss IIDD ((aassssuummeess iinntteerrrruuppttss aarree ddiissaabblleedd))
**//
##ddeeffiinnee iissbbaaddppiidd((xx))
(( ((((ppiidd3322))((xx)) << 00)) |||| \\
((((ppiidd3322))((xx)) >>== NNPPRROOCC)) |||| \\
((pprrooccttaabb[[((xx))]]..pprrssttaattee ==== PPRR__FFRREEEE))))
//** NNuummbbeerr ooff ddeevviiccee ddeessccrriippttoorrss aa pprroocceessss ccaann hhaavvee ooppeenn **//
##ddeeffiinnee NNDDEESSCC
55
//** mmuusstt bbee oodddd ttoo mmaakkee pprroocceenntt 44NN bbyytteess **//
//** DDeeffiinniittiioonn ooff tthhee pprroocceessss ttaabbllee ((mmuullttiippllee ooff 3322 bbiittss)) **//
ssttrruucctt pprroocceenntt {{
//** EEnnttrryy iinn tthhee pprroocceessss ttaabbllee
**//
uuiinntt1166
pprrssttaattee;;
//** PPrroocceessss ssttaattee:: PPRR__CCUURRRR,, eettcc..
**//
pprrii1166
pprrpprriioo;;
//** PPrroocceessss pprriioorriittyy
**//

Sec. 5.2        The Process Table 
79
cchhaarr
**pprrssttkkppttrr;;
//** SSaavveedd ssttaacckk ppooiinntteerr
**//
cchhaarr
**pprrssttkkbbaassee;;
//** BBaassee ooff rruunn ttiimmee ssttaacckk
**//
uuiinntt3322
pprrssttkklleenn;;
//** SSttaacckk lleennggtthh iinn bbyytteess
**//
cchhaarr
pprrnnaammee[[PPNNMMLLEENN]];; //** PPrroocceessss nnaammee
**//
ssiidd3322
pprrsseemm;;
//** SSeemmaapphhoorree oonn wwhhiicchh pprroocceessss wwaaiittss
**//
ppiidd3322
pprrppaarreenntt;;
//** IIDD ooff tthhee ccrreeaattiinngg pprroocceessss
**//
uummssgg3322
pprrmmssgg;;
//** MMeessssaaggee sseenntt ttoo tthhiiss pprroocceessss
**//
bbooooll88
pprrhhaassmmssgg;;
//** NNoonnzzeerroo iiffff mmssgg iiss vvaalliidd
**//
iinntt1166
pprrddeesscc[[NNDDEESSCC]];;
//** DDeevviiccee ddeessccrriippttoorrss ffoorr pprroocceessss
**//
}};;
//** MMaarrkkeerr ffoorr tthhee ttoopp ooff aa pprroocceessss ssttaacckk ((uusseedd ttoo hheellpp ddeetteecctt oovveerrffllooww)) **//
##ddeeffiinnee SSTTAACCKKMMAAGGIICC
00xx00AA00AAAAAAAA99
eexxtteerrnn
ssttrruucctt
pprroocceenntt pprrooccttaabb[[]];;
eexxtteerrnn
iinntt3322
pprrccoouunntt;;
//** CCuurrrreennttllyy aaccttiivvee pprroocceesssseess
**//
eexxtteerrnn
ppiidd3322
ccuurrrrppiidd;;
//** CCuurrrreennttllyy eexxeeccuuttiinngg pprroocceessss
**//
5.3 Process States
To record exactly what each process is doing and to validate operations performed
on the process, each process is assigned a state. An operating system designer defines
the set of possible states as the design proceeds. Because many of the system functions 
that operate on processes use the state to determine whether an operation is valid, the 
set of states must be completely defined before the system can be implemented.
Xinu uses field prstate in the process table to record state information for each 
process. The system defines seven valid states and a symbolic constant for each. The 
system also defines an additional constant that is assigned when a given table entry is 
unused (i.e., no process has been created to use that particular entry). File process.h 
contains the definitions; Figure 5.2 lists the symbolic state constants and the meaning of 
each.
Because it runs as an embedded system, Xinu keeps the code and data for all 
processes in memory at all times. In larger operating systems, where a process executes 
an application program, the system can move a process to secondary storage when the 
process is not currently executing. Thus, in those systems, the process state also deter-
mines whether the process must reside in memory or can be moved to disk temporarily.

80 
Scheduling And Context Switching 
Chap. 5
                                                       Constant 
Meaning
                                                       PR_FREE 
The entry in the process table is unused
(not really a process state)
                                                       PR_CURR 
The process is currently executing
                                                       PR_READY 
The process is ready to execute
                                                       PR_RECV 
The process is waiting for a message
                                                       PR_SLEEP 
The process is waiting for a timer
                                                       PR_SUSP 
The process is suspended
                                                       PR_WAIT 
The process is waiting on a semaphore
                                                       PR_RECTIM 
The process is waiting for a timer
or a message, whichever occurs first
                                                       



























































Figure 5.2 The seven symbolic constants that can be assigned to the state of
a process.
5.4 Ready And Current States
Later chapters will explain each process state in detail, and show how and why 
system functions change a process’s state. The remainder of this chapter focuses on the 
current and ready states.
Almost every operating system includes ready and current process states. A proc-
ess is classified ready if the process is ready (i.e., eligible) to execute, but is not
currently executing; at any time, the single process executing is classified as current.†
5.5 A Scheduling Policy
Switching from the currently executing process to another process consists of two 
steps: selecting a process from among those that are eligible to use the processor, and 
giving control of the processor to the selected process. Software that implements the 
policy for selecting a process is called a scheduler. In Xinu, function resched makes 
the selection according to the following well-known scheduling policy:
At any time, the highest priority eligible process is executing. Among 
processes with equal priority scheduling is round-robin.

†Recall that our initial discussions are focused on a single-core processor.

Sec. 5.5        A Scheduling Policy 
81
Two aspects of the policy deserve attention:
d The currently executing process is included in the set of eligible
processes. Thus, if process p is currently executing and has a
higher priority than any of the other processes, process p will con-
tinue to execute.
d The term round-robin refers to a situation in which a set of k
processes all have the same priority and the priority of processes in 
the set is higher than the priority of other processes. The round-
robin policy means that members of the set will receive service one 
after another so all members of the set have an opportunity to exe-
cute before any member has a second opportunity.
5.6 Implementation Of Scheduling
The key to understanding a scheduler lies in knowing that a scheduler is merely a 
function. That is, the operating system scheduler is not an active agent that picks up the 
processor from one process and moves it to another. Instead, a running process invokes 
the scheduler:†
A scheduler consists of a function that a running process calls to will-
ingly give up the processor.
Recall that a process priority consists of a positive integer, and the priority for a 
given process is stored in the prprio field of the process’s entry in the process table. A
user assigns a priority to each process to control how the process will be selected for 
execution. A variety of complex scheduling policies have been proposed and measured, 
including schedulers that adjust the priority of processes dynamically, based on the ob-
served behavior of each process. For most embedded systems, process priorities remain 
relatively static (typically, the priority does not change after a process has been created).
To make the selection of a new process fast, our example system stores all ready 
processes on a list known as a ready list. Processes on a ready list are stored in des-
cending order by priority. Thus, a highest priority process is immediately accessible at 
the head of the list.
In the example code, the ready list is stored in the queuetab array described in
Chapter 4, and the scheduler uses functions from Chapter 4 to update and access the
list. That is, the key in each element on the ready list consists of the priority for the 
process to which the element corresponds. Global variable readylist contains the queue 
ID of the ready list.
Should an operating system keep the current process on the ready list? The answer 
depends on details of the implementation. Either possibility is feasible provided an en-
tire system follows one approach or the other. Xinu implements the following policy:

†Later chapters explain how and why a process invokes the scheduler.

82 
Scheduling And Context Switching 
Chap. 5
The current process does not appear on the ready list; to provide fast 
access to the current process, its ID is stored in global integer vari-
able currpid.
Consider what happens when the processor switches from one process to another. 
The currently executing process relinquishes the processor. Often, the process that was 
executing remains eligible to use the processor again. In such situations, the scheduler 
must change the state of the current process to PR_READY and insert the process onto 
the ready list, ensuring that it will be considered for service again later. In other cases, 
however, the current process does not remain ready to execute, which means the process 
should not be placed on the ready list.
How does the scheduler decide whether to move the current process onto the ready 
list? In Xinu, the scheduler does not receive an explicit argument that specifies the 
disposition of the current process. Instead, the system functions use an implicit argu-
ment: if the current process should not remain ready, before calling resched, the current 
process’s prstate field must be set to the desired next state. Whenever it prepares to 
switch to a new process, resched checks the prstate field of the current process. If the 
state still specifies PR_CURR, resched assumes the process should remain ready, and 
moves the process to the ready list. Otherwise, resched assumes the next state has al-
ready been chosen. The next chapter shows an example.
In addition to moving the current process to the ready list, resched completes every 
detail of scheduling and context switching except saving and restoring machine registers 
(which cannot be done directly in a high-level language like C).  Resched selects a new 
process to run, updates the process table entry for the new process, removes the new 
process from the ready list, marks it current, and updates currpid. It also resets the 
preemption counter, something we will consider later. Finally, resched calls function 
ctxsw to save the hardware registers of the current process and restore the registers for 
the new process. The code can be found in file resched.c:
//** rreesscchheedd..cc -- rreesscchheedd,, rreesscchheedd__ccnnttll **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt
ddeeffeerr
DDeeffeerr;;
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
rreesscchheedd
--
RReesscchheedduullee pprroocceessssoorr ttoo hhiigghheesstt pprriioorriittyy eelliiggiibbllee pprroocceessss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
rreesscchheedd((vvooiidd))
//** AAssssuummeess iinntteerrrruuppttss aarree ddiissaabblleedd
**//
{{
ssttrruucctt pprroocceenntt **ppttoolldd;;
//** PPttrr ttoo ttaabbllee eennttrryy ffoorr oolldd pprroocceessss
**//
ssttrruucctt pprroocceenntt **ppttnneeww;;
//** PPttrr ttoo ttaabbllee eennttrryy ffoorr nneeww pprroocceessss
**//

Sec. 5.6        Implementation Of Scheduling 
83
//** IIff rreesscchheedduulliinngg iiss ddeeffeerrrreedd,, rreeccoorrdd aatttteemmpptt aanndd rreettuurrnn **//
iiff ((DDeeffeerr..nnddeeffeerrss >> 00)) {{
DDeeffeerr..aatttteemmpptt == TTRRUUEE;;
rreettuurrnn;;
}} 
//** PPooiinntt ttoo pprroocceessss ttaabbllee eennttrryy ffoorr tthhee ccuurrrreenntt ((oolldd)) pprroocceessss **//
ppttoolldd == &&pprrooccttaabb[[ccuurrrrppiidd]];;
iiff ((ppttoolldd-->>pprrssttaattee ==== PPRR__CCUURRRR)) {{
//** PPrroocceessss rreemmaaiinnss eelliiggiibbllee **//
iiff ((ppttoolldd-->>pprrpprriioo >> ffiirrssttkkeeyy((rreeaaddyylliisstt)))) {{
rreettuurrnn;;
}} 
//** OOlldd pprroocceessss wwiillll nnoo lloonnggeerr rreemmaaiinn ccuurrrreenntt **//
ppttoolldd-->>pprrssttaattee == PPRR__RREEAADDYY;;
iinnsseerrtt((ccuurrrrppiidd,, rreeaaddyylliisstt,, ppttoolldd-->>pprrpprriioo));;
}} 
//** FFoorrccee ccoonntteexxtt sswwiittcchh ttoo hhiigghheesstt pprriioorriittyy rreeaaddyy pprroocceessss **//
ccuurrrrppiidd == ddeeqquueeuuee((rreeaaddyylliisstt));;
ppttnneeww == &&pprrooccttaabb[[ccuurrrrppiidd]];;
ppttnneeww-->>pprrssttaattee == PPRR__CCUURRRR;;
pprreeeemmpptt == QQUUAANNTTUUMM;;
//** RReesseett ttiimmee sslliiccee ffoorr pprroocceessss **//
ccttxxssww((&&ppttoolldd-->>pprrssttkkppttrr,, &&ppttnneeww-->>pprrssttkkppttrr));;
//** OOlldd pprroocceessss rreettuurrnnss hheerree wwhheenn rreessuummeedd **//
rreettuurrnn;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
rreesscchheedd__ccnnttll
--
CCoonnttrrooll wwhheetthheerr rreesscchheedduulliinngg iiss ddeeffeerrrreedd oorr aalllloowweedd
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
rreesscchheedd__ccnnttll((
//** AAssssuummeess iinntteerrrruuppttss aarree ddiissaabblleedd
**//
iinntt3322 ddeeffeerr
//** EEiitthheerr DDEEFFEERR__SSTTAARRTT oorr DDEEFFEERR__SSTTOOPP
**//
))
{{
sswwiittcchh ((ddeeffeerr)) {{

84 
Scheduling And Context Switching 
Chap. 5
ccaassee DDEEFFEERR__SSTTAARRTT::
//** HHaannddllee aa ddeeffeerrrraall rreeqquueesstt **//
iiff ((DDeeffeerr..nnddeeffeerrss++++ ==== 00)) {{
DDeeffeerr..aatttteemmpptt == FFAALLSSEE;;
}} 
rreettuurrnn OOKK;;
ccaassee DDEEFFEERR__SSTTOOPP::
//** HHaannddllee eenndd ooff ddeeffeerrrraall **//
iiff ((DDeeffeerr..nnddeeffeerrss <<== 00)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
iiff (( ((----DDeeffeerr..nnddeeffeerrss ==== 00)) &&&& DDeeffeerr..aatttteemmpptt )) {{
rreesscchheedd(());;
}} 
rreettuurrnn OOKK;;
ddeeffaauulltt::
rreettuurrnn SSYYSSEERRRR;;
}}
}}
Resched begins by checking global variable Defer.ndefers to see whether
rescheduling is deferred. If so, resched sets global variable Defer.attempt to indicate
that an attempt was made during the deferral period and returns to the caller. As the
next section explains, deferred rescheduling is provided for situations where the operat-
ing system must make multiple processes eligible to use the processor before allowing 
any to run. In particular, some I/O hardware delivers multiple data items on a single 
interrupt. If multiple processes are each waiting to read a data item, the operating sys-
tem must handle all of them at the same time. For now, it is sufficient to understand 
that rescheduling can be deferred temporarily.
Once it passes the test for deferral, resched examines the implicit parameter
described above: the state of the current process. If the state variable contains
PR_CURR and the current process’s priority is the highest in the system, resched re-
turns and the current process remains running. If the state specifies that the current 
process should remain eligible to use the processor but the current process does not 
have the highest priority, resched adds the current process to the ready list. Resched 
then removes the process at the head of the ready list (the highest priority process), and 
performs a context switch.
It may be difficult to envision how context switching occurs because each con-
current process has its own instruction pointer. To see how concurrency operates, sup-
pose that process P1 is running and calls resched. If resched chooses to switch to proc-
ess P2, process P1 will be stopped in the call to ctxsw. Once process P2 starts to run, it 
can execute arbitrary code. At a later time when resched switches back to process P1, 
execution will resume where it left off — in the call to ctxsw. The location at which P1

Sec. 5.6        Implementation Of Scheduling 
85
is executing does not change just because P2 used the processor. When process P1 runs,
the call to ctxsw will return to resched. A later section explains exactly how a context 
switch handles the details.
5.7 Deferred Rescheduling
Although our scheduling policy requires the highest priority eligible process to ex-
ecute, resched permits scheduling to be deferred temporarily. The motivation arises be-
cause some operating system functions move multiple processes onto the ready list at 
the same time. For example, consider a timer. If two or more processes choose delays 
that expire at the exact same time, the operating system must move all of them to the 
ready state. The important idea is that one or more of the processes that become ready 
may have a higher priority than the process that is currently executing. However, 
rescheduling in the midst of such a move can result in incomplete and incorrect opera-
tion. In particular, rescheduling after making one process ready may cause the process 
to execute, even if other processes have higher priority. We will see an example in 
Chapter 7; for now, it is sufficient to understand that the situation can arise.
The solution for multiple processes consists of temporarily suspending the schedul-
ing policy. Function resched_cntl provides the mechanism. At any time, a process can 
make the call:
resched_cntl(DEFER_START)
to defer rescheduling, and then call:
resched_cntl(DEFER_STOP)
to end a deferral period and continue normal operation.
To permit nested function calls that each request deferral, our implementation uses
a global counter, Defer.ndefers, that is initialized to zero. When a deferral is requested,
the code increments Defer.ndefers. Later, when a function ends its deferral period,
Defer.ndefers is decremented. As long as the count remains positive, resched only
records that a call was made, but returns to its caller without switching context. When 
Defer.ndefers reaches zero, resched_cntl examines Defer.attempt to see if resched was 
called during the deferral period. If so, resched_cntl invokes resched before returning 
to its caller.
5.8 Implementation Of Context Switching
Because registers and hardware status cannot be manipulated directly with a high-
level language, resched calls an assembly language function, ctxsw, to switch context
from one process to another. The code for ctxsw is, of course, machine dependent. The
last step consists of resetting the program counter (i.e., jumping to the location in the

86 
Scheduling And Context Switching 
Chap. 5
new process at which execution should resume). In Xinu, the text segment for the new 
process will be present in memory because Xinu keeps all parts of the program resident. 
The point is that the operating system must load all other state variables for the new 
process before jumping to the new process. Some architectures contain a pair of in-
structions that are used in context switching: one stores processor state information in 
successive memory locations and the other loads processor state from successive 
memory locations. On such architectures, context switching code executes a single in-
struction to save the processor state on the current process’s stack and another instruc-
tion to load the processor state from the new process’s stack. Of course, each instruc-
tion takes many cycles. RISC architectures often implement ctxsw with a sequence of 
instructions that each save one of the registers and a sequence of instructions that each 
load a register.
5.9 State Saved In Memory
To understand how ctxsw saves processor states, imagine that we can look at the 
memory of a system that has three active processes: two of which are ready and one of 
which is currently executing. Each process has a private stack. The process that is 
currently executing is using its stack. That is, the hardware stack pointer currently 
points to the top of the current process’s stack.† When it calls a function, the executing 
process pushes copies of registers on the stack and allocates space on the stack for local 
variables and temporary storage needed by the called function. When it returns from a 
function, the saved items are popped off the stack.
Our context switching function is designed to store a copy of the machine state for
a process on the process’s stack. That is, just before switching context, the code stores
all pertinent information about the process on the process’s stack. Now imagine freez-
ing the system at a point in time, and think about the two processes that are not current-
ly executing. When they were running, the two processes each pushed state information 
on their stack because each performed a context switch as the last step before turning 
the processor over to another process. Thus, if we look in memory, each of the 
processes will have saved state information on the top of their stack. Figure 5.3 illus-
trates the configuration.

†Recall that stacks grow downward in memory, so the top of a stack is the lowest memory address that
has been used in a process’s stack area.

Sec. 5.9        State Saved In Memory 
87
memory
(a)
(b)
(c)
unused
unused
unused
stack space for current process
stack space for ready process b
stack space for ready process a
stack pointer (sp) points here
used
saved state for process b
used
saved state for process a
used
Figure 5.3 Illustration of stacks in memory when processes (a) and (b) are
on the ready list, and process (c) is currently executing.
5.10 Context Switch Operation
Our example ctxsw function takes two arguments: a pointer to the process table en-
try for the current process and a pointer to the process table entry for the new process.
d Execute instructions that push the contents of the processor register
on the stack of the process that is running when ctxsw is called
(i.e., the old process).
d Save the stack pointer in the process table entry for the current
process, and load the stack pointer for the “new” process.
d Execute instructions that reload the processor registers from values
previously saved on the new process’s stack.
d Return to the function in the new process that called ctxsw.
Because context switching involves the direct manipulation of processor registers, 
the code is written in assembly language. In addition to saving copies of the general-
purpose registers, most processors require a context switch to save internal hardware re-

88 
Scheduling And Context Switching 
Chap. 5
gisters, such as the status register (i.e., the register that records whether the last arithme-
tic result was positive, negative, or zero).
The second step, saving and restoring stack pointers, is handled by passing two ar-
guments to ctxsw. The first argument gives the address of the location in the process
table where the current process’s stack pointer should be stored. The second argument 
gives the address of the location in the process table where the stack pointer for the new 
process has previously been saved. Thus, when saving the stack pointer for the current 
process, the context switch merely needs to dereference the first argument. Similarly, to 
pick up the stack pointer for the new process, the context switch merely needs to 
dereference the second argument. We will see that on an Intel processor, one of the 
general purpose registers must be saved because dereferencing requires the use of one 
register. On the ARM architecture, the calling sequence requires the caller to save re-
gisters r0 through r3 (which are used to pass arguments). Because the context switch 
function only has two arguments, only registers r0 and r1 contain argument values. 
Therefore, the ARM context switch code can use either of registers r2 or r3.
After the second step, the hardware stack pointer points to the new process’s stack. 
Ctxsw extracts the set of values that was saved on the stack for the process, and loads 
the values into processor registers. The following sections show the code for the Intel
and ARM platforms.
5.10.1  Galileo (Intel)
On an Intel platform, such as the Galileo, the context switch begins by saving
values for the old process on the current stack (i.e., the old process’s stack). It first
pushes the EBX register (so EBX can be used to access the arguments). It then pushes
the processor flags and all general-purpose registers. The flags contain the current pro-
cessor status. The code then saves the old process’s stack pointer in the location given 
by the first argument, and picks up the new process’s stack pointer from the location 
given by the second argument. Once the stack pointer has been switched, ctxsw restores 
values that were previously saved with the new process: the general-purpose registers, 
the flags, and the saved value of EBX. Finally, ctxsw returns. Note that when the re-
turn occurs, the new process will be running. An Intel processor includes a single 
machine instruction to push copies of all the registers on the stack (pushal), and a single 
machine instruction to restore all the registers from the saved values (popal). File 
ctxsw.S contains the code.
//** ccttxxssww..SS -- ccttxxssww ((ffoorr xx8866)) **//
..tteexxtt
..gglloobbll
ccttxxssww
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ccttxxssww --
XX8866 ccoonntteexxtt sswwiittcchh;; tthhee ccaallll iiss ccttxxssww((&&oolldd__sspp,, &&nneeww__sspp))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//

Sec. 5.10        Context Switch Operation 
89
ccttxxssww::
ppuusshhll
%%eebbpp
//** PPuusshh eebbpp oonnttoo ssttaacckk
**//
mmoovvll
%%eesspp,,%%eebbpp
//** RReeccoorrdd ccuurrrreenntt SSPP iinn eebbpp
**//
ppuusshhffll
//** PPuusshh ffllaaggss oonnttoo tthhee ssttaacckk
**//
ppuusshhaall
//** PPuusshh ggeenneerraall rreeggss.. oonn ssttaacckk
**//
//** SSaavvee oolldd sseeggmmeenntt rreeggiisstteerrss hheerree,, iiff mmuullttiippllee aalllloowweedd **//
mmoovvll
88((%%eebbpp)),,%%eeaaxx
//** GGeett mmeemm llooccaattiioonn iinn wwhhiicchh ttoo **//
//**
ssaavvee tthhee oolldd pprroocceessss’’ss SSPP
**//
mmoovvll
%%eesspp,,((%%eeaaxx))
//** SSaavvee oolldd pprroocceessss’’ss SSPP
**//
mmoovvll
1122((%%eebbpp)),,%%eeaaxx
//** GGeett llooccaattiioonn ffrroomm wwhhiicchh ttoo
**//
//**
rreessttoorree nneeww pprroocceessss’’ss SSPP
**//
//** TThhee nneexxtt iinnssttrruuccttiioonn sswwiittcchheess ffrroomm tthhee oolldd pprroocceessss’’ss **//
//**
ssttaacckk ttoo tthhee nneeww pprroocceessss’’ss ssttaacckk..
**//
mmoovvll
((%%eeaaxx)),,%%eesspp
//** PPoopp uupp nneeww pprroocceessss’’ss SSPP
**//
//** RReessttoorree nneeww sseegg.. rreeggiisstteerrss hheerree,, iiff mmuullttiippllee aalllloowweedd **//
ppooppaall
//** RReessttoorree ggeenneerraall rreeggiisstteerrss
**//
mmoovvll
44((%%eesspp)),,%%eebbpp
//** PPiicckk uupp eebbpp bbeeffoorree rreessttoorriinngg **//
//**
iinntteerrrruuppttss
**//
ppooppffll
//** RReessttoorree iinntteerrrruupptt mmaasskk
**//
aadddd
$$44,,%%eesspp
//** SSkkiipp ssaavveedd vvaalluuee ooff eebbpp
**//
rreett
//** RReettuurrnn ttoo nneeww pprroocceessss
**//
5.10.2  BeagleBone Black (ARM)
The context switch for an ARM platform, such as the BeagleBone Black, follows 
almost the same approach as on the Intel platform. On an ARM processor, the co-
processor stores the internal hardware status register. Therefore, to save a copy of the 
status, the context switch must obtain the value from the co-processor. Instruction mrs 
moves the status from the co-processor status register to a specified general-purpose re-
gister. As described above, the example code uses register r3 because the calling se-
quence allows a called function to change r3. Once a copy of the status has been ob-
tained, the code saves a copy of registers r3 through r12 and register lr on the current 
process’s stack. The code then saves the old process’s stack pointer in the location 
given by the first argument, picks up the new process’s stack pointer from the location 
given by the second argument, restores registers r3 through r12 and lr from the stack, 
restores the status register from r3, and returns.

90 
Scheduling And Context Switching 
Chap. 5
Because it uses a RISC approach, an ARM processor does not have a single
machine instruction that can save multiple registers, nor does the processor have a sin-
gle machine instruction that can restore multiple registers. Instead, a given instruction
can only save (i.e., push) or restore (i.e., pop) a single register. Thus, one might expect
the context switch code to start with a series of statements that each push one register:
push 
r3
push 
r4
push 
r5
push 
r6
push 
r7
push 
r8
push 
r9
push 
r10
push 
r11
push 
r12
push 
lr
and to end with a series of statements that each pop one register:
pop 
lr
pop 
r12
pop 
r11
pop 
r10
pop 
r9
pop 
r8
pop 
r7
pop 
r6
pop 
r5
pop 
r4
pop 
r3
Interestingly, the code does not contain such sequences. Instead, the code uses as-
sembler directives that the assembler interprets and uses to generate multiple instruc-
tions. For example, the push directive
push 
{r3–r12, lr}
instructs the assembler to generate a sequence of instructions that each push one of the 
registers listed. Similarly, the pop directive:
pop 
{r3–r12, lr}
causes the assembler to generate a sequence of pop instructions. The assembler gen-
erates the pop sequence in the opposite order than the push sequence, which gives the 
instruction sequence illustrated above. File ctxsw.S contains the code.

Sec. 5.10        Context Switch Operation 
91
//** ccttxxssww..SS -- ccttxxssww ((ffoorr AARRMM)) **//
..tteexxtt
..gglloobbll
ccttxxssww
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ccttxxssww --
AARRMM ccoonntteexxtt sswwiittcchh;; tthhee ccaallll iiss ccttxxssww((&&oolldd__sspp,, &&nneeww__sspp))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ccttxxssww::
ppuusshh
{{rr00--rr1111,, llrr}}
//** PPuusshh rreeggss 00 -- 1111 aanndd llrr
**//
ppuusshh
{{llrr}}
//** PPuusshh rreettuurrnn aaddddrreessss
**//
mmrrss
rr22,, ccppssrr
//** OObbttaaiinn ssttaattuuss ffrroomm ccoopprroocceessss..**//
ppuusshh
{{rr22}}
//**
aanndd ppuusshh oonnttoo ssttaacckk
**//
ssttrr
sspp,, [[rr00]]
//** SSaavvee oolldd pprroocceessss’’ss SSPP
**//
llddrr
sspp,, [[rr11]]
//** PPiicckk uupp nneeww pprroocceessss’’ss SSPP
**//
ppoopp
{{rr00}}
//** UUssee ssttaattuuss aass aarrgguummeenntt aanndd
**//
bbll
rreessttoorree
//**
ccaallll rreessttoorree ttoo rreessttoorree iitt **//
ppoopp
{{llrr}}
//** PPiicckk uupp tthhee rreettuurrnn aaddddrreessss
**//
ppoopp
{{rr00--rr1122}}
//** RReessttoorree ootthheerr rreeggiisstteerree
**//
mmoovv
ppcc,, rr1122
//** RReettuurrnn ttoo tthhee nneeww pprroocceessss
**//
5.11 An Address At Which To Restart A Process
A potential problem arises during context switching because the processor can 
change registers. Thus, the code must be written carefully because once a given register 
has been saved, subsequent changes will be lost when the process restarts. Fortunately, 
the standard calling sequence helps by saving and restoring registers when the context 
switch function is called. The instruction pointer (i.e., program counter) represents a 
special dilemma, because storing the value means that when the process restarts, execu-
tion will continue at exactly the point in the code at which the instruction pointer was 
stored. If a copy of the instruction pointer is saved before the context switch has com-
pleted, the process will restart at a point before the context switch has occurred. The 
code in ctxsw reveals how the situation is resolved: the instruction pointer is not among 
the registers saved on the stack. Instead, we only save the address to which ctxsw 
should return.
To understand the idea, think of an executing process, P, that has called resched
which has then called ctxsw. We assume that the only way P will regain the processor
later will occur when some other process calls ctxsw. So, if we save the return address, 
when P runs again, ctxsw will return as if it were a normal function. Consequently:
When a process restarts, the process will resume execution in resched 
immediately following the call to ctxsw.

92 
Scheduling And Context Switching 
Chap. 5
We assume that no context switching occurs outside of ctxsw. That is, all
processes must call resched to perform context switching, and resched calls ctxsw.
Thus, if one were to freeze the system at an arbitrary instant and examine memory, the 
saved information for each ready process will have the same value for a return address 
— an address just after the call to ctxsw in resched. However, each process has its own 
stack of function calls, which means that when a given process resumes execution and 
returns from resched, the return may go to a different caller than the return in another 
process.
The notion of function return forms a key ingredient in keeping the system design 
clean. Function calls proceed downward through each level of the system, and each call 
returns. To enforce the design at all levels, the scheduler, resched, and the context 
switch, ctxsw, have each been designed to behave like any other function and return. 
To summarize:
In Xinu, each function, including the scheduler and context switch, 
eventually returns to its caller.
Of course, rescheduling allows other processes to execute, and the execution may 
take arbitrarily long (depending on process priorities). Thus, a considerable delay may 
elapse between a call to resched and the time the call returns and the process runs 
again.
5.12 Concurrent Execution And A Null Process
The concurrent execution abstraction is complete and absolute. That is, an operat-
ing system views all computation as part of a process — there is no way that the pro-
cessor can temporarily stop executing processes and execute a separate piece of code. 
The scheduler design reflects the following principle: the scheduler’s only function is to 
switch the processor among the set of processes that are current or ready. The 
scheduler cannot execute any code that is not part of a process, and cannot create a new 
process. Figure 5.4 illustrates the possible state transitions.
READY
CURRENT
resched
resched
Figure 5.4 Illustrations of state transitions for processes between the ready
and current states.

Sec. 5.12        Concurrent Execution And A Null Process 
93
We will see that a given process does not always remain ready to execute. For ex-
ample, a process stops executing when it waits for I/O to complete or when it needs to
use a shared resource that is already in use. What happens if all processes wait for I/O? 
Resched will fail because the code has been designed to assume at least one process will 
be eligible to execute at any time. When the currently executing process blocks, 
resched removes the first process from the ready list without verifying that the list is 
nonempty. If the list is empty, an error results. To summarize:
Because an operating system can only switch the processor from one 
process to another, at least one process must remain ready to execute 
at all times.
To ensure that at least one process always remains ready to execute, Xinu uses a 
standard technique: it creates an extra process, called the null process, when the system 
boots. The null process has process ID zero and priority zero (a lower priority than any 
other process). The null process code, which will be shown in Chapter 22, consists of 
an infinite loop. Because all other processes must have a priority greater than zero, the 
scheduler switches to the null process only when no other process is ready to run. In 
essence, the operating system switches the processor to the null process when all other 
processes are blocked (e.g., waiting for I/O).†
5.13 Making A Process Ready And The Scheduling Invariant
Because it performs a swap by removing a process from the ready list and (possi-
bly) moving the current process onto the ready list, resched manipulates the list directly. 
We will see that many other functions need to make a process eligible for processor ser-
vice. The task occurs so frequently that we designed a function to do just that. The 
function is named ready.
Ready takes an argument that specifies a process ID, and makes the process eligi-
ble to execute. Our scheduling policy specifies that at any time, the highest priority eli-
gible process must be executing. We say that each operating system function should 
maintain a scheduling invariant: a function assumes the highest priority process was ex-
ecuting when the function was called, and must ensure that the highest priority process 
is executing when the function returns. Thus, if a function changes the state of 
processes, the function must call resched to reestablish the invariant. Thus, when it 
places a high priority process on the ready list, ready calls resched to ensure that the 
policy is followed. File ready.c contains the code.

†Some processors include a special instruction that can be placed in a null process that stops the proces-
sor until an interrupt occurs; using the special instruction may reduce the energy that the processor consumes.

94 
Scheduling And Context Switching 
Chap. 5
//** rreeaaddyy..cc -- rreeaaddyy **//
##iinncclluuddee <<xxiinnuu..hh>>
qqiidd1166
rreeaaddyylliisstt;;
//** IInnddeexx ooff rreeaaddyy lliisstt
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
rreeaaddyy
--
MMaakkee aa pprroocceessss eelliiggiibbllee ffoorr CCPPUU sseerrvviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
rreeaaddyy((
ppiidd3322
ppiidd
//** IIDD ooff pprroocceessss ttoo mmaakkee rreeaaddyy
**//
))
{{
rreeggiisstteerr ssttrruucctt pprroocceenntt **pprrppttrr;;
iiff ((iissbbaaddppiidd((ppiidd)))) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** SSeett pprroocceessss ssttaattee ttoo iinnddiiccaattee rreeaaddyy aanndd aadddd ttoo rreeaaddyy lliisstt **//
pprrppttrr == &&pprrooccttaabb[[ppiidd]];;
pprrppttrr-->>pprrssttaattee == PPRR__RREEAADDYY;;
iinnsseerrtt((ppiidd,, rreeaaddyylliisstt,, pprrppttrr-->>pprrpprriioo));;
rreesscchheedd(());;
rreettuurrnn OOKK;;
}}
5.14 Other Process Scheduling Algorithms
Process scheduling was once an important topic in operating systems, and many 
scheduling algorithms have been proposed as alternatives to the round-robin scheduler
in Xinu. For example, one policy measures the amount of I/O a process performs and 
gives the processor to the process that spends the most time doing I/O. Proponents of 
the policy argue that because I/O devices are slower than processors, choosing a proc-
ess that performs I/O will increase the total throughput of the system.
Because scheduling is confined to a few functions, it is easy to experiment with the 
scheduling policy in Xinu. Changing resched and ready changes the basic scheduler. 
Of course, if the new policy uses data that Xinu does not already gather (e.g., the
amount of time spent doing I/O), other functions may need to change to record the ap-
propriate data.

Sec. 5.15        Perspective
95
5.15 Perspective
The most interesting aspect of scheduling and context switching arises because 
they are embedded as part of normal computation. That is, instead of the operating sys-
tem being implemented separately from the processes it controls, the operating system 
code is executed by the processes themselves. Thus, the system does not have an extra 
process that can stop the processor from executing one application and move it to 
another, scheduling and context switching occur as the side effect of a function call.
We will see that using processes to execute operating system code affects the 
design. When a programmer writes an operating system function, the programmer must 
accommodate execution by concurrent processes. Similarly, using processes to execute 
operating system code affects how the system interacts with I/O devices and how it 
handles interrupts.
5.16 Summary
Scheduling and context switching form a foundation for concurrent execution. 
Scheduling consists of choosing a process from among those that are eligible for execu-
tion. Context switching consists of stopping one process and starting a new one. To 
keep track of processes, the system uses a global data structure called a process table. 
Whenever it temporarily suspends a process, the context switch saves the processor state 
for the process on the process’s stack and places a pointer to the stack in the process 
table. To restart a process, the context switch reloads the processor state information 
from the process’s stack, and resumes execution in the process at the point the call to 
the context switch function returns.
To allow functions to determine when an operation is permitted, each process is as-
signed a state. A process that is using the processor is assigned the current state, and a 
process that is eligible to use the processor, but is not currently executing, is assigned 
the ready state. Because at least one process must remain eligible to execute at any 
time, the operating system creates an extra process at startup known as the null process. 
The null process has priority zero, and all other processes have priority greater than 
zero. Consequently, the null process only runs when no other process is eligible.
The chapter presents three functions that perform transitions between the current 
and ready states. Function resched performs scheduling, function ctxsw performs con-
text switching, and function ready makes a process eligible to execute.
EXERCISES
5.1 
If the operating system contains a total of N processes, how many processes can be on the
ready list at a given time? Explain.
5.2    How do operating system functions know which process is executing at a given time?

96 
Scheduling And Context Switching 
Chap. 5
5.3 
Rewrite resched to have an explicit parameter giving the disposition of the currently exe-
cuting process, and examine the assembly code generated to determine the number of in-
structions executed in each case.
5.4 
What are the basic steps performed during a context switch?
5.5   Investigate another hardware architecture (e.g., SPARC or MIPS), and determine what in-
formation needs to be saved during a context switch.
5.6  How much memory is needed to store processor state for a MIPS processor? Which regis-
ters must be saved, and why? How does the standard calling convention for a processor af-
fect the answer?
5.7  Suppose process k has been placed on the ready list. When process k becomes current,
where will execution start?
5.8 
Why is a null process needed?
5.9 
Consider a modification to the code that stores processor state in the process table instead
of on the process’s stack (i.e., assume the process table entry contains an array that holds
the contents of registers). What are the advantages of each approach?
5.10  In the previous exercise, does saving registers in the process table reduce or increase the
number of instructions executed during a context switch?
5.11 Devise a scheduling policy for a dual-core processor (i.e., a processor that contains two
separate processing cores that can execute in parallel).
5.12 Extend the previous exercise: show that executing resched on one core may require chang-
ing the process that is running on the other core. (Note: many operating systems for dual-
core processors avoid the problem by specifying that all operating system functions, includ-
ing scheduling, run on one of the two cores.)
5.13 Variable Defer.attempt records whether resched was called during the period when
rescheduling is deferred, but it does not record whether a context switch would have oc-
curred. Should the code be rewritten to record whether rescheduling is needed rather than 
whether resched was called? Why or why not?

Chapter Contents
6.1 
Introduction, 99
6.2 
Process Suspension And Resumption, 99
6.3 
Self–suspension And Information Hiding, 100
6.4 
The Concept Of A System Call, 101
6.5 
Interrupt Control With Disable And Restore, 103
6.6 
A System Call Template, 104
6.7 
System Call Return Values SYSERR And OK, 105
6.8 
Implementation Of Suspend, 105
6.9 
Suspending The Current Process, 107
6.10 
The Value Returned By Suspend, 107
6.11 
Process Termination And Process Exit, 108
6.12 
Process Creation, 111
6.13 
Other Process Manager Functions, 115
6.14 
Summary, 117


6
More Process Management
When men willingly suspend fear, science flourishes.
— Anonymous
6.1 Introduction
Chapter 5 discusses the concurrent execution abstraction and process execution. 
The chapter explains how an operating system stores information about processes in a 
table, and how each process is assigned a state. Chapter 5 also explains the concepts of 
scheduling and context switching. It shows how a scheduler implements a scheduling 
policy, and explains how a process moves between the ready and current states.
This chapter extends our study of the process management functions in an operat-
ing system. The chapter explains how a new process comes into existence, and what 
happens when a process exits. The chapter also examines a process state that allows a 
process to be suspended temporarily, and explores functions that move processes among 
the current, ready, and suspended states.
6.2 Process Suspension And Resumption
We will see that operating system functions sometimes need to stop a process from 
executing temporarily and, at a later time, resume execution. We say that a stopped 
process has been placed in a state of “suspended animation.” For example, suspended 
animation can be used when a process waits for one of several restart conditions 
without knowing which will occur first.
99

100 
More Process Management 
Chap. 6
The first step in implementing operating system functionality consists of defining a 
set of operations. In the case of suspended animation, only two conceptual operations 
provide all the functionality that is needed:
d Suspend stops a process and places the process in suspended ani-
mation (i.e., makes the process ineligible to use the processor).
d Resume continues execution of a previously suspended process
(i.e., makes the process eligible to use the processor again).
Because it is not eligible to use the processor, a suspended process cannot remain
in either the ready or current states. Thus, a new state must be invented. We call the
new state suspended, and add the new state and associated transitions to the state di-
agram. Figure 6.1 shows the extended state diagram, which summarizes how suspend 
and resume affect the state. The resulting diagram documents the possible transitions 
among the ready, current, and suspended states.
READY
CURRENT
resched
resched
SUSPENDED
suspend
resume
suspend
Figure 6.1  Transitions among the current, ready, and suspended states.
6.3 Self–suspension And Information Hiding
Although each state transition in Figure 6.1 has a label that specifies a particular 
function, process suspension differs from scheduling in a significant way: instead of act-
ing on the current process, suspend allows one process to suspend another process. 
More important, because a suspended process cannot resume itself, resume must allow 
an executing process to resume a previously suspended process. Thus, suspend and 
resume each take an argument that specifies the ID of a process on which the operation 
should be performed.
Can a process suspend itself? Yes. To do so, a process must obtain its process ID
and then pass the ID as an argument to suspend. An implementation may seem obvi-
ous. Because global variable currpid contains the process ID of the currently executing 
process, a self-suspension can be achieved with:

Sec. 6.3        Self–suspension And Information Hiding 
101
suspend( currpid );
However, a well-designed operating system design adheres to the principle of in-
formation hiding: implementation details are not generally revealed. Thus, instead of 
permitting processes to access global variables like currpid directly, Xinu includes a 
function named getpid that a process can call to obtain its ID. Thus, to suspend itself, a 
process calls:
suspend( getpid( ) );
The present implementation of getpid merely returns the value of currpid, which 
may seem like unnecessary overhead. However, the advantage of information hiding 
becomes clear when one considers modifying the operating system. If all processes call 
getpid, a designer can change the details of where and how the current process ID is 
stored without changing other code.
The point is:
A good system design follows the principle of information hiding,
which states that implementation details are not revealed unless 
necessary. Hiding such details makes it possible to change the imple-
mentation of a function without rewriting code that uses the function.
6.4 The Concept Of A System Call
In theory, process resumption is straightforward. The process must be placed in 
the ready state and inserted in the correct position on the ready list. The ready function 
described in the previous chapter performs both tasks, so it may seem that resume is un-
necessary. In practice, however, resume adds an extra layer of protection: it makes no 
assumptions about the caller or the correctness of the arguments. In particular, an arbi-
trary process can invoke resume at an arbitrary time with arbitrary arguments.
We used the term system call to distinguish a function like resume from internal 
functions like ready. In general, we think of the set of system calls as defining a view
of the operating system from the outside — application processes invoke system calls to 
obtain services. In addition to adding a layer of protection, the system call interface 
provides another example of information hiding: application processes remain unaware 
of the internal implementation, and can only use the set of system calls to obtain ser-
vice. We will see that the distinction between system calls and other functions appears 
throughout an operating system. To summarize:
System calls, which define operating system services for applications, 
protect the system from illegal use and hide information about the 
underlying implementation.

102 
More Process Management 
Chap. 6
To provide protection, system calls handle three aspects of computation that under-
lying functions do not:
d Check all arguments
d Ensure that changes leave global data structures in a
consistent state
d Report success or failure to the caller
In essence, a system call cannot make any assumptions about the process that is 
making the call. Thus, instead of assuming that the caller has supplied correct and 
meaningful argument values, a system call checks each argument. More important, 
many system calls make changes to operating system data structures, such as the proc-
ess table and lists of processes stored in the queue structure. A system call must 
guarantee that no other process will attempt to change data structures at the same time, 
or inconsistencies can result. Because it cannot make assumptions about the conditions 
under which it will be invoked, a system call must take steps to prevent other processes 
from executing concurrently while data structures are being changed. There are two as-
pects:
d Avoid invoking any functions that voluntarily relinquish the pro-
cessor
d Disable interrupts to prevent involuntarily relinquishing the proces-
sor
To prevent voluntarily relinquishing the processor, a system call must avoid direct 
or indirect calls to resched. That is, while changes are in progress, a system call cannot 
invoke resched directly and cannot invoke any function that calls resched. To prevent 
involuntarily relinquishing the processor, a system call disables interrupts until a change 
is complete. In Chapter 13, we will understand the reason: hardware interrupts can 
result in rescheduling because some interrupt routines call resched.
An example system call will help clarify the two aspects. Consider the code for
resume that is contained in file resume.c.
//** rreessuummee..cc -- rreessuummee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
rreessuummee
--
UUnnssuussppeenndd aa pprroocceessss,, mmaakkiinngg iitt rreeaaddyy
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
pprrii1166
rreessuummee((
ppiidd3322
ppiidd
//** IIDD ooff pprroocceessss ttoo uunnssuussppeenndd
**//

Sec. 6.4        The Concept Of A System Call 
103
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pprroocceenntt **pprrppttrr;;
//** PPttrr ttoo pprroocceessss’’ ttaabbllee eennttrryy
**//
pprrii1166
pprriioo;;
//** PPrriioorriittyy ttoo rreettuurrnn
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddppiidd((ppiidd)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn ((pprrii1166))SSYYSSEERRRR;;
}} 
pprrppttrr == &&pprrooccttaabb[[ppiidd]];;
iiff ((pprrppttrr-->>pprrssttaattee !!== PPRR__SSUUSSPP)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn ((pprrii1166))SSYYSSEERRRR;;
}} 
pprriioo == pprrppttrr-->>pprrpprriioo;;
//** RReeccoorrdd pprriioorriittyy ttoo rreettuurrnn
**//
rreeaaddyy((ppiidd));;
rreessttoorree((mmaasskk));;
rreettuurrnn pprriioo;;
}}
6.5 Interrupt Control With Disable And Restore
As expected, the code in resume checks argument pid to ensure that the caller has 
supplied a valid process ID and the specified process is in the suspended state. Before 
it performs any computation, however, resume guarantees that no interrupts will occur 
(i.e., no context switching can occur until resume invokes an operating system function
that causes a context switch). To control interrupts, resume uses a pair of functions:†
d Function disable disables interrupts and returns the previous inter-
rupt status to its caller.
d Function restore reloads an interrupt status from a previously saved
value.
As expected, resume disables interrupts immediately upon entry. Resume can re-
turn in two ways: either an error is detected or resume finishes the requested operation 
successfully. In either case, resume must call restore before returning to reset the inter-
rupt status to the same value the caller was using when the call began.
Programmers who do not have experience writing code for operating systems often 
expect a system call to enable interrupts before returning. However, restore provides
more generality. To see why, observe that because it restores interrupts rather than sim-
ply enabling them, resume works correctly whether it is called with interrupts enabled 
or disabled. On the one hand, if a function has interrupts disabled when it calls resume, 

†Chapter 12 explains the details of interrupt handling.

104 
More Process Management 
Chap. 6
the call will return with interrupts disabled. On the other hand, if a function has inter-
rupts enabled when it calls resume, the call will return with interrupts enabled.
System calls must disable interrupts to prevent other processes from 
changing global data structures; using a disable / restore paradigm in-
creases generality.
6.6 A System Call Template
Another way to look at interrupt handling focuses on an invariant that a system
function must maintain:
An operating system function always returns to its caller with the
same interrupt status as when it was called.
To ensure the invariant is maintained, operating system functions follow the gen-
eral approach that Figure 6.2 illustrates.
ssyyssccaallll function_name((args))
{{
iinnttmmaasskk mmaasskk;;
//** Saved interrupt mask 
**//
mmaasskk == ddiissaabbllee(());;
//** Disable interrupts at start of function **//
iiff (( args are incorrect )) {{
rreessttoorree((mmaasskk));;
//** Restore interrupts before error return **//
rreettuurrnn SSYYSSEERRRR;;
}} 
......other processing......
iiff (( an error occurs )) {{
rreessttoorree((mmaasskk));;
//** Restore interrupts before error return **//
rreettuurrnn SSYYSSEERRRR;;
}} 
......more processing......
rreessttoorree((mmaasskk));;
//** Restore interrupts before normal return**//
rreettuurrnn appropriate value ;;
}}




















































Figure 6.2  Illustration of the general form of an operating system function.

Sec. 6.6        A System Call Template 
105
6.7 System Call Return Values SYSERR And OK
We will see that some system calls return a value that relates to the function being 
performed and others merely return a status to indicate that the call was successful. 
Resume provides an example of the former: it returns the priority of the process that has 
been resumed. In the case of resume, care must be taken to record the priority before 
calling ready because the resumed process may have higher priority than the currently 
executing process. Thus, as soon as ready places the specified process on the ready list 
and calls resched, the new process may begin executing. In fact, an arbitrary delay can 
occur between the time resume calls ready and execution continues after the call. Dur-
ing the delay, an arbitrary number of other processes can execute and processes may 
terminate. Thus, to ensure that the returned priority reflects the resumed process’s 
priority at the time of resumption, resume makes a copy in local variable prio before 
calling ready.  Resume uses the local copy as the return value.
To aid in reporting status, Xinu defines two constants that are used as return values 
throughout the system. A function returns SYSERR to indicate that an error occurred
during processing. That is, a system function returns SYSERR if the arguments are in-
correct (e.g., outside the acceptable range) or the requested operation could not be com-
pleted successfully. A function such as ready that does not compute a specific return 
value uses constant OK to indicate that the operation was successful.
6.8 Implementation Of Suspend
As the state diagram in Figure 6.1 indicates, suspend can only be applied to a proc-
ess that is current or ready. Suspension of a ready process is trivial: the process must
be removed from the ready list and its state must be changed to suspended. No further 
action is required. Thus, after deleting the process from the ready list and changing the 
process’s state to PR_SUSP, suspend can restore interrupts and return to its caller. The 
suspended process will remain ineligible to use the processor until it has been resumed.
Suspending the current process is almost as easy. The only subtle point is that 
resched uses an implicit argument to specify the disposition of the calling process. Re-
call from Chapter 5 that if a caller does not want to remain eligible to use the processor, 
the caller must set its state before invoking resched. Therefore, to suspend the current 
process, suspend must set the state of the current process to PR-SUSP and then call 
resched. That is, suspend sets the state of the current process to the desired next state.
The code for function suspend can be found in file suspend.c.

106 
More Process Management 
Chap. 6
//** ssuussppeenndd..cc -- ssuussppeenndd **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ssuussppeenndd
--
SSuussppeenndd aa pprroocceessss,, ppllaacciinngg iitt iinn hhiibbeerrnnaattiioonn
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll ssuussppeenndd((
ppiidd3322
ppiidd
//** IIDD ooff pprroocceessss ttoo ssuussppeenndd
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pprroocceenntt **pprrppttrr;;
//** PPttrr ttoo pprroocceessss’’ ttaabbllee eennttrryy
**//
pprrii1166
pprriioo;;
//** PPrriioorriittyy ttoo rreettuurrnn
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddppiidd((ppiidd)) |||| ((ppiidd ==== NNUULLLLPPRROOCC)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** OOnnllyy ssuussppeenndd aa pprroocceessss tthhaatt iiss ccuurrrreenntt oorr rreeaaddyy **//
pprrppttrr == &&pprrooccttaabb[[ppiidd]];;
iiff ((((pprrppttrr-->>pprrssttaattee !!== PPRR__CCUURRRR)) &&&& ((pprrppttrr-->>pprrssttaattee !!== PPRR__RREEAADDYY)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
iiff ((pprrppttrr-->>pprrssttaattee ==== PPRR__RREEAADDYY)) {{
ggeettiitteemm((ppiidd));;
//** RReemmoovvee aa rreeaaddyy pprroocceessss
**//
//**
ffrroomm tthhee rreeaaddyy lliisstt
**//
pprrppttrr-->>pprrssttaattee == PPRR__SSUUSSPP;;
}} eellssee {{
pprrppttrr-->>pprrssttaattee == PPRR__SSUUSSPP;;
//** MMaarrkk tthhee ccuurrrreenntt pprroocceessss **//
rreesscchheedd(());;
//**
ssuussppeennddeedd aanndd rreesscchheedd.. **//
}} 
pprriioo == pprrppttrr-->>pprrpprriioo;;
rreessttoorree((mmaasskk));;
rreettuurrnn pprriioo;;
}}
Like resume, suspend is a system call, which means the function disables interrupts 
when it is invoked. In addition, suspend checks argument pid to verify that it is a valid

Sec. 6.8        Implementation Of Suspend 
107
process ID. Because suspension is only valid for a process that is ready or current, the 
code verifies that the process is in one of the two valid states. If an error is detected, 
suspend restores interrupts and returns SYSERR to the caller.
6.9 Suspending The Current Process
The code for suspending the currently executing process raises two interesting 
points. First, the currently executing process will stop executing, at least temporarily. 
Thus, before suspending itself, the current process must prearrange for some other proc-
ess to resume it (or it will remain suspended forever). Second, because it will be 
suspended, the current process must allow another process to execute. Thus, when 
suspending the current process, suspend must call resched. The key idea is that when a 
process suspends itself, the process remains executing until the call to resched selects 
another process and switches context.
Note that when a process is suspended, resched does not place the process on the 
ready list. In fact, a suspended process is not on a list of suspended processes because 
there is no list of suspended processes analogous to the list of ready processes. Ready 
processes are only kept on an ordered list to speed the search for the highest priority 
process during rescheduling. Because the system never searches through suspended 
processes looking for one to resume, the set of suspended processes need not be kept on 
a list. Thus, before suspending a process, a programmer must arrange a way for another 
process to find the ID of the suspended process so it can be resumed.
6.10 The Value Returned By Suspend
Suspend, like resume, returns the priority of the suspended process to its caller. In 
the case of a ready process, the value returned will reflect the priority the process had 
when suspend was called. (Once suspend disables interrupts, no other process can 
change priorities in the system, so the priority can be recorded at any time before 
suspend restores interrupts.) In the case of the current process, however, a question 
arises: should suspend return the priority that was in effect when suspend was invoked 
or the priority the process has after the process has been resumed (i.e., when suspend re-
turns)? The two values can differ because it is possible to change the priority of a proc-
ess at any time, which means the priority can change while the process is suspended. In 
terms of the code, the question is whether the local copy of the priority should be 
recorded before the call to resched or afterward (the version above records it afterward).
To understand one possible motivation for returning the priority at the time of 
resumption, consider how the priority can be used to convey information. Suppose, for 
example, that a process needs to suspend until one of two events occurs. A programmer 
can assign a unique priority value to each event (e.g., priorities 25 and 26), and arrange 
the calls to resume to set the priority accordingly. The process can then use the priority 
to determine why it was resumed:

108 
More Process Management 
Chap. 6
nneewwpprriioo == ssuussppeenndd(( ggeettppiidd(()) ));;
iiff ((nneewwpprriioo ==== 2255)) {{
...... EEvveenntt 11 hhaass ooccccuurrrreedd ......
}} eellssee {{ 
...... EEvveenntt 22 hhaass ooccccuurrrreedd ......
}}
6.11 Process Termination And Process Exit
Although it freezes a process temporarily, suspend saves information about a proc-
ess so the process can be resumed later. Another system call, kill, implements process 
termination by completely removing a process from the system. Once it has been 
killed, a process cannot be restarted because kill eradicates the entire record and frees 
the process table entry for reuse by a new process.
The actions taken by kill depend on the process state. Before writing the code, a 
designer needs to consider each possible process state and what it means to terminate a 
process in that state. We will see, for example, that a process in the ready, sleeping, or 
waiting states is stored on one of the linked lists in the queue structure, which means 
kill must dequeue the process. In the next chapter, we will see that if a process is wait-
ing for a semaphore, kill must adjust the semaphore count. Each of the cases will be-
come clear once we have examined the process state and the functions that control the 
state. For now, it is sufficient to understand the overall structure of kill and see how it 
handles processes that are current or ready. The code for kill appears in file kill.c.
Kill checks its argument, pid, to ensure that it corresponds to a valid process other 
than the null process (the null process cannot be killed because it must remain running). 
Kill then decrements prcount, a global variable that records the number of active user 
processes, and calls function freestk to free memory that has been allocated for the 
process’s stack. The remaining actions depend on the process’s state. For a process 
that is in the ready state, kill removes the process from the ready list and then frees the 
process table entry by assigning value PR_FREE to the process’s state. Because it no 
longer appears on the ready list, the process will not be selected for rescheduling; be-
cause it has state PR_FREE, the entry in the process table can be reused.
Now consider what happens when kill needs to terminate the currently executing 
process. We say that the process exits. As before, kill validates its argument and decre-
ments the count of active processes. If the current process happens to be the last user 
process, decrementing prcount makes it zero, so kill calls function xdone, which is ex-
plained below. Because resched uses an implicit argument to control disposition of the 
current process, kill must set the current process’s state to the desired state before cal-
ling resched. To remove the current process from the system, kill sets the current 
process’s state to PR_FREE, meaning that the process table slot is unused, and then 
calls resched.

Sec. 6.11        Process Termination And Process Exit 
109
//** kkiillll..cc -- kkiillll **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
kkiillll
--
KKiillll aa pprroocceessss aanndd rreemmoovvee iitt ffrroomm tthhee ssyysstteemm
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll kkiillll((
ppiidd3322
ppiidd
//** IIDD ooff pprroocceessss ttoo kkiillll
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pprroocceenntt **pprrppttrr;;
//** PPttrr ttoo pprroocceessss’’ ttaabbllee eennttrryy
**//
iinntt3322
ii;;
//** IInnddeexx iinnttoo ddeessccrriippttoorrss
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddppiidd((ppiidd)) |||| ((ppiidd ==== NNUULLLLPPRROOCC))
|||| ((((pprrppttrr == &&pprrooccttaabb[[ppiidd]]))-->>pprrssttaattee)) ==== PPRR__FFRREEEE)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
iiff ((----pprrccoouunntt <<== 11)) {{
//** LLaasstt uusseerr pprroocceessss ccoommpplleetteess
**//
xxddoonnee(());;
}} 
sseenndd((pprrppttrr-->>pprrppaarreenntt,, ppiidd));;
ffoorr ((ii==00;; ii<<33;; ii++++)) {{
cclloossee((pprrppttrr-->>pprrddeesscc[[ii]]));;
}} 
ffrreeeessttkk((pprrppttrr-->>pprrssttkkbbaassee,, pprrppttrr-->>pprrssttkklleenn));;
sswwiittcchh ((pprrppttrr-->>pprrssttaattee)) {{
ccaassee PPRR__CCUURRRR::
pprrppttrr-->>pprrssttaattee == PPRR__FFRREEEE;;
//** SSuuiicciiddee **//
rreesscchheedd(());;
ccaassee PPRR__SSLLEEEEPP::
ccaassee PPRR__RREECCTTIIMM::
uunnsslleeeepp((ppiidd));;
pprrppttrr-->>pprrssttaattee == PPRR__FFRREEEE;;
bbrreeaakk;;
ccaassee PPRR__WWAAIITT::

110 
More Process Management 
Chap. 6
sseemmttaabb[[pprrppttrr-->>pprrsseemm]]..ssccoouunntt++++;;
//** FFaallll tthhrroouugghh **//
ccaassee PPRR__RREEAADDYY::
ggeettiitteemm((ppiidd));;
//** RReemmoovvee ffrroomm qquueeuuee **//
//** FFaallll tthhrroouugghh **//
ddeeffaauulltt::
pprrppttrr-->>pprrssttaattee == PPRR__FFRREEEE;;
}} 
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}
When the last user process exits, kill calls xdone. In some systems, xdone powers
down the device. In others, xdone restarts the device. In our example, xdone merely
prints a message on the console, and halts the processor. The code is found in file
xdone.c.
//** xxddoonnee..cc -- xxddoonnee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
xxddoonnee
--
PPrriinntt ssyysstteemm ccoommpplleettiioonn mmeessssaaggee aass llaasstt pprroocceessss eexxiittss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
xxddoonnee((vvooiidd))
{{
kkpprriinnttff((""\\nn\\nnAAllll uusseerr pprroocceesssseess hhaavvee ccoommpplleetteedd..\\nn\\nn""));;
hhaalltt(());;
//** HHaalltt tthhee pprroocceessssoorr
**//
}}
Why should kill invoke function xdone? Doing so may seem unnecessary because
the code is trivial and could easily be incorporated into kill itself. The motivation for
using a function stems from a desire to separate functionality: a programmer can change 
the action taken when all processes exit without modifying kill.
A more serious question arises because xdone is invoked before the last user proc-
ess has been removed from the system. To understand the problem, consider a fault-
tolerant design that restarts processes in the case all processes exit. With the current 
implementation, one of the process table slots remains in use when xdone is called. The 
exercises consider an alternative implementation.

Sec. 6.12        Process Creation 
111
6.12 Process Creation
As we have seen, processes are dynamic — a process can be created at any time.
The system call create starts a new, independent process. In essence, create builds an
image of the process as if it had been stopped while running. Once the image has been 
constructed and the process has been placed on the ready list, ctxsw can switch to it.
A look at the code in file create.c explains most of the details.  Create uses func-
tion newpid to search the process table for a free (i.e., unused) slot. Once a slot has 
been found, create allocates space for the new process’s stack, and fills in the process 
table entry. Create calls getstk to allocate space for a stack (Chapter 9 discusses
memory allocation).
The first argument to create specifies the initial function at which the process
should start execution. Create forms a saved environment on the process’s stack as if
the specified function had been called. Consequently, we refer to the initial config-
uration as a pseudo call. To build a pseudo call, create stores initial values for the re-
gisters, including the stack pointer and a return address in the pseudo-call on the 
process’s stack. When ctxsw switches to it, the new process begins executing the code 
for the designated function, obeying the normal calling conventions for accessing argu-
ments and allocating local variables. In short, the initial function for a process behaves 
exactly as if it had been called.
What value should create use as a return address in the pseudo call? The value 
determines what action the system will take if a process returns from its initial (i.e.,
top-level) function. Our example system follows a well-known paradigm:
If a process returns from the initial (top-level) function in which its 
execution started, the process exits.
To be precise, we should distinguish between a return from the function itself and
a return from the initial call. To see why, observe that C permits recursive function
calls. Thus, if a process begins in function X which recursively calls X, the first return 
merely pops one level of recursion and returns to the initial call without causing the 
process to exit. If the process returns again (or reaches the end of X) without making 
further calls, the process will exit.
To arrange for an exit to occur when the initial call returns, create assigns the ad-
dress of function userret as the return address in the pseudo call. The code uses sym-
bolic constant INITRET, which has been defined to be function name userret.† If dur-
ing the initial call the process reaches the end of the function or explicitly invokes re-
turn, control will pass to userret. Function userret terminates the current process by 
calling kill.
Create also fills in the process table entry. In particular, create makes the state of 
the newly created process PR_SUSP, leaving it suspended, but otherwise ready to run. 
Finally, create returns the process ID of the newly created process; the process must be 
resumed before it can execute.

†Using a symbolic constant allows the choice to be overridden in a configuration file rather than requir-
ing the code to be changed.

112 
More Process Management 
Chap. 6
Many of the process initialization details depend on the C runtime environment as 
well as the calling conventions — one cannot write the code to start a process without 
understanding the details. For example, on an x86 platform, create arranges for argu-
ments to be placed on the runtime stack; on an ARM platform, create places some argu-
ments in registers and others on the stack. The code that pushes arguments may be dif-
ficult to understand because create copies the arguments directly from its own runtime 
stack onto the stack that it has allocated for the new process. To do so, it finds the ad-
dress of the arguments on its own stack and moves through the list using pointer arith-
metic. The following example shows how create forms the stack on an x86 platform.
//** ccrreeaattee..cc -- ccrreeaattee,, nneewwppiidd **//
##iinncclluuddee <<xxiinnuu..hh>>
llooccaall
iinntt nneewwppiidd(());;
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ccrreeaattee
--
CCrreeaattee aa pprroocceessss ttoo ssttaarrtt rruunnnniinngg aa ffuunnccttiioonn oonn xx8866
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ppiidd3322
ccrreeaattee((
vvooiidd
**ffuunnccaaddddrr,,
//** AAddddrreessss ooff tthhee ffuunnccttiioonn
**//
uuiinntt3322
ssssiizzee,,
//** SSttaacckk ssiizzee iinn wwoorrddss
**//
pprrii1166
pprriioorriittyy,,
//** PPrroocceessss pprriioorriittyy >> 00
**//
cchhaarr
**nnaammee,,
//** NNaammee ((ffoorr ddeebbuuggggiinngg))
**//
uuiinntt3322
nnaarrggss,,
//** NNuummbbeerr ooff aarrggss tthhaatt ffoollllooww
**//
......
))
{{
uuiinntt3322
ssaavvsspp,, **ppuusshhsspp;;
iinnttmmaasskk
mmaasskk;;
//** IInntteerrrruupptt mmaasskk
**//
ppiidd3322
ppiidd;;
//** SSttoorreess nneeww pprroocceessss iidd
**//
ssttrruucctt
pprroocceenntt **pprrppttrr;;
//** PPooiinntteerr ttoo pprroocc.. ttaabbllee eennttrryy **//
iinntt3322
ii;;
uuiinntt3322
**aa;;
//** PPooiinnttss ttoo lliisstt ooff aarrggss
**//
uuiinntt3322
**ssaaddddrr;;
//** SSttaacckk aaddddrreessss
**//
mmaasskk == ddiissaabbllee(());;
iiff ((ssssiizzee << MMIINNSSTTKK))
ssssiizzee == MMIINNSSTTKK;;
ssssiizzee == ((uuiinntt3322)) rroouunnddmmbb((ssssiizzee));;
iiff (( ((pprriioorriittyy << 11)) |||| ((((ppiidd==nneewwppiidd(()))) ==== SSYYSSEERRRR)) ||||
((((ssaaddddrr == ((uuiinntt3322 **))ggeettssttkk((ssssiizzee)))) ==== ((uuiinntt3322 **))SSYYSSEERRRR)) )) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}}

Sec. 6.12        Process Creation 
113
pprrccoouunntt++++;;
pprrppttrr == &&pprrooccttaabb[[ppiidd]];;
//** IInniittiiaalliizzee pprroocceessss ttaabbllee eennttrryy ffoorr nneeww pprroocceessss **//
pprrppttrr-->>pprrssttaattee == PPRR__SSUUSSPP;;
//** IInniittiiaall ssttaattee iiss ssuussppeennddeedd
**//
pprrppttrr-->>pprrpprriioo == pprriioorriittyy;;
pprrppttrr-->>pprrssttkkbbaassee == ((cchhaarr **))ssaaddddrr;;
pprrppttrr-->>pprrssttkklleenn == ssssiizzee;;
pprrppttrr-->>pprrnnaammee[[PPNNMMLLEENN--11]] == NNUULLLLCCHH;;
ffoorr ((ii==00 ;; ii<<PPNNMMLLEENN--11 &&&& ((pprrppttrr-->>pprrnnaammee[[ii]]==nnaammee[[ii]]))!!==NNUULLLLCCHH;; ii++++))
;;
pprrppttrr-->>pprrsseemm == --11;;
pprrppttrr-->>pprrppaarreenntt == ((ppiidd3322))ggeettppiidd(());;
pprrppttrr-->>pprrhhaassmmssgg == FFAALLSSEE;;
//** SSeett uupp ssttddiinn,, ssttddoouutt,, aanndd ssttddeerrrr ddeessccrriippttoorrss ffoorr tthhee sshheellll
**//
pprrppttrr-->>pprrddeesscc[[00]] == CCOONNSSOOLLEE;;
pprrppttrr-->>pprrddeesscc[[11]] == CCOONNSSOOLLEE;;
pprrppttrr-->>pprrddeesscc[[22]] == CCOONNSSOOLLEE;;
//** IInniittiiaalliizzee ssttaacckk aass iiff tthhee pprroocceessss wwaass ccaalllleedd
**//
**ssaaddddrr == SSTTAACCKKMMAAGGIICC;;
ssaavvsspp == ((uuiinntt3322))ssaaddddrr;;
//** PPuusshh aarrgguummeennttss **//
aa == ((uuiinntt3322 **))((&&nnaarrggss ++ 11));;
//** SSttaarrtt ooff aarrggss
**//
aa ++== nnaarrggss --11;;
//** LLaasstt aarrgguummeenntt
**//
ffoorr (( ;; nnaarrggss >> 00 ;; nnaarrggss----))
//** MMaacchhiinnee ddeeppeennddeenntt;; ccooppyy aarrggss **//
**----ssaaddddrr == **aa----;;
//**
oonnttoo ccrreeaatteedd pprroocceessss’’ ssttaacckk**//
**----ssaaddddrr == ((lloonngg))IINNIITTRREETT;;
//** PPuusshh oonn rreettuurrnn aaddddrreessss
**//
//** TThhee ffoolllloowwiinngg eennttrriieess oonn tthhee ssttaacckk mmuusstt mmaattcchh wwhhaatt ccttxxssww
**//
//**
eexxppeeccttss aa ssaavveedd pprroocceessss ssttaattee ttoo ccoonnttaaiinn:: rreett aaddddrreessss,,
**//
//**
eebbpp,, iinntteerrrruupptt mmaasskk,, ffllaaggss,, rreeggiisstteerrss,, aanndd aann oolldd SSPP
**//
**----ssaaddddrr == ((lloonngg))ffuunnccaaddddrr;;
//** MMaakkee tthhee ssttaacckk llooookk lliikkee iitt’’ss**//
//**
hhaallff--wwaayy tthhrroouugghh aa ccaallll ttoo **//
//**
ccttxxssww tthhaatt ""rreettuurrnnss"" ttoo tthhee**//
//**
nneeww pprroocceessss
**//
**----ssaaddddrr == ssaavvsspp;;
//** TThhiiss wwiillll bbee rreeggiisstteerr eebbpp
**//
//**
ffoorr pprroocceessss eexxiitt
**//
ssaavvsspp == ((uuiinntt3322)) ssaaddddrr;;
//** SSttaarrtt ooff ffrraammee ffoorr ccttxxssww
**//
**----ssaaddddrr == 00xx0000000000220000;;
//** NNeeww pprroocceessss rruunnss wwiitthh
**//
//**
iinntteerrrruuppttss eennaabblleedd
**//

114 
More Process Management 
Chap. 6
//** BBaassiiccaallllyy,, tthhee ffoolllloowwiinngg eemmuullaatteess aann xx8866 ""ppuusshhaall"" iinnssttrruuccttiioonn**//
**----ssaaddddrr == 00;;
//** %%eeaaxx **//
**----ssaaddddrr == 00;;
//** %%eeccxx **//
**----ssaaddddrr == 00;;
//** %%eeddxx **//
**----ssaaddddrr == 00;;
//** %%eebbxx **//
**----ssaaddddrr == 00;;
//** %%eesspp;; vvaalluuee ffiilllleedd iinn bbeellooww
**//
ppuusshhsspp == ssaaddddrr;;
//** RReemmeemmbbeerr tthhiiss llooccaattiioonn
**//
**----ssaaddddrr == ssaavvsspp;;
//** %%eebbpp ((wwhhiillee ffiinniisshhiinngg ccttxxssww)) **//
**----ssaaddddrr == 00;;
//** %%eessii **//
**----ssaaddddrr == 00;;
//** %%eeddii **//
**ppuusshhsspp == ((uunnssiiggnneedd lloonngg)) ((pprrppttrr-->>pprrssttkkppttrr == ((cchhaarr **))ssaaddddrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn ppiidd;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
nneewwppiidd
--
OObbttaaiinn aa nneeww ((ffrreeee)) pprroocceessss IIDD
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
llooccaall
ppiidd3322
nneewwppiidd((vvooiidd))
{{
uuiinntt3322
ii;;
//** IItteerraattee tthhrroouugghh aallll pprroocceesssseess**//
ssttaattiicc
ppiidd3322 nneexxttppiidd == 11;;
//** PPoossiittiioonn iinn ttaabbllee ttoo ttrryy oorr
**//
//**
oonnee bbeeyyoonndd eenndd ooff ttaabbllee
**//
//** CChheecckk aallll NNPPRROOCC sslloottss **//
ffoorr ((ii == 00;; ii << NNPPRROOCC;; ii++++)) {{
nneexxttppiidd %%== NNPPRROOCC;;
//** WWrraapp aarroouunndd ttoo bbeeggiinnnniinngg **//
iiff ((pprrooccttaabb[[nneexxttppiidd]]..pprrssttaattee ==== PPRR__FFRREEEE)) {{
rreettuurrnn nneexxttppiidd++++;;
}} eellssee {{
nneexxttppiidd++++;;
}}
}} 
rreettuurrnn ((ppiidd3322)) SSYYSSEERRRR;;
}}
As described above, create arranges for a process to invoke function userret if the 
process returns from the top-level function. In fact, create stores the address of userret
in the stack location where a return address would normally appear (using the symbolic 
constant INITRET). Placing the address of a function in the return address field is al-
lowed because a function return merely jumps to the address. File userret.c contains 
the code.

Sec. 6.12        Process Creation 
115
//** uusseerrrreett..cc -- uusseerrrreett **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
uusseerrrreett
--
CCaalllleedd wwhheenn aa pprroocceessss rreettuurrnnss ffrroomm tthhee ttoopp--lleevveell ffuunnccttiioonn
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
uusseerrrreett((vvooiidd))
{{
kkiillll((ggeettppiidd(())));;
//** FFoorrccee pprroocceessss ttoo eexxiitt **//
}}
Create introduces an initial transition in the state diagram: a newly created process
starts in the suspended state. Figure 6.3 illustrates the augmented state diagram.
READY
CURRENT
resched
resched
SUSPENDED
suspend
resume
suspend
create
Figure 6.3 The state diagram showing an initial transition to the suspended
state.
6.13 Other Process Manager Functions
Three additional system calls help manage processes: getpid, getprio, and chprio. 
As we have seen, getpid allows the current process to obtain its process ID, and getprio 
allows a caller to obtain the scheduling priority of an arbitrary process. Another useful 
system call, chprio, allows a process to change the priority of an arbitrary process. The 
implementation of each of the three functions appears to be completely straightforward. 
For example, consider the code for getprio. After checking its argument, getprio ex-

116 
More Process Management 
Chap. 6
tracts the scheduling priority for the specified process from the process table entry, and 
returns the priority to the caller.
//** ggeettpprriioo..cc -- ggeettpprriioo **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ggeettpprriioo
--
RReettuurrnn tthhee sscchheedduulliinngg pprriioorriittyy ooff aa pprroocceessss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll ggeettpprriioo((
ppiidd3322
ppiidd
//** PPrroocceessss IIDD
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
uuiinntt3322
pprriioo;;
//** PPrriioorriittyy ttoo rreettuurrnn
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddppiidd((ppiidd)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
pprriioo == pprrooccttaabb[[ppiidd]]..pprrpprriioo;;
rreessttoorree((mmaasskk));;
rreettuurrnn pprriioo;;
}}
Because global variable currpid contains the ID of the currently executing process,
the code for getpid is trivial:
//** ggeettppiidd..cc -- ggeettppiidd **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ggeettppiidd
--
RReettuurrnn tthhee IIDD ooff tthhee ccuurrrreennttllyy eexxeeccuuttiinngg pprroocceessss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ppiidd3322
ggeettppiidd((vvooiidd))
{{
rreettuurrnn ((ccuurrrrppiidd));;
}}

Sec. 6.13        Other Process Manager Functions 
117
Function chprio allows the scheduling priority of any process to be changed. The
code is found in chprio.c.
//** cchhpprriioo..cc -- cchhpprriioo **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
cchhpprriioo
--
CChhaannggee tthhee sscchheedduulliinngg pprriioorriittyy ooff aa pprroocceessss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
pprrii1166
cchhpprriioo((
ppiidd3322
ppiidd,,
//** IIDD ooff pprroocceessss ttoo cchhaannggee
**//
pprrii1166
nneewwpprriioo
//** NNeeww pprriioorriittyy
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pprroocceenntt **pprrppttrr;;
//** PPttrr ttoo pprroocceessss’’ ttaabbllee eennttrryy
**//
pprrii1166
oollddpprriioo;;
//** PPrriioorriittyy ttoo rreettuurrnn
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddppiidd((ppiidd)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn ((pprrii1166)) SSYYSSEERRRR;;
}} 
pprrppttrr == &&pprrooccttaabb[[ppiidd]];;
oollddpprriioo == pprrppttrr-->>pprrpprriioo;;
pprrppttrr-->>pprrpprriioo == nneewwpprriioo;;
rreessttoorree((mmaasskk));;
rreettuurrnn oollddpprriioo;;
}}
The implementation of chprio seems to do exactly what is needed. It checks to be 
sure the specified process exists before changing the priority field in its process table 
entry. As the exercises point out, however, the code contains two omissions.
6.14 Summary
The chapter expands the support for concurrent execution by adding a layer of 
process management software on top of a scheduler and context switch. The new layer 
includes routines to suspend and resume execution as well as routines that create a new 
process or kill an existing process. The chapter also examines three additional functions 
that obtain the ID of the current process (getpid), the scheduling priority of the current

118 
More Process Management 
Chap. 6
process (getprio), or change the scheduling priority of an arbitrary process (chprio). 
Despite its brevity, the code built thus far forms the basis of a process manager. With 
proper initialization and support routines, our basic process manager can multiplex a 
processor among multiple concurrent computations.
Function create forms a new process, and leaves the process in the suspended state. 
Create allocates a stack for the new process, and places values on the stack and in the 
process table such that ctxsw can switch to the process and begin execution. The initial 
values are arranged in a pseudo call, as if the process was called from userret. If the 
process returns from its top-level function, control passes to userret, which calls kill to 
terminate the process.
EXERCISES
6.1 
As the text suggests, a process can tell which of several events triggered resumption if its
priority is set to a unique value for each separate call to resume. Use the method to create
a process that suspends itself and determines which of two other processes resumes it first.
6.2    Suppose a system contains three processes, A, B, and C, with equal priority. If process A is
executing and suspends C, which process will run? Explain.
6.3    Suppose a system contains three processes, A, B, and C, priorities 20, 20, and 10, and proc-
ess C has been suspended. If process A is executing and resumes process C, which process
will run? Why?
6.4 
Why does create build a pseudo-call that returns to userret at process exit instead of one
that calls kill directly?
6.5  Global variable prcount tells the number of active user processes. Carefully consider the
code in kill and tell whether the count in prcount includes the null process?
6.6 
When a process kills itself, kill deallocates the stack and then calls resched, which means
the process continues to use the deallocated stack. Redesign the system so a current proc-
ess does not deallocate its own stack, but instead moves to a new state, PR_DYING. Ar-
range for whatever process searches the process table to look for dying processes, free the 
stack, and move the entry to PR_FREE.
6.7  As the text mentions, kill calls xdone before the last process has been terminated. Change
the system so the null process continuously monitors the count of user processes and calls 
xdone when all processes complete.
6.8 
In the previous exercise, what restrictions does the new implementation impose on xdone
that were not in the current implementation?
6.9    Some hardware architectures use a special instruction to allow an application program to in-
voke a system call. Investigate such an architecture, and describe exactly how a system
call passes to the correct operating system function.
6.10  Create leaves the new process suspended instead of running. Why?
6.11 Function resume saves the resumed process’s priority in a local variable before calling
ready. Show that if it references prptr->prprio after the call to ready, resume can return a 
priority value that the resumed process never had (not even after resumption).

Exercises
119
6.12 In function newpid, variable nextpid is a static integer that tells the next process table slot
to check for a free one. Starting the search from where it left off eliminates looking past
the used slots again and again. Speculate on whether the technique is worthwhile in an em-
bedded system.
6.13  Function chprio contains two design flaws. The first arises because the code does not en-
sure that the new priority value is a positive integer. Describe what can happen if the prior-
ity of a process is set to –1.
6.14 The second design flaw in chprio violates a fundamental design principle. Identify the
flaw, describe its consequences, and repair it.
6.15 In addition to the functionality discussed in the chapter, system calls are also responsible
for enforcing system security policies. Choose an operating system and find out how sys-
tem calls enforce security.


Chapter Contents
7.1 
Introduction, 123
7.2 
The Need For Synchronization, 123
7.3 
A Conceptual View Of Counting Semaphores, 125
7.4 
Avoidance Of Busy Waiting, 125
7.5 
Semaphore Policy And Process Selection, 126
7.6 
The Waiting State, 127
7.7 
Semaphore Data Structures, 128
7.8 
The Wait System Call, 129
7.9 
The Signal System Call, 130
7.10 
Static And Dynamic Semaphore Allocation, 131
7.11 
Example Implementation Of Dynamic Semaphores, 132
7.12 
Semaphore Deletion, 133
7.13 
Semaphore Reset, 135
7.14 
Coordination Across Parallel Processors (Multicore), 136
7.15 
Perspective, 137
7.16 
Summary, 137


7
Coordination Of Concurrent 
Processes
The future belongs to him who knows how to wait.
— Russian Proverb
7.1 Introduction
Previous chapters introduce pieces of a process manager, including scheduling, 
context switching, and functions that create and terminate processes. This chapter con-
tinues the exploration of process management by discussing functions that a set of 
processes can use to coordinate and synchronize their actions. The chapter explains the 
motivation for such primitives and their implementation. The chapter also considers 
coordination of multiple processors, such as those on a multicore chip.
The next chapter extends our discussion of a process manager by describing a 
low-level message passing mechanism. Later chapters show how synchronization func-
tions are used to perform I/O.
7.2 The Need For Synchronization
Because they execute concurrently, processes need to cooperate when sharing glo-
bal resources. In particular, an operating system designer must ensure that only one 
process attempts to change a given variable at any time. For example, consider the 
process table. When a new process is created, a slot in the table must be allocated and
123

124 
Coordination Of Concurrent Processes 
Chap. 7
values inserted. If two processes each attempt to create a new process, the system must 
guarantee that only one of them can execute create at a given time, or errors can result.
The previous chapter illustrates one approach system functions can take to guaran-
tee that no other process interferes with them: a function disables interrupts and avoids 
using any functions that call resched. Indeed, system calls such as suspend, resume, 
create, and kill each use the approach.
Why not use the same solution whenever a process needs to guarantee non-
interference? The answer is that disabling interrupts has an undesirable global effect on
all parts of the system: it stops all activity except for one process, and limits what the 
process can do. In particular, no I/O can occur while interrupts are disabled. We will 
learn later that disabling interrupts too long can cause problems (e.g., if packets contin-
ue to arrive over a network while interrupts are disabled, the network interface will start 
to discard them). Therefore, we need a general-purpose coordination mechanism that 
permits arbitrary subsets of the processes to coordinate the use of individual data items 
without disabling device interrupts for long periods of time, without interfering with 
processes outside the subset, and without limiting what the running process can do. For 
example, it should be possible for one process to prohibit changes to a large data struc-
ture long enough to format and print the data, without stopping processes that do not 
need to access the data structure. The mechanism should be transparent: a programmer 
should be able to understand the consequences of process coordination. Thus, further 
synchronization mechanisms are needed that:
d Allow a subset of processes to contend for access to a resource
d Provide a policy that guarantees fair access
The first item ensures that coordination is local: instead of disabling all interrupts, 
only those processes contending for a given resource will block waiting for access. 
Other parts of the system can continue to operate unaffected. The second item ensures
that if K processes all attempt to access a given resource, each of the K will eventually 
receive access (i.e., no process is starved).
Chapter 2 introduces the fundamental mechanism that solves the problem: counting 
semaphores. The chapter also provides examples that show how processes use sema-
phores to coordinate. As Chapter 2 indicates, semaphores provide an elegant solution 
for two problems:
d Mutual exclusion
d Producer–consumer interaction
Mutual exclusion. The term mutual exclusion is used to describe a situation where 
a set of processes needs to guarantee that only one of them operates at a given time. 
Mutual exclusion includes access to shared data, but can also include access to an arbi-
trary shared resource, such as an I/O device.

Sec. 7.2        The Need For Synchronization 
125
Producer–consumer interaction. We use the term producer–consumer interaction 
to refer to a situation where processes exchange data items. In the simplest form, one 
process acts as a producer by generating a sequence of data items, and another process 
acts as a consumer by accepting the data items. In more complex forms, one or more 
processes can act as producers and one or more processes can act as consumers. The 
key to coordinating the interaction is that each item produced must be received by ex-
actly one consumer (i.e., no items are lost and no items are duplicated).
Both forms of process coordination arise throughout an operating system. For ex-
ample, consider a set of applications that are producing messages to be displayed on the 
console. The console device software must coordinate processes to ensure that charac-
ters do not arrive faster than the hardware can display them. Outgoing characters can 
be placed in a buffer in memory. Once the buffer fills, the producer must be blocked 
until space becomes available. Similarly, if the buffer becomes empty, the device stops 
sending characters. The key idea is that a producer must be blocked when the consumer 
is not ready to receive data, and a consumer must be blocked when a producer is not 
ready to send data.
7.3 A Conceptual View Of Counting Semaphores
A counting semaphore mechanism that solves both problems described above has a 
surprisingly elegant implementation. Conceptually, a semaphore, s, consists of an in-
teger count and a set of blocked processes. Once a semaphore has been created,
processes use two functions, wait and signal, to operate on the semaphore. A process 
calls wait(s) to decrement the count of semaphore s, and signal(s) to increment the 
count. If the semaphore count becomes negative when a process executes wait(s), the 
process is temporarily blocked and placed in the semaphore’s set of blocked processes. 
From the point of view of the process, the call to wait does not return for a while. A 
blocked process becomes ready to run again when another process calls signal to incre-
ment the semaphore count. That is, if any processes are blocked waiting for a sema-
phore when signal is called, one of the blocked processes will be made ready and al-
lowed to execute. Of course, a programmer must use semaphores with caution: if no 
process ever signals the semaphore, the blocked processes will wait forever.
7.4 Avoidance Of Busy Waiting
What should a process do while waiting on a semaphore? It might seem that after 
it decrements the semaphore count, a process could repeatedly test the count until the 
value becomes positive. On a single processor system, however, such busy waiting is 
unacceptable because other processes will be deprived of the processor. If no other 
process receives processor service, no process can call signal to terminate the wait. 
Therefore, operating systems avoid busy waiting. Instead, semaphore implementations 
follow an important principle:

126 
Coordination Of Concurrent Processes 
Chap. 7
While a process waits on a semaphore, the process does not execute 
instructions.
7.5 Semaphore Policy And Process Selection
To implement semaphores without busy waiting, an operating system associates a 
process list with each semaphore. Only the current process can choose to wait on a 
semaphore. When a process waits on semaphore s, the system decrements the count as-
sociated with s. If the count becomes negative, the process must be blocked. To block 
a process, the system places the process on the list associated with the semaphore, 
changes the state so the process is no longer current, and calls resched to allow other 
processes to run.
Later, when signal is called on semaphore s, the semaphore count is incremented.
In addition, the signal examines the process list associated with s. If the list is not emp-
ty (i.e., at least one process is waiting on the semaphore), signal extracts a process from
the list and moves the process back to the ready list.
A question arises: if multiple processes are waiting, which one should signal
select? Several policies have been used:
d Highest scheduling priority
d First-come-first-served (longest waiting time)
d Random
Although it may seem reasonable, selecting the highest priority waiting process 
violates the principle of fairness. To see why, consider a set of low-priority and high-
priority processes that are using a mutual exclusion semaphore. Suppose each process 
repeatedly waits on the semaphore, uses the resource, and signals the semaphore. If the 
semaphore system always selects a high-priority process and the scheduling policy al-
ways gives the processor to high-priority processes, the low-priority processes can be 
blocked forever while high-priority processes continue to gain access.
To avoid unfairness, many implementations choose a first-come-first-served policy:
if processes are waiting, the system always chooses the process that has been waiting
the longest. The implementation of a first-come-first-served policy is both elegant and 
efficient: the system creates a FIFO queue for each semaphore, and uses the queue to 
store processes that are waiting. When it needs to block a process, wait inserts the 
process at the tail; when it needs to unblock a process, signal extracts a process from 
the head.
A first-come-first-served policy can lead to a priority inversion in the sense that a 
high-priority process can be blocked on a semaphore while a low-priority process exe-
cutes. In addition, it can lead to a synchronization problem discussed in an exercise. 
One alternative consists of choosing among waiting processes at random. The chief 
disadvantage of random selection lies in computational overhead (e.g., random number 
generation).

Sec. 7.5        Semaphore Policy And Process Selection 
127
After considering the advantages and disadvantages of various schemes, we chose
a first-come-first-served policy for Xinu:
Xinu semaphore process selection policy: if one or more processes are 
waiting for semaphore s when a signal operation occurs for s, the 
process that has been waiting the longest becomes ready.
7.6 The Waiting State
In what state should a process be placed while it is waiting for a semaphore? Be-
cause it is neither using the processor nor eligible to run, the process is neither current 
nor ready. The suspended state, introduced in the previous chapter cannot be used be-
cause functions suspend and resume, which move processes in and out of the suspended 
state, have no connection with semaphores. More important, processes waiting for 
semaphores appear on a list, but suspended processes do not — kill must distinguish the 
two cases when terminating a process. Because existing states do not adequately en-
compass processes waiting on a semaphore, a new state must be invented. We call the 
new state waiting, and use symbolic constant PR_WAIT in the code. Figure 7.1 shows 
the expanded state transition diagram.
READY
CURRENT
resched
resched
SUSPENDED
suspend
resume
suspend
create
WAITING
wait
signal
Figure 7.1  State transitions including the waiting state.

128 
Coordination Of Concurrent Processes 
Chap. 7
7.7 Semaphore Data Structures
The example system stores semaphore information in a global semaphore table, 
semtab. Each entry in semtab corresponds to one semaphore. An entry contains an in-
teger count for the semaphore, and the ID of a queue that can be used to hold waiting 
processes. The definition of an entry is given by structure sentry. File semaphore.h 
contains the details.
//** sseemmaapphhoorree..hh -- iissbbaaddsseemm **//
##iiffnnddeeff NNSSEEMM
##ddeeffiinnee NNSSEEMM
112200
//** NNuummbbeerr ooff sseemmaapphhoorreess,, iiff nnoott ddeeffiinneedd **//
##eennddiiff
//** SSeemmaapphhoorree ssttaattee ddeeffiinniittiioonnss **//
##ddeeffiinnee SS__FFRREEEE
00
//** SSeemmaapphhoorree ttaabbllee eennttrryy iiss aavvaaiillaabbllee
**//
##ddeeffiinnee SS__UUSSEEDD
11
//** SSeemmaapphhoorree ttaabbllee eennttrryy iiss iinn uussee
**//
//** SSeemmaapphhoorree ttaabbllee eennttrryy **//
ssttrruucctt
sseennttrryy
{{
bbyyttee
ssssttaattee;;
//** WWhheetthheerr eennttrryy iiss SS__FFRREEEE oorr SS__UUSSEEDD
**//
iinntt3322
ssccoouunntt;;
//** CCoouunntt ffoorr tthhee sseemmaapphhoorree
**//
qqiidd1166
ssqquueeuuee;;
//** QQuueeuuee ooff pprroocceesssseess tthhaatt aarree wwaaiittiinngg
**//
//**
oonn tthhee sseemmaapphhoorree
**//
}};;
eexxtteerrnn
ssttrruucctt
sseennttrryy sseemmttaabb[[]];;
##ddeeffiinnee iissbbaaddsseemm((ss))
((((iinntt3322))((ss)) << 00 |||| ((ss)) >>== NNSSEEMM))
In structure sentry, field scount contains the current integer count of the sema-
phore. The list of processes waiting for a semaphore resides in the queue structure, and 
field squeue gives the index of the head of the list for a given semaphore. The state 
field, sstate, tells whether the entry is currently used (i.e., allocated) or free (currently 
unallocated).
Throughout the system, semaphores are identified by an integer ID. As with other 
identification values, semaphore IDs are assigned to make lookup efficient: the sema-
phore table is an array, and each ID is an index in the array. To summarize:
A semaphore is identified by its index in the global semaphore table, 
semtab.

Sec. 7.7        Semaphore Data Structures 
129
7.8 The Wait System Call
Recall that the two primary operations on a semaphore are wait and signal.  Wait 
decrements the count of a semaphore. If the count remains nonnegative, wait returns to
the caller immediately. In essence, a process executing wait on a semaphore with a 
nonpositive count voluntarily gives up control of the processor. That is, wait enqueues 
the calling process on the list for the semaphore, changes the process state to PR_WAIT, 
and calls resched to switch to a ready process. Also recall that our policy maintains the 
list of processes as a FIFO queue, which means a new process is inserted at the tail of a 
list. File wait.c contains the code.
//** wwaaiitt..cc -- wwaaiitt **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
wwaaiitt
--
CCaauussee ccuurrrreenntt pprroocceessss ttoo wwaaiitt oonn aa sseemmaapphhoorree
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll wwaaiitt((
ssiidd3322
sseemm
//** SSeemmaapphhoorree oonn wwhhiicchh ttoo wwaaiitt
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pprroocceenntt **pprrppttrr;;
//** PPttrr ttoo pprroocceessss’’ ttaabbllee eennttrryy
**//
ssttrruucctt
sseennttrryy **sseemmppttrr;;
//** PPttrr ttoo sseemmppaahhoorree ttaabbllee eennttrryy **//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddsseemm((sseemm)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
sseemmppttrr == &&sseemmttaabb[[sseemm]];;
iiff ((sseemmppttrr-->>ssssttaattee ==== SS__FFRREEEE)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
iiff ((----((sseemmppttrr-->>ssccoouunntt)) << 00)) {{
//** IIff ccaalllleerr mmuusstt bblloocckk **//
pprrppttrr == &&pprrooccttaabb[[ccuurrrrppiidd]];;
pprrppttrr-->>pprrssttaattee == PPRR__WWAAIITT;;
//** SSeett ssttaattee ttoo wwaaiittiinngg **//
pprrppttrr-->>pprrsseemm == sseemm;;
//** RReeccoorrdd sseemmaapphhoorree IIDD
**//
eennqquueeuuee((ccuurrrrppiidd,,sseemmppttrr-->>ssqquueeuuee));;//** EEnnqquueeuuee oonn sseemmaapphhoorree **//
rreesscchheedd(());;
//**
aanndd rreesscchheedduullee
**//
}}

130 
Coordination Of Concurrent Processes 
Chap. 7
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}
Once enqueued on a semaphore list, a process remains in the waiting state (i.e., not 
eligible to execute) until the process reaches the head of the queue and some other proc-
ess signals the semaphore. When the call to signal moves a waiting process back to the 
ready list, the process becomes eligible to use the processor, and eventually resumes ex-
ecution. From the point of view of the waiting process, its last act consisted of a call to 
ctxsw. When the process restarts, the call to ctxsw returns to resched, the call to 
resched returns to wait, and the call to wait returns to the location from which it was 
called.
7.9 The Signal System Call
Function signal takes a semaphore ID as an argument, increments the count of the 
specified semaphore, and makes the first process ready, if any are waiting. Although it 
may seem difficult to understand why signal makes a process ready even though the 
semaphore count remains negative or why wait does not always enqueue the calling 
process, the reason is both easy to understand and easy to implement.  Wait and signal 
maintain the following invariant regarding the count of a semaphore:
Semaphore invariant: a nonnegative semaphore count means that the 
queue is empty; a semaphore count of negative N means that the 
queue contains N waiting processes.
In essence, a count of positive N means that wait can be called N more times be-
fore any process blocks. Because wait and signal each change the semaphore count,
they must each adjust the queue length to reestablish the invariant. When it decrements 
the count, wait examines the result, and adds the current process to the queue if the new 
count is negative. Because it increments the count, signal examines the queue and re-
moves a process from the queue if the queue is nonempty.
//** ssiiggnnaall..cc -- ssiiggnnaall **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ssiiggnnaall
--
SSiiggnnaall aa sseemmaapphhoorree,, rreelleeaassiinngg aa pprroocceessss iiff oonnee iiss wwaaiittiinngg
**------------------------------------------------------------------------------------------------------------------------------------------------
**//

Sec. 7.9        The Signal System Call 
131
ssyyssccaallll ssiiggnnaall((
ssiidd3322
sseemm
//** IIDD ooff sseemmaapphhoorree ttoo ssiiggnnaall
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
sseennttrryy **sseemmppttrr;;
//** PPttrr ttoo sseemmppaahhoorree ttaabbllee eennttrryy **//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddsseemm((sseemm)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
sseemmppttrr== &&sseemmttaabb[[sseemm]];;
iiff ((sseemmppttrr-->>ssssttaattee ==== SS__FFRREEEE)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
iiff ((((sseemmppttrr-->>ssccoouunntt++++)) << 00)) {{
//** RReelleeaassee aa wwaaiittiinngg pprroocceessss **//
rreeaaddyy((ddeeqquueeuuee((sseemmppttrr-->>ssqquueeuuee))));;
}} 
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}
7.10 Static And Dynamic Semaphore Allocation
An operating system designer must choose between two approaches for semaphore
allocation:
d Static allocation: a programmer defines a fixed set of semaphores
at compile time; the set does not change as the system runs.
d Dynamic allocation: the system includes functions that allow sema-
phores to be created on demand and deallocated when they are no 
longer needed.
The advantage of static allocation lies in saving space and reducing processing 
overhead — the system only contains memory for the needed semaphores, and the sys-
tem does not require functions to allocate or deallocate semaphores. Thus, the smallest 
embedded systems use static allocation.
The chief advantage of dynamic allocation arises from the ability to accommodate 
new uses at runtime. For example, a dynamic allocation scheme allows a user to launch 
an application that allocates a semaphore, terminate the application, and then launch 
another application. Thus, larger embedded systems and most large operating systems 
provide dynamic allocation of resources, including semaphores. The next sections show 
that dynamic allocation does not introduce much additional code.

132 
Coordination Of Concurrent Processes 
Chap. 7
7.11 Example Implementation Of Dynamic Semaphores
Xinu provides a limited form of dynamic allocation: processes can create sema-
phores dynamically, and a given process can create multiple semaphores, provided the 
total number of semaphores allocated simultaneously does not exceed a predefined max-
imum. Furthermore, to minimize the allocation overhead, the system preallocates a list 
in the queue structure for each semaphore when the operating system boots. Thus, only 
a small amount of work needs be done when a process creates a semaphore.
Two system calls, semcreate and semdelete, handle dynamic semaphore allocation
and deallocation. Semcreate takes an initial semaphore count as an argument, allocates
a semaphore, assigns the semaphore the specified count, and returns the semaphore ID.
To preserve the semaphore invariant, the initial count must be nonnegative. Therefore, 
semcreate begins by testing its argument. If the argument is valid, semcreate searches 
the semaphore table, semtab, for an unused entry and initializes the count. To search 
the table, semcreate calls function newsem, which iterates through all NSEM entries of 
the table. If no free entry is found, newsem returns SYSERR. Otherwise, newsem 
changes the state of the entry to S_USED, and returns the table index as the ID.
Once a table entry has been allocated, semcreate only needs to initialize the count 
and return the index of the semaphore to its caller; the head and tail of a queue used to 
store waiting processes have been allocated when the operating system boots. File 
semcreate.c contains the code for function newsem as well as function semcreate. Note 
the use of a static index variable nextsem to optimize searching (i.e., allow a search to 
start where the last search left off).
//** sseemmccrreeaattee..cc -- sseemmccrreeaattee,, nneewwsseemm **//
##iinncclluuddee <<xxiinnuu..hh>>
llooccaall
ssiidd3322
nneewwsseemm((vvooiidd));;
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
sseemmccrreeaattee
--
CCrreeaattee aa nneeww sseemmaapphhoorree aanndd rreettuurrnn tthhee IIDD ttoo tthhee ccaalllleerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssiidd3322
sseemmccrreeaattee((
iinntt3322
ccoouunntt
//** IInniittiiaall sseemmaapphhoorree ccoouunntt
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssiidd3322
sseemm;;
//** SSeemmaapphhoorree IIDD ttoo rreettuurrnn
**//
mmaasskk == ddiissaabbllee(());;
iiff ((ccoouunntt << 00 |||| ((((sseemm==nneewwsseemm(())))====SSYYSSEERRRR)))) {{

Sec. 7.11        Example Implementation Of Dynamic Semaphores 
133
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
sseemmttaabb[[sseemm]]..ssccoouunntt == ccoouunntt;;
//** IInniittiiaalliizzee ttaabbllee eennttrryy
**//
rreessttoorree((mmaasskk));;
rreettuurrnn sseemm;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
nneewwsseemm
--
AAllllooccaattee aann uunnuusseedd sseemmaapphhoorree aanndd rreettuurrnn iittss iinnddeexx
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
llooccaall
ssiidd3322
nneewwsseemm((vvooiidd))
{{
ssttaattiicc
ssiidd3322
nneexxttsseemm == 00;;
//** NNeexxtt sseemmaapphhoorree iinnddeexx ttoo ttrryy
**//
ssiidd3322
sseemm;;
//** SSeemmaapphhoorree IIDD ttoo rreettuurrnn
**//
iinntt3322
ii;;
//** IItteerraattee tthhrroouugghh ## eennttrriieess
**//
ffoorr ((ii==00 ;; ii<<NNSSEEMM ;; ii++++)) {{
sseemm == nneexxttsseemm++++;;
iiff ((nneexxttsseemm >>== NNSSEEMM))
nneexxttsseemm == 00;;
iiff ((sseemmttaabb[[sseemm]]..ssssttaattee ==== SS__FFRREEEE)) {{
sseemmttaabb[[sseemm]]..ssssttaattee == SS__UUSSEEDD;;
rreettuurrnn sseemm;;
}}
}} 
rreettuurrnn SSYYSSEERRRR;;
}}
7.12 Semaphore Deletion
Function semdelete reverses the actions of semcreate.  Semdelete takes the ID of a 
semaphore as an argument and releases the semaphore table entry for subsequent use. 
Deallocating a semaphore requires three steps. First, semdelete verifies that the argu-
ment specifies a valid semaphore ID and that the corresponding entry in the semaphore 
table is currently in use. Second, semdelete sets the state of the entry to S_FREE to in-
dicate that the table entry can be reused. Finally, semdelete iterates through the set of 
processes that are waiting on the semaphore and makes each process ready. File 
semdelete.c contains the code.

134 
Coordination Of Concurrent Processes 
Chap. 7
//** sseemmddeelleettee..cc -- sseemmddeelleettee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** sseemmddeelleettee
--
DDeelleettee aa sseemmaapphhoorree bbyy rreelleeaassiinngg iittss ttaabbllee eennttrryy
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll sseemmddeelleettee((
ssiidd3322
sseemm
//** IIDD ooff sseemmaapphhoorree ttoo ddeelleettee
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
sseennttrryy **sseemmppttrr;;
//** PPttrr ttoo sseemmaapphhoorree ttaabbllee eennttrryy **//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddsseemm((sseemm)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
sseemmppttrr == &&sseemmttaabb[[sseemm]];;
iiff ((sseemmppttrr-->>ssssttaattee ==== SS__FFRREEEE)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
sseemmppttrr-->>ssssttaattee == SS__FFRREEEE;;
rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTAARRTT));;
wwhhiillee ((sseemmppttrr-->>ssccoouunntt++++ << 00)) {{
//** FFrreeee aallll wwaaiittiinngg pprroocceesssseess
**//
rreeaaddyy((ggeettffiirrsstt((sseemmppttrr-->>ssqquueeuuee))));;
}} 
rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTOOPP));;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}
If processes remain enqueued on a semaphore when the semaphore is deallocated, 
an operating system must handle each of the processes. In the example implementation, 
semdelete places each waiting process back on the ready list, allowing the process to 
resume execution as if the semaphore had been signaled. The example only represents 
one strategy, and other strategies are possible. For example, some operating systems 
consider it an error to attempt to deallocate a semaphore on which processes are wait-
ing. The exercises suggest exploring alternatives.

Sec. 7.12        Semaphore Deletion 
135
Note that the code to make processes ready uses deferred rescheduling. That is, 
semdelete calls resched_cntl to start deferral before making processes ready, and only 
calls resched_cntl to end the deferral period after all waiting processes have been 
moved to the ready list. The second call will invoke resched to reestablish the schedul-
ing invariant.
7.13 Semaphore Reset
It is sometimes convenient to reset the count of a semaphore without incurring the 
overhead of deleting an existing semaphore and creating a new one. The system call 
semreset, shown in file semreset.c below, resets the count of a semaphore.
//** sseemmrreesseett..cc -- sseemmrreesseett **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
sseemmrreesseett
--
RReesseett aa sseemmaapphhoorree’’ss ccoouunntt aanndd rreelleeaassee wwaaiittiinngg pprroocceesssseess
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll sseemmrreesseett((
ssiidd3322
sseemm,,
//** IIDD ooff sseemmaapphhoorree ttoo rreesseett
**//
iinntt3322
ccoouunntt
//** NNeeww ccoouunntt ((mmuusstt bbee >>== 00))
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
sseennttrryy **sseemmppttrr;;
//** PPttrr ttoo sseemmaapphhoorree ttaabbllee eennttrryy **//
qqiidd1166
sseemmqquueeuuee;;
//** SSeemmaapphhoorree’’ss pprroocceessss qquueeuuee IIDD **//
ppiidd3322
ppiidd;;
//** IIDD ooff aa wwaaiittiinngg pprroocceessss
**//
mmaasskk == ddiissaabbllee(());;
iiff ((ccoouunntt << 00 |||| iissbbaaddsseemm((sseemm)) |||| sseemmttaabb[[sseemm]]..ssssttaattee====SS__FFRREEEE)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
sseemmppttrr == &&sseemmttaabb[[sseemm]];;
sseemmqquueeuuee == sseemmppttrr-->>ssqquueeuuee;;
//** FFrreeee aannyy wwaaiittiinngg pprroocceesssseess **//
rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTAARRTT));;
wwhhiillee ((((ppiidd==ggeettffiirrsstt((sseemmqquueeuuee)))) !!== EEMMPPTTYY))
rreeaaddyy((ppiidd));;
sseemmppttrr-->>ssccoouunntt == ccoouunntt;;
//** RReesseett ccoouunntt aass ssppeecciiffiieedd **//

136 
Coordination Of Concurrent Processes 
Chap. 7
rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTOOPP));;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}
Semreset must preserve the semaphore invariant. Rather than build a general-
purpose solution that allows a caller to specify an arbitrary semaphore count, our imple-
mentation takes a simplified approach by requiring the new count to be nonnegative. 
As a result, once the semaphore count has been changed, the queue of waiting processes 
will be empty. As with semdelete, semreset must be sure that no processes are already 
waiting on the semaphore. Thus, after checking its arguments and verifying that the 
semaphore exists, semreset iterates through the list of waiting processes, removing each 
from the semaphore queue and making the process ready to execute. As expected, sem-
reset uses resched_cntl to defer rescheduling during the time processes are placed on 
the ready list.
7.14 Coordination Across Parallel Processors (Multicore)
The semaphore system described above works well on a computer that has a single 
processor core. However, many modern processor chips include multiple cores. One
core is usually dedicated to run operating system functions, and other cores are used to 
execute user applications. On such systems, using semaphores supplied by the operat-
ing system to coordinate processes can be inefficient. To see why, consider what hap-
pens when an application running on core 2 needs exclusive access to a specific 
memory location. The application process calls wait, which must pass the request to the 
operating system on core 1. Communication among cores often involves raising an in-
terrupt. Furthermore, while it runs an operating system function, core 1 disables inter-
rupts, which defeats one of the reasons to use semaphores.
Some multiprocessor systems supply hardware primitives, known as spin locks, 
that allow multiple processors to contend for mutually exclusive access. The hardware 
defines a set of K spin locks (K might be less than 1024). Conceptually, each of the 
spin locks is a single bit, and the spin locks are initialized to zero. The instruction set 
includes a special instruction, called a test-and-set, that a core can use to coordinate. A 
test-and-set performs two operations atomically: it sets a spin lock to 1 and returns the 
value of the spin lock before the operation. The hardware guarantees atomicity, which 
means that if two or more processors attempt to set a given spin lock simultaneously, 
one of them will receive 0 as the previous value and the others will receive 1. Once it 
finishes using the locked item, the core that obtained the lock resets the value to 0, al-
lowing another core to obtain the lock.
To see how spin locks work, suppose two cores need exclusive access to a shared 
data item and are using spin lock 5. When a core wants to obtain mutually exclusive 
access, the core executes a loop:†

†Because it uses hardware instructions, test-and-set code is usually written in assembly language; it is
shown in pseudo code for clarity.

Sec. 7.14        Coordination Across Parallel Processors (Multicore) 
137
wwhhiillee ((tteesstt__aanndd__sseett((55)))) {{
;;
}}
The loop repeatedly uses the test-and-set instruction to set spin lock 5. If the lock was
set before the instruction executed, the instruction will return 1, and the loop will con-
tinue. If the lock was not set before the instruction executed, the hardware will return 
0, and the loop terminates. If multiple processors are all trying to set spin lock 5 at the 
same time, the hardware guarantees that only one will be granted access. Thus, 
test_and_set is analogous to wait.
Once a core finishes using the shared data, the core executes an instruction that
clears the spin lock:
cclleeaarr((55));;
On multicore machines, vendors include various instructions that can be used as a
spin lock. For example, in addition to test-and-set, Intel multicore processors provide
an atomic compare-and-swap instruction. If multiple cores attempt to execute a
compare-and-swap instruction at the same time, one of them will succeed and the others 
will all find that the comparison fails. A programmer can use such instructions to build 
the equivalent of a spin lock.
It may seem that a spin lock is wasteful because a processor merely blocks (i.e., 
busy waits) in a loop until access is granted. However, if the probability of two proces-
sors contending for access is low, a spin lock mechanism is much more efficient than a 
system call (e.g., waiting on a semaphore). Therefore, a programmer must be careful in 
choosing when to use spin locks and when to use system calls.
7.15 Perspective
The counting semaphore abstraction is significant for two reasons. First, it pro-
vides a powerful mechanism that can be used to control both mutual exclusion and 
producer–consumer synchronization, the two primary process coordination paradigms. 
Second, the implementation is surprisingly compact and extremely efficient. To appre-
ciate the small size, reconsider functions wait and signal. If the code to test arguments 
and returns results is removed, only a few lines of code remain. As we examine the im-
plementation of other abstractions, the point will become more significant: despite their 
importance, only a trivial amount of code is needed to implement counting semaphores.
7.16 Summary
Instead of disabling interrupts, which stops all activities other than the current 
process, operating systems offer synchronization primitives that allow subsets of 
processes to coordinate without affecting other processes. A fundamental coordination 
mechanism, known as a counting semaphore, allows processes to coordinate without us-

138 
Coordination Of Concurrent Processes 
Chap. 7
ing busy-waiting. Each semaphore consists of an integer count plus a queue of
processes. The semaphore adheres to an invariant that specifies a count of negative N 
means the queue contains N processes.
The two fundamental primitives, signal and wait, permit a caller to increment or 
decrement the semaphore count. If a call to wait makes the semaphore count negative,
the calling process is placed in the waiting state and the processor passes to another 
process. In essence, a process that waits for a semaphore voluntarily enqueues itself on 
the list of processes waiting for the semaphore, and calls resched to allow other 
processes to execute.
Either static or dynamic allocation can be used with semaphores. The example 
code includes functions semcreate and semdelete to permit dynamic allocation. If a 
semaphore is deallocated while processes are waiting, the processes must be handled. 
The example code makes the processes ready as if the semaphore had been signaled.
Multiprocessors can use a mutual exclusion mechanism known as spin locks. 
Although spin locks seem inefficient because they require a processor to repeatedly test 
for access, they can be more efficient than an arrangement where one processor inter-
rupts another to place a system call.
EXERCISES
7.1   The text notes that some operating systems consider semaphore deletion to be in error if
processes remain enqueued waiting for the semaphore. Rewrite semdelete to return
SYSERR for a busy semaphore.
7.2 
As an alternative to the semaphore deletion mechanism illustrated in the chapter, consider
using deferred deletion. That is, rewrite semdelete to place a deleted semaphore in a de-
ferred state until all processes have been signaled. Modify signal to release the semaphore 
table entry when the last waiting process has been removed from the queue.
7.3  In the previous exercise, can deferred deletion have unexpected side effects? Explain.
7.4 
As a further alternative to the deferred deletion of an active semaphore, modify wait to re-
turn a value DELETED if the semaphore was deleted while the calling process was waiting. 
(Choose a value for DELETED that differs from SYSERR and OK.) How can a process 
determine whether the semaphore on which it was waiting has been deleted? Be careful: 
remember that a high-priority process can execute at any time. Thus, after a low-priority 
process becomes ready, a higher-priority process can obtain the processor and create a new 
semaphore that reuses the semaphore table entry before the low-priority process completes 
execution of wait. Hint: consider adding a sequence field to the semaphore table entry.
7.5 
Instead of allocating a central semaphore table, arrange to have each process allocate space
for semaphore entries as needed, and use the address of an entry as the semaphore ID. 
Compare the approach to the centralized table in the example code. What are the advan-
tages and disadvantages of each?
7.6 
Wait, signal, semcreate, and semdelete coordinate among themselves for use of the sema-
phore table. Is it possible to use a semaphore to protect use of the semaphore table? Ex-
plain.

Exercises
139
7.7 
Consider a possible optimization: instead of using ready, arrange for semdelete to examine
the priority of each waiting process before the process is placed on the ready list. If none
of the processes has higher priority than the current process, do not reschedule, but if any
of them has a higher priority, call resched. What is the cost of the optimization and what is 
the potential savings?
7.8  Construct a new system call, signaln(sem, n) that signals semaphore sem n times. Can you
find an implementation that is more efficient than n calls to signal? Explain.
7.9  The example code uses a FIFO policy for semaphores. That is, when a semaphore is sig-
naled, the process that has been waiting the longest becomes ready. Imagine a modification
in which the processes waiting for a semaphore are kept on a priority queue ordered by 
process priority (i.e., when a semaphore is signaled, the highest priority waiting process be-
comes ready). What is the chief disadvantage of a priority approach?
7.10  Languages meant specifically for writing concurrent programs often have coordination and
synchronization embedded in the language constructs directly. For example, it might be 
possible to declare functions in groups such that the compiler automatically inserts code to 
prohibit more than one process from executing a given group at a given time. Find an ex-
ample of a language designed for concurrent programming, and compare process coordina-
tion with the semaphores in the Xinu code.
7.11 When a programmer is required to manipulate semaphores explicitly, what types of mis-
takes can a programmer make?
7.12 When it moves a waiting process to the ready state, wait sets field prsem in the process
table entry to the ID of the semaphore on which the process is waiting. Will the value ever
be used?
7.13 If a programmer makes a mistake, it is more likely that the error will produce 0 or 1 than
an arbitrary integer. To help prevent errors, change newsem to begin allocating semaphores 
from the high end of the table, leaving slots 0 and 1 unused until all other entries have been 
exhausted. Suggest better ways of identifying semaphores that increase the ability to detect 
errors.
7.14  Function semdelete behaves in an unexpected way when deleting a semaphore with a non-
negative count. Identify the behavior and rewrite the code to correct it.
7.15 Draw a call graph of all operating system functions from Chapters 4 through 7, showing
which functions a given function invokes. Can a multi-level structure be deduced from the 
graph? Explain.


Chapter Contents
8.1 
Introduction, 143
8.2 
Two Types Of Message Passing Services, 143
8.3 
Limits On Resources Used By Messages, 144
8.4 
Message Passing Functions And State Transitions, 145
8.5 
Implementation Of Send, 146
8.6 
Implementation Of Receive, 148
8.7 
Implementation Of Non-Blocking Message Reception, 149
8.8 
Perspective, 149
8.9 
Summary, 150


8
Message Passing
The message of history is clear: the past lies before us.
— Anonymous
8.1 Introduction
Previous chapters explain the basic components of a process manager, including: 
scheduling, context switching, and counting semaphores that provide coordination 
among concurrent processes. The chapters show how processes are created and how
they terminate, and explain how an operating system keeps information about each 
process in a central table.
This chapter concludes our examination of basic process management facilities. 
The chapter introduces the concept of message passing, describes possible approaches, 
and shows an example of a low-level message passing system. Chapter 11 explains 
how a high-level message passing facility can be built using the basic process manage-
ment mechanisms.
8.2 Two Types Of Message Passing Services
We use the term message passing to refer to a form of inter-process communica-
tion in which one process transfers (usually a small amount of) data to another. In
some systems, processes deposit and retrieve messages from named pickup points that
are sometimes called mailboxes. In other systems, a message must be addressed direct-
ly to a process. Message passing is both convenient and powerful, and some operating 
systems use it as the basis for all communication and coordination among processes.
143

144 
Message Passing 
Chap. 8
For example, an operation such as transmitting data across a computer network can be 
implemented using message passing primitives.
Some message passing facilities provide process coordination because the mecha-
nism delays a receiver until a message arrives. Thus, message passing can replace proc-
ess suspension and resumption. Can message passing also replace synchronization 
primitives such as semaphores? The answer depends on the implementation of message 
passing. There are two types:
d Synchronous. If a receiver attempts to receive a message before
the message has arrived, the receiver blocks; if a sender tries to
send a message before a receiver is ready, the sender blocks. Send-
ing and receiving processes must coordinate or one can become 
blocked waiting for the other.
d Asynchronous.  A message can arrive at any time, and a receiver is
notified. A receiver does not need to know in advance how many 
messages will arrive or how many senders will send messages.
Although it may lack generality and convenience, a synchronous message passing 
facility can serve in place of a semaphore mechanism. For example, consider a
producer–consumer paradigm. Each time it generates new data, a producer process can 
send a message to the consumer process. Similarly, instead of waiting on a semaphore, 
the consumer can wait for a message. Using message passing to implement mutual ex-
clusion is more complex, but usually possible.
The chief advantage of a synchronous message passing system arises because it fits 
well with a traditional computational paradigm. To receive a message in a synchronous 
system, a process calls a system function, and the call does not return until a message 
arrives. In contrast, an asynchronous message passing system either requires a process 
to poll (i.e., check for a message periodically) or requires a mechanism that allows the 
operating system to stop a process temporarily, allows the process to handle a message, 
and then resumes normal execution. Although it introduces additional overhead or 
complexity, asynchronous message passing can be convenient if a process does not 
know how many messages it will receive, when the messages will be sent, or which 
processes will send messages.
8.3 Limits On Resources Used By Messages
Xinu supports two forms of message passing that illustrate a completely synchro-
nous paradigm and a partially asynchronous paradigm. The two facilities also illustrate
the difference between direct and indirect message delivery: one provides a direct ex-
change of messages among processes, and the other arranges for messages to be ex-
changed through rendezvous points. This chapter begins the discussion by examining a 
facility that provides direct communication from one process to another. Chapter 11 
discusses a second message passing facility. Separating message passing into two in-

Sec. 8.3        Limits On Resources Used By Messages 
145
dependent pieces has the advantage of making low-level message passing among 
processes efficient, while allowing a programmer to choose a more complex rendezvous 
approach when needed.
The Xinu process-to-process message passing system has been designed carefully
to ensure that a process does not block while sending a message, and waiting messages
do not consume all of memory. To make such guarantees, the message passing facility 
follows three guidelines:
d Limited message size. The system limits each message to a small,
fixed size. In our example code, each message consists of a single 
word (i.e., an integer or a pointer).
d No message queues. The system permits a given process to store
only one unreceived message per process at any time. There are no 
message queues.
d First message semantics. If several messages are sent to a given
process before the process receives any of them, only the first mes-
sage is stored and delivered; subsequent senders do not block.
The concept of first message semantics makes the mechanism useful for determin-
ing which of several events completes first. A process that needs to wait for events can 
arrange for each event to send a unique message. The process then waits for a message, 
and the operating system guarantees that the process will receive the first message that 
is sent.
8.4 Message Passing Functions And State Transitions
Three system calls manipulate messages: send, receive, and recvclr.  Send takes a 
message and a process ID as arguments, and delivers the message to the specified proc-
ess. Receive, which does not require arguments, causes the current process to wait until 
a message arrives, and then returns the message to its caller.  Recvclr provides a non-
blocking version of receive. If the current process has received a message when recvclr 
is called, the call returns the message exactly like receive. If no message is waiting, 
however, recvclr returns the value OK to its caller immediately, without delaying to 
wait for a message to arrive. As the name implies, recvclr can be used to remove an 
old message before engaging in a round of message passing.
The question arises: in what state should a process be while waiting for a message? 
Because waiting for a message differs from being ready to execute, waiting for a sema-
phore, waiting for the processor, suspended animation, or current execution, none of the 
existing states suffices. Thus, another state must be added to our design. The new 
state, receiving, is denoted in the example software with the symbolic constant 
PR_RECV. Adding the state produces the transition diagram illustrated in Figure 8.1.

146 
Message Passing 
Chap. 8
READY
CURRENT
resched
resched
SUSPENDED
suspend
resume
suspend
create
WAITING
wait
signal
RECEIVING
receive
send
Figure 8.1  Illustration of state transitions including the receiving state.
8.5 Implementation Of Send
A message passing system requires agreement between senders and receivers be-
cause a sender must store a message in a location from which the receiver can extract
the message. A message cannot be stored in the sender’s memory because a sending 
process can exit before the message is received. Most operating systems do not permit 
a sender to place a message in a receiver’s address space because allowing a process to 
write into the memory allocated to another process poses a security threat. In our ex-
ample system, restrictions on the size of messages eliminate the problem. Our imple-
mentation reserves space for one message in field prmsg of the recipient’s process table 
entry.
To deposit a message, function send first checks that the specified recipient process 
exists. It then checks to ensure the recipient does not have a message outstanding. To 
do so, send examines field prhasmsg in the recipient’s process table entry. If the reci-
pient has no outstanding message, send deposits the new message in the prmsg field and 
sets prhasmsg to TRUE to indicate that a message is waiting. As a final step, if the re-
cipient is waiting for the arrival of a message (i.e., the recipient process has state 
PR_RECV or state PR_RECTIM), send calls ready to make the process ready and re-

Sec. 8.5        Implementation Of Send 
147
establish the scheduling invariant. In the case of PR_RECTIM, which is discussed later
in the text, send must first call unsleep to remove the process from the queue of sleep-
ing processes. File send.c contains the code.
//** sseenndd..cc -- sseenndd **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
sseenndd
--
PPaassss aa mmeessssaaggee ttoo aa pprroocceessss aanndd ssttaarrtt rreecciippiieenntt iiff wwaaiittiinngg
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll sseenndd((
ppiidd3322
ppiidd,,
//** IIDD ooff rreecciippiieenntt pprroocceessss
**//
uummssgg3322
mmssgg
//** CCoonntteennttss ooff mmeessssaaggee
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pprroocceenntt **pprrppttrr;;
//** PPttrr ttoo pprroocceessss’’ ttaabbllee eennttrryy
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddppiidd((ppiidd)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
pprrppttrr == &&pprrooccttaabb[[ppiidd]];;
iiff ((((pprrppttrr-->>pprrssttaattee ==== PPRR__FFRREEEE)) |||| pprrppttrr-->>pprrhhaassmmssgg)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
pprrppttrr-->>pprrmmssgg == mmssgg;;
//** DDeelliivveerr mmeessssaaggee
**//
pprrppttrr-->>pprrhhaassmmssgg == TTRRUUEE;;
//** IInnddiiccaattee mmeessssaaggee iiss wwaaiittiinngg
**//
//** IIff rreecciippiieenntt wwaaiittiinngg oorr iinn ttiimmeedd--wwaaiitt mmaakkee iitt rreeaaddyy **//
iiff ((pprrppttrr-->>pprrssttaattee ==== PPRR__RREECCVV)) {{
rreeaaddyy((ppiidd));;
}} eellssee iiff ((pprrppttrr-->>pprrssttaattee ==== PPRR__RREECCTTIIMM)) {{
uunnsslleeeepp((ppiidd));;
rreeaaddyy((ppiidd));;
}} 
rreessttoorree((mmaasskk));;
//** RReessttoorree iinntteerrrruuppttss **//
rreettuurrnn OOKK;;
}}

148 
Message Passing 
Chap. 8
8.6 Implementation Of Receive
A process calls receive (or recvclr) to obtain an incoming message. Receive exam-
ines the process table entry for the current process, and uses the prhasmsg field to deter-
mine whether a message is waiting. If no message has arrived, receive changes the 
process state to PR_RECV, and calls resched, to allow other processes to run. When 
another process sends the receiving process a message, the call to resched returns. 
Once execution passes the if statement, receive extracts the message, sets prhasmsg to 
FALSE, and returns the message to its caller. File receive.c contains the code:
//** rreecceeiivvee..cc -- rreecceeiivvee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
rreecceeiivvee
--
WWaaiitt ffoorr aa mmeessssaaggee aanndd rreettuurrnn tthhee mmeessssaaggee ttoo tthhee ccaalllleerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
uummssgg3322
rreecceeiivvee((vvooiidd))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pprroocceenntt **pprrppttrr;;
//** PPttrr ttoo pprroocceessss’’ ttaabbllee eennttrryy
**//
uummssgg3322
mmssgg;;
//** MMeessssaaggee ttoo rreettuurrnn
**//
mmaasskk == ddiissaabbllee(());;
pprrppttrr == &&pprrooccttaabb[[ccuurrrrppiidd]];;
iiff ((pprrppttrr-->>pprrhhaassmmssgg ==== FFAALLSSEE)) {{
pprrppttrr-->>pprrssttaattee == PPRR__RREECCVV;;
rreesscchheedd(());;
//** BBlloocckk uunnttiill mmeessssaaggee aarrrriivveess
**//
}} 
mmssgg == pprrppttrr-->>pprrmmssgg;;
//** RReettrriieevvee mmeessssaaggee
**//
pprrppttrr-->>pprrhhaassmmssgg == FFAALLSSEE;;
//** RReesseett mmeessssaaggee ffllaagg
**//
rreessttoorree((mmaasskk));;
rreettuurrnn mmssgg;;
}}
Look carefully at the code and notice that receive copies the message from the
process table entry into local variable msg and then returns the value in msg. Interest-
ingly, receive does not modify field prmsg in the process table. Thus, it may seem that
a more efficient implementation would avoid copying into a local variable and simply 
return the message from the process table:
return proctab[currpid].prmsg;

Sec. 8.6        Implementation Of Receive 
149
Unfortunately, such an implementation is incorrect; an exercise asks readers to consider 
why the implementation can produce incorrect results.
8.7 Implementation Of Non-Blocking Message Reception
Recvclr operates much like receive except that it always returns immediately. If a
message is waiting, recvclr returns the message; otherwise, recvclr returns OK.
//** rreeccvvccllrr..cc -- rreeccvvccllrr **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
rreeccvvccllrr
--
CClleeaarr iinnccoommiinngg mmeessssaaggee,, aanndd rreettuurrnn mmeessssaaggee iiff oonnee wwaaiittiinngg
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
uummssgg3322
rreeccvvccllrr((vvooiidd))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pprroocceenntt **pprrppttrr;;
//** PPttrr ttoo pprroocceessss’’ ttaabbllee eennttrryy
**//
uummssgg3322
mmssgg;;
//** MMeessssaaggee ttoo rreettuurrnn
**//
mmaasskk == ddiissaabbllee(());;
pprrppttrr == &&pprrooccttaabb[[ccuurrrrppiidd]];;
iiff ((pprrppttrr-->>pprrhhaassmmssgg ==== TTRRUUEE)) {{
mmssgg == pprrppttrr-->>pprrmmssgg;;
//** RReettrriieevvee mmeessssaaggee
**//
pprrppttrr-->>pprrhhaassmmssgg == FFAALLSSEE;;//** RReesseett mmeessssaaggee ffllaagg
**//
}} eellssee {{
mmssgg == OOKK;;
}} 
rreessttoorree((mmaasskk));;
rreettuurrnn mmssgg;;
}}
8.8 Perspective
Like the counting semaphore abstraction in the previous chapter, the code for a 
basic message passing facility is extremely compact and efficient. Look at the functions 
and notice how few lines of code perform each operation. Furthermore, observe that 
storing the message buffer in the process table is important because doing so isolates 
message passing from memory management and allows message passing to be posi-
tioned at a low level in the hierarchy.

150 
Message Passing 
Chap. 8
8.9 Summary
Message passing facilities provide inter-process communication that allows a proc-
ess to send information to another process. A completely synchronous message passing 
system blocks either the sender or receiver, depending on how many messages have 
been sent and received. Our example system includes two facilities for message pass-
ing: a low-level mechanism that provides direct communication among processes and a 
high-level mechanism that uses rendezvous points.
The Xinu low-level message passing mechanism limits the message size to a single 
word, restricts each process to at most one outstanding message, and uses first-message 
semantics. Message storage is associated with the process table — a message sent to 
process P is stored in the process table entry for P. The use of first-message semantics 
allows a process to determine which of several events occurs first.
The low-level message facility comprises three functions: send, receive, and 
recvclr. Of the three functions, only receive is blocking — it blocks the calling process 
until a message arrives. A process can use recvclr to remove an old message before 
starting an interaction that uses message passing.
EXERCISES
8.1 
Write a program that prints a prompt, and then loops printing the prompt again every 8
seconds until someone types a character. Hint: sleep(8) delays the calling process for 8 
seconds.
8.2   Assume send and receive do not exist, and build code to perform message passing using
suspend and resume.
8.3  The example implementation uses first-message semantics. What facilities exist to handle
last-message semantics?
8.4 
Implement versions of send and receive that record up to K messages per process (make
successive calls to send block).
8.5    Investigate systems in which the innermost level of the system implements message passing
instead of context switching. What is the advantage? The chief liability?
8.6 
Consider the modification of receive mentioned in the text that returns the message directly
from the process table entry:
return proctab[currpid].prmsg;
Explain why such an implementation is incorrect.
8.7 
Implement versions of send and receive that define a fixed set of thirty-two possible mes-
sages. Instead of using integers to represent messages, use one bit of a word to represent
each message, and allow a process to accumulate all thirty-two messages.
8.8 
Observe that because receive uses SYSERR to indicate an error, sending a message with the
same value as SYSERR is ambiguous. Furthermore, recvclr returns OK if no message is
waiting. Modify recvclr to return SYSERR if no message is waiting, and modify send so it
refuses to send SYSERR (i.e., checks its argument and returns an error if the value is
SYSERR).

Chapter Contents
9.1 
Introduction, 153
9.2 
Types Of Memory, 153
9.3 
Definition Of A Heavyweight Process, 154
9.4 
Memory Management In Our Example System, 155
9.5 
Program Segments And Regions Of Memory, 156
9.6 
Dynamic Memory Allocation, 157
9.7 
Design Of The Low–level Memory Manager, 158
9.8 
Allocation Strategy And Memory Persistence, 159
9.9 
Keeping Track Of Free Memory, 159
9.10 
Implementation Of Low–level Memory Management, 160
9.11 
Data Structure Definitions Used With Free Memory, 161
9.12 
Allocating Heap Storage, 162
9.13 
Allocating Stack Storage, 165
9.14 
Releasing Heap And Stack Storage, 167
9.15 
Perspective, 170
9.16 
Summary, 170


9
Basic Memory Management
Memory is the ghost of experience.
— Anonymous
9.1 Introduction
Previous chapters explain concurrent computation and the facilities that an operat-
ing system provides to manage concurrent processes. The chapters discuss process 
creation and termination, scheduling, context switching, coordination, and inter-process 
communication.
This chapter begins the discussion of a second key topic: facilities that an operat-
ing system uses to manage memory. The chapter focuses on basics: dynamic allocation
of stack and heap storage. It presents a set of functions that allocate and free memory,
and explains how an embedded system handles memory for processes. The next
chapter continues the discussion of memory management by describing address spaces, 
high-level memory management facilities, and virtual memory.
9.2 Types Of Memory
Because it is essential for program execution and data storage, main memory ranks 
high among the important resources that an operating system manages. An operating 
system maintains information about the size and location of available free memory 
blocks, and allocates memory to concurrent programs upon request. The system recov-
ers the memory allocated to a process when the process terminates, making the memory 
available for reuse. We will assume that code remains resident in memory.
153

154 
Basic Memory Management 
Chap. 9
In many embedded systems, main memory consists of a contiguous set of locations 
with addresses 0 through N – 1. However, some systems have complex address spaces 
where certain regions are reserved (e.g., for memory-mapped devices or backward com-
patibility). Our example platforms illustrate the two styles: the BeagleBone Black has a 
contiguous set of memory locations, and the Galileo provides a set of discontiguous 
blocks.
Broadly speaking, memory can be divided into two categories:
d Stable Storage, such as Flash memory that retains values after the
power is removed
d Random Access Memory (RAM) that only retains values while the
system is powered on
In terms of addresses, the two types of memory occupy separate locations. For exam-
ple, addresses 0 through K – 1 might correspond to Flash memory, and addresses K 
through N – 1 might correspond to dynamic RAM.†
Some systems further distinguish regions of memory by using specific types of
memory technologies. For example, RAM might be divided into two regions that use:
d Static RAM (SRAM): faster, but more expensive
d Dynamic RAM (DRAM): less expensive, but slower
Because SRAM is more expensive, systems usually have a small amount of SRAM 
and a larger amount of DRAM. If memory types differ, a programmer must carefully 
place variables and code that are referenced the most frequently in SRAM, and items 
that are referenced less often in DRAM.
9.3 Definition Of A Heavyweight Process
Operating systems include mechanisms that prevent an application from reading or 
modifying areas of memory that have been assigned to another application. For exam-
ple, Chapter 10 discusses how each process can be assigned a separate virtual address 
space. The approach, which is known as a heavyweight process abstraction, creates an 
address space, and then creates a process to run in the address space. Usually, code for 
a heavyweight process is loaded dynamically — an application must be compiled and 
stored in a file on disk before the application can be used in a heavyweight process. 
Thus, when creating the heavyweight process, a programmer specifies the file on disk 
that contains the compiled code, and the operating system loads the specified applica-
tion into a new virtual address space and starts a process executing the application.
Interestingly, some operating systems that support a heavyweight process abstrac-
tion also incorporate a lightweight process abstraction (i.e., threads of execution). In-
stead of a single process executing in an address space, the operating system starts a

†Usually, K and N are each a power of 2.

Sec. 9.3        Definition Of A Heavyweight Process 
155
single process, but then permits the process to create additional threads that all execute
in the same address space.
In the hybrid system described above, a thread is similar to a Xinu process. Each 
thread has a separate runtime stack used to hold activation records for function calls (in-
cluding a copy of local variables). The stacks are allocated from the data area in the 
heavyweight process’s address space. All the threads within a given heavyweight proc-
ess share global variables; the global variables are allocated in the data area of the 
heavyweight process’s address space. Sharing implies the need for coordination —
threads within a heavyweight process must use synchronization primitives, such as 
semaphores, to control access to the variables they share. Figure 9.1 illustrates threads 
within a heavyweight process.
..................
heavyweight process’s 
address space
shared variables 
and thread stacks
lightweight processes 
(threads)
data in process
code in process
Figure 9.1 Illustration of a heavyweight process that contains multiple light-
weight processes (threads). All threads share the address space.
9.4 Memory Management In Our Example System
The largest embedded systems, such as those used in video game consoles, have 
the memory management hardware and operating system support needed for demand 
paged virtual memory. On the smallest embedded systems, however, the hardware can-
not support multiple address spaces, nor can it protect processes from one another. As a 
consequence, the operating system and all processes occupy a single address space.
Although running multiple processes in a single address space does not offer pro-
tection, the approach has advantages. Because they can pass pointers among them-
selves, processes can share large amounts of data without copying from one address
space to another. Furthermore, the operating system itself can easily dereference an ar-
bitrary pointer because the interpretation of an address does not depend on the process

156 
Basic Memory Management 
Chap. 9
context. Finally, having just one address space makes the memory manager much
simpler than the memory managers found in more sophisticated systems.
9.5 Program Segments And Regions Of Memory
A C compiler divides a memory image into four contiguous regions known as: 
d Text segment
d Data segment
d Bss segment
d Free space
Text segment. The text segment, which begins at the lowest usable memory ad-
dress, contains compiled code for each of the functions that are part of the memory im-
age (including the code for function main, which is compiled and linked like other func-
tions). A compiler may also choose to place constants in the text segment because con-
stants are read, but never changed. For example, string constants can be placed in the 
text segment. If the hardware includes a protection mechanism, addresses in the text 
segment are classified as read-only, which means that an error occurs if the program at-
tempts to store into any of the text locations at runtime.
Data segment. The data segment, which follows the text segment, contains storage 
for all global variables that are assigned an initial value. In C, such variables are de-
clared to be global by placing the declarations outside of function declarations. Values 
in the data segment are classified as read-write because they may be both accessed and 
modified.
Bss segment. The term bss abbreviates block started by symbol, and is taken from 
the assembly language of a PDP-11, the computer on which C was designed. The bss 
segment, which follows the data segment, contains global variables that are not initial-
ized explicitly. Following C conventions, Xinu writes zero into each bss location be-
fore execution begins.
Free space. Addresses beyond the bss segment are considered free (i.e., unallocat-
ed) when execution begins. To simplify the discussion, we will assume free space con-
sists of a single, contiguous region. In practice, some hardware platforms (e.g., the 
Galileo platform) may divide the free space into a set of discontiguous blocks.
As described in Chapter 3, a C program loader defines three external symbols, 
etext, edata, and end,† that correspond to the first memory location beyond the text seg-
ment, the first memory location beyond the data segment, and the first memory location 
beyond the bss segment. Figure 9.2 illustrates the memory layout when Xinu begins to 
execute and the three external symbols.

†External symbol names have an underscore prepended by the loader. Thus, if we use etext in a C pro-
gram, it becomes _etext in the linked image.

Sec. 9.5        Program Segments And Regions Of Memory 
157
text
data
bss
free space
etext 
edata 
end
max address
start address
Figure 9.2  Illustration of the memory layout when Xinu begins.
The external symbols shown in Figure 9.2 are not variables, but instead are names 
assigned to memory locations when the image is linked. Thus, a program should only
use one of the external symbols to reference a location and should not load or store a 
value. For example, the text segment might occupy memory locations from the starting 
address through etext – 1. To compute the size, a program declares etext to be an exter-
nal integer, and references &etext in an expression.
How can a program determine the free space available for use? Our example plat-
forms illustrate two approaches. In the case of the BeagleBone Black, the hardware 
manual specifies the available addresses. In the case of the Galileo, when it is powered 
on, the hardware and boot loader work together to probe memory, build a table of avail-
able address blocks, and pass the table to whatever operating system is being booted. 
We will see that the version of Xinu used on the BeagleBone Black contains constants 
that specify the address range, and the version of Xinu that runs on a Galileo is passed a 
list of available address blocks when it boots.
9.6 Dynamic Memory Allocation
Although they are allocated fixed locations in the address space and must remain 
resident in physical memory at all times, program text and global variables only account 
for part of the memory used by an executing process. The remaining memory can be 
allocated dynamically for:
d Stack
d Heap
Stack. Each process needs space for a stack that holds the activation record associ-
ated with each function the process invokes. In addition to arguments, an activation
record contains storage for local variables.
Heap. A process or set of processes may also use heap storage. Items from the
heap are allocated dynamically and persist independent of specific function calls.
Xinu accommodates both types of dynamic memory. First, when creating a new 
process, Xinu allocates a stack for the process. Stacks are allocated from the highest 
block in free space that accommodates the request. Second, whenever a process re-
quests heap storage, Xinu allocates the necessary amount of space from the lowest free

158 
Basic Memory Management 
Chap. 9
block that accommodates the request. Figure 9.3 shows an example of the memory lay-
out when three processes are executing and heap storage has been allocated.
text
data
bss
heap
stack1
stack2
stack3
free
etext 
edata 
end
Figure 9.3  Illustration of memory after three processes have been created.
9.7 Design Of The Low–level Memory Manager
A set of functions and associated data structures are used to manage free memory.
The low-level memory manager provides five functions:
d getstk 
— Allocate stack space when a process is created
d freestk — Release a stack when a process terminates
d getmem — Allocate heap storage on demand
d freemem — Release heap storage as requested
d meminit — Initialize the free list at startup
Our design treats free space as a single, exhaustable resource — the low-level 
memory manager allocates space provided a request can be satisfied. Furthermore, the 
low-level memory manager does not partition the free space into memory available for 
process stacks and memory available for heap variables. Requests of one type can take 
the remaining free space, and leave none for the other type. Of course, such an alloca-
tion only works if processes cooperate. Otherwise, a given process can consume all free 
memory, leaving no space for other processes. Chapter 10 illustrates an alternative ap-
proach by describing a set of high-level memory management functions that prevent ex-
haustion by partitioning memory among subsystems. The high-level memory manager 
also demonstrates how processes can block until memory becomes available.
Functions getstk and freestk are not intended for general use. Instead, when it
forms a new process, create calls getstk to allocate a stack. Getstk obtains a block of
memory from the highest address of free space, and returns a pointer to the block. 
Create records the size and location of the allocated stack space in the process table en-
try. Later, when the process becomes current, the context switch moves the stack ad-
dress into the stack pointer register, allowing the stack to be used for function calls. Fi-
nally, when the process terminates, kill calls function freestk to release the process’s 
stack and return the block to the free list.
Functions getmem and freemem perform analogous functions for heap storage. Un-
like the stack allocation functions, getmem and freemem allocate heap space from the
lowest available free memory address.

Sec. 9.8        Allocation Strategy And Memory Persistence 
159
9.8 Allocation Strategy And Memory Persistence
Because only create and kill allocate and free process stacks, the system can 
guarantee that the stack space allocated to a process will be released when the process 
exits. However, the system does not record the set of blocks that a process allocates 
from the heap by calling getmem. Therefore, the system does not automatically release 
heap storage. As a consequence, the burden of returning heap space is left to the pro-
grammer:
Heap space persists independent of the process that allocates the
space. Before it exits, a process must explicitly release storage that it 
has allocated from the heap, or the space will remain allocated.
Of course, returning allocated heap space does not guarantee that the heap will 
never be exhausted. On the one hand, demand can exceed the available space. On the 
other hand, the free space can become fragmented into small, discontiguous pieces that 
are each too small to satisfy a request. A later chapter continues the discussion of allo-
cation policies, and shows one approach to avoiding fragmentation of the free space.
9.9 Keeping Track Of Free Memory
A memory manager must keep information about all free memory blocks. To do 
so, the memory manager forms a list, where each item on the list specifies a memory 
address at which a block starts and a length. In systems where the entire free memory 
is contiguous, the initial list will contain only one item that corresponds to the block of 
memory between the end of the program and the highest available address. In systems 
where the free memory is divided into blocks, the initial list will contain one node for 
each block. In either case, when a process requests a block of memory, the memory 
manager searches the list, finds a free area, allocates the requested size block, and up-
dates the list to show that more of the free memory has been allocated. Similarly, 
whenever a process releases a previously allocated block of memory, the memory 
manager adds the block to the list of free blocks. Figure 9.4 illustrates an example set 
of four free memory blocks.

Block 
Address 
Length

1 
0x84F800 
4096
2 
0x850F70 
8192
3 
0x8A03F0 
8192
4 
0x8C01D0 
4096





























Figure 9.4  An example set of free memory blocks.

160 
Basic Memory Management 
Chap. 9
A memory manager must examine each transaction carefully to avoid generating an 
arbitrarily long list of small blocks. When a block is released, the memory manager 
scans the list to see if the released block is adjacent to the end of one of the existing
free blocks. If so, the size of the existing block can be increased without adding a new 
entry to the list. Similarly, if the new block is adjacent to the beginning of an existing 
block, the entry can be updated. Finally, if a released block exactly fills the gap 
between two free blocks on the list, the memory manager will combine the two existing 
entries on the list into one giant block that covers all the memory from the two on the 
list plus the released block. We use the term coalesce to describe combining entries. 
The point is: if a memory manager is built correctly, once all allocated blocks have 
been released, the free list will be back to the initial state (i.e., the exact set of memory 
regions that were free when the operating system started).
9.10 Implementation Of Low–level Memory Management
Where should the list of free memory blocks be stored? Our example implementa-
tion follows a standard approach by using free memory itself to store the list. After all,
a free memory block is not being used, so the contents are no longer needed. Thus, the 
free memory blocks can be chained together to form a linked list by placing a pointer in 
each block to the next block.
In the code, global variable memlist contains a pointer to the first free block. The
key to understanding the implementation lies in the invariant maintained at all times:
All free blocks of memory are kept on a linked list; blocks on the free 
list are ordered by increasing address.
The example set of blocks in Figure 9.4 shows two items associated with each en-
try: an address and a size. In our linked list implementation, each node in the list points
to (i.e., gives the address) of the next node. However, we must also store the size of
each block. Therefore, each block of free memory contains two items: a pointer to the 
next free block of memory and an integer that gives the size of the current block. Fig-
ure 9.5 illustrates the concept.
z
x
y
free block of x bytes 
free block of y bytes
global variable memlist
structure memblk 
imposed on free block
Figure 9.5 Illustration of a free memory list that contains two memory
blocks.

Sec. 9.10        Implementation Of Low–level Memory Management 
161
9.11 Data Structure Definitions Used With Free Memory
File memory.h contains declarations related to memory management. Structure
memblk is imposed on each free node.
//** mmeemmoorryy..hh -- rroouunnddmmbb,, ttrruunnccmmbb,, ffrreeeessttkk **//
##ddeeffiinnee PPAAGGEE__SSIIZZEE
44009966
//**--------------------------------------------------------------------------------------------------------------------------------------------
** rroouunnddmmbb,, ttrruunnccmmbb -- RRoouunndd oorr ttrruunnccaattee aaddddrreessss ttoo mmeemmoorryy bblloocckk ssiizzee
**--------------------------------------------------------------------------------------------------------------------------------------------
**//
##ddeeffiinnee rroouunnddmmbb((xx))
((cchhaarr **))(( ((77 ++ ((uuiinntt3322))((xx)))) && ((~~77)) ))
##ddeeffiinnee ttrruunnccmmbb((xx))
((cchhaarr **))(( ((((uuiinntt3322))((xx)))) && ((~~77)) ))
//**--------------------------------------------------------------------------------------------------------------------------------------------
**
ffrreeeessttkk
----
FFrreeee ssttaacckk mmeemmoorryy aallllooccaatteedd bbyy ggeettssttkk
**--------------------------------------------------------------------------------------------------------------------------------------------
**//
##ddeeffiinnee ffrreeeessttkk((pp,,lleenn))
ffrreeeemmeemm((((cchhaarr **))((((uuiinntt3322))((pp))
\\
-- ((((uuiinntt3322))rroouunnddmmbb((lleenn))))
\\
++ ((uuiinntt3322))ssiizzeeooff((uuiinntt3322)))),,
\\
((uuiinntt3322))rroouunnddmmbb((lleenn)) ))
ssttrruucctt
mmeemmbbllkk
{{
//** SSeeee rroouunnddmmbb && ttrruunnccmmbb
**//
ssttrruucctt
mmeemmbbllkk
**mmnneexxtt;;
//** PPttrr ttoo nneexxtt ffrreeee mmeemmoorryy bbllkk
**//
uuiinntt3322
mmlleennggtthh;;
//** SSiizzee ooff bbllkk ((iinncclluuddeess mmeemmbbllkk))**//
}};;
eexxtteerrnn
ssttrruucctt
mmeemmbbllkk
mmeemmlliisstt;;
//** HHeeaadd ooff ffrreeee mmeemmoorryy lliisstt
**//
eexxtteerrnn
vvooiidd
**mmiinnhheeaapp;;
//** SSttaarrtt ooff hheeaapp
**//
eexxtteerrnn
vvooiidd
**mmaaxxhheeaapp;;
//** HHiigghheesstt vvaalliidd hheeaapp aaddddrreessss
**//
//** AAddddeedd bbyy lliinnkkeerr **//
eexxtteerrnn
iinntt
tteexxtt;;
//** SSttaarrtt ooff tteexxtt sseeggmmeenntt
**//
eexxtteerrnn
iinntt
eetteexxtt;;
//** EEnndd ooff tteexxtt sseeggmmeenntt
**//
eexxtteerrnn
iinntt
ddaattaa;;
//** SSttaarrtt ooff ddaattaa sseeggmmeenntt
**//
eexxtteerrnn
iinntt
eeddaattaa;;
//** EEnndd ooff ddaattaa sseeggmmeenntt
**//
eexxtteerrnn
iinntt
bbssss;;
//** SSttaarrtt ooff bbssss sseeggmmeenntt
**//
eexxtteerrnn
iinntt
eebbssss;;
//** EEnndd ooff bbssss sseeggmmeenntt
**//
eexxtteerrnn
iinntt
eenndd;;
//** EEnndd ooff pprrooggrraamm
**//

162 
Basic Memory Management 
Chap. 9
In struct memblk, field mnext points to the next block on the list or contains the 
value NULL to indicate that a block is the final block on the list. Field mlength speci-
fies the length of the current block in bytes, including the header. Note that the length
is declared to be an unsigned long, which accommodates any size block up to the entire 
32-bit physical address space.
Variable memlist, which constitutes the head of the list, is defined as consisting of 
a memblk structure. Thus, the head of the list has exactly the same form that we impose 
on other nodes in the list. In memlist, however, the mlength field (which is normally 
used to store the size of a block) is not meaningful because the size of memlist is 
sizeof(struct memblk). Consequently, we can use the length field for another purpose. 
Xinu uses the field to store the total size of free memory (i.e., a sum of the length field 
in each free block). Having a count of the free memory can help when debugging or to 
assess whether the system is approaching the maximum possible size.
Note that each block on the free list must hold a complete memblk structure (i.e.,
eight bytes). The design choice has a consequence: our free list cannot store a free
block of less then eight bytes. How can we guarantee that no process attempts to free a 
smaller amount of memory? We can tell programmers that they must free exactly the 
same amount they request, and design the memory management functions to ensure all 
requests are at least eight bytes. But another problem can arise if the memory manager 
extracts a piece from a free block: subtraction can leave a remainder of less than eight 
bytes. To solve the problem, our memory manager rounds all requests to a multiple of 
memblk structures. Our solution has a useful property described later: subtracting a 
multiple of eight from a multiple of eight always produces a multiple of eight.
File memory.h defines two inline functions, roundmb and truncmb, that handle the 
rounding. Function roundmb rounds requests to multiples of eight bytes, and truncmb 
is used to truncate a memory size to a multiple of eight bytes. Truncation is only used
at startup: if the initial size of a free block is not a multiple of eight, the size must be 
truncated down rather than rounded up. To make the implementation efficient, the code 
for the two functions uses constants and Boolean operations rather than the sizeof func-
tion and division. Using Boolean operations is only possible because the size of a 
memory block is a power of two. We can summarize:
Rounding all requests to multiples of the memblk structure ensures
that each request satisfies the size constraint and guarantees that no 
free block will ever be too small to link into the free list.
9.12 Allocating Heap Storage
Function getmem allocates heap storage by finding a free block that is sufficient for 
the request. Our implementation uses a first-fit allocation strategy by allocating the first 
block on the free list that satisfies a request. Getmem subtracts the requested memory 
from the free block and adjusts the free list accordingly. File getmem.c contains the 
code.

Sec. 9.12        Allocating Heap Storage 
163
//** ggeettmmeemm..cc -- ggeettmmeemm **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ggeettmmeemm
--
AAllllooccaattee hheeaapp ssttoorraaggee,, rreettuurrnniinngg lloowweesstt wwoorrdd aaddddrreessss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
cchhaarr
**ggeettmmeemm((
uuiinntt3322
nnbbyytteess
//** SSiizzee ooff mmeemmoorryy rreeqquueesstteedd
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
mmeemmbbllkk
**pprreevv,, **ccuurrrr,, **lleeffttoovveerr;;
mmaasskk == ddiissaabbllee(());;
iiff ((nnbbyytteess ==== 00)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn ((cchhaarr **))SSYYSSEERRRR;;
}} 
nnbbyytteess == ((uuiinntt3322)) rroouunnddmmbb((nnbbyytteess));;
//** UUssee mmeemmbbllkk mmuullttiipplleess **//
pprreevv == &&mmeemmlliisstt;;
ccuurrrr == mmeemmlliisstt..mmnneexxtt;;
wwhhiillee ((ccuurrrr !!== NNUULLLL)) {{
//** SSeeaarrcchh ffrreeee lliisstt
**//
iiff ((ccuurrrr-->>mmlleennggtthh ==== nnbbyytteess)) {{
//** BBlloocckk iiss eexxaacctt mmaattcchh **//
pprreevv-->>mmnneexxtt == ccuurrrr-->>mmnneexxtt;;
mmeemmlliisstt..mmlleennggtthh --== nnbbyytteess;;
rreessttoorree((mmaasskk));;
rreettuurrnn ((cchhaarr **))((ccuurrrr));;
}} eellssee iiff ((ccuurrrr-->>mmlleennggtthh >> nnbbyytteess)) {{ //** SSpplliitt bbiigg bblloocckk **//
lleeffttoovveerr == ((ssttrruucctt mmeemmbbllkk **))((((uuiinntt3322)) ccuurrrr ++
nnbbyytteess));;
pprreevv-->>mmnneexxtt == lleeffttoovveerr;;
lleeffttoovveerr-->>mmnneexxtt == ccuurrrr-->>mmnneexxtt;;
lleeffttoovveerr-->>mmlleennggtthh == ccuurrrr-->>mmlleennggtthh -- nnbbyytteess;;
mmeemmlliisstt..mmlleennggtthh --== nnbbyytteess;;
rreessttoorree((mmaasskk));;
rreettuurrnn ((cchhaarr **))((ccuurrrr));;
}} eellssee {{
//** MMoovvee ttoo nneexxtt bblloocckk
**//
pprreevv == ccuurrrr;;
ccuurrrr == ccuurrrr-->>mmnneexxtt;;

164 
Basic Memory Management 
Chap. 9
}}
}} 
rreessttoorree((mmaasskk));;
rreettuurrnn ((cchhaarr **))SSYYSSEERRRR;;
}}
After verifying that its argument is valid and the free list is not empty, getmem 
uses roundmb to round the memory request to a multiple of memblk bytes, and then
searches the free list to find the first block of memory large enough to satisfy the re-
quest. Because the free list is singly linked, getmem uses two pointers, prev and curr, 
to walk the list. The code maintains the following invariant during the search: when 
curr points to a free block, prev points to its predecessor on the list (possibly the head 
of the list, memlist). As it runs through the list, the code must ensure the invariant 
remains intact. Consequently, when a free block is discovered that is large enough to 
satisfy the request, prev will point to the predecessor.
At each step of the iteration, getmem compares the size of the current block to
nbytes, the size of the request. There are three cases. If the size of the current block is
less than the size requested, getmem moves to the next block on the list and continues
the search. If the size of the current block exactly matches the size of the request, get-
mem removes the block from the free list (by making the mnext field in the predecessor 
block point to the successor block), and returns a pointer to the current block. Finally, 
if the size of the current block is greater than the size requested, getmem partitions the 
current block into two pieces: one of size nbytes that will be returned to the caller, and a 
remaining piece that will be left on the free list. To divide a free block into two pieces, 
getmem computes the address of the remaining piece, and places the address in variable 
leftover. Computing such an address is conceptually simple: the leftover piece lies 
nbytes beyond the beginning of the block. However, adding nbytes to pointer curr will 
not produce the desired result because C performs pointer arithmetic. To force C to use 
integer arithmetic instead of pointer arithmetic, variable curr is cast to an unsigned in-
teger before adding nbytes:
(uint32) curr
Once a sum has been computed, another cast is applied to change the result back 
into a memory block pointer. After leftover has been computed, the mnext field of the 
prev block is updated, and the mnext and mlength fields in the leftover block are as-
signed.
The code relies on a fundamental mathematical relationship: subtracting two multi-
ples of K will produce a multiple of K. In the example, K is the size of a memblk struc-
ture, eight bytes. Thus, if the system begins by using roundmb to round the size of free 
memory, and always uses roundmb to round requests, each free block and each leftover 
piece will be large enough to hold a memblk structure.

Sec. 9.13        Allocating Stack Storage 
165
9.13 Allocating Stack Storage
Function getstk allocates a block of memory for a process stack. We will see that
getstk is invoked whenever a process is created. The code appears in file getstk.c.
Because the free list is kept in order by memory address and stack space is allocat-
ed from the highest available block, getstk must search the entire list of free blocks.
During the search, getstk records the address of any block that satisfies the request,
which means that after the search completes, the last recorded address points to the free 
block with the highest address that satisfies the request.† As with getmem, getstk main-
tains the invariant that during the search, variables curr and prev point to a free block of 
memory and the predecessor of the free block, respectively. Whenever a block is found 
that has sufficient size to satisfy the request, getstk sets variable fits to the address of the 
block and sets variable fitsprev to the address of its predecessor. Thus, when the search 
completes, fits points to the usable free block with the highest memory address (or will 
remain equal to NULL if no block satisfies the request).
Once the search completes and a block has been found, two cases arise, analogous 
to the cases in getmem. If the size of the block on the free list is exactly the size re-
quested, getstk unlinks the block from the free list and returns the address of the block 
to its caller. Otherwise, getstk partitions the block into two pieces, allocating a piece of 
size nbytes, and leaves the remainder on the free list. Because getstk returns the piece 
from the highest part of the selected block, the computation differs slightly from that in 
getmem.

†The strategy of allocating the block with the highest address that satisfies a request is known as the
last-fit strategy.

166 
Basic Memory Management 
Chap. 9
//** ggeettssttkk..cc -- ggeettssttkk **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ggeettssttkk
--
AAllllooccaattee ssttaacckk mmeemmoorryy,, rreettuurrnniinngg hhiigghheesstt wwoorrdd aaddddrreessss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
cchhaarr
**ggeettssttkk((
uuiinntt3322
nnbbyytteess
//** SSiizzee ooff mmeemmoorryy rreeqquueesstteedd
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
mmeemmbbllkk
**pprreevv,, **ccuurrrr;;
//** WWaallkk tthhrroouugghh mmeemmoorryy lliisstt
**//
ssttrruucctt
mmeemmbbllkk
**ffiittss,, **ffiittsspprreevv;; //** RReeccoorrdd bblloocckk tthhaatt ffiittss
**//
mmaasskk == ddiissaabbllee(());;
iiff ((nnbbyytteess ==== 00)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn ((cchhaarr **))SSYYSSEERRRR;;
}} 
nnbbyytteess == ((uuiinntt3322)) rroouunnddmmbb((nnbbyytteess));;
//** UUssee mmbblloocckk mmuullttiipplleess **//
pprreevv == &&mmeemmlliisstt;;
ccuurrrr == mmeemmlliisstt..mmnneexxtt;;
ffiittss == NNUULLLL;;
ffiittsspprreevv == NNUULLLL;;
//** JJuusstt ttoo aavvooiidd aa ccoommppiilleerr wwaarrnniinngg **//
wwhhiillee ((ccuurrrr !!== NNUULLLL)) {{
//** SSccaann eennttiirree lliisstt
**//
iiff ((ccuurrrr-->>mmlleennggtthh >>== nnbbyytteess)) {{
//** RReeccoorrdd bblloocckk aaddddrreessss **//
ffiittss == ccuurrrr;;
//**
wwhheenn rreeqquueesstt ffiittss
**//
ffiittsspprreevv == pprreevv;;
}} 
pprreevv == ccuurrrr;;
ccuurrrr == ccuurrrr-->>mmnneexxtt;;
}} 
iiff ((ffiittss ==== NNUULLLL)) {{
//** NNoo bblloocckk wwaass ffoouunndd
**//
rreessttoorree((mmaasskk));;
rreettuurrnn ((cchhaarr **))SSYYSSEERRRR;;
}} 
iiff ((nnbbyytteess ==== ffiittss-->>mmlleennggtthh)) {{
//** BBlloocckk iiss eexxaacctt mmaattcchh **//
ffiittsspprreevv-->>mmnneexxtt == ffiittss-->>mmnneexxtt;;
}} eellssee {{
//** RReemmoovvee ttoopp sseeccttiioonn
**//

Sec. 9.13        Allocating Stack Storage 
167
ffiittss-->>mmlleennggtthh --== nnbbyytteess;;
ffiittss == ((ssttrruucctt mmeemmbbllkk **))((((uuiinntt3322))ffiittss ++ ffiittss-->>mmlleennggtthh));;
}} 
mmeemmlliisstt..mmlleennggtthh --== nnbbyytteess;;
rreessttoorree((mmaasskk));;
rreettuurrnn ((cchhaarr **))((((uuiinntt3322)) ffiittss ++ nnbbyytteess -- ssiizzeeooff((uuiinntt3322))));;
}}
9.14 Releasing Heap And Stack Storage
Once it finishes using a block of heap storage, a process calls function freemem to 
return the block to the free list, making the memory eligible for subsequent allocation. 
Because blocks on the free list are kept in order by address, freemem uses the block’s 
address to find the correct location on the list. In addition, freemem handles the task of 
coalescing the block with adjacent free blocks. There are three cases: the new block of 
memory can be adjacent to the previous block, adjacent to the succeeding block, or ad-
jacent to both. When any of the three cases occurs, freemem combines the new block 
with adjacent block(s) to form one large block on the free list. Coalescing helps avoid 
memory fragmentation.
The code for freemem can be found in file freemem.c. As in getmem, two pointers, 
prev and next, run through the list of free blocks. Freemem searches the list until the 
address of the block to be returned lies between prev and next. Once the correct posi-
tion has been found, the code performs coalescing.
Coalescing is handled in three steps. The code first checks for coalescing with the 
previous block. That is, freemem adds the length of the previous block to the block’s 
address to compute the address one beyond the previous block.  Freemem compares the 
result, which is found in variable top, to the address of the block being inserted. If the 
address of the inserted block equals top, freemem increases the size of the previous 
block to include the new block. Otherwise, freemem inserts the new block in the list. 
Of course, if the previous pointer points to the head of the memlist, no coalescing can 
be performed.
Once it has handled coalescing with the previous block, freemem checks for 
coalescing with the next block. Once again, freemem computes the address that lies one 
beyond the current block, and tests whether the address is equal to the address of the 
next block. If so, the current block is adjacent to the next block, so freemem increases 
the size of the current block to include the next block, and unlinks the next block from 
the list.
The important point is that freemem handles all three special cases:
When adding a block to the free list, the memory manager must check
to see whether the new block is adjacent to the previous block, adja-
cent to the next block, or adjacent to both.

168 
Basic Memory Management 
Chap. 9
//** ffrreeeemmeemm..cc -- ffrreeeemmeemm **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ffrreeeemmeemm
--
FFrreeee aa mmeemmoorryy bblloocckk,, rreettuurrnniinngg tthhee bblloocckk ttoo tthhee ffrreeee lliisstt
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll ffrreeeemmeemm((
cchhaarr
**bbllkkaaddddrr,,
//** PPooiinntteerr ttoo mmeemmoorryy bblloocckk
**//
uuiinntt3322
nnbbyytteess
//** SSiizzee ooff bblloocckk iinn bbyytteess
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
mmeemmbbllkk
**nneexxtt,, **pprreevv,, **bblloocckk;;
uuiinntt3322
ttoopp;;
mmaasskk == ddiissaabbllee(());;
iiff ((((nnbbyytteess ==== 00)) |||| ((((uuiinntt3322)) bbllkkaaddddrr << ((uuiinntt3322)) mmiinnhheeaapp))
|||| ((((uuiinntt3322)) bbllkkaaddddrr >> ((uuiinntt3322)) mmaaxxhheeaapp)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
nnbbyytteess == ((uuiinntt3322)) rroouunnddmmbb((nnbbyytteess));;
//** UUssee mmeemmbbllkk mmuullttiipplleess **//
bblloocckk == ((ssttrruucctt mmeemmbbllkk **))bbllkkaaddddrr;;
pprreevv == &&mmeemmlliisstt;;
//** WWaallkk aalloonngg ffrreeee lliisstt **//
nneexxtt == mmeemmlliisstt..mmnneexxtt;;
wwhhiillee ((((nneexxtt !!== NNUULLLL)) &&&& ((nneexxtt << bblloocckk)))) {{
pprreevv == nneexxtt;;
nneexxtt == nneexxtt-->>mmnneexxtt;;
}} 
iiff ((pprreevv ==== &&mmeemmlliisstt)) {{
//** CCoommppuuttee ttoopp ooff pprreevviioouuss bblloocckk**//
ttoopp == ((uuiinntt3322)) NNUULLLL;;
}} eellssee {{
ttoopp == ((uuiinntt3322)) pprreevv ++ pprreevv-->>mmlleennggtthh;;
}} 
//** EEnnssuurree nneeww bblloocckk ddooeess nnoott oovveerrllaapp pprreevviioouuss oorr nneexxtt bblloocckkss
**//
iiff ((((((pprreevv !!== &&mmeemmlliisstt)) &&&& ((uuiinntt3322)) bblloocckk << ttoopp))
|||| ((((nneexxtt !!== NNUULLLL))
&&&& ((uuiinntt3322)) bblloocckk++nnbbyytteess>>((uuiinntt3322))nneexxtt)))) {{
rreessttoorree((mmaasskk));;

Sec. 9.14        Releasing Heap And Stack Storage 
169
rreettuurrnn SSYYSSEERRRR;;
}} 
mmeemmlliisstt..mmlleennggtthh ++== nnbbyytteess;;
//** EEiitthheerr ccooaalleessccee wwiitthh pprreevviioouuss bblloocckk oorr aadddd ttoo ffrreeee lliisstt **//
iiff ((ttoopp ==== ((uuiinntt3322)) bblloocckk)) {{
//** CCooaalleessccee wwiitthh pprreevviioouuss bblloocckk **//
pprreevv-->>mmlleennggtthh ++== nnbbyytteess;;
bblloocckk == pprreevv;;
}} eellssee {{
//** LLiinnkk iinnttoo lliisstt aass nneeww nnooddee
**//
bblloocckk-->>mmnneexxtt == nneexxtt;;
bblloocckk-->>mmlleennggtthh == nnbbyytteess;;
pprreevv-->>mmnneexxtt == bblloocckk;;
}} 
//** CCooaalleessccee wwiitthh nneexxtt bblloocckk iiff aaddjjaacceenntt **//
iiff ((((((uuiinntt3322)) bblloocckk ++ bblloocckk-->>mmlleennggtthh)) ==== ((uuiinntt3322)) nneexxtt)) {{
bblloocckk-->>mmlleennggtthh ++== nneexxtt-->>mmlleennggtthh;;
bblloocckk-->>mmnneexxtt == nneexxtt-->>mmnneexxtt;;
}} 
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}
Because free memory is treated as a single resource that can be used for stacks or 
heap storage, releasing stack memory follows the same algorithm as releasing heap 
storage. The only difference between heap and stack allocations arises because getmem 
returns the lowest address of an allocated block and getstk returns the highest address. 
In the current implementation, freestk is an inline function that invokes freemem. Be-
fore calling freemem, freestk must convert its argument from the highest address in a 
block to the lowest. The code is found in memory.h.† Although the current implemen-
tation uses a single underlying list, keeping freestk separate from freemem maintains a 
conceptual distinction, and makes it easier to modify the implementation later. The 
point is:
Although the current implementation uses the same underlying func-
tion to release heap and stack storage, having separate system calls 
for freestk and freemem maintains the conceptual distinction and 
makes the system easier to change later.

†File memory.h can be found on page 161.

170 
Basic Memory Management 
Chap. 9
9.15 Perspective
Although the mechanisms are relatively straightforward, the design of a memory 
management subsystem reveals one of the most surprisingly subtle problems in operat-
ing systems. The problem arises from a fundamental conflict. On the one hand, an 
operating system is designed to run without stopping. Therefore, operating system fa-
cilities must be resource-preserving: when a process finishes with a resource, the system 
must recapture the resource and make it available to other processes. On the other 
hand, any memory management mechanism that allows processes to allocate and free 
blocks of arbitrary size is not resource-preserving because memory can become frag-
mented, with free memory divided into small, discontiguous blocks. Thus, a designer 
must be aware that the choice represents a tradeoff. Allowing arbitrary-size allocations 
makes the system easier to use, but also introduces a potential for problems.
9.16 Summary
We use the term heavyweight process to refer to an application that runs in a
separate address space; a lightweight process abstraction permits one or more processes
to run in each address space.
A Xinu image contains three segments: a text segment consisting of compiled 
code, a data segment that contains initialized data values, and a bss segment that con-
tains uninitialized variables. When a system starts, physical memory not allocated to 
the three segments is considered free, and a low-level memory manager allocates the 
free memory on demand.
When Xinu starts, the low-level memory manager forms a linked list of all free 
memory blocks; both stack and heap storage is allocated from the list as needed. Heap 
storage is allocated by finding the first free memory block that satisfies the request (i.e., 
the free block with the lowest address). A request for stack storage is satisfied from the 
highest free memory block that satisfies the request. Because the list of free memory 
blocks is singly linked in order by address, allocating stack space requires searching the 
entire free list.
Our low-level memory manager treats free space as an exhaustable resource with 
no partition between stack and heap storage. Because the memory manager does not 
contain mechanisms to prevent a process from allocating all free memory, a program-
mer must plan carefully to avoid starvation.
EXERCISES
9.1 
Write a function that walks the list of free memory blocks and prints a line with the address
and length of each block.

Exercises
171
9.2   In the previous exercise, what can occur if your function does not disable interrupts while
searching the list?
9.3    An early version of the low-level memory manager had no provision for returning blocks of
memory to the free list. Speculate about memory allocation in an embedded system: are 
freemem and freestk necessary? Why or why not?
9.4 
Replace the low-level memory management functions with a set of functions that allocate
heap and stack memory permanently (i.e., without providing a mechanism to return storage
to a free list). How do the sizes of the new allocation routines compare to the sizes of 
getstk and getmem?
9.5 
Does the approach of allocating stack and heap storage from opposite ends of free space
help minimize fragmentation? To find out, consider a series of requests that intermix allo-
cation and freeing of stack storage of 1000 bytes and heap storage of 500 bytes. Compare 
the approach described in the chapter to an approach that allocates stack and heap requests 
from the same end of free space (i.e., an approach in which all allocation uses getmem). 
Find a sequence of requests that result in fragmentation if stack and heap requests are not 
allocated from separate ends.
9.6  At startup, function meminit is called to form an initial list of free memory. Compare mem-
init for the Galileo and BeagleBone Black platforms. Which is smaller? Which is more 
general? Explain the basic tradeoff.
9.7 
Many embedded systems go through a prototype stage, in which the system is built on a
general platform, and a final stage, in which minimal hardware is designed for the system.
In terms of memory management, one question concerns the size of the stack needed by
each process. Modify the code to allow the system to measure the maximum stack space
used by a process and report the maximum stack size when the process exits.
9.8 
Consider a hardware platform where the operating system must probe to find the size of
memory at startup (i.e., read from an address and either receive an exception or some ran-
dom value). Describe a strategy to find the maximum valid address efficiently.


Chapter Contents
10.1 
Introduction, 175
10.2 
Partitioned Space Allocation, 176
10.3 
Buffer Pools, 176
10.4 
Allocating A Buffer, 178
10.5 
Returning Buffers To The Buffer Pool, 179
10.6 
Creating A Buffer Pool, 181
10.7 
Initializing The Buffer Pool Table, 183
10.8 
Virtual Memory And Memory Multiplexing, 184
10.9 
Real And Virtual Address Spaces, 185
10.10 Hardware For Demand Paging, 186
10.11 Address Translation With A Page Table, 187 
10.12 Metadata In A Page Table Entry, 188
10.13 Demand Paging And Design Questions, 189 
10.14 Page Replacement And Global Clock, 190 
10.15 Perspective, 191
10.16 Summary, 191


10
High-level Memory 
Management and Virtual 
Memory
Yea, from the table of my memory I’ll wipe away all 
fond trivial records.
— William Shakespeare
10.1 Introduction
Earlier chapters consider abstractions that an operating system uses to manage 
computation and coordinate concurrent processes. The previous chapter describes a
low-level memory management facility that treats memory as an exhaustable resource. 
The chapter discusses address spaces, program segments, and functions that manage a 
global free list. Although they are necessary, low-level memory management facilities 
are not sufficient for all needs.
This chapter completes the discussion of memory management by introducing 
high-level facilities. The chapter explains the motivation for partitioning memory 
resources into independent subsets. It presents a high-level memory management mech-
anism that allows memory to be divided into independent buffer pools, and explains 
how allocation and use of the memory in a given pool does not affect the use of 
memory in other pools. The chapter also describes virtual memory, and explains how 
virtual memory hardware operates.
175

176 
High-level Memory Management and Virtual Memory 
Chap. 10
10.2 Partitioned Space Allocation
Functions getmem and freemem that were described in the previous chapter consti-
tute a basic memory manager. The design places no limit on the amount of memory
that a given process can allocate, nor do the functions attempt to divide free space “fair-
ly.” Instead, the allocation functions merely honor requests on a first-come-first-served 
basis until no free memory remains. Once free memory has been exhausted, the func-
tions reject further requests without blocking processes or waiting for memory to be 
released. Although it is relatively efficient, a global allocation strategy that forces all 
processes to contend for the same memory can lead to deprivation, a situation in which 
one or more processes cannot obtain memory because all memory has been consumed. 
As a consequence, global memory allocation schemes do not work well for all parts of 
the operating system.
To understand why a system cannot rely on global allocation, consider software for 
network communication. Packets arrive at random. Because a network application
takes time to process a given packet, additional packets may arrive while one is being 
handled. If each incoming packet is placed in a memory buffer, exhaustive allocation 
can lead to disaster because incoming packets will pile up occupying memory and wait-
ing to be processed. In the worst case, all the available memory will be allocated to 
packet buffers, and none will be available for other operating system functions. In par-
ticular, if disk I/O uses memory, all disk I/O may stop until memory becomes avail-
able. If the application processing network packets attempts to write to a file, deadlock 
can occur: the network process can block waiting for a disk buffer, but all memory is 
used for network buffers and no network buffer can be released until disk I/O com-
pletes.
To prevent deadlocks, higher-level memory management must be designed to parti-
tion free memory into independent subsets, and ensure that allocation and deallocation
of a given subset remains independent from the allocation and deallocation of other sub-
sets. By limiting the amount of memory that can be used for a particular function, the 
system can guarantee that excessive requests will not lead to global deprivation. Fur-
thermore, the system can assume that memory allocated for a particular function will al-
ways be returned, so it can arrange to suspend processes until their memory request can 
be satisfied, eliminating the overhead introduced by busy waiting. Partitioning cannot 
guarantee that no deadlocks will occur, but it does limit unintentional deadlocks that 
arise when one subsystem takes memory needed by another subsystem.
10.3 Buffer Pools
The mechanism we have chosen to handle partitioned memory is known as a buffer 
pool manager. Memory is divided into a set of buffer pools. Each buffer pool contains 
a fixed number of memory blocks, and all blocks in a given pool are the same size. 
The term buffer was chosen to reflect the intended use in I/O routines and communica-
tion software (e.g., disk buffers or buffers for network packets).

Sec. 10.3        Buffer Pools
177
The memory space for a particular set of buffers is allocated when the pool is 
created; once a pool has been allocated, there is no way to increase the number of
buffers in the pool or to change the buffer size.
Each buffer pool is identified by an integer, known as a pool identifier or buffer
pool ID. Like other IDs in Xinu, a buffer pool ID is used as an index into the buffer
pool table, buftab. Once a pool has been created, a process uses the pool ID whenever
it requests a buffer from a pool or releases a previously allocated buffer back to a pool. 
Requests to allocate or release a buffer from a pool do not need to specify the length of 
a buffer because the size of buffers is fixed when the pool is created.
The data structure used to hold information about buffer pools consists of a single 
table. Each entry in the table holds a buffer size, a semaphore ID, and a pointer to a
linked list of buffers for the pool. Pertinent declarations can be found in file bufpool.h:
//** bbuuffppooooll..hh **//
##iiffnnddeeff NNBBPPOOOOLLSS
##ddeeffiinnee NNBBPPOOOOLLSS 2200
//** MMaaxxiimmuumm nnuummbbeerr ooff bbuuffffeerr ppoooollss
**//
##eennddiiff
##iiffnnddeeff BBPP__MMAAXXBB
##ddeeffiinnee BBPP__MMAAXXBB 88119922
//** MMaaxxiimmuumm bbuuffffeerr ssiizzee iinn bbyytteess
**//
##eennddiiff
##ddeeffiinnee BBPP__MMIINNBB 88
//** MMiinniimmuumm bbuuffffeerr ssiizzee iinn bbyytteess
**//
##iiffnnddeeff BBPP__MMAAXXNN
##ddeeffiinnee BBPP__MMAAXXNN 22004488
//** MMaaxxiimmuumm nnuummbbeerr ooff bbuuffffeerrss iinn aa ppooooll
**//
##eennddiiff
ssttrruucctt
bbppeennttrryy {{
//** DDeessccrriippttiioonn ooff aa ssiinnggllee bbuuffffeerr ppooooll
**//
ssttrruucctt
bbppeennttrryy **bbppnneexxtt;;//** ppooiinntteerr ttoo nneexxtt ffrreeee bbuuffffeerr
**//
ssiidd3322
bbppsseemm;;
//** sseemmaapphhoorree tthhaatt ccoouunnttss bbuuffffeerrss
**//
//**
ccuurrrreennttllyy aavvaaiillaabbllee iinn tthhee ppooooll
**//
uuiinntt3322
bbppssiizzee;;
//** ssiizzee ooff bbuuffffeerrss iinn tthhiiss ppooooll
**//
}};;
eexxtteerrnn
ssttrruucctt
bbppeennttrryy bbuuffttaabb[[]];;//** BBuuffffeerr ppooooll ttaabbllee
**//
eexxtteerrnn
bbppiidd3322
nnbbppoooollss;;
//** ccuurrrreenntt nnuummbbeerr ooff aallllooccaatteedd ppoooollss
**//
Structure bpentry defines the contents of an entry in the buffer pool table, buftab. 
The buffers for a given pool are linked into a list, with field bpnext pointing to the first 
buffer on the list. Semaphore bpsem controls allocation from the pool, and integer 
bpsize gives the length of buffers in the pool.

178 
High-level Memory Management and Virtual Memory 
Chap. 10
10.4 Allocating A Buffer
The buffer pool mechanism differs from the low-level memory manager in another 
way: the mechanism is synchronous. That is, a process that requests a buffer will be 
blocked until the request can be satisfied. As in many of the previous examples, the 
implementation uses semaphores to control access to a buffer pool. Each buffer pool 
has a semaphore, and the code that allocates a buffer calls wait on a pool’s semaphore. 
The call returns immediately if buffers remain in the pool, but blocks the caller if no 
buffers remain. Eventually, when another process returns a buffer to a pool, the sema-
phore is signaled, which allows a waiting process to obtain the buffer and resume exe-
cution.
Three functions provide an interface to buffer pools. A process calls function 
mkpool to create a buffer pool and obtain an ID. Once a pool as been created, a process 
can call function getbuf to obtain a buffer, and function freebuf to release a buffer back 
to the pool.  Getbuf works as expected, waiting on the semaphore until a buffer is avail-
able, and then unlinking the first buffer from the list. The code is found in file getbuf.c:
//** ggeettbbuuff..cc -- ggeettbbuuff **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ggeettbbuuff
--
GGeett aa bbuuffffeerr ffrroomm aa pprreeeessttaabblliisshheedd bbuuffffeerr ppooooll
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
cchhaarr
**ggeettbbuuff((
bbppiidd3322
ppoooolliidd
//** IInnddeexx ooff ppooooll iinn bbuuffttaabb
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
bbppeennttrryy **bbppppttrr;;
//** PPooiinntteerr ttoo eennttrryy iinn bbuuffttaabb
**//
ssttrruucctt
bbppeennttrryy **bbuuffppttrr;;
//** PPooiinntteerr ttoo aa bbuuffffeerr
**//
mmaasskk == ddiissaabbllee(());;
//** CChheecckk aarrgguummeennttss **//
iiff (( ((ppoooolliidd << 00
||||
ppoooolliidd >>== nnbbppoooollss)) )) {{
rreessttoorree((mmaasskk));;
rreettuurrnn ((cchhaarr **))SSYYSSEERRRR;;
}} 
bbppppttrr == &&bbuuffttaabb[[ppoooolliidd]];;

Sec. 10.4        Allocating A Buffer 
179
//** WWaaiitt ffoorr ppooooll ttoo hhaavvee >> 00 bbuuffffeerrss aanndd aallllooccaattee aa bbuuffffeerr **//
wwaaiitt((bbppppttrr-->>bbppsseemm));;
bbuuffppttrr == bbppppttrr-->>bbppnneexxtt;;
//** UUnnlliinnkk bbuuffffeerr ffrroomm ppooooll **//
bbppppttrr-->>bbppnneexxtt == bbuuffppttrr-->>bbppnneexxtt;;
//** RReeccoorrdd ppooooll IIDD iinn ffiirrsstt ffoouurr bbyytteess ooff bbuuffffeerr aanndd sskkiipp **//
**((bbppiidd3322 **))bbuuffppttrr == ppoooolliidd;;
bbuuffppttrr == ((ssttrruucctt bbppeennttrryy **))((ssiizzeeooff((bbppiidd3322)) ++ ((cchhaarr **))bbuuffppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn ((cchhaarr **))bbuuffppttrr;;
}}
Observant readers may have noticed that getbuf does not return the address of the 
buffer to its caller. Instead, getbuf stores the pool ID in the first four bytes of the allo-
cated space, and returns the address just beyond the ID. From a caller’s point of view, 
a call to getbuf returns the address of a buffer; the caller does not need to worry that 
earlier bytes hold the pool ID. The system is transparent: when the pool is created, ex-
tra space is allocated in each buffer to hold the pool ID. When a buffer is released, 
freebuf uses the hidden pool ID to determine the pool to which a buffer belongs. The 
technique of using hidden information to identify a buffer pool turns out to be especial-
ly useful when buffers are returned by a process other than the one that allocated the 
buffer.
10.5 Returning Buffers To The Buffer Pool
Function freebuf returns a buffer to the pool from which it was allocated. The
code is found in file freebuf.c:

180 
High-level Memory Management and Virtual Memory 
Chap. 10
//** ffrreeeebbuuff..cc -- ffrreeeebbuuff **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ffrreeeebbuuff
--
FFrreeee aa bbuuffffeerr tthhaatt wwaass aallllooccaatteedd ffrroomm aa ppooooll bbyy ggeettbbuuff
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll ffrreeeebbuuff((
cchhaarr
**bbuuffaaddddrr
//** AAddddrreessss ooff bbuuffffeerr ttoo rreettuurrnn
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
bbppeennttrryy **bbppppttrr;;
//** PPooiinntteerr ttoo eennttrryy iinn bbuuffttaabb
**//
bbppiidd3322
ppoooolliidd;;
//** IIDD ooff bbuuffffeerr’’ss ppooooll
**//
mmaasskk == ddiissaabbllee(());;
//** EExxttrraacctt ppooooll IIDD ffrroomm iinntteeggeerr pprriioorr ttoo bbuuffffeerr aaddddrreessss **//
bbuuffaaddddrr --== ssiizzeeooff((bbppiidd3322));;
ppoooolliidd == **((bbppiidd3322 **))bbuuffaaddddrr;;
iiff ((ppoooolliidd << 00
||||
ppoooolliidd >>== nnbbppoooollss)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** GGeett aaddddrreessss ooff ccoorrrreecctt ppooooll eennttrryy iinn ttaabbllee **//
bbppppttrr == &&bbuuffttaabb[[ppoooolliidd]];;
//** IInnsseerrtt bbuuffffeerr iinnttoo lliisstt aanndd ssiiggnnaall sseemmaapphhoorree **//
((((ssttrruucctt bbppeennttrryy **))bbuuffaaddddrr))-->>bbppnneexxtt == bbppppttrr-->>bbppnneexxtt;;
bbppppttrr-->>bbppnneexxtt == ((ssttrruucctt bbppeennttrryy **))bbuuffaaddddrr;;
ssiiggnnaall((bbppppttrr-->>bbppsseemm));;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}
Recall that when it allocates a buffer, getbuf stores the pool ID in the four bytes
that precede the buffer address. Freebuf moves back four bytes from the beginning of
the buffer, and extracts the pool ID. After verifying that the pool ID is valid, getbuf
uses the ID to locate the entry in the table of buffer pools. It then links the buffer back

Sec. 10.5        Returning Buffers To The Buffer Pool 
181
into the linked list of buffers, and signals the pool semaphore bpsem, allowing other 
processes to use the buffer.
10.6 Creating A Buffer Pool
Function mkbufpool creates a new buffer pool and returns its ID. Mkbufpool takes
two arguments: the size of buffers in the pool and the number of buffers. Mkbufpool
begins by checking its arguments. If the buffer size is out of range, the requested
number of buffers is negative, or the buffer pool table is full, mkbufpool reports an er-
ror.  Mkbufpool computes the size of memory required to hold the buffers, and calls get-
mem to allocate the needed memory. If the memory allocation succeeds, mkbufpool al-
locates an entry in the buffer pool table, and fills in entries. It creates a semaphore, 
saves the buffer size, and stores the address of the allocated memory in the linked list 
pointer, bpnext.
Once the table entry has been initialized, mkbufpool iterates through the allocated 
memory, dividing the block into a set of buffers. It links each buffer onto the free list. 
Note that when mkbufpool creates the free list, each block of memory contains the size 
of the buffer the user requested plus the size of a buffer pool ID (four bytes). Thus, 
after the buffer pool ID is stored in the block, sufficient bytes remain for the buffer that 
the user requested. After the free list has been formed, mkbufpool returns the pool ID to 
its caller.

182 
High-level Memory Management and Virtual Memory 
Chap. 10
//** mmkkbbuuffppooooll..cc -- mmkkbbuuffppooooll **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
mmkkbbuuffppooooll
--
AAllllooccaattee mmeemmoorryy ffoorr aa bbuuffffeerr ppooooll aanndd lliinnkk tthhee bbuuffffeerrss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
bbppiidd3322
mmkkbbuuffppooooll((
iinntt3322
bbuuffssiizz,,
//** SSiizzee ooff aa bbuuffffeerr iinn tthhee ppooooll **//
iinntt3322
nnuummbbuuffss
//** NNuummbbeerr ooff bbuuffffeerrss iinn tthhee ppooooll**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
bbppiidd3322
ppoooolliidd;;
//** IIDD ooff ppooooll tthhaatt iiss ccrreeaatteedd
**//
ssttrruucctt
bbppeennttrryy **bbppppttrr;;
//** PPooiinntteerr ttoo eennttrryy iinn bbuuffttaabb
**//
cchhaarr
**bbuuff;;
//** PPooiinntteerr ttoo mmeemmoorryy ffoorr bbuuffffeerr **//
mmaasskk == ddiissaabbllee(());;
iiff ((bbuuffssiizz<<BBPP__MMIINNBB |||| bbuuffssiizz>>BBPP__MMAAXXBB
|||| nnuummbbuuffss<<11 |||| nnuummbbuuffss>>BBPP__MMAAXXNN
|||| nnbbppoooollss >>== NNBBPPOOOOLLSS)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn ((bbppiidd3322))SSYYSSEERRRR;;
}} 
//** RRoouunndd rreeqquueesstt ttoo aa mmuullttiippllee ooff 44 bbyytteess **//
bbuuffssiizz == (( ((bbuuffssiizz ++ 33)) && ((~~33)) ));;
bbuuff == ((cchhaarr **))ggeettmmeemm(( nnuummbbuuffss ** ((bbuuffssiizz++ssiizzeeooff((bbppiidd3322)))) ));;
iiff ((((iinntt3322))bbuuff ==== SSYYSSEERRRR)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn ((bbppiidd3322))SSYYSSEERRRR;;
}} 
ppoooolliidd == nnbbppoooollss++++;;
bbppppttrr == &&bbuuffttaabb[[ppoooolliidd]];;
bbppppttrr-->>bbppnneexxtt == ((ssttrruucctt bbppeennttrryy **))bbuuff;;
bbppppttrr-->>bbppssiizzee == bbuuffssiizz;;
iiff (( ((bbppppttrr-->>bbppsseemm == sseemmccrreeaattee((nnuummbbuuffss)))) ==== SSYYSSEERRRR)) {{
nnbbppoooollss----;;
rreessttoorree((mmaasskk));;
rreettuurrnn ((bbppiidd3322))SSYYSSEERRRR;;
}} 
bbuuffssiizz++==ssiizzeeooff((bbppiidd3322));;
ffoorr ((nnuummbbuuffss---- ;; nnuummbbuuffss>>00 ;; nnuummbbuuffss---- )) {{

Sec. 10.6        Creating A Buffer Pool 
183
bbppppttrr == ((ssttrruucctt bbppeennttrryy **))bbuuff;;
bbuuff ++== bbuuffssiizz;;
bbppppttrr-->>bbppnneexxtt == ((ssttrruucctt bbppeennttrryy **))bbuuff;;
}} 
bbppppttrr == ((ssttrruucctt bbppeennttrryy **))bbuuff;;
bbppppttrr-->>bbppnneexxtt == ((ssttrruucctt bbppeennttrryy **))NNUULLLL;;
rreessttoorree((mmaasskk));;
rreettuurrnn ppoooolliidd;;
}}
10.7 Initializing The Buffer Pool Table
Function bufinit initializes the buffer pool table. Initialization occurs once before 
the buffer pools are used (i.e., the table is initialized when the system boots). The code, 
found in file bufinit.c, is trivial:
//** bbuuffiinniitt..cc -- bbuuffiinniitt **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt
bbppeennttrryy bbuuffttaabb[[NNBBPPOOOOLLSS]];;
//** BBuuffffeerr ppooooll ttaabbllee
**//
bbppiidd3322
nnbbppoooollss;;
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
bbuuffiinniitt
--
IInniittiiaalliizzee tthhee bbuuffffeerr ppooooll ddaattaa ssttrruuccttuurree
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
bbuuffiinniitt((vvooiidd))
{{
nnbbppoooollss == 00;;
rreettuurrnn OOKK;;
}}
All that bufinit needs to do is set the global count of allocated buffer pools. In the 
example code, buffer pools can be allocated dynamically. However, once it has been 
allocated, a pool cannot be deallocated. An exercise suggests extending the mechanism 
to permit dynamic deallocation.

184 
High-level Memory Management and Virtual Memory 
Chap. 10
10.8 Virtual Memory And Memory Multiplexing
Most large computer systems virtualize memory and present an application with an 
abstract view of memory. Each application appears to occupy a large address space; on
a system with a small physical memory, the address space can exceed the size of physi-
cal memory. The operating system multiplexes physical memory among all processes 
that need to use it, moving all or part of the application into physical memory as need-
ed. That is, code and data for processes are kept on secondary storage (i.e., disk), and 
moved into main memory temporarily when the process is executing. Although few 
embedded systems rely on virtual memory, many processors include virtual memory 
hardware.
The chief design question in virtual memory management systems concerns the
form of multiplexing. Several possibilities have been used:
d Swapping
d Segmentation
d Paging
Swapping refers to an approach that moves all code and data associated with a par-
ticular computation into main memory when the scheduler makes the computation 
current. Swapping works best for a long-running computation, such as a word proces-
sor that runs while a human types a document — the computation is moved into main 
memory, and remains resident for a long period.
Segmentation refers to an approach that moves pieces of the code and data associ-
ated with a computation into main memory as needed. One can imagine, for example, 
placing each function and the associated variables in a separate segment. When a func-
tion is called, the operating system loads the segment containing the function into main 
memory. Seldom-used functions (e.g., a function that displays an error message) 
remain on secondary storage. In theory, segmentation uses less memory than swapping 
because segmentation allows pieces of a computation to be loaded into memory as 
needed. Although the approach has intuitive appeal, few operating systems use dynam-
ic segmentation.
Paging refers to an approach that divides each program into small, fixed-size 
pieces called pages. The system keeps the most recently referenced pages in main 
memory, and moves copies of other pages to secondary storage. Pages are fetched on 
demand — when a running program references memory location i, the memory 
hardware checks to see whether the page containing location i is resident (i.e., currently 
in memory). If the page is not resident, the operating system suspends the process (al-
lowing other processes to execute), and issues a request to the disk to obtain a copy of 
the needed page. Once the page has been placed in main memory, the operating system 
makes the process ready. When the process retries the reference to location i, the refer-
ence succeeds.

Sec. 10.9        Real And Virtual Address Spaces 
185
10.9 Real And Virtual Address Spaces
In many operating systems, the memory manager supplies each computation with 
its own, independent address space. That is, an application is given a private set of 
memory locations that are numbered 0 through M – 1. The operating system works with 
the underlying hardware to map each address space to a set of memory locations in 
memory. As a result, when an application references address zero, the reference is 
mapped to the memory location that corresponds to zero for the process. When another 
application references address zero, the reference is mapped to a different location. 
Thus, although multiple applications can reference address zero, each reference maps to 
a separate location, and the applications do not interfere with one another. To be pre-
cise, we use the term physical address space or real address space to define the set of 
addresses that the memory hardware provides, and the term virtual address space to 
describe the set of addresses available to a given computation. At any time, memory 
functions in the operating system map one or more virtual address spaces onto the 
underlying physical address space. For example, Figure 10.1 illustrates how three virtu-
al address spaces of K locations can be mapped onto an underlying physical address 
space that contains 3K locations.
virtual 
space 
3
virtual 
space 
2
virtual 
space 
1
physical 
memory
. . . . . . . . . . .
. . . . . . . . . . .
0
K – 1
0
K – 1
0
K – 1
0
K – 1
K
2K – 1
2K
3K – 1
Figure 10.1 Illustration of three virtual address spaces mapped onto a single
underlying physical address space.
From the point of view of a running computation, only addresses in the virtual ad-
dress space can be referenced. Furthermore, because the system maps each address
from a given virtual space to a specific region of memory, the running computation can-
not accidentally read or overwrite memory that has been allocated to another computa-
tion. As a result, a system that provides each computation with its own virtual address

186 
High-level Memory Management and Virtual Memory 
Chap. 10
space helps detect programming errors and prevent problems. The point can be sum-
marized:
A memory management system that maps each virtual address space 
into a unique block of memory prevents one computation from reading 
or writing memory allocated to another computation.
In Figure 10.1, each virtual address space is smaller than the underlying physical 
address space. However, most memory management systems permit a virtual address 
space to be larger than the memory on the machine. For example, a demand paging 
system only keeps pages that are being referenced in main memory, and leaves copies 
of other pages on disk.
The original research on virtual memory arose from two motivations. First, the 
small size of physical memory limited the size of programs that were feasible. Second, 
with only one program running, a processor remained idle during I/O cycles. On the 
one hand, if multiple programs can be placed in memory, an operating system can 
switch the processor among them, allowing one to execute while another waits for an 
I/O operation. On the other hand, squeezing more programs into a fixed memory 
means each program will have less allocated memory, forcing the programs to be small. 
So, demand paging arose as a mechanism that handled both problems. By dividing pro-
grams into many pieces, a demand paging system can choose to keep parts of many 
programs in memory, keeping the processor busy when a program waits for I/O. By al-
lowing pieces of a program’s address space to be resident in memory without requiring 
space for the entire program, a demand paging system can support an address space that 
is larger than physical memory.
10.10 Hardware For Demand Paging
An operating system that maps between virtual and real addresses cannot operate 
without hardware support. To understand why, observe that each address, including ad-
dresses generated at runtime, must be mapped. Thus, if a program computes a value C 
and then jumps to location C, the memory system must map C to the corresponding real 
memory address. Only a hardware unit can perform the mapping efficiently.
The hardware needed for demand paging consists of a page table and an address 
translation unit. A page table resides in kernel memory, and there is one page table for 
each process. Typically, the hardware contains a register that points to the current page 
table and a second register that specifies the length; after it has created a page table in 
memory, the operating system assigns values to the registers and turns on demand pag-
ing. Similarly, when a context switch occurs, the operating system changes the page 
table registers to point to the page table for the new process. Figure 10.2 illustrates the 
arrangement.

Sec. 10.10        Hardware For Demand Paging 
187
Process 1 
Page Table
Process N 
Page Table
Process 2 
Page Table 
(active)
. . .
L
Page Table Base Register
Page Table Length Register
L
Figure 10.2  Page tables in memory and hardware registers that specify which
page table to use at a given time.
10.11 Address Translation With A Page Table
Conceptually, a page table consists of an array of pointers to memory locations. In 
addition to a pointer, each entry contains a bit that specifies whether the entry is valid 
(i.e., whether it has been initialized). Address translation hardware uses the current
page table to translate a memory address; translation is applied to the instruction ad-
dresses as well as addresses used to fetch or store data. Translation consists of array 
lookup: the hardware treats the high-order bits of an address as a page number, uses the 
page number as an index into the page table, and follows the pointer to the location of 
the page in memory.
In practice, a page table entry does not contain a complete memory pointer. In-
stead, pages are restricted to start in memory locations that have zeroes in the low-order 
bits, and the low-order bits are omitted from each page table entry. For example, sup-
pose a computer has 32-bit addressing and uses 4096-byte pages (i.e., each page con-
tains 212 bytes). If memory is divided into a set of 4096-byte frames, the starting ad-
dress of each frame (i.e., the address of the first byte in the frame) will have zeroes in 
the 12 low-order bits. Therefore, to point to a frame in memory, a page table entry only 
needs to contain the upper 20 bits.
To translate an address, A, the hardware uses the upper bits of A as an index into
the page table, extracts the address of a frame in memory where the page resides, and
then uses the low-order bits of A as an offset into the frame. We can imagine that the 
translation forms a physical memory address as Figure 10.3 illustrates.

188 
High-level Memory Management and Virtual Memory 
Chap. 10
P
O
F
O
F
page table
Pth Entry in Page
Table (20 bits)
Virtual Address 
(32 bits)
Resulting Physical 
Address (32 bits)
Page Number (20 bits) 
Offset (12 bits)
Figure 10.3  An example of virtual address translation used with paging.
Our description implies that each address translation requires a page table access 
(i.e., a memory access). However, such overhead would be intolerable. To make trans-
lation efficient, a processor employs a special-purpose hardware unit known as a Trans-
lation Look-aside Buffer (TLB). The TLB caches recently accessed page table entries, 
and can look up the answer much faster than a conventional memory access. To 
achieve high speed, a TLB uses a form of parallel hardware known as a Content-
Addressable Memory (CAM). Given an address, CAM hardware searches a set of stored 
values in parallel, returning the answer in only a few clock cycles. As a result, a TLB 
enables a processor to run as fast with address translation turned on as it can with ad-
dress translation disabled.
10.12 Metadata In A Page Table Entry
In addition to a frame pointer, each page table entry contains three bits of metadata
that the hardware and operating system use. Figure 10.4 lists the bits and their mean-
ing.

Sec. 10.12        Metadata In A Page Table Entry 
189

Name 
Meaning

Use Bit 
Set by hardware whenever the page
is referenced (fetch or store)

Modify Bit 
Set by hardware whenever a store
operation changes data on the page

Presence Bit 
Set by OS to indicate whether the
page is resident in memory


































Figure 10.4  The three metabits in each page table entry and their meanings.
10.13 Demand Paging And Design Questions
The term demand paging refers to a system where an operating system places the 
pages for all processes on secondary storage, and only reads a page into memory when
the page is needed (i.e., on demand). Special processor hardware is required to support 
demand paging: if a process attempts to access a page that is not resident in memory, 
the hardware must suspend execution of the current instruction and notify the operating 
system by signaling a page fault exception. When a page fault occurs, the operating 
system finds an unused frame in memory, reads the needed page from disk, and then in-
structs the processor to resume the instruction that caused the fault.
When a computer first starts, memory is relatively empty, which makes finding a 
free frame easy. Eventually, however, all frames in memory will be filled and the 
operating system must select one of the filled frames, copy the page back to disk (if the 
page has been modified), fetch the new page, and change the page tables accordingly. 
The selection of a page to move back to disk forms a key problem for operating sys-
tems designers.
The design of a paging system centers on the relationship between pages and 
processes. When process X encounters a page fault, should the operating system move
one of process X’s pages back to disk, or should the system select a page from another 
process? While a page is being fetched from disk, the operating system can run another 
process. How can the operating system ensure that at least some process has enough 
pages to run without also generating a page fault?† Should some pages be locked in 
memory? If so, which ones? How will the page selection policy interact with other 
policies, such as scheduling? For example, should the operating system guarantee each 
high-priority process a minimum number of resident pages? If the system allows 
processes to share memory, what policies apply to the shared pages?
One of the interesting tradeoffs in the design of a paging system arises from the 
balance between I/O and processing. Paging overhead and the latency a process experi-
ences can be reduced by giving a process the maximal amount of physical memory 
when the process runs. However, many processes are I/O-bound, which means that a 
given process is likely to block waiting for I/O. When one process blocks, overall per-

†If insufficient frames exist in memory, a paging system can thrash, which means the frequency of page 
faults becomes so high that the system spends all its time paging and each process spends long periods waiting 
for pages.

190 
High-level Memory Management and Virtual Memory 
Chap. 10
formance is maximized if another process is ready to execute and the operating system 
can switch context. That is, processor utilization and overall throughput of a system 
can be increased by having many processes ready to execute. So the question arises: 
should a given process be allowed to use many frames of memory or should memory be 
divided among processes?
10.14 Page Replacement And Global Clock
Various page replacement policies have been proposed and tried:
d Least Recently Used (LRU)
d Least Frequently Used (LFU)
d First In First Out (FIFO)
Interestingly, a provably optimal replacement policy has been discovered. Known 
as Belady’s optimal page replacement algorithm, the policy chooses to replace the page 
that will be referenced farthest in the future. Of course, the method is totally impracti-
cal because the operating system cannot know how pages will be used in the future. 
However, Belady’s algorithm allows researchers to assess how well replacement poli-
cies perform.
In terms of practical systems, a single algorithm has become the de facto standard
for page replacement. Known as global clock or second chance, the algorithm was de-
vised as part of the MULTICS operating system and has relatively low overhead. The 
term global means that all processes compete with one another (i.e., when process X 
generates a page fault, the operating system can choose a frame from another process, 
Y). The alternative name of the algorithm arises because global clock is said to give 
used frames a “second chance” before they are reclaimed.
Global clock starts running whenever a page fault occurs. The algorithm maintains 
a pointer that sweeps through all the frames in memory, stopping when a free frame is 
found. The next time it runs, the algorithm starts at the frame just beyond where it left 
off.
To determine whether to select a frame, global clock checks the Use and Modify
bits in the page table of the frame. If the Use / Modify bits have value (0,0), global
clock chooses the frame. If the bits are (1,0), global clock resets them to (0,0) and by-
passes the frame. Finally, if the bits are (1,1), global clock changes them to (1,0) and 
bypasses the frame, keeping a copy of the modified bit to know whether the page has 
been modified. In the worst case, global clock sweeps through all frames twice before 
reclaiming one.
In practice, most implementations use a separate process to run the global clock al-
gorithm (which allows the clock to perform disk I/O). Furthermore, global clock does
not stop immediately once a frame has been found. Instead, the algorithm continues to 
run, and collects a small set of candidate pages. Collecting a set allows subsequent 
page faults to be handled quickly and avoids the overhead associated with running the 
global clock algorithm frequently (i.e., avoids frequent context switching).

Sec. 10.15        Perspective
191
10.15 Perspective
Although address space management and virtual memory subsystems comprise
many lines of code in an operating system, the most significant intellectual aspects of
the problem arise from the choice of allocation policies and the consequent tradeoffs. 
Allowing each subsystem to allocate arbitrary amounts of memory maximizes flexibility 
and avoids the problem of a subsystem being deprived when free memory exists. Parti-
tioning memory maximizes protection and avoids the problem of having one subsystem 
deprive other subsystems. Thus, a tradeoff exists between flexibility and protection.
Despite years of research, no general solution for page replacement has emerged,
the tradeoffs have not been quantified, and no general guidelines exist. Similarly,
despite years of research on virtual memory systems, no demand paging algorithms ex-
ist that work well for small memories. Fortunately, economics and technology have
made many of the problems associated with memory management irrelevant: DRAM
chip density increased rapidly, making huge memories inexpensive. As a result, com-
puter vendors avoid memory management altogether by making the memory on each 
new product much larger than the memory on the previous product. Because memory is 
so large, the operating system can satisfy the needs of a process without taking frames 
from other processes. That is, a demand paging system works well not because we 
have devised excellent replacement algorithms, but because memories have grown so 
large that replacement algorithms are seldom invoked.
10.16 Summary
Low-level memory allocation mechanisms treat all of free memory as a single, ex-
haustible resource. High-level memory management facilities that allow memory to be 
partitioned into separate regions provide guarantees that prevent one subsystem from us-
ing all available memory.
The high-level memory management functions in Xinu use a buffer pool paradigm
in which a fixed set of buffers is allocated in each pool. Once a pool has been created,
a group of processes can allocate and free buffers dynamically. The buffer pool inter-
face is synchronous: a given process will block until a buffer becomes available.
Large operating systems use virtual memory mechanisms to allocate a separate ad-
dress space for each process. The most popular virtual memory mechanism, paging, 
divides the address space into fixed-size pages, and loads pages on demand. Hardware 
is needed to support paging because each memory reference must be mapped from a 
virtual address to a corresponding physical address. Paging systems only perform satis-
factorily if memory is large enough to avoid running the page replacement algorithm 
frequently.

192 
High-level Memory Management and Virtual Memory 
Chap. 10
EXERCISES
10.1  
Design a new getmem that subsumes getbuf. Hint: allow the user to suballocate from a
previously allocated block of memory.
10.2  
Mkbufpool forms a linked list of all buffers in a pool. Explain how to modify the code
so it allocates memory but does not link buffers together until a call to getbuf requires a
new buffer to be allocated.
10.3  
Is freebuf more efficient than freemem? Justify your answer.
10.4 
Revise the buffer pool allocation mechanism to allow deallocation of buffer pools.
10.5 
The current implementation of buffer pools hides a pool ID in memory just prior to the
buffer. Rewrite freebuf to eliminate the need for a pool ID. Ensure your version of 
freebuf will detect an invalid address (i.e., will not return a buffer to a pool unless the 
buffer was previously allocated from the pool).
10.6 
Consider a modification of the buffer pool mechanism in which mkbufpool stores the
pool ID in the first four bytes of a buffer and then uses the next four bytes in the buffer
to store a pointer when linking the buffer onto a free list. What are the advantages of
such an approach?
10.7  
Suppose a processor has support for paging. Describe paging hardware that can be used
to protect a process’s stack from access by other processes, even if demand paging is not 
implemented (i.e., all pages remain resident and no replacement is performed).
10.8 
Implement the scheme devised in the previous exercise to protect stacks in Xinu.
10.9 
Build a demand paging version of Xinu.
10.10 
Sketch the data structures an operating system needs to maintain for demand paging.
Hint: think of a page replacement algorithm, such as global clock.

Chapter Contents
11.1 
Introduction, 195
11.2 
Inter–process Communication Ports, 195
11.3 
The Implementation Of Ports, 196
11.4 
Port Table Initialization, 197
11.5 
Port Creation, 199
11.6 
Sending A Message To A Port, 200
11.7 
Receiving A Message From A Port, 202
11.8 
Port Deletion And Reset, 204
11.9 
Perspective, 207
11.10 Summary, 207


11
High-level Message 
Passing
I’m always uneasy with messages.
— Neil Tennant
11.1 Introduction
Chapter 8 describes a low-level message passing facility that permits a process to 
pass a message directly to another process. Although it provides a useful function, the 
low-level message passing system cannot be used to coordinate multiple receivers, nor 
can a given process participate in several message exchanges without interference 
among them.
This chapter completes the discussion of message passing by introducing a high-
level facility that provides a synchronous interface for buffered message exchange. The 
message mechanism allows an arbitrary subset of processes to pass messages without 
affecting other processes. It introduces the concept of named rendezvous points that ex-
ist independent of processes. The implementation uses the buffer pool mechanism from 
the previous chapter.
11.2 Inter–process Communication Ports
Xinu uses the term inter-process communication port to refer to a rendezvous point 
through which processes can exchange messages. Message passing through ports 
differs from process-to-process message passing described in Chapter 8 because ports
195

196 
High-level Message Passing 
Chap. 11
allow multiple outstanding messages, allow multiple processes to receive from a port,
and processes sending or receiving messages are blocked until requests can be satisfied. 
Each port is configured to hold up to a specified number of messages; each message oc-
cupies a 32-bit word. Once it has produced a message, a process can use function 
ptsend to send the message to a port. Messages are deposited in a port in FIFO order. 
Once a message has been sent, the sending process can continue to execute. At any 
time, a process can call function ptrecv to receive the next message from a port.
Both message sending and receiving are synchronous. As long as space remains in
a port, a sender can deposit a message with no delay. Once a port becomes full, how-
ever, an additional sending process will be blocked until a message has been removed
and space becomes available. Similarly, if a process tries to receive a message from an 
empty port, the process will be blocked until a message arrives. Requests are also han-
dled in FIFO order. For example, if multiple processes are waiting on an empty port, 
the process that has been waiting the longest will receive the message. Similarly, if 
multiple processes are blocked waiting to send, the process that has been waiting the 
longest is allowed to proceed when a space becomes available.
11.3 The Implementation Of Ports
Each port consists of a queue to hold messages and two semaphores. One of the 
semaphores controls producers, blocking any process that attempts to add messages to a 
full port. The other semaphore controls consumers, blocking any process that attempts 
to remove a message from an empty port.
Because ports can be created dynamically, it is impossible to know the total count 
of items that will be enqueued at all ports at any given time. Although each message is 
small (one word), the total space required for port queues must be limited to prevent the 
port functions from using all the free space. To guarantee a limit on the total space 
used, the port functions allocate a fixed number of nodes to hold messages, and share 
the set among all ports. Initially, the message nodes are linked into a free list given by 
variable ptfree. Function ptsend removes a node from the free list, stores the message 
in the node, and adds the node to the queue associated with the port to which the mes-
sage has been sent. Function ptrecv extracts the next message from a specified port, re-
turns the node containing the message to the free list, and delivers the message to its 
caller.
Structure ptnode in file ports.h defines the contents of a node that contains one 
message. A ptnode structure contains two fields: ptmsg holds a 32-bit message, and 
ptnext points to the next message.
Structure ptentry defines the contents of an entry in the port table. Fields ptssem 
and ptrsem contain the IDs of semaphores that control sending and receiving. Field 
ptstate specifies whether the entry is currently being used, and field ptmaxcnt specifies 
the maximum messages that are allowed in the port at any time. Fields pthead and 
pttail point to the first node on the message list and the last, respectively. We will dis-
cuss the sequence field, ptseq, later.

Sec. 11.3        The Implementation Of Ports 
197
//** ppoorrttss..hh -- iissbbaaddppoorrtt **//
##ddeeffiinnee NNPPOORRTTSS
3300
//** MMaaxxiimmuumm nnuummbbeerr ooff ppoorrttss
**//
##ddeeffiinnee PPTT__MMSSGGSS
110000
//** TToottaall mmeessssaaggeess iinn ssyysstteemm
**//
##ddeeffiinnee PPTT__FFRREEEE
11
//** PPoorrtt iiss ffrreeee
**//
##ddeeffiinnee PPTT__LLIIMMBBOO
22
//** PPoorrtt iiss bbeeiinngg ddeelleetteedd//rreesseett
**//
##ddeeffiinnee PPTT__AALLLLOOCC
33
//** PPoorrtt iiss aallllooccaatteedd
**//
ssttrruucctt
ppttnnooddee
{{
//** NNooddee oonn lliisstt ooff mmeessssaaggeess
**//
uuiinntt3322
ppttmmssgg;;
//** AA oonnee--wwoorrdd mmeessssaaggee
**//
ssttrruucctt
ppttnnooddee
**ppttnneexxtt;;
//** PPooiinntteerr ttoo nneexxtt nnooddee oonn lliisstt **//
}};;
ssttrruucctt
pptteennttrryy {{
//** EEnnttrryy iinn tthhee ppoorrtt ttaabbllee
**//
ssiidd3322
ppttsssseemm;;
//** SSeennddeerr sseemmaapphhoorree
**//
ssiidd3322
ppttrrsseemm;;
//** RReecceeiivveerr sseemmaapphhoorree
**//
uuiinntt1166
ppttssttaattee;;
//** PPoorrtt ssttaattee ((FFRREEEE//LLIIMMBBOO//AALLLLOOCC))**//
uuiinntt1166
ppttmmaaxxccnntt;;
//** MMaaxx mmeessssaaggeess ttoo bbee qquueeuueedd
**//
iinntt3322
ppttsseeqq;;
//** SSeeqquueennccee cchhaannggeedd aatt ccrreeaattiioonn **//
ssttrruucctt
ppttnnooddee
**pptthheeaadd;;
//** LLiisstt ooff mmeessssaaggee ppooiinntteerrss
**//
ssttrruucctt
ppttnnooddee
**ppttttaaiill;;
//** TTaaiill ooff mmeessssaaggee lliisstt
**//
}};;
eexxtteerrnn
ssttrruucctt
ppttnnooddee
**ppttffrreeee;;
//** LLiisstt ooff ffrreeee nnooddeess
**//
eexxtteerrnn
ssttrruucctt
pptteennttrryy ppoorrttttaabb[[]];;
//** PPoorrtt ttaabbllee
**//
eexxtteerrnn
iinntt3322
ppttnneexxttiidd;;
//** NNeexxtt ppoorrtt IIDD ttoo ttrryy wwhheenn
**//
//**
llooookkiinngg ffoorr aa ffrreeee sslloott
**//
##ddeeffiinnee iissbbaaddppoorrtt((ppoorrttiidd))
(( ((ppoorrttiidd))<<00 |||| ((ppoorrttiidd))>>==NNPPOORRTTSS ))
11.4 Port Table Initialization
Because initialization code is designed after basic operations have been implement-
ed, we have been discussing initialization functions after other functions. In the case of 
ports, however, we will discuss initialization first, because doing so will make the 
remaining functions easier to understand. File ptinit.c contains the code to initialize 
ports and a declaration of the port table. Global variable ptnextid gives the index in ar-
ray porttab at which the search will start when a new port is needed. Initialization con-
sists of marking each port free, forming the linked list of free nodes, and initializing 
ptnextid. To create a free list, ptinit uses getmem to allocate a block of memory, and 
then moves through the memory, linking individual message nodes together to form a 
free list.

198 
High-level Message Passing 
Chap. 11
//** ppttiinniitt..cc -- ppttiinniitt **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt
ppttnnooddee
**ppttffrreeee;;
//** LLiisstt ooff ffrreeee mmeessssaaggee nnooddeess
**//
ssttrruucctt
pptteennttrryy ppoorrttttaabb[[NNPPOORRTTSS]];;
//** PPoorrtt ttaabbllee
**//
iinntt3322
ppttnneexxttiidd;;
//** NNeexxtt ttaabbllee eennttrryy ttoo ttrryy
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ppttiinniitt
--
IInniittiiaalliizzee aallll ppoorrttss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll ppttiinniitt((
iinntt3322 mmaaxxmmssggss
//** TToottaall mmeessssaaggeess iinn aallll ppoorrttss
**//
))
{{
iinntt3322
ii;;
//** RRuunnss tthhrroouugghh tthhee ppoorrtt ttaabbllee
**//
ssttrruucctt
ppttnnooddee
**nneexxtt,, **ccuurrrr;;
//** UUsseedd ttoo bbuuiilldd aa ffrreeee lliisstt
**//
//** AAllllooccaattee mmeemmoorryy ffoorr aallll mmeessssaaggeess oonn aallll ppoorrttss **//
ppttffrreeee == ((ssttrruucctt ppttnnooddee **))ggeettmmeemm((mmaaxxmmssggss**ssiizzeeooff((ssttrruucctt ppttnnooddee))));;
iiff ((ppttffrreeee ==== ((ssttrruucctt ppttnnooddee **))SSYYSSEERRRR)) {{
ppaanniicc((""ppiinniitt -- iinnssuuffffiicciieenntt mmeemmoorryy""));;
}} 
//** IInniittiiaalliizzee aallll ppoorrtt ttaabbllee eennttrriieess ttoo ffrreeee **//
ffoorr ((ii==00 ;; ii<<NNPPOORRTTSS ;; ii++++)) {{
ppoorrttttaabb[[ii]]..ppttssttaattee == PPTT__FFRREEEE;;
ppoorrttttaabb[[ii]]..ppttsseeqq == 00;;
}} 
ppttnneexxttiidd == 00;;
//** CCrreeaattee aa ffrreeee lliisstt ooff mmeessssaaggee nnooddeess lliinnkkeedd ttooggeetthheerr **//
ffoorr (( ccuurrrr==nneexxtt==ppttffrreeee ;;
----mmaaxxmmssggss >> 00
;; ccuurrrr==nneexxtt )) {{
ccuurrrr-->>ppttnneexxtt == ++++nneexxtt;;
}} 
//** SSeett tthhee ppooiinntteerr iinn tthhee ffiinnaall nnooddee ttoo NNUULLLL **//
ccuurrrr-->>ppttnneexxtt == NNUULLLL;;
rreettuurrnn OOKK;;
}}

Sec. 11.5        Port Creation
199
11.5 Port Creation
Port creation consists of allocating an entry in the port table from among those that
are free. Function ptcreate performs the allocation and returns a port identifier (port
ID) to its caller.  Ptcreate takes an argument that specifies the maximum count of out-
standing messages that the port will allow. Thus, when a port is created, the calling 
process can determine how many messages can be enqueued on the port before any 
sender blocks.
//** ppttccrreeaattee..cc -- ppttccrreeaattee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ppttccrreeaattee
--
CCrreeaattee aa ppoorrtt tthhaatt aalllloowwss ""ccoouunntt"" oouuttssttaannddiinngg mmeessssaaggeess
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll ppttccrreeaattee((
iinntt3322
ccoouunntt
//** SSiizzee ooff ppoorrtt
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
iinntt3322
ii;;
//** CCoouunnttss aallll ppoossssiibbllee ppoorrttss
**//
iinntt3322
ppttnnuumm;;
//** CCaannddiiddaattee ppoorrtt nnuummbbeerr ttoo ttrryy **//
ssttrruucctt
pptteennttrryy **ppttppttrr;;
//** PPooiinntteerr ttoo ppoorrtt ttaabbllee eennttrryy
**//
mmaasskk == ddiissaabbllee(());;
iiff ((ccoouunntt << 00)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
ffoorr ((ii==00 ;; ii<<NNPPOORRTTSS ;; ii++++)) {{
//** CCoouunntt aallll ttaabbllee eennttrriieess
**//
ppttnnuumm == ppttnneexxttiidd;;
//** GGeett aann eennttrryy ttoo cchheecckk
**//
iiff ((++++ppttnneexxttiidd >>== NNPPOORRTTSS)) {{
ppttnneexxttiidd == 00;;
//** RReesseett ffoorr nneexxtt iitteerraattiioonn
**//
}} 
//** CChheecckk ttaabbllee eennttrryy tthhaatt ccoorrrreessppoonnddss ttoo IIDD ppttnnuumm **//
ppttppttrr== &&ppoorrttttaabb[[ppttnnuumm]];;
iiff ((ppttppttrr-->>ppttssttaattee ==== PPTT__FFRREEEE)) {{
ppttppttrr-->>ppttssttaattee == PPTT__AALLLLOOCC;;
ppttppttrr-->>ppttsssseemm == sseemmccrreeaattee((ccoouunntt));;

200 
High-level Message Passing 
Chap. 11
ppttppttrr-->>ppttrrsseemm == sseemmccrreeaattee((00));;
ppttppttrr-->>pptthheeaadd == ppttppttrr-->>ppttttaaiill == NNUULLLL;;
ppttppttrr-->>ppttsseeqq++++;;
ppttppttrr-->>ppttmmaaxxccnntt == ccoouunntt;;
rreessttoorree((mmaasskk));;
rreettuurrnn ppttnnuumm;;
}}
}} 
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}}
11.6 Sending A Message To A Port
The basic operations on ports, sending and receiving messages, are handled by 
functions ptsend and ptrecv. Each requires the caller to specify the port on which the 
operation is to be performed by passing a port ID as an argument. Function ptsend adds 
a message to those that are waiting at the port. It waits for space in the port, enqueues 
the message given by its argument, signals the receiver semaphore to indicate another 
message is available, and returns. The code is found in file ptsend.c:
//** ppttsseenndd..cc -- ppttsseenndd **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ppttsseenndd
--
SSeenndd aa mmeessssaaggee ttoo aa ppoorrtt bbyy aaddddiinngg iitt ttoo tthhee qquueeuuee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll ppttsseenndd((
iinntt3322
ppoorrttiidd,,
//** IIDD ooff ppoorrtt ttoo uussee
**//
uummssgg3322
mmssgg
//** MMeessssaaggee ttoo sseenndd
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pptteennttrryy **ppttppttrr;;
//** PPooiinntteerr ttoo ttaabbllee eennttrryy
**//
iinntt3322
sseeqq;;
//** LLooccaall ccooppyy ooff sseeqquueennccee nnuumm..
**//
ssttrruucctt
ppttnnooddee
**mmssggnnooddee;;
//** AAllllooccaatteedd mmeessssaaggee nnooddee
**//
ssttrruucctt
ppttnnooddee
**ttaaiillnnooddee;;
//** LLaasstt nnooddee iinn ppoorrtt oorr NNUULLLL
**//
mmaasskk == ddiissaabbllee(());;
iiff (( iissbbaaddppoorrtt((ppoorrttiidd)) ||||
((ppttppttrr== &&ppoorrttttaabb[[ppoorrttiidd]]))-->>ppttssttaattee !!== PPTT__AALLLLOOCC )) {{

Sec. 11.6        Sending A Message To A Port 
201
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** WWaaiitt ffoorr ssppaaccee aanndd vveerriiffyy ppoorrtt hhaass nnoott bbeeeenn rreesseett **//
sseeqq == ppttppttrr-->>ppttsseeqq;;
//** RReeccoorrdd oorriiggnnaall sseeqquueennccee
**//
iiff ((wwaaiitt((ppttppttrr-->>ppttsssseemm)) ==== SSYYSSEERRRR
|||| ppttppttrr-->>ppttssttaattee !!== PPTT__AALLLLOOCC
|||| ppttppttrr-->>ppttsseeqq !!== sseeqq)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
iiff ((ppttffrreeee ==== NNUULLLL)) {{
ppaanniicc((""PPoorrtt ssyysstteemm rraann oouutt ooff mmeessssaaggee nnooddeess""));;
}} 
//** OObbttaaiinn nnooddee ffrroomm ffrreeee lliisstt bbyy uunnlliinnkkiinngg **//
mmssggnnooddee == ppttffrreeee;;
//** PPooiinntt ttoo ffiirrsstt ffrreeee nnooddee
**//
ppttffrreeee
== mmssggnnooddee-->>ppttnneexxtt;;
//** UUnnlliinnkk ffrroomm tthhee ffrreeee lliisstt
**//
mmssggnnooddee-->>ppttnneexxtt == NNUULLLL;;
//** SSeett ffiieellddss iinn tthhee nnooddee
**//
mmssggnnooddee-->>ppttmmssgg
== mmssgg;;
//** LLiinnkk iinnttoo qquueeuuee ffoorr tthhee ssppeecciiffiieedd ppoorrtt **//
ttaaiillnnooddee == ppttppttrr-->>ppttttaaiill;;
iiff ((ttaaiillnnooddee ==== NNUULLLL)) {{
//** QQuueeuuee ffoorr ppoorrtt wwaass eemmppttyy
**//
ppttppttrr-->>ppttttaaiill == ppttppttrr-->>pptthheeaadd == mmssggnnooddee;;
}} eellssee {{
//** IInnsseerrtt nneeww nnooddee aatt ttaaiill
**//
ttaaiillnnooddee-->>ppttnneexxtt == mmssggnnooddee;;
ppttppttrr-->>ppttttaaiill == mmssggnnooddee;;
}} 
ssiiggnnaall((ppttppttrr-->>ppttrrsseemm));;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}
The initial code in ptsend merely verifies that argument portid specifies a valid 
port ID. What happens next is more interesting.  Ptsend makes a local copy of the se-
quence number, ptseq, and then processes the request. It waits on the sender sema-
phore, and then verifies that the port is still allocated and that the sequence number 
agrees. It may seem odd that ptsend verifies the port ID a second time. However, if 
the port is already full when ptsend runs, the calling process can be blocked. Further-

202 
High-level Message Passing 
Chap. 11
more, while the process is blocked waiting to send, the port may be deleted (and even 
recreated). To understand how the sequence number helps, recall that ptcreate incre-
ments the sequence number when a port is created. The idea is to have waiting 
processes verify that the wait did not terminate because the port was deleted. If it did, 
the port will either remain unused or the sequence number will be incremented. Thus, 
the code following the call to wait verifies that the original port remains allocated.
The implementation of ptsend enqueues messages in FIFO order. It relies on pttail 
to point to the last node on the queue if the queue is nonempty. Furthermore, ptsend al-
ways makes pttail point to a new node after the node has been added to the list. Final-
ly, ptsend signals the receiver semaphore after the new message has been added to the 
queue, allowing a receiver to consume the message.
As in earlier code, an invariant helps a programmer understand the implementation.
The invariant states:
Semaphore ptrsem has a nonnegative count n if n messages are wait-
ing in the port; it has negative count –n if n processes are waiting for 
messages.
The call to panic also deserves comment because this is its first occurrence. In our 
design, running out of message nodes is a catastrophe from which the system cannot re-
cover. It means that the arbitrary limit on message nodes, set to prevent ports from us-
ing all the free memory, is insufficient. Perhaps the processes using ports are perform-
ing incorrectly. Perhaps the request is valid, but the message limit was set too low; 
there is no way to know. Under such circumstances it is often better to announce 
failure and stop rather than attempt to go on. In our system, panic handles such situa-
tions by printing the specified error message and halting the processor. Panic could be 
changed to reboot the entire system. (The exercises suggest alternative ways of han-
dling the problem.)
11.7 Receiving A Message From A Port
Function ptrecv implements a basic consumer operation. It removes a message
from a specified port and returns the message to its caller. The code is found in file
ptrecv.c:
//** ppttrreeccvv..cc -- ppttrreeccvv **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ppttrreeccvv
--
RReecceeiivvee aa mmeessssaaggee ffrroomm aa ppoorrtt,, bblloocckkiinngg iiff ppoorrtt eemmppttyy
**------------------------------------------------------------------------------------------------------------------------------------------------

Sec. 11.7        Receiving A Message From A Port 
203
**//
uuiinntt3322
ppttrreeccvv((
iinntt3322
ppoorrttiidd
//** IIDD ooff ppoorrtt ttoo uussee
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pptteennttrryy **ppttppttrr;;
//** PPooiinntteerr ttoo ttaabbllee eennttrryy
**//
iinntt3322
sseeqq;;
//** LLooccaall ccooppyy ooff sseeqquueennccee nnuumm..
**//
uummssgg3322
mmssgg;;
//** MMeessssaaggee ttoo rreettuurrnn
**//
ssttrruucctt
ppttnnooddee
**mmssggnnooddee;;
//** FFiirrsstt nnooddee oonn mmeessssaaggee lliisstt
**//
mmaasskk == ddiissaabbllee(());;
iiff (( iissbbaaddppoorrtt((ppoorrttiidd)) ||||
((ppttppttrr== &&ppoorrttttaabb[[ppoorrttiidd]]))-->>ppttssttaattee !!== PPTT__AALLLLOOCC )) {{
rreessttoorree((mmaasskk));;
rreettuurrnn ((uuiinntt3322))SSYYSSEERRRR;;
}} 
//** WWaaiitt ffoorr mmeessssaaggee aanndd vveerriiffyy tthhaatt tthhee ppoorrtt iiss ssttiillll aallllooccaatteedd **//
sseeqq == ppttppttrr-->>ppttsseeqq;;
//** RReeccoorrdd oorriiggnnaall sseeqquueennccee
**//
iiff ((wwaaiitt((ppttppttrr-->>ppttrrsseemm)) ==== SSYYSSEERRRR |||| ppttppttrr-->>ppttssttaattee !!== PPTT__AALLLLOOCC
|||| ppttppttrr-->>ppttsseeqq !!== sseeqq)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn ((uuiinntt3322))SSYYSSEERRRR;;
}} 
//** DDeeqquueeuuee ffiirrsstt mmeessssaaggee tthhaatt iiss wwaaiittiinngg iinn tthhee ppoorrtt **//
mmssggnnooddee == ppttppttrr-->>pptthheeaadd;;
mmssgg == mmssggnnooddee-->>ppttmmssgg;;
iiff ((ppttppttrr-->>pptthheeaadd ==== ppttppttrr-->>ppttttaaiill))
//** DDeelleettee llaasstt iitteemm
**//
ppttppttrr-->>pptthheeaadd == ppttppttrr-->>ppttttaaiill == NNUULLLL;;
eellssee
ppttppttrr-->>pptthheeaadd == mmssggnnooddee-->>ppttnneexxtt;;
mmssggnnooddee-->>ppttnneexxtt == ppttffrreeee;;
//** RReettuurrnn ttoo ffrreeee lliisstt
**//
ppttffrreeee == mmssggnnooddee;;
ssiiggnnaall((ppttppttrr-->>ppttsssseemm));;
rreessttoorree((mmaasskk));;
rreettuurrnn mmssgg;;
}}
Ptrecv checks its argument, waits until a message is available, verifies that the port
has not been deleted or reused, and dequeues the message node. It records the value of

204 
High-level Message Passing 
Chap. 11
the message in local variable msg before returning the message node to the free list, and 
then returns the value to its caller.
11.8 Port Deletion And Reset
It is sometimes useful to delete or to reset a port. In either case, the system must 
dispose of waiting messages (if the port contains messages), return message nodes to
the free list, and permit waiting processes to continue execution. How should the port 
system dispose of waiting messages? It could choose to throw them away, or to return 
them to the processes that sent them. To permit maximum flexibility, our design does 
not make a choice. Instead, it permits a caller to specify how to dispose of messages. 
Functions ptdelete and ptreset perform port deletion and reset operations. Each function 
takes an argument that specifies a function to be called to dispose of each waiting mes-
sage. The code is found in files ptdelete.c and ptreset.c:
//** ppttddeelleettee..cc -- ppttddeelleettee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ppttddeelleettee
--
DDeelleettee aa ppoorrtt,, ffrreeeeiinngg wwaaiittiinngg pprroocceesssseess aanndd mmeessssaaggeess
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll ppttddeelleettee((
iinntt3322
ppoorrttiidd,,
//** IIDD ooff ppoorrtt ttoo ddeelleettee
**//
iinntt3322
((**ddiisspp))((iinntt3322))
//** FFuunnccttiioonn ttoo ccaallll ttoo ddiissppoossee
**//
))
//**
ooff wwaaiittiinngg mmeessssaaggeess
**//
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pptteennttrryy **ppttppttrr;;
//** PPooiinntteerr ttoo ppoorrtt ttaabbllee eennttrryy
**//
mmaasskk == ddiissaabbllee(());;
iiff (( iissbbaaddppoorrtt((ppoorrttiidd)) ||||
((ppttppttrr== &&ppoorrttttaabb[[ppoorrttiidd]]))-->>ppttssttaattee !!== PPTT__AALLLLOOCC )) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
__ppttcclleeaarr((ppttppttrr,, PPTT__FFRREEEE,, ddiisspp));;
ppttnneexxttiidd == ppoorrttiidd;;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}

Sec. 11.8        Port Deletion And Reset 
205
//** ppttrreesseett..cc -- ppttrreesseett **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ppttrreesseett
--
RReesseett aa ppoorrtt,, ffrreeeeiinngg wwaaiittiinngg pprroocceesssseess aanndd mmeessssaaggeess aanndd
lleeaavviinngg tthhee ppoorrtt rreeaaddyy ffoorr ffuurrtthheerr uussee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll ppttrreesseett((
iinntt3322
ppoorrttiidd,,
//** IIDD ooff ppoorrtt ttoo rreesseett
**//
iinntt3322
((**ddiisspp))((iinntt3322))
//** FFuunnccttiioonn ttoo ccaallll ttoo ddiissppoossee
**//
))
//**
ooff wwaaiittiinngg mmeessssaaggeess
**//
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pptteennttrryy **ppttppttrr;;
//** PPooiinntteerr ttoo ppoorrtt ttaabbllee eennttrryy
**//
mmaasskk == ddiissaabbllee(());;
iiff (( iissbbaaddppoorrtt((ppoorrttiidd)) ||||
((ppttppttrr== &&ppoorrttttaabb[[ppoorrttiidd]]))-->>ppttssttaattee !!== PPTT__AALLLLOOCC )) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
__ppttcclleeaarr((ppttppttrr,, PPTT__AALLLLOOCC,, ddiisspp));;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}
Both ptdelete and ptreset verify that their arguments are correct, and then call 
_ptclear to perform the work of clearing messages and waiting processes.† The dispo-
sal function can cause a context switch, which means other processes can run and use 
ports. Therefore, while it proceeds to clear a port, _ptclear places the port in a “limbo”
state (PT_LIMBO). The limbo state guarantees that no other processes can use the port 
— functions ptsend and ptrecv will refuse to operate on a port that is not allocated, and 
pcreate will not allocate the port unless it is free. Thus, even if the disposal function 
switches context, no problems will occur.
Before declaring a port eligible for use again, _ptclear calls dispose repeatedly, 
passing it each waiting message. Finally, after all messages have been removed, 
_ptclear deletes or resets the semaphores as specified by its second argument. Before 
disposing of messages, _ptclear increments the port sequence number so that waiting 
processes can tell that the port has changed when they awaken. The code is found in 
file ptclear.c:
                                †The name _ptclear begins with an underscore to indicate that the function is internal to the system and
is not intended to be called by an application process (i.e., is not part of the system’s API).

206 
High-level Message Passing 
Chap. 11
//** ppttcclleeaarr..cc -- __ppttcclleeaarr **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
__ppttcclleeaarr
--
UUsseedd bbyy ppttddeelleettee aanndd ppttrreesseett ttoo cclleeaarr oorr rreesseett aa ppoorrtt
**
((iinntteerrnnaall ffuunnccttiioonn aassssuummeess iinntteerrrruuppttss ddiissaabblleedd aanndd
**
aarrgguummeennttss hhaavvee bbeeeenn cchheecckkeedd ffoorr vvaalliiddiittyy))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
__ppttcclleeaarr((
ssttrruucctt pptteennttrryy **ppttppttrr,,
//** TTaabbllee eennttrryy ttoo cclleeaarr
**//
uuiinntt1166
nneewwssttaattee,,
//** NNeeww ssttaattee ffoorr ppoorrtt
**//
iinntt3322
((**ddiissppoossee))((iinntt3322))//** DDiissppoossaall ffuunnccttiioonn ttoo ccaallll
**//
))
{{
ssttrruucctt
ppttnnooddee
**wwaallkk;;
//** PPooiinntteerr ttoo wwaallkk mmeessssaaggee lliisstt **//
//** PPllaaccee ppoorrtt iinn lliimmbboo ssttaattee wwhhiillee wwaaiittiinngg pprroocceesssseess aarree ffrreeeedd **//
ppttppttrr-->>ppttssttaattee == PPTT__LLIIMMBBOO;;
ppttppttrr-->>ppttsseeqq++++;;
//** RReesseett aacccceessssiioonn nnuummbbeerr
**//
wwaallkk == ppttppttrr-->>pptthheeaadd;;
//** FFiirrsstt iitteemm oonn mmssgg lliisstt
**//
iiff (( wwaallkk !!== NNUULLLL )) {{
//** IIff mmeessssaaggee lliisstt nnoonneemmppttyy
**//
//** WWaallkk mmeessssaaggee lliisstt aanndd ddiissppoossee ooff eeaacchh mmeessssaaggee **//
ffoorr(( ;; wwaallkk!!==NNUULLLL ;; wwaallkk==wwaallkk-->>ppttnneexxtt)) {{
((**ddiissppoossee))(( wwaallkk-->>ppttmmssgg ));;
}} 
//** LLiinnkk eennttiirree mmeessssaaggee lliisstt iinnttoo tthhee ffrreeee lliisstt **//
((ppttppttrr-->>ppttttaaiill))-->>ppttnneexxtt == ppttffrreeee;;
ppttffrreeee == ppttppttrr-->>pptthheeaadd;;
}} 
iiff ((nneewwssttaattee ==== PPTT__AALLLLOOCC)) {{
ppttppttrr-->>ppttttaaiill == ppttppttrr-->>pptthheeaadd == NNUULLLL;;
sseemmrreesseett((ppttppttrr-->>ppttsssseemm,, ppttppttrr-->>ppttmmaaxxccnntt));;
sseemmrreesseett((ppttppttrr-->>ppttrrsseemm,, 00));;
}} eellssee {{
sseemmddeelleettee((ppttppttrr-->>ppttsssseemm));;

Sec. 11.8        Port Deletion And Reset 
207
sseemmddeelleettee((ppttppttrr-->>ppttrrsseemm));;
}} 
ppttppttrr-->>ppttssttaattee == nneewwssttaattee;;
rreettuurrnn;;
}}
11.9 Perspective
Because it provides a synchronous interface, our port mechanism allows a process 
to wait for the next message to arrive. A synchronous interface can be powerful — a 
clever programmer can use the mechanism to coordinate processes (e.g., to implement 
mutual exclusion). Interestingly, the ability to coordinate processes also introduces a 
potential problem: deadlock. That is, a set of processes that uses ports to exchange 
messages can end up with all processes in the set blocked, waiting for a message to ar-
rive with no processes left running to send a message. Therefore, a programmer using 
ports must be careful to guarantee that such deadlocks cannot occur.
11.10 Summary
The chapter introduces a high-level message passing mechanism, called communi-
cation ports, that permits processes to exchange messages through rendezvous points. 
Each port consists of a fixed length queue of messages. Function ptsend deposits a 
message at the tail of the queue, and function ptrecv extracts an item from the head of 
the queue. Processes that attempt to receive from an empty port are blocked until a 
message arrives; processes that attempt to send to a full port are blocked until space be-
comes available.
EXERCISES
11.1  
Consider the primitives send—receive and ptsend—ptrecv. Is it possible to design a sin-
gle message passing scheme that encompasses both? Explain.
11.2     An important distinction is made between statically allocated and dynamically allocated
resources. For example, ports are dynamically allocated while inter-process message
slots are statically allocated. What is the key problem with dynamic allocation in a
multi-process environment?
11.3 
Change the message node allocation scheme so that a semaphore controls nodes on the
free list. Have ptsend wait for a free node if none exists. What potential problems, if
any, does the new scheme introduce?
11.4     Panic is used for conditions like internal inconsistency or potential deadlock. Often the
conditions causing a panic are irreproducible, so their cause is difficult to pinpoint. Dis-
cuss what you might do to trace the cause of the panic in ptsend.

208 
High-level Message Passing 
Chap. 11
11.5 
As alternatives to the call to panic in ptsend, consider allocating more nodes or retrying
the operation. What are the liabilities of each?
11.6 
Rewrite ptsend and ptrecv to return a special value when the port is deleted while they
are waiting. What is the chief disadvantage of the new mechanism?
11.7      Modify the routines in previous chapters that allocate, use, and delete objects so they use
sequence numbers to detect deletion as the communication port functions do.
11.8 
Ptsend and ptrecv cannot transmit a message with value equal to SYSERR because ptrecv
cannot distinguish between a message with that value and an error. Redesign the func-
tions to transmit any value.
11.9 
Although each call to ptcreate specifies a count of messages, the implementation does
not check that the set of allocated message nodes is sufficient to handle all possible re-
quests. Modify ptcreate to ensure that the sum of messages on all ports is less than 
PT_MSGS.
11.10    If the previous exercise is implemented, what important change can be made to ptsend?

Chapter Contents
12.1 
Introduction, 211
12.2 
The Advantage Of Interrupts, 212
12.3 
Interrupt Processing, 212
12.4 
Vectored Interrupts, 213
12.5 
Integration Of Interrupts And Exceptions, 214
12.6 
ARM Exception Vectors Using Code, 215
12.7 
Assignment Of Device Interrupt Vector Numbers, 219
12.8 
Interrupt Dispatching, 220
12.9 
The Structure Of Interrupt Software, 221
12.10 Disabling Interrupts, 223
12.11 Constraints On Functions That Interrupt Code Invokes, 225 
12.12 The Need To Reschedule During An Interrupt, 225
12.13 Rescheduling During An Interrupt, 226 
12.14 Perspective, 227
12.15 Summary, 228


12
Interrupt Processing
The joy of music should never be interrupted by a 
commercial.
— Leonard Bernstein
12.1 Introduction
Previous chapters focus on processor and memory management. The chapters on 
processor management introduce the concept of concurrent processing, show how 
processes are created and terminated, and describe how processes coordinate. The 
chapters on memory management illustrate low-level mechanisms used to manage 
dynamic allocation and the release of stack and heap storage.
This chapter begins a discussion of input and output (I/O) facilities. The chapter 
reviews the concept of an interrupt, and introduces the overall software architecture that 
an operating system uses to handle interrupts. It describes how an operating system 
passes control to the appropriate interrupt handler software when an interrupt occurs. 
More important, the chapter explains the complex relationship between interrupts and 
the operating system abstraction of concurrent processes, and gives general guidelines 
that interrupt code must follow to provide a correct and safe implementation of con-
current processes in the presence of interrupts. Later chapters continue the discussion 
by examining specific devices, including a real-time clock that enables preemptive proc-
ess scheduling. The chapters explain how interrupt handler software forms part of a 
driver.
211

212 
Interrupt Processing 
Chap. 12
12.2 The Advantage Of Interrupts
The interrupt mechanism invented for third-generation computer systems provides
a powerful facility that separates I/O activities from processing. Many of the services
an operating system offers would not be possible without hardware that supports inter-
rupts.
The motivation for an interrupt mechanism arises from the observation that I/O 
hardware can function in parallel with processing. Instead of relying on the processor 
to provide complete control over I/O, each I/O device contains hardware that can 
operate independently. The processor only needs to start or stop a device — once start-
ed, a device proceeds to transfer data without further help. Because most I/O proceeds 
much slower than computation, the processor can start multiple devices and allow the 
operations to proceed in parallel. After starting I/O, the processor can perform other 
computation (i.e., execute a process) until a device interrupts to signal completion. The 
key idea is:
An interrupt mechanism permits the processor and I/O devices to 
operate in parallel. Although the details differ, the hardware includes 
a mechanism that automatically “interrupts” normal processing and 
informs the operating system when a device completes an operation or 
needs attention.
12.3 Interrupt Processing
Hardware in a processor performs three basic steps when an interrupt occurs:
d Set the hardware to prevent further interrupts from occurring while
an interrupt is being processed
d Save sufficient state to allow the processor to resume execution
transparently once the interrupt has been handled
d Branch to a predetermined memory location where the operating
system has placed code to process the interrupt
Each processor includes details that complicate interrupt processing. For example, 
when it saves state, the hardware in most systems does not save a complete copy of all 
processor registers. Instead, the hardware records a few basic values, such as a copy of 
the instruction pointer,† and requires the operating system to save any other registers 
that will be used during interrupt processing. To ensure that interrupt processing does 
not change any values visible to the process that was executing, the operating system 
must restore all the saved registers before returning to normal processing once the inter-
rupt handling is complete.

†The instruction pointer, sometimes called a program counter, contains the address of the instruction to
be executed next.

Sec. 12.4        Vectored Interrupts 
213
12.4 Vectored Interrupts
When an interrupt occurs, the operating system must have a way to identify which 
device caused the interrupt. A variety of hardware mechanisms have been invented that 
handle device identification. For example, on some systems, the processor uses the bus 
to ask the interrupting device to identify itself. On other systems, a separate controller 
unit handles communication with devices. Some designs use a separate co-processor in-
stead of a controller. After considering other aspects of interrupt handling, we will see 
how the example platforms handle interrupts.
How should a device identify itself? The most popular technique is known as a 
vectored interrupt. Each device is assigned a unique integer, 0, 1, 2, and so on. Using 
terminology that has become popular, the integer is called an Interrupt Request Number 
(IRQ). When an interrupt occurs, the device specifies its IRQ. A vectored interrupt 
mechanism helps make interrupt processing extremely efficient: the IRQ can be used as 
an index into an interrupt vector array. The operating system preloads each location in 
the interrupt vector with a pointer to a function that handles the interrupt. When a de-
vice with IRQ i interrupts, control branches to:
interrupt_vector[i]
Figure 12.1 illustrates the conceptual organization of interrupt vectors as an array of 
pointers.
. . .
code to handle device 0
code to handle device 1
code to handle device 2
code to handle device 3
code to handle device N –1
0
1
2
3
Figure 12.1 The conceptual organization of interrupt vectors as an array of
pointers, where each entry gives the address of code that handles 
the interrupt for a specific device.

214 
Interrupt Processing 
Chap. 12
12.5 Integration Of Interrupts And Exceptions
Although the vectored approach was invented to handle interrupts from I/O de-
vices, the scheme has been extended to handle exceptions. That is, the vector can have 
additional slots that are devoted to handle error conditions, such as page faults, divide-
by-zero errors, protection violations, illegal instructions, and illegal memory references. 
The processor hardware is constructed such that it generates an exception when an error 
occurs. In fact, exception processing is so fundamental that some platforms use the 
term exception vector to refer to the array of pointers instead of the term interrupt vec-
tor. The two example platforms illustrate two approaches vendors have used to com-
bine exceptions and interrupts.
12.5.1  Galileo (Intel)
The Galileo uses a single, large vector that contains entries for both exceptions and 
device interrupts. The first entries in the array correspond to exceptions, and devices
are assigned IRQ values above the exceptions. For example, vector position zero is 
reserved for arithmetic division errors. When a program attempts to divide by zero, the 
hardware detects the problem and raises exception 0. In essence, the hardware behaves 
exactly as if an interrupt had occurred with IRQ 0 (i.e., the program counter is saved 
and control passes to the address given by interrupt_vector[0]). Similarly, if it en-
counters an illegal opcode, the processor raises exception 5 exactly as if an interrupt had 
occurred with IRQ 5.
12.5.2  BeagleBone Black (ARM)
The BeagleBone Black uses a two-level approach. At the top level, the processor 
defines eight possible exceptions: Reset, Undefined instruction, Software interrupt, 
Pre-Fetch Abort, Data Abort, Unused, IRQ, and FIQ. All errors, such as divide-by-
zero, are classified as one of the exceptions. Two of the exceptions (IRQ and FIQ) 
correspond to I/O device interrupts.† When a device generates an IRQ interrupt, the 
hardware raises an IRQ exception. The processor uses an exception vector to branch to 
the code that handles the exception. That is, all device interrupts follow the same ex-
ception vector pointer. The code that handles the IRQ exception must interrogate the 
hardware, obtain the IRQ for the interrupting device, and then use a second level of in-
direction to find the code that handles the specific device. The point is:
Exceptions, such as divide-by-zero and page faults, follow a vectored 
approach. The Galileo illustrates how interrupts and exceptions are 
integrated into a single exception vector. The BeagleBone Black il-
lustrates a two-level scheme in which device interrupts correspond to 
one particular exception and the operating system must use a second 
level of indirection to reach the handler for a specific device.

†IRQ corresponds to a normal interrupt; FIQ can be used to optimize interrupt processing for device
hardware that does not need the processor to save as much state.

Sec. 12.5        Integration Of Interrupts And Exceptions 
215
12.6 ARM Exception Vectors Using Code
The ARM architecture adds one more wrinkle to exception vector processing: in-
stead of containing pointers to handlers as the Intel architecture does, an ARM excep-
tion vector contains instructions that the processor executes. When exception i occurs,
the processor starts executing the code at:
exception_vector[i]
Each location in the exception vector is only one instruction long (i.e., four bytes), 
which means the instruction must branch to the code for the exception. The instruction
in the exception vector for device interrupts jumps to the device dispatch code, the in-
struction in the exception vector for software interrupts jumps to the software interrupt 
code, and so on.
An operating system must initialize exception vectors, and may need to change the 
vectors later. Because ARM exception vectors contain code rather than data, changing 
the contents means creating an executable instruction, which can be dangerous. To
avoid modifying code at runtime, Xinu uses indirect branch instructions. That is, Xinu 
defines an additional array of pointers that is parallel to the exception vectors, and 
makes each exception vector contain an indirect jump instruction that references the 
corresponding location in the parallel array of pointers. Figure 12.2 illustrates the con-
cept.
exception vectors 
array of pointers
jump indirect
jump indirect
jump indirect
jump indirect
jump indirect
jump indirect
jump indirect
jump indirect
code for exception 0
code for exception 1
code for exception 2
code for exception 3
code for exception 4
code for exception 5
code for exception 6
code for exception 7
vector for exception 0
vector for exception 1
vector for exception 2
vector for exception 3
vector for exception 4
vector for exception 5
vector for exception 6
vector for exception 7
Figure 12.2 An ARM exception vector with instructions that each jump in-
directly through an item in an array of pointers.
Using an extra array has both a practical and conceptual advantage. It is practical 
because the operating system only needs to change a pointer to change the function as-
sociated with a given exception; there is no need to create executable instructions at 
runtime. The conceptual advantage should also be clear: the scheme makes the ARM 
exception mechanism match the model presented in Figure 12.1 on page 213.

216 
Interrupt Processing 
Chap. 12
How is the parallel array mechanism from Figure 12.2 implemented? Because a 
normal jump instruction takes two words, Xinu places the parallel array immediately 
after the exception vectors, and uses PC-relative addressing, which makes the jump fit
into a single word. More important, because the ith  location of the parallel array is a 
constant distance from the ith exception vector, every exception vector location contains 
the same offset in the jump instruction.† Figure 12.3 illustrates the implementation.
exception vectors 
array of pointers
Each vector contains ldr pc, [pc #24]
Figure 12.3 ARM exception vectors and an indirect array are contiguous in
memory.
Function initevec near the end of file intr.S assigns the relative jump instruction to 
locations in the exception vector, assigns the address of a default exception handler to 
each position in the parallel array, and then changes the pointer associated with IRQs to 
point to the IRQ exception hander, irq_except.
//** iinnttrr..SS -- eennaabbllee,, ddiissaabbllee,, rreessttoorree,, hhaalltt,, ppaauussee,, iirrqq__eexxcceepptt ((AARRMM)) **//
##iinncclluuddee <<aarrmmvv77aa..hh>>
..tteexxtt
..gglloobbll
ddiissaabbllee
..gglloobbll
rreessttoorree
..gglloobbll
eennaabbllee
..gglloobbll
ppaauussee
..gglloobbll
hhaalltt
..gglloobbll
iirrqq__eexxcceepptt
..gglloobbll
iirrqq__ddiissppaattcchh
..gglloobbll
iinniitteevveecc
..gglloobbll
eexxppjjmmppiinnssttrr
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ddiissaabbllee
--
DDiissaabbllee iinntteerrrruuppttss aanndd rreettuurrnn tthhee pprreevviioouuss ssttaattee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddiissaabbllee::
mmrrss
rr00,, ccppssrr
//** CCooppyy tthhee CCPPSSRR iinnttoo rr00
**//
ccppssiidd
ii
//** DDiissaabbllee iinntteerrrruuppttss
**//
mmoovv
ppcc,, llrr
//** RReettuurrnn tthhee CCPPSSRR
**//

†The offset in the indirect jump is 24 bytes instead of 32 bytes because the program counter points two
words beyond the instruction being executed.

Sec. 12.6        ARM Exception Vectors Using Code 
217
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rreessttoorree
--
RReessttoorree iinntteerrrruuppttss ttoo vvaalluuee ggiivveenn bbyy mmaasskk aarrgguummeenntt
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
rreessttoorree::
ppuusshh
{{rr11,, rr22}}
//** SSaavvee rr11,, rr22 oonn ssttaacckk
**//
mmrrss
rr11,, ccppssrr
//** CCooppyy CCPPSSRR iinnttoo rr11
**//
llddrr
rr22,, ==00xx0011FF0000222200
aanndd
rr11,, rr11,, rr22
//** EExxttrraacctt ffllaaggss aanndd ootthheerr iimmppoorrttaanntt
**//
bbiicc
rr00,, rr00,, rr22
//**
bbiittss ffrroomm tthhee mmaasskk
**//
oorrrr
rr11,, rr11,, rr00
mmssrr
ccppssrr__ccffssxx,, rr11
//** RReessttoorree tthhee CCPPSSRR
**//
ppoopp
{{rr11,, rr22}}
//** RReessttoorree rr11,, rr22
**//
mmoovv
ppcc,, llrr
//** RReettuurrnn ttoo ccaalllleerr
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
** eennaabbllee
--
EEnnaabbllee iinntteerrrruuppttss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
eennaabbllee::
ccppssiiee
ii
//** EEnnaabbllee iinntteerrrruuppttss
**//
mmoovv
ppcc,, llrr
//** RReettuurrnn
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ppaauussee oorr hhaalltt
--
PPllaaccee tthhee pprroocceessssoorr iinn aa hhaarrdd lloooopp
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
hhaalltt::
ppaauussee::
ccppssiidd
ii
//** DDiissaabbllee iinntteerrrruuppttss
**//
ddlloooopp::
bb
ddlloooopp
//** DDeeaadd lloooopp
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
** iirrqq__eexxcceepptt
--
DDiissppaattcchh aann IIRRQQ eexxcceeppttiioonn ttoo hhiigghheerr lleevveell IIRRQQ ddiissppaattcchheerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iirrqq__eexxcceepptt::
ssuubb
llrr,, llrr,, ##44
//** CCoorrrreecctt tthhee rreettuurrnn aaddddrreessss
**//
ssrrssddbb
sspp!!,, ##1199
//** SSaavvee rreettuurrnn ssttaattee oonn tthhee ssuuppeerrvviissoorr
**//
//**
mmooddee ssttaacckk
**//
ccppss
##1199
//** CChhaannggee ttoo ssuuppeerrvviissoorr mmooddee
**//
ppuusshh
{{rr00--rr1122,, llrr}}
//** SSaavvee aallll rreeggiisstteerrss
**//
bbll
iirrqq__ddiissppaattcchh
//** CCaallll IIRRQQ ddiissppaattcchh
**//
ppoopp
{{rr00--rr1122,, llrr}}
//** RReessttoorree aallll rreeggiisstteerrss
**//
rrffeeiiaa
sspp!!
//** RReettuurrnn ffrroomm tthhee eexxcceeppttiioonn uussiinngg iinnffoo **//
//**
ssttoorreedd oonn tthhee ssttaacckk
**//

218 
Interrupt Processing 
Chap. 12
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ddeeffeexxpp__hhaannddlleerr -- DDeeffaauulltt EExxcceeppttiioonn hhaannddlleerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeeffeexxpp__hhaannddlleerr::
llddrr
rr00,, ==eexxppmmssgg11
mmoovv
rr11,, llrr
bbll
kkpprriinnttff
llddrr
rr00,, ==eexxppmmssgg22
bbll
ppaanniicc
//**------------------------------------------------------------------------------------------------------------------------------------------------
** iinniitteevveecc -- IInniittiiaalliizzee tthhee eexxcceeppttiioonn vveeccttoorr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinniitteevveecc:: 
mmrrcc
pp1155,, 00,, rr00,, cc11,, cc00,, 00 //** RReeaadd tthhee cc11--ccoonnttrrooll rreeggiisstteerr
**//
bbiicc
rr00,, rr00,, ##AARRMMVV77AA__CC11CCTTLL__VV//** VV bbiitt == 00,, nnoorrmmaall eexxpp.. bbaassee
**//
mmccrr
pp1155,, 00,, rr00,, cc11,, cc00,, 00 //** WWrriittee tthhee cc11--ccoonnttrrooll rreeggiisstteerr
**//
llddrr
rr00,, ==AARRMMVV77AA__EEVV__SSTTAARRTT
//** EExxcceeppttiioonn bbaassee aaddddrreessss
**//
mmccrr
pp1155,, 00,, rr00,, cc1122,, cc00,, 00//** SSttoorree eexxccpp.. bbaassee aaddddrr.. iinn cc1122
**//
llddrr
rr00,, ==AARRMMVV77AA__EEVV__SSTTAARRTT
//** SSttaarrtt aaddddrreessss ooff eexxpp.. vveeccttoorr
**//
llddrr
rr11,, ==AARRMMVV77AA__EEVV__EENNDD
//** EEnndd aaddddrreessss ooff eexxpp.. vveeccttoorr
**//
llddrr
rr22,, ==eexxppjjmmppiinnssttrr
//** CCooppyy tthhee eexxpp jjuummpp iinnssttrr
**//
llddrr
rr22,, [[rr22]]
//**
iinnttoo rreeggiisstteerr rr22
**//
eexxppvveecc:: ssttrr
rr22,, [[rr00]]
//** SSttoorree tthhee jjuummpp iinnssttrruuccttiioonn
**//
aadddd
rr00,, rr00,, ##44
//**
iinn tthhee eexxcceeppttiioonn vveeccttoorr
**//
ccmmpp
rr00,, rr11
bbnnee
eexxppvveecc
llddrr
rr00,, ==AARRMMVV77AA__EEHH__SSTTAARRTT
//** IInnssttaallll tthhee ddeeffaauulltt eexxcceeppttiioonn
**//
llddrr
rr11,, ==AARRMMVV77AA__EEHH__EENNDD
//**
hhaannddlleerr ffoorr aallll eexxcceeppttiioonnss
**//
llddrr
rr22,, ==ddeeffeexxpp__hhaannddlleerr
eexxpphhnndd:: ssttrr
rr22,, [[rr00]]
aadddd
rr00,, rr00,, ##44
ccmmpp
rr00,, rr11
bbnnee
eexxpphhnndd
llddrr
rr00,, ==AARRMMVV77AA__IIRRQQHH__AADDDDRR //** IInnssttaallll tthhee IIRRQQ hhaannddlleerr ttoo
**//
llddrr
rr11,, ==iirrqq__eexxcceepptt
//**
oovveerrrriiddee tthhee ddeeffaauulltt
**//
ssttrr
rr11,, [[rr00]]
//**
eexxcceeppttiioonn hhaannddlleerr
**//
mmoovv
ppcc,, llrr
//**------------------------------------------------------------------------------------------------------------------------------------------------
** eexxppjjmmppiinnssttrr -- AA PPCC rreellaattiivvee jjuummpp iinnssttrruuccttiioonn,, ccooppiieedd iinnttoo eexxpp.. vveeccttoorr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//

Sec. 12.6        ARM Exception Vectors Using Code 
219
eexxppjjmmppiinnssttrr::
llddrr
ppcc,, [[ppcc,, ##2244]]
The last statement of the file is the relative jump instruction. We use the assem-
bler to create the instruction, which is both easier to read and less prone to errors than 
defining a constant.
12.7 Assignment Of Device Interrupt Vector Numbers
The position of exceptions in an exception vector are chosen when a system is 
designed and never change. For example, we said that the Galileo hardware is built so
an illegal instruction error always raises exception 5. On the BeagleBone Black, an ille-
gal instruction raises exception 6. However, IRQ values cannot be preassigned unless 
the set of devices is fixed when the hardware is built (e.g., an SoC that has three de-
vices). To understand why, observe that most computer systems allow an owner to pur-
chase and install new device hardware. To accommodate an arbitrary set of devices, 
three basic approaches have been used for IRQ assignment:
d Manual device configuration
d Automated assignment during bootstrap
d Dynamic assignment for pluggable devices
Manual device configuration. On early hardware, a human had to assign a unique 
IRQ to each device before the device was connected to a computer. Typically, the as-
signment was made using switches or wire jumpers on the device circuit board. Once 
an assignment was made to the hardware, the operating system had to be configured to 
match the hardware. Manual assignment had the problems of being tedious and error-
prone — if a human accidentally assigned the same IRQ to two different devices, or the 
vector number configured into the operating system did not match the IRQ value con-
figured into device hardware, devices would fail to operate correctly.
Automated assignment during bootstrap. As bus hardware became more sophisti-
cated, techniques were developed that automated interrupt vector assignments. Au-
tomated assignment requires programmable devices. That is, the operating system uses 
the bus to find devices that are attached to the bus, and assigns each device an IRQ. In 
essence, programmable devices allow the paradigm to be reversed: instead of assigning 
an IRQ to a device and then configuring the operating system to match the assignment, 
programmable devices allow the operating system to choose an IRQ and then assign the 
number to the device. Because the operating system handles assignment when a com-
puter boots, the automated approach eliminates human error, and makes it possible for 
users to attach new hardware to their computer without understanding IRQ assignment.
Dynamic assignment for pluggable devices. A final approach is used to accommo-
date devices that can be plugged into a computer while the operating system is running.

220 
Interrupt Processing 
Chap. 12
For example, consider a Universal Serial Bus (USB) that allows devices to be connected 
or disconnected at runtime. A USB uses two levels of interrupt binding. At the first 
level, a computer contains a USB host controller device that attaches to the computer’s 
bus. When it boots, the operating system recognizes the host controller, and assigns it a 
unique IRQ value using the same automated assignment used for other devices. The 
operating system configures a device driver for the USB host controller, and the driver 
includes a function that handles interrupts. We will use the term master driver to 
describe the software that handles USB host controller interrupts.
At runtime, when a user plugs a device into a USB port, a second level binding oc-
curs. The USB controller hardware detects the new device, and generates an interrupt.
The master driver receives control, and communicates across the USB to obtain the type 
and model of the new device. The master dynamically loads a driver for the new de-
vice, and records the driver location. Later, when the USB device interrupts, the master 
obtains control, determines which of the devices plugged into the USB generated the in-
terrupt, and forwards control to the appropriate driver. Finally, when a user disconnects 
a USB device, the master receives an interrupt, determines which device has been un-
plugged, and removes its record of the device.
12.8 Interrupt Dispatching
Several questions arise about the design of an interrupt and/or exception mecha-
nism. How large is an interrupt or exception vector? Does an entry in a vector contain 
more than the address of a handler? Where is the vector stored? Does the hardware or 
operating system perform indexing? A variety of designs have been used. Most sys-
tems choose a maximum size for the vector. Some systems place the vector at a fixed 
location in memory; a slightly more advanced design allows the operating system to 
choose a memory location and then inform the hardware.
We use the term interrupt dispatching to refer to the steps that are taken to obtain
a device number, use the device number as an index into a vector, extract the address of
a handler, and pass control to the handler. To make dispatching efficient and to
separate I/O details from the processor, many systems use a special-purpose hardware 
device known as an interrupt controller.†
The example platforms illustrate two types of interrupt controllers. The controller 
used on the BeagleBone Black handles communication over the bus, but does not store 
interrupt vectors. Instead, when an interrupt occurs, the controller obtains an integer 
IRQ from the device, raises an IRQ exception, and passes the IRQ value to the proces-
sor. The operating system manages the interrupt vectors, and performs the steps of us-
ing the IRQ as an index into the interrupt vector and passing control to the appropriate 
handler. The interrupt controller for the Galileo stores the entire interrupt vector. 
When a device interrupts, the controller obtains the IRQ, uses the IRQ as an index into 
the interrupt vector array, and calls the appropriate handler. On the Galileo, the operat-
ing system must load the vector into the controller at startup, before any interrupts or 
exceptions occur. The point is:

†In a traditional computer design, an interrupt controller consists of a separate chip; in an SoC design, the
controller is physically located on the SoC, but remains external to the processor.

Sec. 12.8        Interrupt Dispatching 
221
Most systems use external interrupt controller hardware. The design
of the controller determines which steps of interrupt dispatching are 
handled by the hardware and which steps are handled by the operat-
ing system.
12.9 The Structure Of Interrupt Software
Because interrupt dispatching involves saving and restoring hardware state,
dispatch code must be written in assembly language. However, system designers prefer
to write device drivers, including interrupt handlers, in a high-level language, such as C. 
To accommodate the requirement for assembly language, we follow an approach used in 
most systems: interrupt code is divided into two parts: a low-level piece written in as-
sembly language and a high-level piece written in C. We use the term dispatcher for 
the low-level piece and handler for the high-level piece. Figure 12.4 illustrates the con-
cept.
dispatcher
handler
hardware interrupt
Figure 12.4 The conceptual division of interrupt code into a dispatcher writ-
ten in assembly language and a handler written in C.
As the sizes of items in the figure imply, a dispatcher is usually much smaller than 
a handler. In most systems, a dispatcher consists of a few lines of assembly language 
code. The dispatcher saves hardware state, usually by pushing copies of the general-
purpose registers onto the stack, and calls the handler code. When the handler returns, 
the dispatcher restores the machine state (e.g., by popping registers off the stack), and 
then uses the special instruction that returns from the interrupt. Of course, the call to a 
handler must follow the standard C calling conventions. Therefore, on some architec-
tures, the dispatcher includes a few extra instructions that set up the environment need-
ed by a C function.
12.9.1  Galileo (Intel)
Recall that the Intel interrupt controller stores the interrupt and exception vectors,
and invokes code associated with a specific exception or device. For example, when
the Ethernet device interrupts, control passes to the Ethernet interrupt code, and when
the serial console interrupts, control passes to the code that handles interrupts on the
serial console.

222 
Interrupt Processing 
Chap. 12
Interrupt controller hardware that invokes code for a specific device can save time 
because the operating system does not need to index interrupt vectors in memory. 
However, the design has a consequence for device driver software: a driver must in-
clude low-level dispatch code. Our Galileo device drivers illustrate the organization: 
each driver has both a dispatch function (written in assembly language) and a handler 
function (written in C). Figure 12.5 illustrates the structure.
H1
H2
Hn
...
Ethernet dispatcher
Ethernet handler
Serial dispatcher
Serial handler
Other dispatcher
hardware interrupts
Figure 12.5 The structure of interrupt code on the Galileo. Each device
driver has both a low-level dispatcher and a high-level handler.
12.9.2  BeagleBone Black (ARM)
The interrupt controller hardware used with BeagleBone Black differs from the 
controller used with the Galileo. The controller on the BeagleBone Black does not
store interrupt vectors, nor does it invoke the code for a specific device. Instead, the 
hardware groups device interrupts into two exceptions: IRQ and FIQ. Because the de-
vices of interest only use the IRQ mechanism, we will ignore FIQ, and assume all de-
vices are grouped into the IRQ exception. When a device interrupts, an IRQ exception 
occurs, and the hardware invokes a single function in the operating system. A hardware 
register specifies the IRQ of the interrupting device.
Recall that the exception vectors reside in memory, and the operating system must 
initialize the vectors at startup. The hardware maps the interrupt from any device into 
an IRQ exception, jumps to the interrupt vector, which has been initialized with code
that will jump to the IRQ dispatcher. The IRQ dispatcher determines which device in-
terrupted, and then calls the appropriate handler. Figure 12.6 illustrates the structure.

Sec. 12.9        The Structure Of Interrupt Software 
223
H1
H2
Hn
...
Ethernet handler
Serial handler
. . .
. . .
irq_dispatch
hardware exceptions
data exception
IRQ exception
other exception
code for data exception
code for IRQ exception (irq_except)
code for other exception
Figure 12.6  The two-level interrupt code on the BeagleBone Black.  Device
exceptions pass to an assembly language function, irq_except, 
which calls a dispatcher written in C, which calls a handler.
Function irq_dispatch is found in file evec.c. Although the file contains other
functions (initintc to initialize the interrupt controller hardware and set_evec to assign
an entry in the parallel exception vector array), we only need to consider irq_dispatch.
The code appears on the next page.
12.10 Disabling Interrupts
Interrupts play a fundamental role in operating system design. The basic idea is
easy to understand. The hardware disables further interrupts once an interrupt occurs.
As a result, interrupt code cannot be interrupted. That is, interrupts remain disabled
when the dispatcher runs, when the handler is called, and when the handler returns. In-
terrupts are only enabled when the processor executes a special instruction (or sequence 
of instructions) that return from the interrupt to the place at which processing was origi-
nally interrupted. The point can be summarized:
Interrupts are disabled when an interrupt occurs, and remain disabled 
until the code returns from an interrupt.

224 
Interrupt Processing 
Chap. 12
//** SSnniippppeett ooff ccooddee ffrroomm eevveecc..cc **//
//**--------------------------------------------------------------------------------------------------------------------------------------------------
** iirrqq__ddiissppaattcchh
--
CCaallll tthhee hhaannddlleerr ffoorr ssppeecciiffiicc iinntteerrrruupptt
**--------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
iirrqq__ddiissppaattcchh(())
{{
ssttrruucctt
iinnttcc__ccssrreegg **ccssrrppttrr == ((ssttrruucctt iinnttcc__ccssrreegg **))00xx4488220000000000;;
uuiinntt3322
xxnnuumm;;
//** IInntteerrrruupptt nnuummbbeerr ooff ddeevviiccee
**//
iinntteerrrruupptt ((**hhaannddlleerr))(());;
//** PPooiinntteerr ttoo hhaannddlleerr ffuunnccttiioonn
**//
//** GGeett tthhee iinntteerrrruupptt nnuummbbeerr ffrroomm tthhee IInntteerrrruupptt ccoonnttrroolllleerr **//
xxnnuumm == ccssrrppttrr-->>ssiirr__iirrqq && 00xx77FF;;
//** IIff aa hhaannddlleerr iiss sseett ffoorr tthhee iinntteerrrruupptt,, ccaallll iitt **//
iiff((iinnttcc__vveeccttoorr[[xxnnuumm]])) {{
hhaannddlleerr == iinnttcc__vveeccttoorr[[xxnnuumm]];;
hhaannddlleerr((xxnnuumm));;
}} 
//** AAcckknnoowwlleeddggee tthhee iinntteerrrruupptt **//
ccssrrppttrr-->>ccoonnttrrooll ||== ((IINNTTCC__CCOONNTTRROOLL__NNEEWWIIRRQQAAGGRR));;
}}
Although it may seem obvious, the interrupt policy stated above has subtle conse-
quences. Device hardware places strict limits on the time a processor can run with in-
terrupts disabled. If an operating system leaves interrupts disabled arbitrarily long, de-
vices will fail to perform correctly. For example, a network device may drop incoming 
packets if the onboard packet buffer fills and interrupts remain disabled. As a conse-
quence, interrupt routines must be written to complete processing as quickly as possible 
and resume executing the code that had interrupts enabled. More important, interrupts 
are global — if the handler for one device leaves interrupts disabled, all devices are af-
fected. Thus, when creating interrupt code, a programmer must be aware of the con-
straints on other devices in the system, and must accommodate the device with the 
smallest time constraint. The point can be summarized:
The maximum time that an interrupt handler for device D can leave 
interrupts disabled cannot be computed by examining device D. In-
stead, the time is computed by choosing the smallest constraint across 
all devices in the system.

Sec. 12.10        Disabling Interrupts 
225
The rule may seem obvious and trivial. One must remember, however, that com-
puters are designed to accommodate an arbitrary set of devices and to allow owners to 
connect new devices at any time. Therefore, when writing an interrupt handler for a 
specific device, a programmer cannot know the set of devices that will be connected to 
the computer. Users experience a consequence: a driver for an existing device, X, may 
not be compatible with hardware for a new device, Y.
12.11 Constraints On Functions That Interrupt Code Invokes
In addition to ensuring that interrupt code accommodates the device with the tight-
est time constraints, an operating system designer must build interrupt code to be exe-
cuted by an arbitrary process. That is, interrupt code is executed by whichever process 
is running when the interrupt occurs.
The process executing an interrupt seems irrelevant until one considers two facts:
d An interrupt handler can invoke operating system functions.
d Because the scheduler assumes at least one process will remain
ready to run, the null process must remain in either the current or 
ready state.
The null process is designed to be an infinite loop that does not make function 
calls. However, an interrupt can be thought of as occurring “between” two successive 
instructions. Thus, if an interrupt occurs while the null process is executing, the null 
process will remain running while the handler executes. The most important conse-
quence is:
Interrupt routines can only call operating system functions that leave 
the executing process in the current or ready states.
That is, interrupt routines may invoke functions such as send or signal, but may not in-
voke functions such as wait that move the executing process to a non-eligible state.
12.12 The Need To Reschedule During An Interrupt
Consider the question of rescheduling during an interrupt. To see why reschedul-
ing is needed, observe the following:
d The scheduling invariant specifies that at any time, a highest priori-
ty eligible process must be executing.
d When an I/O operation completes, a high-priority process may be-
come eligible to execute.

226 
Interrupt Processing 
Chap. 12
For example, suppose a high-priority process, P, chooses to read a packet from the 
network. Even though it has high priority, P must block to wait for a packet. While P
is blocked, some other process, Q, will be running. When a packet arrives and an inter-
rupt occurs, process Q will be interrupted, and will execute the interrupt handler. If the 
interrupt handler merely moves P to the ready state and returns, process Q will continue 
to execute. If Q has lower-priority than P, the scheduling invariant will be violated.
As an extreme case, consider what happens if a system only contains one applica-
tion process, and the application blocks to wait for I/O. The null process will be run-
ning when the interrupt occurs. If the interrupt handler does not reschedule, the inter-
rupt will return to the null process and the application will never execute. The key idea
is:
To ensure that processes are notified promptly when an I/O operation 
completes and to maintain the scheduling invariant, an interrupt 
handler must reschedule whenever it makes a waiting process ready.
12.13 Rescheduling During An Interrupt
The interaction between the scheduling and interrupt policies creates a complex 
question: under what circumstances can we allow rescheduling? We said that interrupt 
routines must keep interrupts disabled while processing an interrupt. We also said that 
an interrupt handler must re-establish the scheduling invariant if a process that was 
waiting for I/O becomes eligible to execute. However, consider what can happen dur-
ing rescheduling. Suppose the process that is selected to execute has been executing 
with interrupts enabled. Once it begins to execute, the process will return from the 
scheduler, and interrupts will be allowed. Thus, it might seem that an interrupt handler 
should not be allowed to reschedule because switching to a process that runs with inter-
rupts enabled could start a cascade of further interrupts. We must convince ourselves 
that rescheduling during an interrupt is safe as long as global data structures are valid.
To understand why rescheduling is safe, consider the series of events leading to a
call of resched from an interrupt handler. Suppose a process U was running with inter-
rupts enabled when the interrupt occurred. Interrupt dispatching uses U’s stack to save
the state, and leaves process U running with interrupts disabled while executing the in-
terrupt handler. Suppose the handler calls resched, which switches to another process, 
T. After T returns from the context switch, T may be running with interrupts enabled, 
and another interrupt may occur. What prevents an infinite loop where unfinished inter-
rupts pile up until a stack overflows with interrupt function calls? Recall that each 
process has its own stack. Process U had one interrupt on its stack when it was stopped 
by the context switch. The new interrupt occurs while the processor is executing proc-
ess T, which means the processor is using T’s stack.
Consider process U. Before another interrupt can pile up on U’s stack, U must re-
gain control of the processor and interrupts must be enabled. At the last step before it
gave up control, U called the scheduler, resched, which called the context switch. At

Sec. 12.13        Rescheduling During An Interrupt 
227
that point, U was running with interrupts disabled. Therefore, when U regains control
(i.e., when the scheduler selects U again and performs a context switch), U will begin 
executing with interrupts disabled. That is, U will start executing in the context switch. 
The context switch will return to the scheduler, the scheduler will return to the interrupt 
handler, and the handler will return to the dispatcher.
During the sequence of returns, U will continue to execute with interrupts disabled 
until the dispatcher returns from the interrupt (i.e., until interrupt processing completes 
and the dispatcher returns to the location at which the original interrupt occurred). So, 
no additional interrupts can occur while process U is executing interrupt code (even 
though an interrupt can occur if U switches to another process and the other process 
runs with interrupts enabled). The important constraint is: only one interrupt can be in 
progress for a given process at any time. Because only a finite number of processes ex-
ist in the system at a given time and each process can have at most one outstanding in-
terrupt, the number of outstanding interrupts is bounded. To summarize:
Rescheduling during interrupt processing is safe provided that (1) in-
terrupt code leaves global data in a valid state before rescheduling, 
and (2) no function enables interrupts unless it disabled them.
The rule explains why all operating systems functions use disable/restore rather 
than disable/enable. A function that disables interrupts upon entry always restores them 
before returning to its caller; no routine ever enables interrupts explicitly. The hardware 
that manages interrupts follows the same paradigm as the operating system. When an 
interrupt occurs, further interrupts are disabled, and they remain disabled until the pro-
cessor returns from interrupt processing. The only exception to our rule about disabling 
and restoring interrupts is found in the system initialization function which enables in-
terrupts explicitly at system startup.†
12.14 Perspective
The relationship between interrupts and processes is among the most subtle and 
complex aspects of operating systems. Interrupts are low-level mechanisms — they are 
part of the underlying hardware and are defined in terms of sequential notions such as 
the fetch-execute cycle. Processes are high-level abstractions — they are imagined by 
operating system designers and defined by a set of system functions. Consequently, it 
is easiest to understand interrupts by thinking about the mechanism without thinking 
about concurrent processes, and easiest to understand concurrent processes by thinking 
about the abstraction without thinking about interrupts.
Unfortunately, combining the abstract world of processes and the concrete world of 
interrupts is intellectually challenging. If the interactions between interrupts and
processes does not seem incredibly complex, you have not thought about it deeply. If it 
seems too complex to grasp, console yourself that you are not alone. With careful 
thought, you will be able to master the basics.

†At startup, a processor disables all interrupt processing until the operating system runs and enables them.

228 
Interrupt Processing 
Chap. 12
12.15 Summary
To process an interrupt, the hardware and operating system cooperate to save a
copy of the processor state, determine which device requested the interrupt, and invoke
a handler for the device. Because a high-level language does not provide facilities to 
manipulate machine state, interrupt code is divided into a dispatcher that is written in 
assembly language and a handler that is written in a high-level language, such as C. On 
the Galileo, a separate dispatch function is needed for each device; on the BeagleBone 
Black, a single dispatch function handles all devices.
Three basic rules control interrupt processing. First, interrupt code must not leave 
interrupts disabled arbitrarily long or devices will fail to operate correctly. The length 
of time an interrupt can be delayed depends on all devices attached to the system, not
only on the device being serviced. Second, because it can be executed by the null proc-
ess, interrupt code must never call a function that will move the executing process out 
of the current or ready states. Third, an interrupt handler must use a special instruction 
to return from an interrupt; the code must never enable interrupts explicitly.
Despite the prohibition on enabling interrupts, a handler can call resched whenever 
a waiting process becomes ready. Doing so re-establishes the scheduling invariant and 
also means that if a process is waiting for I/O to complete, the process will be informed 
promptly. Of course, the code must ensure that global data structures are in a valid 
state before rescheduling. Rescheduling does not cause a cascade of interrupts because 
each process can have at most one interrupt on its stack.
EXERCISES
12.1  
Suppose an interrupt handler contains an error that explicitly enables interrupts.
Describe how a system might fail.
12.2      Modify interrupt handlers to enable interrupts, and see how long a system can run before
crashing. Are you surprised? Determine exactly why the system crashes. (Note: for this 
exercise, disable the timer device that is described in the next chapter.)
12.3      On the BeagleBone Black platform, how many functions are called each time a character
arrives over a serial line? Can the number of calls be reduced, or does the software ar-
chitecture depend on the hardware? Explain.
12.4 
Imagine a processor where the hardware automatically switches context to a special “in-
terrupt process” whenever an interrupt occurs. The only purpose of the interrupt process
is to run interrupt code. Does such a design make an operating system easier or more 
difficult to design? Explain. Hint: will the interrupted process be permitted to 
reschedule?
12.5 
If you could redesign interrupt controller hardware, what changes would you make to
minimize the work the operating system needs to do?
12.6 
Calculate how many microseconds can be spent per interrupt assuming eight serial de-
vices each receive characters at 115 Kbaud (115 thousand bits per second, or approxi-
mately 11,500 characters per second).

Exercises
229
12.7 
Download a copy of the Xinu source code, and examine the interrupt functions in intr.S
for both the Galileo and BeagleBone Black (for the Galileo, also include the dispatch 
function from a device driver). Explain the purpose of each line of code.
12.8  
Read about IRQ mode in the ARM architecture. Which registers are banked? Why?
12.9  
Download a copy of source code for both the ARM and Galileo versions of Xinu. Com-
pare function set_evec for the two architectures. What is the chief difference?


Chapter Contents
13.1 
Introduction, 233
13.2 
Timed Events, 234
13.3 
Real-time Clocks And Timer Hardware, 234
13.4 
Handling Real-time Clock Interrupts, 235
13.5 
Delay And Preemption, 236
13.6 
Implementation Of Preemption, 237
13.7 
Efficient Management Of Delay With A Delta List, 238
13.8 
Delta List Implementation, 239
13.9 
Putting A Process To Sleep, 241
13.10 Timed Message Reception, 244
13.11 Awakening Sleeping Processes, 248 
13.12 Clock Interrupt Processing, 249
13.13 Clock Initialization, 251 
13.14 Perspective, 254
13.15 Summary, 255


13
Real-time Clock 
Management
We haven’t the time to take our time.
— Eugene Ionesco
13.1 Introduction
Earlier chapters describe two major pieces of an operating system: a process
manager that provides concurrent processing and a memory manager that allows blocks
of memory to be allocated and released dynamically. The previous chapter introduces 
interrupt processing. The chapter states rules for interrupt processing, describes how the 
operating system captures control when an interrupt occurs, and explains how control 
passes through a dispatcher to a device-specific interrupt handler.
This chapter continues the discussion of interrupts by describing timing hardware
and explaining how an operating system uses a real-time mechanism to provide
processes with the ability to control timed events. The chapter introduces two funda-
mental concepts: a delta list data structure and process preemption. It explains how an 
operating system uses a clock to provide round-robin service to a set of equal-priority 
processes. Later chapters extend the study of interrupts by exploring device drivers for 
other I/O devices.
233

234 
Real-time Clock Management 
Chap. 13
13.2 Timed Events
Many applications use timed events. For example, an application might create a 
window to display a message, leave the window on the screen for five seconds, and 
then remove the window. An application that prompts for a password might choose to 
exit unless a password is entered within thirty seconds. Parts of an operating system
also use timed events. For example, many network protocols require a sender to re-
transmit a request if no response is received within a specified time. Similarly, an 
operating system might choose to inform a user if a peripheral, such as a printer, 
remains disconnected for more than a few seconds. On small embedded systems that do 
not have a separate hardware mechanism, an operating system uses timed events to 
maintain the current date and time of day.
Because time is fundamental, most operating systems provide facilities that make it 
easy for an application to create and manage a set of timed events. Some systems use a 
general-purpose asynchronous event paradigm in which a programmer defines a set of 
event handlers and the operating system invokes the appropriate handler when an event 
occurs. Timed events fit into the asynchronous paradigm easily: a running process re-
quests that a specific event occur T time units in the future. Other systems follow a 
synchronous event paradigm in which the operating system only provides delay and a 
programmer creates extra processes as needed to schedule events. Our example system 
uses the synchronous approach.
13.3 Real-time Clocks And Timer Hardware
Four types of hardware devices relate to time:
d Processor clock
d Real-time clock
d Time-of-day clock
d Interval timer
Processor clock. The term processor clock refers to a hardware device that emits 
pulses (i.e., square waves) at regular intervals with high precision. The processor clock 
controls the rate at which the processor executes instructions. To minimize hardware, 
low-end embedded systems often use the processor clock as a source of timing informa-
tion. Unfortunately, a processor clock rate is often inconvenient (i.e., the clock pulses 
rapidly, and the rate may not divide evenly into one second).
Real-time clock. A real-time clock operates independent of the processor, and 
pulses in fractions of a second (e.g., 1000 times per second), generating an interrupt for 
each pulse. Usually, real-time clock hardware does not count pulses — if an operating 
system needs to compute an elapsed time, the system must increment a counter when 
each clock interrupt occurs.

Sec. 13.3        Real-time Clocks And Timer Hardware 
235
Time-of-day clock. Technically, a time-of-day clock is a chronometer that com-
putes elapsed time. The hardware consists of an internal real-time clock connected to a 
counter that tallies the pulses. Like a normal clock, the time can be changed. Once set, 
however, the mechanism runs independent of the processor, and continues as long as the 
system receives power (some units include a small battery to keep the clock active even 
if the external power is removed temporarily). Unlike other clocks, a time-of-day clock 
does not interrupt — the processor must set or interrogate the clock.
Interval timer. An interval timer, sometimes called a count-down timer or simply a 
timer, also consists of an internal real-time clock and a counter. To use an interval tim-
er, the system initializes the counter to a positive value. The timer decrements the
count once for each real-time clock pulse, and generates an interrupt when the count 
reaches zero. A variant known as a count-up timer requires the operating system to ini-
tialize the count to zero and set a limit. As the name implies, a count-up timer incre-
ments the counter, and interrupts the operating system when the counter reaches the 
limit value.
The chief advantage of a timer over a real-time clock lies in lower interrupt over-
head. A real-time clock interrupts regularly, even if the next event is many time units 
in the future. A timer only interrupts when an event is scheduled. Furthermore, a timer 
is more flexible than a real-time clock because a timer can emulate a real-time clock. 
To emulate a real-time clock with a rate of R pulses per second, for example, a timer is
set to interrupt in 1/ R seconds. When an interrupt occurs, the timer is reset to the same 
value. To summarize:
The hardware an operating system uses to manage timed events con-
sists of real-time clocks and interval timers. A real-time clock inter-
rupts regularly; an interval timer interrupts after a specified delay.
In terms of the example platforms, the Galileo has a real-time clock, and the 
BeagleBone Black has an interval timer. At startup, the Galileo code configures the
real-time clock to interrupt once every millisecond. The BeagleBone Black code con-
figures the interval timer to act like a real-time clock by specifying that the timer should 
interrupt after a millisecond and should automatically restart when an interrupt occurs. 
Thus, the following sections that describe how an operating system uses a real-time 
clock apply to both of the example platforms.
13.4 Handling Real-time Clock Interrupts
We said that a real-time clock interrupts regularly without counting or accumulat-
ing interrupts. Similarly, if a timer is used to emulate a real-time clock, the timer does
not accumulate interrupts. In either case, if a processor fails to service a clock interrupt 
before the clock pulses again, the processor will not receive the second interrupt. More 
important, the hardware does not detect or report the error†:

†Although hardware exists that can report overflow, many clock modules do not.

236 
Real-time Clock Management 
Chap. 13
If a processor takes too long to service a real-time clock interrupt or
if it operates with interrupts disabled for more than one clock cycle, a 
clock interrupt will be missed and no error will be reported.
The operation of real-time clock hardware has two significant consequences for 
system designers. First, because it must be able to execute many instructions between 
real-time clock interrupts, a processor must operate significantly faster than the real-
time clock. Second, real-time clock interrupts can be a source of hidden errors. That is, 
if an operating system runs too long with interrupts disabled, clock interrupts will be 
missed and timing will be affected. Such errors can easily go undetected.
Obviously, systems must be designed to service clock interrupts quickly. Some 
hardware helps by giving highest priority to real-time clock interrupts. Thus, if an I/O 
device and a clock device each request an interrupt at the same time, the processor re-
ceives the clock interrupt first, and only receives the I/O interrupt after the clock has 
been serviced.
13.5 Delay And Preemption
We will focus on two ways that an operating system uses timed events:
d Timed delay
d Preemption
Timed delay. An operating system allows any process to request a timed delay.
When a process requests a timed delay, the operating system moves the process from
the current state into a new state (which we call sleeping), and schedules a wakeup
event to restart the process at the specified time. When the wakeup event occurs, the 
process becomes eligible to use the processor, and executes according to the scheduling 
policy. Later sections explain how a process is put to sleep and how it is reawakened at 
the correct time.
Preemption. The process manager in an operating system uses a preemption mech-
anism to implement time slicing that guarantees equal-priority processes receive service 
round-robin, as specified by the scheduling policy in Chapter 5. The system defines a 
maximum time slice, T, that a process can execute without allowing other processes to 
execute. When it switches from one process to another, the scheduler schedules a 
preemption event T time units in the future. When a preemption event occurs, the event 
handler simply calls resched.
To understand how preemption works, observe that a system may contain multiple 
processes with the same priority. Thus, while one process executes, other processes of 
equal priority may be enqueued on the ready list, eligible to run. In such cases, a call to 
resched places the current process at the end of the ready list, behind other processes 
with equal priority, and switches to the first process on the list. Therefore, if k equal-

Sec. 13.5        Delay And Preemption 
237
priority processes are ready to use the processor, all k execute for at most one time slice 
before any process receives more service.
How long should a time slice be? We say that the choice of a time slice controls 
the granularity of preemption. Using a short time slice makes the granularity small by 
rescheduling often. Small granularity tends to keep all equal priority processes proceed-
ing at approximately the same pace because no process can run for more than T time 
units before another has an opportunity to run. However, a small granularity introduces 
higher overhead because the system switches context often. If the granularity is too 
small, the system will spend more time handling clock interrupts and context switching 
than executing application processes. A large granularity reduces the overhead of con-
text switching, but allows a process to hold the processor longer before allowing other 
processes to execute.
It turns out that in most systems, a process seldom uses the processor long enough 
for preemption to occur. Instead, a process usually performs I/O or executes a system 
function, such as wait, that causes rescheduling. In essence, a process voluntarily gives 
up control of the processor before its timeslice ends. More important, because input 
and output are slow compared to processing, processes spend most of their time waiting 
for I/O to complete. Despite the expected case, preemption provides important func-
tionality:
Without a preemptive capability, an operating system cannot regain 
control from a process that executes an infinite loop.
13.6 Implementation Of Preemption
The example code implements both preemption and timed delays; before examin-
ing the code, we will discuss each. Preemption is the easiest to understand. Defined 
constant QUANTUM specifies the number of clock ticks in a single time slice. When-
ever it switches from one process to another, resched sets global variable preempt to 
QUANTUM. Each time the clock ticks, the clock interrupt handler decrements preempt. 
When preempt reaches zero, the clock interrupt handler resets preempt to QUANTUM 
and calls resched. Following the call to resched, the handler returns from the interrupt.
The call to resched has two possible outcomes. First, if the currently executing
process remains the only process at the highest priority, resched will return immediate-
ly, the interrupt handler will return, and the current process will return to the point of
the interrupt and continue executing for another timeslice. Second, if another ready 
process has the same priority as the current process, the call to resched will switch to 
the new process. Eventually, resched will switch back to the interrupted process. The 
assignment of QUANTUM to preempt handles the case where the current process 
remains running. The assignment is needed because resched only resets the preemption 
counter when it switches to a new process.† Note that resetting the preemption counter 
prevents the counter from underflowing in cases where a single process executes inde-
finitely.

†The code for resched can be found on page 82.

238 
Real-time Clock Management 
Chap. 13
13.7 Efficient Management Of Delay With A Delta List
To implement delay, the operating system must maintain information about the set 
of processes that have requested a delay. Each process specifies a delay relative to the 
time at which it places a request, and additional processes can make a request at any 
time. When the delay for a process expires, the system makes the process ready and 
calls resched.
How can an operating system maintain a set of processes that have each requested 
a specific delay? The system cannot afford to search through arbitrarily long lists of 
sleeping processes on each clock tick. Therefore, an efficient data structure is needed 
that only requires a clock interrupt handler to execute a few instructions on each clock 
tick while accommodating a set of processes that have each requested a specific delay.
The solution lies in a data structure that we call a delta list. A delta list contains a
set of processes, and the list is ordered by the time at which a process should awaken.
The fundamental insight needed to make computation efficient lies in the use of relative 
rather than absolute times. That is, instead of storing a value that specifies the time a 
process should awaken, a key in the delta list stores the additional time a process must 
delay beyond the preceding process on the list:
The key of the first process on a delta list specifies the number of
clock ticks a process must delay beyond the current time; the key of 
each other process on a delta list specifies the number of clock ticks 
the process must delay beyond the preceding process on the list.
As an example, suppose processes A, B, C, and D request delays of 6, 12, 27, and 
50 ticks, respectively. Further suppose the requests are made at approximately the same 
time (i.e., within one clock tick). Figure 13.1 illustrates the delta list that will result.
6
A
23 
D
6
B
15 
C
key process next
Figure 13.1 Conceptual form of a delta list with four processes that have de-
lays 6, 12, 27, and 50 ticks from the current time, respectively.
Given a delta list, one can find the time at which each process will awaken by 
computing partial sums of keys. In the figure, the delay before process A awakens is 6, 
the delay before process B awakens is 6 + 6, the delay before process C awakens is
6 + 6 + 15, and the delay before D  awakens is 6 + 6 + 15 + 23.

Sec. 13.8        Delta List Implementation 
239
13.8 Delta List Implementation
An overarching goal of operating systems designers arises from the desire to 
achieve maximal functionality with minimal mechanism. Designs that provide powerful 
functionality with minimal overhead are valued. To achieve such goals, designers look 
for ways to create underlying mechanisms that accommodate multiple functions. In the 
case of delta lists, we will see that it is possible to use the basic list data structure 
covered in Chapter 4. That is, the delta list of delayed processes will reside in the 
queuetab structure, just like other lists of processes.
Conceptually, the processing required for a delta list is straightforward. Global 
variable sleepq contains the queue ID of the delta list for sleeping processes. On each
clock tick, the clock interrupt handler examines the queue of sleeping processes, and de-
crements the key on the first item if the queue is nonempty. If the key reaches zero, the 
delay has expired and the process must be awakened. To awaken a process, the clock 
handler calls function wakeup
Functions to manipulate a delta list seem straightforward, but the implementation 
can be tricky. Therefore, a programmer must pay close attention to details. Function 
insertd takes three arguments: a process ID, pid, a queue ID, q, and a delay given by ar-
gument key.  Insertd finds the location on the delta list where the new process should be 
inserted and links the process into the list. In the code, variable next scans the delta list 
searching for the place to insert the new process. File insertd.c contains the code.
Observe that the initial value of argument key specifies a delay relative to the
current time. Thus, argument key can be compared to the key in the first item on the
delta list. However, successive keys in the delta list specify delays relative to their 
predecessor. Thus, the key in successive nodes on the list cannot be compared directly 
to the value of argument key. To keep the delays comparable, insertd subtracts the rela-
tive delays from key as the search proceeds, maintaining the following invariant:
At any time during the search, both key and queuetab[next].qkey
specify a delay relative to the time at which the predecessor of “next”
awakens.
Although insertd checks for the tail of the list explicitly during the search, the test 
could be removed without affecting the execution. To understand why, recall that the 
key value in the tail of a list is assumed to be greater than any key being inserted. As
long as the assertion holds, the loop will terminate once the tail has been reached. Be-
cause insertd does not check its argument, keeping the test provides a safety check.
After it has identified a location on the list where the relative delay of the item be-
ing inserted is smaller than the relative delay of an item on the list, insertd links the
new item into the list.  Insertd must also subtract the extra delay that the new item in-
troduces from the delay of the rest of the list. To do so, insertd decrements the key in 
the next item on the list by the key value being inserted. The subtraction is guaranteed

240 
Real-time Clock Management 
Chap. 13
to produce a nonnegative value because the termination condition for the loop guaran-
tees that the key inserted is less than the next key on the list.
//** iinnsseerrttdd..cc -- iinnsseerrttdd **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
iinnsseerrttdd
--
IInnsseerrtt aa pprroocceessss iinn ddeellttaa lliisstt uussiinngg ddeellaayy aass tthhee kkeeyy
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
iinnsseerrttdd((
//** AAssssuummeess iinntteerrrruuppttss ddiissaabblleedd
**//
ppiidd3322
ppiidd,,
//** IIDD ooff pprroocceessss ttoo iinnsseerrtt
**//
qqiidd1166
qq,,
//** IIDD ooff qquueeuuee ttoo uussee
**//
iinntt3322
kkeeyy
//** DDeellaayy ffrroomm ""nnooww"" ((iinn mmss..))
**//
))
{{
iinntt3322
nneexxtt;;
//** RRuunnss tthhrroouugghh tthhee ddeellttaa lliisstt
**//
iinntt3322
pprreevv;;
//** FFoolllloowwss nneexxtt tthhrroouugghh tthhee lliisstt**//
iiff ((iissbbaaddqqiidd((qq)) |||| iissbbaaddppiidd((ppiidd)))) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
pprreevv == qquueeuueehheeaadd((qq));;
nneexxtt == qquueeuueettaabb[[qquueeuueehheeaadd((qq))]]..qqnneexxtt;;
wwhhiillee ((((nneexxtt !!== qquueeuueettaaiill((qq)))) &&&& ((qquueeuueettaabb[[nneexxtt]]..qqkkeeyy <<== kkeeyy)))) {{
kkeeyy --== qquueeuueettaabb[[nneexxtt]]..qqkkeeyy;;
pprreevv == nneexxtt;;
nneexxtt == qquueeuueettaabb[[nneexxtt]]..qqnneexxtt;;
}} 
//** IInnsseerrtt nneeww nnooddee bbeettwweeeenn pprreevv aanndd nneexxtt nnooddeess **//
qquueeuueettaabb[[ppiidd]]..qqnneexxtt == nneexxtt;;
qquueeuueettaabb[[ppiidd]]..qqpprreevv == pprreevv;;
qquueeuueettaabb[[ppiidd]]..qqkkeeyy == kkeeyy;;
qquueeuueettaabb[[pprreevv]]..qqnneexxtt == ppiidd;;
qquueeuueettaabb[[nneexxtt]]..qqpprreevv == ppiidd;;
iiff ((nneexxtt !!== qquueeuueettaaiill((qq)))) {{
qquueeuueettaabb[[nneexxtt]]..qqkkeeyy --== kkeeyy;;
}} 
rreettuurrnn OOKK;;
}}

Sec. 13.8        Delta List Implementation 
241
13.9 Putting A Process To Sleep
An application does not call insertd, nor does the application access the sleep 
queue directly. Instead, an application invokes system call sleep or sleepms to request a 
delay. The only difference between the two functions is the granularity of their argu-
ments. An argument to sleepms specifies a delay in milliseconds, the smallest granular-
ity delay that is possible when a clock interrupts every millisecond. An argument to 
sleep specifies a delay in seconds, which is easier to use in some cases. For example, a 
delay visible to a human is often expressed in seconds rather than milliseconds.
To avoid duplicating code, function sleep multiplies its argument by 1000 and in-
vokes sleepms. The only interesting aspect of sleep is a check on its argument size: to 
avoid integer overflow, sleep limits the delay to a value that can be represented as a
32-bit unsigned integer. If the caller specifies a larger value, sleep returns SYSERR.
On a 32-bit processor, measuring delay in milliseconds provides an adequate range 
of delay for most applications. An unsigned 32-bit integer accommodates delays over 
1100 hours (49 days). Delays longer than 49 days can be managed by having a process 
repeatedly sleep for many days, awaken, check the time, and sleep again. On embedded 
systems that use 16-bit integers, however, millisecond delays mean that a caller can 
only express a delay of thirty-two seconds. Such systems seldom have much memory 
or processing power, so using a process to manage longer delays may not be feasible. 
Therefore, an operating system designed for a slow, 16-bit processor may choose a 
larger granularity for clock interrupts (e.g., tenths of seconds instead of milliseconds). 
If the clock generates interrupts every tenth of a second, a sleep function must be 
changed to measure delays in tenths of seconds.
The choice of delay granularity may also be limited by the speed of the processor. 
Handling clock interrupts can take a surprising amount of time because they never stop, 
even when no processes are sleeping. If a clock interrupts too fast, a processor will 
spend most of its time handling clock interrupts. Fortunately, processors have become 
extremely fast. As processor speeds increased, it became possible to increase the rate of 
clock interrupts, allowing the granularity of delays to decrease. Thus, the fastest pro-
cessors allow microsecond delays.
Consider the state of a sleeping process. We said that to delay a process, sleepms 
inserts the process into the delta list of sleeping processes. When it has been moved to 
the list of sleeping processes, the process is no longer ready or current. In what state
should it be placed? Sleeping differs from suspension, waiting to receive a message, or 
waiting for a semaphore. Thus, because none of the existing states suffices, a new proc-
ess state must be added to the design. We call the new state sleeping, and denote it 
with symbolic constant PR_SLEEP. Figure 13.2 illustrates state transitions that include 
the sleeping state.

242 
Real-time Clock Management 
Chap. 13
READY
CURRENT
resched
resched
SUSPENDED
suspend
resume
suspend
create
WAITING
wait
signal
RECEIVING
receive
send
SLEEPING
sleep
wakeup
Figure 13.2  State transitions including the sleeping state.
The implementation of sleepms, shown below in file sleep.c, includes a special 
case: if a process specified a delay of zero, sleepms does not delay the process, but calls 
resched immediately. Otherwise, sleepms uses insertd to insert the current process in 
the delta list of sleeping processes, changes the state to sleeping, and calls resched to al-
low other processes to execute.
//** sslleeeepp..cc -- sslleeeepp sslleeeeppmmss **//
##iinncclluuddee <<xxiinnuu..hh>>
##ddeeffiinnee MMAAXXSSEECCOONNDDSS
44229944996677
//** MMaaxx sseeccoonnddss ppeerr 3322--bbiitt mmsseecc
**//

Sec. 13.9        Putting A Process To Sleep 
243
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
sslleeeepp
--
DDeellaayy tthhee ccaalllliinngg pprroocceessss nn sseeccoonnddss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll sslleeeepp((
uuiinntt3322
ddeellaayy
//** TTiimmee ttoo ddeellaayy iinn sseeccoonnddss
**//
))
{{
iiff ((ddeellaayy >> MMAAXXSSEECCOONNDDSS)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
sslleeeeppmmss((11000000**ddeellaayy));;
rreettuurrnn OOKK;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
sslleeeeppmmss
--
DDeellaayy tthhee ccaalllliinngg pprroocceessss nn mmiilllliisseeccoonnddss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll sslleeeeppmmss((
uuiinntt3322
ddeellaayy
//** TTiimmee ttoo ddeellaayy iinn mmsseecc..
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
mmaasskk == ddiissaabbllee(());;
iiff ((ddeellaayy ==== 00)) {{
yyiieelldd(());;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}} 
//** DDeellaayy ccaalllliinngg pprroocceessss **//
iiff ((iinnsseerrttdd((ccuurrrrppiidd,, sslleeeeppqq,, ddeellaayy)) ==== SSYYSSEERRRR)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
pprrooccttaabb[[ccuurrrrppiidd]]..pprrssttaattee == PPRR__SSLLEEEEPP;;
rreesscchheedd(());;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}

244 
Real-time Clock Management 
Chap. 13
13.10 Timed Message Reception
Xinu includes a mechanism that is especially useful in computer networking: timed 
message reception. In essence, the mechanism allows a process to wait for a specified 
time or for a message to arrive, whichever occurs first. The mechanism enhances the 
send and receive functions. That is, the mechanism operates like the synchronous re-
ceive function with an additional provision that places a bound on the maximum time 
the process will wait.
The fundamental concept behind timed message reception is disjunctive wait: a  
process blocks until one of two events occurs. Many network protocols use disjunctive 
wait to implement timeout-and-retransmission, a technique senders employ to handle 
packet loss. When it sends a message, a sender also starts a timer, and then waits for a 
reply to arrive or the timer to expire, whichever occurs first. If a reply arrives, the net-
work cancels the timer. If the message or the reply is lost, the timer expires, and the 
protocol software retransmits a copy of the request.
In Xinu, when a process requests a timed receive, the process is placed on the
queue of sleeping processes, exactly like any other sleeping process. Instead of assign-
ing the process state PR_SLEEP, however, the system places the process in state
PR_RECTIM to indicate that it is engaged in a receive with timeout. If the sleep timer 
expires, the process is awakened like any other sleeping process. If a message arrives 
before the delay expires, the process must be removed from the sleeping process queue. 
In our implementation, send handles the task of removing a process. That is, when 
sending a message to a process that has performed a disjunctive wait, send calls unsleep 
to remove the process from the queue of sleeping processes, and then proceeds to 
deliver the message.
How can a process know whether the timer expired before a message arrived? In
our implementation, the process tests the presence of a message. That is, once it
resumes execution after a timed delay, the process checks its process table entry to see
if a message has arrived. If no message is present, the timer must have expired. An ex-
ercise explores the consequences of the implementation.
Figure 13.3 shows the state diagram with a new state, TIMED-RECV, for timed
message reception.

Sec. 13.10        Timed Message Reception 
245
READY
CURRENT
resched
resched
SUSPENDED
suspend
resume
suspend
create
WAITING
wait
signal
RECEIVING
receive
send
SLEEPING
sleep
wakeup
TIMED-RECV
recvtime
wakeup
Figure 13.3  State transitions including the timed receive state.
As we have seen, the send† function in Chapter 8 handles the case where a process 
is in the timed receive state. Thus, we only need to examine the code for function recv-
time and unsleep. Function recvtime is almost identical to function receive‡ except that 
before calling resched, recvtime calls insertd to insert the calling process on the queue 
of sleeping processes and assigns state PR_RECTIM instead of state PR_RECV. File 
recvtime.c contains the code.

†Function send can be found in file send.c on page 147. 
‡Function receive can be found in file receive.c on page 148.

246 
Real-time Clock Management 
Chap. 13
//** rreeccvvttiimmee..cc -- rreeccvvttiimmee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
rreeccvvttiimmee
--
WWaaiitt ssppeecciiffiieedd ttiimmee ttoo rreecceeiivvee aa mmeessssaaggee aanndd rreettuurrnn
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
uummssgg3322
rreeccvvttiimmee((
iinntt3322
mmaaxxwwaaiitt
//** TTiicckkss ttoo wwaaiitt bbeeffoorree ttiimmeeoouutt **//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pprroocceenntt **pprrppttrr;;
//** TTbbll eennttrryy ooff ccuurrrreenntt pprroocceessss **//
uummssgg3322
mmssgg;;
//** MMeessssaaggee ttoo rreettuurrnn
**//
iiff ((mmaaxxwwaaiitt << 00)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
mmaasskk == ddiissaabbllee(());;
//** SScchheedduullee wwaakkeeuupp aanndd ppllaaccee pprroocceessss iinn ttiimmeedd--rreecceeiivvee ssttaattee **//
pprrppttrr == &&pprrooccttaabb[[ccuurrrrppiidd]];;
iiff ((pprrppttrr-->>pprrhhaassmmssgg ==== FFAALLSSEE)) {{ //** IIff mmeessssaaggee wwaaiittiinngg,, nnoo ddeellaayy **//
iiff ((iinnsseerrttdd((ccuurrrrppiidd,,sslleeeeppqq,,mmaaxxwwaaiitt)) ==== SSYYSSEERRRR)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
pprrppttrr-->>pprrssttaattee == PPRR__RREECCTTIIMM;;
rreesscchheedd(());;
}} 
//** EEiitthheerr mmeessssaaggee aarrrriivveedd oorr ttiimmeerr eexxppiirreedd **//
iiff ((pprrppttrr-->>pprrhhaassmmssgg)) {{
mmssgg == pprrppttrr-->>pprrmmssgg;;
//** RReettrriieevvee mmeessssaaggee
**//
pprrppttrr-->>pprrhhaassmmssgg == FFAALLSSEE;;//** RReesseett mmeessssaaggee iinnddiiccaattoorr
**//
}} eellssee {{
mmssgg == TTIIMMEEOOUUTT;;
}} 
rreessttoorree((mmaasskk));;
rreettuurrnn mmssgg;;
}}

Sec. 13.10        Timed Message Reception 
247
Function unsleep is an internal function that removes a process from the queue of 
sleeping processes.† To maintain the correct delays for processes that remain in the
queue, unsleep must keep all delays the same as before the deletion. To so do, unsleep 
examines the successor of the process being removed. If a successor exists, unsleep 
adds the delay of the process being removed to the delay of the successor. File 
unsleep.c contains the code.
//** uunnsslleeeepp..cc -- uunnsslleeeepp **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
uunnsslleeeepp
--
IInntteerrnnaall ffuunnccttiioonn ttoo rreemmoovvee aa pprroocceessss ffrroomm tthhee sslleeeepp
**
qquueeuuee pprreemmaattuurreellyy..
TThhee ccaalllleerr mmuusstt aaddjjuusstt tthhee ddeellaayy
**
ooff ssuucccceessssiivvee pprroocceesssseess..
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
uunnsslleeeepp((
ppiidd3322
ppiidd
//** IIDD ooff pprroocceessss ttoo rreemmoovvee
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pprroocceenntt **pprrppttrr;;
//** PPttrr ttoo pprroocceessss’’ ttaabbllee eennttrryy
**//
ppiidd3322
ppiiddnneexxtt;;
//** IIDD ooff pprroocceessss oonn sslleeeepp qquueeuuee **//
//**
tthhaatt ffoolllloowwss tthhee pprroocceessss
**//
//**
wwhhiicchh iiss bbeeiinngg rreemmoovveedd
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddppiidd((ppiidd)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** VVeerriiffyy tthhaatt ccaannddiiddaattee pprroocceessss iiss oonn tthhee sslleeeepp qquueeuuee **//
pprrppttrr == &&pprrooccttaabb[[ppiidd]];;
iiff ((((pprrppttrr-->>pprrssttaattee!!==PPRR__SSLLEEEEPP)) &&&& ((pprrppttrr-->>pprrssttaattee!!==PPRR__RREECCTTIIMM)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** IInnccrreemmeenntt ddeellaayy ooff nneexxtt pprroocceessss iiff ssuucchh aa pprroocceessss eexxiissttss **//

†The term internal emphasizes that unsleep is not a system call, and should not be called by a user proc-
ess.

248 
Real-time Clock Management 
Chap. 13
ppiiddnneexxtt == qquueeuueettaabb[[ppiidd]]..qqnneexxtt;;
iiff ((ppiiddnneexxtt << NNPPRROOCC)) {{
qquueeuueettaabb[[ppiiddnneexxtt]]..qqkkeeyy ++== qquueeuueettaabb[[ppiidd]]..qqkkeeyy;;
}} 
ggeettiitteemm((ppiidd));;
//** UUnnlliinnkk pprroocceessss ffrroomm qquueeuuee **//
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}
13.11 Awakening Sleeping Processes
We said that on each tick of the clock, the clock interrupt handler decrements the 
count of the first key on sleepq, and calls wakeup to awaken the process when the delay 
reaches zero. In fact, wakeup does not merely awaken one process — it must handle 
the case where multiple processes are scheduled to awaken at the same time. Therefore, 
after deferring rescheduling, wakeup iterates through all processes that have a delay of 
zero, using sleepq to remove the process from the sleep queue and ready to make the 
process eligible for processor service. (Note that because it has been called from an in-
terrupt dispatcher, which has interrupts disabled, wakeup can call ready without expli-
citly disabling interrupts.) Once it finishes moving processes to the ready list, wakeup 
calls resched_cntl to allow rescheduling, which means that a context switch will occur 
if a higher-priority process became ready.
//** wwaakkeeuupp..cc -- wwaakkeeuupp **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
wwaakkeeuupp
--
CCaalllleedd bbyy cclloocckk iinntteerrrruupptt hhaannddlleerr ttoo aawwaakkeenn pprroocceesssseess
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
wwaakkeeuupp((vvooiidd))
{{
//** AAwwaakkeenn aallll pprroocceesssseess tthhaatt hhaavvee nnoo mmoorree ttiimmee ttoo sslleeeepp **//
rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTAARRTT));;
wwhhiillee ((nnoonneemmppttyy((sslleeeeppqq)) &&&& ((ffiirrssttkkeeyy((sslleeeeppqq)) <<== 00)))) {{
rreeaaddyy((ddeeqquueeuuee((sslleeeeppqq))));;
}} 
rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTOOPP));;
rreettuurrnn;;
}}

Sec. 13.11        Awakening Sleeping Processes 
249
13.12 Clock Interrupt Processing
We are now ready to examine the code that handles clock interrupts. The clock is 
configured to interrupt once each millisecond. Recall that interrupt processing is ar-
ranged so the interrupt mechanism invokes a dispatch function written in assembly 
language that saves processor state and invokes a handler that is written in C. On the 
Galileo, each device has a separate dispatch function; the clock dispatch function is 
clkdisp. The file only contains a few lines of code that save registers, call the interrupt 
handler, clkhandler, restore registers, and return from the interrupt.
//** ccllkkddiisspp..ss -- ccllkkddiisspp ((xx8866)) **//
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ccllkkddiisspp
--
IInntteerrrruupptt ddiissppaattcchheerr ffoorr cclloocckk iinntteerrrruuppttss ((xx8866 vveerrssiioonn))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
##iinncclluuddee <<iiccuu..ss>>
..tteexxtt
..gglloobbll
ccllkkddiisspp
## CClloocckk iinntteerrrruupptt ddiissppaattcchheerr
ccllkkddiisspp::
ppuusshhaall
## SSaavvee rreeggiisstteerrss
ccllii
## DDiissaabbllee ffuurrtthheerr iinntteerrrruuppttss
mmoovvbb
$$EEOOII,,%%aall
## RReesseett iinntteerrrruupptt
oouuttbb
%%aall,,$$OOCCWW11__22
ccaallll
ccllkkhhaannddlleerr
## CCaallll hhiigghh lleevveell hhaannddlleerr
ssttii
## RReessttoorree iinntteerrrruupptt ssttaattuuss
ppooppaall
## RReessttoorree rreeggiisstteerrss
iirreett
## RReettuurrnn ffrroomm iinntteerrrruupptt
The clock interrupt handler, clkhandler, which manages sleeping processes and
preemption, can be found in file clkhandler.c.

250 
Real-time Clock Management 
Chap. 13
//** ccllkkhhaannddlleerr..cc -- ccllkkhhaannddlleerr **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ccllkkhhaannddlleerr -- hhiigghh lleevveell cclloocckk iinntteerrrruupptt hhaannddlleerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
ccllkkhhaannddlleerr(())
{{
ssttaattiicc
uuiinntt3322
ccoouunntt11000000 == 11000000;;
//** CCoouunntt ttoo 11000000 mmss
**//
//** DDeeccrreemmeenntt tthhee mmss ccoouunntteerr,, aanndd sseeee iiff aa sseeccoonndd hhaass ppaasssseedd **//
iiff((((----ccoouunntt11000000)) <<== 00)) {{
//** OOnnee sseeccoonndd hhaass ppaasssseedd,, ssoo iinnccrreemmeenntt sseeccoonnddss ccoouunntt **//
ccllkkttiimmee++++;;
//** RReesseett tthhee llooccaall mmss ccoouunntteerr ffoorr tthhee nneexxtt sseeccoonndd **//
ccoouunntt11000000 == 11000000;;
}} 
//** HHaannddllee sslleeeeppiinngg pprroocceesssseess iiff aannyy eexxiisstt **//
iiff((!!iisseemmppttyy((sslleeeeppqq)))) {{
//** DDeeccrreemmeenntt tthhee ddeellaayy ffoorr tthhee ffiirrsstt pprroocceessss oonn tthhee
**//
//**
sslleeeepp qquueeuuee,, aanndd aawwaakkeenn iiff tthhee ccoouunntt rreeaacchheess zzeerroo
**//
iiff((((----qquueeuueettaabb[[ffiirrssttiidd((sslleeeeppqq))]]..qqkkeeyy)) <<== 00)) {{
wwaakkeeuupp(());;
}}
}} 
//** DDeeccrreemmeenntt tthhee pprreeeemmppttiioonn ccoouunntteerr,, aanndd rreesscchheedduullee wwhheenn tthhee **//
//**
rreemmaaiinniinngg ttiimmee rreeaacchheess zzeerroo
**//
iiff((((----pprreeeemmpptt)) <<== 00)) {{
pprreeeemmpptt == QQUUAANNTTUUMM;;
rreesscchheedd(());;
}}
}}

Sec. 13.12        Clock Interrupt Processing 
251
Clkhandler begins by incrementing local variable count1000, which counts from
1000 down to 0. When count1000 reaches zero, one second (i.e., 1000 ms.) has
elapsed, so clkhandler increments global variable clktime, which stores the time in
seconds since the system booted. Clktime is used to provide the date (e.g., it is used by
the Xinu shell command date).
Once it has handled incrementing global counters, clkhandler performs two tasks 
related to processes: sleeping processes and time slicing. To manage sleeping
processes, clkhandler decrements the time remaining on the first process in sleepq (pro-
vided sleepq is nonempty). If the remaining delay reaches zero, clkdisp calls wakeup, 
which removes all processes from the sleep queue that have a zero delay. As we have 
seen, wakeup makes the processes ready. Finally, clkint decrements the preemption 
counter, calling resched if the preemption counter reaches zero.
13.13 Clock Initialization
Clock initialization can be divided into two conceptual parts: initialization related 
to the operating system and initialization related to the underlying clock hardware. In 
terms of the operating system, the clock initialization code performs three steps. First, 
it allocates a queue to hold the delta list of sleeping processes, and stores the queue ID 
in global variable sleepq. Second, it initializes the preemption counter, preempt to 
QUANTUM. Third, the code initializes global variable clktime, which gives the seconds 
since the system booted, to zero.
In terms of clock hardware initialization, the details vary widely among platforms. 
On the simplest systems, the clock hardware is completely preconfigured — both the in-
terrupt vector and clock rate are hardwired. On most systems, the hardware is 
parameterized, which means the operating system can control the rate at which inter-
rupts are generated. The operating system, may also be able to assign an interrupt vec-
tor.
Both the Galileo and BeagleBone Black platforms have configurable clock 
hardware. On the Galileo, the operating system must assign an interrupt vector, set the 
mode of the clock, and set the exact clock rate. Our code calls set_evec to configure 
clkdisp to be the function that receives interrupts. It then uses an outb call to configure 
the clock as a 16-bit timer. Finally, our code uses two calls of outb to configure the 
16-bit rate register to 1193, which will cause the clock to interrupt once per millisecond. 
The clock initialization code for the Galileo can be found in file clkinit.c.

252 
Real-time Clock Management 
Chap. 13
//** ccllkkiinniitt..cc -- ccllkkiinniitt ((xx8866)) **//
##iinncclluuddee <<xxiinnuu..hh>>
uuiinntt3322
ccllkkttiimmee;;
//** SSeeccoonnddss ssiinnccee bboooott
**//
uuiinntt3322
ccttrr11000000 == 00;;
//** MMiilllliisseeccoonnddss ssiinnccee bboooott
**//
qqiidd1166
sslleeeeppqq;;
//** QQuueeuuee ooff sslleeeeppiinngg pprroocceesssseess
**//
uuiinntt3322
pprreeeemmpptt;;
//** PPrreeeemmppttiioonn ccoouunntteerr
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ccllkkiinniitt
--
IInniittiiaalliizzee tthhee cclloocckk aanndd sslleeeepp qquueeuuee aatt ssttaarrttuupp ((xx8866))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
ccllkkiinniitt((vvooiidd))
{{
uuiinntt1166
iinnttvv;;
//** CClloocckk rraattee iinn KKHHzz
**//
//** AAllllooccaattee aa qquueeuuee ttoo hhoolldd tthhee ddeellttaa lliisstt ooff sslleeeeppiinngg pprroocceesssseess**//
sslleeeeppqq == nneewwqquueeuuee(());;
//** IInniittiiaalliizzee tthhee pprreeeemmppttiioonn ccoouunntt **//
pprreeeemmpptt == QQUUAANNTTUUMM;;
//** IInniittiiaalliizzee tthhee ttiimmee ssiinnccee bboooott ttoo zzeerroo **//
ccllkkttiimmee == 00;;
//** SSeett iinntteerrrruupptt vveeccttoorr ffoorr tthhee cclloocckk ttoo iinnvvookkee ccllkkddiisspp **//
sseett__eevveecc((IIRRQQBBAASSEE,, ((uuiinntt3322))ccllkkddiisspp));;
//** SSeett tthhee hhaarrddwwaarree cclloocckk:: ttiimmeerr 00,, 1166--bbiitt ccoouunntteerr,, rraattee **//
//**
ggeenneerraattoorr mmooddee,, aanndd ccoouunntteerr rruunnss iinn bbiinnaarryy
**//
oouuttbb((CCLLKKCCNNTTLL,, 00xx3344));;
//** SSeett tthhee cclloocckk rraattee ttoo 11..119900 MMhhzz;; tthhiiss iiss 11 mmss iinntteerrrruupptt rraattee **//
iinnttvv == 11119933;;
//** UUssiinngg 11119933 iinnsstteeaadd ooff 11119900 ttoo ffiixx cclloocckk sskkeeww **//
//** MMuusstt wwrriittee LLSSBB ffiirrsstt,, tthheenn MMSSBB **//
oouuttbb((CCLLOOCCKK00,, ((cchhaarr)) ((00xxffff && iinnttvv)) ));;

Sec. 13.13        Clock Initialization 
253
oouuttbb((CCLLOOCCKK00,, ((cchhaarr)) ((00xxffff && ((iinnttvv>>>>88))))));;
rreettuurrnn;;
}}
The clock initialization code for the BeagleBone Black is also in a file named
clkinit.c; the first line of the file indicates the platform.
//** ccllkkiinniitt..cc -- ccllkkiinniitt ((BBeeaagglleeBBoonnee BBllaacckk)) **//
##iinncclluuddee <<xxiinnuu..hh>>
uuiinntt3322
ccllkkttiimmee;;
//** SSeeccoonnddss ssiinnccee bboooott
**//
uuiinntt3322
ccttrr11000000 == 00;;
//** MMiilllliisseeccoonnddss ssiinnccee bboooott
**//
qqiidd1166
sslleeeeppqq;;
//** QQuueeuuee ooff sslleeeeppiinngg pprroocceesssseess
**//
uuiinntt3322
pprreeeemmpptt;;
//** PPrreeeemmppttiioonn ccoouunntteerr
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ccllkkiinniitt
--
IInniittiiaalliizzee tthhee cclloocckk aanndd sslleeeepp qquueeuuee aatt ssttaarrttuupp
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
ccllkkiinniitt((vvooiidd))
{{
vvoollaattiillee ssttrruucctt aamm333355xx__ttiimmeerr11mmss **ccssrrppttrr ==
((vvoollaattiillee ssttrruucctt aamm333355xx__ttiimmeerr11mmss **))AAMM333355XX__TTIIMMEERR11MMSS__AADDDDRR;;
//** PPooiinntteerr ttoo ttiimmeerr CCSSRR iinn BBBBoonneeBBllaacckk
**//
vvoollaattiillee uuiinntt3322 **ccllkkccttrrll ==
((vvoollaattiillee uuiinntt3322 **))AAMM333355XX__TTIIMMEERR11MMSS__CCLLKKCCTTRRLL__AADDDDRR;;
**ccllkkccttrrll == AAMM333355XX__TTIIMMEERR11MMSS__CCLLKKCCTTRRLL__EENN;;
wwhhiillee((((**ccllkkccttrrll)) !!== 00xx22)) //** DDoo nnootthhiinngg **// ;;
//** RReesseett tthhee ttiimmeerr mmoodduullee **//
ccssrrppttrr-->>ttiiooccpp__ccffgg ||== AAMM333355XX__TTIIMMEERR11MMSS__TTIIOOCCPP__CCFFGG__SSOOFFTTRREESSEETT;;
//** WWaaiitt uunnttiill tthhee rreesseett ooss ccoommpplleettee **//
wwhhiillee((((ccssrrppttrr-->>ttiissttaatt && AAMM333355XX__TTIIMMEERR11MMSS__TTIISSTTAATT__RREESSEETTDDOONNEE)) ==== 00))
//** DDoo nnootthhiinngg **// ;;
//** SSeett iinntteerrrruupptt vveeccttoorr ffoorr cclloocckk ttoo iinnvvookkee ccllkkiinntt **//
sseett__eevveecc((AAMM333355XX__TTIIMMEERR11MMSS__IIRRQQ,, ((uuiinntt3322))ccllkkhhaannddlleerr));;

254 
Real-time Clock Management 
Chap. 13
sslleeeeppqq == nneewwqquueeuuee(());;
//** AAllllooccaattee aa qquueeuuee ttoo hhoolldd tthhee ddeellttaa
**//
//**
lliisstt ooff sslleeeeppiinngg pprroocceesssseess
**//
pprreeeemmpptt == QQUUAANNTTUUMM;;
//** SSeett tthhee pprreeeemmppttiioonn ttiimmee
**//
ccllkkttiimmee == 00;;
//** SSttaarrtt ccoouunnttiinngg sseeccoonnddss
**//
//** TThhee ffoolllloowwiinngg vvaalluueess aarree ccaallccuullaatteedd ffoorr aa
**//
//**
ttiimmeerr tthhaatt ggeenneerraatteess 11mmss ttiicckk rraattee
**//
ccssrrppttrr-->>ttppiirr == 11000000000000;;
ccssrrppttrr-->>ttnniirr == 00;;
ccssrrppttrr-->>ttllddrr == 00xxFFFFFFFFFFFFFFFF -- 2266000000;;
//** SSeett tthhee ttiimmeerr ttoo aauuttoo rreellooaadd **//
ccssrrppttrr-->>ttccllrr == AAMM333355XX__TTIIMMEERR11MMSS__TTCCLLRR__AARR;;
//** SSttaarrtt tthhee ttiimmeerr **//
ccssrrppttrr-->>ttccllrr ||== AAMM333355XX__TTIIMMEERR11MMSS__TTCCLLRR__SSTT;;
//** EEnnaabbllee oovveerrffllooww iinntteerrrruupptt wwhhiicchh wwiillll ggeenneerraattee **//
//**
aann iinntteerrrruupptt eevveerryy 11 mmss
**//
ccssrrppttrr-->>ttiieerr == AAMM333355XX__TTIIMMEERR11MMSS__TTIIEERR__OOVVFF__IITT__EENNAA;;
//** KKiicckkssttaarrtt tthhee ttiimmeerr **//
ccssrrppttrr-->>ttttggrr == 11;;
rreettuurrnn;;
}}
13.14 Perspective
Clock and timer management are both technically and intellectually challenging. 
On the one hand, because clock or timer interrupts occur frequently and have high 
priority, the total time a processor spends executing clock interrupts is large and other 
interrupts are prevented. Thus, the code for an interrupt handler must be written care-
fully to minimize the time taken to handle a given interrupt. On the other hand, an 
operating system that allows processes to request timed events can schedule many 
events to occur at exactly the same time, which means that the time taken for a given

Sec. 13.14        Perspective
255
interrupt can be arbitrarily long. The conflict can become especially important in real-
time embedded systems where the processor is relatively slow and other devices need 
prompt service.
Most systems allow arbitrary events to be scheduled and defer processing when 
multiple events collide — a cell phone may not update the display exactly when an ap-
plication starts, or a text message may take longer to deliver when multiple applications 
are running. The intellectual questions are: how can an operating system best provide 
the illusion of precise timing within hardware constraints and inform users when re-
quests cannot be serviced? Should events be assigned priorities? If so, how should 
event priorities interact with scheduling priorities? There are no easy answers.
13.15 Summary
A real-time clock interrupts the processor at regular intervals. An operating system 
uses the clock to handle preemption and process delay. A preemption event, scheduled 
every time the system switches context, forces a call to the scheduler after a process has 
used the processor for QUANTUM clock ticks. Preemption guarantees that no process 
uses the processor forever, and enforces the scheduling policy by ensuring round-robin 
service among equal-priority processes.
A delta list provides an efficient way to manage sleeping processes. When a proc-
ess requests a timed delay (i.e., sleeps), the process places itself on the delta list of 
sleeping processes. Later, when its delay expires, the clock interrupt handler awakens 
the sleeping process by moving the process back to the ready list and rescheduling.
EXERCISES
13.1 
Modify the code to generate clock interrupts ten times faster, and arrange for the clock
interrupt handler to ignore nine interrupts before processing one. How much extra over-
head do the additional interrupts generate?
13.2 
Trace the series of function calls that occur starting with a clock interrupt that awakens
two sleeping processes, one of which has higher priority than the currently executing 
process.
13.3  
Explain what can fail if QUANTUM is set to 1. Hint: consider switching back to a proc-
ess that was suspended by resched while processing an interrupt.
13.4     Does sleepms(3) guarantee a minimum delay of 3 milliseconds, an exact delay of 3 mil-
liseconds, or a maximum delay of 3 milliseconds?
13.5 
Explain what might happen if wakeup calls wait.
13.6 
An operating system that attempts to record the exact amount of processor time a proc-
ess consumes faces the following problem: when an interrupt occurs, it is most con-
venient to let the current process execute the interrupt routine even though the interrupt 
is unlikely to be related to the current process. Investigate how operating systems charge 
the cost of executing interrupt routines like wakeup to the processes that are affected.

256 
Real-time Clock Management 
Chap. 13
13.7  
To find out how much overhead is involved in using a high-level interrupt handler,
rewrite the code to have clkint perform all clock interrupt handling. Devise a way to 
measure the extra overhead.
13.8      Consider process scheduling and code in recvtime carefully. Show that it is possible for
recvtime to return a message, even if the message arrives long after the timer expires and 
the process is awakened.
13.9  
Design an experiment to see if preemption ever causes the system to reschedule. Be
careful: the presence of a separate process testing a variable or performing I/O can inter-
fere with the experiment by generating calls to resched.
13.10 
Suppose a system contains three processes: a low-priority process, L, that is sleeping,
and two high-priority processes, H1 and H2, that are eligible to execute. Further suppose
that immediately after the scheduler switches to process H1, a clock interrupt occurs, 
process L becomes ready, and the interrupt handler calls resched. Although L will not 
run, resched will switch from H1  to H2  without giving H1  its quantum. Propose a modifi-
cation to resched that ensures a process will not lose control of the processor unless a 
higher-priority process becomes ready or its time slice expires.

Chapter Contents
14.1 
Introduction, 259
14.2 
Conceptual Organization Of I/O And Device Drivers, 260
14.3 
Interface And Driver Abstractions, 261
14.4 
An Example I/O Interface, 262
14.5 
The Open-Read-Write-Close Paradigm, 263
14.6 
Bindings For I/O Operations And Device Names, 264
14.7 
Device Names In Xinu, 265
14.8 
The Concept Of A Device Switch Table, 265
14.9 
Multiple Copies Of A Device And Shared Drivers, 266
14.10 The Implementation Of High–level I/O Operations, 269 
14.11 Other High–level I/O Functions, 271
14.12 Open, Close, And Reference Counting, 275 
14.13 Null And Error Entries In Devtab, 277
14.14 Initialization Of The I/O System, 278 
14.15 Perspective, 283
14.16 Summary, 283


14
Device–independent Input 
And Output
We have been left so much to our own devices — after
a while, one welcomes the uncertainty of being left to 
other people’s.
— Tom Stoppard
14.1 Introduction
Earlier chapters explain concurrent process support and memory management. 
Chapter 12 discusses the key concept of interrupts. The chapter describes interrupt 
processing, gives an architecture for interrupt code, and explains the relationship 
between interrupt handling and concurrent processes. Chapter 13 expands the discus-
sion of interrupts by showing how real-time clock interrupts can be used to implement 
preemption and process delay.
This chapter takes a broader look at how an operating system implements I/O. 
The chapter explains the conceptual basis for building I/O abstractions, and presents an 
architecture for a general-purpose I/O facility. The chapter shows how processes can 
transfer data to or from a device without understanding the underlying hardware. It de-
fines a general model, and explains how the model incorporates device-independent I/O 
functions. Finally, the chapter examines an efficient implementation of an I/O subsys-
tem.
259

260 
Device–independent Input And Output 
Chap. 14
14.2 Conceptual Organization Of I/O And Device Drivers
Operating systems control and manage input and output (I/O) devices for three 
reasons. First, because most device hardware uses a low-level interface, the software 
interface is complex. Second, because a device is a shared resource, an operating sys-
tem provides access according to policies that make sharing fair and safe. Third, an 
operating system defines a high-level interface that hides details and allows a program-
mer to use a consistent and uniform set of operations when interacting with devices.
The I/O subsystem can be divided into three conceptual pieces: an abstract inter-
face consisting of high-level I/O functions that processes use to perform I/O, a set of 
physical devices, and device driver software that connects the two. Figure 14.1 illus-
trates the organization.
I/O operations available to processes
User processes
device 1
device 
driver 
upper-half 
(device 1)
device 
driver 
lower-half 
(device 1)
device 2
device 
driver 
upper-half 
(device 2)
device 
driver 
lower-half 
(device 2)
device 3
device 
driver 
upper-half 
(device 3)
device 
driver 
lower-half 
(device 3)
device n
device 
driver 
upper-half 
(device n)
device 
driver
lower-half 
(device n)
. . .
device 
drivers
Figure 14.1 The conceptual organization of the I/O subsystem with device
driver software between processes and the underlying device 
hardware.
As the figure indicates, device driver software bridges the gap between high-level, 
concurrent processes and low-level hardware. We will see that each driver is divided 
into two conceptual pieces: an upper half and a lower half. Functions in the upper half 
are invoked when a process requests I/O. Upper-half functions implement operations 
such as read and write by transferring data to or from a process. The lower half con-
tains functions that are invoked by interrupts. When a device interrupts, the interrupt 
dispatcher invokes a lower-half handler function. The handler services the interrupt, in-
teracts with the device to transfer data, and may start an additional I/O operation.

Sec. 14.3        Interface And Driver Abstractions 
261
14.3 Interface And Driver Abstractions
The ultimate goal of an operating system designer lies in creating convenient pro-
gramming abstractions and finding efficient implementations. With respect to I/O,
there are two aspects:
d Interface abstraction
d Driver abstractions
Interface abstraction. The question arises: what I/O interface should an operating 
system supply to processes? There are several possibilities, and the choice represents a 
tradeoff among goals of flexibility, simplicity, efficiency, and generality. To understand 
the scope of the problem, consider Figure 14.2, which lists a set of example devices and 
the types of operations appropriate for each.

Device 
I/O paradigm

hard drive 
move to a position and transfer a block of data

keyboard 
accept individual characters as entered

printer 
transfer an entire document to be printed

audio output 
transfer a continuous stream of encoded audio

wireless network 
send or receive a single network packet


































Figure 14.2  Example devices and the paradigm that each device uses.
Early operating systems provided a separate set of I/O operations for each indivi-
dual hardware device. Unfortunately, building device-specific information into software 
means the software must be changed when an I/O device is replaced by an equivalent 
device from another vendor. A slightly more general approach defines a set of opera-
tions for each type of device, and requires the operating system to perform the appropri-
ate low-level operations on a given device. For example, an operating system can offer 
abstract functions send_network_packet and receive_network_packet that can be used to 
transfer network packets over any type of network. A third approach originated in Mul-
tics and was popularized by Unix: choose a small set of abstract I/O operations that are 
sufficient for all I/O.
Driver abstractions. We think of the second category of abstraction as providing 
semantics. One of the most important semantic design questions focuses on synchrony: 
does a process block while waiting for an I/O operation to complete? A synchronous 
interface, similar to the one described earlier, provides blocking operations. For exam-
ple, to request data from a keyboard in a synchronous system, a process invokes an

262 
Device–independent Input And Output 
Chap. 14
upper-half routine that blocks the process until a user presses a key. Once a user makes
a keystroke, the device interrupts and the dispatcher invokes a lower-half routine that
acts as a handler. The handler unblocks a waiting process and reschedules to allow the 
process to run. In contrast, an asynchronous I/O interface allows a process to continue 
executing after the process initiates an I/O operation. When the I/O completes, the 
driver must inform the requesting process (e.g., by invoking the event handler function 
associated with the process). We can summarize:
When using a synchronous I/O interface, a process is blocked until
the operation completes. When using an asynchronous I/O interface,
a process continues to execute and is notified when the operation 
completes.
Each approach has advantages. An asynchronous interface is useful in situations 
where a programmer needs to control the overlap of I/O and computation. A synchro-
nous approach has the advantage of being easier to program.
Another design issue arises from the format of data and the size of transfers. Two 
questions arise. First, will data be transferred in blocks or bytes? Second, how much
data can be transferred in a single operation? Observe that some devices transfer indivi-
dual data bytes, some transfer a variable-size chunk of data (such as a network packet or 
a line of text), and others, such as disks, transfer fixed-size blocks of data. Because a 
general-purpose operating system must handle a variety of I/O devices, an I/O interface 
may require both single-byte transfers as well as multi-byte transfers.
A final design question arises from the parameters that a driver supplies and the 
way a driver interprets individual operations. For example, does a process specify a lo-
cation on disk and then repeatedly request the next disk block, or does the process 
specify a block number in each request? The example device driver presented in the 
next chapter illustrates the use of parameters.
The key idea is:
In a modern operating system, the I/O interface and device drivers
are designed to hide device details and present a programmer with 
convenient, high-level abstractions.
14.4 An Example I/O Interface
Experience has shown that a small set of I/O functions is both sufficient and con-
venient. Thus, our example system contains an I/O subsystem with nine abstract I/O 
operations that are used for all input and output. The operations have been derived 
from the I/O facilities in the Unix operating system. Figure 14.3 lists the operations 
and the purpose of each.

Sec. 14.4        An Example I /O Interface 
263

Operation 
Purpose

close 
Terminate use of a device

control 
Perform operations other than data transfer

getc 
Input a single byte of data

init 
Initialize the device at system startup

open 
Prepare the device for use

putc 
Output a single byte of data

read 
Input multiple bytes of data

seek 
Move to specific data (usually a disk)

write 
Output multiple bytes of data


























































Figure 14.3  The set of abstract I/O interface operations used in Xinu.
14.5 The Open-Read-Write-Close Paradigm
Like the programming interface in many operating systems, the example I/O inter-
face follows an open-read-write-close paradigm. That is, before it can perform I/O, a 
process must open a specific device. Once it has been opened, a device is ready for the 
process to call read to obtain input or write to send output. Finally, once it has finished 
using a device, the process calls close to terminate use.
To summarize:
The open-read-write-close paradigm requires a process to open a de-
vice before use and close a device after use.
Open and close allow the operating system to manage devices that require ex-
clusive use, prepare a device for data transfer, and stop a device after transfer has end-
ed. Closing a device may be useful, for example, if a device needs to be powered down
or placed in a standby state when not in use.  Read and write handle the transfer of mul-
tiple data bytes to or from a buffer in memory. Getc and putc form a counterpart for 
the transfer of a single byte (usually a character).  Control allows a program to control a 
device or a device driver (e.g., to check supplies in a printer or select the channel on a 
wireless radio). Seek is a special case of control that applies to randomly accessible 
storage devices, such as disks. Finally, init initializes the device and driver at system 
startup.

264 
Device–independent Input And Output 
Chap. 14
Consider how the operations apply to a console window.  Getc reads the next char-
acter from the keyboard, and putc displays one character in the console window. Write
can display multiple characters with one call, and read can read a specified number of 
characters (or all that have been entered, depending on its arguments). Finally, control 
allows the program to change parameters in the driver to control such things as whether 
the system stops echoing characters as a password is entered.
14.6 Bindings For I/O Operations And Device Names
How can an abstract operation such as read act on an underlying hardware device? 
The answer lies in a binding. When a process invokes a high-level operation, the 
operating system maps the call to a device driver function. For example, if a process 
calls read on a console device, the operating system passes the call to a function in the 
console device driver that implements read. In doing so, the operating system hides 
both the hardware and device driver details from application processes and presents an 
abstract version of devices. By using a single abstract device for a keyboard and a win-
dow on the display, an operating system can hide the fact that the underlying hardware 
consists of two separate devices. Furthermore, an operating system can hide device de-
tails by presenting the same high-level abstraction for the hardware from multiple ven-
dors. The point is:
An operating system creates a virtual I/O environment — a process
can only perceive peripheral devices through the abstractions that the 
interface and device drivers provide.
In addition to mapping abstract I/O operations onto driver routines, an operating 
system must map device names onto devices. A variety of mappings have been used. 
Early systems required a programmer to embed device names in source code. Later 
systems arranged for programs to use small integers to identify devices, and allowed a 
command interpreter to link each integer with a specific device when the application 
was launched. Many modern systems embed devices in a file naming hierarchy, allow-
ing an application to use a symbolic name for each device.
Early and late binding each have advantages. An operating system that waits until 
runtime to bind the name of an abstract device to a real device and a set of abstract 
operations to device driver functions is flexible. However, such late binding systems 
incur more computational overhead, making them impractical in the smallest embedded 
systems. At the other extreme, early binding requires device information to be specified 
when an application is written. Thus, the essence of I/O design consists of synthesizing 
a binding mechanism that allows maximum flexibility within the required performance 
bounds.
Our example system uses an approach that is typical of small embedded systems: 
information about devices is specified before the operating system is compiled. For 
each device, the operating system knows exactly which driver functions correspond to

Sec. 14.6        Bindings For I /O Operations And Device Names 
265
each of the abstract I/O operations. In addition, the operating system knows the under-
lying hardware device to which each abstract device corresponds. Thus, the operating 
system must be recompiled whenever a new device is added or when an existing device 
is removed. Because application code does not contain information about specific de-
vice hardware, application code can be ported from one system to another easily. For 
example, an application that only performs I/O operations on a CONSOLE serial port 
will work on any Xinu system that offers a CONSOLE device and the appropriate 
driver, independent of the physical device hardware and interrupt structure.
14.7 Device Names In Xinu
In Xinu, the system designer must specify a set of abstract devices when the sys-
tem is configured. The configuration program assigns each device name a unique in-
teger value known as a device descriptor. For example, if a designer specifies a device 
name CONSOLE, the configuration program might assign descriptor zero. The config-
uration program produces a header file that contains #define statements for each name. 
Thus, once the header file has been included, a programmer can reference CONSOLE in 
the code. For example, if CONSOLE has been assigned descriptor zero, the call:
read(CONSOLE, buf, 100);
is equivalent to:
read(0, buf, 100);
To summarize:
Xinu uses a static binding for device names. Each device name is
bound to an integer descriptor at configuration time before the 
operating system is compiled.
14.8 The Concept Of A Device Switch Table
Each time a process invokes a high-level I/O operation such as read or write, the 
operating system must forward the call to the appropriate driver function. To make the 
implementation efficient, Xinu uses an array known as a device switch table. The in-
teger descriptor assigned to a device is an index into the device switch table. To under-
stand the arrangement, imagine a two-dimensional array. Conceptually, each row of the 
array corresponds to a device, and each column corresponds to an abstract operation. 
An entry in the array specifies the driver function to use to perform the operation.
For example, suppose a system contains three devices defined as follows:
d CONSOLE, a serial device used to send and receive characters
d ETHER, an Ethernet interface device
d DISK, a hard drive

266 
Device–independent Input And Output 
Chap. 14
Figure 14.4 illustrates part of a device switch table that has a row for each of the 
three devices and a column for each I/O operation. Items in the table represent the
names of driver functions that perform the operation given by the column on the device 
given by the row.
open 
close 
read 
write 
getc
. . .
...
CONSOLE
ETHER
DISK
conopen 
conclose 
conread 
conwrite 
congetc
ethopen 
ethclose 
ethread 
ethwrite 
ethgetc
dskopen 
dskclose 
dskread 
dskwrite 
dskgetc
Figure 14.4 Conceptual organization of the device switch table with one row
per device and one column per abstract I/O operation.
As an example, suppose a process invokes the write operation on the CONSOLE 
device. The operating system goes to the row of the table that corresponds to the CON-
SOLE device, finds the column that corresponds to the write operation, and calls the 
function named in the entry, conwrite.
In essence, each row of the device switch table defines how the I/O operations ap-
ply to a single device, which means I/O semantics can change dramatically among de-
vices. For example, when it is applied to a DISK device, a read might transfer a block 
of 512 bytes of data. However, when it is applied to a CONSOLE device, read might 
transfer a line of characters that the user has entered.
The most significant aspect of the device switch table arises from the ability to de-
fine a uniform abstraction across multiple physical devices. For example, suppose a 
computer contains a disk that uses 1 Kbyte sectors and a disk that uses 4 Kbyte sectors. 
Drivers for the two disks can present an identical interface to applications, while hiding 
the differences in the underlying hardware. That is, a driver can always transfer 4 
Kbytes to a user, and convert each transfer into four 1 Kbyte disk transfers.
14.9 Multiple Copies Of A Device And Shared Drivers
Suppose a given computer has two devices that use identical hardware. Does the 
operating system need two separate copies of the device driver? No. The system con-
tains one copy of each driver routine and uses a parameter to distinguish between the 
two devices. Parameters are kept in columns of the device switch table in addition to 
the functions that Figure 14.4 illustrates. For example, if a system contains two Ether-
net interfaces, each will have its own row in the device switch table. Most entries in
the two rows will be identical. However, one column will specify a unique Control and 
Status Register (CSR) address for each device. When it invokes a driver function, the

Sec. 14.9        Multiple Copies Of A Device And Shared Drivers 
267
system passes an argument that contains a pointer to the row in the device switch table
for the device. Thus, a driver function can apply the operation to the correct device.
The point is:
Instead of creating a device driver for each physical device, an 
operating system maintains a single copy of the driver for each type of 
device and supplies an argument that permits the driver to distinguish 
among multiple copies of the physical hardware.
A look at the definition of the device switch table, devtab, will clarify the details. 
Structure dentry defines the format of entries in the table; the declaration can be found
in file conf.h†.
//** ccoonnff..hh ((GGEENNEERRAATTEEDD FFIILLEE;; DDOO NNOOTT EEDDIITT)) **//
//** DDeevviiccee sswwiittcchh ttaabbllee ddeeccllaarraattiioonnss **//
//** DDeevviiccee ttaabbllee eennttrryy **//
ssttrruucctt
ddeennttrryy
{{
iinntt3322
ddvvnnuumm;;
iinntt3322
ddvvmmiinnoorr;;
cchhaarr
**ddvvnnaammee;;
ddeevvccaallll ((**ddvviinniitt)) ((ssttrruucctt ddeennttrryy **));;
ddeevvccaallll ((**ddvvooppeenn)) ((ssttrruucctt ddeennttrryy **,, cchhaarr **,, cchhaarr **));;
ddeevvccaallll ((**ddvvcclloossee))((ssttrruucctt ddeennttrryy **));;
ddeevvccaallll ((**ddvvrreeaadd)) ((ssttrruucctt ddeennttrryy **,, vvooiidd **,, uuiinntt3322));;
ddeevvccaallll ((**ddvvwwrriittee))((ssttrruucctt ddeennttrryy **,, vvooiidd **,, uuiinntt3322));;
ddeevvccaallll ((**ddvvsseeeekk)) ((ssttrruucctt ddeennttrryy **,, iinntt3322));;
ddeevvccaallll ((**ddvvggeettcc)) ((ssttrruucctt ddeennttrryy **));;
ddeevvccaallll ((**ddvvppuuttcc)) ((ssttrruucctt ddeennttrryy **,, cchhaarr));;
ddeevvccaallll ((**ddvvccnnttll)) ((ssttrruucctt ddeennttrryy **,, iinntt3322,, iinntt3322,, iinntt3322));;
vvooiidd
**ddvvccssrr;;
vvooiidd
((**ddvviinnttrr))((vvooiidd));;
bbyyttee
ddvviirrqq;;
}};;
eexxtteerrnn
ssttrruucctt
ddeennttrryy
ddeevvttaabb[[]];; //** oonnee eennttrryy ppeerr ddeevviiccee **//
//** DDeevviiccee nnaammee ddeeffiinniittiioonnss **//
##ddeeffiinnee CCOONNSSOOLLEE
00
//** ttyyppee ttttyy
**//
##ddeeffiinnee NNUULLLLDDEEVV
11
//** ttyyppee nnuullll
**//
##ddeeffiinnee EETTHHEERR00
22
//** ttyyppee eetthh
**//

†Chapter 25 explains Xinu configuration and gives more detail about conf.h.

268 
Device–independent Input And Output 
Chap. 14
##ddeeffiinnee NNAAMMEESSPPAACCEE
33
//** ttyyppee nnaamm
**//
##ddeeffiinnee RRDDIISSKK
44
//** ttyyppee rrddss
**//
##ddeeffiinnee RRAAMM00
55
//** ttyyppee rraamm
**//
##ddeeffiinnee RRFFIILLEESSYYSS
66
//** ttyyppee rrffss
**//
##ddeeffiinnee RRFFIILLEE00
77
//** ttyyppee rrffll
**//
##ddeeffiinnee RRFFIILLEE11
88
//** ttyyppee rrffll
**//
##ddeeffiinnee RRFFIILLEE22
99
//** ttyyppee rrffll
**//
##ddeeffiinnee RRFFIILLEE33
1100
//** ttyyppee rrffll
**//
##ddeeffiinnee RRFFIILLEE44
1111
//** ttyyppee rrffll
**//
##ddeeffiinnee RRFFIILLEE55
1122
//** ttyyppee rrffll
**//
##ddeeffiinnee RRFFIILLEE66
1133
//** ttyyppee rrffll
**//
##ddeeffiinnee RRFFIILLEE77
1144
//** ttyyppee rrffll
**//
##ddeeffiinnee RRFFIILLEE88
1155
//** ttyyppee rrffll
**//
##ddeeffiinnee RRFFIILLEE99
1166
//** ttyyppee rrffll
**//
##ddeeffiinnee LLFFIILLEESSYYSS
1177
//** ttyyppee llffss
**//
##ddeeffiinnee LLFFIILLEE00
1188
//** ttyyppee llffll
**//
##ddeeffiinnee LLFFIILLEE11
1199
//** ttyyppee llffll
**//
##ddeeffiinnee LLFFIILLEE22
2200
//** ttyyppee llffll
**//
##ddeeffiinnee LLFFIILLEE33
2211
//** ttyyppee llffll
**//
##ddeeffiinnee LLFFIILLEE44
2222
//** ttyyppee llffll
**//
##ddeeffiinnee LLFFIILLEE55
2233
//** ttyyppee llffll
**//
//** CCoonnttrrooll bblloocckk ssiizzeess **//
##ddeeffiinnee NNnnuullll
11
##ddeeffiinnee NNttttyy
11
##ddeeffiinnee NNeetthh
11
##ddeeffiinnee NNrrddss
11
##ddeeffiinnee NNrraamm
11
##ddeeffiinnee NNrrffss
11
##ddeeffiinnee NNrrffll
1100
##ddeeffiinnee NNllffss
11
##ddeeffiinnee NNllffll
66
##ddeeffiinnee NNnnaamm
11
##ddeeffiinnee DDEEVVMMAAXXNNAAMMEE 2244
##ddeeffiinnee NNDDEEVVSS 2244
//** CCoonnffiigguurraattiioonn aanndd SSiizzee CCoonnssttaannttss **//
##ddeeffiinnee NNPPRROOCC
110000
//** nnuummbbeerr ooff uusseerr pprroocceesssseess
**//
##ddeeffiinnee NNSSEEMM
110000
//** nnuummbbeerr ooff sseemmaapphhoorreess
**//
##ddeeffiinnee IIRRQQBBAASSEE
3322
//** bbaassee iivveecc ffoorr IIRRQQ00
**//
##ddeeffiinnee IIRRQQ__TTIIMMEERR
IIRRQQ__HHWW55
//** ttiimmeerr IIRRQQ iiss wwiirreedd ttoo hhaarrddwwaarree 55
**//
##ddeeffiinnee IIRRQQ__AATTHH__MMIISSCC IIRRQQ__HHWW44
//** MMiisscc.. IIRRQQ iiss wwiirreedd ttoo hhaarrddwwaarree 44
**//
##ddeeffiinnee CCLLKKFFRREEQQ
220000000000000000
//** 220000 MMHHzz cclloocckk
**//

Sec. 14.9        Multiple Copies Of A Device And Shared Drivers 
269
##ddeeffiinnee LLFF__DDIISSKK__DDEEVV
RRAAMM00
Each entry in devtab corresponds to a single device. The entry specifies the ad-
dress of functions that constitute the driver for the device, the device CSR address, and 
other information used by the driver. Fields dvinit, dvopen, dvclose, dvread, dvwrite, 
dvseek, dvgetc, dvputc, and dvcntl hold the addresses of driver routines that correspond 
to high-level operations. Field dvminor contains an integer index into the control block 
array for the device. A minor device number accommodates multiple identical 
hardware devices by allowing a driver to maintain a separate control block entry for 
each physical device. Field dvcsr contains the hardware CSR address for the device. 
The control block for a device holds additional information for the particular instance of 
the device and the driver; the contents depend on the device, but may include such 
things as input or output buffers, device status information (e.g., whether a wireless net-
working device is currently in contact with another wireless device), and accounting in-
formation (e.g., the total amount of data sent or received since the system booted).
14.10 The Implementation Of High–level I/O Operations
Because it isolates high-level I/O operations from underlying details, the device 
switch table allows high-level functions to be created before any device drivers have 
been written. One of the chief benefits of such a strategy arises because a programmer
can build pieces of the I/O system without requiring specific hardware devices to be 
present.
The example system contains a function for each high-level I/O operation. Thus,
the system contains functions open, close, read, write, getc, putc, and so on. However,
a function such as read does not perform I/O. Instead, each high-level I/O function 
operates indirectly: the function uses the device switch table to find and invoke the ap-
propriate low-level device driver routine to perform the requested function. The point 
is:
Instead of performing I/O, high-level functions such as read and write
use a level of indirection to invoke a low-level driver function for the 
specified device.
An examination of the code will clarify the concept. Consider the read function
found in file read.c:

270 
Device–independent Input And Output 
Chap. 14
//** rreeaadd..cc -- rreeaadd **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
rreeaadd
--
RReeaadd oonnee oorr mmoorree bbyytteess ffrroomm aa ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll rreeaadd((
ddiidd3322
ddeessccrrpp,,
//** DDeessccrriippttoorr ffoorr ddeevviiccee
**//
cchhaarr
**bbuuffffeerr,,
//** AAddddrreessss ooff bbuuffffeerr
**//
uuiinntt3322
ccoouunntt
//** LLeennggtthh ooff bbuuffffeerr
**//
))
{{
iinnttmmaasskk
mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt ddeennttrryy
**ddeevvppttrr;;
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
iinntt3322
rreettvvaall;;
//** VVaalluuee ttoo rreettuurrnn ttoo ccaalllleerr
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddddeevv((ddeessccrrpp)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
ddeevvppttrr == ((ssttrruucctt ddeennttrryy **)) &&ddeevvttaabb[[ddeessccrrpp]];;
rreettvvaall == ((**ddeevvppttrr-->>ddvvrreeaadd)) ((ddeevvppttrr,, bbuuffffeerr,, ccoouunntt));;
rreessttoorree((mmaasskk));;
rreettuurrnn rreettvvaall;;
}}
The arguments to read consist of a device descriptor, the address of a buffer, and 
an integer that gives the maximum number of bytes to read.  Read uses the device 
descriptor, descrp, as an index into devtab, and assigns pointer devptr the address of the 
device switch table entry. The return statement contains code that performs the task of 
invoking the underlying device driver function and returning the result to the function 
that called read. The code:
(*devptr->dvread) (devptr, buffer, count)
performs the indirect function call. That is, the code invokes the driver function given
by field dvread in the device switch table entry, passing the function three arguments:
the address of the devtab entry, devptr, the buffer address, buffer, and a count of charac-
ters to read, count.

Sec. 14.11        Other High–level I  /O Functions 
271
14.11 Other High–level I/O Functions
The remaining high-level transfer and control functions operate exactly as read: 
they use the device switch table to select the appropriate low-level driver function, in-
voke the function, and return the result to the caller. Code for each function is shown 
below.
//** ccoonnttrrooll..cc -- ccoonnttrrooll **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ccoonnttrrooll
--
CCoonnttrrooll aa ddeevviiccee oorr aa ddrriivveerr ((ee..gg..,, sseett tthhee ddrriivveerr mmooddee))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll ccoonnttrrooll((
ddiidd3322
ddeessccrrpp,,
//** DDeessccrriippttoorr ffoorr ddeevviiccee
**//
iinntt3322
ffuunncc,,
//** SSppeecciiffiicc ccoonnttrrooll ffuunnccttiioonn
**//
iinntt3322
aarrgg11,,
//** SSppeecciiffiicc aarrgguummeenntt ffoorr ffuunncc
**//
iinntt3322
aarrgg22
//** SSppeecciiffiicc aarrgguummeenntt ffoorr ffuunncc
**//
))
{{
iinnttmmaasskk
mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt ddeennttrryy
**ddeevvppttrr;;
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
iinntt3322
rreettvvaall;;
//** VVaalluuee ttoo rreettuurrnn ttoo ccaalllleerr
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddddeevv((ddeessccrrpp)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
ddeevvppttrr == ((ssttrruucctt ddeennttrryy **)) &&ddeevvttaabb[[ddeessccrrpp]];;
rreettvvaall == ((**ddeevvppttrr-->>ddvvccnnttll)) ((ddeevvppttrr,, ffuunncc,, aarrgg11,, aarrgg22));;
rreessttoorree((mmaasskk));;
rreettuurrnn rreettvvaall;;
}}

272 
Device–independent Input And Output 
Chap. 14
//** ggeettcc..cc -- ggeettcc **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ggeettcc
--
OObbttaaiinn oonnee bbyyttee ffrroomm aa ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll ggeettcc((
ddiidd3322
ddeessccrrpp
//** DDeessccrriippttoorr ffoorr ddeevviiccee
**//
))
{{
iinnttmmaasskk
mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt ddeennttrryy
**ddeevvppttrr;;
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
iinntt3322
rreettvvaall;;
//** VVaalluuee ttoo rreettuurrnn ttoo ccaalllleerr
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddddeevv((ddeessccrrpp)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
ddeevvppttrr == ((ssttrruucctt ddeennttrryy **)) &&ddeevvttaabb[[ddeessccrrpp]];;
rreettvvaall == ((**ddeevvppttrr-->>ddvvggeettcc)) ((ddeevvppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn rreettvvaall;;
}} 
//** ppuuttcc..cc -- ppuuttcc **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ppuuttcc
--
SSeenndd oonnee cchhaarraacctteerr ooff ddaattaa ((bbyyttee)) ttoo aa ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll ppuuttcc((
ddiidd3322
ddeessccrrpp,,
//** DDeessccrriippttoorr ffoorr ddeevviiccee
**//
cchhaarr
cchh
//** CChhaarraacctteerr ttoo sseenndd
**//
))
{{
iinnttmmaasskk
mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt ddeennttrryy
**ddeevvppttrr;;
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
iinntt3322
rreettvvaall;;
//** VVaalluuee ttoo rreettuurrnn ttoo ccaalllleerr
**//

Sec. 14.11        Other High–level I  /O Functions 
273
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddddeevv((ddeessccrrpp)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
ddeevvppttrr == ((ssttrruucctt ddeennttrryy **)) &&ddeevvttaabb[[ddeessccrrpp]];;
rreettvvaall == ((**ddeevvppttrr-->>ddvvppuuttcc)) ((ddeevvppttrr,, cchh));;
rreessttoorree((mmaasskk));;
rreettuurrnn rreettvvaall;;
}} 
//** sseeeekk..cc -- sseeeekk **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
sseeeekk
--
PPoossiittiioonn aa rraannddoomm aacccceessss ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll sseeeekk((
ddiidd3322
ddeessccrrpp,,
//** DDeessccrriippttoorr ffoorr ddeevviiccee
**//
uuiinntt3322
ppooss
//** PPoossiittiioonn
**//
))
{{
iinnttmmaasskk
mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt ddeennttrryy
**ddeevvppttrr;;
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
iinntt3322
rreettvvaall;;
//** VVaalluuee ttoo rreettuurrnn ttoo ccaalllleerr
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddddeevv((ddeessccrrpp)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
ddeevvppttrr == ((ssttrruucctt ddeennttrryy **)) &&ddeevvttaabb[[ddeessccrrpp]];;
rreettvvaall == ((**ddeevvppttrr-->>ddvvsseeeekk)) ((ddeevvppttrr,, ppooss));;
rreessttoorree((mmaasskk));;
rreettuurrnn rreettvvaall;;
}}

274 
Device–independent Input And Output 
Chap. 14
//** wwrriittee..cc -- wwrriittee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
wwrriittee
--
WWrriittee oonnee oorr mmoorree bbyytteess ttoo aa ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll wwrriittee((
ddiidd3322
ddeessccrrpp,,
//** DDeessccrriippttoorr ffoorr ddeevviiccee
**//
cchhaarr
**bbuuffffeerr,,
//** AAddddrreessss ooff bbuuffffeerr
**//
uuiinntt3322
ccoouunntt
//** LLeennggtthh ooff bbuuffffeerr
**//
))
{{
iinnttmmaasskk
mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt ddeennttrryy
**ddeevvppttrr;;
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
iinntt3322
rreettvvaall;;
//** VVaalluuee ttoo rreettuurrnn ttoo ccaalllleerr
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddddeevv((ddeessccrrpp)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
ddeevvppttrr == ((ssttrruucctt ddeennttrryy **)) &&ddeevvttaabb[[ddeessccrrpp]];;
rreettvvaall == ((**ddeevvppttrr-->>ddvvwwrriittee)) ((ddeevvppttrr,, bbuuffffeerr,, ccoouunntt));;
rreessttoorree((mmaasskk));;
rreettuurrnn rreettvvaall;;
}}
The functions listed above are designed to allow user processes to access I/O de-
vices. In addition, the system provides one high-level I/O function that is intended only 
for the operating system to use: init. We will see that when it boots, the operating sys-
tem calls init for each device. Like the other I/O functions, init uses the device switch 
table to invoke the appropriate low-level driver function. Thus, the initialization func-
tion in each driver can initialize the hardware device, if necessary, and can also initial-
ize the data structures used by the driver (e.g., buffers and semaphores). We will see 
examples of driver initialization later. For now, it is sufficient to understand that init 
follows the same approach as other I/O functions:

Sec. 14.11        Other High–level I  /O Functions 
275
//** iinniitt..cc -- iinniitt **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
iinniitt
--
IInniittiiaalliizzee aa ddeevviiccee aanndd iittss ddrriivveerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll iinniitt((
ddiidd3322
ddeessccrrpp
//** DDeessccrriippttoorr ffoorr ddeevviiccee
**//
))
{{
iinnttmmaasskk
mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt ddeennttrryy
**ddeevvppttrr;;
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
iinntt3322
rreettvvaall;;
//** VVaalluuee ttoo rreettuurrnn ttoo ccaalllleerr
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddddeevv((ddeessccrrpp)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
ddeevvppttrr == ((ssttrruucctt ddeennttrryy **)) &&ddeevvttaabb[[ddeessccrrpp]];;
rreettvvaall == ((**ddeevvppttrr-->>ddvviinniitt)) ((ddeevvppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn rreettvvaall;;
}}
14.12 Open, Close, And Reference Counting
Functions open and close operate similar to other I/O functions by using the de-
vice switch table to call the appropriate driver function. One motivation for using open 
and close arises from their ability to establish ownership of a device or prepare a device 
for use. For example, if a device requires exclusive access, open can block a subse-
quent user until the device becomes free. As another example, consider a system that 
saves power by keeping a disk device idle when the device is not in use. Although a 
designer could arrange to use the control function to start or stop a disk, open and close 
are more convenient. Thus, a disk can be powered on when a process calls open, and 
powered off when a process calls close.
Although a small embedded system might choose to power down a disk whenever 
a process calls close on the device, larger systems need a more sophisticated mechanism 
because multiple processes can use a device simultaneously. Thus, most drivers employ 
a technique known as reference counting. That is, a driver maintains an integer variable

276 
Device–independent Input And Output 
Chap. 14
that counts the number of processes using the device. During initialization, the refer-
ence count is set to zero. Whenever a process calls open, the driver increments the 
reference count, and whenever a process calls close, the driver decrements the reference 
count. When the reference count reaches zero, the driver powers down the device.
The code for open and close follows the same approach as the code for other
high-level I/O functions:
//** ooppeenn..cc -- ooppeenn **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ooppeenn
--
OOppeenn aa ddeevviiccee ((ssoommee ddeevviicceess iiggnnoorree nnaammee aanndd mmooddee ppaarraammeetteerrss))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll ooppeenn((
ddiidd3322
ddeessccrrpp,,
//** DDeessccrriippttoorr ffoorr ddeevviiccee
**//
cchhaarr
**nnaammee,,
//** NNaammee ttoo uussee,, iiff aannyy
**//
cchhaarr
**mmooddee
//** MMooddee ffoorr ddeevviiccee,, iiff aannyy
**//
))
{{
iinnttmmaasskk
mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt ddeennttrryy
**ddeevvppttrr;;
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
iinntt3322
rreettvvaall;;
//** VVaalluuee ttoo rreettuurrnn ttoo ccaalllleerr
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddddeevv((ddeessccrrpp)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
ddeevvppttrr == ((ssttrruucctt ddeennttrryy **)) &&ddeevvttaabb[[ddeessccrrpp]];;
rreettvvaall == ((**ddeevvppttrr-->>ddvvooppeenn)) ((ddeevvppttrr,, nnaammee,, mmooddee));;
rreessttoorree((mmaasskk));;
rreettuurrnn rreettvvaall;;
}} 
//** cclloossee..cc -- cclloossee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
cclloossee
--
CClloossee aa ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//

Sec. 14.12        Open, Close, And Reference Counting 
277
ssyyssccaallll cclloossee((
ddiidd3322
ddeessccrrpp
//** DDeessccrriippttoorr ffoorr ddeevviiccee
**//
))
{{
iinnttmmaasskk
mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
ddeennttrryy
**ddeevvppttrr;;
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
iinntt3322
rreettvvaall;;
//** VVaalluuee ttoo rreettuurrnn ttoo ccaalllleerr
**//
mmaasskk == ddiissaabbllee(());;
iiff ((iissbbaaddddeevv((ddeessccrrpp)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
ddeevvppttrr == ((ssttrruucctt ddeennttrryy **)) &&ddeevvttaabb[[ddeessccrrpp]];;
rreettvvaall == ((**ddeevvppttrr-->>ddvvcclloossee)) ((ddeevvppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn rreettvvaall;;
}}
14.13 Null And Error Entries In Devtab
An interesting dilemma arises from the way I/O functions operate. On the one
hand, high-level functions, such as read and write, use entries in devtab without check-
ing whether the entries are valid. Thus, a function must be supplied for every I/O 
operation for each device. On the other hand, an operation may not be meaningful on 
all devices. For example, seek is not an operation that can be performed on a serial de-
vice, and getc is not meaningful on a network device that delivers packets. Further-
more, a designer may choose to ignore an operation on a particular device (e.g., a 
designer may choose to leave the CONSOLE device open at all times, which means the 
close operation has no effect).
What value can be used in devtab for operations that are not meaningful? The
answer lies in two special routines that can be used to fill in entries of devtab that have
no driver functions:
d ionull — return OK without performing any action
d ioerr — return SYSERR without performing any action
By convention, entries filled with ioerr should never be called; they signify an ille-
gal operation. Entries for unnecessary, but otherwise innocuous operations (e.g., open
for a terminal device), point to function ionull. The code for each of the two functions
is trivial.

278 
Device–independent Input And Output 
Chap. 14
//** iioonnuullll..cc -- iioonnuullll **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
iioonnuullll
--
DDoo nnootthhiinngg ((uusseedd ffoorr ""ddoonn’’tt ccaarree"" eennttrriieess iinn ddeevvttaabb))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll iioonnuullll((vvooiidd))
{{
rreettuurrnn OOKK;;
}} 
//** iiooeerrrr..cc -- iiooeerrrr **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
iiooeerrrr
--
RReettuurrnn aann eerrrroorr ssttaattuuss ((uusseedd ffoorr ""eerrrroorr"" eennttrriieess iinn ddeevvttaabb))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll iiooeerrrr((vvooiidd))
{{
rreettuurrnn SSYYSSEERRRR;;
}}
14.14 Initialization Of The I/O System
How is a device switch table initialized? How are driver functions installed? In a 
large, complex operating system, device drivers can be managed dynamically. Thus, 
when it finds new device hardware, the operating system can identify the hardware,
search for an appropriate driver, and install the driver without rebooting.
A small embedded system does not have a collection of drivers available on secon-
dary storage, and may not have sufficient computational resources to install drivers at 
runtime. Thus, most embedded systems use a static device configuration in which the 
set of devices and the set of device drivers are specified when the system is compiled. 
Our example follows the static approach by requiring the system designer to specify a 
set of devices and the set of low-level driver functions that constitute each driver. In-
stead of forcing a programmer to enter explicit declarations for the entire device switch 
table, however, a separate application program is used that reads a configuration file and 
generates a C file that contains a declaration of devtab with an initial value for each 
field. The point is:

Sec. 14.14        Initialization Of The I /O System 
279
Small embedded systems use a static device specification in which a 
designer specifies the set of devices plus the device driver functions 
for each; a configuration program can generate code that assigns a 
value to each field of the device switch table.
File conf.c contains an example of the C code generated by the configuration pro-
gram. Chapter 25 explains how conf.c is generated; for now, it is sufficient to examine
one of the entries in devtab and observe how each field is initialized.
//** ccoonnff..cc ((GGEENNEERRAATTEEDD FFIILLEE;; DDOO NNOOTT EEDDIITT)) **//
##iinncclluuddee <<xxiinnuu..hh>>
eexxtteerrnn
ddeevvccaallll iiooeerrrr((vvooiidd));;
eexxtteerrnn
ddeevvccaallll iioonnuullll((vvooiidd));;
//** DDeevviiccee iinnddeeppeennddeenntt II//OO sswwiittcchh **//
ssttrruucctt
ddeennttrryy
ddeevvttaabb[[NNDDEEVVSS]] ==
{{ 
//****
** FFoorrmmaatt ooff eennttrriieess iiss::
** ddeevv--nnuummbbeerr,, mmiinnoorr--nnuummbbeerr,, ddeevv--nnaammee,,
** iinniitt,, ooppeenn,, cclloossee,,
** rreeaadd,, wwrriittee,, sseeeekk,,
** ggeettcc,, ppuuttcc,, ccoonnttrrooll,,
** ddeevv--ccssrr--aaddddrreessss,, iinnttrr--hhaannddlleerr,, iirrqq
**//
//** CCOONNSSOOLLEE iiss ttttyy **//
{{ 00,, 00,, ""CCOONNSSOOLLEE"",,
((vvooiidd **))ttttyyiinniitt,, ((vvooiidd **))iioonnuullll,, ((vvooiidd **))iioonnuullll,,
((vvooiidd **))ttttyyrreeaadd,, ((vvooiidd **))ttttyywwrriittee,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))ttttyyggeettcc,, ((vvooiidd **))ttttyyppuuttcc,, ((vvooiidd **))ttttyyccoonnttrrooll,,
((vvooiidd **))00xx33ff88,, ((vvooiidd **))ttttyyddiissppaattcchh,, 4422 }},,
//** NNUULLLLDDEEVV iiss nnuullll **//
{{ 11,, 00,, ""NNUULLLLDDEEVV"",,
((vvooiidd **))iioonnuullll,, ((vvooiidd **))iioonnuullll,, ((vvooiidd **))iioonnuullll,,
((vvooiidd **))iioonnuullll,, ((vvooiidd **))iioonnuullll,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))iioonnuullll,, ((vvooiidd **))iioonnuullll,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iiooeerrrr,, 00 }},,

280 
Device–independent Input And Output 
Chap. 14
//** EETTHHEERR00 iiss eetthh **//
{{ 22,, 00,, ""EETTHHEERR00"",,
((vvooiidd **))eetthhiinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))eetthhrreeaadd,, ((vvooiidd **))eetthhwwrriittee,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))eetthhccoonnttrrooll,,
((vvooiidd **))00xx00,, ((vvooiidd **))eetthhddiissppaattcchh,, 4433 }},,
//** NNAAMMEESSPPAACCEE iiss nnaamm **//
{{ 33,, 00,, ""NNAAMMEESSPPAACCEE"",,
((vvooiidd **))nnaammiinniitt,, ((vvooiidd **))nnaammooppeenn,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iiooeerrrr,, 00 }},,
//** RRDDIISSKK iiss rrddss **//
{{ 44,, 00,, ""RRDDIISSKK"",,
((vvooiidd **))rrddssiinniitt,, ((vvooiidd **))rrddssooppeenn,, ((vvooiidd **))rrddsscclloossee,,
((vvooiidd **))rrddssrreeaadd,, ((vvooiidd **))rrddsswwrriittee,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))rrddssccoonnttrrooll,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** RRAAMM00 iiss rraamm **//
{{ 55,, 00,, ""RRAAMM00"",,
((vvooiidd **))rraammiinniitt,, ((vvooiidd **))rraammooppeenn,, ((vvooiidd **))rraammcclloossee,,
((vvooiidd **))rraammrreeaadd,, ((vvooiidd **))rraammwwrriittee,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** RRFFIILLEESSYYSS iiss rrffss **//
{{ 66,, 00,, ""RRFFIILLEESSYYSS"",,
((vvooiidd **))rrffssiinniitt,, ((vvooiidd **))rrffssooppeenn,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))rrffssccoonnttrrooll,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** RRFFIILLEE00 iiss rrffll **//
{{ 77,, 00,, ""RRFFIILLEE00"",,
((vvooiidd **))rrfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))rrffllcclloossee,,
((vvooiidd **))rrffllrreeaadd,, ((vvooiidd **))rrffllwwrriittee,, ((vvooiidd **))rrffllsseeeekk,,
((vvooiidd **))rrffllggeettcc,, ((vvooiidd **))rrffllppuuttcc,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** RRFFIILLEE11 iiss rrffll **//
{{ 88,, 11,, ""RRFFIILLEE11"",,
((vvooiidd **))rrfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))rrffllcclloossee,,

Sec. 14.14        Initialization Of The I /O System 
281
((vvooiidd **))rrffllrreeaadd,, ((vvooiidd **))rrffllwwrriittee,, ((vvooiidd **))rrffllsseeeekk,,
((vvooiidd **))rrffllggeettcc,, ((vvooiidd **))rrffllppuuttcc,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** RRFFIILLEE22 iiss rrffll **//
{{ 99,, 22,, ""RRFFIILLEE22"",,
((vvooiidd **))rrfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))rrffllcclloossee,,
((vvooiidd **))rrffllrreeaadd,, ((vvooiidd **))rrffllwwrriittee,, ((vvooiidd **))rrffllsseeeekk,,
((vvooiidd **))rrffllggeettcc,, ((vvooiidd **))rrffllppuuttcc,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** RRFFIILLEE33 iiss rrffll **//
{{ 1100,, 33,, ""RRFFIILLEE33"",,
((vvooiidd **))rrfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))rrffllcclloossee,,
((vvooiidd **))rrffllrreeaadd,, ((vvooiidd **))rrffllwwrriittee,, ((vvooiidd **))rrffllsseeeekk,,
((vvooiidd **))rrffllggeettcc,, ((vvooiidd **))rrffllppuuttcc,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** RRFFIILLEE44 iiss rrffll **//
{{ 1111,, 44,, ""RRFFIILLEE44"",,
((vvooiidd **))rrfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))rrffllcclloossee,,
((vvooiidd **))rrffllrreeaadd,, ((vvooiidd **))rrffllwwrriittee,, ((vvooiidd **))rrffllsseeeekk,,
((vvooiidd **))rrffllggeettcc,, ((vvooiidd **))rrffllppuuttcc,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** RRFFIILLEE55 iiss rrffll **//
{{ 1122,, 55,, ""RRFFIILLEE55"",,
((vvooiidd **))rrfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))rrffllcclloossee,,
((vvooiidd **))rrffllrreeaadd,, ((vvooiidd **))rrffllwwrriittee,, ((vvooiidd **))rrffllsseeeekk,,
((vvooiidd **))rrffllggeettcc,, ((vvooiidd **))rrffllppuuttcc,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** RRFFIILLEE66 iiss rrffll **//
{{ 1133,, 66,, ""RRFFIILLEE66"",,
((vvooiidd **))rrfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))rrffllcclloossee,,
((vvooiidd **))rrffllrreeaadd,, ((vvooiidd **))rrffllwwrriittee,, ((vvooiidd **))rrffllsseeeekk,,
((vvooiidd **))rrffllggeettcc,, ((vvooiidd **))rrffllppuuttcc,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** RRFFIILLEE77 iiss rrffll **//
{{ 1144,, 77,, ""RRFFIILLEE77"",,
((vvooiidd **))rrfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))rrffllcclloossee,,
((vvooiidd **))rrffllrreeaadd,, ((vvooiidd **))rrffllwwrriittee,, ((vvooiidd **))rrffllsseeeekk,,
((vvooiidd **))rrffllggeettcc,, ((vvooiidd **))rrffllppuuttcc,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,

282 
Device–independent Input And Output 
Chap. 14
//** RRFFIILLEE88 iiss rrffll **//
{{ 1155,, 88,, ""RRFFIILLEE88"",,
((vvooiidd **))rrfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))rrffllcclloossee,,
((vvooiidd **))rrffllrreeaadd,, ((vvooiidd **))rrffllwwrriittee,, ((vvooiidd **))rrffllsseeeekk,,
((vvooiidd **))rrffllggeettcc,, ((vvooiidd **))rrffllppuuttcc,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** RRFFIILLEE99 iiss rrffll **//
{{ 1166,, 99,, ""RRFFIILLEE99"",,
((vvooiidd **))rrfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))rrffllcclloossee,,
((vvooiidd **))rrffllrreeaadd,, ((vvooiidd **))rrffllwwrriittee,, ((vvooiidd **))rrffllsseeeekk,,
((vvooiidd **))rrffllggeettcc,, ((vvooiidd **))rrffllppuuttcc,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** LLFFIILLEESSYYSS iiss llffss **//
{{ 1177,, 00,, ""LLFFIILLEESSYYSS"",,
((vvooiidd **))llffssiinniitt,, ((vvooiidd **))llffssooppeenn,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))iiooeerrrr,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** LLFFIILLEE00 iiss llffll **//
{{ 1188,, 00,, ""LLFFIILLEE00"",,
((vvooiidd **))llfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))llffllcclloossee,,
((vvooiidd **))llffllrreeaadd,, ((vvooiidd **))llffllwwrriittee,, ((vvooiidd **))llffllsseeeekk,,
((vvooiidd **))llffllggeettcc,, ((vvooiidd **))llffllppuuttcc,, ((vvooiidd **))llffllccoonnttrrooll,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** LLFFIILLEE11 iiss llffll **//
{{ 1199,, 11,, ""LLFFIILLEE11"",,
((vvooiidd **))llfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))llffllcclloossee,,
((vvooiidd **))llffllrreeaadd,, ((vvooiidd **))llffllwwrriittee,, ((vvooiidd **))llffllsseeeekk,,
((vvooiidd **))llffllggeettcc,, ((vvooiidd **))llffllppuuttcc,, ((vvooiidd **))llffllccoonnttrrooll,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** LLFFIILLEE22 iiss llffll **//
{{ 2200,, 22,, ""LLFFIILLEE22"",,
((vvooiidd **))llfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))llffllcclloossee,,
((vvooiidd **))llffllrreeaadd,, ((vvooiidd **))llffllwwrriittee,, ((vvooiidd **))llffllsseeeekk,,
((vvooiidd **))llffllggeettcc,, ((vvooiidd **))llffllppuuttcc,, ((vvooiidd **))llffllccoonnttrrooll,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** LLFFIILLEE33 iiss llffll **//
{{ 2211,, 33,, ""LLFFIILLEE33"",,

Sec. 14.14        Initialization Of The I /O System 
283
((vvooiidd **))llfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))llffllcclloossee,,
((vvooiidd **))llffllrreeaadd,, ((vvooiidd **))llffllwwrriittee,, ((vvooiidd **))llffllsseeeekk,,
((vvooiidd **))llffllggeettcc,, ((vvooiidd **))llffllppuuttcc,, ((vvooiidd **))llffllccoonnttrrooll,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** LLFFIILLEE44 iiss llffll **//
{{ 2222,, 44,, ""LLFFIILLEE44"",,
((vvooiidd **))llfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))llffllcclloossee,,
((vvooiidd **))llffllrreeaadd,, ((vvooiidd **))llffllwwrriittee,, ((vvooiidd **))llffllsseeeekk,,
((vvooiidd **))llffllggeettcc,, ((vvooiidd **))llffllppuuttcc,, ((vvooiidd **))llffllccoonnttrrooll,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }},,
//** LLFFIILLEE55 iiss llffll **//
{{ 2233,, 55,, ""LLFFIILLEE55"",,
((vvooiidd **))llfflliinniitt,, ((vvooiidd **))iiooeerrrr,, ((vvooiidd **))llffllcclloossee,,
((vvooiidd **))llffllrreeaadd,, ((vvooiidd **))llffllwwrriittee,, ((vvooiidd **))llffllsseeeekk,,
((vvooiidd **))llffllggeettcc,, ((vvooiidd **))llffllppuuttcc,, ((vvooiidd **))llffllccoonnttrrooll,,
((vvooiidd **))00xx00,, ((vvooiidd **))iioonnuullll,, 00 }}
}};;
14.15 Perspective
Device-independent I/O is now an integral part of mainstream computing, and the 
advantages seem obvious. However, it took decades for the computing community to 
reach consensus on device-independent I/O and to devise a set of primitives. Some of 
the contention arose because programming languages each define a set of I/O abstrac-
tions. For example, FORTRAN used device numbers and required a mechanism that 
could bind each number to an I/O device or file. Operating system designers wanted to 
accommodate all languages because a large volume of code has been written in each. 
So, questions arise. Have we chosen the best set of device-independent I/O functions, 
or have we merely become so accustomed to using them that we fail to look for alterna-
tives? Are the functions we are using ideal for systems that focus on graphical devices?
14.16 Summary
An operating system hides the details of peripheral devices, and provides a set of 
abstract, device-independent functions that can be used to perform I/O. The example 
system uses nine abstract functions: open, close, control, getc, putc, read, write, seek, 
and an initialization function, init. In our design, each of the I/O primitives operates 
synchronously, delaying a calling process until the request has been satisfied (e.g., func-
tion read delays the calling process until data has arrived).
The example system defines an abstract device name (such as CONSOLE) for each 
device, and assigns the device a unique integer device descriptor. The system uses a 
device switch table to bind a descriptor to a specific device at runtime. Conceptually, 
the device switch table contains one row for each device and one column for each

284 
Device–independent Input And Output 
Chap. 14
abstract I/O operation; additional columns point to a control block for the device, and a 
minor device number is used to distinguish among multiple copies of a physical device. 
A high-level I/O operation, such as read or write, uses the device switch table to invoke 
the device driver function that performs the requested operation on the specified device. 
Individual drivers interpret the calls in a way meaningful to a particular device; if an 
operation makes no sense when applied to a particular device, the device switch table is 
configured to invoke function ioerr, which returns an error code.
EXERCISES
14.1 
Identify the set of abstract I/O operations available in Linux.
14.2 
Find a system that uses asynchronous I/O, and identify the mechanism by which a run-
ning program is notified when the operation completes. Which approach, synchronous
or asynchronous, makes it easier to program? Explain.
14.3  
The chapter discusses two separate bindings: the binding from a device name (e.g.,
CONSOLE) to a descriptor (e.g., 0) and the binding from a device descriptor to a specif-
ic hardware device. Explain how Linux performs the two bindings.
14.4  
Consider the implementation of device names in the example code. Is it possible to
write a program that allows a user to enter a device name (e.g., CONSOLE), and then
open the device? Why or why not?
14.5      Assume that in the course of debugging you begin to suspect that a process is making in-
correct calls to high-level I/O functions (e.g., calling seek on a device for which the 
operation makes no sense). How can you make a quick change to the code to intercept 
such errors and display the process ID of the offending process? (Make the change 
without recompiling the source code.)
14.6      Are the abstract I/O operations presented in the chapter sufficient for all I/O operations?
Explain. Hint: consider socket functions found in Unix.
14.7 
Xinu defines the device subsystem as the fundamental I/O abstraction and merges files
into the device system. Unix systems define the file system as the fundamental abstrac-
tion and merge devices into the file system. Compare the two approaches and list the 
advantages of each.

Chapter Contents
15.1 
Introduction, 287
15.2 
Serial Communication Using UART Hardware, 287
15.3 
The Tty Abstraction, 288
15.4 
Organization Of A Tty Device Driver, 289
15.5 
Request Queues And Buffers, 290
15.6 
Synchronization Of Upper Half And Lower Half, 291
15.7 
UART Hardware FIFOs And Driver Design, 292
15.8 
The Concept Of A Control Block, 293
15.9 
Tty Control Block And Data Declarations, 293
15.10 Minor Device Numbers, 296
15.11 Upper–half Tty Character Input (ttygetc), 297 
15.12 Upper–half Tty Read Function (ttyread), 298 
15.13 Upper–half Tty Character Output (ttyputc), 300 
15.14 Starting Output (ttykickout), 301
15.15 Upper–half Tty Multiple Character Output (ttywrite), 302 
15.16 Lower–half Tty Driver Function (ttyhandler), 303
15.17 Output Interrupt Processing (ttyhandle_out), 306 
15.18 Tty Input Processing (ttyhandle_in), 308
15.19 Tty Control Block Initialization (ttyinit), 315 
15.20 Device Driver Control (ttycontrol), 317
15.21 Perspective, 319 
15.22 Summary, 320


15
An Example Device Driver
It’s hard to find a good driver these days, one with 
character and style.
— Unknown
15.1 Introduction
Chapters in this section of the text explore the general structure of an I/O system, 
including interrupt processing and real-time clock management. The previous chapter 
presents the organization of the I/O subsystem, a set of abstract I/O operations, and an 
efficient implementation using a device switch table.
This chapter continues the exploration of I/O. The chapter explains how a driver 
can define an I/O service at a high level of abstraction that is independent of the under-
lying hardware. The chapter also elaborates on the conceptual division of a device 
driver into upper and lower halves by explaining how the two halves share data struc-
tures, such as buffers, and how they communicate. Finally, the chapter shows the de-
tails of a particular example: a driver for an asynchronous character-oriented serial de-
vice.
15.2 Serial Communication Using UART Hardware
The console line on most embedded systems uses a Universal Asynchronous 
Transmitter and Receiver (UART) chip that implements serial communication according 
to the RS-232 standard. UART hardware is primitive — it only provides the ability to 
send and receive individual bytes. It does not interpret the meaning of bytes or provide 
functions such as the use of backspace to erase previous input.
287

288 
An Example Device Driver 
Chap. 15
15.3 The Tty Abstraction
Xinu uses the name tty to refer to the abstraction of an interface used with a 
character-oriented text window that displays characters the user enters on a serial inter-
face, such as a keyboard.† In broad terms, a tty device supports two-way communica-
tion: a process can send characters to the output side and/or receive characters from the 
input side. Although the underlying serial hardware mechanism operates the input and 
output independently, the tty abstraction allows the two to be treated as a single mecha-
nism in which the input and output appear to be connected. For example, our tty driver 
supports character echo, which means that the input side of the driver can output a 
copy of each incoming character. Echo is especially important when a user is typing on 
a keyboard and expects to see characters displayed on a screen.
The tty abstraction illustrates an important feature of many device drivers: multiple 
modes. At any time, the driver operates in one mode, and the mode can be changed at 
runtime. Figure 15.1 summarizes the three modes our driver supports.
                                                                   Mode 
Meaning
                                                                   The driver delivers each incoming character as it arrives
raw 
without echoing the character, buffering a line of text,
performing translation, or controlling the output flow
                                                                   The driver buffers input, echoes characters in a readable
cooked 
form, honors backspace and line kill, allows type-ahead,
handles flow control, and delivers an entire line of text
                                                                   The driver handles character translation, echoing, and
cbreak 
flow control, but instead of buffering an entire line of text,
the driver delivers each incoming character as it arrives
                                                                   









































Figure 15.1  Three modes supported by the tty abstraction.
Raw mode is intended to give applications access to input characters with no pre-
processing. In raw mode, the tty driver merely delivers input without interpreting or 
changing characters. The driver does not echo characters nor does it handle flow con-
trol. Raw mode is useful when handling non-interactive communication, such as down-
loading a binary file over a serial line or using a serial device to control a sensor.
Cooked mode handles interactive keyboard input. Each time it receives a charac-
ter, the driver echoes the character (i.e., transmits a copy of the character to the output), 
which allows a user to see characters as they are typed. The driver has a parameter to 
control character echoing, which means an application can turn echo off and back on 
(e.g., to prompt for a password). Cooked mode supports line buffering, which means 
that the driver collects all characters of a line before delivering them to a reading proc-

†The name tty is taken from early Unix systems that used an ASCII Teletype device that consisted of a
keyboard and an associated printer mechanism.

Sec. 15.3        The Tty Abstraction 
289
ess. Because the tty driver performs character echo and other functions at interrupt
time, a user can type ahead, even if no application is reading characters (e.g., a user can 
type the next command while the current command is running). A chief advantage of 
cooked mode arises from the ability to edit a line, either by backspacing or by typing a 
special character to erase the entire line.
Cooked mode also provides flow control and input mapping. When enabled, flow 
control allows a user to type control-s to stop output temporarily, and later to type 
control-q to restart output. Input mapping handles hardware (or applications) that use
the two-character sequence of carriage return (cr) and linefeed (lf) to terminate a line of 
text instead of a single lf. Cooked mode contains a crlf† parameter that controls how 
the driver handles line termination. When a user presses the key labeled ENTER or RE-
TURN, the driver consults the parameter to decide whether to pass a linefeed (also 
called a NEWLINE) character to the application or to map the linefeed into a pair of 
characters, carriage return followed by linefeed.
Cbreak mode provides a compromise between cooked and raw modes. In cbreak 
mode, each character is delivered to the application instantly, without waiting to accu-
mulate a line of text. Thus, the driver does not buffer input, nor does the driver support 
backspace or line kill functions. However, the driver does handle both character echo 
and flow control.
15.4 Organization Of A Tty Device Driver
Like most device drivers, the example tty driver is partitioned into an upper half 
that contains functions called by application processes (indirectly through the device 
switch table), and a lower half that contains functions invoked when the device inter-
rupts. The two halves share a data structure that contains information about the device, 
the current mode of the driver, and buffers for incoming and outgoing data. In general, 
upper-half functions move data to or from the shared structure and have minimal in-
teraction with the device hardware. For example, an upper-half function places outgo-
ing data in the shared structure where a lower-half function can access and send the data 
to the device. Similarly, the lower half places incoming data in the shared structure 
where an upper-half function can extract it.
The motivation for driver partitioning can be difficult to appreciate at first. We 
will see, however, that dividing a driver into two halves is fundamental because the 
division allows a system designer to decouple normal processing from hardware inter-
rupt processing and understand exactly how each function is invoked. The point is:
When creating a device driver, a programmer must be careful to 
preserve the division between upper-half and lower-half functions be-
cause upper-half functions are called by application processes and 
lower-half functions are invoked by interrupts.

†Pronounced curl-if.

290 
An Example Device Driver 
Chap. 15
15.5 Request Queues And Buffers
In most drivers, the shared data structure contains two key items:
d Request queue
d Buffered I/O
Request queue. In principle, the most important item found in the data structure 
shared by upper-half and lower-half functions is a queue into which the upper half
places requests. Conceptually, the request queue connects high-level operations that ap-
plications specify and low-level actions that must be performed on the device. Each 
driver has its own set of requests, and the contents of elements on a request queue 
depend on the underlying device as well as the operations to be performed. For exam-
ple, requests issued to a disk device specify the direction of transfer (read or write), a 
location on the disk, and a buffer for the data to be transferred. Requests issued to a 
network device might specify a set of packet buffers, and specify whether to transmit a 
packet from the buffer or receive an incoming packet. Our example driver has two 
queues: one contains a set of outgoing characters and the other holds incoming charac-
ters. In essence, a character in an outgoing queue is a request to transmit, and space in 
the input queue serves as a request to receive.
Buffered I/O. Most drivers buffer incoming and outgoing data. Output buffering 
allows an application to deposit an outgoing item in a buffer, and then continue process-
ing. The item remains in the buffer until the hardware is ready to accept the item. In-
put buffering allows a driver to accept data from a device before an application is ready 
to receive it. An incoming item remains in the buffer from the time the device deposits 
the item until a process requests it.
Buffers are important for several reasons. First, a driver can accept incoming data 
before a user process consumes the data. Input buffering is especially important for 
asynchronous devices like a network interface that can receive packets at any time or a 
keyboard on which a user can press a key at any time. Second, buffering permits an ap-
plication to read or write arbitrary amounts of data, even if the underlying hardware 
transfers entire blocks. By placing a block in a buffer, an operating system can satisfy 
subsequent requests from the buffer without an I/O transfer. Third, output buffering 
permits the driver to perform I/O concurrently with processing because a process can 
write data into a buffer, and then continue executing while the driver writes the data to 
the device.
Our tty driver uses circular input and output buffers, with an extra circular buffer 
for echoed characters (echoed characters are kept in a buffer separate from normal out-
put because echoed characters have higher priority). We think of each buffer as a con-
ceptual queue, with characters being inserted at the tail and removed from the head. 
Figure 15.2 illustrates the concept of a circular output buffer, and shows the implemen-
tation with an array of bytes in memory.

Sec. 15.5        Request Queues And Buffers 
291
–
–
Q
W
E
R
T
Y
U
–
–
–
–
–
Q
W
E
R
T
Y
U
–
–
–
next item 
to send 
(head)
next slot 
to fill 
(tail)
next item 
to send 
(head)
next slot 
to fill 
(tail
(a) 
(b)
Figure 15.2 (a) A circular output buffer acting as a queue, and (b) the imple-
mentation with an array of bytes.
Output functions deposit characters to be sent in the output buffer and return to 
their caller. When it places characters in the output buffer, an upper-half function must 
also start output interrupts on the device. Whenever the device generates an output in-
terrupt, the lower half extracts up to sixteen characters from the output buffer, and depo-
sits the characters in the device’s output FIFO.† Once all characters in the output FIFO 
have been transmitted, the device will interrupt again. Thus, output continues until the 
output buffer becomes empty at which time the driver stops output and the device be-
comes idle.
Input works the other way around. Whenever it receives characters, the device in-
terrupts and the interrupt dispatcher calls a lower-half function (i.e., ttyhandler). The 
interrupt handler extracts the characters from the device’s input FIFO and deposits them 
in the circular input buffer. When a process calls an upper-half function to read input, 
the upper-half function extracts characters from the input buffer.
Conceptually, the two halves of a driver only communicate through shared buffers. 
Upper-half functions place outgoing data in a buffer and extract incoming data from a 
buffer. The lower half extracts outgoing data from the buffer and sends it to the device, 
and places incoming data in the buffer. To summarize:
Upper-half functions transfer data between processes and buffers; the 
lower half transfers data between buffers and the device hardware.
15.6 Synchronization Of Upper Half And Lower Half
In practice, the two halves of the driver usually need to do more than manipulate a 
shared data structure. For example, an upper-half function may need to start an output 
transfer if a device is idle. More important, the two halves need to coordinate opera-
tions on the request queue and the buffers. For example, if all slots in the output buffer 
are full when a process tries to write data, the process must be blocked. Later, when 
characters have been sent to the device and buffer space becomes available, the blocked 

†To improve efficiency, most UART hardware has a small on-board character buffer that can hold up to
16 outgoing characters at a time.

292 
An Example Device Driver 
Chap. 15
process must be allowed to proceed. Similarly, if the input buffer is empty when a
process attempts to read from a device, the process must be blocked. Later, when input 
has been received and placed in the buffer, the process that is waiting for input must be 
allowed to proceed.
At first glance, synchronization between the upper half and lower half of a driver 
appears to consist of two instances of producer–consumer coordination that can be 
solved easily with semaphores. On output, the upper-half functions produce data that
the lower-half functions consume, and on input, the lower half produces input data that 
the upper-half functions consume. Input poses no problem for the producer–consumer 
paradigm; a semaphore can be created that handles coordination. When a process calls 
an upper-half input function, the process waits on the input semaphore until the lower 
half produces an input data item and signals the semaphore.
Output poses an added twist. To understand the problem, recall our restriction on 
interrupt processing: because it can be executed by the null process, an interrupt func-
tion cannot call a function that moves the executing process to any state other than 
ready or current. In particular, lower-half routines cannot call wait. Consequently, a 
driver cannot be designed in which a semaphore allows upper-half functions to produce 
data and lower-half functions to consume data.
How can upper-half and lower-half functions coordinate to control output? 
Surprisingly, a semaphore solves the problem easily. The trick is to turn around the call 
to wait by changing the purpose of the output semaphore. Instead of having a lower-
half routine wait for the upper half to produce data, we arrange for the upper half to 
wait for space in the buffer. Thus, we do not view the lower half as a consumer. In-
stead, a lower-half output function acts as a producer to generate space (i.e., slots) in the 
buffer, and signals the output semaphore for each slot. To summarize:
Semaphores can be used to coordinate the upper half and lower half
of a device driver. To avoid having lower-half functions block, output
is handled by arranging for upper-half functions to wait for buffer 
space.
15.7 UART Hardware FIFOs And Driver Design
The design of the hardware can complicate driver design. For example, consider 
the UART hardware in the example platforms. The UART device contains two onboard 
buffers, known as FIFOs. One FIFO handles incoming characters, and the other han-
dles outgoing characters. Each FIFO holds up to sixteen characters. The device does 
not interrupt each time a character arrives. Instead, the hardware generates an interrupt 
when the first character arrives, but continues to add characters to the input FIFO if 
they arrive before the interrupt has been serviced. Thus, when it receives an input inter-
rupt, the driver must repeatedly extract characters from the FIFO until the hardware 
FIFO is empty.

Sec. 15.7        UART Hardware FIFOs And Driver Design 
293
How do multiple input characters affect the driver design? Consider the case 
where a process is blocked on an input semaphore, waiting for a character to arrive. In 
theory, once it extracts a character from the device and places the character in the input 
buffer, the driver should signal the semaphore to reschedule to indicate that a character 
is available. However, doing so may cause an immediate context switch, leaving addi-
tional characters in the FIFO unprocessed. To avoid the problem, our driver uses 
resched_cntl to defer rescheduling temporarily.† After all characters have been extract-
ed from the input FIFO and processed, the driver again calls resched_cntl to permit oth-
er processes to run.
15.8 The Concept Of A Control Block
We use the term control block to refer to the shared data structure associated with 
a device. More specifically, the control block is associated with a driver for the device, 
and holds data that the driver uses as well as data needed by the hardware. For exam-
ple, if a driver uses semaphores to coordinate the upper-half and lower-half functions, 
the semaphore IDs will be placed in the control block.
Recall that if a system contains multiple copies of a given hardware device, the 
operating system uses one copy of the device driver code to service all devices. How-
ever, each copy of the device must have a separate data structure. That is, the system 
must have a separate control block for each physical copy of the device. Like most sys-
tems, Xinu uses an array to hold N copies of the data structure if the system contains N 
copies of a given hardware device. We will see that each copy of the device is assigned 
a unique index number 0, 1, 2, and so on. The value serves as an index into the array 
of control blocks. Thus, the copy of a device assigned value i uses the ith  entry in the 
control block array.
When it runs, a device driver function receives an argument that identifies the con-
trol block to use. Thus, if a particular system has three serial devices that use the tty 
abstraction, the operating system contains only one copy of the functions that read and 
write to a tty device, but contains three separate copies of a tty control block.
15.9 Tty Control Block And Data Declarations
A control block stores information about a specific device, the driver, and the re-
quest queues. The control block either contains buffers or contains pointers to buffers 
in memory.‡ The tty control block also stores IDs of the two semaphores that coordi-
nate input and output. The code in file tty.h contains the declaration of the tty control 
block structure, which is named ttycblk. The key components of the ttycblk structure
consist of the input buffer, tyibuff, an output buffer, tyobuff, and a separate echo buffer, 
tyebuff. Each buffer used in the tty driver is implemented as an array of characters.

†The code for resched_cntl can be found in file resched.c on page 82.
‡On some systems, I/O buffers must be placed in a special region of memory to permit devices to access
the buffers directly.

294 
An Example Device Driver 
Chap. 15
//** ttttyy..hh **//
##ddeeffiinnee TTYY__OOBBMMIINNSSPP
2200
//** MMiinn ssppaaccee iinn bbuuffffeerr bbeeffoorree
**//
//**
pprroocceesssseess aawwaakkeenneedd ttoo wwrriittee**//
##ddeeffiinnee TTYY__EEBBUUFFLLEENN
2200
//** SSiizzee ooff eecchhoo qquueeuuee
**//
//** SSiizzee ccoonnssttaannttss **//
##iiffnnddeeff NNttttyy
##ddeeffiinnee NNttttyy
11
//** NNuummbbeerr ooff sseerriiaall ttttyy lliinneess
**//
##eennddiiff
##iiffnnddeeff TTYY__IIBBUUFFLLEENN
##ddeeffiinnee TTYY__IIBBUUFFLLEENN
112288
//** NNuumm.. cchhaarrss iinn iinnppuutt qquueeuuee
**//
##eennddiiff
##iiffnnddeeff TTYY__OOBBUUFFLLEENN
##ddeeffiinnee TTYY__OOBBUUFFLLEENN
6644
//** NNuumm.. cchhaarrss iinn oouuttppuutt qquueeuuee
**//
##eennddiiff
//** MMooddee ccoonnssttaannttss ffoorr iinnppuutt aanndd oouuttppuutt mmooddeess **//
##ddeeffiinnee TTYY__IIMMRRAAWW
’’RR’’
//** RRaaww iinnppuutt mmooddee ==>> nnoo eeddiittss
**//
##ddeeffiinnee TTYY__IIMMCCOOOOKKEEDD
’’CC’’
//** CCooookkeedd mmooddee ==>> lliinnee eeddiittiinngg
**//
##ddeeffiinnee TTYY__IIMMCCBBRREEAAKK
’’KK’’
//** HHoonnoorr eecchhoo,, eettcc,, nnoo lliinnee eeddiitt**//
##ddeeffiinnee TTYY__OOMMRRAAWW
’’RR’’
//** RRaaww oouuttppuutt mmooddee ==>> nnoo eeddiittss
**//
ssttrruucctt
ttttyyccbbllkk {{
//** TTttyy lliinnee ccoonnttrrooll bblloocckk
**//
cchhaarr
**ttyyiihheeaadd;;
//** NNeexxtt iinnppuutt cchhaarr ttoo rreeaadd
**//
cchhaarr
**ttyyiittaaiill;;
//** NNeexxtt sslloott ffoorr aarrrriivviinngg cchhaarr
**//
cchhaarr
ttyyiibbuuffff[[TTYY__IIBBUUFFLLEENN]];;
//** IInnppuutt bbuuffffeerr ((hhoollddss oonnee lliinnee))**//
ssiidd3322
ttyyiisseemm;;
//** IInnppuutt sseemmaapphhoorree
**//
cchhaarr
**ttyyoohheeaadd;;
//** NNeexxtt oouuttppuutt cchhaarr ttoo xxmmiitt
**//
cchhaarr
**ttyyoottaaiill;;
//** NNeexxtt sslloott ffoorr oouuttggooiinngg cchhaarr
**//
cchhaarr
ttyyoobbuuffff[[TTYY__OOBBUUFFLLEENN]];;
//** OOuuttppuutt bbuuffffeerr
**//
ssiidd3322
ttyyoosseemm;;
//** OOuuttppuutt sseemmaapphhoorree
**//
cchhaarr
**ttyyeehheeaadd;;
//** NNeexxtt eecchhoo cchhaarr ttoo xxmmiitt
**//
cchhaarr
**ttyyeettaaiill;;
//** NNeexxtt sslloott ttoo ddeeppoossiitt eecchhoo cchh **//
cchhaarr
ttyyeebbuuffff[[TTYY__EEBBUUFFLLEENN]];;
//** EEcchhoo bbuuffffeerr
**//
cchhaarr
ttyyiimmooddee;;
//** IInnppuutt mmooddee rraaww//ccbbrreeaakk//ccooookkeedd **//
bbooooll88
ttyyiieecchhoo;;
//** IIss iinnppuutt eecchhooeedd??
**//
bbooooll88
ttyyiieebbaacckk;;
//** DDoo eerraassiinngg bbaacckkssppaaccee oonn eecchhoo??**//
bbooooll88
ttyyeevviiss;;
//** EEcchhoo ccoonnttrrooll cchhaarrss aass ^^XX ??
**//
bbooooll88
ttyyeeccrrllff;;
//** EEcchhoo CCRR--LLFF ffoorr nneewwlliinnee??
**//
bbooooll88
ttyyiiccrrllff;;
//** MMaapp ’’\\rr’’ ttoo ’’\\nn’’ oonn iinnppuutt??
**//
bbooooll88
ttyyiieerraassee;;
//** HHoonnoorr eerraassee cchhaarraacctteerr??
**//
cchhaarr
ttyyiieerraasseecc;;
//** PPrriimmaarryy eerraassee cchhaarraacctteerr
**//

Sec. 15.9        Tty Control Block And Data Declarations 
295
cchhaarr
ttyyiieerraasseecc22;;
//** AAlltteerrnnaattee eerraassee cchhaarraacctteerr
**//
bbooooll88
ttyyeeooff;;
//** HHoonnoorr EEOOFF cchhaarraacctteerr??
**//
cchhaarr
ttyyeeooffcchh;;
//** EEOOFF cchhaarraacctteerr ((uussuuaallllyy ^^DD))
**//
bbooooll88
ttyyiikkiillll;;
//** HHoonnoorr lliinnee kkiillll cchhaarraacctteerr??
**//
cchhaarr
ttyyiikkiillllcc;;
//** LLiinnee kkiillll cchhaarraacctteerr
**//
iinntt3322
ttyyiiccuurrssoorr;;
//** CCuurrrreenntt ccuurrssoorr ppoossiittiioonn
**//
bbooooll88
ttyyooffllooww;;
//** HHoonnoorr oossttoopp//oossttaarrtt??
**//
bbooooll88
ttyyoohheelldd;;
//** OOuuttppuutt ccuurrrreennttllyy bbeeiinngg hheelldd?? **//
cchhaarr
ttyyoossttoopp;;
//** CChhaarraacctteerr tthhaatt ssttooppss oouuttppuutt
**//
cchhaarr
ttyyoossttaarrtt;;
//** CChhaarraacctteerr tthhaatt ssttaarrttss oouuttppuutt **//
bbooooll88
ttyyooccrrllff;;
//** OOuuttppuutt CCRR//LLFF ffoorr LLFF ??
**//
cchhaarr
ttyyiiffuullllcc;;
//** CChhaarr ttoo sseenndd wwhheenn iinnppuutt ffuullll **//
}};;
eexxtteerrnn
ssttrruucctt
ttttyyccbbllkk ttttyyttaabb[[]];;
//** CChhaarraacctteerrss wwiitthh mmeeaanniinngg ttoo tthhee ttttyy ddrriivveerr **//
##ddeeffiinnee TTYY__BBAACCKKSSPP
’’\\bb’’
//** BBaacckkssppaaccee cchhaarraacctteerr
**//
##ddeeffiinnee TTYY__BBAACCKKSSPP22
’’\\117777’’
//** AAlltteerrnnaattee bbaacckkssppaaccee cchhaarr..
**//
##ddeeffiinnee TTYY__BBEELLLL
’’\\0077’’
//** CChhaarraacctteerr ffoorr aauuddiibbllee bbeeeepp
**//
##ddeeffiinnee TTYY__EEOOFFCCHH
’’\\0044’’
//** CCoonnttrrooll--DD iiss EEOOFF oonn iinnppuutt
**//
##ddeeffiinnee TTYY__BBLLAANNKK
’’ ’’
//** BBllaannkk
**//
##ddeeffiinnee TTYY__NNEEWWLLIINNEE
’’\\nn’’
//** NNeewwlliinnee ==== lliinnee ffeeeedd
**//
##ddeeffiinnee TTYY__RREETTUURRNN
’’\\rr’’
//** CCaarrrriiaaggee rreettuurrnn cchhaarraacctteerr
**//
##ddeeffiinnee TTYY__SSTTOOPPCCHH
’’\\002233’’
//** CCoonnttrrooll--SS ssttooppss oouuttppuutt
**//
##ddeeffiinnee TTYY__SSTTRRTTCCHH
’’\\002211’’
//** CCoonnttrrooll--QQ rreessttaarrttss oouuttppuutt
**//
##ddeeffiinnee TTYY__KKIILLLLCCHH
’’\\002255’’
//** CCoonnttrrooll--UU iiss lliinnee kkiillll
**//
##ddeeffiinnee TTYY__UUPPAARRRROOWW
’’^^’’
//** UUsseedd ffoorr ccoonnttrrooll cchhaarrss ((^^XX))
**//
##ddeeffiinnee TTYY__FFUULLLLCCHH
TTYY__BBEELLLL
//** CChhaarr ttoo eecchhoo wwhheenn bbuuffffeerr ffuullll**//
//** TTttyy ccoonnttrrooll ffuunnccttiioonn ccooddeess **//
##ddeeffiinnee TTCC__NNEEXXTTCC
33
//** LLooookk aahheeaadd 11 cchhaarraacctteerr
**//
##ddeeffiinnee TTCC__MMOODDEERR
44
//** SSeett iinnppuutt mmooddee ttoo rraaww
**//
##ddeeffiinnee TTCC__MMOODDEECC
55
//** SSeett iinnppuutt mmooddee ttoo ccooookkeedd
**//
##ddeeffiinnee TTCC__MMOODDEEKK
66
//** SSeett iinnppuutt mmooddee ttoo ccbbrreeaakk
**//
##ddeeffiinnee TTCC__IICCHHAARRSS
88
//** RReettuurrnn nnuummbbeerr ooff iinnppuutt cchhaarrss **//
##ddeeffiinnee TTCC__EECCHHOO
99
//** TTuurrnn oonn eecchhoo
**//
##ddeeffiinnee TTCC__NNOOEECCHHOO
1100
//** TTuurrnn ooffff eecchhoo
**//
The driver treats each buffer as a circular list, with location zero in an array treated 
as if it follows the last location. Head and tail pointers give the address of the next lo-
cation in the array to fill and the next location in the array to empty, respectively. 
Thus, a programmer can remember an easy rule:

296 
An Example Device Driver 
Chap. 15
A character is always inserted at the tail and taken from the head, in-
dependent of whether a buffer is used for input or output.
Initially, the head and tail each point to location zero, but there is never any confu-
sion about whether an input or output buffer is completely empty or completely full be-
cause each buffer has a semaphore that gives the count of characters in the buffer. 
Semaphore tyisem controls the input buffer, and a nonnegative count n means the buffer 
contains n characters. Semaphore tyosem controls the output buffer, and a nonnegative 
count n means the buffer contains n unfilled slots. The echo buffer is an exception. 
Our design assumes echo is used for a human typing, which means that only a few 
characters will ever occupy the echo queue. Therefore, we assume that no overflow 
will occur, which means that no semaphore is needed to control the queue.
15.10 Minor Device Numbers
We said that the configuration program assigns each device in the system a unique 
device ID. If the system contains multiple physical copies of a device that all use a 
given abstraction, the IDs assigned to the devices may not be contiguous values. Thus,
if a system has three tty devices, the configuration program may assign them device IDs 
2, 7, and 8.
We also said that the operating system must allocate one control block per device.
For example, if a system contains three tty devices, the system must allocate three
copies of the tty control block. Xinu, like many systems, employs a technique that per-
mits efficient access of a control block for a given device. The system assigns a minor 
device number to each copy of the device, and chooses minor device numbers to be 
contiguous integers starting at zero. Thus, if a system contains three tty devices, they 
will be assigned minor device numbers 0, 1, and 2. Unlike device IDs, the assignment 
of minor device numbers is guaranteed to be contiguous.
How does a sequential assignment of minor device numbers make access efficient? 
We can now understand how device drivers are parameterized, and how they use minor 
device numbers. A minor device number serves as an index into the array of control 
blocks for the device. For example, consider how tty control blocks are allocated. As 
file tty.h illustrates, the control blocks are placed in array ttytab. The system config-
uration program defines constant Ntty to be the number of tty devices, which is used to 
declare the size of array ttytab. The configuration program assigns each tty device a 
minor device number starting at 0 and ending at Ntty–1. The minor device number is 
placed in the device switch table entry. Both interrupt-driven routines in the lower half 
and driver routines in the upper half can access the minor device number. Each func-
tion in the upper half has an argument that specifies one of the device table entries. 
Similarly, when an interrupt occurs, the operating system associates the interrupt with a 
specific device in the device table. Consequently, each driver function can extract the 
minor device number, and use the value as an index into array ttytab.

Sec. 15.11        Upper–half Tty Character Input (ttygetc) 
297
15.11 Upper–half Tty Character Input (ttygetc)
Four functions form the foundation for the upper half of the tty driver: ttygetc,
ttyputc, ttyread, and ttywrite. The functions correspond to the high-level operations
getc, putc, read, and write described in Chapter 14. The simplest driver routine is
ttygetc; the code can be found in file ttygetc.c.
//** ttttyyggeettcc..cc -- ttttyyggeettcc **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ttttyyggeettcc
--
RReeaadd oonnee cchhaarraacctteerr ffrroomm aa ttttyy ddeevviiccee ((iinntteerrrruuppttss ddiissaabblleedd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll ttttyyggeettcc((
ssttrruucctt ddeennttrryy **ddeevvppttrr
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
))
{{
cchhaarr
cchh;;
//** CChhaarraacctteerr ttoo rreettuurrnn
**//
ssttrruucctt
ttttyyccbbllkk **ttyyppttrr;;
//** PPooiinntteerr ttoo ttttyyttaabb eennttrryy
**//
ttyyppttrr == &&ttttyyttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
//** WWaaiitt ffoorr aa cchhaarraacctteerr iinn tthhee bbuuffffeerr aanndd eexxttrraacctt oonnee cchhaarraacctteerr **//
wwaaiitt((ttyyppttrr-->>ttyyiisseemm));;
cchh == **ttyyppttrr-->>ttyyiihheeaadd++++;;
//** WWrraapp aarroouunndd ttoo bbeeggiinnnniinngg ooff bbuuffffeerr,, iiff nneeeeddeedd **//
iiff ((ttyyppttrr-->>ttyyiihheeaadd >>== &&ttyyppttrr-->>ttyyiibbuuffff[[TTYY__IIBBUUFFLLEENN]])) {{
ttyyppttrr-->>ttyyiihheeaadd == ttyyppttrr-->>ttyyiibbuuffff;;
}} 
//** IInn ccooookkeedd mmooddee,, cchheecckk ffoorr tthhee EEOOFF cchhaarraacctteerr **//
iiff (( ((ttyyppttrr-->>ttyyiimmooddee ==== TTYY__IIMMCCOOOOKKEEDD)) &&&& ((ttyyppttrr-->>ttyyeeooff)) &&&&
((cchh ==== ttyyppttrr-->>ttyyeeooffcchh)) )) {{
rreettuurrnn ((ddeevvccaallll))EEOOFF;;
}} 
rreettuurrnn ((ddeevvccaallll))cchh;;
}}

298 
An Example Device Driver 
Chap. 15
When called, ttygetc retrieves the minor device number from the device switch 
table, and then uses the number as an index into array ttytab to locate the correct control 
block. It then executes wait on the input semaphore, tyisem, blocking until the lower 
half has deposited a character in the buffer. When wait returns, ttygetc extracts the next 
character from the input buffer and updates the head pointer to make it ready for subse-
quent extractions. Normally, ttygetc returns the character to its caller. However, one 
special case arises: if the driver is honoring end-of-file and the character matches the 
end-of-file character (field tyeofch in the control block), ttygetc returns constant EOF.
15.12 Upper–half Tty Read Function (ttyread)
The read operation can be used to obtain multiple characters in a single operation. 
The driver function that implements the read operation, ttyread, is shown below in file 
ttyread.c.  Ttyread is conceptually straightforward: it calls ttygetc repeatedly to obtain 
characters. When the driver is operating in cooked mode, ttyread returns a single line 
of input, stopping after a NEWLINE or RETURN character; when operating in other 
modes, ttyread reads characters without testing for an end-of-line.
//** ttttyyrreeaadd..cc -- ttttyyrreeaadd **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ttttyyrreeaadd
--
RReeaadd cchhaarraacctteerr((ss)) ffrroomm aa ttttyy ddeevviiccee ((iinntteerrrruuppttss ddiissaabblleedd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll ttttyyrreeaadd((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**bbuuffff,,
//** BBuuffffeerr ooff cchhaarraacctteerrss
**//
iinntt3322 ccoouunntt
//** CCoouunntt ooff cchhaarraacctteerr ttoo rreeaadd
**//
))
{{
ssttrruucctt
ttttyyccbbllkk **ttyyppttrr;;
//** PPooiinntteerr ttoo ttttyy ccoonnttrrooll bblloocckk **//
iinntt3322
aavvaaiill;;
//** CChhaarraacctteerrss aavvaaiillaabbllee iinn bbuuffff..**//
iinntt3322
nnrreeaadd;;
//** NNuummbbeerr ooff cchhaarraacctteerrss rreeaadd
**//
iinntt3322
ffiirrssttcchh;;
//** FFiirrsstt iinnppuutt cchhaarraacctteerr oonn lliinnee**//
cchhaarr
cchh;;
//** NNeexxtt iinnppuutt cchhaarraacctteerr
**//
iiff ((ccoouunntt << 00)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
ttyyppttrr== &&ttttyyttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;

Sec. 15.12        Upper–half Tty Read Function (ttyread) 
299
iiff ((ttyyppttrr-->>ttyyiimmooddee !!== TTYY__IIMMCCOOOOKKEEDD)) {{
//** FFoorr ccoouunntt ooff zzeerroo,, rreettuurrnn aallll aavvaaiillaabbllee cchhaarraacctteerrss **//
iiff ((ccoouunntt ==== 00)) {{
aavvaaiill == sseemmccoouunntt((ttyyppttrr-->>ttyyiisseemm));;
iiff ((aavvaaiill ==== 00)) {{
rreettuurrnn 00;;
}} eellssee {{
ccoouunntt == aavvaaiill;;
}}
}} 
ffoorr ((nnrreeaadd == 00;; nnrreeaadd << ccoouunntt;; nnrreeaadd++++)) {{
**bbuuffff++++ == ((cchhaarr)) ttttyyggeettcc((ddeevvppttrr));;
}} 
rreettuurrnn nnrreeaadd;;
}} 
//** BBlloocckk uunnttiill iinnppuutt aarrrriivveess **//
ffiirrssttcchh == ttttyyggeettcc((ddeevvppttrr));;
//** CChheecckk ffoorr EEnndd--OOff--FFiillee **//
iiff ((ffiirrssttcchh ==== EEOOFF)) {{
rreettuurrnn EEOOFF;;
}} 
//** RReeaadd uupp ttoo aa lliinnee **//
cchh == ((cchhaarr)) ffiirrssttcchh;;
**bbuuffff++++ == cchh;;
nnrreeaadd == 11;;
wwhhiillee (( ((nnrreeaadd << ccoouunntt)) &&&& ((cchh !!== TTYY__NNEEWWLLIINNEE)) &&&&
((cchh !!== TTYY__RREETTUURRNN)) )) {{
cchh == ttttyyggeettcc((ddeevvppttrr));;
**bbuuffff++++ == cchh;;
nnrreeaadd++++;;
}} 
rreettuurrnn nnrreeaadd;;
}}
The semantics of how read operates on terminals illustrates how the I/O primitives
can be adapted to a variety of devices and modes. For example, an application that uses

300 
An Example Device Driver 
Chap. 15
raw mode may need to read all the characters available from the input buffer without 
blocking. Ttyread cannot simply call ttygetc repeatedly because ttygetc will block once 
the buffer is empty. To accommodate non-blocking requests, our driver allows what 
might otherwise be considered an illegal operation: it interprets a request to read zero 
characters as a request to “read all characters that are waiting.”
The code in ttyread shows how the zero length requests are handled in raw mode:
the driver uses semcount to obtain the current count of the input semaphore, tyisem. It
then knows exactly how many calls can be made to ttygetc without blocking.
For cooked mode, the driver blocks until at least one character arrives. It handles
the special case of an end-of-file character, and then calls ttygetc repeatedly to read the
rest of the line.
15.13 Upper–half Tty Character Output (ttyputc)
The upper-half output routines are almost as easy to understand as the upper-half 
input routines. Ttyputc waits for space in the output buffer, deposits the specific charac-
ter in the output queue, tyobuff, and increments the tail pointer, tyotail. In addition, 
ttyputc starts output on the device. File ttyputc.c contains the code.
//** ttttyyppuuttcc..cc -- ttttyyppuuttcc **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ttttyyppuuttcc
--
WWrriittee oonnee cchhaarraacctteerr ttoo aa ttttyy ddeevviiccee ((iinntteerrrruuppttss ddiissaabblleedd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll ttttyyppuuttcc((
ssttrruucctt
ddeennttrryy
**ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
cchh
//** CChhaarraacctteerr ttoo wwrriittee
**//
))
{{
ssttrruucctt
ttttyyccbbllkk **ttyyppttrr;;
//** PPooiinntteerr ttoo ttttyy ccoonnttrrooll bblloocckk **//
ttyyppttrr == &&ttttyyttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
//** HHaannddllee oouuttppuutt CCRRLLFF bbyy sseennddiinngg CCRR ffiirrsstt **//
iiff (( cchh====TTYY__NNEEWWLLIINNEE &&&& ttyyppttrr-->>ttyyooccrrllff )) {{
ttttyyppuuttcc((ddeevvppttrr,, TTYY__RREETTUURRNN));;
}} 
wwaaiitt((ttyyppttrr-->>ttyyoosseemm));;
//** WWaaiitt ffoorr ssppaaccee iinn qquueeuuee **//
**ttyyppttrr-->>ttyyoottaaiill++++ == cchh;;

Sec. 15.13        Upper–half Tty Character Output (ttyputc) 
301
//** WWrraapp aarroouunndd ttoo bbeeggiinnnniinngg ooff bbuuffffeerr,, iiff nneeeeddeedd **//
iiff ((ttyyppttrr-->>ttyyoottaaiill >>== &&ttyyppttrr-->>ttyyoobbuuffff[[TTYY__OOBBUUFFLLEENN]])) {{
ttyyppttrr-->>ttyyoottaaiill == ttyyppttrr-->>ttyyoobbuuffff;;
}} 
//** SSttaarrtt oouuttppuutt iinn ccaassee ddeevviiccee iiss iiddllee **//
ttttyykkiicckkoouutt((((ssttrruucctt uuaarrtt__ccssrreegg **))ddeevvppttrr-->>ddvvccssrr));;
rreettuurrnn OOKK;;
}}
In addition to the processing mentioned above, ttyputc honors one of the tty param-
eters, tyocrlf. When tyocrlf is TRUE, each NEWLINE should map to the combination 
RETURN plus NEWLINE. To write the RETURN character, ttyputc calls itself recur-
sively.
15.14 Starting Output (ttykickout)
Just before it returns, ttyputc calls ttykickout to start output. In fact, ttykickout does 
not perform any output to the device because all output is handled by the lower-half 
function when an output interrupt occurs. To understand how ttykickout works, it is 
necessary to know how an operating system interacts with the device hardware. It may 
seem that when a character becomes ready for output, ttyputc would take the following 
steps:
Interact with the device to determine whether the device is busy; 
if (the device is not busy) {
send the character to the device;
} else {
instruct the device to interrupt when output finishes;
}
Unfortunately, a device operates in parallel with the processor. Therefore, a race 
condition can occur — between the time the processor obtains the status and the time it 
instructs the device to interrupt, the device can finish output. If the device is already 
idle before the processor sends the command, the device will never interrupt.
To avoid the race condition, device hardware is designed to allow an operating sys-
tem to request an interrupt without testing the device. Making a request is trivial: the 
driver merely needs to set a bit in one of the device control registers. No race condition 
occurs because setting the bit causes an interrupt whether the device is currently sending

302 
An Example Device Driver 
Chap. 15
characters or idle. If the device is busy, the hardware waits until output finishes and the 
on-board buffer is empty before generating an interrupt; if the device is currently idle 
when the bit is set, the device interrupts immediately.
Setting the interrupt bit in the device only requires a single assignment statement;
the code can be found in file ttykickout.c:
//** ttttyykkiicckkoouutt..cc -- ttttyykkiicckkoouutt **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ttttyykkiicckkoouutt
--
""KKiicckk"" tthhee hhaarrddwwaarree ffoorr aa ttttyy ddeevviiccee,, ccaauussiinngg iitt ttoo
**
ggeenneerraattee aann oouuttppuutt iinntteerrrruupptt ((iinntteerrrruuppttss ddiissaabblleedd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
ttttyykkiicckkoouutt((
ssttrruucctt uuaarrtt__ccssrreegg **ccssrrppttrr
//** AAddddrreessss ooff UUAARRTT’’ss CCSSRRss
**//
))
{{
//** FFoorrccee tthhee UUAARRTT hhaarrddwwaarree ggeenneerraattee aann oouuttppuutt iinntteerrrruupptt **//
ccssrrppttrr-->>iieerr == UUAARRTT__IIEERR__EERRBBFFII || UUAARRTT__IIEERR__EETTBBEEII;;
rreettuurrnn;;
}}
15.15 Upper–half Tty Multiple Character Output (ttywrite)
The tty driver also supports multiple-byte output transfers (i.e., writes). Driver 
function ttywrite, found in file ttywrite.c, handles the output of one or more bytes. 
Ttywrite begins by checking the argument count, which specifies the number of bytes to 
write. A negative count is invalid, and a count of zero is allowed, but means no charac-
ters are written.
Once it has finished checking argument count, ttywrite enters a loop. On each 
iteration through the loop, ttywrite extracts the next character from the user’s buffer and 
calls ttyputc to place the character in the output buffer. As we have seen, ttyputc will 
proceed until the output buffer is full, at which time the call to ttyputc will block until 
space becomes available.

Sec. 15.15        Upper–half Tty Multiple Character Output (ttywrite) 
303
//** ttttyywwrriittee..cc -- ttttyywwrriittee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ttttyywwrriittee
--
WWrriittee cchhaarraacctteerr((ss)) ttoo aa ttttyy ddeevviiccee ((iinntteerrrruuppttss ddiissaabblleedd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll ttttyywwrriittee((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**bbuuffff,,
//** BBuuffffeerr ooff cchhaarraacctteerrss
**//
iinntt3322 ccoouunntt
//** CCoouunntt ooff cchhaarraacctteerr ttoo wwrriittee
**//
))
{{
//** HHaannddllee nneeggaattiivvee aanndd zzeerroo ccoouunnttss **//
iiff ((ccoouunntt << 00)) {{
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((ccoouunntt ==== 00)){{
rreettuurrnn OOKK;;
}} 
//** WWrriittee ccoouunntt cchhaarraacctteerrss oonnee aatt aa ttiimmee **//
ffoorr ((;; ccoouunntt>>00 ;; ccoouunntt----)) {{
ttttyyppuuttcc((ddeevvppttrr,, **bbuuffff++++));;
}} 
rreettuurrnn OOKK;;
}}
15.16 Lower–half Tty Driver Function (ttyhandler)
The lower half of the tty driver is invoked when an interrupt occurs. The lower 
half consists of a handler, ttyhandler. Recall that a handler is invoked indirectly — an 
interrupt dispatcher function calls the handler whenever the device interrupts. The 
dispatch code is trivial, and identical to the dispatch code used with other devices, ex-
cept for the handler that is invoked.  Therefore, we will only examine the handler code.
It is important to understand that the UART hardware uses one interrupt vector for 
both input and output. That is, the handler will be invoked whenever the device has re-
ceived one or more incoming characters, or when the device has sent all the characters 
in its output FIFO and is ready for more. The handler must check a control register in 
the device to determine whether an input or output interrupt has occurred. File 
ttyhandler.c contains the code.

304 
An Example Device Driver 
Chap. 15
//** ttttyyhhaannddlleerr..cc -- ttttyyhhaannddlleerr **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ttttyyhhaannddlleerr
--
HHaannddllee aann iinntteerrrruupptt ffoorr aa ttttyy ((sseerriiaall)) ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd ttttyyhhaannddlleerr((vvooiidd)) {{
ssttrruucctt
ddeennttrryy
**ddeevvppttrr;;
//** AAddddrreessss ooff ddeevviiccee ccoonnttrrooll bbllkk**//
ssttrruucctt
ttttyyccbbllkk **ttyyppttrr;;
//** PPooiinntteerr ttoo ttttyyttaabb eennttrryy
**//
ssttrruucctt
uuaarrtt__ccssrreegg **ccssrrppttrr;;
//** AAddddrreessss ooff UUAARRTT’’ss CCSSRR
**//
bbyyttee
iiiirr == 00;;
//** IInntteerrrruupptt iiddeennttiiffiiccaattiioonn
**//
bbyyttee
llssrr == 00;;
//** LLiinnee ssttaattuuss
**//
//** GGeett CCSSRR aaddddrreessss ooff tthhee ddeevviiccee ((aassssuummee ccoonnssoollee ffoorr nnooww)) **//
ddeevvppttrr == ((ssttrruucctt ddeennttrryy **)) &&ddeevvttaabb[[CCOONNSSOOLLEE]];;
ccssrrppttrr == ((ssttrruucctt uuaarrtt__ccssrreegg **)) ddeevvppttrr-->>ddvvccssrr;;
//** OObbttaaiinn aa ppooiinntteerr ttoo tthhee ttttyy ccoonnttrrooll bblloocckk **//
ttyyppttrr == &&ttttyyttaabb[[ ddeevvppttrr-->>ddvvmmiinnoorr ]];;
//** DDeeccooddee hhaarrddwwaarree iinntteerrrruupptt rreeqquueesstt ffrroomm UUAARRTT ddeevviiccee **//
//** CChheecckk iinntteerrrruupptt iiddeennttiiffiiccaattiioonn rreeggiisstteerr **//
iiiirr == ccssrrppttrr-->>iiiirr;;
iiff ((iiiirr && UUAARRTT__IIIIRR__IIRRQQ)) {{
rreettuurrnn;;
}} 
//** DDeeccooddee tthhee iinntteerrrruupptt ccaauussee bbaasseedd uuppoonn tthhee vvaalluuee eexxttrraacctteedd
**//
//** ffrroomm tthhee UUAARRTT iinntteerrrruupptt iiddeennttiiffiiccaattiioonn rreeggiisstteerr..
CClleeaarr
**//
//** tthhee iinntteerrrruupptt ssoouurrccee aanndd ppeerrffoorrmm tthhee aapppprroopprriiaattee hhaannddlliinngg
**//
//** ttoo ccoooorrddiinnaattee wwiitthh tthhee uuppppeerr hhaallff ooff tthhee ddrriivveerr
**//
//** DDeeccooddee tthhee iinntteerrrruupptt ccaauussee **//
iiiirr &&== UUAARRTT__IIIIRR__IIDDMMAASSKK;;
//** MMaasskk ooffff tthhee iinntteerrrruupptt IIDD **//
sswwiittcchh ((iiiirr)) {{
//** RReecceeiivveerr lliinnee ssttaattuuss iinntteerrrruupptt ((eerrrroorr)) **//

Sec. 15.16        Lower–half Tty Driver Function (ttyhandler) 
305
ccaassee UUAARRTT__IIIIRR__RRLLSSII::
rreettuurrnn;;
//** RReecceeiivveerr ddaattaa aavvaaiillaabbllee oorr ttiimmeedd oouutt **//
ccaassee UUAARRTT__IIIIRR__RRDDAA::
ccaassee UUAARRTT__IIIIRR__RRTTOO::
rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTAARRTT));;
//** WWhhiillee cchhaarrss aavvaaiill.. iinn UUAARRTT bbuuffffeerr,, ccaallll ttttyyiinntteerr__iinn
**//
wwhhiillee (( ((ccssrrppttrr-->>llssrr && UUAARRTT__LLSSRR__DDRR)) !!== 00)) {{
ttttyyhhaannddllee__iinn((ttyyppttrr,, ccssrrppttrr));;
}} 
rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTOOPP));;
rreettuurrnn;;
//** TTrraannssmmiitttteerr oouuttppuutt FFIIFFOO iiss eemmppttyy ((ii..ee..,, rreeaaddyy ffoorr mmoorree))
**//
ccaassee UUAARRTT__IIIIRR__TTHHRREE::
ttttyyhhaannddllee__oouutt((ttyyppttrr,, ccssrrppttrr));;
rreettuurrnn;;
//** MMooddeemm ssttaattuuss cchhaannggee ((ssiimmppllyy iiggnnoorree)) **//
ccaassee UUAARRTT__IIIIRR__MMSSCC::
rreettuurrnn;;
}}
}}
After obtaining the device’s CSR address from the device switch table, ttyhandler 
loads the UART’s CSR address into csrptr, and then uses csrptr to access the UART 
device. The key step consists of reading the interrupt identification register and using 
the value to determine the exact reason for the interrupt. The two reasons of interest are 
an input interrupt (data has arrived) or an output interrupt (i.e., the transmitter FIFO is 
empty and the driver can send additional characters).
In the code, a switch statement chooses among a line status interrupt, an input in-
terrupt, and an output interrupt. In our system, a line status interrupt should not occur,
and is considered an error. Therefore, if a line status interrupt does occur, the handler 
merely returns (i.e., ignores the interrupt).

306 
An Example Device Driver 
Chap. 15
15.17 Output Interrupt Processing (ttyhandle_out)
Output interrupt processing is the easiest to understand. When an output interrupt 
occurs, the device has transmitted all characters from the onboard FIFO and is ready for 
more. Ttyhandler clears the interrupt and calls ttyhandle_out to restart output. The 
code for ttyhandle_out can be found in file ttyhandle_out.c
//** ttttyyhhaannddllee__oouutt..cc -- ttttyyhhaannddllee__oouutt **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ttttyyhhaannddllee__oouutt
--
HHaannddllee aann oouuttppuutt oonn aa ttttyy ddeevviiccee bbyy sseennddiinngg mmoorree
**
cchhaarraacctteerrss ttoo tthhee ddeevviiccee FFIIFFOO ((iinntteerrrruuppttss ddiissaabblleedd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
ttttyyhhaannddllee__oouutt((
ssttrruucctt ttttyyccbbllkk **ttyyppttrr,,
//** PPttrr ttoo ttttyyttaabb eennttrryy
**//
ssttrruucctt uuaarrtt__ccssrreegg **ccssrrppttrr
//** AAddddrreessss ooff UUAARRTT’’ss CCSSRRss
**//
))
{{
iinntt3322
oocchhaarrss;;
//** NNuummbbeerr ooff oouuttppuutt cchhaarrss sseenntt
**//
//**
ttoo tthhee UUAARRTT
**//
iinntt3322
aavvaaiill;;
//** AAvvaaiillaabbllee cchhaarrss iinn oouuttppuutt bbuuff**//
iinntt3322
uussppaaccee;;
//** SSppaaccee lleefftt iinn oonnbbooaarrdd UUAARRTT
**//
//**
oouuttppuutt FFIIFFOO
**//
bbyyttee
iieerr == 00;;
//** IIff oouuttppuutt iiss ccuurrrreennttllyy hheelldd,, ssiimmppllyy iiggnnoorree tthhee ccaallll **//
iiff ((ttyyppttrr-->>ttyyoohheelldd)) {{
rreettuurrnn;;
}} 
//** IIff eecchhoo aanndd oouuttppuutt qquueeuueess eemmppttyy,, ttuurrnn ooffff iinntteerrrruuppttss **//
iiff (( ((ttyyppttrr-->>ttyyeehheeaadd ==== ttyyppttrr-->>ttyyeettaaiill)) &&&&
((sseemmccoouunntt((ttyyppttrr-->>ttyyoosseemm)) >>== TTYY__OOBBUUFFLLEENN)) )) {{
iieerr == ccssrrppttrr-->>iieerr;;
ccssrrppttrr-->>iieerr == iieerr && ~~UUAARRTT__IIEERR__EETTBBEEII;;
rreettuurrnn;;
}} 
//** IInniittiiaalliizzee uussppaaccee ttoo tthhee ssiizzee ooff tthhee ttrraannssmmiitt FFIIFFOO **//

Sec. 15.17        Output Interrupt Processing (ttyhandle_out) 
307
uussppaaccee == UUAARRTT__FFIIFFOO__SSIIZZEE;;
//** WWhhiillee oonnbbooaarrdd FFIIFFOO iiss nnoott ffuullll aanndd tthhee eecchhoo qquueeuuee iiss **//
//**
nnoonneemmppttyy,, xxmmiitt cchhaarrss ffrroomm tthhee eecchhoo qquueeuuee
**//
wwhhiillee (( ((uussppaaccee>>00)) &&&&
ttyyppttrr-->>ttyyeehheeaadd !!== ttyyppttrr-->>ttyyeettaaiill)) {{
ccssrrppttrr-->>bbuuffffeerr == **ttyyppttrr-->>ttyyeehheeaadd++++;;
iiff ((ttyyppttrr-->>ttyyeehheeaadd >>== &&ttyyppttrr-->>ttyyeebbuuffff[[TTYY__EEBBUUFFLLEENN]])) {{
ttyyppttrr-->>ttyyeehheeaadd == ttyyppttrr-->>ttyyeebbuuffff;;
}} 
uussppaaccee----;;
}} 
//** WWhhiillee oonnbbooaarrdd FFIIFFOO iiss nnoott ffuullll aanndd tthhee oouuttppuutt qquueeuuee iiss
**//
//**
nnoonneemmppttyy,, ttrraannssmmiitt cchhaarrss ffrroomm tthhee oouuttppuutt qquueeuuee
**//
oocchhaarrss == 00;;
aavvaaiill == TTYY__OOBBUUFFLLEENN -- sseemmccoouunntt((ttyyppttrr-->>ttyyoosseemm));;
wwhhiillee (( ((uussppaaccee>>00)) &&&&
((aavvaaiill >> 00)) )) {{
ccssrrppttrr-->>bbuuffffeerr == **ttyyppttrr-->>ttyyoohheeaadd++++;;
iiff ((ttyyppttrr-->>ttyyoohheeaadd >>== &&ttyyppttrr-->>ttyyoobbuuffff[[TTYY__OOBBUUFFLLEENN]])) {{
ttyyppttrr-->>ttyyoohheeaadd == ttyyppttrr-->>ttyyoobbuuffff;;
}} 
aavvaaiill----;;
uussppaaccee----;;
oocchhaarrss++++;;
}} 
iiff ((oocchhaarrss >> 00)) {{
ssiiggnnaallnn((ttyyppttrr-->>ttyyoosseemm,, oocchhaarrss));;
}} 
rreettuurrnn;;
}}
Ttyhandle_out makes a series of tests before starting output. For example, output 
should not be started if a user has entered control-S. Similarly, there is no need to start 
output if both the echo and output queues are empty. To understand how ttyhandle_out 
starts output, recall that the underlying hardware has an onboard FIFO that can hold 
multiple outgoing characters. Once it has determined that output should proceed, 
ttyhandle_out can send up to UART_FIFO_SIZE (16) characters to the device. Charac-
ters are sent until the FIFO is full or the buffers are empty, whichever occurs first. The 
echo queue has highest priority. Therefore, ttyhandle_out first sends characters from 
the echo queue. If slots remain in the FIFO, ttyhandle_out sends characters from the 
output queue.
Each time it removes a character from the output queue, ttyhandle_out should sig-
nal the output semaphore to indicate that another space is available in the buffer. Be-
cause a call to signal can reschedule, however, ttyhandle_out does not call signal im-

308 
An Example Device Driver 
Chap. 15
mediately. Instead, it increments variable ochars to count the number of slots being 
created. Once it has filled the FIFO (or has emptied the output queue), ttyhandle_out 
calls signaln to indicate that space is available in the buffer.
15.18 Tty Input Processing (ttyhandle_in)
Input interrupt processing is more complex than output processing because the on-
board input FIFO can contain more than one character. Thus, to handle an input inter-
rupt, ttyhandler† enters a loop: while the onboard FIFO is not empty, ttyhandler calls 
ttyhandle_in, which extracts and processes one character from the UART’s input FIFO. 
To prevent rescheduling until the loop completes and all characters have been extracted 
from the device, ttyhandler uses resched_cntl. Thus, although ttyhandle_in calls signal 
to make each character available, no rescheduling occurs until all available characters 
have been extracted from the device.
Processing individual input characters is the most complex part of the tty device 
driver because it includes code for details such as character echo and line editing. 
Function ttyhandle_in handles the processing for raw, cbreak, and cooked modes. File 
ttyhandle_in.c contains the code.
//** ttttyyhhaannddllee__iinn..cc -- ttttyyhhaannddllee__iinn,, eerraassee11,, eeppuuttcc,, eecchhoocchh **//
##iinncclluuddee <<xxiinnuu..hh>>
llooccaall
vvooiidd
eerraassee11((ssttrruucctt ttttyyccbbllkk **,, ssttrruucctt uuaarrtt__ccssrreegg **));;
llooccaall
vvooiidd
eecchhoocchh((cchhaarr,, ssttrruucctt ttttyyccbbllkk **,, ssttrruucctt uuaarrtt__ccssrreegg **));;
llooccaall
vvooiidd
eeppuuttcc((cchhaarr,, ssttrruucctt ttttyyccbbllkk **,, ssttrruucctt uuaarrtt__ccssrreegg **));;
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ttttyyhhaannddllee__iinn
--
HHaannddllee oonnee aarrrriivviinngg cchhaarr ((iinntteerrrruuppttss ddiissaabblleedd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
ttttyyhhaannddllee__iinn ((
ssttrruucctt ttttyyccbbllkk **ttyyppttrr,,
//** PPooiinntteerr ttoo ttttyyttaabb eennttrryy
**//
ssttrruucctt uuaarrtt__ccssrreegg **ccssrrppttrr
//** AAddddrreessss ooff UUAARRTT’’ss CCSSRR
**//
))
{{
cchhaarr
cchh;;
//** NNeexxtt cchhaarr ffrroomm ddeevviiccee
**//
iinntt3322
aavvaaiill;;
//** CChhaarrss aavvaaiillaabbllee iinn bbuuffffeerr
**//
cchh == ccssrrppttrr-->>bbuuffffeerr;;
//** CCoommppuuttee cchhaarrss aavvaaiillaabbllee **//

†The code for ttyhandler can be found on page 304.

Sec. 15.18        Tty Input Processing (ttyhandle_in) 
309
aavvaaiill == sseemmccoouunntt((ttyyppttrr-->>ttyyiisseemm));;
iiff ((aavvaaiill << 00)) {{
//** OOnnee oorr mmoorree pprroocceesssseess wwaaiittiinngg**//
aavvaaiill == 00;;
}} 
//** HHaannddllee rraaww mmooddee **//
iiff ((ttyyppttrr-->>ttyyiimmooddee ==== TTYY__IIMMRRAAWW)) {{
iiff ((aavvaaiill >>== TTYY__IIBBUUFFLLEENN)) {{ //** NNoo ssppaaccee ==>> iiggnnoorree iinnppuutt
**//
rreettuurrnn;;
}} 
//** PPllaaccee cchhaarr iinn bbuuffffeerr wwiitthh nnoo eeddiittiinngg **//
**ttyyppttrr-->>ttyyiittaaiill++++ == cchh;;
//** WWrraapp bbuuffffeerr ppooiinntteerr
**//
iiff ((ttyyppttrr-->>ttyyoottaaiill >>== &&ttyyppttrr-->>ttyyoobbuuffff[[TTYY__OOBBUUFFLLEENN]])) {{
ttyyppttrr-->>ttyyoottaaiill == ttyyppttrr-->>ttyyoobbuuffff;;
}} 
//** SSiiggnnaall iinnppuutt sseemmaapphhoorree aanndd rreettuurrnn **//
ssiiggnnaall((ttyyppttrr-->>ttyyiisseemm));;
rreettuurrnn;;
}} 
//** HHaannddllee ccooookkeedd aanndd ccbbrreeaakk mmooddeess ((ccoommmmoonn ppaarrtt)) **//
iiff (( ((cchh ==== TTYY__RREETTUURRNN)) &&&& ttyyppttrr-->>ttyyiiccrrllff )) {{
cchh == TTYY__NNEEWWLLIINNEE;;
}} 
//** IIff ffllooww ccoonnttrrooll iiss iinn eeffffeecctt,, hhaannddllee ^^SS aanndd ^^QQ **//
iiff ((ttyyppttrr-->>ttyyooffllooww)) {{
iiff ((cchh ==== ttyyppttrr-->>ttyyoossttaarrtt)) {{
//** ^^QQ ssttaarrttss oouuttppuutt **//
ttyyppttrr-->>ttyyoohheelldd == FFAALLSSEE;;
ttttyykkiicckkoouutt((ccssrrppttrr));;
rreettuurrnn;;
}} eellssee iiff ((cchh ==== ttyyppttrr-->>ttyyoossttoopp)) {{
//** ^^SS ssttooppss oouuttppuutt
**//
ttyyppttrr-->>ttyyoohheelldd == TTRRUUEE;;
rreettuurrnn;;
}}
}}

310 
An Example Device Driver 
Chap. 15
ttyyppttrr-->>ttyyoohheelldd == FFAALLSSEE;;
//** AAnnyy ootthheerr cchhaarr ssttaarrttss oouuttppuutt **//
iiff ((ttyyppttrr-->>ttyyiimmooddee ==== TTYY__IIMMCCBBRREEAAKK)) {{
//** JJuusstt ccbbrreeaakk mmooddee
**//
//** IIff iinnppuutt bbuuffffeerr iiss ffuullll,, sseenndd bbeellll ttoo uusseerr **//
iiff ((aavvaaiill >>== TTYY__IIBBUUFFLLEENN)) {{
eeppuuttcc((ttyyppttrr-->>ttyyiiffuullllcc,, ttyyppttrr,, ccssrrppttrr));;
}} eellssee {{
//** IInnppuutt bbuuffffeerr hhaass ssppaaccee ffoorr tthhiiss cchhaarr **//
**ttyyppttrr-->>ttyyiittaaiill++++ == cchh;;
//** WWrraapp aarroouunndd bbuuffffeerr **//
iiff ((ttyyppttrr-->>ttyyiittaaiill>>==&&ttyyppttrr-->>ttyyiibbuuffff[[TTYY__IIBBUUFFLLEENN]])) {{
ttyyppttrr-->>ttyyiittaaiill == ttyyppttrr-->>ttyyiibbuuffff;;
}} 
iiff ((ttyyppttrr-->>ttyyiieecchhoo)) {{
//** AArree wwee eecchhooiinngg cchhaarrss??**//
eecchhoocchh((cchh,, ttyyppttrr,, ccssrrppttrr));;
}}
}} 
rreettuurrnn;;
}} eellssee {{
//** JJuusstt ccooookkeedd mmooddee ((sseeee ccoommmmoonn ccooddee aabboovvee)) **//
//** LLiinnee kkiillll cchhaarraacctteerr aarrrriivveess -- kkiillll eennttiirree lliinnee **//
iiff ((cchh ==== ttyyppttrr-->>ttyyiikkiillllcc &&&& ttyyppttrr-->>ttyyiikkiillll)) {{
ttyyppttrr-->>ttyyiittaaiill --== ttyyppttrr-->>ttyyiiccuurrssoorr;;
iiff ((ttyyppttrr-->>ttyyiittaaiill << ttyyppttrr-->>ttyyiibbuuffff)) {{
ttyyppttrr-->>ttyyiihheeaadd ++== TTYY__IIBBUUFFLLEENN;;
}} 
ttyyppttrr-->>ttyyiiccuurrssoorr == 00;;
eeppuuttcc((TTYY__RREETTUURRNN,, ttyyppttrr,, ccssrrppttrr));;
eeppuuttcc((TTYY__NNEEWWLLIINNEE,, ttyyppttrr,, ccssrrppttrr));;
rreettuurrnn;;
}} 
//** EErraassee ((bbaacckkssppaaccee)) cchhaarraacctteerr **//
iiff (( ((((cchh====ttyyppttrr-->>ttyyiieerraasseecc)) |||| ((cchh====ttyyppttrr-->>ttyyiieerraasseecc22))))
&&&& ttyyppttrr-->>ttyyiieerraassee)) {{
iiff ((ttyyppttrr-->>ttyyiiccuurrssoorr >> 00)) {{
ttyyppttrr-->>ttyyiiccuurrssoorr----;;
eerraassee11((ttyyppttrr,, ccssrrppttrr));;
}} 
rreettuurrnn;;
}}

Sec. 15.18        Tty Input Processing (ttyhandle_in) 
311
//** EEnndd ooff lliinnee **//
iiff (( ((cchh ==== TTYY__NNEEWWLLIINNEE)) |||| ((cchh ==== TTYY__RREETTUURRNN)) )) {{
iiff ((ttyyppttrr-->>ttyyiieecchhoo)) {{
eecchhoocchh((cchh,, ttyyppttrr,, ccssrrppttrr));;
}} 
**ttyyppttrr-->>ttyyiittaaiill++++ == cchh;;
iiff ((ttyyppttrr-->>ttyyiittaaiill>>==&&ttyyppttrr-->>ttyyiibbuuffff[[TTYY__IIBBUUFFLLEENN]])) {{
ttyyppttrr-->>ttyyiittaaiill == ttyyppttrr-->>ttyyiibbuuffff;;
}} 
//** MMaakkee eennttiirree lliinnee ((pplluuss \\nn oorr \\rr)) aavvaaiillaabbllee **//
ssiiggnnaallnn((ttyyppttrr-->>ttyyiisseemm,, ttyyppttrr-->>ttyyiiccuurrssoorr ++ 11));;
ttyyppttrr-->>ttyyiiccuurrssoorr == 00;;
//** RReesseett ffoorr nneexxtt lliinnee
**//
rreettuurrnn;;
}} 
//** CChhaarraacctteerr ttoo bbee ppllaacceedd iinn bbuuffffeerr -- sseenndd bbeellll iiff
**//
//**
bbuuffffeerr hhaass oovveerrfflloowweedd
**//
aavvaaiill == sseemmccoouunntt((ttyyppttrr-->>ttyyiisseemm));;
iiff ((aavvaaiill << 00)) {{
aavvaaiill == 00;;
}} 
iiff ((((aavvaaiill ++ ttyyppttrr-->>ttyyiiccuurrssoorr)) >>== TTYY__IIBBUUFFLLEENN--11)) {{
eeppuuttcc((ttyyppttrr-->>ttyyiiffuullllcc,, ttyyppttrr,, ccssrrppttrr));;
rreettuurrnn;;
}} 
//** EEOOFF cchhaarraacctteerr:: rreeccooggnniizzee aatt bbeeggiinnnniinngg ooff lliinnee,, bbuutt
**//
//**
pprriinntt aanndd iiggnnoorree ootthheerrwwiissee..
**//
iiff ((cchh ==== ttyyppttrr-->>ttyyeeooffcchh &&&& ttyyppttrr-->>ttyyeeooff)) {{
iiff ((ttyyppttrr-->>ttyyiieecchhoo)) {{
eecchhoocchh((cchh,, ttyyppttrr,, ccssrrppttrr));;
}} 
iiff ((ttyyppttrr-->>ttyyiiccuurrssoorr !!== 00)) {{
rreettuurrnn;;
}} 
**ttyyppttrr-->>ttyyiittaaiill++++ == cchh;;
ssiiggnnaall((ttyyppttrr-->>ttyyiisseemm));;
rreettuurrnn;;
}} 
//** EEcchhoo tthhee cchhaarraacctteerr **//

312 
An Example Device Driver 
Chap. 15
iiff ((ttyyppttrr-->>ttyyiieecchhoo)) {{
eecchhoocchh((cchh,, ttyyppttrr,, ccssrrppttrr));;
}} 
//** IInnsseerrtt iinn tthhee iinnppuutt bbuuffffeerr **//
ttyyppttrr-->>ttyyiiccuurrssoorr++++;;
**ttyyppttrr-->>ttyyiittaaiill++++ == cchh;;
//** WWrraapp aarroouunndd iiff nneeeeddeedd **//
iiff ((ttyyppttrr-->>ttyyiittaaiill >>== &&ttyyppttrr-->>ttyyiibbuuffff[[TTYY__IIBBUUFFLLEENN]])) {{
ttyyppttrr-->>ttyyiittaaiill == ttyyppttrr-->>ttyyiibbuuffff;;
}} 
rreettuurrnn;;
}}
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
eerraassee11
--
EErraassee oonnee cchhaarraacctteerr hhoonnoorriinngg eerraassiinngg bbaacckkssppaaccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
llooccaall
vvooiidd
eerraassee11((
ssttrruucctt ttttyyccbbllkk
**ttyyppttrr,, //** PPttrr ttoo ttttyyttaabb eennttrryy
**//
ssttrruucctt uuaarrtt__ccssrreegg
**ccssrrppttrr //** AAddddrreessss ooff UUAARRTT’’ss CCSSRRss
**//
))
{{
cchhaarr
cchh;;
//** CChhaarraacctteerr ttoo eerraassee
**//
iiff (( ((----ttyyppttrr-->>ttyyiittaaiill)) << ttyyppttrr-->>ttyyiibbuuffff)) {{
ttyyppttrr-->>ttyyiittaaiill ++== TTYY__IIBBUUFFLLEENN;;
}} 
//** PPiicckk uupp cchhaarr ttoo eerraassee **//
cchh == **ttyyppttrr-->>ttyyiittaaiill;;
iiff ((ttyyppttrr-->>ttyyiieecchhoo)) {{
//** AArree wwee eecchhooiinngg??
**//
iiff ((cchh << TTYY__BBLLAANNKK |||| cchh ==== 00117777)) {{ //** NNoonnpprriinnttaabbllee
**//
iiff ((ttyyppttrr-->>ttyyeevviiss)) {{
//** VViissuuaall ccnnttll cchhaarrss **//
eeppuuttcc((TTYY__BBAACCKKSSPP,, ttyyppttrr,, ccssrrppttrr));;
iiff ((ttyyppttrr-->>ttyyiieebbaacckk)) {{ //** EErraassee cchhaarr
**//
eeppuuttcc((TTYY__BBLLAANNKK,, ttyyppttrr,, ccssrrppttrr));;
eeppuuttcc((TTYY__BBAACCKKSSPP,, ttyyppttrr,, ccssrrppttrr));;
}}
}}

Sec. 15.18        Tty Input Processing (ttyhandle_in) 
313
eeppuuttcc((TTYY__BBAACCKKSSPP,, ttyyppttrr,, ccssrrppttrr));;//** BByyppaassss uupp aarrrr**//
iiff ((ttyyppttrr-->>ttyyiieebbaacckk)) {{
eeppuuttcc((TTYY__BBLLAANNKK,, ttyyppttrr,, ccssrrppttrr));;
eeppuuttcc((TTYY__BBAACCKKSSPP,, ttyyppttrr,, ccssrrppttrr));;
}}
}} eellssee {{
//** AA nnoorrmmaall cchhaarraacctteerr tthhaatt iiss pprriinnttaabbllee
**//
eeppuuttcc((TTYY__BBAACCKKSSPP,, ttyyppttrr,, ccssrrppttrr));;
iiff ((ttyyppttrr-->>ttyyiieebbaacckk)) {{
//** eerraassee tthhee cchhaarraacctteerr
**//
eeppuuttcc((TTYY__BBLLAANNKK,, ttyyppttrr,, ccssrrppttrr));;
eeppuuttcc((TTYY__BBAACCKKSSPP,, ttyyppttrr,, ccssrrppttrr));;
}}
}}
}} 
rreettuurrnn;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
eecchhoocchh
--
EEcchhoo aa cchhaarraacctteerr wwiitthh vviissuuaall aanndd oouuttppuutt ccrrllff ooppttiioonnss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
llooccaall
vvooiidd
eecchhoocchh((
cchhaarr
cchh,,
//** CChhaarraacctteerr ttoo eecchhoo
**//
ssttrruucctt ttttyyccbbllkk **ttyyppttrr,,
//** PPttrr ttoo ttttyyttaabb eennttrryy
**//
ssttrruucctt uuaarrtt__ccssrreegg **ccssrrppttrr
//** AAddddrreessss ooff UUAARRTT’’ss CCSSRRss
**//
))
{{
iiff ((((cchh====TTYY__NNEEWWLLIINNEE |||| cchh====TTYY__RREETTUURRNN)) &&&& ttyyppttrr-->>ttyyeeccrrllff)) {{
eeppuuttcc((TTYY__RREETTUURRNN,, ttyyppttrr,, ccssrrppttrr));;
eeppuuttcc((TTYY__NNEEWWLLIINNEE,, ttyyppttrr,, ccssrrppttrr));;
}} eellssee iiff (( ((cchh<<TTYY__BBLLAANNKK||||cchh====00117777)) &&&& ttyyppttrr-->>ttyyeevviiss)) {{
eeppuuttcc((TTYY__UUPPAARRRROOWW,, ttyyppttrr,, ccssrrppttrr));;//** pprriinntt ^^xx
**//
eeppuuttcc((cchh++00110000,, ttyyppttrr,, ccssrrppttrr));;
//** MMaakkee iitt pprriinnttaabbllee
**//
}} eellssee {{
eeppuuttcc((cchh,, ttyyppttrr,, ccssrrppttrr));;
}}
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
eeppuuttcc
--
PPuutt oonnee cchhaarraacctteerr iinn tthhee eecchhoo qquueeuuee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
llooccaall
vvooiidd
eeppuuttcc((
cchhaarr
cchh,,
//** CChhaarraacctteerr ttoo eecchhoo
**//
ssttrruucctt ttttyyccbbllkk **ttyyppttrr,,
//** PPttrr ttoo ttttyyttaabb eennttrryy
**//
ssttrruucctt uuaarrtt__ccssrreegg **ccssrrppttrr
//** AAddddrreessss ooff UUAARRTT’’ss CCSSRRss
**//
))

314 
An Example Device Driver 
Chap. 15
{{
**ttyyppttrr-->>ttyyeettaaiill++++ == cchh;;
//** WWrraapp aarroouunndd bbuuffffeerr,, iiff nneeeeddeedd **//
iiff ((ttyyppttrr-->>ttyyeettaaiill >>== &&ttyyppttrr-->>ttyyeebbuuffff[[TTYY__EEBBUUFFLLEENN]])) {{
ttyyppttrr-->>ttyyeettaaiill == ttyyppttrr-->>ttyyeebbuuffff;;
}} 
ttttyykkiicckkoouutt((ccssrrppttrr));;
rreettuurrnn;;
}}
15.18.1  Raw Mode Processing
Raw mode is the easiest to understand, and accounts for only a few lines of code.
In raw mode, ttyhandle_in checks the input buffer to verify that space remains. To do
so, it compares the count of the input semaphore (i.e., the number of characters that are 
currently in the buffer) to the buffer size. If no space remains in the buffer, 
ttyhandle_in merely returns to the handler (i.e., it discards the character). If space 
remains, ttyhandle_in deposits the character at the tail of the input buffer, moves to the 
next buffer position, signals the input semaphore, and returns.
15.18.2  Cbreak Mode Processing
Cooked and cbreak mode share code that maps RETURN to NEWLINE and handles 
output flow control. Field tyoflow of the tty control block determines whether the
driver currently honors flow control. If it does, the driver suspends output by setting 
tyoheld to TRUE when it receives character tyostop, and restarts output when it receives 
character tyostart. Characters tyostart and tyostop are considered “control” characters, 
so the driver does not place them in the buffer.
Cbreak mode checks the input buffer, and sends character tyifullc if the buffer is
full. Normally, tyifullc is a “bell” that causes the terminal to sound an audible alarm;
the idea is that a human who is typing characters will hear the alarm and stop typing
until characters have been read and more buffer space becomes available. If the buffer
is not full, the code places the character in the buffer, and wraps around the pointer, if 
necessary. Finally, cbreak mode calls echoch to perform character echo.
15.18.3  Cooked Mode Processing
Cooked mode operates like cbreak mode except that it also performs line editing. 
The driver accumulates lines in the input buffer, using variable tyicursor to keep a count 
of the characters on the “current” line. When the erase character, tyierasec, arrives, 
ttyhandle_in decrements tyicursor by one, backing up over the previous character, and

Sec. 15.18        Tty Input Processing (ttyhandle_in) 
315
calling function erase1 to erase the character from the display. When the line kill char-
acter, tyikillc, arrives, ttyhandle_in eliminates the current line by setting tyicursor to 
zero and moving the tail pointer back to the beginning of the line. Finally, when a 
NEWLINE or RETURN character arrives, ttyhandle_in calls signaln to make the entire 
input line available. It resets tyicursor to zero for the next line. Note that the test for 
buffer full always leaves one extra space in the buffer for the end-of-line character (i.e., 
a NEWLINE).
15.19 Tty Control Block Initialization (ttyinit)
Function ttyinit, shown below in file ttyinit.c, is called once for each tty device. 
The parameter, devptr, is a pointer to the device switch table entry for a tty device. 
Ttyinit extracts the minor device number from the device switch table, uses the number 
as an index into the ttytab array, and sets typtr to the tty control block for the device. 
Ttyinit then initializes each field in the control block, setting the device to cooked mode, 
creating the input and output semaphores, and assigning head and tail pointers to indi-
cate that buffers are empty. After driver parameters and buffers have been initialized, 
ttyinit sets variable csrptr to the CSR address of the UART hardware. It then sets the 
baud rate, sets the bits per character, turns off hardware parity checking, and sets the 
number of RS-232 stop bits to 1. Finally, ttyinit disables transmitter interrupts tem-
porarily.
Once the basic hardware initialization has been completed, ttyinit calls set_evec to
set the interrupt vector to the interrupt function given in the device switch table. After
the interrupt vector has been set, ttyinit finishes the last steps of hardware initialization:
it resets the hardware to permit both transmit and receive interrupts, and calls ttykickout
to start output.
Ttyinit assumes a tty will be associated with a keyboard and display that a human 
will use. Consequently, ttyinit initializes a tty to cooked mode, and sets parameters as-
suming a video device that can backspace over characters on the display and erase 
them. In particular, the parameter tyieback causes ttyhandle_in to echo three characters, 
backspace-space-backspace, when it receives the erase character, tyierasec.
On a
 
display screen, sending the three-character sequence gives the effect of erasing charac-
ters as the user backs over them. If you look again at ttyhandle_in,† you will see that it 
carefully backs up the correct number of spaces, even if the user erases a control char-
acter that has been displayed as two printable characters.

†The code for ttyhandle_in can be found on page 308.

316 
An Example Device Driver 
Chap. 15
//** ttttyyiinniitt..cc -- ttttyyiinniitt **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt
ttttyyccbbllkk ttttyyttaabb[[NNttttyy]];;
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ttttyyiinniitt
--
IInniittiiaalliizzee bbuuffffeerrss aanndd mmooddeess ffoorr aa ttttyy lliinnee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll ttttyyiinniitt((
ssttrruucctt ddeennttrryy **ddeevvppttrr
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
))
{{
ssttrruucctt
ttttyyccbbllkk **ttyyppttrr;;
//** PPooiinntteerr ttoo ttttyyttaabb eennttrryy
**//
ssttrruucctt
uuaarrtt__ccssrreegg **uuppttrr;;
//** AAddddrreessss ooff UUAARRTT’’ss CCSSRRss
**//
ttyyppttrr == &&ttttyyttaabb[[ ddeevvppttrr-->>ddvvmmiinnoorr ]];;
//** IInniittiiaalliizzee vvaalluueess iinn tthhee ttttyy ccoonnttrrooll bblloocckk **//
ttyyppttrr-->>ttyyiihheeaadd == ttyyppttrr-->>ttyyiittaaiill ==
//** SSeett uupp iinnppuutt qquueeuuee
**//
&&ttyyppttrr-->>ttyyiibbuuffff[[00]];;
//**
aass eemmppttyy
**//
ttyyppttrr-->>ttyyiisseemm == sseemmccrreeaattee((00));;
//** IInnppuutt sseemmaapphhoorree
**//
ttyyppttrr-->>ttyyoohheeaadd == ttyyppttrr-->>ttyyoottaaiill ==
//** SSeett uupp oouuttppuutt qquueeuuee
**//
&&ttyyppttrr-->>ttyyoobbuuffff[[00]];;
//**
aass eemmppttyy
**//
ttyyppttrr-->>ttyyoosseemm == sseemmccrreeaattee((TTYY__OOBBUUFFLLEENN));;
//** OOuuttppuutt sseemmaapphhoorree
**//
ttyyppttrr-->>ttyyeehheeaadd == ttyyppttrr-->>ttyyeettaaiill ==
//** SSeett uupp eecchhoo qquueeuuee
**//
&&ttyyppttrr-->>ttyyeebbuuffff[[00]];;
//**
aass eemmppttyy
**//
ttyyppttrr-->>ttyyiimmooddee == TTYY__IIMMCCOOOOKKEEDD;;
//** SSttaarrtt iinn ccooookkeedd mmooddee **//
ttyyppttrr-->>ttyyiieecchhoo == TTRRUUEE;;
//** EEcchhoo ccoonnssoollee iinnppuutt
**//
ttyyppttrr-->>ttyyiieebbaacckk == TTRRUUEE;;
//** HHoonnoorr eerraassiinngg bbkksspp
**//
ttyyppttrr-->>ttyyeevviiss == TTRRUUEE;;
//** VViissuuaall ccoonnttrrooll cchhaarrss **//
ttyyppttrr-->>ttyyeeccrrllff == TTRRUUEE;;
//** EEcchhoo CCRRLLFF ffoorr NNEEWWLLIINNEE**//
ttyyppttrr-->>ttyyiiccrrllff == TTRRUUEE;;
//** MMaapp CCRR ttoo NNEEWWLLIINNEE
**//
ttyyppttrr-->>ttyyiieerraassee == TTRRUUEE;;
//** DDoo eerraassiinngg bbaacckkssppaaccee **//
ttyyppttrr-->>ttyyiieerraasseecc == TTYY__BBAACCKKSSPP;;
//** PPrriimmaarryy eerraassee cchhaarr
**//
ttyyppttrr-->>ttyyiieerraasseecc22== TTYY__BBAACCKKSSPP22;;
//** AAlltteerrnnaattee eerraassee cchhaarr **//
ttyyppttrr-->>ttyyeeooff == TTRRUUEE;;
//** HHoonnoorr eeooff oonn iinnppuutt
**//
ttyyppttrr-->>ttyyeeooffcchh == TTYY__EEOOFFCCHH;;
//** EEnndd--ooff--ffiillee cchhaarraacctteerr**//
ttyyppttrr-->>ttyyiikkiillll == TTRRUUEE;;
//** AAllllooww lliinnee kkiillll
**//
ttyyppttrr-->>ttyyiikkiillllcc == TTYY__KKIILLLLCCHH;;
//** SSeett lliinnee kkiillll ttoo ^^UU
**//
ttyyppttrr-->>ttyyiiccuurrssoorr == 00;;
//** SSttaarrtt ooff iinnppuutt lliinnee
**//
ttyyppttrr-->>ttyyooffllooww == TTRRUUEE;;
//** HHaannddllee ffllooww ccoonnttrrooll
**//
ttyyppttrr-->>ttyyoohheelldd == FFAALLSSEE;;
//** OOuuttppuutt nnoott hheelldd
**//

Sec. 15.19        Tty Control Block Initialization (ttyinit) 
317
ttyyppttrr-->>ttyyoossttoopp == TTYY__SSTTOOPPCCHH;;
//** SSttoopp cchhaarr iiss ^^SS
**//
ttyyppttrr-->>ttyyoossttaarrtt == TTYY__SSTTRRTTCCHH;;
//** SSttaarrtt cchhaarr iiss ^^QQ
**//
ttyyppttrr-->>ttyyooccrrllff == TTRRUUEE;;
//** SSeenndd CCRRLLFF ffoorr NNEEWWLLIINNEE**//
ttyyppttrr-->>ttyyiiffuullllcc == TTYY__FFUULLLLCCHH;;
//** SSeenndd ^^GG wwhheenn bbuuffffeerr
**//
//**
iiss ffuullll
**//
//** IInniittiiaalliizzee tthhee UUAARRTT **//
uuppttrr == ((ssttrruucctt uuaarrtt__ccssrreegg **))ddeevvppttrr-->>ddvvccssrr;;
//** SSeett bbaauudd rraattee **//
uuppttrr-->>llccrr == UUAARRTT__LLCCRR__DDLLAABB;;
uuppttrr-->>ddllmm == 00xx0000;;
uuppttrr-->>ddllll == 00xx1188;;
uuppttrr-->>llccrr == UUAARRTT__LLCCRR__88NN11;;
//** 88 bbiitt cchhaarr,, NNoo PPaarriittyy,, 11 SSttoopp**//
uuppttrr-->>ffccrr == 00xx0000;;
//** DDiissaabbllee FFIIFFOO ffoorr nnooww
**//
//** RReeggiisstteerr tthhee iinntteerrrruupptt ddiissppaattcchheerr ffoorr tthhee ttttyy ddeevviiccee **//
sseett__eevveecc(( ddeevvppttrr-->>ddvviirrqq,, ((uuiinntt3322))ddeevvppttrr-->>ddvviinnttrr ));;
//** EEnnaabbllee iinntteerrrruuppttss oonn tthhee ddeevviiccee:: rreesseett tthhee ttrraannssmmiitt aanndd
**//
//**
rreecceeiivvee FFIIFFOOSS,, aanndd sseett tthhee iinntteerrrruupptt ttrriiggggeerr lleevveell
**//
uuppttrr-->>ffccrr == UUAARRTT__FFCCRR__EEFFIIFFOO || UUAARRTT__FFCCRR__RRRREESSEETT ||
UUAARRTT__FFCCRR__TTRREESSEETT || UUAARRTT__FFCCRR__TTRRIIGG22;;
//** SSttaarrtt tthhee ddeevviiccee **//
ttttyykkiicckkoouutt((uuppttrr));;
rreettuurrnn OOKK;;
}}
15.20 Device Driver Control (ttycontrol)
So far we have discussed driver functions that handle upper-half data transfer 
operations (e.g., read and write), functions that handle lower-half input and output inter-
rupts, and an initialization function that sets parameters at system startup. The I/O in-
terface defined in Chapter 14 provides another type of non-transfer function: control. 
Basically, control allows an application to control the device driver or the underlying 
device. In our example driver, function ttycontrol, found in file ttycontrol.c, provides 
basic control functions:

318 
An Example Device Driver 
Chap. 15
//** ttttyyccoonnttrrooll..cc -- ttttyyccoonnttrrooll **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
ttttyyccoonnttrrooll
--
CCoonnttrrooll aa ttttyy ddeevviiccee bbyy sseettttiinngg mmooddeess
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll ttttyyccoonnttrrooll((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
iinntt3322
ffuunncc,,
//** FFuunnccttiioonn ttoo ppeerrffoorrmm
**//
iinntt3322
aarrgg11,,
//** AArrgguummeenntt 11 ffoorr rreeqquueesstt
**//
iinntt3322
aarrgg22
//** AArrgguummeenntt 22 ffoorr rreeqquueesstt
**//
))
{{
ssttrruucctt
ttttyyccbbllkk **ttyyppttrr;;
//** PPooiinntteerr ttoo ttttyy ccoonnttrrooll bblloocckk **//
cchhaarr
cchh;;
//** CChhaarraacctteerr ffoorr llooookkaahheeaadd
**//
ttyyppttrr == &&ttttyyttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
//** PPrroocceessss tthhee rreeqquueesstt **//
sswwiittcchh (( ffuunncc )) {{
ccaassee TTCC__NNEEXXTTCC::
wwaaiitt((ttyyppttrr-->>ttyyiisseemm));;
cchh == **ttyyppttrr-->>ttyyiittaaiill;;
ssiiggnnaall((ttyyppttrr-->>ttyyiisseemm));;
rreettuurrnn ((ddeevvccaallll))cchh;;
ccaassee TTCC__MMOODDEERR::
ttyyppttrr-->>ttyyiimmooddee == TTYY__IIMMRRAAWW;;
rreettuurrnn ((ddeevvccaallll))OOKK;;
ccaassee TTCC__MMOODDEECC::
ttyyppttrr-->>ttyyiimmooddee == TTYY__IIMMCCOOOOKKEEDD;;
rreettuurrnn ((ddeevvccaallll))OOKK;;
ccaassee TTCC__MMOODDEEKK::
ttyyppttrr-->>ttyyiimmooddee == TTYY__IIMMCCBBRREEAAKK;;
rreettuurrnn ((ddeevvccaallll))OOKK;;
ccaassee TTCC__IICCHHAARRSS::
rreettuurrnn((sseemmccoouunntt((ttyyppttrr-->>ttyyiisseemm))));;

Sec. 15.20        Device Driver Control (ttycontrol) 
319
ccaassee TTCC__EECCHHOO::
ttyyppttrr-->>ttyyiieecchhoo == TTRRUUEE;;
rreettuurrnn ((ddeevvccaallll))OOKK;;
ccaassee TTCC__NNOOEECCHHOO::
ttyyppttrr-->>ttyyiieecchhoo == FFAALLSSEE;;
rreettuurrnn ((ddeevvccaallll))OOKK;;
ddeeffaauulltt::
rreettuurrnn ((ddeevvccaallll))SSYYSSEERRRR;;
}}
}}
The control interface for a tty device provides seven control functions (i.e., possi-
ble operations a process can perform on a tty device). Function TC_NEXTC allows an 
application to “lookahead” (i.e., obtain a copy of the next character waiting to be read 
without actually reading the character). Three of the control functions (TC_MODER, 
TC_MODEC, and TC_MODEK) allow a user to set the mode of a tty device to one of 
the three modes. Functions TC_ECHO and TC_NOECHO control character echo, al-
lowing a caller to turn off echo, accept input, and then turn echo back on. Finally, 
function TC_ICHARS allows a user to query the driver to determine how many charac-
ters are waiting in the input queue.
Observant readers may have noticed that neither parameter arg1 nor arg2 is used
in function ttycontrol. They have been declared, however, because the device-
independent I/O routine control always provides four arguments when calling a control 
function, such as ttycontrol. Although the compiler cannot perform type-checking on 
indirect function calls, omitting the argument declarations makes the code less portable 
and more difficult to understand.
15.21 Perspective
The length of the code in the chapter reveals an important point about device 
drivers. To understand the point, compare the amount of code used for a trivial serial 
device to the code used for message passing and process synchronization primitives 
(i.e., semaphores). Although message passing and semaphores each provide a powerful 
abstraction, the code is relatively small.
Why does a trivial device driver contain so much code? After all, the driver only 
makes it possible to read and write characters. The answer lies in the difference 
between the abstraction the hardware supplies and the abstraction the driver provides.
The underlying hardware merely transfers characters, and the output side is independent 
of the input side. Thus, the hardware does not handle flow control or character echo. 
Furthermore, the hardware knows nothing about end-of-line translation (i.e., the crlf 
mapping). Consequently, a driver must contain code that handles many details.

320 
An Example Device Driver 
Chap. 15
Although it may seem complex, the example driver in this chapter is trivial. A 
production device driver may comprise more than ten thousand lines of source code,
and may contain hundreds of functions. Drivers for devices that can be plugged in at 
runtime (e.g., a USB device) are even more complex than drivers for static devices. 
Thus, one should appreciate that taken as a whole, code for device drivers is both huge 
and extremely complex.
15.22 Summary
A device driver consists of a set of functions that control a peripheral hardware de-
vice. The driver routines are partitioned into two halves: an upper half that contains the 
functions called from applications, and a lower half that contains functions that the sys-
tem calls when a device interrupts. The two halves communicate through a shared data 
structure called a device control block.
The example device driver examined in the chapter implements a tty abstraction. 
It manages input and output over serial line hardware, such as the connection to a key-
board. Upper-half functions in the example driver implement read, write, getc, putc, 
and control operations. Each upper-half function is called indirectly through the 
device-switch table. Lower-half functions in the example driver handle interrupts. Dur-
ing an output interrupt, the lower half fills the onboard FIFO from the echo or output 
queues. During an input interrupt, the lower half extracts and processes characters from 
the input FIFO.
EXERCISES
15.1 
Predict what would happen if two processes executed ttyread concurrently when both re-
quested a large number of characters. Experiment and see what happens.
15.2 
Find a flaw in ttyputc that prevents it from working correctly in raw mode, and repair the
flaw. Hint: raw mode means all incoming characters are received without change.
15.3 
Kprintf uses polled I/O: it disables interrupts, waits until the device is idle, displays its
message, and then restores interrupts. What happens if the tty output buffer is full,
kprintf is called repeatedly, and each call displays a single NEWLINE character? Ex-
plain.
15.4 
The code in ttyhandle_out counts characters as they are removed from the buffer, and
then calls signaln to update the semaphore. Modify the code to use deferred reschedul-
ing. Which version is easier to understand? Which is more efficient? Explain.
15.5 
Some systems partition asynchronous device drivers into three levels: interrupt level to
do nothing but transfer characters to and from the device, upper level to transfer charac-
ters to and from the user, and a middle level to implement a line discipline that handles 
details like character echo, flow control, special processing, and out of band signals. 
Convert the Xinu tty driver to a three-level scheme, and arrange for a process to execute 
code in the middle layer.

Exercises
321
15.6 
Suppose two processes both attempt to use write() on the CONSOLE device concurrent-
ly. What will the output be? Why?
15.7 
Implement a control function that allows a process to obtain exclusive use of a tty device
(e.g., the CONSOLE) and another control function that the process can use to release its 
exclusive use.
15.8      Ttycontrol handles changes of mode poorly because it does not reset the cursor or buffer
pointers. Rewrite the code to improve it.
15.9 
When connecting two computers, it is useful to have flow control in both directions.
Modify the tty driver to include a “tandem” mode that sends Control-S when the input 
buffer is nearly full, and then sends Control-Q when the buffer is half empty.
15.10 
When a user changes the mode of a tty device, what should happen to characters already
in the input queue (which were accepted before the mode changed)? One possibility is
that the queue is discarded. Modify the code to implement discard during a mode
change.


Chapter Contents
16.1 
Introduction, 325
16.2 
Direct Memory Access And Buffers, 325
16.3 
Multiple Buffers And Rings, 326
16.4 
An Example Ethernet Driver Using DMA, 327
16.5 
Device Hardware Definitions And Constants, 328
16.6 
Rings And Buffers In Memory, 331
16.7 
Definitions Of An Ethernet Control Block, 333
16.8 
Device And Driver Initialization, 336
16.9 
Reading From An Ethernet Device, 343
16.10 Writing To An Ethernet Device, 347
16.11 Handling Interrupts From An Ethernet Device, 349 
16.12 Ethernet Control Functions, 352
16.13 Perspective, 353 
16.14 Summary, 354


16
DMA Devices And Drivers 
(Ethernet)
Modern hardware is stunningly difficult to deal with.
— James Buchanan
16.1 Introduction
Previous chapters on I/O present a general paradigm that uses a device switch
table, and explain how a device driver is organized. Chapter 15 shows an example
driver for a tty device, and uses the example to illustrate how the upper half and lower 
half interact.
This chapter extends our discussion of I/O by considering the design of device 
drivers for hardware devices that can transfer data from or to memory directly. The 
chapter presents an Ethernet device to show one example of how buffers are organized 
for such devices and how a device can access the buffers to perform both input and out-
put.
16.2 Direct Memory Access And Buffers
Although a bus can only transfer a word of data at one time, a block-oriented de-
vice, such as a disk or a network interface, needs to transfer multiple words of data to
fill a given request. The motivation for Direct Memory Access (DMA) is parallelism: 
adding intelligence to an I/O device allows the device to perform multiple bus transfers 
without interrupting the processor. Thus, when they use DMA, a disk device can
325

326 
DMA Devices And Drivers (Ethernet) 
Chap. 16
transfer an entire disk block between memory and the device before interrupting the 
processor and a network interface can transfer an entire packet before interrupting the 
processor.
DMA output is the easiest to understand. As an example, consider DMA output to 
a disk. To write a disk block, the operating system places the data in a buffer, creates a 
write request in memory, and passes a pointer to the request to the device. Once a re-
quest has been passed to the device, the processor is free to continue executing other 
processes. While the processor executes, the disk DMA hardware uses the bus to access 
the write request, obtain the buffer address, and transfer successive words of data from 
the buffer to the disk. Once the device has read an entire block of data from memory 
and written the block to disk, the disk interrupts the processor. If an additional disk 
block is ready for output, another DMA operation can be started.
DMA input works the other way around. To read a disk block, the operating sys-
tem allocates a buffer to hold the incoming data, creates a read request in memory, and 
passes the address of the request to the disk device. After initiating the request, the pro-
cessor is free, and the operating system executes a process that is ready. Simultaneous 
with processor execution, the DMA hardware uses the bus to access the request, and 
transfer the block from the disk to the buffer in memory. Once the entire block has 
been copied into the memory buffer, the disk interrupts the processor. Thus, with 
DMA, only one interrupt occurs per block transferred.
16.3 Multiple Buffers And Rings
DMA devices are more complex than described above. Instead of passing the de-
vice the address of a single request, the hardware requires the operating system to allo-
cate multiple request blocks (each with its own buffer), link them together on a linked 
list, and pass the address of the list. The device hardware is designed to follow the 
linked list and perform successive requests without waiting for the processor to restart 
each operation.† For example, consider a network interface that uses DMA hardware 
for input. To receive packets from the network, the operating system allocates a linked 
list of requests, each of which has a buffer that can hold a network packet. The operat-
ing system passes the address of the list to the network interface device. When a packet 
arrives, the network device uses the request to find the address of the buffer, uses DMA 
to copy the packet into the buffer, generates an interrupt, and automatically moves to 
the next request without waiting for the processor. As long as requests remain on the 
list, the device continues to accept incoming packets and place each packet in the buffer 
associated with the request.
What happens when a DMA device reaches the end of a buffer list? Interestingly, 
most DMA devices never reach the end of the linked list because the hardware uses a 
circular linked list, called a request ring (or informally, a buffer ring). That is, the last 
node on the list points back to the first. Each node in the list contains two values: a 
pointer to a buffer and a status bit that tells whether the buffer is ready for use. On in-
put, the operating system initializes each node on the list to point to a buffer and sets 
                                †Some hardware places request blocks in an array and uses an index rather than a pointer, but the concept
is the same.

Sec. 16.3        Multiple Buffers And Rings 
327
the status to indicate EMPTY. When it fills a buffer, the DMA hardware changes the
status to FULL and generates an interrupt. The device driver function that handles in-
terrupts extracts the data from all buffers that are full, and clears the status bits to indi-
cate that each buffer is EMPTY. On the one hand, if the operating system is fast 
enough, it will be able to extract each incoming packet and mark the buffer EMPTY be-
fore another packet arrives. Thus, on a fast processor, the DMA hardware will keep 
moving around the ring without ever encountering a buffer that is marked FULL. On  
the other hand, if the operating system cannot process packets as fast as they arrive, the 
device will eventually fill all the buffers and will encounter a buffer marked FULL. If  
it travels completely around the ring and encounters a full buffer, the DMA hardware 
sets an error indicator (typically an overflow bit) and generates an interrupt to inform 
the operating system.
Most DMA hardware also uses a circular linked list for output. The operating sys-
tem creates the ring with each buffer marked EMPTY. When it has a packet to send,
the operating system places the packet in the next available output buffer, marks the 
buffer FULL, and starts the device if the device is not currently running. The device 
moves to the next buffer, uses DMA to obtain a copy of the packet from the buffer, and 
transmits the packet over the network. Once started, the DMA output hardware contin-
ues to move around the ring until it reaches an empty buffer. Thus, if applications gen-
erate data fast enough, the DMA hardware will transmit packets continuously without 
ever encountering an empty buffer.
16.4 An Example Ethernet Driver Using DMA
An example will clarify the discussion above. Our example driver is written for 
the Ethernet device on the Quark SoC in the Galileo. Although many of the details are 
specific to the Ethernet on the Galileo board, the interaction between the processor and 
device is typical of most DMA devices. For example, the code for the Ethernet device 
in the BeagleBone Black is similar.
The Quark Ethernet handles both input and output, and has a separate DMA engine 
for each. That is, a driver must create two rings — one ring has buffers used to receive 
packets, and the other has buffers used to send packets. The device has separate regis-
ters that a driver uses to pass pointers to the input and output rings, and the hardware 
allows input and output to proceed simultaneously. Despite operating independently, 
both input and output interrupts use a single interrupt vector. Therefore, the driver acts 
like the tty driver in Chapter 15: when an interrupt occurs, the handler interacts with the 
device to determine whether the interrupt corresponds to an input or output operation, 
and proceeds accordingly.

328 
DMA Devices And Drivers (Ethernet) 
Chap. 16
16.5 Device Hardware Definitions And Constants
File quark_eth.h defines constants and structures for the Ethernet hardware. The
file contains many details and may seem confusing. For now, it is sufficient to know
that the definitions are taken directly from the vendor’s manual for the device. For ex-
ample, struct eth_q_csreg specifies the format of control and status registers as specified 
by the hardware vendor.
We will see that the transmit and receive rings each consist of a circular linked list 
of descriptors, where a descriptor contains status information, a pointer to a buffer in 
memory, and a pointer to the next descriptor in the ring. For now, it is sufficient to 
know that structures eth_q_tx_desc and eth_q_rx_desc define the descriptors that the 
DMA expects to find in the transmit and receive rings, respectively.
//** qquuaarrkk__eetthh..hh **//
//** DDeeffiinniittiioonnss ffoorr IInntteell QQuuaarrkk EEtthheerrnneett **//
##ddeeffiinnee IINNTTEELL__EETTHH__QQUUAARRKK__PPCCII__DDIIDD 00xx00993377
//** MMAACC PPCCII DDeevviiccee IIDD
**//
##ddeeffiinnee IINNTTEELL__EETTHH__QQUUAARRKK__PPCCII__VVIIDD 00xx88008866
//** MMAACC PPCCII VVeennddoorr IIDD
**//
ssttrruucctt eetthh__qq__ccssrreegg {{
uuiinntt3322
mmaaccccrr;;
//** MMAACC CCoonnffiigguurraattiioonn RReeggiisstteerr
**//
uuiinntt3322
mmaaccffff;;
//** MMAACC FFrraammee FFiilltteerr RReeggiisstteerr
**//
uuiinntt3322
hhtthhrr;;
//** HHaasshh TTaabbllee HHiigghh RReeggiisstteerr
**//
uuiinntt3322
hhttllrr;;
//** HHaasshh TTaabbllee LLooww RReeggiisstteerr
**//
uuiinntt3322
ggmmiiiiaarr;;
//** GGMMIIII AAddddrreessss RReeggiisstteerr
**//
uuiinntt3322
ggmmiiiiddrr;;
//** GGMMIIII DDaattaa RReeggiisstteerr
**//
uuiinntt3322
ffccrr;;
//** FFllooww CCoonnttrrooll RReeggiisstteerr
**//
uuiinntt3322
vvllaannttaagg;;
//** VVLLAAVV TTaagg RReeggiisstteerr
**//
uuiinntt3322
vveerrssiioonn;;
//** VVeerrssiioonn RReeggiisstteerr
**//
uuiinntt3322
ddeebbuugg;;
//** DDeebbuugg RReeggiisstteerr
**//
uuiinntt3322
rreess11[[44]];;
//** SSkkiippppeedd AAddddrreesssseess
**//
uuiinntt3322
iirr;;
//** IInntteerrrruupptt RReeggiisstteerr
**//
uuiinntt3322
iimmrr;;
//** IInntteerrrruupptt MMaasskk RReeggiisstteerr
**//
uuiinntt3322
mmaaccaaddddrr00hh;;
//** MMAACC AAddddrreessss00 HHiigghh RReeggiisstteerr
**//
uuiinntt3322
mmaaccaaddddrr00ll;;
//** MMAACC AAddddrreessss00 LLooww RReeggiisstteerr
**//
uuiinntt3322
rreess22[[4466]];;
uuiinntt3322
mmmmccccrr;;
//** MMAACC MMaannaaggeemmeenntt CCoouunntteerr CCnnttll RReeggiisstteerr **//
uuiinntt3322
mmmmccrrvvcciirr;;
//** MMMMCC RReecceeiivvee IInntteerrrruupptt RReeggiisstteerr
**//
uuiinntt3322
mmmmccttxxiirr;;
//** MMMMCC TTrraannssmmiitt IInntteerrrruupptt RReeggiisstteerr
**//
uuiinntt3322
rreess33[[995577]];;
//** SSkkiippppeedd AAddddrreesssseess
**//
uuiinntt3322
bbmmrr;;
//** BBuuss MMooddee RReeggiisstteerr
**//
uuiinntt3322
ttppddrr;;
//** TTrraannssmmiitt PPoollll DDeemmaanndd RReeggiisstteerr
**//
uuiinntt3322
rrppddrr;;
//** RReecceeiivvee PPoollll DDeemmaanndd RReeggiisstteerr
**//

Sec. 16.5        Device Hardware Definitions And Constants 
329
uuiinntt3322
rrddllaa;;
//** RReecceeiivvee DDeessccrriippttoorr LLiisstt AAddddrr
**//
uuiinntt3322
ttddllaa;;
//** TTrraannssmmiitt DDeessccrriippttoorr LLiisstt AAddddrr
**//
uuiinntt3322
ssrr;;
//** SSttaattuuss RReeggiisstteerr
**//
uuiinntt3322
oommrr;;
//** OOppeerraattiioonn MMooddee RReeggiisstteerr
**//
uuiinntt3322
iieerr;;
//** IInntteerrrruupptt EEnnaabbllee RReeggiisstteerr
**//
}};;
//** IInnddiivviidduuaall BBiittss iinn CCoonnttrrooll aanndd SSttaattuuss RReeggiisstteerrss **//
//** MMAACC CCoonnffiigguurraattiioonn RReeggiisstteerr
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__PPEE22KK
00xx0088000000000000
//** EEnnaabbllee 22KK PPaacckkeettss
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__WWDD
00xx0000880000000000
//** WWaattcchhddoogg DDiissaabbllee
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__JJDD
00xx0000440000000000
//** JJaabbbbeerr DDiissaabbllee
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__JJEE
00xx0000110000000000
//** JJuummbboo FFrraammee EEnnaabbllee
**//
//** IInntteerr--ffrraammee ggaapp vvaalluueess **//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__IIFFGG9966
00xx0000000000000000
//** 9966 bbiitt ttiimmeess
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__IIFFGG8888
00xx0000002200000000
//** 8888 bbiitt ttiimmeess
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__IIFFGG8800
00xx0000004400000000
//** 8800 bbiitt ttiimmeess
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__IIFFGG4400
00xx000000EE00000000
//** 4400 bbiitt ttiimmeess
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__IIFFGG6644
00xx0000008800000000
//** 6644 bbiitt ttiimmeess
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__DDCCRRSS
00xx0000001100000000
//** DDiiss.. CC.. SSeennssee dduurr TTXX **//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__RRMMIIIISSPPDD1100
00xx0000000000000000
//** RRMMIIII SSppeeeedd == 1100 MMbbppss **//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__RRMMIIIISSPPDD110000 00xx0000000044000000
//** RRMMIIII SSppeeeedd == 110000 MMbbppss**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__DDOO
00xx0000000022000000
//** DDiissaabbllee RReecceeiivvee OOwwnn
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__LLMM
00xx0000000011000000
//** LLooooppbbaacckk MMooddee EEnnaabbllee **//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__DDMM
00xx0000000000880000
//** DDuupplleexx MMooddee EEnnaabbllee
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__IIPPCC
00xx0000000000440000
//** CChheecckkssuumm OOffffllooaadd
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__DDRR
00xx0000000000220000
//** DDiissaabbllee RReettrryy
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__AACCSS
00xx0000000000008800
//** AAuuttoo PPaadd oorr CCRRCC SSttrriipp**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__DDCC
00xx0000000000001100
//** DDeeffeerrrraall CChheecckk
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__TTEE
00xx0000000000000088
//** TTrraannssmmiitttteerr EEnnaabbllee
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__RREE
00xx0000000000000044
//** RReecceeiivveerr EEnnaabbllee
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__PPRREELLEENN77 00xx0000000000000000
//** PPrreeaammbbllee == 77 bbyytteess
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__PPRREELLEENN55 00xx0000000000000011
//** PPrreeaammbbllee == 55 bbyytteess
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAACCCCRR__PPRREELLEENN33 00xx0000000000000022
//** PPrreeaammbbllee == 33 bbyytteess
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMMMCC__CCNNTTFFRREEEEZZ 00xx0000000000000088
//** FFrreeeezzee MMMMCC ccoouunntteerr vvaalluueess**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMMMCC__CCNNTTRRSSTT
00xx0000000000000011
//** RReesseett aallll ccnnttrrss ttoo zzeerroo
**//
//** GGMMIIII AAddddrreessss RReeggiisstteerr
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__GGMMIIIIAARR__PPAAMMAASSKK 00xx00000000FF880000
//** PPhhyyss LLaayyeerr AAddddrr MMaasskk **//
##ddeeffiinnee EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGRRMMAASSKK 00xx000000000077CC00
//** GGMMIIII RReeggiisstteerr MMaasskk
**//

330 
DMA Devices And Drivers (Ethernet) 
Chap. 16
##ddeeffiinnee EETTHH__QQUUAARRKK__GGMMIIIIAARR__CCRR
00xx0000000000000044
//** CCllkk RRaannggee == 110000--115500
**//
//**
MMHHzz ffoorr QQuuaarrkk
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGWW
00xx0000000000000022
//** GGMMIIII WWrriittee EEnnaabbllee
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB
00xx0000000000000011
//** GGMMIIII BBuussyy
**//
//** BBuuss MMooddee RReeggiisstteerr **//
##ddeeffiinnee EETTHH__QQUUAARRKK__BBMMRR__SSWWRR
00xx0000000000000011
//** SSooffttwwaarree RReesseett
**//
//** SSttaattuuss RReeggiisstteerr **//
##ddeeffiinnee EETTHH__QQUUAARRKK__SSRR__MMMMCCII
00xx0088000000000000
//** MMAACC MMMMCC iinntteerrrruupptt
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__SSRR__TTSS__SSUUSSPP
00xx0000660000000000
//** TTXX DDMMAA iiss ssuussppeennddeedd
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__SSRR__NNIISS
00xx0000001100000000
//** NNoorrmmaall IInntt ssuummmmaarryy
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__SSRR__AAIISS
00xx0000000088000000
//** AAbbnnoorrmm IInnttrruupptt ssuummmm.. **//
##ddeeffiinnee EETTHH__QQUUAARRKK__SSRR__RRII
00xx0000000000004400
//** RReecceeiivvee IInntteerrrruupptt
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__SSRR__TTII
00xx0000000000000011
//** TTrraannssmmiitt IInntteerrrruupptt
**//
//** OOppeerraattiioonn MMooddee RReeggiisstteerr **//
##ddeeffiinnee EETTHH__QQUUAARRKK__OOMMRR__TTSSFF
00xx0000220000000000
//** TTxx ssttoorree aanndd ffoorrwwaarrdd **//
##ddeeffiinnee EETTHH__QQUUAARRKK__OOMMRR__SSTT
00xx0000000022000000
//** SSttaarrtt//SSttoopp TTXX
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__OOMMRR__SSRR
00xx0000000000000022
//** SSttaarrtt//SSttoopp RRXX
**//
//** IInntteerrrruupptt EEnnaabbllee RReeggiisstteerr **//
##ddeeffiinnee EETTHH__QQUUAARRKK__IIEERR__NNIIEE
00xx0000001100000000
//** EEnnaabbllee NNoorrmm IInntt SSuummmm..**//
##ddeeffiinnee EETTHH__QQUUAARRKK__IIEERR__AAIIEE
00xx0000000088000000
//** EEnnaabbllee AAbbnnnnoomm ""
""
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__IIEERR__RRIIEE
00xx0000000000004400
//** EEnnaabbllee RRXX IInntteerrrruupptt
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__IIEERR__TTIIEE
00xx0000000000000011
//** EEnnaabbllee TTXX IInntteerrrruupptt
**//
//** QQuuaarrkk EEtthheerrnneett TTrraannssmmiitt DDeessccrriippttoorr **//
ssttrruucctt eetthh__qq__ttxx__ddeesscc {{
uuiinntt3322
ccttrrllssttaatt;;
//** CCoonnttrrooll aanndd ssttaattuuss
**//
uuiinntt1166
bbuuff11ssiizzee;;
//** SSiizzee ooff bbuuffffeerr 11
**//
uuiinntt1166
bbuuff22ssiizzee;;
//** SSiizzee ooff bbuuffffeerr 22
**//
uuiinntt3322
bbuuffffeerr11;;
//** AAddddrreessss ooff bbuuffffeerr 11
**//
uuiinntt3322
bbuuffffeerr22;;
//** AAddddrreessss ooff bbuuffffeerr 22
**//
}};;
##ddeeffiinnee EETTHH__QQUUAARRKK__TTDDCCSS__OOWWNN
00xx8800000000000000
//** DDeessccrriipp.. oowwnneedd bbyy DDMMAA**//
##ddeeffiinnee EETTHH__QQUUAARRKK__TTDDCCSS__IICC
00xx4400000000000000
//** IInntt oonn CCoommpplleettiioonn
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__TTDDCCSS__LLSS
00xx2200000000000000
//** LLaasstt SSeeggmmeenntt
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__TTDDCCSS__FFSS
00xx1100000000000000
//** FFiirrsstt SSeeggmmeenntt
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__TTDDCCSS__TTEERR
00xx0000220000000000
//** TTrraannssmmiitt EEnndd ooff RRiinngg **//
##ddeeffiinnee EETTHH__QQUUAARRKK__TTDDCCSS__EESS
00xx0000000088000000
//** EErrrroorr SSuummmmaarryy
**//
//** QQuuaarrkk EEtthheerrnneett RReecceeiivvee DDeessccrriippttoorr **//

Sec. 16.5        Device Hardware Definitions And Constants 
331
ssttrruucctt eetthh__qq__rrxx__ddeesscc {{
uuiinntt3322
ssttaattuuss;;
//** DDeesscc ssttaattuuss wwoorrdd
**//
uuiinntt1166
bbuuff11ssiizzee;;
//** SSiizzee ooff bbuuffffeerr 11
**//
uuiinntt1166
bbuuff22ssiizzee;;
//** SSiizzee ooff bbuuffffeerr 22
**//
uuiinntt3322
bbuuffffeerr11;;
//** AAddddrreessss ooff bbuuffffeerr 11
**//
uuiinntt3322
bbuuffffeerr22;;
//** AAddddrreessss ooff bbuuffffeerr 22
**//
}};;
##ddeeffiinnee rrddccttll11
bbuuff11ssiizzee
//** BBuuffffeerr 11 ssiizzee ffiieelldd hhaass ccoonnttrrooll bbiittss ttoooo **//
##ddeeffiinnee rrddccttll22
bbuuff22ssiizzee
//** BBuuffffeerr 22 ssiizzee ffiieelldd hhaass ccoonnttrrooll bbiittss ttoooo **//
##ddeeffiinnee EETTHH__QQUUAARRKK__RRDDSSTT__OOWWNN
00xx8800000000000000
//** DDeessccrriipp.. oowwnneedd bbyy DDMMAA**//
##ddeeffiinnee EETTHH__QQUUAARRKK__RRDDSSTT__EESS
00xx0000000088000000
//** EErrrroorr SSuummmmaarryy
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__RRDDSSTT__FFSS
00xx0000000000220000
//** FFiirrsstt SSeeggmmeenntt
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__RRDDSSTT__LLSS
00xx0000000000110000
//** LLaasstt sseeggmmeenntt
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__RRDDSSTT__FFTTEETTHH
00xx0000000000002200
//** FFrraammee TTyyppee == EEtthheerrnneett**//
##ddeeffiinnee EETTHH__QQUUAARRKK__RRDDCCTTLL11__DDIICC
00xx88000000
//** DDiiss.. IInntt oonn CCoommpplleett.. **//
##ddeeffiinnee EETTHH__QQUUAARRKK__RRDDCCTTLL11__RREERR
00xx88000000
//** RReeccvv EEnndd ooff RRiinngg
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__RRXX__RRIINNGG__SSIIZZEE
3322
##ddeeffiinnee EETTHH__QQUUAARRKK__TTXX__RRIINNGG__SSIIZZEE
1166
##ddeeffiinnee EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY
550000000000
//** DDeellaayy iinn mmiiccrroo sseeccss
**//
##ddeeffiinnee EETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS
33
//** MMaaxx rreettrriieess ffoorr iinniitt **//
16.6 Rings And Buffers In Memory
From a device’s perspective, an input or output ring consists of a linked list of 
descriptors in memory. We said that each descriptor on a ring contains a status word 
that specifies whether the associated buffer is empty or full. The descriptor also con-
tains a pointer to a buffer in memory and a pointer to the next descriptor on the list.
Figure 16.1 illustrates the conceptual organization of transmit and receive rings, and 
shows that each descriptor contains a pointer to a buffer as well as a pointer to the next 
ring.

332 
DMA Devices And Drivers (Ethernet) 
Chap. 16
. . .  
. . .
. . .
. . .
Transmit ring 
Receive ring
Transmit buffers 
Receive buffers
Figure 16.1 Illustration of the transmit and receive rings used with the exam-
ple DMA hardware device.
As the figure illustrates, the descriptors are arranged in a circular linked list where
the final node points back to the first node. When reading the code, it will be important
to remember that the Ethernet device views each ring as a linked list. Thus, the DMA 
hardware merely follows the pointer in one node to get to the next node on the list. The 
reason the distinction is important arises from the way our driver code allocates storage. 
The driver uses getmem to allocate enough memory for all descriptors in a ring, and 
then links them together. Because they are contiguous, driver code can use pointer in-
crement to move along the set of nodes. Figure 16.2 shows the structure of a node and 
illustrates how nodes of a ring are stored in contiguous storage.

Sec. 16.6        Rings And Buffers In Memory 
333
Ptr. To Next Node
Status
Ptr. To Buffer
EMPTY
EMPTY
EMPTY
EMPTY
buffer 1
buffer 2
buffer 3
buffer N
(a) 
(b)
..
.
Figure 16.2 (a) The three fields in a node on a receive or transmit ring, and
(b) a ring stored in contiguous memory with the second node 
shaded.
16.7 Definitions Of An Ethernet Control Block
File ether.h defines constants and data structures used by the Ethernet driver, in-
cluding the format of an Ethernet packet header, the layout of a packet buffer in
memory, and the contents of an Ethernet control block.

334 
DMA Devices And Drivers (Ethernet) 
Chap. 16
//** eetthheerr..hh **//
//** EEtthheerrnneett ppaacckkeett ffoorrmmaatt::
++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++
||
DDeesstt.. MMAACC ((66))
||
SSrrcc.. MMAACC ((66))
||TTyyppee ((22))||
DDaattaa ((4466--11550000))......
||
++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++
**//
##ddeeffiinnee EETTHH__AADDDDRR__LLEENN
66
//** LLeenn.. ooff EEtthheerrnneett ((MMAACC)) aaddddrr.. **//
ttyyppeeddeeff uunnssiiggnneedd cchhaarr
EEaaddddrr[[EETTHH__AADDDDRR__LLEENN]];;//** PPhhyyssiiccaall EEtthheerrnneett aaddddrreessss**//
//** EEtthheerrnneett ppaacckkeett hheeaaddeerr **//
ssttrruucctt
eetthheerrPPkktt {{
bbyyttee
ddsstt[[EETTHH__AADDDDRR__LLEENN]];;
//** DDeessttiinnaattiioonn MMaacc aaddddrreessss
**//
bbyyttee
ssrrcc[[EETTHH__AADDDDRR__LLEENN]];;
//** SSoouurrccee MMaacc aaddddrreessss
**//
uuiinntt1166
ttyyppee;;
//** EEtthheerr ttyyppee ffiieelldd
**//
bbyyttee
ddaattaa[[11]];;
//** PPaacckkeett ppaayyllooaadd
**//
}};;
##ddeeffiinnee EETTHH__HHDDRR__LLEENN
1144
//** LLeennggtthh ooff EEtthheerrnneett ppaacckkeett
**//
//**
hheeaaddeerr
**//
//** EEtthheerrnneett DDMMAA bbuuffffeerr ssiizzeess **//
##ddeeffiinnee EETTHH__MMTTUU
11550000
//** MMaaxxiimmuumm ttrraannssmmiissssiioonn uunniitt
**//
##ddeeffiinnee EETTHH__VVLLAANN__LLEENN
44
//** LLeennggtthh ooff EEtthheerrnneett vvllaann ttaagg
**//
##ddeeffiinnee EETTHH__CCRRCC__LLEENN
44
//** LLeennggtthh ooff CCRRCC oonn EEtthheerrnneett
**//
//**
ffrraammee
**//
##ddeeffiinnee EETTHH__MMAAXX__PPKKTT__LLEENN (( EETTHH__HHDDRR__LLEENN ++ EETTHH__VVLLAANN__LLEENN ++ EETTHH__MMTTUU ))
##ddeeffiinnee EETTHH__BBUUFF__SSIIZZEE
22004488
//** AA mmuullttiippllee ooff 1166 ggrreeaatteerr
**//
//**
tthhaann tthhee mmaaxx ppaacckkeett
**//
//**
ssiizzee ((ffoorr ccaacchhee aalliiggnnmmeenntt)) **//
//** SSttaattee ooff tthhee EEtthheerrnneett iinntteerrffaaccee **//
##ddeeffiinnee EETTHH__SSTTAATTEE__FFRREEEE
00
//** CCoonnttrrooll bblloocckk iiss uunnuusseedd
**//
##ddeeffiinnee EETTHH__SSTTAATTEE__DDOOWWNN
11
//** IInntteerrffaaccee iiss iinnaaccttiivvee
**//
##ddeeffiinnee EETTHH__SSTTAATTEE__UUPP
22
//** IInntteerrffaaccee iiss ccuurrrreennttllyy aaccttiivvee**//
//** EEtthheerrnneett ddeevviiccee ccoonnttrrooll ffuunnccttiioonnss **//

Sec. 16.7        Definitions Of An Ethernet Control Block 
335
##ddeeffiinnee EETTHH__CCTTRRLL__GGEETT__MMAACC
11
//** GGeett tthhee MMAACC ffoorr tthhiiss ddeevviiccee
**//
##ddeeffiinnee EETTHH__CCTTRRLL__AADDDD__MMCCAASSTT
22
//** AAdddd aa mmuullttiiccaasstt aaddddrreessss
**//
##ddeeffiinnee EETTHH__CCTTRRLL__RREEMMOOVVEE__MMCCAASSTT
33
//** RReemmoovvee aa mmuullttiiccaasstt aaddddrreessss
**//
//** EEtthheerrnneett mmuullttiiccaasstt **//
##ddeeffiinnee EETTHH__NNUUMM__MMCCAASSTT
3322
//** MMaaxx mmuullttiiccaasstt aaddddrreesssseess
**//
//** EEhhtteerrnneett NNIICC ttyyppee **//
##ddeeffiinnee EETTHH__TTYYPPEE__33CC990055CC
11
//** 33CCOOMM 990055CC
**//
##ddeeffiinnee EETTHH__TTYYPPEE__EE11000000EE
22
//** IInntteell EE11000000EE
**//
##ddeeffiinnee EETTHH__TTYYPPEE__QQUUAARRKK__EETTHH
33
//** EEtthheerrnneett oonn QQuuaarrkk bbooaarrdd
**//
//** CCoonnttrrooll bblloocckk ffoorr EEtthheerrnneett ddeevviiccee **//
ssttrruucctt
eetthhccbbllkk {{
bbyyttee
ssttaattee;;
//** EETTHH__SSTTAATTEE__...... aass ddeeffiinneedd aabboovvee
**//
ssttrruucctt
ddeennttrryy
**pphhyy;;
//** pphhyyssiiccaall eetthh ddeevviiccee ffoorr TTxx DDMMAA
**//
bbyyttee
ttyyppee;;
//** NNIICC ttyyppee__...... aass ddeeffiinneedd aabboovvee
**//
//** PPooiinntteerrss ttoo aassssoocciiaatteedd ssttrruuccttuurreess **//
ssttrruucctt
ddeennttrryy
**ddeevv;;
//** AAddddrreessss iinn ddeevviiccee sswwiittcchh ttaabbllee
**//
vvooiidd
**ccssrr;;
//** CCoonnttrrooll aanndd ssttaattuuss rreeggssiitteerr aaddddrreessss
**//
uuiinntt3322
ppcciiddeevv;;
//** PPCCII ddeevviiccee nnuummbbeerr
**//
uuiinntt3322
iioobbaassee;;
//** II//OO bbaassee ffrroomm ccoonnffiigg
**//
uuiinntt3322
ffllaasshhbbaassee;;
//** FFllaasshh bbaassee ffrroomm ccoonnffiigg
**//
uuiinntt3322
mmeemmbbaassee;;
//** MMeemmoorryy bbaassee ffoorr ddeevviiccee ffrroomm ccoonnffiigg
**//
vvooiidd
**rrxxRRiinngg;;
//** PPttrr ttoo aarrrraayy ooff rreeccvv rriinngg ddeessccrriippttoorrss**//
vvooiidd
**rrxxBBuuffss;;
//** PPttrr ttoo RRxx ppaacckkeett bbuuffffeerrss iinn mmeemmoorryy
**//
uuiinntt3322
rrxxHHeeaadd;;
//** IInnddeexx ooff ccuurrrreenntt hheeaadd ooff RRxx rriinngg
**//
uuiinntt3322
rrxxTTaaiill;;
//** IInnddeexx ooff ccuurrrreenntt ttaaiill ooff RRxx rriinngg
**//
uuiinntt3322
rrxxRRiinnggSSiizzee;;
//** SSiizzee ooff RRxx rriinngg ddeessccrriippttoorr aarrrraayy
**//
uuiinntt3322
rrxxIIrrqq;;
//** CCoouunntt ooff RRxx iinntteerrrruupptt rreeqquueessttss
**//
vvooiidd
**ttxxRRiinngg;;
//** PPttrr ttoo aarrrraayy ooff xxmmiitt rriinngg ddeessccrriippttoorrss**//
vvooiidd
**ttxxBBuuffss;;
//** PPttrr ttoo TTxx ppaacckkeett bbuuffffeerrss iinn mmeemmoorryy
**//
uuiinntt3322
ttxxHHeeaadd;;
//** IInnddeexx ooff ccuurrrreenntt hheeaadd ooff TTxx rriinngg
**//
uuiinntt3322
ttxxTTaaiill;;
//** IInnddeexx ooff ccuurrrreenntt ttaaiill ooff TTxx rriinngg
**//
uuiinntt3322
ttxxRRiinnggSSiizzee;;
//** SSiizzee ooff TTxx rriinngg ddeessccrriippttoorr aarrrraayy
**//
uuiinntt3322
ttxxIIrrqq;;
//** CCoouunntt ooff TTxx iinntteerrrruupptt rreeqquueessttss
**//
uuiinntt88
ddeevvAAddddrreessss[[EETTHH__AADDDDRR__LLEENN]];;//** MMAACC aaddddrreessss
**//

336 
DMA Devices And Drivers (Ethernet) 
Chap. 16
uuiinntt88
aaddddrrLLeenn;;
//** HHaarrddwwaarree aaddddrreessss lleennggtthh
**//
uuiinntt1166
mmttuu;;
//** MMaaxxiimmuumm ttrraannssmmiissssiioonn uunniitt ((ppaayyllooaadd))
**//
uuiinntt3322
eerrrroorrss;;
//** NNuummbbeerr ooff EEtthheerrnneett eerrrroorrss
**//
ssiidd3322
iisseemm;;
//** SSeemmaapphhoorree ffoorr EEtthheerrnneett iinnppuutt
**//
ssiidd3322
oosseemm;;
//** SSeemmaapphhoorree ffoorr EEtthheerrnneett oouuttppuutt
**//
uuiinntt1166
iissttaarrtt;;
//** IInnddeexx ooff nneexxtt ppaacckkeett iinn tthhee rriinngg
**//
iinntt1166
iinnPPooooll;;
//** BBuuffffeerr ppooooll IIDD ffoorr iinnppuutt bbuuffffeerrss
**//
iinntt1166
oouuttPPooooll;;
//** BBuuffffeerr ppooooll IIDD ffoorr oouuttppuutt bbuuffffeerrss
**//
iinntt1166
pprroommss;;
//** NNoonnzzeerroo ==>> pprroommiissccuuoouuss mmooddee
**//
iinntt1166
eedd__mmccsseett;;
//** NNoonnzzeerroo ==>> mmuullttiiccaasstt rreecceeppttiioonn sseett
**//
iinntt1166
eedd__mmcccc;;
//** CCoouunntt ooff mmuullttiiccaasstt aaddddrreesssseess
**//
EEaaddddrr
eedd__mmccaa[[EETTHH__NNUUMM__MMCCAASSTT]];;//** AArrrraayy ooff mmuullttiiccaasstt aaddddrrss
**//
}};;
eexxtteerrnn
ssttrruucctt
eetthhccbbllkk eetthheerrttaabb[[]];;
//** AArrrraayy ooff ccoonnttrrooll bblloocckkss
**//
16.8 Device And Driver Initialization
Recall that the operating calls function init on each device at startup. The device 
switch table is configured such that a call to init on the Ethernet device invokes func-
tion ethinit, which initializes both the Ethernet device and the device driver data struc-
tures. File ethinit.c contains the code.
//** eetthhiinniitt..cc -- eetthhiinniitt,, eetthh__pphhyy__rreeaadd,, eetthh__pphhyy__wwrriittee **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt
eetthhccbbllkk eetthheerrttaabb[[11]];;
//**------------------------------------------------------------------------------------------------------------------------------------------------
** eetthh__pphhyy__rreeaadd
--
RReeaadd aa PPHHYY rreeggiisstteerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
uuiinntt1166
eetthh__pphhyy__rreeaadd
((
vvoollaattiillee
ssttrruucctt eetthh__qq__ccssrreegg **ccssrrppttrr,,
//** CCSSRR aaddddrreessss
**//
uuiinntt3322
rreeggnnuumm
//** RReeggiisstteerr
**//
))
{{
uuiinntt3322
rreettrriieess;;
//** NNoo.. ooff rreettrriieess ffoorr rreeaadd
**//

Sec. 16.8        Device And Driver Initialization 
337
//** WWaaiitt ffoorr tthhee MMIIII ttoo bbee rreeaaddyy **//
wwhhiillee((ccssrrppttrr-->>ggmmiiiiaarr && EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB));;
//** PPrreeppaarree tthhee GGMMIIII aaddddrreessss rreeggiisstteerr ffoorr rreeaadd ttrraannssaaccttiioonn **//
ccssrrppttrr-->>ggmmiiiiaarr ==
((11 <<<< 1111))
|| //** PPhhyyssiiccaall LLaayyeerr AAddddrreessss == 11 **//
((rreeggnnuumm <<<< 66))
|| //** PPHHYY RReeggiisstteerr NNuummbbeerr
**//
((EETTHH__QQUUAARRKK__GGMMIIIIAARR__CCRR))
|| //** GGMMIIII CClloocckk RRaannggee 110000--115500MMHHzz**//
((EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB));;
//** SSttaarrtt tthhee ttrraannssaaccttiioonn
**//
//** WWaaiitt ffoorr tthhee ttrraannssaaccttiioonn ttoo ccoommpplleettee **//
rreettrriieess == 00;;
wwhhiillee((ccssrrppttrr-->>ggmmiiiiaarr && EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB)) {{
DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;
iiff((((++++rreettrriieess)) >> EETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS))
rreettuurrnn 00;;
}} 
//** TTrraannssaaccttiioonn iiss ccoommpplleettee,, rreeaadd tthhee PPHHYY rreeggiisstteerr vvaalluuee ffrroomm
**//
//**
tthhee GGMMIIII ddaattaa rreeggiisstteerr
**//
rreettuurrnn ((uuiinntt1166))ccssrrppttrr-->>ggmmiiiiddrr;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** eetthh__pphhyy__wwrriittee
--
WWrriittee aa PPHHYY rreeggiisstteerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
eetthh__pphhyy__wwrriittee
((
vvoollaattiillee
ssttrruucctt eetthh__qq__ccssrreegg **ccssrrppttrr,, //** CCSSRR aaddddrreessss
**//
uuiinntt3322
rreeggnnuumm,,
//** RReeggiisstteerr
**//
uuiinntt1166
vvaalluuee
//** VVaalluuee ttoo wwrriittee
**//
))
{{
uuiinntt3322
rreettrriieess;; //** NNoo.. ooff rreettrriieess ffoorr wwrriittee **//
//** WWaaiitt ffoorr tthhee MMIIII ttoo bbee rreeaaddyy **//
wwhhiillee((ccssrrppttrr-->>ggmmiiiiaarr && EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB));;
//** WWrriittee tthhee vvaalluuee ttoo GGMMIIII ddaattaa rreeggiisstteerr **//
ccssrrppttrr-->>ggmmiiiiddrr == ((uuiinntt3322))vvaalluuee;;

338 
DMA Devices And Drivers (Ethernet) 
Chap. 16
//** PPrreeppaarree tthhee GGMMIIII aaddddrreessss rreeggiisstteerr ffoorr wwrriittee ttrraannssaaccttiioonn **//
ccssrrppttrr-->>ggmmiiiiaarr ==
((11 <<<< 1111))
|| //** PPhhyyssiiccaall LLaayyeerr AAddddrreessss == 11 **//
((rreeggnnuumm <<<< 66))
|| //** PPHHYY RReeggiisstteerr NNuummbbeerr
**//
((EETTHH__QQUUAARRKK__GGMMIIIIAARR__CCRR))
|| //** GGMMIIII CClloocckk RRaannggee 110000--115500MMHHzz**//
((EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGWW))
|| //** WWrriittee ttrraannssaaccttiioonn
**//
((EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB));;
//** SSttaarrtt tthhee ttrraannssaaccttiioonn
**//
//** WWaaiitt ttiillll tthhee ttrraannssaaccttiioonn iiss ccoommpplleettee **//
rreettrriieess == 00;;
wwhhiillee((ccssrrppttrr-->>ggmmiiiiaarr && EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB)) {{
DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;
iiff((((++++rreettrriieess)) >> EETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS))
rreettuurrnn;;
}}
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** eetthh__pphhyy__rreesseett
--
RReesseett aann EEtthheerrnneett PPHHYY
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinntt3322
eetthh__pphhyy__rreesseett
((
vvoollaattiillee ssttrruucctt eetthh__qq__ccssrreegg **ccssrrppttrr
//** CCSSRR aaddddrreessss
**//
))
{{
uuiinntt1166
vvaalluuee;;
//** VVaarriiaabbllee ttoo rreeaadd iinn PPHHYY rreeggiisstteerrss
**//
uuiinntt3322
rreettrriieess;;
//** NNoo..
ooff rreettrriieess ffoorr rreesseett
**//
//** RReeaadd tthhee PPHHYY ccoonnttrrooll rreeggiisstteerr ((rreeggiisstteerr 00)) **//
vvaalluuee == eetthh__pphhyy__rreeaadd((ccssrrppttrr,, 00));;
//** SSeett bbiitt 1155 iinn ccoonnttrrooll rreeggiisstteerr ttoo rreesseett tthhee PPHHYY **//
eetthh__pphhyy__wwrriittee((ccssrrppttrr,, 00,, ((vvaalluuee || 00xx88000000))));;
//** WWaaiitt ffoorr PPHHYY rreesseett pprroocceessss ttoo ccoommpplleettee **//
rreettrriieess == 00;;
wwhhiillee((eetthh__pphhyy__rreeaadd((ccssrrppttrr,, 00)) && 00xx88000000)) {{
DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;
iiff((((++++rreettrriieess)) >> EETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS))
rreettuurrnn SSYYSSEERRRR;;
}}

Sec. 16.8        Device And Driver Initialization 
339
//** SSeeee iiff tthhee PPHHYY hhaass aauuttoo--nneeggoottiiaattiioonn ccaappaabbiilliittyy **//
vvaalluuee == eetthh__pphhyy__rreeaadd((ccssrrppttrr,, 11));;
//** PPHHYY SSttaattuuss rreeggiisstteerr
**//
iiff((vvaalluuee && 00xx00000088)) {{ //** AAuuttoo--nneeggoottiiaattiioonn ccaappaabbllee **//
//** WWaaiitt ffoorr tthhee aauuttoo--nneeggoottiiaattiioonn pprroocceessss ttoo ccoommpplleettee **//
rreettrriieess == 00;;
wwhhiillee((((eetthh__pphhyy__rreeaadd((ccssrrppttrr,, 11)) && 00xx00002200)) ==== 00)) {{
DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;
iiff((((++++rreettrriieess)) >> EETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS))
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
//** WWaaiitt ffoorr tthhee LLiinnkk ttoo bbee UUpp **//
rreettrriieess == 00;;
wwhhiillee((((eetthh__pphhyy__rreeaadd((ccssrrppttrr,, 11)) && 00xx00000044)) ==== 00)) {{
DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;
iiff((((++++rreettrriieess)) >> EETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS))
rreettuurrnn SSYYSSEERRRR;;
}} 
DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;
kkpprriinnttff((""EEtthheerrnneett LLiinnkk iiss UUpp\\nn""));;
rreettuurrnn OOKK;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** eetthhiinniitt
--
IInniittiiaalliizzee tthhee IInntteell QQuuaarrkk EEtthheerrnneett ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinntt3322
eetthhiinniitt ((
ssttrruucctt ddeennttrryy **ddeevvppttrr
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
))
{{
ssttrruucctt
eetthhccbbllkk **eetthhppttrr;;
//** PPttrr ttoo ccoonnttrrooll bblloocckk **//
vvoollaattiillee ssttrruucctt eetthh__qq__ccssrreegg **ccssrrppttrr;;
//** PPttrr ttoo CCSSRR
**//
ssttrruucctt
eetthh__qq__ttxx__ddeesscc **ttxx__ddeessccss;;
//** AArrrraayy ooff ttxx ddeessccss
**//
ssttrruucctt
eetthh__qq__rrxx__ddeesscc **rrxx__ddeessccss;;
//** AArrrraayy ooff rrxx ddeessccss
**//
ssttrruucctt
nneettppaacckkeett **ppkkttppttrr;;
//** PPooiinntteerr ttoo aa ppaacckkeett
**//
vvooiidd
**tteemmppttrr;;
//** TTeemmpp.. ppooiinntteerr
**//

340 
DMA Devices And Drivers (Ethernet) 
Chap. 16
uuiinntt3322
rreettrriieess;;
//** RReettrryy ccoouunntt ffoorr rreesseett**//
iinntt3322
rreettvvaall;;
iinntt3322
ii;;
eetthhppttrr == &&eetthheerrttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
eetthhppttrr-->>ccssrr == ((ssttrruucctt eetthh__qq__ccssrreegg **))ddeevvppttrr-->>ddvvccssrr;;
ccssrrppttrr == ((ssttrruucctt eetthh__qq__ccssrreegg **))eetthhppttrr-->>ccssrr;;
//** EEnnaabbllee CCSSRR MMeemmoorryy SSppaaccee,, EEnnaabbllee BBuuss MMaasstteerr **//
ppccii__wwrriittee__ccoonnffiigg__wwoorrdd((eetthhppttrr-->>ppcciiddeevv,, 00xx44,, 00xx00000066));;
//** RReesseett tthhee PPHHYY **//
rreettvvaall == eetthh__pphhyy__rreesseett((ccssrrppttrr));;
iiff((rreettvvaall ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** RReesseett tthhee EEtthheerrnneett MMAACC **//
ccssrrppttrr-->>bbmmrr ||== EETTHH__QQUUAARRKK__BBMMRR__SSWWRR;;
//** WWaaiitt ffoorr tthhee MMAACC RReesseett pprroocceessss ttoo ccoommpplleettee **//
rreettrriieess == 00;;
wwhhiillee((ccssrrppttrr-->>bbmmrr && EETTHH__QQUUAARRKK__BBMMRR__SSWWRR)) {{
DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;
iiff((((++++rreettrriieess)) >> EETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS))
rreettuurrnn SSYYSSEERRRR;;
}} 
//** TTrraannssmmiitt SSttoorree aanndd FFoorrwwaarrdd **//
ccssrrppttrr-->>oommrr ||== EETTHH__QQUUAARRKK__OOMMRR__TTSSFF;;
//** SSeett tthhee iinntteerrrruupptt hhaannddlleerr **//
sseett__eevveecc((ddeevvppttrr-->>ddvviirrqq,, ((uuiinntt3322))ddeevvppttrr-->>ddvviinnttrr));;
//** SSeett tthhee MMAACC SSppeeeedd == 110000MMbbppss,, FFuullll DDuupplleexx mmooddee **//
ccssrrppttrr-->>mmaaccccrr ||== ((EETTHH__QQUUAARRKK__MMAACCCCRR__RRMMIIIISSPPDD110000 ||
EETTHH__QQUUAARRKK__MMAACCCCRR__DDMM));;
//** RReesseett tthhee MMMMCC CCoouunntteerrss **//
ccssrrppttrr-->>mmmmccccrr ||== EETTHH__QQUUAARRKK__MMMMCC__CCNNTTFFRREEEEZZ || EETTHH__QQUUAARRKK__MMMMCC__CCNNTTRRSSTT;;
//** RReettrriieevvee tthhee MMAACC aaddddrreessss ffrroomm SSPPII ffllaasshh **//
ggeett__qquuaarrkk__ppddaatt__eennttrryy__ddaattaa__bbyy__iidd((QQUUAARRKK__MMAACC11__IIDD,,
((cchhaarr**))((eetthhppttrr-->>ddeevvAAddddrreessss)),, EETTHH__AADDDDRR__LLEENN));;

Sec. 16.8        Device And Driver Initialization 
341
kkpprriinnttff((""MMAACC aaddddrreessss iiss %%0022xx::%%0022xx::%%0022xx::%%0022xx::%%0022xx::%%0022xx\\nn"",,
00xxffff&&eetthhppttrr-->>ddeevvAAddddrreessss[[00]],,
00xxffff&&eetthhppttrr-->>ddeevvAAddddrreessss[[11]],,
00xxffff&&eetthhppttrr-->>ddeevvAAddddrreessss[[22]],,
00xxffff&&eetthhppttrr-->>ddeevvAAddddrreessss[[33]],,
00xxffff&&eetthhppttrr-->>ddeevvAAddddrreessss[[44]],,
00xxffff&&eetthhppttrr-->>ddeevvAAddddrreessss[[55]]));;
//** AAdddd tthhee MMAACC aaddddrreessss rreeaadd ffrroomm SSPPII ffllaasshh iinnttoo tthhee
**//
//** mmaaccaaddddrr rreeggiisstteerrss ffoorr aaddddrreessss ffiilltteerriinngg
**//
ccssrrppttrr-->>mmaaccaaddddrr00ll == ((uuiinntt3322))((**((((uuiinntt3322 **))eetthhppttrr-->>ddeevvAAddddrreessss))));;
ccssrrppttrr-->>mmaaccaaddddrr00hh == ((((uuiinntt3322))
((**((((uuiinntt1166 **))((eetthhppttrr-->>ddeevvAAddddrreessss ++ 44)))))) || 00xx8800000000000000));;
eetthhppttrr-->>ttxxRRiinnggSSiizzee == EETTHH__QQUUAARRKK__TTXX__RRIINNGG__SSIIZZEE;;
//** AAllllooccaattee mmeemmoorryy ffoorr tthhee ttrraannssmmiitt rriinngg **//
tteemmppttrr == ((vvooiidd **))ggeettmmeemm((ssiizzeeooff((ssttrruucctt eetthh__qq__ttxx__ddeesscc)) **
((eetthhppttrr-->>ttxxRRiinnggSSiizzee++11))));;
iiff((((iinntt))tteemmppttrr ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
mmeemmsseett((tteemmppttrr,, 00,, ssiizzeeooff((ssttrruucctt eetthh__qq__ttxx__ddeesscc)) **
((eetthhppttrr-->>ttxxRRiinnggSSiizzee++11))));;
//** TThhee ttrraannssmmiitt ddeessccrriippttoorrss nneeeedd ttoo bbee 44--bbyyttee aalliiggnneedd **//
eetthhppttrr-->>ttxxRRiinngg == ((vvooiidd **))((((((uuiinntt3322))tteemmppttrr ++ 33)) && ((~~33))));;
//** AAllllooccaattee mmeemmoorryy ffoorr ttrraannssmmiitt bbuuffffeerrss **//
eetthhppttrr-->>ttxxBBuuffss == ((vvooiidd **))ggeettmmeemm((ssiizzeeooff((ssttrruucctt nneettppaacckkeett)) **
((eetthhppttrr-->>ttxxRRiinnggSSiizzee++11))));;
iiff((((iinntt))eetthhppttrr-->>ttxxBBuuffss ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
eetthhppttrr-->>ttxxBBuuffss == ((vvooiidd **))((((((uuiinntt3322))eetthhppttrr-->>ttxxBBuuffss ++ 33)) && ((~~33))));;
//** PPooiinntteerrss ttoo iinniittiiaalliizzee ttrraannssmmiitt ddeessccrriippttoorrss **//
ttxx__ddeessccss == ((ssttrruucctt eetthh__qq__ttxx__ddeesscc **))eetthhppttrr-->>ttxxRRiinngg;;
ppkkttppttrr == ((ssttrruucctt nneettppaacckkeett **))eetthhppttrr-->>ttxxBBuuffss;;
//** IInniittiiaalliizzee tthhee ttrraannssmmiitt ddeessccrriippttoorrss **//
ffoorr((ii == 00;; ii << eetthhppttrr-->>ttxxRRiinnggSSiizzee;; ii++++)) {{
ttxx__ddeessccss[[ii]]..bbuuffffeerr11 == ((uuiinntt3322))((ppkkttppttrr ++ ii));;
}}

342 
DMA Devices And Drivers (Ethernet) 
Chap. 16
//** CCrreeaattee tthhee oouuttppuutt ssyynncchhrroonniizzaattiioonn sseemmaapphhoorree **//
eetthhppttrr-->>oosseemm == sseemmccrreeaattee((eetthhppttrr-->>ttxxRRiinnggSSiizzee));;
iiff((((iinntt))eetthhppttrr-->>oosseemm ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
eetthhppttrr-->>rrxxRRiinnggSSiizzee == EETTHH__QQUUAARRKK__RRXX__RRIINNGG__SSIIZZEE;;
//** AAllllooccaattee mmeemmoorryy ffoorr tthhee rreecceeiivvee ddeessccrriippttoorrss **//
tteemmppttrr == ((vvooiidd **))ggeettmmeemm((ssiizzeeooff((ssttrruucctt eetthh__qq__rrxx__ddeesscc)) **
((eetthhppttrr-->>rrxxRRiinnggSSiizzee++11))));;
iiff((((iinntt))tteemmppttrr ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
mmeemmsseett((tteemmppttrr,, 00,, ssiizzeeooff((ssttrruucctt eetthh__qq__rrxx__ddeesscc)) **
((eetthhppttrr-->>rrxxRRiinnggSSiizzee++11))));;
//** RReecceeiivvee ddeessccrriippttoorrss mmuusstt bbee 44--bbyyttee aalliiggnneedd **//
eetthhppttrr-->>rrxxRRiinngg == ((ssttrruucctt eetthh__qq__rrxx__ddeesscc **))
((((((uuiinntt3322))tteemmppttrr ++ 33)) && ((~~33))));;
//** AAllllooccaattee mmeemmoorryy ffoorr tthhee rreecceeiivvee bbuuffffeerrss **//
eetthhppttrr-->>rrxxBBuuffss == ((vvooiidd **))ggeettmmeemm((ssiizzeeooff((ssttrruucctt nneettppaacckkeett)) **
((eetthhppttrr-->>rrxxRRiinnggSSiizzee++11))));;
iiff((((iinntt))eetthhppttrr-->>rrxxBBuuffss ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** RReecceeiivvee bbuuffffeerrss mmuusstt bbee 44--bbyyttee aalliiggnneedd **//
eetthhppttrr-->>rrxxBBuuffss == ((vvooiidd **))((((((uuiinntt3322))eetthhppttrr-->>rrxxBBuuffss ++ 33)) && ((~~33))));;
//** PPooiinntteerr ttoo iinniittiiaalliizzee rreecceeiivvee ddeessccrriippttoorrss **//
rrxx__ddeessccss == ((ssttrruucctt eetthh__qq__rrxx__ddeesscc **))eetthhppttrr-->>rrxxRRiinngg;;
//** PPooiinntteerr ttoo ddaattaa bbuuffffeerrss **//
ppkkttppttrr == ((ssttrruucctt nneettppaacckkeett **))eetthhppttrr-->>rrxxBBuuffss;;
//** IInniittiiaalliizzee tthhee rreecceeiivvee ddeessccrriippttoorrss **//
ffoorr((ii == 00;; ii << eetthhppttrr-->>rrxxRRiinnggSSiizzee;; ii++++)) {{
rrxx__ddeessccss[[ii]]..ssttaattuuss
== EETTHH__QQUUAARRKK__RRDDSSTT__OOWWNN;;
rrxx__ddeessccss[[ii]]..bbuuff11ssiizzee == ((uuiinntt3322))ssiizzeeooff((ssttrruucctt nneettppaacckkeett));;
rrxx__ddeessccss[[ii]]..bbuuffffeerr11
== ((uuiinntt3322))((ppkkttppttrr ++ ii));;
}}

Sec. 16.8        Device And Driver Initialization 
343
//** IInnddiiccaattee eenndd ooff rriinngg oonn llaasstt ddeessccrriippttoorr **//
rrxx__ddeessccss[[eetthhppttrr-->>rrxxRRiinnggSSiizzee--11]]..bbuuff11ssiizzee ||== ((EETTHH__QQUUAARRKK__RRDDCCTTLL11__RREERR));;
//** CCrreeaattee tthhee iinnppuutt ssyynncchhrroonniizzaattiioonn sseemmaapphhoorree **//
eetthhppttrr-->>iisseemm == sseemmccrreeaattee((00));;
iiff((((iinntt))eetthhppttrr-->>iisseemm ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** EEnnaabbllee tthhee TTrraannssmmiitt aanndd RReecceeiivvee IInntteerrrruuppttss **//
ccssrrppttrr-->>iieerr == (( EETTHH__QQUUAARRKK__IIEERR__NNIIEE ||
EETTHH__QQUUAARRKK__IIEERR__TTIIEE ||
EETTHH__QQUUAARRKK__IIEERR__RRIIEE ));;
//** IInniittiiaalliizzee tthhee ttrraannssmmiitt ddeessccrriippttoorr bbaassee aaddddrreessss **//
ccssrrppttrr-->>ttddllaa == ((uuiinntt3322))eetthhppttrr-->>ttxxRRiinngg;;
//** IInniittiiaalliizzee tthhee rreecceeiivvee ddeessccrriippttoorr bbaassee aaddddrreessss **//
ccssrrppttrr-->>rrddllaa == ((uuiinntt3322))eetthhppttrr-->>rrxxRRiinngg;;
//** EEnnaabbllee tthhee MMAACC RReecceeiivveerr aanndd TTrraannssmmiitttteerr **//
ccssrrppttrr-->>mmaaccccrr ||== ((EETTHH__QQUUAARRKK__MMAACCCCRR__TTEE || EETTHH__QQUUAARRKK__MMAACCCCRR__RREE));;
//** SSttaarrtt tthhee TTrraannssmmiitt aanndd RReecceeiivvee PPrroocceesssseess iinn tthhee DDMMAA **//
ccssrrppttrr-->>oommrr ||== ((EETTHH__QQUUAARRKK__OOMMRR__SSTT || EETTHH__QQUUAARRKK__OOMMRR__SSRR));;
rreettuurrnn OOKK;;
}}
When it is called, ethinit initializes fields in the device control block, and then ini-
tializes the hardware. Many of the details depend on the specific Ethernet hardware, but 
most hardware has equivalent functionality. Once the descriptor rings have been initial-
ized, ethinit enables transmit and receiver interrupts in the hardware, making the device 
ready to transmit and receive packets.
16.9 Reading From An Ethernet Device
Because the DMA engine uses the input ring to store incoming packets in succes-
sive buffers, reading from an Ethernet device does not involve much interaction with
the device hardware. Instead, the driver uses a semaphore to coordinate reading: the 
semaphore begins with a count of zero, and is signalled each time a packet arrives.

344 
DMA Devices And Drivers (Ethernet) 
Chap. 16
When it reads a packet, a process waits on the semaphore, then extracts a packet from
the next ring buffer. If no packet is available when a process attempts to read a packet,
the caller will be blocked. Once a packet becomes available and the interrupt handler 
signals the semaphore, the caller will proceed. The driver merely needs to copy the 
packet from the ring buffer to the caller’s buffer and return. File ethread.c contains the 
code:
//** eetthhrreeaadd..cc -- eetthhrreeaadd **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** eetthhrreeaadd
--
RReeaadd aann iinnccoommiinngg ppaacckkeett oonn IInntteell QQuuaarrkk EEtthheerrnneett
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll eetthhrreeaadd ((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**bbuuff,,
//** BBuuffffeerr ffoorr tthhee ppaacckkeett
**//
iinntt3322 lleenn
//** SSiizzee ooff tthhee bbuuffffeerr
**//
))
{{
ssttrruucctt
eetthhccbbllkk **eetthhppttrr;;
//** EEtthheerrttaabb eennttrryy ppooiinntteerr
**//
ssttrruucctt
eetthh__qq__rrxx__ddeesscc **rrddeessccppttrr;;//** PPooiinntteerr ttoo tthhee ddeessccrriippttoorr
**//
ssttrruucctt
nneettppaacckkeett **ppkkttppttrr;;
//** PPooiinntteerr ttoo ppaacckkeett
**//
uuiinntt3322
ffrraammeelleenn == 00;;
//** LLeennggtthh ooff tthhee iinnccoommiinngg ffrraammee **//
bbooooll88
vvaalliidd__aaddddrr;;
iinntt3322
ii;;
eetthhppttrr == &&eetthheerrttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
wwhhiillee((11)) {{
//** WWaaiitt uunnttiill tthheerree iiss aa ppaacckkeett iinn tthhee rreecceeiivvee qquueeuuee **//
wwaaiitt((eetthhppttrr-->>iisseemm));;
//** PPooiinntt ttoo tthhee hheeaadd ooff tthhee ddeessccrriippttoorr lliisstt **//
rrddeessccppttrr == ((ssttrruucctt eetthh__qq__rrxx__ddeesscc **))eetthhppttrr-->>rrxxRRiinngg ++
eetthhppttrr-->>rrxxHHeeaadd;;
ppkkttppttrr == ((ssttrruucctt nneettppaacckkeett**))rrddeessccppttrr-->>bbuuffffeerr11;;
//** SSeeee iiff ddeessttiinnaattiioonn aaddddrreessss iiss oouurr uunniiccaasstt aaddddrreessss **//
iiff((!!mmeemmccmmpp((ppkkttppttrr-->>nneett__eetthhddsstt,, eetthhppttrr-->>ddeevvAAddddrreessss,, 66)))) {{

Sec. 16.9        Reading From An Ethernet Device 
345
vvaalliidd__aaddddrr == TTRRUUEE;;
//** SSeeee iiff ddeessttiinnaattiioonn aaddddrreessss iiss tthhee bbrrooaaddccaasstt aaddddrreessss **//
}} eellssee iiff((!!mmeemmccmmpp((ppkkttppttrr-->>nneett__eetthhddsstt,,
NNeettDDaattaa..eetthhbbccaasstt,,66)))) {{
vvaalliidd__aaddddrr == TTRRUUEE;;
//** FFoorr mmuullttiiccaasstt aaddddrreesssseess,, sseeee iiff wwee sshhoouulldd aacccceepptt **//
}} eellssee {{
vvaalliidd__aaddddrr == FFAALLSSEE;;
ffoorr((ii == 00;; ii << ((eetthhppttrr-->>eedd__mmcccc));; ii++++)) {{
iiff((mmeemmccmmpp((ppkkttppttrr-->>nneett__eetthhddsstt,,
eetthhppttrr-->>eedd__mmccaa[[ii]],, 66)) ==== 00)){{
vvaalliidd__aaddddrr == TTRRUUEE;;
bbrreeaakk;;
}}
}}
}} 
iiff((vvaalliidd__aaddddrr ==== TTRRUUEE)){{ //** AAcccceepptt tthhiiss ppaacckkeett **//
//** GGeett tthhee lleennggtthh ooff tthhee ffrraammee **//
ffrraammeelleenn == ((rrddeessccppttrr-->>ssttaattuuss >>>> 1166)) && 00xx0000000033FFFFFF;;
//** OOnnllyy rreettuurrnn lleenn cchhaarraacctteerrss ttoo ccaalllleerr **//
iiff((ffrraammeelleenn >> lleenn)) {{
ffrraammeelleenn == lleenn;;
}} 
//** CCooppyy tthhee ppaacckkeett iinnttoo tthhee ccaalllleerr’’ss bbuuffffeerr **//
mmeemmccppyy((bbuuff,, ((vvooiidd**))rrddeessccppttrr-->>bbuuffffeerr11,, ffrraammeelleenn));;
}} 
//** IInnccrreemmeenntt tthhee hheeaadd ooff tthhee ddeessccrriippttoorr lliisstt **//
eetthhppttrr-->>rrxxHHeeaadd ++== 11;;
iiff((eetthhppttrr-->>rrxxHHeeaadd >>== EETTHH__QQUUAARRKK__RRXX__RRIINNGG__SSIIZZEE)) {{
eetthhppttrr-->>rrxxHHeeaadd == 00;;
}}

346 
DMA Devices And Drivers (Ethernet) 
Chap. 16
//** RReesseett tthhee ddeessccrriippttoorr ttoo mmaaxx ppoossssiibbllee ffrraammee lleenn **//
rrddeessccppttrr-->>bbuuff11ssiizzee == ssiizzeeooff((ssttrruucctt nneettppaacckkeett));;
//** IIff wwee rreeaacchh tthhee eenndd ooff tthhee rriinngg,, mmaarrkk tthhee ddeessccrriippttoorr **//
iiff((eetthhppttrr-->>rrxxHHeeaadd ==== 00)) {{
rrddeessccppttrr-->>rrddccttll11 ||== ((EETTHH__QQUUAARRKK__RRDDCCTTLL11__RREERR));;
}} 
//** IInnddiiccaattee tthhaatt tthhee ddeessccrriippttoorr iiss rreeaaddyy ffoorr DDMMAA iinnppuutt **//
rrddeessccppttrr-->>ssttaattuuss == EETTHH__QQUUAARRKK__RRDDSSTT__OOWWNN;;
iiff((vvaalliidd__aaddddrr ==== TTRRUUEE)) {{
bbrreeaakk;;
}}
}} 
//** RReettuurrnn tthhee nnuummbbeerr ooff bbyytteess rreettuurrnneedd ffrroomm tthhee ppaacckkeett **//
rreettuurrnn ffrraammeelleenn;;
}}
Ethread consists of a loop that reads packets until it finds a packet that should be 
processed (i.e., valid). A packet is accepted if the packet is addressed to the computer’s 
unicast address, the network broadcast address, or is one of the multicast addresses to 
which the computer is listening. Other packets are discarded.
Multicast. Like many hardware devices, the Galileo Ethernet does not recognize a 
large set of multicast addresses. Instead, the hardware receives a set of multicast pack-
ets, and relies on the software to decide whether a packet should be accepted. Our 
driver uses an array of multicast addresses, and checks each incoming multicast packet
to see whether the address matches one of the addresses that an application has speci-
fied. An exercise explores the use of hardware filters.
To block until at least one packet is available, ethread waits on the input sema-
phore on each iteration of the loop. Once it proceeds beyond the call to wait, the code 
locates the next available ring descriptor and obtains a pointer to the buffer associated 
with the ring. It then examines the destination address on the packet in the buffer. 
When a valid packet is found, the code copies the packet to the caller’s buffer, and re-
turns the size of the packet to the caller. Whether a packet is accepted or skipped, 
ethread makes the descriptor available to the device (i.e., ready for the DMA engine to 
deposit another packet).

Sec. 16.10        Writing To An Ethernet Device 
347
16.10 Writing To An Ethernet Device
Using DMA makes output as straightforward as input. An application calls write 
to send a packet, which invokes function ethwrite. As with input, the output side only 
interacts with the ring buffers: ethwrite copies the caller’s buffer to the next available 
output buffer. File ethwrite.c contains the code:
//** eetthhwwrriittee..cc -- eetthhwwrriittee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** eetthhwwrriittee
--
eennqquueeuuee ppaacckkeett ffoorr ttrraannssmmiissssiioonn oonn IInntteell QQuuaarrkk EEtthheerrnneett
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll eetthhwwrriittee
((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**bbuuff,,
//** BBuuffffeerr tthhaatt hhoollss aa ppaacckkeett
**//
iinntt3322 lleenn
//** LLeennggtthh ooff tthhee ppaacckkeett
**//
))
{{
ssttrruucctt
eetthhccbbllkk **eetthhppttrr;;
//** PPooiinntteerr ttoo ccoonnttrrooll bblloocckk
**//
ssttrruucctt
eetthh__qq__ccssrreegg **ccssrrppttrr;;
//** AAddddrreessss ooff ddeevviiccee CCSSRRss
**//
vvoollaattiillee ssttrruucctt eetthh__qq__ttxx__ddeesscc **ddeessccppttrr;; //** PPttrr ttoo ddeessccrriippttoorr
**//
uuiinntt3322 ii;;
//** CCoouunnttss bbyytteess dduurriinngg ccooppyy
**//
eetthhppttrr == &&eetthheerrttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
ccssrrppttrr == ((ssttrruucctt eetthh__qq__ccssrreegg **))eetthhppttrr-->>ccssrr;;
//** WWaaiitt ffoorr aann eemmppttyy sslloott iinn tthhee ttrraannssmmiitt ddeessccrriippttoorr rriinngg **//
wwaaiitt((eetthhppttrr-->>oosseemm));;
//** PPooiinntt ttoo tthhee ttaaiill ooff tthhee ddeessccrriippttoorr rriinngg **//
ddeessccppttrr == ((ssttrruucctt eetthh__qq__ttxx__ddeesscc **))eetthhppttrr-->>ttxxRRiinngg ++ eetthhppttrr-->>ttxxTTaaiill;;
//** IInnccrreemmeenntt tthhee ttaaiill iinnddeexx aanndd wwrraapp,, iiff nneeeeddeedd **//
eetthhppttrr-->>ttxxTTaaiill ++== 11;;
iiff((eetthhppttrr-->>ttxxTTaaiill >>== eetthhppttrr-->>ttxxRRiinnggSSiizzee)) {{
eetthhppttrr-->>ttxxTTaaiill == 00;;
}}

348 
DMA Devices And Drivers (Ethernet) 
Chap. 16
//** AAdddd ppaacckkeett lleennggtthh ttoo tthhee ddeessccrriippttoorr **//
ddeessccppttrr-->>bbuuff11ssiizzee == lleenn;;
//** CCooppyy ppaacckkeett iinnttoo tthhee bbuuffffeerr aassssoocciiaatteedd wwiitthh tthhee ddeessccrriippttoorr
**//
ffoorr((ii == 00;; ii << lleenn;; ii++++)) {{
**((((cchhaarr **))ddeessccppttrr-->>bbuuffffeerr11 ++ ii)) == **((((cchhaarr **))bbuuff ++ ii));;
}} 
//** MMaarrkk tthhee ddeessccrriippttoorr iiff wwee aarree aatt tthhee eenndd ooff tthhee rriinngg **//
iiff((eetthhppttrr-->>ttxxTTaaiill ==== 00)) {{
ddeessccppttrr-->>ccttrrllssttaatt == EETTHH__QQUUAARRKK__TTDDCCSS__TTEERR;;
}} eellssee {{
ddeessccppttrr-->>ccttrrllssttaatt == 00;;
}} 
//** IInniittiiaalliizzee tthhee ddeessccrriippttoorr **//
ddeessccppttrr-->>ccttrrllssttaatt ||==
((EETTHH__QQUUAARRKK__TTDDCCSS__OOWWNN || //** TThhee ddeesscc iiss oowwnneedd bbyy DDMMAA
**//
EETTHH__QQUUAARRKK__TTDDCCSS__IICC
|| //** IInntteerrrruupptt aafftteerr ttrraannssffeerr
**//
EETTHH__QQUUAARRKK__TTDDCCSS__LLSS
|| //** LLaasstt sseeggmmeenntt ooff ppaacckkeett
**//
EETTHH__QQUUAARRKK__TTDDCCSS__FFSS));;
//** FFiirrsstt sseeggmmeenntt ooff ppaacckkeett
**//
//** UUnn--ssuussppeenndd DDMMAA oonn tthhee ddeevviiccee **//
ccssrrppttrr-->>ttppddrr == 11;;
rreettuurrnn OOKK;;
}}
Ethwrite waits on the output semaphore, which blocks the calling process until an 
output ring descriptor is empty and available. The code then copies a packet from the 
caller’s buffer into the packet buffer associated with the descriptor. If the device is 
currently idle, ethwrite must start the device. Starting the device is trivial: ethwrite as-
signs 1 to the tpdr register in the device’s transmit control register. If the device is al-
ready running, the assignment has no effect; if the device is idle, the assignment starts 
the device, which will examine the next ring descriptor (the one into which the driver 
placed the packet to be transmitted).

Sec. 16.11        Handling Interrupts From An Ethernet Device 
349
16.11 Handling Interrupts From An Ethernet Device
One of the advantages of a DMA device arises because the DMA engine on the de-
vice handles many of the details. As a result, interrupt processing does not involve
much interaction with the device. An interrupt occurs when an input or output opera-
tion completes successfully or when the DMA engine encounters an error. To deter-
mine the exact cause, the interrupt handler checks the transmit interrupt bit in the con-
trol register, and then checks the receive interrupt bit. Other interrupts are acknowl-
edged (to reset the hardware), but otherwise ignored. File ethhandler.c contains the
code:
//** eetthhhhaannddlleerr..cc -- eetthhhhaannddlleerr **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** eetthhhhaannddlleerr
--
IInntteerrrruupptt hhaannddlleerr ffoorr IInntteell QQuuaarrkk EEtthheerrnneett
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinntteerrrruupptt
eetthhhhaannddlleerr((vvooiidd))
{{
ssttrruucctt
eetthhccbbllkk **eetthhppttrr;;
//** EEtthheerrttaabb eennttrryy ppooiinntteerr
**//
ssttrruucctt
eetthh__qq__ccssrreegg **ccssrrppttrr;;
//** PPooiinntteerr ttoo EEtthheerrnneett CCRRSSss
**//
ssttrruucctt
eetthh__qq__ttxx__ddeesscc **ttddeessccppttrr;;//** PPooiinntteerr ttoo ttxx ddeessccrriippttoorr
**//
ssttrruucctt
eetthh__qq__rrxx__ddeesscc **rrddeessccppttrr;;//** PPooiinntteerr ttoo rrxx ddeessccrriippttoorr
**//
vvoollaattiillee uuiinntt3322 ssrr;;
//** CCooppyy ooff ssttaattuuss rreeggiisstteerr
**//
uuiinntt3322
ccoouunntt;;
//** VVaarriiaabbllee uusseedd ttoo ccoouunntt ppkkttss
**//
eetthhppttrr == &&eetthheerrttaabb[[ddeevvttaabb[[EETTHHEERR00]]..ddvvmmiinnoorr]];;
ccssrrppttrr == ((ssttrruucctt eetthh__qq__ccssrreegg **))eetthhppttrr-->>ccssrr;;
//** CCooppyy tthhee ssttaattuuss rreeggiisstteerr iinnttoo aa llooccaall vvaarriiaabbllee **//
ssrr == ccssrrppttrr-->>ssrr;;
//** IIff tthheerree iiss nnoo iinntteerrrruupptt ppeennddiinngg,, rreettuurrnn **//
iiff((((ccssrrppttrr-->>ssrr && EETTHH__QQUUAARRKK__SSRR__NNIISS)) ==== 00)) {{
rreettuurrnn;;
}} 
//** AAcckknnoowwlleeddggee tthhee iinntteerrrruupptt **//
ccssrrppttrr-->>ssrr == ssrr;;

350 
DMA Devices And Drivers (Ethernet) 
Chap. 16
//** CChheecckk ssttaattuuss rreeggiisstteerr ttoo ffiigguurree oouutt tthhee ssoouurrccee ooff iinntteerrrruupptt **//
iiff ((ssrr && EETTHH__QQUUAARRKK__SSRR__TTII)) {{ //** TTrraannssmmiitt iinntteerrrruupptt **//
//** PPooiinntteerr ttoo tthhee hheeaadd ooff ttrraannssmmiitt ddeesscc rriinngg **//
ttddeessccppttrr == ((ssttrruucctt eetthh__qq__ttxx__ddeesscc **))eetthhppttrr-->>ttxxRRiinngg ++
eetthhppttrr-->>ttxxHHeeaadd;;
//** SSttaarrtt ppaacckkeett ccoouunntt aatt zzeerroo **//
ccoouunntt == 00;;
//** RReeppeeaatt uunnttiill wwee pprroocceessss aallll tthhee ddeessccrriippttoorr sslloottss **//
wwhhiillee((eetthhppttrr-->>ttxxHHeeaadd !!== eetthhppttrr-->>ttxxTTaaiill)) {{
//** IIff tthhee ddeessccrriippttoorr iiss oowwnneedd bbyy DDMMAA,, ssttoopp hheerree **//
iiff((ttddeessccppttrr-->>ccttrrllssttaatt && EETTHH__QQUUAARRKK__TTDDCCSS__OOWWNN)) {{
bbrreeaakk;;
}} 
//** DDeessccrriippttoorr wwaass pprroocceesssseedd;; iinnccrreemmeenntt ccoouunntt
**//
ccoouunntt++++;;
//** GGoo ttoo tthhee nneexxtt ddeessccrriippttoorr **//
ttddeessccppttrr ++== 11;;
//** IInnccrreemmeenntt tthhee hheeaadd ooff tthhee ttrraannssmmiitt ddeesscc rriinngg **//
eetthhppttrr-->>ttxxHHeeaadd ++== 11;;
iiff((eetthhppttrr-->>ttxxHHeeaadd >>== eetthhppttrr-->>ttxxRRiinnggSSiizzee)) {{
eetthhppttrr-->>ttxxHHeeaadd == 00;;
ttddeessccppttrr == ((ssttrruucctt eetthh__qq__ttxx__ddeesscc **))
eetthhppttrr-->>ttxxRRiinngg;;
}}
}} 
//** ’’ccoouunntt’’ ppaacckkeettss wweerree pprroocceesssseedd bbyy DDMMAA,, aanndd sslloottss aarree **//
//** nnooww ffrreeee;; ssiiggnnaall tthhee sseemmaapphhoorree aaccccoorrddiinnggllyy
**//
ssiiggnnaallnn((eetthhppttrr-->>oosseemm,, ccoouunntt));;

Sec. 16.11        Handling Interrupts From An Ethernet Device 
351
}} 
iiff((ssrr && EETTHH__QQUUAARRKK__SSRR__RRII)) {{ //** RReecceeiivvee iinntteerrrruupptt **//
//** GGeett tthhee ppooiinntteerr ttoo tthhee ttaaiill ooff tthhee rreecceeiivvee ddeesscc lliisstt **//
rrddeessccppttrr == ((ssttrruucctt eetthh__qq__rrxx__ddeesscc **))eetthhppttrr-->>rrxxRRiinngg ++
eetthhppttrr-->>rrxxTTaaiill;;
ccoouunntt == 00;;
//** SSttaarrtt ppaacckkeett ccoouunntt aatt zzeerroo **//
//** RReeppeeaatt uunnttiill wwee hhaavvee rreecceeiivveedd
**//
//** mmaaxxiimmuumm nnoo.. ppaacckkeettss tthhaatt ccaann ffiitt iinn qquueeuuee
**//
wwhhiillee((ccoouunntt <<== eetthhppttrr-->>rrxxRRiinnggSSiizzee)) {{
//** IIff tthhee ddeessccrriippttoorr iiss oowwnneedd bbyy tthhee DDMMAA,, ssttoopp **//
iiff((rrddeessccppttrr-->>ssttaattuuss && EETTHH__QQUUAARRKK__RRDDSSTT__OOWWNN)) {{
bbrreeaakk;;
}} 
//** DDeessccrriippttoorr wwaass pprroocceesssseedd;; iinnccrreemmeenntt ccoouunntt
**//
ccoouunntt++++;;
//** GGoo ttoo tthhee nneexxtt ddeessccrriippttoorr **//
rrddeessccppttrr ++== 11;;
//** IInnccrreemmeenntt tthhee ttaaiill iinnddeexx ooff tthhee rrxx ddeesscc rriinngg **//
eetthhppttrr-->>rrxxTTaaiill ++== 11;;
iiff((eetthhppttrr-->>rrxxTTaaiill >>== eetthhppttrr-->>rrxxRRiinnggSSiizzee)) {{
eetthhppttrr-->>rrxxTTaaiill == 00;;
rrddeessccppttrr == ((ssttrruucctt eetthh__qq__rrxx__ddeesscc **))
eetthhppttrr-->>rrxxRRiinngg;;
}}
}} 
//** ’’ccoouunntt’’ ppaacckkeettss wweerree rreecceeiivveedd aanndd aarree aavvaaiillaabbllee,,
**//
//**
ssoo ssiiggnnaall tthhee sseemmaapphhoorree aaccccoorrddiinnggllyy
**//
ssiiggnnaallnn((eetthhppttrr-->>iisseemm,, ccoouunntt));;
}} 
rreettuurrnn;;
}}

352 
DMA Devices And Drivers (Ethernet) 
Chap. 16
Note that when an interrupt occurs, more than one packet may have been transmit-
ted or received. The transmit interrupt code iterates through the descriptor ring, counts
the available slots, and uses signaln to signal the output semaphore. The receive inter-
rupt code iterates through the descriptor ring, counts available packets, and uses signaln
to signal the input semaphore.
16.12 Ethernet Control Functions
The Ethernet driver supports three control functions: a caller can fetch the MAC 
address from the device, add a multicast address to the set of addresses that the driver 
accepts, or remove a multicast address from the set. The MAC address is trivial: be-
cause the MAC address is copied into the control block at startup, the code merely 
copies the address from the control block into the buffer the caller has provided (arg1).
Rather than incorporate code for multicast address manipulation into ethcontrol, 
the code has been placed into two functions.  Ethmcast_add adds an address to the set 
(inserts it in the array that ethread examines), and ethmcast_remove deletes an address 
from the array.
//** eetthhccoonnttrrooll..cc -- eetthhccoonnttrrooll **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** eetthhccoonnttrrooll -- iimmpplleemmeenntt ccoonnttrrooll ffuunnccttiioonn ffoorr aa qquuaarrkk eetthheerrnneett ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll eetthhccoonnttrrooll ((
ssttrruucctt
ddeennttrryy **ddeevvppttrr,,
//** eennttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
iinntt3322
ffuunncc,,
//** ccoonnttrrooll ffuunnccttiioonn
**//
iinntt3322
aarrgg11,,
//** aarrgguummeenntt 11,, iiff nneeeeddeedd
**//
iinntt3322
aarrgg22
//** aarrgguummeenntt 22,, iiff nneeeeddeedd
**//
))
{{
ssttrruucctt
eetthhccbbllkk **eetthhppttrr;;
//** EEtthheerrttaabb eennttrryy ppooiinntteerr
**//
iinntt3322
rreettvvaall == OOKK;;
//** RReettuurrnn vvaalluuee ooff ccnnttll ffuunnccttiioonn**//
eetthhppttrr == &&eetthheerrttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
sswwiittcchh ((ffuunncc)) {{
//** GGeett MMAACC aaddddrreessss **//
ccaassee EETTHH__CCTTRRLL__GGEETT__MMAACC::

Sec. 16.12        Ethernet Control Functions 
353
mmeemmccppyy((((bbyyttee **))aarrgg11,, eetthhppttrr-->>ddeevvAAddddrreessss,,
EETTHH__AADDDDRR__LLEENN));;
bbrreeaakk;;
//** AAdddd aa mmuullttiiccaasstt aaddddrreessss **//
ccaassee EETTHH__CCTTRRLL__AADDDD__MMCCAASSTT::
rreettvvaall == eetthhmmccaasstt__aadddd((eetthhppttrr,, ((bbyyttee **))aarrgg11));;
bbrreeaakk;;
//** RReemmoovvee aa mmuullttiiccaasstt aaddddrreessss **//
ccaassee EETTHH__CCTTRRLL__RREEMMOOVVEE__MMCCAASSTT::
rreettvvaall == eetthhmmccaasstt__rreemmoovvee((eetthhppttrr,, ((bbyyttee **))aarrgg11));;
bbrreeaakk;;
ddeeffaauulltt::
rreettuurrnn SSYYSSEERRRR;;
}} 
rreettuurrnn rreettvvaall;;
}}
16.13 Perspective
DMA devices present an interesting irony to a programmer who must write a de-
vice driver. On the one hand, DMA hardware can be incredibly complex, and the docu-
mentation (which is called a data sheet) is often so difficult to understand that program-
mers find it impenetrable. Unlike a device with a few simple control and status regis-
ters, a DMA device requires a programmer to create complex data structures in memory 
and to communicate their location to the device. Furthermore, a programmer must 
understand exactly how and when the hardware sets response bits in the data structures 
and how the hardware interprets the requests that the operating system generates. On 
the other hand, once a programmer masters the documentation, the resulting driver code 
is usually smaller than the code for a non-DMA device. Thus, DMA devices have a 
steep learning curve, but offer the reward of both higher performance and smaller driver 
code.

354 
DMA Devices And Drivers (Ethernet) 
Chap. 16
16.14 Summary
A device that uses Direct Memory Access (DMA) can move an arbitrary block of 
data between the device and memory without using the processor to fetch individual 
words of data. A DMA device typically uses a descriptor ring in memory, where each 
node in the ring points to one buffer. Once the driver points the hardware to a node of 
the ring, the DMA engine performs the operation and moves to the next node on the 
ring automatically.
The chief advantage of a DMA device lies in lower overhead: the device only
needs to interrupt the processor once per block instead of once per byte or once per
word. The driver code for a DMA device is simpler than the code for a conventional 
device because the driver does not need to perform low-level operations.
EXERCISES
16.1  
Read about Ethernet packets and find the minimum packet size. At 100 Mbps, how
many packets can arrive per second?
16.2      Our code merely accepts all multicast packets and allows the driver to filter. Consult the
hardware data sheet, and rewrite the code to use the multicast filtering that the hardware 
provides.
16.3     In the previous exercise, is it necessary for the driver to check incoming packets even if
hardware filtering is enabled? Explain.
16.4      Build a test program that transmits Ethernet packets as fast as possible. How many large
packets can you send per second? How many small packets?
16.5  
The current driver is complex and the code is somewhat difficult to read. Can you
rewrite the code to allocate ring descriptor and buffers statically? Why or why not?

Chapter Contents
17.1 
Introduction, 357
17.2 
Required Functionality, 358
17.3 
Simultaneous Conversations, Timeouts, And Processes, 359
17.4 
A Consequence Of The Design, 359
17.5 
ARP Functions, 360
17.6 
Definition Of A Network Packet, 371
17.7 
The Network Input Process, 373
17.8 
Definitions For IP, 377
17.9 
IP Functions, 377
17.10 Definition Of The UDP Table, 388 
17.11 UDP Functions, 389
17.12 Internet Control Message Protocol, 403 
17.13 Dynamic Host Configuration Protocol, 404 
17.14 Perspective, 412
17.15 Summary, 413


17
A Minimal Internet Protocol 
Stack
The lure of the distant and the difficult is deceptive.
The great opportunity is where you are.
— John Burroughs
17.1 Introduction
Most embedded systems are connected — they use computer networks to access 
remote services and storage facilities. As a result, protocol software has become a re-
quired part of even small embedded operating systems. The previous chapter describes 
a basic Ethernet device driver that can send and receive packets. Although an Ethernet 
device can transfer packets across a single network, additional communication software 
is required to permit applications to communicate across the Internet. In particular, the 
TCP/Internet Protocol Suite defines the protocols used for Internet communication. 
The protocols are organized into conceptual layers, and an implementation is known as 
a protocol stack.
A complete TCP/IP stack contains many protocols, and requires much more than a 
single chapter to describe. Therefore, this chapter describes a minimal implementation 
that is sufficiently powerful to support the remote disk and remote file systems covered 
later in the book. It provides a brief description without delving into the details of the 
protocols; the reader is referred to other texts from the author that explain the protocol 
suite and a full implementation.
357

358 
A Minimal Internet Protocol Stack 
Chap. 17
17.2 Required Functionality
Our implementation of Internet protocols allows a process running on Xinu to 
communicate with an application running on a remote computer in the Internet (e.g., a
PC, Mac, or Unix system, such as Linux or Solaris). It is possible to identify a remote 
computer and exchange messages with the computer. The system includes a timeout 
mechanism that allows a receiver to be informed if no message is received within a 
specified timeout.
In terms of protocols, our implementation supports basic Internet protocols:
d IP 
Internet Protocol†
d UDP 
User Datagram Protocol
d ARP 
Address Resolution Protocol
d DHCP 
Dynamic Host Configuration Protocol
d ICMP 
Internet Control Message Protocol
The Internet Protocol (IP) defines the format of an internet packet, which is known 
as a datagram. Each datagram is carried in the data area of an Ethernet frame. The In-
ternet Protocol also defines the address format. Our implementation does not support 
IPv4 options or features such as fragmentation (i.e., it is not a complete implementa-
tion). Packet forwarding follows the pattern used in most end systems: our IPv4 
software knows the computer’s IP address, address mask for the local network, and a 
single default router address; if a destination is not on the local network, the packet is 
sent to the default router.
The User Datagram Protocol (UDP) defines a set of 16-bit port numbers that an 
operating system uses to identify a specific application program. Communicating appli-
cations must agree on the port numbers they will use. Port numbers allow simultaneous 
communication without interference: an application can interact with one remote server 
while a second application interacts with another. Our software allows a process to 
specify a port number at runtime.
The Address Resolution Protocol (ARP) provides two functions. Before another 
computer can send IP packets to our system, the computer must send an ARP packet
that requests our Ethernet address and our system must respond with an ARP reply. 
Similarly, before our system can send IP packets to another computer, it first sends an 
ARP request to obtain the computer’s Ethernet address, then uses the Ethernet address 
to send IP packets.
The Dynamic Host Configuration Protocol (DHCP) provides a mechanism that a 
computer can use to obtain an IP address, an address mask for the network, and the IP 
address of a default router. The computer broadcasts a request, and a DHCP server 
running on the network sends a response. Usually, DHCP is invoked at startup because 
the information must be obtained before normal Internet communication is possible. 
Our implementation does not invoke DHCP immediately at startup. Instead, it waits 
until a process attempts to obtain a local IP address.

†Throughout this text, IP will refer to version 4 of the Internet Protocol, which is sometimes written IPv4
to distinguish it from the successor, IPv6.

Sec. 17.2        Required Functionality 
359
The Internet Control Message Protocol (ICMP) provides error and informational 
messages that support IP. Our implementation only handles the two ICMP messages 
used by the ping program: Echo Request and Echo Reply. Because the code for ICMP
is large, we describe the structure of the protocol software without showing all the de-
tails; the code is available on the web site for the text.†
17.3 Simultaneous Conversations, Timeouts, And Processes
How should protocol software be organized? How many processes are needed? 
There is no easy answer. Our minimal stack implements the set of protocols described 
above with an elegant design that has a single network input process, named netin,‡ and 
a single IP output process named ipout. The software uses recvtime to handle timeout-
and-retransmission. That is, after transmitting a message, a sender calls recvtime to 
wait for a response. When a response arrives, the netin process calls a function that 
sends a message to the waiting process, and recvtime returns the message. If the timer 
expires, recvtime returns value TIMEOUT. The protocol software provides coordination 
between application processes and netin. We will see how the software handles 
timeout. Figure 17.1 illustrates the basic idea: the netin process places an incoming 
UDP packet in a queue associated with a UDP port number, and uses an incoming ARP 
packet to supply information for an ARP table entry. In either case, if an application 
process is waiting for the incoming packet, netin sends a message to allow the waiting 
process to run.
packet 
arrives
netin 
process
P1 
P2
UDP table entries 
(one per port)
ARP table entries 
(one per address)
Figure 17.1 The operation of the netin process that handles incoming packets
by using UDP and ARP tables to coordinate with processes that 
are waiting for the packets.
17.4 A Consequence Of The Design
The use of a netin process has an important consequence for the overall design of 
protocol software. To understand the consequence, one must know three facts. First, 
netin is the only process that reads and handles incoming packets — if netin blocks, no 
more incoming packets will be handled. Second, incoming IP packets sometimes cause 

†URL: xinu.cs.purdue.edu
‡The code for netin can be found later in the chapter in file net.c on page 374.

360 
A Minimal Internet Protocol Stack 
Chap. 17
the transmission of a reply. For example, the ping protocol, which is used to test
whether a computer is reachable, requires the transmission of a response whenever a 
ping request arrives. Third, transmission of an outgoing IP packet may require a prel-
iminary ARP exchange. That is, before it can send an IP packet, the protocol software 
may need to send an ARP request and receive an ARP reply.
Taken together, the three facts mean that netin must never attempt to transmit an
IP packet, or a deadlock can occur. To summarize:
Because the netin process must remain running to receive incoming 
packets, netin must never execute code that blocks waiting for a pack-
et to arrive. In particular, netin cannot execute code that sends an IP 
packet, such as a ping reply.
To decouple IP reply output from input, our implementation uses an extra process, 
ipout. When a local application sends a packet, transmission can proceed directly. 
When protocol software replies to an incoming packet (e.g., a response to a ping re-
quest), however, the netin process enqueues the IP packet for the IP output process to 
send. Figure 17.2 illustrates the decoupling by showing how a ping request and reply
pass through the two processes.
ping 
request 
arrives
netin 
process
queue of 
IP packets
ipout 
process
ping 
reply 
sent
Figure 17.2 The process structure with ipout decoupled from netin, and the
example of a ping request that causes a reply to be sent.
17.5 ARP Functions
Before two computers on an Ethernet can communicate using the Internet Protocol,
they must learn each other’s Ethernet addresses.† The protocol exchanges two mes-
sages: computer A broadcasts an ARP request that contains an IP address. Whichever 
computer on the network has the IP address in the request sends an ARP response that 
specifies its Ethernet address. When a response arrives, an entry is added to a table that 
is known as an ARP cache. The entry contains the remote computer’s IP address and 
its Ethernet address. Subsequent transmissions to the same destination extract the infor-
mation from the ARP cache without sending another request.
Our implementation stores ARP information in array arpcache. Struct arpentry 
defines the contents of each entry in the array to consist of: a state field (which specifies 
whether the entry is currently unused, being filled in, or already filled in), an IP address, 

†Technically, they learn MAC addresses, but in our examples, MAC addresses will be Ethernet addresses.

Sec. 17.5        ARP Functions 
361
the corresponding Ethernet address, and a process ID. If the entry is in the pending
state, the process ID field contains the ID of the process that is waiting for the informa-
tion to arrive. File arp.h defines the ARP packet format (when used on an Ethernet) 
and the format of an ARP cache entry.
//** aarrpp..hh **//
//** IItteemmss rreellaatteedd ttoo AARRPP -- ddeeffiinniittiioonn ooff ccaacchhee aanndd tthhee ppaacckkeett ffoorrmmaatt **//
##ddeeffiinnee AARRPP__HHAALLEENN
66
//** SSiizzee ooff EEtthheerrnneett MMAACC aaddddrreessss **//
##ddeeffiinnee AARRPP__PPAALLEENN
44
//** SSiizzee ooff IIPP aaddddrreessss
**//
##ddeeffiinnee AARRPP__HHTTYYPPEE
11
//** EEtthheerrnneett hhaarrddwwaarree ttyyppee
**//
##ddeeffiinnee AARRPP__PPTTYYPPEE
00xx00880000
//** IIPP pprroottooccooll ttyyppee
**//
##ddeeffiinnee AARRPP__OOPP__RREEQQ
11
//** RReeqquueesstt oopp ccooddee
**//
##ddeeffiinnee AARRPP__OOPP__RRPPLLYY
22
//** RReeppllyy oopp ccooddee
**//
##ddeeffiinnee AARRPP__SSIIZZ
1166
//** NNuummbbeerr ooff eennttrriieess iinn aa ccaacchhee **//
##ddeeffiinnee AARRPP__RREETTRRYY
33
//** NNuumm.. rreettrriieess ffoorr AARRPP rreeqquueesstt **//
##ddeeffiinnee AARRPP__TTIIMMEEOOUUTT
330000
//** RReettrryy ttiimmeerr iinn mmiilllliisseeccoonnddss
**//
//** SSttaattee ooff aann AARRPP ccaacchhee eennttrryy **//
##ddeeffiinnee AARR__FFRREEEE
00
//** SSlloott iiss uunnuusseedd
**//
##ddeeffiinnee AARR__PPEENNDDIINNGG
11
//** RReessoolluuttiioonn iinn pprrooggrreessss
**//
##ddeeffiinnee AARR__RREESSOOLLVVEEDD
22
//** EEnnttrryy iiss vvaalliidd
**//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
aarrppppaacckkeett {{
//** AARRPP ppaacckkeett ffoorr IIPP && EEtthheerrnneett **//
bbyyttee
aarrpp__eetthhddsstt[[EETTHH__AADDDDRR__LLEENN]];;//** EEtthheerrnneett ddeesstt.. MMAACC aaddddrr
**//
bbyyttee
aarrpp__eetthhssrrcc[[EETTHH__AADDDDRR__LLEENN]];;//** EEtthheerrnneett ssoouurrccee MMAACC aaddddrreessss **//
uuiinntt1166
aarrpp__eetthhttyyppee;;
//** EEtthheerrnneett ttyyppee ffiieelldd
**//
uuiinntt1166
aarrpp__hhttyyppee;;
//** AARRPP hhaarrddwwaarree ttyyppee
**//
uuiinntt1166
aarrpp__ppttyyppee;;
//** AARRPP pprroottooccooll ttyyppee
**//
bbyyttee
aarrpp__hhlleenn;;
//** AARRPP hhaarrddwwaarree aaddddrreessss lleennggtthh
**//
bbyyttee
aarrpp__pplleenn;;
//** AARRPP pprroottooccooll aaddddrreessss lleennggtthh
**//
uuiinntt1166
aarrpp__oopp;;
//** AARRPP ooppeerraattiioonn
**//
bbyyttee
aarrpp__ssnnddhhaa[[AARRPP__HHAALLEENN]];;
//** AARRPP sseennddeerr’’ss EEtthheerrnneett aaddddrr
**//
uuiinntt3322
aarrpp__ssnnddppaa;;
//** AARRPP sseennddeerr’’ss IIPP aaddddrreessss
**//
bbyyttee
aarrpp__ttaarrhhaa[[AARRPP__HHAALLEENN]];;
//** AARRPP ttaarrggeett’’ss EEtthheerrnneett aaddddrr
**//
uuiinntt3322
aarrpp__ttaarrppaa;;
//** AARRPP ttaarrggeett’’ss IIPP aaddddrreessss
**//
}};;

362 
A Minimal Internet Protocol Stack 
Chap. 17
##pprraaggmmaa ppaacckk(())
ssttrruucctt
aarrppeennttrryy {{
//** EEnnttrryy iinn tthhee AARRPP ccaacchhee
**//
iinntt3322
aarrssttaattee;;
//** SSttaattee ooff tthhee eennttrryy
**//
uuiinntt3322
aarrppaaddddrr;;
//** IIPP aaddddrreessss ooff tthhee eennttrryy
**//
ppiidd3322
aarrppiidd;;
//** WWaaiittiinngg pprroocceessss oorr --11
**//
bbyyttee
aarrhhaaddddrr[[AARRPP__HHAALLEENN]];;
//** EEtthheerrnneett aaddddrreessss ooff tthhee eennttrryy**//
}};;
eexxtteerrnn ssttrruucctt
aarrppeennttrryy aarrppccaacchhee[[]];;
ARP uses the same packet format for both requests and responses; a field in the 
header specifies the type as a request or response. In each case, the packet contains the 
sender’s IP address and Ethernet address as well as the target’s IP address and Ethernet 
address. In a request, the target’s Ethernet address is unknown, so the field contains 
zeroes.
Our ARP software consists of four functions, arp_init, arp_resolve, arp_in, and
arp_alloc. All four functions reside in a single source file, arp.c:
//** aarrpp..cc -- aarrpp__iinniitt,, aarrpp__rreessoollvvee,, aarrpp__iinn,, aarrpp__aalllloocc,, aarrpp__nnttoohh,, aarrpp__hhttoonn **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt
aarrppeennttrryy
aarrppccaacchhee[[AARRPP__SSIIZZ]];;
//** AARRPP ccaacchhee
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
** aarrpp__iinniitt
--
IInniittiiaalliizzee AARRPP ccaacchhee ffoorr aann EEtthheerrnneett iinntteerrffaaccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
aarrpp__iinniitt((vvooiidd))
{{
iinntt3322
ii;;
//** AARRPP ccaacchhee iinnddeexx
**//
ffoorr ((ii==11;; ii<<AARRPP__SSIIZZ;; ii++++)) {{
//** IInniittiiaalliizzee ccaacchhee ttoo eemmppttyy
**//
aarrppccaacchhee[[ii]]..aarrssttaattee == AARR__FFRREEEE;;
}}
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** aarrpp__rreessoollvvee
--
UUssee AARRPP ttoo rreessoollvvee aann IIPP aaddddrreessss ttoo aann EEtthheerrnneett aaddddrreessss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
aarrpp__rreessoollvvee ((
uuiinntt3322 nnxxtthhoopp,,
//** NNeexxtt--hhoopp aaddddrreessss ttoo rreessoollvvee
**//

Sec. 17.5        ARP Functions 
363
bbyyttee
mmaacc[[EETTHH__AADDDDRR__LLEENN]]
//** AArrrraayy iinnttoo wwhhiicchh EEtthheerrnneett
**//
))
//**
aaddddrreessss sshhoouulldd bbee ppllaacceedd
**//
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
aarrppppaacckkeett aappkktt;;
//** LLooccaall ppaacckkeett bbuuffffeerr
**//
iinntt3322
ii;;
//** IInnddeexx iinnttoo aarrppccaacchhee
**//
iinntt3322
sslloott;;
//** AARRPP ttaabbllee sslloott ttoo uussee
**//
ssttrruucctt
aarrppeennttrryy
**aarrppttrr;;
//** PPttrr ttoo AARRPP ccaacchhee eennttrryy
**//
iinntt3322
mmssgg;;
//** MMeessssaaggee rreettuurrnneedd bbyy rreeccvvttiimmee **//
//** UUssee MMAACC bbrrooaaddccaasstt aaddddrreessss ffoorr IIPP lliimmiitteedd bbrrooaaddccaasstt **//
iiff ((nnxxtthhoopp ==== IIPP__BBCCAASSTT)) {{
mmeemmccppyy((mmaacc,, NNeettDDaattaa..eetthhbbccaasstt,, EETTHH__AADDDDRR__LLEENN));;
rreettuurrnn OOKK;;
}} 
//** UUssee MMAACC bbrrooaaddccaasstt aaddddrreessss ffoorr IIPP nneettwwoorrkk bbrrooaaddccaasstt **//
iiff ((nnxxtthhoopp ==== NNeettDDaattaa..iippbbccaasstt)) {{
mmeemmccppyy((mmaacc,, NNeettDDaattaa..eetthhbbccaasstt,, EETTHH__AADDDDRR__LLEENN));;
rreettuurrnn OOKK;;
}} 
//** EEnnssuurree oonnllyy oonnee pprroocceessss uusseess AARRPP aatt aa ttiimmee **//
mmaasskk == ddiissaabbllee(());;
//** SSeeee iiff nneexxtt hhoopp aaddddrreessss iiss aallrreeaaddyy pprreesseenntt iinn AARRPP ccaacchhee **//
ffoorr ((ii==00;; ii<<AARRPP__SSIIZZ;; ii++++)) {{
aarrppttrr == &&aarrppccaacchhee[[ii]];;
iiff ((aarrppttrr-->>aarrssttaattee ==== AARR__FFRREEEE)) {{
ccoonnttiinnuuee;;
}} 
iiff ((aarrppttrr-->>aarrppaaddddrr ==== nnxxtthhoopp)) {{ //** AAddddddrreessss iiss iinn ccaacchhee **//
bbrreeaakk;;
}}
}} 
iiff ((ii << AARRPP__SSIIZZ)) {{
//** EEnnttrryy wwaass ffoouunndd **//
//** IIff eennttrryy iiss rreessoollvveedd -- hhaannddllee aanndd rreettuurrnn **//
iiff ((aarrppttrr-->>aarrssttaattee ==== AARR__RREESSOOLLVVEEDD)) {{

364 
A Minimal Internet Protocol Stack 
Chap. 17
mmeemmccppyy((mmaacc,, aarrppttrr-->>aarrhhaaddddrr,, AARRPP__HHAALLEENN));;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}} 
//** EEnnttrryy iiss aallrreeaaddyy ppeennddiinngg --
rreettuurrnn eerrrroorr bbeeccaauussee
**//
//**
oonnllyy oonnee pprroocceessss ccaann bbee wwaaiittiinngg aatt aa ttiimmee
**//
iiff ((aarrppttrr-->>aarrssttaattee ==== AARR__PPEENNDDIINNGG)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
//** IIPP aaddddrreessss nnoott iinn ccaacchhee --
aallllooccaattee aa nneeww ccaacchhee eennttrryy aanndd
**//
//**
sseenndd aann AARRPP rreeqquueesstt ttoo oobbttaaiinn tthhee aannsswweerr
**//
sslloott == aarrpp__aalllloocc(());;
iiff ((sslloott ==== SSYYSSEERRRR)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
aarrppttrr == &&aarrppccaacchhee[[sslloott]];;
aarrppttrr-->>aarrssttaattee == AARR__PPEENNDDIINNGG;;
aarrppttrr-->>aarrppaaddddrr == nnxxtthhoopp;;
aarrppttrr-->>aarrppiidd == ccuurrrrppiidd;;
//** HHaanndd--ccrraafftt aann AARRPP RReeqquueesstt ppaacckkeett **//
mmeemmccppyy((aappkktt..aarrpp__eetthhddsstt,, NNeettDDaattaa..eetthhbbccaasstt,, EETTHH__AADDDDRR__LLEENN));;
mmeemmccppyy((aappkktt..aarrpp__eetthhssrrcc,, NNeettDDaattaa..eetthhuuccaasstt,, EETTHH__AADDDDRR__LLEENN));;
aappkktt..aarrpp__eetthhttyyppee == EETTHH__AARRPP;;
//** PPaacckkeett ttyyppee iiss AARRPP
**//
aappkktt..aarrpp__hhttyyppee == AARRPP__HHTTYYPPEE;;
//** HHaarrddwwaarree ttyyppee iiss EEtthheerrnneett
**//
aappkktt..aarrpp__ppttyyppee == AARRPP__PPTTYYPPEE;;
//** PPrroottooccooll ttyyppee iiss IIPP
**//
aappkktt..aarrpp__hhlleenn == 00xxffff && AARRPP__HHAALLEENN;; //** EEtthheerrnneett MMAACC ssiizzee iinn bbyytteess **//
aappkktt..aarrpp__pplleenn == 00xxffff && AARRPP__PPAALLEENN;; //** IIPP aaddddrreessss ssiizzee iinn bbyytteess
**//
aappkktt..aarrpp__oopp == 00xxffffffff && AARRPP__OOPP__RREEQQ;;//** AARRPP ttyyppee iiss RReeqquueesstt
**//
mmeemmccppyy((aappkktt..aarrpp__ssnnddhhaa,, NNeettDDaattaa..eetthhuuccaasstt,, AARRPP__HHAALLEENN));;
aappkktt..aarrpp__ssnnddppaa == NNeettDDaattaa..iippuuccaasstt;; //** IIPP aaddddrreessss ooff iinntteerrffaaccee
**//
mmeemmsseett((aappkktt..aarrpp__ttaarrhhaa,, ’’\\00’’,, AARRPP__HHAALLEENN));; //** TTaarrggeett HHAA iiss uunnkknnoowwnn**//
aappkktt..aarrpp__ttaarrppaa == nnxxtthhoopp;;
//** TTaarrggeett pprroottooccooll aaddddrreessss
**//
//** CCoonnvveerrtt AARRPP ppaacckkeett ffrroomm hhoosstt ttoo nneett bbyyttee oorrddeerr **//

Sec. 17.5        ARP Functions 
365
aarrpp__hhttoonn((&&aappkktt));;
//** CCoonnvveerrtt EEtthheerrnneett hheeaaddeerr ffrroomm hhoosstt ttoo nneett bbyyttee oorrddeerr **//
eetthh__hhttoonn((((ssttrruucctt nneettppaacckkeett **))&&aappkktt));;
//** SSeenndd tthhee ppaacckkeett AARRPP__RREETTRRYY ttiimmeess aanndd aawwaaiitt rreessppoonnssee **//
mmssgg == rreeccvvccllrr(());;
ffoorr ((ii==00;; ii<<AARRPP__RREETTRRYY;; ii++++)) {{
wwrriittee((EETTHHEERR00,, ((cchhaarr **))&&aappkktt,, ssiizzeeooff((ssttrruucctt aarrppppaacckkeett))));;
mmssgg == rreeccvvttiimmee((AARRPP__TTIIMMEEOOUUTT));;
iiff ((mmssgg ==== TTIIMMEEOOUUTT)) {{
ccoonnttiinnuuee;;
}} eellssee iiff ((mmssgg ==== SSYYSSEERRRR)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} eellssee {{
//** eennttrryy iiss rreessoollvveedd **//
bbrreeaakk;;
}}
}} 
//** IIff nnoo rreessppoonnssee,, rreettuurrnn TTIIMMEEOOUUTT **//
iiff ((mmssgg ==== TTIIMMEEOOUUTT)) {{
aarrppttrr-->>aarrssttaattee == AARR__FFRREEEE;;
//** IInnvvaalliiddaattee ccaacchhee eennttrryy **//
rreessttoorree((mmaasskk));;
rreettuurrnn TTIIMMEEOOUUTT;;
}} 
//** RReettuurrnn hhaarrddwwaarree aaddddrreessss **//
mmeemmccppyy((mmaacc,, aarrppttrr-->>aarrhhaaddddrr,, AARRPP__HHAALLEENN));;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** aarrpp__iinn
--
HHaannddllee aann iinnccoommiinngg AARRPP ppaacckkeett
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
aarrpp__iinn ((
ssttrruucctt aarrppppaacckkeett **ppkkttppttrr
//** PPttrr ttoo iinnccoommiinngg ppaacckkeett
**//
))

366 
A Minimal Internet Protocol Stack 
Chap. 17
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
aarrppppaacckkeett aappkktt;;
//** LLooccaall ppaacckkeett bbuuffffeerr
**//
iinntt3322
sslloott;;
//** SSlloott iinn ccaacchhee
**//
ssttrruucctt
aarrppeennttrryy
**aarrppttrr;;
//** PPttrr ttoo AARRPP ccaacchhee eennttrryy
**//
bbooooll88
ffoouunndd;;
//** IIss tthhee sseennddeerr’’ss aaddddrreessss iinn
**//
//**
tthhee ccaacchhee??
**//
//** CCoonnvveerrtt ppaacckkeett ffrroomm nneettwwoorrkk oorrddeerr ttoo hhoosstt oorrddeerr **//
aarrpp__nnttoohh((ppkkttppttrr));;
//** VVeerriiffyy AARRPP iiss ffoorr IIPPvv44 aanndd EEtthheerrnneett **//
iiff (( ((ppkkttppttrr-->>aarrpp__hhttyyppee !!== AARRPP__HHTTYYPPEE)) ||||
((ppkkttppttrr-->>aarrpp__ppttyyppee !!== AARRPP__PPTTYYPPEE)) )) {{
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreettuurrnn;;
}} 
//** EEnnssuurree oonnllyy oonnee pprroocceessss uusseess AARRPP aatt aa ttiimmee **//
mmaasskk == ddiissaabbllee(());;
//** SSeeaarrcchh ccaacchhee ffoorr sseennddeerr’’ss IIPP aaddddrreessss **//
ffoouunndd == FFAALLSSEE;;
ffoorr ((sslloott==00;; sslloott << AARRPP__SSIIZZ;; sslloott++++)) {{
aarrppttrr == &&aarrppccaacchhee[[sslloott]];;
//** SSkkiipp ttaabbllee eennttrriieess tthhaatt aarree uunnuusseedd **//
iiff ((aarrppttrr-->>aarrssttaattee ==== AARR__FFRREEEE)) {{
ccoonnttiinnuuee;;
}} 
//** IIff sseennddeerr’’ss aaddddrreessss mmaattcchheess,, wwee’’vvee ffoouunndd iitt **//
iiff ((aarrppttrr-->>aarrppaaddddrr ==== ppkkttppttrr-->>aarrpp__ssnnddppaa)) {{
ffoouunndd == TTRRUUEE;;
bbrreeaakk;;
}}
}}

Sec. 17.5        ARP Functions 
367
iiff ((ffoouunndd)) {{
//** UUppddaattee sseennddeerr’’ss hhaarrddwwaarree aaddddrreessss **//
mmeemmccppyy((aarrppttrr-->>aarrhhaaddddrr,, ppkkttppttrr-->>aarrpp__ssnnddhhaa,, AARRPP__HHAALLEENN));;
//** IIff aa pprroocceessss wwaass wwaaiittiinngg,, iinnffoorrmm tthhee pprroocceessss **//
iiff ((aarrppttrr-->>aarrssttaattee ==== AARR__PPEENNDDIINNGG)) {{
//** MMaarrkk rreessoollvveedd aanndd nnoottiiffyy wwaaiittiinngg pprroocceessss **//
aarrppttrr-->>aarrssttaattee == AARR__RREESSOOLLVVEEDD;;
sseenndd((aarrppttrr-->>aarrppiidd,, OOKK));;
}}
}} 
//** FFoorr aann AARRPP rreeppllyy,, pprroocceessssiinngg iiss ccoommpplleettee **//
iiff ((ppkkttppttrr-->>aarrpp__oopp ==== AARRPP__OOPP__RRPPLLYY)) {{
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn;;
}} 
//** TThhee ffoolllloowwiinngg iiss ffoorr aann AARRPP rreeqquueesstt ppaacckkeett:: iiff tthhee llooccaall
**//
//**
mmaacchhiinnee iiss nnoott tthhee ttaarrggeett oorr tthhee llooccaall IIPP aaddddrreessss iiss nnoott
**//
//**
yyeett kknnoowwnn,, iiggnnoorree tthhee rreeqquueesstt ((ii..ee..,, pprroocceessssiinngg iiss ccoommpplleettee))**//
iiff ((((!!NNeettDDaattaa..iippvvaalliidd)) ||||
((ppkkttppttrr-->>aarrpp__ttaarrppaa !!== NNeettDDaattaa..iippuuccaasstt)))) {{
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn;;
}} 
//** RReeqquueesstt hhaass bbeeeenn sseenntt ttoo tthhee llooccaall mmaacchhiinnee’’ss aaddddrreessss..
SSoo,,
**//
//**
aadddd sseennddeerr’’ss iinnffoo ttoo ccaacchhee,, iiff nnoott aallrreeaaddyy pprreesseenntt
**//
iiff ((!!ffoouunndd)) {{
sslloott == aarrpp__aalllloocc(());;
iiff ((sslloott ==== SSYYSSEERRRR)) {{
//** CCaacchhee iiss ffuullll **//
kkpprriinnttff((""AARRPP ccaacchhee oovveerrffllooww oonn iinntteerrffaaccee\\nn""));;
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn;;
}}

368 
A Minimal Internet Protocol Stack 
Chap. 17
aarrppttrr == &&aarrppccaacchhee[[sslloott]];;
aarrppttrr-->>aarrppaaddddrr == ppkkttppttrr-->>aarrpp__ssnnddppaa;;
mmeemmccppyy((aarrppttrr-->>aarrhhaaddddrr,, ppkkttppttrr-->>aarrpp__ssnnddhhaa,, AARRPP__HHAALLEENN));;
aarrppttrr-->>aarrssttaattee == AARR__RREESSOOLLVVEEDD;;
}} 
//** HHaanndd--ccrraafftt aann AARRPP rreeppllyy ppaacckkeett aanndd sseenndd bbaacckk ttoo rreeqquueesstteerr
**//
mmeemmccppyy((aappkktt..aarrpp__eetthhddsstt,, ppkkttppttrr-->>aarrpp__ssnnddhhaa,, AARRPP__HHAALLEENN));;
mmeemmccppyy((aappkktt..aarrpp__eetthhssrrcc,, NNeettDDaattaa..eetthhuuccaasstt,, AARRPP__HHAALLEENN));;
aappkktt..aarrpp__eetthhttyyppee== EETTHH__AARRPP;;
//** FFrraammee ccaarrrriieess AARRPP
**//
aappkktt..aarrpp__hhttyyppee
== AARRPP__HHTTYYPPEE;;
//** HHaarrddwwaarree iiss EEtthheerrnneett **//
aappkktt..aarrpp__ppttyyppee
== AARRPP__PPTTYYPPEE;;
//** PPrroottooccooll iiss IIPP
**//
aappkktt..aarrpp__hhlleenn
== AARRPP__HHAALLEENN;;
//** EEtthheerrnneett aaddddrreessss ssiizzee**//
aappkktt..aarrpp__pplleenn
== AARRPP__PPAALLEENN;;
//** IIPP aaddddrreessss ssiizzee
**//
aappkktt..aarrpp__oopp
== AARRPP__OOPP__RRPPLLYY;;
//** TTyyppee iiss RReeppllyy
**//
//** IInnsseerrtt llooccaall EEtthheerrnneett aanndd IIPP aaddddrreessss iinn sseennddeerr ffiieellddss
**//
mmeemmccppyy((aappkktt..aarrpp__ssnnddhhaa,, NNeettDDaattaa..eetthhuuccaasstt,, AARRPP__HHAALLEENN));;
aappkktt..aarrpp__ssnnddppaa == NNeettDDaattaa..iippuuccaasstt;;
//** CCooppyy ttaarrggeett EEtthheerrnneett aanndd IIPP aaddddrreesssseess ffrroomm rreeqquueesstt ppaacckkeett **//
mmeemmccppyy((aappkktt..aarrpp__ttaarrhhaa,, ppkkttppttrr-->>aarrpp__ssnnddhhaa,, AARRPP__HHAALLEENN));;
aappkktt..aarrpp__ttaarrppaa == ppkkttppttrr-->>aarrpp__ssnnddppaa;;
//** CCoonnvveerrtt AARRPP ppaacckkeett ffrroomm hhoosstt ttoo nneettwwoorrkk bbyyttee oorrddeerr **//
aarrpp__hhttoonn((&&aappkktt));;
//** CCoonnvveerrtt tthhee EEtthheerrnneett hheeaaddeerr ttoo nneettwwoorrkk bbyyttee oorrddeerr **//
eetthh__hhttoonn((((ssttrruucctt nneettppaacckkeett **))&&aappkktt));;
//** SSeenndd tthhee rreeppllyy **//
wwrriittee((EETTHHEERR00,, ((cchhaarr **))&&aappkktt,, ssiizzeeooff((ssttrruucctt aarrppppaacckkeett))));;
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** aarrpp__aalllloocc
--
FFiinndd aa ffrreeee sslloott oorr kkiicckk oouutt aann eennttrryy ttoo ccrreeaattee oonnee

Sec. 17.5        ARP Functions 
369
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinntt3322
aarrpp__aalllloocc (())
{{
iinntt3322
sslloott;;
//** SSlloott iinn AARRPP ccaacchhee
**//
//** SSeeaarrcchh ffoorr aa ffrreeee sslloott **//
ffoorr ((sslloott==00;; sslloott << AARRPP__SSIIZZ;; sslloott++++)) {{
iiff ((aarrppccaacchhee[[sslloott]]..aarrssttaattee ==== AARR__FFRREEEE)) {{
mmeemmsseett((((cchhaarr **))&&aarrppccaacchhee[[sslloott]],,
NNUULLLLCCHH,, ssiizzeeooff((ssttrruucctt aarrppeennttrryy))));;
rreettuurrnn sslloott;;
}}
}} 
//** SSeeaarrcchh ffoorr aa rreessoollvveedd eennttrryy **//
ffoorr ((sslloott==00;; sslloott << AARRPP__SSIIZZ;; sslloott++++)) {{
iiff ((aarrppccaacchhee[[sslloott]]..aarrssttaattee ==== AARR__RREESSOOLLVVEEDD)) {{
mmeemmsseett((((cchhaarr **))&&aarrppccaacchhee[[sslloott]],,
NNUULLLLCCHH,, ssiizzeeooff((ssttrruucctt aarrppeennttrryy))));;
rreettuurrnn sslloott;;
}}
}} 
//** AAtt tthhiiss ppooiinntt,, aallll sslloottss aarree ppeennddiinngg ((sshhoouulldd nnoott hhaappppeenn)) **//
kkpprriinnttff((""AARRPP ccaacchhee ssiizzee eexxcceeeeddeedd\\nn""));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** aarrpp__nnttoohh
--
CCoonnvveerrtt AARRPP ppaacckkeett ffiieellddss ffrroomm nneett ttoo hhoosstt bbyyttee oorrddeerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
aarrpp__nnttoohh((
ssttrruucctt aarrppppaacckkeett **ppkkttppttrr
))
{{
ppkkttppttrr-->>aarrpp__hhttyyppee == nnttoohhss((ppkkttppttrr-->>aarrpp__hhttyyppee));;
ppkkttppttrr-->>aarrpp__ppttyyppee == nnttoohhss((ppkkttppttrr-->>aarrpp__ppttyyppee));;
ppkkttppttrr-->>aarrpp__oopp
== nnttoohhss((ppkkttppttrr-->>aarrpp__oopp));;
ppkkttppttrr-->>aarrpp__ssnnddppaa == nnttoohhll((ppkkttppttrr-->>aarrpp__ssnnddppaa));;

370 
A Minimal Internet Protocol Stack 
Chap. 17
ppkkttppttrr-->>aarrpp__ttaarrppaa == nnttoohhll((ppkkttppttrr-->>aarrpp__ttaarrppaa));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** aarrpp__hhttoonn
--
CCoonnvveerrtt AARRPP ppaacckkeett ffiieellddss ffrroomm nneett ttoo hhoosstt bbyyttee oorrddeerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
aarrpp__hhttoonn((
ssttrruucctt aarrppppaacckkeett **ppkkttppttrr
))
{{
ppkkttppttrr-->>aarrpp__hhttyyppee == hhttoonnss((ppkkttppttrr-->>aarrpp__hhttyyppee));;
ppkkttppttrr-->>aarrpp__ppttyyppee == hhttoonnss((ppkkttppttrr-->>aarrpp__ppttyyppee));;
ppkkttppttrr-->>aarrpp__oopp
== hhttoonnss((ppkkttppttrr-->>aarrpp__oopp));;
ppkkttppttrr-->>aarrpp__ssnnddppaa == hhttoonnll((ppkkttppttrr-->>aarrpp__ssnnddppaa));;
ppkkttppttrr-->>aarrpp__ttaarrppaa == hhttoonnll((ppkkttppttrr-->>aarrpp__ttaarrppaa));;
}}
Function arp_init is called once when the system starts. It marks each entry in the 
ARP cache free, and creates a mutual exclusion semaphore that ensures only one proc-
ess will attempt to change the ARP cache (e.g., insert an entry) at any time. Functions 
arp_resolve and arp_in are used to handle address lookup for outgoing IP packets and 
to process incoming ARP packets, respectively. The final function, arp_alloc, is called 
to allocate an entry in the table whenever a new item must be added.
Function arp_resolve is called when an IP packet is ready to be sent. Arp_resolve 
takes two arguments: the first specifies the IP address of a computer for which an Ether-
net address is needed; the second is a pointer to an array that will hold the Ethernet ad-
dress.
Although the code may seem complex, there are only three cases: the IP address is
a broadcast address, the information is already in the ARP cache, or the information is
not known. For an IP broadcast address, arp_resolve copies the Ethernet broadcast ad-
dress into the array specified by the second argument. If the information is present in 
the cache, arp_resolve finds the correct entry, copies the Ethernet address from the en-
try into the caller’s array, and returns to the caller without sending any packets over the 
network.
In the case where the requested mapping is not in the cache, arp_resolve must send 
packets over the network to obtain the information. The exchange involves sending a 
request and waiting for a reply.  Arp_resolve creates an entry in the table, marks the en-
try AR_PENDING, forms an ARP request packet, broadcasts the packet on the local net-
work, and then waits for a reply. As discussed above, arp_resolve uses recvtime to 
wait. The call to recvtime will return if a response arrives or the timer expires, which-
ever occurs first. In the next section, we will describe how an incoming packet is pro-
cessed and how a message is sent to a waiting process.

Sec. 17.5        ARP Functions 
371
The code is more complex than we have described because arp_resolve does not 
merely give up if a timeout occurs. Instead, our implementation is designed to retry the 
operation: it sends a request and waits for a reply ARP_RETRY times before it returns 
TIMEOUT to the caller.
Arp_in, the second major ARP function, runs when an incoming ARP packet ar-
rives. The netin process examines the type field in each incoming Ethernet packet. If it 
finds the ARP packet type (0x806), netin calls function arp_in to handle the packet. 
Arp_in must handle two cases: either the packet is a request that was initiated by anoth-
er computer or it is a reply, possibly to a request that we have sent.
The protocol specifies that when either type of packet arrives, ARP must examine 
the sender’s information (IP address and Ethernet address), and update the local cache 
accordingly. If a process is waiting for the reply, arp_in sends a message to the proc-
ess.
Because an ARP request is broadcast, all computers on the network receive each 
request. Therefore, after it updates the sender’s information, arp_in checks the target IP 
address in a request to determine whether the request is for the local system or some 
other computer on the network. If the request is for another computer, arp_in returns 
without taking further action. If the target IP address in the incoming request matches 
the IP address of the local system, arp_in sends an ARP reply.  Arp_in forms a reply in 
variable apkt. Once all fields of the packet have been filled in, the code calls write on 
the Ethernet device to transmit the reply back to the requester.
17.6 Definition Of A Network Packet
Our minimal implementation of network protocols combines IP, UDP, ICMP, and 
Ethernet. That is, we use a single data structure, named netpacket, to describe an Ether-
net packet that carries an IP datagram which either carries a UDP message or an ICMP 
message. File net.h defines netpacket as well as constants, such as the Ethernet type 
values used for ARP and IP. Finally, the file defines a network data structure that holds 
address information for the local machine (both Ethernet and IP addresses), and variable 
NetData to be a struct of type network.

372 
A Minimal Internet Protocol Stack 
Chap. 17
//** nneett..hh **//
##ddeeffiinnee NNEETTSSTTKK
88119922
//** SSttaacckk ssiizzee ffoorr nneettwwoorrkk sseettuupp **//
##ddeeffiinnee NNEETTPPRRIIOO
550000
//** NNeettwwoorrkk ssttaarrttuupp pprriioorriittyy
**//
##ddeeffiinnee NNEETTBBOOOOTTFFIILLEE
112288
//** SSiizzee ooff tthhee nneettbboooott ffiilleennaammee **//
//** CCoonnssttaannttss uusseedd iinn tthhee nneettwwoorrkkiinngg ccooddee **//
##ddeeffiinnee EETTHH__AARRPP
00xx00880066
//** EEtthheerrnneett ttyyppee ffoorr AARRPP
**//
##ddeeffiinnee EETTHH__IIPP
00xx00880000
//** EEtthheerrnneett ttyyppee ffoorr IIPP
**//
##ddeeffiinnee EETTHH__IIPPvv66
00xx8866DDDD
//** EEtthheerrnneett ttyyppee ffoorr IIPPvv66
**//
//** FFoorrmmaatt ooff aann EEtthheerrnneett ppaacckkeett ccaarrrryyiinngg IIPPvv44 aanndd UUDDPP **//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
nneettppaacckkeett
{{
bbyyttee
nneett__eetthhddsstt[[EETTHH__AADDDDRR__LLEENN]];;//** EEtthheerrnneett ddeesstt.. MMAACC aaddddrreessss
**//
bbyyttee
nneett__eetthhssrrcc[[EETTHH__AADDDDRR__LLEENN]];;//** EEtthheerrnneett ssoouurrccee MMAACC aaddddrreessss **//
uuiinntt1166
nneett__eetthhttyyppee;;
//** EEtthheerrnneett ttyyppee ffiieelldd
**//
bbyyttee
nneett__iippvvhh;;
//** IIPP vveerrssiioonn aanndd hhddrr lleennggtthh
**//
bbyyttee
nneett__iippttooss;;
//** IIPP ttyyppee ooff sseerrvviiccee
**//
uuiinntt1166
nneett__iipplleenn;;
//** IIPP ttoottaall ppaacckkeett lleennggtthh
**//
uuiinntt1166
nneett__iippiidd;;
//** IIPP ddaattaaggrraamm IIDD
**//
uuiinntt1166
nneett__iippffrraagg;;
//** IIPP ffllaaggss && ffrraaggmmeenntt ooffffsseett
**//
bbyyttee
nneett__iippttttll;;
//** IIPP ttiimmee--ttoo--lliivvee
**//
bbyyttee
nneett__iipppprroottoo;;
//** IIPP pprroottooccooll ((aaccttuuaallllyy ttyyppee))
**//
uuiinntt1166
nneett__iippcckkssuumm;;
//** IIPP cchheecckkssuumm
**//
uuiinntt3322
nneett__iippssrrcc;;
//** IIPP ssoouurrccee aaddddrreessss
**//
uuiinntt3322
nneett__iippddsstt;;
//** IIPP ddeessttiinnaattiioonn aaddddrreessss
**//
uunniioonn {{
ssttrruucctt {{
uuiinntt1166
nneett__uuddppssppoorrtt;;
//** UUDDPP ssoouurrccee pprroottooccooll ppoorrtt
**//
uuiinntt1166
nneett__uuddppddppoorrtt;;
//** UUDDPP ddeessttiinnaattiioonn pprroottooccooll ppoorrtt**//
uuiinntt1166
nneett__uuddpplleenn;;
//** UUDDPP ttoottaall lleennggtthh
**//
uuiinntt1166
nneett__uuddppcckkssuumm;;
//** UUDDPP cchheecckkssuumm
**//
bbyyttee
nneett__uuddppddaattaa[[11550000--2288]];;//** UUDDPP ppaayyllooaadd ((11550000--aabboovvee))**//
}};;
ssttrruucctt {{
bbyyttee
nneett__iiccttyyppee;;
//** IICCMMPP mmeessssaaggee ttyyppee
**//
bbyyttee
nneett__iiccccooddee;;
//** IICCMMPP ccooddee ffiieelldd ((00 ffoorr ppiinngg)) **//
uuiinntt1166
nneett__iicccckkssuumm;;
//** IICCMMPP mmeessssaaggee cchheecckkssuumm
**//
uuiinntt1166
nneett__iicciiddeenntt;;
//** IICCMMPP iiddeennttiiffiieerr
**//
uuiinntt1166
nneett__iiccsseeqq;;
//** IICCMMPP sseeqquueennccee nnuummbbeerr
**//
bbyyttee
nneett__iiccddaattaa[[11550000--2288]];;//** IICCMMPP ppaayyllooaadd ((11550000--aabboovvee))**//
}};;
}};;
}};;
##pprraaggmmaa ppaacckk(())

Sec. 17.6        Definition Of A Network Packet 
373
##ddeeffiinnee PPAACCKKLLEENN ssiizzeeooff((ssttrruucctt nneettppaacckkeett))
eexxtteerrnn
bbppiidd3322
nneettbbuuffppooooll;;
//** IIDD ooff nneett ppaacckkeett bbuuffffeerr ppooooll **//
ssttrruucctt
nneettwwoorrkk {{
uuiinntt3322
iippuuccaasstt;;
uuiinntt3322
iippbbccaasstt;;
uuiinntt3322
iippmmaasskk;;
uuiinntt3322
iipppprreeffiixx;;
uuiinntt3322
iipprroouutteerr;;
uuiinntt3322
bboooottsseerrvveerr;;
bbooooll88
iippvvaalliidd;;
bbyyttee
eetthhuuccaasstt[[EETTHH__AADDDDRR__LLEENN]];;
bbyyttee
eetthhbbccaasstt[[EETTHH__AADDDDRR__LLEENN]];;
cchhaarr
bboooottffiillee[[NNEETTBBOOOOTTFFIILLEE]];;
}};;
eexxtteerrnn
ssttrruucctt
nneettwwoorrkk NNeettDDaattaa;;
//** LLooccaall NNeettwwoorrkk IInntteerrffaaccee
**//
17.7 The Network Input Process
At startup, Xinu calls function net_init to initialize data structures and start the net-
work processes. After it creates the network buffer pool and initializes global variables, 
net_init calls arp_init, udp_init, and icmp_init. It then initializes the IP output queue to 
empty, and creates the netin and netout processes.
The netin process repeatedly allocates a buffer, waits for the next packet, and then 
performs packet demultiplexing. That is, netin uses information in each incoming pack-
et to decide which protocol to use to process the packet. When it reads a packet from
an Ethernet, netin uses the Ethernet type field in the packet to determine whether the 
Ethernet packet is carrying an ARP message or an IP datagram. In the case of ARP, 
netin passes the packet to arp_in, which performs input processing on arriving ARP 
packets. In the case of an IP datagram, netin passes the packet to ip_in, which performs 
input processing on arriving IP datagrams.
The code contains two additional cases: one for IPv6 and a default for all other 
packets. In each case, the action is the same: netin drops (i.e., discards) the packet 
without further processing. To do so, netin calls freebuf and passes a pointer to the 
buffer. The case for IPv6 has been separated from the default to indicate where one
would add code for IPv6.
File net.c contains the code for both net_init and netin.

374 
A Minimal Internet Protocol Stack 
Chap. 17
//** nneett..cc -- nneett__iinniitt,, nneettiinn,, eetthh__hhttoonn **//
##iinncclluuddee <<xxiinnuu..hh>>
##iinncclluuddee <<ssttddiioo..hh>>
ssttrruucctt
nneettwwoorrkk NNeettDDaattaa;;
bbppiidd3322
nneettbbuuffppooooll;;
//**------------------------------------------------------------------------------------------------------------------------------------------------
** nneett__iinniitt
--
IInniittiiaalliizzee nneettwwoorrkk ddaattaa ssttrruuccttuurreess aanndd pprroocceesssseess
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
nneett__iinniitt ((vvooiidd))
{{
iinntt3322
nnbbuuffss;;
//** TToottaall nnoo ooff bbuuffffeerrss
**//
//** IInniittiiaalliizzee tthhee nneettwwoorrkk ddaattaa ssttrruuccttuurree **//
mmeemmsseett((((cchhaarr **))&&NNeettDDaattaa,, NNUULLLLCCHH,, ssiizzeeooff((ssttrruucctt nneettwwoorrkk))));;
//** OObbttaaiinn tthhee EEtthheerrnneett MMAACC aaddddrreessss **//
ccoonnttrrooll((EETTHHEERR00,, EETTHH__CCTTRRLL__GGEETT__MMAACC,, ((iinntt3322))NNeettDDaattaa..eetthhuuccaasstt,, 00));;
mmeemmsseett((((cchhaarr **))NNeettDDaattaa..eetthhbbccaasstt,, 00xxFFFF,, EETTHH__AADDDDRR__LLEENN));;
//** CCrreeaattee tthhee nneettwwoorrkk bbuuffffeerr ppooooll **//
nnbbuuffss == UUDDPP__SSLLOOTTSS ** UUDDPP__QQSSIIZZ ++ IICCMMPP__SSLLOOTTSS ** IICCMMPP__QQSSIIZZ ++ 11;;
nneettbbuuffppooooll == mmkkbbuuffppooooll((PPAACCKKLLEENN,, nnbbuuffss));;
//** IInniittiiaalliizzee tthhee AARRPP ccaacchhee **//
aarrpp__iinniitt(());;
//** IInniittiiaalliizzee UUDDPP **//
uuddpp__iinniitt(());;
//** IInniittiiaalliizzee IICCMMPP **//
iiccmmpp__iinniitt(());;
//** IInniittiiaalliizzee tthhee IIPP oouuttppuutt qquueeuuee **//

Sec. 17.7        The Network Input Process 
375
iippooqquueeuuee..iiqqhheeaadd == 00;;
iippooqquueeuuee..iiqqttaaiill == 00;;
iippooqquueeuuee..iiqqsseemm == sseemmccrreeaattee((00));;
iiff((((iinntt3322))iippooqquueeuuee..iiqqsseemm ==== SSYYSSEERRRR)) {{
ppaanniicc((""CCaannnnoott ccrreeaattee iipp oouuttppuutt qquueeuuee sseemmaapphhoorree""));;
rreettuurrnn;;
}} 
//** CCrreeaattee tthhee IIPP oouuttppuutt pprroocceessss **//
rreessuummee((ccrreeaattee((iippoouutt,, NNEETTSSTTKK,, NNEETTPPRRIIOO,, ""iippoouutt"",, 00,, NNUULLLL))));;
//** CCrreeaattee aa nneettwwoorrkk iinnppuutt pprroocceessss **//
rreessuummee((ccrreeaattee((nneettiinn,, NNEETTSSTTKK,, NNEETTPPRRIIOO,, ""nneettiinn"",, 00,, NNUULLLL))));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** nneettiinn
--
RReeppeeaatteeddllyy rreeaadd aanndd pprroocceessss tthhee nneexxtt iinnccoommiinngg ppaacckkeett
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
pprroocceessss nneettiinn (())
{{
ssttrruucctt
nneettppaacckkeett **ppkktt;;
//** PPttrr ttoo ccuurrrreenntt ppaacckkeett
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee ffrroomm rreeaadd
**//
//** DDoo ffoorreevveerr:: rreeaadd aa ppaacckkeett ffrroomm tthhee nneettwwoorrkk aanndd pprroocceessss **//
wwhhiillee((11)) {{
//** AAllllooccaattee aa bbuuffffeerr **//
ppkktt == ((ssttrruucctt nneettppaacckkeett **))ggeettbbuuff((nneettbbuuffppooooll));;
//** OObbttaaiinn nneexxtt ppaacckkeett tthhaatt aarrrriivveess **//
rreettvvaall == rreeaadd((EETTHHEERR00,, ((cchhaarr **))ppkktt,, PPAACCKKLLEENN));;
iiff((rreettvvaall ==== SSYYSSEERRRR)) {{
ppaanniicc((""CCaannnnoott rreeaadd ffrroomm EEtthheerrnneett\\nn""));;
}} 
//** CCoonnvveerrtt EEtthheerrnneett TTyyppee ttoo hhoosstt oorrddeerr **//
eetthh__nnttoohh((ppkktt));;

376 
A Minimal Internet Protocol Stack 
Chap. 17
//** DDeemmuullttiipplleexx oonn EEtthheerrnneett ttyyppee **//
sswwiittcchh ((ppkktt-->>nneett__eetthhttyyppee)) {{
ccaassee EETTHH__AARRPP::
//** HHaannddllee AARRPP
**//
aarrpp__iinn((((ssttrruucctt aarrppppaacckkeett **))ppkktt));;
ccoonnttiinnuuee;;
ccaassee EETTHH__IIPP::
//** HHaannddllee IIPP
**//
iipp__iinn((ppkktt));;
ccoonnttiinnuuee;;
ccaassee EETTHH__IIPPvv66::
//** HHaannddllee IIPPvv66
**//
ffrreeeebbuuff((((cchhaarr **))ppkktt));;
ccoonnttiinnuuee;;
ddeeffaauulltt::
//** IIggnnoorree aallll ootthheerr iinnccoommiinngg ppaacckkeettss
**//
ffrreeeebbuuff((((cchhaarr **))ppkktt));;
ccoonnttiinnuuee;;
}}
}}
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** eetthh__hhttoonn
--
CCoonnvveerrtt EEtthheerrnneett ttyyppee ffiieelldd ttoo nneettwwoorrkk bbyyttee oorrddeerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
eetthh__hhttoonn((
ssttrruucctt nneettppaacckkeett **ppkkttppttrr
))
{{
ppkkttppttrr-->>nneett__eetthhttyyppee == hhttoonnss((ppkkttppttrr-->>nneett__eetthhttyyppee));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** eetthh__nnttoohh
--
CCoonnvveerrtt EEtthheerrnneett ttyyppee ffiieelldd ttoo hhoosstt bbyyttee oorrddeerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
eetthh__nnttoohh((
ssttrruucctt nneettppaacckkeett **ppkkttppttrr
))
{{
ppkkttppttrr-->>nneett__eetthhttyyppee == nnttoohhss((ppkkttppttrr-->>nneett__eetthhttyyppee));;
}}

Sec. 17.8        Definitions For IP 
377
17.8 Definitions For IP
File ip.h contains definitions needed for functions that handle the Internet Protocol 
(IP), including constants for the local broadcast address, type values for UDP and 
ICMP, and header constants. The file also defines struct iqentry that specifies the con-
tents of an entry in the IP output queue.
//** iipp..hh
--
CCoonnssttaannttss rreellaatteedd ttoo IInntteerrnneett PPrroottooccooll vveerrssiioonn 44 ((IIPPvv44)) **//
##ddeeffiinnee IIPP__BBCCAASSTT
00xxffffffffffffffff
//** IIPP llooccaall bbrrooaaddccaasstt aaddddrreessss
**//
##ddeeffiinnee IIPP__TTHHIISS
00xxffffffffffffffff
//** ""tthhiiss hhoosstt"" ssrrcc IIPP aaddddrreessss
**//
##ddeeffiinnee IIPP__AALLLLZZEERROOSS
00xx0000000000000000
//** TThhee aallll--zzeerrooss IIPP aaddddrreessss
**//
##ddeeffiinnee IIPP__IICCMMPP
11
//** IICCMMPP pprroottooccooll ttyyppee ffoorr IIPP
**//
##ddeeffiinnee IIPP__UUDDPP
1177
//** UUDDPP pprroottooccooll ttyyppee ffoorr IIPP
**//
##ddeeffiinnee IIPP__AASSIIZZEE
44
//** BByytteess iinn aann IIPP aaddddrreessss
**//
##ddeeffiinnee IIPP__HHDDRR__LLEENN
2200
//** BByytteess iinn aann IIPP hheeaaddeerr
**//
##ddeeffiinnee IIPP__VVHH
00xx4455
//** IIPP vveerrssiioonn aanndd hhddrr lleennggtthh
**//
##ddeeffiinnee IIPP__OOQQSSIIZZ
88
//** SSiizzee ooff IIPP oouuttppuutt qquueeuuee
**//
//** QQuueeuuee ooff oouuttggooiinngg IIPP ppaacckkeettss wwaaiittiinngg ffoorr iippoouutt pprroocceessss **//
ssttrruucctt
iiqqeennttrryy {{
iinntt3322
iiqqhheeaadd;;
//** IInnddeexx ooff nneexxtt ppaacckkeett ttoo sseenndd **//
iinntt3322
iiqqttaaiill;;
//** IInnddeexx ooff nneexxtt ffrreeee sslloott
**//
ssiidd3322
iiqqsseemm;;
//** SSeemmaapphhoorree tthhaatt ccoouunnttss ppkkttss
**//
ssttrruucctt
nneettppaacckkeett **iiqqbbuuff[[IIPP__OOQQSSIIZZ]];;//** CCiirrccuullaarr ppaacckkeett qquueeuuee
**//
}};;
eexxtteerrnn
ssttrruucctt
iiqqeennttrryy iippooqquueeuuee;;
//** NNeettwwoorrkk oouuttppuutt qquueeuuee
**//
17.9 IP Functions
Our IP software uses eight functions that are specified in file ip.c: ip_in, ip_send,
ip_local, ip_out, ipcksum, ip_hton, ip_ntoh, and ip_enqueue. In addition, the file con-
tains the code for ipout, the IP output process.
On input, ip_in passes valid datagrams to ip_local, which examines the type field 
in the datagram. Datagrams carrying UDP are passed to udp_in, datagrams carrying 
ICMP are passed to icmp_in, and other datagrams are dropped.

378 
A Minimal Internet Protocol Stack 
Chap. 17
//** iipp..cc -- iipp__iinn,, iipp__sseenndd,, iipp__llooccaall,, iipp__oouutt,, iippcckkssuumm,, iipp__hhttoonn,, iipp__nnttoohh,,
**//
//**
iippoouutt,, iipp__eennqquueeuuee
**//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt
iiqqeennttrryy iippooqquueeuuee;;
//** QQuueeuuee ooff oouuttggooiinngg ppaacckkeettss
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
** iipp__iinn
--
HHaannddllee aann IIPP ppaacckkeett tthhaatt hhaass aarrrriivveedd oovveerr aa nneettwwoorrkk
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
iipp__iinn((
ssttrruucctt nneettppaacckkeett **ppkkttppttrr
//** PPooiinntteerr ttoo tthhee ppaacckkeett
**//
))
{{
iinntt3322
iiccmmpplleenn;;
//** LLeennggtthh ooff IICCMMPP mmeessssaaggee
**//
//** VVeerriiffyy cchheecckkssuumm **//
iiff ((iippcckkssuumm((ppkkttppttrr)) !!== 00)) {{
kkpprriinnttff((""IIPP hheeaaddeerr cchheecckkssuumm ffaaiilleedd\\nn\\rr""));;
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreettuurrnn;;
}} 
//** CCoonnvveerrtt IIPP hheeaaddeerr ffiieellddss ttoo hhoosstt oorrddeerr **//
iipp__nnttoohh((ppkkttppttrr));;
//** EEnnssuurree vveerrssiioonn aanndd lleennggtthh aarree vvaalliidd **//
iiff ((ppkkttppttrr-->>nneett__iippvvhh !!== 00xx4455)) {{
kkpprriinnttff((""IIPP vveerrssiioonn ffaaiilleedd\\nn\\rr""));;
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreettuurrnn;;
}} 
//** VVeerriiffyy eennccaappssuullaatteedd pprroottoottccooll cchheecckkssuummss aanndd tthheenn ccoonnvveerrtt
**//
//**
tthhee eennccaappssuullaatteedd hheeaaddeerrss ttoo hhoosstt bbyyttee oorrddeerr
**//
sswwiittcchh ((ppkkttppttrr-->>nneett__iipppprroottoo)) {{
ccaassee IIPP__UUDDPP::
//** SSkkiippppiinngg UUDDPP cchheecckkssuumm ffoorr nnooww **//

Sec. 17.9        IP Functions
379
uuddpp__nnttoohh((ppkkttppttrr));;
bbrreeaakk;;
ccaassee IIPP__IICCMMPP::
iiccmmpplleenn == ppkkttppttrr-->>nneett__iipplleenn -- IIPP__HHDDRR__LLEENN;;
iiff ((iiccmmpp__cckkssuumm((((cchhaarr **))&&ppkkttppttrr-->>nneett__iiccttyyppee,,iiccmmpplleenn)) !!== 00)){{
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreettuurrnn;;
}} 
iiccmmpp__nnttoohh((ppkkttppttrr));;
bbrreeaakk;;
ddeeffaauulltt::
bbrreeaakk;;
}} 
//** DDeelliivveerr 225555..225555..225555..225555 ttoo llooccaall ssttaacckk **//
iiff ((ppkkttppttrr-->>nneett__iippddsstt ==== IIPP__BBCCAASSTT)) {{
iipp__llooccaall((ppkkttppttrr));;
rreettuurrnn;;
}} 
//** IIff wwee ddoo nnoott yyeett hhaavvee aa vvaalliidd aaddddrreessss,, aacccceepptt UUDDPP ppaacckkeettss
**//
//**
((ttoo ggeett DDHHCCPP rreepplliieess)) aanndd ddrroopp ootthheerrss
**//
iiff ((!!NNeettDDaattaa..iippvvaalliidd)) {{
iiff ((ppkkttppttrr-->>nneett__iipppprroottoo ==== IIPP__UUDDPP)) {{
iipp__llooccaall((ppkkttppttrr));;
rreettuurrnn;;
}} eellssee {{
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreettuurrnn;;
}}
}} 
//** IIff ppaacckkeett iiss ddeessttiinneedd ffoorr uuss,, aacccceepptt iitt;; ootthheerrwwiissee,, ddrroopp iitt
**//
iiff (( ((ppkkttppttrr-->>nneett__iippddsstt ==== NNeettDDaattaa..iippuuccaasstt)) ||||
((ppkkttppttrr-->>nneett__iippddsstt ==== NNeettDDaattaa..iippbbccaasstt)) ||||
((ppkkttppttrr-->>nneett__iippddsstt ==== IIPP__BBCCAASSTT))
)) {{
iipp__llooccaall((ppkkttppttrr));;
rreettuurrnn;;

380 
A Minimal Internet Protocol Stack 
Chap. 17
}} eellssee {{
//** DDrroopp tthhee ppaacckkeett **//
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreettuurrnn;;
}}
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** iipp__sseenndd
--
SSeenndd aann oouuttggooiinngg IIPP ddaattaaggrraamm ffrroomm tthhee llooccaall ssttaacckk
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
iipp__sseenndd((
ssttrruucctt nneettppaacckkeett **ppkkttppttrr
//** PPooiinntteerr ttoo tthhee ppaacckkeett
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
uuiinntt3322
ddeesstt;;
//** DDeessttiinnaattiioonn ooff tthhee ddaattaaggrraamm
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee ffrroomm ffuunnccttiioonnss
**//
uuiinntt3322
nnxxtthhoopp;;
//** NNeexxtt--hhoopp aaddddrreessss
**//
mmaasskk == ddiissaabbllee(());;
//** PPiicckk uupp tthhee IIPP ddeessttiinnaattiioonn aaddddrreessss ffrroomm tthhee ppaacckkeett **//
ddeesstt == ppkkttppttrr-->>nneett__iippddsstt;;
//** LLoooopp bbaacckk ttoo llooccaall ssttaacckk iiff ddeessttiinnaattiioonn 112277..00..00..00//88 **//
iiff ((((ddeesstt&&00xxffff000000000000)) ==== 00xx77ff000000000000)) {{
iipp__llooccaall((ppkkttppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}} 
//** LLoooopp bbaacckk iiff tthhee ddeessttiinnaattiioonn mmaattcchheess oouurr IIPP uunniiccaasstt aaddddrreessss
**//
iiff ((ddeesstt ==== NNeettDDaattaa..iippuuccaasstt)) {{
iipp__llooccaall((ppkkttppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}

Sec. 17.9        IP Functions
381
//** BBrrooaaddccaasstt iiff ddeessttiinnaattiioonn iiss 225555..225555..225555..225555 **//
iiff (( ((ddeesstt ==== IIPP__BBCCAASSTT)) ||||
((ddeesstt ==== NNeettDDaattaa..iippbbccaasstt)) )) {{
mmeemmccppyy((ppkkttppttrr-->>nneett__eetthhddsstt,, NNeettDDaattaa..eetthhbbccaasstt,,
EETTHH__AADDDDRR__LLEENN));;
rreettvvaall == iipp__oouutt((ppkkttppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn rreettvvaall;;
}} 
//** IIff ddeessttiinnaattiioonn iiss oonn tthhee llooccaall nneettwwoorrkk,, nneexxtt hhoopp iiss tthhee
**//
//**
ddeessttiinnaattiioonn;; ootthheerrwwiissee,, nneexxtt hhoopp iiss ddeeffaauulltt rroouutteerr
**//
iiff (( ((ddeesstt && NNeettDDaattaa..iippmmaasskk)) ==== NNeettDDaattaa..iipppprreeffiixx)) {{
//** NNeexxtt hhoopp iiss tthhee ddeessttiinnaattiioonn iittsseellff **//
nnxxtthhoopp == ddeesstt;;
}} eellssee {{
//** NNeexxtt hhoopp iiss ddeeffaauulltt rroouutteerr oonn tthhee nneettwwoorrkk **//
nnxxtthhoopp == NNeettDDaattaa..iipprroouutteerr;;
}} 
iiff ((nnxxtthhoopp ==== 00)) {{
//** DDeesstt.. iinnvvaalliidd oorr nnoo ddeeffaauulltt rroouuttee
**//
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** RReessoollvvee tthhee nneexxtt--hhoopp aaddddrreessss ttoo ggeett aa MMAACC aaddddrreessss **//
rreettvvaall == aarrpp__rreessoollvvee((nnxxtthhoopp,, ppkkttppttrr-->>nneett__eetthhddsstt));;
iiff ((rreettvvaall !!== OOKK)) {{
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** SSeenndd tthhee ppaacckkeett **//
rreettvvaall == iipp__oouutt((ppkkttppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn rreettvvaall;;
}}

382 
A Minimal Internet Protocol Stack 
Chap. 17
//**------------------------------------------------------------------------------------------------------------------------------------------------
** iipp__llooccaall
--
DDeelliivveerr aann IIPP ddaattaaggrraamm ttoo tthhee llooccaall ssttaacckk
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
iipp__llooccaall((
ssttrruucctt nneettppaacckkeett **ppkkttppttrr
//** PPooiinntteerr ttoo tthhee ppaacckkeett
**//
))
{{
//** UUssee ddaattaaggrraamm ccoonntteennttss ttoo ddeetteerrmmiinnee hhooww ttoo pprroocceessss **//
sswwiittcchh ((ppkkttppttrr-->>nneett__iipppprroottoo)) {{
ccaassee IIPP__UUDDPP::
uuddpp__iinn((ppkkttppttrr));;
rreettuurrnn;;
ccaassee IIPP__IICCMMPP::
iiccmmpp__iinn((ppkkttppttrr));;
rreettuurrnn;;
ddeeffaauulltt::
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreettuurrnn;;
}}
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
iipp__oouutt
--
TTrraannssmmiitt aann oouuttggooiinngg IIPP ddaattaaggrraamm
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
iipp__oouutt((
ssttrruucctt nneettppaacckkeett **ppkkttppttrr
//** PPooiinntteerr ttoo tthhee ppaacckkeett
**//
))
{{
uuiinntt1166
cckkssuumm;;
//** CChheecckkssuumm iinn hhoosstt bbyyttee oorrddeerr
**//
iinntt3322
lleenn;;
//** LLeennggtthh ooff IICCMMPP mmeessssaaggee
**//
iinntt3322
ppkkttlleenn;;
//** LLeennggtthh ooff eennttiirree ppaacckkeett
**//
iinntt3322
rreettvvaall;;
//** VVaalluuee rreettuurrnneedd bbyy wwrriittee
**//
//** CCoommppuuttee ttoottaall ppaacckkeett lleennggtthh **//
ppkkttlleenn == ppkkttppttrr-->>nneett__iipplleenn ++ EETTHH__HHDDRR__LLEENN;;

Sec. 17.9        IP Functions
383
//** CCoonnvveerrtt eennccaappssuullaatteedd pprroottooccooll ttoo nneettwwoorrkk bbyyttee oorrddeerr **//
sswwiittcchh ((ppkkttppttrr-->>nneett__iipppprroottoo)) {{
ccaassee IIPP__UUDDPP::
ppkkttppttrr-->>nneett__uuddppcckkssuumm == 00;;
uuddpp__hhttoonn((ppkkttppttrr));;
//** ......sskkiippppiinngg UUDDPP cchheecckkssuumm ccoommppuuttaattiioonn **//
bbrreeaakk;;
ccaassee IIPP__IICCMMPP:: 
iiccmmpp__hhttoonn((ppkkttppttrr));;
//** CCoommppuuttee IICCMMPP cchheecckkssuumm **//
ppkkttppttrr-->>nneett__iicccckkssuumm == 00;;
lleenn == ppkkttppttrr-->>nneett__iipplleenn--IIPP__HHDDRR__LLEENN;;
cckkssuumm == iiccmmpp__cckkssuumm((((cchhaarr **))&&ppkkttppttrr-->>nneett__iiccttyyppee,,
lleenn));;
ppkkttppttrr-->>nneett__iicccckkssuumm == 00xxffffffff && hhttoonnss((cckkssuumm));;
bbrreeaakk;;
ddeeffaauulltt::
bbrreeaakk;;
}} 
//** CCoonnvveerrtt IIPP ffiieellddss ttoo nneettwwoorrkk bbyyttee oorrddeerr **//
iipp__hhttoonn((ppkkttppttrr));;
//** CCoommppuuttee IIPP hheeaaddeerr cchheecckkssuumm **//
ppkkttppttrr-->>nneett__iippcckkssuumm == 00;;
cckkssuumm == iippcckkssuumm((ppkkttppttrr));;
ppkkttppttrr-->>nneett__iippcckkssuumm == 00xxffffffff && hhttoonnss((cckkssuumm));;
//** CCoonnvveerrtt EEtthheerrnneett ffiieellddss ttoo nneettwwoorrkk bbyyttee oorrddeerr **//
eetthh__hhttoonn((ppkkttppttrr));;

384 
A Minimal Internet Protocol Stack 
Chap. 17
//** SSeenndd ppaacckkeett oovveerr tthhee EEtthheerrnneett **//
rreettvvaall == wwrriittee((EETTHHEERR00,, ((cchhaarr**))ppkkttppttrr,, ppkkttlleenn));;
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} eellssee {{
rreettuurrnn OOKK;;
}}
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** iippcckkssuumm
--
CCoommppuuttee tthhee IIPP hheeaaddeerr cchheecckkssuumm ffoorr aa ddaattaaggrraamm
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
uuiinntt1166
iippcckkssuumm((
ssttrruucctt
nneettppaacckkeett **ppkktt
//** PPooiinntteerr ttoo tthhee ppaacckkeett
**//
))
{{
uuiinntt1166
**hhppttrr;;
//** PPttrr ttoo 1166--bbiitt hheeaaddeerr vvaalluueess
**//
iinntt3322
ii;;
//** CCoouunnttss 1166--bbiitt vvaalluueess iinn hhddrr
**//
uuiinntt1166
wwoorrdd;;
//** OOnnee 1166--bbiitt wwoorrdd
**//
uuiinntt3322
cckkssuumm;;
//** CCoommppuutteedd vvaalluuee ooff cchheecckkssuumm
**//
hhppttrr== ((uuiinntt1166 **)) &&ppkktt-->>nneett__iippvvhh;;
//** SSuumm 1166--bbiitt wwoorrddss iinn tthhee ppaacckkeett **//
cckkssuumm == 00;;
ffoorr ((ii==00;; ii<<1100;; ii++++)) {{
wwoorrdd == **hhppttrr++++;;
cckkssuumm ++== ((uuiinntt3322)) hhttoonnss((wwoorrdd));;
}} 
//** AAdddd iinn ccaarrrryy,, aanndd ttaakkee tthhee oonneess--ccoommpplleemmeenntt **//
cckkssuumm ++== ((cckkssuumm >>>> 1166));;
cckkssuumm == 00xxffffffff && ~~cckkssuumm;;

Sec. 17.9        IP Functions
385
//** UUssee aallll--11ss ffoorr zzeerroo **//
iiff ((cckkssuumm ==== 00xxffffffff)) {{
cckkssuumm == 00;;
}} 
rreettuurrnn ((uuiinntt1166)) ((00xxffffffff && cckkssuumm));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** iipp__nnttoohh
--
CCoonnvveerrtt IIPP hheeaaddeerr ffiieellddss ttoo hhoosstt bbyyttee oorrddeerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
iipp__nnttoohh((
ssttrruucctt nneettppaacckkeett **ppkkttppttrr
))
{{
ppkkttppttrr-->>nneett__iipplleenn == nnttoohhss((ppkkttppttrr-->>nneett__iipplleenn));;
ppkkttppttrr-->>nneett__iippiidd == nnttoohhss((ppkkttppttrr-->>nneett__iippiidd));;
ppkkttppttrr-->>nneett__iippffrraagg == nnttoohhss((ppkkttppttrr-->>nneett__iippffrraagg));;
ppkkttppttrr-->>nneett__iippssrrcc == nnttoohhll((ppkkttppttrr-->>nneett__iippssrrcc));;
ppkkttppttrr-->>nneett__iippddsstt == nnttoohhll((ppkkttppttrr-->>nneett__iippddsstt));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** iipp__hhttoonn
--
CCoonnvveerrtt IIPP hheeaaddeerr ffiieellddss ttoo nneettwwoorrkk bbyyttee oorrddeerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
iipp__hhttoonn((
ssttrruucctt nneettppaacckkeett **ppkkttppttrr
))
{{
ppkkttppttrr-->>nneett__iipplleenn == hhttoonnss((ppkkttppttrr-->>nneett__iipplleenn));;
ppkkttppttrr-->>nneett__iippiidd == hhttoonnss((ppkkttppttrr-->>nneett__iippiidd));;
ppkkttppttrr-->>nneett__iippffrraagg == hhttoonnss((ppkkttppttrr-->>nneett__iippffrraagg));;
ppkkttppttrr-->>nneett__iippssrrcc == hhttoonnll((ppkkttppttrr-->>nneett__iippssrrcc));;
ppkkttppttrr-->>nneett__iippddsstt == hhttoonnll((ppkkttppttrr-->>nneett__iippddsstt));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
iippoouutt
--
PPrroocceessss tthhaatt ttrraannssmmiittss IIPP ppaacckkeettss ffrroomm tthhee IIPP oouuttppuutt qquueeuuee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//

386 
A Minimal Internet Protocol Stack 
Chap. 17
pprroocceessss iippoouutt((vvooiidd))
{{
ssttrruucctt
nneettppaacckkeett **ppkkttppttrr;;
//** PPooiinntteerr ttoo nneexxtt tthhee ppaacckkeett
**//
ssttrruucctt
iiqqeennttrryy
**iippqqppttrr;;
//** PPooiinntteerr ttoo IIPP oouuttppuutt qquueeuuee
**//
uuiinntt3322
ddeessttiipp;;
//** DDeessttiinnaattiioonn IIPP aaddddrreessss
**//
uuiinntt3322
nnxxtthhoopp;;
//** NNeexxtt hhoopp IIPP aaddddrreessss
**//
iinntt3322
rreettvvaall;;
//** VVaalluuee rreettuurrnneedd bbyy ffuunnccttiioonnss
**//
iippqqppttrr == &&iippooqquueeuuee;;
wwhhiillee((11)) {{
//** OObbttaaiinn nneexxtt ppaacckkeett ffrroomm tthhee IIPP oouuttppuutt qquueeuuee **//
wwaaiitt((iippqqppttrr-->>iiqqsseemm));;
ppkkttppttrr == iippqqppttrr-->>iiqqbbuuff[[iippqqppttrr-->>iiqqhheeaadd++++]];;
iiff ((iippqqppttrr-->>iiqqhheeaadd >>== IIPP__OOQQSSIIZZ)) {{
iippqqppttrr-->>iiqqhheeaadd== 00;;
}} 
//** FFiillll iinn tthhee MMAACC ssoouurrccee aaddddrreessss **//
mmeemmccppyy((ppkkttppttrr-->>nneett__eetthhssrrcc,, NNeettDDaattaa..eetthhuuccaasstt,, EETTHH__AADDDDRR__LLEENN));;
//** EExxttrraacctt ddeessttiinnaattiioonn aaddddrreessss ffrroomm ppaacckkeett **//
ddeessttiipp == ppkkttppttrr-->>nneett__iippddsstt;;
//** SSaanniittyy cchheecckk:: ppaacckkeettss sseenntt ttoo iioooouutt sshhoouulldd **nnoott**
**//
//**
ccoonnttaaiinn aa bbrrooaaddccaasstt aaddddrreessss..
**//
iiff ((((ddeessttiipp ==== IIPP__BBCCAASSTT))||||((ddeessttiipp ==== NNeettDDaattaa..iippbbccaasstt)))) {{
kkpprriinnttff((""iippoouutt:: eennccoouunntteerreedd aa bbrrooaaddccaasstt\\nn""));;
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
ccoonnttiinnuuee;;
}} 
//** CChheecckk wwhheetthheerr ddeessttiinnaattiioonn iiss tthhee llooccaall ccoommppuutteerr **//
iiff ((ddeessttiipp ==== NNeettDDaattaa..iippuuccaasstt)) {{
iipp__llooccaall((ppkkttppttrr));;
ccoonnttiinnuuee;;
}}

Sec. 17.9        IP Functions
387
//** CChheecckk wwhheetthheerr ddeessttiinnaattiioonn iiss oonn tthhee llooccaall nneett **//
iiff (( ((ddeessttiipp && NNeettDDaattaa..iippmmaasskk)) ==== NNeettDDaattaa..iipppprreeffiixx)) {{
//** NNeexxtt hhoopp iiss tthhee ddeessttiinnaattiioonn iittsseellff **//
nnxxtthhoopp == ddeessttiipp;;
}} eellssee {{
//** NNeexxtt hhoopp iiss ddeeffaauulltt rroouutteerr oonn tthhee nneettwwoorrkk **//
nnxxtthhoopp == NNeettDDaattaa..iipprroouutteerr;;
}} 
iiff ((nnxxtthhoopp ==== 00)) {{
//** DDeesstt.. iinnvvaalliidd oorr nnoo ddeeffaauulltt rroouuttee**//
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
ccoonnttiinnuuee;;
}} 
//** UUssee AARRPP ttoo rreessoollvvee nneexxtt--hhoopp aaddddrreessss **//
rreettvvaall == aarrpp__rreessoollvvee((nnxxtthhoopp,, ppkkttppttrr-->>nneett__eetthhddsstt));;
iiff ((rreettvvaall !!== OOKK)) {{
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
ccoonnttiinnuuee;;
}} 
//** UUssee iippoouutt ttoo CCoonnvveerrtt bbyyttee oorrddeerr aanndd sseenndd **//
iipp__oouutt((ppkkttppttrr));;
}}
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
iipp__eennqquueeuuee
--
DDeeppoossiitt aann oouuttggooiinngg IIPP ddaattaaggrraamm oonn tthhee IIPP oouuttppuutt qquueeuuee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
iipp__eennqquueeuuee((
ssttrruucctt nneettppaacckkeett **ppkkttppttrr
//** PPooiinntteerr ttoo tthhee ppaacckkeett
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
iiqqeennttrryy **iippttrr;;
//** PPttrr.. ttoo nneettwwoorrkk oouuttppuutt qquueeuuee **//

388 
A Minimal Internet Protocol Stack 
Chap. 17
//** EEnnssuurree oonnllyy oonnee pprroocceessss aacccceesssseess oouuttppuutt qquueeuuee aatt aa ttiimmee **//
mmaasskk == ddiissaabbllee(());;
//** EEnnqquueeuuee ppaacckkeett oonn nneettwwoorrkk oouuttppuutt qquueeuuee **//
iippttrr == &&iippooqquueeuuee;;
iiff ((sseemmccoouunntt((iippttrr-->>iiqqsseemm)) >>== IIPP__OOQQSSIIZZ)) {{
kkpprriinnttff((""iippoouutt:: oouuttppuutt qquueeuuee oovveerrffllooww\\nn""));;
ffrreeeebbuuff((((cchhaarr **))ppkkttppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
iippttrr-->>iiqqbbuuff[[iippttrr-->>iiqqttaaiill++++]] == ppkkttppttrr;;
iiff ((iippttrr-->>iiqqttaaiill >>== IIPP__OOQQSSIIZZ)) {{
iippttrr-->>iiqqttaaiill == 00;;
}} 
ssiiggnnaall((iippttrr-->>iiqqsseemm));;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}
When a local application sends a datagram, ip_send is invoked. When the netin
process needs to send a reply, it calls ip_enqueue to enqueue the packet for the IP out-
put process to handle.
17.10 Definition Of The UDP Table
UDP maintains a table that specifies the pairs of UDP endpoints that are currently
in use. A single endpoint consists of an IP address and a UDP port number. Therefore,
an entry in the table has four fields that specify two endpoints: one for a remote com-
puter and one for the local computer.
To act as a server that can receive a packet from an arbitrary remote computer, a 
process allocates a table entry, fills in the local endpoint information, and leaves the re-
mote endpoint unspecified. To act as a client that communicates with a specific remote 
computer, a process allocates a table entry and fills in both the local and remote end-
point information.
In addition to endpoint information, each entry in the UDP table contains a queue 
of packets that have arrived from the remote system (i.e., packets where the endpoints 
specified in the packet match those in the table entry). An entry in the UDP table is 
described by struct udpentry; file udp.h defines the structure as well as associated sym-
bolic constants.

Sec. 17.10        Definition Of The UDP Table 
389
//** uuddpp..hh -- DDeeccllaarraattiioonnss ppeerrttaaiinniinngg ttoo UUsseerr DDaattaaggrraamm PPrroottooccooll ((UUDDPP)) **//
##ddeeffiinnee UUDDPP__SSLLOOTTSS
66
//** NNuummbbeerr ooff ooppeenn UUDDPP eennddppooiinnttss **//
##ddeeffiinnee UUDDPP__QQSSIIZZ
88
//** PPaacckkeettss eennqquueeuueedd ppeerr eennddppooiinntt**//
##ddeeffiinnee UUDDPP__DDHHCCPP__CCPPOORRTT
6688
//** PPoorrtt nnuummbbeerr ffoorr DDHHCCPP cclliieenntt
**//
##ddeeffiinnee UUDDPP__DDHHCCPP__SSPPOORRTT
6677
//** PPoorrtt nnuummbbeerr ffoorr DDHHCCPP sseerrvveerr
**//
//** CCoonnssttaannttss ffoorr tthhee ssttaattee ooff aann eennttrryy **//
##ddeeffiinnee UUDDPP__FFRREEEE
00
//** EEnnttrryy iiss uunnuusseedd
**//
##ddeeffiinnee UUDDPP__UUSSEEDD
11
//** EEnnttrryy iiss bbeeiinngg uusseedd
**//
##ddeeffiinnee UUDDPP__RREECCVV
22
//** EEnnttrryy hhaass aa pprroocceessss wwaaiittiinngg
**//
##ddeeffiinnee UUDDPP__AANNYYIIFF
--22
//** RReeggiisstteerr aann eennddppooiinntt ffoorr aannyy **//
//**
iinntteerrffaaccee oonn tthhee mmaacchhiinnee
**//
##ddeeffiinnee UUDDPP__HHDDRR__LLEENN
88
//** BByytteess iinn aa UUDDPP hheeaaddeerr
**//
ssttrruucctt
uuddppeennttrryy {{
//** EEnnttrryy iinn tthhee UUDDPP eennddppooiinntt ttbbll**//
iinntt3322
uuddssttaattee;;
//** SSttaattee ooff eennttrryy:: ffrreeee//uusseedd
**//
uuiinntt3322
uuddrreemmiipp;;
//** RReemmoottee IIPP aaddddrreessss ((zzeerroo
**//
//**
mmeeaannss ""ddoonn’’tt ccaarree""))
**//
uuiinntt1166
uuddrreemmppoorrtt;;
//** RReemmoottee pprroottooccooll ppoorrtt nnuummbbeerr
**//
uuiinntt1166
uuddllooccppoorrtt;;
//** LLooccaall pprroottooccooll ppoorrtt nnuummbbeerr
**//
iinntt3322
uuddhheeaadd;;
//** IInnddeexx ooff nneexxtt ppaacckkeett ttoo rreeaadd **//
iinntt3322
uuddttaaiill;;
//** IInnddeexx ooff nneexxtt sslloott ttoo iinnsseerrtt **//
iinntt3322
uuddccoouunntt;;
//** CCoouunntt ooff ppaacckkeettss eennqquueeuueedd
**//
ppiidd3322
uuddppiidd;;
//** IIDD ooff wwaaiittiinngg pprroocceessss
**//
ssttrruucctt
nneettppaacckkeett **uuddqquueeuuee[[UUDDPP__QQSSIIZZ]];;//** CCiirrccuullaarr ppaacckkeett qquueeuuee
**//
}};;
eexxtteerrnn
ssttrruucctt
uuddppeennttrryy uuddppttaabb[[]];;
17.11 UDP Functions
To permit applications to communicate over the Internet, the UDP interface is 
designed to allow applications to send and receive UDP messages and to act as either a 
client or a server. Our UDP software includes eight interface functions†: udp_init, 
udp_in, udp_register, udp_recv, udp_recvaddr, udp_send, udp_sendto, and udp_release. 
The functions are collected into a single file, udp.c. Following the file, the text 
describes each UDP function.

†The code also contains two internal functions, udp_ntoh and udp_hton, that translate between host byte
order and network byte order.

390 
A Minimal Internet Protocol Stack 
Chap. 17
//** uuddpp..cc -- uuddpp__iinniitt,, uuddpp__iinn,, uuddpp__rreeggiisstteerr,, uuddpp__sseenndd,, uuddpp__sseennddttoo,,
**//
//**
uuddpp__rreeccvv,, uuddpp__rreeccvvaaddddrr,, uuddpp__rreelleeaassee,, uuddpp__nnttoohh,, uuddpp__hhttoonn **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt
uuddppeennttrryy uuddppttaabb[[UUDDPP__SSLLOOTTSS]];;
//** TTaabbllee ooff UUDDPP eennddppooiinnttss
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
** uuddpp__iinniitt
--
IInniittiiaalliizzee aallll eennttrriieess iinn tthhee UUDDPP eennddppooiinntt ttaabbllee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
uuddpp__iinniitt((vvooiidd))
{{
iinntt3322
ii;;
//** IInnddeexx iinnttoo tthhee UUDDPP ttaabbllee **//
ffoorr((ii==00;; ii<<UUDDPP__SSLLOOTTSS;; ii++++)) {{
uuddppttaabb[[ii]]..uuddssttaattee == UUDDPP__FFRREEEE;;
}} 
rreettuurrnn;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** uuddpp__iinn
--
HHaannddllee aann iinnccoommiinngg UUDDPP ppaacckkeett
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
uuddpp__iinn((
ssttrruucctt nneettppaacckkeett **ppkkttppttrr
//** PPooiinntteerr ttoo tthhee ppaacckkeett
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
iinntt3322
ii;;
//** IInnddeexx iinnttoo uuddppttaabb
**//
ssttrruucctt
uuddppeennttrryy **uuddppttrr;;
//** PPooiinntteerr ttoo aa uuddppttaabb eennttrryy
**//
//** EEnnssuurree oonnllyy oonnee pprroocceessss ccaann aacccceessss tthhee UUDDPP ttaabbllee aatt aa ttiimmee
**//
mmaasskk == ddiissaabbllee(());;
ffoorr ((ii==00;; ii<<UUDDPP__SSLLOOTTSS;; ii++++)) {{
uuddppttrr == &&uuddppttaabb[[ii]];;
iiff ((uuddppttrr-->>uuddssttaattee ==== UUDDPP__FFRREEEE)) {{
ccoonnttiinnuuee;;

Sec. 17.11        UDP Functions 
391
}} 
iiff ((((ppkkttppttrr-->>nneett__uuddppddppoorrtt ==== uuddppttrr-->>uuddllooccppoorrtt))
&&&&
((((uuddppttrr-->>uuddrreemmppoorrtt ==== 00)) ||||
((ppkkttppttrr-->>nneett__uuddppssppoorrtt ==== uuddppttrr-->>uuddrreemmppoorrtt)))) &&&&
((
((((uuddppttrr-->>uuddrreemmiipp====00))
||||
((ppkkttppttrr-->>nneett__iippssrrcc ==== uuddppttrr-->>uuddrreemmiipp))))))
)) {{
//** EEnnttrryy mmaattcchheess iinnccoommiinngg ppaacckkeett **//
iiff ((uuddppttrr-->>uuddccoouunntt << UUDDPP__QQSSIIZZ)) {{
uuddppttrr-->>uuddccoouunntt++++;;
uuddppttrr-->>uuddqquueeuuee[[uuddppttrr-->>uuddttaaiill++++]] == ppkkttppttrr;;
iiff ((uuddppttrr-->>uuddttaaiill >>== UUDDPP__QQSSIIZZ)) {{
uuddppttrr-->>uuddttaaiill == 00;;
}} 
iiff ((uuddppttrr-->>uuddssttaattee ==== UUDDPP__RREECCVV)) {{
uuddppttrr-->>uuddssttaattee == UUDDPP__UUSSEEDD;;
sseenndd ((uuddppttrr-->>uuddppiidd,, OOKK));;
}} 
rreessttoorree((mmaasskk));;
rreettuurrnn;;
}}
}}
}} 
//** NNoo mmaattcchh -- ssiimmppllyy ddiissccaarrdd ppaacckkeett **//
ffrreeeebbuuff((((cchhaarr **)) ppkkttppttrr));;
rreessttoorree((mmaasskk));;
rreettuurrnn;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** uuddpp__rreeggiisstteerr
--
RReeggiisstteerr aa rreemmoottee IIPP,, rreemmoottee ppoorrtt && llooccaall ppoorrtt ttoo
**
rreecceeiivvee iinnccoommiinngg UUDDPP mmeessssaaggeess ffrroomm tthhee ssppeecciiffiieedd
**
rreemmoottee ssiittee sseenntt ttoo tthhee ssppeecciiffiieedd llooccaall ppoorrtt
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
uuiidd3322
uuddpp__rreeggiisstteerr ((
uuiinntt3322 rreemmiipp,,
//** RReemmoottee IIPP aaddddrreessss oorr zzeerroo
**//
uuiinntt1166 rreemmppoorrtt,,
//** RReemmoottee UUDDPP pprroottooccooll ppoorrtt
**//
uuiinntt1166 llooccppoorrtt
//** LLooccaall UUDDPP pprroottooccooll ppoorrtt
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//

392 
A Minimal Internet Protocol Stack 
Chap. 17
iinntt3322
sslloott;;
//** IInnddeexx iinnttoo uuddppttaabb
**//
ssttrruucctt
uuddppeennttrryy **uuddppttrr;;
//** PPooiinntteerr ttoo uuddppttaabb eennttrryy
**//
//** EEnnssuurree oonnllyy oonnee pprroocceessss ccaann aacccceessss tthhee UUDDPP ttaabbllee aatt aa ttiimmee
**//
mmaasskk == ddiissaabbllee(());;
//** SSeeee iiff rreeqquueesstt aallrreeaaddyy rreeggiisstteerreedd **//
ffoorr ((sslloott==00;; sslloott<<UUDDPP__SSLLOOTTSS;; sslloott++++)) {{
uuddppttrr == &&uuddppttaabb[[sslloott]];;
iiff ((uuddppttrr-->>uuddssttaattee ==== UUDDPP__FFRREEEE)) {{
ccoonnttiinnuuee;;
}} 
//** LLooookk aatt tthhiiss eennttrryy iinn ttaabbllee **//
iiff (( ((rreemmppoorrtt ==== uuddppttrr-->>uuddrreemmppoorrtt)) &&&&
((llooccppoorrtt ==== uuddppttrr-->>uuddllooccppoorrtt)) &&&&
((rreemmiipp
==== uuddppttrr-->>uuddrreemmiipp
)) )) {{
//** RReeqquueesstt iiss aallrreeaaddyy iinn tthhee ttaabbllee **//
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
//** FFiinndd aa ffrreeee sslloott aanndd aallllooccaattee iitt **//
ffoorr ((sslloott==00;; sslloott<<UUDDPP__SSLLOOTTSS;; sslloott++++)) {{
uuddppttrr == &&uuddppttaabb[[sslloott]];;
iiff ((uuddppttrr-->>uuddssttaattee !!== UUDDPP__FFRREEEE)) {{
ccoonnttiinnuuee;;
}} 
uuddppttrr-->>uuddllooccppoorrtt == llooccppoorrtt;;
uuddppttrr-->>uuddrreemmppoorrtt == rreemmppoorrtt;;
uuddppttrr-->>uuddrreemmiipp == rreemmiipp;;
uuddppttrr-->>uuddccoouunntt == 00;;
uuddppttrr-->>uuddhheeaadd == uuddppttrr-->>uuddttaaiill == 00;;
uuddppttrr-->>uuddppiidd == --11;;
uuddppttrr-->>uuddssttaattee == UUDDPP__UUSSEEDD;;
rreessttoorree((mmaasskk));;
rreettuurrnn sslloott;;
}}

Sec. 17.11        UDP Functions 
393
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** uuddpp__rreeccvv
--
RReecceeiivvee aa UUDDPP ppaacckkeett
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinntt3322
uuddpp__rreeccvv ((
uuiidd3322
sslloott,,
//** SSlloott iinn ttaabbllee ttoo uussee
**//
cchhaarr
**bbuuffff,,
//** BBuuffffeerr ttoo hhoolldd UUDDPP ddaattaa
**//
iinntt3322
lleenn,,
//** LLeennggtthh ooff bbuuffffeerr
**//
uuiinntt3322 ttiimmeeoouutt
//** RReeaadd ttiimmeeoouutt iinn mmsseecc
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
uuddppeennttrryy **uuddppttrr;;
//** PPooiinntteerr ttoo uuddppttaabb eennttrryy
**//
uummssgg3322
mmssgg;;
//** MMeessssaaggee ffrroomm rreeccvvttiimmee(())
**//
ssttrruucctt
nneettppaacckkeett **ppkktt;;
//** PPooiinntteerr ttoo ppaacckkeett bbeeiinngg rreeaadd **//
iinntt3322
ii;;
//** CCoouunnttss bbyytteess ccooppiieedd
**//
iinntt3322
mmssgglleenn;;
//** LLeennggtthh ooff UUDDPP ddaattaa iinn ppaacckkeett **//
cchhaarr
**uuddaattaappttrr;;
//** PPooiinntteerr ttoo UUDDPP ddaattaa
**//
//** EEnnssuurree oonnllyy oonnee pprroocceessss ccaann aacccceessss tthhee UUDDPP ttaabbllee aatt aa ttiimmee
**//
mmaasskk == ddiissaabbllee(());;
//** VVeerriiffyy tthhaatt tthhee sslloott iiss vvaalliidd **//
iiff ((((sslloott << 00)) |||| ((sslloott >>== UUDDPP__SSLLOOTTSS)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** GGeett ppooiinntteerr ttoo ttaabbllee eennttrryy **//
uuddppttrr == &&uuddppttaabb[[sslloott]];;
//** VVeerriiffyy tthhaatt tthhee sslloott hhaass bbeeeenn rreeggiisstteerreedd aanndd iiss vvaalliidd **//
iiff ((uuddppttrr-->>uuddssttaattee !!== UUDDPP__UUSSEEDD)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}}

394 
A Minimal Internet Protocol Stack 
Chap. 17
//** WWaaiitt ffoorr aa ppaacckkeett ttoo aarrrriivvee **//
iiff ((uuddppttrr-->>uuddccoouunntt ==== 00)) {{
//** NNoo ppaacckkeett iiss wwaaiittiinngg **//
uuddppttrr-->>uuddssttaattee == UUDDPP__RREECCVV;;
uuddppttrr-->>uuddppiidd == ccuurrrrppiidd;;
mmssgg == rreeccvvccllrr(());;
mmssgg == rreeccvvttiimmee((ttiimmeeoouutt));;
//** WWaaiitt ffoorr aa ppaacckkeett
**//
uuddppttrr-->>uuddssttaattee == UUDDPP__UUSSEEDD;;
iiff ((mmssgg ==== TTIIMMEEOOUUTT)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn TTIIMMEEOOUUTT;;
}} eellssee iiff ((mmssgg !!== OOKK)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
//** PPaacckkeett hhaass aarrrriivveedd ---- ddeeqquueeuuee iitt **//
ppkktt == uuddppttrr-->>uuddqquueeuuee[[uuddppttrr-->>uuddhheeaadd++++]];;
iiff ((uuddppttrr-->>uuddhheeaadd >>== UUDDPP__QQSSIIZZ)) {{
uuddppttrr-->>uuddhheeaadd == 00;;
}} 
uuddppttrr-->>uuddccoouunntt----;;
//** CCooppyy UUDDPP ddaattaa ffrroomm ppaacckkeett iinnttoo ccaalllleerr’’ss bbuuffffeerr **//
mmssgglleenn == ppkktt-->>nneett__uuddpplleenn -- UUDDPP__HHDDRR__LLEENN;;
uuddaattaappttrr == ((cchhaarr **))ppkktt-->>nneett__uuddppddaattaa;;
iiff ((lleenn << mmssgglleenn)) {{
mmssgglleenn == lleenn;;
}} 
ffoorr ((ii==00;; ii<<mmssgglleenn;; ii++++)) {{
**bbuuffff++++ == **uuddaattaappttrr++++;;
}} 
ffrreeeebbuuff((((cchhaarr **))ppkktt));;
rreessttoorree((mmaasskk));;
rreettuurrnn mmssgglleenn;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** uuddpp__rreeccvvaaddddrr
--
RReecceeiivvee aa UUDDPP ppaacckkeett aanndd rreeccoorrdd tthhee sseennddeerr’’ss aaddddrreessss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinntt3322
uuddpp__rreeccvvaaddddrr ((

Sec. 17.11        UDP Functions 
395
uuiidd3322
sslloott,,
//** SSlloott iinn ttaabbllee ttoo uussee
**//
uuiinntt3322 **rreemmiipp,,
//** LLoocc ffoorr rreemmoottee IIPP aaddddrreessss
**//
uuiinntt1166 **rreemmppoorrtt,,
//** LLoocc ffoorr rreemmoottee pprroottooccooll ppoorrtt **//
cchhaarr
**bbuuffff,,
//** BBuuffffeerr ttoo hhoolldd UUDDPP ddaattaa
**//
iinntt3322
lleenn,,
//** LLeennggtthh ooff bbuuffffeerr
**//
uuiinntt3322 ttiimmeeoouutt
//** RReeaadd ttiimmeeoouutt iinn mmsseecc
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
uuddppeennttrryy **uuddppttrr;;
//** PPooiinntteerr ttoo uuddppttaabb eennttrryy
**//
uummssgg3322
mmssgg;;
//** MMeessssaaggee ffrroomm rreeccvvttiimmee(())
**//
ssttrruucctt
nneettppaacckkeett **ppkktt;;
//** PPooiinntteerr ttoo ppaacckkeett bbeeiinngg rreeaadd **//
iinntt3322
mmssgglleenn;;
//** LLeennggtthh ooff UUDDPP ddaattaa iinn ppaacckkeett **//
iinntt3322
ii;;
//** CCoouunnttss bbyytteess ccooppiieedd
**//
cchhaarr
**uuddaattaappttrr;;
//** PPooiinntteerr ttoo UUDDPP ddaattaa
**//
//** EEnnssuurree oonnllyy oonnee pprroocceessss ccaann aacccceessss tthhee UUDDPP ttaabbllee aatt aa ttiimmee
**//
mmaasskk == ddiissaabbllee(());;
//** VVeerriiffyy tthhaatt tthhee sslloott iiss vvaalliidd **//
iiff ((((sslloott << 00)) |||| ((sslloott >>== UUDDPP__SSLLOOTTSS)))) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** GGeett ppooiinntteerr ttoo ttaabbllee eennttrryy **//
uuddppttrr == &&uuddppttaabb[[sslloott]];;
//** VVeerriiffyy tthhaatt tthhee sslloott hhaass bbeeeenn rreeggiisstteerreedd aanndd iiss vvaalliidd **//
iiff ((uuddppttrr-->>uuddssttaattee !!== UUDDPP__UUSSEEDD)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** WWaaiitt ffoorr aa ppaacckkeett ttoo aarrrriivvee **//
iiff ((uuddppttrr-->>uuddccoouunntt ==== 00)) {{
//** NNoo ppaacckkeett iiss wwaaiittiinngg **//
uuddppttrr-->>uuddssttaattee == UUDDPP__RREECCVV;;
uuddppttrr-->>uuddppiidd == ccuurrrrppiidd;;
mmssgg == rreeccvvccllrr(());;
mmssgg == rreeccvvttiimmee((ttiimmeeoouutt));;
//** WWaaiitt ffoorr aa ppaacckkeett
**//

396 
A Minimal Internet Protocol Stack 
Chap. 17
uuddppttrr-->>uuddssttaattee == UUDDPP__UUSSEEDD;;
iiff ((mmssgg ==== TTIIMMEEOOUUTT)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn TTIIMMEEOOUUTT;;
}} eellssee iiff ((mmssgg !!== OOKK)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
//** PPaacckkeett hhaass aarrrriivveedd ---- ddeeqquueeuuee iitt **//
ppkktt == uuddppttrr-->>uuddqquueeuuee[[uuddppttrr-->>uuddhheeaadd++++]];;
iiff ((uuddppttrr-->>uuddhheeaadd >>== UUDDPP__QQSSIIZZ)) {{
uuddppttrr-->>uuddhheeaadd == 00;;
}} 
//** RReeccoorrdd sseennddeerr’’ss IIPP aaddddrreessss aanndd UUDDPP ppoorrtt nnuummbbeerr **//
**rreemmiipp == ppkktt-->>nneett__iippssrrcc;;
**rreemmppoorrtt == ppkktt-->>nneett__uuddppssppoorrtt;;
uuddppttrr-->>uuddccoouunntt----;;
//** CCooppyy UUDDPP ddaattaa ffrroomm ppaacckkeett iinnttoo ccaalllleerr’’ss bbuuffffeerr **//
mmssgglleenn == ppkktt-->>nneett__uuddpplleenn -- UUDDPP__HHDDRR__LLEENN;;
uuddaattaappttrr == ((cchhaarr **))ppkktt-->>nneett__uuddppddaattaa;;
iiff ((lleenn << mmssgglleenn)) {{
mmssgglleenn == lleenn;;
}} 
ffoorr ((ii==00;; ii<<mmssgglleenn;; ii++++)) {{
**bbuuffff++++ == **uuddaattaappttrr++++;;
}} 
ffrreeeebbuuff((((cchhaarr **))ppkktt));;
rreessttoorree((mmaasskk));;
rreettuurrnn mmssgglleenn;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** uuddpp__sseenndd
--
SSeenndd aa UUDDPP ppaacckkeett uussiinngg iinnffoo iinn aa UUDDPP ttaabbllee eennttrryy
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
uuddpp__sseenndd ((
uuiidd3322
sslloott,,
//** TTaabbllee sslloott ttoo uussee
**//

Sec. 17.11        UDP Functions 
397
cchhaarr
**bbuuffff,,
//** BBuuffffeerr ooff UUDDPP ddaattaa
**//
iinntt3322
lleenn
//** LLeennggtthh ooff ddaattaa iinn bbuuffffeerr
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
nneettppaacckkeett **ppkktt;;
//** PPooiinntteerr ttoo ppaacckkeett bbuuffffeerr
**//
iinntt3322
ppkkttlleenn;;
//** TToottaall ppaacckkeett lleennggtthh
**//
ssttaattiicc
uuiinntt1166 iiddeenntt == 11;;
//** DDaattaaggrraamm IIDDEENNTT ffiieelldd
**//
cchhaarr
**uuddaattaappttrr;;
//** PPooiinntteerr ttoo UUDDPP ddaattaa
**//
uuiinntt3322
rreemmiipp;;
//** RReemmoottee IIPP aaddddrreessss ttoo uussee
**//
uuiinntt1166
rreemmppoorrtt;;
//** RReemmoottee pprroottooccooll ppoorrtt ttoo uussee
**//
uuiinntt1166
llooccppoorrtt;;
//** LLooccaall pprroottooccooll ppoorrtt ttoo uussee
**//
uuiinntt3322
lloocciipp;;
//** LLooccaall IIPP aaddddrreessss ttaakkeenn ffrroomm
**//
//**
tthhee iinntteerrffaaccee
**//
ssttrruucctt
uuddppeennttrryy **uuddppttrr;;
//** PPooiinntteerr ttoo ttaabbllee eennttrryy
**//
//** EEnnssuurree oonnllyy oonnee pprroocceessss ccaann aacccceessss tthhee UUDDPP ttaabbllee aatt aa ttiimmee
**//
mmaasskk == ddiissaabbllee(());;
//** VVeerriiffyy tthhaatt tthhee sslloott iiss vvaalliidd **//
iiff (( ((sslloott << 00)) |||| ((sslloott >>== UUDDPP__SSLLOOTTSS)) )) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** GGeett ppooiinntteerr ttoo ttaabbllee eennttrryy **//
uuddppttrr == &&uuddppttaabb[[sslloott]];;
//** VVeerriiffyy tthhaatt tthhee sslloott hhaass bbeeeenn rreeggiisstteerreedd aanndd iiss vvaalliidd **//
iiff ((uuddppttrr-->>uuddssttaattee ==== UUDDPP__FFRREEEE)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** VVeerriiffyy tthhaatt tthhee sslloott hhaass aa ssppeecciiffiieedd rreemmoottee aaddddrreessss **//
rreemmiipp == uuddppttrr-->>uuddrreemmiipp;;
iiff ((rreemmiipp ==== 00)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}}

398 
A Minimal Internet Protocol Stack 
Chap. 17
lloocciipp == NNeettDDaattaa..iippuuccaasstt;;
rreemmppoorrtt == uuddppttrr-->>uuddrreemmppoorrtt;;
llooccppoorrtt == uuddppttrr-->>uuddllooccppoorrtt;;
//** AAllllooccaattee aa nneettwwoorrkk bbuuffffeerr ttoo hhoolldd tthhee ppaacckkeett **//
ppkktt == ((ssttrruucctt nneettppaacckkeett **))ggeettbbuuff((nneettbbuuffppooooll));;
iiff ((((iinntt3322))ppkktt ==== SSYYSSEERRRR)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** CCoommppuuttee ppaacckkeett lleennggtthh aass UUDDPP ddaattaa ssiizzee ++ ffiixxeedd hheeaaddeerr ssiizzee
**//
ppkkttlleenn == ((((cchhaarr **))&&ppkktt-->>nneett__uuddppddaattaa -- ((cchhaarr **))ppkktt)) ++ lleenn;;
//** CCrreeaattee aa UUDDPP ppaacckkeett iinn ppkktt **//
mmeemmccppyy((((cchhaarr **))ppkktt-->>nneett__eetthhssrrcc,,NNeettDDaattaa..eetthhuuccaasstt,,EETTHH__AADDDDRR__LLEENN));;
ppkktt-->>nneett__eetthhttyyppee == 00xx00880000;;
//** TTyyppee iiss IIPP
**//
ppkktt-->>nneett__iippvvhh == 00xx4455;;
//** IIPP vveerrssiioonn aanndd hhddrr lleennggtthh
**//
ppkktt-->>nneett__iippttooss == 00xx0000;;
//** TTyyppee ooff sseerrvviiccee
**//
ppkktt-->>nneett__iipplleenn== ppkkttlleenn -- EETTHH__HHDDRR__LLEENN;;//** TToottaall IIPP ddaattaaggrraamm lleennggtthh**//
ppkktt-->>nneett__iippiidd == iiddeenntt++++;;
//** DDaattaaggrraamm ggeettss nneexxtt IIDDEENNTT
**//
ppkktt-->>nneett__iippffrraagg == 00xx00000000;;
//** IIPP ffllaaggss && ffrraaggmmeenntt ooffffsseett
**//
ppkktt-->>nneett__iippttttll == 00xxffff;;
//** IIPP ttiimmee--ttoo--lliivvee
**//
ppkktt-->>nneett__iipppprroottoo == IIPP__UUDDPP;;
//** DDaattaaggrraamm ccaarrrriieess UUDDPP
**//
ppkktt-->>nneett__iippcckkssuumm == 00xx00000000;;
//** iinniittiiaall cchheecckkssuumm
**//
ppkktt-->>nneett__iippssrrcc == lloocciipp;;
//** IIPP ssoouurrccee aaddddrreessss
**//
ppkktt-->>nneett__iippddsstt == rreemmiipp;;
//** IIPP ddeessttiinnaattiioonn aaddddrreessss
**//
ppkktt-->>nneett__uuddppssppoorrtt == llooccppoorrtt;;
//** LLooccaall UUDDPP pprroottooccooll ppoorrtt
**//
ppkktt-->>nneett__uuddppddppoorrtt == rreemmppoorrtt;;
//** RReemmoottee UUDDPP pprroottooccooll ppoorrtt
**//
ppkktt-->>nneett__uuddpplleenn == ((uuiinntt1166))((UUDDPP__HHDDRR__LLEENN++lleenn));; //** UUDDPP lleennggtthh
**//
ppkktt-->>nneett__uuddppcckkssuumm == 00xx00000000;;
//** IIggnnoorree UUDDPP cchheecckkssuumm
**//
uuddaattaappttrr == ((cchhaarr **)) ppkktt-->>nneett__uuddppddaattaa;;
ffoorr ((;; lleenn>>00;; lleenn----)) {{
**uuddaattaappttrr++++ == **bbuuffff++++;;
}} 
//** CCaallll iippsseenndd ttoo sseenndd tthhee ddaattaaggrraamm **//
iipp__sseenndd((ppkktt));;
rreessttoorree((mmaasskk));;

Sec. 17.11        UDP Functions 
399
rreettuurrnn OOKK;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** uuddpp__sseennddttoo
--
SSeenndd aa UUDDPP ppaacckkeett ttoo aa ssppeecciiffiieedd ddeessttiinnaattiioonn
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
uuddpp__sseennddttoo ((
uuiidd3322
sslloott,,
//** UUDDPP ttaabbllee sslloott ttoo uussee
**//
uuiinntt3322 rreemmiipp,,
//** RReemmoottee IIPP aaddddrreessss ttoo uussee
**//
uuiinntt1166 rreemmppoorrtt,,
//** RReemmoottee pprroottooccooll ppoorrtt ttoo uussee
**//
cchhaarr
**bbuuffff,,
//** BBuuffffeerr ooff UUDDPP ddaattaa
**//
iinntt3322
lleenn
//** LLeennggtthh ooff ddaattaa iinn bbuuffffeerr
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
nneettppaacckkeett **ppkktt;;
//** PPooiinntteerr ttoo aa ppaacckkeett bbuuffffeerr
**//
iinntt3322
ppkkttlleenn;;
//** TToottaall ppaacckkeett lleennggtthh
**//
ssttaattiicc
uuiinntt1166 iiddeenntt == 11;;
//** DDaattaaggrraamm IIDDEENNTT ffiieelldd
**//
ssttrruucctt
uuddppeennttrryy **uuddppttrr;;
//** PPooiinntteerr ttoo aa UUDDPP ttaabbllee eennttrryy **//
cchhaarr
**uuddaattaappttrr;;
//** PPooiinntteerr ttoo UUDDPP ddaattaa
**//
//** EEnnssuurree oonnllyy oonnee pprroocceessss ccaann aacccceessss tthhee UUDDPP ttaabbllee aatt aa ttiimmee
**//
mmaasskk == ddiissaabbllee(());;
//** VVeerriiffyy tthhaatt tthhee sslloott iiss vvaalliidd **//
iiff (( ((sslloott << 00)) |||| ((sslloott >>== UUDDPP__SSLLOOTTSS)) )) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** GGeett ppooiinntteerr ttoo ttaabbllee eennttrryy **//
uuddppttrr == &&uuddppttaabb[[sslloott]];;
//** VVeerriiffyy tthhaatt tthhee sslloott hhaass bbeeeenn rreeggiisstteerreedd aanndd iiss vvaalliidd **//
iiff ((uuddppttrr-->>uuddssttaattee ==== UUDDPP__FFRREEEE)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}}

400 
A Minimal Internet Protocol Stack 
Chap. 17
//** AAllllooccaattee aa nneettwwoorrkk bbuuffffeerr ttoo hhoolldd tthhee ppaacckkeett **//
ppkktt == ((ssttrruucctt nneettppaacckkeett **))ggeettbbuuff((nneettbbuuffppooooll));;
iiff ((((iinntt3322))ppkktt ==== SSYYSSEERRRR)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** CCoommppuuttee ppaacckkeett lleennggtthh aass UUDDPP ddaattaa ssiizzee ++ ffiixxeedd hheeaaddeerr ssiizzee
**//
ppkkttlleenn == ((((cchhaarr **))&&ppkktt-->>nneett__uuddppddaattaa -- ((cchhaarr **))ppkktt)) ++ lleenn;;
//** CCrreeaattee UUDDPP ppaacckkeett iinn ppkktt **//
mmeemmccppyy((((cchhaarr **))ppkktt-->>nneett__eetthhssrrcc,,NNeettDDaattaa..eetthhuuccaasstt,,EETTHH__AADDDDRR__LLEENN));;
ppkktt-->>nneett__eetthhttyyppee == 00xx00880000;;
//** TTyyppee iiss IIPP **//
ppkktt-->>nneett__iippvvhh == 00xx4455;;
//** IIPP vveerrssiioonn aanndd hhddrr lleennggtthh
**//
ppkktt-->>nneett__iippttooss == 00xx0000;;
//** TTyyppee ooff sseerrvviiccee
**//
ppkktt-->>nneett__iipplleenn== ppkkttlleenn -- EETTHH__HHDDRR__LLEENN;;//** ttoottaall IIPP ddaattaaggrraamm lleennggtthh**//
ppkktt-->>nneett__iippiidd == iiddeenntt++++;;
//** DDaattaaggrraamm ggeettss nneexxtt IIDDEENNTT
**//
ppkktt-->>nneett__iippffrraagg == 00xx00000000;;
//** IIPP ffllaaggss && ffrraaggmmeenntt ooffffsseett
**//
ppkktt-->>nneett__iippttttll == 00xxffff;;
//** IIPP ttiimmee--ttoo--lliivvee
**//
ppkktt-->>nneett__iipppprroottoo == IIPP__UUDDPP;;
//** DDaattaaggrraamm ccaarrrriieess UUDDPP
**//
ppkktt-->>nneett__iippcckkssuumm == 00xx00000000;;
//** IInniittiiaall cchheecckkssuumm
**//
ppkktt-->>nneett__iippssrrcc == NNeettDDaattaa..iippuuccaasstt;;//** IIPP ssoouurrccee aaddddrreessss
**//
ppkktt-->>nneett__iippddsstt == rreemmiipp;;
//** IIPP ddeessttiinnaattiioonn aaddddrreessss
**//
ppkktt-->>nneett__uuddppssppoorrtt == uuddppttrr-->>uuddllooccppoorrtt;;//** llooccaall UUDDPP pprroottooccooll ppoorrtt **//
ppkktt-->>nneett__uuddppddppoorrtt == rreemmppoorrtt;;
//** RReemmoottee UUDDPP pprroottooccooll ppoorrtt
**//
ppkktt-->>nneett__uuddpplleenn == ((uuiinntt1166))((UUDDPP__HHDDRR__LLEENN++lleenn));; //** UUDDPP lleennggtthh
**//
ppkktt-->>nneett__uuddppcckkssuumm == 00xx00000000;;
//** IIggnnoorree UUDDPP cchheecckkssuumm
**//
uuddaattaappttrr == ((cchhaarr **)) ppkktt-->>nneett__uuddppddaattaa;;
ffoorr ((;; lleenn>>00;; lleenn----)) {{
**uuddaattaappttrr++++ == **bbuuffff++++;;
}} 
//** CCaallll iippsseenndd ttoo sseenndd tthhee ddaattaaggrraamm **//
iipp__sseenndd((ppkktt));;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------

Sec. 17.11        UDP Functions 
401
** uuddpp__rreelleeaassee
--
RReelleeaassee aa pprreevviioouussllyy--rreeggiisstteerreedd UUDDPP sslloott
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
uuddpp__rreelleeaassee ((
uuiidd3322
sslloott
//** TTaabbllee sslloott ttoo rreelleeaassee
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
uuddppeennttrryy **uuddppttrr;;
//** PPooiinntteerr ttoo uuddppttaabb eennttrryy
**//
ssttrruucctt
nneettppaacckkeett **ppkktt;;
//** ppooiinntteerr ttoo ppaacckkeett bbeeiinngg rreeaadd **//
//** EEnnssuurree oonnllyy oonnee pprroocceessss ccaann aacccceessss tthhee UUDDPP ttaabbllee aatt aa ttiimmee
**//
mmaasskk == ddiissaabbllee(());;
//** VVeerriiffyy tthhaatt tthhee sslloott iiss vvaalliidd **//
iiff (( ((sslloott << 00)) |||| ((sslloott >>== UUDDPP__SSLLOOTTSS)) )) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** GGeett ppooiinntteerr ttoo ttaabbllee eennttrryy **//
uuddppttrr == &&uuddppttaabb[[sslloott]];;
//** VVeerriiffyy tthhaatt tthhee sslloott hhaass bbeeeenn rreeggiisstteerreedd aanndd iiss vvaalliidd **//
iiff ((uuddppttrr-->>uuddssttaattee ==== UUDDPP__FFRREEEE)) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** DDeeffeerr rreesscchheedduulliinngg ttoo pprreevveenntt ffrreeeebbuuff ffrroomm sswwiittcchhiinngg ccoonntteexxtt **//
rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTAARRTT));;
wwhhiillee ((uuddppttrr-->>uuddccoouunntt >> 00)) {{
ppkktt == uuddppttrr-->>uuddqquueeuuee[[uuddppttrr-->>uuddhheeaadd++++]];;
iiff ((uuddppttrr-->>uuddhheeaadd >>== UUDDPP__QQSSIIZZ)) {{
uuddppttrr-->>uuddhheeaadd == 00;;
}} 
ffrreeeebbuuff((((cchhaarr **))ppkktt));;
uuddppttrr-->>uuddccoouunntt----;;
}} 
uuddppttrr-->>uuddssttaattee == UUDDPP__FFRREEEE;;

402 
A Minimal Internet Protocol Stack 
Chap. 17
rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTOOPP));;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** uuddpp__nnttoohh
--
CCoonnvveerrtt UUDDPP hheeaaddeerr ffiieellddss ffrroomm nneett ttoo hhoosstt bbyyttee oorrddeerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
uuddpp__nnttoohh((
ssttrruucctt nneettppaacckkeett **ppkkttppttrr
))
{{
ppkkttppttrr-->>nneett__uuddppssppoorrtt == nnttoohhss((ppkkttppttrr-->>nneett__uuddppssppoorrtt));;
ppkkttppttrr-->>nneett__uuddppddppoorrtt == nnttoohhss((ppkkttppttrr-->>nneett__uuddppddppoorrtt));;
ppkkttppttrr-->>nneett__uuddpplleenn == nnttoohhss((ppkkttppttrr-->>nneett__uuddpplleenn));;
rreettuurrnn;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** uuddpp__hhttoonn
--
CCoonnvveerrtt ppaacckkeett hheeaaddeerr ffiieellddss ffrroomm hhoosstt ttoo nneett bbyyttee oorrddeerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
uuddpp__hhttoonn((
ssttrruucctt nneettppaacckkeett **ppkkttppttrr
))
{{
ppkkttppttrr-->>nneett__uuddppssppoorrtt == hhttoonnss((ppkkttppttrr-->>nneett__uuddppssppoorrtt));;
ppkkttppttrr-->>nneett__uuddppddppoorrtt == hhttoonnss((ppkkttppttrr-->>nneett__uuddppddppoorrtt));;
ppkkttppttrr-->>nneett__uuddpplleenn == hhttoonnss((ppkkttppttrr-->>nneett__uuddpplleenn));;
rreettuurrnn;;
}}
Udp_init. The initialization function is easiest to understand. The system calls
udp_init once during startup, and udp_init sets the state of each entry in the UDP table
to indicate that the entry is unused.
Udp_in. The ip_in process calls function udp_in when a packet arrives carrying a
UDP message. Argument pktptr points to the incoming packet. Udp_in searches the
UDP table to see if an entry in the table matches the port numbers and IP addresses in
the current packet. If there is no match, the incoming packet is dropped — udp_in calls 
freebuf to return the buffer to the buffer pool. If a match does occur, udp_in inserts the 
incoming packet in the queue associated with the table entry. If the queue is full, 
udp_in drops the packet. When it inserts a packet in the queue, udp_in checks to see if 
a process is waiting for a packet to arrive (state UDP_RECV), and sends a message to

Sec. 17.11        UDP Functions 
403
the waiting process. Note that at any time, only one process can be waiting for an entry
in the table; if multiple processes need to use an entry to communicate, they must coor-
dinate among themselves.
Udp_register. Before it can use UDP to communicate, an application must call 
udp_register to specify that it expects to receive incoming packets sent to a specific 
protocol port. The application can act as a client by specifying a remote IP address or 
can act as a server to accept packets from an arbitrary sender.  Udp_register allocates an 
entry in the UDP table, records the remote and local protocol port and IP address infor-
mation in the entry, and creates a queue to hold incoming packets.
Udp_recv. Once a local port number has been registered, an application can call
udp_recv to extract a packet from a table entry. Arguments to the call specify a slot in
the UDP table, a buffer to hold the incoming message, and a buffer length. The slot
must have been registered previously using udp_register. In terms of coordination,
udp_recv uses the same paradigm as ARP. If no packet is waiting (i.e., the queue for
the entry is empty), udp_recv blocks and waits for the amount of time specified by the
last argument. When a UDP packet arrives, netin calls udp_in. The code in udp_in
finds the appropriate entry in the UDP table, and if an application process is waiting, 
sends a message to the waiting process. Thus, if a packet arrives within the specified 
time, udp_recv copies the UDP data to the caller’s buffer and returns the length. If the 
timer expires before a packet arrives, udp_recv returns TIMEOUT.
Udp_recvaddr. When it acts as a server, a process must learn the address of the 
client that contacted it. A server process calls udp_recvaddr, which acts like udp_recv 
except that the call returns both an incoming packet and the address of the sender. The 
server can use the address to send a reply.
Udp_send. A process calls udp_send to transmit a UDP message. Arguments
specify a slot in the UDP table, the address of a message in memory, and the length of
the message. The slot must have been registered with udp_register. Udp_send creates
an Ethernet packet that contains an IP datagram carrying the specified UDP message. 
Udp_send obtains the IP address and port numbers from the table entry.
Udp_release. Once a process has finished using a UDP endpoint, the process can 
call udp_release to release the table entry. If packets are enqueued in an entry,
udp_release returns each to the buffer pool before marking the table entry free.
17.12 Internet Control Message Protocol
Our implementation of ICMP only handles the two message types used by the ping 
program: ICMP Echo Request and ICMP Echo Reply. Despite the restriction on mes-
sage types, the code contains seven major functions: icmp_init, icmp_in, icmp_out,
icmp_register, icmp_send, icmp_recv, and icmp_release.
As with other parts of the protocol stack, the network input function initializes
ICMP by calling icmp_init. The network input process calls icmp_in when an ICMP
packet arrives. An application process calls icmp_register to register its use of a remote
IP address, then uses icmp_send to send a ping request and icmp_recv to receive a re-

404 
A Minimal Internet Protocol Stack 
Chap. 17
ply. Finally, once it has finished, the application calls icmp_release to release the re-
mote IP address and allow other processes to use it.
Although it is not shown in the text,† the functions follow the same general struc-
ture as the UDP functions. A trick is used to associate ping replies with requests: the 
identification field in an outgoing ping packet is the slot in the ping table (i.e., the index 
of an entry). When a reply arrives, the reply contains the same identification, which 
icmp_in uses as an index into the array. Thus, unlike UDP, the ICMP code never needs 
to search the table. Of course, the identification field alone is not sufficient: once a 
table entry has been identified, icmp_in verifies that the IP source address in the reply 
matches the IP address in the entry. Recall from the discussion earlier in the chapter 
that the netin process is running when icmp_in is called. Therefore, if a reply is needed, 
icmp_in does not send the reply directly. Instead, it calls ip_enqueue to enqueue the 
outgoing packet for the IP output process to send.
17.13 Dynamic Host Configuration Protocol
When it boots, a computer must obtain its IP address, the IP address of a default 
router, and the address mask used on the local network. The protocol used to obtain in-
formation at startup is known as the Dynamic Host Configuration Protocol (DHCP). 
Although a DHCP packet contains many fields, the basic packet exchange is straightfor-
ward. A computer, known as a host, broadcasts a DHCP Discover message. A DHCP 
server on the local network replies by sending a DHCP Offer message that contains an 
IP address for the host, a 32-bit subnet mask for the local network, and the address of a 
default router. The computer replies by sending a Request message to the server.
Instead of engaging in a DHCP exchange when the system boots, our code waits 
until an IP address is needed. An application calls getlocalip to obtain the local IP ad-
dress. If the IP address has been fetched previously, the code merely returns the value. 
If the host’s IP address is unknown, getlocalip uses DHCP to obtain the address. The 
code starts by creating and sending a DHCP Discover message. It then uses udp_recv 
to wait for a reply.
File dhcp.h defines the structure of a DHCP message. The entire DHCP message 
will be carried in the payload of a UDP message, which is carried in an IP datagram, 
which is carried in an Ethernet packet.
//** ddhhccpp..hh -- DDeeffiinniittiioonnss rreellaatteedd ttoo DDHHCCPP **//
##ddeeffiinnee DDHHCCPP
##ddeeffiinnee DDHHCCPP__RREETTRRYY
55
##ddeeffiinnee DDHHCCPP__PPAADDDDIINNGG
00
##ddeeffiinnee DDHHCCPP__SSUUBBNNEETT__MMAASSKK
11
##ddeeffiinnee DDHHCCPP__RROOUUTTEERR
33

†The code can be obtained from the website xinu.cs.purdue.edu

Sec. 17.13        Dynamic Host Configuration Protocol 
405
##ddeeffiinnee DDHHCCPP__DDNNSS__SSEERRVVEERR
66
##ddeeffiinnee DDHHCCPP__DDOOMMAAIINN__NNAAMMEE
1155
##ddeeffiinnee DDHHCCPP__VVEENNDDEERR__OOPPTTIIOONNSS
4433
##ddeeffiinnee DDHHCCPP__RREEQQUUEESSTTEEDD__IIPP
5500
##ddeeffiinnee DDHHCCPP__IIPP__AADDDDRR__LLEEAASSEE__TTIIMMEE
5511
##ddeeffiinnee DDHHCCPP__OOPPTTIIOONN__OOVVEERRLLOOAADD
5522
##ddeeffiinnee DDHHCCPP__MMEESSSSAAGGEE__TTYYPPEE
5533
##ddeeffiinnee DDHHCCPP__SSEERRVVEERR__IIDD
5544
##ddeeffiinnee DDHHCCPP__PPAARRAAMMEETTEERR__RREEQQUUEESSTT__LLIISSTT
5555
##ddeeffiinnee DDHHCCPP__MMEESSSSAAGGEE
5566
##ddeeffiinnee DDHHCCPP__MMAAXXIIMMUUMM__DDHHCCPP__MMEESSSSAAGGEE__SSIIZZEE
5577
##ddeeffiinnee DDHHCCPP__RREENNEEWWAALL__TTIIMMEE__VVAALLUUEE
5588
##ddeeffiinnee DDHHCCPP__RREEBBIINNDDIINNGG__TTIIMMEE__VVAALLUUEE
5599
##ddeeffiinnee DDHHCCPP__VVEENNDDOORR__CCLLAASSSS__IIDD
6600
##ddeeffiinnee DDHHCCPP__CCLLIIEENNTT__IIDD
6611
##ddeeffiinnee DDHHCCPP__TTFFTTPP__SSEERRVVEERR__NNAAMMEE
6666
##ddeeffiinnee DDHHCCPP__BBOOOOTTFFIILLEE__NNAAMMEE
6677
##ddeeffiinnee DDHHCCPP__CCLLIIEENNTT__SSYYSS__AARRCCHH
9933
##ddeeffiinnee DDHHCCPP__CCLLIIEENNTT__NNEETT__IIDD
9944
##ddeeffiinnee DDHHCCPP__CCLLIIEENNTT__MMAACCHHIINNEE__IIDD
9977
##ddeeffiinnee DDHHCCPP__MMEESSSSAAGGEE__EENNDD
225555
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
ddhhccppmmssgg {{
bbyyttee
ddcc__bboopp;;
//** DDHHCCPP bboooottpp oopp 11==rreeqq 22==rreeppllyy
**//
bbyyttee
ddcc__hhttyyppee;;
//** DDHHCCPP hhaarrddwwaarree ttyyppee
**//
bbyyttee
ddcc__hhlleenn;;
//** DDHHCCPP hhaarrddwwaarree aaddddrreessss lleennggtthh **//
bbyyttee
ddcc__hhooppss;;
//** DDHHCCPP hhoopp ccoouunntt
**//
uuiinntt3322
ddcc__xxiidd;;
//** DDHHCCPP xxiidd
**//
uuiinntt1166
ddcc__sseeccss;;
//** DDHHCCPP sseeccoonnddss
**//
uuiinntt1166
ddcc__ffllaaggss;;
//** DDHHCCPP ffllaaggss
**//
uuiinntt3322
ddcc__cciipp;;
//** DDHHCCPP cclliieenntt IIPP aaddddrreessss
**//
uuiinntt3322
ddcc__yyiipp;;
//** DDHHCCPP yyoouurr IIPP aaddddrreessss
**//
uuiinntt3322
ddcc__ssiipp;;
//** DDHHCCPP sseerrvveerr IIPP aaddddrreessss
**//
uuiinntt3322
ddcc__ggiipp;;
//** DDHHCCPP ggaatteewwaayy IIPP aaddddrreessss
**//
bbyyttee
ddcc__cchhaaddddrr[[1166]];;
//** DDHHCCPP cclliieenntt hhaarrddwwaarree aaddddrreessss **//
uunniioonn {{
bbyyttee
ddcc__bboooottpp[[119922]];;
//** DDHHCCPP bboooottpp aarreeaa ((zzeerroo))
**//
ssttrruucctt {{
bbyyttee
ssnnaammee[[6644]];;
//** TTFFTTPP SSeerrvveerr NNaammee
**//
bbyyttee
bboooottffiillee[[112288]];;
//** TTFFTTPP FFiillee nnaammee
**//
}};;
}};;
uuiinntt3322
ddcc__ccooookkiiee;;
//** DDHHCCPP ccooookkiiee
**//
bbyyttee
ddcc__oopptt[[11002244]];;
//** DDHHCCPP ooppttiioonnss aarreeaa ((llaarrggee
**//

406 
A Minimal Internet Protocol Stack 
Chap. 17
//**
eennoouugghh ttoo hhoolldd mmoorree tthhaann
**//
//**
rreeaassoonnaabbllee ooppttiioonnss
**//
}};;
##pprraaggmmaa ppaacckk(())
If the local IP address has not been initialized, function getlocalip creates and
sends a DHCP Discover message, waits to receive a reply, extracts the IP address, sub-
net mask, and default router address from the reply and stores them in Netdata, and re-
turns the IP address. The code can be found in file dhcp.c:
//** ddhhccpp..cc -- ggeettllooccaalliipp **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ddhhccpp__ggeett__oopptt__vvaall
--
RReettrriieevvee aa ppooiinntteerr ttoo tthhee vvaalluuee ffoorr aa ssppeecciiffiieedd
**
DDHHCCPP ooppttiioonnss kkeeyy
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
cchhaarr**
ddhhccpp__ggeett__oopptt__vvaall((
ccoonnsstt ssttrruucctt ddhhccppmmssgg** ddmmssgg,,
//** DDHHCCPP MMeessssaaggee
**//
uuiinntt3322 ddmmssgg__ssiizzee,,
//** SSiizzee ooff DDHHCCPP MMeessssaaggee
**//
uuiinntt88 ooppttiioonn__kkeeyy
//** OOppttiioonn kkeeyy ttoo rreettrriieevvee
**//
))
{{
uunnssiiggnneedd cchhaarr** oopptt__ttmmpp;;
uunnssiiggnneedd cchhaarr** eeoomm;;
eeoomm == ((uunnssiiggnneedd cchhaarr**))ddmmssgg ++ ddmmssgg__ssiizzee -- 11;;
oopptt__ttmmpp == ((uunnssiiggnneedd cchhaarr**))ddmmssgg-->>ddcc__oopptt;;
wwhhiillee((oopptt__ttmmpp << eeoomm)) {{
//** IIff tthhee ooppttiioonn vvaalluuee mmaattcchheess rreettuurrnn tthhee vvaalluuee **//
iiff((((**oopptt__ttmmpp)) ==== ooppttiioonn__kkeeyy)) {{
//** OOffffsseett ppaasstt tthhee ooppttiioonn vvaalluuee aanndd tthhee ssiizzee
**//
rreettuurrnn ((cchhaarr**))((oopptt__ttmmpp++22));;
}} 
oopptt__ttmmpp++++;;
//** MMoovvee ttoo lleennggtthh oocctteett **//
oopptt__ttmmpp ++== **((uuiinntt88**))oopptt__ttmmpp ++ 11;;
}}

Sec. 17.13        Dynamic Host Configuration Protocol 
407
//** OOppttiioonn vvaalluuee nnoott ffoouunndd **//
rreettuurrnn NNUULLLL;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ddhhccpp__bblldd__bboooottpp__mmssgg
--
SSeett tthhee ccoommmmoonn ffiieellddss ffoorr aallll DDHHCCPP mmeessssaaggeess
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
ddhhccpp__bblldd__bboooottpp__mmssgg((ssttrruucctt ddhhccppmmssgg** ddmmssgg))
{{
uuiinntt3322
xxiidd;;
//** XXiidd uusseedd ffoorr tthhee eexxcchhaannggee
**//
mmeemmccppyy((&&xxiidd,, NNeettDDaattaa..eetthhuuccaasstt,, 44));; //** UUssee 44 bbyytteess ffrroomm MMAACC aass
**//
//**
uunniiqquuee XXIIDD
**//
mmeemmsseett((ddmmssgg,, 00xx0000,, ssiizzeeooff((ssttrruucctt ddhhccppmmssgg))));;
ddmmssgg-->>ddcc__bboopp == 00xx0011;;
//** OOuuttggooiinngg rreeqquueesstt
**//
ddmmssgg-->>ddcc__hhttyyppee == 00xx0011;;
//** HHaarrddwwaarree ttyyppee iiss EEtthheerrnneett
**//
ddmmssgg-->>ddcc__hhlleenn == 00xx0066;;
//** HHaarrddwwaarree aaddddrreessss lleennggtthh
**//
ddmmssgg-->>ddcc__hhooppss == 00xx0000;;
//** HHoopp ccoouunntt
**//
ddmmssgg-->>ddcc__xxiidd == hhttoonnll((xxiidd));;
//** XXiidd ((uunniiqquuee IIDD))
**//
ddmmssgg-->>ddcc__sseeccss == 00xx00000000;;
//** SSeeccoonnddss
**//
ddmmssgg-->>ddcc__ffllaaggss == 00xx00000000;;
//** FFllaaggss
**//
ddmmssgg-->>ddcc__cciipp == 00xx0000000000000000;;
//** CClliieenntt IIPP aaddddrreessss
**//
ddmmssgg-->>ddcc__yyiipp == 00xx0000000000000000;;
//** YYoouurr IIPP aaddddrreessss
**//
ddmmssgg-->>ddcc__ssiipp == 00xx0000000000000000;;
//** SSeerrvveerr IIPP aaddddrreessss
**//
ddmmssgg-->>ddcc__ggiipp == 00xx0000000000000000;;
//** GGaatteewwaayy IIPP aaddddrreessss
**//
mmeemmsseett((&&ddmmssgg-->>ddcc__cchhaaddddrr,,’’\\00’’,,1166));;//** CClliieenntt hhaarrddwwaarree aaddddrreessss
**//
mmeemmccppyy((&&ddmmssgg-->>ddcc__cchhaaddddrr,, NNeettDDaattaa..eetthhuuccaasstt,, EETTHH__AADDDDRR__LLEENN));;
mmeemmsseett((&&ddmmssgg-->>ddcc__bboooottpp,,’’\\00’’,,119922));;//** ZZeerroo tthhee bboooottpp aarreeaa
**//
ddmmssgg-->>ddcc__ccooookkiiee == hhttoonnll((00xx6633882255336633));; //** MMaaggiicc ccooookkiiee ffoorr DDHHCCPP
**//
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ddhhccpp__bblldd__ddiisscc
--
hhaannddccrraafftt aa DDHHCCPP DDiissccoovveerr mmeessssaaggee iinn ddmmssgg
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinntt3322
ddhhccpp__bblldd__ddiisscc((ssttrruucctt ddhhccppmmssgg** ddmmssgg))
{{
uuiinntt3322
jj == 00;;
ddhhccpp__bblldd__bboooottpp__mmssgg((ddmmssgg));;

408 
A Minimal Internet Protocol Stack 
Chap. 17
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff && 5533;;
//** DDHHCCPP mmeessssaaggee ttyyppee ooppttiioonn
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff &&
11;;
//** OOppttiioonn lleennggtthh
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff &&
11;;
//** DDHHCCPP DDiiccoovveerr mmeessssaaggee
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff &&
00;;
//** OOppttiioonnss ppaaddddiinngg
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff && 5555;;
//** DDHHCCPP ppaarraammeetteerr rreeqquueesstt lliisstt
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff &&
22;;
//** OOppttiioonn lleennggtthh
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff &&
11;;
//** RReeqquueesstt ssuubbnneett mmaasskk
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff &&
33;;
//** RReeqquueesstt ddeeffaauulltt rroouutteerr aaddddrr-->>**//
rreettuurrnn ((uuiinntt3322))((((cchhaarr **))&&ddmmssgg-->>ddcc__oopptt[[jj]] -- ((cchhaarr **))ddmmssgg ++ 11));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ddhhccpp__bblldd__rreeqq -- hhaannddccrraafftt aa DDHHCCPP rreeqquueesstt mmeessssaaggee iinn ddmmssgg
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinntt3322
ddhhccpp__bblldd__rreeqq((
ssttrruucctt ddhhccppmmssgg** ddmmssgg,,
//** DDHHCCPP mmeessssaaggee ttoo bbuuiilldd
**//
ccoonnsstt ssttrruucctt ddhhccppmmssgg** ddmmssgg__ooffffeerr,, //** DDHHCCPP ooffffeerr mmeessssaaggee
**//
uuiinntt3322 ddssmmgg__ooffffeerr__ssiizzee
//** SSiizzee ooff DDHHCCPP ooffffeerr mmeessssaaggee
**//
))
{{
uuiinntt3322
jj == 00;;
uuiinntt3322** sseerrvveerr__iipp;;
//** TTaakkee tthhee DDHHCCPP sseerrvveerr IIPP aaddddrr **//
//**
ffrroomm DDHHCCPP ooffffeerr mmeessssaaggee
**//
ddhhccpp__bblldd__bboooottpp__mmssgg((ddmmssgg));;
ddmmssgg-->>ddcc__ssiipp == ddmmssgg__ooffffeerr-->>ddcc__ssiipp;; //** SSeerrvveerr IIPP aaddddrreessss
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff && 5533;;
//** DDHHCCPP mmeessssaaggee ttyyppee ooppttiioonn
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff &&
11;;
//** OOppttiioonn lleennggtthh
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff &&
33;;
//** DDHHCCPP RReeqquueesstt mmeessssaaggee
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff &&
00;;
//** OOppttiioonnss ppaaddddiinngg
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff && 5500;;
//** RReeqquueesstteedd IIPP
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff &&
44;;
//** OOppttiioonn lleennggtthh
**//
**((((uuiinntt3322**))&&ddmmssgg-->>ddcc__oopptt[[jj]])) == ddmmssgg__ooffffeerr-->>ddcc__yyiipp;;
jj ++== 44;;
//** RReettrriieevvee tthhee DDHHCCPP sseerrvveerr IIPP ffrroomm tthhee DDHHCCPP ooppttiioonnss **//
sseerrvveerr__iipp == ((uuiinntt3322**))ddhhccpp__ggeett__oopptt__vvaall((ddmmssgg__ooffffeerr,,
ddssmmgg__ooffffeerr__ssiizzee,, DDHHCCPP__SSEERRVVEERR__IIDD));;
iiff((sseerrvveerr__iipp ==== 00)) {{

Sec. 17.13        Dynamic Host Configuration Protocol 
409
kkpprriinnttff((""UUnnaabbllee ttoo ggeett sseerrvveerr IIPP aadddd.. ffrroomm DDHHCCPP OOffffeerr\\nn""));;
rreettuurrnn SSYYSSEERRRR;;
}} 
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff && 5544;;
//** SSeerrvveerr IIPP
**//
ddmmssgg-->>ddcc__oopptt[[jj++++]] == 00xxffff &&
44;;
//** OOppttiioonn lleennggtthh
**//
**((((uuiinntt3322**))&&ddmmssgg-->>ddcc__oopptt[[jj]])) == **sseerrvveerr__iipp;;
jj ++== 44;;
rreettuurrnn ((uuiinntt3322))((((cchhaarr **))&&ddmmssgg-->>ddcc__oopptt[[jj]] -- ((cchhaarr **))ddmmssgg ++ 11));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ggeettllooccaalliipp -- uussee DDHHCCPP ttoo oobbttaaiinn aann IIPP aaddddrreessss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
uuiinntt3322
ggeettllooccaalliipp((vvooiidd))
{{
iinntt3322
sslloott;;
//** UUDDPP sslloott ttoo uussee
**//
ssttrruucctt
ddhhccppmmssgg ddmmssgg__ssnndd;;
//** HHoollddss oouuttggooiinngg DDHHCCPP mmeessssaaggeess **//
ssttrruucctt
ddhhccppmmssgg ddmmssgg__rrvvcc;;
//** HHoollddss iinnccoommiinngg DDHHCCPP mmeessssaaggeess **//
iinntt3322
ii,, jj;;
//** RReettrryy ccoouunntteerrss
**//
iinntt3322
lleenn;;
//** LLeennggtthh ooff ddaattaa sseenntt
**//
iinntt3322
iinnlleenn;;
//** LLeennggtthh ooff ddaattaa rreecceeiivveedd
**//
cchhaarr
**ooppttppttrr;;
//** PPooiinntteerr ttoo ooppttiioonnss aarreeaa
**//
cchhaarr
**eeoopp;;
//** AAddddrreessss ooff eenndd ooff ppaacckkeett
**//
iinntt3322
mmssggttyyppee;;
//** TTyyppee ooff DDCCHHPP mmeessssaaggee
**//
uuiinntt3322
aaddddrrmmaasskk;;
//** AAddddrreessss mmaasskk ffoorr nneettwwoorrkk
**//
uuiinntt3322
rroouutteerraaddddrr;;
//** DDeeffaauulltt rroouutteerr aaddddrreessss
**//
uuiinntt3322
ttmmpp;;
//** UUsseedd ffoorr bbyyttee ccoonnvveerrssiioonn
**//
uuiinntt3322** ttmmpp__sseerrvveerr__iipp;;
//** TTeemmppoorraarryy DDHHCCPP sseerrvveerr ppooiinntteerr**//
sslloott == uuddpp__rreeggiisstteerr((00,, UUDDPP__DDHHCCPP__SSPPOORRTT,, UUDDPP__DDHHCCPP__CCPPOORRTT));;
iiff ((sslloott ==== SSYYSSEERRRR)) {{
kkpprriinnttff((""ggeettllooccaalliipp:: ccaannnnoott rreeggiisstteerr wwiitthh UUDDPP\\nn""));;
rreettuurrnn SSYYSSEERRRR;;
}} 
lleenn == ddhhccpp__bblldd__ddiisscc((&&ddmmssgg__ssnndd));;
iiff((lleenn ==== SSYYSSEERRRR)) {{
kkpprriinnttff((""ggeettllooccaalliipp:: UUnnaabbllee ttoo bbuuiilldd DDHHCCPP ddiissccoovveerr\\nn""));;
rreettuurrnn SSYYSSEERRRR;;
}}

410 
A Minimal Internet Protocol Stack 
Chap. 17
ffoorr ((ii == 00;; ii << DDHHCCPP__RREETTRRYY;; ii++++)) {{
uuddpp__sseennddttoo((sslloott,, IIPP__BBCCAASSTT,, UUDDPP__DDHHCCPP__SSPPOORRTT,,
((cchhaarr **))&&ddmmssgg__ssnndd,, lleenn));;
//** RReeaadd 33 iinnccoommiinngg DDHHCCPP mmeessssaaggeess aanndd cchheecckk ffoorr aann ooffffeerr **//
//**
oorr wwaaiitt ffoorr tthhrreeee ttiimmeeoouutt ppeerriiooddss iiff nnoo mmeessssaaggee **//
//**
aarrrriivveess..
**//
ffoorr ((jj==00;; jj<<33;; jj++++)) {{
iinnlleenn == uuddpp__rreeccvv((sslloott,, ((cchhaarr **))&&ddmmssgg__rrvvcc,,
ssiizzeeooff((ssttrruucctt ddhhccppmmssgg)),,22000000));;
iiff ((iinnlleenn ==== TTIIMMEEOOUUTT)) {{
ccoonnttiinnuuee;;
}} eellssee iiff ((iinnlleenn ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** CChheecckk tthhaatt iinnccoommiinngg mmeessssaaggee iiss aa vvaalliidd
**//
//**
rreessppoonnssee ((IIDD mmaattcchheess oouurr rreeqquueesstt))
**//
iiff ((ddmmssgg__rrvvcc..ddcc__xxiidd !!== ddmmssgg__ssnndd..ddcc__xxiidd)) {{
ccoonnttiinnuuee;;
}} 
eeoopp == ((cchhaarr **))&&ddmmssgg__rrvvcc ++ iinnlleenn -- 11;;
ooppttppttrr == ((cchhaarr **))&&ddmmssgg__rrvvcc..ddcc__oopptt;;
mmssggttyyppee == aaddddrrmmaasskk == rroouutteerraaddddrr == 00;;
wwhhiillee ((ooppttppttrr << eeoopp)) {{
sswwiittcchh ((**ooppttppttrr)) {{
ccaassee 5533::
//** MMeessssaaggee ttyyppee **//
mmssggttyyppee == 00xxffff && **((ooppttppttrr++22));;
bbrreeaakk;;
ccaassee 11::
//** SSuubbnneett mmaasskk **//
mmeemmccppyy((((vvooiidd **))&&ttmmpp,, ooppttppttrr++22,, 44));;
aaddddrrmmaasskk == nnttoohhll((ttmmpp));;
bbrreeaakk;;
ccaassee 33::
//** RRoouutteerr aaddddrreessss **//
mmeemmccppyy((((vvooiidd **))&&ttmmpp,, ooppttppttrr++22,, 44));;
rroouutteerraaddddrr == nnttoohhll((ttmmpp));;
bbrreeaakk;;
}} 
ooppttppttrr++++;;
//** MMoovvee ttoo lleennggtthh oocctteett **//

Sec. 17.13        Dynamic Host Configuration Protocol 
411
ooppttppttrr ++== ((00xxffff && **ooppttppttrr)) ++ 11;;
}} 
iiff ((mmssggttyyppee ==== 00xx0022)) {{
//** OOffffeerr -- sseenndd rreeqquueesstt **//
lleenn == ddhhccpp__bblldd__rreeqq((&&ddmmssgg__ssnndd,, &&ddmmssgg__rrvvcc,,
iinnlleenn));;
iiff((lleenn ==== SSYYSSEERRRR)) {{
kkpprriinnttff((""ggeettllooccaalliipp:: %%ss\\nn"",,
""UUnnaabbllee ttoo bbuuiilldd DDHHCCPP rreeqquueesstt""));;
rreettuurrnn SSYYSSEERRRR;;
}} 
uuddpp__sseennddttoo((sslloott,, IIPP__BBCCAASSTT,, UUDDPP__DDHHCCPP__SSPPOORRTT,,
((cchhaarr **))&&ddmmssgg__ssnndd,, lleenn));;
ccoonnttiinnuuee;;
}} eellssee iiff ((ddmmssgg__rrvvcc..ddcc__oopptt[[22]] !!== 00xx0055)) {{
//** IIff nnoott aann aacckk sskkiipp iitt **//
ccoonnttiinnuuee;;
}} 
iiff ((aaddddrrmmaasskk !!== 00)) {{
NNeettDDaattaa..iippmmaasskk == aaddddrrmmaasskk;;
}} 
iiff ((rroouutteerraaddddrr !!== 00)) {{
NNeettDDaattaa..iipprroouutteerr == rroouutteerraaddddrr;;
}} 
NNeettDDaattaa..iippuuccaasstt == nnttoohhll((ddmmssgg__rrvvcc..ddcc__yyiipp));;
NNeettDDaattaa..iipppprreeffiixx == NNeettDDaattaa..iippuuccaasstt &&
NNeettDDaattaa..iippmmaasskk;;
NNeettDDaattaa..iippbbccaasstt == NNeettDDaattaa..iipppprreeffiixx ||
~~NNeettDDaattaa..iippmmaasskk;;
NNeettDDaattaa..iippvvaalliidd == TTRRUUEE;;
uuddpp__rreelleeaassee((sslloott));;
//** RReettrriieevvee tthhee bboooott sseerrvveerr IIPP **//
iiff((ddoott22iipp((((cchhaarr**))ddmmssgg__rrvvcc..ssnnaammee,,
&&NNeettDDaattaa..bboooottsseerrvveerr)) !!== OOKK)) {{
//** CCoouulldd nnoott rreettrriieevvee tthhee bboooott sseerrvveerr ffrroomm
**//
//**
tthhee
BBOOOOTTPP ffiieellddss,, ssoo uussee tthhee DDHHCCPP sseerrvveerr **//
//**
aaddddrreessss
**//
ttmmpp__sseerrvveerr__iipp == ((uuiinntt3322**))ddhhccpp__ggeett__oopptt__vvaall((
&&ddmmssgg__rrvvcc,, lleenn,, DDHHCCPP__SSEERRVVEERR__IIDD));;
iiff((ttmmpp__sseerrvveerr__iipp ==== 00)) {{
kkpprriinnttff((""CCaannnnoott rreettrriieevvee bboooott sseerrvveerr aaddddrr\\nn""));;
rreettuurrnn ((uuiinntt3322))SSYYSSEERRRR;;

412 
A Minimal Internet Protocol Stack 
Chap. 17
}}
NNeettDDaattaa..bboooottsseerrvveerr == nnttoohhll((**ttmmpp__sseerrvveerr__iipp));;
}} 
mmeemmccppyy((NNeettDDaattaa..bboooottffiillee,, ddmmssgg__rrvvcc..bboooottffiillee,,
ssiizzeeooff((ddmmssgg__rrvvcc..bboooottffiillee))));;
rreettuurrnn NNeettDDaattaa..iippuuccaasstt;;
}}
}} 
kkpprriinnttff((""DDHHCCPP ffaaiilleedd ttoo ggeett rreessppoonnssee\\nn""));;
uuddpp__rreelleeaassee((sslloott));;
rreettuurrnn ((uuiinntt3322))SSYYSSEERRRR;;
}}
A DHCP server responds to the initial Discover message by sending the requested 
information, and the client responds with a Request. When it receives a reply, getlo-
calip examines the options area of the message. DHCP is unusual because the options 
carry important information. In particular, the type of the DHCP message is stored in 
the options area as well as information that a computer system uses to initialize network 
parameters. Three options are crucial to our implementation: option 53 defines the type 
of a DHCP message, option 1 specifies a subnet mask used on the local network, and 
option 3 specifies the address of a default router. If the options are present, getlocalip 
can extract the needed information from the reply, store the information for successive 
calls, and return the IP address to the caller.
Further details of DHCP are beyond the scope of this text. However, it is suffi-
cient to understand that the DHCP code uses the UDP interface exactly the same way
that other applications use it. That is, before communication can begin, getlocalip must 
call udp_register to register the port that DHCP will use. Once the port has been re-
gistered, getlocalip can create a DHCP Discover message and call udp_sendto to broad-
cast the message. The DHCP Discover message causes a DHCP server to respond, and 
the code can use udp_recv to obtain the response, which contains the computer’s IP ad-
dress.
17.14 Perspective
The implementation of Internet protocols described in this chapter is indeed 
minimalistic. Many details have been omitted, and the code takes many shortcuts. For 
example, the structures used to define message formats combine multiple layers of the 
protocol stack and assume that the underlying network is always an Ethernet. More im-
portant, the code presented here omits TCP, the major transport protocol used in the In-
ternet. The code also omits IP version 6, the new version of the Internet Protocol that is 
much more complex than version 4. Unlike IPv4, for example, IPv6 uses variable-size 
headers, which makes it impossible to use a struct to specify IPv6 datagrams. There-

Sec. 17.14        Perspective
413
fore, you should not view the code as typical of a protocol implementation, nor should 
you assume that the same structure will suffice for a more extensive protocol stack.
Despite its limitations, the code does illustrate the importance of timed operations.
In particular, the availability of a timed receive function simplifies the overall structure
of the code and makes the operation much easier to understand. If the system did not 
provide a timed receive, multiple processes would be needed — one process would im-
plement a timer function and another would handle responses.
17.15 Summary
Even small embedded systems use Internet protocols to communicate. As a conse-
quence, most operating systems include software known as a protocol stack.
The chapter examines a minimal protocol stack that supports limited versions of 
IP, UDP, ICMP, ARP, and DHCP running over an Ethernet. The above protocols are 
closely interrelated. Both ICMP and UDP messages travel in an IP datagram; a DHCP 
message travels in a UDP packet.
To accommodate asynchronous packet arrivals, our protocol implementation uses a 
network input process, netin. The netin process repeatedly reads an Ethernet packet, 
validates header fields, and uses header information to determine how to process the 
packet. When an ARP packet arrives, netin calls arp_in to handle the packet, when a 
UDP packet arrives, netin calls udp_in, and when an ICMP packet arrives, netin calls 
icmp_in. For all other packets, netin ignores the packet. When receiving packets, our 
implementation allows a process to specify the maximum time to wait for a packet to 
arrive. The timeout mechanism can be used to implement retransmission: if a response 
does not arrive before the timeout occurs, a process can retransmit the request.
EXERCISES
17.1  
Can you rewrite the code to eliminate the need for a separate IP output process? Hint:
keep a queue of outgoing IP packets with each ARP table entry and arrange for the
packets to be sent once an ARP reply arrives.
17.2  
Assume you have access to a pair of Xinu systems that connect to the Internet. Use the
UDP functions to write two programs that communicate by sending UDP messages to
each other.
17.3 
To ensure that ARP information does not become stale, the ARP protocol requires an en-
try to be removed from the cache after a fixed time (even if the entry has been used). 
Rewrite the code to remove entries that are more than 5 minutes old without using an 
extra process.
17.4  
Redesign udp_recv to use timer processes instead of recvtime. How many processes are
needed? Explain.

414 
A Minimal Internet Protocol Stack 
Chap. 17
17.5 
Instead of structuring network code around a netin process and an ipout process, some
operating systems use software interrupts. Redesign the networking code in this chapter
to use software interrupts.
17.6 
If a computer connects to two separate networks (e.g., a Wi-Fi network as well as an
Ethernet), what major change is required in the structure of the network code? Hint:
how many processes are needed?
17.7  
Xinu uses a device paradigm for abstract devices as well as hardware devices. Rewrite
the UDP code to use a device paradigm in which a process calls open on a UDP master 
device to specify protocol port and IP address information, and receives the descriptor of 
a pseudo-device that can be used for communication.
17.8  
Can the device paradigm described in the previous exercise handle all of ICMP? Does
the answer change if the question is restricted to ICMP echo (i.e., ping)? Explain.
17.9 
Wireless routers used in residences and dorm rooms pass Internet packets between an
Ethernet connection and a Wi-Fi connection. Can you use the code in this chapter to
build a wireless router? Why or why not?

Chapter Contents
18.1 
Introduction, 417
18.2 
The Disk Abstraction, 417
18.3 
Operations A Disk Driver Supports, 418
18.4 
Block Transfer And High–level I/O Functions, 418
18.5 
A Remote Disk Paradigm, 419
18.6 
The Important Concept Of Caching, 420
18.7 
Semantics Of Disk Operations, 421
18.8 
Definition Of Driver Data Structures, 421
18.9 
Driver Initialization (rdsinit), 427
18.10 The Upper–half Open Function (rdsopen), 430
18.11 The Remote Communication Function (rdscomm), 432 
18.12 The Upper–half Write Function (rdswrite), 435
18.13 The Upper–half Read Function (rdsread), 438 
18.14 Flushing Pending Requests, 442
18.15 The Upper–half Control Function (rdscontrol), 442 
18.16 Allocating A Disk Buffer (rdsbufalloc), 445
18.17 The Upper–half Close Function (rdsclose), 447
18.18 The Lower–half Communication Process (rdsprocess), 448 
18.19 Perspective, 453
18.20 Summary, 454


18
A Remote Disk Driver
For my purpose holds ... To strive, to seek, to find,
and not to yield.
— Alfred, Lord Tennyson
18.1 Introduction
Earlier chapters explain I/O devices and the structure of a device driver. Chapter 
16 describes how block-oriented devices use DMA, and shows an example Ethernet 
driver.
This chapter considers the design of a device driver for secondary storage devices 
known as disks or hard drives. The chapter focuses on basic data transfer operations.
The next chapter describes how higher levels of the system use disk hardware to pro-
vide files and directories.
18.2 The Disk Abstraction
Disk hardware provides a basic abstraction in which a disk is a storage mechanism
that has the following properties:
d  Nonvolatile: 
stored data persists even if power is removed.
d  Block-oriented: the hardware can only fetch or store fixed-size blocks.
d  Multi-use: 
a given block can be read and written many times.
d Random-access: blocks can be read or written in any order.
417

418 
A Remote Disk Driver 
Chap. 18
Like the Ethernet hardware described in Chapter 16, disk hardware typically uses 
Direct-Memory-Access (DMA) to allow the disk to transfer an entire block before inter-
rupting the processor. Also like the Ethernet driver, a disk driver does not understand 
or examine the contents of data blocks. Instead, the driver merely treats the entire 
storage device as an array of data blocks.
18.3 Operations A Disk Driver Supports
At the device driver level, a disk consists of fixed-size data blocks that can be ac-
cessed randomly using three basic operations:
d Fetch: Copy the contents of a specified block from the disk to a
buffer in memory.
d Store: Copy the contents of a memory buffer to a specified block
on the disk.
d Seek: Move to a specified block on the disk. The seek option is
only used on electro-mechanical devices (i.e., a magnetic disk) be-
cause it provides an optimization that positions the disk head where 
it will be needed in the future. Thus, when solid state disk technol-
ogy is used, seek is unimportant.
The block size of a disk is derived from the size of a sector on magnetic disks. 
The industry has settled on a de facto standard block size of 512 bytes; throughout the 
chapter, we will assume 512-byte blocks.†
18.4 Block Transfer And High–level I/O Functions
Because the hardware only provides block transfer, it makes sense to design an in-
terface in which read and write operations transfer an entire block. The question be-
comes how to include a block specification in the existing high-level I/O operations.
We might require a programmer to call seek to move to a specific block before calling 
read or write to access data in the block. Unfortunately, requiring a user to call seek 
before each data transfer is clumsy and error prone. Therefore, to keep the interface 
simple, we will stretch the usual meaning of arguments to read and write: instead of in-
terpreting the third argument as a buffer size, we will assume the buffer is large enough 
to hold a disk block, and use the third argument to specify a block number. For exam-
ple, the call:
read ( DISK0, buff, 5 )
requests the driver to read block five from the disk into memory starting at location
buff.

†Although modern disks often use a larger underlying block size (e.g., 4K bytes), the hardware presents
an interface that uses 512-byte blocks.

Sec. 18.4        Block Transfer And High–level I/O Functions 
419
Our driver will supply two basic operations: read, which copies a single block 
from the disk into memory, and write, which copies data from memory onto a specified 
disk block. In addition, our driver will supply control functions that can be used to 
erase a disk (i.e., destroy all saved data) and to synchronize write requests (i.e., ensure 
that all cached data is written to the disk). The concept of caching and its importance 
for efficient disk access is discussed later in the chapter.
18.5 A Remote Disk Paradigm
Unlike a traditional computer that has a local disk, cloud computing follows a 
broader notion in which disk storage is separated from processors. Separation allows a 
physical disk to be accessed from multiple processors, and supports virtual machine mi-
gration. Many modern embedded systems follow the cloud approach. To see how disk 
storage can be separated from processing, we will examine a remote disk paradigm. 
Our remote disk system will provide the same abstraction as a local disk by allowing 
processes to read and write disk blocks. Instead of using disk hardware, however, our 
system will send requests over a network to a remote disk server that runs on another 
computer.
The driver software for the remote disk is surprisingly similar to driver software 
for a local disk. Overall, both local and remote disk drivers follow the same general or-
ganization. That is, the driver functions are partitioned into an upper half and a lower 
half that communicate through a shared data structure. The main difference arises in 
the way the lower half operates. Instead of using DMA hardware and interrupts in the 
lower half, our remote disk driver uses a high-priority communication process. The 
communication process sends requests over a network to a remote server, and receives 
responses from the server. Figure 18.1 illustrates the organization.
upper-half functions
shared
data structures
write
read
network communication 
with remote server
process that provides 
lower-half functionality
Figure 18.1  Organization of a remote disk driver.

420 
A Remote Disk Driver 
Chap. 18
18.6 The Important Concept Of Caching
Three key facts help operating system designers optimize disk drivers. First, the 
underlying disk hardware can only transfer complete blocks. Second, as we will see in 
the next chapter, a file system allows an application to read and write arbitrary amounts 
of data. Third, disk hardware is much slower than processor hardware. The conse-
quence of the above three facts should be clear: if a driver attempts to transfer data each 
time an application reads or writes a few bytes, disk access will become a bottleneck in 
the system.
To make disk accesses efficient, a driver must use caching. That is, when a block 
is accessed, the driver places a copy of the block in a cache in memory. Subsequent 
read and write operations manipulate the cached copy without waiting for I/O opera-
tions to access the underlying disk. Eventually, of course, changes must be written 
back to the disk. Without caching, disk access is intolerably slow, but caching can 
make the effective performance of a disk system fast enough to accommodate most 
needs. We can summarize:
Because disk access is slow and file system functions often read or
write partial blocks, a disk driver must cache copies of blocks to 
achieve high performance.
Our example driver illustrates the idea. The shared data structure contains two key
items.
d A cache of recently accessed blocks
d A list of pending requests
A cache of recently accessed blocks. Our cache stores recently accessed disk
blocks. A block is cached whenever a read or write operation occurs. Furthermore,
when it receives a subsequent operation for a block, the driver always searches the
cache before requesting a transfer; the driver does not distinguish between read and 
write requests. Thus, if a file system first writes data to a given block and then reads 
data from the same block, the read operation will use the cached copy.
A list of pending requests. Like a traditional driver, our remote disk system allows 
multiple processes to access a disk, and implements synchronous read operations and 
asynchronous write operations. That is, when it reads a block, a process must wait until 
the data has been fetched. When it writes a block, however, a process does not block 
— the driver places a copy of the outgoing disk block on a request list, and allows the 
process to continue execution. The lower-half process, which handles communication 
with the remote server, continually takes the next item off the request queue and per-
forms the specified operation. Thus, at some time in the future, data will be written to 
the disk.

Sec. 18.7        Semantics Of Disk Operations 
421
18.7 Semantics Of Disk Operations
Although it can employ optimizations such as caching and delayed write opera-
tions, a disk driver must always preserve the appearance of a synchronous interface.
That is, the driver must always return the data that was written most recently.
If we envision the read and write operations on a given block, they form a se-
quence:
op1, op2, op3, ... opn
If opt is a read operation for block i, the driver must deliver the data that was written to
the block in opk, where k is the highest index of a write operation less than t (i.e., all the 
operations between opk  and opt  are read operations). To complete the definition, we as-
sume an implicit write occurs at time zero before the system starts. Thus, if a system 
attempts to read a block before any calls to write the block, the driver returns whatever 
data was on the disk when the system booted.
We use the term last-write semantics to capture the concept, and insist that:
A disk driver can use techniques such as caching to optimize perfor-
mance provided the driver guarantees last-write semantics.
The example driver uses a FIFO queue to enforce last-write semantics:
Items are inserted at the tail of the request queue; the lower-half 
process continually selects and performs the item at the head of the 
queue.
Because items are always inserted at the tail, the driver handles requests in the
same order they were made. Thus, if process A reads block five and process B writes
block five later, the two requests will appear in the correct order in the queue. The read 
request will be serviced first, followed by the write request. We will see that the queue 
discipline is extended to the cache: driver functions always start at the head when 
searching the cache. Our code relies on the queue discipline to ensure that a process re-
ceives data according to last-write semantics.
18.8 Definition Of Driver Data Structures
File rdisksys.h defines the constants and data structures used by the remote disk 
system. The file defines the format of a disk buffer. Each buffer includes a header that 
specifies the number of the disk block stored in the buffer and fields that are used to 
link the buffer onto the request list, cache, or free list. In addition, the file defines the 
contents of the device control block and the format of messages sent to the remote 
server.

422 
A Remote Disk Driver 
Chap. 18
//** rrddiisskkssyyss..hh -- ddeeffiinniittiioonnss ffoorr rreemmoottee ddiisskk ssyysstteemm ppsseeuuddoo--ddeevviicceess **//
##iiffnnddeeff NNrrddss
##ddeeffiinnee NNrrddss
11
##eennddiiff
//** RReemmoottee ddiisskk bblloocckk ssiizzee **//
##ddeeffiinnee RRDD__BBLLKKSSIIZZ
551122
//** GGlloobbaall ddaattaa ffoorr tthhee rreemmoottee ddiisskk sseerrvveerr **//
##iiffnnddeeff RRDD__SSEERRVVEERR__IIPP
##ddeeffiinnee RRDD__SSEERRVVEERR__IIPP
""225555..225555..225555..225555""
##eennddiiff
##iiffnnddeeff RRDD__SSEERRVVEERR__PPOORRTT
##ddeeffiinnee RRDD__SSEERRVVEERR__PPOORRTT
3333112244
##eennddiiff
##iiffnnddeeff RRDD__LLOOCC__PPOORRTT
##ddeeffiinnee RRDD__LLOOCC__PPOORRTT
3333112244
//** BBaassee ppoorrtt nnuummbbeerr -- mmiinnoorr ddeevv **//
//**
nnuummbbeerr iiss aaddddeedd ttoo iinnssuurree
**//
//**
tthhaatt eeaacchh ddeevviiccee iiss uunniiqquuee **//
##eennddiiff
//** CCoonnttrrooll bblloocckk ffoorr rreemmoottee ddiisskk ddeevviiccee **//
##ddeeffiinnee RRDD__IIDDLLEENN
6644
//** SSiizzee ooff aa rreemmoottee ddiisskk IIDD
**//
##ddeeffiinnee RRDD__BBUUFFFFSS
6644
//** NNuummbbeerr ooff ddiisskk bbuuffffeerrss
**//
##ddeeffiinnee RRDD__SSTTAACCKK
1166338844
//** SSttaacckk ssiizzee ffoorr ccoommmm.. pprroocceessss **//
##ddeeffiinnee RRDD__PPRRIIOO
220000
//** PPrriioorrttyy ooff ccoommmm.. pprroocceessss
**//
//** CCoonnssttaannttss ffoorr ssttaattee ooff tthhee ddeevviiccee **//
##ddeeffiinnee RRDD__FFRREEEE
00
//** DDeevviiccee iiss aavvaaiillaabbllee
**//
##ddeeffiinnee RRDD__OOPPEENN
11
//** DDeevviiccee iiss ooppeenn ((iinn uussee))
**//
##ddeeffiinnee RRDD__PPEENNDD
22
//** OOppeenn iiss ppeennddiinngg
**//
//** OOppeerraattiioonnss ffoorr rreeqquueesstt qquueeuuee **//
##ddeeffiinnee RRDD__OOPP__RREEAADD
11
//** RReeaadd ooppeerraattiioonn oonn rreeqq.. lliisstt
**//
##ddeeffiinnee RRDD__OOPP__WWRRIITTEE
22
//** WWrriittee ooppeerraattiioonn oonn rreeqq.. lliisstt **//
##ddeeffiinnee RRDD__OOPP__SSYYNNCC
33
//** SSyynncc ooppeerraattiioonn oonn rreeqq.. lliisstt
**//
//** SSttaattuuss vvaalluueess ffoorr aa bbuuffffeerr **//

Sec. 18.8        Definition Of Driver Data Structures 
423
##ddeeffiinnee RRDD__VVAALLIIDD
00
//** BBuuffffeerr ccoonnttaaiinnss vvaalliidd ddaattaa
**//
##ddeeffiinnee RRDD__IINNVVAALLIIDD
11
//** BBuuffffeerr ddooeess nnoott ccoonnttaaiinn ddaattaa **//
//** DDeeffiinniittiioonn ooff aa bbuuffffeerr wwiitthh aa hheeaaddeerr tthhaatt aalllloowwss tthhee ssaammee nnooddee ttoo bbee **//
//**
uusseedd aass aa rreeqquueesstt oonn tthhee rreeqquueesstt qquueeuuee,, aann iitteemm iinn tthhee ccaacchhee,, oorr aa
**//
//**
nnooddee oonn tthhee ffrreeee lliisstt ooff bbuuffffeerrss
**//
ssttrruucctt
rrddbbuuffff
{{
//** RReeqquueesstt lliisstt nnooddee
**//
ssttrruucctt
rrddbbuuffff
**rrdd__nneexxtt;;
//** PPttrr ttoo nneexxtt nnooddee oonn aa lliisstt
**//
ssttrruucctt
rrddbbuuffff
**rrdd__pprreevv;;
//** PPttrr ttoo pprreevv nnooddee oonn aa lliisstt
**//
iinntt3322
rrdd__oopp;;
//** OOppeerraattiioonn -- rreeaadd//wwrriittee//ssyynncc
**//
iinntt3322
rrdd__rreeffccnntt;;
//** RReeffeerreennccee ccoouunntt ooff pprroocceesssseess **//
//**
rreeaaddiinngg tthhee bblloocckk
**//
uuiinntt3322
rrdd__bbllkknnuumm;;
//** BBlloocckk nnuummbbeerr ooff tthhiiss bblloocckk
**//
iinntt3322
rrdd__ssttaattuuss;;
//** IIss bbuuffffeerr ccuurrrreennttllyy vvaalliidd??
**//
ppiidd3322
rrdd__ppiidd;;
//** PPrroocceessss tthhaatt iinniittiiaatteedd aa
**//
//**
rreeaadd rreeqquueesstt ffoorr tthhee bblloocckk **//
cchhaarr
rrdd__bblloocckk[[RRDD__BBLLKKSSIIZZ]];;
//** SSppaaccee ttoo hhoolldd oonnee ddiisskk bblloocckk **//
}};;
ssttrruucctt
rrddssccbbllkk {{
iinntt3322
rrdd__ssttaattee;;
//** SSttaattee ooff ddeevviiccee
**//
cchhaarr
rrdd__iidd[[RRDD__IIDDLLEENN]];;
//** DDiisskk IIDD ccuurrrreennttllyy bbeeiinngg uusseedd **//
iinntt3322
rrdd__sseeqq;;
//** NNeexxtt sseeqquueennccee nnuummbbeerr ttoo uussee
**//
//** RReeqquueesstt qquueeuuee hheeaadd aanndd ttaaiill **//
ssttrruucctt
rrddbbuuffff
**rrdd__rrhhnneexxtt;;
//** HHeeaadd ooff rreeqquueesstt qquueeuuee:: nneexxtt
**//
ssttrruucctt
rrddbbuuffff
**rrdd__rrhhpprreevv;;
//**
aanndd pprreevviioouuss
**//
ssttrruucctt
rrddbbuuffff
**rrdd__rrttnneexxtt;;
//** TTaaiill ooff rreeqquueesstt qquueeuuee:: nneexxtt
**//
ssttrruucctt
rrddbbuuffff
**rrdd__rrttpprreevv;;
//**
((nnuullll)) aanndd pprreevviioouuss
**//
//** CCaacchhee hheeaadd aanndd ttaaiill **//
ssttrruucctt
rrddbbuuffff
**rrdd__cchhnneexxtt;;
//** HHeeaadd ooff ccaacchhee:: nneexxtt aanndd
**//
ssttrruucctt
rrddbbuuffff
**rrdd__cchhpprreevv;;
//**
pprreevviioouuss
**//
ssttrruucctt
rrddbbuuffff
**rrdd__ccttnneexxtt;;
//** TTaaiill ooff ccaacchhee:: nneexxtt ((nnuullll))
**//
ssttrruucctt
rrddbbuuffff
**rrdd__ccttpprreevv;;
//**
aanndd pprreevviioouuss
**//
//** FFrreeee lliisstt hheeaadd ((ssiinnggllyy--lliinnkkeedd)) **//
ssttrruucctt
rrddbbuuffff
**rrdd__ffrreeee;;
//** PPooiinntteerr ttoo ffrreeee lliisstt
**//
ppiidd3322
rrdd__ccoommpprroocc;;
//** PPrroocceessss IIDD ooff ccoommmm.. pprroocceessss
**//
bbooooll88
rrdd__ccoommrruunnss;;
//** HHaass ccoommmm.. pprroocceessss ssttaarrtteedd??
**//
ssiidd3322
rrdd__aavvaaiillsseemm;;
//** SSeemmaapphhoorree IIDD ffoorr aavvaaiill bbuuffffss **//
ssiidd3322
rrdd__rreeqqsseemm;;
//** SSeemmaapphhoorree IIDD ffoorr rreeqquueessttss
**//

424 
A Remote Disk Driver 
Chap. 18
uuiinntt3322
rrdd__sseerr__iipp;;
//** SSeerrvveerr IIPP aaddddrreessss
**//
uuiinntt1166
rrdd__sseerr__ppoorrtt;;
//** SSeerrvveerr UUDDPP ppoorrtt
**//
uuiinntt1166
rrdd__lloocc__ppoorrtt;;
//** LLooccaall ((cclliieenntt)) UUPPDD ppoorrtt
**//
bbooooll88
rrdd__rreeggiisstteerreedd;;
//** HHaass UUDDPP ppoorrtt bbeeeenn rreeggiisstteerreedd??**//
iinntt3322
rrdd__uuddppsslloott;;
//** RReeggiisstteerreedd UUDDPP sslloott
**//
}};;
eexxtteerrnn
ssttrruucctt
rrddssccbbllkk rrddssttaabb[[]];;
//** RReemmoottee ddiisskk ccoonnttrrooll bblloocckk
**//
//** DDeeffiinniittiioonnss ooff ppaarraammeetteerrss uusseedd dduurriinngg sseerrvveerr aacccceessss **//
##ddeeffiinnee RRDD__RREETTRRIIEESS
33
//** TTiimmeess ttoo rreettrryy sseennddiinngg aa mmssgg **//
##ddeeffiinnee RRDD__TTIIMMEEOOUUTT
22000000
//** TTiimmeeoouutt ffoorr rreeppllyy ((22 sseeccoonnddss))**//
//** CCoonnttrrooll ffuunnccttiioonnss ffoorr aa rreemmoottee ffiillee ppsseeuuddoo ddeevviiccee **//
##ddeeffiinnee RRDDSS__CCTTLL__DDEELL
11
//** DDeelleettee ((eerraassee)) aann eennttiirree ddiisskk**//
##ddeeffiinnee RRDDSS__CCTTLL__SSYYNNCC
22
//** WWrriittee aallll ppeennddiinngg bblloocckkss
**//
//************************************************************************************************************************************************//
//**
DDeeffiinniittiioonn ooff mmeessssaaggeess eexxcchhaannggeedd wwiitthh tthhee rreemmoottee ddiisskk sseerrvveerr
**//
//************************************************************************************************************************************************//
//** VVaalluueess ffoorr tthhee ttyyppee ffiieelldd iinn mmeessssaaggeess **//
##ddeeffiinnee RRDD__MMSSGG__RREESSPPOONNSSEE 00xx00110000
//** BBiitt tthhaatt iinnddiiccaatteess rreessppoonnssee
**//
##ddeeffiinnee RRDD__MMSSGG__RRRREEQQ
00xx00001100
//** RReeaadd rreeqquueesstt aanndd rreessppoonnssee
**//
##ddeeffiinnee RRDD__MMSSGG__RRRREESS
((RRDD__MMSSGG__RRRREEQQ || RRDD__MMSSGG__RREESSPPOONNSSEE))
##ddeeffiinnee RRDD__MMSSGG__WWRREEQQ
00xx00002200
//** WWrriittee rreeqquueesstt aanndd rreessppoonnssee
**//
##ddeeffiinnee RRDD__MMSSGG__WWRREESS
((RRDD__MMSSGG__WWRREEQQ || RRDD__MMSSGG__RREESSPPOONNSSEE))
##ddeeffiinnee RRDD__MMSSGG__OORREEQQ
00xx00003300
//** OOppeenn rreeqquueesstt aanndd rreessppoonnssee
**//
##ddeeffiinnee RRDD__MMSSGG__OORREESS
((RRDD__MMSSGG__OORREEQQ || RRDD__MMSSGG__RREESSPPOONNSSEE))
##ddeeffiinnee RRDD__MMSSGG__CCRREEQQ
00xx00004400
//** CClloossee rreeqquueesstt aanndd rreessppoonnssee
**//
##ddeeffiinnee RRDD__MMSSGG__CCRREESS
((RRDD__MMSSGG__CCRREEQQ || RRDD__MMSSGG__RREESSPPOONNSSEE))
##ddeeffiinnee RRDD__MMSSGG__DDRREEQQ
00xx00005500
//** DDeelleettee rreeqquueesstt aanndd rreessppoonnssee
**//
##ddeeffiinnee RRDD__MMSSGG__DDRREESS
((RRDD__MMSSGG__DDRREEQQ || RRDD__MMSSGG__RREESSPPOONNSSEE))
##ddeeffiinnee RRDD__MMIINN__RREEQQ
RRDD__MMSSGG__RRRREEQQ
//** MMiinniimmuumm rreeqquueesstt ttyyppee
**//
##ddeeffiinnee RRDD__MMAAXX__RREEQQ
RRDD__MMSSGG__DDRREEQQ
//** MMaaxxiimmuumm rreeqquueesstt ttyyppee
**//

Sec. 18.8        Definition Of Driver Data Structures 
425
//** MMeessssaaggee hheeaaddeerr ffiieellddss pprreesseenntt iinn eeaacchh mmeessssaaggee **//
##ddeeffiinnee RRDD__MMSSGG__HHDDRR
//** CCoommmmoonn mmeessssaaggee ffiieellddss
**//\\
uuiinntt1166
rrdd__ttyyppee;;
//** MMeessssaaggee ttyyppee
**//\\
uuiinntt1166
rrdd__ssttaattuuss;;
//** 00 iinn rreeqq,, ssttaattuuss iinn rreessppoonnssee **//\\
uuiinntt3322
rrdd__sseeqq;;
//** MMeessssaaggee sseeqquueennccee nnuummbbeerr
**//\\
cchhaarr
rrdd__iidd[[RRDD__IIDDLLEENN]];;
//** NNuullll--tteerrmmiinnaatteedd ddiisskk IIDD
**//
//************************************************************************************************************************************************//
//**
HHeeaaddeerr
**//
//************************************************************************************************************************************************//
//** TThhee ssttaannddaarrdd hheeaaddeerr pprreesseenntt iinn aallll mmeessssaaggeess wwiitthh nnoo eexxttrraa ffiieellddss **//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrdd__mmssgg__hhddrr {{
//** HHeeaaddeerr ffiieellddss pprreesseenntt iinn eeaacchh**//
RRDD__MMSSGG__HHDDRR
//**
rreemmoottee ffiillee ssyysstteemm mmeessssaaggee **//
}};;
##pprraaggmmaa ppaacckk(())
//************************************************************************************************************************************************//
//**
RReeaadd
**//
//************************************************************************************************************************************************//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrdd__mmssgg__rrrreeqq
{{
//** RReemmoottee ffiillee rreeaadd rreeqquueesstt
**//
RRDD__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
uuiinntt3322
rrdd__bbllkk;;
//** BBlloocckk nnuummbbeerr ttoo rreeaadd
**//
}};;
##pprraaggmmaa ppaacckk(())
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrdd__mmssgg__rrrreess
{{
//** RReemmoottee ffiillee rreeaadd rreeppllyy
**//
RRDD__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
uuiinntt3322
rrdd__bbllkk;;
//** BBlloocckk nnuummbbeerr tthhaatt wwaass rreeaadd
**//
cchhaarr
rrdd__ddaattaa[[RRDD__BBLLKKSSIIZZ]];;
//** AArrrraayy ccoonnttaaiinniinngg oonnee bblloocckk
**//
}};;
##pprraaggmmaa ppaacckk(())
//************************************************************************************************************************************************//
//**
WWrriittee
**//
//************************************************************************************************************************************************//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrdd__mmssgg__wwrreeqq
{{
//** RReemmoottee ffiillee wwrriittee rreeqquueesstt
**//
RRDD__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
uuiinntt3322
rrdd__bbllkk;;
//** BBlloocckk nnuummbbeerr ttoo wwrriittee
**//
cchhaarr
rrdd__ddaattaa[[RRDD__BBLLKKSSIIZZ]];;
//** AArrrraayy ccoonnttaaiinniinngg oonnee bblloocckk
**//
}};;
##pprraaggmmaa ppaacckk(())

426 
A Remote Disk Driver 
Chap. 18
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrdd__mmssgg__wwrreess
{{
//** RReemmoottee ffiillee wwrriittee rreessppoonnssee
**//
RRDD__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
uuiinntt3322
rrdd__bbllkk;;
//** BBlloocckk nnuummbbeerr tthhaatt wwaass wwrriitttteenn**//
}};;
##pprraaggmmaa ppaacckk(())
//************************************************************************************************************************************************//
//**
OOppeenn
**//
//************************************************************************************************************************************************//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrdd__mmssgg__oorreeqq
{{
//** RReemmoottee ffiillee ooppeenn rreeqquueesstt
**//
RRDD__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrdd__mmssgg__oorreess
{{
//** RReemmoottee ffiillee ooppeenn rreessppoonnssee
**//
RRDD__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())
//************************************************************************************************************************************************//
//**
CClloossee
**//
//************************************************************************************************************************************************//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrdd__mmssgg__ccrreeqq
{{
//** RReemmoottee ffiillee cclloossee rreeqquueesstt
**//
RRDD__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrdd__mmssgg__ccrreess
{{
//** RReemmoottee ffiillee cclloossee rreessppoonnssee
**//
RRDD__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())
//************************************************************************************************************************************************//
//**
DDeelleettee
**//
//************************************************************************************************************************************************//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrdd__mmssgg__ddrreeqq
{{
//** RReemmoottee ffiillee ddeelleettee rreeqquueesstt
**//
RRDD__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())

Sec. 18.8        Definition Of Driver Data Structures 
427
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrdd__mmssgg__ddrreess
{{
//** RReemmoottee ffiillee ddeelleettee rreessppoonnssee
**//
RRDD__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())
18.9 Driver Initialization (rdsinit)
Although initialization is completed after the other pieces of the driver have been 
designed, we have chosen to examine the initialization function now because it will help 
us understand the shared data structures. File rdsinit.c contains the driver initialization 
code:
//** rrddssiinniitt..cc -- rrddssiinniitt **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt
rrddssccbbllkk rrddssttaabb[[NNrrddss]];;
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
rrddssiinniitt
--
IInniittiiaalliizzee tthhee rreemmoottee ddiisskk ssyysstteemm ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrddssiinniitt ((
ssttrruucctt ddeennttrryy **ddeevvppttrr
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
))
{{
ssttrruucctt
rrddssccbbllkk **rrddppttrr;;
//** PPttrr ttoo ddeevviiccee ccoonnttooll bblloocckk
**//
ssttrruucctt
rrddbbuuffff
**bbppttrr;;
//** PPttrr ttoo bbuuffffeerr iinn mmeemmoorryy
**//
//**
uusseedd ttoo ffoorrmm lliinnkkeedd lliisstt
**//
ssttrruucctt
rrddbbuuffff
**ppppttrr;;
//** PPttrr ttoo pprreevviioouuss bbuuffff oonn lliisstt **//
ssttrruucctt
rrddbbuuffff
**bbuuffffeenndd;;
//** LLaasstt aaddddrreessss iinn bbuuffffeerr mmeemmoorryy**//
uuiinntt3322
ssiizzee;;
//** TToottaall ssiizzee ooff mmeemmoorryy nneeeeddeedd
**//
//**
bbuuffffeerrss
**//
//** OObbttaaiinn aaddddrreessss ooff ccoonnttrrooll bblloocckk **//
rrddppttrr == &&rrddssttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
//** SSeett ccoonnttrrooll bblloocckk ttoo uunnuusseedd **//
rrddppttrr-->>rrdd__ssttaattee == RRDD__FFRREEEE;;
rrddppttrr-->>rrdd__iidd[[00]] == NNUULLLLCCHH;;

428 
A Remote Disk Driver 
Chap. 18
//** SSeett iinniittiiaall mmeessssaaggee sseeqquueennccee nnuummbbeerr **//
rrddppttrr-->>rrdd__sseeqq == 11;;
//** IInniittiiaalliizzee rreeqquueesstt qquueeuuee aanndd ccaacchhee ttoo eemmppttyy **//
rrddppttrr-->>rrdd__rrhhnneexxtt == ((ssttrruucctt rrddbbuuffff **)) &&rrddppttrr-->>rrdd__rrttnneexxtt;;
rrddppttrr-->>rrdd__rrhhpprreevv == ((ssttrruucctt rrddbbuuffff **))NNUULLLL;;
rrddppttrr-->>rrdd__rrttnneexxtt == ((ssttrruucctt rrddbbuuffff **))NNUULLLL;;
rrddppttrr-->>rrdd__rrttpprreevv == ((ssttrruucctt rrddbbuuffff **)) &&rrddppttrr-->>rrdd__rrhhnneexxtt;;
rrddppttrr-->>rrdd__cchhnneexxtt == ((ssttrruucctt rrddbbuuffff **)) &&rrddppttrr-->>rrdd__ccttnneexxtt;;
rrddppttrr-->>rrdd__cchhpprreevv == ((ssttrruucctt rrddbbuuffff **))NNUULLLL;;
rrddppttrr-->>rrdd__ccttnneexxtt == ((ssttrruucctt rrddbbuuffff **))NNUULLLL;;
rrddppttrr-->>rrdd__ccttpprreevv == ((ssttrruucctt rrddbbuuffff **)) &&rrddppttrr-->>rrdd__cchhnneexxtt;;
//** AAllllooccaattee mmeemmoorryy ffoorr aa sseett ooff bbuuffffeerrss ((aaccttuuaallllyy rreeqquueesstt
**//
//**
bblloocckkss aanndd lliinnkk tthheemm ttoo ffoorrmm tthhee iinniittiiaall ffrreeee lliisstt
**//
ssiizzee == ssiizzeeooff((ssttrruucctt rrddbbuuffff)) ** RRDD__BBUUFFFFSS;;
bbppttrr == ((ssttrruucctt rrddbbuuffff **))ggeettmmeemm((ssiizzee));;
rrddppttrr-->>rrdd__ffrreeee == bbppttrr;;
iiff ((((iinntt3322))bbppttrr ==== SSYYSSEERRRR)) {{
ppaanniicc((""CCaannnnoott aallllooccaattee mmeemmoorryy ffoorr rreemmoottee ddiisskk bbuuffffeerrss""));;
}} 
bbuuffffeenndd == ((ssttrruucctt rrddbbuuffff **)) ((((cchhaarr **))bbppttrr ++ ssiizzee));;
wwhhiillee ((bbppttrr << bbuuffffeenndd)) {{
//** wwaallkk tthhrroouugghh mmeemmoorryy **//
ppppttrr == bbppttrr;;
bbppttrr == ((ssttrruucctt rrddbbuuffff **))
((ssiizzeeooff((ssttrruucctt rrddbbuuffff))++ ((cchhaarr **))bbppttrr));;
ppppttrr-->>rrdd__ssttaattuuss == RRDD__IINNVVAALLIIDD;;
//** BBuuffffeerr iiss eemmppttyy
**//
ppppttrr-->>rrdd__nneexxtt == bbppttrr;;
//** PPooiinntt ttoo nneexxtt bbuuffffeerr **//
}} 
ppppttrr-->>rrdd__nneexxtt == ((ssttrruucctt rrddbbuuffff **)) NNUULLLL;; //** LLaasstt bbuuffffeerr oonn lliisstt
**//
//** CCrreeaattee tthhee rreeqquueesstt lliisstt aanndd aavvaaiillaabbllee bbuuffffeerr sseemmaapphhoorreess **//
rrddppttrr-->>rrdd__aavvaaiillsseemm == sseemmccrreeaattee((RRDD__BBUUFFFFSS));;
rrddppttrr-->>rrdd__rreeqqsseemm
== sseemmccrreeaattee((00));;

Sec. 18.9        Driver Initialization (rdsinit) 
429
//** SSeett tthhee sseerrvveerr IIPP aaddddrreessss,, sseerrvveerr ppoorrtt,, aanndd llooccaall ppoorrtt **//
iiff (( ddoott22iipp((RRDD__SSEERRVVEERR__IIPP,, &&rrddppttrr-->>rrdd__sseerr__iipp)) ==== SSYYSSEERRRR )) {{
ppaanniicc((""iinnvvaalliidd IIPP aaddddrreessss ffoorr rreemmoottee ddiisskk sseerrvveerr""));;
}} 
//** SSeett tthhee ppoorrtt nnuummbbeerrss **//
rrddppttrr-->>rrdd__sseerr__ppoorrtt == RRDD__SSEERRVVEERR__PPOORRTT;;
rrddppttrr-->>rrdd__lloocc__ppoorrtt == RRDD__LLOOCC__PPOORRTT ++ ddeevvppttrr-->>ddvvmmiinnoorr;;
//** SSppeecciiffyy tthhaatt tthhee sseerrvveerr ppoorrtt iiss nnoott yyeett rreeggiisstteerreedd **//
rrddppttrr-->>rrdd__rreeggiisstteerreedd == FFAALLSSEE;;
//** CCrreeaattee aa ccoommmmuunniiccaattiioonn pprroocceessss **//
rrddppttrr-->>rrdd__ccoommpprroocc == ccrreeaattee((rrddsspprroocceessss,, RRDD__SSTTAACCKK,, RRDD__PPRRIIOO,,
""rrddsspprroocc"",, 11,, rrddppttrr));;
iiff ((rrddppttrr-->>rrdd__ccoommpprroocc ==== SSYYSSEERRRR)) {{
ppaanniicc((""CCaannnnoott ccrreeaattee rreemmoottee ddiisskk pprroocceessss""));;
}} 
rreessuummee((rrddppttrr-->>rrdd__ccoommpprroocc));;
rreettuurrnn OOKK;;
}}
In addition to initializing data structures, rdsinit performs three important tasks. It 
allocates a set of disk buffers and links them onto the free list, it creates two sema-
phores that control processing, and it creates the high-priority process that communi-
cates with the server.
One of the semaphores, rd_reqsem, guards the request list. The semaphore starts 
with count zero, and is signaled each time a new request is added to the request queue. 
The communication process waits on rd_reqsem before extracting an item from the list, 
which means the process will block if the list is empty. Because the semaphore starts 
with an initial count of zero, the communication process will block on the semaphore 
until a request has been deposited in the queue.
The other semaphore, rd_availsem, counts the number of buffers that are available
for use (i.e., free or in the cache). Initially, RD_BUFFS buffers are on the free list and
rd_availsem has a count equal to RD_BUFFS. When a buffer is needed, a caller waits
on the semaphore. The cache poses a special case because not all buffers in the cache
are available. Buffers for which operations have been completed can be taken from the 
cache at any time. However, buffers that correspond to pending operations (e.g., a

430 
A Remote Disk Driver 
Chap. 18
process has requested a read operation but has not yet extracted the data) must remain
in the cache. We will see how the cache and the semaphores are used later.
18.10 The Upper–half Open Function (rdsopen)
The remote disk server allows multiple clients to access the server simultaneously. 
Each client supplies a unique identification string which allows the server to distinguish 
among clients. Instead of using a hardware value (e.g., an Ethernet address) as the 
unique string, the example code allows a user to specify the ID string by calling open 
on the disk device. The chief advantage of separating the ID from the hardware is por-
tability — the remote disk ID can be bound to the operating system image, which 
means that moving the image from one physical computer to another does not change 
the disk that the system is using.
When a process calls open for a remote disk device, the second argument is inter-
preted as an ID string. The string is copied into the device control block, and the same
ID is used as long as the device remains open. It is possible to close the remote disk 
device and reopen it with a new ID (i.e., connect to a different remote disk). However, 
most systems are expected to open a remote disk device once and never close it. File 
rdsopen.c contains the code:
//** rrddssooppeenn..cc -- rrddssooppeenn **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrddssooppeenn
--
OOppeenn aa rreemmoottee ddiisskk ddeevviiccee aanndd ssppeecciiffyy aann IIDD ttoo uussee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrddssooppeenn ((
ssttrruucctt ddeennttrryy
**ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**ddiisskkiidd,,
//** DDiisskk IIDD ttoo uussee
**//
cchhaarr
**mmooddee
//** UUnnuusseedd ffoorr aa rreemmoottee ddiisskk
**//
))
{{
ssttrruucctt
rrddssccbbllkk **rrddppttrr;;
//** PPttrr ttoo ccoonnttrrooll bblloocckk eennttrryy
**//
ssttrruucctt
rrdd__mmssgg__oorreeqq mmssgg;;
//** MMeessssaaggee ttoo bbee sseenntt
**//
ssttrruucctt
rrdd__mmssgg__oorreess rreesspp;;
//** BBuuffffeerr ttoo hhoolldd rreessppoonnssee
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee ffrroomm rrddssccoommmm
**//
iinntt3322
lleenn;;
//** CCoouunnttss cchhaarrss iinn ddiisskkiidd
**//
cchhaarr
**iiddttoo;;
//** PPttrr ttoo IIDD ssttrriinngg ccooppyy
**//
cchhaarr
**iiddffrroomm;;
//** PPooiinntteerr iinnttoo IIDD ssttrriinngg
**//

Sec. 18.10        The Upper–half Open Function (rdsopen) 
431
rrddppttrr == &&rrddssttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
//** RReejjeecctt iiff ddeevviiccee iiss aallrreeaaddyy ooppeenn **//
iiff ((rrddppttrr-->>rrdd__ssttaattee !!== RRDD__FFRREEEE)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
rrddppttrr-->>rrdd__ssttaattee == RRDD__PPEENNDD;;
//** CCooppyy ddiisskk IIDD iinnttoo ffrreeee ttaabbllee sslloott **//
iiddttoo == rrddppttrr-->>rrdd__iidd;;
iiddffrroomm == ddiisskkiidd;;
lleenn == 00;;
wwhhiillee (( ((**iiddttoo++++ == **iiddffrroomm++++)) !!== NNUULLLLCCHH)) {{
lleenn++++;;
iiff ((lleenn >>== RRDD__IIDDLLEENN)) {{
//** IIDD ssttrriinngg iiss ttoooo lloonngg **//
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
//** VVeerriiffyy tthhaatt nnaammee iiss nnoonn--nnuullll **//
iiff ((lleenn ==== 00)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** HHaanndd--ccrraafftt aann ooppeenn rreeqquueesstt mmeessssaaggee ttoo bbee sseenntt ttoo tthhee sseerrvveerr **//
mmssgg..rrdd__ttyyppee == hhttoonnss((RRDD__MMSSGG__OORREEQQ));;//** RReeqquueesstt aann ooppeenn
**//
mmssgg..rrdd__ssttaattuuss == hhttoonnss((00));;
mmssgg..rrdd__sseeqq == 00;;
//** RRddssccoommmm ffiillllss iinn aann eennttrryy
**//
iiddttoo == mmssgg..rrdd__iidd;;
mmeemmsseett((iiddttoo,, NNUULLLLCCHH,, RRDD__IIDDLLEENN));;//** iinniittiiaalliizzee IIDD ttoo zzeerroo bbyytteess
**//
iiddffrroomm == ddiisskkiidd;;
wwhhiillee (( ((**iiddttoo++++ == **iiddffrroomm++++)) !!== NNUULLLLCCHH )) {{ //** CCooppyy IIDD ttoo rreeqq..
**//
;;
}} 
//** SSeenndd mmeessssaaggee aanndd rreecceeiivvee rreessppoonnssee **//
rreettvvaall == rrddssccoommmm((((ssttrruucctt rrdd__mmssgg__hhddrr **))&&mmssgg,,
ssiizzeeooff((ssttrruucctt rrdd__mmssgg__oorreeqq)),,
((ssttrruucctt rrdd__mmssgg__hhddrr **))&&rreesspp,,

432 
A Remote Disk Driver 
Chap. 18
ssiizzeeooff((ssttrruucctt rrdd__mmssgg__oorreess)),,
rrddppttrr ));;
//** CChheecckk rreessppoonnssee **//
iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
rrddppttrr-->>rrdd__ssttaattee == RRDD__FFRREEEE;;
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((rreettvvaall ==== TTIIMMEEOOUUTT)) {{
kkpprriinnttff((""TTiimmeeoouutt dduurriinngg rreemmoottee ffiillee ooppeenn\\nn\\rr""));;
rrddppttrr-->>rrdd__ssttaattee == RRDD__FFRREEEE;;
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((nnttoohhss((rreesspp..rrdd__ssttaattuuss)) !!== 00)) {{
rrddppttrr-->>rrdd__ssttaattee == RRDD__FFRREEEE;;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** CChhaannggee ssttaattee ooff ddeevviiccee ttoo iinnddiiccaattee ccuurrrreennttllyy ooppeenn **//
rrddppttrr-->>rrdd__ssttaattee == RRDD__OOPPEENN;;
//** RReettuurrnn ddeevviiccee ddeessccrriippttoorr **//
rreettuurrnn ddeevvppttrr-->>ddvvnnuumm;;
}}
18.11 The Remote Communication Function (rdscomm)
As one of the steps in opening the local remote disk device, rdsopen exchanges a 
message with the remote server. It places an open request message in local variable 
msg, and calls rdscomm to forward the message to the server. Rdscomm takes argu-
ments that specify an outgoing message, a buffer for a reply, and the length of each. It 
sends the outgoing message to the server, and awaits a reply. If the reply is valid, 
rdscomm returns the length of the reply to the caller; otherwise, it returns SYSERR to in-
dicate that an error occurred or TIMEOUT to indicate that no response was received. 
File rdscomm.c contains the code:
//** rrddssccoommmm..cc -- rrddssccoommmm **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrddssccoommmm
--
hhaannddllee ccoommmmuunniiccaattiioonn wwiitthh aa rreemmoottee ddiisskk sseerrvveerr ((sseenndd aa
**
rreeqquueesstt aanndd rreecceeiivvee aa rreeppllyy,, iinncclluuddiinngg sseeqquueenncciinngg aanndd
**
rreettrriieess))

Sec. 18.11        The Remote Communication Function (rdscomm) 
433
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
rrddssccoommmm ((
ssttrruucctt rrdd__mmssgg__hhddrr **mmssgg,,
//** MMeessssaaggee ttoo sseenndd
**//
iinntt3322
mmlleenn,,
//** MMeessssaaggee lleennggtthh
**//
ssttrruucctt rrdd__mmssgg__hhddrr **rreeppllyy,,
//** BBuuffffeerr ffoorr rreeppllyy
**//
iinntt3322
rrlleenn,,
//** SSiizzee ooff rreeppllyy bbuuffffeerr
**//
ssttrruucctt rrddssccbbllkk
**rrddppttrr
//** PPttrr ttoo ddeevviiccee ccoonnttrrooll bblloocckk
**//
))
{{
iinntt3322
ii;;
//** CCoouunnttss rreettrriieess
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee
**//
iinntt3322
sseeqq;;
//** SSeeqquueennccee ffoorr tthhiiss eexxcchhaannggee
**//
uuiinntt3322
llooccaalliipp;;
//** LLooccaall IIPP aaddddrreessss
**//
iinntt1166
rrttyyppee;;
//** RReeppllyy ttyyppee iinn hhoosstt bbyyttee oorrddeerr**//
bbooooll88
xxmmiitt;;
//** SShhoouulldd wwee ttrraannssmmiitt aaggaaiinn??
**//
iinntt3322
sslloott;;
//** UUDDPP sslloott
**//
//** FFoorr tthhee ffiirrsstt ttiimmee aafftteerr rreebboooott,, rreeggiisstteerr tthhee sseerrvveerr ppoorrtt **//
iiff (( !! rrddppttrr-->>rrdd__rreeggiisstteerreedd )) {{
sslloott == uuddpp__rreeggiisstteerr((00,, rrddppttrr-->>rrdd__sseerr__ppoorrtt,,
rrddppttrr-->>rrdd__lloocc__ppoorrtt));;
iiff((sslloott ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
rrddppttrr-->>rrdd__uuddppsslloott == sslloott;;
rrddppttrr-->>rrdd__rreeggiisstteerreedd == TTRRUUEE;;
}} 
iiff (( NNeettDDaattaa..iippvvaalliidd ==== FFAALLSSEE )) {{
llooccaalliipp == ggeettllooccaalliipp(());;
iiff((((iinntt3322))llooccaalliipp ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
//** RReettrriieevvee tthhee ssaavveedd UUDDPP sslloott nnuummbbeerr
**//
sslloott == rrddppttrr-->>rrdd__uuddppsslloott;;
//** AAssssiiggnn mmeessssaaggee nneexxtt sseeqquueennccee nnuummbbeerr **//
sseeqq == rrddppttrr-->>rrdd__sseeqq++++;;
mmssgg-->>rrdd__sseeqq == hhttoonnll((sseeqq));;

434 
A Remote Disk Driver 
Chap. 18
//** RReeppeeaatt RRDD__RREETTRRIIEESS ttiimmeess:: sseenndd mmeessssaaggee aanndd rreecceeiivvee rreeppllyy **//
xxmmiitt == TTRRUUEE;;
ffoorr ((ii==00;; ii<<RRDD__RREETTRRIIEESS;; ii++++)) {{
iiff ((xxmmiitt)) {{
//** SSeenndd aa ccooppyy ooff tthhee mmeessssaaggee **//
rreettvvaall == uuddpp__sseennddttoo((sslloott,, rrddppttrr-->>rrdd__sseerr__iipp,, rrddppttrr-->>rrdd__sseerr__ppoorrtt,,
((cchhaarr **))mmssgg,, mmlleenn));;
iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
kkpprriinnttff((""CCaannnnoott sseenndd ttoo rreemmoottee ddiisskk sseerrvveerr\\nn\\rr""));;
rreettuurrnn SSYYSSEERRRR;;
}}
}} eellssee {{
xxmmiitt == TTRRUUEE;;
}} 
//** RReecceeiivvee aa rreeppllyy **//
rreettvvaall == uuddpp__rreeccvv((sslloott,, ((cchhaarr **))rreeppllyy,, rrlleenn,,
RRDD__TTIIMMEEOOUUTT));;
iiff ((rreettvvaall ==== TTIIMMEEOOUUTT)) {{
ccoonnttiinnuuee;;
}} eellssee iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
kkpprriinnttff((""EErrrroorr rreeaaddiinngg rreemmoottee ddiisskk rreeppllyy\\nn\\rr""));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** VVeerriiffyy tthhaatt sseeqquueennccee iinn rreeppllyy mmaattcchheess rreeqquueesstt **//
iiff ((nnttoohhll((rreeppllyy-->>rrdd__sseeqq)) << sseeqq)) {{
xxmmiitt == FFAALLSSEE;;
}} eellssee iiff ((nnttoohhll((rreeppllyy-->>rrdd__sseeqq)) !!== sseeqq)) {{
ccoonnttiinnuuee;;
}} 
//** VVeerriiffyy tthhee ttyyppee iinn tthhee rreeppllyy mmaattcchheess tthhee rreeqquueesstt **//
rrttyyppee == nnttoohhss((rreeppllyy-->>rrdd__ttyyppee));;
iiff ((rrttyyppee !!== (( nnttoohhss((mmssgg-->>rrdd__ttyyppee)) || RRDD__MMSSGG__RREESSPPOONNSSEE)) )) {{
ccoonnttiinnuuee;;
}}

Sec. 18.11        The Remote Communication Function (rdscomm) 
435
//** CChheecckk tthhee ssttaattuuss **//
iiff ((nnttoohhss((rreeppllyy-->>rrdd__ssttaattuuss)) !!== 00)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
rreettuurrnn OOKK;;
}} 
//** RReettrriieess eexxhhaauusstteedd wwiitthhoouutt ssuucccceessss **//
kkpprriinnttff((""TTiimmeeoouutt oonn eexxcchhaannggee wwiitthh rreemmoottee ddiisskk sseerrvveerr\\nn\\rr""));;
rreettuurrnn TTIIMMEEOOUUTT;;
}}
Rdscomm uses UDP for communication with the remote server.† The code takes
two steps related to the use of UDP. First, rdscomm checks to see whether the UDP
port has already been registered, and calls udp_register if it has not. It may seem that
the check is unnecessary because the port will not be registered until rdscomm runs. 
However, checking at runtime allows the remote disk system to be restarted. Second, 
rdscomm checks to see whether the computer has already obtained an IP address (which 
is required for Internet communication). If an address has not been assigned, rdscomm 
calls getlocalip to obtain an address. Once the two steps are complete, rdscomm is 
ready to communicate with the remote disk server.
Rdscomm assigns the next sequence number to the message, and enters a loop that 
iterates RD_RETRIES times. On each iteration, rdscomm calls udp_sendto to transmit a 
copy of the message to the server, and calls udp_recv to receive a reply. If a reply ar-
rives, rdscomm verifies that the sequence number of the reply matches the sequence 
number of the request that was sent, that the type of the reply matches the type of the 
request, and that the status value indicates success (i.e., is zero). If the reply is valid, 
rdscomm returns OK to the caller; otherwise, it returns an error indication.
18.12 The Upper–half Write Function (rdswrite)
Because the remote disk system provides asynchronous write operations, the
upper-half write function is easiest to understand. The general idea is that a write re-
quest must be created, the data to be written must be copied into the request, and the re-
quest must be enqueued on the request queue. However, because our driver has both a 
queue of impending requests and a cache of recently-accessed blocks, the driver must 
handle the case where a request refers to a block that is already in memory on the re-
quest queue or in the cache. File rdswrite.c contains the code:

†A description of UDP is given in Chapter 17, starting on page 358.

436 
A Remote Disk Driver 
Chap. 18
//** rrddsswwrriittee..cc -- rrddsswwrriittee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrddsswwrriittee
--
WWrriittee aa bblloocckk ttoo aa rreemmoottee ddiisskk
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrddsswwrriittee ((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**bbuuffff,,
//** BBuuffffeerr tthhaatt hhoollddss aa ddiisskk bbllkk **//
iinntt3322 bbllkk
//** BBlloocckk nnuummbbeerr ttoo wwrriittee
**//
))
{{
ssttrruucctt
rrddssccbbllkk **rrddppttrr;;
//** PPooiinntteerr ttoo ccoonnttrrooll bblloocckk
**//
ssttrruucctt
rrddbbuuffff
**bbppttrr;;
//** PPooiinntteerr ttoo bbuuffffeerr oonn aa lliisstt
**//
ssttrruucctt
rrddbbuuffff
**ppppttrr;;
//** PPttrr ttoo pprreevviioouuss bbuuffff oonn lliisstt **//
ssttrruucctt
rrddbbuuffff
**nnppttrr;;
//** PPttrr ttoo nneexxtt bbuuffffeerr oonn lliisstt
**//
bbooooll88
ffoouunndd;;
//** WWaass bbuuffff ffoouunndd dduurriinngg sseeaarrcchh??**//
//** IIff ddeevviiccee nnoott ccuurrrreennttllyy iinn uussee,, rreeppoorrtt aann eerrrroorr **//
rrddppttrr == &&rrddssttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
iiff ((rrddppttrr-->>rrdd__ssttaattee !!== RRDD__OOPPEENN)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** IIff rreeqquueesstt qquueeuuee aallrreeaaddyy ccoonnttaaiinnss aa wwrriittee rreeqquueesstt **//
//**
ffoorr tthhee bblloocckk,, rreeppllaaccee tthhee ccoonntteennttss
**//
bbppttrr == rrddppttrr-->>rrdd__rrhhnneexxtt;;
wwhhiillee ((bbppttrr !!== ((ssttrruucctt rrddbbuuffff **))&&rrddppttrr-->>rrdd__rrttnneexxtt)) {{
iiff (( ((bbppttrr-->>rrdd__bbllkknnuumm ==== bbllkk)) &&&&
((bbppttrr-->>rrdd__oopp ==== RRDD__OOPP__WWRRIITTEE)) )) {{
mmeemmccppyy((bbppttrr-->>rrdd__bblloocckk,, bbuuffff,, RRDD__BBLLKKSSIIZZ));;
rreettuurrnn OOKK;;
}} 
bbppttrr == bbppttrr-->>rrdd__nneexxtt;;
}} 
//** SSeeaarrcchh ccaacchhee ffoorr ccaacchheedd ccooppyy ooff bblloocckk **//
bbppttrr == rrddppttrr-->>rrdd__cchhnneexxtt;;
ffoouunndd == FFAALLSSEE;;

Sec. 18.12        The Upper–half Write Function (rdswrite) 
437
wwhhiillee ((bbppttrr !!== ((ssttrruucctt rrddbbuuffff **))&&rrddppttrr-->>rrdd__ccttnneexxtt)) {{
iiff ((bbppttrr-->>rrdd__bbllkknnuumm ==== bbllkk)) {{
iiff ((bbppttrr-->>rrdd__rreeffccnntt <<== 00)) {{
ppppttrr == bbppttrr-->>rrdd__pprreevv;;
nnppttrr == bbppttrr-->>rrdd__nneexxtt;;
//** UUnnlliinnkk nnooddee ffrroomm ccaacchhee lliisstt aanndd rreesseett**//
//**
tthhee aavvaaiillaabbllee sseemmaapphhoorree aaccccoorrddiinnggllyy**//
ppppttrr-->>rrdd__nneexxtt == bbppttrr-->>rrdd__nneexxtt;;
nnppttrr-->>rrdd__pprreevv == bbppttrr-->>rrdd__pprreevv;;
sseemmrreesseett((rrddppttrr-->>rrdd__aavvaaiillsseemm,,
sseemmccoouunntt((rrddppttrr-->>rrdd__aavvaaiillsseemm)) -- 11));;
ffoouunndd == TTRRUUEE;;
}} 
bbrreeaakk;;
}} 
bbppttrr == bbppttrr-->>rrdd__nneexxtt;;
}} 
iiff (( !!ffoouunndd )) {{
bbppttrr == rrddssbbuuffaalllloocc((rrddppttrr));;
}} 
//** CCrreeaattee aa wwrriittee rreeqquueesstt **//
mmeemmccppyy((bbppttrr-->>rrdd__bblloocckk,, bbuuffff,, RRDD__BBLLKKSSIIZZ));;
bbppttrr-->>rrdd__oopp == RRDD__OOPP__WWRRIITTEE;;
bbppttrr-->>rrdd__rreeffccnntt == 00;;
bbppttrr-->>rrdd__bbllkknnuumm == bbllkk;;
bbppttrr-->>rrdd__ssttaattuuss == RRDD__VVAALLIIDD;;
bbppttrr-->>rrdd__ppiidd == ggeettppiidd(());;
//** IInnsseerrtt nneeww rreeqquueesstt iinnttoo lliisstt jjuusstt bbeeffoorree ttaaiill **//
ppppttrr == rrddppttrr-->>rrdd__rrttpprreevv;;
rrddppttrr-->>rrdd__rrttpprreevv == bbppttrr;;
bbppttrr-->>rrdd__nneexxtt == ppppttrr-->>rrdd__nneexxtt;;
bbppttrr-->>rrdd__pprreevv == ppppttrr;;
ppppttrr-->>rrdd__nneexxtt == bbppttrr;;
//** SSiiggnnaall sseemmaapphhoorree ttoo ssttaarrtt ccoommmmuunniiccaattiioonn pprroocceessss **//
ssiiggnnaall((rrddppttrr-->>rrdd__rreeqqsseemm));;
rreettuurrnn OOKK;;
}}

438 
A Remote Disk Driver 
Chap. 18
The code first considers the case where the request queue already contains a pend-
ing write request for the same block. Note: there can only be one write request for a 
given block on the request queue at a time, which means the queue can be searched in
any order. The code searches the queue from the head toward the tail. If it finds a 
write request for the block, rdswrite replaces the contents of the request with the new 
data, and returns.
After searching the request queue, rdswrite checks the cache. If the specified 
block is in the cache, the cached copy must be invalidated. The code searches the cache 
sequentially. If it finds a match, rdswrite removes the buffer from the cache. Instead of 
moving the buffer to the free list, rdswrite uses the buffer to form a request. If no 
match is found, rdswrite calls rdsbufalloc to allocate a new buffer for the request.
The final section of rdswrite creates a write request and inserts it at the tail of the 
request queue. To help with debugging, the code fills in all fields of the request, even
if they are not needed. For example, the process ID field is set to the ID of the calling 
process, even though the field is not used for a write operation.
18.13 The Upper–half Read Function (rdsread)
The second major upper-half function corresponds to the read operation. Reading 
is more complex than writing, because input is synchronous: a process that attempts to 
read from the disk must be blocked until the data is available. Synchronization of a 
waiting process uses send and receive. A node in the request queue contains a process 
ID field. When a process calls read, the driver code creates a read request that includes 
the caller’s process ID. It then inserts the request on the request queue, calls recvclr to 
remove pending messages, and calls receive to wait for a response. When the request 
reaches the head of the queue, the remote disk communication process sends a message 
to the server and receives a response that contains the specified block. The communica-
tion process copies the block into the buffer that contains the original request, moves 
the buffer to the cache, and uses send to send a message to the waiting process with the 
buffer address. The waiting process receives the message, extracts a copy of the data, 
and returns to the function that called read.
As described, the above scheme is insufficient because buffers are used dynamical-
ly. To understand the problem, imagine that a low-priority process is blocked waiting
to read block 5. Eventually, the communication process obtains block 5 from the
server, stores block 5 in the cache, and sends a message to the waiting process. How-
ever, assume that while the request is on the request queue, higher-priority application 
processes begin to execute, meaning that the low-priority process will not run. Unfor-
tunately, if the high-priority processes continue to use disk buffers, the buffer holding 
block 5 will be taken for another operation.
The problem is exacerbated because the remote disk system permits concurrent ac-
cess: while one process is waiting to read a block, another process can attempt to read
the same block. Thus, when the communication process finally retrieves a copy of the 
block from the server, multiple processes may need to be informed.

Sec. 18.13        The Upper–half Read Function (rdsread) 
439
The example code uses a reference count technique to handle multiple requests for 
a block: the header with each buffer contains an integer that counts the number of 
processes currently reading the block. When a process finishes making a copy, the 
process decrements the reference count. The code in file rdsread.c shows how a proc-
ess creates a request, enqueues it at the tail of the request list, waits for the request to be 
filled, and copies data from the request to each caller’s buffer; later in the chapter, we 
will see how the reference count is managed.
//** rrddssrreeaadd..cc -- rrddssrreeaadd **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrddssrreeaadd
--
RReeaadd aa bblloocckk ffrroomm aa rreemmoottee ddiisskk
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrddssrreeaadd ((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**bbuuffff,,
//** BBuuffffeerr ttoo hhoolldd ddiisskk bblloocckk
**//
iinntt3322 bbllkk
//** BBlloocckk nnuummbbeerr ooff bblloocckk ttoo rreeaadd**//
))
{{
ssttrruucctt
rrddssccbbllkk **rrddppttrr;;
//** PPooiinntteerr ttoo ccoonnttrrooll bblloocckk
**//
ssttrruucctt
rrddbbuuffff
**bbppttrr;;
//** PPooiinntteerr ttoo bbuuffffeerr ppoossssiibbllyy
**//
//**
iinn tthhee rreeqquueesstt lliisstt
**//
ssttrruucctt
rrddbbuuffff
**nnppttrr;;
//** PPooiinntteerr ttoo ""nneexxtt"" nnooddee oonn aa
**//
//**
lliisstt
**//
ssttrruucctt
rrddbbuuffff
**ppppttrr;;
//** PPooiinntteerr ttoo ""pprreevviioouuss"" nnooddee
**//
//**
oonn aa lliisstt
**//
ssttrruucctt
rrddbbuuffff
**ccppttrr;;
//** PPooiinntteerr tthhaatt wwaallkkss tthhee ccaacchhee **//
//** IIff ddeevviiccee nnoott ccuurrrreennttllyy iinn uussee,, rreeppoorrtt aann eerrrroorr **//
rrddppttrr == &&rrddssttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
iiff ((rrddppttrr-->>rrdd__ssttaattee !!== RRDD__OOPPEENN)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** SSeeaarrcchh tthhee ccaacchhee ffoorr ssppeecciiffiieedd bblloocckk **//
bbppttrr == rrddppttrr-->>rrdd__cchhnneexxtt;;
wwhhiillee ((bbppttrr !!== ((ssttrruucctt rrddbbuuffff **))&&rrddppttrr-->>rrdd__ccttnneexxtt)) {{
iiff ((bbppttrr-->>rrdd__bbllkknnuumm ==== bbllkk)) {{
iiff ((bbppttrr-->>rrdd__ssttaattuuss ==== RRDD__IINNVVAALLIIDD)) {{
bbrreeaakk;;
}}

440 
A Remote Disk Driver 
Chap. 18
mmeemmccppyy((bbuuffff,, bbppttrr-->>rrdd__bblloocckk,, RRDD__BBLLKKSSIIZZ));;
rreettuurrnn OOKK;;
}} 
bbppttrr == bbppttrr-->>rrdd__nneexxtt;;
}} 
//** SSeeaarrcchh tthhee rreeqquueesstt lliisstt ffoorr mmoosstt rreecceenntt ooccccuurrrreennccee ooff bblloocckk **//
bbppttrr == rrddppttrr-->>rrdd__rrttpprreevv;;
//** SSttaarrtt aatt ttaaiill ooff lliisstt **//
wwhhiillee ((bbppttrr !!== ((ssttrruucctt rrddbbuuffff **))&&rrddppttrr-->>rrdd__rrhhnneexxtt)) {{
iiff ((bbppttrr-->>rrdd__bbllkknnuumm ==== bbllkk))
{{
//** IIff mmoosstt rreecceenntt rreeqquueesstt ffoorr bblloocckk iiss wwrriittee,, ccooppyy ddaattaa **//
iiff ((bbppttrr-->>rrdd__oopp ==== RRDD__OOPP__WWRRIITTEE)) {{
mmeemmccppyy((bbuuffff,, bbppttrr-->>rrdd__bblloocckk,, RRDD__BBLLKKSSIIZZ));;
rreettuurrnn OOKK;;
}} 
bbrreeaakk;;
}} 
bbppttrr == bbppttrr-->>rrdd__pprreevv;;
}} 
//** AAllllooccaattee aa bbuuffffeerr aanndd aadddd rreeaadd rreeqquueesstt ttoo ttaaiill ooff rreeqq.. qquueeuuee **//
bbppttrr == rrddssbbuuffaalllloocc((rrddppttrr));;
bbppttrr-->>rrdd__oopp == RRDD__OOPP__RREEAADD;;
bbppttrr-->>rrdd__rreeffccnntt == 11;;
bbppttrr-->>rrdd__bbllkknnuumm == bbllkk;;
bbppttrr-->>rrdd__ssttaattuuss == RRDD__IINNVVAALLIIDD;;
bbppttrr-->>rrdd__ppiidd == ggeettppiidd(());;
//** IInnsseerrtt nneeww rreeqquueesstt iinnttoo lliisstt jjuusstt bbeeffoorree ttaaiill **//
ppppttrr == rrddppttrr-->>rrdd__rrttpprreevv;;
rrddppttrr-->>rrdd__rrttpprreevv == bbppttrr;;
bbppttrr-->>rrdd__nneexxtt == ppppttrr-->>rrdd__nneexxtt;;
bbppttrr-->>rrdd__pprreevv == ppppttrr;;
ppppttrr-->>rrdd__nneexxtt == bbppttrr;;
//** PPrreeppaarree ttoo rreecceeiivvee mmeessssaaggee wwhheenn rreeaadd ccoommpplleetteess **//
rreeccvvccllrr(());;

Sec. 18.13        The Upper–half Read Function (rdsread) 
441
//** SSiiggnnaall sseemmaapphhoorree ttoo ssttaarrtt ccoommmmuunniiccaattiioonn pprroocceessss **//
ssiiggnnaall((rrddppttrr-->>rrdd__rreeqqsseemm));;
//** BBlloocckk ttoo wwaaiitt ffoorr mmeessssaaggee **//
bbppttrr == ((ssttrruucctt rrddbbuuffff **))rreecceeiivvee(());;
iiff ((bbppttrr ==== ((ssttrruucctt rrddbbuuffff **))SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
mmeemmccppyy((bbuuffff,, bbppttrr-->>rrdd__bblloocckk,, RRDD__BBLLKKSSIIZZ));;
bbppttrr-->>rrdd__rreeffccnntt----;;
iiff ((bbppttrr-->>rrdd__rreeffccnntt <<== 00)) {{
//** LLooookk ffoorr pprreevviioouuss iitteemm iinn ccaacchhee wwiitthh tthhee ssaammee bblloocckk
**//
//**
nnuummbbeerr ttoo sseeee iiff tthhiiss iitteemm wwaass oonnllyy bbeeiinngg kkeepptt
**//
//**
uunnttiill ppeennddiinngg rreeaadd ccoommpplleetteedd
**//
ccppttrr == rrddppttrr-->>rrdd__cchhnneexxtt;;
wwhhiillee ((ccppttrr !!== bbppttrr)) {{
iiff ((ccppttrr-->>rrdd__bbllkknnuumm ==== bbllkk)) {{
//** UUnnlliinnkk ffrroomm ccaacchhee **//
ppppttrr == bbppttrr-->>rrdd__pprreevv;;
nnppttrr == bbppttrr-->>rrdd__nneexxtt;;
ppppttrr-->>rrdd__nneexxtt == nnppttrr;;
nnppttrr-->>rrdd__pprreevv == ppppttrr;;
//** AAdddd ttoo tthhee ffrreeee lliisstt **//
bbppttrr-->>rrdd__nneexxtt == rrddppttrr-->>rrdd__ffrreeee;;
rrddppttrr-->>rrdd__ffrreeee == bbppttrr;;
}}
}}
}} 
rreettuurrnn OOKK;;
}}
Rdsread begins by handling two special cases. First, if the requested block is
found in the cache, rdsread extracts a copy of the data and returns. Second, if the re-
quest list contains a request to write the specified block, rdsread extracts a copy of the
data from the buffer and returns. Finally, rdsread creates a read request, enqueues the 
request at the tail of the request queue, and waits for a message from the communica-
tion process as described above.

442 
A Remote Disk Driver 
Chap. 18
The code handles one more detail: the case where the reference count reaches zero
and a subsequent read for the same block has placed a more recent buffer in the cache.
If this happens, the more recent version will be used for subsequent reads. Therefore, 
rdsread must extract the old buffer from the cache and move it to the free list.
18.14 Flushing Pending Requests
Because write does not wait for data transfer, the driver does not inform a process 
when a write operation completes. However, it may be important for the software to
know when data is safely stored. For example, an operating system usually ensures that 
write operations are completed before shutdown.
To allow a process to guarantee that all disk transfers have occurred, the driver in-
cludes a primitive that will block the calling process until existing requests have been 
performed. Because “synchronizing” the disk is not a data transfer operation, we use 
the high-level operation control. To flush pending requests, a process calls:
control ( disk_device, RD_SYNC )
The driver suspends the calling process until existing requests have been satisfied on the 
specified device. Once pending operations complete, the call returns.
18.15 The Upper–half Control Function (rdscontrol)
As discussed above, the example driver offers two control functions: one to erase
an entire disk and one to synchronize data to the disk (i.e., forcing all write operations
to complete). File rdscontrol.c contains the code:
//** rrddssccoonnttrrooll..cc -- rrddssccoonnttrrooll **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrddssccoonnttrrooll
--
PPrroovviiddee ccoonnttrrooll ffuunnccttiioonnss ffoorr tthhee rreemmoottee ddiisskk
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrddssccoonnttrrooll ((
ssttrruucctt ddeennttrryy
**ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
iinntt3322
ffuunncc,,
//** TThhee ccoonnttrrooll ffuunnccttiioonn ttoo uussee
**//
iinntt3322
aarrgg11,,
//** AArrgguummeenntt ##11
**//
iinntt3322
aarrgg22
//** AArrgguummeenntt ##22
**//
))
{{

Sec. 18.15        The Upper–half Control Function (rdscontrol) 
443
ssttrruucctt
rrddssccbbllkk **rrddppttrr;;
//** PPooiinntteerr ttoo ccoonnttrrooll bblloocckk
**//
ssttrruucctt
rrddbbuuffff
**bbppttrr;;
//** PPttrr ttoo bbuuffffeerr tthhaatt wwiillll bbee
**//
//**
ppllaacceedd oonn tthhee rreeqq.. qquueeuuee
**//
ssttrruucctt
rrddbbuuffff
**ppppttrr;;
//** PPttrr ttoo ""pprreevviioouuss"" nnooddee oonn
**//
//**
aa lliisstt
**//
ssttrruucctt
rrdd__mmssgg__ddrreeqq mmssgg;;
//** BBuuffffeerr ffoorr ddeelleettee rreeqquueesstt
**//
ssttrruucctt
rrdd__mmssgg__ddrreess rreesspp;;
//** BBuuffffeerr ffoorr ddeelleettee rreessppoonnssee
**//
cchhaarr
**ttoo,, **ffrroomm;;
//** UUsseedd dduurriinngg nnaammee ccooppyy
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee
**//
//** VVeerriiffyy tthhaatt ddeevviiccee iiss ccuurrrreennttllyy ooppeenn **//
rrddppttrr == &&rrddssttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
iiff ((rrddppttrr-->>rrdd__ssttaattee !!== RRDD__OOPPEENN)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
sswwiittcchh ((ffuunncc)) {{
//** SSyynncchhrroonniizzee wwrriitteess **//
ccaassee RRDDSS__CCTTLL__SSYYNNCC::
//** AAllllooccaattee aa bbuuffffeerr ttoo uussee ffoorr tthhee rreeqquueesstt lliisstt **//
bbppttrr == rrddssbbuuffaalllloocc((rrddppttrr));;
iiff ((bbppttrr ==== ((ssttrruucctt rrddbbuuffff **))SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** FFoorrmm aa ssyynncc rreeqquueesstt **//
bbppttrr-->>rrdd__oopp == RRDD__OOPP__SSYYNNCC;;
bbppttrr-->>rrdd__rreeffccnntt == 11;;
bbppttrr-->>rrdd__bbllkknnuumm == 00;;
//** UUnnuusseedd **//
bbppttrr-->>rrdd__ssttaattuuss == RRDD__IINNVVAALLIIDD;;
bbppttrr-->>rrdd__ppiidd == ggeettppiidd(());;
//** IInnsseerrtt nneeww rreeqquueesstt iinnttoo lliisstt jjuusstt bbeeffoorree ttaaiill **//
ppppttrr == rrddppttrr-->>rrdd__rrttpprreevv;;
rrddppttrr-->>rrdd__rrttpprreevv == bbppttrr;;
bbppttrr-->>rrdd__nneexxtt == ppppttrr-->>rrdd__nneexxtt;;
bbppttrr-->>rrdd__pprreevv == ppppttrr;;
ppppttrr-->>rrdd__nneexxtt == bbppttrr;;

444 
A Remote Disk Driver 
Chap. 18
//** PPrreeppaarree ttoo wwaaiitt uunnttiill iitteemm iiss pprroocceesssseedd **//
rreeccvvccllrr(());;
rreessuummee((rrddppttrr-->>rrdd__ccoommpprroocc));;
//** BBlloocckk ttoo wwaaiitt ffoorr mmeessssaaggee **//
bbppttrr == ((ssttrruucctt rrddbbuuffff **))rreecceeiivvee(());;
bbrreeaakk;;
//** DDeelleettee tthhee rreemmoottee ddiisskk ((eennttiirreellyy rreemmoovvee iitt)) **//
ccaassee RRDDSS__CCTTLL__DDEELL::
//** HHaannddccrraafftt aa mmeessssaaggee ffoorr tthhee sseerrvveerr tthhaatt rreeqquueessttss
**//
//**
ddeelleettiinngg tthhee ddiisskk wwiitthh tthhee ssppeecciiffiieedd IIDD
**//
mmssgg..rrdd__ttyyppee == hhttoonnss((RRDD__MMSSGG__DDRREEQQ));;//** RReeqquueesstt ddeelleettiioonn
**//
mmssgg..rrdd__ssttaattuuss == hhttoonnss((00));;
mmssgg..rrdd__sseeqq == 00;; //** rrddssccoommmm wwiillll iinnsseerrtt sseeqquueennccee ## llaatteerr **//
ttoo == mmssgg..rrdd__iidd;;
mmeemmsseett((ttoo,, NNUULLLLCCHH,, RRDD__IIDDLLEENN));;
//** IInniittiiaalliizzee ttoo zzeerrooeess **//
ffrroomm == rrddppttrr-->>rrdd__iidd;;
wwhhiillee (( ((**ttoo++++ == **ffrroomm++++)) !!== NNUULLLLCCHH )) {{ //** ccooppyy IIDD
**//
;;
}} 
//** SSeenndd mmeessssaaggee aanndd rreecceeiivvee rreessppoonnssee **//
rreettvvaall == rrddssccoommmm((((ssttrruucctt rrdd__mmssgg__hhddrr **))&&mmssgg,,
ssiizzeeooff((ssttrruucctt rrdd__mmssgg__ddrreeqq)),,
((ssttrruucctt rrdd__mmssgg__hhddrr **))&&rreesspp,,
ssiizzeeooff((ssttrruucctt rrdd__mmssgg__ddrreess)),,
rrddppttrr));;
//** CChheecckk rreessppoonnssee **//
iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((rreettvvaall ==== TTIIMMEEOOUUTT)) {{
kkpprriinnttff((""TTiimmeeoouutt dduurriinngg rreemmoottee ffiillee ddeelleettee\\nn\\rr""));;
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((nnttoohhss((rreesspp..rrdd__ssttaattuuss)) !!== 00)) {{
rreettuurrnn SSYYSSEERRRR;;
}}

Sec. 18.15        The Upper–half Control Function (rdscontrol) 
445
//** CClloossee llooccaall ddeevviiccee **//
rreettuurrnn rrddsscclloossee((ddeevvppttrr));;
ddeeffaauulltt::
kkpprriinnttff((""rrffssCCoonnttrrooll:: ffuunnccttiioonn %%dd nnoott vvaalliidd\\nn\\rr"",, ffuunncc));;
rreettuurrnn SSYYSSEERRRR;;
}} 
rreettuurrnn OOKK;;
}}
The code for each control function should seem familiar. The code to delete an en-
tire disk is similar to the code in rdsopen — it creates a message for the server and uses 
rdscomm to send the message. The code to synchronize disk writes is similar to the 
code in rdsread — it creates a request, enqueues the request, calls recvclr to remove 
pending messages, and calls receive to wait for a response. Once the response arrives, 
rdscontrol invokes rdsclose to close the local device, and returns to its caller.
18.16 Allocating A Disk Buffer (rdsbufalloc)
As we have seen, driver functions call rdsbufalloc when they need to allocate a
buffer. To understand how rdsbufalloc operates, recall that a semaphore counts avail-
able buffers either on the free list or in the cache with a reference count of zero. After 
waiting on the semaphore, rdsbufalloc knows that a buffer will exist in one of the two 
places. It checks the free list first. If the free list is not empty, rdsbufalloc extracts the 
first buffer and returns it. If the free list is empty, rdsbufalloc searches the cache for an 
available buffer, extracts the buffer, and returns it to the caller. If the search completes 
without finding an available buffer, the count of the semaphore is incorrect, and 
rdsbufalloc calls panic to halt the system.
File rdsbufalloc.c contains the code:

446 
A Remote Disk Driver 
Chap. 18
//** rrddssbbuuffaalllloocc..cc -- rrddssbbuuffaalllloocc **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrddssbbuuffaalllloocc
--
AAllllooccaattee aa bbuuffffeerr ffrroomm tthhee ffrreeee lliisstt oorr tthhee ccaacchhee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttrruucctt rrddbbuuffff **rrddssbbuuffaalllloocc ((
ssttrruucctt rrddssccbbllkk **rrddppttrr
//** PPttrr ttoo ddeevviiccee ccoonnttrrooll bblloocckk
**//
))
{{
ssttrruucctt
rrddbbuuffff
**bbppttrr;;
//** PPooiinntteerr ttoo aa bbuuffffeerr
**//
ssttrruucctt
rrddbbuuffff
**ppppttrr;;
//** PPooiinntteerr ttoo pprreevviioouuss bbuuffffeerr
**//
ssttrruucctt
rrddbbuuffff
**nnppttrr;;
//** PPooiinntteerr ttoo nneexxtt bbuuffffeerr
**//
//** WWaaiitt ffoorr aann aavvaaiillaabbllee bbuuffffeerr **//
wwaaiitt((rrddppttrr-->>rrdd__aavvaaiillsseemm));;
//** IIff ffrreeee lliisstt ccoonnttaaiinnss aa bbuuffffeerr,, eexxttrraacctt iitt **//
bbppttrr == rrddppttrr-->>rrdd__ffrreeee;;
iiff (( bbppttrr !!== ((ssttrruucctt rrddbbuuffff **))NNUULLLL )) {{
rrddppttrr-->>rrdd__ffrreeee == bbppttrr-->>rrdd__nneexxtt;;
rreettuurrnn bbppttrr;;
}} 
//** EExxttrraacctt oollddeesstt iitteemm iinn ccaacchhee tthhaatt hhaass rreeff ccoouunntt zzeerroo ((aatt
**//
//**
lleeaasstt oonnee ssuucchh eennttrryy mmuusstt eexxiisstt bbeeccaauussee tthhee sseemmaapphhoorree
**//
//**
hhaadd aa nnoonnzzeerroo ccoouunntt))
**//
bbppttrr == rrddppttrr-->>rrdd__ccttpprreevv;;
wwhhiillee ((bbppttrr !!== ((ssttrruucctt rrddbbuuffff **)) &&rrddppttrr-->>rrdd__cchhnneexxtt)) {{
iiff ((bbppttrr-->>rrdd__rreeffccnntt <<== 00)) {{
//** RReemmoovvee ffrroomm ccaacchhee aanndd rreettuurrnn ttoo ccaalllleerr **//
ppppttrr == bbppttrr-->>rrdd__pprreevv;;
nnppttrr == bbppttrr-->>rrdd__nneexxtt;;
ppppttrr-->>rrdd__nneexxtt == nnppttrr;;
nnppttrr-->>rrdd__pprreevv == ppppttrr;;
rreettuurrnn bbppttrr;;
}}

Sec. 18.16        Allocating A Disk Buffer (rdsbufalloc) 
447
bbppttrr == bbppttrr-->>rrdd__pprreevv;;
}} 
ppaanniicc((""RReemmoottee ddiisskk ccaannnnoott ffiinndd aann aavvaaiillaabbllee bbuuffffeerr""));;
rreettuurrnn ((ssttrruucctt rrddbbuuffff **))SSYYSSEERRRR;;
}}
18.17 The Upper–half Close Function (rdsclose)
A process invokes close to close the remote disk device and stop all communica-
tion. To close a remote disk device, all buffers must be moved back to the free list (re-
creating the conditions immediately following initialization) and the state field in the 
control block must be assigned RD_FREE. Our implementation removes buffers from 
the cache, but does not handle the request list. Instead, we require a user to wait until 
all requests have been satisfied and the request list is empty before calling rdsclose. 
The synchronization function, RDS_CTL_SYNC,† provides a way to wait for the request 
queue to drain. File rdsclose.c contains the code:
//** rrddsscclloossee..cc -- rrddsscclloossee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrddsscclloossee
--
CClloossee aa rreemmoottee ddiisskk ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrddsscclloossee ((
ssttrruucctt ddeennttrryy **ddeevvppttrr
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
))
{{
ssttrruucctt
rrddssccbbllkk **rrddppttrr;;
//** PPttrr ttoo ccoonnttrrooll bblloocckk eennttrryy
**//
ssttrruucctt
rrddbbuuffff
**bbppttrr;;
//** PPttrr ttoo bbuuffffeerr oonn aa lliisstt
**//
ssttrruucctt
rrddbbuuffff
**nnppttrr;;
//** PPttrr ttoo nneexxtt bbuuffff oonn tthhee lliisstt **//
iinntt3322
nnmmoovveedd;;
//** NNuummbbeerr ooff bbuuffffeerrss mmoovveedd
**//
//** DDeevviiccee mmuusstt bbee ooppeenn **//
rrddppttrr == &&rrddssttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
iiff ((rrddppttrr-->>rrdd__ssttaattee !!== RRDD__OOPPEENN)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** RReeqquueesstt qquueeuuee mmuusstt bbee eemmppttyy **//

†The synchronization code is found in file rdscontrol.c on page 442.

448 
A Remote Disk Driver 
Chap. 18
iiff ((rrddppttrr-->>rrdd__rrhhnneexxtt !!== ((ssttrruucctt rrddbbuuffff **))&&rrddppttrr-->>rrdd__rrttnneexxtt)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** MMoovvee aallll bbuuffffeerrss ffrroomm tthhee ccaacchhee ttoo tthhee ffrreeee lliisstt **//
bbppttrr == rrddppttrr-->>rrdd__cchhnneexxtt;;
nnmmoovveedd == 00;;
wwhhiillee ((bbppttrr !!== ((ssttrruucctt rrddbbuuffff **))&&rrddppttrr-->>rrdd__ccttnneexxtt)) {{
nnmmoovveedd++++;;
//** UUnnlliinnkk bbuuffffeerr ffrroomm ccaacchhee **//
nnppttrr == bbppttrr-->>rrdd__nneexxtt;;
((bbppttrr-->>rrdd__pprreevv))-->>rrdd__nneexxtt == nnppttrr;;
nnppttrr-->>rrdd__pprreevv == bbppttrr-->>rrdd__pprreevv;;
//** IInnsseerrtt bbuuffffeerr iinnttoo ffrreeee lliisstt **//
bbppttrr-->>rrdd__nneexxtt == rrddppttrr-->>rrdd__ffrreeee;;
rrddppttrr-->>rrdd__ffrreeee == bbppttrr;;
bbppttrr-->>rrdd__ssttaattuuss == RRDD__IINNVVAALLIIDD;;
//** MMoovvee ttoo nneexxtt bbuuffffeerr iinn tthhee ccaacchhee **//
bbppttrr == nnppttrr;;
}} 
//** SSeett tthhee ssttaattee ttoo iinnddiiccaattee tthhee ddeevviiccee iiss cclloosseedd **//
rrddppttrr-->>rrdd__ssttaattee == RRDD__FFRREEEE;;
rreettuurrnn OOKK;;
}}
18.18 The Lower–half Communication Process (rdsprocess)
In the example implementation, each remote disk device has its own control block, 
its own set of disk buffers, and its own remote communication process. Thus, a given 
remote disk process only needs to handle requests from a single queue. Although the 
code may seem long and filled with details, the general algorithm is straightforward: re-
peatedly wait on the request semaphore, examine the type of the request at the head of 
the queue, and either perform a read, a write, or a synchronization operation. File 
rdsprocess.c contains the code:

Sec. 18.18        The Lower–half Communication Process (rdsprocess) 
449
//** rrddsspprroocceessss..cc -- rrddsspprroocceessss **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrddsspprroocceessss
--
HHiigghh--pprriioorriittyy bbaacckkggrroouunndd pprroocceessss ttoo rreeppeeaatteeddllyy eexxttrraacctt
**
aann iitteemm ffrroomm tthhee rreeqquueesstt qquueeuuee aanndd sseenndd tthhee rreeqquueesstt ttoo
**
tthhee rreemmoottee ddiisskk sseerrvveerr
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
rrddsspprroocceessss ((
ssttrruucctt rrddssccbbllkk
**rrddppttrr
//** PPttrr ttoo ddeevviiccee ccoonnttrrooll bblloocckk
**//
))
{{
ssttrruucctt
rrdd__mmssgg__wwrreeqq mmssgg;;
//** MMeessssaaggee ttoo bbee sseenntt
**//
//**
((iinncclluuddeess ddaattaa aarreeaa))
**//
ssttrruucctt
rrdd__mmssgg__rrrreess rreesspp;;
//** BBuuffffeerr ttoo hhoolldd rreessppoonnssee
**//
//**
((iinncclluuddeess ddaattaa aarreeaa))
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee ffrroomm rrddssccoommmm
**//
cchhaarr
**iiddttoo;;
//** PPttrr ttoo IIDD ssttrriinngg ccooppyy
**//
cchhaarr
**iiddffrroomm;;
//** PPttrr iinnttoo IIDD ssttrriinngg
**//
ssttrruucctt
rrddbbuuffff
**bbppttrr;;
//** PPttrr ttoo bbuuffffeerr aatt tthhee hheeaadd ooff **//
//**
tthhee rreeqquueesstt qquueeuuee
**//
ssttrruucctt
rrddbbuuffff
**nnppttrr;;
//** PPttrr ttoo nneexxtt bbuuffffeerr oonn tthhee
**//
//**
rreeqquueesstt qquueeuuee
**//
ssttrruucctt
rrddbbuuffff
**ppppttrr;;
//** PPttrr ttoo pprreevviioouuss bbuuffffeerr
**//
ssttrruucctt
rrddbbuuffff
**qqppttrr;;
//** PPttrr tthhaatt rruunnss aalloonngg tthhee
**//
//**
rreeqquueesstt qquueeuuee
**//
iinntt3322
ii;;
//** LLoooopp iinnddeexx
**//
wwhhiillee ((TTRRUUEE)) {{
//** DDoo ffoorreevveerr **//
//** WWaaiitt uunnttiill tthhee rreeqquueesstt qquueeuuee ccoonnttaaiinnss aa nnooddee **//
wwaaiitt((rrddppttrr-->>rrdd__rreeqqsseemm));;
bbppttrr == rrddppttrr-->>rrdd__rrhhnneexxtt;;
//** UUssee ooppeerraattiioonn iinn rreeqquueesstt ttoo ddeetteerrmmiinnee aaccttiioonn **//
sswwiittcchh ((bbppttrr-->>rrdd__oopp)) {{
ccaassee RRDD__OOPP__RREEAADD::
//** BBuuiilldd aa rreeaadd rreeqquueesstt mmeessssaaggee ffoorr tthhee sseerrvveerr **//
mmssgg..rrdd__ttyyppee == hhttoonnss((RRDD__MMSSGG__RRRREEQQ));;
//** RReeaadd rreeqquueesstt **//
mmssgg..rrdd__ssttaattuuss == hhttoonnss((00));;

450 
A Remote Disk Driver 
Chap. 18
mmssgg..rrdd__sseeqq == 00;;
//** RRddssccoommmm ffiillllss iinn aann eennttrryy
**//
iiddttoo == mmssgg..rrdd__iidd;;
mmeemmsseett((iiddttoo,, NNUULLLLCCHH,, RRDD__IIDDLLEENN));;//** IInniittiiaalliizzee IIDD ttoo zzeerroo **//
iiddffrroomm == rrddppttrr-->>rrdd__iidd;;
wwhhiillee (( ((**iiddttoo++++ == **iiddffrroomm++++)) !!== NNUULLLLCCHH )) {{ //** CCooppyy IIDD
**//
;;
}} 
//** SSeenndd tthhee mmeessssaaggee aanndd rreecceeiivvee aa rreessppoonnssee **//
rreettvvaall == rrddssccoommmm((((ssttrruucctt rrdd__mmssgg__hhddrr **))&&mmssgg,,
ssiizzeeooff((ssttrruucctt rrdd__mmssgg__rrrreeqq)),,
((ssttrruucctt rrdd__mmssgg__hhddrr **))&&rreesspp,,
ssiizzeeooff((ssttrruucctt rrdd__mmssgg__rrrreess)),,
rrddppttrr ));;
//** CChheecckk rreessppoonnssee **//
iiff (( ((rreettvvaall ==== SSYYSSEERRRR)) |||| ((rreettvvaall ==== TTIIMMEEOOUUTT)) ||||
((nnttoohhss((rreesspp..rrdd__ssttaattuuss)) !!== 00)) )) {{
ppaanniicc((""FFaaiilleedd ttoo ccoonnttaacctt rreemmoottee ddiisskk sseerrvveerr""));;
}} 
//** CCooppyy ddaattaa ffrroomm tthhee rreeppllyy iinnttoo tthhee bbuuffffeerr **//
ffoorr ((ii==00;; ii<<RRDD__BBLLKKSSIIZZ;; ii++++)) {{
bbppttrr-->>rrdd__bblloocckk[[ii]] == rreesspp..rrdd__ddaattaa[[ii]];;
}} 
//** UUnnlliinnkk bbuuffffeerr ffrroomm tthhee rreeqquueesstt qquueeuuee **//
nnppttrr == bbppttrr-->>rrdd__nneexxtt;;
ppppttrr == bbppttrr-->>rrdd__pprreevv;;
nnppttrr-->>rrdd__pprreevv == bbppttrr-->>rrdd__pprreevv;;
ppppttrr-->>rrdd__nneexxtt == bbppttrr-->>rrdd__nneexxtt;;
//** IInnsseerrtt bbuuffffeerr iinn tthhee ccaacchhee **//
ppppttrr == ((ssttrruucctt rrddbbuuffff **)) &&rrddppttrr-->>rrdd__cchhnneexxtt;;
nnppttrr == ppppttrr-->>rrdd__nneexxtt;;
bbppttrr-->>rrdd__nneexxtt == nnppttrr;;
bbppttrr-->>rrdd__pprreevv == ppppttrr;;
ppppttrr-->>rrdd__nneexxtt == bbppttrr;;
nnppttrr-->>rrdd__pprreevv == bbppttrr;;

Sec. 18.18        The Lower–half Communication Process (rdsprocess) 
451
//** IInniittiiaalliizzee rreeffeerreennccee ccoouunntt **//
bbppttrr-->>rrdd__rreeffccnntt == 11;;
//** SSiiggnnaall tthhee aavvaaiillaabbllee sseemmaapphhoorree **//
ssiiggnnaall((rrddppttrr-->>rrdd__aavvaaiillsseemm));;
//** SSeenndd aa mmeessssaaggee ttoo wwaaiittiinngg pprroocceessss **//
sseenndd((bbppttrr-->>rrdd__ppiidd,, ((uuiinntt3322))bbppttrr));;
//** IIff ootthheerr pprroocceesssseess aarree wwaaiittiinngg ttoo rreeaadd tthhee
**//
//**
bblloocckk,, nnoottiiffyy tthheemm aanndd rreemmoovvee tthhee rreeqquueesstt **//
qqppttrr == rrddppttrr-->>rrdd__rrhhnneexxtt;;
wwhhiillee ((qqppttrr !!== ((ssttrruucctt rrddbbuuffff **))&&rrddppttrr-->>rrdd__rrttnneexxtt)) {{
iiff ((qqppttrr-->>rrdd__bbllkknnuumm ==== bbppttrr-->>rrdd__bbllkknnuumm)) {{
bbppttrr-->>rrdd__rreeffccnntt++++;;
sseenndd((qqppttrr-->>rrdd__ppiidd,,((uuiinntt3322))bbppttrr));;
//** UUnnlliinnkk rreeqquueesstt ffrroomm qquueeuuee
**//
ppppttrr == qqppttrr-->>rrdd__pprreevv;;
nnppttrr == qqppttrr-->>rrdd__nneexxtt;;
ppppttrr-->>rrdd__nneexxtt == bbppttrr-->>rrdd__nneexxtt;;
nnppttrr-->>rrdd__pprreevv == bbppttrr-->>rrdd__pprreevv;;
//** MMoovvee bbuuffffeerr ttoo tthhee ffrreeee lliisstt **//
qqppttrr-->>rrdd__nneexxtt == rrddppttrr-->>rrdd__ffrreeee;;
rrddppttrr-->>rrdd__ffrreeee == qqppttrr;;
ssiiggnnaall((rrddppttrr-->>rrdd__aavvaaiillsseemm));;
bbrreeaakk;;
}} 
qqppttrr == qqppttrr-->>rrdd__nneexxtt;;
}} 
bbrreeaakk;;
ccaassee RRDD__OOPP__WWRRIITTEE::
//** BBuuiilldd aa wwrriittee rreeqquueesstt mmeessssaaggee ffoorr tthhee sseerrvveerr **//
mmssgg..rrdd__ttyyppee == hhttoonnss((RRDD__MMSSGG__WWRREEQQ));;
//** WWrriittee rreeqquueesstt**//
mmssgg..rrdd__bbllkk == bbppttrr-->>rrdd__bbllkknnuumm;;

452 
A Remote Disk Driver 
Chap. 18
mmssgg..rrdd__ssttaattuuss == hhttoonnss((00));;
mmssgg..rrdd__sseeqq == 00;;
//** RRddssccoommbb ffiillllss iinn aann eennttrryy
**//
iiddttoo == mmssgg..rrdd__iidd;;
mmeemmsseett((iiddttoo,, NNUULLLLCCHH,, RRDD__IIDDLLEENN));;//** IInniittiiaalliizzee IIDD ttoo zzeerroo **//
iiddffrroomm == rrddppttrr-->>rrdd__iidd;;
wwhhiillee (( ((**iiddttoo++++ == **iiddffrroomm++++)) !!== NNUULLLLCCHH )) {{ //** CCooppyy IIDD
**//
;;
}} 
ffoorr ((ii==00;; ii<<RRDD__BBLLKKSSIIZZ;; ii++++)) {{
mmssgg..rrdd__ddaattaa[[ii]] == bbppttrr-->>rrdd__bblloocckk[[ii]];;
}} 
//** UUnnlliinnkk bbuuffffeerr ffrroomm rreeqquueesstt qquueeuuee **//
nnppttrr == bbppttrr-->>rrdd__nneexxtt;;
ppppttrr == bbppttrr-->>rrdd__pprreevv;;
ppppttrr-->>rrdd__nneexxtt == nnppttrr;;
nnppttrr-->>rrdd__pprreevv == ppppttrr;;
//** IInnsseerrtt bbuuffffeerr iinn tthhee ccaacchhee **//
ppppttrr == ((ssttrruucctt rrddbbuuffff **)) &&rrddppttrr-->>rrdd__cchhnneexxtt;;
nnppttrr == ppppttrr-->>rrdd__nneexxtt;;
bbppttrr-->>rrdd__nneexxtt == nnppttrr;;
bbppttrr-->>rrdd__pprreevv == ppppttrr;;
ppppttrr-->>rrdd__nneexxtt == bbppttrr;;
nnppttrr-->>rrdd__pprreevv == bbppttrr;;
//** DDeeccllaarree tthhaatt bbuuffffeerr iiss eelliiggiibbllee ffoorr rreeuussee **//
bbppttrr-->>rrdd__rreeffccnntt == 00;;
ssiiggnnaall((rrddppttrr-->>rrdd__aavvaaiillsseemm));;
//** SSeenndd tthhee mmeessssaaggee aanndd rreecceeiivvee aa rreessppoonnssee **//
rreettvvaall == rrddssccoommmm((((ssttrruucctt rrdd__mmssgg__hhddrr **))&&mmssgg,,
ssiizzeeooff((ssttrruucctt rrdd__mmssgg__wwrreeqq)),,
((ssttrruucctt rrdd__mmssgg__hhddrr **))&&rreesspp,,
ssiizzeeooff((ssttrruucctt rrdd__mmssgg__wwrreess)),,
rrddppttrr ));;
//** CChheecckk rreessppoonnssee **//
iiff (( ((rreettvvaall ==== SSYYSSEERRRR)) |||| ((rreettvvaall ==== TTIIMMEEOOUUTT)) ||||
((nnttoohhss((rreesspp..rrdd__ssttaattuuss)) !!== 00)) )) {{

Sec. 18.18        The Lower–half Communication Process (rdsprocess) 
453
ppaanniicc((""ffaaiilleedd ttoo ccoonnttaacctt rreemmoottee ddiisskk sseerrvveerr""));;
}} 
bbrreeaakk;;
ccaassee RRDD__OOPP__SSYYNNCC::
//** SSeenndd aa mmeessssaaggee ttoo tthhee wwaaiittiinngg pprroocceessss **//
sseenndd((bbppttrr-->>rrdd__ppiidd,, OOKK));;
//** UUnnlliinnkk bbuuffffeerr ffrroomm tthhee rreeqquueesstt qquueeuuee **//
nnppttrr == bbppttrr-->>rrdd__nneexxtt;;
ppppttrr == bbppttrr-->>rrdd__pprreevv;;
nnppttrr-->>rrdd__pprreevv == bbppttrr-->>rrdd__pprreevv;;
ppppttrr-->>rrdd__nneexxtt == bbppttrr-->>rrdd__nneexxtt;;
//** IInnsseerrtt bbuuffffeerr iinnttoo tthhee ffrreeee lliisstt **//
bbppttrr-->>rrdd__nneexxtt == rrddppttrr-->>rrdd__ffrreeee;;
rrddppttrr-->>rrdd__ffrreeee == bbppttrr;;
ssiiggnnaall((rrddppttrr-->>rrdd__aavvaaiillsseemm));;
bbrreeaakk;;
}}
}}
}}
When examining the code, remember that the remote disk process has higher prior-
ity than any application process. Thus, the code does not need to disable interrupts or
use a mutual exclusion semaphore when accessing the request queue, cache, or free list. 
However, rdsprocess must leave all data structures in a valid state before using 
rdscomm to exchange messages with the server, because message reception blocks the 
calling process (which means other processes can run). In the case of a read operation, 
rdsprocess leaves the buffer on the request queue until the request can be satisfied. In 
the case of a write operation, rdsprocess extracts a copy of the data and moves the 
buffer to the cache before calling rdscomm.
18.19 Perspective
Conceptually, a remote disk system only needs to provide two basic operations: 
read a block and write a block. In practice, however, the issues of synchrony, caching, 
and sharing dominate the design. Our example simplifies most design decisions be-
cause we assume a single Xinu system acts as a client. Thus, the client code manages

454 
A Remote Disk Driver 
Chap. 18
its local cache, and does not need to coordinate with other Xinu systems. Similarly, the 
lack of sharing simplifies the question of synchrony: the client only needs local infor-
mation to enforce last-write semantics.
If the system is extended to permit multiple Xinu systems to share a disk, the en-
tire design must change. A given client cannot cache blocks unless the client coordi-
nates with the server. Furthermore, last-write semantics must be enforced across all 
systems, which means read operations need a centralized mechanism to ensure that they 
occur in order. A tradeoff arises between sharing and efficiency because communica-
tion is expensive. Relying on a centralized server to coordinate sharing eliminates cach-
ing and imposes a much higher communication overhead. The point is:
Extending the remote disk system to include sharing across multiple 
Xinu systems will result in significant changes to the structure of the 
system and a significant decrease in performance, especially during 
periods of simultaneous access.
18.20 Summary
We considered the design of a remote disk system in which an application can 
read and write disk blocks, and the driver uses a network to communicate with a remote 
server that performs the operation. The driver views a disk as an array of randomly ac-
cessible data blocks, and does not provide files, directories, or any index techniques to 
speed searching. Reading consists of copying data from a specified block on disk into 
memory; writing consists of copying data from memory onto a specified disk block.
Driver code is divided into upper-half functions that are called by application 
processes and a lower half that executes as a separate process. Input is synchronous; a 
process blocks until a request can be satisfied. Output is asynchronous; the driver ac-
cepts an outgoing data block, enqueues the request, and returns to the caller immediate-
ly without blocking. A process can use the control function to flush previous writes to 
disk.
The driver uses three main data structures: a queue of requests, a cache of recently 
used blocks, and a free list. Although it relies on caching to make access efficient, our 
driver guarantees last-write semantics.
EXERCISES
18.1 
Redesign the implementation to keep the buffers separate from the nodes used on the re-
quest list and the cache (i.e., define nodes for each list and arrange for each node to have
a pointer to a buffer). What are the advantages and disadvantages of each approach?

Exercises
455
18.2 
Redesign the remote disk system to use a “buffer exchange” paradigm in which applica-
tions and driver functions share a single buffer pool. To write a disk block, arrange for
an application to allocate a buffer, fill the buffer, and pass the buffer when calling write. 
Have read return a buffer pointer which the application must free once the data has been 
extracted.
18.3     It is possible to configure a system with multiple remote disk devices. Modify the code
in rdsopen to check each open remote disk device to ensure that a disk ID is unique.
18.4 
Build a version of a remote disk system that does not use a cache, and measure the
difference in performance of the two versions.
18.5 
Should requests from high-priority processes take precedence over requests from low-
priority processes? Explain why or why not.
18.6 
Investigate other algorithms like the “elevator” algorithm that can be used to order disk
requests for an electro-mechanical disk.
18.7 
Verify that a request to “synchronize” will not return until all pending requests have
been satisfied. Is there a bound on the time it can be delayed?
18.8  
Redesign the system to use two servers for redundancy. Copy each transaction to both
servers. How much overhead does the redundant implementation add?
18.9 
Build a remote disk server that allows simultaneous access by multiple client computers
and multiple concurrent processes on each client. Plot performance as the number of 
simultaneous users increases.
18.10    Some operating systems allow a disk to be divided into multiple partitions, where each
partition has blocks numbered 0 through N–1 for some N. What is the advantage of par-
titioning disks? Hint: consider the previous exercise.


Chapter Contents
19.1 
What Is A File System?, 459
19.2 
An Example Set Of File Operations, 460
19.3 
Design Of A Local File System, 461
19.4 
Data Structures For The Xinu File System, 461
19.5 
Implementation Of The Index Manager, 462
19.6 
Clearing An Index Block (lfibclear), 467
19.7 
Retrieving An Index Block (lfibget), 468
19.8 
Storing An Index Block (lfibput), 469
19.9 
Allocating An Index Block From The Free List (lfiballoc), 471
19.10 Allocating A Data Block From The Free List (lfdballoc), 472 
19.11 Using The Device-Independent I/O Functions For Files, 474 
19.12 File System Device Configuration And Function Names, 474 
19.13 The Local File System Open Function (lfsopen), 475
19.14 Closing A File Pseudo-Device (lflclose), 483 
19.15 Flushing Data To Disk (lfflush), 483
19.16 Bulk Transfer Functions For A File (lflwrite, lflread), 486 
19.17 Seeking To A New Position In the File (lflseek), 488
19.18 Extracting One Byte From A File (lflgetc), 489 
19.19 Changing One Byte In A File (lflputc), 490
19.20 Loading An Index Block And A Data Block (lfsetup), 492 
19.21 Master File System Device Initialization (lfsinit), 496
19.22 Pseudo-Device Initialization (lflinit), 497 
19.23 File Truncation (lftruncate), 499
19.24 Initial File System Creation (lfscreate), 501 
19.25 Perspective, 503
19.26 Summary, 504


19
File Systems
Filing is concerned with the past; anything you
actually need to see again has to do with the future.
— Katharine Whitehorn
The previous chapter discusses a disk abstraction, and describes a hardware inter-
face that allows the system to read and write individual blocks. Although disks have
the advantage of providing long-term, non-volatile storage, the block-oriented interface
is cumbersome.
This chapter introduces the file system abstraction. It shows how an operating sys-
tem manages a set of dynamically changing file objects, and how the system maps files 
onto the underlying disk hardware.
19.1 What Is A File System?
A file system consists of software that manages permanent data objects whose
values persist longer than the processes that create and use them. Permanent data is
kept in files, which are stored on secondary storage devices, either solid state or elec-
tromechanical disks. Files are organized into directories (also called folders). Concep-
tually, each file consists of a sequence of data objects (e.g., a sequence of integers). 
The file system provides operations that create or delete a file, open a file given its 
name, read the next object from an open file, write an object onto an open file, or close 
a file. If a file system allows random access, the file interface also provides a way a 
process can seek to a specified location in a file.
459

460
File Systems 
Chap. 19
Many file systems offer more functionality than an interface that can access indivi-
dual files on secondary storage — they provide an abstract namespace and high-level 
operations to manipulate objects in that space. The file namespace consists of the set of 
valid file names. A namespace can be as simple as “the set of strings formed from at 
least one but fewer than nine alphabetic characters,” or as complex as “the set of strings 
that form a valid encoding of the network, machine, user, subdirectory, and file identi-
fiers in a specified syntax.” In some systems, the syntax of names in the abstract space 
conveys information about their type (e.g., text files end in “.txt”). In others, names 
give information about the organization of the file system (e.g., a file name that begins 
with the string “M1_d0:” might reside on disk 0 of machine 1). We will defer a discus-
sion of file naming to Chapter 21, and concentrate on file access.
19.2 An Example Set Of File Operations
Our example system uses a straightforward approach motivated by a desire to unify 
the interface between devices and files and to keep the file system software small. File 
semantics are taken from Unix according to the following principle:
The file system considers each file to be a sequence of zero or more 
bytes; any further structure must be enforced by application programs 
that use the file.
Treating a file as a sequence of bytes has several advantages. First, the file system 
does not impose a type on the file and does not need to distinguish among file types. 
Second, the code is small because a single set of file system functions suffices for all 
files. Third, the file semantics can be applied to devices and services as well as to con-
ventional files. Fourth, application programs can choose an arbitrary structure for data 
without changing the underlying system. Finally, file contents are independent of the 
processor or memory (e.g., an application may need to distinguish among a 32-bit and 
64-bit integer stored in a file, but the file system does not).
Our system will use exactly the same high-level operations for files that are used
for devices. Thus, the file system will support open, close, read, write, putc, getc, seek,
init, and control functions. When applied to conventional files, the operations produce
the following results.  Init initializes data structures at startup.  Opening a named file 
connects an executing process with the data on disk, and establishes a pointer to the 
first byte. Operations getc and read retrieve data from the file and advance the pointer; 
getc retrieves one byte, and read can retrieve multiple bytes. Operations putc and write 
change bytes in the file and move the pointer along, extending the file length if new 
data is written beyond the end; putc changes one byte, and write can change multiple 
bytes. The seek operation moves the pointer to a specified byte position in the file; the 
first byte is at position zero. Finally, close detaches the running process from the file, 
leaving the data in the file on permanent storage.

Sec. 19.3        Design Of A Local File System 
461
19.3 Design Of A Local File System
A file is said to be local to a given computer if the file resides on a storage device 
that is attached to the computer. The design of software that manages such files is non-
trivial; it has been the subject of much research. Although the file operations may seem 
straightforward, complexity arises because files are dynamic. That is, a single disk can 
hold multiple files, and a given file can grow arbitrarily large (until disk space is ex-
hausted). To permit dynamic file growth, a system cannot pre-allocate disk blocks for a 
file. Thus, dynamic data structures are needed.
A second form of complexity arises from concurrency. To what extent should the 
system support concurrent file operations? Large systems usually allow arbitrary 
numbers of processes to read and write arbitrary numbers of files concurrently. The
chief difficulty with multiple access lies in specifying exactly what it means to have 
multiple processes writing and reading a file at the same time. When will data become 
available for reading? If two processes attempt to write to the same data byte in the 
file, which will be accepted? Can a process lock pieces of a file to avoid interference?
The generality of allowing multiple processes to read and write a file is usually not 
necessary on small embedded systems. Thus, to limit the software complexity and 
make better use of disk space, small systems can constrain the ways in which files can
be accessed. They may limit the number of files that a given process can access simul-
taneously, or limit the number of processes that can access a given file simultaneously.
Our goal is to design efficient, compact file system software that allows processes 
to create and extend files dynamically without incurring unnecessary overhead. As a 
compromise between generality and efficiency, we will allow a process to open an arbi-
trary number of files until resources are exhausted. However, the system limits a file to 
one active open. That is, if a file is open, successive requests to open the file (e.g., re-
quests by other processes) will fail until the file has been closed. Each file has a mutual 
exclusion semaphore to guarantee that only one process at a time can attempt to write a 
byte to the file, read a byte from the file, or change the current file position. Further-
more, the directory has a mutual exclusion semaphore to guarantee that only one proc-
ess at a time can attempt to create a file or otherwise change a directory entry. 
Although concurrency requires attention to detail, the most significant consequence of 
our design arises from its support for dynamic file growth: data structures will be need-
ed to allocate space on a disk dynamically. The next section explains the data struc-
tures used.
19.4 Data Structures For The Xinu File System
To support dynamic growth and random access, the Xinu file system allocates disk 
blocks dynamically and uses an index mechanism to locate the data in a given file
quickly. The design partitions a disk into three separate areas as Figure 19.1 illustrates: 
a directory, an index area, and a data area.

462
File Systems 
Chap. 19
dir.
index
data area
Figure 19.1 Illustration of a disk partitioned into three areas for the Xinu file
system.
The first sector of the disk holds a directory that contains a list of file names along 
with a pointer to the list of index blocks for the file. The directory also contains two 
other pointers: one to a list of free (unused) index blocks and another to a list of free
data blocks. The directory entry for a file also contains an integer that gives the current 
size of the file measured in bytes.
Following the directory, the disk contains an index area that holds a set of index 
blocks, abbreviated i-blocks. Each file has its own index, which consists of a singly-
linked list of index blocks. Initially, all index blocks are linked onto a free list from 
which the system allocates one as needed; index blocks are only returned to the free list
if a file is truncated or deleted.
Following the index area, remaining blocks of the disk comprise a data area. Each 
block in the data area is referred to as a data block, abbreviated d-block, because a 
block contains data that has been stored in a file. Once a data block has been allocated 
to a file, the block only can contain data. A data block does not contain pointers to oth-
er data blocks, nor does it contain information that relates the block to the file of which
it is a part; all such information resides in the file’s index.
Similar to index blocks, when a disk is initialized, the data blocks are linked onto a
free list. The file system allocates data blocks from the free list as needed, and returns
data blocks to the free list when a file is truncated or deleted.
Figure 19.2 illustrates the conceptual data structure used for a Xinu file system. 
The figure is not drawn to scale: in practice a data block is much larger than an index 
block and occupies one physical disk block. The important idea is that the data struc-
ture illustrated in the figure resides on disk. We will see that at any given time, only a 
few pieces of the structure are present in memory — the file system must create and 
maintain an index without reading the structure into memory.
19.5 Implementation Of The Index Manager
Conceptually index blocks form a randomly accessible array that is mapped onto a 
contiguous area of the disk. Thus, index blocks are numbered from zero through K, and 
the software uses the number to refer to a given index block. Because an index block is 
smaller than a physical disk block, the system stores seven index blocks into each phys-
ical block, and the software handles the details of reading and writing an individual in-
dex block.

Sec. 19.5        Implementation Of The Index Manager 
463
. . .
index block
. . .
index block
. . .
index block
. . .
index block
. . .
index block
. . .
index block
filename 1 
filename 2
. . .
directory
16 data blocks
Figure 19.2 Illustration of the Xinu file system, where each file consists of a
linked list of index blocks that each contain pointers to data 
blocks.
Because the underlying hardware can only transfer an entire disk block at a time, 
the file system cannot transfer an individual index block without transferring others that 
reside in the same physical disk block. Therefore, to write an index block, the software 
must read the entire physical disk block in which it resides, copy the new index block 
into the correct position, and write the resulting physical block back to disk. Similarly, 
to read an index block, the software must read the physical disk block in which it re-
sides, and then extract the index block.
Before we examine the code to handle index blocks, we need to understand basic 
definitions. File lfilesys.h defines constants and data structures used throughout the lo-
cal file system, including struct lfiblk which defines the contents of an index block. As
the file shows, each index block contains a pointer to the next index block, an offset that 
specifies the lowest position in the file indexed by the block, and an array of sixteen 
pointers to data blocks. That is, each entry in the array gives the physical disk sector 
number of a data block. Because a sector is 512 bytes long, a single index block 
indexes sixteen 512-byte blocks or 8192 bytes of data.
How does the software know where to find an index block given its address? In-
dex blocks are contiguous, and occupy contiguous disk sectors starting at sector
LF_AREA_IB. In our design, the directory occupies disk block zero, which means that
the index area starts at sector one. Thus, index blocks zero through six lie in sector
one, seven through thirteen lie in sector two, and so on. Inline function ib2sect converts
an index block number into the correct sector number, and inline function ib2disp con-
verts an index block number to a byte displacement within a physical disk block. Both 
functions can be found in file lfilesys.h.

464
File Systems 
Chap. 19
//** llffiilleessyyss..hh -- iibb22sseecctt,, iibb22ddiisspp **//
//************************************************************************************************************************************************//
//** 
**//
//**
LLooccaall FFiillee SSyysstteemm DDaattaa SSttrruuccttuurreess
**//
//** 
**//
//**
AA llooccaall ffiillee ssyysstteemm uusseess aa rraannddoomm--aacccceessss ddiisskk ccoommppoosseedd ooff 551122--bbyyttee **//
//** sseeccttoorrss nnuummbbeerreedd 00 tthhrroouugghh NN--11..
WWee aassssuummee ddiisskk hhaarrddwwaarree ccaann rreeaadd oorr **//
//** wwrriittee aannyy sseeccttoorr aatt rraannddoomm,, bbuutt mmuusstt ttrraannssffeerr aann eennttiirree sseeccttoorr..
**//
//** TThhuuss,, ttoo wwrriittee aa ffeeww bbyytteess,, tthhee ffiillee ssyysstteemm mmuusstt rreeaadd tthhee sseeccttoorr,,
**//
//** rreeppllaaccee tthhee bbyytteess,, aanndd tthheenn wwrriittee tthhee sseeccttoorr bbaacckk ttoo ddiisskk..
XXiinnuu’’ss
**//
//** llooccaall ffiillee ssyysstteemm ddiivviiddeess tthhee ddiisskk aass ffoolllloowwss:: sseeccttoorr 00 iiss aa
**//
//** ddiirreeccttoorryy,, tthhee nneexxtt KK sseeccttoorrss ccoonnssttiittuuttee aann iinnddeexx aarreeaa,, aanndd tthhee
**//
//** rreemmaaiinniinngg sseeccttoorrss ccoommpprriissee aa ddaattaa aarreeaa.. TThhee ddaattaa aarreeaa iiss eeaassiieesstt ttoo
**//
//** uunnddeerrssttaanndd:: eeaacchh sseeccttoorr hhoollddss oonnee ddaattaa bblloocckk ((dd--bblloocckk)) tthhaatt ssttoorreess
**//
//** ccoonntteennttss ffrroomm oonnee ooff tthhee ffiilleess ((oorr iiss oonn aa ffrreeee lliisstt ooff uunnuusseedd ddaattaa
**//
//** bblloocckkss))..
WWee tthhiinnkk ooff tthhee iinnddeexx aarreeaa aass hhoollddiinngg aann aarrrraayy ooff iinnddeexx
**//
//** bblloocckkss ((ii--bblloocckkss)) nnuummbbeerreedd 00 tthhrroouugghh II--11..
AA ggiivveenn sseeccttoorr iinn tthhee
**//
//** iinnddeexx aarreeaa hhoollddss 77 ooff tthhee iinnddeexx bblloocckkss,, wwhhiicchh aarree eeaacchh 7722 bbyytteess
**//
//** lloonngg..
GGiivveenn aann ii--bblloocckk nnuummbbeerr,, tthhee ffiillee ssyysstteemm mmuusstt ccaallccuullaattee tthhee
**//
//** ddiisskk sseeccttoorr iinn wwhhiicchh tthhee ii--bblloocckk iiss llooccaatteedd aanndd tthhee bbyyttee ooffffsseett
**//
//** wwiitthhiinn tthhee sseeccttoorr aatt wwhhiicchh tthhee ii--bblloocckk rreessiiddeess..
IInntteerrnnaallllyy,, aa ffiillee
**//
//** iiss kknnoowwnn bbyy tthhee ii--bblloocckk iinnddeexx ooff tthhee ffiirrsstt ii--bblloocckk ffoorr tthhee ffiillee..
**//
//** TThhee ddiirreeccttoorryy ccoonnttaaiinnss aa lliisstt ooff ffiillee nnaammeess aanndd tthhee
ii--bblloocckk nnuummbbeerr
**//
//** ooff tthhee ffiirrsstt ii--bblloocckk ffoorr tthhee ffiillee..
TThhee ddiirreeccttoorryy aallssoo hhoollddss tthhee
**//
//** ii--bblloocckk nnuummbbeerr ffoorr aa lliisstt ooff ffrreeee ii--bblloocckkss aanndd aa ddaattaa bblloocckk nnuummbbeerr
**//
//** ooff tthhee ffiirrsstt ddaattaa bblloocckk oonn aa lliisstt ooff ffrreeee ddaattaa bblloocckkss..
**//
//** 
**//
//************************************************************************************************************************************************//
##iiffnnddeeff NNllffll
##ddeeffiinnee NNllffll
11
##eennddiiff
//** UUssee tthhee rreemmoottee ddiisskk ddeevviiccee iiff nnoo ddiisskk iiss ddeeffiinneedd ((ffiillee ssyysstteemm
**//
//**
**aassssuummeess** tthhee uunnddeerrllyyiinngg ddiisskk hhaass aa bblloocckk ssiizzee ooff 551122 bbyytteess))
**//
##iiffnnddeeff LLFF__DDIISSKK__DDEEVV
##ddeeffiinnee LLFF__DDIISSKK__DDEEVV
SSYYSSEERRRR
##eennddiiff
##ddeeffiinnee LLFF__MMOODDEE__RR
FF__MMOODDEE__RR
//** MMooddee bbiitt ffoorr ""rreeaadd""
**//
##ddeeffiinnee LLFF__MMOODDEE__WW
FF__MMOODDEE__WW
//** MMooddee bbiitt ffoorr ""wwrriittee""
**//
##ddeeffiinnee LLFF__MMOODDEE__RRWW
FF__MMOODDEE__RRWW
//** MMooddee bbiittss ffoorr ""rreeaadd oorr wwrriittee""**//

Sec. 19.5        Implementation Of The Index Manager 
465
##ddeeffiinnee LLFF__MMOODDEE__OO
FF__MMOODDEE__OO
//** MMooddee bbiitt ffoorr ""oolldd""
**//
##ddeeffiinnee LLFF__MMOODDEE__NN
FF__MMOODDEE__NN
//** MMooddee bbiitt ffoorr ""nneeww""
**//
##ddeeffiinnee LLFF__BBLLKKSSIIZZ
551122
//** AAssssuummeess 551122--bbyyttee ddiisskk bblloocckkss **//
##ddeeffiinnee LLFF__NNAAMMEE__LLEENN
1166
//** LLeennggtthh ooff nnaammee pplluuss nnuullll
**//
##ddeeffiinnee LLFF__NNUUMM__DDIIRR__EENNTT
2200
//** NNuumm.. ooff ffiilleess iinn aa ddiirreeccttoorryy **//
##ddeeffiinnee LLFF__FFRREEEE
00
//** SSllaavvee ddeevviiccee iiss aavvaaiillaabbllee
**//
##ddeeffiinnee LLFF__UUSSEEDD
11
//** SSllaavvee ddeevviiccee iiss iinn uussee
**//
##ddeeffiinnee LLFF__IINNUULLLL
((iibbiidd3322)) --11
//** IInnddeexx bblloocckk nnuullll ppooiinntteerr
**//
##ddeeffiinnee LLFF__DDNNUULLLL
((ddbbiidd3322)) --11
//** DDaattaa bblloocckk nnuullll ppooiinntteerr
**//
##ddeeffiinnee LLFF__IIBBLLEENN
1166
//** DDaattaa bblloocckk ppttrrss ppeerr ii--bblloocckk
**//
##ddeeffiinnee LLFF__IIDDAATTAA
88119922
//** BByytteess ooff ddaattaa iinnddeexxeedd bbyy aa
**//
//**
ssiinnggllee iinnddeexx bblloocckk
**//
##ddeeffiinnee LLFF__IIMMAASSKK
00xx0000000011ffffff
//** MMaasskk ffoorr tthhee ddaattaa iinnddeexxeedd bbyy **//
//**
oonnee iinnddeexx bblloocckk ((ii..ee..,,
**//
//**
bbyytteess 00 tthhrroouugghh 88119911))..
**//
##ddeeffiinnee LLFF__DDMMAASSKK
00xx000000000011ffff
//** MMaasskk ffoorr tthhee ddaattaa iinn aa ddaattaa
**//
//**
bblloocckk ((00 tthhrroouugghh 551111))
**//
##ddeeffiinnee LLFF__AARREEAA__IIBB
11
//** FFiirrsstt sseeccttoorr ooff ii--bblloocckkss
**//
##ddeeffiinnee LLFF__AARREEAA__DDIIRR
00
//** FFiirrsstt sseeccttoorr ooff ddiirreeccttoorryy
**//
//** SSttrruuccttuurree ooff aann iinnddeexx bblloocckk oonn ddiisskk **//
ssttrruucctt
llffiibbllkk
{{
//** FFoorrmmaatt ooff iinnddeexx bblloocckk
**//
iibbiidd3322
iibb__nneexxtt;;
//** AAddddrreessss ooff nneexxtt iinnddeexx bblloocckk
**//
uuiinntt3322
iibb__ooffffsseett;;
//** FFiirrsstt ddaattaa bbyyttee ooff tthhee ffiillee
**//
//**
IInnddeexxeedd bbyy tthhiiss ii--bblloocckk
**//
ddbbiidd3322
iibb__ddbbaa[[LLFF__IIBBLLEENN]];;//** PPttrrss ttoo ddaattaa bblloocckkss iinnddeexxeedd **//
}};;
//** CCoonnvveerrssiioonn ffuunnccttiioonnss bbeellooww aassssuummee 77 iinnddeexx bblloocckkss ppeerr ddiisskk bblloocckk **//
//** CCoonnvveerrssiioonn bbeettwweeeenn iinnddeexx bblloocckk nnuummbbeerr aanndd ddiisskk sseeccttoorr nnuummbbeerr **//
##ddeeffiinnee iibb22sseecctt((iibb))
((((((iibb))//77))++LLFF__AARREEAA__IIBB))
//** CCoonnvveerrssiioonn bbeettwweeeenn iinnddeexx bblloocckk nnuummbbeerr aanndd tthhee rreellaattiivvee ooffffsseett wwiitthhiinn **//
//**
aa ddiisskk sseeccttoorr
**//
##ddeeffiinnee iibb22ddiisspp((iibb))
((((((iibb))%%77))**ssiizzeeooff((ssttrruucctt llffiibbllkk))))

466
File Systems 
Chap. 19
//** SSttrruuccttuurree uusseedd iinn eeaacchh ddiirreeccttoorryy eennttrryy ffoorr tthhee llooccaall ffiillee ssyysstteemm **//
ssttrruucctt
llddeennttrryy {{
//** DDeessccrriippttiioonn ooff eennttrryy ffoorr oonnee **//
//**
ffiillee iinn tthhee ddiirreeccttoorryy
**//
uuiinntt3322
lldd__ssiizzee;;
//** CCuurrrr.. ssiizzee ooff ffiillee iinn bbyytteess
**//
iibbiidd3322
lldd__iilliisstt;;
//** IIDD ooff ffiirrsstt ii--bblloocckk ffoorr ffiillee **//
//**
oorr IIBB__NNUULLLL ffoorr eemmppttyy ffiillee
**//
cchhaarr
lldd__nnaammee[[LLFF__NNAAMMEE__LLEENN]];;
//** NNuullll--tteerrmmiinnaatteedd ffiillee nnaammee
**//
}};;
//** SSttrruuccttuurree ooff aa ddaattaa bblloocckk wwhheenn oonn tthhee ffrreeee lliisstt oonn ddiisskk **//
ssttrruucctt
llffddbbffrreeee {{
ddbbiidd3322
llff__nneexxttddbb;;
//** NNeexxtt ddaattaa bblloocckk oonn tthhee lliisstt
**//
cchhaarr
llff__uunnuusseedd[[LLFF__BBLLKKSSIIZZ -- ssiizzeeooff((ddbbiidd3322))]];;
}};;
//** FFoorrmmaatt ooff tthhee ffiillee ssyysstteemm ddiirreeccttoorryy,, eeiitthheerr oonn ddiisskk oorr iinn mmeemmoorryy **//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
llffddiirr
{{
//** EEnnttiirree ddiirreeccttoorryy oonn ddiisskk
**//
ddbbiidd3322
llffdd__ddffrreeee;;
//** LLiisstt ooff ffrreeee dd--bblloocckkss oonn ddiisskk**//
iibbiidd3322
llffdd__iiffrreeee;;
//** LLiisstt ooff ffrreeee ii--bblloocckkss oonn ddiisskk**//
iinntt3322
llffdd__nnffiilleess;;
//** CCuurrrreenntt nnuummbbeerr ooff ffiilleess
**//
ssttrruucctt
llddeennttrryy llffdd__ffiilleess[[LLFF__NNUUMM__DDIIRR__EENNTT]];; //** SSeett ooff ffiilleess
**//
cchhaarr
ppaaddddiinngg[[2200]];;
//** UUnnuusseedd cchhaarrss iinn ddiirreeccttoorryy bbllkk**//
}};;
##pprraaggmmaa ppaacckk(())
//** GGlloobbaall ddaattaa uusseedd bbyy llooccaall ffiillee ssyysstteemm **//
ssttrruucctt
llffddaattaa
{{
//** LLooccaall ffiillee ssyysstteemm ddaattaa
**//
ddiidd3322
llff__ddsskkddeevv;;
//** DDeevviiccee IIDD ooff ddiisskk ttoo uussee
**//
ssiidd3322
llff__mmuutteexx;;
//** MMuutteexx ffoorr tthhee ddiirreeccttoorryy aanndd
**//
//**
iinnddeexx//ddaattaa ffrreeee lliissttss
**//
ssttrruucctt
llffddiirr
llff__ddiirr;;
//** IInn--mmeemmoorryy ccooppyy ooff ddiirreeccttoorryy
**//
bbooooll88
llff__ddiirrpprreesseenntt;;
//** TTrruuee wwhheenn ddiirreeccttoorryy iiss iinn
**//
//**
mmeemmoorryy ((11sstt ffiillee iiss ooppeenn))
**//
bbooooll88
llff__ddiirrddiirrttyy;;
//** HHaass tthhee ddiirreeccttoorryy cchhaannggeedd??
**//
}};;
//** CCoonnttrrooll bblloocckk ffoorr llooccaall ffiillee ppsseeuuddoo--ddeevviiccee **//
ssttrruucctt
llffllccbbllkk {{
//** LLooccaall ffiillee ccoonnttrrooll bblloocckk
**//
//**
((oonnee ffoorr eeaacchh ooppeenn ffiillee))
**//

Sec. 19.5        Implementation Of The Index Manager 
467
bbyyttee
llffssttaattee;;
//** IIss eennttrryy ffrreeee oorr uusseedd
**//
ddiidd3322
llffddeevv;;
//** DDeevviiccee IIDD ooff tthhiiss ddeevviiccee
**//
ssiidd3322
llffmmuutteexx;;
//** MMuutteexx ffoorr tthhiiss ffiillee
**//
ssttrruucctt
llddeennttrryy **llffddiirrppttrr;;
//** PPttrr ttoo ffiillee’’ss eennttrryy iinn tthhee
**//
//**
iinn--mmeemmoorryy ddiirreeccttoorryy
**//
iinntt3322
llffmmooddee;;
//** MMooddee ((rreeaadd//wwrriittee//bbootthh))
**//
uuiinntt3322
llffppooss;;
//** BByyttee ppoossiittiioonn ooff nneexxtt bbyyttee
**//
//**
ttoo rreeaadd oorr wwrriittee
**//
cchhaarr
llffnnaammee[[LLFF__NNAAMMEE__LLEENN]];;
//** NNaammee ooff tthhee ffiillee
**//
iibbiidd3322
llffiinnuumm;;
//** IIDD ooff ccuurrrreenntt iinnddeexx bblloocckk iinn **//
//**
llffiibblloocckk oorr LLFF__IINNUULLLL
**//
ssttrruucctt
llffiibbllkk
llffiibblloocckk;;
//** IInn--mmeemm ccooppyy ooff ccuurrrreenntt iinnddeexx **//
//**
bblloocckk
**//
ddbbiidd3322
llffddnnuumm;;
//** NNuummbbeerr ooff ccuurrrreenntt ddaattaa bblloocckk **//
//**
iinn llffddbblloocckk oorr LLFF__DDNNUULLLL
**//
cchhaarr
llffddbblloocckk[[LLFF__BBLLKKSSIIZZ]];;
//** IInn--mmeemm ccooppyy ooff ccuurrrreenntt ddaattaa
**//
//**
bblloocckk
**//
cchhaarr
**llffbbyyttee;;
//** PPttrr ttoo bbyyttee iinn llffddbblloocckk oorr
**//
//**
aaddddrreessss oonnee bbeeyyoonndd llffddbblloocckk**//
//**
iiff ccuurrrreenntt ffiillee ppooss lliieess
**//
//**
oouuttssiiddee llffddbblloocckk
**//
bbooooll88
llffiibbddiirrttyy;;
//** HHaass llffiibblloocckk cchhaannggeedd??
**//
bbooooll88
llffddbbddiirrttyy;;
//** HHaass llffddbblloocckk cchhaannggeedd??
**//
}};;
eexxtteerrnn
ssttrruucctt
llffddaattaa
LLff__ddaattaa;;
eexxtteerrnn
ssttrruucctt
llffllccbbllkk llffllttaabb[[]];;
//** CCoonnttrrooll ffuunnccttiioonnss **//
##ddeeffiinnee LLFF__CCTTLL__DDEELL
FF__CCTTLL__DDEELL
//** DDeelleettee aa ffiillee
**//
##ddeeffiinnee LLFF__CCTTLL__TTRRUUNNCC
FF__CCTTLL__TTRRUUNNCC
//** TTrruunnccaattee aa ffiillee
**//
##ddeeffiinnee LLFF__CCTTLL__SSIIZZEE
FF__CCTTLL__SSIIZZEE
//** OObbttaaiinn tthhee ssiizzee ooff aa ffiillee
**//
19.6 Clearing An Index Block (lfibclear)
Whenever it allocates an index block from the free list, the file system must read 
the index block into memory and clear the block to remove old information. In particu-
lar, all data block pointers must be set to a null value, so they will not be confused with 
valid pointers. Furthermore, the offset in the index block must be assigned the ap-
propriate offset in the file. Function lfibclear clears an index block; file lfibclear.c con-
tains the code.

468
File Systems 
Chap. 19
//** llffiibbcclleeaarr..cc -- llffiibbcclleeaarr **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
llffiibbcclleeaarr
----
CClleeaarr aann iinn--ccoorree ccooppyy ooff aann iinnddeexx bblloocckk
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
llffiibbcclleeaarr((
ssttrruucctt llffiibbllkk **iibbppttrr,,
//** AAddddrreessss ooff ii--bblloocckk iinn mmeemmoorryy **//
iinntt3322
ooffffsseett
//** FFiillee ooffffsseett ffoorr tthhiiss ii--bblloocckk **//
))
{{
iinntt3322
ii;;
//** IInnddeexx ffoorr ddaattaa bblloocckk aarrrraayy
**//
iibbppttrr-->>iibb__ooffffsseett == ooffffsseett;;
//** AAssssiiggnn ssppeecciiffiieedd ffiillee ooffffsseett **//
ffoorr ((ii==00 ;; ii<<LLFF__IIBBLLEENN ;; ii++++)) {{
//** CClleeaarr eeaacchh ddaattaa bblloocckk ppooiinntteerr**//
iibbppttrr-->>iibb__ddbbaa[[ii]] == LLFF__DDNNUULLLL;;
}} 
iibbppttrr-->>iibb__nneexxtt == LLFF__IINNUULLLL;;
//** SSeett nneexxtt ppttrr ttoo nnuullll
**//
rreettuurrnn;;
}}
19.7 Retrieving An Index Block (lfibget)
To read an index block into memory, the system must map the index block number 
to a physical disk block address, read the physical disk block, and copy the appropriate 
area from the physical block into the specified memory location. File lfibget.c contains 
the code, which uses inline function ib2sect to convert the index block number to a disk 
sector, and function ib2disp to compute the location of the index block within the disk 
sector.
//** llffiibbggeett..cc -- llffiibbggeett **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
llffiibbggeett
--
GGeett aann iinnddeexx bblloocckk ffrroomm ddiisskk ggiivveenn iittss nnuummbbeerr ((aassssuummeess
**
mmuutteexx iiss hheelldd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
llffiibbggeett((
ddiidd3322
ddiisskkddeevv,,
//** DDeevviiccee IIDD ooff ddiisskk ttoo uussee
**//

Sec. 19.7        Retrieving An Index Block (lfibget) 
469
iibbiidd3322
iinnuumm,,
//** IIDD ooff iinnddeexx bblloocckk ttoo ffeettcchh
**//
ssttrruucctt llffiibbllkk **iibbuuffff
//** BBuuffffeerr ttoo hhoolldd iinnddeexx bblloocckk
**//
))
{{
cchhaarr
**ffrroomm,, **ttoo;;
//** PPooiinntteerrss uusseedd iinn ccooppyyiinngg
**//
iinntt3322
ii;;
//** LLoooopp iinnddeexx uusseedd dduurriinngg ccooppyy
**//
cchhaarr
ddbbuuffff[[LLFF__BBLLKKSSIIZZ]];;
//** BBuuffffeerr ttoo hhoolldd ddiisskk bblloocckk
**//
//** RReeaadd ddiisskk bblloocckk tthhaatt ccoonnttaaiinnss tthhee ssppeecciiffiieedd iinnddeexx bblloocckk **//
rreeaadd((ddiisskkddeevv,, ddbbuuffff,, iibb22sseecctt((iinnuumm))));;
//** CCooppyy ssppeecciiffiieedd iinnddeexx bblloocckk ttoo ccaalllleerr’’ss iibbuuffff **//
ffrroomm == ddbbuuffff ++ iibb22ddiisspp((iinnuumm));;
ttoo == ((cchhaarr **))iibbuuffff;;
ffoorr ((ii==00 ;; ii<<ssiizzeeooff((ssttrruucctt llffiibbllkk)) ;; ii++++))
**ttoo++++ == **ffrroomm++++;;
rreettuurrnn;;
}}
19.8 Storing An Index Block (lfibput)
Conceptually, we think of index blocks as occupying a giant array on disk. How-
ever, changing an index block is much more complex than changing an element in an 
array for two reasons. First, because the file system does not keep a record of which 
items in an index block changed, the entire index block must be rewritten. Second, the 
disk abstraction only provides write capability for an entire sector at a time. However, 
an index block only occupies part of a sector.
To write an index block without changing other items in the sector, the file system 
must read an entire disk sector from disk, copy bytes of the index block into the ap-
propriate area, and then write the entire sector back to disk. File lfibput.c contains the 
code. Lfibput is given a disk device, an index block ID, and a buffer address as argu-
ments. The code uses the same inline functions as lfibget to convert the index block ID 
to a disk sector and to find the byte displacement in the sector for the specified index 
block. It then calls read to read the appropriate disk block. It copies the index block 
from the caller’s buffer into the disk block, and calls write to write the entire disk block 
back to the disk.

470
File Systems 
Chap. 19
//** llffiibbppuutt..cc -- llffiibbppuutt **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
llffiibbppuutt
--
WWrriittee aann iinnddeexx bblloocckk ttoo ddiisskk ggiivveenn iittss IIDD ((aassssuummeess
**
mmuutteexx iiss hheelldd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
llffiibbppuutt((
ddiidd3322
ddiisskkddeevv,,
//** IIDD ooff ddiisskk ddeevviiccee
**//
iibbiidd3322
iinnuumm,,
//** IIDD ooff iinnddeexx bblloocckk ttoo wwrriittee
**//
ssttrruucctt llffiibbllkk **iibbuuffff
//** BBuuffffeerr hhoollddiinngg tthhee iinnddeexx bbllkk **//
))
{{
ddbbiidd3322
ddiisskkbblloocckk;;
//** IIDD ooff ddiisskk sseeccttoorr ((bblloocckk))
**//
cchhaarr
**ffrroomm,, **ttoo;;
//** PPooiinntteerrss uusseedd iinn ccooppyyiinngg
**//
iinntt3322
ii;;
//** LLoooopp iinnddeexx uusseedd dduurriinngg ccooppyy
**//
cchhaarr
ddbbuuffff[[LLFF__BBLLKKSSIIZZ]];;
//** TTeemmpp.. bbuuffffeerr ttoo hhoolldd dd--bblloocckk **//
//** CCoommppuuttee ddiisskk bblloocckk nnuummbbeerr aanndd ooffffsseett ooff iinnddeexx bblloocckk **//
ddiisskkbblloocckk == iibb22sseecctt((iinnuumm));;
ttoo == ddbbuuffff ++ iibb22ddiisspp((iinnuumm));;
ffrroomm == ((cchhaarr **))iibbuuffff;;
//** RReeaadd ddiisskk bblloocckk **//
iiff ((rreeaadd((ddiisskkddeevv,, ddbbuuffff,, ddiisskkbblloocckk)) ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** CCooppyy iinnddeexx bblloocckk iinnttoo ppllaaccee **//
ffoorr ((ii==00 ;; ii<<ssiizzeeooff((ssttrruucctt llffiibbllkk)) ;; ii++++)) {{
**ttoo++++ == **ffrroomm++++;;
}} 
//** WWrriittee tthhee bblloocckk bbaacckk ttoo ddiisskk **//
wwrriittee((ddiisskkddeevv,, ddbbuuffff,, ddiisskkbblloocckk));;
rreettuurrnn OOKK;;
}}

Sec. 19.9        Allocating An Index Block From The Free List (lfiballoc) 
471
19.9 Allocating An Index Block From The Free List (lfiballoc)
The file system allocates an index block from the free list whenever it needs to ex-
tend the index for a file. Function lfiballoc obtains the next free index block for the
disk, and returns its identifier. The code, which is found in file lfiballoc.c, assumes that
a copy of the directory for the file system has been read into memory and placed in glo-
bal variable Lf_data.lf_dir. Once the index block has been unlinked from the free list, 
the directory is written back to disk.
//** llffiibbaalllloocc..cc -- llffiibbaalllloocc **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffiibbaalllloocc
--
AAllllooccaattee aa nneeww iinnddeexx bblloocckk ffrroomm ffrreeee lliisstt oonn ddiisskk
**
((aassssuummeess ddiirreeccttoorryy mmuutteexx hheelldd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iibbiidd3322
llffiibbaalllloocc ((vvooiidd))
{{
iibbiidd3322
iibbnnuumm;;
//** IIDD ooff nneexxtt bblloocckk oonn tthhee ffrreeee lliisstt
**//
ssttrruucctt
llffiibbllkk
iibblloocckk;; //** BBuuffffeerr ttoo hhoolldd aann iinnddeexx bblloocckk
**//
//** GGeett IIDD ooff ffiirrsstt iinnddeexx bblloocckk oonn ffrreeee lliisstt **//
iibbnnuumm == LLff__ddaattaa..llff__ddiirr..llffdd__iiffrreeee;;
iiff ((iibbnnuumm ==== LLFF__IINNUULLLL)) {{
//** RRaann oouutt ooff ffrreeee iinnddeexx bblloocckkss **//
ppaanniicc((""oouutt ooff iinnddeexx bblloocckkss""));;
}} 
llffiibbggeett((LLff__ddaattaa..llff__ddsskkddeevv,, iibbnnuumm,, &&iibblloocckk));;
//** UUnnlliinnkk iinnddeexx bblloocckk ffrroomm tthhee ddiirreeccttoorryy ffrreeee lliisstt **//
LLff__ddaattaa..llff__ddiirr..llffdd__iiffrreeee == iibblloocckk..iibb__nneexxtt;;
//** WWrriittee aa ccooppyy ooff tthhee ddiirreeccttoorryy ttoo ddiisskk aafftteerr tthhee cchhaannggee **//
wwrriittee((LLff__ddaattaa..llff__ddsskkddeevv,, ((cchhaarr **)) &&LLff__ddaattaa..llff__ddiirr,, LLFF__AARREEAA__DDIIRR));;
LLff__ddaattaa..llff__ddiirrddiirrttyy == FFAALLSSEE;;
rreettuurrnn iibbnnuumm;;
}}

472
File Systems 
Chap. 19
19.10 Allocating A Data Block From The Free List (lfdballoc)
Because an index block contains a “next” pointer field, linking them into a free list 
is straightforward. For data blocks, however, the free list is less obvious because a data 
block does not usually contain a pointer field. The Xinu design uses a singly-linked 
free list, which means that only one pointer is needed. When a data block is on the free 
list, the system uses the first four bytes of the data block to store a pointer to the next 
block on the list. Structure lfdbfree, found in file lfilesys.h above, defines the format of 
a block on the free list. Whenever it extracts a data block from the free list, the file 
system uses the structure definition. Of course, once a block has been removed from 
the free list and allocated to a file, the block is treated as an array of bytes.
Function lfdballoc, which allocates a data block from the free list and returns the 
block number, illustrates how the system uses struct lfdbfree. The code can be found in 
file lfdballoc.c.
//** llffddbbaalllloocc..cc -- llffddbbaalllloocc **//
##iinncclluuddee <<xxiinnuu..hh>>
##ddeeffiinnee
DDFFIILLLL
’’++’’
//** cchhaarraacctteerr uusseedd ttoo ffiillll aa ddiisskk bblloocckk
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffddbbaalllloocc
--
AAllllooccaattee aa nneeww ddaattaa bblloocckk ffrroomm ffrreeee lliisstt oonn ddiisskk
**
((aassssuummeess ddiirreeccttoorryy mmuutteexx hheelldd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddbbiidd3322
llffddbbaalllloocc ((
ssttrruucctt llffddbbffrreeee **ddbbuuffff //** AAddddrr.. ooff bbuuffffeerr ttoo hhoolldd ddaattaa bblloocckk
**//
))
{{
ddbbiidd3322
ddnnuumm;;
//** IIDD ooff nneexxtt dd--bblloocckk oonn tthhee ffrreeee lliisstt
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee
**//
//** GGeett tthhee IIDD ooff ffiirrsstt ddaattaa bblloocckk oonn tthhee ffrreeee lliisstt **//
ddnnuumm == LLff__ddaattaa..llff__ddiirr..llffdd__ddffrreeee;;
iiff ((ddnnuumm ==== LLFF__DDNNUULLLL)) {{ //** RRaann oouutt ooff ffrreeee ddaattaa bblloocckkss **//
ppaanniicc((""oouutt ooff ddaattaa bblloocckkss""));;
}} 
rreettvvaall == rreeaadd((LLff__ddaattaa..llff__ddsskkddeevv,, ((cchhaarr **))ddbbuuffff,, ddnnuumm));;
iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
ppaanniicc((""llffddbbaalllloocc ccaannnnoott rreeaadd ddiisskk bblloocckk\\nn\\rr""));;
}}

Sec. 19.10        Allocating A Data Block From The Free List (lfdballoc) 
473
//** UUnnlliinnkk dd--bblloocckk ffrroomm iinn--mmeemmoorryy ddiirreeccttoorryy **//
LLff__ddaattaa..llff__ddiirr..llffdd__ddffrreeee == ddbbuuffff-->>llff__nneexxttddbb;;
wwrriittee((LLff__ddaattaa..llff__ddsskkddeevv,, ((cchhaarr **))&&LLff__ddaattaa..llff__ddiirr,, LLFF__AARREEAA__DDIIRR));;
LLff__ddaattaa..llff__ddiirrddiirrttyy == FFAALLSSEE;;
//** FFiillll ddaattaa bblloocckk ttoo eerraassee oolldd ddaattaa **//
mmeemmsseett((((cchhaarr **))ddbbuuffff,, DDFFIILLLL,, LLFF__BBLLKKSSIIZZ));;
rreettuurrnn ddnnuumm;;
}}
A corresponding function, lfdbfree, found in file lfdbfree.c, returns a block to the 
free list. The code inserts a pointer into the first four bytes of a block, pointing to the 
current free list. It then makes the free list pointer in the directory point to the block. 
Both the data block and the directory must be written to disk after they have been 
changed.
//** llffddbbffrreeee..cc -- llffddbbffrreeee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
llffddbbffrreeee
--
FFrreeee aa ddaattaa bblloocckk ggiivveenn iittss bblloocckk nnuummbbeerr ((aassssuummeess
**
ddiirreeccttoorryy mmuutteexx iiss hheelldd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
llffddbbffrreeee((
ddiidd3322
ddiisskkddeevv,,
//** IIDD ooff ddiisskk ddeevviiccee ttoo uussee
**//
ddbbiidd3322
ddnnuumm
//** IIDD ooff ddaattaa bblloocckk ttoo ffrreeee
**//
))
{{
ssttrruucctt
llffddiirr
**ddiirrppttrr;;
//** PPooiinntteerr ttoo ddiirreeccttoorryy
**//
ssttrruucctt
llffddbbffrreeee bbuuff;;
//** BBuuffffeerr ttoo hhoolldd ddaattaa bblloocckk
**//
ddiirrppttrr == &&LLff__ddaattaa..llff__ddiirr;;
bbuuff..llff__nneexxttddbb == ddiirrppttrr-->>llffdd__ddffrreeee;;
ddiirrppttrr-->>llffdd__ddffrreeee == ddnnuumm;;
wwrriittee((ddiisskkddeevv,, ((cchhaarr **))&&bbuuff,,
ddnnuumm));;
wwrriittee((ddiisskkddeevv,, ((cchhaarr **))ddiirrppttrr,, LLFF__AARREEAA__DDIIRR));;
rreettuurrnn OOKK;;
}}

474
File Systems 
Chap. 19
19.11 Using The Device-Independent I/O Functions For Files
The file system software must establish connections between running processes and
disk files to allow operations like read and write to be mapped onto the correct file.
Exactly how the system performs this mapping depends on both the size and generality 
needed. To keep our system small, we avoid introducing new functions by reusing the 
device switch mechanisms that are already in place.
Imagine that a set of file pseudo-devices has been added to the device switch table 
such that each pseudo-device can be used to control an open file. As with conventional 
devices, a pseudo-device has a set of driver functions that perform read, write, getc, 
putc, seek, and close operations. When a process opens a disk file, the file system 
searches for a currently unused pseudo-device, sets up the control block for the pseudo-
device, and returns the ID of the pseudo-device to the caller. After the file has been 
opened, the process uses the device ID with operations getc, read, putc, write, and seek. 
The device switch table maps each high-level operation to the appropriate driver func-
tion for file pseudo-devices exactly as it maps high-level operations onto device drivers 
for physical devices. Finally, when it finishes using a file, a process calls close to break 
the connection and make the pseudo-device available for use with another file. The de-
tails will become clear as we review the code.
Designing a pseudo-device driver is not unlike designing a device driver for a con-
ventional hardware device. Just like other drivers, the pseudo-device driver creates a 
control block for each pseudo-device. The control block for a file pseudo-device uses 
struct lflcblk, which is defined in file lfilesys.h.† Conceptually, the control block con-
tains two types of items: fields that hold information about the pseudo-device and fields 
that hold information from the disk. Fields lfstate and lfmode are the former type: the 
state field specifies whether the device is currently in use, and the mode field specifies 
whether the file has been opened for reading, writing, or both. Fields lfiblock and 
lfdblock are of the latter type: when a file is being read or written they contain a copy of 
the index block and the data block for the current position in the file measured in bytes 
(which is given by field lfpos).
When a file is opened, the position (field lfpos in the control block) is assigned 
zero. As processes read or write data, the position increases. A process can call seek to 
move to an arbitrary position in the file, and lfpos is updated.
19.12 File System Device Configuration And Function Names
What interface should be used to open a file and allocate a pseudo-device for read-
ing and writing? One possible design adds a new file abstraction to the operating sys-
tem. For, example, we can imagine a function fileopen that takes three arguments (a
disk device, file name, and mode) and returns the descriptor of a pseudo-device for the 
file:
ffdd == ffiilleeooppeenn((ddeevviiccee,, ffiilleennaammee,, mmooddee));;
                                †File lfilesys.h can be found on page 464.

Sec. 19.12        File System Device Configuration And Function Names 
475
In contrast with Unix, Xinu takes a device approach:
In Unix, everything is a file; in Xinu, everything is a device.
That is, Xinu tends to map many functions into the device space. The local file system 
follows the pattern by defining a master local file device, LFILESYS. Calling open on 
the master device causes the system to allocate a pseudo-device and return the device 
ID of the pseudo-device. File pseudo-devices are named LFILE0, LFILE1, ..., but the 
names are used only in the configuration file — a process receives the device descriptor 
of a pseudo-device when it opens the master device, but no process should call open on 
a pseudo-device. Figure 19.3 shows the types used to configure both the master and the 
local file pseudo-devices.
//** LLooccaall FFiillee SSyysstteemm mmaasstteerr ddeevviiccee ttyyppee **//
llffss:: oonn ddiisskk
--ii llffssiinniitt
--oo llffssooppeenn
--cc iiooeerrrr
--rr iiooeerrrr
--gg iiooeerrrr
--pp iiooeerrrr
--ww iiooeerrrr
--ss iiooeerrrr
--nn rrffssccoonnttrrooll
--iinnttrr NNUULLLL
//** LLooccaall ffiillee ppsseeuuddoo--ddeevviiccee ttyyppee **//
llffll:: oonn llffss
--ii llfflliinniitt
--oo iiooeerrrr
--cc llffllcclloossee
--rr llffllrreeaadd
--gg llffllggeettcc
--pp llffllppuuttcc
--ww llffllwwrriittee
--ss llffllsseeeekk
--nn iiooeerrrr
--iinnttrr NNUULLLL
Figure 19.3 Configuration types for a local file system master device and lo-
cal file pseudo-devices.
As the figure shows, driver functions for the master file system device have names 
that begin with lfs, and driver functions for a file pseudo-device have names that begin 
with lfl. We will see that support functions used by either set of driver functions have 
names that begin with lf.
19.13 The Local File System Open Function (lfsopen)
Figure 19.4 shows the configuration of the local file system master device and a
set of seven local file pseudo-devices. Because a pseudo-device is used for each open
file, the number of local file pseudo-devices provides a bound on the number of files
that can be opened simultaneously.

476
File Systems 
Chap. 19
//** LLooccaall ffiillee ssyysstteemm mmaasstteerr ddeevviiccee ((oonnee ppeerr ssyysstteemm))
**//
LLFFIILLEESSYYSS iiss llffss oonn ddiisskk
//** LLooccaall ffiillee ppsseeuuddoo--ddeevviicceess ((mmaannyy ppeerr ssyysstteemm))
**//
LLFFIILLEE00 iiss llffll oonn llffss
LLFFIILLEE11 iiss llffll oonn llffss
LLFFIILLEE22 iiss llffll oonn llffss
LLFFIILLEE33 iiss llffll oonn llffss
LLFFIILLEE44 iiss llffll oonn llffss
LLFFIILLEE55 iiss llffll oonn llffss
LLFFIILLEE66 iiss llffll oonn llffss
Figure 19.4 Configuration of a local file system master device and a set of
local file pseudo-devices.
A process uses the master device to open a local file, and then uses the pseudo-
device to access the file. For example, to open a local file named myfile for reading and 
writing, a programmer codes:
ffdd == ooppeenn((LLFFIILLEESSYYSS,, ""mmyyffiillee"",, ""rrww""));;
Assuming the open succeeds, descriptor fd can be used to write data to the file, as
in the following:
cchhaarr bbuuffffeerr[[11550000]];;
...... ccooddee ttoo ffiillll bbuuffffeerr ......
ffdd == wwrriittee((ffdd,, bbuuffffeerr,, 11550000));;
Device LFILESYS is only used to open a file. Therefore, the master file system de-
vice driver only needs functions for open and init; all other I/O operations map to ioerr. 
Function lfsopen performs the open operation; the code can be found in file lfsopen.c.
//** llffssooppeenn..cc -- llffssooppeenn **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffssooppeenn -- OOppeenn aa ffiillee aanndd aallllooccaattee aa llooccaall ffiillee ppsseeuuddoo--ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll llffssooppeenn ((
ssttrruucctt ddeennttrryy
**ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**nnaammee,,
//** NNaammee ooff ffiillee ttoo ooppeenn
**//
cchhaarr
**mmooddee
//** MMooddee cchhaarrss:: ’’rr’’ ’’ww’’ ’’oo’’ ’’nn’’
**//
))

Sec. 19.13        The Local File System Open Function (lfsopen) 
477
{{
ssttrruucctt
llffddiirr
**ddiirrppttrr;;
//** PPttrr ttoo iinn--mmeemmoorryy ddiirreeccttoorryy
**//
cchhaarr
**ffrroomm,, **ttoo;;
//** PPttrrss uusseedd dduurriinngg ccooppyy
**//
cchhaarr
**nnaamm,, **ccmmpp;;
//** PPttrrss uusseedd dduurriinngg ccoommppaarriissoonn
**//
iinntt3322
ii;;
//** GGeenneerraall lloooopp iinnddeexx
**//
ddiidd3322
llffnneexxtt;;
//** MMiinnoorr nnuummbbeerr ooff aann uunnuusseedd
**//
//**
ffiillee ppsseeuuddoo--ddeevviiccee
**//
ssttrruucctt
llddeennttrryy **llddppttrr;;
//** PPttrr ttoo aann eennttrryy iinn ddiirreeccttoorryy **//
ssttrruucctt
llffllccbbllkk **llffppttrr;;
//** PPttrr ttoo ooppeenn ffiillee ttaabbllee eennttrryy **//
bbooooll88
ffoouunndd;;
//** WWaass tthhee nnaammee ffoouunndd??
**//
iinntt3322
rreettvvaall;;
//** VVaalluuee rreettuurrnneedd ffrroomm ffuunnccttiioonn **//
iinntt3322
mmbbiittss;;
//** MMooddee bbiittss
**//
//** CChheecckk lleennggtthh ooff nnaammee ffiillee ((lleeaavviinngg ssppaaccee ffoorr NNUULLLLCCHH **//
ffrroomm == nnaammee;;
ffoorr ((ii==00;; ii<< LLFF__NNAAMMEE__LLEENN;; ii++++)) {{
iiff ((**ffrroomm++++ ==== NNUULLLLCCHH)) {{
bbrreeaakk;;
}}
}} 
iiff ((ii >>== LLFF__NNAAMMEE__LLEENN)) {{
//** NNaammee iiss ttoooo lloonngg **//
rreettuurrnn SSYYSSEERRRR;;
}} 
//** PPaarrssee mmooddee aarrgguummeenntt aanndd ccoonnvveerrtt ttoo bbiinnaarryy **//
mmbbiittss == llffggeettmmooddee((mmooddee));;
iiff ((mmbbiittss ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** IIff nnaammeedd ffiillee iiss aallrreeaaddyy ooppeenn,, rreettuurrnn SSYYSSEERRRR **//
llffnneexxtt == SSYYSSEERRRR;;
ffoorr ((ii==00;; ii<<NNllffll;; ii++++)) {{
//** SSeeaarrcchh ffiillee ppsseeuuddoo--ddeevviicceess
**//
llffppttrr == &&llffllttaabb[[ii]];;
iiff ((llffppttrr-->>llffssttaattee ==== LLFF__FFRREEEE)) {{
iiff ((llffnneexxtt ==== SSYYSSEERRRR)) {{
llffnneexxtt == ii;; //** RReeccoorrdd iinnddeexx **//
}} 
ccoonnttiinnuuee;;
}}

478
File Systems 
Chap. 19
//** CCoommppaarree rreeqquueesstteedd nnaammee ttoo nnaammee ooff ooppeenn ffiillee **//
nnaamm == nnaammee;;
ccmmpp == llffppttrr-->>llffnnaammee;;
wwhhiillee((**nnaamm !!== NNUULLLLCCHH)) {{
iiff ((**nnaamm !!== **ccmmpp)) {{
bbrreeaakk;;
}} 
nnaamm++++;;
ccmmpp++++;;
}} 
//** SSeeee iiff ccoommppaarriissoonn ssuucccceeeeddeedd **//
iiff (( ((**nnaamm====NNUULLLLCCHH)) &&&& ((**ccmmpp ==== NNUULLLLCCHH)) )) {{
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
iiff ((llffnneexxtt ==== SSYYSSEERRRR)) {{ //** NNoo ssllaavvee ffiillee ddeevviicceess aarree aavvaaiillaabbllee
**//
rreettuurrnn SSYYSSEERRRR;;
}} 
//** OObbttaaiinn ccooppyy ooff ddiirreeccttoorryy iiff nnoott aallrreeaaddyy pprreesseenntt iinn mmeemmoorryy
**//
ddiirrppttrr == &&LLff__ddaattaa..llff__ddiirr;;
wwaaiitt((LLff__ddaattaa..llff__mmuutteexx));;
iiff ((!! LLff__ddaattaa..llff__ddiirrpprreesseenntt)) {{
rreettvvaall == rreeaadd((LLff__ddaattaa..llff__ddsskkddeevv,,((cchhaarr **))ddiirrppttrr,,LLFF__AARREEAA__DDIIRR));;
iiff ((rreettvvaall ==== SSYYSSEERRRR )) {{
ssiiggnnaall((LLff__ddaattaa..llff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
LLff__ddaattaa..llff__ddiirrpprreesseenntt == TTRRUUEE;;
}} 
//** SSeeaarrcchh ddiirreeccttoorryy ttoo sseeee iiff ffiillee eexxiissttss **//
ffoouunndd == FFAALLSSEE;;
ffoorr ((ii==00;; ii<<ddiirrppttrr-->>llffdd__nnffiilleess;; ii++++)) {{
llddppttrr == &&ddiirrppttrr-->>llffdd__ffiilleess[[ii]];;
nnaamm == nnaammee;;
ccmmpp == llddppttrr-->>lldd__nnaammee;;
wwhhiillee((**nnaamm !!== NNUULLLLCCHH)) {{
iiff ((**nnaamm !!== **ccmmpp)) {{
bbrreeaakk;;

Sec. 19.13        The Local File System Open Function (lfsopen) 
479
}} 
nnaamm++++;;
ccmmpp++++;;
}} 
iiff (( ((**nnaamm====NNUULLLLCCHH)) &&&& ((**ccmmpp====NNUULLLLCCHH)) )) {{ //** NNaammee ffoouunndd **//
ffoouunndd == TTRRUUEE;;
bbrreeaakk;;
}}
}} 
//** CCaassee ##11 -- ffiillee iiss nnoott iinn ddiirreeccttoorryy ((ii..ee..,, ddooeess nnoott eexxiisstt))
**//
iiff ((!! ffoouunndd)) {{
iiff ((mmbbiittss && LLFF__MMOODDEE__OO)) {{
//** FFiillee **mmuusstt** eexxiisstt
**//
ssiiggnnaall((LLff__ddaattaa..llff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** TTaakkee sstteeppss ttoo ccrreeaattee nneeww ffiillee aanndd aadddd ttoo ddiirreeccttoorryy
**//
//** VVeerriiffyy tthhaatt ssppaaccee rreemmaaiinnss iinn tthhee ddiirreeccttoorryy **//
iiff ((ddiirrppttrr-->>llffdd__nnffiilleess >>== LLFF__NNUUMM__DDIIRR__EENNTT)) {{
ssiiggnnaall((LLff__ddaattaa..llff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** AAllllooccaattee nneexxtt ddiirr.. eennttrryy && iinniittiiaalliizzee ttoo eemmppttyy ffiillee
**//
llddppttrr == &&ddiirrppttrr-->>llffdd__ffiilleess[[ddiirrppttrr-->>llffdd__nnffiilleess++++]];;
llddppttrr-->>lldd__ssiizzee == 00;;
ffrroomm == nnaammee;;
ttoo == llddppttrr-->>lldd__nnaammee;;
wwhhiillee (( ((**ttoo++++ == **ffrroomm++++)) !!== NNUULLLLCCHH )) {{
;;
}} 
llddppttrr-->>lldd__iilliisstt == LLFF__IINNUULLLL;;
//** CCaassee ##22 -- ffiillee iiss iinn ddiirreeccttoorryy ((ii..ee..,, aallrreeaaddyy eexxiissttss))
**//
}} eellssee iiff ((mmbbiittss && LLFF__MMOODDEE__NN)) {{
//** FFiillee mmuusstt nnoott eexxiisstt
**//
ssiiggnnaall((LLff__ddaattaa..llff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}}

480
File Systems 
Chap. 19
//** IInniittiiaalliizzee tthhee llooccaall ffiillee ppsseeuuddoo--ddeevviiccee **//
llffppttrr == &&llffllttaabb[[llffnneexxtt]];;
llffppttrr-->>llffssttaattee == LLFF__UUSSEEDD;;
llffppttrr-->>llffddiirrppttrr == llddppttrr;;
//** PPooiinntt ttoo ddiirreeccttoorryy eennttrryy
**//
llffppttrr-->>llffmmooddee == mmbbiittss && LLFF__MMOODDEE__RRWW;;
//** FFiillee ssttaarrttss aatt ppoossiittiioonn 00 **//
llffppttrr-->>llffppooss
== 00;;
ttoo == llffppttrr-->>llffnnaammee;;
ffrroomm == nnaammee;;
wwhhiillee (( ((**ttoo++++ == **ffrroomm++++)) !!== NNUULLLLCCHH )) {{
;;
}} 
//** NNeeiitthheerr iinnddeexx bblloocckk nnoorr ddaattaa bblloocckk aarree iinniittiiaallllyy vvaalliidd
**//
llffppttrr-->>llffiinnuumm
== LLFF__IINNUULLLL;;
llffppttrr-->>llffddnnuumm
== LLFF__DDNNUULLLL;;
//** IInniittiiaalliizzee bbyyttee ppooiinntteerr ttoo aaddddrreessss bbeeyyoonndd tthhee eenndd ooff tthhee
**//
//**
bbuuffffeerr ((ii..ee..,, iinnvvaalliidd ppooiinntteerr ttrriiggggeerrss sseettuupp))
**//
llffppttrr-->>llffbbyyttee == &&llffppttrr-->>llffddbblloocckk[[LLFF__BBLLKKSSIIZZ]];;
llffppttrr-->>llffiibbddiirrttyy == FFAALLSSEE;;
llffppttrr-->>llffddbbddiirrttyy == FFAALLSSEE;;
ssiiggnnaall((LLff__ddaattaa..llff__mmuutteexx));;
rreettuurrnn llffppttrr-->>llffddeevv;;
}}
After verifying that the length of the file name is valid, lfsopen calls lfgetmode to
parse the mode argument and convert it to a set of bits. A mode argument consists of a
null-terminated string that contains zero or more of the characters from Figure 19.5. 
Characters in the mode string may not be repeated, and the combination of “o” and “n”
(i.e., file is both old and new) is considered illegal. Furthermore, if neither “r” nor “w”
is present in the mode string, lfgetmode assumes a default mode that allows both read-
ing and writing. After parsing the mode string, lfgetmode produces an integer with indi-
vidual bits specifying the modes as defined in lfilesys.h.† File lfgetmode.c contains the 
code.
                                †File lfilesys.h can be found on page 464.

Sec. 19.13        The Local File System Open Function (lfsopen) 
481

Character 
Meaning

r 
Open the file for reading

w 
Open the file for writing

o 
File must be “old” (i.e., must exist)

n 
File must be “new” (i.e., must not exist)




























Figure 19.5  Characters permitted in a mode string and their meaning.
//** llffggeettmmooddee..cc -- llffggeettmmooddee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffggeettmmooddee
--
PPaarrssee mmooddee aarrgguummeenntt aanndd ggeenneerraattee iinntteeggeerr ooff mmooddee bbiittss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinntt3322
llffggeettmmooddee ((
cchhaarr
**mmooddee
//** SSttrriinngg ooff mmooddee cchhaarraacctteerrss
**//
))
{{
iinntt3322
mmbbiittss;;
//** MMooddee bbiittss ttoo rreettuurrnn
**//
cchhaarr
cchh;;
//** NNeexxtt cchhaarr iinn mmooddee ssttrriinngg
**//
mmbbiittss == 00;;
//** MMooddee ssttrriinngg ssppeecciiffiieess::
**//
//**
rr -- rreeaadd
**//
//**
ww -- wwrriittee
**//
//**
oo -- oolldd ((ffiillee mmuusstt eexxiisstt))
**//
//**
nn -- nneeww ((ccrreeaattee aa nneeww ffiillee))
**//
wwhhiillee (( ((cchh == **mmooddee++++)) !!== NNUULLLLCCHH)) {{
sswwiittcchh ((cchh)) {{
ccaassee ’’rr’’::
iiff ((mmbbiittss&&LLFF__MMOODDEE__RR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
mmbbiittss ||== LLFF__MMOODDEE__RR;;
ccoonnttiinnuuee;;

482
File Systems 
Chap. 19
ccaassee ’’ww’’::
iiff ((mmbbiittss&&LLFF__MMOODDEE__WW)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
mmbbiittss ||== LLFF__MMOODDEE__WW;;
ccoonnttiinnuuee;;
ccaassee ’’oo’’::
iiff ((mmbbiittss&&LLFF__MMOODDEE__OO |||| mmbbiittss&&LLFF__MMOODDEE__NN)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
mmbbiittss ||== LLFF__MMOODDEE__OO;;
bbrreeaakk;;
ccaassee ’’nn’’::
iiff ((mmbbiittss&&LLFF__MMOODDEE__OO |||| mmbbiittss&&LLFF__MMOODDEE__NN)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
mmbbiittss ||== LLFF__MMOODDEE__NN;;
bbrreeaakk;;
ddeeffaauulltt::
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
//** IIff nneeiitthheerr rreeaadd nnoorr wwrriittee ssppeecciiffiieedd,, aallllooww bbootthh **//
iiff (( ((mmbbiittss&&LLFF__MMOODDEE__RRWW)) ==== 00 )) {{
mmbbiittss ||== LLFF__MMOODDEE__RRWW;;
}} 
rreettuurrnn mmbbiittss;;
}}
Once the mode argument has been parsed, lfsopen verifies that the file is not al-
ready open, verifies that a file pseudo-device is available, and searches the file system 
directory to see if the file exists. If the file exists (and the mode allows opening an ex-
isting file), lfsopen fills in the control block of a file pseudo-device. If the file does not 
exist (and the mode allows creating a new file), lfsopen allocates an entry in the file 
system directory, and then fills in the control block of a file pseudo-device. The initial 
file position is set to zero. Control block fields lfinum and lfdnum are set to the ap-
propriate null value to indicate that neither the index block nor the data block are 
currently present. More important, field lfbyte is set to a value beyond the end of the 
data block buffer. We will see that setting lfbyte is important because the code uses the 
following invariant when accessing data:

Sec. 19.13        The Local File System Open Function (lfsopen) 
483
When lfbyte contains an address in lfdblock, the byte to which it
points contains the data that is in the file at the position given by
lfpos; when lfbyte contains an address beyond lfdblock, values in 
lfdblock cannot be used.
The general idea is that setting the current byte position beyond the end of the 
current data block causes the system to fetch another data block before performing 
transfers. That is, any attempt to read or write bytes will cause the system to read a 
new data block from disk. The details will become clear when we examine data 
transfer functions, such as lflgetc and lflputc.
19.14 Closing A File Pseudo-Device (lflclose)
When an application finishes using a file, the application calls close to terminate
use. Note that the application has been using one of the pseudo-devices to read and
write the file. Therefore, when the application calls close, the device descriptor 
corresponds to a pseudo-device. Closing the device terminates use of the file, and 
makes the pseudo-device available for other uses.
In theory, closing a pseudo-device is trivial: change the state to indicate that the 
device is no longer in use. In practice, however, caching complicates closing because
the control block may contain data that has not been written to the file. Therefore, 
function lflclose must check the dirty bits† in the control block that specify whether the 
index block or data block have been changed since they were written to disk.
If changes have occurred since the last time information was written to disk, the 
data block (and possibly the index block) should be written to disk before the control 
block is deallocated and made available for another file. Rather than write data directly, 
lflclose calls function lfflush to take care of writing the items to disk. Isolating all up-
dates to lfflush keeps the design cleaner. Once the disk has been updated, lflclose 
changes the state of the control block. File lflclose.c contains the code.
19.15 Flushing Data To Disk (lfflush)
Function lfflush operates as expected. It receives a pointer to the control block of 
the pseudo-device as an argument, and uses the pointer to examine “dirty” bits in the 
control block. If the index block has changed, lfflush uses lfibput to write a copy to 
disk; if the data block has changed, lfflush uses write to write a copy to disk. Fields lfi-
num and lfdnum contain the index block number and data block number to use. The 
code can be found in file lfflush.c.
                                †The term dirty bit refers to a Boolean (i.e., a single bit) that is set to TRUE to indicate that data has
changed.

484
File Systems 
Chap. 19
//** llffllcclloossee..cc -- llffllcclloossee..cc **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffllcclloossee
--
CClloossee aa ffiillee bbyy fflluusshhiinngg oouuttppuutt aanndd ffrreeeeiinngg ddeevviiccee eennttrryy
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll llffllcclloossee ((
ssttrruucctt ddeennttrryy **ddeevvppttrr
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
))
{{
ssttrruucctt
llffllccbbllkk **llffppttrr;;
//** PPttrr ttoo ooppeenn ffiillee ttaabbllee eennttrryy **//
//** OObbttaaiinn eexxcclluussiivvee uussee ooff tthhee ffiillee **//
llffppttrr == &&llffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
wwaaiitt((llffppttrr-->>llffmmuutteexx));;
//** IIff ffiillee iiss nnoott ooppeenn,, rreettuurrnn aann eerrrroorr **//
iiff ((llffppttrr-->>llffssttaattee !!== LLFF__UUSSEEDD)) {{
ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** WWrriittee iinnddeexx oorr ddaattaa bblloocckkss ttoo ddiisskk iiff tthheeyy hhaavvee cchhaannggeedd **//
iiff ((LLff__ddaattaa..llff__ddiirrddiirrttyy |||| llffppttrr-->>llffddbbddiirrttyy |||| llffppttrr-->>llffiibbddiirrttyy)) {{
llfffflluusshh((llffppttrr));;
}} 
//** SSeett ddeevviiccee ssttaattee ttoo FFRREEEE aanndd rreettuurrnn ttoo ccaalllleerr **//
llffppttrr-->>llffssttaattee == LLFF__FFRREEEE;;
ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;
rreettuurrnn OOKK;;
}}

Sec. 19.15        Flushing Data To Disk (lfflush) 
485
//** llfffflluusshh..cc -- llfffflluusshh **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llfffflluusshh
--
FFlluusshh ddiirreeccttoorryy,, ddaattaa bblloocckk,, aanndd iinnddeexx bblloocckk ffoorr aann ooppeenn
**
ffiillee ((aassssuummeess ffiillee mmuutteexx iiss hheelldd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
llfffflluusshh ((
ssttrruucctt llffllccbbllkk
**llffppttrr
//** PPttrr ttoo ffiillee ppsseeuuddoo ddeevviiccee
**//
))
{{
iiff ((llffppttrr-->>llffssttaattee ==== LLFF__FFRREEEE)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** WWrriittee tthhee ddiirreeccttoorryy iiff iitt hhaass cchhaannggeedd **//
iiff ((LLff__ddaattaa..llff__ddiirrddiirrttyy)) {{
wwrriittee((LLff__ddaattaa..llff__ddsskkddeevv,, ((cchhaarr **))&&LLff__ddaattaa..llff__ddiirr,,
LLFF__AARREEAA__DDIIRR));;
LLff__ddaattaa..llff__ddiirrddiirrttyy == FFAALLSSEE;;
}} 
//** WWrriittee ddaattaa bblloocckk iiff iitt hhaass cchhaannggeedd **//
iiff ((llffppttrr-->>llffddbbddiirrttyy)) {{
wwrriittee((LLff__ddaattaa..llff__ddsskkddeevv,, llffppttrr-->>llffddbblloocckk,, llffppttrr-->>llffddnnuumm));;
llffppttrr-->>llffddbbddiirrttyy == FFAALLSSEE;;
}} 
//** WWrriittee ii--bblloocckk iiff iitt hhaass cchhaannggeedd **//
iiff ((llffppttrr-->>llffiibbddiirrttyy)) {{
llffiibbppuutt((LLff__ddaattaa..llff__ddsskkddeevv,, llffppttrr-->>llffiinnuumm,, &&llffppttrr-->>llffiibblloocckk));;
llffppttrr-->>llffiibbddiirrttyy == FFAALLSSEE;;
}} 
rreettuurrnn OOKK;;
}}

486
File Systems 
Chap. 19
19.16 Bulk Transfer Functions For A File (lflwrite, lflread)
Our implementation adopts a straightforward approach to transfer operations write 
and read: each uses a loop that calls a character transfer function. For example, func-
tion lflwrite calls lflputc repeatedly. File lflwrite.c contains the code.
//** llffllwwrriittee..cc -- llffllwwrriittee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffllwwrriittee
----
WWrriittee ddaattaa ttoo aa pprreevviioouussllyy ooppeenneedd llooccaall ddiisskk ffiillee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll llffllwwrriittee ((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**bbuuffff,,
//** BBuuffffeerr hhoollddiinngg ddaattaa ttoo wwrriittee **//
iinntt3322 ccoouunntt
//** NNuummbbeerr ooff bbyytteess ttoo wwrriittee
**//
))
{{
iinntt3322
ii;;
//** NNuummbbeerr ooff bbyytteess wwrriitttteenn
**//
iiff ((ccoouunntt << 00)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** IItteerraattaattee aanndd wwrriittee oonnee bbyyttee aatt aa ttiimmee **//
ffoorr ((ii==00;; ii<<ccoouunntt;; ii++++)) {{
iiff ((llffllppuuttcc((ddeevvppttrr,, **bbuuffff++++)) ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
rreettuurrnn ccoouunntt;;
}}
Function lflread calls lflgetc repeatedly to satisfy a read request. It places each 
byte in the next location of the caller’s buffer. An interesting part of the code concerns 
how lflread handles an end-of-file condition. When it reaches the end of the file, lflgetc 
returns constant EOF. If lflread has already extracted one or more bytes of data from 
the file when it receives an EOF from lflgetc, lflread stops the loop and returns a count 
of the bytes that have been read. If no data has been found when an end-of-file is re-
ceived, lflread returns constant EOF to its caller. File lflread.c contains the code.

Sec. 19.16        Bulk Transfer Functions For A File (lflwrite, lflread) 
487
//** llffllrreeaadd..cc -- llffllrreeaadd **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffllrreeaadd
--
RReeaadd ffrroomm aa pprreevviioouussllyy ooppeenneedd llooccaall ffiillee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll llffllrreeaadd ((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**bbuuffff,,
//** BBuuffffeerr ttoo hhoolldd bbyytteess
**//
iinntt3322 ccoouunntt
//** MMaaxx bbyytteess ttoo rreeaadd
**//
))
{{
uuiinntt3322
nnuummrreeaadd;;
//** NNuummbbeerr ooff bbyytteess rreeaadd
**//
iinntt3322
nnxxttbbyyttee;;
//** CChhaarraacctteerr oorr SSYYSSEERRRR//EEOOFF
**//
iiff ((ccoouunntt << 00)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** IItteerraattee aanndd uussee llffllggeettcc ttoo rreeaadd iinnddiivvddiiuuaall bbyytteess **//
ffoorr ((nnuummrreeaadd==00 ;; nnuummrreeaadd << ccoouunntt ;; nnuummrreeaadd++++)) {{
nnxxttbbyyttee == llffllggeettcc((ddeevvppttrr));;
iiff ((nnxxttbbyyttee ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((nnxxttbbyyttee ==== EEOOFF)) {{
//** EEOOFF bbeeffoorree ffiinniisshheedd **//
iiff ((nnuummrreeaadd ==== 00)) {{
rreettuurrnn EEOOFF;;
}} eellssee {{
rreettuurrnn nnuummrreeaadd;;
}}
}} eellssee {{
**bbuuffff++++ == ((cchhaarr)) ((00xxffff && nnxxttbbyyttee));;
}}
}} 
rreettuurrnn nnuummrreeaadd;;
}}

488
File Systems 
Chap. 19
19.17 Seeking To A New Position In the File (lflseek)
A process can call seek to change the current position in a file. Our system uses 
function lflseek to implement seek, and restricts the position to a valid point in the file
(i.e., it is unlike Unix, which allows an application to seek beyond the end of the file).
Seeking to a new position consists of changing field lfpos in the file control block 
and setting field lfbyte to an address beyond lfdblock (which, according to the invariant 
above, means that the pointer cannot be used to extract data until the index block and 
data block are in place). File lflseek.c contains the code.
//** llffllsseeeekk..cc -- llffllsseeeekk **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffllsseeeekk
--
SSeeeekk ttoo aa ssppeecciiffiieedd ppoossiittiioonn iinn aa ffiillee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll llffllsseeeekk ((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
uuiinntt3322
ooffffsseett
//** BByyttee ppoossiittiioonn iinn tthhee ffiillee
**//
))
{{
ssttrruucctt
llffllccbbllkk **llffppttrr;;
//** PPttrr ttoo ooppeenn ffiillee ttaabbllee eennttrryy **//
//** IIff ffiillee iiss nnoott ooppeenn,, rreettuurrnn aann eerrrroorr **//
llffppttrr == &&llffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
wwaaiitt((llffppttrr-->>llffmmuutteexx));;
iiff ((llffppttrr-->>llffssttaattee !!== LLFF__UUSSEEDD)) {{
ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** VVeerriiffyy ooffffsseett iiss wwiitthhiinn ccuurrrreenntt ffiillee ssiizzee **//
iiff ((ooffffsseett >> llffppttrr-->>llffddiirrppttrr-->>lldd__ssiizzee)) {{
ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** RReeccoorrdd nneeww ooffffsseett aanndd iinnvvaalliiddaattee bbyyttee ppooiinntteerr ((ii..ee..,, ffoorrccee
**//
//**
tthhee iinnddeexx aanndd ddaattaa bblloocckkss ttoo bbee rreeppllaacceedd iiff aa ssuucccceessssiivvee
**//
//**
ccaallll iiss mmaaddee ttoo rreeaadd oorr wwrriittee))
**//

Sec. 19.17        Seeking To A New Position In the File (lflseek) 
489
llffppttrr-->>llffppooss == ooffffsseett;;
llffppttrr-->>llffbbyyttee == &&llffppttrr-->>llffddbblloocckk[[LLFF__BBLLKKSSIIZZ]];;
ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;
rreettuurrnn OOKK;;
}}
19.18 Extracting One Byte From A File (lflgetc)
Once a file has been opened and both the correct index block and data block have 
been loaded into memory, extracting a byte from the file is trivial: it consists of treating 
lfbyte as a pointer to the byte, extracting the byte, and advancing the buffer pointer to 
the next byte. Function lflgetc, which performs the operation, can be found in file 
lflgetc.c.
//** llffllggeettcc..cc -- llffggeettcc **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffllggeettcc
--
RReeaadd tthhee nneexxtt bbyyttee ffrroomm aann ooppeenn llooccaall ffiillee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll llffllggeettcc ((
ssttrruucctt ddeennttrryy **ddeevvppttrr
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
))
{{
ssttrruucctt
llffllccbbllkk **llffppttrr;;
//** PPttrr ttoo ooppeenn ffiillee ttaabbllee eennttrryy **//
ssttrruucctt
llddeennttrryy **llddppttrr;;
//** PPttrr ttoo ffiillee’’ss eennttrryy iinn tthhee
**//
//**
iinn--mmeemmoorryy ddiirreeccttoorryy
**//
iinntt3322
oonneebbyyttee;;
//** NNeexxtt ddaattaa bbyyttee iinn tthhee ffiillee
**//
//** OObbttaaiinn eexxcclluussiivvee uussee ooff tthhee ffiillee **//
llffppttrr == &&llffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
wwaaiitt((llffppttrr-->>llffmmuutteexx));;
//** IIff ffiillee iiss nnoott ooppeenn,, rreettuurrnn aann eerrrroorr **//
iiff ((llffppttrr-->>llffssttaattee !!== LLFF__UUSSEEDD)) {{
ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}}

490
File Systems 
Chap. 19
//** RReettuurrnn EEOOFF ffoorr aannyy aatttteemmpptt ttoo rreeaadd bbeeyyoonndd tthhee eenndd--ooff--ffiillee **//
llddppttrr == llffppttrr-->>llffddiirrppttrr;;
iiff ((llffppttrr-->>llffppooss >>== llddppttrr-->>lldd__ssiizzee)) {{
ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;
rreettuurrnn EEOOFF;;
}} 
//** IIff bbyyttee ppooiinntteerr iiss bbeeyyoonndd tthhee ccuurrrreenntt ddaattaa bblloocckk,, sseett uupp
**//
//**
aa nneeww ddaattaa bblloocckk
**//
iiff ((llffppttrr-->>llffbbyyttee >>== &&llffppttrr-->>llffddbblloocckk[[LLFF__BBLLKKSSIIZZ]])) {{
llffsseettuupp((llffppttrr));;
}} 
//** EExxttrraacctt tthhee nneexxtt bbyyttee ffrroomm bblloocckk,, uuppddaattee ffiillee ppoossiittiioonn,, aanndd
**//
//**
rreettuurrnn tthhee bbyyttee ttoo tthhee ccaalllleerr
**//
oonneebbyyttee == 00xxffff && **llffppttrr-->>llffbbyyttee++++;;
llffppttrr-->>llffppooss++++;;
ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;
rreettuurrnn oonneebbyyttee;;
}}
If the specified file is not open, lflgetc returns SYSERR. If the current file position 
exceeds the file size, lflgetc returns EOF. In other cases, lflgetc checks pointer lfbyte to
see whether it currently points outside of the data block in lfdblock. If so, lflgetc calls 
lfsetup to read the correct index block and data block into memory.
Once the data block is in memory, lflgetc can extract a byte. To do so, it derefer-
ences lfbyte to obtain a byte and places the byte in variable onebyte. It increments both
the byte pointer and the file position before returning the byte to the caller.
19.19 Changing One Byte In A File (lflputc)
Function lflputc handles the task of storing a byte into a file at the current position.
As with lflgetc, the code that performs the transfer is trivial and only occupies a few
lines. Pointer lfbyte gives a location in lfdblock at which the byte should be stored; the
code uses the pointer, stores the specified byte, increments the pointer, and sets lfdbdirty 
to indicate that the data block has been changed. Note that lflputc merely accumulates 
characters in a buffer in memory; it does not write the buffer to disk each time a change 
occurs. The buffer will only be copied to disk when the current position moves to 
another disk block.

Sec. 19.19        Changing One Byte In A File (lflputc) 
491
//** llffllppuuttcc..cc -- llffppuuttcc **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffllppuuttcc
--
WWrriittee aa ssiinnggllee bbyyttee ttoo aann ooppeenn llooccaall ffiillee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll llffllppuuttcc ((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
cchh
//** CChhaarraacctteerr ((bbyyttee)) ttoo wwrriittee
**//
))
{{
ssttrruucctt
llffllccbbllkk **llffppttrr;;
//** PPttrr ttoo ooppeenn ffiillee ttaabbllee eennttrryy **//
ssttrruucctt
llddeennttrryy **llddppttrr;;
//** PPttrr ttoo ffiillee’’ss eennttrryy iinn tthhee
**//
//**
iinn--mmeemmoorryy ddiirreeccttoorryy
**//
//** OObbttaaiinn eexxcclluussiivvee uussee ooff tthhee ffiillee **//
llffppttrr == &&llffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
wwaaiitt((llffppttrr-->>llffmmuutteexx));;
//** IIff ffiillee iiss nnoott ooppeenn,, rreettuurrnn aann eerrrroorr **//
iiff ((llffppttrr-->>llffssttaattee !!== LLFF__UUSSEEDD)) {{
ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** RReettuurrnn SSYYSSEERRRR ffoorr aann aatttteemmpptt ttoo sskkiipp bbyytteess bbeeyyoonndd tthhee bbyyttee
**//
//**
tthhaatt iiss ccuurrrreennttllyy tthhee eenndd ooff tthhee ffiillee
**//
llddppttrr == llffppttrr-->>llffddiirrppttrr;;
iiff ((llffppttrr-->>llffppooss >> llddppttrr-->>lldd__ssiizzee)) {{
ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** IIff ppooiinntteerr iiss oouuttssiiddee ccuurrrreenntt bblloocckk,, sseett uupp nneeww bblloocckk **//
iiff ((llffppttrr-->>llffbbyyttee >>== &&llffppttrr-->>llffddbblloocckk[[LLFF__BBLLKKSSIIZZ]])) {{
//** SSeett uupp bblloocckk ffoorr ccuurrrreenntt ffiillee ppoossiittiioonn **//
llffsseettuupp((llffppttrr));;
}}

492
File Systems 
Chap. 19
//** IIff aappppeennddiinngg aa bbyyttee ttoo tthhee ffiillee,, iinnccrreemmeenntt tthhee ffiillee ssiizzee..
**//
//**
NNoottee:: ccoommppaarriissoonn mmiigghhtt bbee eeqquuaall,, bbuutt sshhoouulldd nnoott bbee ggrreeaatteerr..**//
iiff ((llffppttrr-->>llffppooss >>== llddppttrr-->>lldd__ssiizzee)) {{
llddppttrr-->>lldd__ssiizzee++++;;
LLff__ddaattaa..llff__ddiirrddiirrttyy == TTRRUUEE;;
}} 
//** PPllaaccee bbyyttee iinn bbuuffffeerr aanndd mmaarrkk bbuuffffeerr ""ddiirrttyy"" **//
**llffppttrr-->>llffbbyyttee++++ == cchh;;
llffppttrr-->>llffppooss++++;;
llffppttrr-->>llffddbbddiirrttyy == TTRRUUEE;;
ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;
rreettuurrnn OOKK;;
}}
Like lflgetc, lflputc examines lfbyte on each call. If lfbyte lies outside of data 
block lfdblock, lflputc calls lfsetup to move to the next block. However, a subtle differ-
ence exists in the way lflputc and lflgetc treat an invalid file position.  Lflgetc always 
returns EOF if the file position exceeds the last byte of the file. Lflputc returns 
SYSERR when the file position is more than one byte beyond the end of the file, but if 
the position is exactly one byte beyond the end, it allows the operation to proceed. That 
is, it allows a file to be extended. When a file is extended, the file size, found in the 
directory entry for the file, must be incremented. File lflputc.c contains the code.
19.20 Loading An Index Block And A Data Block (lfsetup)
Once a file position has been assigned to field lfpos, function lfsetup handles the 
details of positioning the in-memory data structures at the specified position. That is, 
lfsetup identifies the index block for the position, loads a copy of the index block into 
memory, identifies the data block that contains the position, and loads a copy of the 
data block into memory. Lfsetup begins by obtaining pointers to data structures.
A key idea is that lfsetup handles the case where an existing data block is dirty. 
To do so, before it reads new items from disk, lfsetup checks the control block. If the 
existing index or data blocks have changed, lfsetup calls lfflush to write them to disk.
The first step in loading data for the current file position consists of finding the in-
dex block that covers the specified file position. To do so, lfsetup starts with an index
block that precedes the current position, and moves along the linked list of index blocks
to find the needed block. There are two cases for an initial block: no index block has
been loaded or an index block is currently in memory.

Sec. 19.20        Loading An Index Block And A Data Block (lfsetup) 
493
If no index block has been loaded (i.e., the file was just opened), lfsetup obtains 
one. For a new file, lfsetup must allocate an initial index block from the free list; for an 
existing file, it loads the first index block for the file. In either case, the initial condi-
tion will be that the index block either corresponds to the file position or covers an ear-
lier position in the file.
If an index block has already been loaded, there are two possibilities. If the index 
block covers an earlier part of the file, no further action is needed. If the index block 
corresponds to a portion of the file that lies after the current file position (e.g., a process 
has issued a seek to an earlier position), lfsetup must find an initial block that covers an 
earlier part of the file. To handle the case, lfsetup replaces the index block with the ini-
tial index block for the file.
Once it has loaded an index block that covers an earlier part of the file, lfsetup 
enters a loop that moves along the linked list of index blocks until it reaches the index 
block that covers the current file position. At each iteration, lfsetup uses field ib_next 
to find the number of the next index block on the list, and then calls lfibget to read the 
index block into memory.
Once the correct index block has been loaded, lfsetup must determine the data
block to load. To do so, it uses the file position to compute an index (from 0 through
15) for the data block array. Because each index block covers exactly 8K bytes (i.e., 213 
bytes) of data and each slot in the array corresponds to a block of 512 bytes (29), binary 
arithmetic can be used. Lfsetup computes the logical and of the LF_IMASK (the low-
order 13 bits), and then shifts the result right 9 bits.
Lfsetup uses the result of the above computation as an index into array ib_dba to
obtain the ID of a data block. There are two cases that require lfsetup to load a new
data block. In the first case, the pointer in the array is null, which means lflputc is
about to write a new byte on the end of the file and no data block has been assigned for 
the position.  Lfsetup calls lfdballoc to allocate a new data block from the free list, and 
records the ID in the entry of array ib_dba. In the second case, the entry in array 
ib_dba specifies a data block other than the data block currently loaded. Lfsetup calls 
read to fetch the correct data block from disk.
As the final step before returning, lfsetup uses the file position to compute a posi-
tion within the data block, and assigns the address to field lfbyte. The careful arrange-
ment of making the data block size a power of two means that the indices from 0
through 511 can be computed by selecting the low-order 9 bits of the file position. The 
code uses a logical and with mask LF_DMASK. File lfsetup.c contains the code.

494
File Systems 
Chap. 19
//** llffsseettuupp..cc -- llffsseettuupp **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffsseettuupp
--
SSeett aa ffiillee’’ss iinnddeexx bblloocckk aanndd ddaattaa bblloocckk ffoorr tthhee ccuurrrreenntt
**
ffiillee ppoossiittiioonn ((aassssuummeess ffiillee mmuutteexx hheelldd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
llffsseettuupp ((
ssttrruucctt llffllccbbllkk
**llffppttrr
//** PPooiinntteerr ttoo ssllaavvee ffiillee ddeevviiccee **//
))
{{
ddbbiidd3322
ddnnuumm;;
//** DDaattaa bblloocckk ttoo ffeettcchh
**//
iibbiidd3322
iibbnnuumm;;
//** II--bblloocckk nnuummbbeerr dduurriinngg sseeaarrcchh **//
ssttrruucctt
llddeennttrryy **llddppttrr;;
//** PPttrr ttoo ffiillee eennttrryy iinn ddiirr..
**//
ssttrruucctt
llffiibbllkk
**iibbppttrr;;
//** PPttrr ttoo iinn--mmeemmoorryy iinnddeexx bblloocckk **//
uuiinntt3322
nneewwooffffsseett;;
//** CCoommppuutteedd ddaattaa ooffffsseett ffoorr
**//
//**
nneexxtt iinnddeexx bblloocckk
**//
iinntt3322
ddiinnddeexx;;
//** IInnddeexx iinnttoo aarrrraayy iinn aann iinnddeexx **//
//**
bblloocckk
**//
//** OObbttaaiinn eexxcclluussiivvee aacccceessss ttoo tthhee ddiirreeccttoorryy **//
wwaaiitt((LLff__ddaattaa..llff__mmuutteexx));;
//** GGeett ppooiinntteerrss ttoo iinn--mmeemmoorryy ddiirreeccttoorryy,, ffiillee’’ss eennttrryy iinn tthhee
**//
//**
ddiirreeccttoorryy,, aanndd tthhee iinn--mmeemmoorryy iinnddeexx bblloocckk
**//
llddppttrr == llffppttrr-->>llffddiirrppttrr;;
iibbppttrr == &&llffppttrr-->>llffiibblloocckk;;
//** IIff eexxiissttiinngg iinnddeexx bblloocckk oorr ddaattaa bblloocckk cchhaannggeedd,, wwrriittee ttoo ddiisskk **//
iiff ((llffppttrr-->>llffiibbddiirrttyy |||| llffppttrr-->>llffddbbddiirrttyy)) {{
llfffflluusshh((llffppttrr));;
}} 
iibbnnuumm == llffppttrr-->>llffiinnuumm;;
//** GGeett IIDD ooff ccuurrrr.. iinnddeexx bblloocckk
**//
//** IIff tthheerree iiss nnoo iinnddeexx bblloocckk iinn mmeemmoorryy ((ee..gg..,, bbeeccaauussee tthhee ffiillee **//
//**
wwaass jjuusstt ooppeenneedd)),, eeiitthheerr llooaadd tthhee ffiirrsstt iinnddeexx bblloocckk ooff
**//
//**
tthhee ffiillee oorr aallllooccaattee aa nneeww ffiirrsstt iinnddeexx bblloocckk
**//
iiff ((iibbnnuumm ==== LLFF__IINNUULLLL)) {{

Sec. 19.20        Loading An Index Block And A Data Block (lfsetup) 
495
//** CChheecckk ddiirreeccttoorryy eennttrryy ttoo sseeee iiff iinnddeexx bblloocckk eexxiissttss
**//
iibbnnuumm == llddppttrr-->>lldd__iilliisstt;;
iiff ((iibbnnuumm ==== LLFF__IINNUULLLL)) {{ //** EEmmppttyy ffiillee -- ggeett nneeww ii--bblloocckk**//
iibbnnuumm == llffiibbaalllloocc(());;
llffiibbcclleeaarr((iibbppttrr,, 00));;
llddppttrr-->>lldd__iilliisstt == iibbnnuumm;;
llffppttrr-->>llffiibbddiirrttyy == TTRRUUEE;;
}} eellssee {{
//** NNoonneemmppttyy -- rreeaadd ffiirrsstt ii--bblloocckk**//
llffiibbggeett((LLff__ddaattaa..llff__ddsskkddeevv,, iibbnnuumm,, iibbppttrr));;
}} 
llffppttrr-->>llffiinnuumm == iibbnnuumm;;
//** OOtthheerrwwiissee,, iiff ccuurrrreenntt ffiillee ppoossiittiioonn hhaass bbeeeenn mmoovveedd ttoo aann
**//
//**
ooffffsseett bbeeffoorree tthhee ccuurrrreenntt iinnddeexx bblloocckk,, ssttaarrtt aatt tthhee
**//
//**
bbeeggiinnnniinngg ooff tthhee iinnddeexx lliisstt ffoorr tthhee ffiillee
**//
}} eellssee iiff ((llffppttrr-->>llffppooss << iibbppttrr-->>iibb__ooffffsseett)) {{
//** LLooaadd iinniittiiaall iinnddeexx bblloocckk ffoorr tthhee ffiillee ((wwee kknnooww tthhaatt
**//
//**
aatt lleeaasstt oonnee iinnddeexx bblloocckk eexxiissttss))
**//
iibbnnuumm == llddppttrr-->>lldd__iilliisstt;;
llffiibbggeett((LLff__ddaattaa..llff__ddsskkddeevv,, iibbnnuumm,, iibbppttrr));;
llffppttrr-->>llffiinnuumm == iibbnnuumm;;
}} 
//** AAtt tthhiiss ppooiinntt,, aann iinnddeexx bblloocckk iiss iinn mmeemmoorryy,, bbuutt mmaayy ccoovveerr
**//
//**
aann ooffffsseett lleessss tthhaann tthhee ccuurrrreenntt ffiillee ppoossiittiioonn..
LLoooopp uunnttiill
**//
//**
tthhee iinnddeexx bblloocckk ccoovveerrss tthhee ccuurrrreenntt ffiillee ppoossiittiioonn..
**//
wwhhiillee ((((llffppttrr-->>llffppooss && ~~LLFF__IIMMAASSKK)) >> iibbppttrr-->>iibb__ooffffsseett )) {{
iibbnnuumm == iibbppttrr-->>iibb__nneexxtt;;
iiff ((iibbnnuumm ==== LLFF__IINNUULLLL)) {{
//** AAllllooccaattee nneeww iinnddeexx bblloocckk ttoo eexxtteenndd ffiillee **//
iibbnnuumm == llffiibbaalllloocc(());;
iibbppttrr-->>iibb__nneexxtt == iibbnnuumm;;
llffiibbppuutt((LLff__ddaattaa..llff__ddsskkddeevv,, llffppttrr-->>llffiinnuumm,, iibbppttrr));;
llffppttrr-->>llffiinnuumm == iibbnnuumm;;
nneewwooffffsseett == iibbppttrr-->>iibb__ooffffsseett ++ LLFF__IIDDAATTAA;;
llffiibbcclleeaarr((iibbppttrr,, nneewwooffffsseett));;
llffppttrr-->>llffiibbddiirrttyy == TTRRUUEE;;
}} eellssee {{
llffiibbggeett((LLff__ddaattaa..llff__ddsskkddeevv,, iibbnnuumm,, iibbppttrr));;
llffppttrr-->>llffiinnuumm == iibbnnuumm;;

496
File Systems 
Chap. 19
}} 
llffppttrr-->>llffddnnuumm == LLFF__DDNNUULLLL;; //** IInnvvaalliiddaattee oolldd ddaattaa bblloocckk **//
}} 
//** AAtt tthhiiss ppooiinntt,, tthhee iinnddeexx bblloocckk iinn llffiibblloocckk ccoovveerrss tthhee
**//
//**
ccuurrrreenntt ffiillee ppoossiittiioonn ((ii..ee..,, ppoossiittiioonn llffppttrr-->>llffppooss))..
TThhee
**//
//**
nneexxtt sstteepp ccoonnssiissttss ooff llooaaddiinngg tthhee ccoorrrreecctt ddaattaa bblloocckk..
**//
ddiinnddeexx == ((llffppttrr-->>llffppooss && LLFF__IIMMAASSKK)) >>>> 99;;
//** IIff ddaattaa bblloocckk iinnddeexx ddooeess nnoott mmaattcchh ccuurrrreenntt ddaattaa bblloocckk,, rreeaadd
**//
//**
tthhee ccoorrrreecctt ddaattaa bblloocckk ffrroomm ddiisskk
**//
ddnnuumm == llffppttrr-->>llffiibblloocckk..iibb__ddbbaa[[ddiinnddeexx]];;
iiff ((ddnnuumm ==== LLFF__DDNNUULLLL)) {{
//** AAllllooccaattee nneeww ddaattaa bblloocckk **//
ddnnuumm == llffddbbaalllloocc((((ssttrruucctt llffddbbffrreeee **))&&llffppttrr-->>llffddbblloocckk));;
llffppttrr-->>llffiibblloocckk..iibb__ddbbaa[[ddiinnddeexx]] == ddnnuumm;;
llffppttrr-->>llffiibbddiirrttyy == TTRRUUEE;;
}} eellssee iiff (( ddnnuumm !!== llffppttrr-->>llffddnnuumm)) {{
rreeaadd((LLff__ddaattaa..llff__ddsskkddeevv,, ((cchhaarr **))llffppttrr-->>llffddbblloocckk,, ddnnuumm));;
llffppttrr-->>llffddbbddiirrttyy == FFAALLSSEE;;
}} 
llffppttrr-->>llffddnnuumm == ddnnuumm;;
//** UUssee ccuurrrreenntt ffiillee ooffffsseett ttoo sseett tthhee ppooiinntteerr ttoo tthhee nneexxtt bbyyttee
**//
//**
wwiitthhiinn tthhee ddaattaa bblloocckk
**//
llffppttrr-->>llffbbyyttee == &&llffppttrr-->>llffddbblloocckk[[llffppttrr-->>llffppooss && LLFF__DDMMAASSKK]];;
ssiiggnnaall((LLff__ddaattaa..llff__mmuutteexx));;
rreettuurrnn OOKK;;
}}
19.21 Master File System Device Initialization (lfsinit)
Initialization for the master file system device is straightforward. Function lfsinit 
performs the task, which consists of recording the ID of the disk device, creating a 
semaphore that provides mutual exclusion to the directory, clearing the in-memory 
directory (merely to help with debugging), and setting a Boolean to indicate that the 
directory has not been read into memory. Data for the master file system device is kept 
in the global structure Lf_data. File lfsinit.c contains the code.

Sec. 19.21        Master File System Device Initialization (lfsinit) 
497
//** llffssiinniitt..cc -- llffssiinniitt **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt
llffddaattaa
LLff__ddaattaa;;
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffssiinniitt
--
IInniittiiaalliizzee tthhee llooccaall ffiillee ssyysstteemm mmaasstteerr ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll llffssiinniitt ((
ssttrruucctt ddeennttrryy **ddeevvppttrr
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
))
{{
//** AAssssiiggnn IIDD ooff ddiisskk ddeevviiccee tthhaatt wwiillll bbee uusseedd **//
LLff__ddaattaa..llff__ddsskkddeevv == LLFF__DDIISSKK__DDEEVV;;
//** CCrreeaattee aa mmuuttuuaall eexxcclluussiioonn sseemmaapphhoorree **//
LLff__ddaattaa..llff__mmuutteexx == sseemmccrreeaattee((11));;
//** ZZeerroo ddiirreeccttoorryy aarreeaa ((ffoorr ddeebbuuggggiinngg)) **//
mmeemmsseett((((cchhaarr **))&&LLff__ddaattaa..llff__ddiirr,, NNUULLLLCCHH,, ssiizzeeooff((ssttrruucctt llffddiirr))));;
//** IInniittiiaalliizzee ddiirreeccttoorryy ttoo ""nnoott pprreesseenntt"" iinn mmeemmoorryy **//
LLff__ddaattaa..llff__ddiirrpprreesseenntt == LLff__ddaattaa..llff__ddiirrddiirrttyy == FFAALLSSEE;;
rreettuurrnn OOKK;;
}}
19.22 Pseudo-Device Initialization (lflinit)
When it opens a file, lfsopen initializes many of the entries in the control block for 
the file pseudo-device. However, some initialization is performed at system startup. To 
indicate that the device is not in use, the state is assigned LF_FREE. A mutual exclu-
sion semaphore is created to guarantee that at most one operation will be in progress on 
the file at a given time. Most other fields in the control block are initialized to zero 
(they will not be used until a file is opened, but initializing to zero can make debugging 
easier). File lflinit.c contains the code.

498
File Systems 
Chap. 19
//** llfflliinniitt..cc -- llfflliinniitt **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt
llffllccbbllkk llffllttaabb[[NNllffll]];;
//** PPsseeuuddoo--ddeevviiccee ccoonnttrrooll bblloocckkss **//
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llfflliinniitt
--
IInniittiiaalliizzee ccoonnttrrooll bblloocckkss ffoorr llooccaall ffiillee ppsseeuuddoo--ddeevviicceess
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll llfflliinniitt ((
ssttrruucctt ddeennttrryy **ddeevvppttrr
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
))
{{
ssttrruucctt
llffllccbbllkk **llffppttrr;;
//** PPttrr.. ttoo ccoonnttrrooll bblloocckk eennttrryy
**//
iinntt3322
ii;;
//** WWaallkkss tthhrroouugghh nnaammee aarrrraayy
**//
llffppttrr == &&llffllttaabb[[ ddeevvppttrr-->>ddvvmmiinnoorr ]];;
//** IInniittiiaalliizzee ccoonnttrrooll bblloocckk eennttrryy **//
llffppttrr-->>llffssttaattee == LLFF__FFRREEEE;;
//** DDeevviiccee iiss ccuurrrreennttllyy uunnuusseedd
**//
llffppttrr-->>llffddeevv == ddeevvppttrr-->>ddvvnnuumm;;
//** SSeett ddeevviiccee IIDD
**//
llffppttrr-->>llffmmuutteexx == sseemmccrreeaattee((11));;
//** CCrreeaattee tthhee mmuutteexx sseemmaapphhoorree
**//
//** IInniittiiaalliizzee tthhee ddiirreeccttoorryy aanndd ffiillee ppoossiittiioonn **//
llffppttrr-->>llffddiirrppttrr == ((ssttrruucctt
llddeennttrryy **)) NNUULLLL;;
llffppttrr-->>llffppooss == 00;;
ffoorr ((ii==00;; ii<<LLFF__NNAAMMEE__LLEENN;; ii++++)) {{
llffppttrr-->>llffnnaammee[[ii]] == NNUULLLLCCHH;;
}} 
//** ZZeerroo tthhee iinn--mmeemmoorryy iinnddeexx bblloocckk aanndd ddaattaa bblloocckk **//
llffppttrr-->>llffiinnuumm == LLFF__IINNUULLLL;;
mmeemmsseett((((cchhaarr **)) &&llffppttrr-->>llffiibblloocckk,, NNUULLLLCCHH,, ssiizzeeooff((ssttrruucctt llffiibbllkk))));;
llffppttrr-->>llffddnnuumm == 00;;
mmeemmsseett((((cchhaarr **)) &&llffppttrr-->>llffddbblloocckk,, NNUULLLLCCHH,, LLFF__BBLLKKSSIIZZ));;
//** SSttaarrtt wwiitthh tthhee bbyyttee bbeeyyoonndd tthhee ccuurrrreenntt ddaattaa bblloocckk **//
llffppttrr-->>llffbbyyttee == &&llffppttrr-->>llffddbblloocckk[[LLFF__BBLLKKSSIIZZ]];;
llffppttrr-->>llffiibbddiirrttyy == llffppttrr-->>llffddbbddiirrttyy == FFAALLSSEE;;
rreettuurrnn OOKK;;
}}

Sec. 19.22        Pseudo-Device Initialization (lflinit) 
499
19.23 File Truncation (lftruncate)
We will use file truncation as a way to show how file data structures are deallocat-
ed. To truncate a file to zero length, each of the index blocks for the file must be
placed on the free list of index blocks. Before an index block can be released, however, 
each of the data blocks to which the index block points must be placed on the free list 
of data blocks. Function lftruncate performs file truncation; file lftruncate.c contains 
the code.
//** llffttrruunnccaattee..cc -- llffttrruunnccaattee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffttrruunnccaattee
--
TTrruunnccaattee aa ffiillee bbyy ffrreeeeiinngg iittss iinnddeexx aanndd ddaattaa bblloocckkss
**
((aassssuummeess ddiirreeccttoorryy mmuutteexx hheelldd))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
llffttrruunnccaattee ((
ssttrruucctt llffllccbbllkk **llffppttrr
//** PPttrr ttoo ffiillee’’ss ccnnttll bbllkk eennttrryy **//
))
{{
ssttrruucctt
llddeennttrryy **llddppttrr;;
//** PPooiinntteerr ttoo ffiillee’’ss ddiirr.. eennttrryy **//
ssttrruucctt
llffiibbllkk
iibblloocckk;;
//** BBuuffffeerr ffoorr oonnee iinnddeexx bblloocckk
**//
iibbiidd3322
iiffrreeee;;
//** SSttaarrtt ooff iinnddeexx bbllkk ffrreeee lliisstt **//
iibbiidd3322
ffiirrssttiibb;;
//** FFiirrsstt iinnddeexx bbllkk ooff tthhee ffiillee
**//
iibbiidd3322
nneexxttiibb;;
//** WWaallkkss ddoowwnn lliisstt ooff tthhee
**//
//**
ffiillee’’ss iinnddeexx bblloocckkss
**//
ddbbiidd3322
nneexxttddbb;;
//** NNeexxtt ddaattaa bblloocckk ttoo ffrreeee
**//
iinntt3322
ii;;
//** MMoovveess tthhrroouugghh ddaattaa bblloocckkss iinn **//
//**
aa ggiivveenn iinnddeexx bblloocckk
**//
llddppttrr == llffppttrr-->>llffddiirrppttrr;;
//** GGeett ppooiinntteerr ttoo ddiirr.. eennttrryy
**//
iiff ((llddppttrr-->>lldd__ssiizzee ==== 00)) {{
//** FFiillee iiss aallrreeaaddyy eemmppttyy **//
rreettuurrnn OOKK;;
}} 
//** CClleeaann uupp tthhee ooppeenn llooccaall ffiillee ffiirrsstt **//
iiff (( ((llffppttrr-->>llffiibbddiirrttyy)) |||| ((llffppttrr-->>llffddbbddiirrttyy)) )) {{
llfffflluusshh((llffppttrr));;
}} 
llffppttrr-->>llffppooss == 00;;
llffppttrr-->>llffiinnuumm == LLFF__IINNUULLLL;;

500
File Systems 
Chap. 19
llffppttrr-->>llffddnnuumm == LLFF__DDNNUULLLL;;
llffppttrr-->>llffbbyyttee == &&llffppttrr-->>llffddbblloocckk[[LLFF__BBLLKKSSIIZZ]];;
//** OObbttaaiinn IIDD ooff ffiirrsstt iinnddeexx bblloocckk oonn ffrreeee lliisstt **//
iiffrreeee == LLff__ddaattaa..llff__ddiirr..llffdd__iiffrreeee;;
//** RReeccoorrdd ffiillee’’ss ffiirrsstt ii--bblloocckk aanndd cclleeaarr ddiirreeccttoorryy eennttrryy **//
ffiirrssttiibb == llddppttrr-->>lldd__iilliisstt;;
llddppttrr-->>lldd__iilliisstt == LLFF__IINNUULLLL;;
llddppttrr-->>lldd__ssiizzee == 00;;
LLff__ddaattaa..llff__ddiirrddiirrttyy == TTRRUUEE;;
//** WWaallkk aalloonngg iinnddeexx bblloocckk lliisstt,, ddiissppoossiinngg ooff eeaacchh ddaattaa bblloocckk
**//
//**
aanndd cclleeaarriinngg tthhee ccoorrrreessppoonnddiinngg ppooiinntteerr..
AA nnoottee oonn lloooopp
**//
//**
tteerrmmiinnaattiioonn:: llaasstt ppooiinntteerr iiss sseett ttoo iiffrreeee bbeellooww..
**//
ffoorr ((nneexxttiibb==ffiirrssttiibb;; nneexxttiibb!!==iiffrreeee;; nneexxttiibb==iibblloocckk..iibb__nneexxtt)) {{
//** OObbttaaiinn aa ccooppyy ooff ccuurrrreenntt iinnddeexx bblloocckk ffrroomm ddiisskk
**//
llffiibbggeett((LLff__ddaattaa..llff__ddsskkddeevv,, nneexxttiibb,, &&iibblloocckk));;
//** FFrreeee eeaacchh ddaattaa bblloocckk iinn tthhee iinnddeexx bblloocckk
**//
ffoorr ((ii==00;; ii<<LLFF__IIBBLLEENN;; ii++++)) {{
//** FFoorr eeaacchh dd--bblloocckk
**//
//** FFrreeee tthhee ddaattaa bblloocckk **//
nneexxttddbb == iibblloocckk..iibb__ddbbaa[[ii]];;
iiff ((nneexxttddbb !!== LLFF__DDNNUULLLL)) {{
llffddbbffrreeee((LLff__ddaattaa..llff__ddsskkddeevv,, nneexxttddbb));;
}} 
//** CClleeaarr eennttrryy iinn ii--bblloocckk ffoorr tthhiiss dd--bblloocckk
**//
iibblloocckk..iibb__ddbbaa[[ii]] == LLFF__DDNNUULLLL;;
}} 
//** CClleeaarr ooffffsseett ((jjuusstt ttoo mmaakkee ddeebbuuggggiinngg eeaassiieerr))
**//
iibblloocckk..iibb__ooffffsseett == 00;;
//** FFoorr tthhee llaasstt iinnddeexx bblloocckk oonn tthhee lliisstt,, mmaakkee iitt ppooiinntt
**//

Sec. 19.23        File Truncation (lftruncate) 
501
//**
ttoo tthhee ccuurrrreenntt ffrreeee lliisstt
**//
iiff ((iibblloocckk..iibb__nneexxtt ==== LLFF__IINNUULLLL)) {{
iibblloocckk..iibb__nneexxtt == iiffrreeee;;
}} 
//** WWrriittee cclleeaarreedd ii--bblloocckk bbaacckk ttoo ddiisskk **//
llffiibbppuutt((LLff__ddaattaa..llff__ddsskkddeevv,, nneexxttiibb,, &&iibblloocckk));;
}} 
//** LLaasstt iinnddeexx bblloocckk oonn tthhee ffiillee lliisstt nnooww ppooiinnttss ttoo ffiirrsstt nnooddee
**//
//**
oonn tthhee ccuurrrreenntt ffrreeee lliisstt..
OOnnccee wwee mmaakkee tthhee ffrreeee lliisstt
**//
//**
ppooiinntt ttoo tthhee ffiirrsstt iinnddeexx bblloocckk oonn tthhee ffiillee lliisstt,, tthhee
**//
//**
eennttiirree sseett ooff iinnddeexx bblloocckkss wwiillll bbee oonn tthhee ffrreeee lliisstt
**//
LLff__ddaattaa..llff__ddiirr..llffdd__iiffrreeee == ffiirrssttiibb;;
//** IInnddiiccaattee tthhaatt ddiirreeccttoorryy hhaass cchhaannggeedd aanndd rreettuurrnn **//
LLff__ddaattaa..llff__ddiirrddiirrttyy == TTRRUUEE;;
rreettuurrnn OOKK;;
}}
The approach used is straightforward: if the file already has length zero, return to
the caller. Otherwise, walk along the file’s index block list. Read each index block
into memory, and call lfdbfree to free each data block to which the index block points.
Once the final index block has been reached, add all the index blocks for the file to
the free list. To do so, observe that all index blocks for the file are already linked.
Thus, only two pointer changes are needed. First, change the next pointer in the final
index block of the file to point to the current free list. Second, change the free list to
point to the first index block of the file.
19.24 Initial File System Creation (lfscreate)
A final initialization function will complete details of the file system. Function 
lfscreate creates an initial, empty file system on a disk. That is, it forms a free list of 
index blocks, a free list of data blocks, and a directory that contains no files. File
lfscreate.c contains the code.

502
File Systems 
Chap. 19
//** llffssccrreeaattee..cc -- llffssccrreeaattee **//
##iinncclluuddee <<xxiinnuu..hh>>
##iinncclluuddee <<rraammddiisskk..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** llffssccrreeaattee
--
CCrreeaattee aann iinniittiiaallllyy--eemmppttyy ffiillee ssyysstteemm oonn aa ddiisskk
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
llffssccrreeaattee ((
ddiidd3322
ddiisskk,,
//** IIDD ooff aann ooppeenn ddiisskk ddeevviiccee
**//
iibbiidd3322
llffiibbllkkss,,
//** NNuumm.. ooff iinnddeexx bblloocckkss oonn ddiisskk **//
uuiinntt3322
ddssiizz
//** TToottaall ssiizzee ooff ddiisskk iinn bbyytteess
**//
))
{{
uuiinntt3322
sseeccttoorrss;;
//** NNuummbbeerr ooff sseeccttoorrss ttoo uussee
**//
uuiinntt3322
iibbsseeccttoorrss;;
//** NNuummbbeerr ooff sseeccttoorrss ooff ii--bblloocckkss**//
uuiinntt3322
iibbppeerrsseeccttoorr;;
//** NNuummbbeerr ooff ii--bblloocckkss ppeerr sseeccttoorr**//
ssttrruucctt
llffddiirr
ddiirr;;
//** BBuuffffeerr ttoo hhoolldd tthhee ddiirreeccttoorryy **//
uuiinntt3322
ddbbllkkss;;
//** TToottaall ffrreeee ddaattaa bblloocckkss
**//
ssttrruucctt
llffiibbllkk
iibblloocckk;;
//** SSppaaccee ffoorr oonnee ii--bblloocckk
**//
ssttrruucctt
llffddbbffrreeee ddbblloocckk;;
//** DDaattaa bblloocckk oonn tthhee ffrreeee lliisstt
**//
ddbbiidd3322
ddbbiinnddeexx;;
//** IInnddeexx ffoorr ddaattaa bblloocckkss
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee ffrroomm ffuunncc ccaallll
**//
iinntt3322
ii;;
//** LLoooopp iinnddeexx
**//
//** CCoommppuuttee ttoottaall sseeccttoorrss oonn ddiisskk **//
sseeccttoorrss == ddssiizz
// LLFF__BBLLKKSSIIZZ;;
//** TTrruunnccaattee ttoo ffuullll sseeccttoorr **//
//** CCoommppuuttee nnuummbbeerr ooff sseeccttoorrss ccoommpprriissiinngg ii--bblloocckkss **//
iibbppeerrsseeccttoorr == LLFF__BBLLKKSSIIZZ // ssiizzeeooff((ssttrruucctt llffiibbllkk));;
iibbsseeccttoorrss == ((llffiibbllkkss++((iibbppeerrsseeccttoorr--11)))) // iibbppeerrsseeccttoorr;;//** RRoouunndd uupp **//
llffiibbllkkss == iibbsseeccttoorrss ** iibbppeerrsseeccttoorr;;
iiff ((iibbsseeccttoorrss >> sseeccttoorrss//22)) {{
//** IInnvvaalliidd aarrgguummeennttss **//
rreettuurrnn SSYYSSEERRRR;;
}} 
//** CCrreeaattee aann iinniittiiaall ddiirreeccttoorryy **//
mmeemmsseett((((cchhaarr **))&&ddiirr,, NNUULLLLCCHH,, ssiizzeeooff((ssttrruucctt llffddiirr))));;
ddiirr..llffdd__nnffiilleess == 00;;
ddbbiinnddeexx== ((ddbbiidd3322))((iibbsseeccttoorrss ++ 11));;
ddiirr..llffdd__ddffrreeee == ddbbiinnddeexx;;

Sec. 19.24        Initial File System Creation (lfscreate) 
503
ddbbllkkss == sseeccttoorrss -- iibbsseeccttoorrss -- 11;;
rreettvvaall == wwrriittee((ddiisskk,,((cchhaarr **))&&ddiirr,, LLFF__AARREEAA__DDIIRR));;
iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** CCrreeaattee lliisstt ooff ffrreeee ii--bblloocckkss oonn ddiisskk **//
llffiibbcclleeaarr((&&iibblloocckk,, 00));;
ffoorr ((ii==00;; ii<<llffiibbllkkss--11;; ii++++)) {{
iibblloocckk..iibb__nneexxtt == ((iibbiidd3322))((ii ++ 11));;
llffiibbppuutt((ddiisskk,, ii,, &&iibblloocckk));;
}} 
iibblloocckk..iibb__nneexxtt == LLFF__IINNUULLLL;;
llffiibbppuutt((ddiisskk,, ii,, &&iibblloocckk));;
//** CCrreeaattee lliisstt ooff ffrreeee ddaattaa bblloocckkss oonn ddiisskk **//
mmeemmsseett((((cchhaarr**))&&ddbblloocckk,, NNUULLLLCCHH,, LLFF__BBLLKKSSIIZZ));;
ffoorr ((ii==00;; ii<<ddbbllkkss--11;; ii++++)) {{
ddbblloocckk..llff__nneexxttddbb == ddbbiinnddeexx ++ 11;;
wwrriittee((ddiisskk,, ((cchhaarr **))&&ddbblloocckk,, ddbbiinnddeexx));;
ddbbiinnddeexx++++;;
}} 
ddbblloocckk..llff__nneexxttddbb == LLFF__DDNNUULLLL;;
wwrriittee((ddiisskk,, ((cchhaarr **))&&ddbblloocckk,, ddbbiinnddeexx));;
cclloossee((ddiisskk));;
rreettuurrnn OOKK;;
}}
19.25 Perspective
File systems are among the most complex pieces of an operating system. Our im-
plementation avoids one of the most challenging problems, sharing, by imposing a res-
triction: a file can only be opened once at a given time. If the restriction is relaxed, a 
file system must coordinate operations among multiple file descriptors that can refer to 
the same file. Sharing raises the question of semantics: how should overlapping write 
operations be interpreted? In particular, if a process attempts to write bytes 0 through N 
of a file and another process simultaneously attempts to write bytes 2 through N-1 of 
the same file, what should happen? Should the file system guarantee that one of the 
two operations occurs first? Should the file system allow bytes to be intermingled? 
How should the file system manage a shared cache to make operations efficient?

504
File Systems 
Chap. 19
A second form of complexity arises from the implementation. All operations on
files must be translated into operations on disk blocks. As a result, basic data struc-
tures, such as linked lists, can be complex to manipulate. Interestingly, much of the 
complexity arises when disk blocks are shared. For example, because a given disk 
block can hold index blocks from multiple files, two processes may need to access the 
same disk block simultaneously. Most file systems arrange to cache disk blocks, mak-
ing such access efficient.
A final form of complexity arises from the need for safety and recovery. Users as-
sume that once data has been written to a file, the data is “safe,” even if the power fails. 
However, a file system cannot afford to write to disk each time an application stores a 
byte in a file. Thus, one of the grand challenges of file system design arises from the 
tradeoff between efficiency and safety — a designer looks for ways to minimize the risk 
of losing data while also looking for ways to maximize efficiency.
19.26 Summary
A file system manages objects on nonvolatile storage. To ensure the interface to
files is the same as the interface to devices, our example system is organized into a
master file system device and a set of file pseudo-devices. To access a file, a process 
opens the master device; the call returns the descriptor of a pseudo-device for the file. 
Once a file has been opened, functions read, write, getc, putc, seek, and close can be 
used on the file.
Our design allows files to grow dynamically; the data structures for a file consist
of a directory entry and a linked list of index blocks that each point to a set of data
blocks. When a file is used, the driver software loads an index block and data block
into memory. Subsequent accesses or changes to a file affect the data block in memory. 
When the file position moves outside the current block, the file system writes the data 
block back to disk and allocates another data block. Similarly, when the file position 
moves outside the data covered by the current index block, the system writes the current 
index block to disk and allocates a new index block.
EXERCISES
19.1  
Consider the amount of code needed for the Xinu file system. Can you find an alterna-
tive file system design that provides equivalent functionality, but requires substantially
less code?
19.2 
Redesign functions lflread and lflwrite to perform high-speed copies (i.e., copy bytes
from or to the current data block without making repeated calls to lflgetc or lflputc.
19.3     Redesign the system to permit multiple processes to open the same file simultaneously.
Coordinate all writes to ensure that a given byte in the file always contains the data writ-
ten last.

Exercises
505
19.4  
Free data blocks are chained together on a singly-linked list. Redesign the system to
place them in a file (i.e., reserve index block 0 to be an unnamed “file” in which index 
blocks point to free data blocks). Compare the performance of the new and original 
designs.
19.5 
What are the maximum number of disk accesses necessary to allocate and free a data
block under the original design and the new design in the previous exercise?
19.6 
The number of index blocks is important because having too many wastes space that
could be used for data, while having too few means data blocks will be wasted because 
there are insufficient index blocks to use them. Given that there are 16 data block 
pointers in an index block and 7 index blocks fill a disk block, how many index blocks 
might be needed for a disk of n total blocks if the directory can hold k files?
19.7  
Current index block IDs are 32 bits long. Redesign the system to use 16-bit index block
IDs. What are the tradeoffs of the two approaches?
19.8 
Redesign the system so it closes all files that have been opened by a process when the
process terminates.
19.9 
Change the system to have a file switch table separate from the device switch table.
What are the advantages and disadvantages of each approach?
19.10  After modifying the free list, function lfiballoc writes a copy of the directory to disk. As
an alternative, lfiballoc could mark the directory “dirty” and defer the write operation
until later. Discuss the advantages and disadvantages of each approach.
19.11  Consider two processes attempting to write to a single file. Suppose one process repeat-
edly writes 20 bytes of character A and the other process repeatedly writes 20 bytes of 
character B. Describe the order in which characters might appear in the file.
19.12    Create a control function for the file pseudo-device driver that allows a caller to invoke
lftruncate.
19.13    Create a control function for the master file system device that allows a caller to invoke
lfscreate.


Chapter Contents
20.1 
Introduction, 509
20.2 
Remote File Access, 509
20.3 
Remote File Semantics, 510
20.4 
Remote File Design And Messages, 510
20.5 
Remote File Server Communication (rfscomm), 518
20.6 
Sending A Basic Message (rfsndmsg), 520
20.7 
Network Byte Order, 522
20.8 
A Remote File System Using A Device Paradigm, 522
20.9 
Opening A Remote File (rfsopen), 524
20.10 Checking The File Mode (rfsgetmode), 527 
20.11 Closing A Remote File (rflclose), 528
20.12 Reading From A Remote File (rflread), 529 
20.13 Writing To A Remote File (rflwrite), 532 
20.14 Seeking On A Remote File (rflseek), 535
20.15 Character I/O On A Remote File (rflgetc, rflputc), 536 
20.16 Remote File System Control Functions (rfscontrol), 537 
20.17 Initializing The Remote File System (rfsinit, rflinit), 541 
20.18 Perspective, 543
20.19 Summary, 543


20
A Remote File Mechanism
Networking makes the far-away the here-and-now.
— Unknown
20.1 Introduction
Chapter 16 discusses a network interface and a device driver that uses the hardware 
interface to send and receive packets. Chapter 18 considers disk hardware and the
block transfer paradigm. Chapter 19 explains how a file system creates high-level 
abstractions, including dynamic files, and shows how files can be mapped onto a disk.
This chapter expands the discussion of file systems by considering an alternative
that uses a remote file server. That is, instead of implementing the file abstraction
directly on hardware, the operating system relies on a separate computer called a server. 
When an application requests a file operation, the operating system sends a request to 
the server and receives a response. The next chapter extends the discussion by showing 
how a remote and local file system can be integrated.
20.2 Remote File Access
A remote file access mechanism requires four conceptual pieces. First, an operat-
ing system must contain a device driver for a network device (such as an Ethernet). 
Second, the operating system must also contain protocol software (such as UDP and IP) 
that handles addressing so the packets can reach the remote server and replies can re-
turn. Third, the operating system must have remote file access software that becomes a 
client (i.e., forms a request, uses the network to send the request to the server and re-
509

510 
A Remote File Mechanism 
Chap. 20
ceive a response, and interprets the response). Whenever a process invokes an I/O 
operation on a remote file (e.g., read or write), the remote file access software forms a 
message that specifies the operation, sends the request to the remote file server, and 
processes the response. Fourth, a computer on the network must be running a remote 
file server application that honors each request.
In practice, many questions arise about the design of a remote file access mecha-
nism. What services should a remote file server provide? Should the service permit a 
client to create hierarchical directories, or should the server only permit a client to 
create data files? Should the mechanism allow a client to remove files? If two or more 
clients send requests to a given server, should the files be shared or should each client 
have its own files? Should a file be cached in the memory of the client machine? For 
example, when a process reads a byte from a remote file, should the client software re-
quest one-thousand bytes and hold the extra bytes in a cache to avoid sending requests 
to the remote server for successive bytes?
20.3 Remote File Semantics
One of the primary design considerations surrounding remote file systems arises 
from heterogeneity: the operating systems on the client and server machines may differ. 
As a result, the file operations available to the remote server may differ from the file 
operations used on the client machine. For example, because the file server we use runs 
on a Unix system (e.g., Linux or Solaris), the server supplies functionality from the 
Unix file system, not from Xinu.
Some of the Xinu file operations map directly to Unix file operations. For exam-
ple, Xinu uses the same semantics for read as Unix — a request specifies a buffer size 
and read specifies the number of data bytes that were placed in the buffer. Similarly, a 
Xinu write operation follows the same semantics as a Unix write.
However, Xinu semantics do differ from Unix semantics in many ways. Each
Unix file has an owner that is identified by a Unix userid; Xinu does not have userids,
and even if it did, they would not align with the userids used by the server. Even small 
details differ. For example, the mode argument used with a Xinu open operation allows 
a caller to specify that the file must be new (i.e., must not exist) or that the file must be 
old (i.e., must exist). Unix allows a file to be created, but does not test whether the file 
already exists. Instead, if the file exists, Unix truncates the file to zero bytes. Thus, to 
implement the Xinu new mode, a remote server running on a Unix system must first test 
whether the file exists and return an error indication if it does.
20.4 Remote File Design And Messages
Our example remote file system provides basic functionality: a Xinu process can 
create a file, write data to the file, seek to an arbitrary position in the file, read data 
from the file, truncate a file, and delete a file. The remote file system also allows a

Sec. 20.4        Remote File Design And Messages 
511
Xinu process to create or remove directories. However, the system does not permit 
processes on multiple computers to share files. For each operation, the system defines a 
request message (sent from a Xinu client to the remote file server) and a response mes-
sage (sent from the server back to the Xinu client). Each message begins with a com-
mon header that specifies the type of the operation, a status value (used in responses to 
report errors), a sequence number, and the name of a file. Each outgoing request is as-
signed a unique sequence number, and the remote file software checks a reply to ensure 
that an incoming reply matches the outgoing request. Our implementation defines a 
structure for each message type. To avoid nested structure declarations, the code uses a 
preprocessor definition, RF_MSG_HDR, for the header fields, and then includes the 
header in each struct. File rfilesys.h contains the code.
//** rrffiilleessyyss..hh -- DDeeffiinniittiioonnss ffoorr rreemmoottee ffiillee ssyysstteemm ppsseeuuddoo--ddeevviicceess **//
##iiffnnddeeff NNrrffll
##ddeeffiinnee NNrrffll
1100
##eennddiiff
//** CCoonnttrrooll bblloocckk ffoorr aa rreemmoottee ffiillee ppsseeuuddoo--ddeevviiccee **//
##ddeeffiinnee RRFF__NNAAMMLLEENN
112288
//** MMaaxxiimmuumm lleennggtthh ooff ffiillee nnaammee
**//
##ddeeffiinnee RRFF__DDAATTAALLEENN
11002244
//** MMaaxxiimmuumm ddaattaa iinn rreeaadd oorr wwrriittee**//
##ddeeffiinnee RRFF__MMOODDEE__RR
FF__MMOODDEE__RR
//** BBiitt ttoo ggrraanntt rreeaadd aacccceessss
**//
##ddeeffiinnee RRFF__MMOODDEE__WW
FF__MMOODDEE__WW
//** BBiitt ttoo ggrraanntt wwrriittee aacccceessss
**//
##ddeeffiinnee RRFF__MMOODDEE__RRWW
FF__MMOODDEE__RRWW
//** MMaasskk ffoorr rreeaadd aanndd wwrriittee bbiittss **//
##ddeeffiinnee RRFF__MMOODDEE__NN
FF__MMOODDEE__NN
//** BBiitt ffoorr ""nneeww"" mmooddee
**//
##ddeeffiinnee RRFF__MMOODDEE__OO
FF__MMOODDEE__OO
//** BBiitt ffoorr ""oolldd"" mmooddee
**//
##ddeeffiinnee RRFF__MMOODDEE__NNOO
FF__MMOODDEE__NNOO
//** MMaasskk ffoorr ""nn"" aanndd ""oo"" bbiittss
**//
//** GGlloobbaall ddaattaa ffoorr tthhee rreemmoottee sseerrvveerr **//
##iiffnnddeeff RRFF__SSEERRVVEERR__IIPP
##ddeeffiinnee RRFF__SSEERRVVEERR__IIPP
""112288..1100..33..5511""
##eennddiiff
##iiffnnddeeff RRFF__SSEERRVVEERR__PPOORRTT
##ddeeffiinnee RRFF__SSEERRVVEERR__PPOORRTT
3333112233
##eennddiiff
##iiffnnddeeff RRFF__LLOOCC__PPOORRTT
##ddeeffiinnee RRFF__LLOOCC__PPOORRTT
3333112233
##eennddiiff
ssttrruucctt
rrffddaattaa
{{
iinntt3322
rrff__sseeqq;;
//** NNeexxtt sseeqquueennccee nnuummbbeerr ttoo uussee
**//
uuiinntt3322
rrff__sseerr__iipp;;
//** SSeerrvveerr IIPP aaddddrreessss
**//

512 
A Remote File Mechanism 
Chap. 20
uuiinntt1166
rrff__sseerr__ppoorrtt;;
//** SSeerrvveerr UUDDPP ppoorrtt
**//
uuiinntt1166
rrff__lloocc__ppoorrtt;;
//** LLooccaall ((cclliieenntt)) UUPPDD ppoorrtt
**//
iinntt3322
rrff__uuddpp__sslloott;;
//** UUDDPP sslloott ttoo uussee
**//
ssiidd3322
rrff__mmuutteexx;;
//** MMuuttuuaall eexxcclluussiioonn ffoorr aacccceessss
**//
bbooooll88
rrff__rreeggiisstteerreedd;;
//** HHaass UUDDPP ppoorrtt bbeeeenn rreeggiisstteerreedd??**//
}};;
eexxtteerrnn
ssttrruucctt
rrffddaattaa
RRff__ddaattaa;;
//** DDeeffiinniittiioonn ooff tthhee ccoonnttrrooll bblloocckk ffoorr aa rreemmoottee ffiillee ppsseeuuddoo--ddeevviiccee
**//
##ddeeffiinnee RRFF__FFRREEEE 00
//** EEnnttrryy iiss ccuurrrreennttllyy uunnuusseedd
**//
##ddeeffiinnee RRFF__UUSSEEDD 11
//** EEnnttrryy iiss ccuurrrreennttllyy iinn uussee
**//
ssttrruucctt
rrffllccbbllkk {{
iinntt3322
rrffssttaattee;;
//** EEnnttrryy iiss ffrreeee oorr uusseedd
**//
iinntt3322
rrffddeevv;;
//** DDeevviiccee nnuummbbeerr ooff tthhiiss ddeevv..
**//
cchhaarr
rrffnnaammee[[RRFF__NNAAMMLLEENN]];;
//** NNaammee ooff tthhee ffiillee
**//
uuiinntt3322
rrffppooss;;
//** CCuurrrreenntt ffiillee ppoossiittiioonn
**//
uuiinntt3322
rrffmmooddee;;
//** MMooddee:: rreeaadd aacccceessss,, wwrriittee
**//
//**
aacccceessss oorr bbootthh
**//
}};;
eexxtteerrnn
ssttrruucctt
rrffllccbbllkk rrffllttaabb[[]];;
//** RReemmoottee ffiillee ccoonnttrrooll bblloocckkss
**//
//** DDeeffiinniittiioonnss ooff ppaarraammeetteerrss uusseedd wwhheenn aacccceessssiinngg aa rreemmoottee sseerrvveerr
**//
##ddeeffiinnee RRFF__RREETTRRIIEESS
33
//** TTiimmee ttoo rreettrryy sseennddiinngg aa mmssgg
**//
##ddeeffiinnee RRFF__TTIIMMEEOOUUTT
33000000
//** WWaaiitt oonnee sseeccoonndd ffoorr aa rreeppllyy
**//
//** CCoonnttrrooll ffuunnccttiioonnss ffoorr aa rreemmoottee ffiillee ppsseeuuddoo ddeevviiccee **//
##ddeeffiinnee RRFFSS__CCTTLL__DDEELL
FF__CCTTLL__DDEELL
//** DDeelleettee aa ffiillee
**//
##ddeeffiinnee RRFFSS__CCTTLL__TTRRUUNNCC
FF__CCTTLL__TTRRUUNNCC
//** TTrruunnccaattee aa ffiillee
**//
##ddeeffiinnee RRFFSS__CCTTLL__MMKKDDIIRR
FF__CCTTLL__MMKKDDIIRR
//** MMaakkee aa ddiirreeccttoorryy
**//
##ddeeffiinnee RRFFSS__CCTTLL__RRMMDDIIRR
FF__CCTTLL__RRMMDDIIRR
//** RReemmoovvee aa ddiirreeccttoorryy
**//
##ddeeffiinnee RRFFSS__CCTTLL__SSIIZZEE
FF__CCTTLL__SSIIZZEE
//** OObbttaaiinn tthhee ssiizzee ooff aa ffiillee
**//
//************************************************************************************************************************************************//
//** 
**//
//**
DDeeffiinniittiioonn ooff mmeessssaaggeess eexxcchhaannggeedd wwiitthh tthhee rreemmoottee sseerrvveerr
**//
//** 
**//
//************************************************************************************************************************************************//
//** VVaalluueess ffoorr tthhee ttyyppee ffiieelldd iinn mmeessssaaggeess **//

Sec. 20.4        Remote File Design And Messages 
513
##ddeeffiinnee RRFF__MMSSGG__RREESSPPOONNSSEE 00xx00110000
//** BBiitt tthhaatt iinnddiiccaatteess rreessppoonnssee
**//
##ddeeffiinnee RRFF__MMSSGG__RRRREEQQ
00xx00000011
//** RReeaadd RReeqquueesstt aanndd rreessppoonnssee
**//
##ddeeffiinnee RRFF__MMSSGG__RRRREESS
((RRFF__MMSSGG__RRRREEQQ || RRFF__MMSSGG__RREESSPPOONNSSEE))
##ddeeffiinnee RRFF__MMSSGG__WWRREEQQ
00xx00000022
//** WWrriittee RReeqquueesstt aanndd rreessppoonnssee
**//
##ddeeffiinnee RRFF__MMSSGG__WWRREESS
((RRFF__MMSSGG__WWRREEQQ || RRFF__MMSSGG__RREESSPPOONNSSEE))
##ddeeffiinnee RRFF__MMSSGG__OORREEQQ
00xx00000033
//** OOppeenn rreeqquueesstt aanndd rreessppoonnssee
**//
##ddeeffiinnee RRFF__MMSSGG__OORREESS
((RRFF__MMSSGG__OORREEQQ || RRFF__MMSSGG__RREESSPPOONNSSEE))
##ddeeffiinnee RRFF__MMSSGG__DDRREEQQ
00xx00000044
//** DDeelleettee rreeqquueesstt aanndd rreessppoonnssee
**//
##ddeeffiinnee RRFF__MMSSGG__DDRREESS
((RRFF__MMSSGG__DDRREEQQ || RRFF__MMSSGG__RREESSPPOONNSSEE))
##ddeeffiinnee RRFF__MMSSGG__TTRREEQQ
00xx00000055
//** TTrruunnccaattee rreeqquueesstt && rreessppoonnssee
**//
##ddeeffiinnee RRFF__MMSSGG__TTRREESS
((RRFF__MMSSGG__TTRREEQQ || RRFF__MMSSGG__RREESSPPOONNSSEE))
##ddeeffiinnee RRFF__MMSSGG__SSRREEQQ
00xx00000066
//** SSiizzee rreeqquueesstt aanndd rreessppoonnssee
**//
##ddeeffiinnee RRFF__MMSSGG__SSRREESS
((RRFF__MMSSGG__SSRREEQQ || RRFF__MMSSGG__RREESSPPOONNSSEE))
##ddeeffiinnee RRFF__MMSSGG__MMRREEQQ
00xx00000077
//** MMkkddiirr rreeqquueesstt aanndd rreessppoonnssee
**//
##ddeeffiinnee RRFF__MMSSGG__MMRREESS
((RRFF__MMSSGG__MMRREEQQ || RRFF__MMSSGG__RREESSPPOONNSSEE))
##ddeeffiinnee RRFF__MMSSGG__XXRREEQQ
00xx00000088
//** RRmmddiirr rreeqquueesstt aanndd rreessppoonnssee
**//
##ddeeffiinnee RRFF__MMSSGG__XXRREESS
((RRFF__MMSSGG__XXRREEQQ || RRFF__MMSSGG__RREESSPPOONNSSEE))
##ddeeffiinnee RRFF__MMIINN__RREEQQ
RRFF__MMSSGG__RRRREEQQ
//** MMiinniimmuumm rreeqquueesstt ttyyppee
**//
##ddeeffiinnee RRFF__MMAAXX__RREEQQ
RRFF__MMSSGG__XXRREEQQ
//** MMaaxxiimmuumm rreeqquueesstt ttyyppee
**//
//** MMeessssaaggee hheeaaddeerr ffiieellddss pprreesseenntt iinn eeaacchh mmeessssaaggee **//
##ddeeffiinnee RRFF__MMSSGG__HHDDRR
//** CCoommmmoonn mmeessssaaggee ffiieellddss
**//\\
uuiinntt1166
rrff__ttyyppee;;
//** MMeessssaaggee ttyyppee
**//\\
uuiinntt1166
rrff__ssttaattuuss;;
//** 00 iinn rreeqq,, ssttaattuuss iinn rreessppoonnssee **//\\
uuiinntt3322
rrff__sseeqq;;
//** MMeessssaaggee sseeqquueennccee nnuummbbeerr
**//\\
cchhaarr
rrff__nnaammee[[RRFF__NNAAMMLLEENN]];;
//** NNuullll--tteerrmmiinnaatteedd ffiillee nnaammee
**//
//** TThhee ssttaannddaarrdd hheeaaddeerr pprreesseenntt iinn aallll mmeessssaaggeess wwiitthh nnoo eexxttrraa ffiieellddss
**//
//************************************************************************************************************************************************//
//** 
**//
//**
HHeeaaddeerr
**//
//** 
**//
//************************************************************************************************************************************************//

514 
A Remote File Mechanism 
Chap. 20
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__hhddrr {{
//** HHeeaaddeerr ffiieellddss pprreesseenntt iinn eeaacchh**//
RRFF__MMSSGG__HHDDRR
//**
rreemmoottee ffiillee ssyysstteemm mmeessssaaggee **//
}};;
##pprraaggmmaa ppaacckk(())
//************************************************************************************************************************************************//
//** 
**//
//**
RReeaadd
**//
//** 
**//
//************************************************************************************************************************************************//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__rrrreeqq
{{
//** RReemmoottee ffiillee rreeaadd rreeqquueesstt
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
uuiinntt3322
rrff__ppooss;;
//** PPoossiittiioonn iinn ffiillee ttoo rreeaadd
**//
uuiinntt3322
rrff__lleenn;;
//** NNuummbbeerr ooff bbyytteess ttoo rreeaadd
**//
//**
((bbeettwweeeenn 11 aanndd 11002244))
**//
}};;
##pprraaggmmaa ppaacckk(())
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__rrrreess
{{
//** RReemmoottee ffiillee rreeaadd rreeppllyy
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
uuiinntt3322
rrff__ppooss;;
//** PPoossiittiioonn iinn ffiillee
**//
uuiinntt3322
rrff__lleenn;;
//** NNuummbbeerr ooff bbyytteess tthhaatt ffoollllooww
**//
//**
((00 ffoorr EEOOFF))
**//
cchhaarr
rrff__ddaattaa[[RRFF__DDAATTAALLEENN]];;
//** AArrrraayy ccoonnttaaiinniinngg ddaattaa ffrroomm
**//
//**
tthhee ffiillee
**//
}};;
##pprraaggmmaa ppaacckk(())
//************************************************************************************************************************************************//
//** 
**//
//**
WWrriittee
**//
//** 
**//
//************************************************************************************************************************************************//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__wwrreeqq
{{
//** RReemmoottee ffiillee wwrriittee rreeqquueesstt
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
uuiinntt3322
rrff__ppooss;;
//** PPoossiittiioonn iinn ffiillee
**//
uuiinntt3322
rrff__lleenn;;
//** NNuummbbeerr ooff vvaalliidd bbyytteess iinn
**//
//**
aarrrraayy tthhaatt ffoolllloowwss
**//

Sec. 20.4        Remote File Design And Messages 
515
cchhaarr
rrff__ddaattaa[[RRFF__DDAATTAALLEENN]];;
//** AArrrraayy ccoonnttaaiinniinngg ddaattaa ttoo bbee
**//
//**
wwrriitttteenn ttoo tthhee ffiillee
**//
}};;
##pprraaggmmaa ppaacckk(())
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__wwrreess
{{
//** RReemmoottee ffiillee wwrriittee rreessppoonnssee
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
uuiinntt3322
rrff__ppooss;;
//** OOrriiggiinnaall ppoossiittiioonn iinn ffiillee
**//
uuiinntt3322
rrff__lleenn;;
//** NNuummbbeerr ooff bbyytteess wwrriitttteenn
**//
}};;
##pprraaggmmaa ppaacckk(())
//************************************************************************************************************************************************//
//** 
**//
//**
OOppeenn
**//
//** 
**//
//************************************************************************************************************************************************//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__oorreeqq
{{
//** RReemmoottee ffiillee ooppeenn rreeqquueesstt
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
iinntt3322
rrff__mmooddee;;
//** XXiinnuu mmooddee bbiittss
**//
}};;
##pprraaggmmaa ppaacckk(())
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__oorreess
{{
//** RReemmoottee ffiillee ooppeenn rreessppoonnssee
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
iinntt3322
rrff__mmooddee;;
//** XXiinnuu mmooddee bbiittss
**//
}};;
##pprraaggmmaa ppaacckk(())
//************************************************************************************************************************************************//
//** 
**//
//**
SSiizzee
**//
//** 
**//
//************************************************************************************************************************************************//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__ssrreeqq
{{
//** RReemmoottee ffiillee ssiizzee rreeqquueesstt
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())

516 
A Remote File Mechanism 
Chap. 20
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__ssrreess
{{
//** RReemmoottee ffiillee ssttaattuuss rreessppoonnssee
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
uuiinntt3322
rrff__ssiizzee;;
//** SSiizzee ooff ffiillee iinn bbyytteess
**//
}};;
##pprraaggmmaa ppaacckk(())
//************************************************************************************************************************************************//
//** 
**//
//**
DDeelleettee
**//
//** 
**//
//************************************************************************************************************************************************//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__ddrreeqq
{{
//** RReemmoottee ffiillee ddeelleettee rreeqquueesstt
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__ddrreess
{{
//** RReemmoottee ffiillee ddeelleettee rreessppoonnssee
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())
//************************************************************************************************************************************************//
//** 
**//
//**
TTrruunnccaattee
**//
//** 
**//
//************************************************************************************************************************************************//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__ttrreeqq
{{
//** RReemmoottee ffiillee ttrruunnccaattee rreeqquueesstt **//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__ttrreess
{{
//** RReemmoottee ffiillee ttrruunnccaattee rreessppoonnssee**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())
//************************************************************************************************************************************************//
//** 
**//

Sec. 20.4        Remote File Design And Messages 
517
//**
MMkkddiirr
**//
//** 
**//
//************************************************************************************************************************************************//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__mmrreeqq
{{
//** RReemmoottee ffiillee mmkkddiirr rreeqquueesstt
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__mmrreess
{{
//** RReemmoottee ffiillee mmkkddiirr rreessppoonnssee
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())
//************************************************************************************************************************************************//
//** 
**//
//**
RRmmddiirr
**//
//** 
**//
//************************************************************************************************************************************************//
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__xxrreeqq
{{
//** RReemmoottee ffiillee rrmmddiirr rreeqquueesstt
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())
##pprraaggmmaa ppaacckk((22))
ssttrruucctt
rrff__mmssgg__xxrreess
{{
//** RReemmoottee ffiillee rrmmddiirr rreessppoonnssee
**//
RRFF__MMSSGG__HHDDRR
//** HHeeaaddeerr ffiieellddss
**//
}};;
##pprraaggmmaa ppaacckk(())
In the file, constants that begin RF_MSG_ define a unique type value for each mes-
sage. For example, RF_MSG_RREQ defines the type value used in a read request mes-
sage, and RF_MSG_RRES defines the type value used in a read response message. The 
implementation uses a trick to improve efficiency: rather than define arbitrary integers, 
the type of a response is formed by a logical or of the request type and constant 
RF_MSG_RESPONSE, which is defined to be 0x0100. That is, a response has the same 
type value as a request except that the low-order bit of the second byte is turned on.
The size of a message depends on the type. Many of the messages only need
fields in the common header. For example, a file deletion request only requires a type
(to indicate that it is a deletion request), a file name, and a sequence number. Thus, the

518 
A Remote File Mechanism 
Chap. 20
struct that defines a deletion request, rf_msg_dreq, only contains header fields. How-
ever, a write request message must include a file offset, the number of data bytes in the 
request, and the data to be written. Consequently, the struct that defines a write request 
message, rf_msg_wreq, includes three additional fields beyond the common header.
20.5 Remote File Server Communication (rfscomm)
Our remote file system software follows a principle that works well in many cases:
the functionality is separated into two levels of software. A lower level handles details
of communication with the remote server — it sends a message, waits for a response,
and handles retransmission, if necessary. An upper level handles message semantics —
it forms a message, passes the message to the lower level for transmission, receives a 
response, and interprets the response. The important idea is that because it only handles 
transmission and reception, the lower level does not need to understand or interpret the 
contents of a message. Consequently, a single function provides all lower-level func-
tionality.
Examining the code will clarify the idea. Function rfscomm performs the action of 
sending a message to the remote file server and receiving a response. File rfscomm.c 
contains the code:
//** rrffssccoommmm..cc -- rrffssccoommmm **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrffssccoommmm
--
HHaannddllee ccoommmmuunniiccaattiioonn wwiitthh RRFFSS sseerrvveerr ((sseenndd rreeqquueesstt aanndd
**
rreecceeiivvee aa rreeppllyy,, iinncclluuddiinngg sseeqquueenncciinngg aanndd rreettrriieess))
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinntt3322
rrffssccoommmm ((
ssttrruucctt rrff__mmssgg__hhddrr **mmssgg,,
//** MMeessssaaggee ttoo sseenndd
**//
iinntt3322
mmlleenn,,
//** MMeessssaaggee lleennggtthh
**//
ssttrruucctt rrff__mmssgg__hhddrr **rreeppllyy,,
//** BBuuffffeerr ffoorr rreeppllyy
**//
iinntt3322
rrlleenn
//** SSiizzee ooff rreeppllyy bbuuffffeerr
**//
))
{{
iinntt3322
ii;;
//** CCoouunnttss rreettrriieess
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee
**//
iinntt3322
sseeqq;;
//** SSeeqquueennccee ffoorr tthhiiss eexxcchhaannggee
**//
iinntt1166
rrttyyppee;;
//** RReeppllyy ttyyppee iinn hhoosstt bbyyttee oorrddeerr**//
iinntt3322
sslloott;;
//** UUDDPP sslloott
**//
//** FFoorr tthhee ffiirrsstt ttiimmee aafftteerr rreebboooott,, rreeggiisstteerr tthhee sseerrvveerr ppoorrtt **//

Sec. 20.5        Remote File Server Communication (rfscomm) 
519
iiff (( !! RRff__ddaattaa..rrff__rreeggiisstteerreedd )) {{
iiff (( ((rreettvvaall == uuddpp__rreeggiisstteerr((RRff__ddaattaa..rrff__sseerr__iipp,,
RRff__ddaattaa..rrff__sseerr__ppoorrtt,,
RRff__ddaattaa..rrff__lloocc__ppoorrtt)))) ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
RRff__ddaattaa..rrff__uuddpp__sslloott == rreettvvaall;;
RRff__ddaattaa..rrff__rreeggiisstteerreedd == TTRRUUEE;;
}} 
//** AAssssiiggnn mmeessssaaggee nneexxtt sseeqquueennccee nnuummbbeerr **//
sseeqq == RRff__ddaattaa..rrff__sseeqq++++;;
mmssgg-->>rrff__sseeqq == hhttoonnll((sseeqq));;
//** RReeppeeaatt RRFF__RREETTRRIIEESS ttiimmeess:: sseenndd mmeessssaaggee aanndd rreecceeiivvee rreeppllyy **//
ffoorr ((ii==00;; ii<<RRFF__RREETTRRIIEESS;; ii++++)) {{
//** SSeenndd aa ccooppyy ooff tthhee mmeessssaaggee **//
rreettvvaall == uuddpp__sseenndd((RRff__ddaattaa..rrff__uuddpp__sslloott,, ((cchhaarr **))mmssgg,,
mmlleenn));;
iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
kkpprriinnttff((""CCaannnnoott sseenndd ttoo rreemmoottee ffiillee sseerrvveerr\\nn""));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** RReecceeiivvee aa rreeppllyy **//
rreettvvaall == uuddpp__rreeccvv((RRff__ddaattaa..rrff__uuddpp__sslloott,, ((cchhaarr **))rreeppllyy,,
rrlleenn,, RRFF__TTIIMMEEOOUUTT));;
iiff ((rreettvvaall ==== TTIIMMEEOOUUTT)) {{
ccoonnttiinnuuee;;
}} eellssee iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
kkpprriinnttff((""EErrrroorr rreeaaddiinngg rreemmoottee ffiillee rreeppllyy\\nn""));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** VVeerriiffyy tthhaatt sseeqquueennccee iinn rreeppllyy mmaattcchheess rreeqquueesstt **//
iiff ((nnttoohhll((rreeppllyy-->>rrff__sseeqq)) !!== sseeqq)) {{
ccoonnttiinnuuee;;
}}

520 
A Remote File Mechanism 
Chap. 20
//** VVeerriiffyy tthhee ttyyppee iinn tthhee rreeppllyy mmaattcchheess tthhee rreeqquueesstt **//
rrttyyppee == nnttoohhss((rreeppllyy-->>rrff__ttyyppee));;
iiff ((rrttyyppee !!== (( nnttoohhss((mmssgg-->>rrff__ttyyppee)) || RRFF__MMSSGG__RREESSPPOONNSSEE)) )) {{
ccoonnttiinnuuee;;
}} 
rreettuurrnn rreettvvaall;;
//** RReettuurrnn lleennggtthh ttoo ccaalllleerr **//
}} 
//** RReettrriieess eexxhhaauusstteedd wwiitthhoouutt ssuucccceessss **//
kkpprriinnttff((""TTiimmeeoouutt oonn eexxcchhaannggee wwiitthh rreemmoottee ffiillee sseerrvveerr\\nn""));;
rreettuurrnn TTIIMMEEOOUUTT;;
}}
The four arguments specify the address of a message that should be sent to the 
server, the length of the message, the address of a buffer that will hold a response mes-
sage, and the length of the buffer. After assigning a unique sequence number to the 
message, rfscomm enters a loop that iterates RF_RETRIES times. On each iteration, 
rfscomm uses function udp_send to send a copy of the request message over the net-
work† and function udp_recv to receive a response.
Udp_recv allows a caller to specify a maximum time to wait for a response; 
rfscomm specifies RF_TIMEOUT.‡ If no message arrives within the specified time, 
udp_recv returns the value TIMEOUT, and the loop continues by transmitting another
copy of the request. If no response arrives after RF_RETRIES attempts, rfscomm re-
turns TIMEOUT to its caller.
If a response does arrive, rfscomm verifies that the sequence number matches the 
sequence number in the outgoing request and the message type in the incoming message 
is the response for the outgoing request. If either test fails, the server formed the mes-
sage incorrectly or the message was intended for another client on the network. In ei-
ther case, rfscomm continues the loop, sending another copy of the request and waiting 
for a response to arrive. If the two tests succeed, the incoming message is a valid 
response, and rfscomm returns the length of the response to its caller.
20.6 Sending A Basic Message (rfsndmsg)
To understand how rfscomm functions, consider a message that only requires the 
common header fields. For example, the request and response messages used for a 
truncate operation consist of a message header. Because multiple message types only 
have the common header fields, function rfsndmsg has been created to send such a mes-
sage. File rfsndmsg.c contains the code.
                                †We say that rfscomm sends a copy of the message because the original message remains unchanged. 
‡RF_TIMEOUT is defined to be 1000 milliseconds (i.e., one second), which is ample time for a client to
transmit a message across a network to a server and a server to send a response back to the client.

Sec. 20.6        Sending A Basic Message (rfsndmsg) 
521
//** rrffssnnddmmssgg..cc -- rrffssnnddmmssgg **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrffssnnddmmssgg
--
CCrreeaattee aanndd sseenndd aa mmeessssaaggee tthhaatt oonnllyy hhaass hheeaaddeerr ffiieellddss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
rrffssnnddmmssgg ((
uuiinntt1166 ttyyppee,,
//** MMeessssaaggee ttyyppee
**//
cchhaarr
**nnaammee
//** NNuullll--tteerrmmiinnaatteedd ffiillee nnaammee
**//
))
{{
ssttrruucctt
rrff__mmssgg__hhddrr
rreeqq;;
//** RReeqquueesstt mmeessssaaggee ttoo sseenndd
**//
ssttrruucctt
rrff__mmssgg__hhddrr rreesspp;;
//** BBuuffffeerr ffoorr rreessppoonnssee
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee
**//
cchhaarr
**ttoo;;
//** UUsseedd dduurriinngg nnaammee ccooppyy
**//
//** FFoorrmm aa rreeqquueesstt **//
rreeqq..rrff__ttyyppee == hhttoonnss((ttyyppee));;
rreeqq..rrff__ssttaattuuss == hhttoonnss((00));;
rreeqq..rrff__sseeqq == 00;;
//** RRffssccoommmm wwiillll sseett sseeqquueennccee
**//
ttoo == rreeqq..rrff__nnaammee;;
wwhhiillee (( ((**ttoo++++ == **nnaammee++++)) )) {{
//** CCooppyy nnaammee ttoo rreeqquueesstt
**//
;;
}} 
//** SSeenndd mmeessssaaggee aanndd rreecceeiivvee rreessppoonnssee **//
rreettvvaall == rrffssccoommmm((&&rreeqq,,
ssiizzeeooff((ssttrruucctt rrff__mmssgg__hhddrr)),,
&&rreesspp,, ssiizzeeooff((ssttrruucctt rrff__mmssgg__hhddrr)) ));;
//** CChheecckk rreessppoonnssee **//
iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((rreettvvaall ==== TTIIMMEEOOUUTT)) {{
kkpprriinnttff((""TTiimmeeoouutt dduurriinngg rreemmoottee ffiillee sseerrvveerr aacccceessss\\nn""));;
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((nnttoohhll((rreesspp..rrff__ssttaattuuss)) !!== 00)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
rreettuurrnn OOKK;;
}}

522 
A Remote File Mechanism 
Chap. 20
Rfsndmsg takes two arguments that specify the type of the message to send and the 
name of a file. To create a request message, the code assigns a value to each field of 
variable req. It then calls rfscomm to transmit the message and receive a response. If 
rfscomm reports an error or timeout or if the status in the response indicates an error, 
rfsndmsg returns SYSERR to its caller. Otherwise, rfsndmsg returns OK.
20.7 Network Byte Order
Remote file access raises an important consideration: the format of integers (i.e., 
endianness) depends on the computer architecture. If one were to transfer an integer
from the memory of one computer directly to the memory on another, the numeric value 
of the integer on the second computer may differ from the numeric value on the first. 
To accommodate differences, software that sends data over a computer network follows 
the convention of converting integers from the local byte order to a standard known as 
network byte order, and software that receives data from a computer network converts 
integers from network byte order to the local byte order. We can summarize:
To accommodate differences in endianness, an integer value sent from 
one computer to another is converted to network byte order before 
sending and converted to local byte order upon reception. In our 
design, upper-level functions perform the conversion.
Xinu follows the Unix naming convention for byte-order transform functions. 
Function htonl (htons) transforms an integer (a short integer) from local host byte order 
to network byte order; function ntohl (ntohs) transforms an integer (a short integer) 
from network byte order to local byte order. For example, function rfsndmsg uses htons
to convert the integers that specify the message type and status from local byte order to 
network byte order.
20.8 A Remote File System Using A Device Paradigm
As we have seen, Xinu uses a device paradigm for both devices and files. The re-
mote file system follows the pattern. Figure 20.1 shows an excerpt from the Xinu Con-
figuration file that defines the type of a remote file system master device and a set of 
remote file pseudo-devices.

Sec. 20.8        A Remote File System Using A Device Paradigm 
523
//** RReemmoottee FFiillee SSyysstteemm mmaasstteerr ddeevviiccee ttyyppee **//
rrffss::
oonn uuddpp
--ii rrffssiinniitt
--oo rrffssooppeenn
--cc iiooeerrrr
--rr iiooeerrrr
--gg iiooeerrrr
--pp iiooeerrrr
--ww iiooeerrrr
--ss iiooeerrrr
--nn rrffssccoonnttrrooll
--iinnttrr NNUULLLL
//** RReemmoottee ffiillee ppsseeuuddoo--ddeevviiccee ttyyppee **//
rrffll::
oonn rrffss
--ii rrfflliinniitt
--oo iiooeerrrr
--cc rrffllcclloossee
--rr rrffllrreeaadd
--gg rrffllggeettcc
--pp rrffllppuuttcc
--ww rrffllwwrriittee
--ss rrffllsseeeekk
--nn iiooeerrrr
--iinnttrr NNUULLLL
Figure 20.1 Excerpt from a Xinu Configuration file that defines the two de-
vice types used by the remote file system.
Figure 20.2 contains an excerpt from the Configuration file that defines a remote 
file system master device (RFILESYS) and a set of six remote file pseudo-devices 
(RFILE0 through RFILE5).
//** RReemmoottee ffiillee ssyysstteemm mmaasstteerr ddeevviiccee ((oonnee ppeerr ssyysstteemm)) **//
RRFFIILLEESSYYSS iiss rrffss oonn uuddpp
//** RReemmoottee ffiillee ppsseeuuddoo--ddeevviicceess ((mmaannyy iinnssttaanncceess ppeerr ssyysstteemm)) **//
RRFFIILLEE00 iiss rrffll oonn rrffss
RRFFIILLEE11 iiss rrffll oonn rrffss
RRFFIILLEE22 iiss rrffll oonn rrffss
RRFFIILLEE33 iiss rrffll oonn rrffss
RRFFIILLEE44 iiss rrffll oonn rrffss
RRFFIILLEE55 iiss rrffll oonn rrffss
Figure 20.2 Excerpt from a Xinu Configuration file that defines devices used
by the remote file system.
When an application calls open on the remote file system master device, the call 
allocates one of the remote file pseudo-devices and returns the device ID of the allocat-

524 
A Remote File Mechanism 
Chap. 20
ed pseudo-device. The application uses the device ID in calls to read and write, and 
eventually calls close to deallocate the pseudo-device. The next sections define the de-
vice driver functions used for both the remote file system master device and the remote 
file pseudo-devices.
20.9 Opening A Remote File (rfsopen)
To open a remote file, a program calls open on device RFILESYS, supplying a file 
name and mode argument.  Open invokes function rfsopen, which forms a request and 
uses rfscomm to communicate with the remote file server. If it succeeds, the call to 
open returns the descriptor of a remote file pseudo-device that is associated with the 
open file (i.e., can be used to write data into the file or read data from the file). File 
rfsopen.c contains the code:
//** rrffssooppeenn..cc -- rrffssooppeenn **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrffssooppeenn
--
AAllllooccaattee aa rreemmoottee ffiillee ppsseeuuddoo--ddeevviiccee ffoorr aa ssppeecciiffiicc ffiillee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrffssooppeenn ((
ssttrruucctt ddeennttrryy
**ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**nnaammee,,
//** FFiillee nnaammee ttoo uussee
**//
cchhaarr
**mmooddee
//** MMooddee cchhaarrss:: ’’rr’’ ’’ww’’ ’’oo’’ ’’nn’’
**//
))
{{
ssttrruucctt
rrffllccbbllkk **rrffppttrr;;
//** PPttrr ttoo ccoonnttrrooll bblloocckk eennttrryy
**//
ssttrruucctt
rrff__mmssgg__oorreeqq mmssgg;;
//** MMeessssaaggee ttoo bbee sseenntt
**//
ssttrruucctt
rrff__mmssgg__oorreess rreesspp;;
//** BBuuffffeerr ttoo hhoolldd rreessppoonnssee
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee ffrroomm rrffssccoommmm
**//
iinntt3322
lleenn;;
//** CCoouunnttss cchhaarrss iinn nnaammee
**//
cchhaarr
**nnppttrr;;
//** PPooiinntteerr iinnttoo nnaammee ssttrriinngg
**//
cchhaarr
**ffppttrr;;
//** PPooiinntteerr iinnttoo ffiillee nnaammee
**//
iinntt3322
ii;;
//** GGeenneerraall lloooopp iinnddeexx
**//
//** WWaaiitt ffoorr eexxcclluussiivvee aacccceessss **//
wwaaiitt((RRff__ddaattaa..rrff__mmuutteexx));;
//** SSeeaarrcchh ccoonnttrrooll bblloocckk aarrrraayy ttoo ffiinndd aa ffrreeee eennttrryy **//

Sec. 20.9        Opening A Remote File (rfsopen) 
525
ffoorr((ii==00;; ii<<NNrrffll;; ii++++)) {{
rrffppttrr == &&rrffllttaabb[[ii]];;
iiff ((rrffppttrr-->>rrffssttaattee ==== RRFF__FFRREEEE)) {{
bbrreeaakk;;
}}
}} 
iiff ((ii >>== NNrrffll)) {{
//** NNoo ffrreeee ttaabbllee sslloottss rreemmaaiinn
**//
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** CCooppyy nnaammee iinnttoo ffrreeee ttaabbllee sslloott **//
nnppttrr == nnaammee;;
ffppttrr == rrffppttrr-->>rrffnnaammee;;
lleenn == 00;;
wwhhiillee (( ((**ffppttrr++++ == **nnppttrr++++)) !!== NNUULLLLCCHH)) {{
lleenn++++;;
iiff ((lleenn >>== RRFF__NNAAMMLLEENN)) {{ //** FFiillee nnaammee iiss ttoooo lloonngg
**//
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
//** VVeerriiffyy tthhaatt nnaammee iiss nnoonn--nnuullll **//
iiff ((lleenn====00)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** PPaarrssee mmooddee ssttrriinngg **//
iiff (( ((rrffppttrr-->>rrffmmooddee == rrffssggeettmmooddee((mmooddee)))) ==== SSYYSSEERRRR )) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** FFoorrmm aann ooppeenn rreeqquueesstt ttoo ccrreeaattee aa nneeww ffiillee oorr ooppeenn aann oolldd oonnee **//
mmssgg..rrff__ttyyppee == hhttoonnss((RRFF__MMSSGG__OORREEQQ));;//** RReeqquueesstt aa ffiillee ooppeenn
**//
mmssgg..rrff__ssttaattuuss == hhttoonnss((00));;
mmssgg..rrff__sseeqq == 00;;
//** RRffssccoommmm ffiillllss iinn sseeqq.. nnuummbbeerr **//
nnppttrr == mmssgg..rrff__nnaammee;;
mmeemmsseett((nnppttrr,, NNUULLLLCCHH,, RRFF__NNAAMMLLEENN));;//** IInniittiiaalliizzee nnaammee ttoo zzeerroo bbyytteess**//

526 
A Remote File Mechanism 
Chap. 20
wwhhiillee (( ((**nnppttrr++++ == **nnaammee++++)) !!== NNUULLLLCCHH )) {{ //** CCooppyy nnaammee ttoo rreeqq..
**//
;;
}} 
mmssgg..rrff__mmooddee == hhttoonnll((rrffppttrr-->>rrffmmooddee));; //** SSeett mmooddee iinn rreeqquueesstt
**//
//** SSeenndd mmeessssaaggee aanndd rreecceeiivvee rreessppoonnssee **//
rreettvvaall == rrffssccoommmm((((ssttrruucctt rrff__mmssgg__hhddrr **))&&mmssgg,,
ssiizzeeooff((ssttrruucctt rrff__mmssgg__oorreeqq)),,
((ssttrruucctt rrff__mmssgg__hhddrr **))&&rreesspp,,
ssiizzeeooff((ssttrruucctt rrff__mmssgg__oorreess)) ));;
//** CChheecckk rreessppoonnssee **//
iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((rreettvvaall ==== TTIIMMEEOOUUTT)) {{
kkpprriinnttff((""TTiimmeeoouutt dduurriinngg rreemmoottee ffiillee ooppeenn\\nn\\rr""));;
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((nnttoohhss((rreesspp..rrff__ssttaattuuss)) !!== 00)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** SSeett iinniittiiaall ffiillee ppoossiittiioonn **//
rrffppttrr-->>rrffppooss == 00;;
//** MMaarrkk ssttaattee aass ccuurrrreennttllyy uusseedd **//
rrffppttrr-->>rrffssttaattee == RRFF__UUSSEEDD;;
//** RReettuurrnn ddeevviiccee ddeessccrriippttoorr ooff nneewwllyy ccrreeaatteedd ppsseeuuddoo--ddeevviiccee **//
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn rrffppttrr-->>rrffddeevv;;
}}
Before proceeding to check its arguments, rfsopen checks the remote pseudo-
devices to ensure that one is available. The code then checks the file name to ensure
that the name is less than the maximum allowed and the mode string to ensure that the 
specification is valid.

Sec. 20.9        Opening A Remote File (rfsopen) 
527
Before it allocates the remote file device, rfsopen must communicate with the re-
mote server to ensure the remote server agrees the file can be opened. The code creates
a request message, and uses rfscomm to send the message to the server. If a positive 
response arrives, rfsopen marks the control block entry for the remote file device as be-
ing used, sets the initial file position to zero, and returns the descriptor to the caller.
20.10 Checking The File Mode (rfsgetmode)
When it needs to check the file mode argument, rfsopen calls function rfsgetmode,
passing the mode string as an argument. The code can be found in file rfsgetmode.c:
//** rrffssggeettmmooddee..cc -- rrffssggeettmmooddee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrffssggeettmmooddee
--
PPaarrssee mmooddee aarrgguummeenntt aanndd ggeenneerraattee iinntteeggeerr ooff mmooddee bbiittss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinntt3322
rrffssggeettmmooddee ((
cchhaarr
**mmooddee
//** SSttrriinngg ooff mmooddee cchhaarraacctteerrss
**//
))
{{
iinntt3322
mmbbiittss;;
//** MMooddee bbiittss ttoo rreettuurrnn ((iinn hhoosstt **//
//**
bbyyttee oorrddeerr))
**//
cchhaarr
cchh;;
//** NNeexxtt cchhaarraacctteerr iinn mmooddee ssttrriinngg**//
mmbbiittss == 00;;
//** MMooddee ssttrriinngg ssppeecciiffiieess::
**//
//**
rr -- rreeaadd
**//
//**
ww -- wwrriittee
**//
//**
oo -- oolldd ((ffiillee mmuusstt eexxiisstt))
**//
//**
nn -- nneeww ((ccrreeaattee aa nneeww ffiillee))
**//
wwhhiillee (( ((cchh == **mmooddee++++)) !!== NNUULLLLCCHH)) {{
sswwiittcchh ((cchh)) {{
ccaassee ’’rr’’::
iiff ((mmbbiittss&&RRFF__MMOODDEE__RR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
mmbbiittss ||== RRFF__MMOODDEE__RR;;
ccoonnttiinnuuee;;

528 
A Remote File Mechanism 
Chap. 20
ccaassee ’’ww’’::
iiff ((mmbbiittss&&RRFF__MMOODDEE__WW)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
mmbbiittss ||== RRFF__MMOODDEE__WW;;
ccoonnttiinnuuee;;
ccaassee ’’oo’’::
iiff ((mmbbiittss&&RRFF__MMOODDEE__OO |||| mmbbiittss&&RRFF__MMOODDEE__NN)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
mmbbiittss ||== RRFF__MMOODDEE__OO;;
bbrreeaakk;;
ccaassee ’’nn’’::
iiff ((mmbbiittss&&RRFF__MMOODDEE__OO |||| mmbbiittss&&RRFF__MMOODDEE__NN)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
mmbbiittss ||== RRFF__MMOODDEE__NN;;
bbrreeaakk;;
ddeeffaauulltt::
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
//** IIff nneeiitthheerr rreeaadd nnoorr wwrriittee ssppeecciiffiieedd,, aallllooww bbootthh **//
iiff (( ((mmbbiittss&&RRFF__MMOODDEE__RRWW)) ==== 00 )) {{
mmbbiittss ||== RRFF__MMOODDEE__RRWW;;
}} 
rreettuurrnn mmbbiittss;;
}}
Rfsgetmode extracts characters from the mode string, ensures each is valid, and 
checks for illegal combinations (e.g., a mode string cannot specify both new and old 
modes). As it parses the mode string, rfsgetmode sets the bits in integer mbits. Once it 
has finished examining the string and checking the combinations, rfsgetmode returns in-
teger mbits to the caller.
20.11 Closing A Remote File (rflclose)
Once a process has finished using a file, the process can call close to release the 
remote file device and make it available for the system to use for another file. For a re-
mote file device, close invokes rflclose. In our implementation, closing a remote file is 
trivial. Function rflclose.c contains the code:

Sec. 20.11        Closing A Remote File (rflclose) 
529
//** rrffllcclloossee..cc -- rrffllcclloossee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrffllcclloossee
--
CClloossee aa rreemmoottee ffiillee ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrffllcclloossee ((
ssttrruucctt ddeennttrryy **ddeevvppttrr
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
))
{{
ssttrruucctt
rrffllccbbllkk **rrffppttrr;;
//** PPooiinntteerr ttoo ccoonnttrrooll bblloocckk
**//
//** WWaaiitt ffoorr eexxcclluussiivvee aacccceessss **//
wwaaiitt((RRff__ddaattaa..rrff__mmuutteexx));;
//** VVeerriiffyy rreemmoottee ffiillee ddeevviiccee iiss ooppeenn **//
rrffppttrr == &&rrffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
iiff ((rrffppttrr-->>rrffssttaattee ==== RRFF__FFRREEEE)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** MMaarrkk ddeevviiccee cclloosseedd **//
rrffppttrr-->>rrffssttaattee == RRFF__FFRREEEE;;
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn OOKK;;
}}
After verifying that the device is currently open, rflclose sets the state of the con-
trol block entry to RF_FREE. Note that this version of rflclose does not inform the re-
mote file server that the file is closed. The exercises suggest redesigning the system to 
inform the remote server when a file is closed.
20.12 Reading From A Remote File (rflread)
Once a remote file has been opened, a process can read data from the file. Driver
function rflread performs the read operation. The code can be found in file rflread.c:

530 
A Remote File Mechanism 
Chap. 20
//** rrffllrreeaadd..cc -- rrffllrreeaadd **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrffllrreeaadd
--
RReeaadd ddaattaa ffrroomm aa rreemmoottee ffiillee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrffllrreeaadd ((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**bbuuffff,,
//** BBuuffffeerr ooff bbyytteess
**//
iinntt3322 ccoouunntt
//** CCoouunntt ooff bbyytteess ttoo rreeaadd
**//
))
{{
ssttrruucctt
rrffllccbbllkk **rrffppttrr;;
//** PPooiinntteerr ttoo ccoonnttrrooll bblloocckk
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee
**//
ssttrruucctt
rrff__mmssgg__rrrreeqq
mmssgg;;
//** RReeqquueesstt mmeessssaaggee ttoo sseenndd
**//
ssttrruucctt
rrff__mmssgg__rrrreess rreesspp;;
//** BBuuffffeerr ffoorr rreessppoonnssee
**//
iinntt3322
ii;;
//** CCoouunnttss bbyytteess ccooppiieedd
**//
cchhaarr
**ffrroomm,, **ttoo;;
//** UUsseedd dduurriinngg nnaammee ccooppyy
**//
iinntt3322
lleenn;;
//** LLeennggtthh ooff nnaammee
**//
//** WWaaiitt ffoorr eexxcclluussiivvee aacccceessss **//
wwaaiitt((RRff__ddaattaa..rrff__mmuutteexx));;
//** VVeerriiffyy ccoouunntt iiss lleeggiittiimmaattee **//
iiff (( ((ccoouunntt <<== 00)) |||| ((ccoouunntt >> RRFF__DDAATTAALLEENN)) )) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** VVeerriiffyy ppsseeuuddoo--ddeevviiccee iiss iinn uussee **//
rrffppttrr == &&rrffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
//** IIff ddeevviiccee nnoott ccuurrrreennttllyy iinn uussee,, rreeppoorrtt aann eerrrroorr **//
iiff ((rrffppttrr-->>rrffssttaattee ==== RRFF__FFRREEEE)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** VVeerriiffyy ppsseeuuddoo--ddeevviiccee aalllloowwss rreeaaddiinngg **//

Sec. 20.12        Reading From A Remote File (rflread) 
531
iiff ((((rrffppttrr-->>rrffmmooddee && RRFF__MMOODDEE__RR)) ==== 00)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** FFoorrmm rreeaadd rreeqquueesstt **//
mmssgg..rrff__ttyyppee == hhttoonnss((RRFF__MMSSGG__RRRREEQQ));;
mmssgg..rrff__ssttaattuuss == hhttoonnss((00));;
mmssgg..rrff__sseeqq == 00;;
//** RRffssccoommmm wwiillll sseett sseeqquueennccee
**//
ffrroomm == rrffppttrr-->>rrffnnaammee;;
ttoo == mmssgg..rrff__nnaammee;;
mmeemmsseett((ttoo,, NNUULLLLCCHH,, RRFF__NNAAMMLLEENN));;
//** SSttaarrtt nnaammee aass aallll zzeerroo bbyytteess **//
lleenn == 00;;
wwhhiillee (( ((**ttoo++++ == **ffrroomm++++)) )) {{
//** CCooppyy nnaammee ttoo rreeqquueesstt
**//
iiff ((++++lleenn >>== RRFF__NNAAMMLLEENN)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
mmssgg..rrff__ppooss == hhttoonnll((rrffppttrr-->>rrffppooss));;//** SSeett ffiillee ppoossiittiioonn
**//
mmssgg..rrff__lleenn == hhttoonnll((ccoouunntt));;
//** SSeett ccoouunntt ooff bbyytteess ttoo rreeaadd
**//
//** SSeenndd mmeessssaaggee aanndd rreecceeiivvee rreessppoonnssee **//
rreettvvaall == rrffssccoommmm((((ssttrruucctt rrff__mmssgg__hhddrr **))&&mmssgg,,
ssiizzeeooff((ssttrruucctt rrff__mmssgg__rrrreeqq)),,
((ssttrruucctt rrff__mmssgg__hhddrr **))&&rreesspp,,
ssiizzeeooff((ssttrruucctt rrff__mmssgg__rrrreess)) ));;
//** CChheecckk rreessppoonnssee **//
iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((rreettvvaall ==== TTIIMMEEOOUUTT)) {{
kkpprriinnttff((""TTiimmeeoouutt dduurriinngg rreemmoottee ffiillee rreeaadd\\nn""));;
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((nnttoohhss((rreesspp..rrff__ssttaattuuss)) !!== 00)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** CCooppyy ddaattaa ttoo aapppplliiccaattiioonn bbuuffffeerr aanndd uuppddaattee ffiillee ppoossiittiioonn **//

532 
A Remote File Mechanism 
Chap. 20
ffoorr ((ii==00;; ii<<hhttoonnll((rreesspp..rrff__lleenn));; ii++++)) {{
**bbuuffff++++ == rreesspp..rrff__ddaattaa[[ii]];;
}} 
rrffppttrr-->>rrffppooss ++== hhttoonnll((rreesspp..rrff__lleenn));;
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn hhttoonnll((rreesspp..rrff__lleenn));;
}}
Rflread begins by checking argument count to verify that the request is in range. It
then verifies that the pseudo-device has been opened and the mode allows reading.
Once the checking is complete, rflread performs the read operation: it forms a message, 
uses rfscomm to transmit a copy to the server and receive a response, and interprets the 
response.
If rfscomm returns a valid response, the message will include the data that has been 
read. Rflread copies the data from the response message into the caller’s buffer, up-
dates the file position, and returns the number of bytes to the caller.
20.13 Writing To A Remote File (rflwrite)
Writing to a remote file follows the same general paradigm as reading from a re-
mote file. Driver function rflwrite performs the write operation; the code can be found
in file rflwrite.c:
//** rrffllwwrriittee..cc -- rrffllwwrriittee **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrffllwwrriittee
--
WWrriittee ddaattaa ttoo aa rreemmoottee ffiillee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrffllwwrriittee ((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**bbuuffff,,
//** BBuuffffeerr ooff bbyytteess
**//
iinntt3322 ccoouunntt
//** CCoouunntt ooff bbyytteess ttoo wwrriittee
**//
))
{{
ssttrruucctt
rrffllccbbllkk **rrffppttrr;;
//** PPooiinntteerr ttoo ccoonnttrrooll bblloocckk
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee
**//
ssttrruucctt
rrff__mmssgg__wwrreeqq
mmssgg;;
//** RReeqquueesstt mmeessssaaggee ttoo sseenndd
**//
ssttrruucctt
rrff__mmssgg__wwrreess rreesspp;;
//** BBuuffffeerr ffoorr rreessppoonnssee
**//
cchhaarr
**ffrroomm,, **ttoo;;
//** UUsseedd ttoo ccooppyy nnaammee
**//

Sec. 20.13        Writing To A Remote File (rflwrite) 
533
iinntt
ii;;
//** CCoouunnttss bbyytteess ccooppiieedd iinnttoo rreeqq **//
iinntt3322
lleenn;;
//** LLeennggtthh ooff nnaammee
**//
//** WWaaiitt ffoorr eexxcclluussiivvee aacccceessss **//
wwaaiitt((RRff__ddaattaa..rrff__mmuutteexx));;
//** VVeerriiffyy ccoouunntt iiss lleeggiittiimmaattee **//
iiff (( ((ccoouunntt <<== 00)) |||| ((ccoouunntt >> RRFF__DDAATTAALLEENN)) )) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** VVeerriiffyy ppsseeuuddoo--ddeevviiccee iiss iinn uussee aanndd mmooddee aalllloowwss wwrriittiinngg **//
rrffppttrr == &&rrffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
iiff (( ((rrffppttrr-->>rrffssttaattee ==== RRFF__FFRREEEE)) ||||
!! ((rrffppttrr-->>rrffmmooddee && RRFF__MMOODDEE__WW)) )) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** FFoorrmm wwrriittee rreeqquueesstt **//
mmssgg..rrff__ttyyppee == hhttoonnss((RRFF__MMSSGG__WWRREEQQ));;
mmssgg..rrff__ssttaattuuss == hhttoonnss((00));;
mmssgg..rrff__sseeqq == 00;;
//** RRffssccoommmm wwiillll sseett sseeqquueennccee
**//
ffrroomm == rrffppttrr-->>rrffnnaammee;;
ttoo == mmssgg..rrff__nnaammee;;
mmeemmsseett((ttoo,, NNUULLLLCCHH,, RRFF__NNAAMMLLEENN));;
//** SSttaarrtt nnaammee aass aallll zzeerroo bbyytteess **//
lleenn == 00;;
wwhhiillee (( ((**ttoo++++ == **ffrroomm++++)) )) {{
//** CCooppyy nnaammee ttoo rreeqquueesstt
**//
iiff ((++++lleenn >>== RRFF__NNAAMMLLEENN)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}}
}} 
wwhhiillee (( ((**ttoo++++ == **ffrroomm++++)) )) {{
//** CCooppyy nnaammee iinnttoo rreeqquueesstt
**//
;;
}} 
mmssgg..rrff__ppooss == hhttoonnll((rrffppttrr-->>rrffppooss));;//** SSeett ffiillee ppoossiittiioonn
**//
mmssgg..rrff__lleenn == hhttoonnll((ccoouunntt));;
//** SSeett ccoouunntt ooff bbyytteess ttoo wwrriittee
**//
ffoorr ((ii==00;; ii<<ccoouunntt;; ii++++)) {{
//** CCooppyy ddaattaa iinnttoo mmeessssaaggee
**//
mmssgg..rrff__ddaattaa[[ii]] == **bbuuffff++++;;

534 
A Remote File Mechanism 
Chap. 20
}} 
wwhhiillee ((ii << RRFF__DDAATTAALLEENN)) {{
mmssgg..rrff__ddaattaa[[ii++++]] == NNUULLLLCCHH;;
}} 
//** SSeenndd mmeessssaaggee aanndd rreecceeiivvee rreessppoonnssee **//
rreettvvaall == rrffssccoommmm((((ssttrruucctt rrff__mmssgg__hhddrr **))&&mmssgg,,
ssiizzeeooff((ssttrruucctt rrff__mmssgg__wwrreeqq)),,
((ssttrruucctt rrff__mmssgg__hhddrr **))&&rreesspp,,
ssiizzeeooff((ssttrruucctt rrff__mmssgg__wwrreess)) ));;
//** CChheecckk rreessppoonnssee **//
iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((rreettvvaall ==== TTIIMMEEOOUUTT)) {{
kkpprriinnttff((""TTiimmeeoouutt dduurriinngg rreemmoottee ffiillee rreeaadd\\nn""));;
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} eellssee iiff ((nnttoohhss((rreesspp..rrff__ssttaattuuss)) !!== 00)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
//** RReeppoorrtt rreessuullttss ttoo ccaalllleerr **//
rrffppttrr-->>rrffppooss ++== nnttoohhll((rreesspp..rrff__lleenn));;
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn nnttoohhll((rreesspp..rrff__lleenn));;
}}
As with a read operation, rflwrite begins by checking the count argument, verify-
ing that the pseudo-device is open and the mode allows writing.  Rflwrite then forms a 
request message and uses rfscomm to send the message to the server.
Unlike a read request, an outgoing write request contains data. Thus, when form-
ing the request, rflwrite copies data from the user’s buffer into the request message.
When a response arrives, the response message does not contain a copy of the data that 
has been written. Thus, rflwrite uses the status field in the message to determine 
whether to report success or failure to the caller.

Sec. 20.14        Seeking On A Remote File (rflseek) 
535
20.14 Seeking On A Remote File (rflseek)
How should a seek operation be implemented for our remote file system? There
are two possibilities. In one design, the system sends a message to the remote server,
and the remote server seeks to the specified location in the file. In the other design, all 
location data is kept on the local computer, and each request to the server contains an 
explicit file position.
Our implementation uses the latter: the current file position is stored in the control 
block entry for a remote file device. When read is called, rflread requests data from the 
server and updates the file position in the control block entry accordingly. The remote 
server does not record a position because each request includes explicit position infor-
mation. An exercise considers a consequence of the design.
Because all file position information is stored on the client, a seek operation can be 
performed locally. That is, the software stores the file position in the control block en-
try for use on the next read or write operation. Function rflseek performs the seek
operation on a remote file device. The code can be found in file rflseek.c:
//** rrffllsseeeekk..cc -- rrffllsseeeekk **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrffllsseeeekk
--
CChhaannggee tthhee ccuurrrreenntt ppoossiittiioonn iinn aann ooppeenn ffiillee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrffllsseeeekk ((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
uuiinntt3322 ppooss
//** NNeeww ffiillee ppoossiittiioonn
**//
))
{{
ssttrruucctt
rrffllccbbllkk **rrffppttrr;;
//** PPooiinntteerr ttoo ccoonnttrrooll bblloocckk
**//
//** WWaaiitt ffoorr eexxcclluussiivvee aacccceessss **//
wwaaiitt((RRff__ddaattaa..rrff__mmuutteexx));;
//** VVeerriiffyy rreemmoottee ffiillee ddeevviiccee iiss ooppeenn **//
rrffppttrr == &&rrffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
iiff ((rrffppttrr-->>rrffssttaattee ==== RRFF__FFRREEEE)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}}

536 
A Remote File Mechanism 
Chap. 20
//** SSeett tthhee nneeww ppoossiittiioonn **//
rrffppttrr-->>rrffppooss == ppooss;;
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn OOKK;;
}}
The code is trivial. After obtaining exclusive access, rflseek verifies that the de-
vice has been opened. It then stores the file position argument in field rfpos of the con-
trol block, signals the mutual exclusion semaphore, and returns. There is no need to 
contact the remote server.
20.15 Character I/O On A Remote File (rflgetc, rflputc)
Using a remote file server to read and write individual bytes of data is expensive 
because a message must be sent to the server for each byte. Rather than prohibit char-
acter I/O, our implementations of getc and putc, call rflread and rflwrite, respectively. 
Thus, we allow a programmer to decide whether the cost is reasonable. Files rflgetc.c 
and rflputc.c contain the code.
//** rrffllggeettcc..cc -- rrffllggeettcc **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
rrffllggeettcc
--
RReeaadd oonnee cchhaarraacctteerr ffrroomm aa rreemmoottee ffiillee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrffllggeettcc((
ssttrruucctt
ddeennttrryy
**ddeevvppttrr
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
))
{{
cchhaarr
cchh;;
//** CChhaarraacctteerr ttoo rreeaadd
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee
**//
rreettvvaall == rrffllrreeaadd((ddeevvppttrr,, &&cchh,, 11));;
iiff ((rreettvvaall !!== 11)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
rreettuurrnn ((ddeevvccaallll))cchh;;
}}

Sec. 20.15        Character I  /O On A Remote File (rflgetc, rflputc) 
537
//** rrffllppuuttcc..cc -- rrffllppuuttcc **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
rrffllppuuttcc
--
WWrriittee oonnee cchhaarraacctteerr ttoo aa rreemmoottee ffiillee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrffllppuuttcc((
ssttrruucctt
ddeennttrryy
**ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
cchh
//** CChhaarraacctteerr ttoo wwrriittee
**//
))
{{
ssttrruucctt
rrffllccbbllkk **rrffppttrr;;
//** PPooiinntteerr ttoo rrffll ccoonnttrrooll bblloocckk **//
rrffppttrr == &&rrffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
iiff ((rrffllwwrriittee((ddeevvppttrr,, &&cchh,, 11)) !!== 11)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
rreettuurrnn OOKK;;
}}
20.16 Remote File System Control Functions (rfscontrol)
Several file operations are needed beyond open, read, write, and close. For exam-
ple, it may be necessary to delete a file. The Xinu remote file system uses the control 
function to implement such functions. The table in Figure 20.3 lists the set of symbolic 
constants used for control functions along with the meaning of each.

Constant 
Meaning

RFS_CTL_DEL 
Delete the named file

RFS_CTL_TRUNC 
Truncate a named file to zero bytes

RFS_CTL_MKDIR 
Make a directory

RFS_CTL_RMDIR 
Remove a directory

RFS_CTL_SIZE 
Return the current size of a file in bytes


































Figure 20.3  Control functions used with the remote file system.

538 
A Remote File Mechanism 
Chap. 20
Because they refer to operations outside individual files, control operations are per-
formed on the master device, RFILESYS, rather than on an individual file pseudo-
device. Driver function rfscontrol implements the control operation; the code can be
found in file rfscontrol.c:
//** rrffssccoonnttrrooll..cc -- rrffssccoonnttrrooll **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** rrffssccoonnttrrooll
--
PPrroovviiddee ccoonnttrrooll ffuunnccttiioonnss ffoorr tthhee rreemmoottee ffiillee ssyysstteemm
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrffssccoonnttrrooll ((
ssttrruucctt ddeennttrryy
**ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
iinntt3322
ffuunncc,,
//** AA ccoonnttrrooll ffuunnccttiioonn
**//
iinntt3322
aarrgg11,,
//** AArrgguummeenntt ##11
**//
iinntt3322
aarrgg22
//** AArrgguummeenntt ##22
**//
))
{{
iinntt3322
lleenn;;
//** LLeennggtthh ooff nnaammee
**//
ssttrruucctt
rrff__mmssgg__ssrreeqq mmssgg;;
//** BBuuffffeerr ffoorr ssiizzee rreeqquueesstt
**//
ssttrruucctt
rrff__mmssgg__ssrreess rreesspp;;
//** BBuuffffeerr ffoorr ssiizzee rreessppoonnssee
**//
ssttrruucctt
rrffllccbbllkk **rrffppttrr;;
//** PPooiinntteerr ttoo eennttrryy iinn rrffllttaabb
**//
cchhaarr
**ttoo,, **ffrroomm;;
//** UUsseedd dduurriinngg nnaammee ccooppyy
**//
iinntt3322
rreettvvaall;;
//** RReettuurrnn vvaalluuee
**//
//** WWaaiitt ffoorr eexxcclluussiivvee aacccceessss **//
wwaaiitt((RRff__ddaattaa..rrff__mmuutteexx));;
//** CChheecckk lleennggtthh aanndd ccooppyy ((nneeeeddeedd ffoorr ssiizzee)) **//
rrffppttrr == &&rrffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;
ffrroomm == rrffppttrr-->>rrffnnaammee;;
ttoo == mmssgg..rrff__nnaammee;;
lleenn == 00;;
mmeemmsseett((ttoo,, NNUULLLLCCHH,, RRFF__NNAAMMLLEENN));;
//** SSttaarrtt nnaammee aass aallll zzeerrooeess
**//
wwhhiillee (( ((**ttoo++++ == **ffrroomm++++)) )) {{
//** CCooppyy nnaammee ttoo mmeessssaaggee
**//
lleenn++++;;
iiff ((lleenn >>== ((RRFF__NNAAMMLLEENN -- 11)) )) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}}
}}

Sec. 20.16        Remote File System Control Functions (rfscontrol) 
539
sswwiittcchh ((ffuunncc)) {{
//** DDeelleettee aa ffiillee **//
ccaassee RRFFSS__CCTTLL__DDEELL::
iiff ((rrffssnnddmmssgg((RRFF__MMSSGG__DDRREEQQ,, ((cchhaarr **))aarrgg11)) ==== SSYYSSEERRRR)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
bbrreeaakk;;
//** TTrruunnccaattee aa ffiillee **//
ccaassee RRFFSS__CCTTLL__TTRRUUNNCC::
iiff ((rrffssnnddmmssgg((RRFF__MMSSGG__TTRREEQQ,, ((cchhaarr **))aarrgg11)) ==== SSYYSSEERRRR)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
bbrreeaakk;;
//** MMaakkee aa ddiirreeccttoorryy **//
ccaassee RRFFSS__CCTTLL__MMKKDDIIRR::
iiff ((rrffssnnddmmssgg((RRFF__MMSSGG__MMRREEQQ,, ((cchhaarr **))aarrgg11)) ==== SSYYSSEERRRR)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
bbrreeaakk;;
//** RReemmoovvee aa ddiirreeccttoorryy **//
ccaassee RRFFSS__CCTTLL__RRMMDDIIRR::
iiff ((rrffssnnddmmssgg((RRFF__MMSSGG__XXRREEQQ,, ((cchhaarr **))aarrgg11)) ==== SSYYSSEERRRR)) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
bbrreeaakk;;
//** OObbttaaiinn ccuurrrreenntt ffiillee ssiizzee ((nnoonn--ssttaannddaarrdd mmeessssaaggee ssiizzee)) **//
ccaassee RRFFSS__CCTTLL__SSIIZZEE::
//** HHaanndd--ccrraafftt aa ssiizzee rreeqquueesstt mmeessssaaggee **//

540 
A Remote File Mechanism 
Chap. 20
mmssgg..rrff__ttyyppee == hhttoonnss((RRFF__MMSSGG__SSRREEQQ));;
mmssgg..rrff__ssttaattuuss == hhttoonnss((00));;
mmssgg..rrff__sseeqq == 00;;
//** RRffssccoommmm wwiillll sseett tthhee sseeqq nnuumm **//
//** SSeenndd tthhee rreeqquueesstt ttoo sseerrvveerr aanndd oobbttaaiinn aa rreessppoonnssee
**//
rreettvvaall == rrffssccoommmm(( ((ssttrruucctt rrff__mmssgg__hhddrr **))&&mmssgg,,
ssiizzeeooff((ssttrruucctt rrff__mmssgg__ssrreeqq)),,
((ssttrruucctt rrff__mmssgg__hhddrr **))&&rreesspp,,
ssiizzeeooff((ssttrruucctt rrff__mmssgg__ssrreess)) ));;
iiff (( ((rreettvvaall ==== SSYYSSEERRRR)) |||| ((rreettvvaall ==== TTIIMMEEOOUUTT)) )) {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} eellssee {{
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn nnttoohhll((rreesspp..rrff__ssiizzee));;
}}
ddeeffaauulltt::
kkpprriinnttff((""rrffssccoonnttrrooll:: ffuunnccttiioonn %%dd nnoott vvaalliidd\\nn"",, ffuunncc));;
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn SSYYSSEERRRR;;
}} 
ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;
rreettuurrnn OOKK;;
}}
For all the control functions, argument arg1 contains a pointer to a null-terminated 
file name. After it obtains exclusive access and checks the length of the file name, 
rfscontrol uses the function argument to choose among several cases that correspond to 
file deletion, file truncation, directory creation, directory deletion, or a file size request. 
In each case, rfscontrol must send a message to the remote server and receive a 
response.
Except for a file size request, all messages to the server only include the common 
header fields. Therefore, for all functions except a size request, rfscontrol uses function 
rfsndmsg to generate and send a request to the remote server. For a size request, rfscon-
trol creates a message in variable msg, and uses rfscomm to send the message and re-
ceive a response. To avoid scanning the file name twice, rfscontrol copies the file name 
into the name field of variable msg as it checks the length of the name. Thus, no extra 
copy is needed when rfscontrol creates a size request. If a valid response arrives to a 
size request, rfscontrol extracts the file size from the response, converts it to local byte 
order, and returns the size to the caller. In all other cases, rfscontrol returns a status of 
either OK or SYSERR.

Sec. 20.17        Initializing The Remote File System (rfsinit, rflinit) 
541
20.17 Initializing The Remote File System (rfsinit, rflinit)
Because the design includes both a remote file system master device and a set of 
remote file pseudo-devices, two initialization functions are needed. The first, rfsinit, in-
itializes the control block associated with the master device.
Data for the master device is kept in global variable Rf_data. Rfsinit fills in fields 
of the structure with the remote server’s IP address and UDP port number. It also allo-
cates a mutual exclusion semaphore and stores the semaphore ID in the structure. 
Rfsinit sets field rf_registered to FALSE, indicating that before communication with the 
server is possible, the UDP port of the server must be registered with the network code. 
File rfsinit.c contains the code:
//** rrffssiinniitt..cc -- rrffssiinniitt **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt
rrffddaattaa
RRff__ddaattaa;;
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
rrffssiinniitt
--
IInniittiiaalliizzee tthhee rreemmoottee ffiillee ssyysstteemm mmaasstteerr ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrffssiinniitt((
ssttrruucctt ddeennttrryy **ddeevvppttrr
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
))
{{
//** CChhoooossee aann iinniittiiaall mmeessssaaggee sseeqquueennccee nnuummbbeerr **//
RRff__ddaattaa..rrff__sseeqq == 11;;
//** SSeett tthhee sseerrvveerr IIPP aaddddrreessss,, sseerrvveerr ppoorrtt,, aanndd llooccaall ppoorrtt **//
iiff (( ddoott22iipp((RRFF__SSEERRVVEERR__IIPP,, &&RRff__ddaattaa..rrff__sseerr__iipp)) ==== SSYYSSEERRRR )) {{
ppaanniicc((""iinnvvaalliidd IIPP aaddddrreessss ffoorr rreemmoottee ffiillee sseerrvveerr""));;
}} 
RRff__ddaattaa..rrff__sseerr__ppoorrtt == RRFF__SSEERRVVEERR__PPOORRTT;;
RRff__ddaattaa..rrff__lloocc__ppoorrtt == RRFF__LLOOCC__PPOORRTT;;
//** CCrreeaattee aa mmuuttuuaall eexxcclluussiioonn sseemmaapphhoorree **//
iiff (( ((RRff__ddaattaa..rrff__mmuutteexx == sseemmccrreeaattee((11)))) ==== SSYYSSEERRRR )) {{
ppaanniicc((""CCaannnnoott ccrreeaattee rreemmoottee ffiillee ssyysstteemm sseemmaapphhoorree""));;
}}

542 
A Remote File Mechanism 
Chap. 20
//** SSppeecciiffyy tthhaatt tthhee sseerrvveerr ppoorrtt iiss nnoott yyeett rreeggiisstteerreedd **//
RRff__ddaattaa..rrff__rreeggiisstteerreedd == FFAALLSSEE;;
rreettuurrnn OOKK;;
}}
Function rflinit handles initialization of individual remote file devices. The code
can be found in file rflinit.c:
//** rrfflliinniitt..cc -- rrfflliinniitt **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttrruucctt
rrffllccbbllkk rrffllttaabb[[NNrrffll]];;
//** RReemmoottee ffiillee ccoonnttrrooll bblloocckkss
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
rrfflliinniitt
--
IInniittiiaalliizzee aa rreemmoottee ffiillee ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll rrfflliinniitt((
ssttrruucctt ddeennttrryy **ddeevvppttrr
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
))
{{
ssttrruucctt
rrffllccbbllkk **rrffllppttrr;;
//** PPttrr.. ttoo ccoonnttrrooll bblloocckk eennttrryy
**//
iinntt3322
ii;;
//** WWaallkkss tthhrroouugghh nnaammee aarrrraarryy
**//
rrffllppttrr == &&rrffllttaabb[[ ddeevvppttrr-->>ddvvmmiinnoorr ]];;
//** IInniittiiaalliizzee eennttrryy ttoo uunnuusseedd **//
rrffllppttrr-->>rrffssttaattee == RRFF__FFRREEEE;;
rrffllppttrr-->>rrffddeevv == ddeevvppttrr-->>ddvvnnuumm;;
ffoorr ((ii==00;; ii<<RRFF__NNAAMMLLEENN;; ii++++)) {{
rrffllppttrr-->>rrffnnaammee[[ii]] == NNUULLLLCCHH;;
}} 
rrffllppttrr-->>rrffppooss == rrffllppttrr-->>rrffmmooddee == 00;;
rreettuurrnn OOKK;;
}}
Rflinit sets the state of the entry to RF_FREE to indicate that the entry is currently 
unused. It also zeroes the name and mode fields. If the state is marked RF_FREE, no  
references should occur to other fields of the entry. Placing zeroes in the fields aids de-
bugging.

Sec. 20.18        Perspective
543
20.18 Perspective
As with a local file system, the most complex decision involved in the design of a 
remote file system arises from the need to choose a balance between efficiency and 
sharing. To understand the choice, imagine multiple applications running on multiple 
computers all sharing a single file. At one extreme, to guarantee last-write semantics on 
a shared file, each file operation must be sent to the remote server so the requests can 
be serialized and operations can be applied to the file in the order they occur. At the 
other extreme, efficiency is maximized when a computer can cache files (or parts of 
files) and access items from the local cache. The goal is to devise a remote file system 
that maximizes performance when no sharing occurs, guarantees correctness in the pres-
ence of sharing, and transitions gracefully and automatically between the two extremes.
Sharing a remote file among multiple clients creates some unexpected subtleties.
For example, consider the seek operation. Suppose a process on computer 1 writes
1000 bytes to a file. Then a process on computer 2 seeks to the end of the file and
writes an additional 1000 bytes. Unless it contacts the server, the file access software
on computer 1 cannot know that the file has been extended. Therefore, the software 
cannot determine whether a seek operation is valid without contacting the server. More 
important, the size of the file can continue to change while the communication takes 
place.
20.19 Summary
A remote file access mechanism allows applications running on a client computer
to access files stored on a remote server. The example design uses a device paradigm
in which an application calls open on the remote file system master device to obtain the
ID of an individual remote file pseudo-device. The application can then use read and 
write on the pseudo-device.
When an application accesses a remote file, the remote file software creates a mes-
sage, sends the message to the remote file server, waits for a response, and interprets the 
response. The software transmits each request multiple times in case the network drops 
a packet or the server is too busy to answer.
Operations such as file deletion, file truncation, creating and removing directories, 
and determining the current size of a file are handled with the control function. As with 
data transfer operations, each call to control results in the transmission of a request mes-
sage and a response from the server.

544 
A Remote File Mechanism 
Chap. 20
EXERCISES
20.1  
Modify the remote file server and rflclose. Arrange to have rflclose send a message to
the server when a file is closed, and have the server send a response.
20.2 
The underlying protocol limits a read request to RF_DATALEN bytes, and rflread rejects
any call that specifies more. Modify rflread to allow a user to request an arbitrary size,
but still limit the size in a request message to RF_DATALEN (i.e., don’t reject large re-
quests, but limit the data returned to RF_DATALEN bytes).
20.3 
As an alternative to the exercise above, devise a system in which rflread permits a caller
to specify an arbitrary size read and sends multiple requests to the server to satisfy the 
request.
20.4      The code in rflgetc calls rflread directly. What potential problem does such a direct call
introduce? Modify the code to use the device switch table when making the call.
20.5 
Our design keeps position information on the client side, which makes seek extremely
efficient. What limitation does the design impose? Hint: consider shared files.
20.6     Consider an alternative design for the remote file system that improves efficiency. Ar-
range rflread so it always requests RF_DATALEN bytes, even if the caller requests
fewer. Place extra bytes in a cache, making them available to subsequent calls.
20.7 
In the previous exercise, what is the chief disadvantage of caching data for subsequent
reads? Hint: consider shared access to the server.
20.8 
Consider what happens if two clients attempt to use the remote file server at the same
time. When the clients boot, they each start their packet sequence number at 1, which 
makes the probability of conflict high. Revise the system to use a random starting se-
quence number (and revise the server to accept arbitrary sequence numbers).
20.9      Redesign the remote file system to allow multiple clients to share a given file.

Chapter Contents
21.1 
Introduction, 547
21.2 
Transparency And A Namespace Abstraction, 547
21.3 
Myriad Naming Schemes, 548
21.4 
Naming System Design Alternatives, 550
21.5 
Thinking About Names Syntactically, 550
21.6 
Patterns And Replacements, 551
21.7 
Prefix Patterns, 551
21.8 
Implementation Of A Namespace, 552
21.9 
Namespace Data Structures And Constants, 552
21.10 Adding Mappings To The Namespace Prefix Table, 553 
21.11 Mapping Names With The Prefix Table, 555
21.12 Opening A Named File, 559 
21.13 Namespace Initialization, 560
21.14 Ordering Entries In The Prefix Table, 562 
21.15 Choosing A Logical Namespace, 563
21.16 A Default Hierarchy And The Null Prefix, 564 
21.17 Additional Object Manipulation Functions, 564
21.18 Advantages And Limits Of The Namespace Approach, 566 
21.19 Generalized Patterns, 566
21.20 Perspective, 567 
21.21 Summary, 568


21
A Syntactic Namespace
A rose by any other name ...
— William Shakespeare
21.1 Introduction
Chapter 14 outlines a set of device-independent I/O operations, including read and 
write, and shows how a device switch table provides an efficient mapping between
high-level operations and the driver functions for each device. Later chapters describe 
how device drivers are organized, and provide examples. The previous chapters illus-
trate how a file system fits into the device paradigm, and illustrate the concept of 
pseudo-devices.
This chapter considers a generalization of device names. It explains how names
can be viewed syntactically, and shows that both devices and files can be represented in
a single unified namespace.
21.2 Transparency And A Namespace Abstraction
Transparency forms one of the fundamental principles in operating system design:
Whenever possible, applications should remain unaware of implemen-
tation details such as the location of an object or its representation.
547

548 
A Syntactic Namespace 
Chap. 21
For example, when an application creates a new process, the application does not 
need to know the location of the code or the location of the stack that is allocated. 
Similarly, when an application opens a local file, the application does not need to know 
which disk blocks the file occupies.
In terms of file access, the Xinu paradigm seems to violate the principle of trans-
parency because it requires the user to specify a file system name when opening a file. 
For example, the master device for the local file system is named LFILESYS. When a
Xinu system includes a remote file system, the violation of transparency becomes obvi-
ous: a programmer must also know the master device for the remote file system, 
RFILESYS, and must choose between local and remote files. Furthermore, a file name 
must be chosen to match the naming convention used on the specified file system.
How can we add transparency to file and device naming? The answer lies in a 
high-level abstraction called a namespace. Conceptually, a namespace provides a uni-
form set of names that knits together apparently diverse file naming schemes into a sin-
gle unified whole, allowing users to open files and devices without knowing their loca-
tion. The Unix operating system uses a directory abstraction to provide a namespace: 
local files, remote files, and devices are each assigned names in a hierarchical directory 
namespace. For example, the name / dev/ console usually corresponds to the system 
console device and the name / dev/ usb corresponds to the USB device.
Xinu takes a novel approach to the namespace abstraction by separating the 
namespace mechanism from the underlying files and directories. Furthermore, Xinu
uses a syntactic approach, which means that the namespace examines names without 
understanding their meaning. What makes our implementation of the namespace espe-
cially fascinating is its combination of simplicity and power. By thinking of names as 
strings, we can understand their similarity. By using the relationship between prefix 
strings and trees, we can manipulate names easily. By following the principle of access 
transparency, we can improve the system dramatically. Adding just a small layer of 
software to existing mechanisms will allow us to unify naming completely.
Before looking at namespace mechanisms, we will review a few examples of file 
naming to understand the problem at hand. Following the discussion of file names, we 
will look at a general-purpose syntactic naming scheme, and then examine a simpler, 
less general solution. Finally, we will examine an implementation of the simplified 
scheme.
21.3 Myriad Naming Schemes
The problem designers face when inventing a namespace can be summarized: they 
must glue together myriad unrelated naming schemes, each of which has evolved into a 
self-contained system. On some systems, file names specify the storage device on 
which the file resides. On others, the filename includes a suffix that tells the type of the 
file (older systems used suffixes to specify a version for the file). Other systems map 
all files into a single flat namespace in which each name is merely a string of al-
phanumeric characters. The following sections give examples of file names on several

Sec. 21.3        Myriad Naming Schemes 
549
systems, and help the reader understand the types and formats of names our namespace 
must accommodate.
21.3.1  MS-DOS
Names in MS-DOS consist of two parts: a device specification and a file name. 
Syntactically, an MS-DOS name has the form X:file, where X is a single letter that 
designates the device on which the file resides and file is the name of the file. Typical-
ly, the letter C denotes the system hard disk, which means a name like C:abc refers to 
file abc on the hard disk.
21.3.2  Unix
Unix organizes files into a hierarchical, tree structured directory system. A file
name is either relative to the current directory or a full path name that specifies a path
from the root of the directory tree to a file.
Syntactically, full path names consist of slash-separated components, where each 
intermediate component specifies a directory and the final component specifies a file. 
Thus, the Unix name /homes/xinu/x refers to file x in subdirectory xinu, which is found 
in subdirectory homes, which is contained in the root directory. The root directory itself 
is named by a single slash (/). Notice that the prefix /homes/xinu/ refers to a directory, 
and that the names of all files in that directory share the prefix.
The importance of the prefix property will become apparent later. For now, it is
sufficient to remember that the tree structure relates to a name prefix:
When components in a file name specify a path through a tree-
structured directory, the names of all files that reside in the same 
directory share a common prefix that denotes the directory.
21.3.3  V System
A research operating system known as the V system allowed a user to specify a 
context and a name; the system used the context to resolve the name. The syntax used 
brackets to enclose the context. Thus, [ctx] abc refers to file abc in context ctx. Usual-
ly, one thinks of each context as a set of files on a particular remote file server.
21.3.4  IBIS
The research operating system, IBIS, provides yet another syntax for multiple-
machine connections that has been adopted for use with Linux commands, such as scp. 
In IBIS, names have the form machine:path, where machine denotes a particular com-
puter system, and path is the file name on that machine (e.g., a Unix full path name).

550 
A Syntactic Namespace 
Chap. 21
21.4 Naming System Design Alternatives
We seek a single naming system that provides a unified view of all possible file 
names, independent of the location of the file or the operating system under which it re-
sides. It seems that a designer could choose between two basic approaches in solving 
the problem: define yet another file naming scheme, or adopt an existing naming 
scheme. Surprisingly, the Xinu namespace uses neither of these two approaches. In-
stead, it adds a syntactic naming mechanism that accommodates many underlying nam-
ing schemes, while allowing the user to choose a uniform interface to the naming 
software. The namespace software maps names that the user supplies into names ap-
propriate for the underlying system.
A naming mechanism that accommodates many underlying schemes has several 
advantages. First, it allows the designer to integrate existing file systems and devices
into a single, uniform namespace, even when implemented by remote servers on a set of 
heterogeneous systems. Second, it permits designers to add new devices or file systems 
without requiring recompilation of the application programs that use them. Third, it 
avoids two unattractive extremes. At one extreme, choosing the simplest naming 
scheme ensures that all file systems can handle the names, but means that the user can-
not take advantage of the complexity offered by some servers. At the other extreme, 
choosing a naming scheme that encompasses the most complex cases means that an ap-
plication which takes advantage of the complexity may not be able to run on a less so-
phisticated file system.
21.5 Thinking About Names Syntactically
To understand how to handle names, think of them syntactically: a name is merely 
a string of characters. Consequentially, a namespace can be created that transforms 
strings. The namespace does not need to provide files and directories, nor does it need 
to understand the semantics of each underlying file system. Instead, the namespace 
maps strings from a uniform representation chosen by the user into strings appropriate 
for each particular subsystem. For example, the namespace might translate the string clf 
into the string C:long_file_name.
What makes a syntactic namespace powerful? Syntactic manipulation is both natu-
ral and flexible. Thus, it is easy to specify and understand as well as easy to adapt to
many underlying naming schemes. A user can imagine a consistent set of names, and
can use the namespace software to translate them into the forms required by underlying 
file systems. For example, suppose a system has access to a local file system that uses 
MS-DOS naming and a remote file system that uses Unix full path names. The user 
might adopt the Unix full path name syntax for all names, making the local disk names 
start with /local. In such a scheme, the name /local/abc would refer to file abc on the 
local hard drive, while the name /etc/passwd would refer to a remote file. The 
namespace must translate /local/abc into C:abc so the local MS-DOS file system can

Sec. 21.5        Thinking About Names Syntactically 
551
understand it, but would pass /etc/passwd on to the remote Unix file system without 
change.
21.6 Patterns And Replacements
Exactly how should a syntactic namespace operate? One convenient method uses a 
pattern string to specify the name syntax and a replacement string to specify the map-
ping. For example, consider the pattern replacement pair:
""//llooccaall""
""CC::""
which means “translate all occurrences of the string /local into the string C: ”.
How should patterns be formed? Patterns that consist of literal strings cannot
specify replacement unambiguously. In the previous example, the pattern works well
on strings like /local/x, but it fails on strings like /homes/local/bin because /local is an 
internal substring that should not be changed. To be effective, more powerful patterns 
are needed. For example, Unix pattern matching tools introduce meta-characters that 
specify how matching should be performed. A carat (sometimes called up-arrow) 
matches the beginning of a string. Thus, the Unix pattern:
""^^//llooccaall""
""CC::""
specifies that /local only matches at the beginning of a string. Unfortunately, imple-
mentations that allow arbitrary patterns and replacements tend to be cumbersome and 
the patterns become difficult to read. A more efficient solution is needed.
21.7 Prefix Patterns
The problem at hand is to find a useful pattern-replacement mechanism that allows 
the user to specify how names map onto a subsystem without introducing more com-
plexity than is needed. Before thinking about complex patterns, consider what can be 
done with patterns that consist of literal strings. The key is to imagine files organized 
into a hierarchy, and to use the prefix property to understand why patterns should speci-
fy prefixes.
In a hierarchy, name prefixes group files into subdirectories, making it easy to de-
fine the relationship between names and the underlying file systems or devices. Fur-
thermore, each prefix can be represented by a literal string. The point is:
Restricting name replacement to prefixes means it is possible to use 
literal strings to separate underlying file systems into distinct parts of 
a name hierarchy.

552 
A Syntactic Namespace 
Chap. 21
21.8 Implementation Of A Namespace
A concrete example will clarify the details of how a syntactic namespace uses the 
pattern-replacement paradigm, and will show how the namespace hides subsystem de-
tails. In the example, patterns will consist of fixed strings, and only prefixes will be 
matched. Later sections discuss alternative implementations and generalizations.
The example implementation of a namespace consists of a pseudo-device, 
NAMESPACE, that programs use to open a named object. An application program in-
vokes open on the NAMESPACE device, passing a name and mode as arguments. The 
NAMESPACE pseudo-device uses a set of prefix patterns to transform the name into a 
new name, and then passes the new name to the appropriate underlying device through 
a call to open. We will see that all files and devices can be part of the namespace, 
meaning that an application never needs to open a device other than the NAMESPACE 
pseudo-device.
The next sections present the namespace software, beginning with declarations of 
the basic data structures and culminating in the definition of the NAMESPACE pseudo-
device. Following the declarations, two functions are presented that transform names 
according to the prefix patterns. The two functions are used by the most important 
piece of namespace software: a function that implements open for the NAMESPACE 
pseudo-device. Later sections show examples that illustrate how the NAMESPACE is 
used.
21.9 Namespace Data Structures And Constants
File name.h contains declarations for the data structures and constants used in the
Xinu namespace.
//** nnaammee..hh **//
//** CCoonnssttaannttss tthhaatt ddeeffiinnee tthhee nnaammeessppaaccee mmaappppiinngg ttaabbllee ssiizzeess **//
##ddeeffiinnee NNMM__PPRREELLEENN
6644
//** MMaaxx ssiizzee ooff aa pprreeffiixx ssttrriinngg
**//
##ddeeffiinnee NNMM__RREEPPLLLLEENN
9966
//** MMaaxxiimmuumm ssiizzee ooff aa rreeppllaacceemmeenntt**//
##ddeeffiinnee NNMM__MMAAXXLLEENN
225566
//** MMaaxxiimmuumm ssiizzee ooff aa ffiillee nnaammee
**//
##ddeeffiinnee NNNNAAMMEESS
4400
//** NNuummbbeerr ooff pprreeffiixx ddeeffiinniittiioonnss **//
//** DDeeffiinniittiioonn ooff tthhee nnaammee pprreeffiixx ttaabbllee tthhaatt ddeeffiinneess aallll nnaammee mmaappppiinnggss **//
ssttrruucctt
nnmmeennttrryy {{
//** DDeeffiinniittiioonn ooff pprreeffiixx ttaabbllee
**//
cchhaarr
nnpprreeffiixx[[NNMM__PPRREELLEENN]];;
//** NNuullll--tteerrmmiinnaatteedd pprreeffiixx
**//
cchhaarr
nnrreeppllaaccee[[NNMM__RREEPPLLLLEENN]];;
//** NNuullll--tteerrmmiinnaatteedd rreeppllaacceemmeenntt
**//
ddiidd3322
nnddeevviiccee;;
//** DDeevviiccee ddeessccrriippttoorr ffoorr pprreeffiixx **//
}};;

Sec. 21.9        Namespace Data Structures And Constants 
553
eexxtteerrnn
ssttrruucctt
nnmmeennttrryy nnaammeettaabb[[]];;
//** TTaabbllee ooff nnaammee mmaappppiinnggss
**//
eexxtteerrnn
iinntt3322
nnnnaammeess;;
//** NNuummbbeerr ooff eennttrriieess aallllooccaatteedd
**//
The principle data structure is array nametab, which holds up to NNAMES entries. 
Each entry consists of a prefix pattern string, a replacement string, and a device ID. 
External integer nnames holds a count of the valid entries in nametab.
21.10 Adding Mappings To The Namespace Prefix Table
Function mount is used to add mappings to the prefix table. As expected, mount
takes three arguments: a prefix string, a replacement string, and a device ID. File
mount.c contains the code.
//** mmoouunntt..cc -- mmoouunntt,, nnaammlleenn **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
mmoouunntt
--
AAdddd aa pprreeffiixx mmaappppiinngg ttoo tthhee nnaammee ssppaaccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssyyssccaallll mmoouunntt((
cchhaarr
**pprreeffiixx,,
//** PPrreeffiixx ttoo aadddd
**//
cchhaarr
**rreeppllaaccee,,
//** RReeppllaacceemmeenntt ssttrriinngg
**//
ddiidd3322
ddeevviiccee
//** DDeevviiccee IIDD ttoo uussee
**//
)) 
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
nnmmeennttrryy **nnaammppttrr;;
//** PPooiinntteerr ttoo uunnuusseedd ttaabbllee eennttrryy**//
iinntt3322
ppssiizz,, rrssiizz;;
//** SSiizzeess ooff pprreeffiixx && rreeppllaacceemmeenntt**//
iinntt3322
ii;;
//** CCoouunntteerr ffoorr ccooppyy lloooopp
**//
mmaasskk == ddiissaabbllee(());;
ppssiizz == nnaammlleenn((pprreeffiixx,, NNMM__PPRREELLEENN));;
rrssiizz == nnaammlleenn((rreeppllaaccee,, NNMM__RREEPPLLLLEENN));;
//** IIff aarrgguummeennttss aarree iinnvvaalliidd oorr ttaabbllee iiss ffuullll,, rreettuurrnn eerrrroorr **//
iiff (( ((ppssiizz ==== SSYYSSEERRRR))
|||| ((rrssiizz ==== SSYYSSEERRRR)) ||||
((iissbbaaddddeevv((ddeevviiccee)))) |||| ((nnnnaammeess >>== NNNNAAMMEESS)) )) {{
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}}

554 
A Syntactic Namespace 
Chap. 21
//** AAllllooccaattee aa sslloott iinn tthhee ttaabbllee **//
nnaammppttrr == &&nnaammeettaabb[[nnnnaammeess]];;
//** NNeexxtt uunnuusseedd eennttrryy iinn ttaabbllee
**//
//** ccooppyy pprreeffiixx aanndd rreeppllaacceemmeenntt ssttrriinnggss aanndd rreeccoorrdd ddeevviiccee IIDD **//
ffoorr ((ii==00;; ii<<ppssiizz;; ii++++)) {{
//** CCooppyy pprreeffiixx iinnttoo ttaabbllee eennttrryy **//
nnaammppttrr-->>nnpprreeffiixx[[ii]] == **pprreeffiixx++++;;
}} 
ffoorr ((ii==00;; ii<<rrssiizz;; ii++++)) {{
//** CCooppyy rreeppllaacceemmeenntt iinnttoo eennttrryy
**//
nnaammppttrr-->>nnrreeppllaaccee[[ii]] == **rreeppllaaccee++++;;
}} 
nnaammppttrr-->>nnddeevviiccee == ddeevviiccee;;
//** RReeccoorrdd tthhee ddeevviiccee IIDD
**//
nnnnaammeess++++;;
//** IInnccrreemmeenntt nnuummbbeerr ooff nnaammeess
**//
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
nnaammlleenn
--
CCoommppuuttee tthhee lleennggtthh ooff aa ssttrriinngg ssttooppppiinngg aatt mmaaxxlleenn
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinntt3322
nnaammlleenn((
cchhaarr
**nnaammee,,
//** NNaammee ttoo uussee
**//
iinntt3322
mmaaxxlleenn
//** MMaaxxiimmuumm lleennggtthh ((iinncclluuddiinngg aa
**//
//**
NNUULLLLCCHH))
**//
)) 
{{
iinntt3322
ii;;
//** CCoouunntt ooff cchhaarraacctteerrss ffoouunndd
**//
//** SSeeaarrcchh uunnttiill aa nnuullll tteerrmmiinnaattoorr oorr lleennggtthh rreeaacchheess mmaaxx **//
ffoorr ((ii==00;; ii << mmaaxxlleenn;; ii++++)) {{
iiff ((**nnaammee++++ ==== NNUULLLLCCHH)) {{
rreettuurrnn ii++11;;
//** IInncclluuddee NNUULLLLCCHH iinn lleennggtthh **//
}}
}} 
rreettuurrnn SSYYSSEERRRR;;
}}

Sec. 21.10        Adding Mappings To The Namespace Prefix Table 
555
If any of the arguments are invalid or the table is full, mount returns SYSERR. 
Otherwise, it increments nnames to allocate a new entry in the table and fills in the
values.
21.11 Mapping Names With The Prefix Table
Once a prefix table has been created, name translation can be performed. Mapping 
consists of finding a prefix match and substituting the corresponding replacement string. 
Function nammap performs translation. The code can be found in file nammap.c:
//** nnaammmmaapp..cc -- nnaammmmaapp,, nnaammrreeppll,, nnaammccppyy **//
##iinncclluuddee <<xxiinnuu..hh>>
ssttaattuuss
nnaammccppyy((cchhaarr **,, cchhaarr **,, iinntt3322));;
ddiidd3322
nnaammrreeppll((cchhaarr **,, cchhaarr[[]]));;
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
nnaammmmaapp
--
UUssiinngg nnaammeessppaaccee,, mmaapp nnaammee ttoo nneeww nnaammee aanndd nneeww ddeevviiccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll nnaammmmaapp((
cchhaarr
**nnaammee,,
//** TThhee nnaammee ttoo mmaapp
**//
cchhaarr
nneewwnnaammee[[NNMM__MMAAXXLLEENN]],,
//** BBuuffffeerr ffoorr mmaappppeedd nnaammee
**//
ddiidd3322 nnaammddeevv
//** IIDD ooff tthhee nnaammeessppaaccee ddeevviiccee
**//
))
{{
ddiidd3322
nneewwddeevv;;
//** DDeevviiccee ddeessccrriippttoorr ttoo rreettuurrnn
**//
cchhaarr
ttmmppnnaammee[[NNMM__MMAAXXLLEENN]];;
//** TTeemmppoorraarryy bbuuffffeerr ffoorr nnaammee
**//
iinntt3322
iitteerr;;
//** NNuummbbeerr ooff iitteerraattiioonnss
**//
//** PPllaaccee oorriiggiinnaall nnaammee iinn tteemmppoorraarryy bbuuffffeerr aanndd nnuullll tteerrmmiinnaattee **//
iiff ((nnaammccppyy((ttmmppnnaammee,, nnaammee,, NNMM__MMAAXXLLEENN)) ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** RReeppeeaatteeddllyy ssuubbssttiittuuttee tthhee nnaammee pprreeffiixx uunnttiill aa nnoonn--nnaammeessppaaccee
**//
//**
ddeevviiccee iiss rreeaacchheedd oorr aann iitteerraattiioonn lliimmiitt iiss eexxcceeeeddeedd
**//
ffoorr ((iitteerr==00;; iitteerr<<nnnnaammeess ;; iitteerr++++)) {{
nneewwddeevv == nnaammrreeppll((ttmmppnnaammee,, nneewwnnaammee));;
iiff ((nneewwddeevv !!== nnaammddeevv)) {{

556 
A Syntactic Namespace 
Chap. 21
nnaammccppyy((ttmmppnnaammee,, nneewwnnaammee,, NNMM__MMAAXXLLEENN));;
rreettuurrnn nneewwddeevv;;
//** EEiitthheerr vvaalliidd IIDD oorr SSYYSSEERRRR
**//
}}
}} 
rreettuurrnn SSYYSSEERRRR;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
nnaammrreeppll
--
UUssee tthhee nnaammee ttaabbllee ttoo ppeerrffoorrmm pprreeffiixx ssuubbssttiittuuttiioonn
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddiidd3322
nnaammrreeppll((
cchhaarr
**nnaammee,,
//** OOrriiggiinnaall nnaammee
**//
cchhaarr
nneewwnnaammee[[NNMM__MMAAXXLLEENN]]
//** BBuuffffeerr ffoorr mmaappppeedd nnaammee
**//
))
{{
iinntt3322
ii;;
//** IItteerraattee tthhrroouugghh nnaammee ttaabbllee
**//
cchhaarr
**ppppttrr;;
//** WWaallkkss tthhrroouugghh aa pprreeffiixx
**//
cchhaarr
**rrppttrr;;
//** WWaallkkss tthhrroouugghh aa rreeppllaacceemmeenntt
**//
cchhaarr
**ooppttrr;;
//** WWaallkkss tthhrroouugghh oorriiggiinnaall nnaammee
**//
cchhaarr
**nnppttrr;;
//** WWaallkkss tthhrroouugghh nneeww nnaammee
**//
cchhaarr
oolleenn;;
//** LLeennggtthh ooff oorriiggiinnaall nnaammee
**//
//**
iinncclluuddiinngg tthhee NNUULLLL bbyyttee
**//
iinntt3322
pplleenn;;
//** LLeennggtthh ooff aa pprreeffiixx ssttrriinngg
**//
//**
**nnoott** iinncclluuddiinngg NNUULLLL bbyyttee
**//
iinntt3322
rrlleenn;;
//** LLeennggtthh ooff rreeppllaaccmmeenntt ssttrriinngg
**//
iinntt3322
rreemmaaiinn;;
//** BByytteess iinn nnaammee bbeeyyoonndd pprreeffiixx
**//
ssttrruucctt
nnmmeennttrryy **nnaammppttrr;;
//** PPooiinntteerr ttoo aa ttaabbllee eennttrryy
**//
//** SSeeaarrcchh nnaammee ttaabbllee ffoorr ffiirrsstt pprreeffiixx tthhaatt mmaattcchheess **//
ffoorr ((ii==00;; ii<<nnnnaammeess;; ii++++)) {{
nnaammppttrr == &&nnaammeettaabb[[ii]];;
ooppttrr == nnaammee;;
//** SSttaarrtt aatt bbeeggiinnnniinngg ooff nnaammee
**//
ppppttrr == nnaammppttrr-->>nnpprreeffiixx;; //** SSttaarrtt aatt bbeeggiinnnniinngg ooff pprreeffiixx **//
//** CCoommppaarree pprreeffiixx ttoo ssttrriinngg aanndd ccoouunntt pprreeffiixx ssiizzee **//
ffoorr ((pplleenn==00;; **ppppttrr !!== NNUULLLLCCHH ;; pplleenn++++)) {{
iiff ((**ppppttrr !!== **ooppttrr)) {{
bbrreeaakk;;
}} 
ppppttrr++++;;
ooppttrr++++;;
}}

Sec. 21.11        Mapping Names With The Prefix Table 
557
iiff ((**ppppttrr !!== NNUULLLLCCHH)) {{
//** PPrreeffiixx ddooeess nnoott mmaattcchh **//
ccoonnttiinnuuee;;
}} 
//** FFoouunndd aa mmaattcchh -- cchheecckk tthhaatt rreeppllaacceemmeenntt ssttrriinngg pplluuss
**//
//** bbyytteess rreemmaaiinniinngg aatt tthhee eenndd ooff tthhee oorriiggiinnaall nnaammee wwiillll **//
//** ffiitt iinnttoo nneeww nnaammee bbuuffffeerr..
IIggnnoorree nnuullll oonn rreeppllaacceemmeenntt**//
//** ssttrriinngg,, bbuutt kkeeeepp nnuullll oonn rreemmaaiinnddeerr ooff nnaammee..
**//
oolleenn == nnaammlleenn((nnaammee ,,NNMM__MMAAXXLLEENN));;
rrlleenn == nnaammlleenn((nnaammppttrr-->>nnrreeppllaaccee,,NNMM__MMAAXXLLEENN)) -- 11;;
rreemmaaiinn == oolleenn -- pplleenn;;
iiff (( ((rrlleenn ++ rreemmaaiinn)) >> NNMM__MMAAXXLLEENN)) {{
rreettuurrnn ((ddiidd3322))SSYYSSEERRRR;;
}} 
//** PPllaaccee rreeppllaacceemmeenntt ssttrriinngg ffoolllloowweedd bbyy rreemmaaiinnddeerr ooff
**//
//**
oorriiggiinnaall nnaammee ((aanndd nnuullll)) iinnttoo tthhee nneeww nnaammee bbuuffffeerr
**//
nnppttrr == nneewwnnaammee;;
rrppttrr == nnaammppttrr-->>nnrreeppllaaccee;;
ffoorr ((;; rrlleenn>>00 ;; rrlleenn----)) {{
**nnppttrr++++ == **rrppttrr++++;;
}} 
ffoorr ((;; rreemmaaiinn>>00 ;; rreemmaaiinn----)) {{
**nnppttrr++++ == **ooppttrr++++;;
}} 
rreettuurrnn nnaammppttrr-->>nnddeevviiccee;;
}} 
rreettuurrnn ((ddiidd3322))SSYYSSEERRRR;;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
nnaammccppyy
--
CCooppyy aa nnaammee ffrroomm oonnee bbuuffffeerr ttoo aannootthheerr,, cchheecckkiinngg lleennggtthh
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
nnaammccppyy((
cchhaarr
**nneewwnnaammee,,
//** BBuuffffeerr ttoo hhoolldd ccooppyy
**//
cchhaarr
**oollddnnaammee,,
//** BBuuffffeerr ccoonnttaaiinniinngg nnaammee
**//
iinntt3322
bbuufflleenn
//** SSiizzee ooff bbuuffffeerr ffoorr ccooppyy
**//
))
{{
cchhaarr
**nnppttrr;;
//** PPooiinntt ttoo nneeww nnaammee
**//
cchhaarr
**ooppttrr;;
//** PPooiinntt ttoo oolldd nnaammee
**//

558 
A Syntactic Namespace 
Chap. 21
iinntt3322
ccnntt;;
//** CCoouunntt ooff cchhaarraacctteerrss ccooppiieedd
**//
nnppttrr == nneewwnnaammee;;
ooppttrr == oollddnnaammee;;
ffoorr ((ccnntt==00;; ccnntt<<bbuufflleenn;; ccnntt++++)) {{
iiff (( ((**nnppttrr++++ == **ooppttrr++++)) ==== NNUULLLLCCHH)) {{
rreettuurrnn OOKK;;
}}
}} 
rreettuurrnn SSYYSSEERRRR;;
//** BBuuffffeerr ffiilllleedd bbeeffoorree ccooppyy ccoommpplleetteedd
**//
}}
The most interesting aspect of nammap arises because it allows multiple mappings.
In particular, because the namespace is a pseudo-device, it is possible for a user to
specify a mapping back onto the NAMESPACE device. For example, consider the fol-
lowing two entries in nametab:
""//llooccaall//""
""""
LLFFIILLEESSYYSS
""LLFFSS::""
""//llooccaall//""
NNAAMMEESSPPAACCEE
The first entry specifies that if a name begins with /local/, the prefix is removed and the 
name is passed to the local file system. The second entry specifies that LFS: is an ab-
breviation for /local/. That is, the prefix LFS: is replaced by /local/ and the resulting 
string is passed back to the NAMESPACE device for another round of mapping.
Of course, recursive mapping can be dangerous. Consider what can happen if a
user adds the following to the namespace:
""//xx""
""//xx""
NNAAMMEESSPPAACCEE
When presented with a name /xyz, a naive implementation will find prefix /x, make the 
substitution, and call open on the NAMESPACE device, causing an infinite recursion. 
To avoid the problem, our implementation iterates through NAMESPACE replacements 
and limits the total iterations. In particular, the code only permits one iteration for each 
prefix in nametab (i.e., each prefix can be substituted at most once). Of course, nam-
map also limits the size of a name: if a replacement would expand the name to more 
than NM_MAXLEN characters, nammap stops and returns SYSERR.
Nammap begins by copying the original name into local array tmpname. It then 
iterates until the name has been mapped to a device other than the NAMESPACE or the 
iteration limit is reached. During each iteration, nammap calls function namrepl to look 
up the current name and form a replacement.
Function namrepl implements a basic replacement policy. Our example replace-
ment policy is simplistic: namrepl searches the table linearly. A search always begins
with the first entry in the table, and stops as soon as a prefix in the table matches the

Sec. 21.11        Mapping Names With The Prefix Table 
559
string supplied by argument name. Once searching has stopped, nammap forms a
mapped name in argument newname by appending the unmatched portion of the origi-
nal name onto the replacement string. It then returns the device ID from the table entry. 
A later section explains that the design has consequences for users.
21.12 Opening A Named File
Once nammap is available, constructing the upper-half open routine for the 
namespace pseudo-device becomes trivial. Recall that the basic goal is to define a 
namespace pseudo-device, NAMESPACE, such that opening the device causes the sys-
tem to open the appropriate underlying device. Once a name has been mapped and a 
new device identified, namopen merely invokes open. The code is contained in file 
namopen.c.
//** nnaammooppeenn..cc -- nnaammooppeenn **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
nnaammooppeenn
--
OOppeenn aa ffiillee oorr ddeevviiccee bbaasseedd oonn tthhee nnaammee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ddeevvccaallll nnaammooppeenn((
ssttrruucctt ddeennttrryy **ddeevvppttrr,,
//** EEnnttrryy iinn ddeevviiccee sswwiittcchh ttaabbllee **//
cchhaarr
**nnaammee,,
//** NNaammee ttoo ooppeenn
**//
cchhaarr
**mmooddee
//** MMooddee aarrgguummeenntt
**//
))
{{
cchhaarr
nneewwnnaammee[[NNMM__MMAAXXLLEENN]];;
//** NNaammee wwiitthh pprreeffiixx rreeppllaacceedd
**//
ddiidd3322
nneewwddeevv;;
//** DDeevviiccee IIDD aafftteerr mmaappppiinngg
**//
//** UUssee nnaammeessppaaccee ttoo mmaapp nnaammee ttoo aa nneeww nnaammee aanndd nneeww ddeessccrriippttoorr **//
nneewwddeevv == nnaammmmaapp((nnaammee,, nneewwnnaammee,, ddeevvppttrr-->>ddvvnnuumm));;
iiff ((nneewwddeevv ==== SSYYSSEERRRR)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** OOppeenn uunnddeerrllyyiinngg ddeevviiccee aanndd rreettuurrnn ssttaattuuss **//
rreettuurrnn
ooppeenn((nneewwddeevv,, nneewwnnaammee,, mmooddee));;
}}

560 
A Syntactic Namespace 
Chap. 21
21.13 Namespace Initialization
How should initial values be assigned to the prefix table? There are two possible 
approaches: an initialization function could assign initial mappings when it creates the 
namespace data structure, or the initialization function could leave the table empty and 
require the user to add mappings. We chose the former approach.
In terms of initialization, the mechanism should be clear. Because the namespace
has been designed as a pseudo-device, the files resemble a device driver. In particular,
the namespace device includes an initialization function that the system calls when de-
vices are initialized (i.e., when the system calls init for the device at system startup).
Deciding how to initialize a prefix table can be difficult. Therefore, we will exam-
ine the initialization function to see how it constructs a prefix table, and defer the dis-
cussion of actual prefixes until later sections. File naminit.c contains the code for the 
naminit function:
//** nnaammiinniitt..cc -- nnaammiinniitt **//
##iinncclluuddee <<xxiinnuu..hh>>
##iiffnnddeeff RRFFIILLEESSYYSS
##ddeeffiinnee RRFFIILLEESSYYSS
SSYYSSEERRRR
##eennddiiff
##iiffnnddeeff FFIILLEESSYYSS
##ddeeffiinnee FFIILLEESSYYSS
SSYYSSEERRRR
##eennddiiff
##iiffnnddeeff LLFFIILLEESSYYSS
##ddeeffiinnee LLFFIILLEESSYYSS
SSYYSSEERRRR
##eennddiiff
ssttrruucctt
nnmmeennttrryy nnaammeettaabb[[NNNNAAMMEESS]];;
//** TTaabbllee ooff nnaammee mmaappppiinnggss
**//
iinntt3322
nnnnaammeess;;
//** NNuummbbeerr ooff eennttrriieess aallllooccaatteedd
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
nnaammiinniitt
--
IInniittiiaalliizzee tthhee ssyynnttaaccttiicc nnaammeessppaaccee
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
nnaammiinniitt((vvooiidd))
{{
ddiidd3322
ii;;
//** IInnddeexx iinnttoo ddeevvttaabb
**//
ssttrruucctt
ddeennttrryy **ddeevvppttrr;;
//** PPooiinntteerr ttoo ddeevviiccee ttaabbllee eennttrryy**//
cchhaarr
ttmmppssttrr[[NNMM__MMAAXXLLEENN]];;
//** SSttrriinngg ttoo hhoolldd aa nnaammee
**//
ssttaattuuss
rreettvvaall;;
//** RReettuurrnn vvaalluuee
**//
cchhaarr
**ttppttrr;;
//** PPooiinntteerr iinnttoo tteemmppssttrriinngg
**//
cchhaarr
**nnppttrr;;
//** PPooiinntteerr ttoo ddeevviiccee nnaammee
**//

Sec. 21.13        Namespace Initialization 
561
cchhaarr
ddeevvpprreeffiixx[[]] == ""//ddeevv//"";;
//** PPrreeffiixx ttoo uussee ffoorr ddeevviicceess
**//
iinntt3322
lleenn;;
//** LLeennggtthh ooff ccrreeaatteedd nnaammee
**//
cchhaarr
cchh;;
//** SSttoorraaggee ffoorr aa cchhaarraacctteerr
**//
//** SSeett pprreeffiixx ttaabbllee ttoo eemmppttyy **//
nnnnaammeess == 00;;
ffoorr ((ii==00;; ii<<NNDDEEVVSS ;; ii++++)) {{
ttppttrr == ttmmppssttrr;;
nnppttrr == ddeevvpprreeffiixx;;
//** CCooppyy pprreeffiixx iinnttoo ttmmppssttrr **//
lleenn == 00;;
wwhhiillee ((((**ttppttrr++++ == **nnppttrr++++)) !!== NNUULLLLCCHH)) {{
lleenn++++;;
}} 
ttppttrr----;; //** MMoovvee ppooiinntteerr ttoo ppoossiittiioonn bbeeffoorree NNUULLLLCCHH **//
ddeevvppttrr == &&ddeevvttaabb[[ii]];;
nnppttrr == ddeevvppttrr-->>ddvvnnaammee;;
//** MMoovvee ttoo ddeevviiccee nnaammee **//
//** MMaapp ddeevviiccee nnaammee ttoo lloowweerr ccaassee aanndd aappppeenndd **//
wwhhiillee((++++lleenn << NNMM__MMAAXXLLEENN)) {{
cchh == **nnppttrr++++;;
iiff (( ((cchh >>== ’’AA’’)) &&&& ((cchh <<== ’’ZZ’’)))) {{
cchh ++== ’’aa’’ -- ’’AA’’;;
}} 
iiff (( ((**ttppttrr++++ == cchh)) ==== NNUULLLLCCHH)) {{
bbrreeaakk;;
}}
}} 
iiff ((lleenn >> NNMM__MMAAXXLLEENN)) {{
kkpprriinnttff((""nnaammeessppaaccee:: ddeevviiccee nnaammee %%ss ttoooo lloonngg\\rr\\nn"",,
ddeevvppttrr-->>ddvvnnaammee));;
ccoonnttiinnuuee;;
}} 
rreettvvaall == mmoouunntt((ttmmppssttrr,, NNUULLLLSSTTRR,, ddeevvppttrr-->>ddvvnnuumm));;
iiff ((rreettvvaall ==== SSYYSSEERRRR)) {{
kkpprriinnttff((""nnaammeessppaaccee:: ccaannnnoott mmoouunntt ddeevviiccee %%dd\\rr\\nn"",,
ddeevvppttrr-->>ddvvnnaammee));;
ccoonnttiinnuuee;;
}}
}}

562 
A Syntactic Namespace 
Chap. 21
//** AAdddd ootthheerr pprreeffiixxeess ((lloonnggeesstt pprreeffiixx ffiirrsstt)) **//
mmoouunntt((""//ddeevv//nnuullll"",,
"""",,
NNUULLLLDDEEVV));;
mmoouunntt((""//rreemmoottee//"",,
""rreemmoottee::"",, RRFFIILLEESSYYSS));;
mmoouunntt((""//llooccaall//"",,
NNUULLLLSSTTRR,,
LLFFIILLEESSYYSS));;
mmoouunntt((""//ddeevv//"",,
NNUULLLLSSTTRR,,
SSYYSSEERRRR));;
mmoouunntt((""~~//"",,
NNUULLLLSSTTRR,,
LLFFIILLEESSYYSS));;
mmoouunntt((""//"",,
""rroooott::"",,
RRFFIILLEESSYYSS));;
mmoouunntt(("""",,
"""",,
LLFFIILLEESSYYSS));;
rreettuurrnn OOKK;;
}}
Ignore the specific prefix and replacement names and look only at how straightfor-
ward initialization is. After setting the number of valid entries to zero, naminit calls 
mount to add entries to the prefix table, where each entry contains a prefix pattern, re-
placement string, and device id. The for loop iterates through the device switch table. 
For each device, it creates a name of the form /dev/xxx, where xxx is the name of the de-
vice mapped into lower case. Thus, it creates an entry for /dev/console that maps to the 
CONSOLE device. If a process calls:
dd == ooppeenn((NNAAMMEESSPPAACCEE,,""//ddeevv//ccoonnssoollee"",,""rrww""));;
the namespace will invoke open on the CONSOLE device and return the result.
21.14 Ordering Entries In The Prefix Table
The Xinu name replacement policy affects users. To understand how, recall that 
namrepl uses sequential lookup. Therefore, a user must mount names so that sequential 
lookup produces the expected outcome. In particular, our implementation does not 
prohibit overlapping prefixes, and does not warn users if overlaps occur. Consequently, 
if overlapping prefixes occur, a user must ensure that the longest prefix appears earlier 
in the table than shorter prefixes. As an example, consider what happens if the table 
contains two entries as Figure 21.1 illustrates.
                                       Prefix 
Replacement 
Device
                                       "x" 
"" (null string) 
LFILESYS
                                       "xyz" 
"" (null string) 
RFILESYS
                                       



















Figure 21.1 Two entries in a prefix table; the order must be swapped or the
second entry will never be used.

Sec. 21.14        Ordering Entries In The Prefix Table 
563
The first entry maps prefix x to a local file system, and the second entry maps pre-
fix xyz to a remote file system. Unfortunately, because namrepl searches the table 
sequentially, any file name that starts with x will match the first entry and will be 
mapped to the local file system. The second entry will never be used. If the two are 
reversed, however, file names starting with xyz will map onto the remote file system, 
and other names starting with x will map to the local file system. The point is:
Because our implementation searches the table of prefixes sequential-
ly and does not detect overlapping prefixes, a user must insert prefixes 
in reverse order by length, ensuring that the system will match the 
longest prefix first.
21.15 Choosing A Logical Namespace
It is tempting to think of a namespace as merely a mechanism that can be used to 
abbreviate long names. However, focusing on the mechanism can be misleading. The
key to choosing meaningful prefix names lies in thinking of a hierarchy into which files 
can be placed. Then, the namespace design defines the organization of the hierarchy.
Rather than thinking of the namespace as a mechanism that abbrevi-
ates names, we think of all names being organized into a hierarchy. 
Entries in the namespace are chosen to implement the desired hierar-
chy.
Imagine, for a minute, a system that can access files on a local disk as well as files 
on a remote server. Do not think about how to abbreviate specific file names; think in-
stead of how to organize the files. Three possible organizations come to mind as Figure 
21.2 shows.
R
L
L
R
(a) 
(b) 
(c)
Figure 21.2 Three possible hierarchical organizations of local and remote
files: (a) local and remote files at the same level, (b) remote files 
in a subdirectory of local files, and (c) local files as a subdirec-
tory of remote files.

564 
A Syntactic Namespace 
Chap. 21
As in the figure, local and remote files could be placed at equal, but distinct posi-
tions in the hierarchy. Alternatively, the local system could form the main part of the 
hierarchy with remote files as a sub-hierarchy, or the remote files could form the main 
hierarchy with local files as a sub-hierarchy. Among the choices, the size of the two 
file systems and the frequency of access may help determine which organization is 
preferable. For example, if the remote file system has thousands of files while the local 
file system has only ten, it may be natural to think of the remote file system as the main 
hierarchy with the local files grafted onto a sub-hierarchy.
21.16 A Default Hierarchy And The Null Prefix
The Xinu namespace software design can easily support any of the hierarchies
shown in Figure 21.2. In particular, mount permits the user to choose one subsystem as
the default, and organize the remaining files with respect to that hierarchy.
How does a subsystem become the default? First, the prefix for the subsystem 
must be such that it matches all names not matched by other table entries. The null pre-
fix provides guaranteed matching for our example namespace. Second, the default en-
try, which carries the null prefix, must be examined only after all other prefixes have 
been tested. Because nammap searches the prefix table sequentially, the default must be 
placed at the end of the table. If any other entry matches, namrepl will follow the 
match.
Look at naminit again to see how the local file system becomes the default. The
final call to mount inserts the default mapping with a null prefix. Thus, any name that
does not match another prefix will refer to the local file system.
21.17 Additional Object Manipulation Functions
Although it appears to organize all names into a single, unified hierarchy, the 
namespace illustrated above does not provide all needed functionality. To understand 
why, observe that the code only handles the case of opening a named object. Other 
operations on named objects are also possible:
d Testing the existence of an object
d Changing the name of an object
d Deleting an object
Testing the existence of an object. Often software needs to test the existence of an 
object without otherwise affecting the object. It may seem that the following test could
be used to determine whether an object exists.

Sec. 21.17        Additional Object Manipulation Functions 
565
ddeevv == ooppeenn((NNAAMMEESSPPAACCEE"",, ""oobbjjeecctt"",, ""rr""));;
iiff ((ddeevv ==== SSYYSSEERRRR)) {{
...object does not exist
}} eellssee {{
cclloossee((ddeevv));;
...object exists
}}
Unfortunately, a call to open can have side effects. For example, opening a network in-
terface device can cause the system to declare the interface to be available for packet 
transfer. Thus, opening and then closing the device may cause packet transfer to begin, 
even if a process has specifically disabled the interface. To avoid side effects, addition-
al functionality is needed.
Changing the name of an object. Most file systems allow a user to rename files. 
However, two problems arise when the namespace is used. First, because users view all 
files through the namespace, requests to rename files can be ambiguous: should the 
name of the underlying file be changed, or should the mapping in the namespace be 
changed? Although it is possible to include an escape mechanism that allows a user to 
distinguish between abstract names and names used in the underlying system, doing so 
is dangerous because changes to underlying names may no longer map through the 
namespace. Second, if a user specifies changing name α to name β, it may turn out that 
string β maps to a local file system and α maps to a remote file system. Thus, even 
though a user sees a unified hierarchy, a renaming operation may not be allowed (or 
may involve a file copy).
Deleting an object. The reasoning given above applies to object deletion as well. 
That is, because a user views all names through the namespace, a request to delete an 
object must map the name through the namespace to determine the underlying file sys-
tem.
How should deletion, renaming, and testing the existence of an object be imple-
mented? Three possibilities arise: separate functions could be created for each opera-
tion, the device switch table could be expanded, or the control functions could be aug-
mented with additional operations. To understand the first approach, separate functions, 
imagine a function delete_obj that takes a name as an argument. The function would 
use the namespace to map the name to an underlying device, and then invoke the ap-
propriate deletion operation on the device. The second approach consists of expanding 
the device switch table to add additional high-level functions, such as delete, rename, 
and an existence test. That is, in addition to open, read, write, and close operations, add 
new operations that implement the additional functionality. The third approach consists 
of adding functionality to the control function. For example, we could specify that if a 
subsystem implements object deletion, the driver function that implements control must 
honor a DELETE request. Xinu uses a mixture of the first and third approaches. Exer-
cises ask the reader to consider the advantages and disadvantages of expanding the de-
vice switch table.

566 
A Syntactic Namespace 
Chap. 21
21.18 Advantages And Limits Of The Namespace Approach
A syntactic namespace isolates programs from the underlying devices and file sys-
tems, allowing a naming hierarchy to be imagined or changed without changing the 
underlying systems. To appreciate the power of a namespace, consider a system that 
keeps temporary files on a local disk and uses the prefix /tmp/ to distinguish them from 
other files. Moving temporary files to the remote file system consists of changing the 
namespace entry that specifies how to handle prefix /tmp/. Because programs always 
use the namespace when they refer to files, all programs continue to operate correctly 
with no change to the source code. The key point is:
A namespace permits the conceptual naming hierarchy to be reorgan-
ized without requiring recompilation of programs that use it.
Namespace software that uses only prefix patterns cannot handle all hierarchical 
organizations or file mappings. For example, in some Unix systems, the name /dev/tty 
refers to a process’s control terminal, which a server should not use. The namespace 
can prevent accidental access by mapping the prefix /dev/tty onto device ID SYSERR. 
Unfortunately, such a mapping prevents the client from accessing other entries that 
share the same prefix (e.g., /dev/tty1).
Using fixed strings as prefix patterns also prevents the namespace from changing 
separator characters when they occur in the middle of names. For example, suppose a 
computer has two underlying file systems, one of which follows the Unix convention of 
using the slash character to separate components along a path, while the other uses the 
backslash character to separate components. Because it deals only with prefix patterns, 
our example namespace cannot map slashes to backslashes or vice versa unless all pos-
sible prefixes are stored in the namespace.
21.19 Generalized Patterns
Many of the namespace limitations can be overcome by using more general pat-
terns than were described near the beginning of the chapter. For example, if it is possi-
ble to specify a full string match instead of just a prefix match, the problem of distin-
guishing a name like /dev/tty from the name /dev/tty1 can be solved. Full match and 
prefix match can be combined: mount can be modified to have an additional argument 
that specifies the type of match, and the value can be stored in the table entry.
Generalizing patterns to allow more than fixed strings solves additional problems
and keeps all matching information in the pattern itself. For example, suppose charac-
ters have special meanings in a pattern as defined in Figure 21.3:†

†The pattern matching given here corresponds to that used in the Unix sed command.

Sec. 21.19        Generalized Patterns 
567
Character 
Meaning
                                                ↑
match beginning of string
$ 
match end of string
. 
match any single character
* 
repeat 0 or more of a pattern
\ 
take next character in pattern literally
other 
self match as in a fixed string
Figure 21.3  An example definition of generalized patterns.
Thus, a pattern like ↑/dev/tty $ specifies a full match of the string /dev/tty, while a pat-
tern like \$ matches a dollar sign that may be embedded in the string.
Two additional rules are necessary to make generalized pattern matching useful in
the namespace. First, we assume the left-most possible match will be used. Second,
we assume that among all left-most matches, the longest will be selected. The exercises 
suggest how to use these generalized patterns to map the names that fixed prefixes can-
not handle.
21.20 Perspective
The syntax of names has been studied and debated extensively. At one time, each 
operating system had its own naming scheme, and a variety of naming schemes flour-
ished. However, once hierarchical directory systems became prevalent, most operating 
systems adopted a hierarchical naming scheme, and the only differences arise over small 
details, such as whether a forward slash or backslash is used to separate components.
As our design points out, naming is conceptually separate from the underlying file 
and I/O systems, and allows a designer to impose a consistent namespace across all 
underlying facilities. However, the use of a syntactic approach has disadvantages as 
well as advantages. The chief problems arise from semantics: although it provides the 
appearance of uniformity, the namespace introduces ambiguity and confuses semantics. 
For example, if an object is renamed, should the namespace be modified or should the 
name of the underlying object be changed? If the namespace maps two prefixes to the 
same underlying file system, applications that use separate prefixes could inadvertently 
access the same object. If two names map to different underlying file systems, an 
operation such as move that references the names may not be possible or may not work 
as expected. Even an operation such as delete may have unexpected semantics (e.g., 
deleting a local object may move it to the trash, while deleting a remote object per-
manently removes the object).

568 
A Syntactic Namespace 
Chap. 21
21.21 Summary
Dealing with file names is difficult, especially if the operating system supports 
multiple underlying naming schemes. One way to solve the naming problem employs a 
layer of namespace software between applications and the underlying file systems. The 
namespace does not implement files itself, but merely treats names as strings, mapping 
them into forms appropriate for underlying systems based on information in a mapping 
table.
We examined the implementation of a syntactic namespace that uses a pattern-
replacement scheme in which patterns are fixed strings representing name prefixes. The 
software includes a mount that installs a mapping, as well as functions like nammap that 
map names into their target form. Our example namespace uses a NAMESPACE 
pseudo-device that users specify when opening a file. The NAMESPACE pseudo-device 
maps the specified file name, and then opens the designated file.
The namespace software is both elegant and powerful. With only a few functions
and the simplistic notion of prefix matching, it can accommodate many naming
schemes. In particular, it accommodates a remote file system, a local file system, and a
set of devices. However, our simplistic version cannot handle all possible mappings. To 
provide for more complex naming systems, the notion of pattern must be generalized. 
One possible generalization assigns special meanings to some characters in the pattern.
EXERCISES
21.1  
Should users have access to both nammap and namrepl? Why or why not?
21.2  
Look carefully at the code in mount. Will the prefix and replacement strings in nametab
always include a NULL byte? Why or why not?
21.3 
Is it possible to modify mount so it refuses to mount prefix-replacement pairs that can
potentially cause an infinite loop? Why or why not?
21.4 
What is the minimum number of prefix-replacement pairs that can cause nammap to
exceed the maximum string length?
21.5 
Minimize the code in namopen by replacing the body with a single statement consisting
of two function calls.
21.6   Implement an upper-half control function for the NAMESPACE pseudo-device, and
make nammap a control function.
21.7  
Implement generalized pattern matching. Refer to the Unix sed command for additional
ways to define pattern match characters.
21.8 
Build a namespace that has both prefix matches and full string matches.
21.9 
Suppose a namespace uses fixed string patterns, but allows full string matching in addi-
tion to the current prefix matching. Are there instances when it makes sense to have a
full string pattern identical to a prefix pattern? Explain.

Exercises
569
21.10    What additional file manipulation primitives might be needed beside rename, delete, and
existence test?
21.11 
Implement a function unmount that removes a prefix from the mapping table.
21.12 
As written, the namespace functions rely on a user to install patterns in longest-prefix
order. Rewrite the code to allow a user to mount patterns in an arbitrary order, and ar-
range the table by prefix length.
21.13 
Rewrite function mount (either the original or the version in the previous exercise) to
check for overlapping patterns, and report an error.
21.14 
Examine the Network File System technology used with Linux systems that allows re-
mote files to be mapped into the directory hierarchy. What basic file operation is not 
permitted across file systems?


Chapter Contents
22.1 
Introduction, 573
22.2 
Bootstrap: Starting From Scratch, 573
22.3 
An Example Of Booting Over A Network, 574
22.4 
Operating System Initialization, 575
22.5 
Xinu Initialization, 576
22.6 
Xinu System Startup, 579
22.7 
Transforming A Program Into A Process, 583
22.8 
Perspective, 584
22.9 
Summary, 584


22
System Initialization
Only by avoiding the beginning of things can we
escape their end.
— Cyril Connolly
22.1 Introduction
Initialization is the last step of the design process. Designers create a system by 
thinking about the system in an executing state and postponing the details of how to get 
the system started. Thinking about initialization early has the same bad effect as worry-
ing about optimization early: it tends to impose unnecessary constraints on the design, 
and diverts the designer’s attention from important issues to trivial ones.
This chapter describes the steps required to initialize the system, and explains the 
conceptual leap that initialization code makes in switching from a program that executes 
sequentially to a system that supports concurrent processes. We will see that no special 
hardware steps are involved, and understand that concurrency is an abstraction created 
entirely by operating system software.
22.2 Bootstrap: Starting From Scratch
Our discussion of initialization begins with a consideration of system termination. 
Everyone who has worked with a computer system knows that errant programs or mal-
functions in the hardware lead to catastrophic failures popularly called crashes. A crash 
occurs when the hardware attempts an invalid operation because code or data for a 
given operation is incorrect. Users know that when a crash occurs, the contents of 
memory are lost and the operating system must be restarted, which often takes consider-
able time.
573

574 
System Initialization 
Chap. 22
How can a computer that is devoid of operating system code spring into action and 
begin executing? It cannot. Somehow a program must be available before a computer
can start. On the oldest machines, restarting was a painful process because a human 
operator entered the initial program through switches on the front panel. Switches were 
replaced by keyboards, then by I/O devices such as tapes and disks, and eventually by 
Read-Only Memory (ROM), and Flash memory.
Some embedded devices do more than store an initial program in Flash; they store
the entire operating system, which means that the device can start executing immediate-
ly after receiving power (e.g., after the batteries are changed or the device is powered
on). However, most computers take multiple steps when restarting. When power is ap-
plied, the hardware executes an initial startup program from Flash. Although it may in-
clude mechanisms that allow engineers to debug the hardware, an initial program is usu-
ally quite small — its primary function consists of loading and running a larger pro-
gram. In a typical personal computer, for example, the startup program powers on de-
vices (e.g., a display, keyboard, and disk), searches the disk for a bootable operating 
system image, copies the operating system image from disk into memory, and then 
jumps to the entry point of the operating system.
Computer systems that do not have permanent storage or embedded systems may 
use a network: the initial startup program initializes the network interface, and then uses 
the network to download the operating system image from a remote server. Some Eth-
ernet hardware includes firmware and a small onboard processor that can download an 
image network over a network, store the image in memory, and then start the processor 
running the image.
In some cases, multiple steps are used. The initial startup program loads a larger, 
more powerful program, which then loads an operating system. Startup programs ar-
ranged in a sequence to load ever larger startup programs are often called bootstraps, 
and the entire process is known as booting the system.† Older names for the bootstrap 
process include Initial Program Load (IPL) and cold start.
22.3 An Example Of Booting Over A Network
The Galileo platform provides a specific example of a multi-stage bootstrap. Our
lab at Purdue is designed so systems boot over a network. Unfortunately, a Galileo
board does not have the hardware and software needed to boot over a network. Instead, 
when it receives power, a Galileo board runs an initial bootstrap program from the on-
board Flash memory. The initial bootstrap, supplied by the vendor, can search local de-
vices, find a specified image, download the image into memory, and start the processor 
executing the image. In particular, the initial bootstrap program can be configured to 
search the micro SD card for an image.
To enable network booting, we created a second bootstrap program that includes a 
network stack plus code to use the network to download an image. We placed a copy 
of the program on the SD card in each Galileo board. To boot a Galileo board, we 
power-cycle it. We built a special hardware system to handle the task: the system re-
                                †The terminology derives from the phrase “pulling one’s self up by one’s bootstraps,” a seemingly im-
possible task.

Sec. 22.3        An Example Of Booting Over A Network 
575
moves power, waits a short time, and then restores power. Once a Galileo board re-
ceives power, the firmware begins the bootstrap process. The initial bootstrap program 
runs the second stage bootstrap, which uses the lab network to communicate with a 
server.
The server in our lab stores a set of Xinu images, one for each Galileo board. 
When our network bootstrap program sends a request to the server, the server uses the 
MAC address in the packet to choose the correct image, and then downloads the image 
over the network. Figure 22.1 lists the steps.
d Galileo board receives power and runs an initial bootstrap pro-
gram from onboard Flash
d Initial bootstrap copies a second bootstrap from the SD card
into memory
d Second bootstrap runs and uses the network to download a
Xinu image
d Processor jumps to the downloaded Xinu image
Figure 22.1 The multi-step bootstrap used on the Galileo board to boot over
a network.
We took an interesting approach to create a bootstrap program that downloads an 
image from a remote server. Instead of building code from scratch, we took a Xinu sys-
tem, removed all the unneeded modules, and wrote a main program that used the Trivial 
File Transfer Protocol (TFTP) to download an image from a remote server. We call 
the program Xboot (for Xinu bootstrap).
If the Xboot code has been placed in memory, how can Xboot download another 
image without causing problems? The answer lies in a large memory. Instead of build-
ing Xboot to occupy the same memory locations as a standard Xinu image, Xboot is 
configured to run in high memory locations that lie beyond those used by a standard 
image. Thus, there is no conflict because Xboot can load a standard Xinu image into 
low memory without overwriting itself.
22.4 Operating System Initialization
The work of initialization does not end when the processor begins to execute the 
operating system image. Before it is ready to run processes, an operating system must 
initialize modules in the operating system as well as hardware devices. Figure 22.2 lists 
the initialization tasks.

576 
System Initialization 
Chap. 22
d Perform initialization required by the hardware platform
d Initialize the memory management hardware and the free
memory list
d Initialize each operating system module
d Load (if not present) and initialize a device driver for each de-
vice
d Start (or reset) each I/O device
d Transform from a sequential program to a concurrent system
d Create a null process
d Create a process to execute user code (e.g., a desktop)
Figure 22.2  Initialization tasks an operating system performs.
The most important step occurs after the hardware and operating system modules 
have been initialized: the operating system must undergo a metamorphosis, changing it-
self from a program that executes sequentially into an operating system that runs 
processes and supports concurrent execution. In the next sections, we will see what 
happens when Xinu boots, and see exactly how the transformation occurs.
22.5 Xinu Initialization
The underlying hardware handles some of the basic initialization tasks, and the 
bootstrap programs handle others. For example, if the firmware has initialized the bus
and console I/O device, it may be possible for Xinu to use polled I/O (i.e., kputc and 
kprintf) immediately after execution begins. On the Galileo, where the address space is 
not contiguous, the startup program handles the task of finding available addresses. The 
startup program builds a list of available memory blocks and places the list in memory, 
making it available to Xinu.
Although some low-level initialization is completed before Xinu boots, an assem-
bly language initialization function is still required. For example, Xinu must establish
the runtime environment suitable for C. In our code, execution begins at label start,
found in file start.S. The BeagleBone Black startup code provides an example:
//** ssttaarrtt..SS -- ssttaarrtt,, bbzzeerroo **//
##iinncclluuddee <<aarrmmvv77aa..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ssttaarrtt
--
IInniittiiaall eennttrryy ppooiinntt ffoorr aa XXiinnuu iimmaaggee ((AARRMM))
**------------------------------------------------------------------------------------------------------------------------------------------------

Sec. 22.5        Xinu Initialization 
577
**//
..tteexxtt
..gglloobbll
ssttaarrtt
//** DDeeccllaarree eennttrryy ppooiinntt gglloobbaall
**//
ssttaarrtt::
//** LLooaadd tthhee ssttaacckk ppooiinntteerr wwiitthh eenndd ooff mmeemmoorryy **//
llddrr
sspp,, ==MMAAXXAADDDDRR
//** EEnnaabbllee tthhee IInnssttrruuccttiioonn CCaacchhee **//
mmrrcc
pp1155,, 00,, rr00,, cc11,, cc00,, 00
oorrrr
rr00,, rr00,, ##AARRMMVV77AA__CC11CCTTLL__II
mmccrr
pp1155,, 00,, rr00,, cc11,, cc00,, 00
//** UUssee bbzzeerroo ((bbeellooww)) ttoo zzeerroo oouutt tthhee BBSSSS aarreeaa **//
llddrr
rr00,, ==eeddaattaa
llddrr
rr11,, ==eenndd
bbll
bbzzeerroo
//** CCaallll nnuulllluusseerr ttoo iinniittiiaalliizzee tthhee XXiinnuu ssyysstteemm
**//
//**
((NNoottee:: tthhee ccaallll nneevveerr rreettuurrnnss))
**//
bbll
nnuulllluusseerr
//** FFuunnccttiioonn ttoo zzeerroo mmeemmoorryy ((rr00 iiss lloowweesstt aaddddrr;; rr11 iiss hhiigghheesstt))
**//
bbzzeerroo::
mmoovv
rr22,, ##00
//** RRoouunndd aaddddrreessss ttoo mmuullttiippllee
**//
aadddd
rr00,, rr00,, ##33
//**
ooff ffoouurr bbyy aaddddiinngg 33 aanndd
**//
aanndd
rr00,, rr00,, ##00xxFFFFFFFFFFFFFFCC
//**
ttaakkiinngg tthhee rreessuulltt mmoodduullee 44 **//
bblloooopp::
ccmmpp
rr00,, rr11
//** LLoooopp uunnttiill llaasstt aaddddrreessss
**//
bbhhss
bbeexxiitt
//**
hhaass bbeeeenn rreeaacchheedd
**//
ssttrr
rr22,, [[rr00]]
//** ZZeerroo ffoouurr--bbyyttee wwoorrdd ooff mmeemmoorryy**//
aadddd
rr00,, rr00,, ##44
//** MMoovvee ttoo nneexxtt wwoorrdd
**//
bb
bblloooopp
//** CCoonnttiinnuuee ttoo iitteerraattee
**//
bbeexxiitt::
mmoovv
ppcc,, llrr
//** RReettuurrnn ttoo ccaalllleerr
**//
The code sets an initial stack pointer, enables the instruction cache, and calls 
nulluser. Setting the stack pointer is trivial because memory on the BeagleBone Black 
is contiguous and the highest address is specified by the hardware vendor. The code
uses constant MAXADDR.

578 
System Initialization 
Chap. 22
The code to enable the instruction cache seems cryptic, but the explanation is 
straightforward. On an ARM version 7a processor, the co-processor controls the cache.
A bit in the co-processor control register determines whether the cache is enabled or 
disabled. The code fetches a copy of the control register, turns on the cache enable bit 
(constant ARMv7A_C1CTL_I), and stores the result back in the control register. File 
armv7a.h, which is included at the beginning of start.S, contains the definition of indi-
vidual co-processor registers:
//** aarrmmvv77aa..hh **//
//** CCPPSSRR bbiittss **//
##ddeeffiinnee AARRMMVV77AA__CCPPSSRR__AA
00xx0000000000110000
//** IImmpprreecciissee ddaattaa aabboorrtt ddiissaabbllee **//
##ddeeffiinnee AARRMMVV77AA__CCPPSSRR__II
00xx0000000000008800
//** IIRRQQ iinntteerrrruuppttss ddiissaabbllee
**//
##ddeeffiinnee AARRMMVV77AA__CCPPSSRR__FF
00xx0000000000004400
//** FFIIQQ iinntteerrrruuppttss ddiissaabbllee
**//
##ddeeffiinnee AARRMMVV77AA__CCPPSSRR__MMMM
00xx00000000000011FF
//** PPrroocceessssoorr MMooddee MMaasskk
**//
##ddeeffiinnee AARRMMVV77AA__CCPPSSRR__UUSSRR 00xx0000000000001100
//** PPrroocceessssoorr MMooddee == UUsseerr
**//
##ddeeffiinnee AARRMMVV77AA__CCPPSSRR__FFIIQQ 00xx0000000000001111
//** PPrroocceessssoorr MMooddee == FFIIQQ
**//
##ddeeffiinnee AARRMMVV77AA__CCPPSSRR__IIRRQQ 00xx0000000000001122
//** PPrroocceessssoorr MMooddee == IIRRQQ
**//
##ddeeffiinnee AARRMMVV77AA__CCPPSSRR__SSPPRR 00xx0000000000001133
//** PPrroocceessssoorr MMooddee == SSuuppeerrvviissoorr
**//
##ddeeffiinnee AARRMMVV77AA__CCPPSSRR__AABBTT 00xx0000000000001177
//** PPrroocceessssoorr MMooddee == AAbboorrtt
**//
##ddeeffiinnee AARRMMVV77AA__CCPPSSRR__UUNNDD 00xx00000000000011BB
//** PPrroocceessssoorr MMooddee == UUnnddeeffiinneedd
**//
##ddeeffiinnee AARRMMVV77AA__CCPPSSRR__SSYYSS 00xx00000000000011FF
//** PPrroocceessssoorr MMooddee == SSyysstteemm
**//
##ddeeffiinnee AARRMMvv77AA__CCPPSSRR__SSCCMM 00xx0000000000001166
//** PPrroocceessssoorr MMooddee SSeeccuurree MMoonniittoorr**//
//** CCoopprroocceessssoorr cc11 -- CCoonnttrrooll RReeggiisstteerr bbiittss **//
##ddeeffiinnee AARRMMVV77AA__CC11CCTTLL__VV
00xx0000000022000000
//** EExxcceeppttiioonn bbaassee aaddddrr ccoonnttrrooll
**//
##ddeeffiinnee AARRMMVV77AA__CC11CCTTLL__II
00xx0000000011000000
//** IInnssttrruuccttiioonn CCaacchhee eennaabbllee
**//
##ddeeffiinnee AARRMMVV77AA__CC11CCTTLL__CC
00xx0000000000000044
//** DDaattaa CCaacchhee eennaabbllee
**//
##ddeeffiinnee AARRMMVV77AA__CC11CCTTLL__AA
00xx0000000000000022
//** SSttrriicctt aalliiggnnmmeenntt eennaabbllee
**//
##ddeeffiinnee AARRMMVV77AA__CC11CCTTLL__MM
00xx0000000000000011
//** MMMMUU eennaabbllee
**//
//** EExxcceeppttiioonn VVeeccttoorr AAddddrreesssseess **//
##ddeeffiinnee AARRMMVV77AA__EEVV__SSTTAARRTT 00xx44003300CCEE0000
//** EExxcceeppttiioonn vveeccttoorr ssttaarrtt aaddddrr
**//
##ddeeffiinnee AARRMMVV77AA__EEVV__EENNDD
00xx44003300CCEE2200
//** EExxcceeppttiioonn vveeccttoorr eenndd aaddddrr
**//
##ddeeffiinnee AARRMMVV77AA__EEHH__SSTTAARRTT 00xx44003300CCEE2244
//** EExxcceeppttiioonn hhaannddlleerr ssttaarrtt aaddddrr **//
##ddeeffiinnee AARRMMVV77AA__EEHH__EENNDD
00xx44003300CCEE4400
//** EExxcceeppttiioonn hhaannddlleerr eenndd aaddddrr
**//
##ddeeffiinnee AARRMMVV77AA__IIRRQQHH__AADDDDRR 00xx44003300CCEE3388
//** IIRRQQ eexxpp hhaannddlleerr aaddddrreessss
**//
##ddeeffiinnee MMAAXXAADDDDRR 00xxAA00000000000000
//** 551122 MMBB RRAAMM ssttaarrttiinngg ffrroomm 00xx8800000000000000
**//

Sec. 22.6        Xinu System Startup 
579
22.6 Xinu System Startup
As the last step, the code in start.S calls function nulluser. A single program, not 
an operating system, is running when the call occurs.  Nulluser initializes the operating 
system, creates a process to execute function main, and becomes the null process. If 
there is drama in the system, it lies here, where the transformation from program to con-
current system occurs. The code is found in file initialize.c.
//** iinniittiiaalliizzee..cc -- nnuulllluusseerr,, ssyyssiinniitt,, ssiizzmmeemm **//
//** HHaannddllee ssyysstteemm iinniittiiaalliizzaattiioonn aanndd bbeeccoommee tthhee nnuullll pprroocceessss **//
##iinncclluuddee <<xxiinnuu..hh>>
##iinncclluuddee <<ssttrriinngg..hh>>
eexxtteerrnn
vvooiidd
ssttaarrtt((vvooiidd));;
//** SSttaarrtt ooff XXiinnuu ccooddee
**//
eexxtteerrnn
vvooiidd
**__eenndd;;
//** EEnndd ooff XXiinnuu ccooddee
**//
//** FFuunnccttiioonn pprroottoottyyppeess **//
eexxtteerrnn
vvooiidd mmaaiinn((vvooiidd));;
//** MMaaiinn iiss tthhee ffiirrsstt pprroocceessss ccrreeaatteedd
**//
eexxtteerrnn
vvooiidd xxddoonnee((vvooiidd));;
//** SSyysstteemm ""sshhuuttddoowwnn"" pprroocceedduurree
**//
ssttaattiicc
vvooiidd ssyyssiinniitt(());;
//** IInntteerrnnaall ssyysstteemm iinniittiiaalliizzaattiioonn
**//
eexxtteerrnn
vvooiidd mmeemmiinniitt((vvooiidd));;
//** IInniittiiaalliizzeess tthhee ffrreeee mmeemmoorryy lliisstt
**//
//** DDeeccllaarraattiioonnss ooff mmaajjoorr kkeerrnneell vvaarriiaabblleess **//
ssttrruucctt
pprroocceenntt pprrooccttaabb[[NNPPRROOCC]];; //** PPrroocceessss ttaabbllee
**//
ssttrruucctt
sseennttrryy
sseemmttaabb[[NNSSEEMM]];;
//** SSeemmaapphhoorree ttaabbllee
**//
ssttrruucctt
mmeemmbbllkk
mmeemmlliisstt;;
//** LLiisstt ooff ffrreeee mmeemmoorryy bblloocckkss
**//
//** AAccttiivvee ssyysstteemm ssttaattuuss **//
iinntt
pprrccoouunntt;;
//** TToottaall nnuummbbeerr ooff lliivvee pprroocceesssseess
**//
ppiidd3322
ccuurrrrppiidd;;
//** IIDD ooff ccuurrrreennttllyy eexxeeccuuttiinngg pprroocceessss
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
** nnuulllluusseerr -- iinniittiiaalliizzee tthhee ssyysstteemm aanndd bbeeccoommee tthhee nnuullll pprroocceessss
** 
** NNoottee:: eexxeeccuuttiioonn bbeeggiinnss hheerree aafftteerr tthhee CC rruunn--ttiimmee eennvviirroonnmmeenntt hhaass bbeeeenn
** eessttaabblliisshheedd..
IInntteerrrruuppttss aarree iinniittiiaallllyy DDIISSAABBLLEEDD,, aanndd mmuusstt eevveennttuuaallllyy
** bbee eennaabblleedd eexxpplliicciittllyy..
TThhee ccooddee ttuurrnnss iittsseellff iinnttoo tthhee nnuullll pprroocceessss
** aafftteerr iinniittiiaalliizzaattiioonn..
BBeeccaauussee iitt mmuusstt aallwwaayyss rreemmaaiinn rreeaaddyy ttoo eexxeeccuuttee,,

580 
System Initialization 
Chap. 22
** tthhee nnuullll pprroocceessss ccaannnnoott eexxeeccuuttee ccooddee tthhaatt mmiigghhtt ccaauussee iitt ttoo bbee
** ssuussppeennddeedd,, wwaaiitt ffoorr aa sseemmaapphhoorree,, ppuutt ttoo sslleeeepp,, oorr eexxiitt..
IInn
** ppaarrttiiccuullaarr,, tthhee ccooddee mmuusstt nnoott ppeerrffoorrmm II//OO eexxcceepptt ffoorr ppoolllleedd vveerrssiioonnss
** ssuucchh aass kkpprriinnttff..
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
nnuulllluusseerr(())
{{
ssttrruucctt
mmeemmbbllkk
**mmeemmppttrr;;
//** PPttrr ttoo mmeemmoorryy bblloocckk
**//
uuiinntt3322
ffrreeee__mmeemm;;
//** TToottaall aammoouunntt ooff ffrreeee mmeemmoorryy
**//
//** IInniittiiaalliizzee tthhee ssyysstteemm **//
ssyyssiinniitt(());;
kkpprriinnttff((""\\nn\\rr%%ss\\nn\\nn\\rr"",, VVEERRSSIIOONN));;
//** OOuuttppuutt XXiinnuu mmeemmoorryy llaayyoouutt **//
ffrreeee__mmeemm == 00;;
ffoorr ((mmeemmppttrr == mmeemmlliisstt..mmnneexxtt;; mmeemmppttrr !!== NNUULLLL;;
mmeemmppttrr == mmeemmppttrr-->>mmnneexxtt)) {{
ffrreeee__mmeemm ++== mmeemmppttrr-->>mmlleennggtthh;;
}} 
kkpprriinnttff((""%%1100dd bbyytteess ooff ffrreeee mmeemmoorryy..
FFrreeee lliisstt::\\nn"",, ffrreeee__mmeemm));;
ffoorr ((mmeemmppttrr==mmeemmlliisstt..mmnneexxtt;; mmeemmppttrr!!==NNUULLLL;;mmeemmppttrr == mmeemmppttrr-->>mmnneexxtt)) {{
kkpprriinnttff((""
[[00xx%%0088XX ttoo 00xx%%0088XX]]\\rr\\nn"",,
((uuiinntt3322))mmeemmppttrr,, ((((uuiinntt3322))mmeemmppttrr)) ++ mmeemmppttrr-->>mmlleennggtthh -- 11));;
}} 
kkpprriinnttff((""%%1100dd bbyytteess ooff XXiinnuu ccooddee..\\nn"",,
((uuiinntt3322))&&eetteexxtt -- ((uuiinntt3322))&&tteexxtt));;
kkpprriinnttff((""
[[00xx%%0088XX ttoo 00xx%%0088XX]]\\nn"",,
((uuiinntt3322))&&tteexxtt,, ((uuiinntt3322))&&eetteexxtt -- 11));;
kkpprriinnttff((""%%1100dd bbyytteess ooff ddaattaa..\\nn"",,
((uuiinntt3322))&&eebbssss -- ((uuiinntt3322))&&ddaattaa));;
kkpprriinnttff((""
[[00xx%%0088XX ttoo 00xx%%0088XX]]\\nn\\nn"",,
((uuiinntt3322))&&ddaattaa,, ((uuiinntt3322))&&eebbssss -- 11));;
//** EEnnaabbllee iinntteerrrruuppttss **//
eennaabbllee(());;
//** CCrreeaattee aa pprroocceessss ttoo eexxeeccuuttee ffuunnccttiioonn mmaaiinn(()) **//

Sec. 22.6        Xinu System Startup 
581
rreessuummee ((
ccrreeaattee((((vvooiidd **))mmaaiinn,, IINNIITTSSTTKK,, IINNIITTPPRRIIOO,, ""MMaaiinn pprroocceessss"",, 00,,
NNUULLLL))));;
//** BBeeccoommee tthhee NNuullll pprroocceessss ((ii..ee..,, gguuaarraanntteeee tthhaatt tthhee CCPPUU hhaass
**//
//**
ssoommeetthhiinngg ttoo rruunn wwhheenn nnoo ootthheerr pprroocceessss iiss rreeaaddyy ttoo eexxeeccuuttee)) **//
wwhhiillee ((TTRRUUEE)) {{
;;
//** DDoo nnootthhiinngg **//
}}
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
** 
** ssyyssiinniitt
--
IInniittiiaalliizzee aallll XXiinnuu ddaattaa ssttrruuccttuurreess aanndd ddeevviicceess
** 
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattiicc
vvooiidd
ssyyssiinniitt(())
{{
iinntt3322
ii;;
ssttrruucctt
pprroocceenntt **pprrppttrr;;
//** PPttrr ttoo pprroocceessss ttaabbllee eennttrryy
**//
ssttrruucctt
sseennttrryy
**sseemmppttrr;;
//** PPttrr ttoo sseemmaapphhoorree ttaabbllee eennttrryy **//
//** PPllaattffoorrmm SSppeecciiffiicc IInniittiiaalliizzaattiioonn **//
ppllaattiinniitt(());;
//** IInniittiiaalliizzee tthhee iinntteerrrruupptt vveeccttoorrss **//
iinniitteevveecc(());;
//** IInniittiiaalliizzee ffrreeee mmeemmoorryy lliisstt **//
mmeemmiinniitt(());;
//** IInniittiiaalliizzee ssyysstteemm vvaarriiaabblleess **//
//** CCoouunntt tthhee NNuullll pprroocceessss aass tthhee ffiirrsstt pprroocceessss iinn tthhee ssyysstteemm **//
pprrccoouunntt == 11;;
//** SScchheedduulliinngg iiss nnoott ccuurrrreennttllyy bblloocckkeedd **//
DDeeffeerr..nnddeeffeerrss == 00;;

582 
System Initialization 
Chap. 22
//** IInniittiiaalliizzee pprroocceessss ttaabbllee eennttrriieess ffrreeee **//
ffoorr ((ii == 00;; ii << NNPPRROOCC;; ii++++)) {{
pprrppttrr == &&pprrooccttaabb[[ii]];;
pprrppttrr-->>pprrssttaattee == PPRR__FFRREEEE;;
pprrppttrr-->>pprrnnaammee[[00]] == NNUULLLLCCHH;;
pprrppttrr-->>pprrssttkkbbaassee == NNUULLLL;;
pprrppttrr-->>pprrpprriioo == 00;;
}} 
//** IInniittiiaalliizzee tthhee NNuullll pprroocceessss eennttrryy **//
pprrppttrr == &&pprrooccttaabb[[NNUULLLLPPRROOCC]];;
pprrppttrr-->>pprrssttaattee == PPRR__CCUURRRR;;
pprrppttrr-->>pprrpprriioo == 00;;
ssttrrnnccppyy((pprrppttrr-->>pprrnnaammee,, ""pprrnnuullll"",, 77));;
pprrppttrr-->>pprrssttkkbbaassee == ggeettssttkk((NNUULLLLSSTTKK));;
pprrppttrr-->>pprrssttkklleenn == NNUULLLLSSTTKK;;
pprrppttrr-->>pprrssttkkppttrr == 00;;
ccuurrrrppiidd == NNUULLLLPPRROOCC;;
//** IInniittiiaalliizzee sseemmaapphhoorreess **//
ffoorr ((ii == 00;; ii << NNSSEEMM;; ii++++)) {{
sseemmppttrr == &&sseemmttaabb[[ii]];;
sseemmppttrr-->>ssssttaattee == SS__FFRREEEE;;
sseemmppttrr-->>ssccoouunntt == 00;;
sseemmppttrr-->>ssqquueeuuee == nneewwqquueeuuee(());;
}} 
//** IInniittiiaalliizzee bbuuffffeerr ppoooollss **//
bbuuffiinniitt(());;
//** CCrreeaattee aa rreeaaddyy lliisstt ffoorr pprroocceesssseess **//
rreeaaddyylliisstt == nneewwqquueeuuee(());;
//** IInniittiiaalliizzee tthhee rreeaall ttiimmee cclloocckk **//
ccllkkiinniitt(());;
ffoorr ((ii == 00;; ii << NNDDEEVVSS;; ii++++)) {{
iinniitt((ii));;
}}

Sec. 22.6        Xinu System Startup 
583
rreettuurrnn;;
}} 
iinntt3322
ssttoopp((cchhaarr **ss))
{{
kkpprriinnttff((""%%ss\\nn"",, ss));;
kkpprriinnttff((""llooooppiinngg...... pprreessss rreesseett\\nn""));;
wwhhiillee((11))
//** EEmmppttyy **//;;
}} 
iinntt3322
ddeellaayy((iinntt nn))
{{
DDEELLAAYY((nn));;
rreettuurrnn OOKK;;
}}
Nulluser itself is exceedingly simple. It calls function sysinit to initialize the sys-
tem data structures. When sysinit returns, the running program has become the null
process (process 0), but interrupts remain disabled and no other processes exist. After 
printing a few introductory messages, nulluser enables interrupts, and calls create to 
start a process running the user’s main program.
Because the program executing nulluser has become the null process, it cannot 
exit, sleep, wait for a semaphore, or suspend itself. Fortunately, the initialization func-
tion does not perform any action that takes the caller out of the current or ready states. 
If such actions were needed, sysinit would have created another process to handle the 
action. Once initialization is complete and a process has been created to execute the 
user’s main program, the null process falls into an infinite loop, giving resched a proc-
ess to schedule when no user processes are ready to run.
22.7 Transforming A Program Into A Process
Function sysinit handles the task of system initialization. It makes a series of calls
to initialize the hardware platform (platinit), exception vectors (initevec), and the
memory free list (meminit). It initializes remaining system data structures, such as the 
process table and semaphore table, and calls clkinit to initialize the real-time clock. Fi-
nally, sysinit iterates through the devices that have been configured and calls the initiali-
zation function for each device. To do so, it invokes init for the device ID.
The most interesting piece of the initialization code occurs about half-way through 
sysinit when it fills in the process table entry for process zero. Many of the process
table fields, such as the process name field, can be left uninitialized — they are filled in 
merely to make debugging easier. The real work is done by the two lines that set the 
current process ID variable, currpid, to the ID of the null process, and assign PR_CURR

584 
System Initialization 
Chap. 22
to the process state field of the process table entry. Until currpid and the state have
been assigned, rescheduling is impossible. Once the process table entry and currpid
have been assigned, the program has become a currently running process that has proc-
ess ID zero, and is available for context switching.
To summarize:
After it fills in the process table entry for process zero, the code sets 
variable currpid to zero, which transforms the sequential program into 
a process.
Once the null process has been created, all that remains is for sysinit to initialize 
the other pieces of the system before it returns so that all services are available when 
function nulluser starts a process executing the user’s main program. When it is 
resumed, the new process will have a higher priority than the null process. Therefore, 
resched will switch context to the new process, and the scheduling invariant will be in 
effect.
22.8 Perspective
The intellectually significant aspects of operating system design arise when new 
abstractions are created on top of low-level hardware. In the case of system initializa-
tion, the details are not as important as the conceptual transformation: the processor 
starts a fetch-execute cycle running instructions sequentially, and the initialization code 
self-transforms into a concurrent processing system. The important point is that the ini-
tial code does not create a separate, concurrent system and then jump to the new sys-
tem. No leap is made to reach the abstraction, and the original sequential execution is 
not abandoned. Instead, the running code declares itself to be a process, fills in the sys-
tem data structures needed to support the declaration, and eventually allows other 
processes to execute. Meanwhile, the processor continues the fetch-execute cycle, and 
the new abstraction emerges without any disruption.
22.9 Summary
Initialization is the last step of system design; it should be postponed to avoid 
changing the design simply to make initialization easier. Although initialization in-
volves many details, the most conceptually interesting part involves the transformation 
from a sequential program to a system that supports concurrent processing. To make it-
self correspond to the null process, the code fills in the process table entry for process 
zero and sets variable currpid to zero.

Exercises
585
EXERCISES
22.1 
What is the BIOS on an x86 computer, and what does it do?
22.2 
If you were designing a bootstrap loader program, what functionality would you include?
Why?
22.3  
Read about the GRUB and UBOOT bootstrap programs. What functionality does each
provide?
22.4 
Is the order of initialization important for the process table, semaphore table, memory
free list, devices, and ready list? Explain.
22.5 
On many systems, it is possible to create a function sizmem that finds the highest valid
memory address by probing memory until an exception occurs. Is such a function possi-
ble on the example platforms? Why or why not?
22.6 
Explain, by tracing through the functions involved, what would go wrong if nulluser en-
abled interrupts before calling sysinit.
22.7 
The network code, remote disk driver, and remote file system driver each create a proc-
ess. Should the processes be created in sysinit? Why or why not?
22.8 
Most operating systems arrange for the network code to run and obtain an IP address be-
fore the system starts any user processes. Design a way for Xinu to create a network 
process, wait for the network process to obtain an IP address, and then create a process 
to run the main program. Be careful: the null process cannot block.


Chapter Contents
23.1 
Introduction, 589
23.2 
Self-initializing Modules, 590
23.3 
Self-initializing Modules In A Concurrent System, 591
23.4 
Self-initialization In The Presence Of Reboot, 593
23.5 
Initialization Using Accession Numbers, 593
23.6 
A Generalized Memory Marking Scheme, 595
23.7 
Data Declarations For The Memory Marking System, 596
23.8 
Implementation Of Marking, 598
23.9 
Perspective, 599
23.10 Summary, 599


23
Subsystem Initialization And 
Memory Marking
The best thing about endings is knowing that just
ahead lies the daunting task to start over
— Jodi Picoult
23.1 Introduction
The previous chapter considers hardware bootstrap and operating system initializa-
tion. The chapter explains how an operating system starts as a program that executes 
instructions, and how, after initializing system variables and data structures, the initiali-
zation code creates a process to start executing the main function, and then becomes the 
null process.
This chapter extends our examination of initialization by considering two broad 
questions. First, if we divide sets of functions into modules, how can each perform 
self-initialization without relying on a central initialization function? Second, if
modules remain resident in memory across system reboots, how can each module know 
whether it has been reinitialized following the latest reboot? The chapter introduces an 
elegant, compact mechanism called memory marking that allows self-initializing 
modules to be created. The system correctly identifies whether a module needs to be 
reinitialized, even if the module remains resident in memory across a system reboot.
589

590 
Subsystem Initialization And Memory Marking 
Chap. 23
23.2 Self-initializing Modules
We use the term module to refer to a set of functions and the shared data on which 
they operate. Although the C language does not have encapsulation mechanisms that 
permit a programmer to specify modules, we can think of code being divided into con-
ceptual modules. For example, consider the buffer pool mechanism described in 
Chapter 10 and the high-level message passing mechanism described in Chapter 11. In 
each case, a set of functions operates on a shared data structure. The buffer pool 
module offers four primary functions:
poolinit 
mkpool 
getbuf 
freebuf
Each of the functions is written to assume that poolinit will be called before any of
the other functions are invoked. As we have seen, sysinit makes the call to poolinit
when the operating system functions are being initialized. Similarly, sysinit calls ptinit
to initialize the port mechanism.
Relying on sysinit to initialize each module has several disadvantages. First, a pro-
grammer cannot add a new module to the operating system without modifying a funda-
mental system function, sysinit. More important, a programmer must understand which 
other modules a given initialization function uses, and must insert the new initialization 
call after the other modules are initialized. Second, if the initialization call is acciden-
tally omitted, the module may operate incorrectly and cause the system to fail. Third, 
placing a call of the initialization function in sysinit forces the loader to include the ini-
tialization function and shared data items, even if other functions in the module are not 
used. On an embedded system with constrained memory, programmers cannot afford to 
include items that are not needed — if sysinit references all possible modules, the image 
may be too large to fit in memory.
How can a programmer arrange for module initialization without placing an expli-
cit call in sysinit? The answer lies in self-initializing modules. For a conventional C 
program, self-initializing is trivial: declare a global variable with an initial value that 
specifies whether initialization has been performed, and insert code at the beginning of 
each function to test the global variable. For example, Figure 23.1 shows the general 
structure of code for a module that has two functions, func_1 and func_2, plus an ini-
tialization function, func_init. Each function includes an extra line of code that exam-
ines global variable needinit, which is statically initialized to 1. If needinit is 1 when a 
function is called, func_init is invoked to perform initialization.

Sec. 23.2        Self-initializing Modules 
591
//** EExxaammppllee ooff aa sseellff--iinniittiiaalliizziinngg mmoodduullee tthhaatt uusseess aa gglloobbaall vvaarriiaabbllee **//
iinntt3322 nneeeeddiinniitt == 11;;
//** NNoonn--zzeerroo uunnttiill iinniittiiaalliizzeedd
**//
... declarations for other global data structures
vvooiidd
ffuunncc__11((... args)) {{
iiff ((nneeeeddiinniitt)) ffuunncc__iinniitt(());;
//** IInniittiiaalliizzee bbeeffoorree pprroocceeeeddiinngg
**//
... code for func_1
rreettuurrnn;;
}} 
vvooiidd
ffuunncc__22((... args)) {{
iiff ((nneeeeddiinniitt)) ffuunncc__iinniitt(());;
//** IInniittiiaalliizzee bbeeffoorree pprroocceeeeddiinngg
**//
... code for func_2
rreettuurrnn;;
}} 
vvooiidd
ffuunncc__iinniitt((vvooiidd)) {{
iiff ((nneeeeddiinniitt !!== 00)) {{
//** IInniittiiaalliizzaattiioonn iiss nneeeeddeedd
**//
... code to perform initialization
nneeeeddiinniitt == 00;;
}} 
rreettuurrnn;;
}}
Figure 23.1 An example showing the structure of a conventional C program
that uses a global variable to control self-initialization.
Although it works in a conventional program, the approach outlined above does
not suffice for modules in our operating system. There are two reasons: concurrency
and reboot. First we will discuss how to handle concurrency, and then we will look at 
reboot.
23.3 Self-initializing Modules In A Concurrent System
To see what can happen to the module in Figure 23.1 if concurrent processes make 
calls to the functions, consider a worst-case scenario. Suppose two processes, P1  and P2 
attempt to use the module, and consider context switching between them. If one proc-
ess calls function func_1 and the other calls func_2, both processes could be executing 
func_init to initialize global data structures the module uses. One of the processes

592 
Subsystem Initialization And Memory Marking 
Chap. 23
might finish initialization, return to its function, and start using the global data struc-
tures while the other process continues initialization which overwrites the values.
The options for handling concurrent execution consist of disabling interrupts or us-
ing a mutual exclusion semaphore. A mutex semaphore minimizes interference with
other system activities — a process will only block if it attempts to use the module
while another process is already using it. Otherwise, no processes block, and interrupts
are not disabled. However, semaphore creation requires initialization, which means we 
cannot use semaphores to control access to the initialization function. Figure 23.2 illus-
trates a hybrid solution that disables interrupts during initialization, and uses a sema-
phore to provide mutual exclusion for normal execution.
//** AA sseellff--iinniittiiaalliizziinngg mmoodduullee tthhaatt ppeerrmmiittss ccoonnccuurrrreenntt aacccceessss
**//
iinntt3322 nneeeeddiinniitt == 11;;
//** NNoonn--zzeerroo uunnttiill iinniittiiaalliizzeedd
**//
ssiidd3322 mmuutteexx;;
//** MMuuttuuaall eexxcclluussiioonn sseemmaapphhoorree IIDD **//
vvooiidd
ffuunncc__11((... args)) {{
iinnttmmaasskk mmaasskk;;
mmaasskk == ddiissaabbllee(());;
//** DDiissaabbllee dduurriinngg iinniittiiaalliizzaattiioonn **//
iiff ((nneeeeddiinniitt)) ffuunncc__iinniitt(());;
//** IInniittiiaalliizzee bbeeffoorree pprroocceeeeddiinngg
**//
rreessttoorree((mmaasskk));;
//** RReessttoorree iinntteerrrruuppttss
**//
wwaaiitt((mmuutteexx));;
//** UUssee mmuutteexx ffoorr eexxcclluussiivvee aacccceessss**//
... code for func_1
ssiiggnnaall((mmuutteexx));;
//** RReelleeaassee tthhee mmuutteexx
**//
rreettuurrnn;;
}}
. . . other functions in the module structured as above
vvooiidd
ffuunncc__iinniitt((vvooiidd)) {{
iinnttmmaasskk mmaasskk;;
mmaasskk == ddiissaabbllee(());;
iiff ((nneeeeddiinniitt !!== 00)) {{
//** IInniittiiaalliizzaattiioonn iiss ssttiillll nneeeeddeedd**//
mmuutteexx == sseemmccrreeaattee((11));; //** CCrreeaattee tthhee mmuutteexx sseemmaapphhoorree
**//
... code to perform other initialization
nneeeeddiinniitt == 00;;
}} 
rreessttoorree((mmaasskk));;
rreettuurrnn;;
}}
Figure 23.2 An illustration of a self-initializing module that permits con-
current access.

Sec. 23.3        Self-initializing Modules In A Concurrent System 
593
As the code shows, disable and restore are only used when the initialization is test-
ed or performed, which means functions in the module can take arbitrarily long without 
causing problems for devices. Note that func_init disables interrupts even though indi-
vidual functions (e.g., func_1) disable interrupts before calling func_init. The use of 
disable and restore allows func_init to be called directly by a user process or from a 
function in the module. In either case, the initialization function will return to the caller 
with interrupts in the same state as when the call was made. Exercises consider alterna-
tive structures.
Also note that when the initialization finishes, two things will have been accom-
plished. First, the module’s data structures will have been initialized. Second, the mu-
tual exclusion semaphore will have been created, and its ID will have been placed in 
global variable mutex ready for functions in the module to use.
23.4 Self-initialization In The Presence Of Reboot
As an added complication, consider rebooting a system where all code and data 
remain resident in memory. For example, an early version of Xinu allowed reboot to 
avoid slow speed downloading. Rebooting a resident system adds a complication to ini-
tialization because global variables (i.e., variables in the data segment) will not be reset 
to their initial values. For example, consider variable needinit in Figure 23.2. When 
the operating system is loaded, the variable has the value 1. As soon as any of the 
functions in the module are called, initialization will be performed, and needinit will 
have the value 0. If the operating system is restarted, the module will not be reinitial-
ized.
To understand the potential consequences, consider a module that allocates heap 
memory. The initialization function will call getmem, and will save a pointer to the al-
located memory. Functions in the module use the pointer to access the allocated 
memory. When the operating system reboots, all heap memory will be placed on the 
free list, and will be available for allocation. Suppose that after the reboot, the order in 
which processes execute differs from the order in the initial run. It could happen that 
the memory block allocated to a module in the first run of the system is allocated for 
another purpose in the second run. If a module continues to assume it owns the 
memory block that was allocated in the first run, the module can write into a memory 
block owned by another process. Such errors are especially difficult to find.
23.5 Initialization Using Accession Numbers
For systems where the integer size is large and reboots do not occur often, the ini-
tialization problem can be handled with an accession number scheme. The scheme uses
a single global counter for the operating system plus a global counter for each module. 
The operating system counter is used to count how many times the operating system has 
rebooted, and the global variable for each module is used to count the number of times

594 
Subsystem Initialization And Memory Marking 
Chap. 23
the module has been initialized. The value of all counters is initialized to 0 at compile 
time. The operating system boot counter is incremented when sysinit executes, so it 
will be 1 on the first run of the system.
Assuming a module must be initialized once each time the system boots, the use of 
accession numbers should be clear. The module initialization test can be replaced by a 
comparison: the module should be initialized if the system’s boot counter exceeds the 
module’s initialization counter. Figure 23.3 illustrates the use of accession numbers.
//** AA sseellff--iinniittiiaalliizziinngg mmoodduullee uussiinngg aacccceessssiioonn nnuummbbeerrss
**//
eexxtteerrnn iinntt3322
bboooott;;
//** CCoouunntt ooff ttiimmeess OOSS bboooottss
**//
iinntt3322
mmiinniitt == 00;;
//** CCoouunntt ooff mmoodduullee iinniittiiaalliizzaattiioonnss**//
ssiidd3322
mmuutteexx;;
//** MMuuttuuaall eexxcclluussiioonn sseemmaapphhoorree IIDD
**//
vvooiidd
ffuunncc__11((... args)) {{
iiff ((mmiinniitt<<bboooott)) ffuunncc__iinniitt(());;//** IInniittiiaalliizzee bbeeffoorree pprroocceeeeddiinngg
**//
wwaaiitt((mmuutteexx));;
//** UUssee mmuutteexx ffoorr eexxcclluussiivvee aacccceessss **//
... code for func_1
ssiiggnnaall((mmuutteexx));;
//** RReelleeaassee tthhee mmuutteexx
**//
rreettuurrnn;;
}}
. . . other functions in the module structured as above
vvooiidd
ffuunncc__iinniitt((vvooiidd)) {{
iinnttmmaasskk mmaasskk;;
mmaasskk == ddiissaabbllee(());;
iiff ((mmiinniitt << bboooott)) {{
//** IInniittiiaalliizzaattiioonn iiss ssttiillll nneeeeddeedd **//
mmuutteexx == sseemmccrreeaattee((11));; //** CCrreeaattee tthhee mmuutteexx sseemmaapphhoorree
**//
... code to perform other initialization
mmiinniitt++++;;
}} 
rreessttoorree((mmaasskk));;
rreettuurrnn;;
}}
Figure 23.3 Illustration of a self-initializing module using accession numbers
to handle system reboot.

Sec. 23.6        A Generalized Memory Marking Scheme 
595
23.6 A Generalized Memory Marking Scheme
The accession number scheme illustrated in Figure 23.3 makes an important as-
sumption: the reboot counter will never wrap around. On a system with 32-bit integers, 
rebooting once per second and using unsigned arithmetic means the system can run for 
over one-hundred years before the counter wraps around. On 8-bit and 16-bit embedded 
processors, an accession number mechanism will not suffice.
The question arises: how can self-initializing modules work in a concurrent en-
vironment on a processor with a small range of integer values? Of course, one could 
write code to compute 32-bit values using smaller integers. However, the author creat-
ed an elegant and efficient technique to handle the problem. Known as memory mark-
ing, the technique requires almost no overhead and accommodates dynamic module 
loading as well as the static modules described in this chapter.
Memory marking defines a new data type (memmark) and two functions to mani-
pulate the data type:
memmark L; – Declare L to be a location that can be marked 
mark(L); 
– Mark location L
notmarked(L) – Non-zero if location L is not marked
After an operating system reboot, none of the locations in memory has been 
marked. Thererfore, notmarked returns non-zero. After mark has been called to mark a 
location, notmarked returns 0 for that location. It may seem odd that the second func-
tion tests whether a location is unmarked instead of whether the location is marked. 
However, we will see that the most common situation involves taking action when a lo-
cation has not yet been marked. For example, the code for a typical check might ap-
pear:
iiff (( nnoottmmaarrkkeedd((xxxxxx)) )) {{
...code to perform initialization
mmaarrkk((xxxxxx));;
}}
where xxx is a variable declared to be of type memmark. Of course, when used in a 
concurrent processing system, additional code is needed to disable interrupts to guaran-
tee that no other process can interfere with initialization.
Figure 23.4 shows how memory marking facilities can be inserted into a self-
initializing module.

596 
Subsystem Initialization And Memory Marking 
Chap. 23
//** AA sseellff--iinniittiiaalliizziinngg mmoodduullee uussiinngg mmeemmoorryy mmaarrkkiinngg
**//
mmeemmmmaarrkk lloocc;;
//** CCoouunntt ooff mmoodduullee iinniittiiaalliizzaattiioonnss**//
ssiidd3322
mmuutteexx;;
//** MMuuttuuaall eexxcclluussiioonn sseemmaapphhoorree IIDD
**//
vvooiidd
ffuunncc__11((... args)) {{
iiff ((nnoottmmaarrkkeedd((lloocc)))) ffuunncc__iinniitt(());; //** IInniittiiaalliizzee tthhee mmoodduullee
**//
wwaaiitt((mmuutteexx));;
//** UUssee mmuutteexx ffoorr eexxcclluussiivvee aacccceessss **//
... code for func_1
ssiiggnnaall((mmuutteexx));;
//** RReelleeaassee tthhee mmuutteexx
**//
rreettuurrnn;;
}}
. . . other functions in the module structured as above
vvooiidd
ffuunncc__iinniitt((vvooiidd)) {{
iinnttmmaasskk mmaasskk;;
mmaasskk == ddiissaabbllee(());;
iiff ((nnoottmmaarrkkeedd((lloocc)))) {{
mmuutteexx == sseemmccrreeaattee((11));; //** CCrreeaattee tthhee mmuutteexx sseemmaapphhoorree
**//
... code to perform other initialization
mmaarrkk((lloocc));;
}} 
rreessttoorree((mmaasskk));;
rreettuurrnn;;
}}
Figure 23.4  An illustration of a module using memory marking.
23.7 Data Declarations For The Memory Marking System
The implementation of memory marking is surprisingly efficient in both the time 
required and space occupied. In essence, the system stores a list of memory locations 
that have been marked in array marks. The system uses integer nmarks to store an in-
teger count of the number of items currently in the marks array. Each marked location 
is an integer. When the location is marked, the system stores a value in the location
that gives the index in the marks array corresponding to the location.
Testing whether a location L has been marked is straightforward: extract the in-
teger value from location L, call it I. If I is out of range of the marks array or the Ith

Sec. 23.7        Data Declarations For The Memory Marking System 
597
entry in the marks array does not contain L, the location is not marked. File mark.h
contains the data declarations as well as inline function notmarked.
//** mmaarrkk..hh -- nnoottmmaarrkkeedd **//
##ddeeffiinnee MMAAXXMMAARRKK 2200
//** MMaaxxiimmuumm nnuummbbeerr ooff mmaarrkkeedd llooccaattiioonnss
**//
eexxtteerrnn
iinntt3322
**((mmaarrkkss[[]]));;
eexxtteerrnn
iinntt3322
nnmmaarrkkss;;
eexxtteerrnn
ssiidd3322
mmkkmmuutteexx;;
ttyyppeeddeeff iinntt3322
mmeemmmmaarrkk[[11]];;
//** DDeeccllaarree aa mmeemmoorryy mmaarrkk ttoo bbee aann aarrrraayy **//
//**
ssoo uusseerr ccaann rreeffeerreennccee tthhee nnaammee
**//
//**
wwiitthhoouutt aa lleeaaddiinngg &&
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
nnoottmmaarrkkeedd
--
RReettuurrnn nnoonnzzeerroo iiff aa llooccaattiioonn hhaass nnoott bbeeeenn mmaarrkkeedd
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
##ddeeffiinnee nnoottmmaarrkkeedd((LL))
((LL[[00]]<<00 |||| LL[[00]]>>==nnmmaarrkkss |||| mmaarrkkss[[LL[[00]]]]!!==LL))
The memory marking code exploits a C language subtlety to make using memory 
marks easier and safer. In C, the name of an array gives a pointer to the array. When a 
programmer declares a variable to be of type memmark, the result is an integer array 
with one element. For example, when a programmer declares:
mmeemmmmaarrkk
lloocc;;
the compiler allocates storage for a single integer. However, because the type of vari-
able loc is an array rather than an integer, references to loc in a program result in a 
pointer. Therefore, when a programmer writes:
mmaarrkk((lloocc));;
the compiler passes the address of loc without requiring a programmer to remember to 
include an ampersand. The code for notmarked should now be clear: when a program-
mer writes:
nnoottmmaarrkkeedd((lloocc))
to invoke the notmarked macro, argument loc will be an array with one location, not an 
integer. Therefore, to find the integer value stored in loc, the code dereferences the ar-
ray (i.e., refers to loc[0] rather than to loc).

598 
Subsystem Initialization And Memory Marking 
Chap. 23
23.8 Implementation Of Marking
File mark.c contains code for the two remaining functions of the memory marking 
system: markinit and mark. Function markinit is called when the operating system re-
boots (e.g., in Xinu, it is called from sysinit). Markinit sets the count of marked loca-
tions to zero, and allocates a mutual exclusion semaphore. Once markinit has initialized 
the system, modules can call mark to mark a specific location.
//** mmaarrkk..cc -- mmaarrkkiinniitt,, mmaarrkk **//
##iinncclluuddee <<xxiinnuu..hh>>
iinntt3322
**mmaarrkkss[[MMAAXXMMAARRKK]];;
//** PPooiinntteerrss ttoo mmaarrkkeedd llooccaattiioonnss **//
iinntt3322
nnmmaarrkkss;;
//** NNuummbbeerr ooff mmaarrkkeedd llooccaattiioonnss
**//
ssiidd3322
mmkkmmuutteexx;;
//** MMuuttuuaall eexxcclluussiioonn sseemmaapphhoorree
**//
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
mmaarrkkiinniitt
--
CCaalllleedd oonnccee aatt ssyysstteemm ssttaarrttuupp
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
mmaarrkkiinniitt((vvooiidd))
{{
nnmmaarrkkss == 00;;
mmkkmmuutteexx == sseemmccrreeaattee((11));;
}} 
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
mmaarrkk
--
MMaarrkk aa ssppeecciiffiieedd mmeemmoorryy llooccaattiioonn
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
mmaarrkk((
iinntt3322 **lloocc
//** LLooccaattiioonn ttoo mmaarrkk
**//
))
{{
//** IIff llooccaattiioonn iiss aallrreeaaddyy mmaarrkkeedd,, ddoo nnootthhiinngg **//
iiff (( ((**lloocc>>==00)) &&&& ((**lloocc<<nnmmaarrkkss)) &&&& ((mmaarrkkss[[**lloocc]]====lloocc)) )) {{
rreettuurrnn OOKK;;
}} 
//** IIff nnoo mmoorree mmeemmoorryy mmaarrkkss aarree aavvaaiillaabbllee,, iinnddiiccaattee aann eerrrroorr **//

Sec. 23.8        Implementation Of Marking 
599
iiff ((nnmmaarrkkss >>== MMAAXXMMAARRKK)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** OObbttaaiinn eexxcclluussiivvee aacccceessss aanndd mmaarrkk tthhee ssppeecciiffiieedd llooccaattiioonn **//
wwaaiitt((mmkkmmuutteexx));;
mmaarrkkss[[ ((**lloocc)) == nnmmaarrkkss++++ ]] == lloocc;;
ssiiggnnaall((mmkkmmuutteexx));;
rreettuurrnn OOKK;;
}}
One line of code in function mark does the work of marking a location:
mmaarrkkss[[ ((**lloocc)) == nnmmaarrkkss++++ ]] == lloocc;;
The single line increments the number of marks, assigns the original value to the loca-
tion, and uses the number as an index into the marks array to set the entry to the ad-
dress of the location being marked.
23.9 Perspective
Since the publication of the first edition of the Xinu book, engineers have written 
to say they used the memory marking approach when building embedded software sys-
tems. In other words, the mechanism is quite practical. The author originally created 
the memory marking mechanism while he was a graduate student, and the purpose was 
to solve a homework problem in a theory class. Ironically, the professor in the class did 
not appreciate the practicality of the scheme.
Even if you skim over everything else in this chapter, take a moment to look at the 
line of code discussed above. In most languages, marking a memory location would re-
quire multiple lines of code, and would not compile into minimal instructions. In C, the 
source code is incredibly compact, and the compiler can produce an efficient implemen-
tation.
23.10 Summary
Several techniques are available to allow a module to initialize itself. The standard 
programming technique of using an initialized global variable can be extended to a con-
current programming environment by disabling interrupts during initialization. A hy-
brid scheme can restrict disabling interrupts to the initialization code, and can use a mu-
tual exclusion semaphore to allow the functions in the module to execute with interrupts 
enabled.

600 
Subsystem Initialization And Memory Marking 
Chap. 23
The memory marking technique generalizes self-initialization to handle reboot of
an operating system without reloading the image. Memory marking is both efficient
and elegant. The implementation uses the trick of declaring an array of one location to 
allow a programmer to declare a memory mark, x, pass the name x as an argument to 
notmarked and mark, even though the functions require an address.
EXERCISES
23.1 
The module shown in Figure 23.2 arranges for function func_1 to disable interrupts be-
fore the if statement that checks global variable needinit, and restore interrupts afterward. 
Argue that removing the calls to disable and restore in func_1 will not change correct-
ness.
23.2 
Extend the previous exercise by removing the calls to disable, restore, and the condition-
al check of needinit (i.e., simply have func_1 call func_init and then wait on the mutex).
Show that the resulting code is still correct. What is the advantage of keeping the if 
statement?
23.3 
Can multiple processes call notmarked and mark concurrently or will problems result?
Explain.
23.4  
The code in mark can be rewritten to use the notmarked macro. What is the disadvan-
tage of using the macro?
23.5 
Modify the buffer pool functions from Chapter 10 to use memory marking and to be
self-initializing.
23.6 
Consider an operating system that provides dynamic loading (i.e., the system can load a
module into memory at runtime). Is memory marking useful in such a system? Explain.

Chapter Contents
24.1 
Introduction, 603
24.2 
Terminology: Faults, Checks, Traps, And Exceptions, 603
24.3 
Vectored Exceptions And Maskable Interrupts, 604
24.4 
Types Of Exceptions, 604
24.5 
Handling Exceptions, 605
24.6 
Exception Vector Initialization, 606
24.7 
Panic In The Face Of Catastrophic Problems, 606
24.8 
Implementation Of Panic, 607
24.9 
Perspective, 607
24.10 Summary, 608


24
Exception Handling
I never make exceptions. An exception disproves the 
rule.
— Sir Arthur Conan Doyle
24.1 Introduction
This chapter discusses the topic of exception handling. Because the underlying 
hardware dictates exactly how an exception is reported, the techniques an operating sys-
tem uses to handle exceptions depend entirely on the hardware. Therefore, we will 
describe how exceptions are handled on the example platforms, and leave readers to ex-
plore other systems and architectures.
In general, exception handling is concerned with details rather than concepts. 
Therefore, the chapter contains fewer broad concepts than earlier chapters. The reader 
should think of it as an example, and be aware that both the details and techniques may 
change if another hardware system is used.
24.2 Terminology: Faults, Checks, Traps, And Exceptions
A variety of terms have been used to describe problems that can occur during exe-
cution, and various hardware vendors have preferred terminology. Early computers 
used the term check (or machine check) to refer to an internal hardware malfunction.
For example, an early version of Xinu ran on hardware that could detect a power supply 
failure. That is, as the voltage began to fall, the processor informed the operating sys-
tem.†
                                †Although it seems unlikely that an operating system would have time to respond during a power failure, 
on the occasion when a power supply did fail, Xinu was able to print a “power failure” message before losing 
power.
603

604 
Exception Handling 
Chap. 24
Originally, the term fault was used to refer to problems associated with hardware, 
as opposed to errors that are caused by software. When demand paging was invented, 
however, the term page fault was used to describe a condition where a referenced page 
is not resident in memory. As paging became popular, faults became associated with 
page faults, and the distinction between hardware faults and software faults was lost.
When an error situation arises, the hardware must have a way to inform the operat-
ing system. Some vendors use the term trap, and say that the hardware traps to the 
operating system. As we have seen, the hardware must also inform the operating sys-
tem when an I/O device needs service, and hardware is often designed to use a single 
mechanism for both errors and interrupts.
24.3 Vectored Exceptions And Maskable Interrupts
Currently, most vendors use the generic term exception to refer to any condition
that is unexpected. We say that the hardware “raises an exception” to indicate a prob-
lem. Exceptions include a broad range of conditions, including page faults, arithmetic 
errors (e.g., divide by zero), illegal instructions, bus errors, page faults, and I/O inter-
rupts. As we have seen, systems can use a single vectored mechanism to handle all ex-
ceptions.
Despite using a single mechanism, all exceptions are not treated exactly the same.
The main difference arises because a processor can mask some exceptions, but not oth-
ers. We have seen that an operating system can disable interrupts. The term maskable 
interrupt occurs because disabling interrupts requires the operating system to set inter-
rupt mask bits in an internal hardware register. Some hardware only provides one mask 
bit (i.e., interrupts are disabled or enabled). Other hardware uses multiple bits to pro-
vide multiple levels of interrupts. On such systems, a processor can disable interrupts 
on lower-priority devices while still permitting interrupts on higher-priority devices. In-
terrupt controller hardware may also provide a mask for specific IRQs, which allows a 
processor to disable or enable interrupts on individual devices (e.g., to stop a Wi-Fi de-
vice without affecting other devices).
24.4 Types Of Exceptions
Exceptions can be grouped into seven key types:
d Device interrupts
d Arithmetic exceptions
d Illegal memory references
d I/O errors (bus errors)
d Protection faults
d Invalid instructions
d Hardware failures

Sec. 24.4        Types Of Exceptions 
605
Earlier chapters examine device interrupts in detail, and point out that a misconfig-
ured device can generate an interrupt with an invalid IRQ. Arithmetic exceptions in-
clude attempts to divide by zero, and floating point overflow/underflow. On hardware
in which the memory system is separate from other I/O, the hardware will raise a
memory exception if software references an address that does not correspond to physi-
cal memory. On RISC computers where memory references must be aligned, a memory 
error can result if software attempts to fetch or store an integer from an address that is 
not a multiple of the word size. Some hardware does not distinguish between illegal 
memory references and I/O errors — a single exception type (bus error) is used for 
both. I/O errors do not always mean that device hardware has malfunctioned. It is pos-
sible for an I/O error to occur if a device driver passes an invalid address to a device. 
For example, if DMA hardware is using a descriptor ring in memory and the ring con-
tains an invalid pointer, the DMA hardware will cause an error by attempting to use the 
pointer.
Protection faults occur when software attempts to perform an operation that is not 
permitted at the current level of protection. For example, the hardware raises a protec-
tion fault if an application attempts to execute an instruction that requires operating sys-
tem privilege.
Invalid instructions are rare because most code is generated by a compiler. How-
ever, if an error causes a program to branch to an arbitrary location in memory, the lo-
cation may not contain an instruction. Therefore, programmers must be especially care-
ful when writing code, such as the device-independent I/O functions, that uses indirect 
function calls.
With current technology, hardware failures are also rare. Solid-state electronics 
has made hardware extremely reliable. However, battery-powered devices introduce a 
specific failure mode because a battery can lose voltage gradually as the charge is 
drained, and hardware can misbehave if the voltage slips below a minimum threshold.
24.5 Handling Exceptions
When an unexpected interrupt occurs, the solution is straightforward: ignore the in-
terrupt (or if a new device has been added, reconfigure the system to include the de-
vice). Exception processing is more complex, and depends on the size and purpose of 
the system as well as the source of the exception. In particular, operating systems must
be correct and reliable. Therefore, if operating system code causes an exception, the 
problem is serious, and may warrant stopping the system.
When application code causes an exception, the problem is less serious and is as-
sumed to be local to the application. Two general approaches have been used to handle 
application exceptions: termination and notification. Termination means the process 
that caused the exception is killed. Notification means the operating system calls an ex-
ception handler associated with the application process. That is, when it begins execu-
tion, an application informs the operating system of a function to call for exceptions 
that it wishes to catch. When an exception occurs, the operating checks the stored in-

606 
Exception Handling 
Chap. 24
formation to see whether the process registered an exception handler for the exception.
If so, the operating system calls the exception handler, and then allows the process to 
continue. Some programming languages have a way to declare exception handlers.
For an embedded system, recovery from an exception is usually difficult or impos-
sible. Even if the system allows interaction with a user, the user can do little to correct
the problem. Thus, many embedded systems either reboot or power down when an ex-
ception occurs.
24.6 Exception Vector Initialization
We said that although some exceptions are maskable, many are not. The hardware 
uses the exception to choose an entry in the vector, and assumes the entry contains the 
address of a handler. Therefore, an operating system designer must be careful to ensure 
that no exceptions can occur until the system fills in the exception vector.
Arranging an operating system to associate exceptions with the appropriate 
handler, filling in vectors, and building dispatch code that invokes a handler are tedious 
tasks that plague implementers. The mismatch between low-level hardware and high-
level operating system abstractions makes it difficult to map exceptions onto the code 
that caused the exception. For example, suppose a device using DMA is following 
pointers on a descriptor ring in memory, and encounters an invalid pointer. The 
hardware raises an exception, but the exception has nothing to do with the application 
that is currently executing. Thus, it may be difficult for an operating system designer to 
identify the correct source of a problem.
24.7 Panic In The Face Of Catastrophic Problems
Our example code follows the Unix tradition, and uses the name panic for the 
function that handles catastrophic problems.  Panic is only invoked in situations where 
processing cannot continue. The idea is straightforward: panic takes a string as an argu-
ment, displays the string on the console, and then halts the processor. The code is 
minimal: panic does not attempt to recover, nor does it attempt to identify the offending 
process.
Because many hardware-specific details are involved, a version of panic that 
displays registers or processor state may need to be written in assembly language. For 
example, an exception can occur because a stack pointer is invalid, and a panic function 
may need to avoid using the stack. Consequently, to work under all circumstances, 
panic code cannot merely attempt to push a value on the stack or execute a function 
call. Similarly, because entries in the device switch table may be incorrect, a panic 
function that extracts information about the CONSOLE device from the device switch 
table may not work. Fortunately, most of these cases are extreme. Therefore, many 
operating system designers start with a basic version of the panic function that works as 
long as the bulk of the operating system and runtime environment remain intact.

Sec. 24.8        Implementation Of Panic 
607
24.8 Implementation Of Panic
Our version of a panic function is simplistic. Because interrupt processing may 
have caused the exception, panic begins by disabling further interrupts, and then uses 
polled I/O to display the message on the console (i.e., it uses kprintf). To stop the pro-
cessor, the code merely enters a tight loop; the exercises suggest alternatives.
File panic.c contains the code:
//** ppaanniicc..cc -- ppaanniicc **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** ppaanniicc
--
DDiissppllaayy aa mmeessssaaggee aanndd ssttoopp aallll pprroocceessssiinngg
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
vvooiidd
ppaanniicc ((
cchhaarr
**mmssgg
//** MMeessssaaggee ttoo ddiissppllaayy
**//
))
{{
ddiissaabbllee(());;
//** DDiissaabbllee iinntteerrrruuppttss
**//
kkpprriinnttff((""\\nn\\nn\\rrppaanniicc:: %%ss\\nn\\nn"",, mmssgg));;
wwhhiillee((TTRRUUEE)) {{;;}}
//** BBuussyy lloooopp ffoorreevveerr
**//
}}
24.9 Perspective
The question of how to handle exceptions is more complex than it may seem. To 
see why, consider what happens after an application makes a system call: although it 
remains running, the application process executes operating system code. If an excep-
tion occurs, the exception should be considered an operating system problem and should 
not invoke the exception handler for the process. Similarly, if an exception occurs 
while an application is executing code from a shared library, the exception should not 
be treated differently than an exception caused by the application. Such distinctions re-
quire the operating system to keep track of exactly what an application is currently do-
ing.
Another type of complexity arises because exceptions can be caused by the interac-
tion of processes. For example, if a Xinu process inadvertently writes into another 
process’s address space, the second process may experience an exception that the first 
process caused. Thus, even if the system provides a mechanism to catch exceptions, the 
exception handler for the second process may not anticipate the problem, and may have 
no way to recover.

608 
Exception Handling 
Chap. 24
24.10 Summary
Trapping and identifying exceptions and unexpected interrupts are important be-
cause they help isolate bugs that arise as an operating system is being implemented. 
Hence, building error detection functions early is essential, even if the implementation 
is crude and unsophisticated.
In embedded systems, an exception usually causes the system to reboot or power 
down. Our example implementation of panic does not assume interrupts are working,
and does not attempt to use operating system functions. Instead, the code disables inter-
rupts, prints a message on the console, and enters a hard loop to stop further processing.
EXERCISES
24.1 
Rewrite Xinu to make the code serially reusable, and modify panic to wait 15 seconds
and then jump back to the starting location (i.e., reboot Xinu).
24.2 
How many locations does panic require on the runtime stack to process an exception?
24.3 
Design a mechanism that allows an executing process to catch exceptions.
24.4  
Some processors include a halt instruction that shuts down the processor. Find example
systems that have such an instruction, and rewrite the code.
24.5  
Find a situation where an error can occur, but panic cannot be called. Hint: what hap-
pens during a function call?

Chapter Contents
25.1 
Introduction, 611
25.2 
The Need For Multiple Configurations, 611
25.3 
Configuration In Xinu, 613
25.4 
Contents Of The Xinu Configuration File, 613
25.5 
Computation Of Minor Device Numbers, 616
25.6 
Steps In Configuring A Xinu System, 616
25.7 
Perspective, 617
25.8 
Summary, 617


25
System Configuration
No pleasure endures unseasoned by variety.
— Publilius Syrus
25.1 Introduction
This chapter concludes the discussion of basic operating system design by answer-
ing a practical question: how can the code from earlier chapters be transformed to make
it suitable for a given computer that has a specific set of peripheral devices?
The chapter discusses the motivation for configuration, tradeoffs between static and 
dynamic configuration, and presents a basic configuration program that takes a descrip-
tion of the system and generates source files tailored to the description.
25.2 The Need For Multiple Configurations
The earliest computers were designed as monolithic systems, meaning that the 
hardware and software were designed together. A designer chose the details of the pro-
cessor, memory, and I/O devices, and an operating system was built to control the 
specific hardware that had been selected. Later generations of computers added options, 
allowing a customer to choose between a large or small memory and a large or small 
disk. As the industry matured, third-party vendors began selling peripheral devices that 
could be attached to a computer. Current computer users have many possibilities — an 
owner can purchase hardware devices from a variety of vendors. Thus, a given comput-
er can have a combination of hardware devices unlike other computers.
611

612 
System Configuration 
Chap. 25
Two broad approaches have been used to configure operating system software:
d Static configuration
d Dynamic configuration
Static configuration. Static configuration is appropriate for small, “self-contained”
systems, where the hardware does not change. A designer chooses the hardware, in-
cluding processor, memory, and a set of peripheral devices. Once the hardware has 
been specified, an operating system is created that supports exactly the hardware that 
has been chosen, without any extra software modules. In practice, one does not create a 
new operating system for each hardware design. Instead, a general-purpose operating 
system is used, and a subset of the system modules are selected. Usually, the hardware 
specification becomes input to a configuration program that manages operating system 
source code. The configuration program uses the hardware specification to select the 
modules that are needed for the target hardware, and excludes other modules. When the 
resulting code has been compiled and linked, we say it has been configured for the 
hardware.
Dynamic configuration. The alternative to static configuration is dynamic config-
uration in which parts of the operating system can be changed while the system exe-
cutes. Dynamic configuration is only appropriate for systems that have large memories 
and secondary storage. A basic operating system starts running without an exact 
knowledge of the hardware. The system probes the hardware, determines which devices 
are present, and loads pieces of the system for the hardware. Of course, the pieces of 
operating system software must be available on a local disk or downloaded (e.g., over 
the Internet).
Static configuration is a form of early binding. The chief advantage is that the 
memory image only contains modules for the hardware that exists. Static configuration
is ideal for the smallest embedded systems where memory is limited and no secondary 
storage is available. Another advantage arises because the system does not spend time 
identifying hardware during the bootstrap process; the information is bound into the 
code when the operating system image is created. Thus, a system can boot instantly. 
The chief disadvantage of early configuration is that a system configured for one 
machine cannot run on another unless the two are identical, including details such as the 
size of memory and all the devices.
Deferring configuration until system startup allows the designer to build more 
robust code because a single system can operate on several hardware configurations. 
During startup, the system can adapt itself to the exact hardware on which it executes. 
In particular, dynamic configuration handles an arbitrary set of peripheral devices built 
by an arbitrary set of vendors. For example, a single operating system image can be 
used independent of the disk, printer, network interface, and video screen used on the 
computer. Dynamic reconfiguration also allows a system to adapt to changes in the 
hardware without stopping (e.g., when a user attaches or detaches a USB device).

Sec. 25.3        Configuration In Xinu 
613
25.3 Configuration In Xinu
Because it runs as an embedded system, Xinu follows a static configuration ap-
proach, with the majority of configuration occurring when the system is compiled and 
linked. Of course, even in some embedded systems, part of the configuration must be 
postponed until system startup. For example, some versions of Xinu calculate the size 
of memory during system initialization. Others use dynamic configuration to detect the 
presence of a real-time clock. As we have seen, some bus hardware chooses IRQs and 
device addresses when the bus is powered on. On such hardware, Xinu must wait until 
it runs to find the interrupt vector addresses and device CSR addresses.
To help manage configuration and to automate the selection of device driver 
modules, Xinu uses a separate configuration program. Named config, the program is
not part of the operating system, and we do not need to examine the source code. In-
stead, we will look at how config operates: it takes an input file that contains specifica-
tions, and produces output files that become part of the operating system code. The 
next sections explain the configuration program and show examples.
25.4 Contents Of The Xinu Configuration File
The config program takes as input a text file named Configuration. It parses the 
input file, and generates two output files: conf.h and conf.c. We have already seen the 
output files, which contain defined constants for devices and a definition of the device 
switch table.†
The Xinu configuration file is a text file, divided into three sections. The sections 
are separated by lines that contain two ampersand characters (%%). The three sections 
are:
d Section 1: Type declarations for device types
d Section 2: Device specifications for specific devices
d Section 3:  Symbolic constants
25.4.1  Section 1: Type Declarations
The motivation for a type declaration arises because a system may contain more 
than one copy of a particular hardware device. For example, a system may contain two 
UART devices that both use the tty abstraction. In such cases, a set of functions that 
comprise a tty driver must be specified for each UART. Entering the specification 
many times manually is error-prone, and can lead to inconsistencies. Thus, the type 
section allows the specification to be entered once and assigned a name that is used 
with both devices in the device specification section.

†File conf.h can be found on page 267, and conf.c can be found on page 279.

614 
System Configuration 
Chap. 25
Each type declaration defines a name for the type, and lists a set of default device 
driver functions for the type. The declaration also allows one to specify the type of 
hardware with which the device is associated. For example, the type declaration:
ttttyy::
oonn uuaarrtt
--ii ttttyyiinniitt
--oo iioonnuullll
--cc iioonnuullll
--rr ttttyyrreeaadd
--gg ttttyyggeettcc
--pp ttttyyppuuttcc
--ww ttttyywwrriittee
--ss iiooeerrrr
--nn ttttyyccoonnttrrooll
--iinnttrr ttttyyhhaannddlleerr
--iirrqq 88
defines a type named tty that is used on a UART device. Neither tty nor uart is a key-
word or has any meaning. Instead they are simply names that the designer chose. The 
remaining items specify the default driver functions for type tty. Each driver function is 
preceded by a keyword that begins with a minus sign. Figure 25.1 lists the possible 
keywords and gives their meaning. Note: a given specification does not need to use all 
keywords. In particular, because a CSR address is unique to a device, a type declara-
tion does not usually include a csr keyword.

Keyword 
Meaning

-i 
function that performs init
-o 
function that performs open
-c 
function that performs close
-r 
function that performs read
-w 
function that performs write
-s 
function that performs seek
-g 
function that performs getc
-p 
function that performs putc
-n 
function that performs control
-intr 
function that handles interrupts
-csr 
control and status register address
-irq 
interrupt vector number

















































Figure 25.1  Keywords used in the Xinu configuration file and their meaning.
25.4.2  Section 2: Device Specifications
Section 2 of file Configuration contains a declaration for each device in the sys-
tem. A declaration gives a name for the device (e.g., CONSOLE), and specifies the set
of functions that constitutes a driver. Note that in Xinu, a device is an abstract concept, 
not necessarily tied to a physical hardware device. For example, in addition to devices 
like CONSOLE and ETHERNET that each correspond to underlying hardware, the de-
vice section can list pseudo-devices, such as a FILE device used for I/O.

Sec. 25.4        Contents Of The Xinu Configuration File 
615
Declaring a device serves two purposes. First, it allocates a slot in the device
switch table, allowing the high-level I/O primitives to be used with the device rather
than requiring a programmer to call specific driver functions. Second, it allows config
to assign each device a minor device number. All devices with the same type are as-
signed minor numbers in sequence starting at zero.
When a device is declared, specific values can be supplied as needed or driver
functions can be overridden. For example, the declaration:
CCOONNSSOOLLEE iiss ttttyy
oonn uuaarrtt --ccssrr 00xxBB88002200000000
declares CONSOLE to be a device of type tty that runs on UART hardware. In addi-
tion, the declaration specifies a CSR address of 0xB8020000.
If a programmer needed to test a new version of ttygetc, the programmer might
change the specification to:
CCOONNSSOOLLEE iiss ttttyy
oonn uuaarrtt --ccssrr 00xxBB88002200000000
--gg mmyyttttyyggeettcc
which uses the default driver functions from the tty declaration given above, but over-
rides the getc function to use myttygetc. Note that having a configuration makes it easy 
to change one function without modifying or replacing the original file.
The example type declaration includes the phrase on uart. To understand the pur-
pose of specifying the underlying hardware, observe that designers sometimes wish to
use the same abstraction for multiple pieces of hardware. For example, suppose a sys-
tem contains two types of UART hardware. The on keyword allows a designer to use
the tty abstraction for hardware types, and to allocate a single array of control blocks
even though some of the low-level hardware details differ and the set of driver func-
tions used for one type of hardware differs from the set used for another.
25.4.3  Symbolic Constants
In addition to defining the structure of the device switch table, conf.h contains con-
stants that specify the total number of devices and the number of each type. The config 
program generates such constants to reflect the specification found in file Configuration. 
For example, constant NDEVS is defined to be an integer that tells the total number of 
devices that have been configured. The device switch table contains NDEVS devices, 
and device-independent I/O routines use NDEVS to test whether a device id 
corresponds to a valid device.
Config also generates a set of defined constants that specify the number of devices 
of each type. Driver functions can use the appropriate constant to declare the array of 
control blocks. Each constant has the form Nxxx, where xxx is the type name. For ex-
ample, if file Configuration defines two devices of type tty, conf.h will contain the fol-
lowing line:
##ddeeffiinnee NNttttyy
22

616 
System Configuration 
Chap. 25
25.5 Computation Of Minor Device Numbers
Consider the files that config produces. File conf.h contains the declaration of the 
device switch table, and conf.c contains the code that initializes the table. For a given 
device, its devtab entry contains a set of pointers to the device driver routines that 
correspond to high-level I/O operations like open, close, read, and write. The entry 
also contains the interrupt vector address and the device’s CSR address (if the hardware 
allows the addresses to be known when the system is compiled). All information in the 
device switch table is derived from file Configuration in a straightforward manner.
As mentioned above, each entry in the device switch table also contains a minor 
device number. Minor device numbers are nothing more than integers that distinguish 
among multiple devices that each use the same type of control block. Recall that device 
driver functions use the minor device number as an index into the array of control 
blocks to associate a specific entry with each device. In essence, the config program 
counts devices of each type. That is, each time it encounters a device, config uses the 
device type to assign the next minor device number (numbers start at zero). For exam-
ple, Figure 25.2 shows how device IDs and minor numbers are assigned on a system 
that has three tty devices and two eth devices.

device 
device 
device 
minor
name 
identifier 
type 
number

CONSOLE 
0 
tty 
0

ETHERNET 
1 
eth 
0

SERIAL2 
2 
tty 
1

PRINTER 
3 
tty 
2

ETHERNET2 
4 
eth 
1





























































Figure 25.2  An example of device configuration.
Notice that the three tty lines have minor numbers zero, one, and two, even though
their device IDs happen to be zero, two, and three.
25.6 Steps In Configuring A Xinu System
To configure a Xinu system, the programmer edits file Configuration, adding or 
changing device information and symbolic constants as desired. When run, program 
config first reads and parses the file, collecting the information about each device type. 
It then reads device specifications, assigns minor device numbers, and produces the out-
put files conf.c and conf.h. Finally, in addition to symbolic constants that are generated

Sec. 25.6        Steps In Configuring A Xinu System 
617
automatically, config appends definitions of symbolic constants from the third section of 
the specifications onto conf.h, making them available for operating system functions to 
include.
After config produces a new version of conf.c and conf.h, conf.c must be recom-
piled, as must all system functions that include conf.h.
25.7 Perspective
The history of operating systems is one of moving from static configuration to 
dynamic configuration. The interesting question is whether the benefits of dynamic 
configuration outweigh the costs. For example, compare the time required to boot Xinu 
to the time required to boot a large production system, such as Windows or Linux. 
Although the underlying computer hardware does not usually change, a production sys-
tem may need to go through the steps of polling the bus to find the devices that are 
present, loading drivers, and interacting with each device
Some systems, especially those used on laptops, offer a sleep mode (sometimes 
called hibernation mode) that allows rapid restart. Instead of completely powering
down the system, sleep mode saves processor state (e.g., by saving the running memory 
image and hardware registers on disk). Then, when a user restarts the machine, the 
machine state is restored from disk. Only a few checks must be made before the system 
can resume running. For example, if a laptop was connected to a wireless network be-
fore being put into sleep mode, the user could have moved to a new location where the 
network is no longer available. Therefore, the operating system must check network 
connections after the system resumes.
25.8 Summary
Instead of building a monolithic operating system tailored to specific hardware, 
designers look for ways to make systems configurable. Static configuration, a form of 
early binding, selects modules when the system is compiled and linked. The alternative, 
dynamic configuration, loads modules, such as device drivers, at runtime.
Because it is designed for an embedded environment, Xinu uses static config-
uration. Program config reads file Configuration, and produces files conf.h and conf.c
that define and initialize the device switch table. The separation of device types from 
device declarations allows config to compute minor device numbers.

618 
System Configuration 
Chap. 25
EXERCISES
25.1  
Create a function myttyread that calls ttygetc repeatedly to satisfy a request. To test your
code, modify file Configuration to substitute your code in place of ttyread.
25.2  
Find out how other systems are configured. What happens, for example, when Windows
boots?
25.3  
If every operating system function includes conf.h, any change to file Configuration
means a new version of conf.h will be generated, and the entire system must be recom-
piled. Redesign the config program to separate constants into several different include 
files to eliminate unnecessary recompilation.
25.4  
Discuss whether a configuration program is worthwhile. Include some estimate of the
extra effort required to make a system easily configurable. Remember that a program-
mer is likely to have little experience or knowledge about a system when it is first con-
figured.
25.5 
In theory, many aspects of a system may need to change when porting the system from
one computer to another. In addition to devices, for example, one might consider the 
processor (not only the basic instruction set, but the extra instructions found on some 
models), the availability of co-processors (including floating point), the real-time clock 
or time resolution, and the endianness of integers. Argue that if a configuration system 
has parameters for all the above, the resulting system is untestable.
25.6 
Measure the time a production system takes to boot and the time the same system takes
to resume after hibernation. What is the percentage difference?
25.7 
In the previous exercise, does the time to resume change if the system is moved and its
network is no longer available?
25.8 
Repeat the measurement of booting vs. resuming after hibernation for a system that has
three USB devices plugged in before hibernation and none when the system resumes.
Also repeat the experiment for the case where the system has no USB devices before 
hibernation, but three devices are plugged in during hibernation.

Chapter Contents
26.1 
Introduction, 621
26.2 
What Is A User Interface?, 622
26.3 
Commands And Design Principles, 622
26.4 
Design Decisions For A Simplified Shell, 623
26.5 
Shell Organization And Operation, 623
26.6 
The Definition Of Lexical Tokens, 624
26.7 
The Definition Of Command-Line Syntax, 625
26.8 
Implementation Of The Xinu Shell, 625
26.9 
Storage Of Tokens, 628
26.10 Code For The Lexical Analyzer, 629
26.11 The Heart Of The Command Interpreter, 633
26.12 Command Name Lookup And Builtin Processing, 641 
26.13 Arguments Passed To Commands, 641
26.14 Passing Arguments To A Non-builtin Command, 643 
26.15 I/O Redirection, 646
26.16 An Example Command Function (sleep), 647 
26.17 Perspective, 649
26.18 Summary, 650


26
An Example User Interface: 
The Xinu Shell
A man has to learn that he cannot command things...
— James Allen
26.1 Introduction
Previous chapters explain an operating system as a set of functions that applica-
tions can invoke to obtain services. However, a typical user never encounters system 
functions. Instead, users invoke applications, and allow the applications to access func-
tions in the underlying system.
This chapter examines a basic interface known as a shell† that allows a user to
launch applications and control their input and output. Following the pattern estab-
lished by other parts of the system, our design emphasizes simplicity and elegance rath-
er than features. We concentrate on a few fundamental ideas that make the shell power-
ful without requiring large amounts of code. The chapter shows examples of both 
software that interprets user commands and applications that a user can invoke. 
Although it only offers basic functionality, our example interpreter illustrates several 
important concepts.
                                †The term shell and many of the ideas used in the Xinu shell come from Unix.
621

622 
An Example User Interface: The Xinu Shell 
Chap. 26
26.2 What Is A User Interface?
A user interface consists of the hardware and software with which users interact to 
perform computational tasks and observe the results. Thus, user interface software lies 
between a human who specifies what must be done and a computer system that per-
forms the specified tasks.
The goal of user interface design is to create an environment in which users can 
perform computational tasks conveniently and productively. For example, most modern 
user interfaces employ a graphical representation that presents a set of icons from which 
the user selects to launch an application. The use of graphics makes application selec-
tion quick, and relieves the user from memorizing a set of application names.
Small embedded systems typically offer two levels of interface: one for a system 
builder and another for the end user. For example, a desktop system provides a graphi-
cal interface through which an end user launches applications and interacts with the de-
vice. To write new software, directly access the file system, or enter text commands, 
however, a programmer invokes a lower-level interface that is sometimes called a Ter-
minal.
26.3 Commands And Design Principles
Industry uses the term Command Line Interface (CLI) to describe an interface that 
allows a user to enter a series of textual commands; many embedded system products 
offer a CLI. Usually, each line of input corresponds to a command, and the system 
processes a line before reading the next line. The term command arises because most 
CLIs follow the same syntactic form in which a line starts with a name that specifies an 
action to be taken and is followed by parameters that control the details of the action 
and the item(s) to which the action applies. For example, we can imagine a system that 
uses a command named config to control settings associated with a network interface. 
To minimize keystrokes, a CLI may use short, cryptic abbreviations. The command to 
set the MTU parameter of interface number 0 to 1500 might be:
config 
0 
MTU=1500
The set of all available commands determines the functionality available to a user 
(i.e., defines the power of the computing system). However, a good design does not 
merely collect random commands. Instead, the design adheres to the following princi-
ples:
d Functionality: sufficient for all needs
d Orthogonality: only one way to perform a given task
d Consistency: commands follow a consistent pattern
d Least astonishment: a user should be able to predict results

Sec. 26.4        Design Decisions For A Simplified Shell 
623
26.4 Design Decisions For A Simplified Shell
When they design a CLI and the shell program that processes commands, program-
mers must choose among many alternatives. The following paragraphs list decisions a 
programmer faces, and describe the choices made for a simplified Xinu shell.
Handling input. Should our interface allow the terminal device driver to handle 
the details of backspacing, character echoing, and line erasing, or should it handle those 
details itself? The choice is important because it determines the extent to which the 
shell can control input. For example, a modern Unix shell allows Control-B and 
Control-F characters to move the cursor backward and forward while editing a line of 
input, while our tty driver does not.† Our choice is to use the tty driver, which simpli-
fies the design and reduces the amount of code. An exercise suggests changing the 
design to have the shell, rather than the tty driver, interpret all input characters.
Foreground or background execution. Does the shell wait while a command com-
pletes execution before starting another? Our shell follows the Unix tradition of allow-
ing a user to decide whether the shell waits or the command executes in foreground or 
background.
Redirection of input and output. Also like Unix, our example shell allows a user
to specify a source of input and destination for output when the command is invoked.
The technique, known as I/O redirection, allows each command to function as a
general-purpose tool that can be applied to a variety of files and I/O devices. Providing 
redirection in the shell also means that I/O specifications are uniform — a single mech-
anism for redirection applies to all commands.
Typed or untyped arguments. Should a shell check the number and type of argu-
ments for a given command, or should each command handle arguments? Following 
the Unix tradition, our example shell does not check the number of arguments, nor does
it interpret argument values. Instead, the shell treats each argument as a text string, and 
the set of arguments is passed to the command. Consequently, each command must 
check whether its arguments are valid.
26.5 Shell Organization And Operation
A shell is organized as a loop that repeatedly reads a line of input and executes the 
command on the line. Once a line has been read, the shell must extract a command
name, arguments, and other items, such as the specifications of I/O redirection or back-
ground processing. Following standard practice for syntactic analysis, we have divided 
the code into two separate functions: one function handles lexical analysis by grouping 
characters into tokens, and the other function examines whether the set of tokens forms 
a valid command.
Using a separate lexical function may seem unnecessary for the trivial syntax of
our sample shell. It is tempting to take short cuts for a small task. However, we chose
the organization because it permits future expansion.
                                †The use of Control-B and Control-F is derived from the Emacs editor.

624 
An Example User Interface: The Xinu Shell 
Chap. 26
26.6 The Definition Of Lexical Tokens
At the lexical level, our shell scans a line of input and groups characters into syn-
tactic tokens. Figure 26.1 lists the lexical tokens that the scanner recognizes and the
four lexical types the scanner uses when classifying tokens.

Symbolic Name 
Numeric 
Input 
Description
(Token Type) 
Value 
Characters

SH_TOK_AMPER 
0 
& 
ampersand

SH_TOK_LESS 
1 
< 
less-than symbol

SH_TOK_GREATER 
2 
> 
greater-than symbol

SH_TOK_OTHER 
3 
’...’ 
quoted string (single quotes)

SH_TOK_OTHER 
3 
"..." 
quoted string (double-quotes) 

SH_TOK_OTHER  
3 
other 
sequence of non-whitespace





























Figure 26.1  Lexical tokens used by the example Xinu shell.
As with most command line processors, our shell strives to be flexible. Characters 
such as a “less than” (i.e., <) are assigned special meaning. The shell includes quoted 
strings as lexical tokens to permit a user to include special characters in arguments. 
The rule is that a quoted string can contain arbitrary characters, including the special 
characters recognized by the shell. Rather than incorporate complex rules for escaping 
characters in a string, the Xinu shell uses two forms. A quoted string starts with either 
a single or double quote, and contains all characters, including blanks, tabs, and special 
characters up to the first occurrence of the opening quote. Thus, the string:
’’aa ssttrriinngg’’
contains eight total characters including a blank. More important, because two quotes
are recognized, a string can be created that includes one of the quote characters. For 
example, the string:
""ddoonn’’tt bblliinnkk""
contains eleven characters, including a single quote. The lexical scanner removes the 
surrounding quotes, and classifies the resulting sequence of characters to be a single to-
ken of type SH_TOK_OTHER.
The lexical scanner defines whitespace to consist of blanks or tab characters. At 
least one whitespace character must separate two tokens of type SH_TOK_OTHER. 
Otherwise, whitespace is ignored.

Sec. 26.7        The Definition Of Command-Line Syntax 
625
26.7 The Definition Of Command-Line Syntax
Once a line has been scanned and divided into a series of lexical tokens, the shell
parses the tokens to verify that they form a valid sequence. The syntax is:
command_name args* [ redirection ] [ background ]
Brackets [ ] denote an optional occurrence and asterisk indicates zero or more repetitions 
of an item. The string command_name denotes the name of a command, args* denotes 
zero or more optional arguments, the optional redirection refers to input redirection, 
output redirection, or both, and the optional background indicates background execu-
tion. Figure 26.2 contains a grammar that defines the set of valid inputs in terms of to-
kens.
command 
→
name [args] [redirection] [background]
name 
→
SH_TOK_OTHER
args 
→
SH_TOK_OTHER [args]
redirection    →
input_redirect [output_redirect] 
redirection 
→
output_redirect [input_redirect]
input_redirect 
→
SH_TOK_LESS SH_TOK_OTHER
output_redirect  →
SH_TOK_GREATER SH_TOK_OTHER 
background 
→
SH_TOK_AMPER
Figure 26.2 A grammar that specifies valid sequences of tokens for the ex-
ample shell.
In essence, a command consists of a sequence of one or more “other” tokens op-
tionally followed by requests to redirect the input and/or output (in either order), option-
ally followed by a specification that the command should run in background. The first 
token on the line must be the name of a command.
26.8 Implementation Of The Xinu Shell
Our examination of the implementation begins with the definition of constants and
variables used by the shell. File shell.h contains the declarations.

626 
An Example User Interface: The Xinu Shell 
Chap. 26
//** sshheellll..hh -- DDeeccllaarraattiioonnss aanndd ccoonnssttaannttss uusseedd bbyy tthhee XXiinnuu sshheellll **//
//** SSiizzee ccoonnssttaannttss **//
##ddeeffiinnee SSHHEELLLL__BBUUFFLLEENN
TTYY__IIBBUUFFLLEENN++11
//** LLeennggtthh ooff iinnppuutt bbuuffffeerr
**//
##ddeeffiinnee SSHHEELLLL__MMAAXXTTOOKK
3322
//** MMaaxxiimmuumm ttookkeennss ppeerr lliinnee
**//
##ddeeffiinnee SSHHEELLLL__CCMMDDSSTTKK
88119922
//** SSiizzee ooff ssttaacckk ffoorr pprroocceessss
**//
//**
tthhaatt eexxeeccuutteess ccoommmmaanndd
**//
##ddeeffiinnee SSHHEELLLL__AARRGGLLEENN
((SSHHEELLLL__BBUUFFLLEENN++SSHHEELLLL__MMAAXXTTOOKK)) //** AArrgguummeenntt aarreeaa
**//
##ddeeffiinnee SSHHEELLLL__CCMMDDPPRRIIOO
2200
//** PPrroocceessss pprriioorriittyy ffoorr ccoommmmaanndd **//
//** MMeessssaaggee ccoonnssttaannttss **//
//** SShheellll bbaannnneerr ((aassssuummeess VVTT110000)) **//
##ddeeffiinnee SSHHEELLLL__BBAANN00
""\\003333[[11;;3311mm""
##ddeeffiinnee SSHHEELLLL__BBAANN11
""------------------------------------------------------------------------------------""
##ddeeffiinnee SSHHEELLLL__BBAANN22
""
____
____
__________
__
__
__
__
""
##ddeeffiinnee SSHHEELLLL__BBAANN33
""
\\\\ \\\\
// //
||____ ____||
|| \\\\ || ||
|| ||
|| ||
""
##ddeeffiinnee SSHHEELLLL__BBAANN44
""
\\\\ \\\\// //
|| ||
||
\\\\|| ||
|| ||
|| ||
""
##ddeeffiinnee SSHHEELLLL__BBAANN55
""
// //\\\\ \\\\
__|| ||__
|| \\\\
||
|| ||
|| ||
""
##ddeeffiinnee SSHHEELLLL__BBAANN66
""
// //
\\\\ \\\\
||
||
|| || \\\\ ||
\\\\
----
//
""
##ddeeffiinnee SSHHEELLLL__BBAANN77
""
----
----
----------
--
--
--------
""
##ddeeffiinnee SSHHEELLLL__BBAANN88
""------------------------------------------------------------------------------------""
##ddeeffiinnee SSHHEELLLL__BBAANN99
""\\003333[[00;;3399mm\\nn""
//** MMeessssaaggeess sshheellll ddiissppllaayyss ffoorr uusseerr **//
##ddeeffiinnee SSHHEELLLL__PPRROOMMPPTT
""xxsshh $$ ""
//** CCoommmmaanndd pprroommpptt
**//
##ddeeffiinnee SSHHEELLLL__SSTTRRTTMMSSGG
""WWeellccoommee ttoo XXiinnuu!!\\nn""//** WWeellccoommee mmeessssaaggee
**//
##ddeeffiinnee SSHHEELLLL__EEXXIITTMMSSGG
""SShheellll cclloosseedd\\nn""//** SShheellll eexxiitt mmeessssaaggee
**//
##ddeeffiinnee SSHHEELLLL__SSYYNNEERRRRMMSSGG ""SSyynnttaaxx eerrrroorr\\nn""//** SSyynnttaaxx eerrrroorr mmeessssaaggee
**//
##ddeeffiinnee SSHHEELLLL__CCRREEAATTMMSSGG
""CCaannnnoott ccrreeaattee pprroocceessss\\nn""//** ccoommmmaanndd eerrrroorr
**//
##ddeeffiinnee SSHHEELLLL__IINNEERRRRMMSSGG
""CCaannnnoott ooppeenn ffiillee %%ss ffoorr iinnppuutt\\nn"" //** IInnppuutt eerrrr
**//
##ddeeffiinnee SSHHEELLLL__OOUUTTEERRRRMMSSGG ""CCaannnnoott ooppeenn ffiillee %%ss ffoorr oouuttppuutt\\nn""//** OOuuttppuutt eerrrr **//
//** BBuuiillttiinn ccmmdd eerrrroorr mmeessssaaggee
**//
##ddeeffiinnee SSHHEELLLL__BBGGEERRRRMMSSGG
""CCaannnnoott rreeddiirreecctt II//OO oorr bbaacckkggrroouunndd aa bbuuiillttiinn\\nn""
//** CCoonnssttaannttss uusseedd ffoorr lleexxiiccaall aannaallyyssiiss **//
##ddeeffiinnee SSHH__NNEEWWLLIINNEE
’’\\nn’’
//** NNeeww lliinnee cchhaarraacctteerr
**//
##ddeeffiinnee SSHH__EEOOFF
’’\\0044’’
//** CCoonnttrrooll--DD iiss EEOOFF
**//
##ddeeffiinnee SSHH__AAMMPPEERR
’’&&’’
//** AAmmppeerrssaanndd cchhaarraacctteerr
**//
##ddeeffiinnee SSHH__BBLLAANNKK
’’ ’’
//** BBllaannkk cchhaarraacctteerr
**//
##ddeeffiinnee SSHH__TTAABB
’’\\tt’’
//** TTaabb cchhaarraacctteerr
**//

Sec. 26.8        Implementation Of The Xinu Shell 
627
##ddeeffiinnee SSHH__SSQQUUOOTTEE
’’\\’’’’
//** SSiinnggllee qquuoottee cchhaarraacctteerr
**//
##ddeeffiinnee SSHH__DDQQUUOOTTEE
’’""’’
//** DDoouubbllee qquuoottee cchhaarraacctteerr
**//
##ddeeffiinnee SSHH__LLEESSSS
’’<<’’
//** LLeessss--tthhaann cchhaarraacctteerr
**//
##ddeeffiinnee SSHH__GGRREEAATTEERR
’’>>’’
//** GGrreeaatteerr--tthhaann cchhaarraacctteerr
**//
//** TTookkeenn ttyyppeess **//
##ddeeffiinnee SSHH__TTOOKK__AAMMPPEERR
00
//** AAmmppeerrssaanndd ttookkeenn
**//
##ddeeffiinnee SSHH__TTOOKK__LLEESSSS
11
//** LLeessss--tthhaann ttookkeenn
**//
##ddeeffiinnee SSHH__TTOOKK__GGRREEAATTEERR
22
//** GGrreeaatteerr--tthhaann ttookkeenn
**//
##ddeeffiinnee SSHH__TTOOKK__OOTTHHEERR
33
//** TTookkeenn ootthheerr tthhaann tthhoossee
**//
//**
lliisstteedd aabboovvee ((ee..gg..,, aann
**//
//**
aallpphhaannuummeerriicc ssttrriinngg))
**//
//** SShheellll rreettuurrnn ccoonnssttaannttss **//
##ddeeffiinnee SSHHEELLLL__OOKK
00
##ddeeffiinnee SSHHEELLLL__EERRRROORR
11
##ddeeffiinnee SSHHEELLLL__EEXXIITT
--33
//** SSttrruuccttuurree ooff aann eennttrryy iinn tthhee ttaabbllee ooff sshheellll ccoommmmaannddss **//
ssttrruucctt
ccmmddeenntt
{{
//** EEnnttrryy iinn ccoommmmaanndd ttaabbllee
**//
cchhaarr
**ccnnaammee;;
//** NNaammee ooff ccoommmmaanndd
**//
bbooooll88
ccbbuuiillttiinn;;
//** IIss tthhiiss aa bbuuiillttiinn ccoommmmaanndd??
**//
iinntt3322
((**ccffuunncc))((iinntt3322,,cchhaarr**[[]]));;//** FFuunnccttiioonn ffoorr ccoommmmaanndd
**//
}};;
eexxtteerrnn
uuiinntt3322
nnccmmdd;;
eexxtteerrnn
ccoonnsstt
ssttrruucctt
ccmmddeenntt
ccmmddttaabb[[]];;
Unlike a Unix system, where commands reside in files, all Xinu shell commands
are linked into the image. The shell defines an array that lists the set of commands that
are available, the name of each command, and the function to execute for the command.
The final section of file shell.h defines the table of commands, cmdtab. Each entry 
in the table is struct cmdent which contains three items: a name for the command, a 
Boolean indicating whether the command is restricted to run as a builtin, and a pointer 
to a function that implements the command. Later sections discuss how the command 
table is initialized and how it is used.

628 
An Example User Interface: The Xinu Shell 
Chap. 26
26.9 Storage Of Tokens
The data structures that our shell uses are somewhat unexpected. An integer array, 
toktyp, is used to record the numeric value of the type for each token. The tokens them-
selves are stored as null-terminated strings. To conserve space, tokens are packed into 
contiguous locations of a character array, tokbuf. An integer array, tok, is used to store 
the index of the start of each token. The shell depends on two counters: ntok counts the 
number of tokens found so far, and variable tlen counts the characters that have been 
stored in array tokbuf. To understand the data structures, consider the example input 
line:
date > file &
The line contains four tokens. Figure 26.3 shows how the lexical analyzer fills in the
data structures to hold the tokens that have been extracted from the input line.
toktyp
tok
d
0
a
t
e Φ >
5
Φ f
7
i
l
e Φ &
12
Φ
0
5
7
12
tokbuf
3
2
3
0
tlen = 14
ntok = 4
Figure 26.3 Contents of variables tokbuf, toktyp, tok, ntok, and tlen for the
input line: date > file &
As the figure shows, the tokens themselves are placed in array tokbuf with all 
whitespace removed. A null character terminates each token. Array tok contains in-
tegers that are each an index into tokbuf — the ith location of array tok gives the index
in tokbuf of the string for the ith token. Finally, the ith location of array toktyp specifies
the type of the ith token. For example, the second token on the line, >, has numeric
type 2 (SH_TOK_LESS†), and starts at location 5 in array tokbuf. The third token on
the line, file, has numeric type 3 (SH_TOK_OTHER), and starts at location 7 in array 
tokbuf.
                                †Figure 26.1 on page 624 lists the numeric values for each token type.

Sec. 26.10        Code For The Lexical Analyzer 
629
26.10 Code For The Lexical Analyzer
Because our shell syntax is straightforward, we have chosen to use an ad hoc, top-
down implementation for the lexical analyzer. File lexan.c contains the code.
//** lleexxaann..cc
-- lleexxaann **//
##iinncclluuddee <<xxiinnuu..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** lleexxaann
--
AAdd hhoocc lleexxiiccaall aannaallyyzzeerr ttoo ddiivviiddee ccoommmmaanndd lliinnee iinnttoo ttookkeennss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
iinntt3322
lleexxaann ((
cchhaarr
**lliinnee,,
//** IInnppuutt lliinnee tteerrmmiinnaatteedd wwiitthh
**//
//**
NNEEWWLLIINNEE oorr NNUULLLLCCHH
**//
iinntt3322
lleenn,,
//** LLeennggtthh ooff tthhee iinnppuutt lliinnee,,
**//
//**
iinncclluuddiinngg NNEEWWLLIINNEE
**//
cchhaarr
**ttookkbbuuff,,
//** BBuuffffeerr iinnttoo wwhhiicchh ttookkeennss aarree **//
//**
ssttoorreedd wwiitthh aa nnuullll
**//
//**
ffoolllloowwiinngg eeaacchh ttookkeenn
**//
iinntt3322
**ttlleenn,,
//** PPllaaccee ttoo ssttoorree nnuummbbeerr ooff
**//
//**
cchhaarrss iinn ttookkbbuuff
**//
iinntt3322
ttookk[[]],,
//** AArrrraayy ooff ppooiinntteerrss ttoo tthhee
**//
//**
ssttaarrtt ooff eeaacchh ttookkeenn
**//
iinntt3322
ttookkttyypp[[]]
//** AArrrraayy tthhaatt ggiivveess tthhee ttyyppee
**//
//**
ooff eeaacchh ttookkeenn
**//
))
{{
cchhaarr
qquuoottee;;
//** CChhaarraacctteerr ffoorr qquuootteedd ssttrriinngg
**//
uuiinntt3322
nnttookk;;
//** NNuummbbeerr ooff ttookkeennss ffoouunndd
**//
cchhaarr
**pp;;
//** PPooiinntteerr tthhaatt wwaallkkss aalloonngg tthhee **//
//**
iinnppuutt lliinnee
**//
iinntt3322
ttbbiinnddeexx;;
//** IInnddeexx iinnttoo ttookkbbuuff
**//
cchhaarr
cchh;;
//** NNeexxtt cchhaarr ffrroomm iinnppuutt lliinnee
**//
//** SSttaarrtt aatt tthhee bbeeggiinnnniinngg ooff tthhee lliinnee wwiitthh nnoo ttookkeennss **//
nnttookk == 00;;
pp == lliinnee;;
ttbbiinnddeexx == 00;;
//** WWhhiillee nnoott yyeett aatt eenndd ooff lliinnee,, ggeett nneexxtt ttookkeenn **//

630 
An Example User Interface: The Xinu Shell 
Chap. 26
wwhhiillee (( ((**pp !!== NNUULLLLCCHH)) &&&& ((**pp !!== SSHH__NNEEWWLLIINNEE)) )) {{
//** IIff ttoooo mmaannyy ttookkeennss,, rreettuurrnn eerrrroorr **//
iiff ((nnttookk >>== SSHHEELLLL__MMAAXXTTOOKK)) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
//** SSkkiipp wwhhiitteessppaaccee bbeeffoorree ttookkeenn **//
wwhhiillee (( ((**pp ==== SSHH__BBLLAANNKK)) |||| ((**pp ==== SSHH__TTAABB)) )) {{
pp++++;;
}} 
//** SSttoopp ppaarrssiinngg aatt eenndd ooff lliinnee ((oorr eenndd ooff ssttrriinngg)) **//
cchh == **pp;;
iiff (( ((cchh====SSHH__NNEEWWLLIINNEE)) |||| ((cchh====NNUULLLLCCHH)) )) {{
**ttlleenn == ttbbiinnddeexx;;
rreettuurrnn nnttookk;;
}} 
//** SSeett nneexxtt eennttrryy iinn ttookk aarrrraayy ttoo bbee aann iinnddeexx ttoo tthhee
**//
//**
ccuurrrreenntt llooccaattiioonn iinn tthhee ttookkeenn bbuuffffeerr
**//
ttookk[[nnttookk]] == ttbbiinnddeexx;;
//** tthhee ssttaarrtt ooff tthhee ttookkeenn
**//
//** SSeett tthhee ttookkeenn ttyyppee **//
sswwiittcchh ((cchh)) {{
ccaassee SSHH__AAMMPPEERR::
ttookkttyypp[[nnttookk]] == SSHH__TTOOKK__AAMMPPEERR;;
ttookkbbuuff[[ttbbiinnddeexx++++]] == cchh;;
ttookkbbuuff[[ttbbiinnddeexx++++]] == NNUULLLLCCHH;;
nnttookk++++;;
pp++++;;
ccoonnttiinnuuee;;
ccaassee SSHH__LLEESSSS::
ttookkttyypp[[nnttookk]] == SSHH__TTOOKK__LLEESSSS;;
ttookkbbuuff[[ttbbiinnddeexx++++]] == cchh;;
ttookkbbuuff[[ttbbiinnddeexx++++]] == NNUULLLLCCHH;;
nnttookk++++;;
pp++++;;
ccoonnttiinnuuee;;

Sec. 26.10        Code For The Lexical Analyzer 
631
ccaassee SSHH__GGRREEAATTEERR::
ttookkttyypp[[nnttookk]] == SSHH__TTOOKK__GGRREEAATTEERR;;
ttookkbbuuff[[ttbbiinnddeexx++++]] == cchh;;
ttookkbbuuff[[ttbbiinnddeexx++++]] == NNUULLLLCCHH;;
nnttookk++++;;
pp++++;;
ccoonnttiinnuuee;;
ddeeffaauulltt::
ttookkttyypp[[nnttookk]] == SSHH__TTOOKK__OOTTHHEERR;;
}};;
//** HHaannddllee qquuootteedd ssttrriinngg ((ssiinnggllee oorr ddoouubbllee qquuoottee)) **//
iiff (( ((cchh====SSHH__SSQQUUOOTTEE)) |||| ((cchh====SSHH__DDQQUUOOTTEE)) )) {{
qquuoottee == cchh;;
//** rreemmeemmbbeerr ooppeenniinngg qquuoottee **//
//** CCooppyy qquuootteedd ssttrriinngg ttoo aarrgg aarreeaa **//
pp++++;;
//** MMoovvee ppaasstt ssttaarrttiinngg qquuoottee **//
wwhhiillee (( ((((cchh==**pp++++)) !!== qquuoottee)) &&&& ((cchh !!== SSHH__NNEEWWLLIINNEE))
&&&& ((cchh !!== NNUULLLLCCHH)) )) {{
ttookkbbuuff[[ttbbiinnddeexx++++]] == cchh;;
}} 
iiff ((cchh !!== qquuoottee)) {{
//** ssttrriinngg mmiissssiinngg eenndd qquuoottee **//
rreettuurrnn SSYYSSEERRRR;;
}} 
//** FFiinniisshheedd ssttrriinngg -- ccoouunntt ttookkeenn aanndd ggoo oonn
**//
ttookkbbuuff[[ttbbiinnddeexx++++]] == NNUULLLLCCHH;; //** tteerrmmiinnaattee ttookkeenn
**//
nnttookk++++;;
//** ccoouunntt ssttrriinngg aass oonnee ttookkeenn
**//
ccoonnttiinnuuee;;
//** ggoo ttoo nneexxtt ttookkeenn
**//
}} 
//** HHaannddllee aa ttookkeenn ootthheerr tthhaann aa qquuootteedd ssttrriinngg
**//
ttookkbbuuff[[ttbbiinnddeexx++++]] == cchh;; //** ppuutt ffiirrsstt cchhaarraacctteerr iinn bbuuffffeerr**//
pp++++;;
wwhhiillee (( ((((cchh == **pp)) !!== SSHH__NNEEWWLLIINNEE)) &&&& ((cchh !!== NNUULLLLCCHH))
&&&& ((cchh !!== SSHH__LLEESSSS))
&&&& ((cchh !!== SSHH__GGRREEAATTEERR))
&&&& ((cchh !!== SSHH__BBLLAANNKK)) &&&& ((cchh !!== SSHH__TTAABB))
&&&& ((cchh !!== SSHH__AAMMPPEERR)) &&&& ((cchh !!== SSHH__SSQQUUOOTTEE))
&&&& ((cchh !!== SSHH__DDQQUUOOTTEE)) ))
{{

632 
An Example User Interface: The Xinu Shell 
Chap. 26
ttookkbbuuff[[ttbbiinnddeexx++++]] == cchh;;
pp++++;;
}} 
//** RReeppoorrtt eerrrroorr iiff ootthheerr ttookkeenn iiss aappppeennddeedd **//
iiff ((
((cchh ==== SSHH__SSQQUUOOTTEE)) |||| ((cchh ==== SSHH__DDQQUUOOTTEE))
|||| ((cchh ==== SSHH__LLEESSSS))
|||| ((cchh ==== SSHH__GGRREEAATTEERR)) )) {{
rreettuurrnn SSYYSSEERRRR;;
}} 
ttookkbbuuff[[ttbbiinnddeexx++++]] == NNUULLLLCCHH;;
//** tteerrmmiinnaattee tthhee ttookkeenn
**//
nnttookk++++;;
//** ccoouunntt vvaalliidd ttookkeenn
**//
}} 
**ttlleenn == ttbbiinnddeexx;;
rreettuurrnn nnttookk;;
}}
The first two arguments of lexan give the address of an input line and the number 
of characters on the line. Succeeding arguments give pointers to the data structures that 
Figure 26.3 illustrates.  Lexan initializes the number of tokens found, a pointer to the in-
put line, and an index into array tokbuf. It then enters a while loop that runs until 
pointer p reaches the end of the line.
To process a token, lexan skips leading whitespace (i.e., blanks and tabs), stores 
the current index of tokbuf in array tok, and then uses a switch statement to choose the 
action appropriate for the next input character. For any of the single-character tokens 
(i.e., an ampersand, less-than symbol, or greater-than symbol), lexan records the token 
type in array toktyp, places the token followed by a null character in the tokbuf array, 
increments ntok, moves to the next character in the string, and continues the while loop, 
which will start to process the next input character.
For a character that is not one of the three single-character tokens, lexan records
the token type as SH_TOK_OTHER and exits the switch statement. There are two
cases: the token is a quoted string or the token consists of contiguous characters up to
the next special character or whitespace.  Lexan recognizes either a single-quote or a 
double-quote character; the string ends at the first occurrence of a matching quote or the 
end-of-line, whichever occurs first. If it encounters an end-of-line condition in a string, 
lexan returns SYSERR. Otherwise, it copies characters from the string to tokbuf un-
changed and uninterpreted, which means that a string can contain arbitrary characters, 
including whitespace and the other quote mark character. Once the copy has been com-
pleted, lexan appends a null character to define the end of the token. It then continues 
the outer while loop to look for the next token.

Sec. 26.10        Code For The Lexical Analyzer 
633
The final section of code handles a token that is composed of contiguous characters 
other than the single token characters and quotes. The code loops until it encounters a 
special character or whitespace, placing characters in successive locations of tokbuf. 
Before moving on to the next token, the code checks for an error where two tokens oc-
cur with no whitespace between them.
Once lexan reaches the end of the input line, it returns a count of the number of to-
kens found. If an error is detected during processing, lexan returns SYSERR to its call-
er, making no attempt to recover or repair the problem. That is, the action to be taken 
when an error occurs is coded into lexan. The exercises discuss the choice of error han-
dling and suggest alternatives.
26.11 The Heart Of The Command Interpreter
Although a command interpreter must handle many details, the basic algorithm is 
not difficult to understand. At the top level, the code consists of a loop that repeatedly 
reads a line of input, uses lexan to extract tokens, checks the syntax, arranges a way to 
pass arguments, redirects I/O if necessary, and runs a command in foreground or back-
ground as specified. The loop terminates if a user enters the end-of-file character 
(control-d), or if a command returns a special exit code.
As with the lexical analyzer, our interpreter implementation uses an ad hoc imple-
mentation. That is, the code does not resemble a conventional compiler, nor does it 
contain independent code to verify that the sequence of tokens is valid. Instead, error 
checking is built into each step of processing. For example, after it has processed back-
ground and I/O redirection, the shell verifies that remaining tokens are all of type 
SH_TOK_OTHER.
Examining the code will make the approach clear. Function shell performs com-
mand interpretation; file shell.c, shown below, contains the code. Note that the file also 
includes the declaration of array cmdtab which specifies the set of commands and the 
function used to implement each. In addition, the code sets external variable ncmd to 
the number of commands in the table.
Conceptually, the set of commands is independent from the code that processes 
user input. Thus, it may make sense to divide shell.c into two files: one that specifies 
commands and another that contains code. In practice, however, the two have been 
combined because the example set of commands is so small that an additional file is un-
necessary.

634 
An Example User Interface: The Xinu Shell 
Chap. 26
//** sshheellll..cc
--
sshheellll **//
##iinncclluuddee <<xxiinnuu..hh>>
##iinncclluuddee <<ssttddiioo..hh>>
##iinncclluuddee ""sshhpprroottoottyyppeess..hh""
//************************************************************************************************************************************************//
//** TTaabbllee ooff XXiinnuu sshheellll ccoommmmaannddss aanndd tthhee ffuunnccttiioonn aassssoocciiaatteedd wwiitthh eeaacchh
**//
//************************************************************************************************************************************************//
ccoonnsstt
ssttrruucctt
ccmmddeenntt
ccmmddttaabb[[]] == {{
{{""aarrggeecchhoo"",,
TTRRUUEE,,
xxsshh__aarrggeecchhoo}},,
{{""aarrpp"",,
FFAALLSSEE,,
xxsshh__aarrpp}},,
{{""ccaatt"",,
FFAALLSSEE,,
xxsshh__ccaatt}},,
{{""cclleeaarr"",,
TTRRUUEE,,
xxsshh__cclleeaarr}},,
{{""ddaattee"",,
FFAALLSSEE,,
xxsshh__ddaattee}},,
{{""ddeevvdduummpp"",,
FFAALLSSEE,,
xxsshh__ddeevvdduummpp}},,
{{""eecchhoo"",,
FFAALLSSEE,,
xxsshh__eecchhoo}},,
{{""eexxiitt"",,
TTRRUUEE,,
xxsshh__eexxiitt}},,
{{""hheellpp"",,
FFAALLSSEE,,
xxsshh__hheellpp}},,
{{""iippaaddddrr"",,
FFAALLSSEE,,
xxsshh__iippaaddddrr}},,
{{""kkiillll"",,
TTRRUUEE,,
xxsshh__kkiillll}},,
{{""mmeemmdduummpp"",,
FFAALLSSEE,,
xxsshh__mmeemmdduummpp}},,
{{""mmeemmssttaatt"",,
FFAALLSSEE,,
xxsshh__mmeemmssttaatt}},,
{{""ppiinngg"",,
FFAALLSSEE,,
xxsshh__ppiinngg}},,
{{""ppss"",,
FFAALLSSEE,,
xxsshh__ppss}},,
{{""sslleeeepp"",,
FFAALLSSEE,,
xxsshh__sslleeeepp}},,
{{""uuddpp"",,
FFAALLSSEE,,
xxsshh__uuddppdduummpp}},,
{{""uuddppeecchhoo"",,
FFAALLSSEE,,
xxsshh__uuddppeecchhoo}},,
{{""uuddppeesseerrvveerr"",,
FFAALLSSEE,,
xxsshh__uuddppeesseerrvveerr}},,
{{""uuppttiimmee"",,
FFAALLSSEE,,
xxsshh__uuppttiimmee}},,
{{""??"",,
FFAALLSSEE,,
xxsshh__hheellpp}}
}};;
uuiinntt3322
nnccmmdd == ssiizzeeooff((ccmmddttaabb)) // ssiizzeeooff((ssttrruucctt ccmmddeenntt));;
//************************************************************************************************************************************************//
//** sshheellll
--
PPrroovviiddee aann iinntteerraaccttiivvee uusseerr iinntteerrffaaccee tthhaatt eexxeeccuutteess
**//
//**
ccoommmmaannddss..
EEaacchh ccoommmmaanndd bbeeggiinnss wwiitthh aa ccoommmmaanndd nnaammee,, hhaass
**//
//**
aa sseett ooff ooppttiioonnaall aarrgguummeennttss,, hhaass ooppttiioonnaall iinnppuutt oorr
**//
//**
oouuttppuutt rreeddiirreeccttiioonn,, aanndd aann ooppttiioonnaall ssppeecciiffiiccaattiioonn ffoorr
**//
//**
bbaacckkggrroouunndd eexxeeccuuttiioonn ((aammppeerrssaanndd))..
TThhee ssyynnttaaxx iiss::
**//
//** 
**//
//**
ccoommmmaanndd__nnaammee [[aarrggss**]] [[rreeddiirreeccttiioonn]] [[&&]]
**//
//** 
**//

Sec. 26.11        The Heart Of The Command Interpreter 
635
//**
RReeddiirreeccttiioonn iiss eeiitthheerr oorr bbootthh ooff::
**//
//** 
**//
//**
<< iinnppuutt__ffiillee
**//
//**
oorr
**//
//**
>> oouuttppuutt__ffiillee
**//
//** 
**//
//************************************************************************************************************************************************//
pprroocceessss sshheellll ((
ddiidd3322
ddeevv
//** IIDD ooff ttttyy ddeevviiccee ffrroomm wwhhiicchh
**//
))
//**
ttoo aacccceepptt ccoommmmaannddss
**//
{{
cchhaarr
bbuuff[[SSHHEELLLL__BBUUFFLLEENN]];;
//** IInnppuutt lliinnee ((llaarrggee eennoouugghh ffoorr **//
//**
oonnee lliinnee ffrroomm aa ttttyy ddeevviiccee **//
iinntt3322
lleenn;;
//** LLeennggtthh ooff lliinnee rreeaadd
**//
cchhaarr
ttookkbbuuff[[SSHHEELLLL__BBUUFFLLEENN ++
//** BBuuffffeerr ttoo hhoolldd aa sseett ooff
**//
SSHHEELLLL__MMAAXXTTOOKK]];;
//** CCoonnttiigguuoouuss nnuullll--tteerrmmiinnaatteedd
**//
//** SSttrriinnggss ooff ttookkeennss
**//
iinntt3322
ttlleenn;;
//** CCuurrrreenntt lleennggtthh ooff aallll ddaattaa
**//
//**
iinn aarrrraayy ttookkbbuuff
**//
iinntt3322
ttookk[[SSHHEELLLL__MMAAXXTTOOKK]];;
//** IInnddeexx ooff eeaacchh ttookkeenn iinn
**//
//**
aarrrraayy ttookkbbuuff
**//
iinntt3322
ttookkttyypp[[SSHHEELLLL__MMAAXXTTOOKK]];;
//** TTyyppee ooff eeaacchh ttookkeenn iinn ttookkbbuuff **//
iinntt3322
nnttookk;;
//** NNuummbbeerr ooff ttookkeennss oonn lliinnee
**//
ppiidd3322
cchhiilldd;;
//** PPrroocceessss IIDD ooff ssppaawwnneedd cchhiilldd
**//
bbooooll88
bbaacckkggnndd;;
//** RRuunn ccoommmmaanndd iinn bbaacckkggrroouunndd??
**//
cchhaarr
**oouuttnnaammee,, **iinnnnaammee;;
//** PPooiinntteerrss ttoo ssttrriinnggss ffoorr ffiillee **//
//**
nnaammeess tthhaatt ffoollllooww >> aanndd <<
**//
ddiidd3322
ssttddiinnppuutt,, ssttddoouuttppuutt;;
//** DDeessccrriippttoorrss ffoorr rreeddiirreecctteedd
**//
//**
iinnppuutt aanndd oouuttppuutt
**//
iinntt3322
ii;;
//** IInnddeexx iinnttoo aarrrraayy ooff ttookkeennss
**//
iinntt3322
jj;;
//** IInnddeexx iinnttoo aarrrraayy ooff ccoommmmaannddss **//
iinntt3322
mmssgg;;
//** MMeessssaaggee ffrroomm rreecceeiivvee(()) ffoorr
**//
//**
cchhiilldd tteerrmmiinnaattiioonn
**//
iinntt3322
ttmmppaarrgg;;
//** AAddddrreessss ooff tthhiiss vvaarr iiss uusseedd
**//
//**
wwhheenn ffiirrsstt ccrreeaattiinngg cchhiilldd
**//
//**
pprroocceessss,, bbuutt iiss rreeppllaacceedd
**//
cchhaarr
**ssrrcc,, **ccmmpp;;
//** PPooiinntteerrss uusseedd dduurriinngg nnaammee
**//
//**
ccoommppaarriissoonn
**//
bbooooll88
ddiiffff;;
//** WWaass ddiiffffeerreennccee ffoouunndd dduurriinngg
**//
//**
ccoommppaarriissoonn
**//
cchhaarr
**aarrggss[[SSHHEELLLL__MMAAXXTTOOKK]];;
//** AArrgguummeenntt vveeccttoorr ppaasssseedd ttoo
**//
//**
bbuuiillttiinn ccoommmmaannddss
**//
//** PPrriinntt sshheellll bbaannnneerr aanndd ssttaarrttuupp mmeessssaaggee **//

636 
An Example User Interface: The Xinu Shell 
Chap. 26
ffpprriinnttff((ddeevv,, ""\\nn\\nn%%ss%%ss\\nn%%ss\\nn%%ss\\nn%%ss\\nn%%ss\\nn%%ss\\nn%%ss\\nn%%ss\\nn%%ss\\nn"",,
SSHHEELLLL__BBAANN00,,SSHHEELLLL__BBAANN11,,SSHHEELLLL__BBAANN22,,SSHHEELLLL__BBAANN33,,SSHHEELLLL__BBAANN44,,
SSHHEELLLL__BBAANN55,,SSHHEELLLL__BBAANN66,,SSHHEELLLL__BBAANN77,,SSHHEELLLL__BBAANN88,,SSHHEELLLL__BBAANN99));;
ffpprriinnttff((ddeevv,, ""%%ss\\nn\\nn"",, SSHHEELLLL__SSTTRRTTMMSSGG));;
//** CCoonnttiinnuuaallllyy pprroommpptt tthhee uusseerr,, rreeaadd iinnppuutt,, aanndd eexxeeccuuttee ccoommmmaanndd **//
wwhhiillee ((TTRRUUEE)) {{
//** DDiissppllaayy pprroommpptt **//
ffpprriinnttff((ddeevv,, SSHHEELLLL__PPRROOMMPPTT));;
//** RReeaadd aa ccoommmmaanndd **//
lleenn == rreeaadd((ddeevv,, bbuuff,, ssiizzeeooff((bbuuff))));;
//** EExxiitt ggrraacceeffuullllyy oonn eenndd--ooff--ffiillee **//
iiff ((lleenn ==== EEOOFF)) {{
bbrreeaakk;;
}} 
//** IIff lliinnee ccoonnttaaiinnss oonnllyy NNEEWWLLIINNEE,, ggoo ttoo nneexxtt lliinnee **//
iiff ((lleenn <<== 11)) {{
ccoonnttiinnuuee;;
}} 
bbuuff[[lleenn]] == SSHH__NNEEWWLLIINNEE;;
//** tteerrmmiinnaattee lliinnee **//
//** PPaarrssee iinnppuutt lliinnee aanndd ddiivviiddee iinnttoo ttookkeennss **//
nnttookk == lleexxaann((bbuuff,, lleenn,, ttookkbbuuff,, &&ttlleenn,, ttookk,, ttookkttyypp));;
//** HHaannddllee ppaarrssiinngg eerrrroorr **//
iiff ((nnttookk ==== SSYYSSEERRRR)) {{
ffpprriinnttff((ddeevv,,""%%ss\\nn"",, SSHHEELLLL__SSYYNNEERRRRMMSSGG));;
ccoonnttiinnuuee;;
}} 
//** IIff lliinnee iiss eemmppttyy,, ggoo ttoo nneexxtt iinnppuutt lliinnee **//
iiff ((nnttookk ==== 00)) {{

Sec. 26.11        The Heart Of The Command Interpreter 
637
ffpprriinnttff((ddeevv,, ""\\nn""));;
ccoonnttiinnuuee;;
}} 
//** IIff llaasstt ttookkeenn iiss ’’&&’’,, sseett bbaacckkggrroouunndd **//
iiff ((ttookkttyypp[[nnttookk--11]] ==== SSHH__TTOOKK__AAMMPPEERR)) {{
nnttookk---- ;;
ttlleenn--== 22;;
bbaacckkggnndd == TTRRUUEE;;
}} eellssee {{
bbaacckkggnndd == FFAALLSSEE;;
}} 
//** CChheecckk ffoorr iinnppuutt//oouuttppuutt rreeddiirreeccttiioonn ((ddeeffaauulltt iiss nnoonnee)) **//
oouuttnnaammee == iinnnnaammee == NNUULLLL;;
iiff (( ((nnttookk >>==33)) &&&& (( ((ttookkttyypp[[nnttookk--22]] ==== SSHH__TTOOKK__LLEESSSS))
||||((ttookkttyypp[[nnttookk--22]] ==== SSHH__TTOOKK__GGRREEAATTEERR)))))){{
iiff ((ttookkttyypp[[nnttookk--11]] !!== SSHH__TTOOKK__OOTTHHEERR)) {{
ffpprriinnttff((ddeevv,,""%%ss\\nn"",, SSHHEELLLL__SSYYNNEERRRRMMSSGG));;
ccoonnttiinnuuee;;
}} 
iiff ((ttookkttyypp[[nnttookk--22]] ==== SSHH__TTOOKK__LLEESSSS)) {{
iinnnnaammee ==
&&ttookkbbuuff[[ttookk[[nnttookk--11]]]];;
}} eellssee {{
oouuttnnaammee == &&ttookkbbuuff[[ttookk[[nnttookk--11]]]];;
}} 
nnttookk --== 22;;
ttlleenn == ttookk[[nnttookk]];;
}} 
iiff (( ((nnttookk >>==33)) &&&& (( ((ttookkttyypp[[nnttookk--22]] ==== SSHH__TTOOKK__LLEESSSS))
||||((ttookkttyypp[[nnttookk--22]] ==== SSHH__TTOOKK__GGRREEAATTEERR)))))){{
iiff ((ttookkttyypp[[nnttookk--11]] !!== SSHH__TTOOKK__OOTTHHEERR)) {{
ffpprriinnttff((ddeevv,,""%%ss\\nn"",, SSHHEELLLL__SSYYNNEERRRRMMSSGG));;
ccoonnttiinnuuee;;
}} 
iiff ((ttookkttyypp[[nnttookk--22]] ==== SSHH__TTOOKK__LLEESSSS)) {{
iiff ((iinnnnaammee !!== NNUULLLL)) {{
ffpprriinnttff((ddeevv,,""%%ss\\nn"",, SSHHEELLLL__SSYYNNEERRRRMMSSGG));;
ccoonnttiinnuuee;;
}}

638 
An Example User Interface: The Xinu Shell 
Chap. 26
iinnnnaammee == &&ttookkbbuuff[[ttookk[[nnttookk--11]]]];;
}} eellssee {{
iiff ((oouuttnnaammee !!== NNUULLLL)) {{
ffpprriinnttff((ddeevv,,""%%ss\\nn"",, SSHHEELLLL__SSYYNNEERRRRMMSSGG));;
ccoonnttiinnuuee;;
}} 
oouuttnnaammee == &&ttookkbbuuff[[ttookk[[nnttookk--11]]]];;
}} 
nnttookk --== 22;;
ttlleenn == ttookk[[nnttookk]];;
}} 
//** VVeerriiffyy rreemmaaiinniinngg ttookkeennss aarree ttyyppee ""ootthheerr"" **//
ffoorr ((ii==00;; ii<<nnttookk;; ii++++)) {{
iiff ((ttookkttyypp[[ii]] !!== SSHH__TTOOKK__OOTTHHEERR)) {{
bbrreeaakk;;
}}
}} 
iiff ((((nnttookk ==== 00)) |||| ((ii << nnttookk)))) {{
ffpprriinnttff((ddeevv,, SSHHEELLLL__SSYYNNEERRRRMMSSGG));;
ccoonnttiinnuuee;;
}} 
ssttddiinnppuutt == ssttddoouuttppuutt == ddeevv;;
//** LLooookkuupp ffiirrsstt ttookkeenn iinn tthhee ccoommmmaanndd ttaabbllee **//
ffoorr ((jj == 00;; jj << nnccmmdd;; jj++++)) {{
ssrrcc == ccmmddttaabb[[jj]]..ccnnaammee;;
ccmmpp == ttookkbbuuff;;
ddiiffff == FFAALLSSEE;;
wwhhiillee ((**ssrrcc !!== NNUULLLLCCHH)) {{
iiff ((**ccmmpp !!== **ssrrcc)) {{
ddiiffff == TTRRUUEE;;
bbrreeaakk;;
}} 
ssrrcc++++;;
ccmmpp++++;;
}} 
iiff ((ddiiffff |||| ((**ccmmpp !!== NNUULLLLCCHH)))) {{
ccoonnttiinnuuee;;
}} eellssee {{
bbrreeaakk;;
}}

Sec. 26.11        The Heart Of The Command Interpreter 
639
}} 
//** HHaannddllee ccoommmmaanndd nnoott ffoouunndd **//
iiff ((jj >>== nnccmmdd)) {{
ffpprriinnttff((ddeevv,, ""ccoommmmaanndd %%ss nnoott ffoouunndd\\nn"",, ttookkbbuuff));;
ccoonnttiinnuuee;;
}} 
//** HHaannddllee bbuuiilltt--iinn ccoommmmaanndd **//
iiff ((ccmmddttaabb[[jj]]..ccbbuuiillttiinn)) {{ //** NNoo bbaacckkggrroouunndd oorr rreeddiirreecctt.. **//
iiff ((iinnnnaammee !!== NNUULLLL |||| oouuttnnaammee !!== NNUULLLL |||| bbaacckkggnndd)){{
ffpprriinnttff((ddeevv,, SSHHEELLLL__BBGGEERRRRMMSSGG));;
ccoonnttiinnuuee;;
}} eellssee {{
//** SSeett uupp aarrgg vveeccttoorr ffoorr ccaallll **//
ffoorr ((ii==00;; ii<<nnttookk;; ii++++)) {{
aarrggss[[ii]] == &&ttookkbbuuff[[ttookk[[ii]]]];;
}} 
//** CCaallll bbuuiillttiinn sshheellll ffuunnccttiioonn **//
iiff ((((**ccmmddttaabb[[jj]]..ccffuunncc))((nnttookk,, aarrggss))
==== SSHHEELLLL__EEXXIITT)) {{
bbrreeaakk;;
}}
}} 
ccoonnttiinnuuee;;
}} 
//** OOppeenn ffiilleess aanndd rreeddiirreecctt II//OO iiff ssppeecciiffiieedd **//
iiff ((iinnnnaammee !!== NNUULLLL)) {{
ssttddiinnppuutt == ooppeenn((NNAAMMEESSPPAACCEE,,iinnnnaammee,,""rroo""));;
iiff ((ssttddiinnppuutt ==== SSYYSSEERRRR)) {{
ffpprriinnttff((ddeevv,, SSHHEELLLL__IINNEERRRRMMSSGG,, iinnnnaammee));;
ccoonnttiinnuuee;;
}}
}} 
iiff ((oouuttnnaammee !!== NNUULLLL)) {{
ssttddoouuttppuutt == ooppeenn((NNAAMMEESSPPAACCEE,,oouuttnnaammee,,""ww""));;
iiff ((ssttddoouuttppuutt ==== SSYYSSEERRRR)) {{
ffpprriinnttff((ddeevv,, SSHHEELLLL__OOUUTTEERRRRMMSSGG,, oouuttnnaammee));;

640 
An Example User Interface: The Xinu Shell 
Chap. 26
ccoonnttiinnuuee;;
}} eellssee {{
ccoonnttrrooll((ssttddoouuttppuutt,, FF__CCTTLL__TTRRUUNNCC,, 00,, 00));;
}}
}} 
//** SSppaawwnn cchhiilldd tthhrreeaadd ffoorr nnoonn--bbuuiilltt--iinn ccoommmmaannddss **//
cchhiilldd == ccrreeaattee((ccmmddttaabb[[jj]]..ccffuunncc,,
SSHHEELLLL__CCMMDDSSTTKK,, SSHHEELLLL__CCMMDDPPRRIIOO,,
ccmmddttaabb[[jj]]..ccnnaammee,, 22,, nnttookk,, &&ttmmppaarrgg));;
//** IIff ccrreeaattiioonn oorr aarrgguummeenntt ccooppyy ffaaiillss,, rreeppoorrtt eerrrroorr **//
iiff ((((cchhiilldd ==== SSYYSSEERRRR)) ||||
((aaddddaarrggss((cchhiilldd,, nnttookk,, ttookk,, ttlleenn,, ttookkbbuuff,, &&ttmmppaarrgg))
==== SSYYSSEERRRR)) )) {{
ffpprriinnttff((ddeevv,, SSHHEELLLL__CCRREEAATTMMSSGG));;
ccoonnttiinnuuee;;
}} 
//** SSeett ssttddiinnppuutt aanndd ssttddoouuttppuutt iinn cchhiilldd ttoo rreeddiirreecctt II//OO **//
pprrooccttaabb[[cchhiilldd]]..pprrddeesscc[[00]] == ssttddiinnppuutt;;
pprrooccttaabb[[cchhiilldd]]..pprrddeesscc[[11]] == ssttddoouuttppuutt;;
mmssgg == rreeccvvccllrr(());;
rreessuummee((cchhiilldd));;
iiff ((!! bbaacckkggnndd)) {{
mmssgg == rreecceeiivvee(());;
wwhhiillee ((mmssgg !!== cchhiilldd)) {{
mmssgg == rreecceeiivvee(());;
}}
}}
}} 
//** TTeerrmmiinnaattee tthhee sshheellll pprroocceessss bbyy rreettuurrnniinngg ffrroomm tthhee ttoopp lleevveell **//
ffpprriinnttff((ddeevv,,SSHHEELLLL__EEXXIITTMMSSGG));;
rreettuurrnn OOKK;;
}}
The main loop calls lexan to divide the input line into tokens, and begins process-
ing the command. First, the code checks the last token to see if the user appended an

Sec. 26.11        The Heart Of The Command Interpreter 
641
ampersand. If so, the shell sets Boolean backgnd to TRUE; otherwise, backgnd is set to 
FALSE. The variable is used later to determine whether to run the command in back-
ground.
After the background token has been removed, the shell checks for I/O redirection. 
Input and output redirection can both be specified, and the specifications can occur in 
either order, but must be the last of the remaining tokens. Therefore, the shell checks 
for redirection twice. If two specifications occur, the shell verifies that they do not both 
specify input or both specify output. At this point in processing the line, the shell mere-
ly saves a pointer to the file name without attempting to open the file (the files are 
opened later).
Once the shell has removed tokens that specify I/O redirection, the only tokens 
that remain correspond to a command name and arguments to the command. Thus, be-
fore it continues to process the command, the shell iterates through remaining tokens to 
verify that they are of type “other” (SH_TOK_OTHER). If any are not, the code prints 
an error message and moves to the next input line. Once all checks have been per-
formed, the shell looks up the command and executes the corresponding function.
26.12 Command Name Lookup And Builtin Processing
The first token on the line is taken to be a command name. Recall that the exam-
ple code stores information about commands in array cmdtab. Thus, lookup is straight-
forward — the shell searches the array sequentially looking for an exact match between 
the first token and one of the command names. If no match is found, the code prints an 
error message and moves to the next command.
Our shell supports two types of commands: builtin and non-builtin. The difference 
arises from the way the commands are executed: the shell uses the conventional func-
tion call mechanism to execute a builtin command, and creates a separate process to ex-
ecute a non-builtin command. The distinction means that a user cannot specify back-
ground processing and cannot redirect I/O for a builtin command.†
To test whether a command should execute as a builtin, the shell examines field 
cbuiltin of the entry in cmdtab. For a builtin command, no redirection or background 
processing is allowed. So, the shell verifies that neither was specified, creates an argu-
ment array in variable args, and calls the command function. The next section explains 
how command arguments are constructed.
26.13 Arguments Passed To Commands
Our example shell uses the same argument passing mechanism as a Unix shell. 
When a command is invoked, the shell passes tokens from the command line as uninter-
preted, null-terminated strings. The shell does not know how many arguments a given 
command expects, nor does the shell understand whether the arguments make sense. 
                                †An exercise suggests a way to blur the distinction between builtin and non-builtin commands.

642 
An Example User Interface: The Xinu Shell 
Chap. 26
Instead, the shell merely passes all arguments from the command line, and allows the 
command to check and interpret them.
Conceptually, the shell passes an arbitrary number of string arguments, where the 
number is only limited by the length of an input line. To make programming simple
and uniform, the shell creates an array of pointers and only passes two values when it 
invokes a command: a count of command-line arguments and an array of pointers to 
character strings that constitute the arguments. Unix uses the names argc and argv for 
the two arguments a command receives from the shell; Xinu uses the names nargs and 
args. The names are only a convention — a programmer can choose arbitrary names 
for arguments when writing a function that implements a command.
The example shell adopts another convention from Unix: the first item in the args 
array is a pointer to the command name. An example will clarify the details. Consider
the command line:
date -f illegal
Although the argument illegal is not permitted by the Xinu date command, the shell
simply passes the string and allows the function that implements the date command to 
check its arguments. Figure 26.4 illustrates the two items the shell passes to the date 
function.
args
nargs 
3
d a
t
e Φ
-
f
Φ
i
l
l
e g a
l
Φ
Φ
nargs 
entries
Figure 26.4 Illustration of the two arguments (nargs and args) the shell
passes to the date command for an input line: date -f illegal
Although passing an integer, such as nargs, to a command is trivial, the args array 
is more complex. In essence, the shell must construct the args array, and then pass its 
address to the command. There are two cases: builtin commands and non-builtin com-
mands. We will consider builtins first.
After the shell has parsed the command line and removed tokens for I/O redirec-
tion and background processing, variable ntok will contain the count of remaining to-
kens, which is exactly the count needed for nargs. Furthermore, array tok contains the
index in tokbuf where each token begins. Therefore, the shell can create an args array
by computing the starting address of each token.
To form the args array, the code iterates through ntok tokens and for the ith token
computes the expression:
&tokbuf[tok[i]]

Sec. 26.13        Arguments Passed To Commands 
643
That is, it sets args[i] equal to the address of the ith token in tokbuf. Once array args
has been initialized, the shell calls the function that implements the builtin command.
26.14 Passing Arguments To A Non-builtin Command
The second case, non-builtin commands, is more complex. Our shell creates a 
separate process to execute commands that are not builtin, and the command can exe-
cute in background (i.e., the shell can continue to read and handle new input lines while 
the command process runs in background). The question arises: what mechanism 
should the shell use to pass arguments to a process? The shell cannot use the same ap-
proach as with builtin commands because a command running in background needs a 
separate copy of its arguments that will not change as the shell goes on to process 
another command.
There are two ways to solve the problem of argument passing for a non-builtin 
command: the shell can allocate separate storage to arguments or the shell can hide the 
arguments in storage already allocated for the process. Because Xinu does not automat-
ically release heap storage when a process terminates, the first approach requires the 
shell to keep a record of the argument storage allocated for each command so it can free 
the memory once the process completes. Thus, we have chosen the second approach:
After creating a process to execute a command, the shell places a
copy of arguments in the stack area of the process and then allows the 
process to execute.
Where on the process’s stack should arguments be placed? Although it might be 
possible to rewrite create so it leaves space at the top of the stack, doing so is messy. 
Thus, we have chosen to use the area at the bottom of the stack. The shell stores a 
copy of the args array followed by a copy of the strings in tokbuf in the stack. Of 
course, pointers in the copy of the args vector must be assigned the addresses of strings 
in the copy of tokbuf. Figure 26.5 illustrates how the data from Figure 26.4 is arranged
in contiguous memory locations.
d a
t
e Φ -
f
Φ
i
l
l
e g a
l
Φ
Φ
args array starts at lowest byte of user’s stack or next multiple of 4 bytes beyond it
Figure 26.5 A copy of the args array and argument strings in a process’s
stack.

644 
An Example User Interface: The Xinu Shell 
Chap. 26
Rather than incorporate code into the shell that copies items into the process’s
stack, our implementation uses a separate function, addargs. File addargs.c contains
the code.
//** aaddddaarrggss..cc -- aaddddaarrggss **//
##iinncclluuddee <<xxiinnuu..hh>>
##iinncclluuddee ""sshhpprroottoottyyppeess..hh""
//**------------------------------------------------------------------------------------------------------------------------------------------------
**
aaddddaarrggss
--
AAdddd llooccaall ccooppyy ooff aarrggvv--ssttyyllee aarrgguummeennttss ttoo tthhee ssttaacckk ooff
**
aa ccoommmmaanndd pprroocceessss tthhaatt hhaass bbeeeenn ccrreeaatteedd bbyy tthhee sshheellll
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
ssttaattuuss
aaddddaarrggss((
ppiidd3322
ppiidd,,
//** IIDD ooff pprroocceessss ttoo uussee
**//
iinntt3322
nnttookk,,
//** CCoouunntt ooff aarrgguummeennttss
**//
iinntt3322
ttookk[[]],,
//** IInnddeexx ooff ttookkeennss iinn ttookkbbuuff
**//
iinntt3322
ttlleenn,,
//** LLeennggtthh ooff ddaattaa iinn ttookkbbuuff
**//
cchhaarr
**ttookkbbuuff,,
//** AArrrraayy ooff nnuullll--tteerrmm.. ttookkeennss
**//
vvooiidd
**dduummmmyy
//** DDuummmmyy aarrgguummeenntt tthhaatt wwaass
**//
//**
uusseedd aatt ccrreeaattiioonn aanndd mmuusstt
**//
//**
bbee rreeppllaacceedd bbyy aa ppooiinntteerr
**//
//**
ttoo aann aarrgguummeenntt vveeccttoorr
**//
))
{{
iinnttmmaasskk mmaasskk;;
//** SSaavveedd iinntteerrrruupptt mmaasskk
**//
ssttrruucctt
pprroocceenntt **pprrppttrr;;
//** PPttrr ttoo pprroocceessss’’ ttaabbllee eennttrryy
**//
uuiinntt3322
aalloocc;;
//** AArrgguummeenntt llooccaattiioonn iinn pprroocceessss **//
//**
ssttaacckk aass aann iinntteeggeerr
**//
uuiinntt3322
**aarrgglloocc;;
//** LLooccaattiioonn iinn pprroocceessss’’ss ssttaacckk
**//
//**
ttoo ppllaaccee aarrggss vveeccttoorr
**//
cchhaarr
**aarrggssttrr;;
//** LLooccaattiioonn iinn pprroocceessss’’ss ssttaacckk
**//
//**
ttoo ppllaaccee aarrgg ssttrriinnggss
**//
uuiinntt3322
**sseeaarrcchh;;
//** ppooiinntteerr tthhaatt sseeaarrcchheess ffoorr
**//
//**
dduummmmyy aarrgguummeenntt oonn ssttaacckk
**//
uuiinntt3322
**aappttrr;;
//** WWaallkkss tthhrroouugghh aarrggss aarrrraayy
**//
iinntt3322
ii;;
//** IInnddeexx iinnttoo ttookk aarrrraayy
**//
mmaasskk == ddiissaabbllee(());;
//** CChheecckk aarrgguummeenntt ccoouunntt aanndd ddaattaa lleennggtthh **//
iiff (( ((nnttookk <<== 00)) |||| ((ttlleenn << 00)) )) {{

Sec. 26.14        Passing Arguments To A Non-builtin Command 
645
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}} 
pprrppttrr == &&pprrooccttaabb[[ppiidd]];;
//** CCoommppuuttee lloowweesstt llooccaattiioonn iinn tthhee pprroocceessss ssttaacckk wwhheerree tthhee
**//
//**
aarrggss aarrrraayy wwiillll bbee ssttoorreedd ffoolllloowweedd bbyy tthhee aarrgguummeenntt
**//
//**
ssttrriinnggss
**//
aalloocc == ((uuiinntt3322)) ((pprrppttrr-->>pprrssttkkbbaassee
-- pprrppttrr-->>pprrssttkklleenn ++ ssiizzeeooff((uuiinntt3322))));;
aarrgglloocc == ((uuiinntt3322**)) ((((aalloocc ++ 33)) && ~~00xx33));; //** rroouunndd mmuullttiippllee ooff 44
**//
//** CCoommppuuttee tthhee ffiirrsstt llooccaattiioonn bbeeyyoonndd aarrggss aarrrraayy ffoorr tthhee ssttrriinnggss **//
aarrggssttrr == ((cchhaarr **)) ((aarrgglloocc ++ ((nnttookk++11))));;
//** ++11 ffoorr aa nnuullll ppttrr
**//
//** SSeett eeaacchh llooccaattiioonn iinn tthhee aarrggss vveeccttoorr ttoo bbee tthhee aaddddrreessss ooff
**//
//**
ssttrriinngg aarreeaa pplluuss tthhee ooffffsseett ooff tthhiiss aarrgguummeenntt
**//
ffoorr ((aappttrr==aarrgglloocc,, ii==00;; ii << nnttookk;; ii++++)) {{
**aappttrr++++ == ((uuiinntt3322)) ((aarrggssttrr ++ ttookk[[ii]]));;
}} 
//** AAdddd aa nnuullll ppooiinntteerr ttoo tthhee aarrggss aarrrraayy **//
**aappttrr++++ == ((uuiinntt3322))NNUULLLL;;
//** CCooppyy tthhee aarrgguummeenntt ssttrriinnggss ffrroomm ttookkbbuuff iinnttoo pprroocceessss’’ss ssttaacckk
**//
//**
jjuusstt bbeeyyoonndd tthhee aarrggss vveeccttoorr
**//
mmeemmccppyy((aappttrr,, ttookkbbuuff,, ttlleenn));;
//** FFiinndd tthhee sseeccoonndd aarrgguummeenntt iinn pprroocceessss’’ss ssttaacckk **//
ffoorr ((sseeaarrcchh == ((uuiinntt3322 **))pprrppttrr-->>pprrssttkkppttrr;;
sseeaarrcchh << ((uuiinntt3322 **))pprrppttrr-->>pprrssttkkbbaassee;; sseeaarrcchh++++)) {{
//** IIff ffoouunndd,, rreeppllaaccee wwiitthh tthhee aaddddrreessss ooff tthhee aarrggss vveeccttoorr**//
iiff ((**sseeaarrcchh ==== ((uuiinntt3322))dduummmmyy)) {{
**sseeaarrcchh == ((uuiinntt3322))aarrgglloocc;;
rreessttoorree((mmaasskk));;
rreettuurrnn OOKK;;
}}
}}

646 
An Example User Interface: The Xinu Shell 
Chap. 26
//** AArrgguummeenntt vvaalluuee nnoott ffoouunndd oonn tthhee ssttaacckk -- rreeppoorrtt aann eerrrroorr **//
rreessttoorree((mmaasskk));;
rreettuurrnn SSYYSSEERRRR;;
}}
Once a process has been created, the process table entry contains both the address 
of the top of the stack and the stack size. Because a stack grows downward in memory, 
addargs can compute the lowest memory address assigned to the stack by subtracting 
the stack size from the address of the stack top. However, a few details complicate the 
code. For example, on some processors pointers must be aligned. Therefore, addargs 
computes a starting location in the stack that is a multiple of four bytes. As a result, the 
final byte of the last argument string may end up to three bytes before the lowest byte 
of the stack. Furthermore, the code adds an extra null pointer to the end of the args ar-
ray as shown in Figure 26.5.
Most of code in addargs operates as expected by computing the address in the
stack at which the args array starts and then copying both the args array and the argu-
ment strings into the stack. However, the final for loop, which iterates through the
process’s stack may seem unusual: it finds the second argument that has been passed to 
the process and replaces it with a pointer to the args array. When the process is creat-
ed, the shell uses a dummy value for the argument and then passes the value to addargs 
in parameter dummy. Thus, addargs searches the stack until it finds the value and re-
places it.
Why does our implementation use a dummy argument and a search? The alterna-
tive consists of having addargs calculate the location of the second argument. Although 
calculating a location may seem cleaner, such a calculation requires addargs to under-
stand the format of the initial process stack. Using a search means that only create 
needs to understand the details of process creation and the format of the stack. Of 
course, using a search has a disadvantage: the shell must choose a dummy argument 
that will not occur early in the stack. Rather than choosing an arbitrary integer, our 
shell implementation uses the address of variable tmparg.
26.15 I/O Redirection
Once a process has been created to execute a command and the shell has called ad-
dargs to copy arguments into the process stack, all that remains is to handle I/O 
redirection and start the process executing. To redirect I/O, the shell assigns device 
descriptors to the array prdesc in the process table entry. The two key values are 
prdesc[0] and prdesc[1], which the shell sets to stdin and stdout.
How do variables stdin and stdout receive values? Recall that the shell initializes 
them to dev, the device descriptor that was passed as an argument when the shell was 
invoked. Usually, the shell is invoked with device CONSOLE. Thus, if the user does 
not redirect I/O, the process executing a command will “inherit” the console device for

Sec. 26.15        I  /O Redirection 
647
input and output. If a user does redirect I/O, the shell sets variables inname and/or out-
name to the name that was specified on the command line. Otherwise inname and out-
name are set to NULL. Before assigning stdin and stdout to the command process, the 
shell checks inname and outname. If inname is non-null, the shell calls open to open 
inname for reading and sets stdin to the descriptor. Similarly, if outname is non-null, 
the shell calls open to open outname for writing, and sets stdout to the descriptor.
When should descriptors be closed? Our example code assumes that the command
will close standard input and standard output descriptors before it exits; the shell does
not clean up descriptors after the command completes. Forcing all commands to close 
their standard I/O devices before exiting has the disadvantage of making commands dif-
ficult to understand and difficult to program correctly because command code must 
remember to close devices even though the code does not open them. Having the shell 
monitor command processes and close standard I/O devices is also difficult because 
command processes are independent and multiple command processes can exit at the 
same time. The exercises suggest another alternative.
The final section of code in the shell runs the command process. There are two
cases. To run the process in foreground, the shell calls resume to start the process, and
then calls receive to wait for a message that the process has completed (when the proc-
ess exits, kill sends a message to the shell). For the background case, the shell starts the 
command process but does not wait. Instead, the main shell loop continues and the 
shell reads the next command. The exercises suggest a modification of the code to im-
prove correctness.
26.16 An Example Command Function (sleep)
To understand how a command processes arguments, consider function xsh_sleep, 
which implements the sleep command.†  Sleep is trivial — it delays for the number of 
seconds specified by its argument. Thus, the delay is achieved by a single line of code 
that calls the sleep system function; the code is presented here merely to illustrate how 
arguments are parsed and how a command function prints a help message. File 
xsh.sleep.c contains the code.
                                †By convention, the function that implements command X is named xsh_X.

648 
An Example User Interface: The Xinu Shell 
Chap. 26
//** xxsshh__sslleeeepp..cc -- xxsshh__sslleeeepp **//
##iinncclluuddee <<xxiinnuu..hh>>
##iinncclluuddee <<ssttddiioo..hh>>
##iinncclluuddee <<ssttrriinngg..hh>>
//**------------------------------------------------------------------------------------------------------------------------------------------------
** xxsshh__sslleeeepp
--
SShheellll ccoommmmaanndd ttoo ddeellaayy ffoorr aa ssppeecciiffiieedd nnuummbbeerr ooff sseeccoonnddss
**------------------------------------------------------------------------------------------------------------------------------------------------
**//
sshheellllccmmdd xxsshh__sslleeeepp((iinntt nnaarrggss,, cchhaarr **aarrggss[[]]))
{{
iinntt3322
ddeellaayy;;
//** DDeellaayy iinn sseeccoonnddss
**//
cchhaarr
**cchhppttrr;;
//** WWaallkkss tthhrroouugghh aarrgguummeenntt
**//
cchhaarr
cchh;;
//** NNeexxtt cchhaarraacctteerr ooff aarrgguummeenntt
**//
//** FFoorr aarrgguummeenntt ’’----hheellpp’’,, eemmiitt hheellpp aabboouutt tthhee ’’sslleeeepp’’ ccoommmmaanndd
**//
iiff ((nnaarrggss ==== 22 &&&& ssttrrnnccmmpp((aarrggss[[11]],, ""----hheellpp"",, 77)) ==== 00)) {{
pprriinnttff((""UUssee:: %%ss\\nn\\nn"",, aarrggss[[00]]));;
pprriinnttff((""DDeessccrriippttiioonn::\\nn""));;
pprriinnttff((""\\ttDDeellaayy ffoorr aa ssppeecciiffiieedd nnuummbbeerr ooff sseeccoonnddss\\nn""));;
pprriinnttff((""OOppttiioonnss::\\nn""));;
pprriinnttff((""\\tt----hheellpp\\tt ddiissppllaayy tthhiiss hheellpp aanndd eexxiitt\\nn""));;
rreettuurrnn 00;;
}} 
//** CChheecckk ffoorr vvaalliidd nnuummbbeerr ooff aarrgguummeennttss **//
iiff ((nnaarrggss >> 22)) {{
ffpprriinnttff((ssttddeerrrr,, ""%%ss:: ttoooo mmaannyy aarrgguummeennttss\\nn"",, aarrggss[[00]]));;
ffpprriinnttff((ssttddeerrrr,, ""TTrryy ’’%%ss ----hheellpp’’ ffoorr mmoorree iinnffoorrmmaattiioonn\\nn"",,
aarrggss[[00]]));;
rreettuurrnn 11;;
}} 
iiff ((nnaarrggss !!== 22)) {{
ffpprriinnttff((ssttddeerrrr,, ""%%ss:: aarrgguummeenntt iinn eerrrroorr\\nn"",, aarrggss[[00]]));;
ffpprriinnttff((ssttddeerrrr,, ""TTrryy ’’%%ss ----hheellpp’’ ffoorr mmoorree iinnffoorrmmaattiioonn\\nn"",,
aarrggss[[00]]));;
rreettuurrnn 11;;
}} 
cchhppttrr == aarrggss[[11]];;
cchh == **cchhppttrr++++;;

Sec. 26.16        An Example Command Function (sleep) 
649
ddeellaayy == 00;;
wwhhiillee ((cchh !!== NNUULLLLCCHH)) {{
iiff (( ((cchh << ’’00’’)) |||| ((cchh >> ’’99’’)) )) {{
ffpprriinnttff((ssttddeerrrr,, ""%%ss:: nnoonnddiiggiitt iinn aarrgguummeenntt\\nn"",,
aarrggss[[00]]));;
rreettuurrnn 11;;
}} 
ddeellaayy == 1100**ddeellaayy ++ ((cchh -- ’’00’’));;
cchh == **cchhppttrr++++;;
}} 
sslleeeepp((ddeellaayy));;
rreettuurrnn 00;;
}}
26.17 Perspective
The design of a shell introduces many choices. A designer has almost complete 
freedom because a shell operates as an application that lies outside the rest of the sys-
tem and only the command functions depend on the shell. Thus, as our example shows, 
the argument passing paradigm used by a shell can differ dramatically from the argu-
ment passing paradigm used throughout the rest of the system. Similarly, a designer 
can choose a syntax for command-line input as well as a semantic interpretation without 
affecting other parts of the system.
Perhaps the most interesting aspect of shell design arises from the choice of how 
much knowledge about commands is bound into the shell. On the one hand, if a shell 
knows all commands and their arguments, the shell can complete command names and 
check the command arguments, making the code that implements commands much 
simpler. On the other hand, allowing late binding means more flexibility because the 
shell does not need to change when new commands are created, but the tradeoff is that 
each command must check its arguments. Furthermore, a designer can choose whether 
to build each command function into the shell or to leave each command in a separate 
file, as Unix does.
Our example shell demonstrates one of the most important principles in shell
design: a relatively small amount of code can provide powerful abstractions for a user.
For example, consider how little code is needed to interpret input or output redirection, 
and the small amount of code needed to recognize an ampersand at the end of the line 
as a request to run a command in background. Despite their compact implementation, 
facilities for I/O redirection and background processing make a shell much more 
powerful and user-friendly than a shell in which each command interacts with a user to 
prompt for input and output information or whether to run in background.

650 
An Example User Interface: The Xinu Shell 
Chap. 26
26.18 Summary
We have examined a basic command-line interpreter called a shell. Although the 
example code is small, it supports concurrent command execution, redirection of input 
and output, and arbitrary string argument passing. The implementation is divided into 
two conceptual pieces: a lexical analyzer that reads a line of text and groups characters 
into tokens, and a shell function that checks the sequence of tokens and invokes a com-
mand.
The example code demonstrates the relationship between a user interface and the 
facilities provided by the underlying system. For example, although the underlying sys-
tem provides support for concurrent processes, the shell makes concurrent execution 
available to a user. Similarly, although the underlying system provides the ability to 
open devices or files, the shell makes I/O redirection available to the user.
EXERCISES
26.1  
Rewrite the shell to use raw mode and handle all keyboard input. Arrange for Control-P
to move to the “previous” shell command, and interpret Control-B and Control-F as
moving backward and forward through a line as Unix ksh or bash do.
26.2 
Rewrite the grammar in Figure 26.2 to remove the optional notation [ ].
26.3  
Modify the shell to allow I/O redirection on builtin commands. What changes are
necessary?
26.4 
Devise a modified version of create that handles string arguments for the shell, automati-
cally performing the same function as addargs when creating the process.
26.5      Modify the shell so it can be used as a command.  That is, allow the user to invoke com-
mand shell and start with a new shell process. Have control return to the original shell
when the subshell exits. Be careful.
26.6 
Modify the shell so it can accept input from a text file (i.e., allow the user to build a file
of commands and then start a shell interpreting them).
26.7 
Modify the shell to allow a user to redirect standard error as well as standard output.
26.8 
Read about shell variables in a Unix shell, and implement a similar variable mechanism
in the Xinu shell.
26.9    Find out how the Unix shell passes environment variables to command processes, and
implement a similar mechanism in the Xinu shell.
26.10 
Implement inline input redirection, allowing the user to type
ccoommmmaanndd <<<< ssttoopp
followed by lines of input terminated by a line that begins with the sequence of charac-
ters stop. Have the shell save the input in a temporary file and execute the command 
with the temporary file as standard input.

Exercises
651
26.11 
It is possible to extend the command table to include information on the number and
types of arguments each command requires, and to have the shell check arguments be-
fore passing them to the command. List two advantages and two disadvantages of hav-
ing the shell check arguments.
26.12 
Suppose the designer decided to add a for statement to the shell so a user could execute
a command repeatedly as in:
ffoorr 11 22 33 44 55 66 77 88 99;; ccoommmmaanndd--lliinnee
where for is a keyword, and command-line is a command line exactly like commands the 
shell now accepts. Should the designer modify the shell syntax and parser or try to 
make for a builtin command? Explain.
26.13 
Add command completion to the shell by having the user type a unique prefix of a com-
mand followed by ESC; have the shell type out the completed command and wait for the 
user to add arguments and press the Enter key.
26.14 
Unix allows command lines of the form:
ccoommmmaanndd__11 || ccoommmmaanndd__22 || ccoommmmaanndd__33
where the symbol |, called a pipe, specifies that the standard output of one command is 
connected to the standard input of the next command. Implement a pipe device for 
Xinu, and modify the shell to allow a pipeline of commands.
26.15   Modify the tty device driver and shell so that pressing CONTROL-c kills the currently
executing process.
26.16    Modify the tty device driver and shell so that pressing CONTROL-z places the currently
executing process in background.
26.17    Modify the design to permit I/O redirection and background processing for builtin com-
mands: if redirection or background processing is needed, treat the command as a normal 
command and create a separate process.
26.18 
The text describes the problem of closing device descriptors when a command exits.
Modify the system so kill automatically closes a process’s descriptors when the process 
exits.
26.19 
The example shell calls receive to wait for a foreground process to exit, but does not
check the message received. Show a sequence of events that can cause the shell to
proceed before a foreground command has completed.
26.20    Modify the code in the shell to repair the problem in the previous exercise.


Appendix 1
Porting An Operating 
System
Progress, far from consisting in change, depends upon 
retentiveness....
— George Santayana
A1.1 Introduction
Throughout the text, we have focused on the interior of an operating system. 
Chapters present abstractions, discuss design tradeoffs, show how the code fits into a 
hierarchical organization, and examine implementation details. Chapter 25 examines 
how a system can be configured to allow the code to run on systems with a variety of 
peripheral devices.
This appendix examines two larger questions. First, how can an existing operating 
system be ported to a new hardware platform that differs in some fundamental ways? 
Second, can an operating system be written in a way that makes porting easier? To 
answer the first question, the appendix discusses cross-development and downloading, 
outlines the steps involved in understanding hardware, and provides practical advice 
about how to proceed. To answer the second question, the appendix discusses tech-
niques that have been used to make an operating system adaptable.
653

654
Operating System Design
A1.2 Motivation: Evolving Hardware
Although work on operating systems demands the ability to grasp high-level 
abstractions, design efficient mechanisms, and understand small details, the most signi-
ficant challenge facing operating system designers does not arise from the intellectual 
difficulty of the task. Instead, it arises from the constant changes in technology and the 
consequent economic pressure for vendors to create new products or to add features to 
existing products. While this revision of the text was being written, for example, one 
hardware vendor introduced two new hardware platforms. One of the platforms 
represented a minor improvement, but the other made dramatic changes in the processor 
chip, instruction set, memory organization, and I/O devices.
Because an operating system interfaces directly with the underlying hardware, even 
small changes in the hardware can have an overwhelming effect on the system. For ex-
ample, if a vendor changes the hardware to reserve a piece of the memory address space 
for Flash ROM, the memory management software in the operating system must be 
modified. Although such modification may seem straightforward, the details may in-
volve changes to page tables and the code that interacts with the MMU hardware as 
well as the code that allocates memory on demand. If a significant amount of the ad-
dress space becomes reserved, the operating system’s allocation policy may need to 
change. The point is:
Because both technological and economic factors cause continual 
changes in hardware, an operating system designer must be prepared 
to port the operating system to new platforms.
A1.3 Steps Taken When Porting An Operating System
Despite the effects of hardware change, moving an existing operating system to a 
new platform is much easier than designing and building a new system from scratch. In 
particular, if an operating system has been written in a high-level language, porting the 
system to a new platform is easy because a compiler can do most of the work.
Consider Xinu. Most of the code is written in C. If a C compiler is available for
the new platform, many of the functions can be compiled without making changes in
the source. If a given function deals with basic data structures, such as integers, charac-
ters, arrays, and structures, a compiler may be able to compile the code without change, 
and the resulting binary program may run correctly. Even in cases where change is 
needed, the modifications may be minor (e.g., to accommodate slight differences in 
compilers). Thus, a principle is:
An operating system written in a high-level language, such as C, is 
much easier to port to a new platform than a system written in assem-
bly language.

Sec. A1.3        Steps Taken When Porting An Operating System 
655
We will assume that, whenever possible, an operating system has been written in 
C, and we will consider the steps taken when porting to a new platform. Specifically, 
Figure A1.1 lists steps taken when porting Xinu.
                                                                        Step 
Description
                                                                        1. 
Learn about the new hardware
                                                                        2. 
Build cross-development tools
                                                                        3. 
Learn the compiler’s calling conventions
                                                                        4. 
Build a bootstrap mechanism
                                                                        5. 
Devise a basic polled output function
                                                                        6. 
Load and run a sequential program
                                                                        7. 
Port and test the basic memory manager
                                                                        8. 
Port the context switch and process creation functions
                                                                        9. 
Port and test the remaining process manager functions
                                                                        10. 
Build an interrupt dispatcher
                                                                        11. 
Port and test the real-time clock functions
                                                                        12. 
Port and test a tty driver
                                                                        13. 
Port or create drivers for an Ethernet and other devices
                                                                        14. 
Port the network stack, including Internet protocols
                                                                        15. 
Port the remote disk and RAM disk modules
                                                                        16. 
Port the local and remote file system modules
                                                                        17. 
Port the Xinu shell and other applications
                                                                        








































































































Figure A1.1  The steps taken when porting Xinu to a new platform.
Note the relationship between the steps listed and the Xinu hierarchy. In essence, 
porting follows the same pattern as design: lower levels of the hierarchy are ported first, 
and successive levels are then added. The next sections highlight each step.

656
Operating System Design
A1.3.1  Learning About The Hardware
Step 1 may seem straightforward. Unfortunately, some vendors are reluctant to re-
veal details about their commercial hardware or software. For example, one vendor of a 
popular platform for experimenters refuses to provide any details about the USB 
hardware, making it impossible to write a USB driver. Even if generic information is 
available (e.g., the processor instruction set), a vendor may choose to keep some details 
secret (e.g., a map of the bus address space, the hardware initialization sequence, or the 
details about addresses on the bus). Nevertheless, throughout the remainder of this ap-
pendix, we will assume that the needed information can be obtained.
A1.3.2  Build Cross-Development Tools
If the target hardware platform already runs a fully functional operating system, it 
may be possible to skip steps 1 through 6, and use the legacy operating system to com-
pile and boot a new system. In most cases, however, the target platform will be new, 
may lack the power needed for a production system, or may not be available for 
development. Therefore, an operating system designer usually does not rely on the tar-
get platform to support software development. Instead, a designer uses a cross-
development approach in which a compiler and linker run on a conventional computer 
system, but are configured to produce code for the target machine.
One of the most widely used cross-development environments consists of the Gnu
C Compiler, gcc, running on a Unix system, such as Linux or BSD. A copy of gcc can
be downloaded and used at no cost from:
http://gcc.gnu.org
After downloading the source code for gcc, a programmer must select configuration op-
tions to specify details, such as the target processor type and the endianness of the tar-
get machine. The programmer runs the Unix utility make to build a version of the com-
piler, assembler, and linker that will produce code for the target machine.
A1.3.3  Learn The Compiler’s Calling Conventions
Because it is a key to basic parts of an operating system, function invocation must 
be understood in detail. To build a context switch, for example, a programmer must 
precisely understand all details of the calling conventions. Although hardware designers 
include subroutine invocation mechanisms, understanding the hardware is not enough 
because a compiler can impose additional requirements.
It may seem that using an open source compiler means the calling conventions will 
be obvious. However, an operating system designer needs to know about special cases, 
and the answers to questions may be difficult to find. Fortunately, information is usual-
ly available on the web.

Sec. A1.3        Steps Taken When Porting An Operating System 
657
A1.3.4  Build A Bootstrap Mechanism
Once it has been compiled and linked, a program image must be downloaded into 
the target platform. Early embedded hardware required that the image be burned into a 
separate ROM chip and installed in a socket. Fortunately, modern systems use alterna-
tive mechanisms that require much less effort. Typically, the hardware includes 
bootstrap functionality that can read an image from an SD memory card or a USB de-
vice, accept an image over a console serial line, or download an image over a network. 
The bootstrap procedure is usually intended for system developers, and may not gen-
erally be known.
For example, consider the platforms used in the text. One can get started by build-
ing an image, storing the image on an SD memory card, and booting from the card. 
Manually moving a card from a development machine to the target platform after every 
change can be tedious. Downloading over a network means a developer can create a 
new image and boot it without touching the hardware. However, arranging a way to 
download an image over a network can sometimes be difficult. For example, the 
Galileo does not have facilities that can boot an image over a network, which is why we 
had to write a bootstrap program, place the program on an SD card, and arrange for the 
program to perform a network download. Whatever method is chosen, it is essential to 
find a way to boot a copy of an image on the target machine.
A1.3.5  Devise A Basic Polled Output Function
The next step in porting requires a programmer to devise a way for a running pro-
gram to output characters. Until some basic I/O is available, a programmer must work 
in the dark — hoping that the image has been downloaded and started correctly. Some
I/O is invaluable: once even basic I/O is available, a programmer can determine how 
much of the system is working, and can isolate problems quickly.
Because early test programs do not include interrupt processing, the basic I/O 
mechanism must use polling. A typical approach starts by finding a way to light an 
LED (e.g., by using GPIO pins). The key to development, however, lies in a kputc
function that waits for a serial I/O device to become ready and then transmits a charac-
ter. Both ends must agree on details such as the baud rate and bits per character, which 
can make debugging tedious. To simplify the code, the first version of kputc can be 
written in assembly language and can have information about the device (e.g., the CSR 
address and the baud rate) hardwired into the program. Once character output is avail-
able, debugging proceeds rapidly.
A1.3.6  Load And Run A Sequential Program
Once an image can be downloaded and run, the next step consists of building an 
environment that permits a sequential program to execute. In particular, successful exe-
cution of a C program requires that memory permissions are set correctly (the program 
text is readable and data locations can be read and written) and a runtime stack exists 
(which is needed for function calls).

658
Operating System Design
Initializing the environment may seem trivial, but it requires knowledge of both 
hardware and compiler details. For example, one must choose a mode for the proces-
sor. One must also choose an initial value for a stack pointer that does not conflict with 
device CSRs or holes in memory. Depending on the platform and compiler, it may be 
advisable to initialize a frame pointer or exception vectors (e.g., to prevent an invalid 
memory reference from generating another invalid memory reference, which generates 
another invalid memory reference, and so on).
A1.3.7  Port And Test The Basic Memory Manager
Once the layout of memory is known and a sequential program can be downloaded 
and run on the target hardware, a programmer can port and test the four basic memory 
management functions: getmem, freemem, getstk, and freestk. In addition to basic allo-
cation and deallocation tests, a programmer should concentrate on alignment. Some 
hardware platforms require all memory accesses to be word aligned and some allow 
unaligned access. On machines that require alignment, a programmer should ensure 
that the memory free list has been initialized in such a way that alignment works 
correctly (i.e., all allocated blocks begin on the appropriate boundary).
A1.3.8  Port The Context Switch And Process Creation Functions
Once basic memory management is working, a programmer can begin to port the 
process manager functions. In particular, a programmer starts with context switch, 
scheduling, and process creation. A giant step forward occurs once the three fundamen-
tal process management functions are in place: instead of a sequential program, the code 
will be a fledgling operating system that supports concurrent execution.
There are two difficult parts in the design. Creating the saved information for a 
process requires an intricate knowledge of the machine state and the operation of the 
context switch. Building a context switch is tricky because it involves finding a way to 
save all the state associated with a process and reload all the state from another process. 
It can be easy to overlook details or inadvertently to destroy state while saving a copy 
(e.g., clobber a register). Unfortunately, debugging can be extremely difficult because 
problems may not be discovered until the system attempts to reload saved state.
A1.3.9  Port And Test The Remaining Process Manager Functions
Once process creation, scheduling, and context switching are working, other proc-
ess management functions can be added easily. Semaphores functions can be ported
and tested, as can message passing. Beyond the context switch level, most process 
management functions do not depend on the hardware. Of course, various data types 
may change, depending on the underlying hardware. For example, when moving from a 
32-bit computer to a 64-bit computer, the msg32 type may be changed to msg64. 
Nevertheless, porting the semaphore and message passing functions is a relatively 
straightforward task.

Sec. A1.3        Steps Taken When Porting An Operating System 
659
A1.3.10  Build An Interrupt Dispatcher
The last big hardware hurdle concerns interrupts. Building an interrupt dispatcher 
requires a detailed knowledge of the hardware. How do the processor, interrupt con-
troller, and bus interact? Exactly what state does the hardware save when an interrupt 
occurs, and what state is the operating system required to save? How does the dispatch-
er determine which device interrupted? How does a dispatcher return to the running 
program when the interrupt ends? What addresses are used for the bus and devices?
The details of interrupts are surprisingly subtle. On most systems, for example, 
I/O is memory mapped. Thus, I/O devices (and perhaps the bus hardware) are mapped 
into specific addresses. To access I/O facilities, however, an operating system may 
need to disable or avoid the memory cache because each I/O access must go to the 
underlying hardware rather than the cache.
A1.3.11  Port And Test The Real-Time Clock Functions
Once interrupt dispatching is in place, an example device is needed to test the 
mechanism. It is logical to start by testing the real-time clock, usually one of the easi-
est devices to use. On some systems building a real-time clock handler first is absolute-
ly necessary because the clock cannot be stopped — if the system has interrupts en-
abled, clock interrupts will occur. Clock interrupts mean that processes can call sleep()
to delay for a specified time, and that time slicing goes into effect.
A1.3.12  Port And Test A Tty Driver
Clock interrupts are distinct from other devices because a clock does not perform 
input or output. A serial line is perhaps the simplest type of device that has both input
and output (some hardware separates input and output interrupt handling). Thus, the tty 
driver will exercise both input and output, and ensure that all basic interrupt processing 
works.
Fortunately, most systems include a serial line, and many use the same UART 
hardware as described in the text. Thus, much of the tty driver code, including the 
lower half, can simply be recompiled and used. Basic device parameters, which will 
have been worked out in Step A1.3.5, can be added to the device switch table or the
lower half as appropriate.
A1.3.13  Port Or Create Drivers For An Ethernet And Other Devices
Once input and output have been tested, more complex device drivers can be port-
ed. Devices that use DMA (e.g., disks and network interfaces) require buffer pools to
be in place, and may require a deeper understanding of how DMA interacts with a 
memory cache. However, having a basic system in place makes debugging much easier 
because a programmer can focus on one device at a time.

660
Operating System Design
A1.3.14  Port The Network Stack, Including Internet Protocols
Because networking has become fundamental, network protocols are an essential
part of an operating system. Some embedded systems that use network communication
do not have a local disk. Once an Ethernet driver is available, adding higher layer pro-
tocols is straightforward. Porting can start with a network input process; UDP, IP, and 
ARP can then be added. Once UDP is available, Internet communication can be tested.
A1.3.15  Port The Remote Disk And RAM Disk Modules
Porting a RAM disk driver is trivial, and allows a programmer to test the local file 
system. The remote disk driver provides access to stable storage, even if the platform 
does not have a disk. Thus, porting the RAM disk and remote disk is an easy step be-
fore porting a file system.
A1.3.16  Port The Local And Remote File System Modules
Given an operational disk driver, porting a basic file system is straightforward. 
The first step consists of porting and testing functions that read and write index blocks; 
the second step consists of porting and testing code that builds the free lists of index 
and data blocks. Once the basic allocation functions are in place, a directory can be ad-
ded and the file system tested.
A1.3.17  Port The Xinu Shell And Other Applications
Although applications are convenient, a shell adds significant complexity to the 
system. Thus, one usually writes functions that test each operating system module and 
exercise special cases. Once the system is running, the final step consists of porting a 
shell and more general-purpose applications.
A1.4 Programming To Accommodate Change
How should operating system designers contend with constant change? Can we 
anticipate future hardware? Can a system be designed and implemented to make
changes easier? Designers have been considering the questions for decades. Most early 
operating systems were created to match the hardware and written in assembly 
language. Each system was designed and built from scratch, with new abstractions and 
new mechanisms. As I/O devices (such as disks) and operating system abstractions 
(such as files) became standardized, designing a new system from scratch became much 
more expensive than adapting an existing system. Modern systems employ two tech-
niques to accommodate change:

Sec. A1.4        Programming To Accommodate Change 
661
d Compile time: write source code that can generate multiple versions.
d Runtime: design facilities that allow an operating system to change
dynamically.
Compile time. One way to make a system adaptable consists of writing source 
code that uses conditional compilation to allow a given source program to be used on 
multiple systems. As a simplistic example, consider writing an operating system that 
must run on hardware with a real-time clock or hardware that has no real-time clock. A 
programmer can use the C preprocessor to conditionally compile source code according 
to the hardware. For example, if preprocessor variable RT_CLOCK has been defined, 
functions that use the clock should be compiled as usual. Otherwise, functions that 
depend on a clock should be replaced by versions that report an error. The sleep func-
tion from Chapter 13 can be used to illustrate the idea. To accommodate both situa-
tions, the code from the function can be rewritten as follows:
ssyyssccaallll sslleeeepp((
uuiinntt3322
ddeellaayy
//** TTiimmee ttoo ddeellaayy iinn sseeccoonnddss
**//
))
{{ 
##iiffddeeff RRTT__CCLLOOCCKK
iiff ((ddeellaayy >> MMAAXXSSEECCOONNDDSS)) {{
rreettuurrnn((SSYYSSEERRRR));;
}} 
sslleeeeppmmss((11000000**ddeellaayy));;
rreettuurrnn OOKK;;
##eellssee
rreettuurrnn SSYYSSEERRRR;;
##eennddiiff
}}
If constant RT_CLOCK has been defined, the C preprocessor generates the source 
code shown in Chapter 13, which is then compiled. If RT_CLOCK has not been de-
fined, the C preprocessor eliminates the body of the sleep function and generates a sin-
gle line of source code:
rreettuurrnn SSYYSSEERRRR;;
The chief advantage of conditional compilation lies in its efficiency: instead of using a 
test at runtime, the source code can be tailored to the specific hardware. Furthermore, 
the system does not contain extra code that is never used (which can be important in 
embedded systems). The chief disadvantage of conditional compilation is loss of reada-
bility. In the case above, the code snippet is so small that the entire block of code fits 
onto a display. In a production system, the conditional block may span hundreds of 
lines of code. Furthermore, if two conditions interact, conditional code may be nested.

662
Operating System Design
Runtime.  The simplest way to increase runtime portability consists of using condi-
tional execution. When it starts, the operating system gathers information about the 
hardware and places the information in a global data structure. For example, a Boolean 
variable in the global data structure might specify whether the hardware includes a 
real-time clock. Each operating system function is written to interrogate the data struc-
ture and act accordingly. The chief advantage of using a runtime approach lies in gen-
erality — an image can be run without being recompiled.
The idea of runtime adaptation has been generalized by separating an operating 
system into two parts: a microkernel that contains basic process management functional-
ity and a series of dynamically loaded kernel modules that extend the functionality. In 
theory, porting a microkernel to a new environment is easier than porting a complete 
system because porting can be done piecemeal. That is, the microkernel is ported first, 
and modules are ported later, as needed.
A1.5 Summary
Portability is important because hardware continues to change. The steps required
to port an operating system to a new environment follow the same pattern as the origi-
nal design: port the lower levels of the system first, and then port successively higher 
levels.
Operating system code can be written to increase portability. A compile-time ap-
proach that uses conditional compilation achieves highest efficiency. A runtime ap-
proach that uses conditional execution allows a single image to run on multiple versions 
of a platform. The most advanced runtime approach uses a microkernel plus dynamic 
kernel modules, which allows modules to be ported only if they are needed.

Appendix 2
Xinu Design Notes
A2.1 Introduction
This appendix contains a set of informal notes that characterize Xinu and the 
underlying design. The notes are not intended as a tutorial, nor are they a complete 
description of the system. Instead, they provide a concise summary of characteristics 
and features.
A2.2 Overview
Embedded paradigm. Because it is intended for use in embedded systems, Xinu 
follows a cross-development paradigm. To develop create, edit, cross-compile, and 
cross-link Xinu software, a programmer uses a conventional computer, typically one
that runs a version of the Unix operating system, such as Linux. Output from cross-
development software is a memory image. Once such an image has been created, a pro-
grammer downloads the image to the target system (typically over a computer network). 
Finally, the programmer starts the image running on the target embedded system.
Source code organization. Xinu software is organized into a handful of directories 
that follow the organization used with various Unix systems. Instead of placing all files 
for each module in a separate directory, files are grouped into a few directories. For ex-
ample, all include files are placed in one directory, and files that constitute the kernel 
sources are placed in another. Device drivers are the exception — source files for a 
given device driver are placed in a subdirectory named for the device type. The sub-
directories within a Xinu source tree are organized as follows:
663

664
Operating System Design
./compile 
The Makefile used to compile and link a Xinu image
/bin 
Executable scripts invoked during compilation
/binaries Compiled binaries for Xinu functions (.o files)
./config 
Source for the configuration program and Makefile
/conf.h Configuration include file (copied to ../include)
/conf.c 
Configuration declarations (copied to ../system)
./device 
Source code for device drivers, organized into one
subdirectory for each device type
/tty 
Source code for the tty driver
/rfs 
Source code for the remote file access system (both the
master device and remote file pseudo-devices
/eth 
Source code for the Ethernet driver
/rds 
Source code for the remote disk driver
/... 
Directories for other device drivers
./include 
All include files
./shell 
Source code for the Xinu shell and shell commands
./system 
Source code for Xinu kernel functions
./lib 
Source code for library functions
./net 
Source code for network protocol software
A2.3 Xinu Characteristics
Note: these are the notes kept during implementation; they are not intended to be a
tutorial introduction to Xinu.
– The system supports multiple concurrent processes.
– Each process is known by its process ID.
– The process ID is used as an index into the process table.
– The system provides counting semaphores.
–  Each semaphore is known by its ID, which is used as an index into the
semaphore table.

Sec. A2.3        Xinu Characteristics 
665
– The system supports a real-time clock that is used for round-robin
scheduling of equal-priority processes and timed delays.
– Each process is assigned a priority, which is used in scheduling; a
process priority can be changed dynamically.
–  The system supports multiple I/O devices and multiple types of I/O de-
vices.
– The system includes a set of device-independent I/O primitives.
– The console device uses a tty abstraction in which characters are
queued both during input and output.
–  The tty driver supports modes: raw mode passes characters transparent-
ly, and cooked mode supports character echo, line editing with erasing 
backspace, flow control, and crlf mapping.
– The system includes an Ethernet driver that can send and receive Eth-
ernet packets; the driver uses DMA.
– The system includes a local file system that supports concurrent
growth of files without preallocation; the local file system only has a 
single-level directory structure.
– Xinu also includes a remote file system mechanism that allows access
to files on a remote server.
– The system includes a message passing mechanism used for inter-
process communication; each message is one word long.
– Processes are dynamic — a process can be created, suspended, restart-
ed, and killed.
– Xinu includes a low-level memory manager used to allocate and free
heap areas or process stacks, and a high-level memory manager used to 
create buffer pools, where each pool contains a set of fixed-size 
buffers.
– Xinu includes a configuration program that generates a Xinu system
according to the specifications given; the configuration program allows 
one to choose a set of devices and set system parameters.
– The system provides Internet access via TCP and UDP.
A2.4 Xinu Implementation
Functions and modules. The system sources are organized as a set of functions. 
In general, each file corresponds to a system call (e.g., file resume.c contains system 
call resume). In addition to the system call function, a file may contain utility functions 
needed by that system call.

666
Operating System Design
Key files. In most cases, each major system function is found in a separate file.
For example, function resume is found in file resume.c. The following lists other files
that play an important role in Xinu.
Configuration A text file containing device information and constants that
describe the system and the hardware. The config program 
takes file Configuration as input and produces conf.c and 
conf.h.
conf.h 
Generated by config, it contains declarations and constants
including defined names of I/O devices, such as CONSOLE.
conf.c 
Generated by config, it contains initialization for the device
switch table.
kernel.h  
General symbolic constants and type declarations used
throughout the kernel.
prototypes.h   Prototype declarations for all system functions.
xinu.h 
A master include file that includes all header files in the
correct order. Most Xinu functions only need to include
xinu.h.
process.h       Process table entry structure declaration; state constants. 
semaphore.h   Semaphore table entry structure declaration; semaphore con-
stants.
tty.h 
Tty device control block, buffers, and other tty constants.
bufpool.h       Buffer pool constants and format.
memory.h  
Constants and structures used by the low-level memory
manager.
ports.h       Definitions by the high-level inter-process communication
mechanism.
sleep.h 
Definitions for real-time delay functions.
queue.h 
Declarations and constants for the general-purpose process
queue manipulation functions.
resched.c 
The Xinu scheduler that selects the next process to run from
the eligible set; resched calls the context switch.
ctxsw.S 
The context switch that changes from one executing process
to another; it consists of a small piece of assembly code.
initialize.c 
The system initialization function, sysinit, and other initiali-
zation code as well as code for the null process (process 0).

Sec. A2.4        Xinu Implementation 
667
userret.c 
The function to which a user process returns if the process
exits. Userret must never return. It must kill the process
that executed it because the stack does not contain a legal 
frame or return address.
platinit.c 
Platform-specific initialization.
A2.5 Major Concepts And Implementation
Process states. Each process has a state given by field prstate in its process table entry. 
Constants that define process states have names of the form PR_xxxx.  PR_FREE means the 
process entry is unused.  PR_READY means the process is linked into the ready list and is 
eligible for the processor.  PR_WAIT means the process is waiting on a semaphore (given by 
prsem). PR_SUSP means the process is in hibernation; it is not on any list. PR_SLEEP 
means the process is in the queue of sleeping processes and will awaken after a timeout. 
PR_CURR means that the process is (the only one) currently running. The currently running 
process is not on the ready list. PR_RECV means the process is blocked waiting to receive 
a message; PR_RECTIM is like PR_RECV except the process is also sleeping for a specified 
time and will awaken if the timer expires or a message arrives, whichever happens first.
Counting semaphores. Semaphores reside in the array semtab. Each entry in the array 
corresponds to a semaphore and has a count (scount) and state (sstate). The state is 
S_FREE if the semaphore slot is unassigned, and S_USED if the semaphore is in use. If the 
count is negative P then the head and tail fields of the entry in the semaphore table point to 
the head and tail of a FIFO queue of P processes waiting for the semaphore. If the count is 
nonnegative P then no processes are waiting and the queue is empty.
Blocked processes. A process that is blocked for any reason is not eligible to use the pro-
cessor. Any action that blocks the current processes forces it to relinquish the processor and 
allow another process to execute. A process that is blocked on a semaphore is on the queue 
for the semaphore, and a process blocked for a timed delay is on the queue of sleeping 
processes. Other blocked processes are not on a queue. Function ready moves a blocked 
process to the ready list and makes the process eligible to use the processor.
Sleeping processes. A process calls sleep to delay for a specified time. The process is ad-
ded to a delta list of sleeping processes. A process may only put itself to sleep.
Process queues and ordered lists. There is a single data structure used for all process lists.
The structure contains entries for the head and tail of each list as well as an entry for each 
process. The first NPROC entries in the table (0 to NPROC-1) correspond to the NPROC 
processes in the system; successive entries in the table are allocated in pairs, where each pair 
forms the head and tail of a list.
The advantage of keeping all heads and tails in the same data structure is that enqueuing, 
dequeuing, testing for empty/nonempty, and removing from the middle (e.g., when a process

668
Operating System Design
is killed) are all handled by a small set of functions (files queue.c and queue.h). An empty
queue has the head and tail pointing to each other. Testing whether a list is empty is trivial. 
Lists can be ordered or may be FIFO; each entry has a key that is ignored if the list is FIFO.
Null process. Process 0 is a null process that is always available to run or is running. Care 
must be taken so that process 0 never executes code that could cause it to block (e.g., it can-
not wait for a semaphore). Because the null process may be running during interrupts, inter-
rupt code may never wait for a semaphore. When the system starts, the initialization code 
creates a process to execute main and then becomes the null process (i.e., executes an infi-
nite loop). Because its priority is lower than that of any other process, the null process loop 
executes only when no other process is ready.
Netin process. The network input process, netin repeatedly reads and demultiplexes incom-
ing packets. Netin must not block or all network input stops. Therefore, if an Internet pro-
tocol requires replies (e.g., a response to an ICMP ping request), the outgoing packet is
placed on a queue for the IP output process, ipout.

Operating System Design
The Xinu Approach
Second Edition
With Intel and ARM Examples
•	 Access online or download to your smartphone, tablet or PC/Mac
•	 Search the full text of this and other titles you own
•	 Make and share notes and highlights
•	 Copy and paste text and figures for use in your own documents
•	 Customize your view by changing font size and layout
Widely lauded for avoiding the typical black box approach found in other operating system textbooks, the first 
edition of this bestselling book taught readers how an operating system works and explained how to build it from 
the ground up. 
Continuing to follow a logical pattern for system design, Operating System Design: The Xinu Approach, Sec-
ond Edition removes the mystery from operating system design and consolidates the body of material into a sys-
tematic discipline. It presents a hierarchical design paradigm that organizes major operating system components 
in an orderly, understandable manner. 
The book guides readers through the construction of a conventional process-based operating system using prac-
tical, straightforward primitives. It gives the implementation details of one set of primitives, usually the most popu-
lar set. Once readers understand how primitives can be implemented on conventional hardware, they can then 
easily implement alternative versions.
The text begins with a bare machine and proceeds step-by-step through the design and implementation of the 
Xinu operating system. The Xinu code runs on many hardware platforms. This second edition has been completely 
rewritten to contrast operating systems for RISC and CISC processors. Encouraging hands-on experimentation, 
the book provides updated code throughout and examples for two low-cost experimenter boards: BeagleBone 
Black from ARM and Galileo from Intel.
Features
•	
Covers topics in the order a designer follows when building a system
•	
Uses inexpensive embedded platforms from ARM and Intel
•	
Describes the main components in the design hierarchy 
•	
Presents example software that illustrates the functions provided by each hierarchy level
•	
Gives readers the foundation to implement alternative versions of primitives
•	
Includes many practical examples and exercises that facilitate hands-on learning with the code
•	
Offers updated code and other information on the author’s website
Computer Science & Engineering
K25117
w w w . c r c p r e s s . c o m

