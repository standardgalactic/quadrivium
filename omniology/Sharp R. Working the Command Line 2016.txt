WORKING THE 
COMMAND 
LINE
REMY SHARP
FOREWORD BY
JEREMY KEITH
3

MORE FROM A BOOK APART BRIEFS
Making Sense of Color Management
Craig Hockenberry
Pricing Design
Dan Mall
Get Ready for CSS Grid Layout
Rachel Andrew
Visit abookapart.com for our full list of titles.

Copyright © 2016 Remy Sharp
All rights reserved
Publisher: Jeffrey Zeldman
Designer: Jason Santa Maria
Executive Director: Katel LeDû
Editor: Caren Litherland
Technical Editor: Anna Debenham
Copyeditor: Lisa Maria Martin
Proofreader: Katel LeDû
Compositor: Rob Weychert
Ebook Producer: Ron Bilodeau
ISBN: 978-1-937557-49-2
A Book Apart
New York, New York
http://abookapart.com
10 9 8 7 6 5 4 3 2 1

TABLE OF CONTENTS
Chapter 1
 1 |	 “Just Open the Terminal…”
Chapter 2
 18 |	 Install All the Things
Chapter 3
 30 |	 Tools of the Terminal Trade
Chapter 4
 40 |	 How (Not) to Shoot Yourself in the Foot
Chapter 5
 58 |	 Making the Shell Your Own
 
75 |	
Resources
 
76 |	
Acknowledgments
 
77 |	
References
 
79 |	
Index

FOREWORD
STOP ME if you’ve heard this one before.
You’ve just followed a link to a cool-sounding new resource 
that one of your friends has recommended. Now you’re reading 
about how this could help you in your day-to-day work on the 
web. You excitedly click through to the documentation; the 
installation instructions are laid out before you. That’s when 
your heart sinks. “This is moon language!” you cry.
You are not alone. I don’t just mean that there are many of us 
who feel the same way. I mean that you are literally not alone. 
You have Remy with you.
As I navigate the intimidating dark depths of the Command 
Line Interface, I’ll keep this book close to hand. But it isn’t a 
reference book. It’s more like a self-help book. It will help me—
and you—become a more efficient developer, better equipped 
to battle moon language. “It’s a Unix system,” you’ll whisper. 
“I know this!”
Having finished the book, I now have one question I ask 
myself before I confront an unavoidable task on the command 
line: What Would Remy Do?
When it comes to the command line, WWRD will serve 
you in good stead. (Warning: when it comes to just about any 
other aspect of your daily life, WWRD will almost certainly be 
disastrous.)
What Would Remy Do? The answer lies within these pages.
—Jeremy Keith

“JUST OPEN THE 
TERMINAL…”
1

2
WORKING THE COMMAND LINE
AT SOME POINT IN YOUR LIFE, dear reader, you may have 
opened the terminal and found yourself staring into a black 
void—or, if you’re of the Mac persuasion, a white void (FIG 1.1).
A flashing cursor and a dollar symbol invite you to enter a 
command. But then what? What does this void want from you?
In my first experiences with a terminal, I remember typing 
words like “Hello.” “Run.” “Open.” I tried entire sentences. I’m 
not even kidding. And, no, none of it worked.
This book is for those of you who are new—or even not so 
new—to the terminal. Maybe you’re a front-end developer or a 
designer who has read countless blog posts that start with this 
magical incantation: “Just open the terminal…” Or perhaps you 
have a few command-line skills, but have found yourself sucked 
into the void, stuck inside a command, unable to quit—ever.
By the end of this book, you’ll feel quite comfortable firing 
up the terminal, and you’ll be able to speak enough terminal 
black-void gobbledygook that you may very well start telling 
other people to “just” run echo pling dollar.
WHY USE THE TERMINAL?
Damn good question. Who in their right mind would punish 
themselves by using the terminal instead of a beautifully designed 
app with an interface that would make Jony Ive shed a tear?
The answer is that decades of development have gone into 
the tools available from the terminal and the command line (or 
the command-line interface, or CLI, as it’s also known). Lots and 
lots and lots of tiny tools—programs that are built to do one 
simple thing well, but that often join forces to solve more com­
plex problems. This practice of designing tiny tools is known 
as the Unix philosophy.
There is no single, standardized statement of the philosophy. 
But if it had to be described with only a single word, that word 
would be modularity, which refers to a system that is composed 
of components (i.e., modules) that can be fitted together or 
arranged in a variety of ways. —The Linux Information Project

3
“Just Open the Terminal…”
Consider a tiny command-line utility called cat, which allows 
you to print the contents of a file to the screen. On its own, cat 
is fine, if somewhat limited—but it can be used as part of a larger 
system. Now, if I combine cat with grep, I can quickly find out 
on which line the words “black void” appear in my manuscript. 
I can even count how many times I’ve used the phrase “black 
void,” simply by combining these two tools. Then I can plug 
that output into another program and manipulate the text, or 
do something else entirely. (We’ll return to the grep tool in 
Chapter 3.)
One can’t easily plug something like Adobe Photoshop into 
Sublime Text and then into another application. But in the 
terminal, such acrobatics are common practice.
TERMINAL APPLICATIONS
You really only need one terminal application to get to the com­
mand line. You can apply customization and personalization 
to any and all terminals—even remote machines. I personally 
look for a few key features that make working with the terminal 
application more productive:
FIG 1.1: Faced with a dollar symbol and nothingness, you’d be forgiven for bailing 
out immediately.

4
WORKING THE COMMAND LINE
•	 Tabs. We’re used to tabbed browsers, and tabs have become 
a standard requirement for terminal applications these 
days, too.
•	 Split screens. Some of us are fortunate enough to work with 
large screens. Being able to split the terminal to view more 
than one task at a time is very powerful.
•	 Select-to-copy. If you’ve never had this feature, it might 
sound strange, but being able to quickly double-click (to 
select) any text in the terminal and then paste (so it goes 
straight into the prompt) is very powerful and quickly 
becomes muscle memory.
If you’re a Linux desktop user and have Gnome Terminal, 
then you’re pretty much set, since it includes all of these great 
features by default. Both Windows and Mac include terminal 
applications by default, but you’d be wise to upgrade away from 
them because of their inherent limitations. The default Mac ter­
minal is pretty good, but it’s not ideal; if you want to use a split 
screen, or a feature as simple (and powerful) as select-to-copy, 
consider using something else. The default Windows terminal 
is called Command Prompt; it has a number of restrictions, 
including not being able to resize the window. 
Let’s take a closer look at the Mac and Windows terminals.
Mac terminal
Out of the box, the Mac operating system comes with a termi­
nal application called, aptly enough, “Terminal.” It’s a passable 
terminal, but being a Mac user myself, I highly recommend 
installing iTerm2, a free, open-source app that includes all sorts 
of great features. iTerm2 will be the terminal app I’ll continue 
to use throughout this book (FIG 1.2). 
Let me suggest a few tweaks that make working with iTerm2 
extremely slick. Go to the app’s preferences:
•	 In General, uncheck “Use Lion-style Fullscreen windows.” 
This means that when you expand the terminal to fullscreen, 
you won’t have to wait for the annoying full-screen anima­
tion to run before actually being able to use the terminal.

5
“Just Open the Terminal…”
•	 In Keys, check “Show/hide iTerm2 with a system-wide hot­
key” and give yourself a shortcut. My personal favorite is 
cmd+esc—it really has become part of my muscle memory .
Windows “cmd.exe” terminal
Command Prompt is the official name for the Windows ter­
minal, but you’ll often hear it referred to in conversation as 
“command-dot-ex-ee.” It provides a view on what DOS used to 
be like. Including Command Prompt in this book as a terminal 
is almost unfair, because it doesn’t really hold a candle to the 
features and CLI tools of other terminals. PowerShell is way 
more powerful (and complicated)—arguably better than the 
Linux-type shells we’ll use in this book—but it’s beyond the 
scope of this brief volume.
FIG 1.2: iTerm2 running my own customized shell. The shell is a text-based interface that 
gives you access to your operating system; it processes commands and returns output. 
We’ll look at customizing the shell in Chapter 5.

6
WORKING THE COMMAND LINE
If you’re a Windows user, I recommend you get your hands 
on Git BASH. It comes with Git (the version control system), but 
you don’t have to use Git if you don’t want to (FIG 1.3).
Now you’ve got the same commands and navigation meth­
ods as you would on a Linux or Mac machine. This is a win 
for consistency.
THE PROMPT
There’s a certain amount of jargon involved in working with 
the terminal, some of which we’ve touched on already. One of 
the first things you’ll have to familiarize yourself with is the 
prompt. The prompt is where you’ll enter commands.
Though usually represented by a $ symbol, the prompt can 
really be anything (because you can customize it, as we’ll see in 
Chapter 5). It’s not uncommon to see blogs and online tutorials 
start a code block with a $ symbol, which is shorthand for “You 
need to run everything after the $ in the terminal.” Note that 
you don’t need to type this in; it’s just a visual cue for the reader.
Now that you’ve fired up your terminal, you’ll be greeted 
with...well, very little: a $ symbol and a (mostly) blank screen. 
Yes, you’ll need to know your way around—but fear not, that’s 
why you’re reading this book!
We’re going to navigate around your hard drive to get a feel 
for how a path works. First, though, let’s explore a little.
ls: listing files and directories
When you type ls (that’s a lowercase ell, not a numeral one or 
an uppercase I) and hit Enter, the terminal will list the current 
working directory’s files and subdirectories.
We want to change directory, or cd, into one of the directories 
listed. But it’s entirely possible that the output from ls doesn’t 
make it clear what is a directory and what is a file:
$ ls
chapter-outline.md  chapter1  chapter2  todo.md

7
“Just Open the Terminal…”
In this case, we want to see clear distinctions between files 
and directories, and we want detailed information about each 
item in the current directory. Most commands can take switches 
(sometimes also called options or flags): arguments that modify 
how a command is carried out. So we’ll repeat our ls command 
and add a couple of switches to it: -l (again, a lowercase ell) 
which gives us the details, plus -F, which adds a trailing slash to 
the directories. Note that single-character arguments can often 
be combined together—and here’s what we get:
$ ls -lF
total 16
-rw-r--r--@ 1 remy  staff  1226  7 Aug 14:42 
chapter-outline.md
drwxr-xr-x@ 3 remy  staff   102 12 Jan 10:25 
chapter1/
drwxr-xr-x@ 2 remy  staff    68 12 Jan 10:25 
chapter2/
-rw-r--r--@ 1 remy  staff  1900  7 Aug 14:41 todo.md
Our output contains lots of information:
FIG 1.3: Running Windows? Get some Git BASH to make your life a little easier.

8
WORKING THE COMMAND LINE
•	 Total: the first line will give you a total (16, in this case). 
Don’t let this confuse you like it did me. total, here, means 
the total number of “blocks” used, not the total number of 
files. Just ignore this for the moment.
•	 Permissions: where you have access to read, write, or exe­
cute (i.e., run) the file.
•	 Ownership: which user owns the file.
•	 File size: given in bytes.
•	 Timestamps: the last time the content was modified.
•	 Name: of the file or directory.
•	 Whether it’s a directory or not: indicated by the d preced­
ing the permissions string and the trailing slash following 
the name.
Now we can tell directories from files. Let’s pick a directory 
and change to it using cd [directory name]. In this case, I 
want to cd into chapter1:
$ cd chapter1
~/Dropbox/cli-book/chapter1
Quite often, I find I want to list the directory contents (so 
I use -l) by most recently modified. So I can use two more 
switches: the -t switch orders by time, showing newest con­
tents first, while the -r switch reverses the order—so now the 
contents will display in ascending order, with the newest file is 
at the bottom. As the command lists the directory, the last file 
is likely to be the one I last worked on:
$ ls -ltr
total 264
-rw-r--r--@ 1 remy  staff  103726  1 Feb 19:43 
iterm2.png
-rw-r--r--@ 1 remy  staff   14749  1 Feb 19:50 
gitbash-for-windows.png
-rw-r--r--@ 1 remy  staff   12118  2 Feb 16:19 
chapter1.md

9
“Just Open the Terminal…”
Once you have a directory listing, you’ll want to start mess­
ing with the files. We’ll do that in the chapters ahead. For now, 
though, let’s just traverse the directories.
Directory shortcuts
We’ve already used cd to change directories. Navigating through 
those directories is easy once you understand how a directory 
is broken down, and made even easier once you know a few 
special shortcuts. 
Here’s a directory path: ~/Dropbox/cli-book/. Each directory 
is separated by a slash (similar to how a URL is structured). 
The tilde indicates the user’s home directory; in my case, 
if I type cd ~, I’ll end up in /Users/remy. The home directory 
symbol is one of our special shortcuts. (Another way of going 
to the home directory is by typing cd and hitting Enter.)
Typing cd — will take you to whichever directory you were 
in last (a toggle back and forth between directories, if you will).
Here’s how some of the directories are laid out in my Drop­
box folder:
~/Dropbox
├─ cli-book
├─ introducing-html5
├─ personal-stuff-n-stuff
└─ zombies-and-rabbits
If I’m in the ~/Dropbox directory, I can run the following to 
move to the cli-book directory:
$ cd cli-book # moves to ~/Dropbox/cli-book
Note that the # symbol represents a comment that is valid 
to use on the command line (and you’ll see this a few times in 
the book). 
I can also use two periods to navigate to the parent directory: 
typing cd .. puts me back in ~/Dropbox. And I can combine this 
with directories, to move into the introducing-html5 directory:

10
WORKING THE COMMAND LINE
$ cd ../introducing-html5 # moves to ~/Dropbox/
introducing-html5
Typing one period instead of two means this directory, the 
one we’re in now—also known as the current working direc­
tory. (We’ll need this when we run our own scripts in later 
chapters.) You might understandably think that if I wanted to 
move up two directories, I’d use three dots, but that’s not the 
case. Instead, I need to use multiple parent commands, like 
cd ../../, which means: move to the parent directory (the 
first two dots), then in that directory (the /), move to its parent 
directory (the second two dots):
$ cd ../../ # moves me to the parent of Dropbox, 
which is ~
Spaces in names
If you’re using any kind of UI, like OS X or Windows, it’s entirely 
possible that you have a folder or a file name with a space in it. 
If you try to just cd into that folder, it’ll confuse the command:
$ cd my cool folder
cd: too many arguments
This doesn’t only apply to cd; it applies to any com­
mand. That’s okay, though—we’ve got ways to work around 
that limitation.
You can enclose the name of the file or directory in double 
or single quotes:
$ cd "my cool folder"
You can use an escape character (\) in front of the space:
$ cd my\ cool\ folder

11
“Just Open the Terminal…”
Or, if you’re feeling super lazy and happen to have a Mac, 
you can drag the file onto the terminal and it’ll insert the file 
name for you. Similarly, from a finder window, you can drag 
the icon in the title bar into the terminal, and it will insert the 
folder name for you (FIG 1.4).
USING YOUR HISTORY
As you use the shell, it keeps a record of your commands. 
(This record is private—particular to your account—and not 
accessible to anyone else who has their own login account on 
your machine.)
You can use the up/down cursor to cycle through your com­
mand history from the prompt, but there are also some short­
cut commands you can use in the terminal that are especially 
powerful. Let’s go through them.
!!
!!, known as bang bang, is shorthand for your last command.
So if you run a command, hit Enter, run !!, and then hit 
Enter again, it’ll repeat that command:
FIG 1.4: Dragging document icons into the terminal eases the pain of typing file names.

12
WORKING THE COMMAND LINE
$ echo "hello world"
hello world
$ !!
hello world
At first glance, it might seem like this is slightly more com­
plicated than pushing the up cursor key, but the next chapter 
will show you how you can combine this command with other 
commands to powerful effect.
!$
!$, pronounced bang dollar or pling dollar, gives you the last argu­
ment of your previous command. In our echo "hello world" 
example, the last argument is the part in quotes ("hello world").
On the Mac, there’s also a command called say. We can use 
!$ to say “hello world” after echoing it:
$ echo "hello world"
hello world
$ say !$
$
This causes your computer to say, out loud, “Hello world.” 
Again, this gets even more interesting when you’re able to 
“pipe” commands together. We’ll talk more about piping com­
mands in Chapter 3.
!n
Here, n refers to a number, specifically the nth entry in your 
history of commands. This number can mark a specific point 
in the history. A positive value works forward through the 
history, but you can also use a negative value to count from the 
end of the history. For example, you can use !-1 to access the 
last command in your history:

13
“Just Open the Terminal…”
$ echo "hello world"
hello world
$ !-1
hello world
You’ve already met the bang-bang (!!) command, which is 
an alias for !-1, but it also means that if you want to run the 
penultimate command, you can use !-2 (not the last command, 
but the one before that) and so on, working backward from the 
last command.
If you run history, you’ll get a complete list of all the com­
mands you’ve run, with a history index beside it so that you can 
quickly reference a more complicated command. The history 
size can range depending on your operating system—500 items 
is typical, but some will be 1,000, and others 10,000. (If you want 
more information, search The Googles for “HISTSIZE”.)
Here’s my recent command history:
$ history
10161  boot2docker start
10169  cd test/a
10170  nodemon -w ../ a.js -V --dump
10171  z nodemon
10172  cd tmp
10175  docker images
10176  docker run -v ~/Sites/nodemon:/nodemon -t -i 
ubuntu/nvm:latest /bin/bash
10177  touch test/a/a.js
10178  touch test/b/b.js
10179  cd ..
10181  git diff
10182  docker run -v ~/Sites/nodemon:/nodemon -t -i 
node:0.10-slim /bin/bash
Notice that the numbers don’t run exactly incrementally. 
This is the history for the current shell session. (If 10173 and 
10174 are missing, it’s because they were run in another ter­
minal shell session.)

14
WORKING THE COMMAND LINE
The index becomes useful if I want to rerun a command. I 
can rerun a command by copying and pasting the history item, 
like this:
$ docker run -v ~/Sites/nodemon:/nodemon -t -i 
ubuntu/nvm:latest /bin/bash
Or, I can save some time and energy by simply copying and 
pasting the index number:
$ !10176
This reran the 10,176th command, and dropped me into my 
Docker session (which is way beyond the scope of this book). 
Using the history index makes referring to historical commands 
really easy.
USING THE KEYBOARD
Although shortcuts aren’t required, it’s always handy to know 
a few power keyboard moves.
Tab
My favorite shortcut is the unsung Tab. All terminals have 
tab-completion support. So if you find yourself typing a com­
mand or directory name quite a lot, you only need to enter a bit 
of text, hit Tab, and your terminal will try to autocomplete it.
Different-flavored shells will do slightly different things. 
Some will complete the most common word you use, and 
hitting Tab again will cycle through to the next most com­
mon match.
Some will complete up to the point where there’s more than 
one command that matches. For instance, if you have two appli­
cations, one called cowsay and one called cowthink, typing “co” 

15
“Just Open the Terminal…”
and hitting Tab would complete up to “cow”; then, if you added 
s and Tab, it would complete to “cowsay” (FIG 1.5).
Often, hitting Tab twice will list all possible matches. In our 
example, hitting Tab twice after typing “co” would show both 
“cowsay” and “cowthink,” assuming these were the only com­
mands in your environment path (a list of directories where the 
system can find programs) that started with “co”. We’ll go over 
paths in more detail in Chapter 2. (I’ll show you how to install 
the obviously essential cowsay program there, too.)
Control-Left / Control-Right
Instead of using the left/right cursor keys to move through 
every character, you can use ctrl+left or ctrl+right to move by 
entire words. But! This will only work if you don’t use mul­
tiple desktops on a system like Mac OS Yosemite, which uses 
these keys to switch desktops (though you can disable this in 
settings).
An alternative to ctrl+left / ctrl+right, albeit not one that is 
easy to use, is esc+b for backward and esc+f for forward.
FIG 1.5: cowsay in all its glory.

16
WORKING THE COMMAND LINE
Control-C
This means abort. It stops an application from running. If you 
try running yes in your terminal, it’ll spew y over and over until 
you hit ctrl+c to abort.
You might also see this expressed as “^C”. (Note that these 
shortcuts aren’t case-sensitive; it’s just the Control and C keys 
pressed together.)
Control-D
This means end transmission, which is basically like saying 
“GTFO.” Instead of exiting your terminal using the mouse 
(or logout command), you can use ctrl+d and it’ll close your 
terminal session.
Control-R
This is a bit of a power-user shortcut, but since we’re reaching 
the end of Chapter 1, I think you deserve it.
Control-R lets you search for the most recent command 
matching your search term. Using my terminal history from 
earlier, if I hit ctrl+r, I’ll be presented with this:
$
bck-i-search: _
Now if I type “no”, it’ll show the most recent command I 
ran containing the characters n and o together. If I wanted to 
match the nodemon -w ../ a.js -V --dump command, I’d 
need to type something unique to that command, like mon -w. 
Then the full command would come up and, if I hit Enter, it 
would run for me.
If you want to abort out of this mode, just hit ctrl+c.

17
“Just Open the Terminal…”
OUT OF THE ABYSS
As this first chapter draws to a close, you should be proud. 
You’ve stared into the void— the terminal—and you’ve nailed 
down the fundamentals of navigating the CLI. Heck, you can 
even throw the words “pling dollar” into a conversation.
With these essentials in hand, let’s look at how we can 
install third-party tools onto our machines and use them in 
the terminal. 

INSTALL ALL 
THE THINGS
2

19
Install All the Things
YOU KNOW THE STORY: you’re following along with a tuto­
rial when you run smack into a dependency on an existing 
application. I’m not talking about installable applications via 
the iTunes Store (or via a CD, if you’re rocking it old school). I 
mean terminal applications.
It starts innocently enough: someone you follow on Twit­
ter, let’s say the formidable Mr. Paul Irish, posts a tweet about 
something you think would be useful (FIG 2.1).
You think to yourself: That looks useful; I’d better install it! And 
you dutifully follow the link. Now you’ve landed on a GitHub 
page. Okay, not a problem. Scroll, scroll, “usage,” keep scrolling, 
“examples,” cool, keep scrolling, YES! “Installation.”
Copy, paste, BOOM! Not the cool “boom” that Steve Jobs 
used to drop, but the boom of failure (FIG 2.2).
It’s a pretty unhappy experience: “Command not found,” 
“No such file or directory.” You have to start at the beginning 
and try to fix each problem one by one.
APPLICATION INSTALLERS
Most operating systems come with some core applications. 
Ruby is one of these; if you have a modern PC, you’ll likely have 
Ruby installed, but it’s not guaranteed. There are also built-in 
commands like cd, ls, and echo.
But beyond those, how do you install applications like 
Wget—or more important, cowsay? (Note that I’m just using 
cowsay as a simple, silly example of a program. I know, I 
know—this is the second time I’m asking you to install cowsay, 
and I won’t be offended if you don’t. But you should know that 
it does have an option to change the cow to a koala dressed as 
Darth Vader. Because Star Wars.)
Before I go any further, a disclaimer: this book is mainly 
aimed at beginners, front-end developers, and designers. And 
because there’s a strong hint of “Mac user” among that partic­
ular audience, most of my examples of installing applications 
will use Mac methods.

20
WORKING THE COMMAND LINE
Mac users can skip the following two sections. Everyone 
else, read on and bear with me—most of the rest of this chapter 
should apply to you, too!
Linux
Linux comes in many flavors, and installing new applications 
differs slightly with each flavor. Google is your friend here—
once you’ve found the application installer, it’s smooth sailing.
If you’re using Ubuntu, you need to run apt-get 
install [package]. Often you’ll need root privileges to run 
this, but if you don’t have root privileges, you can just prepend 
the command with sudo. (I’ll go into more detail about root 
privileges and sudo in Chapter 4.) You’ll be prompted for your 
password, and then the program will go ahead and install:
FIG 2.1: When Paul Irish tweets, I listen.

21
Install All the Things
remy@ubuntu:/# sudo apt-get install cowsay
Reading package lists... Done
[code omitted for brevity]
Setting up cowsay (3.03+dfsg1-6) 
remy@ubuntu:/# /usr/games/cowsay woot
 ______
< woot >
 ------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
remy@ubuntu:/#
Note that the prompt on Linux is remy@ubuntu:/#. On a 
Mac, you’re more likely to have a $ character as your prompt. 
Windows
Windows is an odd creature. It doesn’t natively have a termi­
nal-like shell, but hopefully you’re using Git BASH (introduced 
in Chapter 1), which is pretty close.
To install external shell applications, though, you’ll need a 
tool called Chocolatey, which dubs itself the “apt-get for Win­
dows” (also known as the “Brew for Windows”—we’ll meet 
Brew next). The gotcha here is that all of your install processes 
need to happen in an administrative cmd.exe command prompt. 
Yes, it’s turtles all the way down (FIG 2.3).
FIG 2.2: Uh-oh…just when things were going so well! Looks like Wget needs to 
be installed.

22
WORKING THE COMMAND LINE
Installation isn’t obvious (at least not to the naked eye), but 
take some time to read the documentation. You’ll need to run 
cmd.exe as the administrator. To do this, hit the Start key to 
open the Start menu; then type “cmd”. Don’t hit Enter just yet: 
FIG 2.3: Chocolatey is the Windows method for installing terminal applications.
FIG 2.4: To install Chocolatey, you need to 
run cmd.exe as the administrator.
FIG 2.5: The Brew installation process.

23
Install All the Things
instead of starting the command prompt, right-click and select 
“Run as administrator” (FIG 2.4).
Then, from the Chocolatey website,  run the commands 
they provide for installing and paste them into the com­
mand line. You’ll also need the admin command prompt to 
install applications.
Sadly, there’s no cowsay on Chocolatey—but don’t worry, 
dear Windows user, we’ll fix that later in this chapter. For now, 
let’s install Wget instead:
C:\Windows\system32>choco install wget
Chocolatey (v0.9.8.32) is installing 'wget' and 
dependencies. By installing you accept the license 
for 'wget' and each dependency you are installing.
Wget v1.11.4.1
Downloading Wget 32 bit
  from 'http://users.ugent.be/~bpuype/wget/wget.exe'
Added C:\ProgramData\chocolatey\bin\wget.exe shim 
pointed to '..\lib\wget.1.11.4.1\tools\wget.exe'.
Finished installing 'wget' and dependencies—if 
errors not shown in console, none detected. Check 
log for errors if unsure.
Now you can run Wget from your Git BASH terminal (or 
the regular cmd.exe).
Mac
There are a number of application installers for Mac, but I rec­
ommend Brew. It’s comprehensive and reliable. Visit the Brew 
site and scroll down to the “Install Homebrew” section, where 
you’ll see a command. Literally just copy it and paste it into 
your terminal, and you’re done: Brew is installed.
Now you can install applications using brew install 
[package] (FIG 2.5).
If your installation is successful, you’ll see a beer emoji.

24
WORKING THE COMMAND LINE
How the heck do I run my own commands?
In this chapter, we’ve been installing global commands. When 
you run global commands, your environment path is searched 
until the program to execute is found. But what if the program 
lives in your current directory rather than in your environment 
path? 
It’s an easy fix, though not obvious if you’ve never done it 
before. Assuming that your program file is executable (I’ll talk 
more about what that means in Chapter 4), simply prefix the 
file name with /, which refers to files in the directory you’re 
currently in:
$ ./my-script
If the file isn’t executable, you’ll get an error like this when 
you run the script:
$ ./my-script
bash: ./my-script: Permission denied
In this case, you’ll need to use the appropriate program (or 
runner) in front of it, like so:
$ ruby my-cool-thing.rb
$ node my-even-cooler-thing.js
$ php -f not-even-cool-enough-for-school.php
$ sh my-script.sh
The program file immediately following the prompt (ruby, 
node, and so forth) is the command; to the right of that is what 
you’re applying the command to (my-cool-thing.rb). It’s also 
worth noting that the file-name extension is only a hint to you, 
the author, about what program is needed to run the file. In 
fact, there doesn’t even have to be an extension—so sometimes 
a little exploration or good old trial and error is required on 
your part.

25
Install All the Things
RUBY, PYTHON, OR NODE?
Anna Debenham, this book’s technical editor, wisely asked me, 
“How does someone know which is the right type of applica­
tion to use?” An excellent question, and a complicated one that 
I would frankly rather sidestep—but I won’t.
First of all, there are no hard-and-fast rules about which 
language is best. Personally, I gravitate toward Node: I find the 
installation of individual programs uncomplicated (using the 
package manager npm, which I’ll come back to in a bit), and the 
support across different operating systems is absolutely superb.
Some people like Ruby, others like Python. There is no abso­
lute right way—what matters most is how comfortable you are 
with a given language. Once you’ve set things up the way you 
want on your machine and have your workflow nailed down, 
you’re good to go.
Occasionally, though, specific applications are only available 
under one language or another—so you really have no choice. 
Over the years, I’ve learned that I need to be able to install from 
the three major languages: Ruby, Python, and Node.
Ruby applications and gems
This is when it gets serious. You’ve read the latest cool thing, 
and you “just have to install” a Ruby gem (a bit of reusable code, 
also called a package or a module in other contexts).
I consider myself pretty comfortable with the terminal, but 
installing gems seems to be a dark art requiring all kinds of 
arcane rites. The real problem (in my experience) is that when 
you find a great application that says “just install the gem,” it 
rarely tells you how to install the gem.
On the optimistic side, when you encounter this scenario, 
it’s always worth trying to run the gem install command first. 
If that doesn’t work, you’ll need to update parts of your system 
(more about this later).
Let’s start by installing lolcommits, a project that uses your 
webcam to capture your picture right after you commit to Git:

26
WORKING THE COMMAND LINE
$ gem install lolcommits
If this works, you’ll see a torrent of install messages ending 
with something like this:
$ gem install lolcommits
Fetching: unf_ext-0.0.7.2.gem (100%)
Building native extensions.  This could take a while...
[code omitted for brevity]
35 gems installed 
And if you follow the setup instructions, you’ll be graced 
with some lovely photos whenever you make a commit 
(FIG 2.6).
When gems don’t work
If Ruby hates you as much as it hates me, then you might need 
to update a few things to get gems to install properly. And hon­
estly, it’s entirely possible that you’ll hit a wall after updating, 
and find that still nothing happens. I run into this all the time. 
The solution isn’t to throw your machine through the window, 
as I have nearly done. Instead, calmly walk away, and accept 
that this particular gem shall not be part of your growing col­
lection of command-line tools.
Here’s a list of things you can do to try to get gems to install 
if you’re having problems:
FIG 2.6: An optimistic Remy has just 
made a commit! (By the way, if you want 
to deepen your understanding of Git, 
consider reading David Demaree’s excellent 
Git for Humans.)

27
Install All the Things
1.	Try running the install as root (using sudo, which we met 
earlier): sudo gem install lolcommits.
2.	Try updating the gem system: sudo gem update --system.
3.	Install the latest Xcode command-line tools: xcode-select 
--install.
4.	Upgrade to the latest version of your operating system.
5.	Buy a new computer. Yeah, I’d give up before this point, too.
Steps 1–3 are the ones I would try, but I have also experi­
enced a machine that needed step 4 to install a gem (it was 
two versions behind the latest OS X). Other times, I’ve had to 
abort—but this book is an introduction, so if you’re getting 
stuck in gem black holes, it might be worth consulting your 
nearest ops engineer!
Python applications
Python has a package manager, but it’s pretty hairy. There are 
a lot of moving parts to keep track of—like pip, easy_install, 
and virtualenv.
One place you can find packages for Python is pypi.python.org. 
In my own experience, though (as someone who has very little 
experience with Python packages), I found it tricky to get the 
right combination of installers. In fact, most of the Python-
based applications I’ve installed in the past have been installed 
via Brew (which we met earlier). This might spare you a little 
pain in the future. Or, it might not.
Swiftly moving on...
Node applications
Because my background is in JavaScript, I tend to turn to Node-
based applications as my go-to solution; Node, after all, is what 
is used to execute JavaScript.
Another thing that draws me to Node modules over Ruby 
gems or Python modules is, as I mentioned earlier, the very 
excellent cross-platform support they enjoy. Most of the time, 
the Node utility you install will work the same on Mac, Win­
dows, and Linux.

28
WORKING THE COMMAND LINE
The only prerequisite is installing Node, which is wrapped 
up in a nice application installer you can download from 
nodejs.org. Hit the big Install button, follow the prompts, and 
you’re done.
Now, when you open your terminal, you can install Node 
modules via npm. (“npm” doesn’t stand for “node package 
manager,” by the way. It doesn’t stand for anything.)
We typically use npm to install packages (also sometimes 
referred to as modules) into software we’re writing. How­
ever, we can also use npm to install globally—that is, to install 
a command-line utility that’s accessible from anywhere in 
the terminal.
Let’s install our friend cowsay, since someone ported it to 
JavaScript. To do this, we’ll type npm on the command line and 
tell it to install a package. Note that to install it globally, we 
need to use the -g flag:
$ npm install -g cowsay
/usr/local/bin/cowsay ->
/usr/local/lib/node_modules/cowsay/cli.js
/usr/local/bin/cowthink ->
/usr/local/lib/node_modules/cowsay/cli.js
cowsay@1.0.3 /usr/local/lib/node_modules/cowsay
└─ optimist@0.3.7 (wordwrap@0.0.2)
You can also use npm to install tools like Grunt, Gulp, Yeo­
man, or PhoneGap. And there’s a huge community of devel­
opers contributing new and updated npm packages by the 
day hour.
In some situations, you may need to use sudo npm install 
-g [package], but I recommend not using sudo and trying a 
regular install first. Installing packages with sudo can uninten­
tionally inherit some of root’s permissions, which results in the 
program having different permissions than your user when it 
runs. Bottom line: things can get gnarly. (I’ll go into more detail 
about sudo in Chapter 4.)
Over the course of this chapter, you’ve learned how to install 
a wealth of applications for your new command-line skills—not 
only “classic” Unix-type applications like Wget, but also utterly 

29
Install All the Things
awesome applications like cowsay and even (wait for it) pony­
say. (Yes, as if a cow weren’t enough, you can also get a brightly 
colored pony to say all the things.) Beyond brew install, you 
can now install all of the bespoke applications that pop up in 
your news and Twitter feeds via Ruby gems or npm packages. 
If you want to find a program that does a particular thing, 
I recommend starting with Google (rather than with pack­
age-specific sites). Some initial, general research will give you 
an idea of whether the program is available in your preferred 
language, or will point you toward an alternative you perhaps 
hadn’t thought of.
Armed with your new knowledge, you’re ready to start 
remixing your command line applications. We’ll do that next.

TOOLS OF THE 
TERMINAL TRADE
3

31
Tools of the Terminal Trade
IF YOU’VE SPENT ANY TIME rummaging through tutorials, or 
perhaps shoulder-surfed a friend as they cruised around the 
terminal like a fish in water, then it’s likely you’ve come across 
the pipe. The pipe typically occurs between two commands, 
like echo "Hello Remy" and say, which will make the machine 
speak and welcome me, like this:
$ echo "Hello Remy" | say
The pipe is a magic and integral part of the command line. 
It’s super powerful and damn useful. What it does is take the 
output from the first command (on the left side) and “pipe” it to 
the second command (on the right side).
If you want an analogy, imagine a cartoon factory conveyor 
belt running through two big machines. Maybe we send a tree 
trunk down the conveyer belt and into the first machine (our 
first command), which eats it up, rumbles a bit, and spits out a 
carefully carved statue of a pony. The wooden pony continues 
along the conveyor belt (this is our “pipe”), and makes its way 
into a second machine (our second command), only to come 
out painted gloriously pink!
The key is that anything can be sent into that second 
machine, and it will come out bright pink—it doesn’t just accept 
wooden ponies.
It’s a pretty simple concept: you can use the output of one 
command as the input to another, and in fact you can keep 
piping commands together—this can go on, and on, and on, 
and on.
So which commands support this behavior? Most. In fact, 
if a command expects text as input (and most generally do), 
then it would be fair to expect the command to support piping 
of content. As a rule of thumb, if I installed an application via 
brew install, I’d expect it to support piping.
One caveat: Ruby gems, Node modules and utilities, Python 
scripts, and so forth might not support this. There are a lot of 
Unix commands available to you on the command line, but the 
third party command-line applications I just mentioned may 
not have written-in support for piping content. 

32
WORKING THE COMMAND LINE
Okay, so now you know the superpower that the command 
line offers. But what can you do with it? Lots.
STRING MANIPULATION
I’m going to cover a handful of core commands that let you do 
string manipulation. That may not sound very fancy, but once 
you know what you can do with these commands, they become 
the bread and butter of using the command line.
grep
grep is a tool that searches for an expression and prints matches 
to the screen. Expressions can be regular strings (like foo) or 
regular expressions (like ^foo, which means “lines starting with 
‘foo’”).
Regular expressions are way beyond the scope of this book. 
But if you’re not familiar with them, don’t worry—there’s many 
a book on the topic. And Lea Verou has given an excellent talk 
on regular expressions.
Here’s a simple example. I’m writing this book using 
Markdown. To create headings, I use hash symbols (#): one for 
a level-one heading, two for a level-two heading, and so on. 
If I want to find all the headings in Chapter 1, I can use grep; 
note that everything after the first line constitutes the output 
of the command:
$ grep '#' chapter1.md
# "Just Open the Terminal…"
## Why Use the Terminal?
## Terminal Applications
### Mac terminal
### Windows "cmd.exe" terminal
## The Prompt
### ls: list
### Spaces in names
## Using Your History

33
Tools of the Terminal Trade
### !!
### !$
### !n
root@a1ed91d61306:/#
## Using the Keyboard
### Tab
### Control-left / control-right
### Control-c
### Control-d
### Control-r
## Out of the Abyss
See how I’ve put the # between quotes in the command 
line? That’s because a hash symbolizes the start of a com­
ment, so unless it’s between quotes, it messes up the grep 
command. You typically won’t need to quote the expression 
you’re searching for. Also notice that my output includes the 
line root@a1ed91d61306:/#. That’s because the line contains 
a hash symbol. 
What if I’m really only interested in level-two headings (indi­
cated by ##)? To find only those, I can use a regular expression: 
a caret (^), which means “starts with”; then two hash marks (##); 
and finally a space (since my Markdown titles are preceded by 
a space):
$ grep '^## ' chapter1.md
## Introduction
## Chapter 1
## Why Use the Terminal?
## Terminal Applications
## The Prompt
## Using History
## Using the Keyboard
## Out of the Abyss
The grep command by itself is helpful, but it can also be used 
to grep the output from another command. 
Say you want to search your history. We encountered the 
history command in Chapter 1, but rather than simply listing 

34
WORKING THE COMMAND LINE
thousands of entries, maybe you want to search your history 
for a particular command.
In my case, I want to retrieve a command that used curl 
(a command for getting and sending to URLs). So I’ll pipe the 
output from history to grep and search for the word “curl”:
$ history | grep curl
  210  curl http://jsbin.dev:8080/help
  220  curl -i https://jsbin.dev/
  260  curl http://localhost:3000/\?url\
=emberjs.jsbin.com > emberjs-jsbin.com
  300  curl -i https://api.github.com/repos/octocat/
Hello-World/hooks
  317  curl -i http://jsbin.dev/help
[code omitted for brevity]
 9855  curl rem.io/install
 9923  curl -H 'accept: application/json' 
http://jsbin.ff-platform.local/user/
twitter\|648873/
That’s a lot of matches. It’s pretty hard for humans to process.
Adding less: “Less is more, more or less.”
less is a command that lets us page through output. There’s 
a similar command called more, but less is better because it 
allows us to page forward and backward (unlike more, which 
only goes forward).
I can use less to page through (and even search) the output 
of my history search:
$ history | grep curl | less
Now that I’m inside the less command, I can use the 
keyboard to cursor up and down; I can page forward (by press­
ing the Space key) or backward (by typing B). Significantly, I 
can search while I’m inside less by hitting the Slash key. I can 
enter an expression like -H (which is an argument to curl); less 

35
Tools of the Terminal Trade
will highlight the matches and allow me to move through the 
next matches by typing N.
less has one oddity that I should note here: ctrl+c won’t quit 
out of it. Type Q to quit.
Variations on history searching
For going through our history, there are a few extra things we 
can try out. What if we want to, say, find the last five items? A 
command called tail will show the tail end of a file (or stream 
of text), and the `-[number] option returns a specific number 
of entries:
$ history | grep curl | tail -5
 9651  curl jsbin.ff-platform.local:8000
 9652  curl localhost:8888
 9921  curl http://jsbin.ff-platform.local/user/
twitter\|648873/
 9923  curl -H 'accept: application/json' 
http://jsbin.ff-platform.local/user/
twitter\|648873/
10227  history | grep curl
But, since we ran it a number of times, our original command 
also turns up in the history. So we can pipe grep to another grep 
to remove matched expressions.
Or say we want to find the last five items matching curl but 
not history. We can use grep -v to remove all occurrences of 
a term in the results:
$ history | grep curl | grep -v history | tail -5
 9649  curl -I jsbin.ff-platform.local
 9651  curl jsbin.ff-platform.local:8000
 9652  curl localhost:8888
 9921  curl http://jsbin.ff-platform.local/user/
twitter\|648873/
 9923  curl -H 'accept: application/json' 
http://jsbin.ff-platform.local/user/
twitter\|648873/

36
WORKING THE COMMAND LINE
SORTING AND PICKING
Sometimes you’ll have a file from which you want to pick out 
some particular lines or pieces of data. 
I used to find myself writing weird jQuery scripts and then 
putting all my data in an array and basically jumping through 
more hoops than a frog on speed. These days, though, the 
command line is my friend, because it offers tools like these:
•	 grep: to find lines (as we’ve just seen)
•	 sort: to sort lines
•	 uniq: to find unique lines
•	 cut, sed, and awk: to break a line into columns and pick a 
particular column
There are tons of things you can do by combining these 
tools, so let me present the following problem as an illustration 
of their range and flexibility.
Let’s say I have an unusually high number of requests com­
ing into my server, but I can’t figure out what the source of 
the issue is. The access logs from my server typically follow a 
consistent format (but might appear slightly different depending 
on the situation):
IP - user [day/month/year:hour:minute:second zone] 
"GET /url HTTP/1.1" status_code bytes "referring_
url" "user_agent"
Each entry shows us a lot of information:
127.0.0.1 - remy [24/Feb/2015:16:14:56 +0000] "POST 
/foobar/save HTTP/1.1" 200 34 "http://jsbin.
local/foobar/edit" "Mozilla/5.0 (Windows NT 6.3; 
Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) 
Chrome/40.0.2214.115 Safari/537.36"
I can pipe commands together to search, sort, and separate 
the information in the access logs in an attempt to understand 
the problem.

37
Tools of the Terminal Trade
1. Get the last 1,000 lines
I need to count the number of unique IP addresses that appear 
in the log—and, since my log file is pretty large, I’m only inter­
ested in the last 1,000 requests. 
When I start off, I need to be in the directory that contains 
the logs. The tail command lets me look at the last 1,000 lines:
$ tail -1000 access.log
You can also use tail in combination with the -f option 
to continuously print lines as new lines are written to a file. 
This command shows each web request as it gets written to 
an access log: 
$ tail -f access.log.*
2. Split the lines only showing the IP
A few tools split lines up. One such tool is cut; another is 
awk. awk is incredibly powerful (and, in fact, a programming 
language unto itself), but to keep things simple, I’m just going 
to stick with cut.
With cut, you have to specify the delimiter charac­
ter (using -d' ' to separate on spaces) and the field (using 
–f[field number]) you want:
$ tail -1000 access.log | cut -d' ' -f1
217.128.174.115
82.2.191.64
62.90.202.184
[code omitted for brevity]
In the command above, tail is feeding cut one line at a time 
and cut is printing out the first field on our split line.

38
WORKING THE COMMAND LINE
3. Find the unique IP
For this, I’ll use the uniq command. However, uniq is quirky in 
that it only works with lines that repeat (specifically, lines that 
are adjacent). This means uniq only works on a list like a a b b, 
and not on a b a b. So we need to combine uniq with a sort tool.
So first I’ll need to sort the list of IPs:
$ tail -1000 access.log | cut -d' ' -f1 | sort
173.15.252.198
194.199.90.161
194.199.90.161
217.128.174.111
41.105.206.139
50.249.99.201
62.90.202.182
85.115.60.181
85.115.60.181
88.128.80.106
[code omitted for brevity]
It doesn’t matter that it’s sorted alphanumerically; the 
important thing is that the common entries are next to each 
other. Now I can pipe to uniq, and I’ll add an argument (-c) that 
gives me a count of times the IP appears in the output (which 
I’ve snipped in the interest of brevity):
$ tail -1000 access.log  | cut -d' ' -f1 | sort | 
uniq -c
[code omitted for brevity]
  2 64.22.242.77
  1 66.249.64.146
  1 66.249.64.182
  2 66.37.35.161
 14 66.7.226.139
 12 68.45.20.22
 13 69.116.182.57

39
Tools of the Terminal Trade
  1 70.88.199.14
  7 71.197.194.82
  3 72.226.11.1
[code omitted for brevity]
The output is still long, and it’s also not sorted by number 
of occurrences, so I’m going to fix that, too.
4. Numerical sorting
The sort command uses alphanumerical order by default, but 
if you use -n, it will sort numerically. Since the output from 
the uniq -c command consists of numbers, this is perfect. In 
addition, I only want the top five requesting IPs, so I’m going 
to pipe this (again) to tail to get just the last five lines:
$ tail -1000 access.log  | cut -d' ' -f1 | sort | 
uniq -c | sort -n | tail -5
 33 77.57.124.151
 36 77.232.10.182
 38 109.70.40.211
 39 122.133.158.35
152 198.21.21.22
Now I can see that there’s a significant number of requests 
coming from a single IP: 198.21.21.22. From there, I can use this 
IP to search the logs to see what they’ve been requesting, or 
perhaps ban the IP for a set amount of time, or something else.
It’s important to note that all of the commands I’ve used here 
come with Unix-based systems. So you don’t have to install any 
of these separately.
The most important lesson to take away from this chapter 
is that commands can have their output piped to the input 
of another program using the | symbol. Putting commands 
together embodies the Unix philosophy mentioned at the start 
of this book; most programs support it. Mixing and remixing 
commands allows any number of combinations of manipula­
tions—and that’s powerful stuff.

HOW (NOT) TO 
SHOOT YOURSELF 
IN THE FOOT
4

41
How (Not) to Shoot Yourself in the Foot
NOW THAT YOU’RE FRESHLY EQUIPPED with a little bit of 
knowledge, I think it’s time I show you just enough to do some 
real damage.
Or, put another way, I’m going to show you some commands 
that will help you get out of a pickle when an application goes 
haywire or your machine gets hammered.
You can achieve most, if not all, of these commands through a 
graphical user interface (GUI) if you’re using a Mac (for instance), 
but as you grow more comfortable with the command line, 
you’ll find that it becomes easier just to use that to remove files 
or to check your system health. And if you go on to tinker with 
remote servers, there won’t be any visual UI for you to rely on; 
you’ll be forced to stare into the void and will have no choice 
but to resort to the commands I describe here.
DELETING FILES: rm
...because who needs files when you can have DISK SPACE? 
Older PC users out there will appreciate this (and younger users 
perhaps won’t believe it): when I started messing around with 
PCs (I think it was in 1991), I had an Intel 286, and there were 
these strange files taking up my precious 40-MB hard drive: 
config.sys and autoexec.bat. So I deleted them. Which taught 
me how PCs worked by plunging me into the deep end of 
recovering super-important configuration settings.
Suffice it to say: be careful about deleting. Today’s systems 
go to great lengths to protect you from yourself, but since this is 
the foot-shooting chapter, I’m going to show you how to work 
around some of that.
Deleting regular files
It’s probably easier to do this in a desktop application, like 
Finder, but to remove a single file or multiple files (either named 
or using a pattern), you can do the following (assuming, for the 
purposes of this discussion, that you’re in a directory containing 
text files with the names I made up here):

42
WORKING THE COMMAND LINE
$ rm my-file.txt
$ rm *.txt
Fun fact: the * is a wildcard character, and *.txt is called 
a glob.
This is all pretty straightforward. You might be presented 
with a tricky question, though:
$ rm not-my-file.txt
rm: remove write-protected regular file 
'not-my-file.txt'? y
$
A simple y back at your machine obliterates the file.
Directories aren’t quite as simple: rm isn’t really made to be 
used on them (though I’ll explain in a bit how to get around 
that constraint). If you try to delete a directory, you get a qua­
si-tautological response:
$ rm chapter6/
rm: chapter6/: is a directory
Huh? 
Deleting directories
Directories have a special command, rmdir:
$ rmdir chapter6/
$
That works—as long as the directory is entirely empty. 
Which, let’s face it, is unlikely. Also, if you’re using a Mac, you 
may have noticed .DS_Store files littered all over the place—or, 
you may not have, since dotfiles (files preceded by a dot) are 
hidden by default. Sometimes, a directory that looks empty 
may not be. (You may want to consider changing your system 
preferences to show hidden files.)
So let’s try deleting a directory that isn’t empty:

43
How (Not) to Shoot Yourself in the Foot
$ rmdir chapter4
rmdir: chapter4: Directory not empty
In the face of “Directory not empty,” you can go ahead and 
remove individual files one at a time—major boring—or blow 
everything away in one fell swoop! Welcome to the danger zone, 
cue music (FIG 4.1).
Ultimate delete!
The command rm -rf is usually my go-to answer to any fences 
the system wants to put in my way. Using rm with these two 
flags (-r, which recursively works through any subdirectories, 
and -f, which forcibly removes files without any prompts) will 
delete without any prompting and destroy any subdirectories.
For example, should I decide to nuke this book at any point, 
running the following would destroy all my hard work with a 
single quiet command:
$ rm -rf cli-book
$
No prompting to check if I’m sure, or if I’ve been drinking, 
or to warn me that Chapters 1 through 5 are about to go down 
the drain. Nothing.
FIG 4.1: No, I couldn’t get the license for a picture of Tom Cruise in an F-14 Tomcat. You’ll 
have to settle for this amazing Photoshop effort.

44
WORKING THE COMMAND LINE
Personally, I tend to use this command rather too quickly. 
I admit that, yes, in the years I’ve worked on the terminal, I 
have accidentally deleted the wrong directory because of trig­
ger-happy fingers.
My most retweeted tweet involved a joke that would lead 
someone to run rm -rf ~, which means “delete my home direc­
tory, and don’t worry about any warnings.” I view my tweet’s 
popularity as evidence that people are inherently evil (FIG 4.2).
But wait. rm -rf only works on files you have permission 
to write to. What about the files you don’t own?
WHEN YOU DON’T HAVE 
PERMISSION: sudo
sudo stands for Super User Do. It’s kind of like “Simon Says” 
for your terminal. We’ve already met sudo a number of times, 
and now I need to make good on my promise to tell you more 
about it.
Why is sudo necessary? Because computers have a user per­
mission system. If you’re using a Unix-based machine (again, 
this includes Mac), the user with the most privilege is root. 
FIG 4.2: My rm –rf ~ “joke.”

45
How (Not) to Shoot Yourself in the Foot
The almighty root can do absolutely anything, ranging from 
deleting all your files (without needing your permission), to 
rebooting, to deleting every file on the operating system (a.k.a. 
“real damage”).
When you’re logged into your machine, you’re likely to 
be—and in fact should be—logged in under your own user­
name. (Mine is “remy.”) It is entirely possible that you don’t 
actually perform the act of logging in, but you do have a user 
(and you’re automatically logged in as that user). Your user has 
some privileges, but it’s not as all-powerful as root.
If you share your computer with another person, you prob­
ably don’t have access to read and write or execute that other 
person’s files. This is the basis of the permission system. We’ll 
look more closely at permissions in a moment, but first: what 
happens if you come across a monstrously large file that some­
one else has created, but that you need to remove?
Deleting the file won’t work, because you don’t have per­
mission. Enter sudo.
As a rule, always try to proceed without sudo first, because 
using it is sometimes like taking a sledgehammer to a nail: it 
certainly works, but isn’t always the right tool. With that in 
mind, let’s add sudo to your toolbox.
Using sudo
You can prefix any command in the terminal with sudo. This 
will run your command with superuser (a.k.a. root) privileges. 
Since root can delete anything without asking permission, 
here’s how we would rm another user’s file:
$ sudo rm /User/jack/boring-pony.jpg
Password:
Enter your password, and that’s it.
Almost. To be able to do things with sudo, you need to be a 
sudoer. On a Mac, if you’re in the group called “admin,” you’re 
a sudoer by default. 

46
WORKING THE COMMAND LINE
However, if you find that the sudo command doesn’t work, 
you’ll need to manually add yourself as a sudoer. This will give 
you permission to use sudo. Do this by adding a line to a system 
file called /etc/sudoers (sudoers is the file name in the etc system 
directory, which is important because it holds your computer’s 
configuration files):
remy  ALL=(ALL) ALL
Swap remy out for your username. This will allow you to 
run everything root can run if you prefix your command with 
sudo. You can customize the control you give to users in /etc/
sudoers, but that’s another story for another book. For now, 
let’s focus on the fact that you have the first superpower to do 
some real damage.
Why not run as root all the time?
The short answer is that it’s a bad practice, kind of like driving 
a tank around a quiet neighborhood—and no one wants that 
on their personal report card. Just because you can doesn’t 
mean you should.
That’s why most operating systems these days (like Mac 
and Windows) ask you to create your own user. The user you 
create doesn’t have the same permissions as root. (When you’re 
prompted for your password, it’s because under the hood, your 
OS is trying to do something that requires more permissions, 
similar to using sudo.)
PERMISSIONS
Now that you know how to bulldoze right through permissions, 
it might be useful to know what permissions look like, what 
they mean, and how they function.
My directory list for this book currently looks like this:

47
How (Not) to Shoot Yourself in the Foot
$ ls -ltr
total 2608
-rw-r--r--@  1 remy  staff     1226  7 Aug  2014 
chapter-outline.md
drwxr-xr-x@ 11 remy  staff      374 11 Feb 10:05 
chapter2
drwxr-xr-x@  6 remy  staff      204 11 Feb 10:08 
chapter1
drwxr-xr-x@  3 remy  staff      102 11 Feb 13:46 
chapter3
-rw-r--r--@  1 remy  staff     2583 11 Feb 13:47 
todo.md
drwxr-xr-x@  4 remy  staff      136  4 Mar 16:03 
chapter4
-rwxr-xr-x@  1 remy  staff       30  4 Mar 17:46 
pony
Here you can see each file’s permissions (far left), followed 
by the “link count” (which you can safely ignore), then the 
owner of the file, and, finally, the group the file is part of. My 
Mac has put me in an oddly named group called staff. I don’t 
know why. Next comes the byte size of the file (including the 
byte size for the directory—note that this isn’t the aggregate 
size), the timestamp, and the file name.
Changing permissions
Numbers appearing next to Read, Write, and Execute indicate 
that there are a couple of ways to change a permission (FIG 4.3). 
The first method is easier to learn, but the second method will 
let you show off your newly learned l33t haxor skillz (that’s 
probably the most “leetspeak” I’ve used in two decades, by 
the way). 
File ownership is broken into three sections:

48
WORKING THE COMMAND LINE
•	 Owner: you
•	 Group: you and anyone else in your “group” (useful if you 
share a machine or server)
•	 Other: anyone who isn’t in your group
Why would we want to change file permissions? One reason 
might be to make a file executable. Another might be to allow 
a group member to access a file.
The command we use to do this is called chmod (short for 
change mode).
With chmod, we type the first letters for user (u), group (g), 
or other (o); then a plus operator (+) for adding permissions or 
a minus operator (-) for removing permissions; and finally the 
permission letters for read (r), write (w), or execute (x). 
Let’s look at this in action. To change a file so that it’s execut­
able by the user and the group, we’d run the following:
$ chmod ug+x my-script
This sets the user and group permissions to executable.
If I want all users to be able to read my-script, I could either 
type ugo+r or use a shortcut for “all” (a):
FIG 4.3: drxwrxwrxw represents the range 
of permissions you can see on files. The 
first cluster of rxw characters is the most 
useful because it tells you whether the file 
is readable, executable, or writable by the 
owner (you).

49
How (Not) to Shoot Yourself in the Foot
$ chmod a+r my-script
As long as you can remember how to communicate User, 
Group, and Other, and Read, Write, and Execute, you should 
be able to remember the modes and flags.
As we saw earlier, permissions can also have numerical val­
ues: 4 = read, 2 = write, and 1 = execute (FIG 4.3). Occasionally, 
when you run across chmod in a tutorial, you’ll see it expressed as 
something like chmod 110 my-script or chmod 744 my-script. 
This is the second method I alluded to, and it’s frankly a tad 
confusing and not particularly easy to remember. 
The first digit represents the user permissions, the second 
the group permissions, and the third the permissions of all 
other users. To set the user permissions to read-only, make the 
first digit 4. To set the user permissions to read and write, make 
the first digit 6 (i.e., 4 + 2). To make a file executable for all users, 
readable and writable for the owner, and readable for everyone 
else, the values are 7 (4 + 2 + 1), 5 (4 + 0 + 1) and 5:
$ chmod 755 my-script
It’s common to make a file readable for other users, but not 
writable: since you’re the owner of the program, you don’t want 
anyone else messing with it.
Changing ownership
Along with changing permissions, you may also want to change 
the ownership of a file—either from yourself to another user, 
or from another user to yourself. I’ve needed to do that in the 
past when I’ve had more than one login for my machine and 
wanted to move a file from the other user to myself so that I 
could edit it. 
On a Mac, if the situation is simple enough, the Finder 
can do that work for you (and can also handle some permis­
sion changes). However, I’ve found it useful to know how to 
perform such tasks on the command line because the Finder 
UI isn’t always available, particularly when working with 
remote machines.

50
WORKING THE COMMAND LINE
The command to change ownership is chown (short for, 
appropriately enough, “change ownership”), followed by the 
new owner’s name (anna, in this case). Here’s how you might 
change the owner of a file:
$ chown anna my-script
You can also use chown to change all the files in a directory 
simultaneously by specifying the -R (short for “apply recur­
sively”) flag:
$ chown -R anna cli-book/
You can explore additional flags and usages of chown on 
your own, but these two commands should be enough to get 
you out of trouble.
What is a group, and when did I join one?
Every user is automatically part of group, even if it’s just a group 
of one. Your user is already part of a group. On a Mountain Lion 
Mac, you are part of the “staff” group, and, if you’re sharing 
your machine, so are the other users. 
If you want to add a user to the admin group, you need a 
special command. On a Mac, run:
$ dscl . -append /Groups/admin GroupMembership remy
Note that the group name is preceded by /Groups/.
On a Linux machine, you need a different command entirely:
$ useradd -G admin remy
Groups are a good way to manage user permissions when 
you’re collaborating with multiple people deploying to a server 
(and similar sysops ninjafoo).

51
How (Not) to Shoot Yourself in the Foot
PROCESSES
A process refers to an application running on your operating sys­
tem. If you use Sublime Text 2, for instance, there is a process 
called—wait for it—Sublime Text 2.
If you’re a Mac user, take a look at the Activity Monitor pro­
gram, which lists the processes currently running. PC users can 
use the trusty Task Manager for the same view.
ps (short for “process status”) is the command-line equiva­
lent of Activity Monitor. Here’s what happens when I run ps 
on my machine right now:
$ ps
  PID TTY           TIME CMD
95218 ttys000    0:04.06 -zsh
61075 ttys001    0:00.21 -zsh
77196 ttys002    0:00.60 -zsh
  509 ttys003    0:04.94 -zsh
  525 ttys004    0:02.52 -zsh
This output doesn’t really represent what’s happening on 
my machine, though. The list above shows five zsh (Z shell) 
commands. Z shell refers to my shell, a text-based interface 
that runs in my terminal, processes commands, and returns 
output. (We’ll look more closely at what the shell is, and Z shell 
in particular, in Chapter 5.)
Notice that Sublime Text doesn’t appear here, even though 
I’m using it right now to write this chapter. In fact, ps by itself 
only lists processes that have a terminal attached.
But we want to list all processes, with the full command 
used and the process owner (which is also linked to who has 
permission to terminate the process, but more on that later).
It’s a mouthful, but using the ps auxww command (the order 
of the flags doesn’t matter) gives us lots of ps goodness. I’ve 
cropped the screenshot because it was reams of lines (FIG 4.4).
The output from ps becomes more manageable when you 
pipe the output into a tool like grep to search for a particular 

52
WORKING THE COMMAND LINE
command—perhaps to make sure it’s running as you expected, 
perhaps to kill it. Here, I’m piping the output of ps auxww to 
grep -i [term] (the -i on grep means case insensitive):
$ ps uaxww | grep -i sublime
remy            59329   0.0  1.5  3308128 260008   
??  S     8Mar15  48:43.56 /Applications/
Sublime Text 2.app/Contents/MacOS/Sublime Text 2 
-psn_0_18747872
remy            66220   0.0  0.0  2432780    428 
s000  R+    1:00pm   0:00.00 grep -i sublime
What’s strange is that this returns two results. Why? Because 
when we grepped, the grep command with the term we were 
looking for was currently running, so it appears in the ps list. 
Inception, anyone?
FIG 4.4: Plain output from ps can be a bit unwieldy, but using grep will help us narrow 
down what we’re looking for.

53
How (Not) to Shoot Yourself in the Foot
If that bothers you, remember that we learned in Chapter 
3 how to use grep -v [term] to exclude the term from your 
results (the –v stands for “invert-match”):
$ ps uaxww | grep -i sublime | grep -v grep
remy   59329   0.0  1.6  3311748 262020   ??  S  
8Mar15  49:04.37 /Applications/Sublime Text 2.app/
Contents/MacOS/Sublime Text 2 -psn_0_18747872
There’s a lot of information here, but most relevant for us 
are the first, second, and last columns: the user who started the 
process (and who therefore owns it), the process ID (PID), and 
the full command running.
Kill kill kill!
If When a process goes haywire, you’ll probably first notice 
by it hanging. If Sublime hangs for me, I can’t enter any text. 
Sometimes my machine will kill the process automatically; 
other times, more aggressive action is required.
First, let’s locate the process ID. In this example, it’s 59329:
$ ps uaxww | grep -i sublime | grep -v grep
remy   59329   0.0  1.6  3311748 262020   ??  S  
8Mar15  49:04.37 /Applications/Sublime Text 2.app/
Contents/MacOS/Sublime Text 2 -psn_0_18747872
If you know part of the process name, you can also try using 
pidof [term] to find the “process ID of” the given term. (Mac 
users may have to brew install pidof first).
Now we use the command kill to stop the process dead 
in its tracks:
$ kill 59329
*Remy reopens Sublime to continue writing.*

54
WORKING THE COMMAND LINE
For me, Sublime just terminated. No warnings. No “Do you 
want to save your carefully crafted prose?” Nothing. Just killed.
But what if the process doesn’t belong to you? What if you 
don’t have permission to kill it? That’s right, sudo to the rescue 
(as you blow away some poor sap’s program):
$ sudo kill 59329
Sometimes, though—just sometimes—a kill isn’t enough. 
You have to kill harder. The kill command says to the process, 
“Would you mind gracefully shutting down?” Typically, the 
program will behave politely and exit, but once in a while you 
have use some force.
The kill -KILL [pid] and kill -9 [pid] commands mean 
the same thing: kill the process and don’t wait for the process 
to respond.
When using -9 to kill, you may also need to add sudo to the 
mix. But it will get the job done. It’s the fatality move of the 
command line (FIG 4.5).
FIG 4.5: The kill -9 command deals a fatal blow to all running programs. It asks no 
questions and grants no mercy.

55
How (Not) to Shoot Yourself in the Foot
DIAGNOSING PROBLEMS
Now that you have the knowledge to completely ruin your 
machine, it’s also worth learning about a handful of com­
mand-line tools that will help you quickly diagnose sim­
ple problems.
top
top will show you a live, constantly updating view of processes 
running. You can order the list by CPU usage (P) or memory 
(uppercase M)—very helpful if you have a process hog. A word 
of warning, though: top on a Mac can be a little hard to deal 
with because it delivers a barrage of way too much information. 
(The Linux flavor of top differs from the Mac version, and is, 
frankly, more useful.)
A viable alternative to top is htop, which is consistent across 
platforms and generally looks nicer than top. It supports the 
same keyboard shortcuts that I use to sort top with, but also 
features quick searching using the / character. You can install 
htop on a Mac by typing brew install htop.
Both top and htop provide information very much akin to 
that of the activity monitor or task manager you may already 
be familiar with. Consider making top or htop your go-to tool 
for quick health analysis.
uptime
uptime offers a quick overview of your machine’s health (also 
shown at the top of top). The values returned by uptime include 
how long your machine has been running (handy if you suspect 
the machine has recently restarted) and load averages:
$ uptime
13:38  up 48 days, 22:40, 9 users, load averages: 
1.37 1.62 1.78
The load averages show numerical values for the current 
load, the average over five minutes, and the average over fifteen 

56
WORKING THE COMMAND LINE
minutes. This is a vaguely useful metric: if it’s around 1, then 
it’s okay; if it’s 10 or above, the machine is probably struggling 
and something might be wrong.
df -kh
If your server appears to have a normal load but things are nev­
ertheless going very wrong, it’s entirely possible that you’ve run 
out of disk space. Understandably, machines get rather weird 
about having no disk space.
The df -kh  command lists the available disk space on the 
machine (FIG 4.6). Depending on whom you ask, df stands for 
either “display free (disk space)” or “disk free”; -k indicates 
kilobytes and –h means (importantly) “human readable.”
The important columns to note here are Size, Used, 
Available, and Mounted on.
Mounted on tells you which path is the problem. In the above 
df, it’s including some funky virtual drives (I can see they read 
a size of 0). I’m ignoring those values and focusing on the row 
that’s mounted on /: that’s the root of my operating system, and 
where all my files live. I can use this information to get a sense 
of how much disk space I have left (and whether I should start 
removing some files).
You’ve basically learned how to completely destroy your 
machine. rm -rf will blast away files without prompts, sudo 
will let you do anything to anyone’s files or processes, and 
kill -9 will terminate a program in mid-execution.
FIG 4.6: Running the df -kh command results in a list of available disk space.
$ df -kh
Filesystem      Size   Used  Avail Capacity  iused     ifree %iused  Mounted on
/dev/disk0s2   931Gi  271Gi  659Gi    30% 71191372 172874989   29%   /
devfs          191Ki  191Ki    0Bi   100%      662         0  100%   /dev
map -hosts       0Bi    0Bi    0Bi   100%        0         0  100%   /net
map auto_home    0Bi    0Bi    0Bi   100%        0         0  100%   /home

57
How (Not) to Shoot Yourself in the Foot
Rumor had it that you could do sudo kill -9 1 and it 
would shut down a machine in one go. As I mentioned earlier, 
systems protect themselves from such stupidity nowadays, but 
one can only try!
You now know some seriously dangerous moves. But if 
you want to be a hero, you have a few tools to check on your 
system’s health, too.

MAKING THE SHELL 
YOUR OWN
5

59
Making the Shell Your Own
IN CHAPTER 1, I showed you how to replace your default ter­
minal with an alternative. The terminal is the application that 
runs your shell. You’ve already met and used the shell—it’s 
where you actually run commands and see the output. The 
shell, irrespective of the terminal application you choose, can 
have its own customizations.
Let’s look at some of those, now that you have a little more 
experience under your belt. Although most shell customization 
offers only modest power-ups, I’d argue that it’s quite import­
ant: customization is what makes a thing feel like it belongs to 
you. Potentially, at least, there are as many shells as there are 
users (FIG 5.1).
Terminal customization follows a certain hierarchy: first, 
there’s the terminal application itself; then, within the terminal, 
is the shell; inside the shell is the prompt; and, finally, there are 
aliases and shortcuts. We’ll look at each in turn (FIG 5.2).
THE TERMINAL
As I mentioned at the beginning of this book, iTerm2 is far 
and away my favorite terminal emulator. Like most other ter­
minal applications, iTerm2 accepts a wealth of customizations. 
Let’s take a look at the preferences for my keyboard shortcuts 
(FIG 5.3).
As I mentioned in Chapter 1, split windows can be quite 
useful. In iTerm2, you can type cmd+d to split your terminal 
vertically (so you have two terminals side by side), or cmd+­
shift+d for a horizontal split. Then you can keep splitting to 
your heart’s content. This is a feature of the application; your 
mileage may vary (FIG 5.4).
You’ll also find in the preferences the theme (or “profile”) for 
your terminal, which allows you to customize the colors and 
the font. Iterm2-color-schemes is a good place to start browsing 
around for themes. Some people prefer a dark theme, some pre­
fer a light theme, others have images in the background of their 
terminal, and still others use a semitransparent background. My 
extra pro-user tweak is that I use a hot-pink (#d13a82) cursor 
combined with a dark theme.

60
WORKING THE COMMAND LINE
FIG 5.1: A smattering of terminal customizations from my Twitter followers.
FIG 5.2: Areas of the terminal that can be personalized.

61
Making the Shell Your Own
FIG 5.4: Ordinarily I split a window only a few times, but if you want to go wild, you can 
split your terminal into the golden ratio.
FIG 5.3: My iTerm2 keyboard preferences. In particular, I’ve changed the shortcut for 
navigating from one split panel to another, and (most important, because it’s my favorite 
keyboard shortcut) the system-wide shortcut to bring iTerm2 to the front: cmd+esc.

62
WORKING THE COMMAND LINE
THE SHELL
There are a number of different shells available with varying 
customizations, but in all likelihood, assuming that you’re on 
a Mac, your machine will come with a shell called Bash. Bash 
is a good go-to shell if you’re managing servers, but if you use 
your own machine for development, you might want to go for 
something a little more powerful.
Fish
Fish Shell is an option with at least one nice advantage: it makes 
it easy to get started by including installers for all platforms, 
and even includes a standalone app for OS X, which is a nice 
way to preview it.
I don’t use Fish myself, but I mention it here because it 
includes a lot of features by default: autocomplete, tab com­
pletion, highlighting, and a web configuration interface for 
customizing the theme and prompt (you have to run fish_config 
in the shell). If ease of configuration is what you need, this is 
a good option.
Z shell
Z shell, or zsh, has some great features—but if you really want 
to get the most from it (with the least amount of effort), you’ll 
also want to install Oh My Zsh, a community-driven framework 
for managing zsh. I like Oh My Zsh because it gives me a bunch 
of plugins and makes theming my shell really easy.
My terminal uses the features of zsh to give me a rather spe­
cial and informative prompt: it includes the current directory, 
Git status, battery power, and whether I have a connection to 
the internet (FIG 5.5).
Installing zsh is a bit more involved than Fish, but it’s cer­
tainly worth the extra work. To install it, you’ll use Brew; while 
you’re at it, go ahead and install the Oh My Zsh manager, too:

63
Making the Shell Your Own
$ # install zsh
$ brew install zsh zsh-completions
$ # add oh-my-zsh
$ curl -L https://github.com/robbyrussell/oh-my-zsh/
raw/master/tools/install.sh | sh
$ # make zsh your default
$ chsh -s /bin/zsh
Windows users will need an alternative way to get zsh. A 
project called Babun looks promising—it includes zsh as the 
default shell, with Oh My Zsh also included by default. The 
shell is preconfigured and doesn’t require admin rights to run. 
This could be a nice alternative to the GitBash shell that you 
may already be using.
Security of curl ... | sh
It’s worth noting that you should be cautious of anything that 
asks you to run curl -L [URL] | sh. This command effec­
tively runs a remote script on your local machine with the 
same privileges as you have. Potentially (worst-case scenario), 
the remote script could remove your entire home directory. If 
you’re familiar with JavaScript, the equivalent would be like 
including a remote <script src="...unknown.js"> on a web 
page. It could be perfectly harmless; it could also be malicious.
Z shell themes
Now that you have zsh installed and set as your default shell, 
you can select a theme and add some plugins to make the shell 
super awesome.
FIG 5.5: Here’s what my zsh prompt looks like today.

64
WORKING THE COMMAND LINE
There are tons of themes to choose from. Z shell’s default 
theme is called “robbyrussell” (named after the author of Oh My 
Zsh). Agnoster is a popular theme, but it requires custom fonts. 
My prompt is a modification of the Agnoster theme—mainly a 
riff on its prompt. I’ll explain the prompt in the next section so 
that you can create your own perfect fit.
A complete list of preinstalled themes is available on the Oh 
My Zsh wiki page, with screenshots for each. There are also 
external themes that do not come bundled with Oh My Zsh, but 
the links include directions on how to install them.
To select your theme, you need to edit the .zshrc file in your 
home directory. If you can do this in your favorite editor, then 
go ahead and open the file. If you’re using Sublime Text like 
me, though, the file will be hidden (since dotfiles are hidden 
by default).
One thing you can do to get around this is to use open (if 
you’re on a Mac) and hope that the file opens in an editor:
$ open ~/.zshrc
Otherwise, you can try using a terminal editor program 
called nano by typing nano ~/.zshrc. The commands to save 
and exit run along the bottom of the window, so it’s pretty 
self-explanatory (FIG 5.6).
Find the line that contains ZSH_THEME="robbyrussell" and 
update it to any name you like. Once you’re done, save the file 
and restart your session (which may close the entire terminal 
window).
Quick history searching with zsh
If you’ve familiarized yourself with the cursor keys enough 
to navigate the history on the CLI, then zsh adds something 
incredibly useful.
Before zsh, if you were looking for a recent command—say, 
wc, to get the word count of a document—you would grep the 
history output looking for wc, and then run that particular 
history item again (either by copying and pasting the command 
or by running ![n]—where n is the history number).

65
Making the Shell Your Own
But with zsh, you can type the start of the command (wc) 
and then cursor up—and the cursor will cycle through every 
command that starts with wc. In most cases, you can immediately 
find the command you want and rerun it.
Plugins
One of the key features of Oh My Zsh is the plugin ecosystem. 
I can’t cover all of the plugins here, but I can show you how 
to enable a few that I personally find very useful, and where 
to find more.
By default, Oh My Zsh comes with a large number of plugins 
listed in detail on its plugin overview wiki page. I highly recom­
mend browsing through them once you’re comfortable adding 
plugins to see if there’s anything that captures your interest.
If you want a plugin that’s outside of the default collection, 
you can often find installation directions in the plugin’s readme 
file. Unfortunately, the “simplest” installation method often 
requires Git on the command line.
Oh My Zsh makes enabling plugins easy: you need to edit 
the .zshrc file (as you did earlier for the theme). Find the line 
that starts with plugins=(. From there, add the names of the 
FIG 5.6: The nano editor isn’t as handsome as Sublime Text, but it does the job. Just 
remember that ^ means the Control key on your keyboard!

66
WORKING THE COMMAND LINE
plugins you want to make available in your shell, separating 
each with a space.
At this writing, my list of plugins reads as follows:
plugins=(sublime z zsh-syntax-highlighting)
It’s worth noting that all of the plugins I’m using are part 
of the default plugins shipped with Oh My Zsh, except for 
zsh-syntax-highlighting, which I’ll explain in a moment.
As a user of Sublime Text, I find myself navigating directories 
and editing hidden files via my terminal. I’m handy with CLI 
editors (Vim in particular, and also nano, which I touched on 
earlier), but I’m much more comfortable editing in Sublime Text.
From the terminal, I can use the Sublime Text plugin that 
adds an st command to my shell to open a file or directory in 
Sublime Text:
$ st cli-book # opens the cli-book directory in 
sublime
$ st cli-book/chapter5/chapter5.md # opens the 
individual file
If you’re a TextMate user, there’s also a plugin for that; just 
use mate in place of the st command.
Next up is z, which is possibly the command I use the most 
in my daily workflow. It allows me to jump to any directory 
using just a fragment of the name (if I’ve been there before), the 
z in this list of plugins:
plugins=(sublime z zsh-syntax-highlighting)
Say I navigate to the cli-book directory in my terminal. After 
I’ve changed to that directory for the first time, I can use the 
z command with any part of the directory name to quickly 
jump to it.

67
Making the Shell Your Own
$ z cli # takes me to ~/Dropbox/writing/cli-book/
$ z book # takes me to ~/Dropbox/writing/cli-book/
$ z writing # takes me to ~/Dropbox/writing/
Running z alone will result in the full list of directories and 
their frequency of use. The highest-frequency directories take 
priority in matching the argument you give to the z command.
There are a few alternatives to this command, including 
autojump, jump, and wd (all provided by Oh My Zsh’s default 
plugins). I personally haven’t tried any of these alternatives, 
since z does the job just fine for me, and I suspect there’s no 
advantage to having more than one installed.
Finally, I’d like to mention zsh-syntax-highlighting. This 
plugin is really handy. It colors your command green if it exists 
and red if it does not, in real time, as you type. This makes it 
easy to catch errors in commands: if the text turns red, you’ll 
know that either the program doesn’t exist or you’ve made a 
typo (FIG 5.7).
There are a number of ways to install zsh-syntax-highlight­
ing, as the install page explains, but I find that the cleanest 
method is to use Git to copy it directly into your plugins:
$ git clone git://github.com/zsh-users/
zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/
plugins/zsh-syntax-highlighting
Then edit your ~/.zshrc file (perhaps using st ~/.zshrc) 
and add zsh-syntax-highlighting to the end of your plugins. 
FIG 5.7: The zsh-syntax-highlighting plugin shows you in real time if a command exists or 
not (or if you’ve made a typo). That way, you don’t have to memorize all of the programs 
on your computer. 

68
WORKING THE COMMAND LINE
(Note that the plugin must be the last plugin in the list as per 
the installation instructions.)
Now when you restart your shell session, the zsh-syn­
tax-highlighting plugin will be enabled. If you don’t want to 
keep exiting and restarting your session, you can load the .zshrc 
file using the following command:
$ source ~/.zshrc
The source command runs the given file, and thus reloads 
your entire shell configuration. Super-pro tip: the source com­
mand is interchangeable with ., so you could run . ~/.zshrc 
if you really wanted to impress someone.
Installing the Git CLI tools
As we saw in Chapter 2, there’s always a way to install stuff 
via the CLI. If you’re using Windows and Git BASH, then you 
have Git on the command line already. If you’re on a Mac, you 
probably have Git, but it’s likely to be out of date (because Git 
is released more frequently than new operating systems), so 
you’ll need to update it.
$ brew install git
$ git --version
Now you’ll be able to use the directions that might require you 
to git clone the plugin into your Oh My Zsh plugins directory.
THE PROMPT
You’ve already met the prompt. It often looks like this: 
$. Maybe it includes your machine name and username: 
MacBook-Pro:~ remy$. Which is fine, but you probably don’t 
care about the machine name if it’s your own machine, and 
I hope you know your own username. (These names can be 
useful if you’re connecting remotely, though.)

69
Making the Shell Your Own
If you’ve switched to zsh already, you’re more likely to have 
a very sleek prompt (FIG 5.8). 
If we break this down, what we see in this prompt is an 
arrow (
) followed by the current directory name (not the full 
path). When we’re in the Git repository, it says git and notes 
which branch is active.
Prompts can get fairly complicated. If they get too compli­
cated, they look like garbage. If I set Bash custom shell (PS1) 
to a new value, it modifies my prompt—but, wow, that’s some 
horrible code (FIG 5.9).
Fortunately, much progress has been made in the area of 
sharing prompts and making them slightly more readable. Shar­
ing prompts is important because it helps people experiment, 
learn, and improve.
My general recommendation is to take a theme you like from 
zsh, copy it, and tweak it to make it your own. Let’s say you’ve 
decided to use the robbyrussell theme and want to customize it 
a little. First you will need to make a copy of it, so let’s call the 
new theme my.zsh-theme and put it in the themes directory:
$ cp ~/.oh-my-zsh/themes/robbyrussell.zsh-theme 
~/.oh-my-zsh/themes/my.zsh-theme
FIG 5.8: The default zsh prompt. Pretty fancy, eh?
FIG 5.9: Prompt overkill.

70
WORKING THE COMMAND LINE
Now open the my.zsh-theme file in your favorite editor. Try 
not to let it bamboozle you too much (like I did the first time I 
encountered it). What interests us here is the first line, in par­
ticular the arrow (
) character, which appears in the file twice:
local ret_status="%(?:%{$fg_bold[green]%}
 
:%{$fg_bold[red]%}
 %s)"
PROMPT='${ret_status}%{$fg_bold[green]%}%p 
%{$fg[cyan]%}%c %{$fg_bold[blue]%}$
(git_prompt_info)%{$fg_bold[blue]%} % 
%{$reset_color%}'
The variable ret_status changes the arrow icon depend­
ing on whether the last command exited successfully: a bold 
green arrow($fg_bold[green]) if so, and a bold red arrow 
($fg_bold[red]) if there was an error. The second line sets the 
magic value of PROMPT, creating the prompt you’ll use.
Now, let’s change the arrow to a snowman (
). (This isn’t 
necessarily very practical, but it will do for the exercise at hand.) 
We’ll also show the full path, but on a line of its own, above 
the prompt.
Swapping the arrow out for the snowman is simple, but since 
the emoji won’t change color if there’s an error, we’ll use an 
alien emoji for errors instead (and drop the color information). 
Furthermore, getting the full path in the prompt will require 
moving some elements around in the PROMPT value. It’s also 
perfectly legitimate to put a line break in the value of PROMPT, 
which is how we’ll get our multiline prompt:
local ret_status="%(?:
 :
 %s)"
PROMPT='%{$fg[cyan]%}%d
${ret_status}%{$fg_bold[green]%}%p 
%{$fg_bold[blue]%}$(git_prompt_info)
%{$fg_bold[blue]%} % %{$reset_color%}'
Now we’ll be able to see when we get a random error; our 
prompt will switch to the alien until there’s a successful com­
mand (FIG 5.10).

71
Making the Shell Your Own
There’s also a right-hand prompt with zsh; this can be set 
using the RPROMPT value. You can do all sorts of things with 
this value, like add the current time (or perhaps something 
more creative).
Or let’s say you want to add the current time in square brack­
ets and in blue, just for the heck of it. Simply add the following 
to your my.zsh-theme file:
RPROMPT="%{$fg[blue]%}[%*]"
The 24-hour time with seconds is represented by %*, so the 
final prompt is a bit of a visual mess of curly braces and percent 
signs. For that I apologize, but once you’ve got your prompt, 
you probably won’t change it again…ever.
The full list of prompt variables is listed in the zsh prompt 
expansion documentation. It’s a little dry, but it contains all the 
values you can use. If you’re after a more approachable account, 
you can read about my entire prompt setup on my blog.
ALIASES
Aliases are just alternatives to existing CLI commands. To cre­
ate an alias, use the alias command. For instance, you might 
alias the command ll to ls -ltrFa (a shortcut to list all files with 
hidden files included, ordered so that the most recently changed 
appears at the end of the output):
$ alias ll='ls -ltrFa'
FIG 5.10: Huzzah. Our prompt now features a snowman when things are okay, and an alien 
when the last command failed.

72
WORKING THE COMMAND LINE
However, running this in the shell means that you only have 
the alias for as long as the session lasts and, crucially, that the 
alias won’t work in other sessions. Not cool. So let’s fix that.
To make your aliases easy to manage and add to later on, 
it can be useful to create a file called .aliases in your home 
directory (cd ~) containing all your aliases. That way you can 
effortlessly pull in your .aliases file by adding the following line 
to your .zshrc file:
source ~/.aliases
Because this is part of your .zshrc file, it means that every 
new session will include all of your aliases. Many developers 
have published their own aliases, which I highly recommend 
checking out; they are amazing resources that you can add to 
your own aliases to make your workflow more efficient.
Aliases can be simple (as we’ve just seen), or they can com­
bine commands. Remember how we learned to navigate to 
parent directories in Chapter 1? You can use aliases to do that 
work much more efficiently: 
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
These commands will allow you to type .. in the shell to 
get it to move to the parent directory. Three dots will take you 
to the parent’s parent directory, and so on.
Aliases are useful for commands that you may not find easy 
to remember. For instance, if you can’t remember the exact 
command to run each time you might want to clear the DNS 
cache on your Mac, you can use this alias:
alias flush="dscacheutil -flushcache"

73
Making the Shell Your Own
Or for example, I can never remember the series of com­
mands to show and hide the desktop icons on my mac, so I use 
two aliases to make my life easier:
alias hidedesktop="defaults write com.apple.finder 
CreateDesktop -bool false && killall Finder"
alias showdesktop="defaults write com.apple.finder 
CreateDesktop -bool true && killall Finder"
I’d love to reel off all of my aliases here and now, but that 
would spoil all the fun you’ll have browsing other people’s 
ideas on your own. Plus, it would likely take up oodles of 
pages in this book and wouldn’t copy and paste very well. I will 
point you toward Mathias Bynens, though, who has compiled 
an excellent repository of dotfiles (including aliases, his shell 
setup, and more), where he also references the sources that have 
inspired him. It’s well worth a look to spur your motivation, and 
to start flexing your copy-and-paste muscles.
Functions
Aliases have one limitation: you can’t insert an argument. For 
instance, if you want to get the base64 data URL for a file, you 
can’t quite do that with an alias; you need a function. You 
can run function names in your terminal the same way you 
run aliases.
Here’s the code required to generate a base64 URL for 
any file:
function dataurl() {
  local mimeType=$(file -b --mime-type "$1");
  if [[ $mimeType == text/* ]]; then
    mimeType="${mimeType};charset=utf-8";
  fi
  echo "data:${mimeType};base64,$(openssl base64 -in
  "$1" | tr -d '\n')";
}

74
WORKING THE COMMAND LINE
This lets you get the data URL for an image from the terminal:
$ dataurl book-cover.png
data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABA...
We’ve just covered a lot of ground, but now you know how 
to customize your terminal to suit your personal style. You’ve 
learned about, and hopefully converted to, Z shell and the 
awesome Oh My Zsh project. You’ll have a few personal aliases 
to make your workflow a little sleeker, and finally you’ll have 
your very own customized prompt—designed by you, for you.
YOUR TURN
Hm. All endings are more or less arbitrary, I suppose, but I can’t 
just close this book by showing you how to add functions to 
your prompt, can I? So let me bid you farewell and wish you 
the best of luck with your continued journey into the void.
In these pages, I’ve tried to spill a little of my knowledge into 
your head and have shared my recommendations for worth­
while terminal features (tabs, split windows, and so on). You 
now know how to install all kinds of CLI utilities, and since 
they’re so tiny, you’ll soon have—lucky you—thousands of 
single-use programs at your disposal. The tools of the terminal, 
I suspect, will become your go-to programs on the command 
line. I have no doubt that with time, you’ll be using these to 
manipulate text and commands as you see fit. 
Above all, my hope is that this book has given you enough 
nerve not to run away screaming from the inevitable: “Just 
open the terminal…”

75
RESOURCES
RESOURCES
Here are a few essential resources to help you take on the 
command line. 
Configuration and dotfiles
•	 Remy’s terminal setup. A look at how I’ve configured my ter­
minal, which you’ve seen in various screenshots throughout 
this book.
•	 GitHub’s guide to dotfiles. A great starting point to dis­
cover other people’s dotfiles (the configuration files for your 
prompt, aliases, and functions). Includes some useful links 
to help enhance the zsh.
•	 Some popular dotfiles by Mathias Bynens, Ben Alman, Paul 
Irish, and me.
Useful shell command browsing sites
•	 Ask HN: Share your favorite bash/zsh aliases. Here people 
share their favorite aliases. A good place to pinch a few ideas.
•	 Bash one-liners. A vast collection of little bash commands, 
useful for browsing and learning a new trick here and there.
•	 alias.sh. Although the site is now retired, it still hosts lots of 
great aliases and explanations about how they work.
Bonus: pretty much the best feature of my terminal
•	 ponysay. An alternative to cowsay, ponysay brightens up my 
terminal every day!

76
WORKING THE COMMAND LINE
ACKNOWLEDGMENTS
I’d like to extend special thanks to a few people who helped 
usher this book into existence. 
First, to Mark, who chucked me into the deep end of the 
terminal long before I’d ever published anything on the web. To 
Craig, for inviting me to write a book on the CLI. And to Anna, 
for strong-arming me into finishing the last half of this project 
after it had started to languish. I’m pretty sure this book never 
would have been finished had it not been for our conversations.
Thanks to Katel and Caren for all of their help, especially to 
Caren for making sense of my sometimes roundabout way of 
saying things.
Finally, a special thank-you to my family for their support 
and to Julie for for letting me write when we really could 
have used two parents to wrestle our children’s attention 
and imaginations.

77
REFERENCES
REFERENCES
Shortened URLs are numbered sequentially; the related long 
URLs are listed below for reference.
Chapter 1
01-01	 http://www.linfo.org/unix_philosophy.html
01-02	 http://iterm2.com/
01-03	 https://git-for-windows.github.io/
01-04	 https://web.archive.org/web/20120225123719/http://www.nog.net/~tony/
warez/cowsay.shtml
Chapter 2
02-01	 https://chocolatey.org/
02-02	 https://chocolatey.org/docs
02-03	 https://chocolatey.org/install
02-04	 http://brew.sh/
02-05	 https://github.com/mroth/lolcommits
02-06	 https://abookapart.com/products/git-for-humans
02-07	 https://pypi.python.org/pypi
02-08	 https://nodejs.org/en/
02-09	 https://github.com/npm/npm/blob/
7fe6950b44d241bb4d90857a44d89d750af1e2b3/doc/misc/npm-faq.md
#if-npm-is-an-acronym-why-is-it-never-capitalized
02-10	 https://www.npmjs.com/package/cowsay
Chapter 3
03-01	 https://www.youtube.com/watch?v=EkluES9Rvak&feature=youtu.be
03-02	 http://daringfireball.net/projects/markdown/
03-03	 https://en.wikipedia.org/wiki/Less_%28Unix%29#Frequently_
used_commands
Chapter 5
05-01	 http://iterm2colorschemes.com/
05-02	 http://fishshell.com/
05-03	 https://github.com/robbyrussell/oh-my-zsh/wiki/themes
05-04	 https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes

78
WORKING THE COMMAND LINE
05-05	 https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview
05-06	 http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html
05-07	 https://remysharp.com/2013/07/25/my-terminal-setup
05-08	 https://github.com/mathiasbynens/dotfiles
05-09	 https://github.com/mathiasbynens/dotfiles#thanks-to
Resources
06-01	 https://dotfiles.github.io/
06-02	 https://github.com/cowboy/dotfiles
06-03	 https://github.com/paulirish/dotfiles
06-04	 https://github.com/remy/dotfiles
06-05	 https://news.ycombinator.com/item?id=9869231
06-06	 http://www.bashoneliners.com/
06-07	 https://web.archive.org/web/20141216192521/http://alias.sh/
06-08	 https://github.com/erkin/ponysay

79
INDEX
INDEX
A
Activity Monitor  51
Adobe Photoshop  3
Agnoster  64
Aliases  71
Alman, Ben  75
application installers  19
awk  37
B
Babun  63
bang dollar  12
Bash  62
Brew  23, 62
Bynens, Mathias  73, 75
C
cat  3
change directory  6
chmod  48
Chocolatey  21
CLI  2
tools  68
cmd.exe  5, 22–23
command history  11
Command Prompt  4, 5
cowsay  15, 19, 28
cowthink  15
ctrl+c  16
ctrl+d  16
ctrl+left  15
ctrl+r  16
ctrl+right  15
curl  63
D
Debenham, Anna  25
deleting files  41
delimiter  37
Demaree, David  26
Docker  14
DOS  5
Dropbox  9
.DS_Store  42
E
esc+b  15
esc+f  15
F
file ownership  47
Finder  41
flags  7
foo  32
functions  73
G
Git BASH  6, 21, 68
GitHub  19
glob  42
global commands  24
Gnome Terminal  4
Google  20
grep  3, 32
group  50
Grunt  28
GUI  41
Gulp  28
H
hash symbol  32
Hello world  12
HISTSIZE  13
I
Irish, Paul  19, 75
iTerm2  4, 59–60
iTunes  19
Ive, Jony  2

80
﻿
J
JavaScript  27
jQuery  36
K
kill  53
L
less  34–35
Linux  4, 20
load averages  55
lolcommits  25
M
Mac  4
OS  15
Markdown  32
N
Node  25, 27
npm  28
O
Oh My Zsh  62
options  7
OS X  10
P
permissions  46
PhoneGap  28
PID  53
pipe  31
pling dollar  12
Plugins  65–67
ponysay  29
PowerShell  5
process  51
Python  25, 27
R
regular expressions  32
rm  41
robbyrussell  64
Ruby  19, 25–26
gem  25
S
select-to-copy  4
shell  5, 62–63
Fish Shell  62
Z shell  62–64
shortcuts  9
sort  39
split screens  4
string manipulation  32
Sublime Text  3, 51
sudo  44–45
switches  7
T
tab  14
tab-completion  14
tabs  4
Terminal  4
terminal application  3
text-based interface  5
TextMate  66
the prompt  6, 68–69
the terminal  2
top  55
Twitter  19
U
Ubuntu  20
uniq  38
Unix philosophy  2
uptime  55
using the keyboard  14
V
Verou, Lea  32
Vim  66

81
INDEX
W
Wget  19, 23
Windows  4
X
Xcode  27
Y
Yeoman  28
Z
Z shell  51
zsh-syntax-highlighting  67

ABOUT A BOOK APART
We cover the emerging and essential topics in web design and 
development with style, clarity, and above all, brevity—because 
working designer-developers can’t afford to waste time.
COLOPHON
The text is set in FF Yoga and its companion, FF Yoga Sans, 
both by Xavier Dupré. Headlines and cover are set in Titling 
Gothic by David Berlow.

ABOUT THE AUTHOR
Remy Sharp has been working 
commercially on the web since 
1999 and blogging for over a 
decade. He runs his own consul-
tancy, has been writing JavaS-
cript long before it was cool, and 
founded the web conference 
ffconf in 2009. Remy tends to 
attract bugs and he enjoys 
squishing them. He uses the ter-
minal daily.

