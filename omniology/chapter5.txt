Table of Contents
Chapter 5. XSLT in Detail.............................................................................................. 1
5.1. XPath.................................................................................................................................................................................. 1
5.2. Programmatic Aspects of XSLT.......................................................................................................................................... 4
5.3. Our CMS Project............................................................................................................................................................... 21
5.4. Summary........................................................................................................................................................................... 30
Chapter 5. XSLT in Detail
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
This PDF is exclusively for your use in accordance with the Safari Terms of Service. No part of it may be reproduced or transmitted in any form by any means without the prior
written permission for reprints and excerpts from the publisher. Redistribution or other use that violates the fair use priviledge under U.S. copyright laws (see 17 USC107) or that
otherwise violates the Safari Terms of Service is strictly prohibited.

Chapter 5. XSLT in Detail
565
In Chapter 2 and Chapter 4, you got some exposure to XSLT, and learned some basic tips for
displaying XML in a Web browser. Now it's time to uncover some of XSLT's more advanced syntax.
The goal of this chapter is to help you get a better understanding of the power of XSLT. Once we've
taken care of that, we'll return to our CMS project and start applying XSLT rules to the display
pages we built in the last chapter. First, though, let's take another look at XPath.
1334027
5.1. XPath
661753
You've already been exposed to XPath in our work with XSLT so far, but in keeping with the theme
of this chapter, let's stop and take a closer look at it now.
1334027
Without XPath, you really can't control XSLT (or other XML technologies) with any kind of
granularity. To draw an analogy, trying to use XSLT without a knowledge of XPath is like trying
to understand databases without knowing Structured Query Language (SQL). Just like SQL, XPath
is a query language, but its syntax is more closely related to file paths .
1334027
For example, if you were working on a UNIX machine and I told you to open up the following file,
you'd know to look in your current working directory:
File.xml
1334027
Imagine I told you to look here:
../File.xml
1334027
In this case, you'd know to look in the directory "above" your current working directory. What if I
gave you this location?
/home/File.xml
Chapter 5. XSLT in Detail
Page 1
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.
Copyright Safari Books Online #672274

1334027
You'd go all the way to the root of your directory hierarchy, and look in the home directory for the
appropriate file. Experienced users know instinctively that some of these file path notations could
point to the same file, or they could point to three completely different files, depending on the
current working directory.
1334027
XPath works in much the same way. You can always grab the root element  of a document using
this expression:
/*
1334027
As in file paths, the slash (/) represents the root of the document structure, and the asterisk (*) is
a wildcard that will match any XML element that occurs at that location. Since XML documents
must have a single root element, this expression will match that one element, whatever it may be.
1334027
XPath also lets you seek out and find all elements with a particular name in the document:
//title
1334027
The double-slash (//) notation  in XPath means "this element or any of its descendants, named…"
When it occurs at the start of the XPath expression, "this element" implicitly refers to the root of
the document. The particular expression shown here will therefore locate any <title> elements
anywhere in the document.
1334027
Rather than looking for elements throughout the document, you could match only certain elements,
depending on their context:
memo/title
1334027
This expression matches <title> elements that are children of a <memo> element that is a child
of the current element. Adding double-slashes in various places can loosen up the requirements of
this expression. For example, memo//title would match <title> elements occurring
anywhere inside <memo>, the memo element, not only its children. //memo/title would match
<title> elements that were children of a <memo> element found anywhere in the document, not
a child of the current element. And for the ultimate in flexibility, //memo//title would match
<title> elements located anywhere inside a <memo> element found anywhere in the document.
1334027
As with file paths, you can use the . and .. notation as well. Predictably, . is shorthand for "the
current node" and ..  is shorthand for "the parent of the current node".
1334027
Chapter 5. XSLT in Detail
Page 2
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

If XPath were just good at retrieving nodes based on paths, that would be terrific. As we first saw
in Chapter 4, XPath also allows us to be more discriminating with our searches . For example, we
may want to retrieve only those elements for which a certain attribute value is set:
title[@priority='hot']
1334027
This expression grabs <title> elements that are children of the current element, but only those
that have a <priority> attribute set to <hot>. The predicate (the portion of the expression in
square brackets) acts as a filter, restricting the results to those that satisfy certain criteria. In this
case, the @ symbol in front of priority indicates that we're referring to an attribute, not an
element name.
1334027
What if you want to retrieve all <title> nodes for which any <priority> attribute value is
set? You'd use this expression:
title[@priority]
1334027
You can use similar notation to find elements that have a certain value. For example, let's say that
in a slightly different schema, we're storing the priority as a text value within a tag, not as an attribute.
If we wanted to retrieve all the <title> elements that have a <priority> element containing
a value of hot, here's how we'd do it:
title[priority='hot']
1334027
Let's continue to mix and match. Here's how you'd pick out all the <date> child elements of
<title> elements anywhere in the document that have a <priority> attribute with a value of
<hot>:
//title[@priority='hot']/date
1334027
XPath also provides selectors that can operate on logical node positions  . For example, to retrieve
the first and last <title> elements of any <memo> elements respectively, you'd use:
memo/title[first()]
memo/title[last()]
1334027
You could also select the first <title> elements of any <memo> elements using an index selector:
memo/title[1]
1334027
This is actually shorthand for the following:
memo/title[position()=1]
Chapter 5. XSLT in Detail
Page 3
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

1334027
In other cases, you might need to select multiple branches within the same document. Here's an
example that shows how you might pick out memo titles and authors at the same time:
memo/title|memo/author
1334027
As you can see, the XPath query language is powerful and flexible—it allows you to retrieve just
about any combination of nodes from an XML document, which can make all the difference when
you're working with XSLT and other XML technologies.
1334027
5.2. Programmatic Aspects of XSLT
661753
In this section, we're going to cover sorting, counting, numbering, conditional processing, and
looping in XSLT. The goal is to give you a solid background in some of the more programmatic
aspects of XSLT. Yes, there is more to XSLT than just displaying stuff in a browser!
1334027
5.2.1. Sorting
672274
Sometimes   , you may want to change the order of the nodes in your XML document. In fact, if
you're using some kind of software process to create a file (such as an inventory readout), it's likely
that the nodes will be output in the same order in which they were written to the file.
1334027
XSLT's <sort> element can be a big help here. It allows you to sort nodes in alphabetical or
numerical order, as well as in ascending (a, b, c) or descending (z, y, x) order.
1334027
Let's take a look at a hypothetical XML file, which contains a list of products in a catalog. As you
can see from the example below, the product listing is not in any discernible order.
1334027
productlisting.xml
<?xml version="1.0" encoding="iso-8859-1"?>
<catalog>
  <product sku="212993">Lamp</product>
  <product sku="488839">Folder</product>
  <product sku="198102">Stapler</product>
  <product sku="91882">Notebook</product>
  <product sku="873638">Inbox</product>
  <product sku="192839">Desk</product>
Chapter 5. XSLT in Detail
Page 4
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

  <product sku="66553">Pen</product>
  <product sku="38289">Calculator</product>
</catalog>
5.2.2.1. Sorting Alphabetically
661753
You can sort this product list in ascending alphabetical order by adding an <xsl:sort> tag as a
child of the <xsl:apply-templates> tag used to select the <product> elements.
1334027
sort.xsl (excerpt)
  <xsl:template match="catalog">
    <h1>Alphabetical List of Products</h1>
    <xsl:apply-templates select="product">
      <xsl:sort/>
    </xsl:apply-templates>
  </xsl:template>
  <xsl:template match="product">
    <p><xsl:apply-templates/></p>
  </xsl:template>
Figure 5-1 shows the file displayed in a Web browser. As you can see, the <product> elements
have been sorted by their contents before being processed by the corresponding template.
1334027
Chapter 5. XSLT in Detail
Page 5
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Figure 5-1. Alphabetical sort of product listing example.
5.2.2.2. Reversing the Sort
661753
What   if you wanted to sort the list in reverse order? Easy! Just add an <order> attribute to the
sort instruction:
1334027
sort-descending.xsl (excerpt)
  <xsl:template match="catalog">
    <h1>Alphabetical List of Products</h1>
    <xsl:apply-templates select="product">
      <xsl:sort order="descending"/>
    </xsl:apply-templates>
  </xsl:template>
The reverse listing is shown in Figure 5-2.
1334027
Chapter 5. XSLT in Detail
Page 6
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Figure 5-2. Reversing the sort on our product listing.
5.2.2.3. Sorting by the Numbers
661753
Now that we have a handle on sorting alphabetically, let's take a look at sorting numerically. What
we want to do is sort the list of products by the value of their <sku> attribute.
1334027
Here's the listing again:
1334027
productlisting.xml
<?xml version="1.0" encoding="iso-8859-1"?>
<catalog>
  <product sku="212993">Lamp</product>
  <product sku="488839">Folder</product>
  <product sku="198102">Stapler</product>
  <product sku="91882">Notebook</product>
  <product sku="873638">Inbox</product>
Chapter 5. XSLT in Detail
Page 7
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

  <product sku="192839">Desk</product>
  <product sku="66553">Pen</product>
  <product sku="38289">Calculator</product>
</catalog>
If we want to sort using the <sku> attribute, we first must add a <data-type> attribute   to the
<sort> element, so that it knows it's sorting numbers and not text values (the default). There are
three valid values for this attribute: text, number, and qname. For now, we'll concentrate on
number, because it will allow us to sort the lists on the numeric SKUs.[1]
1334027
[1] SKU stands for Stock Keeping Unit, which is simply a unique numeric ID for a product for sale.
We also have to tell XSLT what to look at when performing the sort. To do this, we use the
<select> attribute  of the <sort> element.
1334027
sort-sku.xsl (excerpt)
  <xsl:template match="catalog">
    <h1>Product Listing</h1>
    <xsl:apply-templates select="product">
      <xsl:sort select="@sku" data-type="number"/>
    </xsl:apply-templates>
  </xsl:template>
What's happening here is that for each element to be sorted, the <select> attribute of the
<sort> element provides an XPath expression that locates the data to be used in performing the
sort. In this case, @sku points to the <sku> attribute of each <product> element.
1334027
Figure 5-3 shows the results of this XSLT processing.
1334027
What happens if we want to display the SKU as well as the product name? We can simply modify
the template for our <product> elements to output the value using a <value-of> .
1334027
sort-sku-show.xsl (excerpt)
  <xsl:template match="product">
    <p><xsl:value-of select="@sku"/> - <xsl:apply-templates/></p>
  </xsl:template>
Figure 5-4 shows the new display.
1334027
Chapter 5. XSLT in Detail
Page 8
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Figure 5-3. Sorting by numbers.
Chapter 5. XSLT in Detail
Page 9
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Figure 5-4. Sorting by numbers. (Part 2)
5.2.2. Counting
672274
Sorting   the product listing by SKU is good, but it might be nice to provide a total count of products
as well. We can use XPath's count function to print out the number of elements matched by a
particular expression. In the following example, I've added a count of elements to the SKU sort
example:
1334027
sort-count.xsl (excerpt)
  <xsl:template match="catalog">
    <h1>Product Listing</h1>
    <p><em>Total products: <xsl:value-of select="count(product)"/>
      </em></p>
    <xsl:apply-templates select="product">
      <xsl:sort select="@sku" data-type="number"/>
Chapter 5. XSLT in Detail
Page 10
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

    </xsl:apply-templates>
  </xsl:template>
Figure 5-5 shows how this appears in a Web browser.
1334027
Figure 5-5. Counting products.
5.2.3. Numbering
672274
If   you need to add numbered lists to your XSLT output, use the <xsl:number> tag. In this
example, we'll use it to print a number next to each product in the list.
1334027
Let's see the example first. Then, we'll step through it to see how it's done.
1334027
Chapter 5. XSLT in Detail
Page 11
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

number.xsl (excerpt)
  <xsl:template match="catalog">
    <h1>Product Listing</h1>
    <p><em>Total products: <xsl:value-of select="count(product)"/>
      </em></p>
    <xsl:apply-templates select="product"/>
  </xsl:template>
  <xsl:template match="product">
    <p><xsl:number format="1. "/><xsl:apply-templates/>
      (<xsl:value-of select="@sku"/>)</p>
  </xsl:template>
Notice that this style sheet is almost the same as our last one, except that, here, we aren't sorting
the results. Furthermore, in the second template, we've added a <number> element. This tells
XSLT to output a number, based on the <format> attribute, counting up for each element in a
series of nodes matched by this template.
1334027
The <format> attribute lets you create numbering schemes using integers, integers with leading
zeros, upper- and lowercase letters, and upper- and lowercase Roman numerals. Simply supply a
value that indicates how you'd like the first number in the series to look, and XSLT will take it from
there. In this example, the value <1.> indicates that we want an integer number followed by a
period (.) and then a space. In this context, 1 is a special character that tells XSLT that we want it
to write out integers. Table 5-1 provides a summary of these special characters.
1334027
Table 5-1. <format> Attribute Numbering Codes
Code
1334027
Results
1334027
Code
1334027
Results
1334027
1
1334027
1 2 3 4 …
1334027
A
1334027
A B C D E F…
1334027
01
1334027
01 02 03 04 …
1334027
i
1334027
i ii iii iv v …
1334027
a
1334027
a b c d e f …
1334027
I
1334027
I II III IV V …
1334027
By default, the number generated for each element is based on the original position of the node in
the XML file. Thus, if we were to sort our output in any way, the numbers would be mixed up  .
Figure 5-6 shows what happens when we use the <number> element; Figure 5-7 shows what
happens when we sort the data at the same time.
1334027
Chapter 5. XSLT in Detail
Page 12
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Figure 5-6. Numbering your output.
number-position.xsl (excerpt)
  <xsl:template match="catalog">
    <h1>Product Listing</h1>
    <p><em>Total products:
      <xsl:value-of select="count(product)"/></em></p>
    <xsl:apply-templates select="product">
      <xsl:sort/>
    </xsl:apply-templates>
  </xsl:template>
Chapter 5. XSLT in Detail
Page 13
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Figure 5-7. Numbering with a sort.
So, how can you perform a sort and have the numbers appear in the right order—based on the
resulting sort, not the source XML  ? This can be done with the help of the XSLT position function.
The <number>  element supports a <value> attribute with which you can control the number
that is displayed. position gives the position of the current element within the current (sorted) group
of elements, so it's exactly the number we want:
1334027
number-position.xsl (excerpt)
  <xsl:template match="product">
    <p><xsl:number format="1. " value="position()"/>
      <xsl:apply-templates/> (<xsl:value-of select="@sku"/>)</p>
  </xsl:template>
The resulting list is shown in Figure 5-8.
Chapter 5. XSLT in Detail
Page 14
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

1334027
A Complex Affair
Youmay be wondering why numbering and positioning has to be so complicated. You
may ask why you can't just use an HTML ordered list:
1334027
  <xsl:template match="catalog">
    <h1>Product Listing</h1>
    <p><em>Total products: <xsl:value-of select="count(product)"/>
      </em></p>
    <ol>
      <xsl:apply-templates select="product">
        <xsl:sort/>
      </xsl:apply-templates>
    </ol>
  </xsl:template>
  <xsl:template match="product">
    <li><xsl:apply-templates/> (<xsl:value-of select="@sku"/>)</li>
  </xsl:template>
HTML's <ol> tag is a great way to make numbering work, and works regardless of
the sort, since the numbering is performed by the browser. However, something like
that won't help if you're outputting plain text. XSLT numbering provides a more general
solution, which will work even when HTML output isn't an option.
1334027
Chapter 5. XSLT in Detail
Page 15
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Figure 5-8. The right way to sort and number output.
5.2.4. Conditional Processing
672274
Most programming languages allow us to perform some kind of conditional processing. In other
words, they let us test if something is true or false, then perform an appropriate action. Although
it's not a fully-fledged programming language, XSLT does provide basic conditional processing
tools.
1334027
5.2.5.4. <xsl:if>
661753
Continuing with our product listing example, let's imagine that we only want to display those
products whose SKU is greater than 100,000. How would this work in a style sheet?
Chapter 5. XSLT in Detail
Page 16
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

1334027
The answer is to use the <xsl:if> tag. This instruction allows you to set a test, and then do
something based on the results. In the following style sheet, we use this technique to print out those
products that have an SKU above 100,000.
1334027
conditional.xsl (excerpt)
  <xsl:template match="catalog">
    <h1>Product Listing</h1>
    <ol>
      <xsl:apply-templates select="product">
        <xsl:sort/>
      </xsl:apply-templates>
    </ol>
  </xsl:template>
  <xsl:template match="product">
    <xsl:if test="@sku &gt; 100000">
      <li><xsl:apply-templates/>
        (<xsl:value-of select="@sku"/>)</li>
    </xsl:if>
  </xsl:template>
Notice first that we wrap the entire output in an HTML ordered list. Second, notice that we use
<xsl:if> to perform our test in the second <template> block:
1334027
conditional.xsl (excerpt)
    <xsl:if test="@sku &gt; 100000">
Every <if> element must have a corresponding <test> attribute. In this particular case, we're
testing the value of the <sku> attribute (@sku in XPath notation). If it's over 100,000, we print
the product node. &gt;, as you'll know from HTML, is the escaped form of >, the greater-than
symbol.
1334027
Warning: Since      the less-than (<) and greater-than (>) symbols are used to start and end tags in XML,
you must escape these characters when you use them in some other capacity. This includes using them as
operators in XPath expressions.Thus, if you want to perform a "less than" test, you must escape the <
operator as &lt;:If you forget to escape a special character like this, chances are you'll be facing an error
message when you try to process a file using the style sheet.
Figure 5-9 shows how the output displays in a Web browser.
1334027
Chapter 5. XSLT in Detail
Page 17
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Figure 5-9. Conditional processing using <xsl:if>.
5.2.5.5. <xsl:choose>
661753
What's the difference  between <xsl:if> and <xsl:choose>? The <if> element only allows
you to test one condition at a time, whereas a <choose> element can have multiple branches, each
of which responds to a different condition.
1334027
Let's keep working on our product example. In the last section, we used an if element to print out
any product that had an SKU over 100,000. This time, we're going to use <choose> to format the
different products depending on their SKU values.
1334027
conditional2.xsl (excerpt)
  <xsl:template match="product">
    <xsl:choose>
      <xsl:when test="@sku &gt; 100000">
        <li><strong><xsl:apply-templates/>
          (<xsl:value-of select="@sku"/>)</strong></li>
      </xsl:when>
      <xsl:when test="@sku &gt; 50000">
        <li><em><xsl:apply-templates/>
          (<xsl:value-of select="@sku"/>)</em></li>
      </xsl:when>
      <xsl:otherwise>
        <li><xsl:apply-templates/>
          (<xsl:value-of select="@sku"/>)</li>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
Chapter 5. XSLT in Detail
Page 18
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

As you can see, the <xsl:when> tag plays host to a number of <xsl:when> tags, and optionally
a <xsl:otherwise> tag. The <test> attributes of the <when>s are checked in order, and the
first one that is found to be true determines which <when> branch is executed. If none of the
<test>s works out, then the contents of the <optional> branch are processed instead .
1334027
Our two <when> branches in this case are fairly straightforward. In the first branch, we check to
see if the SKU is greater than 100,000. If it is, then we print out the product's name and its SKU in
bold (<strong>). In the second branch, we test to see if the value of the SKU is greater than
50,000. If it is, we display the product's name and SKU in italics (<em>). The <otherwise>
handles any remaining products, displaying them normally.
1334027
Figure 5-10 shows the results.
1334027
Figure 5-10. Conditional processing using xsl:choose.
5.2.5. Looping Through XML Data
672274
With   <xsl:for-each>, you can loop through a set of XML elements, processing each element
as you specify. This looping construct is very useful when you need to repeat a process or function
multiple times, and it can be a great time-saver over writing a template to do the job. In the example
Chapter 5. XSLT in Detail
Page 19
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

below, we'll use <for-each> instead of <apply-templates> to print out the products in our
catalog.
1334027
foreach.xsl (excerpt)
  <xsl:template match="catalog">
    <h1>Product Listing</h1>
    <ol>
      <xsl:for-each select="product">
        <li><xsl:apply-templates/></li>
      </xsl:for-each>
    </ol>
  </xsl:template>
As you can see, the <for-each> loop construct allows us to process XML data quickly, and in
a very concise manner. Although <apply-templates> provide greater flexibility and is
generally easier to maintain and extend, sometimes the simplicity of a <for-each> is exactly
what you need.
1334027
As with templates, you can even add conditional processing to print only the product nodes that
have certain SKUs:
1334027
foreach-conditional.xsl (excerpt)
  <xsl:template match="catalog">
    <h1>Product Listing</h1>
    <ol>
      <xsl:for-each select="product">
        <xsl:if test="@sku &gt; 100000">
          <li><xsl:apply-templates/></li>
        </xsl:if>
      </xsl:for-each>
    </ol>
  </xsl:template>
Another way to achieve this would be to use a predicate in the XPath query in the <for-
each>:
1334027
foreach-conditional2.xsl (excerpt)
  <xsl:template match="catalog">
    <h1>Product Listing</h1>
    <ol>
Chapter 5. XSLT in Detail
Page 20
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

      <xsl:for-each select="product[@sku &gt; 100000]">
        <li><xsl:value-of select="."/></li>
      </xsl:for-each>
    </ol>
  </xsl:template>
Some might argue that this alternative method is more elegant, pithy, and compact, while others
might prefer the programmatic structure of an <if> nested inside the <for-each> loop.
1334027
5.3. Our CMS Project
661753
In  the last chapter, we took a giant leap forward with our CMS, building most of the public pages
we'll need to make our site work. In this chapter, we're going to finish the search engine and start
adding some formatting rules to our documents.
1334027
5.3.1. Finishing our Search Engine
672274
In the last chapter, we created a very simple search widget . This widget contained the following
HTML:
1334027
search.inc.php (excerpt)
<form id="searchWidget" method="post" action="doSearch.php">
  Search Site:
  <input name="term" type="text" id="term" />
  <input name="search" type="submit" id="search" value="Search" />
</form>
What we'll do now is create the doSearch.php file, which will contain the code that implements the
search. When we originally discussed our requirements for the Website, we said: "The search engine
will retrieve content by keywords, titles, and descriptions, and only display those pieces that have
a status of live."
1334027
So let's start working on doSearch.php. The structure of the page is quite similar to the rest of our
site's pages. The heart of the page's code, however, loops through our files looking for the submitted
search string in appropriate places:
1334027
Chapter 5. XSLT in Detail
Page 21
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

doSearch.php (excerpt)
<?php
include_once 'common.inc.php';
$term = $_POST['term'];
?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Search Results</title>
<meta http-equiv="content-type"
    content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="xmlcms.css" type="text/css" />
</head>
<body>
<?php
include 'navtop.inc.php';
?>
<div id="navSide">
  <?php
  include 'search.inc.php';
  include 'news.inc.php';
  ?>
</div>
<div id="mainContent">
  <?php
  $handle = opendir($fileDir);
  $items = array();
  while (($file = readdir($handle)) !== FALSE) {
    if (is_dir($fileDir . $file)) continue;  
    if (!eregi("^(news|article|webcopy).*\.xml$", $file))
      continue;
    $xmlItem = simplexml_load_file($fileDir . $file);
    if ((stripos($xmlItem->keywords, $term) !== FALSE or
        stripos($xmlItem->headline, $term) !== FALSE or
        stripos($xmlItem->description, $term) !== FALSE) and
        (string)$xmlItem->status == 'live') {
      $item = array();
      $item['id'] = (string)$xmlItem['id'];
      $item['headline'] = (string)$xmlItem->headline;
      $items[] = $item;
    }
  }
Though this code is imposing, most of it should be familiar. It simply scans through our xml directory
in search of XML files containing news, articles, and Web copy. It loads every such file using
SimpleXML and checks the <keywords>, <headline>, and <description> elements to
see if they contain the search string ($term). Upon finding a match, we dump information about
the file into an array ($items).
1334027
A few details of note:
1334027
doSearch.php (excerpt)
    if (!eregi("^(news|article|webcopy).*\.xml$", $file))
      continue;
Chapter 5. XSLT in Detail
Page 22
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

This regular expression simply checks that the filename begins with news, article, or
webcopy, and ends with .xml.
1334027
doSearch.php (excerpt)
    if ((stripos($xmlItem->keywords, $term) !== FALSE or
        stripos($xmlItem->headline, $term) !== FALSE or
        stripos($xmlItem->description, $term) !== FALSE) and
        (string)$xmlItem->status == 'live') {
The stripos   function used here is new to PHP 5. It performs a case-insensitive search of its first
argument for the second argument, and returns false if the value was not found. In this case, we're
using it to look for the search term in the various XML element values .
1334027
In the last line, we must cast the value of the <status> element to a string ((string)
$xmlItem->status), in order to compare it with the string 'live', because SimpleXML
actually stores the information as an object. You'll notice we've also cast a couple of other values
(such as $xmlItem['id']) before storing them in variables. Functions like stripos that take
only string values perform this conversion automatically, which is why the values of the
<keywords>, <headline>, and <description> elements are used directly. Casting values
is a fact of life in fully object oriented languages like Java, but in PHP it's a rare necessity.
1334027
We run a test to see if the $items array has a length greater than zero, and print out the appropriate
result: a search results list, or a message stating that no content items were found to match that
search term.
1334027
doSearch.php (excerpt)
  if (count($items) > 0) {
    echo '<h1>Search Results for ' . htmlentities($term) .
      '</h1>';
    echo '<table border="1" cellspacing="0" cellpadding="3"
        width="85%">';
    echo '<tr valign="top"><th>Content Item</th><th>Content Type
        </th></tr>';
    foreach ($items as $item) {
      echo '<tr valign="top"><td><a href="innerpage.php?id=' .
          $item['id'] . '">';
      echo htmlentities($item['headline']) . '</a></td>';
      echo '<td>';
      echo ereg_replace('[0-9]', '', $item['id']);
      echo '</td></tr>';
    }
    echo '</table>';
  } else {
    echo '<h1>Sorry!</h1>';
    echo '<p>No files found with the search term ' .
        htmlentities($term) . '</p>';
  }
  ?>
Chapter 5. XSLT in Detail
Page 23
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

</div>
</body>
</html>
We now have a fast and effective XML-driven search engine for our site, as shown in Figure
5-11.
1334027
Figure 5-11. Our new search engine.
5.3.2. Creating an XSLT-Powered Site Map
672274
A search   engine can certainly help our site visitors get around, but a site map will show them
exactly where specific content is located, and how to get to it.
1334027
In this section, we'll build a PHP- and XSLT-powered site map. This will give us first-hand
experience with the creation of XML files from PHP, the processing of XML with XSLT from
PHP, and the use of dynamic sorting options within XSLT.
1334027
Chapter 5. XSLT in Detail
Page 24
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

5.3.3.1. Generating a Site Map Dynamically
661753
The first thing we need to do is create a PHP script, which will dynamically generate a site map in
memory. It will then process that site map with an XSLT file that we'll create shortly.
1334027
Within our PHP file, we'll use PHP 5's SimpleXML functions to create our XML file. First we'll
create a timestamp  (in the format YYYYMMDDHHMMSS) using PHP's date function, which we
use in the <sitemap> tag at the root of the site map document:
1334027
sitemap.php (excerpt)
<?php
include_once 'common.inc.php';
$timestamp = date('YmdHis');
$xmlstring = '<?xml version="1.0"?>';
$xmlstring .= '<sitemap created="' . $timestamp . '">';
Our next step involves grabbing content from live XML documents in the xml directory. As we did
previously for the site search engine, we'll use SimpleXML to open each file and pull out the values
we need:
1334027
sitemap.php (excerpt)
$handle = opendir($fileDir);
while (($file = readdir($handle)) !== FALSE) {
  if (is_dir($fileDir . $file)) continue;
  if (!eregi("^(news|article|webcopy).*\.xml$", $file)) continue;
  $xmlItem = simplexml_load_file($fileDir . $file);
  if ((string)$xmlItem->status == 'live') {
    $id = (string)$xmlItem['id'];
    $type = ereg_replace('[0-9]', '', $id);
    $created = ereg_replace('[^0-9]', '', $id);
    $xmlstring .= '<content id="' . $id . '">';
    $xmlstring .= '<headline>' .
        htmlspecialchars($xmlItem->headline) . '</headline>';
    $xmlstring .= '<type>' . $type . '</type>';
    $xmlstring .= '<created>' . $date . '</created>';
    $xmlstring .= '</content>';
  }
}
$xmlstring .= '</sitemap>';
You'll note that we have made a new assumption here. The ID of each content item is assumed to
obey a certain format: it will start with the type of content (e.g. news, article, webcopy)—we assume
this in the search engine script as well—and then the item's creation date/time, in the form
Chapter 5. XSLT in Detail
Page 25
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

YYYYMMDDHHMMSS. We'll shortly use this second value, which can be treated as a single
large number, to sort our content items according to their creation date.
1334027
Now that we've generated our site map as an XML string, we'll feed it into SimpleXML using
simplexml_load_string :
1334027
sitemap.php (excerpt)
$xml = simplexml_load_string($xmlstring);
The last thing we'll do in preparation for displaying our site map will be to set a variable that will
determine how the content list will be sorted. For this application, we want the user to be able to
sort on the basis of the headline, creation date, or content type of the items on the site. We'll accept
the user's choice of sort mode as a variable in the query string, with a default of headline sorting:
1334027
sitemap.php (excerpt)
if (isset($_GET['sortby'])) {
  $sortby = $_GET['sortby'];
} else {
  $sortby = 'headline';
}
Now we can apply a style sheet to the information in order to display it in the Web browser. In PHP
5, the XSLT functionality has been separated from the XML functions, which allows you to use
XSLT regardless of the method used to generate the XML data in the first place. This does, however,
mean that you need to make sure that your PHP installation has XSLT support enabled.
1334027
XSLT support in PHP is provided by the optional XSL extension. This extension isn't enabled by
default; so you'll need to compile it in using --with-xsl on Unix-style installations. You'll need to
install libxslt on your server before you can do this. On Windows, the process is a bit easier; you
simply need to add the php_xsl.dll file to your php.ini file on Windows.
1334027
The first thing we need to do is load our style sheet. In PHP, we use the built-in DOMDocument
class to do this. We'll learn more about DOMDocument in later chapters, but for now you just need
to know how to load an XML file with it:
1334027
sitemap.php (excerpt)
$xsl = new DOMDocument;
$xsl->load('xslt/sitemap.xsl');
With this loaded, we can use the style sheet with PHP's XSLTProcessor class:
Chapter 5. XSLT in Detail
Page 26
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

1334027
sitemap.php (excerpt)
$proc = new XSLTProcessor;
$proc->importStyleSheet($xsl);
Next, we pass the $sortby variable to the style sheet as a parameter. We do this with the
xsltprocessor's setParameter method . The first argument has to do with namespaces and is almost
always left blank; the second sets the name of the parameter as it will be used in the style sheet; the
third is the parameter's value. The style sheet will use this parameter to sort the site map according
to the user's preference:
1334027
sitemap.php (excerpt)
$proc->setParameter('', 'SORTBY', $sortby);
Finally, we transform our XML data using the style sheet and send the output to the browser:
1334027
sitemap.php (excerpt)
echo $proc->transformToXML($xml);
?>
With the processing logic in place, all that's left to do is write the style sheet.
1334027
5.3.3.2. Creating the Style Sheet
661753
The style sheet will be very simple. It will transform sitemap.xml into an XHTML display for the
browser, presenting the live content on the site as a list of links. The user will be able to sort the
display by headline, date of creation, and content type.
1334027
In the preamble, we set the output method for XHTML output:
1334027
sitemap.xsl (excerpt)
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns="http://www.w3.org/1999/xhtml">
Chapter 5. XSLT in Detail
Page 27
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

  <xsl:output method="xml" indent="yes" omit-xml-declaration="yes"
      media-type="application/xhtml+xml" encoding="iso-8859-1"
      doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"
      doctype-system=
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"/>
Now we need to declare the SORTBY parameter that our style sheet will accept to indicate how to
sort the headlines in the site map. To do this, we use an XSLT <xsl:param> tag, like this:
1334027
sitemap.xsl (excerpt)
  <xsl:param name="SORTBY">headline</xsl:param>
As you can see, the tag contains the default value of the parameter (to be used in case our script
didn't pass a value for it).
1334027
Next, we write a template for the root of the document that generates the static elements of the page.
In particular, it includes a number of links to allow users to sort the display. These links pass the
query string variable, sortby, that the PHP script expects to receive.
1334027
sitemap.xsl (excerpt)
  <xsl:template match="/">
    <html>
      <head>
        <title>Site Map</title>
        <meta http-equiv="content-type"
            content="application/xhtml+xml; charset=iso-8859-1"/>
      </head>
      <body>
        <h1>Site Map</h1>
        <p>sort: <a href="?sortby=type">type</a> |
          <a href="?sortby=headline">headline</a> |
          <a href="?sortby=date">date</a></p>
        <xsl:apply-templates/>
      </body>
    </html>
  </xsl:template>
The next template matches the <sitemap> element. It uses an XSLT <sort> element to arrange
the list of content according to the user's preference. As we saw in sort-sku.xsl earlier in this chapter,
this element takes an optional <select> attribute that specifies what value to sort on using an
XPath expression. In this case, we use the SORTBY parameter's value (referred to in XSLT as
$SORTBY), which will be passed from the PHP script as either type, headline, or date. In
each case, the style sheet will assign an appropriate value to the <sort> element's <select>
attribute, to instruct the XSL processor to use the corresponding element within each
<content> element to sort the list.
1334027
Chapter 5. XSLT in Detail
Page 28
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

sitemap.xsl (excerpt)
  <xsl:template match="sitemap">
    <ul>
      <xsl:choose>
        <xsl:when test="$SORTBY='type'">
          <xsl:apply-templates>
            <xsl:sort select="type" />
          </xsl:apply-templates>
        </xsl:when>
        <xsl:when test="$SORTBY='date'">
          <xsl:apply-templates>
            <xsl:sort select="created" />
          </xsl:apply-templates>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates>
            <xsl:sort select="headline" />
          </xsl:apply-templates>
        </xsl:otherwise>
      </xsl:choose>
    </ul>
    <p><small>sorting by: <u><xsl:value-of select="$SORTBY"/></u>
      </small></p>
  </xsl:template>
The final template, for the <content> elements, simply prints out a link to innerpage.php using
the <headline> and <type> elements from the dynamically generated XML site map:
1334027
sitemap.xsl (excerpt)
  <xsl:template match="content">
    <li><a href="innerpage.php?id={@id}">
      <xsl:apply-templates select="headline"/></a>
      (<xsl:value-of select="type"/>)</li>
  </xsl:template>
</xsl:stylesheet>
Of particular note here is the way we've included the value of the <id>    attribute in the
<href> attribute of the link. By surrounding it with braces ({}), you can output the value of any
XPath expression in an attribute value, as we've done here.
1334027
That's all there is to it! Now all we have to do is add a link to the sitemap.php file (preferably in
the left navigation area), so your users can view all the live content on the site. The finished site
map should look like Figure 5-12.
1334027
Chapter 5. XSLT in Detail
Page 29
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

Figure 5-12. Our new site map.
5.4. Summary
661753
We learned a great deal more about XSLT in this chapter, and, in the process, we finished up our
search engine and added a site map to the project Website. In the next chapter, we'll learn how to
manipulate XML with JavaScript and DHTML.
1334027
Chapter 5. XSLT in Detail
Page 30
Return to Table of Contents
Chapter 5. XSLT in Detail
No Nonsense XML Web Development With PHP By Thomas Myer ISBN: 097524020X Publisher: SitePoint
Prepared for Matias Eli Sie, Safari ID: el.matia@gmail.com
Print Publication Date: 7/1/2005
User number: 672274 Copyright 2006, Safari Books Online, LLC.
Reproduction, transmission and/or redistribution in any form by any means without the prior written permission from the publisher is prohibited.

