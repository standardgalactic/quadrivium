Notions of computation and monads
Eugenio Moggi∗
Abstract
The λ-calculus is considered an useful mathematical tool in the study of programming
languages, since programs can be identiﬁed with λ-terms. However, if one goes further and
uses βη-conversion to prove equivalence of programs, then a gross simpliﬁcation is introduced
(programs are identiﬁed with total functions from values to values), that may jeopardise the
applicability of theoretical results. In this paper we introduce calculi based on a categorical
semantics for computations, that provide a correct basis for proving equivalence of programs,
for a wide range of notions of computation.
Introduction
This paper is about logics for reasoning about programs, in particular for proving equivalence of
programs. Following a consolidated tradition in theoretical computer science we identify programs
with the closed λ-terms, possibly containing extra constants, corresponding to some features of
the programming language under consideration. There are three semantic-based approaches to
proving equivalence of programs:
• The operational approach starts from an operational semantics, e.g. a partial function
mapping every program (i.e. closed term) to its resulting value (if any), which induces a
congruence relation on open terms called operational equivalence (see e.g. [Plo75]). Then
the problem is to prove that two terms are operationally equivalent.
• The denotational approach gives an interpretation of the (programming) language in a
mathematical structure, the intended model. Then the problem is to prove that two terms
denote the same object in the intended model.
• The logical approach gives a class of possible models for the (programming) language.
Then the problem is to prove that two terms denotes the same object in all possible models.
The operational and denotational approaches give only a theory: the operational equivalence ≈
or the set Th of formulas valid in the intended model respectively. On the other hand, the logical
approach gives a consequence relation ⊢, namely Ax ⊢A iﬀthe formula A is true in all models
of the set of formulas Ax, which can deal with diﬀerent programming languages (e.g. functional,
imperative, non-deterministic) in a rather uniform way, by simply changing the set of axioms
Ax, and possibly extending the language with new constants. Moreover, the relation ⊢is often
semidecidable, so it is possible to give a sound and complete formal system for it, while Th and ≈
are semidecidable only in oversimpliﬁed cases.
We do not take as a starting point for proving equivalence of programs the theory of βη-
conversion, which identiﬁes the denotation of a program (procedure) of type A →B with a
total function from A to B, since this identiﬁcation wipes out completely behaviours like non-
termination, non-determinism or side-eﬀects, that can be exhibited by real programs. Instead, we
proceed as follows:
1. We take category theory as a general theory of functions and develop on top a categorical
semantics of computations based on monads.
∗Research partially supported by EEC Joint Collaboration Contract # ST2J-0374-C(EDB).
1

2. We consider simple formal systems matching the categorical semantics of computation.
3. We extend stepwise categorical semantics and formal system in order to interpret richer
languages, in particular the λ-calculus.
4. We show that w.l.o.g. one may consider only (monads over) toposes, and we exploit this fact
to establish conservative extension results.
The methodology outlined above is inspired by [Sco80]1, and it is followed in [Ros86, Mog86] to
obtain the λp-calculus. The view that “category theory comes, logically, before the λ-calculus”led
us to consider a categorical semantics of computations ﬁrst, rather than to modify directly the
rules of βη-conversion to get a correct calculus.
Related work
The operational approach to ﬁnd correct λ-calculi w.r.t. an operational equivalence, was ﬁrst
considered in [Plo75] for call-by-value and call-by-name operational equivalence. This approach
was later extended, following a similar methodology, to consider other features of computations like
nondeterminism (see [Sha84]), side-eﬀects and continuations (see [FFKD86, FF89]). The calculi
based only on operational considerations, like the λv-calculus, are sound and complete w.r.t. the
operational semantics, i.e. a program M has a value according to the operational semantics iﬀit
is provably equivalent to a value (not necessarily the same) in the calculus, but they are too weak
for proving equivalences of programs.
Previous work on axiom systems for proving equivalence of programs with side eﬀects has
shown the importance of the let-constructor (see [Mas88, MT89a, MT89b]). In the framework of
the computational lambda-calculus the importance of let becomes even more apparent.
The denotational approach may suggest important principles, e.g. ﬁx-point induction (see
[Sco69, GMW79]), that can be found only after developing a semantics based on mathematical
structures rather than term models, but it does not give clear criteria to single out the general
principles among the properties satisﬁed by the model. Moreover, the theory at the heart of De-
notational Semantics, i.e. Domain Theory (see [GS89, Mos89]), has focused on the mathematical
structures for giving semantics to recursive deﬁnitions of types and functions (see [SP82]), while
other structures, that might be relevant to a better understanding of programming languages, have
been overlooked. This paper identify one of such structures, i.e. monads, but probably there are
others just waiting to be discovered.
The categorical semantic of computations presented in this paper has been strongly inﬂuenced
by the reformulation of Denotational Semantics based on the category of cpos, possibly without
bottom, and partial continuous functions (see [Plo85]) and the work on categories of partial mor-
phisms in [Ros86, Mog86].
Our work generalises the categorical account of partiality to other
notions of computations, indeed partial cartesian closed categories turn out to be a special case of
λc-models (see Deﬁnition 3.9).
A type theoretic approach to partial functions and computations is proposed in [CS87, CS88]
by introducing a type-constructor ¯A, whose intuitive meaning is the set of computations of type
A. Our categorical semantics is based on a similar idea. Constable and Smith, however, do not
adequately capture the general axioms for computations (as we do), since their notion of model,
based on an untyped partial applicative structure, accounts only for partial computations.
1
A categorical semantics of computations
The basic idea behind the categorical semantics below is that, in order to interpret a programming
language in a category C, we distinguish the object A of values (of type A) from the object TA of
1“I am trying to ﬁnd out where λ-calculus should come from, and the fact that the notion of a cartesian closed
category is a late developing one (Eilenberg & Kelly (1966)), is not relevant to the argument: I shall try to explain
in my own words in the next section why we should look to it ﬁrst”.
2

computations (of type A), and take as denotations of programs (of type A) the elements of TA.
In particular, we identify the type A with the object of values (of type A) and obtain the object
of computations (of type A) by applying an unary type-constructor T to A. We call T a notion
of computation, since it abstracts away from the type of values computations may produce. There
are many choices for TA corresponding to diﬀerent notions of computations.
Example 1.1 We give few notions of computation in the category of sets.
• partiality TA = A⊥(i.e. A + {⊥}), where ⊥is the diverging computation
• nondeterminism TA = Pfin(A)
• side-eﬀects TA = (A × S)S, where S is a set of states, e.g. a set U L of stores or a set of
input/output sequences U ∗
• exceptions TA = (A + E), where E is the set of exceptions
• continuations TA = R(RA), where R is the set of results
• interactive input TA = (µγ.A + γU), where U is the set of characters.
More explicitly TA is the set of U-branching trees with ﬁnite branches and A-labelled leaves
• interactive output TA = (µγ.A + (U × γ)).
More explicitly TA is (isomorphic to) U ∗× A.
Further examples (in a category of cpos) could be given based on the denotational semantics for
various programming languages (see [Sch86, GS89, Mos89]).
Rather than focusing on a speciﬁc T, we want to ﬁnd the general properties common to all notions
of computation, therefore we impose as only requirement that programs should form a category.
The aim of this section is to convince the reader, with a sequence of informal argumentations, that
such a requirement amounts to say that T is part of a Kleisli triple (T, η, ∗) and that the category
of programs is the Kleisli category for such a triple.
Deﬁnition 1.2 ([Man76]) A Kleisli triple over a category C is a triple (T, η,
∗), where T: Obj(C) →
Obj(C), ηA: A →TA for A ∈Obj(C), f ∗: TA →TB for f: A →TB and the following equations
hold:
• η∗
A = idT A
• ηA; f ∗= f for f: A →TB
• f ∗; g∗= (f; g∗)∗for f: A →TB and g: B →TC.
A Kleisli triple satisﬁes the mono requirement provided ηA is mono for A ∈C.
Intuitively ηA is the inclusion of values into computations (in several cases ηA is indeed a mono) and
f ∗is the extension of a function f from values to computations to a function from computations
to computations, which ﬁrst evaluates a computation and then applies f to the resulting value. In
summary
a: A
ηA
7−→
[a]: TA
a: A
f
7−→
f(a): TB
c: TA
f ∗
7−→
(let x⇐c in f(x)): TB
In order to justify the axioms for a Kleisli triple we have ﬁrst to introduce a category CT whose
morphisms correspond to programs. We proceed by analogy with the categorical semantics for
terms, where types are interpreted by objects and terms of type B with a parameter (free variable)
of type A are interpreted by morphisms from A to B. Since the denotation of programs of type B
are supposed to be elements of TB, programs of type B with a parameter of type A ought to be
3

interpreted by morphisms with codomain TB, but for their domain there are two alternatives, either
A or TA, depending on whether parameters of type A are identiﬁed with values or computations
of type A. We choose the ﬁrst alternative, because it entails the second. Indeed computations
of type A are the same as values of type TA. So we take CT (A, B) to be C(A, TB). It remains
to deﬁne composition and identities in CT (and show that they satisfy the unit and associativity
axioms for categories).
Deﬁnition 1.3 Given a Kleisli triple (T, η, ∗) over C, the Kleisli category CT is deﬁned as
follows:
• the objects of CT are those of C
• the set CT (A, B) of morphisms from A to B in CT is C(A, TB)
• the identity on A in CT is ηA: A →TA
• f ∈CT (A, B) followed by g ∈CT (B, C) in CT is f; g∗: A →TC.
It is natural to take ηA as the identity on A in the category CT , since it maps a parameter x to [x],
i.e. to x viewed as a computation. Similarly composition in CT has a simple explanation in terms
of the intuitive meaning of f ∗, in fact
x: A
f
7−→f(x): TB
y: B
g
7−→g(y): TC
x: A
f;g∗
7−→(let y⇐f(x) in g(y)): TC
i.e. f followed by g in CT with parameter x is the program which ﬁrst evaluates the program
f(x) and then feed the resulting value as parameter to g. At this point we can give also a simple
justiﬁcation for the three axioms of Kleisli triples, namely they are equivalent to the unit and
associativity axioms for CT :
• f; η∗
B = f for f: A →TB
• ηA; f ∗= f for f: A →TB
• (f; g∗); h∗= f; (g; h∗)∗for f: A →TB, g: B →TC and h: C →TD.
Example 1.4 We go through the notions of computation given in Example 1.1 and show that they
are indeed part of suitable Kleisli triples.
• partiality TA = A⊥(= A + {⊥})
ηA is the inclusion of A into A⊥
if f: A →TB, then f ∗(⊥) = ⊥and f ∗(a) = f(a) (when a ∈A)
• nondeterminism TA = Pfin(A)
ηA is the singleton map a 7→{a}
if f: A →TB and c ∈TA, then f ∗(c) = ∪x∈cf(x)
• side-eﬀects TA = (A × S)S
ηA is the map a 7→(λs: S.⟨a, s⟩)
if f: A →TB and c ∈TA, then f ∗(c) = λs: S.(let ⟨a, s′⟩= c(s) in f(a)(s′))
• exceptions TA = (A + E)
ηA is the injection map a 7→inl(a)
if f: A →TB, then f ∗(inr(e)) = e (when e ∈E) and f ∗(inl(a)) = f(a) (when a ∈A)
• continuations TA = R(RA)
ηA is the map a 7→(λk: RA.k(a))
if f: A →TB and c ∈TA, then f ∗(c) = (λk: RB.c(λa: A.f(a)(k)))
4

• interactive input TA = (µγ.A + γU)
ηA maps a to the tree consisting only of one leaf labelled with a
if f: A →TB and c ∈TA, then f ∗(c) is the tree obtained by replacing leaves of c labelled
by a with the tree f(a)
• interactive output TA = (µγ.A + (U × γ))
ηA is the map a 7→⟨ϵ, a⟩
if f: A →TB, then f ∗(⟨s, a⟩) = ⟨s ∗s′, b⟩, where f(a) = ⟨s′, b⟩and s ∗s′ is the concatenation
of s followed by s′.
Kleisli triples are just an alternative description for monads. Although the formers are easy
to justify from a computational perspective, the latters are more widely used in the literature on
Category Theory and have the advantage of being deﬁned only in terms of funtors and natural
transformations, which make them more suitable for abstract manipulation.
Deﬁnition 1.5 ([Mac71]) A monad over a category C is a triple (T, η, µ), where T: C →C is
a functor, η: IdC
.→T and µ: T 2
.→T are natural transformations and the following diagrams
commute:
T 3A
µT A > T 2A
TA
ηT A > T 2A <
TηA
TA
TµA
∨
∨
µA
@@@ idT A
@@@
R ∨
µA
	
    idT A
   T 2A
µA
> TA
TA
Proposition 1.6 ([Man76]) There is a one-one correspondence between Kleisli triples and mon-
ads.
Proof Given a Kleisli triple (T, η, ∗), the corresponding monad is (T, η, µ), where T is the extension
of the function T to an endofunctor by taking T(f) = (f; ηB)∗for f: A →B and µA = id∗
T A.
Conversely, given a monad (T, η, µ), the corresponding Kleisli triple is (T, η, ∗), where T is the
restriction of the functor T to objects and f ∗= (Tf); µB for f: A →TB.
Remark 1.7 In general the categorical semantics of partial maps, based on a category C equipped
with a dominion M (see [Ros86]), cannot be reformulated in terms of a Kleisli triple over C
satisfying some additional properties, unless C has lifting, i.e. the inclusion functor from C into the
category of partial maps P(C, M) has a right adjoint
⊥characterised by the natural isomorphism
C(A, B⊥)
·∼= P(C, M)(A, B)
This mismatch disappears when considering partial cartesian closed categories.
2
Simple languages for monads
In this section we consider two formal systems motivated by diﬀerent objectives: reasoning about
programming languages and reasoning about programs in a ﬁxed programming language. When
reasoning about programming languages one has diﬀerent monads (for simplicity we assume that
they are over the same category), one for each programming language, and the main aim is to
study how they relate to each other. So it is natural to base a formal system on a metalanguage
for a category and treat monads as unary type-constructors. When reasoning about programs one
has only one monad, because the programming language is ﬁxed, and the main aim is to prove
properties of programs. In this case the obvious choice for the term language is the programming
language itself, which is more naturally interpreted in the Kleisli category.
5

Remark 2.1 We regard the metalanguage as more fundamental.
In fact, its models are more
general, as they don’t have to satisfy the mono requirement, and the interpretation of programs (of
some given programming language) can be deﬁned simply by translation into (a suitable extension
of) the metalanguage. It should be pointed out that the mono requirement cannot be axiomatised
in the metalanguage, as we would need conditional equations [x]T = [y]T →x = y, and that
existence assertions cannot be translated into formulas of the metalanguage, as we would need
existentially quantiﬁed formulas (e ↓σ)◦≡(∃!x: σ.e◦= [x]T )2.
In Section 2.3 we will explain once for all the correspondence between theories of a simple
programming language and categories with a monad satisfying the mono requirement. For other
programming languages we will give only their translation in a suitable extension of the metalan-
guage. In this way, issues like call-by-value versus call-by-name aﬀect the translation, but not the
metalanguage.
In Categorical Logic it is common practice to identify a theory T with a category F(T ) with
additional structure such that there is a one-one correspondence between models of T in a category
C with additional structure and structure preserving functors from F(T ) to C (see [KR77])3. This
identiﬁcation was originally proposed by Lawvere, who also showed that algebraic theories can be
viewed as categories with ﬁnite products.
In Section 2.2 we give a class of theories that can be viewed as categories with a monad, so that
any category with a monad is, up to equivalence (of categories with a monad), one of such theories.
Such a reformulation in terms of theories is more suitable for formal manipulation and more
appealing to those unfamiliar with Category Theory. However, there are other advantages in having
an alternative presentation of monads. For instance, natural extensions of the syntax may suggest
extensions of the categorical structure that may not be immediate to motivate and justify otherwise
(we will exploit this in Section 3). In Section 2.3 we take a programming language perspective
and establish a correspondence between theories (with equivalence and existence assertions) for a
simple programming language and categories with a monad satisfying the mono requirement, i.e.
ηA mono for every A.
As starting point we take many sorted monadic equational logic, because it is more primitive
than many sorted equational logic, indeed monadic theories are equivalent to categories without
any additional structure.
2.1
Many sorted monadic equational logic
The language and formal system of many sorted monadic equational logic are parametric in a
signature, i.e. a set of base types A and unary function symbols f: A1 →A2. The language is made
of types ⊢A type, terms x: A1 ⊢e: A2 and equations x: A1 ⊢e1 =A2 e2 deﬁned by the following
formation rules:
A ⊢A type A base type
var
⊢A type
x: A ⊢x: A
f
x: A ⊢e1: A1
x: A ⊢f(e1): A2
f: A1 →A2
eq x: A1 ⊢e1: A2
x: A1 ⊢e2: A2
x: A1 ⊢e1 =A2 e2
2The uniqueness of x s.t. e◦= [x]T follows from the mono requirement.
3In [LS86] a stronger relation is sought between theories and categories with additional structure, namely an
equivalence between the category of theories and translations and the category of small categories with additional
structure and structure preserving functors.
In the case of typed λ-calculus, for instance, such an equivalence
between λ-theories and cartesian closed categories requires a modiﬁcation in the deﬁnition of λ-theory, which allows
not only equations between λ-terms but also equations between type expressions.
6

RULE
SYNTAX
SEMANTICS
A
⊢A type
=
[[A]]
var
⊢A type
=
c
x: A ⊢x: A
=
idc
f: A1 →A2
x: A ⊢e1: A1
=
g
x: A ⊢f(e1): A2
=
g; [[f]]
eq
x: A1 ⊢e1: A2
=
g1
x: A1 ⊢e2: A2
=
g2
x: A1 ⊢e1 =A2 e2
⇐⇒
g1 = g2
Table 1: Interpretation of Many Sorted Monadic Equational Language
Remark 2.2 Terms of (many sorted) monadic equational logic have exactly one free variable (the
one declared in the context) which occurs exactly once, and equations are between terms with the
same free variable.
An interpretation [[ ]] of the language in a category C is parametric in an interpretation of the
symbols in the signature and is deﬁned by induction on the derivation of well-formedness for
(types,) terms and equations (see Table 1) according to the following general pattern:
• the interpretation [[A]] of a base type A is an object of C
• the interpretation [[f]] of an unary function f: A1 →A2 is a morphism from [[A1]] to [[A2]] in
C; similarly for the interpretation of a term x: A1 ⊢e: A2
• the interpretation of an assertion x: A ⊢φ (in this case just an equation) is either true or
false.
Remark 2.3 The interpretation of equations is standard. However, if one want to consider more
complex assertions, e.g. formulas of ﬁrst order logic, then they should be interpreted by subobjects;
in particular equality
= : A should be interpreted by the diagonal ∆[[A]].
The formal consequence relation on the set of equations is generated by the inference rules for
equivalences ((reﬂ), (simm) and (trans)), congruence and substitutivity (see Table 2). This formal
consequence relation is sound and complete w.r.t. interpretation of the language in categories, i.e.
an equation is formally derivable from a set of equational axioms if and only if all the interpretations
satisfying the axioms satisfy the equation. Soundness follows from the admissibility of the inference
rules in any interpretation, while completeness follows from the fact that any theory T (i.e. a set
of equations closed w.r.t. the inference rules) is the set of equations satisﬁed by the canonical
interpretation in the category F(T ), i.e. T viewed as a category.
Deﬁnition 2.4 Given a monadic equational theory T , the category F(T ) is deﬁned as follows:
• objects are (base) types A,
• morphisms from A1 to A2 are equivalence classes [x: A1 ⊢e: A2]T of terms w.r.t. the equiv-
alence relation induced by the theory T , i.e.
(x: A1 ⊢e1: A2) ≡(x: A1 ⊢e2: A2) ⇐⇒(x: A1 ⊢e1 =A2 e2) ∈T
7

reﬂ
x: A ⊢e: A1
x: A ⊢e =A1 e
symm x: A ⊢e1 =A1 e2
x: A ⊢e2 =A1 e1
trans x: A ⊢e1 =A1 e2
x: A ⊢e2 =A1 e3
x: A ⊢e2 =A1 e3
congr
x: A ⊢e1 =A1 e2
x: A ⊢f(e1) =A2 f(e2) f: A1 →A2
subst x: A ⊢e: A1
x: A1 ⊢φ
x: A ⊢[e/x]φ
Table 2: Inference Rules of Many Sorted Monadic Equational Logic
• composition is substitution, i.e.
[x: A1 ⊢e1: A2]T ; [x: A2 ⊢e2: A3]T = [x: A1 ⊢[e1/x]e2: A3]T
• identity over A is [x: A ⊢x: A]T .
There is also a correspondence in the opposite direction, namely every category C (with additional
structure) can be viewed as a theory TC (i.e. the theory of C over the language for C), so that C and
F(TC) are equivalent as categories (with additional structure). Actually, in the case of monadic
equational theories and categories, C and F(TC) are isomorphic.
In the sequel we consider other equational theories. They can be viewed as categories in the
same way described above for monadic theories; moreover, these categories are equipped with
additional structure, depending on the speciﬁc nature of the theories under consideration.
2.2
The Simple metalanguage
We extend many sorted monadic equational logic to match categories equipped with a monad (or
equivalently a Kleisli triple). Although we consider only one monad, it is conceptually straightfor-
ward to have several monads at once.
The ﬁrst step is to extend the language. This could be done in several ways without aﬀecting
the correspondence between theories and monads, we choose a presentation inspired by Kleisli
triples, more speciﬁcally we introduce an unary type-constructor T and the two term-constructors,
[ ] and let, used informally in Section 1. The deﬁnition of signature is slightly modiﬁed, since the
domain and codomain of an unary function symbol f: τ1 →τ2 can be any type, not just base types
(the fact is that in many sorted monadic logic the only types are base types). An interpretation
[[ ]] of the language in a category C with a Kleisli triple (T, η, ∗) is parametric in an interpretation
of the symbols in the signature and is deﬁned by induction on the derivation of well-formedness
for types, terms and equations (see Table 3). Finally we add to many sorted monadic equational
logic appropriate inference rules capturing axiomatically the properties of the new type- and term-
constructors after interpretation (see Table 4).
Proposition 2.5 Every theory T of the simple metalanguage, viewed as a category F(T ), is
equipped with a Kleisli triple (T, η, ∗):
• T(τ) = Tτ,
• ητ = [x: τ ⊢ml [x]T : Tτ]T ,
• ([x: τ1 ⊢ml e: Tτ2]T )∗= [x′: Tτ1 ⊢ml (letT x⇐x′ in e): Tτ2]T .
8

RULE
SYNTAX
SEMANTICS
A
⊢ml A type
=
[[A]]
T
⊢ml τ type
=
c
⊢ml Tτ type
=
Tc
var
⊢ml τ type
=
c
x: τ ⊢ml x: τ
=
idc
f: τ1 →τ2
x: τ ⊢ml e1: τ1
=
g
x: τ ⊢ml f(e1): τ2
=
g; [[f]]
[ ]T
x: τ ⊢ml e: τ ′
=
g
x: τ ⊢ml [e]T : Tτ ′
=
g; η[[τ ′]]
let
x: τ ⊢ml e1: Tτ1
=
g1
x1: τ1 ⊢ml e2: Tτ2
=
g2
x: τ ⊢ml (letT x1⇐e1 in e2): Tτ2
=
g1; g∗
2
eq
x: τ1 ⊢ml e1: τ2
=
g1
x: τ1 ⊢ml e2: τ2
=
g2
x: τ1 ⊢ml e1 =τ2 e2
⇐⇒
g1 = g2
Table 3: Interpretation of the Simple Metalanguage
[ ].ξ
x: τ ⊢ml e1 =τ1 e2
x: τ ⊢ml [e1]T =T τ1 [e2]T
let.ξ
x: τ ⊢ml e1 =T τ1 e2
x′: τ1 ⊢ml e′
1 =T τ2 e′
2
x: τ ⊢ml (letT x′⇐e1 in e′
1) =T τ2 (letT x′⇐e2 in e′
2)
ass
x: τ ⊢ml e1: Tτ1
x1: τ1 ⊢ml e2: Tτ2
x2: τ2 ⊢ml e3: Tτ3
x: τ ⊢ml (letT x2⇐(letT x1⇐e1 in e2) in e3) =T τ3 (letT x1⇐e1 in (letT x2⇐e2 in e3))
T.β
x: τ ⊢ml e1: τ1
x1: τ1 ⊢ml e2: Tτ2
x: τ ⊢ml (letT x1⇐[e1]T in e2) =T τ2 [e1/x1]e2
T.η
x: τ ⊢ml e1: Tτ1
x: τ ⊢ml (letT x1⇐e1 in [x1]T ) =T τ1 e1
Table 4: Inference Rules of the Simple Metalanguage
9

Proof We have to show that the three axioms for Kleisli triples are valid. The validity of each
axiom amounts to the derivability of an equation.
For instance, η∗
τ = idT τ is valid provided
x′: Tτ ⊢ml (letT x⇐x′ in [x]T ) =T τ x′ is derivable, indeed it follows from (T.η). The reader can
check that the equations corresponding to the axioms ητ; f ∗= f and f ∗; g∗= (f; g∗)∗follow from
(T.β) and (ass) respectively.
2.3
A Simple Programming Language
In this section we take a programming language perspective by introducing a simple programming
language, whose terms are interpreted by morphisms of the Kleisli category for a monad. Unlike
the metalanguage of Section 2.2, the programming language does not allow to consider more than
one monad at once.
The interpretation in the Kleisli category can also be given indirectly via a translation in the
simple metalanguage of Section 2.2 mapping programs of type τ into terms of type Tτ. If we try to
establish a correspondence between equational theories of the simple programming language and
categories with one monad (as done for the metalanguage), then we run into problems, since there
is no way (in general) to recover C from CT . What we do instead is to establish a correspondence
between theories with equivalence and existence assertions and categories with one monad satisfying
the mono requirement, i.e. ηA is mono for every object A (note that ηT A is always a mono, because
ηT A; µA = idT A). The intended extension of the existence predicate on computations of type A is
the set of computations of the form [v] for some value v of type A, so it is natural to require ηA to
be mono and interpret the existence predicate as the subobject corresponding to ηA.
The simple programming language is parametric in a signature, i.e. a set of base types and
unary command symbols. To stress that the interpretation is in CT rather than C, we use unary
command symbols p: τ1 ⇀τ2 (instead of unary function symbols f: τ1 →τ2), we call x: τ1 ⊢pl e: τ2
a program (instead of a term) and write
≡τ
(instead of
=T τ
) as equality of computations
of type τ. Given a category C with a Kleisli triple (T, η, ∗) satisfying the mono requirement, an
interpretation [[ ]] of the programming language is parametric in an interpretation of the symbols
in the signature and is deﬁned by induction on the derivation of well-formedness for types, terms
and equations (see Table 5) following the same pattern given for many sorted monadic equational
logic, but with C replaced by CT , namely:
• the interpretation [[τ]] of a (base) type τ is an object of CT , or equivalently an object of C
• the interpretation [[p]] of an unary command p: τ1 ⇀τ2 is a morphism from [[τ1]] to [[τ2]] in
CT , or equivalently a morphism from [[τ1]] to T[[τ2]] in C; similarly for the interpretation of a
program x: τ1 ⊢pl e: τ2
• the interpretation of an equivalence or existence assertion is a truth value.
Remark 2.6 The let-constructor play a fundamental role: operationally it corresponds to sequen-
tial evaluation of programs and categorically it corresponds to composition in the Kleisli category
CT (while substitution corresponds to composition in C). In the λv-calculus (let x⇐e in e′) is treated
as syntactic sugar for (λx.e′)e. We think that this is not the right way to proceed, because it ex-
plains the let-constructor (i.e. sequential evaluation of programs) in terms of constructors available
only in functional languages. On the other hand, (let x⇐e in e′) cannot be treated as syntactic
sugar for [e/x]e′ (involving only the more primitive substitution) without collapsing computations
to values.
The existence predicate e ↓is inspired by the logic of partial terms/elements (see [Fou77, Sco79,
Mog88]); however, there are important diﬀerences, e.g.
strict x: τ ⊢pl p(e) ↓τ2
x: τ ⊢pl e ↓τ1
p: τ1 ⇀τ2
is admissible for partial computations, but not in general. For certain notions of computation there
may be other predicates on computations worth considering, or the existence predicate itself may
have a more specialised meaning, for instance:
10

RULE
SYNTAX
SEMANTICS
A
⊢pl A type
=
[[A]]
T
⊢pl τ type
=
c
⊢pl Tτ type
=
Tc
var
⊢pl τ type
=
c
x: τ ⊢pl x: τ
=
ηc
p: τ1 ⇀τ2
x: τ ⊢pl e1: τ1
=
g
x: τ ⊢pl p(e1): τ2
=
g; [[p]]∗
[ ]
x: τ ⊢pl e: τ ′
=
g
x: τ ⊢pl [e]: Tτ ′
=
g; ηT [[τ ′]]
µ
x: τ ⊢pl e: Tτ ′
=
g
x: τ ⊢pl µ(e): τ ′
=
g; µ[[τ ′]]
let
x: τ ⊢pl e1: τ1
=
g1
x1: τ1 ⊢pl e2: τ2
=
g2
x: τ ⊢pl (let x1⇐e1 in e2): τ2
=
g1; g2∗
eq
x: τ1 ⊢pl e1: τ2
=
g1
x: τ1 ⊢pl e2: τ2
=
g2
x: τ1 ⊢pl e1 ≡τ2 e2
⇐⇒
g1 = g2
ex
x: τ1 ⊢pl e: τ2
=
g
x: τ1 ⊢pl e ↓τ2
⇐⇒
∃!h: [[τ1]] →[[τ2]] s.t. g = h; η[[τ2]]
Table 5: Interpretation of the Simple Programming Language
11

reﬂ
x: τ ⊢pl e: τ1
x: τ ⊢pl e ≡τ1 e
symm x: τ ⊢pl e1 ≡τ1 e2
x: τ ⊢pl e2 ≡τ1 e1
trans x: τ ⊢pl e1 ≡τ1 e2
x: τ ⊢pl e2 ≡τ1 e3
x: τ ⊢pl e2 ≡τ1 e3
congr
x: τ ⊢pl e1 ≡τ1 e2
x: τ ⊢pl p(e1) ≡τ2 p(e2) p: τ1 ⇀τ2
E.x
⊢pl τ type
x: τ ⊢pl x ↓τ
E.congr x: τ ⊢pl e1 ≡τ1 e2
x: τ ⊢pl e1 ↓τ1
x: τ ⊢pl e2 ↓τ1
subst x: τ ⊢pl e ↓τ1
x: τ1 ⊢pl φ
x: τ ⊢pl [e/x]φ
Table 6: General Inference Rules
• a partial computation exists iﬀit terminates;
• a non-deterministic computation exists iﬀit gives exactly one result;
• a computation with side-eﬀects exists iﬀit does not change the store.
Programs can be translated into terms of the metalanguage via a translation
◦s.t. for every well-
formed program x: τ1 ⊢pl e: τ2 the term x: τ1 ⊢ml e◦: Tτ2 is well-formed and [[x: τ1 ⊢pl e: τ2]] =
[[x: τ1 ⊢ml e◦: Tτ2]] (the proof of these properties is left to the reader).
Deﬁnition 2.7 Given a signature Σ for the programming language, let Σ◦be the signature for the
metalanguage with the same base types and a function p: τ1 →Tτ2 for each command p: τ1 ⇀τ2
in Σ. The translation
◦from programs over Σ to terms over Σ◦is deﬁned by induction on raw
programs:
• x◦∆≡[x]T
• (let x1⇐e1 in e2)◦∆≡(letT x1⇐e1◦in e2◦)
• p(e1)◦∆≡(letT x⇐e1◦in p(x))
• [e]◦∆≡[e◦]T
• µ(e)◦∆≡(letT x⇐e◦in x)
The inference rules for deriving equivalence and existence assertions of the simple programming
language can be partitioned as follows:
• general rules (see Table 6) for terms denoting computations, but with variables ranging over
values; these rules replace those of Table 2 for many sorted monadic equational logic
• rules capturing the properties of type- and term-constructors (see Table 7) after interpretation
of the programming language; these rules replace the additional rules for the metalanguage
given in Table 4.
12

[ ].ξ
x: τ ⊢pl e1 ≡τ1 e2
x: τ ⊢pl [e1] ≡T τ1 [e2]
E.[ ]
x: τ ⊢pl e1: τ1
x: τ ⊢pl [e1] ↓T τ1
µ.ξ
x: τ ⊢pl e1 ≡T τ1 e2
x: τ ⊢pl µ(e1) ≡τ1 µ(e2)
µ.β
x: τ ⊢pl e1: τ1
x: τ ⊢µ([e1]) ≡τ1 e1
µ.η
x: τ ⊢pl e1 ↓T τ1
x: τ ⊢[µ(e1)] ≡T τ1 e1
let.ξ
x: τ ⊢pl e1 ≡τ1 e2
x′: τ1 ⊢pl e′
1 ≡τ2 e′
2
x: τ ⊢pl (let x′⇐e1 in e′
1) ≡τ2 (let x′⇐e2 in e′
2)
unit
x: τ ⊢pl e1: τ1
x: τ ⊢pl (let x1⇐e1 in x1) ≡τ1 e1
ass
x: τ ⊢pl e1: τ1
x1: τ1 ⊢pl e2: τ2
x2: τ2 ⊢pl e3: τ3
x: τ ⊢pl (let x2⇐(let x1⇐e1 in e2) in e3) ≡τ3 (let x1⇐e1 in (let x2⇐e2 in e3))
let.β
x: τ ⊢pl e1 ↓τ1
x1: τ1 ⊢pl e2: τ2
x: τ ⊢pl (let x1⇐e1 in e2) ≡τ2 [e1/x1]e2
let.p
x: τ ⊢pl e1: τ1
x: τ ⊢pl p(e1) ≡τ1 (let x1⇐e1 in p(x1)) p: τ1 ⇀τ2
Table 7: Inference Rules of the Simple Programming Language
13

Soundness and completeness of the formal consequence relation w.r.t. interpretation of the
simple programming language in categories with a monad satisfying the mono requirement is
established in the usual way (see Section 2.1). The only step which diﬀers is how to view a theory
T of the simple programming language (i.e. a set of equivalence and existence assertions closed
w.r.t. the inference rules) as a category F(T ) with the required structure.
Deﬁnition 2.8 Given a theory T of the simple programming language, the category F(T ) is de-
ﬁned as follows:
• objects are types τ,
• morphisms from τ1 to τ2 are equivalence classes [x: τ1 ⊢pl e: τ2]T of existing programs x: τ1 ⊢pl
e ↓τ2∈T w.r.t. the equivalence relation induced by the theory T , i.e.
(x: τ1 ⊢pl e1: τ2) ≡(x: τ1 ⊢pl e2: τ2) ⇐⇒(x: τ1 ⊢pl e1 ≡τ2 e2) ∈T
• composition is substitution, i.e.
[x: τ1 ⊢pl e1: τ2]T ; [x: τ2 ⊢pl e2: τ3]T = [x: τ1 ⊢pl [e1/x]e2: τ3]T
• identity over τ is [x: τ ⊢pl x: τ]T .
In order for composition in F(T ) to be well-deﬁned, it is essential to consider only equivalence
classes of existing programs, since the simple programming language satisﬁes only a restricted form
of substitutivity.
Proposition 2.9 Every theory T of the simple programming language, viewed as a category F(T ),
is equipped with a Kleisli triple (T, η, ∗) satisfying the mono requirement:
• T(τ) = Tτ,
• ητ = [x: τ ⊢pl [x]: Tτ]T ,
• ([x: τ1 ⊢pl e: Tτ2]T )∗= [x′: Tτ1 ⊢pl [(let x⇐µ(x′) in µ(e))]: Tτ2]T .
Proof We have to show that the three axioms for Kleisli triples are valid. The validity of each axiom
amounts to the derivability of an existence and equivalence assertion. For instance, η∗
τ = idT τ is
valid provided x′: Tτ ⊢pl x′ ↓T τ and x′: Tτ ⊢pl [(let x⇐µ(x′) in µ([x]))] ≡T τ x′ are derivable. The
existence assertion follows immediately from (E.x), while the equivalence is derived as follows:
• x′: Tτ ⊢pl [(let x⇐µ(x′) in µ([x]))] ≡T τ [(let x⇐µ(x′) in x)]
by (µ.β), (reﬂ) and (let.ξ)
• x′: Tτ ⊢pl [(let x⇐µ(x′) in x)] ≡T τ [µ(x′)]
by (unit) and (let.ξ)
• x′: Tτ ⊢pl [µ(x′)] ≡T τ x′
by (E.x) and (µ.η)
• x′: Tτ ⊢pl [(let x⇐µ(x′) in µ([x]))] ≡T τ x′
by (trans).
We leave to the reader the derivation of the existence and equivalence assertions corresponding
to the other axioms for Kleisli triples, and prove instead the mono requirement i.e. that f1; ητ =
f2; ητ implies f1 = f2.
Let fi be [x: τ ′ ⊢pl ei: τ]T , we have to derive x: τ ′ ⊢pl e1 ≡τ e2 from
x: τ ′ ⊢pl [e1] ≡T τ [e2] (and x: τ ′ ⊢pl ei ↓τ) :
• x: τ ′ ⊢pl µ([e1]) ≡τ µ([e2])
by the ﬁrst assumption and (µ.ξ)
• x: τ ′ ⊢pl µ([ei]) ≡τ ei
by (µ.β)
• x: τ ′ ⊢pl e1 ≡τ e2
by (trans).
14

Remark 2.10 One can show that the canonical interpretation of a program x: τ1 ⊢pl e: τ2 in the
category F(T ) is the morphism [x: τ1 ⊢pl [e]: Tτ2]T .
This interpretation establishes a one-one
correspondence between morphisms from τ1 to Tτ2 in the category F(T ), i.e. morphisms from τ1
to τ2 in the Kleisli category, and equivalence classes of programs x: τ1 ⊢pl e: τ2 (not necessarely
existing). The inverse correspondence maps a morphism [x: τ1 ⊢pl e′: Tτ2]T to the equivalence class
of x: τ1 ⊢pl µ(e′): τ2. Indeed, x: τ1 ⊢pl e ≡τ2 µ([e]) and x: τ1 ⊢pl e′ ≡τ2 [µ(e′)] are derivable provided
x: τ1 ⊢pl e′ ↓T τ2.
3
Extending the simple metalanguage
So far we have considered only languages and formal systems for monadic terms x: τ1 ⊢e: τ2, having
exactly one free variable (occurring once). In this section we want to extend these languages (and
formal systems) by allowing algebraic terms x1: τ1, . . . , xn: τn ⊢e: τ, having a ﬁnite number of free
variables (occurring ﬁnitely many times) and investigate how this aﬀects the interpretation and
the structure on theories viewed as categories. For convenience in relating theories and categories
with additional structure, we also allow types to be closed w.r.t. ﬁnite products4, in particular
a typing context x1: τ1, . . . , xn: τn can be identiﬁed with a type. In general, the interpretation of
an algebraic term x1: τ1, . . . , xn: τn ⊢e: τ in a category (with ﬁnite products) is a morphism from
([[τ1]] × . . . × [[τn]]) to [[τ]].
The extension of monadic equational logic to algebraic terms is equational logic, whose theories
correspond to categories with ﬁnite products. We will introduce the metalanguage, i.e. the ex-
tension of the simple metalanguage described in Section 2.2 to algebraic terms, and show that its
theories correspond to categories with ﬁnite products and a strong monad, i.e. a monad and a natu-
ral transformation tA,B: A×TB →T(A×B). Intuitively tA,B transforms a pair value-computation
into a computation of a pair of values, as follows
a: A, c: TB
tA,B
7−→
(let y⇐c in [⟨a, y⟩]): T(A × B)
Remark 3.1 To understand why a category with ﬁnite products and a monad is not enough to
interpret the metalanguage (and where the natural transformation t is needed), one has to look at
the interpretation of a let-expression
let Γ ⊢ml e1: Tτ1
Γ, x: τ1 ⊢ml e2: Tτ2
Γ ⊢ml (letT x⇐e1 in e2): Tτ2
where Γ is a typing context. Let g1: c →Tc1 and g2: c × c1 →Tc2 be the interpretations of Γ ⊢ml
e1: Tτ1 and Γ, x: τ1 ⊢ml e2: Tτ2 respectively, where c is the interpretation of the typing context Γ
and ci is the interpretation of the type τi, then the interpretation of Γ ⊢ml (letT x⇐e1 in e2): Tτ2
ought to be a morphism g: c →Tc2.
If (T, η, µ) is the identity monad, i.e. T is the identity
functor over C and η and µ are the identity natural transformation over T, then computations get
identiﬁed with values. In this case (letT x⇐e1 in e2) can be replaced by [e1/x]e2, so g is simply
⟨idc, g1⟩; g2: c →c2. In the general case Table 3 suggests that ;
above is indeed composition in
the Kleisli category, therefore ⟨idc, g1⟩; g2 should be replaced by ⟨idc, g1⟩; g2∗. But in ⟨idc, g1⟩; g2∗
there is a type mismatch, since the codomain of ⟨idc, g1⟩is c × Tc1, while the domain of Tg1 is
T(c × c1). The natural transformation tA,B: A × TB →T(A × B) mediates between these two
objects, so that g can be deﬁned as ⟨idc, g1⟩; tc,c1; g2∗.
4If the metalanguage does not have ﬁnite products, we conjecture that its theories would no longer correspond to
categories with ﬁnite products and a strong monad (even by taking as objects contexts and/or the Karoubi envelope,
used in [Sco80] to associate a cartesian closed category to an untyped λ-theory), but instead to multicategories with
a Kleisli triple. We felt the greater generality (of not having products in the metalanguage) was not worth the
mathematical complications.
15

Deﬁnition 3.2 A strong monad over a category C with (explicitly given) ﬁnite products is a
monad (T, η, µ) together with a natural transformation tA,B from A × TB to T(A × B) s.t.
TA
∧
rT A
I
@@@
TrA @@@
1 × TA
t1,A> T(1 × A)
(A × B) × TC
tA×B,C
> T((A × B) × C)
αA,B,T C
∨
@@@
TαA,B,C @@@
R
A × (B × TC)
idA × tB,C > A × T(B × C)
tA,B×C> T(A × (B × C))
A × B
idA × ηB
∨
@@@
ηA×B @@@
R
A × TB
tA,B > T(A × B)
∧
idA × µB
I
@@@
µA×B @@@
A × T 2B
tA,T B> T(A × TB)
TtA,B> T 2(A × B)
where r and α are the natural isomorphisms
rA: (1 × A) →A
,
αA,B,C: (A × B) × C →A × (B × C)
Remark 3.3 The diagrams above are taken from [Koc72], where a characterisation of strong mon-
ads is given in terms of C-enriched categories (see [Kel82]). Kock ﬁxes a commutative monoidal
closed category C (in particular a cartesian closed category), and in this setup he establishes a
one-one correspondence between strengths stA,B: BA →(TB)T A and tensorial strengths tA,B: A ⊗
TB →T(A ⊗B) for a endofunctor T over C (see Theorem 1.3 in [Koc72]). Intuitively a strength
stA,B internalises the action of T on morphisms from A to B, and more precisely it makes (T, st)
a C-enriched endofunctor on C enriched over itself (i.e. the hom-object C(A, B) is BA). In this
setting the diagrams of Deﬁnition 3.2 have the following meaning:
• the ﬁrst two diagrams are (1.7) and (1.8) in [Koc72], saying that t is a tensorial strength of
T. So T can be made into a C-enriched endofunctor.
• the last two diagrams say that η: IdC
.→T and µ: T 2
.→T are C-enriched natural transfor-
mations, where IdC, T and T 2 are enriched in the obvious way (see Remark 1.4 in [Koc72]).
There is another purely categorical characterisation of strong monads, suggested to us by G.
Plotkin, in terms of C-indexed categories (see [JP78]). Both characterisations are instances of a
general methodological principle for studying programming languages (or logics) categorically (see
[Mog89b]):
when studying a complex language the 2-category Cat of small categories, functors and
natural transformations may not be adequate; however, one may replace Cat with a
diﬀerent 2-category, whose objects captures better some fundamental structure of the
language, while less fundamental structure can be modelled by 2-categorical concepts.
16

Monads are a 2-categorical concept, so we expect notions of computations for a complex language
to be modelled by monads in a suitable 2-category.
The ﬁrst characterisation takes a commutative monoidal closed structure on C (used in [Laf88,
See87] to model a fragment of linear logic), so that C can be enriched over itself. Then a strong
monad over a cartesian closed category C is just a monad over C in the 2-category of C-enriched
categories.
The second characterisation takes a class D of display maps over C (used in [HP87] to model
dependent types), and deﬁnes a C-indexed category C/D . Then a strong monad over a category
C with ﬁnite products amounts to a monad over C/D in the 2-category of C-indexed categories,
where D is the class of ﬁrst projections (corresponding to constant type dependency).
In general the natural transformation t has to be given explicitly as part of the additional
structure.
However, t is uniquely determined (but it may not exists) by T and the cartesian
structure on C, when C has enough points.
Proposition 3.4 (Uniqueness) If (T, η, µ) is a monad over a category C with ﬁnite products and
enough points (i.e. ∀h: 1 →A.h; f = h; g implies f = g for any f, g: A →B), then (T, η, µ, t) is
a strong monad over C if and only if tA,B is the unique family of morphisms s.t. for all points
a: 1 →A and b: 1 →TB
⟨a, b⟩; tA,B = b; T(⟨!B; a, idB⟩)
where !B: B →1 is the unique morphism from B to the terminal object.
Proof Note that there is at most one tA,B s.t. ⟨a, b⟩; tA,B = b; T(⟨!B; a, idB⟩) for all points a: 1 →A
and b: 1 →TB, because C has enough points.
First we show that if (T, η, µ, t) is a strong monad, then tA,B satisﬁes the equation above. By
naturality of t and by the ﬁrst diagram in Deﬁnition 3.2 the following diagram commutes
1
⟨a, b⟩
> A × TB
tA,B > T(A × B)
∧
∧
@@@ ⟨id1, b⟩
@@@
R
a × idT B
T(a × idB)
1 × TB
t1,B > T(1 × B)
@@@ rT B
@@@
R
∨
TrB
TB
Since rB is an isomorphism (with inverse ⟨!B, idB⟩), then the two composite morphisms ⟨a, b⟩; tA,B
and ⟨id1, b⟩; rT B; T(r−1
B ); T(a×idB) from 1 to T(A×B) must coincide. But the second composition
can be rewritten as b; T(⟨!B; a, idB⟩).
Second we have to show that if t is the unique family of morphisms satisfying the equation
above, then (T, η, µ, t) is a strong monad. This amount to prove that t is a natural transformation
and that the three diagrams in Deﬁnition 3.2 commute. The proof is a tedious diagram chasing,
which relies on C having enough points. For instance, to prove that t1,A; TrA = rT A it is enough
to show that ⟨id1, a⟩; t1,A; TrA = ⟨id1, a⟩; rT A for all points a: 1 →A.
Example 3.5 We go through the monads given in Example 1.4 and show that they have a tensorial
strength.
• partiality TA = A⊥(= A + {⊥})
tA,B(a, ⊥) = ⊥and tA,B(a, b) = ⟨a, b⟩(when b ∈B)
• nondeterminism TA = Pfin(A)
tA,B(a, c) = {⟨a, b⟩|b ∈c}
17

• side-eﬀects TA = (A × S)S
tA,B(a, c) = (λs: S.(let ⟨b, s′⟩= c(s) in ⟨⟨a, b⟩, s′⟩))
• exceptions TA = (A + E)
tA,B(a, inr(e)) = inr(e) (when e ∈E) and
tA,B(a, inl(b)) = inl(⟨a, b⟩) (when b ∈B)
• continuations TA = R(RA)
tA,B(a, c) = (λk: RA×B.c(λb: B.k(⟨a, b⟩)))
• interactive input TA = (µγ.A + γU)
tA,B(a, c) is the tree obtained by replacing leaves of c labelled by b with the leaf labelled by
⟨a, b⟩
• interactive output TA = (µγ.A + (U × γ))
tA,B(a, ⟨s, b⟩) = ⟨s, ⟨a, b⟩⟩.
Remark 3.6 The tensorial strength t induces a natural transformation ψA,B from TA × TB to
T(A × B), namely
ψA,B = cT A,T B; tT B,A; (cT B,A; tA,B)∗
where c is the natural isomorphism cA,B: A × B →B × A.
The morphism ψA,B has the correct domain and codomain to interpret the pairing of a com-
putation of type A with one of type B, obtained by ﬁrst evaluating the ﬁrst argument and then
the second, namely
c1: TA, c2: TB
ψA,B
7−→
(let x⇐c1 in (let y⇐c2 in [⟨x, y⟩])): T(A × B)
There is also a dual notion of pairing, ˜ψA,B = cT A,T B; ψB,A; TcB,A (see [Koc72]), which amounts
to ﬁrst evaluating the second argument and then the ﬁrst.
3.1
Interpretation and formal system
We are now in a position to give the metalanguage for algebraic terms, its interpretation and
inference rules.
Deﬁnition 3.7 (metalanguage) An interpretation [[ ]] of the metalanguage in a category C with
terminal object !A: A →1, binary products πA1,A2
i
: A1 × A2 →Ai and a strong monad (T, η, µ, t)
is parametric in an interpretation of the symbols in the signature and is deﬁned by induction on
the derivation of well-formedness for types (see Table 8), terms and equations (see Table 9).
Finite products πA1,...,An
i
: A1×. . .×An →Ai used to interpret contexts and variables are deﬁned
by induction on n:
0 A1 × . . . × A0
∆= 1
n + 1 A1 × . . . × An+1
∆= (A1 × . . . × An) × An+1
– πA1,...,An+1
n+1
= π(A1×...×An),An+1
2
– πA1,...,An+1
i
= π(A1×...×An),An+1
1
; πA1,...,An
i
The inference rules for the metalanguage (see Table 10) are divided into three groups:
• general rules for many sorted equational logic
• rules for ﬁnite products
• rules for T
18

RULE
SYNTAX
SEMANTICS
A
⊢ml A type
=
[[A]]
T
⊢ml τ type
=
c
⊢ml Tτ type
=
Tc
1
⊢ml 1 type
=
1
×
⊢ml τ1 type
=
c1
⊢ml τ2 type
=
c2
⊢ml τ1 × τ2 type
=
c1 × c2
∅
⊢ml τi type
(1 ≤i ≤n)
=
ci
x1: τ1, . . . , xn: τn ⊢
=
c1 × . . . × cn
Table 8: Interpretation of types in the Metalanguage
Proposition 3.8 Every theory T of the metalanguage, viewed as a category F(T ), is equipped
with ﬁnite products and a strong monad whose tensorial strength is
tτ1,τ2 = [x: τ1 × Tτ2 ⊢ml (letT x2⇐π2x in [⟨π1x, x2⟩]T ): T(τ1 × τ2)]T
Proof Similar to that of Proposition 2.5
Once we have a metalanguage for algebraic terms it is straightforward to add data-types charac-
terised by universal properties and extend the categorical semantics accordingly5. For instance, if
we want to have function spaces, then we simply require the category C (where the metalanguage
is interpreted) to have exponentials BA and add the inference rules for the simply typed λ-calculus
(see Table 11) to those for the metalanguage. From a programming language perspective the situ-
ation is more delicate. For instance, the semantics of functional types should reﬂect the choice of
calling mechanism6:
• in call-by-value a procedure of type A →B expects a value of type A and computes a result
of type B, so the interpretation of A →B is (TB)A;
• in call-by-name a procedure of type A →B expects a computation of type A, which is
evaluated only when needed, and computes a result of type B, so the interpretation of
A →B is (TB)T A.
In both cases the only exponentials needed to interpret the functional types of a programming
language are of the form (TB)A. By analogy with partial cartesian closed categories (pccc), where
only p-exponentials are required to exists (see [Mog86, Ros86]), we adopt the following deﬁnition
of λc-model:
5The next diﬃcult step in extending the metalanguage is the combination of dependent types and computations,
which is currently under investigation.
6call-by-need does not have a simple categorical semantics, since the environment in which an expression is
evaluated may itself undergo evaluation.
19

RULE
SYNTAX
SEMANTICS
vari
⊢ml τi type
(1 ≤i ≤n)
=
ci
x1: τ1, . . . , xn: τn ⊢xi: τi
=
πc1,...,cn
i
∗
Γ ⊢∗: 1
=
![[Γ]]
⟨⟩
Γ ⊢e1: τ1
=
g1
Γ ⊢e2: τ2
=
g2
Γ ⊢⟨e1, e2⟩: τ1 × τ2
=
⟨g1, g2⟩
πi
Γ ⊢e: τ1 × τ2
=
g
Γ ⊢πi(e): τ1
=
g; π[[τ1]],[[τ2]]
i
f: τ1 →τ2
Γ ⊢ml e1: τ1
=
g
Γ ⊢ml f(e1): τ2
=
g; [[f]]
[ ]T
Γ ⊢ml e: τ
=
g
Γ ⊢ml [e]T : Tτ
=
g; η[[τ]]
let
Γ ⊢ml e1: Tτ1
=
g1
Γ, x: τ1 ⊢ml e2: Tτ2
=
g2
Γ ⊢ml (letT x⇐e1 in e2): Tτ2
=
⟨id[[Γ]], g1⟩; t[[Γ]],[[τ1]]; g∗
2
eq
Γ ⊢ml e1: τ
=
g1
Γ ⊢ml e2: τ
=
g2
Γ ⊢ml e1 =τ e2
⇐⇒
g1 = g2
Table 9: Interpretation of terms in the Metalanguage
20

reﬂ
Γ ⊢e: τ
Γ ⊢e =τ e
symm Γ ⊢e1 =τ e2
Γ ⊢e2 =τ e1
trans Γ ⊢e1 =τ e2
Γ ⊢e2 =τ e3
Γ ⊢e2 =τ e3
congr
Γ ⊢e1 =τ1 e2
Γ ⊢f(e1) =τ2 f(e2) f: τ1 →τ2
subst Γ ⊢e: τ
Γ, x: τ ⊢φ
Γ ⊢[e/x]φ
Inference Rules of Many Sorted Equational Logic
1.η Γ ⊢∗=1 x
⟨⟩.ξ Γ ⊢e1 =τ1 e′
1
Γ ⊢e2 =τ2 e′
2
Γ ⊢⟨e1, e2⟩=τ1×τ2 ⟨e′
1, e′
2⟩
×.β Γ ⊢e1: τ1
Γ ⊢e2: τ2
Γ ⊢πi(⟨e1, e2⟩) =τi ei
×.η
Γ ⊢e: τ1 × τ2
Γ ⊢⟨π1(e), π2(e)⟩=τ1×τ2 e
rules for product types
[ ].ξ
Γ ⊢ml e1 =τ e2
Γ ⊢ml [e1]T =T τ [e2]T
let.ξ
Γ ⊢ml e1 =T τ1 e2
Γ, x: τ1 ⊢ml e′
1 =T τ2 e′
2
Γ ⊢ml (letT x⇐e1 in e′
1) =T τ2 (letT x⇐e2 in e′
2)
ass
Γ ⊢ml e1: Tτ1
Γ, x1: τ1 ⊢ml e2: Tτ2
Γ, x2: τ2 ⊢ml e3: Tτ3
Γ ⊢ml (letT x2⇐(letT x1⇐e1 in e2) in e3) =T τ3 (letT x1⇐e1 in (letT x2⇐e2 in e3))
T.β
Γ ⊢ml e1: τ1
Γ, x1: τ1 ⊢ml e2: Tτ2
Γ ⊢ml (letT x1⇐[e1]T in e2) =T τ2 [e1/x1]e2
T.η
Γ ⊢ml e1: Tτ1
Γ ⊢ml (letT x1⇐e1 in [x1]T ) =T τ1 e1
Table 10: Inference Rules of the Metalanguage
app.ξ Γ ⊢e1 =τ1 e′
1
Γ ⊢e =τ1→τ2 e′
Γ ⊢ee1 =τ2 e′e′
1
λ.ξ
Γ, x: τ1 ⊢e1 =τ2 e2
Γ ⊢(λx: τ1.e1) =τ1→τ2 (λx: τ1.e2)
→.β
Γ ⊢e1: τ1
Γ, x: τ1 ⊢e2: τ2
Γ ⊢(λx: τ1.e2)e1 =τ2 [e1/x]e2
→.η
Γ ⊢e: τ1 →τ2
Γ ⊢(λx: τ1.ex) =τ1→τ2 e x ̸∈DV(Γ)
Table 11: rules for function spaces
21

Deﬁnition 3.9 A λc-model is a category C with ﬁnite products, a strong monad (T, η, µ, t) satis-
fying the mono requirement (i.e. ηA mono for every A ∈C) and T-exponential (TB)A for every
A, B ∈C.
Remark 3.10 The deﬁnition of λc-model generalises that of pccc, in the sense that every pccc
can be viewed as a λc-model. By analogy with p-exponentials, a T-exponential can be deﬁned by
giving an isomorphism CT (C × A, B) ∼= C(C, (TB)A) natural in C ∈C. We refer to [Mog89c] for
the interpretation of a call-by-value programming language in a λc-model and the corresponding
formal system, the λc-calculus.
4
Strong monads over a topos
In this section we show that, as far as monads or strong monads are concerned, we can assume
w.l.o.g. that they are over a topos (see Theorem 4.9). The proof of Theorem 4.9 involves non-
elementary notions from Category Theory, and we postpone it after discussing some applications,
with particular emphasis on further extensions of the metalanguage and on conservative extension
results.
Let us take as formal system for toposes the type theory described in [LS86], this is a many
sorted intuitionistic higher order logic with equality and with a set of types satisfying the following
closure properties7:
• the terminal object 1, the natural number object N and the subobject classiﬁer Ωare types
• if A is a type, then the power object PA is a type
• if A and B are types, then the binary product A × B and the function space A →B are
types
• if A is a type and φ: A →Ωis a predicate, then {x ∈A|φ(x)} is a type.
Notation 4.1 We introduce some notational conventions for formal systems:
• MLT is the metalanguage for algebraic terms, whose set of types is closed under terminal
object, binary products and TA;
• λMLT is the extension of MLT with function spaces A →B (interpreted as exponentials);
• HMLT is the type theory described above (see [LS86]) extended with objects of computations
TA;
• PL is the programming language for algebraic terms (see [Mog89c]);
• λcPL is the extension of PL with function spaces A ⇀B (interpreted as T-exponentials),
called λc-calculus in [Mog89c].
Deﬁnition 4.2 We say that a formal system (L2, ⊢2), where ⊢2⊆P(L2) × L2 is a formal conse-
quence relation8 over L2, is a conservative extension of (L1, ⊢1) provided L1 ⊆L2 and ⊢1 is
the restriction of ⊢2 to P(L1) × L1.
Theorem 4.3 HMLT is a conservative extension of MLT and λMLT . In particular λMLT is a
conservative extension of MLT .
7Lambek and Scott do not require closure under function spaces and subsets {x ∈A|φ(x)}.
8For instance, in the case of MLT the elements of L are well-formed equality judgements Γ ⊢ml e1 =τ e2 and
P ⊢C iﬀthere exists a derivation of C, where all assumptions are in P .
22

Proof The ﬁrst result follows from Theorem 4.9, which implies that for every model C of MLT
the Yoneda embedding maps the interpretation of an MLT -term in C to its interpretation in ˆC,
and the faithfulness of the Yoneda embedding, which implies that two MLT -terms have the same
interpretation in C iﬀthey have the same interpretation in ˆC. The second result follows, because
the Yoneda embedding preserves function spaces. The third conservative extension result follows
immediately from the ﬁrst two.
The above result means that we can think of computations naively in terms of sets and func-
tions, provided we treat them intuitionistically, and can use the full apparatus of higher-order
(intuitionistic) logic instead of the less expressive many sorted equational logic.
Before giving a conservative extension result for the programming language, we have to express
the mono requirement, equivalence and existence in HMLT . The idea is to extend the translation
from PL-terms to MLT -terms given in Deﬁnition 2.7 and exploit the increased expressiveness of
HMLT over MLT to axiomatise the mono requirement and translate existence and equivalence
assertions (see Remark 2.1):
• the mono requirement for τ, i.e. ητ is mono, is axiomatised by
mono.τ (∀x, y: τ.[x]T =T τ [y]T →x =τ y)
• the equalising requirement for τ, i.e. ητ is the equaliser of T(ητ) and ηT τ, is axiomatised
by (mono.τ) and the axiom
eqls.τ (∀x: Tτ.[x]T =T 2τ (letT y⇐x in [[y]T ]T ) →(∃!y: τ.x =T τ [y]T ))
• the translation
◦is extended to assertions and functional types as follows:
– (e1 ≡τ e2)◦∆≡e1◦=T τ e2◦
– (e1 ↓τ)◦∆≡(∃!x: τ.e1◦=T τ [x]T )
– (τ1 ⇀τ2)◦∆≡τ1◦→Tτ2◦
Theorem 4.4 HMLT +{(mono.τ)| τ type of PL} (i.e. τ is built using only base types, 1, TA, and
A×B) is a conservative extension of PL (after translation). Similarly, HMLT +{(mono.τ)| τ type of λcPL}
(i.e. τ is built using only base types, 1, TA, A × B and A →B) is a conservative extension of
λcPL (after translation).
Proof The proof proceeds as in the previous theorem. The only additional step is to show that for
every type τ of PL (or λcPL) the axiom (mono.τ) holds in ˆC, under the assumption that C satisﬁes
the mono requirement. Let c be the interpretation of τ in C (therefore Yc is the interpretation of
τ in ˆC), then the axiom (mono.τ) holds in ˆC provided ˆηYc is a mono. ηc is mono (by the mono
requirement), so ˆηYc = Y(ηc) is mono (as Y preserves monos).
In the theorem above only types from the programming language have to satisfy the mono require-
ment. Indeed, HMLT + {(mono.τ)| τ type of HMLT } is not a conservative extension of PL (or
λcPL).
Lemma 4.5 If (T, η, µ) is a monad over a topos C satisfying the mono requirement, then it satisﬁes
also the equalising requirement.
Proof See Lemma 6 on page 110 of [BW85].
In other words, for any type τ the axiom (eqls.τ) is derivable in HMLT from the set of axioms
{(mono.τ)| τ type of HMLT }. In general, when C is not a topos, the mono requirement does not
entail the equalising requirement; one can easily deﬁne strong monads (over an Heyting algebra)
that satisfy the mono but not the equalising requirement (just take T(A) = A ∨B, for some
element B ̸= ⊥of the Heyting algebra).
In terms of formal consequence relation this means
23

that in HMLT + mono requirement the existence assertion Γ ⊢pl e ↓τ is derivable from Γ ⊢pl
[e] ≡T τ (let x⇐e in [x]), while such derivation is not possible in λcPL. We do not know whether
HMLT + equalising requirement is a conservative extension of PL + equalising requirement, or
whether λcPL is a conservative extension of PL.
A language which combines computations and higher order logic, like HMLT , seems to be the
ideal framework for program logics that go beyond proving equivalence of programs, like Hoare’s
logic for partial correctness of imperative languages. In HMLT (as well as MLT and PL) one can
describe a programming language by introducing additional constant and axioms. In λMLT or
λcPL such constants correspond to program-constructors, for instance:
• lookup: L →TU, which given a location l ∈L produces the value of such location in the
current store, and update: L×U →T1, which changes the current store by assigning to l ∈L
the value u ∈U;
• if: Bool × TA × TA →TA and while: T(Bool) × T1 →T1;
• new: 1 →TL, which returns a newly created location;
• read: 1 →TU, which computes a value by reading it from the input, and write: U →T1,
which writes a value u ∈U on the output.
In HMLT one can describe also a program logic, by adding constants p: TA →Ωcorresponding to
properties of computations.
Example 4.6 Let T be the monad for non-deterministic computations (see Example 1.4), then we
can deﬁne a predicate may: A × TA →Ωsuch that may(a, c) is true iﬀthe value a is a possible
outcome of the computation c (i.e. a ∈c). However, there is a more uniform way of deﬁning the
may predicate for any type. Let 3: TΩ→Ωbe the predicate such that 3(X) = ⊤iﬀ⊤∈X,
where Ωis the set {⊥, ⊤} (note that 3( ) = may(⊤, )).
Then, may(a, c) can be deﬁned as
3(letT x⇐c in [a =τ x]T ).
The previous example suggests that predicates deﬁned uniformly on computations of any type
can be better described in terms of modal operators γ: TΩ→Ω, relating a computation of truth
values to a truth value. This possibility has not been investigated in depth, so we will give only a
tentative deﬁnition.
Deﬁnition 4.7 If (T, η, µ) is a monad over a topos C, then a T-modal operator is a T-algebra
γ: TΩ→Ω, i.e.
T 2Ω
µΩ> TΩ<
ηΩ
Ω
Tγ
∨
∨
γ
	
    idT Ω
   TΩ
γ
> Ω
where Ωis the subobject classiﬁer in C.
The commutativity of the two diagrams above can be expressed in the metalanguage:
• x: Ω⊢γ([x]T ) ←→x
• c: T 2Ω⊢γ(let x⇐c in x) ←→γ(let x⇐c in [γ(x)]T )
We consider some examples and non-examples of modal operators.
Example 4.8 For the monad T of non-deterministic computations (see Example 1.4) there are
only two modal operators 2 and 3:
• 2(X) = ⊥iﬀ⊥∈X;
24

• 3(X) = ⊤iﬀ⊤∈X.
Given a nondeterministic computation e of type τ and a predicate A(x) over τ, i.e. a term of type
Ω, then 2(letT x⇐e in [A(x)]T ) is true iﬀall possible results of e satisfy A(x).
For the monad T of computations with side-eﬀects (see Example 1.4) there is an operator
2: (Ω× S)S →Ωthat can be used to express Hoare’s triples:
• 2f = ⊤iﬀfor all s ∈S there exists s′ ∈S s.t. fs = ⟨⊤, s′⟩
this operator does not satisfy the second equivalence, as only one direction is valid, namely
c: T 2Ω⊢γ(let x⇐c in [γ(x)]T ) →γ(let x⇐c in x)
Let P: U →Ωand Q: U × U →Ωbe predicates over storable values, e ∈T1 a computation of type
1 and x, y ∈L locations. The intended meaning of the triple {P(x)}e{Q(x, y)} is “if in the initial
state the content u of x satisﬁes P(u), then in the ﬁnal state (i.e. after executing e) the content
v of y satisﬁes Q(u, v)”. This intended meaning can be expressed formally in terms of the modal
operator 2 and the program-constructors lookup and update as follows:
∀u: U.P(u) →2(letT v⇐(update(x, u); e; lookup(y)) in [Q(u, v)]T )
where ; : TA×TB →TB is the derived operation e1; e2
∆≡(letT x⇐e1 in e2) with x not free in e2.
Finally, we state the main theorem and outline its proof. In doing so we assume that the reader
is familiar with non-elementary concepts from Category Theory.
Theorem 4.9 Let C be a small category, ˆC the topos of presheaves over C and Y the Yoneda
embedding of C into ˆC. Then for every monad (T, η, µ) over C, there exists a monad ( ˆT, ˆη, ˆµ) over
ˆC such that the following diagram commutes9
C
T
> C
Y
∨
∨
Y
ˆC
ˆT
> ˆC
and for all a ∈C the following equations hold
ˆηYa = Y(ηa)
,
ˆµYa = Y(µa)
Moreover, for every strong monad (T, η, µ, t) over C, there exists a natural transformation ˆt such
that ( ˆT, ˆη, ˆµ,ˆt) is a strong monad over ˆC and for all a, b ∈C the following equation holds
ˆtYa,Yb = Y(ta,b)
where we have implicitly assume that the Yoneda embedding preserves ﬁnite products on the nose,
i.e. the following diagrams commute
1
1
> C <
×
C × C
@@@
1 @@@
R
Y
∨
∨
Y × Y
ˆC <
×
ˆC × ˆC
9This is a simplifying assumption. For our purposes it would be enough to have a natural isomorphism σ: T ; Y
.→
Y; ˆT , but then the remaining equations have to be patched. For instance, the equation relating η and ˆη would become
ˆηYa = Y(ηa); σa.
25

and for all a, b ∈C. the following equations hold
!Ya = Y(!a)
,
πYa,Yb
i
= Y(πa,b
i
)
Deﬁnition 4.10 ([Mac71]) Let T: C →D be a functor between two small categories and A a
cocomplete category. Then, the left Kan extension LA
T : AC →AD is the left adjoint of AT and
can be deﬁned as follows:
LA
T (F)(d) = ColimA
T ↓d(π; F)
where F: C →A , d ∈D, T ↓d is the comma category whose objects are pairs ⟨c ∈C, f: Tc →d⟩,
π: T ↓d →C is the projection functor (mapping a pair ⟨c, f⟩to c) and ColimA
I : AI →A (with I
small category) is a functor mapping an I-diagram in A to its colimit.
The following proposition is a 2-categorical reformulation of Theorem 1.3.10 of [MR77]. For the
sake of simplicity, we use the strict notions of 2-functor and 2-natural transformation, although we
should have used pseudo-functors and pseudo-natural transformations.
Proposition 4.11 Let Cat be the 2-category of small categories, CAT the 2-category of locally
small categories and : Cat →CAT the inclusion 2-functor. Then, the following ˆ: Cat →CAT
is a 2-functor
• if C is a small category, then ˆC is the topos of presheaves SetCop
• if T: C →D is a functor, then ˆT is the left Kan extension LSet
T op
• if σ: S
.→T: C →D is a natural transformation and F ∈ˆC, then ˆσF is the natural transfor-
mation corresponding to id ˆT F via the following sequence of steps
ˆC(F, T op; ˆTF) < ∼
ˆD( ˆTF, ˆTF)
∨
ˆC(F, σop; ˆTF)
ˆC(F, Sop; ˆTF)
∼> ˆD( ˆSF, ˆTF)
Moreover, Y:
.→ˆ is a 2-natural transformation.
Since monads are a 2-categorical concept (see [Str72]), the 2-functor ˆ maps monads in Cat to
monads in CAT. Then, the statement of Theorem 4.9 about lifting of monads follows immediately
from Proposition 4.11. It remains to deﬁne the lifting ˆt of a tensorial strength t for a monad (T, η, µ)
over a small category C.
Proposition 4.12 If C is a small category with ﬁnite products and T is an endofunctor over
C, then for every natural transformation ta,b: a × Tb →T(a × b) there exists a unique natural
transformation ˆtF,G: F × ˆTG →ˆT(F × G) s.t. ˆtYa,Yb = Y(ta,b) for all a, b ∈C.
Proof Every F ∈ˆC is isomorphic to the colimit Colim
ˆC
Y↓F (π; Y) (shortly ColimiYi), where Y is
the Yoneda embedding of C into ˆC. Similarly G is isomorphic to ColimjYj. Both functors ( × ˆT )
and ˆT( × ) from ˆC × ˆC to ˆC preserves colimits (as ˆT and
× F are left adjoints) and commute
with the Yoneda embedding (as Y(a×b) = Ya×Yb and ˆT(Ya) = Y(Ta)). Therefore, F × ˆTG and
ˆT(F × G) are isomorphic to the colimits Colimi,jYi × ˆT(Yj) and Colimi,j ˆT(Yi × Yj) respectively.
Let ˆt be the natural transformation we are looking for, then
Yi × ˆT(Yj)
Y(ti,j)
> ˆT(Yi × Yj)
f × ˆTg
∨
∨
ˆT(f × g)
F × ˆT(G)
ˆtF,G
> ˆT(F × G)
26

for all f: Yi →F and g: Yj →g (by naturality of ˆt and ˆtYi,Yj = Y(ti,j)). But there exists exactly
one morphism ˆtF,G making the diagram above commute, as ⟨ti,j|i, j⟩is a morphism between
diagrams in ˆC of the same shape, and these diagrams have colimit cones ⟨f × ˆTg|f, g⟩and ⟨ˆT(f ×
g)|f, g⟩respectively.
Remark 4.13 If T is a monad of partial computations, i.e. it is induced by a dominion M on C
s.t. P(C, M)(a, b) ∼= C(a, Tb), then the lifting ˆT is the monad of partial computations induced by
the dominion
ˆ
M on ˆC, obtained by lifting M to the topos of presheaves, as described in [Ros86].
For other monads, however, the lifting is not the expected one. For instance, if T is the monad
of side-eﬀects ( × S)S, then ˆT is not (in general) the endofunctor ( × YS)YS on the topos of
presheaves.
Conclusions and further research
The main contribution of this paper is the category-theoretic semantics of computations and the
general principle for extending it to more complex languages (see Remark 3.3 and Section 4), while
the formal systems presented are a straightforward fallout, easy to understand and relate to other
calculi.
Our work is just an example of what can be achieved in the study of programming languages
by using a category-theoretic methodology, which avoids irrelevant syntactic detail and focus in-
stead on the important structures underlying programming languages. We believe that there is a
great potential to be exploited here. Indeed, in [Mog89b] we give a categorical account of phase
distinction and program modules, that could lead to the introduction of higher order modules in
programming languages like ADA or ML (see [HMM90]), while in [Mog89a] we propose a “modular
approach” to Denotational Semantics based on the idea of monad-constructor (i.e. an endofunctor
on the category of monads over a category C).
The metalanguage open also the possibility to develop a new Logic of Computable Functions
(see [Sco69]), based on an abstract semantic of computations rather than domain theory, for
studying axiomatically diﬀerent notions of computation and their relations. Some recent work by
Crole and Pitts (see [CP90]) has consider an extension of the metalanguage equipped with a logic
for inductive predicates, which goes beyond equational reasoning. A more ambitious goal would
be to try exploiting the capabilities oﬀered by higher-order logic in order to give a uniform account
of various program logics, based on the idea of “T-modal operator” (see Deﬁnition 4.7).
The semantics of computations corroborates the view that (constructive) proofs and programs
are rather unrelated, although both of them can be understood in terms of functions. Indeed,
monads (and comonads) used to model logical modalities, e.g. possibility and necessity in modal
logic or why not and of course of linear logic, usually do not have a tensorial strength. In general,
one should expect types suggested by logic to provide a more ﬁne-grained type system without
changing the nature of computations.
We have identiﬁed monads as important to model notions of computations, but computational
monads seem to have additional properties, e.g. they have a tensorial stregth and may satisfy the
mono requirement. It is likely that there are other properties of computational monads still to be
identiﬁed, and there is no reason to believe that such properties have to be found in the literature
on monads.
Acknowledgements
I have to thank many people for advice, suggestions and criticisms, in particular: R. Amadio, R.
Burstall, M. Felleisen, R. Harper, F. Honsell, M. Hyland, B. Jay, A. Kock, Y. Lafont, G. Longo,
R. Milner, A. Pitts, G. Plotkin, J. Power and C. Talcott.
References
[BW85] M. Barr and C. Wells. Toposes, Triples and Theories. Springer Verlag, 1985.
27

[CP90] R.L. Crole and A.M. Pitts. New foundations for ﬁxpoint computations. In 4th LICS
Conf. IEEE, 1990.
[CS87] R.L. Constable and S.F. Smith. Partial objects in constructive type theory. In 2nd
LICS Conf. IEEE, 1987.
[CS88] R.L. Constable and S.F. Smith. Computational foundations of basic recursive function
theory. In 3rd LICS Conf. IEEE, 1988.
[FF89] M. Felleisen and D.P. Friedman. A syntactic theory of sequential state. Theoretical
Computer Science, 69(3), 1989.
[FFKD86] M. Felleisen, D.P. Friedman, E. Kohlbecker, and B. Duba. Reasoning with continua-
tions. In 1st LICS Conf. IEEE, 1986.
[Fou77] M.P. Fourman. The logic of topoi. In J. Barwise, editor, Handbook of Mathematical
Logic, volume 90 of Studies in Logic. North Holland, 1977.
[GMW79] M.J.C. Gordon, R. Milner, and C.P. Wadsworth. Edinburgh LCF: A Mechanized Logic
of Computation, volume 78 of Lecture Notes in Computer Science. Springer Verlag,
1979.
[GS89] C. Gunter and S. Scott. Semantic domains. Technical Report MS-CIS-89-16, Dept.
of Comp. and Inf. Science, Univ. of Pennsylvania, 1989. to appear in North Holland
Handbook of Theoretical Computer Science.
[HMM90] R. Harper, J. Mitchell, and E. Moggi. Higher-order modules and the phase distinction.
In 17th POPL. ACM, 1990.
[HP87] J.M.E. Hyland and A.M. Pitts. The theory of constructions: Categorical semantics and
topos-theoretic models. In Proc. AMS Conf. on Categories in Comp. Sci. and Logic
(Boulder 1987), 1987.
[JP78] P.T. Johnstone and R. Pare, editors. Indexed Categories and their Applications, volume
661 of Lecture Notes in Mathematics. Springer Verlag, 1978.
[Kel82] G.M. Kelly. Basic Concepts of Enriched Category Theory. Cambridge University Press,
1982.
[Koc72] A. Kock. Strong functors and monoidal monads. Archiv der Mathematik, 23, 1972.
[KR77] A. Kock and G.E. Reyes. Doctrines in categorical logic. In J. Barwise, editor, Handbook
of Mathematical Logic, volume 90 of Studies in Logic. North Holland, 1977.
[Laf88] Y. Lafont. The linear abstract machine. Theoretical Computer Science, 59, 1988.
[LS86] J. Lambek and P.J. Scott. Introduction to Higher-Order Categorical Logic, volume 7 of
Cambridge Studies in Advanced Mathematics. Cambridge University Press, 1986.
[Mac71] S. MacLane. Categories for the Working Mathematician. Springer Verlag, 1971.
[Man76] E. Manes. Algebraic Theories, volume 26 of Graduate Texts in Mathematics. Springer
Verlag, 1976.
[Mas88] I.A. Mason. Veriﬁcation of programs that destructively manipulate data. Science of
Computer Programming, 10, 1988.
[Mog86] E. Moggi. Categories of partial morphisms and the partial lambda-calculus. In Pro-
ceedings Workshop on Category Theory and Computer Programming, Guildford 1985,
volume 240 of Lecture Notes in Computer Science. Springer Verlag, 1986.
28

[Mog88] E. Moggi. The Partial Lambda-Calculus. PhD thesis, University of Edinburgh, 1988.
[Mog89a] E. Moggi. An abstract view of programming languages. Technical Report ECS-LFCS-
90-113, Edinburgh Univ., Dept. of Comp. Sci., 1989. Lecture Notes for course CS 359,
Stanford Univ.
[Mog89b] E. Moggi. A category-theoretic account of program modules. In Proceedings of the
Conference on Category Theory and Computer Science, Manchester, UK, Sept. 1989,
volume 389 of Lecture Notes in Computer Science. Springer Verlag, 1989.
[Mog89c] E. Moggi. Computational lambda-calculus and monads. In 4th LICS Conf. IEEE, 1989.
[Mos89] P. Mosses. Denotational semantics. Technical Report MS-CIS-89-16, Dept. of Comp.
and Inf. Science, Univ. of Pennsylvania, 1989. to appear in North Holland Handbook
of Theoretical Computer Science.
[MR77] M. Makkai and G. Reyes. First Order Categorical Logic. Springer Verlag, 1977.
[MT89a] I. Mason and C. Talcott. Programming, transforming, and proving with function ab-
stractions and memories. In 16th Colloquium on Automata, Languages and Program-
ming. EATCS, 1989.
[MT89b] I. Mason and C. Talcott. A sound and complete axiomatization of operational equiva-
lence of programs with memory. In POPL 89. ACM, 1989.
[Plo75] G.D. Plotkin. Call-by-name, call-by-value and the λ-calculus. Theoretical Computer
Science, 1, 1975.
[Plo85] G.D. Plotkin. Denotational semantics with partial functions. Lecture Notes at C.S.L.I.
Summer School, 1985.
[Ros86] G. Rosolini. Continuity and Eﬀectiveness in Topoi. PhD thesis, University of Oxford,
1986.
[Sch86] D.A. Schmidt.
Denotational Semantics: a Methodology for Language Development.
Allyn & Bacon, 1986.
[Sco69] D.S. Scott. A type-theoretic alternative to CUCH, ISWIM, OWHY. Oxford notes,
1969.
[Sco79] D.S. Scott. Identity and existence in intuitionistic logic. In M.P. Fourman, C.J. Mul-
vey, and D.S. Scott, editors, Applications of Sheaves, volume 753 of Lecture Notes in
Mathematics. Springer Verlag, 1979.
[Sco80] D.S. Scott. Relating theories of the λ-calculus. In R. Hindley and J. Seldin, editors, To
H.B. Curry: essays in Combinarory Logic, lambda calculus and Formalisms. Academic
Press, 1980.
[See87] R.A.G. Seely. Linear logic, ∗-autonomous categories and cofree coalgebras. In Proc.
AMS Conf. on Categories in Comp. Sci. and Logic (Boulder 1987), 1987.
[Sha84] K. Sharma. Syntactic aspects of the non-deterministic lambda calculus. Master’s thesis,
Washington State University, September 1984. available as internal report CS-84-127
of the comp. sci. dept.
[SP82] M. Smith and G. Plotkin. The category-theoretic solution of recursive domain equa-
tions. SIAM Journal of Computing, 11, 1982.
[Str72] R. Street. The formal theory of monads. Journal of Pure and Applied Algebra, 2, 1972.
29

