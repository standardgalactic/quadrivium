






ix
table of contents
Intro
Your brain on OOA&D.  Here you are trying to learn something, while here your 
brain is doing you a favor by making sure the learning doesn’t stick.  Your brain’s thinking, 
“Better leave room for more important things, like which wild animals to avoid and whether 
naked snowboarding is a bad idea.”  So how do you trick your brain into thinking that your 
life depends on knowing object-oriented analysis and design? 
Who is this book for?	
xxiv
We know what you’re thinking	
xxv
Metacognition	
xxvii
Bend your brain into submission	
xxix
Read Me	
xxx
The Technical Team	
xxxii
Acknowledgements	
xxxiii
Table of Contents (summary)
          Intro	
xxiii
1 	
Great Software Begins Here:  well-designed apps rock	
1
2	
Give Them What They Want:  gathering requirements	
55
3	
I Love You, You’re Perfect... Now Change:  requirements change	
111
4	
Taking Your Software Into the Real World:  analysis	
145
5	
Part 1: Nothing Ever Stays the Same:  good design	
197
	
Interlude: OO CATASTROPHE	
221
	
Part 2: Give Your Software a 30-minute Workout:  flexible software	
233
6	
“My Name is Art Vandelay”:  solving really big problems	
279
7	
Bringing Order to Chaos:  architecture	
323
8	
Originality is Overrated:  design principles	
375
9	
The Software is Still for the Customer:  iteration and testing	
423
10	
Putting It All Together:  the ooa&d lifecycle	
483
	
Appendix I:  leftovers	
557
	
Appendix II:  welcome to objectville	
575	
Table of Contents (the real thing)

x
table of contents
1
Great Software Begins Here
So how do you really write great software? It’s never easy trying 
to fi gure out where to start. Does the application actually do what it’s supposed to? 
And what about things like duplicate code—that can’t be good, can it? It’s usually pretty 
hard to know what you should work on ﬁ rst, and still make sure you don’t screw 
everything else up in the process. No worries here, though. By the time you’re done 
with this chapter, you’ll know how to write great software, and be well on your way 
to improving the way you develop applications forever. Finally, you’ll understand why 
OOAD is a four-letter word that your mother actually wants you to know about. 
well-designed apps rock
Rock and roll is forever! 
 
 
 
 
2
Rick’s shiny new application  
 
 
 
3
What’s the FIRST thing you’d change?  
 
 
8
Great Software is...  
 
 
 
 
10
Great software in 3 easy steps  
 
 
 
13
Focus on functionality fi rst 
 
 
 
 
18
Test drive  
 
 
 
 
 
23
Looking for problems 
 
 
 
 
25
Analysis  
 
 
 
 
 
26
Apply basic OO principles 
 
 
 
 
31
Design once, design twice 
 
 
 
 
36
How easy is it to change your applications? 
 
 
38
Encapsulate what varies 
 
 
 
 
41
Delegation 
 
 
 
 
 
43
Great software at last (for now) 
 
 
 
46
OOA&D is about writing great software 
 
 
49
Bullet Points 
 
 
 
 
 
50
How am I supposed to know where to start? 
I feel like every time I get a new project to 
work on, everyone’s got a different opinion 
about what to do ﬁ rst. Sometimes I get it right, and 
sometimes I end up reworking the whole app because I 
started in the wrong place. I just want to write 
great software! So what should I do ﬁ rst 
in Rick’s app?

xi
table of contents
2
Give Them What They Want
Everybody loves a satisfied customer. You  already know that the fi rst 
step in writing great software is making sure it does what the customer wants it to. But 
how do you fi gure out what a customer really wants? And how do you make sure that 
the customer even knows what they really want? That’s where good requirements 
come in, and in this chapter, you’re going to learn how to satisfy your customer by 
making sure what you deliver is actually what they asked for. By the time you’re done, 
all of your projects will be “satisfaction guaranteed,” and you’ll be well on your way to 
writing great software, every time.
gathering requirements
You’ve got a new programming gig 
 
 
 
56
Test drive  
 
 
 
 
 
59
Incorrect usage (sort of) 
 
 
 
 
61
What is a requirement? 
 
 
 
 
62
Creating a requirements list  
 
 
 
64
Plan for things going wrong  
 
 
 
68
Alternate paths handle system problems  
 
 
70
Introducing use cases 
 
 
 
 
72
One use case, three parts 
 
 
 
 
74
Check your requirements against your use cases  
 
78
Your system must work in the real world 
 
 
85
Getting to know the Happy Path 
 
 
 
92
OOA&D Toolbox  
 
 
 
 
106
1. Th
ta
2. A
d
t
3. O
c
a
Todd and Gina’s Dog Door, version 2.0
Todd and Ginas
g
,
Requirements List
he dog door opening must be at least 12” 
all.
A button on the remote control opens the 
og door if the door is closed, and closes 
he dog door if the door is open.
Once the dog door has opened, it should 
close automatically if the door isn’t 
already closed.
Requirements List
1. Fido barks to be let out.
2. Todd or Gina hears Fido barking.
3. Todd or Gina presses the button on the 
remote control.
4. The dog door opens.
5. Fido goes outside.
6. Fido does his business.
7. Fido goes back inside.
8. The door shuts automatically.
Todd and Gina’s Dog Door, version 2.0
What the Door Does
The System
The dog door 
and remote are 
part of the 
system, or inside 
the system.

xii
table of contents
3
I Love You, You’re Perfect... Now Change
Think you’ve got just what the customer wanted?
Not so fast...  So you’ve talked to your customer, gathered requirements, written 
out your use cases, and delivered a killer application. It’s time for a nice relaxing 
cocktail, right? Right... until your customer decides that they really wanted something 
different than what they told you. They love what you’ve done, really, but it’s not 
quite good enough anymore. In the real world, requirements are always changing, 
and it’s up to you to roll with these changes and keep your customer satisfi ed.
requirements change
You’re a hero! 
 
 
 
 
 
112
You’re a goat! 
 
 
 
 
 
113
The one constant in software analysis & design 
 
 
115
Original path? Alternate path? Who can tell? 
 
 
120
Use cases have to make sense to you 
 
 
 
122
Start to fi nish: a single scenario 
 
 
 
124
Confessions of an Alternate Path 
 
 
 
126
Finishing up the requirements list 
 
 
 
130
Duplicate code is a bad idea  
 
 
 
138
Final test drive 
 
 
 
 
 
140
Write your own design principle 
 
 
 
141
OOA&D Toolbox  
 
 
 
 
142
  public void  pressButton() {
    System.out.println(“Pressing the remote control button...”);
    if (door.isOpen()) {
      door.close();
    } else {
      door.open();
      final Timer timer = new Timer();
      timer.schedule(new TimerTask() {
        public void run() {
          door.close();
          timer.cancel();
        }
      }, 5000);
    }
  }
class 
Remote {
  press-
Button() 
}     
Remote.java

xiii
table of contents
4
Taking Your Software into the Real World
It’s time to graduate to real-world applications.  
Your application has to do more than  work on your own personal development machine, 
fi nely tuned and perfectly setup; your apps have to work when real people use them. 
This chapter is all about making sure that your software works in a real-world context. 
You’ll learn how textual analysis can take that use case you’ve been working on and 
turn it into classes and methods that you know are what your customers want. And 
when you’re done, you too can say: “I did it! My software is ready for the real world!”
analysis
One dog, two dog, three dog, four... 
 
 
 
146
Your software has a context  
 
 
 
147
Identify the problem 
 
 
 
 
148
Plan a solution 
 
 
 
 
 
149
A tale of two coders 
 
 
 
 
156
Delegation Detour  
 
 
 
 
160
The power of loosely coupled applications 
 
 
162
Pay attention to the nouns in your use case 
 
 
167
From good analysis to good classes... 
 
 
 
180
Class diagrams dissected 
 
 
 
 
182
Class diagrams aren’t everything 
 
 
 
187
Bullet Points 
 
 
 
 
 
191
class 
DogDoor 
{
  open() 
}     
DogDoor.java
The Real World
In the real world, there are 
dogs, cats, rodents, and a host 
of other problems, all set to 
screw up your software.
In this context, 
things go wrong a 
lot more often.
Once I knew the classes and 
operations that I needed, I 
went back and updated my class 
diagram.

xiv
table of contents
5 (part 1)
Nothing Ever Stays the Same
Change is inevitable. No matter how much you like your software right 
now, it’s probably going to change tomorrow. And the harder you make it for 
your software to change, the more diffi cult it’s going to be to respond to your 
customer’s changing needs. In this chapter, we’re going to revisit an old friend, 
try and improve an existing software project, and see how small changes can 
turn into big problems. In fact, we’re going to uncover a problem so big that it will 
take a TWO-PART chapter to solve it!
good design = flexible software
Rick’s Guitars is expanding  
 
 
 
198
Abstract classes 
 
 
 
 
 
201
Class diagrams dissected (again) 
 
 
 
206
UML Cheat Sheet   
 
 
 
 
207
Design problem tipoffs 
 
 
 
 
213
3 steps to great software (revisited) 
 
 
 
215
5 (interlude)
$100
$100
$100
$100
$100
$200
$200
$200
$200
$200
$300
$300
$300
$300
$300
$400
$400
$400
$400
$400
Software 
Software 
Neuroses
Neuroses
Maintenance
Maintenance
and Reuse
and Reuse
Code
Code
Constructs
Constructs
Famous
Famous
Designers
Designers
Risk
Risk
Avoidance
Avoidance

xv
table of contents
5 (part 2)
Give Your Software a 30-minute Workout
Ever wished you were just a bit more flexible?  
When you run into problems making changes to your application, it probably 
means that your software needs to be more flexible and resilient. To help stretch 
your application out, you’re going to do some analysis, a whole lot of design, and 
learn how OO principles can really loosen up your application. And for the grand 
finale, you’ll see how higher cohesion can really help your coupling. Sound 
interesting? Turn the page, and let’s get back to fixing that inflexible application.
good design = flexible software
Back to Rick’s search tool	
	
	
	
	
234
A closer look at the search() method	
	
	
	
237
The benefits of analysis	
	
	
	
	
238
Classes are about behavior	
	
	
	
	
241
Death of a design (decision)	 	
	
	
	
246
Turn bad design decisions into good ones	
	
	
247
“Double encapsulation” in Rick’s software	
	
	
249
Never be afraid to make mistakes	
	
	
	
255
Rick’s flexible application	
	
	
	
	
258
Test driving well-designed software	
	
	
	
261
How easy is it to change Rick’s software?	
	
	
265
The Great Ease-of-Change Challenge	 	
	
	
266
A cohesive class does one thing really well	
	
	
269
The design/cohesion lifecycle		
	
	
	
272
Great software is “good enough”	
	
	
	
274
OOA&D Toolbox	 	
	
	
	
	
276

xvi
table of contents
6
“My Name is Art Vandelay... I am an Architect”
It’s time to build something REALLY BIG. Are you ready?  
You’ve got a ton of tools in your OOA&D toolbox, but how do you use those tools 
when you have to build something really big? Well, you may not realize it, but 
you’ve got everything you need to handle big problems. We’ll learn about some 
new tools, like domain analysis and use case diagrams, but even these new tools 
are based on things you already know about—like listening to the customer and 
understanding what you’re going to build before you start writing code. Get ready... 
it’s time to start playing the architect.
solving really big problems
Solving big problems 
 
 
 
 
280
It’s all in how you look at the big problem 
 
 
281
Requirements and use cases are a good place to start... 
 
286
Commonality and variability  
 
 
 
287
Figure out the features 
 
 
 
 
290
The difference between features and requirements 
 
292
Use cases don’t always help you see the big picture 
 
294
Use case diagrams  
 
 
 
 
296
The Little Actor 
 
 
 
 
 
301
Actors are people, too (well, not always)  
 
 
302
Let’s do a little domain analysis 
 
 
 
307
Divide and conquer 
 
 
 
 
309
Don’t forget who the customer really is  
 
 
313
What’s a design pattern? 
 
 
 
 
315
The power of OOA&D (and a little common sense) 
 
318
OOA&D Toolbox  
 
 
 
 
320
Small 
Problem
Small 
Problem
Small 
Problem
Small 
Problem
Big 
Problem
This BIG PROBLEM is 
really just a collection of 
functionalities, where each 
piece of functionality is really 
a smaller problem on its own.
Small 
Problem

xvii
table of contents
7
Bringing Order to Chaos
You have to start somewhere, but you better pick the right 
somewhere! You know how to break your application up into lots of small 
problems, but all that means is that you have LOTS of small problems. In this chapter, 
we’re going to help you fi gure out where to start, and make sure that you don’t waste 
any time working on the wrong things. It’s time to take all those little pieces laying 
around your workspace, and fi gure out how to turn them into a well-ordered, well-
designed application. Along the way, you’ll learn about the all-important 3 Qs of 
architecture, and how Risk is a lot more than just a cool war game from the ‘80s.
architecture
Feeling a little overwhelmed?  
 
 
 
324
We need an architecture 
 
 
 
 
326
Start with functionality 
 
 
 
 
329
What’s architecturally signifi cant? 
 
 
 
331
The three Qs of architecture  
 
 
 
332
Reducing risk 
 
 
 
 
 
338
Scenarios help reduce risk 
 
 
 
 
341
Focus on one feature at a time 
 
 
 
349
Architecture is your design structure 
 
 
 
351
Commonality revisited 
 
 
 
 
355
Commonality Analysis: the path to fl exible software 
 
361
What does it mean? Ask the customer  
 
 
366
Reducing risk helps you write great software 
 
 
371
Bullet Points 
 
 
 
 
 
372
Giant Risk-O-Meter
Risk-O-
Unit
type: String
properties: Map
setType(String)
getType(): String
setProperty(String, Object)
getProperty(String): Object
Board.java
class 
Unit {
 Unit(){
 }
}
Unit.java
class 
Tile 
{  ge-
tUnit()
}
Tile.java
t(){
a
{ 
tU
}
class 
Board 
{  ge-
tUnit()
}
Not a chance in hell of 
coming in on time.
One in a hundred that 
you get it right.
Only a few things can 
go really wrong.
As close to a sure 
thing as software gets!
Gi
R

xviii
table of contents
8
Originality is Overrated
Imitation is the sincerest form of not being stupid. There’s 
nothing as satisfying as coming up with a completely new and original solution to a 
problem that’s been troubling you for days—until you fi nd out someone else solved 
the same problem, long before you did, and did an even better job than you did! In 
this chapter, we’re going to look at some design principles that people have come up 
with over the years, and how they can make you a better programmer. Lay aside your 
thoughts of “doing it your way”; this chapter is about doing it the smarter, faster way.
design principles
Design principle roundup 
 
 
 
 
376
The Open-Closed Principle (OCP) 
 
 
 
377
The OCP, step-by-step 
 
 
 
 
379
The Don’t Repeat Yourself Principle (DRY) 
 
 
382
DRY is about one requirement in one place 
 
 
384
The Single Responsibility Principle (SRP) 
 
 
390
Spotting multiple responsibilities 
 
 
 
392
Going from multiple responsibilities to a single responsibility 
395
The Liskov Substitution Principle (LSP)  
 
 
400
Misusing subclassing: a case study in misuing inheritance 
 
401
LSP reveals hidden problems with your inheritance structure 
402
Subtypes must be substitutable for their base types 
 
403
Violating the LSP makes for confusing code 
 
 
404
Delegate functionality to another class  
 
 
406
Use composition to assemble behaviors from other classes  
408
Aggregation: composition, without the abrupt ending 
 
412
Aggregation versus composition 
 
 
 
413
Inheritance is just one option  
 
 
 
414
Bullet Points 
 
 
 
 
 
417
OOA&D Toolbox  
 
 
 
 
418
The Open-Closed 
Principle
The Don’t Repeat 
Yourself Principle
The Single 
Responsibility Principle
The Liskov 
Substitution 
Principle

xix
table of contents
9
The Software is Still for the Customer
It’s time to show the customer how much you really care. 
Nagging bosses? Worried clients? Stakeholders that keep asking, “Will it be done on 
time?” No amount of well-designed code will please your customers; you’ve got to 
show them something working. And now that you’ve got a solid OO programming 
toolkit, it’s time to learn how you can prove to the customer that your software 
works. In this chapter, we learn about two ways to dive deeper into your software’s 
functionality, and give the customer that warm feeling in their chest that makes them 
say, Yes, you’re deﬁ nitely the right developer for this job!
iterating and testing
Your toolbox is fi lling up 
 
 
 
 
424
You write great software iteratively 
 
 
 
426
Iterating deeper: two basic choices 
 
 
 
427
Feature driven development  
 
 
 
428
Use case driven development  
 
 
 
429
Two approaches to development 
 
 
 
430
Analysis of a feature 
 
 
 
 
434
Writing test scenarios 
 
 
 
 
437
Test driven development 
 
 
 
 
440
Commonality Analysis (redux) 
 
 
 
442
Emphasizing commonality 
 
 
 
 
446
Emphasizing encapsulation  
 
 
 
448
Match your tests to your design 
 
 
 
452
Test cases dissected... 
 
 
 
 
454
Prove yourself to the customer 
 
 
 
460
We’ve been programming by contract  
 
 
462
Programming by contract is about trust  
 
 
463
Defensive programming 
 
 
 
 
464
Break your apps into smaller chunks of functionality 
 
473
Bullet Points 
 
 
 
 
 
475
OOA&D Toolbox  
 
 
 
 
478
Unit
type: String
properties: Map
id: int
name: String
weapons: Weapon [*]
setType(String)
getType(): String
setProperty(String, Object)
getProperty(String): Object
getId(): int
setName(String)
getName(): String
addWeapon(Weapon)
getWeapons(): Weapon [*]
All the properties 
that were common 
across units are 
represented as 
variables outside of 
the properties Map.
Each of the new 
properties gets its 
own set of methods.
Sam figured that id 
would get set in the Unit 
constructor, so no need 
for a setId() method.

xx
table of contents
10
Putting It All Together
Are we there yet? We’ve been working on lots of individual ways to 
improve your software, but now it’s time to put it all together. This is it, what 
you’ve been waiting for: we’re going to take everything you’ve been learning, 
and show you how it’s all really part of a single process that you can use over 
and over again to write great software. 
the ooa&d lifecycle
Developing software, OOA&D style 
 
 
484
The Objectville Subway problem 
 
 
 
488
Objectville Subway Map 
 
 
 
 
490
Feature lists 
 
 
 
 
 
493
Use cases refl ect usage, features refl ect functionality 
 
499
Now start to iterate  
 
 
 
 
503
A closer look at representing a subway  
 
 
505
To use a Line, or not to use a Line 
 
 
 
514
Points of interest on the Objectville Subway (class) 
 
520
Protecting your classes 
 
 
 
 
523
Break time 
 
 
 
 
 
531
Back to the requirements phase 
 
 
 
533
Focus on code, then focus on customers  
 
 
535
Iteration makes problems easier 
 
 
 
539
What does a route look like?  
 
 
 
544
Check out Objectville for yourself! 
 
 
 
548
Iteration #3, anyone? 
 
 
 
 
551
The journey’s not over... 
 
 
 
 
555
Feature 
List
Use Case 
Diagrams
Break Up the 
Problem
Requirements
Domain 
Analysis
Preliminary 
Design
Implementation
Delivery
Requirements List
L
Key Feature List
Class Diagram
Alternate Path
ak Up the 
Analysis
ements Lis
nts
Alternate Path
Design Pattern
Impleme
I
l
Encapsulation
Design Pa
Design Pa
Design
psulation
D
OO Principles
e
External Initiator
Analysis
Analysis
A
Textual Analysis
Test Scenario
Cohesion
Problem
p
roblem
Problem
roblem
Commonality
External I
quirement
quirement
ernate Pat
Requirement
Req
th
Alte
Req
Req
Alt
A
R
Scenario
Requireme
R
ernate Pat
Alte
R
A ernate Pat
Alte
A
Iteration
ntation
t
ion
D l
ntation
Feature Driven Development
Break Up the
k Up the
Analysis
e
s
E
R
s
E
R
S
A
l
Architecture
Commonality
al
Delegation
Impleme
t Sc
n Feature Driven
Test Driven Development
Analy
Cla
y
Architecture
Feature 
Li t
Use Case 
Di
A
Talk to the Customer
A
Ite
elegation
Variability
attern
es
D li
D
r
D li
Design Principles
nary
Design Pattern
ents List
ents Lis
nts L
Textual A
t
tual A
Arch
Iteration
gn
s
hesion
Tes
sis Coh
C
ure
gn
sis Coh
i
sis C h
Iteration
Test
Test
Development
T
p
Iteration
Domain
A
l
i
s
D
A
s
h
Dom
s
D
Analysis
A
tsts
th
ts
t
Prelimin
D
De
Desig
Desig
D
ig
Desig
Dom
Talk to the Customer
cap
ap
nary Enc
tern
Prelimin
P
li i
esign Patt
me
Encapsulation
nit
nitiator
ia
De
De
T lk to the Custo
esig
esi
om
om
E
Key Feature List
ass Diagram
a
hesion
Coh
Ite
Design Principles
List
Diagrams
List
Di
List
re List
C
De
External Initiator

xxi
table of contents
i
The Top Ten Topics (we didn’t cover)
Believe it or not, there’s still more. Yes, with over 550 
pages under your belt, there are still things we couldn’t cram in. Even 
though these last ten topics don’t deserve more than a mention, we didn’t 
want to let you out of Objectville without a little more information on each 
one of them. But hey, now you’ve got just a little bit more to talk about 
during commercials of CATASTROPHE... and who doesn’t love some 
stimulating OOA&D talk every now and then?
appendix i: leftovers
#1. IS-A and HAS-A 
 
 
 
 
558
#2. Use case formats 
 
 
 
 
560
#3. Anti-patterns  
 
 
 
 
563
#4. CRC cards 
 
 
 
 
 
564
#5. Metrics 
 
 
 
 
 
566
#6. Sequence diagrams 
 
 
 
 
567
#7. State diagrams  
 
 
 
 
568
#8. Unit testing 
 
 
 
 
 
570
#9. Coding standards and readable code 
 
 
572
#10. Refactoring 
 
 
 
 
 
574
Class:  DogDoor
Description: Represents the physical dog door. This provides an interface 
to the hardware that actually controls the door.
Responsibilities:
Name
Collaborator
Open the door
 
Close the door
Be sure you write 
down things that 
this class does on its 
own, as well as things 
it collaborates with 
other classes on.
There’s no collaborator 
class for these.
Anti Patterns
Anti-patterns are the reverse of design pat-
terns: they are common BAD solutions to 
problems. These dangerous pitfalls should 
be recognized and avoided.

xxii
table of contents
ii
Speaking the Language of OO
Get ready to take a trip to a foreign country. It’s time to 
visit Objectville, a land where objects do just what they’re supposed to, 
applications are all well-encapsulated (you’ll find out exactly what that means 
shortly), and designs are easy to reuse and extend. But before we can get 
going, there are a few things you need to know first, and a little bit of language 
skills you’re going to have to learn. Don’t worry, though, it won’t take long, and 
before you know it, you’ll be speaking the language of OO like you’ve been 
living in the well-designed areas of Objectville for years.
appendix ii: welcome to objectville
UML and class diagrams	
	
	
	
	
577
Inheritance	
	
	
	
	
	
579
Polymorphism	
	
	
	
	
	
581
Encapsulation	
	
	
	
	
	
582
Bullet Points	
	
	
	
	
	
586
Airplane
speed: int
getSpeed(): int
setSpeed(int)
This is how you show a 
class in a class diagram. 
That’s the way that 
UML lets you represent 
details about the classes 
in your application.
This is the name of 
the class. It’s always 
in bold, at the top of 
the class diagram.
These are the member 
variables of the class. 
Each one has a name, 
and then a type 
after the colon.
This line separates 
the member variables 
from the methods of 
the class.
These are the 
methods of the 
class. Each one has 
a name, and then 
any parameters the 
method takes, and 
then a return type 
after the colon.
A class diagram makes it really easy 
to see the big picture: you can easily 
tell what a class does at a glance. 
You can even leave out the variables 
and/or methods if it helps you 
communicate better.


























































































































































































































































































































































































































































































































































































































This is the index  591
Index
Numbers
3DBoard, solving without inheritance  405
A
abstract base class  200–203, 212
abstracting behavior  205
abstraction  243
actors  294, 299, 300, 302
aggregation  208, 412–417, 414, 558
versus composition  413
Airplane class  577
alternate paths  70, 85–87
dog door  123
dog door requirement changes  120
questions and answers  125
analysis  xiii–xxii, 145–196, 283
identifying problems  148
planning solutions  149
textual  169
use cases and  151
Analysis and Design Puzzle  510, 536–538
anonymous class  82
anti patterns  563
architecturally significant features  331
architecture
defined  326–328
purpose of  351
three questions  332
Architecture Puzzle  340
revisited  345
solution  346–347
array of arrays  347
association  194
attributes  194
B
Bark object  158, 159
multiple  165
BarkRecognizer.java  131, 132, 135
Don’t Repeat Yourself Principle  382
BarkRecognizer class  132, 135, 159
delegation  161
questions and answers  132
recognize() method  160, 189
base classes, modifying  381
behavior
of subclasses  241
reusing from other classes  414
Be the Browser  333, 334, 365, 437, 438
big problems
breaking into smaller pieces  281, 309, 310–314
looking at  281
versus little problems  280
Board class  346, 348, 349, 364
boolean property versus numStrings property  39
Bullet Points  106, 142, 191, 320, 372, 417, 475, 586
C
cancel() method (TimerTask anonymous class)  82
case diagrams, versus use cases  77
change  228
constant in software development  115
changing requirements  115
checked exception  470

the index 
592 
index
class diagrams  19, 194
abstract classes  206
annotating guitar application  39
dissected  182–183
Guitar  29
limitations  187
subclasses  206
UML and  577
what’s missing  188, 190
classes, protecting  523
clear value  74, 75, 98, 100
closed for modification  377–381, 417, 418
code, robust  18
coding standards  572
cohesion  269–276
collections  251
commonality  355–361, 367, 441–450
commonality-focused solution  450
emphasizing  446–447
commonality analysis  361, 367
common behavior  205
composition  408–417, 414, 558
assembling behaviors from other classes  408
ownership and  411
versus aggregation  413
when to use  409
Connection class  514, 517
constant in software analysis & design  115
context  147
contract, programming by  461–463
coordinating movement  337, 366, 367
CRC cards  564–565
customer’s language  306
customer goal  72
customers
listening to  63
satisfying  12
understanding customer’s requirments  65
D
death of a design  246
Decorator Pattern
disadvantages  92, 126, 341, 343
interview  92, 126, 341, 343
defensive programming  464–465
delegation  43, 45, 162, 414, 504
3DBoard  406
BarkRecognizer class  161
DogDoor class (Sam’s)  160
versus inheritance  407
when to use  407
design
death of a  246
preliminary  485
design lifecycle  273
design patterns  8, 10, 22, 34, 50, 52, 313, 315, 316, 319, 
563
design principles  376, 377, 380, 400, 415
writing your own  141
Dessert interface  230
DessertService class  230
dog door
alternate paths  123
automatically closing  82
barking focus  172
coding changes in  131
final test drive  140
main path  123
planning for things going wrong  68–71
single scenario  124
Todd and Gina’s Dog Door  387, 389
updating after analysis  152
where code should go for closing door  138
DogDoor.java  57, 59, 131, 135, 139, 140
Don’t Repeat Yourself Principle  383
gathering requirements  61
test drive  59
second  83

the index
you are here  593
DogDoor class  59, 135
allowedBarks attribute  183
updating  139
DogDoor class (Sam’s)  158
delegation  160
Dog Door Class Diagram (Maria’s)  180
DogDoorSimulator.java  59, 83, 88–90, 131, 134, 135, 192
code magnets  88, 90
test drive  89
DogDoorSimulator class  59, 135
updating  134
domain analysis  306, 313, 317, 320, 485
Don’t Repeat Yourself Principle (see DRY)  382
double encapsulation  249
DRY (Don’t Repeat Yourself Principle)  382–388
main idea  384
E
encapsulate what varies  115–116
encapsulation  28, 34, 52, 226, 231, 243, 245, 282, 504, 
582, 585
Bullet Points  50
double  249
emphasizing  448–449
guitar specifications  41
OCP and  381
questions and answers  31
enumerated types  16
enums  16–18
equals()
Java’s default  521
overriding  516
RouteFinder  521
essence of a system  332, 335
external initiator  74, 75, 93, 94, 98, 100
F
feature analysis  434–435
feature driven development  427, 428, 433, 475, 478
versus use case driven development  430–432
feature lists  484, 495
Feature Magnets
RouteFinder feature list  497
Feature Puzzle  474
solutions  476–477
features  290
architecturally significant  331
interpreting  366
mapping to use case diagrams  298, 300
versus requirements  292
versus use cases  499, 500
Final CATASTROPHE!  230
FindGuitar.java
updating  42
FindGuitar class  33
FindInstrument.java  259, 260
initializeInventory() method  261
test driving  261, 264
flexibility  34, 49, 52, 380
interfaces and  224
versus functionality  535
fragile  18
Friedman, Dan  301
functionality  34, 52, 324, 329, 330, 342, 345, 364, 371, 
374, 499
breaking applications into smaller chunks of  473
versus flexibility  535
G
game-specific units  352–353
game system framework (GSF)  284
Gary’s Games
customer conversations  288–289
features  290
vision statement  284


the index 
594 
index
Gary’s Game System Framework
coordinating game movement  365
feature list  305, 324, 329
determining significance  333, 334
key features  336, 350, 363, 371
risk  338
getNumStrings() method (GuitarSpec.java)  42, 44
good enough software  274–275
graph structure  515
great software
3 steps to  215, 216
consistently writing  48
satisfying customers  12
three easy steps  13
what does this mean?  10
Guitar.java
adding class for mandolins  208
encapsulating properties of GuitarSpec  45
Guitar class diagram  29
GuitarSpec.java
adding new property  44
getNumStrings() method  42, 44
numStrings property  42, 44
GuitarSpec class  29, 210
adding property to  40
encapsulating properties of  45
questions and answers  31
H
HAS-A  558–559
hashCode( ), overriding  516
Head First Labs website  17
Head First learning principles  xxvi
I
implementation  485
inheritance  243, 380, 558, 579
alternatives  405, 414
hidden structure problems  402
misusing  401
versus delegation  407
(see also LSP) 
instrument-specific subclasses
killing  247
Instrument.java  208
Instrument abstract base class  201
instrument application
ease-of-change challenge  266–269
Instrument class
adding new subclasses  218
completed class diagram  201
extending  208
updated  252
InstrumentSpec  203–220
creating abstract class for  209
making concrete class  237–238
matches( ) method  378
InstrumentSpec.java  209
InstrumentSpec class
updated  252
InstrumentType.java  256
InstrumentType enum  256
interface  224, 226, 230, 232
coding to an  282
Inventory.java  212, 256
making sure is well designed  37
search( ) method  37, 42, 45, 237
Inventory class  32
addInstrument() method  241
updating  256
updating to work with multiple instrument types  212
Inventory Roundup  260
solutions  262–263
IS-A  558–559
iterating over all choices (guitar application)  23
iterative design  503, 530, 539
iterative development  475, 485

the index
you are here  595
J
Java’s default equals()  521
L
Line class  514
Liskov Substitution Principle (see LSP)
LoadTester class  529
loosely coupled  162
LSP (Liskov Substitution Principle)  400–405, 412–418
hidden structure problems  402
violating  404
M
main path  92, 99, 101
dog door  123
Mandolin.java  208
MandolinSpec.java  211
MandolinSpec class  200, 202, 205, 211
Map for storing properties  253, 254
Method Magnets  525
solutions  526
metrics  566
mismatched object type  27
Model-View-Controller pattern (see MVC pattern)
multiplicity  165, 183, 194
MVC pattern  314
N
noun analysis  194
nouns in use cases  167, 175
numStrings property (GuitarSpec.java)  42, 44
numStrings property versus boolean property  39
O
Object-Oriented Analysis & Design (see OOA&D)
Object Oriented Design Principles  141
objects
concepts  27
forwarding operation to another object  43
naming  27
ObjectvilleSubway.txt file  527
Objectville Subway Map  490–491
OCP (Open-Closed Principle)  49, 377–381, 400, 417, 418
step-by-step  379
OOA&D (Object-Oriented Analysis & Design)  48, 49, 50
power of  318–319
process overview  484
OOA&D Cross  51, 107, 143, 195, 277, 321, 373, 419, 
479, 552
OOA&D Magnets  487, 549
solutions  550
OOA&D Toolbox  276, 320, 418, 478
more tools for  142
tools  106
OO CATASTROPHE!  223–232
OO Cross  587
OO Principles  232
Open-Closed Principle (see OCP)
open for extension  377, 378, 381, 417, 418
operation  194
optional paths  120
P
Painter class  226
Patterns Exposed  92, 126, 341, 343
placeholders  201
planning for things going wrong  68–71
polymorphism  243, 581
pressButton()  xii, 136, 139

the index 
596 
index
programming
by contract  461–463, 471
versus defensive programming  466–468
defensively  464–465, 471
properties
storing  250, 251, 253
that vary across objects  251
unused  27
protecting classes  523
R
readable code  572–573
refactoring  574
relationships  326, 331, 343, 351, 353
Remote.java  59, 135, 140
Don’t Repeat Yourself Principle  382
Remote class  58, 59, 135
automatically closing door  82
code magnet solutions  108
remote control
simplifying  139
requirements  93, 94, 484
changes  xii–xxii, 111–144
changes in use cases  129
checking against use cases  78
creating list of  64, 66
defined  62
gathering  xi–xxii, 55–110
good  67, 142, 282
list  81
list, checking  133
list for changes to dog door  130
questions and answers  67
versus features  292
requirements list  286
reusable  49
reusable design  36


Rick’s Search Tool  3–54
download  33
encapsulation  28
iterating over all choices  23
looking deeper for problems  25
making well-designed and flexible  234–235
mismatched object type  27
problems with  6
revisiting problems  14
String comparisons  16
search( ) method  21, 22
analyzing  26
test drive  23, 46
risk  338, 339
reducing  349, 362, 371
use cases and  341
robust code  18
RouteFinder  488–556
back to requirements phase  533
breaking into modules  501, 502
closer look at representing a subway  505
coding
Station class  516
Connection class  514, 517
different output sources  551
feature list  532
getDirections() method  544
iterative design  503, 530, 539
Line class  514
LoadTester class  529
more extensible loading  551
statement of work  488
Station class  514
Subway class  514
coding  519
equals( )  520
hashCode( )  520
subway file  506
SubwayLoader class  524
SubwayPrinter class  545
SubwayTester class  547
textual analysis  510–513
RuntimeException  470

the index
you are here  597
S
satisfying customers  12
scenarios  73
Board interface  342, 344
questions and answers  125
risk and  343
single, for dog door  124
search( ) method (guitar application)  21, 22
analyzing  26
search( ) method (Inventory.java)  37, 42, 45
seeing the big picture  294–295
sequence diagrams  567
Sharpen your pencil
adding support for mandolins to search tool  199
answers  200
analysis  149
answers  150
annotating guitar application class diagram  39, 40
breaking RouteFinder into modules  502
Connection class  517
answers  518
designing test cases  455
answers  456
design principle  141
Dog class, not including  174
answers  179
DogDoor class
allowedBarks attribute  183, 185
dog door requirements  65
drawing class diagram for updated instrument applica­
tion  257
game-specific units  353
answers  354
Gary’s Games, things to do first  285
Gary’s Games features  291, 303
answers  290, 304
Gary’s Game System Framework
most important features  330
great software  11
guitar application  7, 19
GuitarSpec object  29, 30
instrument-specific subclasses  239, 240
Inventory.java  37
letting GuitarSpec handle comparisons  53
OCP, finding in your project  381
OO principles  243
answers  244
potential Unit properties  442–443
answers  444–445
power of use cases  104
reasons requirments might change  115
requirements for dog door  79
answers  80
risk  339
rodents getting into kitchen  60
RouteFinder feature list  493
answers  494
scenarios in use cases  127
answers  128
scenario testing  135
answers  136
skeleton for Airplane class  577
answers  578
SRP, applying to automobile class  393
answers  394
structure for RouteFinder code  496
answers  498
Unit class programming contract  469
answers  470
use case for Get directions  533
use case for loading subway lines  503, 507
answers  504, 508
use case nouns  167
answers  168
use cases  95
real power of  102–103
real power of, solution  104–105
writing more  96–97
use case to store a bark  153
answers  153
value of encapsulating your data  583
answers  584
writing code based on class diagram  157
answers  158

the index 
598 
index
software
good enough  274–275
great (see great software)
well-designed  217
software, great  283
software release  485
solutions, questions and answers  151
SRP (Single Responsibility Principle)  49, 390–399, 504
analysis  392
going from multiple to single  395
SRP Analysis
CRC cards and  565
SRP Sightings  396–397
answers  398–399
start condition  93, 94
statechart diagram  568–569
state machine diagrams  568–569
Station class  514
coding  516
String comparisons  16
Style.java  211
subclasses
adding new instruments  218
behavior of  241
behavior versus properties  242
instrument-specific
killing  247
misusing  401
standing in for superclass  581
versus abstract base classes  201
subtype must be substitutable for its base type  403
Subway.java
implementation  540–542
Subway class  514
coding  519
equals( )  520
hashCode( )  520

SubwayLoader class  524
making sure correctly loads in all stations and 
connections  527
SubwayPrinter class  545–546
SubwayTester class  547
system boundary  296
T
terrain types  309
test cases  454, 477, 571
test driven development  440
Test Puzzle  457, 527
solution  528–530
solutions  458–459
test scenarios
Unit class  437–439
textual analysis  169, 173, 174, 189, 510
code magnets  177
solution  178
The Little Lisper  301
There are no Dumb Questions
advanced OO techniques  222
aggregation  415
alternate paths  125
array of arrays  347
BarkRecognizer class  132
class diagrams  19, 578
cohesion  271
commonality  445
commonality versus variability  369
composition  415
deciding between design choices  451
defensive programming  465
delegation  43, 415
DessertService class  230
Don’t Repeat Yourself Principle  385
encapsulation  31, 34, 585
enumerated types  16
equals( )  521
essence of a system  335

the index
you are here  599
features versus requirements  293, 494
fewer classes and flexibility  255
FindInstrument.java, getting different results  264
hasConnection() method  528
holding off writing code  364
inheritance  415
Instrument class  213
making Instrument abstract  203
matching up every feature to a use case  500
multiple solutions  151
nouns and verbs in use cases  179
OCP  381
options  550
polymorphism  581
programming by contract  471
reducing risk  362
repeated steps in use case  515
requirements  67
RuntimeException  470
scenarios  125
Single Responsibility Principle  391
SRP analysis  395
steps in coding  22
subclassing  415
test cases  456
test driven development  440
textual context  173
Tile and Unit classes  349
Timer class  82
UML  207
unit testing  570
use case diagrams  299
use cases  77
use cases for storing a bark  154
uses cases and risk  345
validation  508
Thread class, using to close door  82
Tile.java  348
Tile class  348, 349
tiles  309
time periods  309
Timer class
using to close door  82
TimerTask anonymous class
cancel() method  82
U
UML and class diagrams  577
UML Cheat Sheet  207
UML diagrams  181, 184
Unit.java  348
Unit class  348, 349, 435–437
class diagram  441
matching tests to design  452
programming by contract  462–463
test scenarios  437–439
writing  453
UnitGroup class  476–477
units  309
finding what is common between  355
game-specific (see game-specific units)
moving  472
unit testing  570–571
upgradable  49
use case diagrams  296–297, 305, 484, 495
mapping features to  298
use case driven development  427, 429, 475, 478
versus driven development  430–432
use cases  71–86, 286
analysis and  151
changes and requirements  129
checking against requirements  78
clear value  74
definite starting and stopping point  74
exposed  92, 126
external initiator  74
formats  560–562
Get directions  533
answers  534
identifying classes to use  170

the index 
600 
index
use cases (continued)
loading subway lines  507
checking flow  509
Load network of subway lines  527
magnets  75, 98–99
solution  76, 100
nouns  167, 175
questions and answers  77
real power of  102
risk and  341
seeing the big picture  294
storing a bark  153
three parts  74
updating after analysis  152
verbs  176
versus case diagrams  77
versus features  499
writing so not confusing  122–123


























V
validation  508
variability  356, 358, 360, 442, 444, 445
verb analysis  194
verbs in use cases  176
vision statement  284, 286
W
Weapon interface  408–410
well-designed software  217
Who Am I?  416, 468
solutions  420, 481

