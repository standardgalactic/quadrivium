M A N N I N G
IN ACTION

Advance Praise for Flex Mobile in Action
A must-read for anyone thinking of doing mobile apps. It’s simple enough for the novice 
and deep enough for the pros.
—Ken Brueck 
Director of User Experience, Protoven
Flex Mobile is cross-platform development at its best.
—Andrew Grothe 
Developer, zedIT Solutions 
An excellent introduction to the powerful ability of Flex and AIR to target 
multiple mobile platforms.
—Kirsten Schwark 
Senior Software Developer, iDashboards 
Great cutting-edge techniques for mobile apps developers!
—Bill LaPrise
Owner/Developer, c3works
A very detailed and complete look at cross-platform mobile development 
with Flex. Lots of great examples explaining the whats, hows, and whys 
of mobile Flex development.
—Brian Genisio 
Senior Software Consultant, SRT Solutions
Very handy code snippets, both for novice and day-to-day development.
—Fabien Nicollet
GIS Software Engineer, Business Geografic
It gets you building multi-platform real-world mobile apps in no time while 
acquainting you with best coding practices and techniques.
—Alexandre Madurell
R&D Analyst Programmer, KIT digital
Get mobile applications running quickly with Flex on AIR. Very good for 
learning, with extremely reusable examples.
—Doug Warren 
Software Architect, Java Web Services

Flex Mobile
in Action
JONATHAN CAMPOS
M A N N I N G
SHELTER ISLAND, NY

For online information and ordering of this and other Manning books, please visit
www.manning.com. The publisher offers discounts on this book when ordered in quantity. 
For more information, please contact
Special Sales Department
Manning Publications Co.
20 Baldwin Road
PO Box 261
Shelter Island, NY 11964
Email: orders@manning.com
©2012 by Manning Publications Co. All rights reserved.
No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in 
any form or by means electronic, mechanical, photocopying, or otherwise, without prior written 
permission of the publisher.
Many of the designations used by manufacturers and sellers to distinguish their products are 
claimed as trademarks. Where those designations appear in the book, and Manning 
Publications was aware of a trademark claim, the designations have been printed in initial caps 
or all caps.
Recognizing the importance of preserving what has been written, it is Manning’s policy to have 
the books we publish printed on acid-free paper, and we exert our best efforts to that end. 
Recognizing also our responsibility to conserve the resources of our planet, Manning books
are printed on paper that is at least 15 percent recycled and processed without the use of 
elemental chlorine.
Manning Publications Co.
Development editor: Cynthia Kane
20 Baldwin Road
Technical proofreader: Kevin Korngut
PO Box 261
Copyeditor: Linda Recktenwald
Shelter Island, NY 11964
Proofreaders: Melody Dolab, 
Nermina Miller 
Cover designer: Marija Tudor
ISBN 9781617290619
Released as eBook only, May 2012

iv
brief contents
PART 1
GETTING STARTED........................................................ 1
1
■
 Getting to know Flex Mobile
3
PART 2
MOBILE DEVELOPMENT WITH FLEX ............................. 15
2
■
Get going with Flex Mobile
17
3
■
Persisting data
54
4
■
Using your device’s native capabilities
78
5
■
Handling multiresolution devices
128
PART 3
ADVANCED MOBILE DEVELOPMENT .............................155
6
■
MVC with mobile applications
157
7
■
Architecting multiscreen applications
218
8
■
Extending your mobile application
246
9
■
Effective unit testing
267
10
■
The almighty application descriptor
291
11
■
Building your application with Flash Builder
310
12
■
Automated builds using Ant
324

v
contents
PART 1 GETTING STARTED ...............................................1
1 
Getting to know Flex Mobile
3
1.1
Learning key terms
4
1.2
Deciding between native and cross-platform
4
1.3
What’s Flex Mobile?
6
What language am I coding in?
7
■What runs our code?
7
1.4
Hello World
8
Prerequisites
8
■Creating a new application
9
1.5
Introducing a running example
11
The roadmap for our example
12
■Public APIs and Rotten 
Tomatoes
12
■The RottenTomatoesAS3 API
13
1.6
Summary
14
PART 2 MOBILE DEVELOPMENT WITH FLEX .....................15
2 
Get going with Flex Mobile
17
2.1
Starting up your application
18
Creating a TabbedViewNavigatorApplication
19
The views
21

vi
2.2
Running your application
23
Desktop run/debug configurations
23
■Adding a device 
configuration
27
■Device run/debug configurations
29
2.3
Building your first application views
29
Navigating your application with the ViewNavigator
29
Providing context with the ActionBar
35
■Updating the main 
application
37
■Creating the browse view
38
■Creating the 
list view
42
■Creating the search view
48
■Creating the 
details view
50
2.4
Persisting navigator state
52
2.5
Summary
53
3 
Persisting data
54
3.1
Storing data with the local shared object
55
Creating a local shared object
57
■Interacting with a local shared 
object
57
3.2
Storing data using SQLite
60
Connecting to SQLite
62
■Creating a SQLite table
63
Reading from SQLite
65
■Writing to SQLite
67
Deleting from SQLite
68
■Updating a SQLite record
69
Adding public methods
70
■Integrating with 
SQLPersistenceManager
71
3.3
Simpler data storage with PersistenceManager
72
Interacting with PersistenceManager
73
■Implementing 
IPersistenceManager
74
3.4
Summary
77
4 
Using your device’s native capabilities
78
4.1
Creating a device capability testing app
79
Creating a new application
79
■Creating the menu view
80
Application descriptor file
82
4.2
Taking the same picture three different ways
84
Using the CameraUI the cross-platform way
86
■Using the 
getCamera() method
88
■Accessing the device’s camera roll
91
Camera permissions
94
4.3
Monitoring movement with the accelerometer
94
Listening to the accelerometer
95
■The values returned from the 
accelerometer
96

vii
4.4
Finding out where you are with geolocation
98
Adding the geolocation permissions
98
■Getting location from the 
geolocation sensor
99
4.5
Including the entire web with StageWebView
102
Connecting the StageWebView with the stage
103
■Setting the 
StageWebView location
104
■Setting the StageWebView 
content
105
4.6
Using gestures the right way, right away
105
Setting your touch input type
106
■Using gestures
107
Using touch points
109
4.7
Texts, emails, maps, and phone calls
112
Sending SMS messages with SMS
113
■Sending emails with 
mailto
114
■Navigating with Google Maps
115
■Making a 
phone call with tel
116
4.8
Recording sound with the microphone
117
Adding the microphone permission
117
■Connecting to the 
microphone
118
■Recording and playing back audio
120
4.9
Responding to OS-specific inputs
122
Android operating system buttons
123
■BlackBerry bevel 
gestures
125
4.10
Summary
127
5 
Handling multiresolution devices
128
5.1
Automatic scaling
131
Diving deep into automatic scaling
131
■Enabling automatic 
scaling
132
■Considerations with automatic scaling
133
5.2
Using media queries in CSS
133
Starting up the CSS file
134
■Adding color
136
■Overriding 
CSS based on DPI
138
■Adding in hardware-specific CSS media 
queries
141
5.3
Images for multiscreen projects
144
Organizing your images for multiscreen projects
144
Using the MultiDPIBitmapSource with an image
145
5.4
Overriding DPI returns to customize applicationDPI 
values
146
Finding the capabilities values for each device
146
■Overriding 
the RuntimeDPIProvider
147

viii
5.5
Splash screens
148
Basic splash screen
148
■Multiresolution splash screen
152
5.6
Summary
154
PART 3 ADVANCED MOBILE DEVELOPMENT....................155
6 
MVC with mobile applications
157
6.1
What is Robotlegs?
161
How Robotlegs works
163
6.2
Hitting the ground running with Robotlegs
169
Creating the context shell
169
■Connecting the context and 
starting up the application
171
6.3
Separating your services
173
Creating your public methods
174
■Transferring your result and 
fault events
177
■Mapping your service events to service 
commands
181
6.4
Refactoring your data into models
186
Creating your model shell
188
■Including the models in your 
context
195
■Creating your state model
196
6.5
Splitting your code into views and mediators
201
Creating the view
202
■Wiring up your mediators
204
Adding handler methods
206
■Connecting and disconnecting 
your mediator
207
6.6
Application upgrade
210
Changing the main application
211
■Building the 
ApplicationMediator
214
6.7
Summary
217
7 
Architecting multiscreen applications
218
7.1
Laying out a multiscreen application
219
Hub library
220
■Spoke applications
220
7.2
Libraries
221
What’s a Flex library?
221
■Setting up the library
223
Creating your base context
225
7.3
Android application
227
Setting up your Android application
228
■Customizing the 
view/mediators for Android capabilities
231

ix
7.4
Creating your QNX-specific application
233
Setting up the QNX application
233
■Customizing the view/
mediators for QNX capabilities
236
7.5
Creating your iOS-specific application
240
Setting up the iOS platform application
241
■Customizing the 
view/mediators for iOS capabilities
242
7.6
Summary
245
8 
Extending your mobile application
246
8.1
Making money by adding ads
246
Not all platforms support ads
246
■Not all ad systems are created 
equal
247
■Be honest or be punished
247
■Integrating with 
Google AdSense
248
■Creating the HTML page
250
Integrating ads into your application
251
8.2
Native extensions
254
Including native extensions
255
■Using a native 
extension
259
8.3
Useful user tracking
259
Using Google Analytics for Flash
260
■Plugging in 
tracking
262
■Integrating with tracking events in an 
application
265
8.4
Summary
266
9 
Effective unit testing
267
9.1
What is unit testing?
267
Test-driven development
268
■Test-behind development
268
Flying blind
268
9.2
Testing terms
269
Test suite
269
■Test case
270
■Test method
270
Assert
271
■What do you unit test?
271
9.3
Synchronous unit tests
272
Creating a RendererUtil class
272
■Testing a utility class
273
9.4
Asynchronous test for event-driven tests
279
Testing a service call
279
■Writing the tests
281
9.5
Running tests from the IDE
283
Using Flash Builder to run FlexUnit tests
283
Creating an application to run FlexUnit tests
287
9.6
Summary
290

x
10 
The almighty application descriptor
291
10.1
General application descriptor settings
291
AIR version
292
■The all-important application ID
292
Application name and filename
293
■Version number
293
Initial window settings
294
■Application icons
295
Certificate file
296
10.2
Customizing your Android permissions
296
Available permissions
297
■Filtering permissions
298
Permission features
299
10.3
QNX permissions for deployment
302
Available permissions
302
■QNX splash screen and icon
303
Categories
304
10.4
Key points to iOS permissions
305
Filtering by device
305
■Enabling features
306
10.5
Summary
309
11 
Building your application with Flash Builder
310
11.1
Exporting a release build with Flash Builder
310
11.2
Android release process
311
11.3
QNX release process
314
11.4
iOS release process
319
11.5
Releasing to markets
322
11.6
Summary
323
12 
Automated builds using Ant
324
12.1
Building with Ant
324
Ant terms
325
■Running Ant
327
12.2
Your build setup
329
Prepping your property files
330
■aying out your build 
file
331
12.3
Using Ant to run FlexUnit
332
Updating your Test Runner application
334
■The FlexUnit Ant 
target
336
12.4
Showing off your code with ASDocs
338
Start by cleaning your old docs
338
■Building your 
ASDocs
338

xi
12.5
Building your library
340
Completing the build target
340
■build-library target
342
12.6
Packaging for Android
342
Compiling the Android project
344
■Packaging the Android 
project
345
12.7
Packaging for QNX (BlackBerry)
348
Compiling the QNX project
350
■Packaging the QNX 
project
352
■Double-signing the BAR file
354
12.8
Packaging for iOS
355
Compiling the iOS project
357
■Packaging the iOS 
project
358
12.9
Final steps
361
FlexPMD, FlexCPD, and FlexMetrics
361
■Master build 
file
362
12.10
Summary
363

xii
preface
It has been almost two years now since Adobe started releasing super-secret early betas
of their mobile AIR runtimes and Flex framework. During that time, only a select few
were kicking the tires and seeing what was possible while waiting for more phones to
successfully run Android 2.2 and the iPhone packager to be completed.
 Fast forward a few months, and it’s October. Seconds after Adobe pushes up the
first versions of AIR for Android, I’m pushing up the first early version of my well-
received Queue Manager application—the first AIR for Android application on the
Android Market. Within a few months, planning on multiple projects for various proj-
ects is at full speed and many clients are adopting AIR and Flex for their mobile enter-
prise applications.
 If we fast-forwarded a few more months, we’d see Queue Manager being used by
more than 20,000 unique users daily and having over 500,000 downloads. Between
personal and professional projects, I’ve created around a dozen mobile applications
that use Flex and AIR, and I was fortunate enough to be asked by Manning if I would
write a book about my experiences building Flex applications for the mobile environ-
ment. Originally, the request was to make a book showing how to use Flex to make
Android applications, but, as Flex developers, we know that we can do better and that
cross-platform development is the name of the game.
 I’m proud to put into one book a collection of resources, examples, and explana-
tions that will help new Flex developers transition from desktop- and browser-based
applications to the mobile world, and assist any developers that want to make visually
stunning applications that execute consistently across multiple platforms with a singu-
lar and elegant code base.

xiii
acknowledgments
Over the last few years, there have been many people that inspired me, leading me to
this point of actually releasing a book—something I said I would never do. First and
foremost, this book is created for the Flex community, a group of friends and col-
leagues that work together cohesively to help each other through the daily struggles
of development.
 Beyond the community, I would like to thank Cynthia Kane for managing the
creation of this book, along with Troy Mott, Bert Bates, and the rest of the Manning
team. Within Manning, I would also like to give special thanks to Linda Recktenwald,
Melody Dolab, and Mary Piergies for making my techno babble readable.
 Next, I’d like to give a special thank you to Kevin Korngut for going through all
my code and making sure that I didn’t leave any late-night programming errors in
the code.
 I would like to thank the following reviewers who read the manuscript at various
stages during its development; their feedback made this a better book: Jason
Fincanon, Antonio Holguin, Brian Genisio, Ken Brueck, Andrew Grothe, Alexandre
Madurell, William LaPrise, Fabien Nicollet, Doug Warren, and Kirsten Schwark.
 Finally, I want to say a special thank you to my family for their lifelong support and
to my wonderful girlfriend—my continuous source of inspiration.

xiv
about this book
This book is about building Flex applications using the Adobe AIR runtime for multi-
ple mobile devices. More than just focusing on the coding conventions, this book
focuses on how to build a fully featured mobile application as well as all on the various
aspects of mobile application development.
 Going beyond development and new Flex mobile features, this book integrates
often-requested and extremely useful application development features such as unit
testing, user tracking, MVC, Robotlegs, and ANT deployment. Utilizing every tool in
your tool belt will give you the ability to create fully featured enterprise applications
using Flex’s and AIR’s new mobile features.
 Some developers may feel that these other features exist outside of the require-
ments for a Flex mobile development book. To these developers I would say that I’ve
included most of the typical needs for Flex mobile application developers—whether
the problem is Flex specific or not.
Roadmap
■
Chapter 1 starts with a general introduction to Flex mobile, mobile develop-
ment, and a simple Hello World example.
■
Chapter 2 hits the ground running by kicking off the Rotten Tomatoes Applica-
tion, setting up some views, and running the application on your desktop and
mobile device.
■
Chapter 3 builds upon chapter 2 by introducing data persistence to your appli-
cation using Local Shared Objects, SQLite, and the new PersistenceManager.

xv
■
Chapter 4 diverges from the main application, creating a new application and,
specifically, showing how to use various device capabilities with Flex.
■
Chapter 5 returns to the Rotten Tomatoes application and updates your appli-
cation to work on a variety of devices, no matter the resolution or screen size of
the device.
■
Chapter 6 takes the Rotten Tomatoes application and gives it an industrial-
strength overhaul by introducing Robotlegs, an MVC micro-architecture.
■
Chapter 7 breaks up your Rotten Tomatoes application, enabling it to run
device-specific features while reusing the maximum amount of code.
■
Chapter 8 expands the Rotten Tomatoes application by introducing Native
Extensions, user tracking, and revenue-generating ads integration.
■
Chapter 9 goes beyond the Rotten Tomatoes application and builds in unit test-
ing.
■
Chapter 10 diverges from the Rotten Tomatoes application by focusing on the
Application Descriptor and all of the features enabled with this single file.
■
Chapter 11 shows how to use Flash Builder to create release-quality builds of
the application.
■
Chapter 12 rounds out the book by showing how to use ANT to automate the
build process of all the application’s parts.
Who should read this book?
This book is about building mobile applications using the Flex framework. As such,
this book targets two types of developers.
 The first are current Flex developers interested in taking their knowledge to the
next level and onto the mobile landscape. Whether you’ve used Flex to develop small
widgets or built entire applications, there’s much to learn about the new mobile para-
digms and best practices when building multi-screen applications. For current Flex
developers, I’ll discuss the new components optimized for mobile development, archi-
tecture strategies for multi-screen applications, and how to create applications that
look and run great across multiple devices and multiple screen sizes.
 The second type of developers that this book is intended for comes from other
languages and wants to create mobile applications. Rather than deciding to learn
Objective-C, Android Development, C++, C# or any of the other languages that create
installable mobile application, we can just use Adobe AIR coupled with Flex and build
applications that work on iOS, Android, BlackBerry, the web, and even the desktop
with a singular codebase. These developers are busy, hard-working, and ready to max-
imize their output. If you’re coming to Flex for the first time, you’ll quickly see how to
create MVC-based applications with Flex, use Flex to build mobile applications, and
release your mobile applications to each of the major markets. 

xvi
Code conventions and downloads
As this is a programming book, you can expect it to include many code samples, con-
figuration files, and other required listings to help you understand how to create Flex-
based mobile applications. Source code in listings or in body text is in a fixed width
font to separate it from ordinary text. In addition to code listings, ActionScript class
and method names, parameters, properties, along with HTML and XML elements will
also be presented using fixed width font. ActionScript method names within text will
not include the full method signature—the name and list of required parameters.
 Well-formatted code utilizes plenty of whitespace, improving readability, but a
book has limited space on a page, so I’ve had to condense the code listed in this
eBook. The full, nicely formatted, code can be found online in my GitHub account at
https://github.com/jonbcampos/Flex-Mobile-In-Action or on the publisher's website
at www.manning.com/FlexMobileinAction.
 Under each code listing I include the path to find the specific file being discussed
in the listing. This is meant to make finding full code segments as simple as possible.
In some rare cases not all of the code is shown in the book—mainly due to repetitive
code. Complete applications, including these missing segments, can be found in my
GitHub account. You can also download the source code in a zip file from the pub-
lisher's website at www.manning.com/FlexMobileinAction.
 Also in the code listings, you will find code annotations that point out certain code
segments and explain what each individual line of code accomplishes.
 Flex is an open source project, released under the Apache Software License and
distributed with the Adobe Flash Builder IDE and many others. You can also down-
load Flex, in source or binary form, from the Flex home page at http://incubator
.apache.org/flex/.
Author Online
The purchase of Flex Mobile in Action includes free access to a private web forum run by
Manning Publications, where you can make comments about the book, ask technical
questions, and receive help from the author and from other users. To access the
forum and subscribe to it, go to http://manning.com/FlexMobileinAction. This page
provides information on how to get on the forum once you are registered, what kind
of help is available, and the rules of conduct on the forum.
About the author
Jonathan Campos is a principal architect for Miller and Associates as well as a commit-
ter on the Apache Flex project. Within the community Jonathan is a user group man-
ager in Dallas, Texas. You can see Jonathan’s blog at http://unitedmindset.com/
jonbcampos and on twitter at http://twitter.com/jonbcampos. 

xvii
about the cover illustration
The figure on the cover of Flex Mobile in Action is captioned “Flag Bearer of the Guard
in Dubrovnik, Croatia.” The illustration is taken from a reproduction of an album of
traditional Croatian costumes from the mid-nineteenth century by Nikola Arsenovic,
published by the Ethnographic Museum in Split, Croatia, in 2003. The illustrations
were obtained from a helpful librarian at the Ethnographic Museum in Split, itself sit-
uated in the Roman core of the medieval center of the town: the ruins of Emperor
Diocletian’s retirement palace from around AD 304. The book includes finely colored
illustrations of figures from different regions of Croatia, accompanied by descriptions
of the costumes and of everyday life.
 Dubrovnik is an ancient city and sea port located on the Adriatic coast of Croatia.
A prime tourist destination today, the city was originally called Ragusa and founded in
the 7th century AD as a refuge for coastal residents fleeing advancing barbarians. In
the Middle Ages, Ragusa flourished and was the only city on the eastern Adriatic to
rival Venice in maritime power and trade. The figure on the cover is holding the flag
of Ragusa with a picture of St. Blaise on it. An early Christian martyr, St. Blaise is the
patron saint of Dubrovnik to this day. 
 Dress codes and lifestyles have changed over the last 200 years, and the diversity by
region, so rich at the time, has faded away. It’s now hard to tell apart the inhabitants of
different continents, let alone of different hamlets or towns separated by only a few
miles. Perhaps we have traded cultural diversity for a more varied personal life—cer-
tainly for a more varied and fast-paced technological life.
 Manning celebrates the inventiveness and initiative of the computer business with
book covers based on the rich diversity of regional life of two centuries ago, brought
back to life by illustrations from old books and collections like this one.

Part 1  
Getting started 
Application development is in a transition period no matter what applications you’re used to 
creating. Applications are becoming apps, and the steps required to prepare applications for 
the desktop and the web are continuing to grow to include many mobile platforms. 
In this part of the book we’ll focus on some concepts and pain points when creating 
mobile applications, including the issue of multiple operating systems and technologies. We’ll 
also look at a quick Hello World example so that you can see how easy it is to create an 
application for various platforms using Flex. 


3 
1  
Getting to know Flex Mobile 
This chapter covers 
 
Defining multidevice and multiscreen 
 
The great debate: native versus cross-platform development 
 
Mobile components 
 
Hello World example 
You, a mild-mannered programmer, work tirelessly on your computer to create desktop and 
web applications for your own personal gain and that of your clients. Suddenly you get a call 
on your phone from a new client asking for a mobile application! You spring into action and 
take the case only to realize later that mobile development is very different from the 
application development you’ve done in the past. Enter Flex Mobile. 
With the latest release of Flex, Flex 4.6—the successor to Flex 4.5 (codenamed Flex 
Hero), you can easily make applications that run on the web, desktop, or a wide range of 
mobile phones and tablets with the same codebase and familiar development techniques 
between each platform. This means you don’t have to learn a new language or relearn how a 
button works each time you need to deploy to a new device. Instead, you can use the 
knowledge you have, extend it, and deploy to each new platform. 
What makes Flex so wonderful for application development? Built into the Flex framework 
is a myriad of components created with the sole purpose of creating amazing applications. 
With many tested, extendable components, you can create applications easily without having 
to re-create the wheel each time. 
In this chapter we’ll discuss the latest changes in mobile application development, as well 
as how to decide between going native and using a cross-platform solution. Once you see the 
benefits of the Flash platform for multiscreen development, we’ll look at what Flex Mobile is, 
work through a basic Hello World example, and finally introduce the running example that 
will be used throughout the entirety of the book. 

4 
CHAPTER 1 Getting to know Flex Mobile 
1.1 
Learning key terms 
Before jumping right into Flex Mobile it’s important to understand some key terms 
surrounding mobile and discuss the debate between native and cross-platform development. 
NATIVE DEVELOPMENT 
When we talk about going native, we’re referring to the use of the device’s native software 
development kit (SDK), and therefore programming language, to create applications. For iOS 
development you’ve probably heard that native development means learning the Objective-C 
language, whereas Android includes its own framework built around the Java language. 
CROSS-PLATFORM DEVELOPMENT 
When we talk about going cross-platform, we’re talking about using one of the development 
platforms, such as Flex (ActionScript) or HTML (and JavaScript), to create applications that 
work similarly, if not the same, across all devices. 
MULTIDEVICE AND MULTISCREEN 
Thanks in part to the changing mobile landscape, two new terms are thrown around 
surprisingly often: multidevice development and multiscreen development. Although some 
circles may argue the unique differences of these terms, on the whole these terms are 
synonymous. 
When we talk about multidevice or multiscreen application development, we’re ultimately 
discussing creating a single application that works on multiple devices or multiple screens. 
Depending on your interpretation of the word, you may believe that the code is 100% the 
same between each device or that the applications need to share a common codebase. 
For some developers, when we talk about multidevice, we’re discussing the various 
mobile platforms, and when we talk about multiscreen, we’re also bringing in web, desktop, 
and television screens, to name a few. For the purposes of this book, we’ll treat the terms as 
the same and focus specifically on creating an application that works across multiple 
platforms. 
1.2 
Deciding between native and cross-platform 
Within various development circles there’s a big debate: go native or go cross-platform. 
Although the final answer is always unique to the team and developers, there are some 
major points to take into consideration before making a final decision. I do want to point out 
that either way you can create some great applications. 
For native development, some reasons to use native code are the execution speed, ease 
of access to core or custom features, and final package size. But the downside to going with 
native code is the limited reuse of code, longer development cycles for projects requiring 
multiple platforms, and more languages that your teams must be proficient in to successfully 
execute an application. 

Getting to know Flex Mobile  
5 
With cross-platform development, some reasons to use a cross-platform language are the 
development speed, consistency of applications across devices, time and cost savings, and 
finally only having to master or use a single language. As with any decision, there are some 
downsides. For cross-platform development, this usually means that it’s harder to access 
core platform features, the final package size is usually larger to support multiple platforms, 
and the code’s execution time is typically slower because there’s a level of abstraction 
between the device and the code (see figure 1.1). 
Figure 1.1 Cross-platform versus native development 
It’s the points of time and cost savings that I want to focus on. As a consultant, all of my 
clients want to create an amazing application while minimizing cost and maximizing their 
return on investment. Therefore, many of my clients start the application development 
process by focusing on a singular device platform that they want to target, usually Android 
or iOS. If you’re creating an application for a singular device, you have the option to either 
use native development techniques or cross-platform development techniques. 
At some point, though, my clients always eventually ask the question, “Can my 
application developed for platform X also work on platform Y?” Immediately, I tell them that 
the only answer is to use cross-platform development without needlessly ballooning the 
development cost and the amount of time necessary to fully support multiple platforms. 
Because you’re reading this book, I assume you’re interested in cross-platform 
development, specifically Flex Mobile. 

6 
CHAPTER 1 Getting to know Flex Mobile 
1.3 
What’s Flex Mobile? 
With the decision to use a cross-platform framework for your mobile applications behind you, 
we’ll look at Flex Mobile specifically. 
Some time back, before Flex 4.5+, Flex was already the best user interface framework on 
the market for browser and desktop applications. Mobile devices were starting to take off, 
and Adobe was planning to create a second lightweight framework influenced by Flex for 
mobile devices, codenamed Slider. During the development and exploration of this 
lightweight framework, the Flex SDK team found the best possible solution, combining the 
lessons learned from the lightweight framework and optimizing the full Flex framework. 
The Flash platform teams released Flex 4.5, providing the Flex framework we know and 
love with the mobile optimizations of a mobile specific framework, along with some 
industrial-strength upgrades to Flash Builder. Including components specifically for mobile, 
Flex 4.5 took existing mobile components appropriate for the mobile user experience and 
provided mobile skins that were size appropriate for touch input and multi-DPI layouts. The 
codename for this merged mobile-capable framework was Hero. 
Powered by thousands of active developers and contributors, the Flex framework is 
always improving and expanding. At the time of this writing, Flex version 4.6 is just being 
released, adding additional mobile components to the Flex framework. Figure 1.2 shows just 
some of the Flex components skinned for mobile use. In addition to the selected list of 
mobile components shown, many other components are available but are harder to visualize. 
Figure 1.2 Small sample of Flex visual components skinned for mobile interaction 
This simple description of Flex Mobile opens the door to many more questions. What 
language am I coding in? What runs our code? Next, I’ll answer these questions. 

Getting to know Flex Mobile  
7 
1.3.1 
What language am I coding in? 
When developing a Flex application you’ll hear people use phrases like the MXML code, the 
ActionScript code, or even the Flex code. Even poor, helpless recruiters will send out job 
requests insisting the developers have three years of MXML development. 
So what’s right? 
Flex is a framework built using the ActionScript language. Whether you’re writing out 
MXML markup or ActionScript code, you’re always writing in ActionScript. You’ll notice that I 
used the words MXML markup rather than MXML code. This is because MXML is an XML-
based markup protocol created by Adobe for the Flex framework to make the layout of visual 
components easier to read. As its popularity grew, other ActionScript frameworks used the 
concept of MXML markup to use a tag-based markup to describe their ActionScript objects. 
It doesn’t look like ActionScript to me. 
MXML is purely an XML representation of the ActionScript objects. All of the rules of XML 
still apply, such as namespaces and markup formatting. When compiling your application the 
compilers within the Flex framework take your MXML tags and convert them to ActionScript 
classes. After this translation is complete, the compiler creates the file to be run on your 
runtime. 
Can I see the generated code? 
It’s a little too advanced to go into right now, but if you want to be able to see the 
generated 
code 
created, 
you 
can 
always 
add 
–keep-generated-
actionscript=true to your compiler settings. See the following URL for the 
application compiler options: 
http://livedocs.adobe.com/flex/3/html/help.html?content=compilers_14.html  
Now that you have a better understanding of the language, we need to discuss what 
executes your code. 
1.3.2 
What runs our code? 
A term you’ve probably heard before is runtime environment, also sometimes referred to as 
just runtime. A runtime environment is a collection of code, settings, and programs that 
execute the code you write. When developing with Flex there are two runtimes to be aware 
of: the Flash Player runtime and the Adobe Integrated Runtime (AIR). 
FLASH PLAYER RUNTIME 
The Flash Player runtime is the program that runs to execute a compiled application within 
an internet browser. Flash Player is available for every major internet browser and provides a 
consistent runtime and code executing experience. As wonderful as Flash Player can be, for 
this book we won’t be concerned with Flash Player. The applications you’ll create all run on 
the AIR runtime. 

8 
CHAPTER 1 Getting to know Flex Mobile 
AIR 
AIR was created to provide a consistent runtime for installed applications running outside the 
browser. Gaining access to system resources previously not available from the browser, 
these applications can be installed on mobile devices, TVs, and desktops. All the applications 
you’ll create in this book will run on the AIR runtime for testing and deployment. The 
growing list of mobile devices that support Adobe AIR include Android, iOS, and QNX 
(BlackBerry) devices. Although it may not be obvious, when I list Android devices, I’m also 
including the Nook, Kindle Fire, and various other Android tablets and phones. 
Within this book you’ll utilize mobile components and many others as you develop a 
handful of applications, learning the finer points of mobile using the Flex framework. The 
best way to understand Flex and the power behind it is to jump in headfirst.  
1.4 
Hello World 
In chapter 2 we’ll get into application development, but before we do you’ll create a quick 
Hello World example to set expectations for the development environment and show how 
easily you can display some text with the Flex framework. Hello World examples are always 
helpful mini-applications that show how quickly you can go from nothing to being able to 
display the words Hello World to a user. This is the first Flex Mobile application that you’ll 
create. 
1.4.1 
Prerequisites 
For this book you don’t have to be a Flex expert; you only need to have an interest in 
making great mobile applications that can run across multiple platforms. But there are some 
basic expectations we’ll use throughout this book. 
YOUR IDE 
Although many of the examples within this book use Flash Builder for the integrated 
development environment (IDE), you don’t have to. An IDE is the application you use to 
code. The I in IDE states that the coding application isn’t created for just one language but 
for many different languages all within the same environment. If you’re used to developing 
with FDT, TextMate, IntelliJ, or any other of the Flex- and Flash-capable IDEs, feel free to 
use it. It’s outside of the scope of this book to set up or customize these IDEs, but full code 
examples will be shown throughout this book that are 100% IDE agnostic.  
FLEX VERSION 
The only real requirement of this book is that you’re developing with at least Flex version 
4.6. Although many of the examples and topics within this book will work with Flex 4.5, a 
few code examples in the latter half of the book cover some of the newer capabilities of Flex 
that require Flex 4.6. All versions of Flex beyond 4.6 will work with the examples shown in 
this book. 

Getting to know Flex Mobile  
9 
MOBILE DEVICES 
If you’re one of the lucky developers to own multiple mobile devices, then you can enjoy 
using each one of your devices throughout this book. If you’re missing a QNX (BlackBerry), 
iOS, and/or Android device, don’t worry; Flash Builder—or your favorite IDE—can provide a 
simulator to run your code. Not all device capabilities are supported within the device 
simulators, but you can still develop using these programs. Obviously, as you get closer to a 
final release, you’ll want to test your application on each device you intend to release on. 
1.4.2 
Creating a new application 
In chapter 2 we’ll go step by step through the application-creation process, looking at every 
option and selection—including how to run an application within the simulator. For this part 
we’ll quickly run through how to create a mobile application using Flash Builder. 
Using Flash Builder, the first step is to create a new Flex Mobile project (see figure 1.3). 
Figure 1.3 New Flex Mobile project 
After you select New > Flex Mobile Project, Flash Builder will lead you through the steps to 
start up your new project (see figure 1.4). The first step is always to name the project and 
determine where you want the project to be saved. 

10 
CHAPTER 1 Getting to know Flex Mobile 
Figure 1.4 Project Location dialog box 
After naming your new Flex Mobile project HelloWorld, click Next to configure your 
application (see figure 1.5). 
Figure 1.5 Mobile Settings dialog box 

Getting to know Flex Mobile  
11 
You can skip most of the project settings (we’ll revisit these settings in chapter 2), and select 
the option to create a blank application template. With this one setting, you can click Finish 
and Flash Builder will create your application template: 
<?xml version="1.0" encoding="utf-8"?> 
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        applicationDPI="160"> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
</s:Application> 
Your last change is to add in the Hello World text by including a Label component, which 
displays text onscreen: 
<?xml version="1.0" encoding="utf-8"?> 
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        applicationDPI="160"> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:Label text="Hello World"/>                                  
</s:Application> 
That’s it. You’ve completed your Hello World application. As simple as this application is, you 
can already see how quickly you can go from no code to an application that you could run on 
multiple platforms. Obviously, you aren’t going to release this application for other people to 
download, but this example shows you just how comfortable this process would be. In 
chapter 2 you’ll expand on your Flex knowledge and customize your application. 
1.5 
Introducing a running example 
Working with a public API can give your applications the important data necessary to 
populate an application. An API, or application programming interface, is a defined process 
detailing how to interact with data available from another software system. For the purposes 
of learning mobile application development, it’s important to be able to make service calls, 
show lists of data and details, as well as integrate device specific capabilities into your 
application to utilize the abilities provided to you by the device. 
The main application created within this book is a Rotten Tomatoes application displaying 
movie data provided by the Rotten Tomatoes API. The Rotten Tomatoes API will provide you 
the ability to quickly get access to a huge library of movie data, and you’ll be able to extend 
the mobile experience by adding new mobile-specific capabilities to the application. In this 
section I’ll explain what a public API is, show how to integrate with an API, explain what data 
Rotten Tomatoes will provide to you, and finally lay out a roadmap for the mobile application. 
“Hello World” label 

12 
CHAPTER 1 Getting to know Flex Mobile 
1.5.1 
The roadmap for our example 
For this book you’ll create an application using the Rotten Tomatoes API, with help from the 
RottenTomatoesAS3.swc, which will run on phones and tablets on the Android, QNX, and iOS 
platforms. 
Starting simple, the application will pull and display data from the Rotten Tomatoes API. 
As the application matures, you’ll update it to run across screens of various DPI and then 
give the application an enterprise-strength overhaul utilizing the popular Robotlegs MVC 
(Model-View-Controller) framework. 
You’ll round out the application by giving it access to some extra native capabilities with 
native extensions giving you the ability to make money using integrated ads. 
Finally, the application will include a full unit test suite and a series of build scripts to 
quickly create release-quality files to upload to the various app markets. 
There are plenty of stops along the way and additional features to be had; this is just a 
mile-high roadmap of where you’re going. 
1.5.2 
Public APIs and Rotten Tomatoes 
While trying to reach a larger audience, many companies open their data to other 
applications, including yours, using a specified protocol called an application programming 
interface. Using protocols like XML and JSON, your application can quickly integrate with 
these other applications and their data, expanding the features available within your 
application. 
For your application you’ll be utilizing the Rotten Tomatoes API provided by Flixster. 
Welcome to the Rotten Tomatoes API 
The API gives access to Rotten Tomatoes’ wealth of movie information, allowing anyone 
to build applications and widgets enriched with Rotten Tomatoes data. 
Using the API, users can, for example: 
• 
Search for movies and retrieve detailed movie information, such as cast, directors, 
and movie posters 
• 
Access the Rotten Tomatoes Score (aggregation of critic's scores) and the Audience 
Score 
• 
Get the current box office movies, new releases, and upcoming movies 
From: http://developer.rottentomatoes.com/  
To fully utilize the Rotten Tomatoes API, you’ll need to sign up for an API key with Flixster. 
Signing up for an API key is free and takes only a few minutes. 

Getting to know Flex Mobile  
13 
SIGN UP FOR AN API KEY 
To sign up for an API Key go to http://developer.rottentomatoes.com/
From this page you must first register for an account and then register your application 
for an API key. Once Flixster accepts your application, you’ll have your API key (see figure 
1.6). 
Figure 1.6 Register and sign up for an API key 
You won’t have to start from scratch, though. We’ll be using the RottenTomatoesAS3 API to 
quickly integrate the Rotten Tomatoes data without having to make complicated service calls 
and JSON-to-ActionScript translations. 
1.5.3 
The RottenTomatoesAS3 API 
Available from GitHub, the RottenTomatoesAS3 API provides an extremely easy way to pull 
data from Rotten Tomatoes. The full source is available for viewing and forking at 
https://github.com/jonbcampos/RottenTomatoesAS3.  
In chapter 2 we’ll discuss what an SWC is and how to use it to consume code. If you 
already know or just want to pull a required resource, use the following link to quickly get 
the compiled SWC: 
https://github.com/downloads/jonbcampos/RottenTomatoesAS3/RottenTomatoesAS3.swc  
What’s an SWC? 
Later we’ll look more closely into what an SWC is, how to create one, and the features it 
provides, but for now just know that an SWC is a file that contains some code and other 
assets packaged to be easily shared between projects. 
To see a live example of the RottenTomatoesAS3 API in action, please check out Tour de Flex 
(http://www.adobe.com/devnet/flex/tourdeflex.html). Tour de Flex is a wonderful application 
containing examples of many different available APIs, components, and code samples (see 
figure 1.7). 

14 
CHAPTER 1 Getting to know Flex Mobile 
Figure 1.7 Tour De Flex application with the Rotten Tomatoes API selected 
Now that you understand how to get your hands on the data from the Rotten Tomatoes API 
and where to get the ActionScript code to make your life easier, we can move on and look at 
what you’ll be creating throughout this book. 
1.6 
Summary 
We have a long way to go, and the journey is just starting. In this chapter we looked at 
some key terms in the growing mobile debate: native development versus cross-platform 
development. From there we looked at how Flex, originally developed as a component library 
to build rich internet and desktop applications, grew to include many new components 
created to support mobile development on a variety of platforms. Then we briefly looked at 
how to start up a new Flex Mobile project with Flash Builder and introduced where you’re 
going throughout the rest of the book. The most important takeaway from this chapter 
should be a high-level understanding of the Rotten Tomatoes API and getting your own API 
key from Flixster. With these steps complete, you just need to pull the RottenTomatoesAS3 
SWC file and move on to chapter 2, where you’ll get into some real development. 
Key takeaways: 
 
Understand the terms multiscreen, multidevice, and cross-platform 
 
Quickly make a Hello World example 
 
Learn about the Rotten Tomatoes API and your Rotten Tomatoes application 

Part 2  
Mobile development with Flex 
Whether you’re a seasoned Flex developer or you’re coming to the Flex platform for the first 
time, this section will ramp you up to being a full-fledged mobile developer. 
As Flex transitions from the desktop and browser to mobile platforms, we’re teaching the 
old dog some new tricks. In this part we’ll focus on these new tricks so that you understand 
just how many capabilities are built right into Flex, enabling you to make enterprise-level 
applications for multiple mobile devices. 
In chapter 2 we focus on the new ViewNavigator component and all of the features 
provided to us by this new component and view paradigm. I’ll show you how to run and 
debug your application on your desktop along with your mobile devices. 
In chapter 3 we’ll switch from focusing on the look and feel of your application to the 
specific data within your application. In chapter 3 we’ll discuss how to hold out data even 
after your users leave the application. 
In chapter 4 we’ll shift gears from the data and focus on tying into native capabilities built 
into your devices. Using features provided by Adobe AIR, you’ll deeply integrate with devices 
in a way that wasn’t available to you before. 
Finally, we’ll end this part in chapter 5 by looking at how to make your application work 
on a variety of devices no matter what the dimensions or resolution of the screen. This 
monumental task will be made easy with the power built into the Flex framework. 


17 
2   
Get going with Flex Mobile 
This chapter covers 
 
Starting a Mobile Flex project 
 
Creating views 
 
Using the ViewNavigator
 
Running your application 
 
Creating new device configurations 
 
Pulling data from Rotten Tomatoes AS3 API 
 
Customizing the ActionBar 
It’s time to dive headfirst into Flex Mobile development. Armed with knowledge of 
ActionScript, MXML, and Flex, you’ll start making your application. In this book you’ll be 
creating an application using the Rotten Tomatoes API. For those who don’t know what 
Rotten Tomatoes is, it’s a wonderful website that provides movie details and reviews 
available in a variety of browsing or search options. 
Rotten Tomatoes API 
To see a sample of the data you’ll be using, feel free to visit the Rotten Tomatoes site at 
http://www.rottentomatoes.com/. To pull data from the Rotten Tomatoes API, you’ll need 
to have an API key. Make sure to sign up for a developer’s account to get an API key to 
the Rotten Tomatoes API at http://developer.rottentomatoes.com/. 
If you skipped chapter 1, full instructions on how to get a developer account are there. 
Using the data provided by the Rotten Tomatoes API, you’ll use the List/Details user 
experience paradigm. Even if you haven’t heard of the List/Details term, I can promise you 
that you already know it; many mobile applications are designed using this pattern.  

18 
CHAPTER 2 Get going with Flex Mobile 
The idea is that you have a list of items, and after selecting a particular item in the list, 
you are then given details on the selected item. Figure 2.1 diagrams the List/Details user 
experience paradigm. 
Figure 2.1 List/Details user experience 
By starting the application as outlined in this chapter, you’ll have the groundwork for a much 
larger application that can run on a variety of devices. This application example, spread over 
many chapters, will show you how to navigate a mobile application, persist data effectively, 
and react to a variety of screen sizes. In this chapter you’ll create the beginnings of the 
application, learn to navigate through the ViewNavigator, pull data from Rotten Tomatoes, 
and add in the basic views for the application. 
2.1 
Starting up your application 
When creating a Flex application the starting point is always a specific Flex class called 
Application. For mobile development Adobe added a few more application-type classes to 
fit the mobile paradigm.  
The first is ViewNavigatorApplication, an Application that includes a single 
ViewNavigator—we’ll discuss the ViewNavigator more later on—to push and pop views 
for navigation. The second new Application subclass, and the one you’ll use to start your 
Rotten 
Tomatoes 
application, 
is 
the 
TabbedViewNavigatorApplication. 
This 
Application subclass is similar to ViewNavigatorApplication, except instead of 
supporting 
just 
one 
ViewNavigator 
and 
its 
single 
stack 
of 
views, 
TabbedViewNavigatorApplication supports multiple ViewNavigators, allowing the 

Get going with Flex Mobile  
19 
user to access the various ViewNavigators by selecting from their respective tabs on 
screen. As I showed in the previous chapter, you can create this Application subclass 
totally in code, or you can use the Flash Builder IDE to help guide you through the setup 
process. In this section you’ll create your application using Flash Builder. 
2.1.1 
Creating a TabbedViewNavigatorApplication 
Using Flash Builder you can create a new Flex Mobile project and select Tabbed Application 
to create the TabbedViewNavigatorApplication subclass. 
Start this process by selecting File > New > Flex Mobile Project, as shown in figure 2.2. 
You can see how by going through File > New or right-clicking in the Package Explorer you 
can create a new Flex Mobile Project. Once you create a new Flex Mobile project, the Flash 
Builder IDE will guide you through the setup process. 
Figure 2.2 Start a new Flex Mobile project. 
As Flash Builder leads you through the steps necessary to create a new Flex Mobile 
application and creates the initial files, you need to set the name of your application and the 
location to save it to (see figure 2.3).  

20 
CHAPTER 2 Get going with Flex Mobile 
Figure 2.3 Naming your application 
After entering the name of your application—use RottenTomatoesApplication—and 
deciding where to save it, click Next and select Tabbed Application in the Application 
Template section, as shown in figure 2.4. 
In this section it’s easy to create tabs for your application. You can see in figure 2.4 that I 
created three tabs named Tab 1, Tab 2, and Tab 3. These values are completely arbitrary at 
this point because you’ll be making changes later to these values directly in your code. As 
with every option you select at this point, everything can be adjusted in code later on; all of 
your selections create a bit of code to make your life easier. 
Figure 2.4 Select Tabbed Application. 

Get going with Flex Mobile  
21 
Once you’ve made your tabs, click Finish and complete the setup dialog box. The resulting 
code, or code that you can enter manually to create the exact same effect as using the IDE, 
is shown in the following listing. 
Listing 2.1 Main application—RottenTomatoesApplication.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:TabbedViewNavigatorApplication                                         
    xmlns:fx="http://ns.adobe.com/mxml/2009" 
    xmlns:s="library://ns.adobe.com/flex/spark" 
    applicationDPI=”160”> 
<s:ViewNavigator label="Tab 1" width="100%" height="100%"  
    firstView="views.Tab1View"/>                                          
<s:ViewNavigator label="Tab 2" width="100%" height="100%"  
    firstView="views.Tab2View"/>                                          
<s:ViewNavigator label="Tab 3" width="100%" height="100%"  
    firstView="views.Tab3View"/>                                          
<fx:Declarations> 
<!-- Place non-visual elements (e.g., services, value objects) here --> 
</fx:Declarations> 
</s:TabbedViewNavigatorApplication> 
{chap 2 code}/src/RottenTomatoesApplication.mxml
Notice that the TabbedViewNavigator holds an array of ViewNavigators, one per tab 
that you intend to create, and each ViewNavigator contains its own first view. The label 
property on the ViewNavigator controls the button labels on the main TabNavigator
(see figure 2.5). Finally, the three initial views are created to hold the user interaction 
components, each set with the firstView property. 
2.1.2 
The views 
Flash Builder generates individual views for each tab you created. From figure 2.4 you know 
that you created an application with three tabs. The following code shows those three views, 
one code segment per tab. The three resulting views—Tab1View, Tab2View, and 
Tab3View—are so similar that it almost feels wasteful to give the code for each, but just so 
that all the code is documented, I’ll show the code for each view: 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="Tab 1">                                                    
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
</s:View> 
Main application tag 
Tab 1 ViewNavigator 
Tab 2 ViewNavigator 
Tab 3 ViewNavigator 
View’s title 

22 
CHAPTER 2 Get going with Flex Mobile 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="Tab 2">                                                   
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
</s:View> 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="Tab 3">                                                   
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
</s:View> 
Each of the view classes is unique, and any further changes that you make to them will only 
add to their uniqueness, but currently the only thing that’s different between each view is 
the title. The title property on the View component is used as the title of the ActionBar 
component. In figure 2.5 you can see the running application including the ActionBar, the 
TabBar, and the View component. 
Right now if you were to run the application, with your three views, the resulting 
application would look like figure 2.5. 
Figure 2.5 Current running application 
View’s title 
View’s title 

Get going with Flex Mobile  
23 
You’ve now created a working application that you’ll continue to expand on. As I stated 
earlier, currently the application only allows you to navigate through the three different tabs, 
but soon you’ll be adding much more complex functionality. Next, we’ll look at all the 
different ways to run the application in the desktop simulator and on the devices you 
currently own. 
2.2 
Running your application 
Before going too far it’s important to know how to run and debug your application so that 
you can test the application in development. With the ability to run your application you can 
see the state of your programming in action. You can also pause the application and view 
variable specifics at runtime, ensuring your application’s values are as expected. 
You can run, debug, and deploy your application using the command line or other IDEs 
other than Flash Builder, but when I show examples of how to use an IDE to run your 
application, we’ll be looking at examples from Flash Builder because it’s currently the most 
widely used IDE. In this section we’ll walk through the steps necessary to run your 
application on the desktop simulator for quick testing and then move on to running the 
application on either your Android, QNX (BlackBerry), or iOS device—or all three. 
2.2.1 
Desktop run/debug configurations 
Now that you have an application—simple or not—you’ll want to run it to ensure that your 
application looks and acts the way you intend. The easiest way to test your application is to 
use the mobile simulator provided by the ADL tool. To be clear, even if you don’t have a 
mobile device, you can run and test your application effectively, although when you release 
your application I’d highly recommend testing it on as many devices as possible. 
ADL 
ADL stands for AIR Debug Launcher. This tool, provided by the Adobe Open Source Stack, 
is useful to run and debug AIR applications on your desktop. Packaged within Flash 
Builder and the Flex SDK, it’s launched each time you run an application on the desktop. 
One caveat is that you can have only one instance of the ADL tool running at a time. Just 
make sure to close the ADL tool each time you’ve finished testing.  
Although running the simulator is fast and easy, and it allows you to quickly customize the 
size of the device you’re simulating, there are some downsides to using it. The main issue is 
that within the simulator you don’t get any of the device’s native features while testing, such 
as gestures, multitouch, cameras, and so on (a partial list of not-included features is shown 
in table 2.1). Any additional APIs that you create using native extensions (see chapter 8) are 
most likely not available. 

24 
CHAPTER 2 Get going with Flex Mobile 
Table 2.1 Available and unavailable device capabilities from ADL 
Feature 
Availability 
Camera 
No 
Camera roll 
No 
Accelerometer 
No 
Geolocation 
No 
Home, Search, Menu, and Back keys 
Yes 
StageWebView 
Yes 
Microphone 
No 
Multitouch 
No, unless you have a monitor that supports 
multitouch input 
Gestures 
No, unless you have a trackpad that supports 
gestures 
Screen orientation changes 
Yes 
Email 
Yes 
Text messages 
No 
Phone calls 
No 
SQLite databases 
Yes 
Caching (via local shared object) 
Yes 
One big benefit of testing on the device is that you can see how long things take to render 
and compute. Simulating is deceptive, because it runs an application on a machine more 
powerful than the actual device and with connection speeds faster than what your users will 
receive over the air. When testing on the device you may see visual slowdowns and services 
taking a long time to return. Performance gains and losses aren’t exposed in the simulator 
because of the power of the hardware. 
To simulate the orientation changes and hardware buttons of the Android device in the 
ADL tool, a few shortcut keys are provided within ADL to simulate these device actions (see 
table 2.2). 

Get going with Flex Mobile  
25 
Table 2.2 ADL shortcut keys 
Hardware feature 
Details 
Windows 
Macintosh 
Back button 
Simulates hitting the 
Back button 
Ctrl-B 
Command-B 
Search button 
Simulates hitting the 
Search button 
Ctrl-S 
Command-S 
Menu button 
Simulates hitting the 
Menu button 
Ctrl-M 
Command-M 
Rotate left 
Simulates rotating the 
device left 
(counterclockwise) 
Ctrl-L 
Command-L 
Rotate right 
Simulates rotating the 
device right (clockwise) 
Ctrl-R 
Command-R 
Close button 
Closes the app 
Ctrl-W 
Command-W 
Two paths are available to get started when you need to run or debug an application. Both 
lead to the Run Configurations, where you’ll customize how your application is simulated. 
The first method is found in the toolbar (see figure 2.6). This quick access to run/debug 
will immediately run/debug the last project run, or you can select the exact project through 
the dropdown. If you have no previously run options, you’ll need to choose Run 
Configurations to configure the run options for your application. 
Figure 2.6 Toolbar Run dropdown 
The second path is to right-click the application file that you want to run and navigate down 
to Run As/Debug As > Mobile Application (see figure 2.7). 

26 
CHAPTER 2 Get going with Flex Mobile 
Figure 2.7 Run Configurations from Package Explorer 
Either way you go, you should now see the Create, Manage, and Run Configurations dialog 
box (see figure 2.8). 
Figure 2.8 Create, Manage, and Run Configurations dialog box 

Get going with Flex Mobile  
27 
From this dialog box, you can customize how the ADL tool will run your application on the 
desktop. Within this dialog box, you can name your run configuration for easy access in the 
future.  
Over time, you’ll probably find it helpful to create multiple run configurations for various 
device configurations and name each configuration uniquely, like “Mobile App Evo” and 
“Mobile App iPad” for Evo and iPad configurations, respectively. This will save you 
development time by not having to continuously change the run configuration. 
To adjust your run configurations, first select the project to run and the application file to 
launch. Then select which target platform you’ll be simulating from, where to launch the 
application, and finally which device to simulate. Once you’ve made all of your selections, 
click Run, and the ADL tool will run your application. 
By simulating your application on the desktop, you can click around and interact with 
your application as you could on your device. If you were debugging your application, any 
ActionScript breakpoints that you set would pause your application and provide details on 
variables and other data at that moment in the application. 
When you select devices in the device dropdown configuration list, a device that you want 
may be missing from the detail list. In the next section we’ll look at how to add devices to 
your device list for your simulator. 
2.2.2 
Adding a device configuration 
If the device that you want to simulate isn’t in the dropdown list, you have two options: 
either import the required device configuration or, if the configuration isn’t in the import list, 
add the custom configuration. Both of these options are available in the Device 
Configurations dialog box (see figure 2.9), which is accessible by clicking the Configure 
button next to the device selection dropdown. 
Figure 2.9 Device Configurations dialog box 

28 
CHAPTER 2 Get going with Flex Mobile 
In the Device Configurations window you can view the available devices or import new device 
profiles that Adobe adds to Flash Builder. If the device you want to add isn’t in the import 
list, you can click the Add button to quickly add a new device by entering the screen 
resolution and DPI. 
Because you’re trying to reach as many devices as possible, you’ll want to also run on the 
Barnes and Noble Nook. The Nook is an Android-based device that isn’t included by default in 
the device list, so you need to add it to your device list. To add this device, you need to click 
Add in the Device Configurations dialog box. 
In the resultant dialog box (see figure 2.10), you’ll specify a few parameters and then 
you’ll be able to accurately simulate the Nook on your desktop. 
Figure 2.10 Adding a device configuration 
First, name the device Nook Color, and then set the platform to Google Android. Then 
enter the portrait width and height—these are the screen dimensions in portrait orientation. 
By default Flash Builder will adjust the usable screen size for a standard platform UI. What 
this means is that the actual size of your application is the total width and height minus the 
size of the status bar and any other platform UI. If the device has a nonstandard status bar, 
then you can make these adjustments by deselecting Estimate Usable Screen Size and 
adjusting the width and height as necessary. Finally, enter the pixels per inch for the Nook. 
With all of your settings configured, you can click OK and start simulating the Nook for 
development. 

Get going with Flex Mobile  
29 
With the ability to add any custom device, you have every possible device at your 
fingertips. Now select to run your applications based on your newly developed device, and 
continue testing for great results. 
2.2.3 
Device run/debug configurations 
If you own an Android-, iOS-, or QNX (BlackBerry)-based device, you can also connect 
directly to the device and debug/run from the device with ease. Each device takes a slightly 
different set of steps to connect and deploy to the device based on the manufacturer’s 
requirements. The following three links outline the connection method for Android, iOS, and 
QNX (BlackBerry) devices, respectively: 
Android—http://www.adobe.com/devnet/air/articles/packaging-air-apps-android.html 
iOS—http://www.adobe.com/devnet/air/articles/packaging-air-apps-ios.html
QNX (BlackBerry)—http://www.adobe.com/devnet/air/articles/packaging-air-apps-
blackberry.html
Once you’re connected, the process to test on the native devices is simple. One big benefit of 
testing on the device is that you can see how long it takes to run your application on the end 
user’s device.  
Simulating is deceptive 
Rendering, computing, and pulling data on a machine more powerful and with faster 
connection speeds than what your users will receive over the air won’t expose where your 
application needs work. My recommendation is to test on the desktop first and then test 
mobile-specific features and performance on the device. 
I know that felt like a lot of work, but the hard parts are over. From here on out you don’t 
need to keep setting up your project; you’re ready to start programming and building out the 
functionality of your application. In the next section you’ll create the first of the list/details 
views. 
2.3 
Building your first application views 
Adding more tools to your belt, you’ll now become a master of the ViewNavigator with the 
ability to navigate through your application by adding and removing views. In this section 
you’ll start adding three important views to your application. These will stand as the bedrock 
of your larger application. You’ll create your main menu, move to a list of movies, and then 
see details based on a specific selected title. 
2.3.1 
Navigating your application with the ViewNavigator 
Before adding and removing views, you need to understand how the ViewNavigator
works. As we’ve discussed, the TabbedViewNavigatorApplication is a subclass of the 

30 
CHAPTER 2 Get going with Flex Mobile 
Application class, which is required as the starting point for any Flex application and 
holds an array of ViewNavigator components. The ViewNavigator holds a stack of views 
and manages the addition and removal of views from the stage. When managing the stack of 
views, the ViewNavigator performs three functions: adding/removing views, cleaning up 
old views, and remembering the list of views in the stack. To illustrate the example we’ll 
work with a simple list of views, the same views you’ll use in your application. The three 
views include a main menu, a list of movies, and details on a selected movie title (see figure 
2.11). 
Figure 2.11 Our three views 
At any given time when using the ViewNavigator, only a single view is active at a time. 
What happens to the other views? By default, the ViewNavigator destroys any views that 
aren’t currently in use. The benefit to destroying unused views is that the application no 
longer has to maintain the data for the view. But the problem with this approach is that the 
way that the view looks—any data that was input, any sliders moved, your position in a list—
will be completely lost when you leave the view. If you navigate back to a view that was 
destroyed, you’ll have to set back anything you’ve changed so that for the user the view 
looks unchanged. 
DESTRUCTION POLICY 
You do have the option to stop a view from being destroyed by working with the 
destructionPolicy: 

Get going with Flex Mobile  
31 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark" title="Tab 1" 
        destructionPolicy="never" >                                       
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
</s:View> 
If you have a view that takes a long time to create and would best be stored in memory, 
then you can turn off this destruction policy on a view-by-view basis. This prevents the view 
from being destroyed and preserves the entire view state. I recommend not leaning on this 
technique because you could quickly hurt the performance of your application by keeping too 
much in active memory. For your application, you won’t keep this code change. 
FIRST VIEW 
As stated when you set up your application, the view set to the firstView property in 
ViewNavigator is the first view shown when the ViewNavigator is created: 
<s:ViewNavigator label="Tab 1" width="100%" height="100%" 
firstView="views.Tab1View"/> 
In this case you want the firstView to be the main menu so that on startup you see the 
main menu (see figure 2.12). 
Figure 2.12 First view 
A view isn’t destroyed 

32 
CHAPTER 2 Get going with Flex Mobile 
The first thing to do is to navigate to the next view when a menu item is selected. To do this 
you push a view onto the view stack (see figure 2.13). The push function on the 
ViewNavigator includes four parameters: 
pushView(viewClass:Class, data:Object=null, context:Object=null, 
transistion:ViewTransitionBase=null); 
Figure 2.13 Pushing a view 
The first and only required parameter is the class that needs to be created; please notice 
that this isn’t an instance of the view you desire to create, just the class. The reason that the 
method wants a class rather than an instance is so that the ViewNavigator controls when 
a view is created or destroyed. 
The second parameter is the generic data object. Any data that you set will 
automatically be passed to the newly created view and set on the view’s data property. This 
is a great way to pass data to the next view, giving the view information that may be used to 
construct the new view.  
The third parameter is another generic parameter called context. Although any form of 
data can be passed in the context and retrieved by using the generated view’s context 
property, the idea is to use this parameter to pass information to the generated view that 
will provide information about where the new view came from. For example, in your Rotten 
Tomatoes application, you may want to pass to the movie title details view information in the 
context that alerts the details that a specific title is in theaters or on DVD. With this bit of 

Get going with Flex Mobile  
33 
additional data, you can change the details view to reflect this information, making it easier 
to know where the generated view is coming from.  
The fourth and final parameter is the transition effect. By default, the 
ViewNavigator will slide new views onto the screen when you push a new view onto the 
stack. If you’d like to use another effect to show when the view is added—even a custom 
effect—you can set an instance of this effect in the fourth parameter. Any effect used for a 
view 
transition 
must 
be 
a 
subclass 
of 
the 
ViewTransitionBase. 
The 
ViewTransitionBase is a special effect class that’s optimized to move a view onto a 
ViewNavigator. 
Pushing views onto your ViewNavigator is great, but at some point you have to 
navigate back down the stack and see where you were; this is referred to as popping views. 
We’re going to look at the three different ways to pop a view from the stack. 
POPVIEW 
Using the popView method (see figure 2.14) is the easiest and most basic way to remove 
your current view: 
popView(transition:ViewTransitionBase=null) 
Figure 2.14 popView 
As indicated by the name, popView pops the current view from the ViewNavigator and 
returns you to the last view in the stack. If you don’t specify a transition, then the default 

34 
CHAPTER 2 Get going with Flex Mobile 
slide-to-the-left transition is used. The main thing to take away is that popView removed 
only one view from the stack, the current view. 
POPTOFIRSTVIEW 
When popView isn’t good enough and you need to immediately move back to the 
firstView, it’s time to use popToFirstView (see figure 2.15). 
popToFirstView(transition:ViewTransitionBase=null) 
Figure 2.15 popToFirstView 
This ultra-helpful function pops off all the views in the stack and returns the user to the first 
view. 
POPALL 
Finally, the last way to pop views is to remove all the views from the stack in one quick 
function (see figure 2.16): 

Get going with Flex Mobile  
35 
popAll(transition:ViewTransitionBase=null) 
Figure 2.16 popAll 
The popAll method removes all the views including the firstView. After calling this 
method you’ll need to push a new view onto the ViewNavigator or your application will 
have no content. 
With the ability to push and pop views to the ViewNavigator you now can take control 
of the navigation elements of your application. 
2.3.2 
Providing context with the ActionBar 
You’ve already seen the ActionBar when you ran the application but probably didn’t realize 
its helpfulness. The ActionBar is a common mobile user interaction component that’s 
helpful for user input, navigation, and view context. Currently, you’re only using the 
ActionBar to provide view context by showing the title of the selected view (see figure 
2.17). 

36 
CHAPTER 2 Get going with Flex Mobile 
Figure 2.17 The ActionBar 
The ActionBar also includes a few different modes that dictate how the ActionBar is laid 
out in the view. 
HIDE THE ACTIONBAR 
One option is to hide the ActionBar: 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark" title="Tab 1" 
        actionBarVisible="false">                                         
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
</s:View> 
If you want to remove the ActionBar from a view, set the actionBarVisible property 
to false. By default this property is true. 
OVERLAY THE ACTIONBAR 
The next option is to overlay the ActionBar on the view’s contents: 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark" title="Tab 1" 
        overlayControls="true">                                           
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
</s:View> 
If you want to have the ActionBar overlay or float over the view visual components, then 
you need to set the overlayControls property to true (see figure 2.18). By default this 
property is false. 
Remove ActionBar 
overlayControls property 

Get going with Flex Mobile  
37 
Figure 2.18 Controls overlaid 
The ActionBar is connected to the ViewNavigator, and as such when new views are 
pushed and popped from the ViewNavigator, the title and content of the ActionBar are 
set to reflect the current view’s content. If you want to override the visual appearance of the 
ActionBar, then you need to change the skin of the ActionBar as part of the 
ViewNavigator skin. 
The one section in the ActionBar that’s special is the titleContent. By default you 
can set the text shown in the titleContent by setting the title property on the 
ActionBar. If you set different content to the titleContent, then the title property is 
ignored, because the default label will be overridden by whatever titleContent you’ve 
set. 
With the intricacies of the ActionBar explained, you can now move forward with the 
customization of your views and create the visual layout of the application. 
2.3.3 
Updating the main application 
The first thing you need to do is update the main application and ensure that it includes two 
tabs, one for your browse menu and one for your search functionality: 
<?xml version="1.0" encoding="utf-8"?> 
<s:TabbedViewNavigatorApplication  
    xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark"> 
    <s:ViewNavigator label="Browse" width="100%" height="100%"  
        firstView="views.BrowseView" />                                   
    <s:ViewNavigator label="Search" width="100%" height="100%"  
        firstView="views.SearchView" />                                   
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
Browse ViewNavigator 
Search ViewNavigator 

38 
CHAPTER 2 Get going with Flex Mobile 
    </fx:Declarations> 
</s:TabbedViewNavigatorApplication> 
Right now, your application can’t be compiled. Don’t worry, that’s expected. You should be 
receiving errors for the missing views.BrowseView and views.SearchView classes. In 
the following sections you’ll create the two missing views. 
2.3.4 
Creating the browse view 
The first new component you’ll make is BrowseView.mxml, which serves as the central 
access point for all of your navigation. As shown in figure 2.19, BrowseView is a simple list 
that provides access to the variety of lists that you’ll include for your users. 
Figure 2.19 BrowseView.mxml 
Using Flash Builder it’s easy to create the BrowseView using the same New menu that we 
used to create the Flex Mobile Project. Using the Package Explorer window, right-click the 
views package and select New > MXML Component (see figure 2.20). 

Get going with Flex Mobile  
39 
Figure 2.20 New MXML component 
This will bring up a New MXML Component dialog box, where you can name the new 
component, choose the package for the new component, and set the component to base 
your new component on, in this case the View class (see figure 2.21). 
Figure 2.21 New MXML Component dialog box 

40 
CHAPTER 2 Get going with Flex Mobile 
This will result in the default code for your BrowseView: 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="BrowseView"> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
</s:View> 
With the basic component ready, you can add the list component for your menu, as shown in 
the following listing; the title for the view has also been changed from BrowseView to Rotten 
Tomatoes. 
Listing 2.2 BrowseView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark"  
    title="Rotten Tomatoes"> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:List width="100%" height="100%"                                    
            labelField="label"> 
        <s:dataProvider> 
            <s:ArrayList>                                                
                <fx:Object label="In Theaters"/>                         
                <fx:Object label="Box Office"/>                          
                <fx:Object label="Opening Now"/>                         
                <fx:Object label="Coming Soon To Theaters"/>              
                <fx:Object label="Top Movie Rentals"/>                   
                <fx:Object label="Currently on DVD"/>                    
                <fx:Object label="New To DVD"/>                          
                <fx:Object label="Soon To DVD"/>                         
            </s:ArrayList>                                               
            </s:dataProvider> 
    </s:List> 
</s:View> 
{chap 2 code}/src/views/BrowseView.mxml
The code for the visual layout of the BrowseView is simple, just a list with some data. The 
list component is a Flex component that visualizes data using itemRenderers. The data 
represented in the list component is set with the dataProvider property. You’ve set the list 
to take the entire view, setting the width and height to 100%. The next step will be to add 
List component 
List’s data

Get going with Flex Mobile  
41 
the ActionScript methods that will control the user interaction of the visual elements; in this 
case you want to move views when a user selects an item in a list (see the following listing). 
Listing 2.3 BrowseView.mxml with change handler 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark" title="Rotten Tomatoes"> 
    <fx:Script> 
    <![CDATA[ 
     
    import spark.events.IndexChangeEvent; 
     
    protected function list1_changeHandler(event:IndexChangeEvent):void   
    { 
    var list:List = event.target as List; 
    var selectedItem:Object = list.selectedItem;                          
    navigator.pushView(ListView, null, selectedItem.label);               
    } 
     
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:List width="100%" height="100%" 
            labelField="label" 
            change="list1_changeHandler(event)"> 
        <s:dataProvider> 
            <s:ArrayList> 
                <fx:Object label="In Theaters"/> 
                <fx:Object label="Box Office"/> 
                <fx:Object label="Opening Now"/> 
                <fx:Object label="Coming Soon To Theaters"/> 
                <fx:Object label="Top Movie Rentals"/> 
                <fx:Object label="Currently on DVD"/> 
                <fx:Object label="New To DVD"/> 
                <fx:Object label="Soon To DVD"/> 
                </s:ArrayList> 
        </s:dataProvider> 
    </s:List> 
</s:View> 
{chap 2 code}/src/views/BrowseView.mxml
To do this you need to listen for the change event from the list component. In the handler 
function you get a reference to the list component by referencing the event’s target 
parameter; then you get the item that was selected on the list. Gathering the selection 
List change handler 
Get the selected item 
Push the new view 

42 
CHAPTER 2 Get going with Flex Mobile 
information, you need to pass the selected browse option to the next view. By using the 
context parameter you can tell which ListView you’ll be creating and what sort of data to 
show. 
Where did “navigator” come from?! 
Components within Flex, such as the View component, are complex components with 
many subcomponents, methods, properties, and references to other components. In this 
case you’re using a reference to the main ViewNavigator through the navigator 
property. The main ViewNavigator includes the pop and push methods, not the 
View component itself. 
Right now, there’s no ListView, and you’ll get an error that stops you from running the 
application. In the next section you’ll rectify this error by creating the ListView component 
and show exactly how you use the context value. 
For now, you can comment out the offending line to run your application: 
. . . 
var list:List = event.target as List; 
var selectedItem:Object = list.selectedItem; 
//navigator.pushView(ListView, null, selectedItem.label); 
. . . 
2.3.5 
Creating the list view 
When a user selects a specific list, you need to navigate to the ListView and populate the 
view with the selected list of movies (see the following listing). 
Listing 2.4 ListView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark" 
        title=”ListView”> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:List width="100%" height="100%" id="list">                         
        <s:itemRenderer> 
            <fx:Component> 
                <s:IconItemRenderer                                      
                    iconField="thumbnailPoster"                           
                    iconWidth="61" iconHeight="91"                        
                    labelField="title"/>                                  
               </fx:Component> 
        </s:itemRenderer> 
    </s:List> 
List’s 
ItemRenderer
List component 

Get going with Flex Mobile  
43 
    <!-- error label --> 
    <s:Label id="errorLabel" width="100%"                                
          backgroundColor="#000000" color="#FFFFFF"                       
          paddingBottom="20" paddingTop="20"                              
          textAlign="center" verticalCenter="0"                           
          visible="false" includeInLayout="false"/>                       
</s:View> 
{chap 2 code}/src/views/ListView.mxml
The ListView is a simple view that includes only a single list component with a custom 
itemRenderer to creatively display the list data. Your itemRenderer is the mobile-
optimized complex renderer IconItemRenderer. The IconItemRenderer—provided by 
the Flex SDK—includes an icon, two text labels stacked vertically, and a decorator image on 
the right side. As you already know, by setting properties such as the labelField, 
labelFunction, iconField, iconFunction, messageField, and messageFunction, 
you can control the fields from the data object that the list is visualizing. 
With the basic view laid out, you now need to add the service to your ListView. For this 
you’ll use the RottenTomatoesService component, provided by the RottenTomatoesAS3 
Library 
and 
available 
for 
download 
from 
GitHub 
at 
https://github.com/jonbcampos/RottenTomatoesAS3. 
RottenTomatoesAS3 SWC file 
If you’re having a hard time finding the SWC file, or are just lazy like me, you can use the 
following link to download the RottenTomatoesAS3 SWC file. 
https://github.com/downloads/jonbcampos/RottenTomatoesAS3/RottenTomatoesAS3.swc  
Once you’ve downloaded the RottenTomatoesAS3.swc, you can include the SWC info in your 
project’s libs directory (see figure 2.22). 
Figure 2.22 RottenTomatoesAS3.swc 
Label overlay to 
display any errors

44 
CHAPTER 2 Get going with Flex Mobile 
To include the service into your view, you need to add the service component into your 
declarations section for nonvisual elements: 
. . . 
<fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    <rottentomatoes:RottenTomatoesService id="service"                    
                apikey="yourApiKey"/>                                     
</fx:Declarations> 
. . . 
You’ll give the service an id so you can reference the service via ActionScript and set the 
apiKey property with your apiKey provided by Rotten Tomatoes. 
rottentomatoes custom namespace 
xmlns:rottentomatoes="com.rottentomatoes.*" 
In Flash Builder you don’t have to type the namespaces yourself. If you start typing 
“RottenTomatoesService,” you’ll notice that autocomplete gives you options for 
RottenTomatoesService. 
When 
you 
select 
to 
create 
the 
RottenTomatoesService, Flash Builder will automatically add in the new 
namespace; otherwise, you’d need to add this for your application to compile 
successfully. 
To kick off the service request you need to use a few methods (see the following listing). 
Listing 2.5 View with methods stubbed out—ListView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        xmlns:rottentomatoes="com.rottentomatoes.*" 
        viewActivate="_onView_ViewActivateHandler(event)"> 
<fx:Script> 
<![CDATA[ 
import com.rottentomatoes.events.RottenTomatoesFaultEvent; 
import com.rottentomatoes.events.RottenTomatoesResultEvent; 
import spark.events.ViewNavigatorEvent; 
import spark.events.IndexChangeEvent; 
private function  
_onView_ViewActivateHandler(event:ViewNavigatorEvent):void{} 
private function  
_onService_ResultHandler(event:RottenTomatoesResultEvent):void{} 
private function  
Service 
Api key input 

Get going with Flex Mobile  
45 
_onService_FaultHandler(event:RottenTomatoesFaultEvent):void{} 
private function _onList_ChangeHandler(event:IndexChangeEvent):void{} 
]]> 
</fx:Script> 
<fx:Declarations> 
<!-- Place non-visual elements (e.g., services, value objects) here --> 
<rottentomatoes:RottenTomatoesService id="service" 
                                  apikey="yourApiKey"/> 
</fx:Declarations> 
<!-- list of movie titles --> 
<s:List width="100%" height="100%" id="list" 
    change="_onList_ChangeHandler(event)"> 
<s:itemRenderer> 
        <fx:Component> 
            <s:IconItemRenderer 
                iconField="thumbnailPoster"  
                iconWidth="61" iconHeight="91" 
                labelField="title"/> 
        </fx:Component> 
    </s:itemRenderer> 
</s:List> 
<!-- error label --> 
<s:Label id="errorLabel" width="100%"  
    backgroundColor="#000000" color="#FFFFFF" 
    paddingBottom="20" paddingTop="20"  
    textAlign="center" verticalCenter="0" 
    visible="false" includeInLayout="false"/> 
</s:View> 
{chap 2 code}/src/views/ListView.mxml
The first method responds to the viewActivate event. The viewActivate event is fired 
when the view activates after the transition effect completes from the ViewNavigator. The 
reason you use the viewActivate event instead of any other event from the view 
component is because this event signifies when the transition is complete, keeping the 
transition effect smooth and uninterrupted. The second method is the service result 
handler. This function will set the results of the service to the list component. The third 
method will alert the user to any error that returns from the service. The final method is the 
change handler for the list component. This method will later be used to push the 
DetailsView, providing more finite information on a movie title. 
You may remember from section 2.3.4 that you passed the context property to the 
ListView when pushing it onto the ViewNavigator stack. In the viewActivate handler, 

46 
CHAPTER 2 Get going with Flex Mobile 
you’ll respond to the context property and make a service call based on the context (see 
the following listing). 
Listing 2.6 Making a service call—ListView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        xmlns:rottentomatoes="com.rottentomatoes.*" 
        viewActivate="_onView_ViewActivateHandler(event)"> 
    <fx:Script> 
    <![CDATA[ 
    import com.rottentomatoes.events.RottenTomatoesFaultEvent; 
    import com.rottentomatoes.events.RottenTomatoesResultEvent; 
    import mx.collections.ArrayList; 
    import spark.events.IndexChangeEvent; 
    import spark.events.ViewNavigatorEvent; 
    private function  
_onView_ViewActivateHandler(event:ViewNavigatorEvent):void{ 
        var context:String = navigator.context as String; 
        title = context; 
    service.addEventListener(RottenTomatoesResultEvent.RESULT,  
_onService_ResultHandler);                                                
    service.addEventListener(RottenTomatoesFaultEvent.FAULT,  
_onService_FaultHandler);                                                 
        switch(context){                                                 
        case "In Theaters":                                              
            service.getInTheaterMovies();                                 
            break;                                                       
        case “Box Office":                                               
            service.getBoxOfficeMovies();                                
            break;                                                       
        case "Opening Now":                                              
            service.getOpeningMovies();                                  
            break;                                                        
        case "Coming Soon To Theaters":                                  
            service.getUpcomingMovies();                                 
            break;                                                       
        case "Top Movie Rentals":                                        
            service.getTopRentals();                                     
            break;                                                       
        case "Currently on DVD":                                         
            service.getCurrentReleaseDvd();                              
            break;                                                       
        case "New To DVD":                                                
            service.getNewReleaseDvd();                                   
Select service 
based on context
Add event listeners for Rotten Tomatoes Service 
Add event listeners for Rotten Tomatoes Service 

Get going with Flex Mobile  
47 
            break;                                                       
        case "Soon To DVD":                                              
            service.getUpcomingDvd();                                    
            break;                                                       
        }                                                                
    } 
    private function  
_onService_ResultHandler(event:RottenTomatoesResultEvent):void{ 
        list.dataProvider = new ArrayList(event.result as Array); 
  
    } 
    private function  
_onService_FaultHandler(event:RottenTomatoesFaultEvent):void{ 
    errorLabel.visible = errorLabel.includeInLayout = true;               
    errorLabel.text = event.fault.faultDetail;                            
    } 
    private function _onList_ChangeHandler(event:IndexChangeEvent):void{} 
    ]]> 
    </fx:Script> 
. . . 
{chap 2 code}/src/views/ListView.mxml
First, you’ll use the view’s context property to know which service to call and then add 
event handlers for the result and fault handlers. 
The service result handler function is simple, setting the result value to the list’s 
dataProvider property to display the list of movie titles. The fault handler is just as 
simple, displaying any service faults to the screen with errorLabel. 
With the ListView almost complete, you can start making service calls and seeing 
movie data being displayed to the screen. Be sure to return to the BrowseView and 
uncomment the push view functionality. 
. . . 
protected function list1_changeHandler(event:IndexChangeEvent):void{ 
    var list:List = event.target as List; 
    var selectedItem:Object = list.selectedItem; 
    navigator.pushView(ListView, null, selectedItem.label); 
} 
. . . 
At this point I’d recommend you take a second and click around in your app; you’ll enjoy 
playing with the results. But before doing so, you’ll want to comment out the line in your 
RottenTomatoesApplication.mxml that references the nonexistent SearchView. In the next 
Select service 
based on context
Set list’s dataProvider 
Display any 
errors 

48 
CHAPTER 2 Get going with Flex Mobile 
section you’ll expand your abilities by adding the SearchView, giving users the ability to 
search through the Rotten Tomatoes library of movies. 
2.3.6 
Creating the search view 
Although the ability to browse for movies based on a variety of predefined lists is great, 
many of your users will want to be able to search for the exact movie title—the SearchView 
will enable this feature (see the following listing). 
Listing 2.7 SearchView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark"  
    title="Search" xmlns:rottentomatoes="com.rottentomatoes.*"> 
    <fx:Script> 
    <![CDATA[ 
    import com.rottentomatoes.events.RottenTomatoesFaultEvent; 
    import com.rottentomatoes.events.RottenTomatoesResultEvent; 
    import spark.events.IndexChangeEvent; 
    private function _onSearchButton_ClickHandler(event:MouseEvent):void{} 
    private function _onList_ChangeHandler(event:IndexChangeEvent):void{} 
    private function  
_onService_ResultHandler(event:RottenTomatoesResultEvent):void{} 
    private function  
_onService_FaultHandler(event:RottenTomatoesFaultEvent):void{} 
    ]]> 
    </fx:Script> 
     
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    <rottentomatoes:RottenTomatoesService id="service"                    
            apikey="yourApiKey" 
            result="_onService_ResultHandler(event)" 
            fault="_onService_FaultHandler(event)"/> 
    </fx:Declarations> 
    <s:titleContent> 
        <s:TextInput id="searchInput" width="100%"/>                      
    </s:titleContent> 
    <s:actionContent> 
Rotten Tomatoes service 
Text input 

Get going with Flex Mobile  
49 
        <s:Button label="Search"                                          
            click="_onSearchButton_ClickHandler(event)"/> 
    </s:actionContent> 
    <!-- list of movie titles --> 
    <s:List width="100%" height="100%" id="list"                          
            change="_onList_ChangeHandler(event)"> 
        <s:itemRenderer> 
            <fx:Component> 
             <s:IconItemRenderer 
                    iconField="thumbnailPoster"  
                    iconWidth="61" iconHeight="91" 
                    labelField="title"/> 
            </fx:Component> 
        </s:itemRenderer> 
    </s:List> 
    <!-- error label --> 
    <s:Label id="errorLabel" width="100%"                               
             backgroundColor="#000000" color="#FFFFFF"                    
             paddingBottom="20" paddingTop="20"                           
             textAlign="center" verticalCenter="0"                        
             visible="false" includeInLayout="false"/>                    
</s:View> 
{chap 2 code}/src/views/SearchView.mxml
The SearchView is similar to the ListView in that it includes a list for the results, a 
service to retrieve the results, and an errorLabel to display if anything unexpected 
happens. The SearchView builds on the ListView by including a TextInput for the 
search term and a Button for the user to initiate the search function. To make the 
SearchView work, you’ll need a few functions to react to user input and search results. 
After looking at the visual layout, you’ll focus on the method implementations. 
To build the functionality into the SearchView, you need to add some code to your 
event handlers: 
import mx.utils.StringUtil; 
private function _onSearchButton_ClickHandler(event:MouseEvent):void 
{ 
    errorLabel.visible = errorLabel.includeInLayout = false;              
    var term:String = StringUtil.trim( searchInput.text );                
    if(term.length>0) 
        service.getMoviesByTerm( term );                                  
} 
In this function you want to initiate a search only if there’s text in the text input. If text 
exists, then you want to search for the movie titles. One helpful thing to do is to use the trim 
Call the search method 
Search list 
Show errors 
Hide any 
shown errors
Clean up the search string 
Call the search method 

50 
CHAPTER 2 Get going with Flex Mobile 
method to remove any leading or trailing spaces so that any extra spaces don’t affect your 
search results. Finally, you want to remove the errorLabel if it’s being shown from 
previous errors. 
After making the service call, the next task is to deal with the results from the service 
(see the following listing). 
Listing 2.8 Result/fault handlers 
private function 
_onService_ResultHandler(event:RottenTomatoesResultEvent):void{ 
    var results:Array = event.result as Array;                            
    list.dataProvider = new ArrayList( results );                         
    if(results.length==0){                                                
        errorLabel.visible = errorLabel.includeInLayout = true;           
        errorLabel.text = "No Results Returned";                          
    } 
} 
private function  
_onService_FaultHandler(event:RottenTomatoesFaultEvent):void{ 
    errorLabel.visible = errorLabel.includeInLayout = true;               
    errorLabel.text = event.fault.faultDetail;                            
} 
{chap 2 code}/src/views/SearchView.mxml
First, you need to respond to any successful results. In the result handler you need to pull 
the results and set the dataProvider with the results. You also need to deal with the 
possibility that there will be no results. Rather than just not showing any results, you’ll alert 
the user that there are no results by using the errorLabel. 
Like the fault handler in the ListView, the fault handler in the SearchView needs to 
display any faults that are returned by the service. 
We’re going to skip the list change handler method right now until after the next section 
when you create the DetailsView. Once you have created the DetailsView, you’ll come 
back and add the push method into the SearchView list change handler. Definitely stop 
now and do some searching for your favorite movies. 
2.3.7 
Creating the details view 
Whether you navigate from the BrowseView or the SearchView, you’ll reach the 
DetailsView eventually. The DetailsView shows specifics about a single title, including 
the Rotten Tomatoes Scores and the movie synopsis, as shown in the following listing. 
Listing 2.9 DetailsView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark" 
Get the results 
Set the list’s dataProvider
Check if results exist 
Show “no 
results” 
Show any 
errors 

Get going with Flex Mobile  
51 
        viewActivate="_onView_ViewActivateHandler(event)"> 
    <fx:Script> 
    <![CDATA[ 
    import com.rottentomatoes.vos.MovieVO; 
    import spark.events.ViewNavigatorEvent; 
    private function  
_onView_ViewActivateHandler(event:ViewNavigatorEvent):void{               
        var movie:MovieVO = data as MovieVO;                             
        title = movie.title;                                             
        image.source = movie.detailedPoster;                             
        details.text = movie.synopsis;                                   
        audienceScoreImage.source = movie.audienceIcon;                   
        audienceScoreDetails.text = movie.audienceScore+"%";              
        criticsScoreImage.source = movie.criticsIcon;                     
        criticsScoreDetails.text = movie.criticsScore+"%";                
    } 
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:Scroller width="100%" height="100%"> 
        <s:VGroup width="100%" height="100%"  
                               clipAndEnableScrolling="true"> 
        <!-- first section --> 
        <s:HGroup width="100%" 
            paddingBottom="5" paddingLeft="5" 
            paddingRight="5" paddingTop="5"> 
            <!-- left, image --> 
            <s:Image id="image" width="180" height="267"/> 
            <!-- right, scores --> 
            <s:VGroup width="100%"> 
                <!-- audience section --> 
                <s:Label width="100%" text="Audience Score"/> 
                <s:HGroup width="100%" 
                     paddingBottom="5" paddingLeft="5" 
                      paddingRight="5" paddingTop="5"> 
                    <s:Image id="audienceScoreImage"/> 
                    <s:Label id="audienceScoreDetails" 
                                 width="100%"/> 
                </s:HGroup> 
viewActivate
handler 
Set data on 
View

52 
CHAPTER 2 Get going with Flex Mobile 
                <!-- critics section --> 
                <s:Label width="100%" text="Critics Score"/> 
                <s:HGroup width="100%" 
                    paddingBottom="5" paddingLeft="5" 
                     paddingRight="5" paddingTop="5"> 
                     <s:Image id="criticsScoreImage"/> 
                     <s:Label id="criticsScoreDetails" 
                                      width="100%"/> 
                     </s:HGroup> 
                </s:VGroup> 
            </s:HGroup> 
            <!-- second group --> 
            <s:Label width="100%" text="Synopsis"/> 
            <s:Label id="details" width="100%"/> 
        </s:VGroup> 
    </s:Scroller> 
</s:View> 
{chap 2 code}/src/views/DetailsView.mxml
When the view is ready, you’ll set the data passed from the data property to the visual 
components in the DetailsView. 
To complete this section, you’ll go back to the ListView.mxml and SearchView.mxml. 
Both of these components include a method to respond to the list selection change: 
. . . 
private function _onList_ChangeHandler(event:IndexChangeEvent):void{ 
    navigator.pushView(DetailsView, list.selectedItem);                   
} 
. . . 
When a title is selected from the list, you push a new view onto the stack and pass the 
selected title to the DetailsView. 
With the DetailsView complete and integrated, the basics of your application are 
complete. You can search and browse movie titles and view more specifics on the selected 
movie title. 
2.4 
Persisting navigator state 
When you run your application, you may get annoyed when you close your application on the 
DetailsView and open the application to see the firstView again. You, and your users, 
may instead expect to see the DetailsView when your application starts up again. To solve 
this 
problem, 
the 
Application, 
the 
ViewNavigatorApplication 
and 
the 
Push view with 
data 

Get going with Flex Mobile  
53 
TabbedViewNavigatorApplication 
include 
a 
property 
called 
persistNavigatorState: 
<?xml version="1.0" encoding="utf-8"?> 
<s:TabbedViewNavigatorApplication xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark" 
        persistNavigatorState="true"> 
    <s:ViewNavigator label="Browse" width="100%" height="100%"  
        firstView="views.BrowseView"/> 
    <s:ViewNavigator label="Search" width="100%" height="100%" 
    firstView="views.SearchView"/> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
</s:TabbedViewNavigatorApplication> 
The persistNavigatorState property tells the application to store the state of the 
ViewNavigator and any data that you’ve set using the data and context properties in 
your push method. There are three caveats to using this functionality. 
The first caveat is that persistNavigatorState doesn’t store or set the state of the 
view or the data pulled by the application. Don’t worry about how you’ll store this 
information; in the next chapter we’ll focus on creating this solution. 
The second caveat is that this functionality is turned off by default. If you intend to use 
this functionality, you need to remember to turn on the switch. 
The third and final caveat is that the navigator’s state will be forgotten if the application 
is uninstalled and then reinstalled or if the application’s data cache is cleared. You shouldn’t 
worry about these two scenarios, because it should be apparent to the user that if they 
remove the application or clear the application’s memory, the navigator state will also be 
removed. 
2.5 
Summary 
We’ve come a long way on this journey, but there are many more steps that we need to 
take. Hopefully you can already see what amazing applications you can put together. In the 
upcoming chapters you’ll find smart ways to persist your data even after the application has 
closed, respond to varying screen sizes, and update your application to being enterprise 
ready with a full-strength MVC architecture. 
Key takeaways: 
 
The ViewNavigator pushes and pops views to control application navigation. 
 
You can run an application on the desktop or on your device of choice. 
 
Adding new desktop configurations is easy. 
 
You can prevent views from destruction by the destruction policy. 
 
You can customize ActionBars for your application or remove them completely. 

54 
3  
Persisting data 
This chapter covers 
 
Using local shared objects 
 
Creating a SQLite database 
 
Understanding the PersistenceManager 
 
Customizing the IPersistenceManager with SQLite 
The problem with mobile development is that at any time the mayor may call and your 
application will be interrupted. In desktop development if an instant message comes in or the 
user gets a bout of ADD, then the user can launch a new window and continue with both 
applications. This isn’t the situation with the mobile environment. In the mobile environment 
if any of these distractions affect your user, then the interrupting application will take 
precedence and your application will be put into the background. This may not sound like an 
issue except that the operating system may at any time close applications, especially 
applications that are in the background. At any moment your application may be shut down, 
and any data that you’ve requested and the state of your application will be lost. 
When talking about the application state, many developers think only of the data that’s 
stored within the application. Actually, the application state is everything from the data 
within the application to how the application looks and any current changes made by the 
user. Our intention is to keep, in an intelligent fashion, the data pulled from any services, list 
scrolls, and paging locations along with any data input by the user. When I say “an 
intelligent fashion,” I’m referring to the fact that you won’t want to store all the data forever. 
At times you’ll want to have your application forget its state, such as when the user closes 
the application or hasn’t used the application in some time. At moments like these, the user 
would expect to start the application in a clean state. 

Persisting data 
55 
How can you do this? The theory is simple and the implementation can get tedious, but 
by setting up simple patterns in the code, you can easily manage your application state no 
matter the interruption. 
In the last chapter we talked about the ViewNavigator and the View component for 
your individual views. The ViewNavigator is the navigation stack that facilitates pushing 
and popping views for user interaction. The View component built into the Flex SDK provides 
convenient hooks for application state persistence, specifically the viewActivate and 
viewDeactivate events.  
Although many developers may think it’s obvious to react to the application’s open and 
close events or even a view’s show and hide events, these events are ultimately flawed 
because they may not always fire depending on how the view is added or removed from the 
application. The viewActivate and viewDeactivate events are stable, consistent events 
that can be listened to on each view.  
The concept is that when a view is activated, you’ll go to your data persistence layer, pull 
any necessary data, and set the view with that data to restore the view’s state. When the 
view is deactivated, you’ll then take any data from the view state that you intend to store 
and set it to your persistence layer. With this complete cycle (see figure 3.1), the view state 
will always be stored and set appropriately whether a phone call interrupts the application or 
the user leaves the application to check the newest tweet that comes in. 
Figure 3.1 Mobile data persistence theory 
In this chapter we’ll focus on the three ways to store data and provide the pros and cons to 
each selection. We’ll look at the local shared object, SQLite, and finally the new 
PersistenceManager. With all these options it will be obvious that data persistence is 
simple to include in your application, holding the data and the application state that you’ve 
spent so much time creating. 
3.1 
Storing data with the local shared object 
The first option to persisting data on a mobile device is to use an old Flash favorite, the local 
shared object—a simple data storage system built into Flash Player. 

56 
CHAPTER 3 Persisting data 
In the past developers thought of the local shared object (LSO) as a super cookie in the 
browser, but the LSO is much simpler than a cookie and much more helpful, especially in the 
case of mobile development. In the browser the LSO was stored with Flash Player and 
provided a simple way to securely store typed objects between application sessions without 
having to communicate with a middle tier. Many Flash and HTML browser applications used 
the LSO to store unique IDs and other bits of information— especially if they wanted to hide 
some data from the user when clearing their cookies.  
Within the AIR runtime you store the LSO to the filesystem in a folder accessible to the 
application. Just as with LSOs in Flash Player, you can store and retrieve typed objects 
without having to parse the data. 
There are pros and cons to using an LSO that should affect your decision to use or not 
use the LSO and in what situation. The first big positive feature of the LSO is how simple it is 
to use—just a few lines of code and you’re good to go. Second, unlike cookies, LSOs never 
expire, meaning that any data you set to the LSO will be there until you explicitly remove the 
data or the user uninstalls the application. Third, the data stored in an LSO is encoded but 
not secure. LSOs use the AMF3 messaging format to encode and decode the data. The AMF3, 
or Action Message Format, created originally by Macromedia, is an open protocol that uses a 
fully binary format to describe data. 
By design it’s lightweight and fast, and it doesn’t provide human-readable files—a benefit 
for security and storage. But it isn’t a secure format and can be decoded by various 
applications.  
Furthermore, if you’re storing an array of data within the LSO, the LSO doesn’t have any 
optimized way to find specific records the way that SQL can query for records. If you need to 
find a specific row within your data or create complicated data joins, you’ll need to iterate 
through the array and find your data. This can be a slow process if you have large data sets. 
The AIR security model doesn’t allow cross-application LSO access, but if someone 
wanted to get to the LSO file, it would only be a matter of time before they could access the 
file and decode the data. Therefore, I don’t recommend storing data objects like credit card 
numbers, passwords, or other sensitive information. Table 3.1 lists some pros and cons of 
LSOs. 
Table 3.1 Pros and cons of local shared objects 
Local shared object pros 
Local shared object cons 
Quick to implement 
Great for small data sets 
Supports typed data 
Fast and lightweight 
No strict data schema 
Provides no migration path 
Requires iteration to find data 
No strict data schema 
Not secure 

Persisting data 
57 
Now that you understand how to use an LSO, we’ll spend the rest of this section looking at 
the code to create an LSO and set data to it. Using an LSO, you’ll store the data returned in 
the ListView so that you don’t always have to call a service each time you move through 
your application. 
3.1.1 
Creating a local shared object 
The first thing you need to do is return to your Rotten Tomatoes application and the 
ListView.mxml file to add in the code to instantiate and access the LSO: 
. . . 
private function _onView_ViewActivateHandler(event:ViewNavigatorEvent):void 
{ 
    var context:String = navigator.context as String; 
    title = context; 
    //persistence layer 
    var lso:SharedObject = 
SharedObject.getLocal("com.unitedmindset.RottenTomatoes");                
    service.addEventListener(RottenTomatoesResultEvent.RESULT, 
_onService_ResultHandler); 
. . . 
You can see you added in code to access the shared object. You’ll notice that unlike with 
other variables, you don’t use the “new” operator to instantiate the shared object. Instead, 
you pull the local version of the shared object by name. You’re using the reverse domain 
naming scheme from the application for the name of the shared object, but you can change 
this as you see fit. The reverse domain naming helps ensure uniqueness by using your 
unique domain for the name, preventing conflicts between LSOs of the same name. Don’t 
worry about the shared object not being there. If the shared object doesn’t exist, the AIR 
runtime will automatically create a new one and instantiate it. Now anywhere in your 
application you can access this same shared object by using the same name when requesting 
it. 
3.1.2 
Interacting with a local shared object 
Once you’re connected to the LSO you need to get and set the data on the viewActivate
and service result event handlers, respectively. The following listing updates the 
viewActivate handler in the ListView.mxml. 
Listing 3.1 ListView.mxml updating the viewActivate handler to get LSO data 
. . . 
private function _onView_ViewActivateHandler(event:ViewNavigatorEvent):void 
{ 
    var context:String = navigator.context as String; 
    title = context; 
    var lso:SharedObject = 
Start up our 
SharedObject 

58 
CHAPTER 3 Persisting data 
    SharedObject.getLocal("com.unitedmindset.RottenTomatoes");            
    var listData:ArrayList = lso.data[title] as ArrayList;                
    if(listData){ 
        list.dataProvider = listData;                                     
        return; 
    } 
    service.addEventListener(RottenTomatoesResultEvent.RESULT,  
    _onService_ResultHandler); 
    service.addEventListener(RottenTomatoesFaultEvent.FAULT, 
    _onService_FaultHandler); 
. . . 
{chap 3 code}/src/views/ListView.mxml
LSOs use an untyped data property to hold their data in key/value pairs. Once you have a 
reference to the LSO, you access the data by using the view’s title property. You could use 
other keys for your key/value pair but the title property is an effective key because it’s 
already unique for each instance of the ListView. If a value exists for the key provided, 
you set it to a new variable as an ArrayList. You may know already that an ArrayList is 
a specific type of an array within Flex, providing the ability to create a list of data while 
adding some extra functionality for Flex components such as the list component you’re using.  
The next thing you need to do is run a quick check to make sure you received a valid 
value and then, if it exists, set the persisted list of movies to the list’s dataProvider. 
Finally, if the value exists and you set the value to the dataProvider, you stop the 
function from continuing, because you no longer want to call any of the services. If the value 
doesn’t exist, then you continue with the function and call the requested service functions as 
necessary. 
To complete the cycle of data persistence you also need to respond to store the data on 
the service response event from the RottenTomatoesService: 
. . . 
private function  
_onService_ResultHandler(event:RottenTomatoesResultEvent):void{ 
    list.dataProvider = new ArrayList( event.result as Array );
    var listData:ArrayList = new ArrayList(event.result as Array); 
    list.dataProvider = listData; 
    var lso:SharedObject = 
    SharedObject.getLocal("com.unitedmindset.RottenTomatoes");            
    lso.data[title] = listData;                                           
    lso.flush();                                                          
} 
. . . 
Like the get functionality, you start by getting a reference to your LSO and then use the 
title property for your key on the LSO’s data object. You set the key’s value to the list’s 
dataProvider value and then flush the LSO—a process that writes out the persisted data 
Reference the 
LSO 
Access data’s title 
as ArrayList 
If value exists, use it 
and stop
Get the LSO 
Set the data 
to the LSO
Store the data 
to the LSO

Persisting data 
59 
to a file (see figure 3.2). If you’ve previously used LSOs in the browser, then you’re probably 
not used to flushing the LSO: 
var lso:SharedObject = 
SharedObject.getLocal("name");   lso.data[title] = value;     lso.flush() 
Figure 3.2 Setting data and flushing an LSO 
Flush the LSO 
Whenever a browser-based application is closed, any connected LSOs automatically get 
their data flushed. As you’ve learned, the application doesn’t always know when it’s being 
closed, which means the LSO isn’t reliably flushed. Therefore, you explicitly flush the LSO 
when you give it new data. As a side note, always make sure that the values actually 
changed before flushing the LSO or you may slow down your application with repeated, 
unnecessary flushing. 
By adding the storage functionality, the cycle is complete and you can run and test your 
application, ensuring that if the data already exists, you don’t call for the service again. This 
one little change will vastly improve the perceived speed of your application. 
OOPS! A LOGIC BUG! 
While testing out the new functionality you’ve probably already noticed a major flaw in your 
application. After the first time you pull the data, the lists will never update because data 
always exists. To fix this bug you need to also store a variable in the LSO that says how old 
the data is. With this data addition you’ll know if the data is too old and be able to decide 
whether to make the service call after all. For this application, you’re going to assume that if 
the data is more than an hour old, it’s too old to use: 
. . . 
private function _onView_ViewActivateHandler(event:ViewNavigatorEvent):void 
{ 
    var context:String = navigator.context as String; 
    title = context; 
var lso:SharedObject = 
SharedObject.getLocal("com.unitedmindset.RottenTomatoes"); 
var listData:ArrayList = lso.data[title] as ArrayList; 
var timestamp:Number = lso.data[title+" Timestamp"] as Number;         
var dataIsValid:Boolean; 
Pull the 
timestamp

60 
CHAPTER 3 Persisting data 
if(!isNaN(timestamp)) 
dataIsValid = (new Date().time - 3600000 /* one hour */) < timestamp;  
if(listData && dataIsValid){                                           
    list.dataProvider = listData; 
    return; 
} 
. . . 
By pulling the timestamp from the LSO, you now can compare old data to the current 
timestamp. If the timestamp value is less than one hour old, you mark the data as valid and 
set the data to your list. The amount of time to keep the data as valid is completely up to 
your application and the type of data that you’re evaluating. 
With the viewActivate handler responding appropriately to new timestamp 
functionality, the only thing left to do is set the timestamp value when the service result 
returns from Rotten Tomatoes: 
. . . 
private function  
_onService_ResultHandler(event:RottenTomatoesResultEvent):void{ 
    var listData:ArrayList = new ArrayList(event.result as Array); 
    list.dataProvider = listData 
    var lso:SharedObject = 
    SharedObject.getLocal("com.unitedmindset.RottenTomatoes"); 
    lso.data[title] = listData; 
    lso.data[title+" Timestamp"] = new Date().time;                       
    lso.flush(); 
} 
. . . 
With a single line of code you set the timestamp on the LSO and then store all of the data 
using the same flush method from earlier. 
With your LSO working, you may wonder if there are any other options to your data-
persistence needs. We’ll continue with another data persistence option, SQLite. 
3.2 
Storing data using SQLite 
The second option to persisting data on a mobile device is to use a new favorite introduced 
with Adobe AIR: SQLite databases. Using SQLite databases, you can store your application 
data in a secure database and query your data just as you would any other database.  
As the name implies, SQLite is a lightweight SQL database that effectively handles large 
datasets and works closely with Adobe AIR. SQLite gives you all the power that you expect 
from a database, including support for tables, multiple variable types, indexing, joins, cross-
table and cross-database queries, and transactions. If you want to see more details on 
SQLite, be sure to check out the SQLite website: http://sqlite.org. 
Compare the 
timestamp for 
validity 
Set the data if 
valid 
Set the timestamp 

Persisting data 
61 
Like any other solution, SQLite has its pros and cons, as shown in table 3.2. The first pro 
is that SQLite can use secure settings to encrypt the database. Using an encrypted database, 
you can securely store passwords, credit card numbers, and any other data.  
Why not secure all data? 
You may be thinking right now that you’ll just encrypt all of your data. The question is, 
why not? The answer is simple: speed and convenience. Encrypting and decrypting data 
takes time; the more data and the more transfers, the more time. Depending on your 
application and the device, this may be an issue for your specific case. Remember that 
you don’t have to secure all of your data. You can pick and choose the data to encrypt, 
keeping your data fast to access. 
One con for SQLite databases is the amount of coding effort it takes to create over other 
persisting models. But with this extra complexity come many more options for data splicing. 
With SQLite databases, and a bit of effort, you can support storing and retrieving typed 
objects along with combining data in a variety of formats.  
Another feature of SQLite databases is that you have the choice between synchronous 
and asynchronous database requests. If your database requests execute quickly, you may 
have no need to use asynchronous requests, because the impact on visual performance 
would be nil. If you find that the display list freezes when making database requests, then 
you’ll want to use asynchronous requests to protect your display list. 
Finally, the main reason why developers use SQLite databases in AIR applications is 
because they’re fast. If you find yourself continuously iterating through arrays within an LSO 
to find a specific entry, then you’re probably losing performance. SQLite databases are fast 
at pulling specific records. 
Table 3.2 SQLite pros and cons 
SQLite pros 
SQLite cons 
Supports encrypted data 
More options for data access 
Supports synchronous access 
Supports asynchronous access 
Reduces iteration through data 
Provides strict schema 
Supports typed data 
Takes additional coding 
More chances for mistakes 
Strict schema requires more migration effort 

62 
CHAPTER 3 Persisting data 
Moving forward with SQLite database development, you’ll remove the LSO from your 
application and try persistence with the SQLite database. As with any object-oriented 
program, if any single class becomes too complicated or includes too much functionality, you 
should create new classes to encapsulate its functionality. If you were to put all the database 
code into ListView, then ListView would balloon and become unmanageable. So for this 
section 
you’re 
going 
to 
create 
a 
new 
class 
to 
handle 
the 
SQLite 
database, 
SQLPersistenceManager. 
You’ll be integrating your SQLPersistenceManager into the ListView that you used 
an LSO for in the last section. For now, you’ll be adding code, and then at the end of this 
section, you’ll test and integrate. 
3.2.1 
Connecting to SQLite 
To start this new class you’ll create a new package, com.unitedmindset.managers, and 
a new class, SQLPersistenceManager: 
package com.unitedmindset.managers 
{ 
    import flash.data.SQLConnection;                                      
    import flash.data.SQLResult; 
    import flash.data.SQLStatement; 
    import flash.errors.SQLError; 
    import flash.filesystem.File; 
    public class SQLPersistenceManager{ 
        public function SQLPersistenceManager(){}                         
    } 
} 
Import statements won’t exist and should be added during coding by your IDE. You can add 
them now if you prefer . With your new class ready to go, the first thing you need to do is 
connect to the database. Making a connection to the database is required before creating any 
database tables or running any SQL statements, as shown in the following listing. 
Listing 3.2 SQLPersistenceManager.as create connection 
private var _connection:SQLConnection; 
private function _checkConnection():void{ 
    if(!_connection) 
        _connection = new SQLConnection();                                
    if(!_connection.connected){                                           
        var dbFile:File = File.applicationStorageDirectory.resolvePath( 
        "rottentomatoes.db");                                             
        try{ 
            _connection.open(dbFile);                                     
        } catch(error:SQLError) { 
Constructor 
 Import statements 
Create database connection 
Check if connection exists 
Access database file 
Open synchronous database connection 

Persisting data 
63 
            //Houston, we have a problem 
        } 
    } 
} 
{chap 3 code}/src/com/unitedmindset/managers/SQLPersistenceManager.as 
The plan is for a connection to be created only once. You set up this method to double-check 
that the connection exists, and you won’t make more than one connection. If you were to 
make a new connection for each request to the database, you’d waste a lot of computational 
cycles just connecting to the database—cycles that aren’t necessary because you can hold a 
reference to your database connection pretty easily. 
You’ll use this private method before each database access operation. The intention of 
this method is to first check to see if your SQLConnection instance exists; if not, the 
method makes a new SQLConnection instance. The next thing that your method does is 
check to see if a connection to the database exists. As you did earlier, if the connection 
doesn’t exist, you’ll make a connection to the rottentomatoes.db database file and open the 
connection. You’ll notice the open connection method is wrapped in a try..catch block; 
this is done to catch any possible error that’s thrown by the AIR runtime when creating the 
connection. If you were using an asynchronous database connection, then you’d listen for 
the result and error events instead of the try..catch statement. If all goes well, then the 
connection will be created only once, and you can check that this connection exists without 
affecting the performance of your application. 
3.2.2 
Creating a SQLite table 
Once you’ve connected to the SQLite database, you need to create a table to hold your data. 
You’ll quickly notice that you’re creating a key/value pair table. Although you could create a 
much more complicated database schema, this will suffice for your application (see the 
following listing). 
Listing 3.3 SQLPersistenceManager.as create table 
private var _createTableStatement:SQLStatement; 
private function _checkTable():void{ 
    if(!_createTableStatement){ 
        _createTableStatement = new SQLStatement(); 
        var sql:String =  
            "CREATE TABLE IF NOT EXISTS storage (" +                      
            "id INTEGER PRIMARY KEY AUTOINCREMENT, " +                    
            "key TEXT UNIQUE, " +                                        
            "value BLOB" +                                               
            ")";                                                         
        _createTableStatement.sqlConnection = _connection; 
        _createTableStatement.text = sql; 
SQL statement 

64 
CHAPTER 3 Persisting data 
    } 
    try{ 
        _createTableStatement.execute();                                  
    } catch(error:SQLError){ 
        //Dang 
    } 
} 
{chap 3 code}/src/com/unitedmindset/managers/SQLPersistenceManager.as
Creating tables in SQLite is simple, but if this is your first foray into SQL, you’ll probably find 
SQL easy to read but will be unsure of all the options. Although the SQL language is outside 
the scope of the book, the SQL you’ll be using should be easy to understand, and we’ll look 
into the code line by line.  
As noted by the name, the _checkTable() method ensures that the key/value table 
exists, and if it doesn’t exist, it creates the table. To execute SQL statements in AIR, you 
need to use a SQLStatement class instance to manage the execution.  
Reuse SQLStatements  
These SQLStatements are labor intensive on the runtime, which is why I hold a 
reference to the SQLStatement in the SQLPersistenceManager class, so that I 
only have to create it once. This is good advice for any SQLStatements that you use. 
Hold a reference to your SQLStatement instances, and you’ll find that your code runs 
much faster.  
Why is it faster? 
After the first execution of a SQLStatement, the statement is optimized by the SQLite 
engine for reuse. By keeping a reference to the SQLStatement, you’re taking full 
advantage of the performance optimizations built into the AIR runtime and SQLite engine. 
If you’re wondering how you’ll reuse SQLStatements when the values need to change 
based on parameters, be patient. In the next section we’ll look specifically at using 
parameters within SQLStatements. 
In the _createTable() method you check to see if your SQLStatement exists; if not, you 
create the SQLStatement instance. Then you create the SQL code that the 
_createTableStatement variable will execute. 
The SQL statement is fairly simple to use to create a new table. First, you use CREATE 
TABLE IF NOT EXISTS to create a table only if it doesn’t already exist in the database. 
The next part, storage, is the name of the table that you’re creating.  
The next section is broken up within the parenthesis and separated by commas. These 
subsections signify the columns in the table and the column’s data type. You’ve also added 
the UNIQUE clause to the key column to ensure that each value in the key column is unique. 
With the instructions given, the table, while empty, currently looks like table 3.3. 
Execute statement 

Persisting data 
65 
Table 3.3 The key/value table  
id 
key 
value 
… 
… 
… 
After 
you’ve 
created 
the 
SQL 
for 
your 
SQLStatement, 
you 
set 
the 
_createTableStatement with a reference to the SQLConnection instance that you’ll 
execute your code on. Finally, you execute the SQLStatement as you did earlier, within a 
try..catch statement to respond to any errors thrown. With your table created, you’ll next 
add functions to read, write, delete, and update the table. 
ID column 
For this example you won’t use the ID column because you have a key column. I felt it 
would be helpful to show the code for how to create an auto-incrementing, primary key 
column in SQLite.  
3.2.3 
Reading from SQLite 
In no particular order you’ll start by adding the ability to read from the table. Reading from a 
database table is easy and will introduce a few new concepts, both for your SQL code and 
SQLStatements (see the following listing). 
Listing 3.4 SQLPersistenceManager read from table 
private var _readStatement:SQLStatement; 
private function _readFromTable(key:String):Object{ 
    if(!_readStatement){ 
        _readStatement = new SQLStatement(); 
        _readStatement.sqlConnection = _connection; 
        var sql:String = "SELECT value " +                                
            "FROM storage " +                                            
            "WHERE key = :key " +                                         
            "LIMIT 1";                                                   
        _readStatement.text = sql; 
    } 
    _readStatement.parameters[":key"] = key;                              
    try{ 
        _readStatement.execute(); 
        var result:SQLResult = _readStatement.getResult();                
        if(!result.data || result.data.length==0) 
            return null; 
        return result.data[0]["value"];                                   
    } catch(error:SQLError){ 
SQL Statement 
Set the :key parameter 
Get result from query 
Return queried data 

66 
CHAPTER 3 Persisting data 
        //Danger Will Robinson, Danger 
    } 
    return null; 
} 
{chap 3 code}/src/com/unitedmindset/managers/SQLPersistenceManager.as
As with _checkTable() you start by having a reference to the _readStatement variable 
for performance reasons. When you start the _readFromTable() method, the first thing 
you need to do is check to see if the _readStatement exists, and if it doesn’t, make it. Like 
earlier statements, the _readStatement needs a reference to the SQL connection and 
some SQL code to run. 
The next part varies from previous functions that you’ve created because you’re 
introducing statement parameters. A parameter is a token specified to be a placeholder in 
the SQL expression for a value that will be inserted while executing the SQL expression, also 
known as at runtime.  
In the SQL statement you’ll notice the parameters being signified by the colon (:). Using 
the colon, you set up named parameters. This way, if you set the parameter :key in your 
SQL expression, you can then set the execution value with the following code: 
ourStatement.parameters[":key"] = key; 
In your SQL statement the parameter is the :key parameter. You use parameters for two 
reasons; the first is so you can keep your optimized SQLStatement without changing the 
SQL statement. The second reason is that using parameters protects your SQL statement 
from SQL injection attacks.  
SQL injection attacks 
SQL injection attacks are malicious attacks that insert unwanted SQL code into your SQL 
statements. Hackers who use these attacks inject SQL code to drop tables, pull 
passwords, log in without proper passwords, and so on. By using parameters you can 
protect yourself from these attacks because the actual SQL statement is defined by you—
the developer—and only the parameter’s value is the unwanted value. These unwanted 
values will likely error out and cause no long-term negative effects. 
You now introduce a new form of SQL statement, the SELECT statement, which pulls data 
from a database. Based on the options that you use in the SELECT, you can pull just specific 
columns, from specific tables, with specific values. Your SELECT statement starts out by 
selecting the value column, from the storage table, where the key value equals the :key 
parameter. Finally, you use the limit option to limit the results pulled to one line. The 
benefit of using the limit parameter is that the SQL code is optimized to stop executing 
after the first instance is found. 
In the next code segment you set the :key parameter to be the key variable and then 
execute your statement within the try..catch block, followed by accessing the data pulled 
by the execute method. You pull the SQL result by using the getResult() method. With 

Persisting data 
67 
the result reference you can check to see if any data was returned, and if there’s data, you 
return the data from the function. The returned data sample can be seen in table 3.4. 
Table 3.4 Returned data structure 
Row 
Data 
[0] 
{"value": value} 
The getResult() method returns an array of objects that meet your SELECT criteria. In 
this case you have one object with the selected columns, the value column. To return the 
proper data you need to access the right data by accessing the correct row; in this case 
there’s only one, and then you access the correct column, in this case the value column. 
With everything set, you can now return the proper data when requested. 
3.2.4 
Writing to SQLite 
Now that you can read values from your database file you need to start adding data using 
the INSERT option (see the following listing). 
Listing 3.5 Write to table 
private var _writeStatement:SQLStatement; 
private function _writeToTable(key:String, value:Object):void{ 
    //create statement 
    if(!_writeStatement){ 
        _writeStatement = new SQLStatement(); 
        _writeStatement.sqlConnection = _connection; 
        var sql:String = "INSERT OR REPLACE INTO storage " +              
            "(key, value) " +                                            
            "VALUES " +                                                  
            "(:key, :value)";                                            
        _writeStatement.text = sql; 
    } 
    //set parameters 
    _writeStatement.parameters[":key"] = key;                             
    _writeStatement.parameters[":value"] = value;                         
    //execute statement 
    try{ 
        _writeStatement.execute(); 
    } catch(error:SQLError){ 
        //I have a bad feeling about this... 
    } 
} 
{chap 3 code}/src/com/unitedmindset/managers/SQLPersistenceManager.as 
Insert/replace 
values in 
storage
table
Set 
parameters

68 
CHAPTER 3 Persisting data 
The _writeToTable() method is similar to the _readFromTable() method in the last 
section. Because of the similarities, we’ll look specifically at the SQL statement—the main 
difference between the two methods. The first section in the SQL is INSERT OR REPLACE 
INTO storage, which inserts or replaces data into the storage table.  
Unique rows 
The replace functionality that you’re using is due to the UNIQUE conflict clause that you 
added when you created the table. If another key has the same value, then instead of 
adding a new row, you replace the row with the new value. This makes it so you don’t 
have two of the same keys in the database, keeping each key unique. 
If you aren’t using the unique rows feature of SQLite, then you can use the statement 
INSERT INTO 'storage' ..., removing the OR REPLACE check. 
The next section specifies the columns you’ll be setting values for and in what order. After 
you specify the columns, you set the values, in order, to the columns. Again, you use 
statement parameters to optimize and protect your SQLite database. 
3.2.5 
Deleting from SQLite 
With the ability to read and write from the database, you next need the ability to delete from 
the database (see the following listing). Your SQL will find a specific key in the database and 
delete the specific row the key is associated with. 
Listing 3.6 Delete from database 
private var _deleteStatement:SQLStatement; 
private function _deleteFromTable(key:String):void{ 
    //create statement 
    if(!_deleteStatement){ 
        _deleteStatement = new SQLStatement(); 
        _deleteStatement.sqlConnection = _connection; 
        var sql:String = "DELETE FROM storage " +                         
            "WHERE key = :key";                                           
        _deleteStatement.text = sql; 
    } 
    //set parameters 
    _deleteStatement.parameters[":key"] = key;                            
    //execute statement 
    try{ 
        _deleteStatement.execute(); 
    } catch(error:SQLError){ 
        //You're messing up my chi man 
    } 
} 
Delete a row from 
the storage 
Set the key parameter 

Persisting data 
69 
{chap 3 code}/src/com/unitedmindset/managers/SQLPersistenceManager.as 
Like the previous methods you’ve created, you always start by checking for your 
SQLStatement, _deleteStatement, and creating one if the statement doesn’t exist. The 
delete SQL starts with DELETE FROM storage to signify you’re deleting and from which 
table. Then you give the SQL statement a condition, to limit the amount of deletions, to 
delete a row only if the key value matches the key property provided.  
It may be helpful to also give your class the ability to delete all the rows from your table. 
The following listing shows the necessary code to achieve this with a slight change to the 
_deleteFromTable() method. 
Listing 3.7 Delete all from database 
private var _deleteAllStatement:SQLStatement; 
private function _deleteAllFromTable():void{ 
    if(!_deleteAllStatement){ 
        _deleteAllStatement = new SQLStatement(); 
        _deleteAllStatement.sqlConnection = _connection; 
        var sql:String = "DELETE FROM storage"; 
        _deleteAllStatement.text = sql; 
    } 
    try{ 
        _deleteAllStatement.execute(); 
    } catch(error:SQLError){ 
        //I'll be back 
    } 
} 
{chap 3 code}/src/com/unitedmindset/managers/SQLPersistenceManager.as 
With the ability to delete a specific row from the table or all rows, you can easily manage 
your data and ensure that it stays up to date. 
3.2.6 
Updating a SQLite record 
Lastly you want the ability to update a specific record in the database. Although you could 
always replace every record, relying on the replace conflict clause that you created when 
creating the table, this isn’t always the best idea based on your database structure. In other 
databases you’ll want to update a record with specific values. In this section, you’ll update a 
record’s value based on matching keys, as shown in the following listing. 
Listing 3.8 Update a record 
private var _updateStatement:SQLStatement; 
private function _updateInTable(key:String, value:Object):void{ 
    //create statement 

70 
CHAPTER 3 Persisting data 
    if(!_updateStatement){ 
        _updateStatement = new SQLStatement(); 
        _updateStatement.sqlConnection = _connection; 
        var sql:String = "UPDATE storage " +                     
            "SET value = :value " +                             
            "WHERE key = :key";                                 
        _updateStatement.text = sql; 
    } 
    //set parameters 
    _updateStatement.parameters[":key"] = key;                   
    _updateStatement.parameters[":value"] = value;               
    //execute statement 
    try{ 
        _updateStatement.execute(); 
    } catch(error:SQLError){ 
        //Red Alert 
    } 
} 
{chap 3 code}/src/com/unitedmindset/managers/SQLPersistenceManager.as
To finish your final method, you address the update SQL. Updating a row using SQL starts 
with the UPDATE keyword and the table name you’re updating, in this case UPDATE 
storage. Then you set the values you’re updating using the SET keyword. When setting 
values you can use a comma-separated string of columns and the value; in this case you’re 
updating one value. Lastly, you use a condition to determine which row to update, in this 
case the row with a key that matches your given key. 
With the update method complete, you can create, read, update, and delete rows in your 
database table. The short name for this set of functions is CRUD: Create, Read, Update, 
Delete. 
3.2.7 
Adding public methods 
With your CRUD methods in place you need to create public functions to access your private 
methods. The next listing shows the public methods that ListView will use to access the 
database. 
Listing 3.9 Public CRUD methods on SQLPersistenceManager.as 
public function initialize():void{                                        
    _checkConnection(); 
    _checkTable(); 
} 
public function read(key:String):Object{ 
    return _readFromTable(key); 
} 
Update a value in 
the storage 
Set the parameters 
Initialize database connection 

Persisting data 
71 
public function write(key:String, value:Object):void{ 
    _writeToTable(key, value); 
} 
public function update(key:String, value:Object):void{ 
    _updateInTable(key, value); 
} 
public function deleteFromTable(key:String):void{ 
    _deleteFromTable(key); 
} 
public function deleteAll():void{ 
    _deleteAllFromTable(); 
} 
{chap 3 code}/src/com/unitedmindset/managers/SQLPersistenceManager.as 
Your public functions will need to provide access to setting up your database, the database 
table, and all of the CRUD functionality. The first public method you’ll make is the 
initialize() method. This method will run both the database checks that you need 
before you execute any SQL commands.  
The rest of the methods are direct accessors to the private methods that you’ve created. 
By creating this pretty interface to your class, you can easily access all the functions that you 
just created. 
3.2.8 
Integrating with SQLPersistenceManager 
Going back to your ListView.mxml, you need to swap out a few lines of code, and you can 
now use the SQLite database to hold all of your data instead of the local shared object. 
. . . 
//imports section 
import com.unitedmindset.managers.SQLPersistenceManager; 
. . . 
//_onView_ViewActivateHandler 
var lso:SharedObject = SharedObject.getLocal("com.unitedmindset.RottenTomatoes");
var listData:ArrayList = lso.data[title] as ArrayList;
var timestamp:Number = lso.data[title+" Timestamp"] as Number;
var database:SQLPersistenceManager = new SQLPersistenceManager();         
database.initialize();                                                    
var listData:ArrayList = database.read(title) as ArrayList;               
var timestamp:Number = database.read(title+" Timestamp") as Number;       
. . . 
You start the integration by switching out code for the shared object with code for your 
SQLPersistenceManager. 
You 
need 
to 
create 
an 
instance 
of 
your 
Initialize database 
Pull values 

72 
CHAPTER 3 Persisting data 
SQLPersistenceManager and initialize the database. Instead of setting the listData
variable to data from the LSO, you’ll read data from the database and assign that data to the 
listData variable. Lastly, you’ll switch out the timestamp code with the data from the 
database. 
With the LSO switched out for the database in the viewActivate handler, you need to 
change out the result handler to complete the cycle: 
. . . 
private function 
_onService_ResultHandler(event:RottenTomatoesResultEvent):void{ 
    var listData:ArrayList = new ArrayList(event.result as Array); 
    list.dataProvider = listData; 
    var lso:SharedObject = SharedObject.getLocal("com.unitedmindset.RottenTomatoes");
lso.data[title] = listData;
lso.data[title+" Timestamp"] = new Date().time;
lso.flush();
    var database:SQLPersistenceManager =  
        new SQLPersistenceManager();                                     
    database.initialize();                                               
    database.write(title, listData);                                     
    database.write(title+" Timestamp", new Date().time);                 
} 
. . . 
In the result handler method you need to finish off some code changes, and then the data 
storage change will be complete. Again, you switch out the LSO initialization code with the 
SQLPersistenceManager initialization code. Then, instead of setting data to the LSO, you 
write your data to the database. You end with storing the timestamp to the database instead 
of the LSO, and you’re good to go. 
With the entire change-out complete, you’re no longer using the LSO and instead are 
using a SQLite database for your entire application. With the muscle of a SQLite database 
behind you, you can achieve anything. These two different methods should give you many 
options for your applications. In the next section we’ll focus on using the new 
PersistenceManager to make storing your data even easier throughout your entire 
application. 
3.3 
Simpler data storage with PersistenceManager 
The new way to store data is to use the PersistenceManager class introduced with Flex 
4.5. This new convenience class is a simple way to persist the application data using 
key/value pairs. 
The PersistenceManager is a class created to provide a convenient interface to 
whatever persistence storage option that you’d like to use. One nice feature of the 
PersistenceManager is it’s built off the interface IPersistenceManager. This means if 
you don’t like the original implementation of the PersistenceManager, you can easily 
Initialize database 
Store the values 

Persisting data 
73 
switch out the implementation for your own. In this section you’ll switch out the SQLite code 
you created in the last section for the PersistenceManager, and then you’ll expand the 
SQLPersistenceManager to support the IPersistenceManager interface. 
3.3.1 
Interacting with PersistenceManager 
The PersistenceManager implementation includes using an LSO as the storage 
mechanism. Just as you switched out the LSO for the SQLPersistenceManager, you’ll 
change a few lines of code, and you’ll be using a different storage method: 
. . . 
//imports section 
import spark.managers.IPersistenceManager; 
import spark.managers.PersistenceManager; 
. . . 
var database:SQLPersistenceManager = new SQLPersistenceManager();
database.initialize();
var listData:ArrayList = database.read(title) as ArrayList;
var timestamp:Number = database.read(title+" Timestamp") as Number;
var persistence:IPersistenceManager = new PersistenceManager();           
persistence.load();                                                       
var listData:ArrayList = persistence.getProperty(title)  
    as ArrayList;                                                         
var timestamp:Number = persistence.getProperty(title+" Timestamp")  
    as Number;                                                            
. . . 
Like the transition from LSO to SQLPersistenceManager, the first change you need to 
make is the initialization code, followed by the code to pull data from the persistence layer. 
Next, you need to switch out the code in the result handler method to properly set the 
data: 
. . . 
private function  
_onService_ResultHandler(event:RottenTomatoesResultEvent):void{ 
    var listData:ArrayList = new ArrayList(event.result as Array); 
    list.dataProvider = listData; 
    var database:SQLPersistenceManager = new SQLPersistenceManager();
    database.initialize();
    database.write(title, listData); 
    database.write(title+" Timestamp", new Date().time);
    var persistence:IPersistenceManager = new PersistenceManager();       
    persistence.load();                                                   
    persistence.setProperty(title, listData);                             
    persistence.setProperty(title+" Timestamp", new Date().time);         
    persistence.save(); 
} 
Initialize 
PersistenceManager 
Pull the title and timestamp 
Pull the title and timestamp 
Initialize 
PersistenceManager 
Set the listData and 
Timestamp

74 
CHAPTER 3 Persisting data 
. . . 
Finally, you switch out the SQLPersistenceManager initialization and set property code 
for the PersistenceManager. With this little change you’re back to using an LSO via an 
IPersistenceManager implementation. If you prefer to use a SQLite database rather than 
an LSO when persisting your data, you can easily alter the implementation of the 
IPersistenceManager from using an LSO to using SQLite. In the next section we’ll look at 
how to make a slight change to the SQLPersistenceManager to support the 
IPersistenceManager interface. 
3.3.2 
Implementing IPersistenceManager 
It’s a good time to admit that from the first line of code I was planning to create an 
IPersistenceManager implementation using SQLite. Now you need to remove the other 
public functions and implement the IPersistenceManager interface. The following listing 
shortens the entire class by not showing all of the private methods and focuses on showing 
the required interface methods. 
Listing 3.10 SQLPersistenceManager.as with the IPersistenceManager interface 
package com.unitedmindset.managers 
{ 
    import flash.data.SQLConnection; 
    import flash.data.SQLResult; 
    import flash.data.SQLStatement; 
    import flash.errors.SQLError; 
    import flash.filesystem.File; 
    import spark.managers.IPersistenceManager; 
    public class SQLPersistenceManager implements  
        IPersistenceManager                                               
    { 
        public function SQLPersistenceManager(){} 
        //check connection 
        . . . 
        //check table 
        . . . 
        //read from table 
        . . . 
        //write to table 
        . . . 
       //delete from table 
        . . . 
        //update in table 
        . . . 
        //delete all from table 
Implement IPersistenceManager interface 

Persisting data 
75 
        . . . 
        //interface methods 
        public function clear():void{} 
        public function save():Boolean{ return false; } 
        public function load():Boolean{ return false; } 
        public function setProperty(key:String, value:Object):void{} 
        public function getProperty(key:String):Object{ return null; } 
    } 
} 
{chap 3 code}/src/com/unitedmindset/managers/SQLPersistenceManager.as 
In listing 3.10 you can see how to implement the IPersistenceManager interface along 
with all the necessary methods. Remember that when implementing an interface, you must 
include all the required methods specified by the interface. The next few code segments 
highlight the implementation of each of the required methods by the interface. 
When starting to implement the required functions, you start with the load() method: 
. . . 
private var _loaded:Boolean;                                              
public function load():Boolean{ 
    _checkConnection();                                                   
    _checkTable();                                                        
    _loaded = true;                                                       
    return _loaded;                                                       
} 
. . . 
When implementing the load() method you need to add a new class level variable that will 
signify that the SQL connection and table are loaded and ready to be used. Then you call the 
_checkConnection() and _checkTable() methods. With these methods called, you can 
set the _loaded variable to true and return that the SQL connection and table are loaded. 
When you’re sure that the SQLPersistenceManager is loaded, you can continue using 
the SQLPersistenceManager’s methods: 
. . . 
public function clear():void{ 
    if(!_loaded)                                                          
        load();                                                           
    _deleteAllFromTable();                                                
} 
. . . 
With each of the SQLPersistenceManager’s methods, you first check that the 
SQLPersistenceManager is loaded; if it isn’t, you run the load() method. Once it’s 
loaded, you need to call the _deleteAllFromTable() method that you created earlier. 
Next, you need to implement the save() method: 
. . . 
Indicates if database is loaded 
Creates connection 
and table
Indicates storage is 
loaded
If not loaded, load 
database
Delete all records 

76 
CHAPTER 3 Persisting data 
public function save():Boolean{ 
    return true; 
} 
. . . 
For the save() method you won’t actually save any data because you’ll immediately save 
data as it’s set. To properly implement the method you need only return a true value. 
Next, you implement the getProperty() method, pulling data from the database: 
. . . 
public function getProperty(key:String):Object{ 
    if(!_loaded)                                                        
        load();                                                         
    return _readFromTable(key);                                         
} 
. . . 
As with some of the earlier methods, you first need to check that the database is ready to be 
accessed. Once you’re sure that you can use the database, you need to call the 
_readFromTable() method that you created earlier to read data from the database. Any 
data that you pull you’ll immediately return for use. 
The last method to implement is the setProperty() method, which is used to save 
data to the database. 
. . . 
public function setProperty(key:String, value:Object):void{ 
    if(!_loaded)                                                          
        load();                                                           
    _writeToTable(key, value);                                            
} 
. . . 
Again, after checking that the database is ready, you need to call one of the handy methods 
you created earlier. This time you use the _writeToTable() method to store any data to 
your database. 
With all of the IPersistenceManager methods implemented, all you need to do is 
switch out the implementations to use either local shared objects or SQLite databases as you 
see fit. With SQLPersistenceManager fully implementing the IPersistenceManager, 
switching between the two implementations is super simple and only requires you to change 
the two persistence declarations: 
var persistence:IPersistenceManager = new PersistenceManager();
var persistence:IPersistenceManager = new SQLPersistenceManager(); 
The final switch between the implementations completes our data persistence investigation, 
and you now know how to store data between sessions to use later. 
Checks if database is 
loaded 
Reads value from table 
Checks if database is 
loaded 
Writes to database 

Persisting data 
77 
Data synchronization 
In this book I don’t cover in depth synchronizing data between the client and the server 
for cases of offline support because data synchronization isn’t specifically a mobile issue. 
On a mile-high view, the reason why data synchronization is important is for the times 
when a user’s device is no longer connected to the internet. Rather than have 
transactions fail, it may be important for your application to still save changes to the 
device and send all of the saved data at once when the internet connection is restored. 
For situations when you’re creating enterprise applications such as sales applications, this 
issue is of the highest importance. 
The biggest issue with data synchronization isn’t on the client side; it’s on the middle tier. 
When the client reestablishes a connection with the middle tier, you need to send your 
data and update any data that may be expired on your device. On the middle tier you 
need to check for duplicate records and outdated changes that need to be ignored, and 
you need to provide these details to the client as necessary. 
Although the logic to determine what data needs to be updated, deleted, or ignored is 
outside the scope of this book, I will say that the code provided to store data with a 
SQLite database is extremely valuable to local storage prior to synchronization. By storing 
rows of data on the client side, you can quickly synchronize the data row by row, 
ensuring that all of your data is properly accounted for. 
3.4 
Summary 
In this chapter we looked at how to store the state and data of your application between 
uses and how to use many different forms of data persistence to hold the data. We looked at 
some of the finer points related to local shared objects and SQLite databases, including when 
to use and when not to use each option. 
If you want to investigate a third option for data persistence, you could implement the 
IPersistenceManager using a file to store the data. If you’re comfortable with reading 
and writing to a file, this option will be quick to implement. 
With the ability to store your data, you can later store list scroll position, data pulled from 
services, user preferences, or any other sort of data between application usages. 
Key takeaways: 
 
You can implement your own IPersistenceManager. 
 
Local shared objects are easy to use in small datasets. 
 
SQLite databases are good for large datasets. 

78 
4  
Using your device’s native 
capabilities 
This chapter covers 
 
Using the camera and CameraRoll
 
Getting data from the accelerometer 
 
Finding where you are with geolocation 
 
Sending texts and emails and making phone calls 
 
Integrating websites 
 
Listening with the microphone 
 
Responding to OS buttons 
With the basics of mobile development behind us, we need to focus on becoming Flex 
heroes. A true Flex hero needs some super powers to make an awesome mobile application, 
and with the latest capabilities built into Adobe Air you can connect into a brand new set of 
talents that weren’t available before. While wonderfully helpful, many mobile applications are 
web or desktop applications reformatted for the smaller screen. What makes a mobile 
application truly special is its ability to tie into the built-in sensors and capabilities of the 
device itself. This may sound like a difficult task based on the variety of devices that exist on 
the market, but thankfully the Adobe AIR team has made this extremely simple. 
In this chapter we’ll go through each of the main device capabilities built into Adobe AIR 
including the camera, geolocation, accelerometer, multitouch and gestures, text messages, 
phone calls, and others. It’s important to see how easy it is to integrate these capabilities so 
that you don’t flinch when a client asks for one of these new features. 

Using your device’s native capabilities  
79 
4.1 
Creating a device capability testing app 
For this chapter you’ll diverge from your main application and create a side application to 
test your device capabilities. This application will need to be run directly on the device, 
because the capabilities that you’re targeting are available only from the mobile device itself. 
The purpose of this application is to create a quick way to see the various device-specific 
capabilities available to you from the AIR runtime. By the end of this chapter you’ll have 
tested all of the AIR device capabilities available specifically to mobile devices. This is the 
only chapter in which we’ll be referencing this new application, and all the code provided is 
modularized and reduced to its simplest form for easy reuse. 
One thing to remember is that if you want to access capabilities that aren’t provided 
directly from AIR, you can create your own API to the device using native extensions, which 
will be discussed in chapter 8. 
Along the way I’ll point out little coding and performance pitfalls so that all of your code 
runs consistently across many different devices with the best performance. 
In this section you’ll set up a new application to run various tests based on the knowledge 
you gained in chapter 2. 
4.1.1 
Creating a new application 
Using Flash Builder or your own favorite IDE, you’ll create a new Flex Mobile project that 
you’ll call DeviceApp with an initial view of DeviceAppHomeView. As you know from 
creating the RottenTomatoesApplication previously, the name of the application has no 
meaning outside your workspace.  
This new view-based application will consist of a list of options and a different view for 
each of the device-specific capabilities we’ll run through. The following code is the main 
application file for the DeviceApp, DeviceApp.mxml: 
<?xml version="1.0" encoding="utf-8"?> 
<s:ViewNavigatorApplication 
xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark"  
    firstView="views.DeviceAppHomeView">  
 
 
 
 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
</s:ViewNavigatorApplication> 
Based 
on 
the 
code, 
you 
can 
see 
that 
the 
main 
application 
is 
of 
type 
ViewNavigatorApplication 
and 
the 
first 
view 
you 
are 
shown 
is 
the 
DeviceAppHomeView. Next, you’ll set up the DeviceAppHomeView to give you the entire 
list of device capabilities that you’ll be creating for this application. 
At this point you may have an error saying that views.DeviceAppHomeView can’t be 
found. If this is the case don’t worry; in the next section you’ll be creating the 
views.DeviceAppHomeView class. After you create this view class, the error will be fixed. 
First view class 

80 
CHAPTER 4 Using your device’s native capabilities 
4.1.2 
Creating the menu view 
The main menu in the DeviceAppHomeView is a simple list view similar to the other list 
views that you created before. Its only purpose is to give you an easy way to access the 
other views in your application. Consisting of a list component, some data, and a list change 
event handler, your DeviceAppHomeView will be quickly completed (see the following 
listing). 
Listing 4.1 DeviceAppHomeView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark"  
    title="Home" 
    viewActivate="_onView_ViewActivateHandler(event)"> 
    <fx:Script> 
    <![CDATA[ 
    import mx.collections.ArrayList; 
    import spark.events.IndexChangeEvent; 
    import spark.events.ViewNavigatorEvent; 
    private function  
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void 
    { 
        var dataProvider:Array = [                                       
            {label:"Camera UI", view:CameraUIView},                      
            {label:"getCamera()", view:GetCameraView},                   
            {label:"Camera Roll", view:CameraRollView},                  
            {label:"Accelerometer", view:AccelerometerView},             
            {label:"Geolocation", view:GeolocationView},                  
            {label:"Website", view:WebsiteView},                         
            {label:"Gestures", view:GesturesView},                       
            {label:"Touch Events", view:TouchView},                      
            {label:"SMS Texts", view:SmsView},                           
            {label:"Emails", view:EmailsView},                           
            {label:"Phone Calls", view:PhoneCallsView},                  
            {label:"Map", view:MapsView},                                
            {label:"Microphone", view:MicrophoneView},                   
            {label:"Android Buttons", view:AndroidButtonsView},          
            {label:"QNX Bevel", view:QnxButtonsView}                     
        ];                                                               
        list.dataProvider = new ArrayList(dataProvider); 
    } 
    private function _onList_ChangeHandler(event:IndexChangeEvent):void 
    { 
        var selectedItem:Object = list.selectedItem; 
List data 

Using your device’s native capabilities  
81 
        navigator.pushView(selectedItem.view);                            
    } 
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:List width="100%" height="100%"                                    
        id="list" labelField="label"                                      
        change="_onList_ChangeHandler(event)"/>                           
</s:View> 
{DeviceApp}/src/views/DeviceAppHomeView.mxml
As 
you 
know 
from 
creating 
the 
ListView 
and 
the 
BrowseView 
in 
the 
RottenTomatoesApplication, you need only use a list component and some data to give 
the user the ability to navigate through your application. In your DeviceAppHomeView you 
set the list’s dataProvider property on the viewActivate handler. You’ll notice that 
you’re using untyped objects with a label and a view property.  
At this point in the chapter you haven’t created any of these view classes, and you’ll 
receive errors saying that the class can’t be found. It’s OK to have these errors; you can 
comment out sections of the list’s dataProvider as you see fit so that your application is 
able to run (see the following listing). Finally, when a user selects an item from the list, you’ll 
pass that item to the ViewNavigator and access the specific view. 
Listing 4.2 DeviceAppHomeView.mxml—data commented out 
var dataProvider:Array = [ 
    //{label:"Camera UI", view:CameraUIView}, 
    //{label:"getCamera()", view:GetCameraView}, 
    //{label:"Camera Roll", view:CameraRollView}, 
    //{label:"Accelerometer", view:AccelerometerView}, 
    //{label:"Geolocation", view:GeolocationView}, 
    //{label:"Website", view:WebsiteView}, 
    //{label:"Gestures", view:GesturesView}, 
    //{label:"Touch Events", view:TouchView}, 
    //{label:"SMS Texts", view:SmsView}, 
    //{label:"Emails", view:EmailsView}, 
    //{label:"Phone Calls", view:PhoneCallsView}, 
    //{label:"Map", view:MapsView}, 
    //{label:"Microphone", view:MicrophoneView}, 
    //{label:"Android Buttons", view:AndroidButtonsView}, 
    //{label:"QNX Bevel", view:QnxButtonsView} 
]; 
{DeviceApp}/src/views/DeviceAppHomeView.mxml
Navigate to selected view 
Visual list component 

82 
CHAPTER 4 Using your device’s native capabilities 
As you add new views and capabilities, you’ll only have to uncomment the specific line of 
code that you’re ready to include in order to wire up the new view. 
4.1.3 
Application descriptor file 
Although you’re used to setting up a new application and a simple list-based view, we’ve yet 
to delve into the application descriptor to customize your application. In this section we won’t 
cover all of the specifics of the application descriptor because parts of the file specifically deal 
with releasing the application to markets, and we’ll cover that in chapter 10. But in this 
section we’ll focus on the permissions section of the application descriptor. The permissions 
enable device-specific capabilities that otherwise would be blocked from your application. 
Your application descriptor is commonly named *-app.xml, where * is the name of your 
application. For this application it’s titled DeviceApp-app.xml. This XML file includes the 
settings for the name of your application, your application ID and version number, your 
application icons, and possibly the most important, your application permissions, as shown in 
the following listing. 
Listing 4.3 DeviceApp-app.xml  
<?xml version="1.0" encoding="utf-8" standalone="no"?> 
<application xmlns="http://ns.adobe.com/air/application/3.0"> 
    <id>DeviceApp</id> 
    <filename>DeviceApp</filename> 
    <name>DeviceApp</name> 
    <versionNumber>0.0.0</versionNumber> 
    <initialWindow> 
        <content>[This value will be overwritten by Flash Builder in  
        the output app.xml]</content> 
        <autoOrients>true</autoOrients> 
        <fullScreen>false</fullScreen> 
        <visible>true</visible> 
        <softKeyboardBehavior>none</softKeyboardBehavior> 
    </initialWindow> 
    <!-- <icon> 
        <image16x16></image16x16> 
        <image32x32></image32x32> 
        <image36x36></image36x36> 
        <image48x48></image48x48> 
        <image57x57></image57x57> 
        <image72x72></image72x72> 
        <image114x114></image114x114> 
        <image128x128></image128x128> 
    </icon> --> 

Using your device’s native capabilities  
83 
    <android>                                                           
    <manifestAdditions><![CDATA[                                        
    <manifest android:installLocation="auto">                           
    <uses-permission android:name="android.permission.INTERNET"/>        
    </manifest>                                                          
    ]]></manifestAdditions>                                              
    </android>                                                           
    <iPhone>                                                            
        <InfoAdditions><![CDATA[                                         
        <key>UIDeviceFamily</key>                                       
            <array>                                                     
                <string>1</string>                                      
                <string>2</string>                                      
            </array>                                                    
        ]]></InfoAdditions>                                             
        <requestedDisplayResolution>high</requestedDisplayResolution>    
    </iPhone>                                                            
</application> 
{DeviceApp}/src/DeviceApp-app. xml
NOTE 
The application descriptor file is provided by Flash Builder with optional values and 
comments removed.  
If you’re developing for a QNX device like the BlackBerry PlayBook, be aware that QNX 
deployments have their own permission file titled blackberry-tablet.xml. Don’t get creative 
with the name of this file; for packaging purposes later it must be titled blackberry-
tablet.xml. This simple file includes only values specifically for QNX devices. The complete 
default QNX permissions file is as follows: 
<?xml version="1.0" encoding="UTF-8"?> 
<qnx/> 
Mobile devices are strict about the abilities that an application has access to. These 
restrictions are important for the user because mobile devices typically contain private 
information. To access any device capabilities you need to explicitly request access using the 
permissions file. When installing the application, a user will be prompted with a list of the 
permissions that the application wants to be able to use (see figure 4.1). 
Android 
permissions 
section
iOS permissions 
section

84 
CHAPTER 4 Using your device’s native capabilities 
Figure 4.1 Install permissions on an Android device 
This extra precaution is necessary because without these alerts users may have passwords, 
credit card information, or their contact list stolen without their knowledge. Now the user is 
told in advance that the wallpaper application that they just downloaded wants access to 
their contact list—a sure sign that something fishy is going on. As a developer, you should 
request access only to the specific capabilities that you intend to use. 
iOS permissions 
The iOS platform is the exception for device permissions. There are iOS-specific options in 
the application descriptor file, but none of them enable specific device capabilities. When 
you release your application in chapter 10, we’ll look at these iOS options. 
For whatever reason let’s assume that you want access to the user’s location but you don’t 
want the user to know that you’re using their geolocation sensor—the sensor that returns the 
user’s location. And let’s assume you don’t include the permission request in your application 
descriptor file because you don’t want them to know you’re accessing this sensor. So what 
happens to your application? In this case your application is denied access to the geolocation 
sensor, and it appears that the sensor doesn’t even exist on the device. The only way to 
access these capabilities is to include the request in your application descriptor file. Even to 
access the internet, you must include the request in your application descriptor file. 
Each device type has its own permissions; therefore, for the following sections we’ll 
discuss the required permission tags for each of the various device types and how to use the 
device capability. In the next section we’ll discuss the first device capability, the device’s 
camera. 
4.2 
Taking the same picture three different ways 
With hardware that would make even James Bond jealous, you can take stunning pictures 
with quality that rivals many dedicated cameras on the market. When taking a picture there 
are three ways to get camera data into your mobile applications, leading to a variety of 
questions about which will work for you at the quality you expect: 

Using your device’s native capabilities  
85 
 
Do you want to stay inside your application or use the hardware’s built-in camera 
interface to take the picture? 
If you want to stay in your application rather than leaving, then you’ll need to use the 
getCamera() method described in section 4.2.2. If you want to have the native 
experience and use the options provided by the camera UI, then you’ll want to use the 
camera UI described in section 4.2.1. 
 
Do you need to take a picture or access one that already exists in the device’s 
memory? 
If you need to take the image, then you can use either the getCamera() method 
(section 4.2.2) or the camera UI (section 4.2.1). If the picture is in the device’s 
memory, then you’ll need to pull the image from the camera roll, as described in 
section 4.2.3. 
 
Should you use a custom camera or the built-in camera? 
The quality of the image is based on the camera’s hardware, but you may find it 
easier to use the device’s built-in camera UI. If you use the getCamera() method 
and build your own camera interface, you’ll have to fully implement any zooming, file 
storage, or other functions. While it isn’t impossible to implement these functions, this 
may be more effort than you want to attempt. 
Table 4.1 provides a quick breakdown of the various camera options. 
Table 4.1 Camera options 
Method 
Parameters 
CameraUI 
Leaves your application. 
Uses native camera UI. 
Takes a new picture. 
CameraRoll 
Leaves your application. 
Uses native camera roll. 
Pulls images in your device. 
getCamera() 
Stays in your application. 
You build the UI. 
Memory intensive. 
Pulls bitmap data for you to manipulate. 
In this section we’ll look at the three different ways you can access your camera and the 
images you’ve taken along with the best practices for mobile performance. 

86 
CHAPTER 4 Using your device’s native capabilities 
4.2.1 
Using the CameraUI the cross-platform way 
The first method to access the camera data is to use the CameraUI, which accesses the 
device’s native camera user interface. The following listing shows the basic structure for 
CameraUIView.mxml; following the listing we’ll break down the various methods to process 
the camera data. 
Listing 4.4 CameraUIView.mxml—basic view structure 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark"  
    title="Camera UI" 
    viewActivate="_onView_ViewActivateHandler(event)"> 
    <fx:Script> 
    <![CDATA[ 
    import spark.events.ViewNavigatorEvent; 
    private var _camera:CameraUI; 
   private var _loader:Loader; 
    private function                                                      
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{} 
    private function                                                      
    _onButton_ClickHandler(event:MouseEvent):void{} 
    private function                                                      
    _onCamera_CompleteHandler(event:MediaEvent):void{} 
    private function                                                      
    _onMediaPromise_LoadedHandler(event:Event):void{} 
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:layout> 
        <s:VerticalLayout verticalAlign="middle" 
            horizontalAlign="center" 
            gap="10"/> 
    </s:layout> 
    <s:Button label="Take Picture"                                       
              click="_onButton_ClickHandler(event)"                       
              id="button"/>                                              
    <s:Image id="image"/>                                                 
viewActivate event handler 
Button click event handler 
Camera operation complete handler 
mediaPromise load handler 
Button to take picture 
Component to load camera image 

Using your device’s native capabilities  
87 
     
</s:View> 
{DeviceApp}/src/views/CameraUIView.mxml
The current CameraUI lays out a button to start the picture-capturing process and an image 
component to display the captured picture. 
When the view is activated, the first thing you need to do is determine if your device 
even has access to a camera. If the device doesn’t have access to the camera, you won’t 
want to allow the user to even take a picture: 
private function _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{ 
button.enabled = CameraUI.isSupported; 
} 
With the knowledge that your device has access to a camera, you next need to respond to 
the button click if a user chooses to take a picture:  
private function _onButton_ClickHandler(event:MouseEvent):void{ 
    if(!_camera){ 
        _camera = new CameraUI();                                         
        _camera.addEventListener(MediaEvent.COMPLETE,  
        _onCamera_CompleteHandler);                                       
    } 
    _camera.launch(MediaType.IMAGE);                                      
    //_camera.launch(MediaType.VIDEO); 
} 
Using the CameraUI class instance you’ll use the launch() method to access the 
CameraUI. The launch() method takes a parameter that indicates whether you intend to 
capture an image or video. Once the launch() method is called, you’ll leave your 
application and go to the native camera user interface. But before this happens you need to 
add an event listener for the complete event to get data from your capture process. 
When the user finishes capturing the picture or video, the complete event returns a 
MediaPromise object. This is important because what’s returned isn’t an actual image but 
instead the information of how to load the media file. If you just want access to the media 
file’s metadata and file location, you can stop now, but if you want to access the actual 
media data, then you need to load the media file: 
private function _onCamera_CompleteHandler(event:MediaEvent):void{ 
    var mediaPromise:MediaPromise = event.data; 
    if(!_loader){ 
        _loader = new Loader();                                           
        _loader.contentLoaderInfo.addEventListener(Event.COMPLETE, 
        _onMediaPromise_LoadedHandler);                                   
    } 
        _loader.loadFilePromise(mediaPromise);                            
Create new CameraUI if one doesn’t exist 
Add complete event handler 
Launch camera UI requesting image 
capture 
Create loader if none exists 
Add complete event handler 
Load MediaPromise 

88 
CHAPTER 4 Using your device’s native capabilities 
} 
Finally, with the media loaded, you can show the picture using the image component: 
private function _onMediaPromise_LoadedHandler(event:Event):void{ 
    var loadedInfo:LoaderInfo = event.target as LoaderInfo;               
    image.source = loadedInfo.loader.content;                             
} 
With your media loaded and shown to the user, your CameraUI method is complete. Some 
developers may stop at the media complete handler, and on an Android device that would 
work. On an iOS device this isn’t enough to show your image, because the MediaPromise 
isn’t loaded. Because you want to make sure your code works across all devices, you’ll need 
to use the entire workflow to show your captured media. 
CAMERA PERMISSIONS 
At the end of this section we’ll focus on the permissions required to access the camera on 
QNX and Android devices; iOS devices require no special permissions for the camera. 
4.2.2 
Using the getCamera() method 
The second method to access the camera is the getCamera() method, which was originally 
used to access webcams and built-in computer cameras. The benefit of using this function is 
that you can reuse the code even for desktop or web applications. The following listing shows 
the base view for the getCamera() method. For this view you’ll include a window to show 
the camera’s data and give the user the ability to switch between the front and back 
cameras. 
Listing 4.5 GetCameraView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark"  
    title="getCamera()" 
    viewActivate="_onView_ViewActivateHandler(event)"> 
    <fx:Script> 
    <![CDATA[ 
    import mx.core.UIComponent; 
    import spark.events.IndexChangeEvent; 
    import spark.events.ViewNavigatorEvent; 
    private function  
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{}          
    private function  
    _onButtonBar_ChangeHandler(event:IndexChangeEvent):void{}             
Get LoaderInfo
Get loaded content  
viewActivate
handler
buttonBar 
change handler

Using your device’s native capabilities  
89 
    private function _getCamera():void{}                                  
    private var _video:Video; 
    private var _videoHolder:UIComponent; 
    private function _attachCamera(camera:Camera):void{}                  
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:layout> 
        <s:VerticalLayout verticalAlign="middle" 
         
horizontalAlign="center" gap="10"/> 
    </s:layout> 
    <s:Group width="320" height="240" id="videoDisplay"/>                 
    <s:ButtonBar id="buttonBar" requireSelection="true"                   
                 change="_onButtonBar_ChangeHandler(event)"> 
        <s:dataProvider> 
            <s:ArrayList> 
                <fx:Object label="{CameraPosition.FRONT}"/> 
                <fx:Object label="{CameraPosition.BACK}"/> 
            </s:ArrayList> 
        </s:dataProvider> 
    </s:ButtonBar> 
</s:View> 
{DeviceApp}/src/views/GetCameraView.mxml
The GetCameraView lays out a video display container and a ButtonBar to select which 
camera to show in the video display—either the front or back camera—in a vertical layout. 
When the view activates, the first thing you do is determine if the camera is supported on 
the device. If the device supports a camera, then you activate the ButtonBar and get the 
currently selected camera for the video display: 
private function  
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{ 
        buttonBar.enabled = Camera.isSupported;                          
        if(Camera.isSupported) _getCamera();                             
} 
When the user selects a different camera position using the ButtonBar, you select the 
proper camera using the _getCamera() method: 
private function _onButtonBar_ChangeHandler(event:IndexChangeEvent):void{ 
    _getCamera();                                                       #A 
} 
Get the selected camera 
Attaches 
camera to view
Video display 
holder
Camera position 
select bar 
Enable/disable ButtonBar
based on support
Get camera image if support exists 
Get image based on camera selection 

90 
CHAPTER 4 Using your device’s native capabilities 
The important part of this view is the code to connect the camera data to the view. With this 
data shown on screen, you can easily copy the image from the display and store it to a file 
(see the following listing). 
Listing 4.6 GetCameraView.mxml _getCamera() and _attachCamera() methods 
private function _getCamera():void{ 
    var names:Array = Camera.names;                                       
    var i:int = -1; 
    var n:int = names.length; 
    while(++i<n){ 
        var cam:Camera = Camera.getCamera( names[i] as String); 
        if(cam && cam.position ==  
             buttonBar.selectedItem.label){                               
            _attachCamera(cam); 
            return; 
        } 
    } 
    _attachCamera(Camera.getCamera());                                    
} 
private var _video:Video; 
private var _videoHolder:UIComponent; 
private function _attachCamera(camera:Camera):void{ 
    //setup camera 
    camera.setMode(400, 300, 15, false);                                  
    camera.setMotionLevel(0); 
    if(!_video){ 
        _video = new Video(320, 240);                                     
        var m:Matrix = new Matrix();                                      
        m.rotate(Math.PI/2); 
        _video.transform.matrix = m; 
    } 
    _video.attachCamera(camera);                                          
    if(!_videoHolder){                                                    
        _videoHolder = new UIComponent(); 
        _videoHolder.x = 0; 
        _videoHolder.y = 0; 
        _videoHolder.x = ((videoDisplay.width/2) - (_video.width/2)) + 
        _video.width; 
        _videoHolder.y = ((videoDisplay.height/2) - (_video.height/2)) 
Get list of available cameras
Pull selected camera 
Attach camera to view 
Set camera size and refresh rate 
Video to display camera data 
Rotate image right side up 
Attach camera to video 
Add video to display list 

Using your device’s native capabilities  
91 
        - 50; 
        _videoHolder.addChild(_video); 
        videoDisplay.addElement(_videoHolder); 
    } 
} 
{DeviceApp}/src/views/GetCameraView.mxml
The _getCamera() and _attachCamera() methods work synchronously, one after the 
other. _getCamera() uses the list of available cameras and pulls the correct camera based 
on the selected item in the ButtonBar. With the proper camera selected, you use the 
_attachCamera() method to first set the camera’s properties. With the camera set up 
properly, you need to show it to the user. Here we get into two tricks needed to show the 
camera’s data to the user. 
The first trick is to use the Video class to show the camera’s data. One issue with mobile 
phone cameras is that the image automatically rotates, but to show the image in the right 
orientation you need to transform the image, rotating it to orient the image properly. 
The second trick is needed to add the Video class to the video display container. Flex 
containers require an IVisualElement child—the base visual interface for Flex 
components. The Video class doesn’t implement the IVisualElement interface, so you 
need to add the Video class to a UIComponent. 
WARNING! 
If you find the performance of the getCamera() method slow on your device, don’t be 
surprised. Currently, the process to show data from the camera is labor and memory 
intensive because it continuously redraws the bitmap data to the screen. If this is an 
issue on your device, you may prefer to use the CameraUI method. 
You’ve now created the beginnings of your own custom camera user interface. There are 
many more ways to customize and add features, but this serves as a good starting point for 
your applications. Next, we’ll look at how to pull images from the camera roll. 
4.2.3 
Accessing the device’s camera roll 
The third way to access data from the camera is to pull data from the camera roll. While it’s 
also possible to use the filesystem to access camera data, this is a central place to access 
images and video taken from the device’s camera without having to search through the 
filesystem 
for 
images. 
The 
following 
listing 
shows 
the 
basic 
layout 
for 
the 
CameraRollView.mxml you’ll use to access your device’s camera roll. 
Listing 4.7 CameraRollView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark"  

92 
CHAPTER 4 Using your device’s native capabilities 
    title="Camera Roll" 
    viewActivate="_onView_ViewActivateHandler(event)"> 
    <fx:Script> 
    <![CDATA[ 
    import spark.events.ViewNavigatorEvent; 
    private var _cameraRoll:CameraRoll; 
    private var _loader:Loader; 
    private function                                                      
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{} 
    private function                                                      
    _onButton_ClickHandler(event:MouseEvent):void{}  
    private function                                                      
    _onCameraRoll_SelectHandler(event:MediaEvent):void{} 
    private function                                                      
    _onMediaPromise_LoadedHandler(event:Event):void{}  
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:layout> 
        <s:VerticalLayout verticalAlign="middle" 
            horizontalAlign="center" 
            gap="10"/> 
    </s:layout> 
    <s:Button label="Get Picture"                                        
              click="_onButton_ClickHandler(event)"                       
              id="button"/>                                               
    <s:Image id="image"/>                                                 
</s:View> 
{DeviceApp}/src/views/CameraRollView.mxml
The CameraRollView contains a button to initiate the camera roll selection code and an 
image to display the camera roll data when it’s returned. 
As with the previous two camera methods, the first thing you need to do is to determine 
if your device has access to a camera roll: 
private function _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{ 
button.enabled = CameraRoll.supportsBrowseForImage;                       
} 
viewActivate handler 
Button click handler 
Camera roll select handler 
Media promise loader handler 
Get Picture button 
Image component 
Enable/disable initiate button 

Using your device’s native capabilities  
93 
After you’re sure that your device supports the camera roll, you then need to respond to a 
user initiating the camera roll process. To start the process you need to use the 
CameraRoll and listen for the select event. The select event is fired when a user 
selects a specific piece of media in the camera roll. When you’re ready, you call the 
browseForImage() method to access the camera roll UI. As soon as the camera roll UI is 
launched, your application loses focus and you need to respond to the select handler to 
retrieve any selected media: 
private function _onButton_ClickHandler(event:MouseEvent):void{ 
    if(!_cameraRoll){ 
        _cameraRoll = new CameraRoll();                                  #A 
        _cameraRoll.addEventListener(MediaEvent.SELECT, 
         onCameraRoll_SelectHandler);                                    #B 
    } 
    _cameraRoll.browseForImage();                                        #C 
} 
#A Create CameraRoll instance if none exists 
#B Add CameraRoll selection event handler 
#C Browse for image on camera roll 
When a user selects their media, your application will have focus again, and as in the 
CameraUI example you’ll need to load the returned MediaPromise object: 
private function _onCameraRoll_SelectHandler(event:MediaEvent):void{ 
    var mediaPromise:MediaPromise = event.data; 
    if(!_loader){ 
        _loader = new Loader();                                           
        _loader.contentLoaderInfo.addEventListener(Event.COMPLETE,  
        _onMediaPromise_LoadedHandler);                                   
    } 
    _loader.loadFilePromise(mediaPromise);                                
} 
Once the MediaPromise file successfully loads the media data, your final load handler is 
called, and you can set the data to the image component and show the selected media to 
your user: 
private function _onMediaPromise_LoadedHandler(event:Event):void{ 
    var loadedInfo:LoaderInfo = event.target as LoaderInfo; 
    image.source = loadedInfo.loader.content;                            
} 
With your camera roll data returned and displayed to the user, we can move forward and 
look at the permissions required to access the device’s camera. 
Create loader if none exists 
Add loader complete handler 
Load MediaPromise file 
Set image source with loaded 
data 

94 
CHAPTER 4 Using your device’s native capabilities 
4.2.4 
Camera permissions 
Earlier we talked about application permissions and how they’re required to gain access to a 
user’s device. As you know, each platform includes its own permissions section either in the 
application descriptor file or the blackberry-tablet.xml. In this section we’ll look at the 
various platform requirements. For the iOS platform there are no special permissions to 
include the camera permissions. 
ANDROID 
For the Android platform you need to go to the application descriptor file titled DeviceApp-
app.xml and find the <android/> tag. Within the manifest tag you need to add a single 
permission tag to the enable camera access in Android devices: 
<android> 
<manifestAdditions><![CDATA[ 
<manifest android:installLocation="auto"> 
. . . 
<uses-permission android:name="android.permission.CAMERA"/> 
. . . 
</manifest> 
]]></manifestAdditions> 
</android> 
This one tag is all that’s required to access the camera on Android devices. 
QNX (BLACKBERRY) 
For QNX devices you need to go to the blackberry-tablet.xml file and add a few <action/>
tags within the main <qnx/> tag: 
<qnx> 
    <action>use_camera</action> 
    <action>access_shared</action> 
</qnx> 
To use the CameraUI or the getCamera() method, you need to add both the use_camera
and the access_shared actions. If you want to access just the CameraRoll, then you’ll 
only need to use the access_shared action in your QNX tag. 
Once you’ve added the camera permissions, you have the three different ways to access 
data from a mobile device’s built-in camera. 
We’ve now looked at three different ways to get images from devices. In the next section 
you’ll use the accelerometer to determine the orientation of the device. 
4.3 
Monitoring movement with the accelerometer 
Useful for more than games, the built-in accelerometer sensor is a feature that’s easy to 
access and helpful for moments when your application needs to understand the orientation 
and movement of the device, such as if the user shakes the phone. This means that if the 

Using your device’s native capabilities  
95 
user tilts, flips, or even lifts the device, you’ll get these numbers directly from the 
accelerometer sensor. 
In this section you’ll add in accelerometer support and look at best practices for using the 
accelerometer sensor for mobile performance. 
ACCELEROMETER PERMISSION 
Apparently, device manufacturers feel that gaining access to a user’s accelerometer poses 
no threat to a user, and so there’s no reason to search for accelerometer permissions—
there are none. 
4.3.1 
Listening to the accelerometer 
To run the accelerometer test you need to set up a view that will initiate the accelerometer 
sensor listener and display the resulting data to a label for the user, as shown in the 
following listing. 
Listing 4.8 AccelerometerView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="Accelerometer" 
        viewActivate="_onView_ViewActivateHandler(event)"> 
    <fx:Script> 
    <![CDATA[ 
    import flash.sensors.Accelerometer; 
    import spark.events.ViewNavigatorEvent; 
    private var _accelerometer:Accelerometer; 
    private function                                                      
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{}  
    private function                                                      
    _onAccelerometer_UpdateHandler(event:AccelerometerEvent):void{}  
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
        <!-- Place non-visual elements  
             (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:Label id="dataLabel" width="100%"/>                                
</s:View> 
{DeviceApp}/src/views/AccelerometerView.mxml
viewActivate handler 
Accelerometer update handler 
Data label 

96 
CHAPTER 4 Using your device’s native capabilities 
When your view is activated, you start by connecting to the accelerometer sensor built into 
the device. As with any device capability, you need to always check first to see if the device 
has an accelerometer sensor built in. After determining that the accelerometer exists, you 
need to use the Accelerometer class and listen for any updates from the accelerometer 
sensor. Once you’ve added your listener, the last thing you need to do is set the request 
update interval to determine how often you’ll receive updates from the accelerometer: 
private function  
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{ 
    if(!Accelerometer.isSupported)                                        
    return; 
    _accelerometer = new Accelerometer(); 
    _accelerometer.addEventListener(AccelerometerEvent.UPDATE,            
    _onAccelerometer_UpdateHandler);                                      
    _accelerometer.setRequestedUpdateInterval(100);                       
} 
Whenever the accelerometer sensor delivers an update, your handler method will include the 
X, Y, and Z values: 
private function  
_onAccelerometer_UpdateHandler(event:AccelerometerEvent):void 
{ 
    dataLabel.text = "AccelerationX: "+event.accelerationX+"\n" + 
    "AccelerationY: "+event.accelerationY+"\n" + 
    "AccelerationZ: "+event.accelerationZ+"\n" + 
    "Timestamp: "+event.timestamp; 
} 
The data returned from the update handler will appear in the view’s dataLabel. At this 
point you can run the accelerometer example, although what the data represents may not be 
obvious. 
4.3.2 
The values returned from the accelerometer 
With your sensor data shown, you know that three pieces of important data are returned 
from the accelerometer: accelerometerX, accelerometerY, and accelerometerZ (see 
figure 4.2). 
Check for accelerometer support 
Add accelerometer 
update event handler
Set interval for 
accelerometer updates

Using your device’s native capabilities  
97 
Figure 4.2 accelerometerX, accelerometerY, and accelerometerZ visualized 
Each of the values returned, positive or negative, is measured in Gs. A single G represents 
9.8 meters/second/second or 9.8 m/s2—the rate of acceleration due to gravity. By adding 
multipliers to these values, it’s easy to simulate the natural movement of objects moving in 
gravity. 
Considerations for your update request value 
One thing to remember when using the accelerometer is to be aware of the value you set 
for the setRequestUpdateInterval() method. This value is the number of 
milliseconds between each round-trip to the accelerometer. This value is a hint to the AIR 
runtime because sometimes the actual amount of time between round-trips may be 
slightly more or less than the set value.  
Each time you access the accelerometer sensor, you burn a bit of power from the device’s 
battery. I recommend keeping the round-trips to the accelerometer to a minimum, or 
your users will find their device’s battery lowering quickly while using your application. 
Make sure to test frequently what value is appropriate for your application and the user’s 
interaction while being nice to your user’s battery levels.  
As a hint, having an update value higher than your application’s frame rate is pointless, 
because the values won’t be displayed to the user any faster than the frame rate allows. 
With the accelerometer sensor behind you, you can add special features to your application 
based on device movement, such as shaking to refresh and tilting the device for great 
augmented reality overlays using camera data. Now that you know the orientation of the 
device, you can find out the orientation of the device in respect to the globe using the 
geolocation sensor.  

98 
CHAPTER 4 Using your device’s native capabilities 
4.4 
Finding out where you are with geolocation 
One principle in mobile devices is that the device’s location can change, and one helpful 
feature in mobile device development is the ability to know the location of the mobile device 
with the geolocation sensor. 
The geolocation sensor returns more than the GPS latitude and longitude of the mobile 
device; there are two modes for running the geolocation sensor called course location and 
fine location.  
Course location uses cell towers and Wi-Fi networks to locate the device. The course 
location isn’t as accurate as the fine location but takes less power to run. 
Fine location uses the location data provided by GPS satellites. The fine location returns 
many finite pieces of information but can be labor intensive for the device. 
iOS and QNX devices make no distinction between these two forms of location services, 
whereas Android devices give you full access over the two modes. 
In this section you’ll add in geolocation support and look at best practices for using the 
geolocation sensor for mobile performance. 
4.4.1 
Adding the geolocation permissions 
As with all permissions, each platform has its own options and settings to access the services 
you require. For geolocation services no iOS permissions are necessary, but Android and 
QNX platforms each have tags necessary to gain access to the geolocation sensor. 
ANDROID 
For the Android platform you need to return to the application descriptor file titled {your 
app name}-app.xml and find the <android/> tag. To access the course location with the 
geolocation sensor you need to add the following tag within the <manifest/> tag: 
<android> 
<manifestAdditions><![CDATA[ 
<manifest android:installLocation="auto"> 
. . . 
<uses-permission  
android:name="android.permission.ACCESS_COARSE_LOCATION"/> 
. . . 
</manifest> 
]]></manifestAdditions> 
</android> 
If you want to access the fine location from your geolocation sensor, then you need to use 
the fine location tag within the <manifest/> tag: 
<android> 
<manifestAdditions><![CDATA[ 
<manifest android:installLocation="auto"> 
. . . 

Using your device’s native capabilities  
99 
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/> 
. . . 
</manifest> 
]]></manifestAdditions> 
</android> 
Feel free to add both as you see fit to access any available location. 
QNX (BLACKBERRY) 
For the QNX platform you need to return to the <qnx/> tag within the blackberry-tablet.xml 
file. Adding a single tag will give you access to the geolocation sensor: 
<qnx> 
    . . . 
    <action>read_geolocation</action> 
    . . . 
</qnx> 
With these permissions added, you have the desired access to your device’s geolocation 
services. 
4.4.2 
Getting location from the geolocation sensor 
To test the geolocation sensor you’ll need to implement the GeolocationView.mxml to access 
the sensor and display the data onscreen, as shown in the following listing. 
Listing 4.9 GeolocationView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="Geolocation" 
        viewActivate="_onView_ViewActivateHandler(event)"> 
    <fx:Script> 
    <![CDATA[ 
    import flash.sensors.Geolocation; 
    import spark.events.ViewNavigatorEvent; 
    private var _geolocation:Geolocation; 
    private function                                                      
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{}  
    private function                                                      
    _onGeolocation_StatusHandler(event:StatusEvent):void{} 
    private function                                                      
    _onGeolocation_UpdateHandler(event:GeolocationEvent):void{}  
viewActivate handler 
Geolocation status handler 
Geolocation update handler 

100 
CHAPTER 4 Using your device’s native capabilities 
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:Label id="dataLabel" width="100%"/>                                
</s:View> 
{DeviceApp}/src/views/GeolocationView.mxml
The GeolocationView starts off simply with a Label to display the data as it’s received 
from the geolocation sensor. When the view is activated, you start the location service by 
starting up the geolocation process, as shown in the following listing. 
Listing 4.10 Geolocation activate method 
. . . 
private function  
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{ 
    if(!Geolocation.isSupported)                                          
        return; 
    _geolocation = new Geolocation(); 
    if(!_geolocation.muted)                                               
        _geolocation.addEventListener(GeolocationEvent.UPDATE,  
        _onGeolocation_UpdateHandler);                                    
    else 
        dataLabel.text = "Geolocation Muted"; 
    _geolocation.addEventListener(StatusEvent.STATUS,                     
    _onGeolocation_StatusHandler);                                        
    _geolocation.setRequestedUpdateInterval(10000);                       
} 
. . . 
{DeviceApp}/src/views/GeolocationView.mxml
When the view is activated you start the data-retrieval process by, as always, first checking 
to see if the device supports the geolocation sensor. If not, you can stop right there.  
If the geolocation sensor exists, that doesn’t always mean that it’s turned on. Your 
application doesn’t have the permissions to turn on the geolocation sensor because the user 
can manually mute the geolocation sensor. If this is the case, you need to let the user know 
if geolocation is off. How do you know if geolocation is off? The muted property lets you 
know. If the geolocation sensor is muted, then your application won’t receive updates. If the 
geolocation sensor isn’t muted, then you can immediately start listening for update events; 
you also need to be aware of when then muted property changes. 
Data label 
Check if geolocation is supported 
Check if sensor is muted 
Listen for updates 
Listen for status changes 
Determine request interval 

Using your device’s native capabilities  
101 
The Geolocation class instance informs you if the muted property changes by firing the 
status change event. Before we get into the status and update handler, you need to 
determine the interval in which you’ll pull the location information. 
Considerations for your update request value 
You need to be aware of the number of times you make a round-trip to the geolocation 
sensor because mobile devices have a limited amount of power and each trip takes extra 
power to use the sensor to pull data. Therefore you need to set the update interval with a 
value appropriate for your application with the setRequestedUpdateInterval() 
method.  
At this point you need to ask yourself how often you need to know where the user is. If 
you’re creating a running or driving application or movement-heavy application, the 
update interval will need to be more frequent. If you just need to know if the user is in 
the state of Texas, you should pull the data once and stop there to save power. 
With the update request value determined, you need to finish up by adding the status and 
update handlers (see the following listing). 
Listing 4.11 Update and status change handlers 
. . . 
private function                                                         
    _onGeolocation_StatusHandler(event:StatusEvent):void{ 
    if(_geolocation.muted){ 
        _geolocation.removeEventListener(GeolocationEvent.UPDATE,  
        _onGeolocation_UpdateHandler); 
        dataLabel.text = "Geolocation Muted"; 
    } else { 
    _geolocation.addEventListener(GeolocationEvent.UPDATE,  
    _onGeolocation_UpdateHandler); 
    } 
} 
private function                                                         
    _onGeolocation_UpdateHandler(event:GeolocationEvent):void{ 
    var s:String = ""; 
    s += "Lat: "+event.latitude+"\n"; 
    s += "Long: "+event.longitude+"\n"; 
    s += "Altitude: "+event.altitude+"\n"; 
    s += "Hor. Accuracy: "+event.horizontalAccuracy+"\n"; 
    s += "Vert. Accuracy: "+event.verticalAccuracy+"\n"; 
    s += "Speed: "+event.speed+"\n"; 
    s += "Heading: "+event.heading+"\n"; 
    s += "Timestamp: "+event.timestamp+"\n"; 
    dataLabel.text = s; 
Geolocation status handler 
Geolocation update handler 

102 
CHAPTER 4 Using your device’s native capabilities 
    } 
. . . 
{DeviceApp}/src/views/GeolocationView.mxml
While using the geolocation sensor it’s best practice to listen for the status change handler in 
case the muted property changes. If the geolocation sensor is muted, you need to stop 
listening for update changes and alert the user that geolocation is muted. If the sensor isn’t 
muted, you just need to listen for updates, and when the location updates, you’ll show all the 
values to the user.  
Along with the expected latitude and longitude, the fine location can tell you the altitude 
of the device, the positive or negative distance from sea level, and the horizontal and vertical 
accuracy of the latitude and longitude point, along with speed and heading, or direction, of 
the device. With all these values combined, you’ll know everything necessary about the 
device at a specific moment in time. 
With full understanding of where the user is on the globe, you’ll press forward and give 
the user access to the entire web. 
4.5 
Including the entire web with StageWebView 
Your mobile application may make James Bond look like a caveman fiddling with two sticks, 
but if you need to show a website without leaving the application, you might feel stuck. Don’t 
panic; the new StageWebView is your golden ticket.  
This is helpful for situations when you may want to navigate a user through the web, use 
the OAuth (Open Authorization) standard within your application, or show HTML content 
directly in your application.  
The StageWebView instantiates a WebKit instance and overlays it onto your application, 
ultimately living outside of the normal display list (see figure 4.3). What does this mean for 
you and your application? This means that no matter what, your Flex content and 
components will be behind the StageWebView. The StageWebView floats over your 
application content, so when you’re finished with the StageWebView, make sure you 
disconnect the StageWebView from the stage and remove it from display. 
Figure 4.3 StageWebView overlay visualized 

Using your device’s native capabilities  
103 
In this section we’ll look at how to include web pages using WebKit directly in your 
application along with how to insert HTML content in your StageWebView container. With 
access to the StageWebView you have full access to the history of the StageWebView, the 
location, and the web history. 
4.5.1 
Connecting the StageWebView with the stage 
Your test case for the StageWebView won’t include any Flex components, because you’ll 
want to get right into showing a web page, as shown in the following listing. 
Listing 4.12 WebsiteView.mxml outline 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="Website View" 
        viewActivate="_onView_ViewActivateHandler(event)" 
        resize="_onView_ResizeHandler(event)" 
        viewDeactivate="_onView_ViewDeactivateHandler(event)"> 
    <fx:Script> 
    <![CDATA[ 
    import mx.events.ResizeEvent; 
    import spark.events.ViewNavigatorEvent; 
    private var _webstageView:StageWebView; 
    private function                                                      
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{}  
    private function                                                      
    _onView_ResizeHandler(event:ResizeEvent):void{}  
    private function                                                      
    _onView_ViewDeactivateHandler(event:ViewNavigatorEvent):void{}  
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
</s:View> 
{DeviceApp}/src/views/WebsiteView.mxml
For this capability test you’ll add the StageWebView to your WebsiteView and also watch 
for the resize handler, in order to resize the StageWebView instance if the view changes 
size or orientation.  
viewActivate handler 
viewResize handler 
viewDeactivate handler 

104 
CHAPTER 4 Using your device’s native capabilities 
First, you’ll add in the StageWebView when the view activates. When adding in the 
StageWebView you need to set its size by setting the StageWebView viewport. The 
viewport determines the position, width, and height of the WebKit instance on the stage. All 
Flash and Flex applications include one stage; this is the basis for your entire display list.  
The position isn’t relative to any containers because the StageWebView floats over your 
application but from the absolute stage X and Y locations. Once the position and size are set, 
you can make the WebKit instance visible by attaching it to the stage instance. If you want a 
quick way to hide the StageWebView, just set the stage property to null: 
private function _onView_ViewActivateHandler(event:ViewNavigatorEvent):void 
{ 
    _webstageView = new StageWebView(); 
    _webstageView.viewPort = new Rectangle(0, navigator.actionBar.height,  
     width, height);                                                      
    _webstageView.stage = stage;                                          
} 
As we mentioned earlier, once added, the WebKit instance resides over the display list, so 
when you’ve finished and your view is complete and deactivated, you need to detach the 
WebKit instance from the stage: 
private function  
_onView_ViewDeactivateHandler(event:ViewNavigatorEvent):void{ 
    _webstageView.stage = null;                                           
    _webstageView = null;                                                 
} 
One little issue to remember is that these devices have portrait and landscape orientations. 
And when the orientation changes, the size and shape of the viewport should change to 
respond to the new layout. You achieve this by listening to the resize event from the view, 
and when it’s fired, you give the StageWebView instance a new viewport adequate to the 
new layout: 
private function _onView_ResizeHandler(event:ResizeEvent):void{ 
    if(_webstageView) 
        _webstageView.viewPort = new Rectangle(0,  
    navigator.actionBar.height, width, height); 
} 
With the StageWebView instance showing properly in the view, the next step is to give your 
WebStageView some content, either a web page or content of your choosing. 
4.5.2 
Setting the StageWebView location 
One option for setting what’s shown in the StageWebView is to use the method 
loadURL(). The loadURL() function takes any web page URL to set its current location. 
Whenever the URL of the StageWebView instance changes, the StageWebView fires a 
Set StageWebView viewport 
Set visible by attaching to stage 
Remove from stage (hiding) 

Using your device’s native capabilities  
105 
location change event, letting you know when your StageWebView instance location 
changes. 
In your viewActivate handler you can set the location for your test view: 
private function _onView_ViewActivateHandler(event:ViewNavigatorEvent):void 
{ 
    _webstageView = new StageWebView(); 
    _webstageView.viewPort =  
     new Rectangle(0, navigator.actionBar.height, width, height); 
    _webstageView.stage = stage; 
    _webstageView.loadURL("http://unitedmindset.com/jonbcampos"); 
} 
With your content set you can run your WebpageView and see the URL content being set—in 
this case, my blog URL. 
4.5.3 
Setting the StageWebView content 
The other option is to directly set content to StageWebView by using the loadString()
method. With loadString() you can set any HTML content into your WebKit instance and 
render the HTML to the device: 
private function  
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{ 
    _webstageView = new StageWebView(); 
    _webstageView.viewPort = new Rectangle(0, navigator.actionBar.height,  
    width, height); 
    _webstageView.stage = stage; 
    _webstageView.loadString("<p>Flex Mobile Rocks</p>"); 
} 
With the content shown to your users, the entire internet is available to your applications. 
Without needing to leave the application to show web pages or HTML content, you can 
respond to web page changes and display HTML content directly within your application. The 
entire web is now behind you and you can move forward to unique user input using touch on 
your device’s touch screen.  
4.6 
Using gestures the right way, right away 
The casual ability to touch and flick items on the screen is easier than most people have 
been lead to believe. Gone are the keyboard and mouse, and in comes a new input device, 
tú dedo (your finger). Getting input from the touch screen is simple either through a low-
level touch point or through gestures that you’re already comfortable with. 
Within Flash and Flex applications there are two different forms of touch input: touch and 
gesture input:  
 
Touch input 

106 
CHAPTER 4 Using your device’s native capabilities 
Touch input returns the raw touch points as they’re returned from the hardware. 
When using touch points you receive nothing more than a location of the touch point, 
similar to a mouse click, and an ID. The touch point ID is the only way to identify one 
unique touch point from the other. This is important because there could be multiple 
touch points, and you need to differentiate one touch point from another (see figure 
4.4). When you put a finger down, a new touch point ID is assigned to the current 
touch connection. Through any movements onscreen the touch point’s ID remains the 
same. If for any reason the touch point ends, the ID is released for reuse. Note that 
you’ll never expect to listen to a specific touch point ID or that the touch point IDs 
would be in any sequence. 
Figure 4.4 Touch points with unique IDs 
 
Gesture inputs 
Gesture inputs are interpreted touch points from the hardware, and depending on the 
hardware, some gestures do and don’t exist. Therefore, you need to check what 
gestures the hardware supports and rely only on gestures supported by the hardware 
you’re using.  
In this section we’ll look at how to set up your application to work with gestures and raw 
touch points. 
4.6.1 
Setting your touch input type 
Within your application you can easily switch between the two touch input settings as you 
see fit, as often as you like. The input mode is a static method on the Multitouch class. To 
change the multitouch input settings, use the Multitouch class and set the input mode: 
 
For raw touch points 
Multitouch.inputMode = MultitouchInputMode.TOUCH_POINT; 
 
For gestures 
Multitouch.inputMode = MultitouchInputMode.GESTURE; 

Using your device’s native capabilities  
107 
MISSING INPUTS  
Remember that just because you set the multitouch input to either gesture or touch 
events, it doesn’t mean that one or either of these modes actually exists. You must 
always check that the hardware supports the input mode. In the following gesture and 
touch input test cases, you’ll start each case by testing for the available input mode.  
4.6.2 
Using gestures 
Our gestures test case will be a simple view with a single label to show touch information 
pertaining to which gesture was fired, titled GesturesView.mxml (see the following listing). 
Listing 4.13 GesturesView.mxml outline 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="Gestures" 
        viewActivate="_onView_ViewActivateHandler(event)"> 
    <fx:Script> 
    <![CDATA[ 
    import spark.events.ViewNavigatorEvent; 
    private function                                                      
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{}  
    private function                                                      
    _onView_GestureHandler(event:Event):void{}  
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:Label id="dataLabel" verticalCenter="0"  
    horizontalCenter="0"/>                                                
</s:View> 
{DeviceApp}/src/views/GesturesView.mxml
To implement gestures you’ll need two methods, as outlined in listing 4.13. The first method 
you’ll use to set up the gesture listeners will be the viewActivate handler, which fires 
when the view activates. The second method you’ll use is one to capture the gesture event 
and respond to it. In this case you’ll show which gesture was fired by your view (see the 
following listing). 
viewActivate handler 
Gesture handler 
Visual output label 

108 
CHAPTER 4 Using your device’s native capabilities 
Listing 4.14 GesturesView.mxml methods 
private function  
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{ 
    if(!Multitouch.supportedGestures)                                     
        return; 
    Multitouch.inputMode = MultitouchInputMode.GESTURE;                   
    var gestures:Vector.<String> = Multitouch.supportedGestures;          
    var i:int = -1; 
    var n:int = gestures.length; 
    while(++i<n){ 
        switch(gestures[i]){                                             
            case GestureEvent.GESTURE_TWO_FINGER_TAP:                     
            addEventListener(GestureEvent.GESTURE_TWO_FINGER_TAP,         
           _onView_GestureHandler);                                       
                break;                                                    
            case PressAndTapGestureEvent.GESTURE_PRESS_AND_TAP:           
            addEventListener(PressAndTapGestureEvent.GESTURE_PRESS_AND_TAP, 
            _onView_GestureHandler);                                      
                break;                                                    
            case TransformGestureEvent.GESTURE_PAN:                       
            addEventListener(TransformGestureEvent.GESTURE_PAN,           
            _onView_GestureHandler);                                      
                break;                                                    
            case TransformGestureEvent.GESTURE_ROTATE:                    
            addEventListener(TransformGestureEvent.GESTURE_ROTATE,        
            _onView_GestureHandler);                                      
                break;                                                    
            case TransformGestureEvent.GESTURE_SWIPE:                     
            addEventListener(TransformGestureEvent.GESTURE_SWIPE,         
            _onView_GestureHandler);                                      
             break;                                                        
            case TransformGestureEvent.GESTURE_ZOOM:                      
            addEventListener(TransformGestureEvent.GESTURE_ZOOM,          
            _onView_GestureHandler);                                      
                break;                                                    
        } 
    } 
    } 
    private function _onView_GestureHandler(event:Event):void{ 
    dataLabel.text = event.type;                                          
} 
{DeviceApp}/src/views/GesturesView.mxml
Check for gesture support 
Change to gesture input mode 
Get list of available gestures 
Loop through gestures 
Add listener 
based on gesture 
available 
Display gesture when fired 

Using your device’s native capabilities  
109 
The viewActivate handler checks that gesture support exists and changes your multitouch 
input mode to gesture mode. Then you’ll get the list of available gestures supported by the 
device you’re running on. This is an important list and something to inspect closely. With this 
list of supported gestures you can iterate through the list and add a listener for each of the 
specific gestures. When the gesture is executed on the view, you’ll display the used gesture 
onscreen using the label component. 
Remember when using gestures that each gesture fires a different kind of event, 
including various bits of information about the gesture fired, such as position, rotation, and 
other data. 
Right now, six main gestures are supported by the various platforms: two-finger tap, 
press and tap, pan, rotate, swipe, and zoom. If the gesture you want isn’t supported in this 
list, you could always use raw touch points and create your own gestures. There are also 
libraries like GestureWorks (http://gestureworks.com/) that allow you to use gestures not 
supported out of the box.  
4.6.3 
Using touch points 
Your touch point test will be noticeably more complicated than the GesturesView.mxml. For 
your TouchView.mxml you’ll listen for the touch begin, touch move, and touch end events 
and move some circles based on the point where the touch currently is located (see the 
following listing). 
Listing 4.15 TouchView.mxml outline 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="Touch Events" 
        viewActivate="_onView_ViewActivateHandler(event)"> 
    <fx:Script> 
    <![CDATA[ 
    import spark.events.ViewNavigatorEvent; 
    private var _touchPoints:Object; 
    private function                                                      
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{} 
    private function                                                      
    _onView_TouchBeginHandler(event:TouchEvent):void{} 
    private function                                                      
    _onView_TouchMoveHandler(event:TouchEvent):void{}  
    private function                                                      
viewActivate handler 
touchBegin handler 
touchMove handler 
touchEnd handler 

110 
CHAPTER 4 Using your device’s native capabilities 
    _onView_TouchEndHandler(event:TouchEvent):void{}  
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    <fx:Component className="BlueCircle">                                 
        <s:Ellipse width="120" height="120">                              
            <s:fill>                                                     
            <s:SolidColor color="#0000FF"/>                               
            </s:fill>                                                    
        </s:Ellipse>                                                     
    </fx:Component>                                                      
    </fx:Declarations> 
    <s:Label id="label" verticalCenter="0" horizontalCenter="0"/>         
</s:View> 
{DeviceApp}/src/views/TouchView.mxml
On activation the TouchView first sets the touch input mode to touch input. Then you check 
to see if the device even supports touch input. If it does support touch input, you’ll show on 
your display label the quantity of touch points your device supports and add listeners for the 
touch begin, touch end, and touch move events. This is important because not all devices 
support the same quantity of touch points. If you’re expecting a three-touch gesture when 
only two touch points are supported, then your application won’t work correctly. If the device 
doesn’t support touch points, you don’t add the listeners and you alert the user that touch 
points aren’t supported: 
private function  
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{ 
    Multitouch.inputMode = MultitouchInputMode.TOUCH_POINT; 
    if(Multitouch.supportsTouchEvents){ 
        label.text = "Supported Touch Points: "+Multitouch.maxTouchPoints; 
        addEventListener(TouchEvent.TOUCH_BEGIN,  
        _onView_TouchBeginHandler); 
        addEventListener(TouchEvent.TOUCH_MOVE, _onView_TouchMoveHandler); 
        addEventListener(TouchEvent.TOUCH_END, _onView_TouchEndHandler); 
    } else { 
        label.text = "Multitouch Not Supported"; 
    } 
} 
Once you have all the event listeners added, the next thing you need to do is respond to the 
touch begin, touch move, and touch end events. To be clear, the touch begin event is fired 
when a touch interaction starts with the hardware, the touch move event is fired when a 
current touch down point moves, and finally the touch end event is fired when you end a 
touch operation. 
Circle component 
Display label 

Using your device’s native capabilities  
111 
The touch begin event is the first of the three events. In the touch begin event the first 
thing you do is create a new BlueCircle component. Then you use your _touchPoints 
object to create a map between touch points and the connected BlueCircle. This way, in 
later event handlers you can find out which BlueCircle needs to respond to a specific 
touch point ID. After your mapping is complete, you move the BlueCircle under the finger 
of the user and add it to the display list. Next, you’ll worry about moving the BlueCircle 
instance: 
private function _onView_TouchBeginHandler(event:TouchEvent):void{ 
    var spot:BlueCircle = new BlueCircle(); 
    if(!_touchPoints) _touchPoints = {}; 
   _touchPoints[event.touchPointID] = spot;                              
    spot.x = event.localX-70;                                             
    spot.y = event.localY-70; 
    addElement(spot);                                                     
} 
When the touch point move event handler is fired, you use the touch point ID map held by 
the _touchPoints object to find out which BlueCircle instance to move. Then you move 
the correct BlueCircle instance underneath the user’s finger: 
private function _onView_TouchMoveHandler(event:TouchEvent):void{ 
    if(!_touchPoints || !_touchPoints[event.touchPointID]) 
        return; 
    var spot:BlueCircle =                                                 
    _touchPoints[event.touchPointID] as BlueCircle; 
    spot.x = event.localX-70;                                             
    spot.y = event.localY-70;                                             
} 
The process ends when a user lifts their finger and the touch end handler method is fired. 
Here you again determine which BlueCircle is connected to the correct touch point ID 
using the _touchPoints map. Then you remove the BlueCircle from the display list, and 
finally you delete the connection between the touch point ID and the BlueCircle so that 
the BlueCircle can be properly garbage collected: 
private function _onView_TouchEndHandler(event:TouchEvent):void{ 
    if(!_touchPoints || !_touchPoints[event.touchPointID]) 
        return; 
    var spot:BlueCircle =                                                 
    _touchPoints[event.touchPointID] as BlueCircle; 
    removeElement(spot);                                                  
    delete _touchPoints[event.touchPointID];                              
Map touch point ID to 
specific spot
Move spot 
Add spot to display list 
Get spot reference from map 
Move spot 
Get spot reference from map 
Remove spot from display list 
Delete spot from map 

112 
CHAPTER 4 Using your device’s native capabilities 
} 
With these methods implemented, you can run your application and see blue circles show up 
underneath your fingers, as shown in figure 4.5. 
Figure 4.5 Touch Start, Touch Move, and Touch End 
Treat touch events like mouse events 
Earlier in the book and through many examples spread around the internet, you’ve 
probably noticed application developers still using mouse events when working with 
touch-based applications. When using single touch points you can still respond to mouse 
events because they’re mapped by Flash Player to touch events. But as soon as you try to 
support more than one touch input at a time, you’ll no longer be able to use mouse 
events for touch events. 
If you’re worried about pulling out every last bit of performance and speed from your 
application, it’s better to use mouse events whenever you can because they’re a fraction 
faster and take less effort on the runtime. 
Being able to fully utilize the touch screen like other mobile applications adds to the unique 
experience of your application. Next, you’ll integrate tightly with other mobile capabilities 
that allow you to access maps, text messages, emails, and phone calls. 
4.7 
Texts, emails, maps, and phone calls 
In the past, sending an email or making a phone call from your application was almost 
impossible; now these features are just one line of code away. Tying into the device’s ability 
to display maps, send emails, send texts, and make phone calls is easy; making you look like 
the hero to all your clients is priceless. 
These abilities are made possible by the old favorite method navigateToUrl(). Before 
the AIR mobile runtimes, you’d use the navigateToUrl() method to navigate to web 

Using your device’s native capabilities  
113 
pages. Now you can use navigateToUrl() to initiate actions using the mobile device to 
communicate an intent to send a text message, send email, show a map location, or make a 
phone call. In the following examples you’ll use the user interface to initiate a 
navigateToUrl() method call to launch one of four mobile capabilities. 
4.7.1 
Sending SMS messages with SMS 
The first of the four navigateToUrl() capabilities that you’ll create is the SmsView. This 
new view will allow you to input a phone number to send an SMS message to, as shown in 
the following listing. 
Listing 4.16 SmsView 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark" 
        title="Sms Text" xmlns:mx="library://ns.adobe.com/flex/mx"> 
    <fx:Script> 
    <![CDATA[ 
    import flash.net.navigateToURL; 
    private function _onButton_ClickHandler(event:MouseEvent):void{ 
        navigateToURL(new                                                 
        URLRequest("sms:"+phoneNumberInput.text)); 
    } 
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:layout> 
    <s:VerticalLayout verticalAlign="middle" horizontalAlign="center"/> 
    </s:layout> 
    <s:TextInput prompt="Phone #"                                         
        id="phoneNumberInput" restrict="0123456789"/> 
    <s:Button label="Send Text"                                           
    click="_onButton_ClickHandler(event)"/> 
</s:View> 
{DeviceApp}/src/views/SmsView.mxml
The SmsView contains a TextInput component and a Button component. You add the 
restrict property to the phoneNumberInput to ensure only numbers can be included in 
your input. Then when a user clicks the Send Text button, you make the navigateToUrl() 
method call. 
To initiate an SMS text you need to navigate to the URL with the sms: prefix. By using 
the sms: prefix rather than the http: prefix, you tell the AIR runtime to send a text message 
Button click handler 
Text Input 
Send Text Button 

114 
CHAPTER 4 Using your device’s native capabilities 
rather than move to a web page. Giving the sms: prefix a phone number will prepopulate the 
to: field with the set phone number. 
4.7.2 
Sending emails with mailto 
The second of the four navigateToUrl() capabilities you’ll test is sending an email with 
the EmailView including the email address, subject, and message prepopulated (see the 
following listing). 
Listing 4.17 EmailView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="Emails"> 
    <fx:Script> 
    <![CDATA[ 
    import flash.net.navigateToURL; 
    private function _onButton_ClickHandler(event:MouseEvent):void{ 
        var subject:String = escape(subjectInput.text);                  
        var body:String = escape(messageInput.text);                     
            navigateToURL(new URLRequest("mailto:" + emailInput.text +  
            "?subject=" + subject + "&body=" + body));                   
    }  
    ]]> 
    </fx:Script> 
     
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:layout> 
    <s:VerticalLayout verticalAlign="middle" horizontalAlign="center"/> 
    </s:layout> 
    <s:TextInput prompt="Email Address" id="emailInput"/>                
    <s:TextInput prompt="Subject" id="subjectInput"/>                    
    <s:TextArea prompt="Message" id="messageInput"/>                     
    <s:Button label="Send Message"  
click="_onButton_ClickHandler(event)"/>                                  
</s:View> 
{DeviceApp}/src/views/EmailView.mxml
The EmailView contains a few inputs for an email address, subject, and email body 
message. When the user clicks to send a message, you then initiate the navigateToUrl() 
method to send the email message. When constructing the URL for the email operation, you 
Clean the input text 
Send the email 
Email address Input 
Subject input 
Message input 
Send Message button 

Using your device’s native capabilities  
115 
first need to clean the subject and message by URL-encoding the input text. Now any spaces 
or other special characters will be properly sent over for the mail operation. 
By using the mailto: prefix, you can create a URL string with the proper email address, 
subject, and email body. 
4.7.3 
Navigating with Google Maps 
The third of the four navigateToUrl() methods you’ll test is opening a Google Map to a 
specific location using the MapsView (see the following listing). 
Listing 4.18 MapView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="MapsView"> 
    <fx:Script> 
    <![CDATA[ 
    import flash.net.navigateToURL; 
    private function _onButton_ClickHandler(event:MouseEvent):void{ 
        navigateToURL(new  
        URLRequest("http://maps.google.com/?q=” +  
        “37.152258,-88.732702"));                                        
    } 
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:Button verticalCenter="0" horizontalCenter="0" 
              click="_onButton_ClickHandler(event)" 
              label="Hero Central"/> 
</s:View> 
{DeviceApp}/src/views/MapsView.mxml
Navigating from your application to a Google Map is simple. If the application supports 
Google Maps, then when you’re using a Google Map URL the Google Maps application will 
interpret the set location and drop a pin at the specified location. If the mobile device doesn’t 
support Google Maps, then your user will be navigated to the Google Maps web page with 
the location highlighted. Either way, you’re a superhero. 
Maps URL 

116 
CHAPTER 4 Using your device’s native capabilities 
4.7.4 
Making a phone call with tel 
The final of the four navigateToUrl() methods you’ll test is making a phone call with the 
number prepopulated (see the following listing). 
Listing 4.19 PhoneCallsView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="Phone Calls"> 
    <fx:Script> 
    <![CDATA[ 
    import flash.net.navigateToURL; 
    private function _onButton_ClickHandler(event:MouseEvent):void{ 
        navigateToURL(new                                                 
        URLRequest("tel:"+phoneNumberInput.text)); 
    } 
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:layout> 
    <s:VerticalLayout verticalAlign="middle" horizontalAlign="center"/> 
    </s:layout> 
    <s:TextInput prompt="Phone #" id="phoneNumberInput"                   
            restrict="0123456789"/>                                       
    <s:Button label="Make Call"                                           
              click="_onButton_ClickHandler(event)"/>                     
</s:View> 
{DeviceApp}/src/views/PhoneCallsView.mxml
The PhoneCallsView includes a phone number input field restricted to numbers and a 
Make Call button, to initiate the phone call navigateToUrl() method. By using the tel: 
prefix you can prepopulate the mobile device’s phone program with the input phone number. 
All the user needs to do is press the Call button, and the phone call operation is complete. 
With the ability to send text messages, make phone calls, show maps, and send a 
completed email, there are a few ways left to interact with the outside world. Next, we’ll look 
at how to record sound with the device’s built-in microphone.  
Telephone navigateToUrl() 
Phone number 
Input
Initiating 
button 

Using your device’s native capabilities  
117 
4.8 
Recording sound with the microphone 
I’m always surprised how many people seem to forget that one special capability of their 
phone is the built-in microphone. Hooking into the microphone is a simple task, as is saving 
the raw audio stream. By adding this feature to your application, you can record audio and 
play it back, along with other nifty audio-based niceties that you may build into your 
application. 
To understand all of the capabilities available with the microphone class, you need to dive 
into the Sound classes, understand sampling, and get a grasp on waveforms. In this section 
you’ll connect to the built-in microphone on your device, record the audio to a ByteArray, 
and finally play the recorded audio back. 
4.8.1 
Adding the microphone permission 
Accessing the microphone is one of the restricted capabilities on Android and QNX devices. 
Because a malicious developer could easily record audio from the user, the Android and QNX 
devices alert the user that an application will be accessing this capability. 
ANDROID 
To access the microphone on an Android device, you need to again return to your application 
descriptor file, titled {your app name}-app.xml, and find the <android/> tag. Within the 
Android tag you need to add a permission line to your <manifest/> section: 
<android> 
<manifestAdditions><![CDATA[ 
<manifest android:installLocation="auto"> 
. . . 
<uses-permission android:name="android.permission.RECORD_AUDIO"/> 
. . . 
</manifest> 
]]></manifestAdditions> 
</android> 
Adding this one line provides you the access to capture and record audio from the built-in 
microphone on an Android device. 
QNX (BLACKBERRY) 
QNX devices protect both the recording of audio and the playback of audio by the 
application. For these devices you’ll need to go to the blackberry-tablet.xml file and add two 
<action/> tags within the <qnx/> tag: 
<qnx> 
    . . . 
    <action>play_audio</action> 
    <action>record_audio</action> 
. . . 
</qnx> 

118 
CHAPTER 4 Using your device’s native capabilities 
With these two tags added you can now record and play back audio on QNX devices. 
4.8.2 
Connecting to the microphone 
For our microphone example we’re going to go a long way, but every hero’s journey starts 
with a single step and a plan. The following listing shows the basic outline for the entire view 
you’ making; over the rest of the section you’ll add in the functionality, starting with 
connecting to the microphone and displaying audio as the microphone hears it. 
Listing 4.20 MicrophoneView.mxml outline 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark" title="Microphone" 
        viewActivate="_onView_ViewActivateHandler(event)"> 
    <fx:Script> 
    <![CDATA[ 
    import spark.events.ViewNavigatorEvent; 
    private var _microphone:Microphone;                                   
    private var _recording:Boolean;                                       
    private var _timer:Timer;                                             
    private var _soundBytes:ByteArray;                                    
    private var _sound:Sound;                                             
    private var _channel:SoundChannel;                                    
    private function                                                      
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{} 
    private function                                                      
    _onMic_SampleHandler(event:SampleDataEvent):void{} 
    private function                                                      
    _onRecordButton_ClickHandler(event:MouseEvent):void{} 
    private function                                                      
    _onTimer_TimerHandler(event:TimerEvent):void{}  
    private function                                                      
    _onSound_SampleHandler(event:SampleDataEvent):void{} 
    private function                                                      
    _onChannel_SoundComplete(event:Event):void{} 
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
Necessary class-level 
variables
Sets up microphone 
Gets data from microphone 
Starts recording 
Ends recording 
Plays audio 
Resets when audio is done 

Using your device’s native capabilities  
119 
    </fx:Declarations> 
    <s:Rect verticalCenter="0" height="200" left="0" width="50" 
            id="levelIndicator"> 
        <s:fill><s:SolidColor color="0x0000FF"/></s:fill> 
    </s:Rect> 
     
    <s:Button label="Record" id="recordButton" right="10" top="10" 
              click="_onRecordButton_ClickHandler(event)"/> 
</s:View> 
{DeviceApp}/src/views/MicrophoneView.mxml
Right now, you have one big outline for your entire view. As you can already see from the 
outline, you’ll be connecting to the microphone, displaying the audio visually, enabling 
recording, stopping the recording based on a timer, replaying the recorded audio, and finally 
resetting your view for your next secret agent recording session. 
With the view outline complete, the first thing you need to do is start everything by 
connecting to the microphone: 
private function  
    _onView_ViewActivateHandler(event:ViewNavigatorEvent):void{ 
    if(!Microphone.isSupported){ 
        recordButton.enabled = false;                                     
        return; 
    } 
    _microphone = Microphone.getMicrophone();                             
    _microphone.setLoopBack(false);                                       
    _microphone.rate = 44;                                                
    _microphone.gain = 100;                                              
    _microphone.setUseEchoSuppression(true);                              
    _microphone.addEventListener(SampleDataEvent.SAMPLE_DATA,             
    _onMic_SampleHandler);                                                
    } 
    private function _onMic_SampleHandler(event:SampleDataEvent):void{ 
    levelIndicator.width = _microphone.activityLevel*2 + 20;              
} 
As always, the first thing you need to do is check to see if you even have access to the 
microphone. If you don’t, then you need to stop this whole process right from square one. If 
you do have access to the microphone, then you need to get access to it, configure the 
microphone as you see fit, and finally connect your sampling listener to display the audio 
level visually. 
At this point you can run the MicrophoneView test case in your application and see the 
blue bar update as sample data is pulled in. In the next section you’ll turn things up and add 
the ability to record audio using a ByteArray. 
Check microphone access 
Access microphone 
Set up microphone 
Attach listener to 
sample data changes 
Display activity level 
visually 

120 
CHAPTER 4 Using your device’s native capabilities 
4.8.3 
Recording and playing back audio 
Right now you have the ability to sample the microphone data stream and visualize it as it 
comes in. The next section will record the data stream as it’s sampled: 
private function _onRecordButton_ClickHandler(event:MouseEvent):void{ 
    _recording = true;                                                   
    recordButton.enabled = false;                                        
    recordButton.label = "Recording";                                     
    _soundBytes = new ByteArray();                                        
    if(!_timer){                                                         
        _timer = new Timer(4000);                                        
        _timer.addEventListener(TimerEvent.TIMER,                         
        _onTimer_TimerHandler);                                          
    }                                                                    
    _timer.reset();                                                      
    _timer.start();                                                      
} 
When a user presses the Record button, you need to set up the recording session and store 
the data to a new ByteArray. A ByteArray is one of the simplest variable types, holding 
an array of raw bytes—in this case you’ll hold sound bytes pulled from the microphone.  
When recording starts, you use the _recording variable to hold the state of the view 
and let other methods know you’re recording. Then you change your Recording button to let 
the user know a recording is in progress. Next, you clear out any data previously held from 
earlier recordings, and you end by starting a timer for four seconds—the amount of sound 
data that you’ll want to store. 
Reuse timers when possible 
You’ll notice that I’m always careful to reuse instances whenever possible, such as the 
code with the timer, because using the “new” identifier is always a laborious operation, 
and having a bunch of timer instances is usually where developers cause memory leaks. 
I also use the reset() method followed by the start() method with timers in case 
the timer isn’t set back to zero. I do this because I’m overly paranoid, but there have 
been many times when this level of paranoia has helped me out. 
With your timer going and the view knowing you’re recording by the _recording variable, 
you now need to store the bytes as they’re streamed in. To do this you need to modify the 
microphone sample handler method: 
private function _onMic_SampleHandler(event:SampleDataEvent):void{ 
    levelIndicator.width = _microphone.activityLevel*2 + 20; 
    if(_recording){ 
        while(event.data.bytesAvailable){                              
            var sample:Number = event.data.readFloat();                 
Flip a switch; you’re 
recording
Create new ByteArray to hold data 
Start a 4-second 
timer
Write out sound 
bytes

Using your device’s native capabilities  
121 
            _soundBytes.writeFloat( sample );                          
        }                                                              
    } 
} 
To enable the recording you’ve added a little code in your method. If you were currently 
recording, then you’d want to write any sample data from the microphone to your 
ByteArray. This will store the bytes until you decide to play back the data. 
With your ByteArray holding the data, the next step is to play back the data. Once the 
four seconds of recording are complete, the timer will throw an event, caught by your 
_onTimer_TimerHandler() method, letting you know that the timer function is complete, 
as shown in the following listing. 
Listing 4.21 Playing back audio 
. . . 
private function _onTimer_TimerHandler(event:TimerEvent):void{ 
    _microphone.removeEventListener(SampleDataEvent.SAMPLE_DATA,  
    _onMic_SampleHandler);                                                
    _timer.stop();                                                        
    recordButton.label = "Playing";                                       
    _recording = false;                                                   
    _soundBytes.position = 0;                                             
    if(!_sound){ 
        _sound = new Sound();                                             
        _sound.addEventListener(SampleDataEvent.SAMPLE_DATA,  
        _onSound_SampleHandler); 
    } 
    _channel = _sound.play(); 
    _channel.addEventListener(Event.SOUND_COMPLETE,  
    _onChannel_SoundComplete); 
} 
private function _onSound_SampleHandler(event:SampleDataEvent):void{ 
    for(var i:int = 0; i<8192 && _soundBytes.bytesAvailable>0; i++){ 
        var sample:Number = _soundBytes.readFloat(); 
        event.data.writeFloat( sample );                                  
        event.data.writeFloat( sample );                                  
    } 
} 
private function _onChannel_SoundComplete(event:Event):void{ 
    _microphone.addEventListener(SampleDataEvent.SAMPLE_DATA,  
    _onMic_SampleHandler);                                                
    recordButton.enabled = true;                                          
    recordButton.label = "Record"; 
} 
Write out sound 
bytes
Stop sampling data 
Stop the timer from running 
Give progress feedback 
Start playing at the first byte 
Use the Sound class to play sound 
Output the sound twice for 
stereo
Start sampling data again 
Give progress feedback 

122 
CHAPTER 4 Using your device’s native capabilities 
. . . 
{DeviceApp}/src/views/MicrophoneView.mxml
With the ByteArray loaded you’re ready to play back the stored audio. You start the 
playback process by no longer sampling data from the microphone by removing the listener 
to no longer show visual sample updates. Then you stop the timer so that no more timer 
events are fired and give the user a progress update, letting them know the audio is playing.  
The last bit of prep work is to move the position of the ByteArray back to zero. You do 
this because the position of the ByteArray continues to move as you add, remove, or 
access data from the ByteArray. So, like a playhead, you move your position back to the 
first byte to play the sound right from the beginning. 
With the prep work complete, you can now start playing the bytes held in the 
ByteArray. First, you need to create a new Sound class instance to play your sound. 
Because the sound is playing through the SoundChannel, you write out your bytes from 
ByteArray. You’ll notice that you write out the bytes twice; as you may know, the sound is 
recorded in mono (one channel), but you can output stereo (two channels). You write out the 
sound twice for the second stereo channel. 
Once you’ve finished playing your recording, you can start sampling data coming in from 
the microphone and reset the onscreen progress indicators. Now your user is reset and ready 
to record another audio segment. 
From this section you’re able to visualize, record, and play audio, giving you a good sense 
of just about any features you may want to support for your own applications. In the next 
section you’ll use the native device inputs to give the application a native feel, utilizing the 
hardware buttons. 
4.9 
Responding to OS-specific inputs 
Making an application that feels like it was meant for the device means plugging into the 
device’s native buttons. On an iOS device you don’t have any of these options, but for the 
Android and BlackBerry hardware you have a few different options (see figure 4.6). 

Using your device’s native capabilities  
123 
Figure 4.6 Device inputs 
In this section we’ll look at how to integrate with the hardware buttons for the Android and 
BlackBerry devices. 
4.9.1 
Android operating system buttons 
As you already know, Android devices support four hardware buttons: Home, Menu, Back, 
and Search. You can’t override the Home button, because that’s a protected button—
protected to ensure that a user can always leave your application—but the other three are 
waiting for your control. 
The following listing shows the AndroidButtonsView.mxml code and how to use the 
keyDown event handler to access the correct key. Unlike the other code examples, this one 
will obviously work only on an Android device. 
Listing 4.22 AndroidButtonsView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="Android Buttons" 
        keyDown="_onView_KeyDownHandler(event)"> 
    <fx:Script> 
    <![CDATA[ 
    import spark.events.ViewNavigatorEvent; 
    private function                                                      
    _onView_KeyDownHandler(event:KeyboardEvent):void{  
        event.preventDefault();                                           
keyDown handler 
Prevent the default action 

124 
CHAPTER 4 Using your device’s native capabilities 
        switch(event.keyCode){                                            
            case Keyboard.BACK:                                           
                label.text = "Back";                                      
                break;                                                    
            case Keyboard.SEARCH:                                         
                label.text = "Search";                                    
                break;                                                    
            case Keyboard.MENU:                                           
                label.text = "Menu";                                      
                break;                                                    
            default:                                                      
                label.text = "Unknown";                                   
                break;                                                    
        } 
    } 
    private function _onBackButton_ClickHandler(event:MouseEvent):void{ 
        navigator.popView();                                              
    } 
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:navigationContent> 
        <s:Button label="Back"                                            
                  click="_onBackButton_ClickHandler(event)"/> 
    </s:navigationContent> 
    <s:Label id="label" verticalCenter="0" horizontalCenter="0"/>         
</s:View> 
{DeviceApp}/src/views/AndroidButtonsView.mxml
The hardware keys are tied to the same keyDown event that you already use when you want 
to respond to keyboard events. AIR has provided a new set of keyboard key codes to 
respond to the Home, Back, Search, and Menu key codes.  
In your example you add a listener onto the view for any keyDown events. When a 
keyDown event is fired, you stop the default function from happening to prevent things like 
the native back key; then you add your own functionality. Using a switch..case statement 
you determine if the Back button, the Search button, or the Menu button was pressed, and 
you show this to the screen with your display label. 
Because you’ve inhibited the default Back button’s functionality, you need to provide an 
alternative method to leave this view. For this view you’ve added an onscreen Back button, 
Based on the keycode, do… 
React to the Back 
button
React to the Search 
button
React to the Menu 
button
React to any other 
buttons
An alternative 
route from view 
Your onscreen Back button 
Your display label 

Using your device’s native capabilities  
125 
and you have it use the popView() method to remove the current view. Now you can safely 
test your view without getting stuck in it. 
When testing you can see that the button you pressed appears onscreen, and you can 
return to the main menu with the onscreen Back button. In the next section, we’ll focus on 
the QNX platform. 
4.9.2 
BlackBerry bevel gestures 
QNX devices like the PlayBook are a bit different because they don’t have hardware buttons. 
Instead, they respond to swipe events from the bevel of the device. You can attach listeners 
to these bevel events and respond to them appropriately, as shown in the following listing. 
Listing 4.23 QNXButtonsView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark"  
        title="Qnx Buttons" 
        viewActivate="_onView_ViewActivate(event)" 
        viewDeactivate="_onView_ViewDeactivate(event)"> 
    <fx:Script> 
    <![CDATA[ 
import flash.utils.getDefinitionByName; 
import qnx.events.QNXApplicationEvent; 
import qnx.system.QNXApplication; 
import spark.events.ViewNavigatorEvent; 
private function _onView_ViewActivate(event:ViewNavigatorEvent):void{ 
    try{ 
        var c:Class = flash.utils.getDefinitionByName(                
        "qnx.system.QNXApplication") as Class;                        
        var q:QNXApplication;                                         
        c.qnxApplication.addEventListener(                            
        QNXApplicationEvent.SWIPE_DOWN,                               
        _onView_SwipeDownHandler);                                    
     } catch(error:Error){ 
        //do nothing 
} 
} 
private function  
    _onView_SwipeDownHandler(event:QNXApplicationEvent):void{ 
    label.text = (label.text==event.type)?"":event.type;                  
} 
Get reference to 
QNXApplication
Add swipe listener 
Display when swipe is performed 

126 
CHAPTER 4 Using your device’s native capabilities 
private function  
    _onView_ViewDeactivate(event:ViewNavigatorEvent):void{ 
    try{ 
        var c:Class = flash.utils.getDefinitionByName( 
        "qnx.system.QNXApplication") as Class; 
        var q:QNXApplication; 
        c.qnxApplication.removeEventListener(                             
        QNXApplicationEvent.SWIPE_DOWN,                                   
        _onView_SwipeDownHandler);                                        
    } catch(error:Error){ 
        //do nothing 
    } 
} 
]]> 
</fx:Script> 
<fx:Declarations> 
<!-- Place non-visual elements (e.g., services, value objects) here --> 
</fx:Declarations> 
<s:Label id="label" verticalCenter="0" horizontalCenter="0"/>             
</s:View> 
{DeviceApp}/src/views/QnxButtonsView.mxml
To access the swipe events you need to access and attach listeners onto the 
QNXApplication that’s at the heart of the QNX device. To allow proper garbage collection 
you need to remember to unhook your listener when you’ve finished listening for the swipe 
events. To do this you add your listener when the view is activated and remove your listener 
when the view is deactivated. 
Currently, the only bevel event that you can tie into is the swipe down event. Like the 
Android Home button, the other swipe events are protected by the operating system. 
When the view is activated you use a try..catch statement to safely connect to the 
QNXApplication. If the QNXApplication doesn’t exist, such as when your application 
runs on an iOS or Android device, then you don’t add the listener and instead just quietly 
fail. If the QNXApplication does exist, then you attach the listener to show onscreen when 
the swipe action is performed. Finally, when the view is deactivated, you repeat the process 
of getting a reference to the QNXApplication and remove the event listener. 
MISSING QNXAPPLICATION ERROR  
If you find your application includes an error saying the QNXApplication reference 
doesn’t exist, this means you haven’t installed the QNX SDK. To get more information on 
Remove swipe listener 
Display label 

Using your device’s native capabilities  
127 
installing and including this SDK, visit BlackBerry’s Tablet OS SDK site at 
http://us.blackberry.com/developers/tablet/adobe.jsp. 
With the ability to respond to the Android and QNX hardware inputs, you can make your 
applications feel better suited for the device by using the more natural input methods. 
4.10 Summary 
With our lengthy investigation and testing of the many various device capabilities, you can 
now easily integrate your application deeply with the deployment device. By working through 
this chapter, you have created an application that you can use on many different devices and 
effectively test what capabilities it does and doesn’t support.  
In upcoming chapters you’ll integrate device support back into your main application and 
build custom native support using native extensions. 
Key takeaways: 
 
You can listen to touch inputs with mouse inputs. 
 
You can tweak the data response frequency of the geolocation and accelerometer 
sensors for performance and battery improvements as necessary. 
 
navigateToUrl() provides access to phone calls, text messages, emails, and maps. 
 
Make sure to load the MediaPromise file from your camera for cross-device 
functionality. 
 
Not all devices have the same gestures list. 
 
Make sure to always check if the device supports a capability before attempting to use 
it. 
NOTE 
A special thanks to Christian Cantrell for his cross-platform work with MediaPromise
files; his examples heavily influenced my work with ensuring cross-platform support with 
the device camera. And a special thanks to Renaun Erickson for his QNX bevel swipe 
trick. 

128 
5  
Handling multiresolution devices 
This chapter covers 
 
Using media queries in CSS 
 MultiDPIBitmapSource 
 
Overriding the RuntimeDPIProvider 
 
Utilizing automatic scaling 
A truly heroic feat is to adapt your application from one release file to work on a variety of 
devices. Because of the various resolutions and screen sizes that each device’s screen 
displays, your application can look wildly different from one device to the next. In desktop 
and web development this wasn’t an issue because most monitors displayed a steady 72 dots 
per inch (DPI). On mobile devices this isn’t the case, with each device’s resolution possibly 
being vastly different from the next. It may seem nearly impossible to get a good-looking 
application on all the devices, but if you take into account screen size and resolution, you can 
achieve a consistent look across all devices. 
SCREEN RESOLUTION, SCREEN SIZE, AND VISIBLE SIZES 
By now you’ve run an application or two in the simulator and on your own device, probably 
thinking that the desktop simulator was crazy with its oversized window. Holding your device 
up to your monitor, you’ll see that the size of your application on the two screens is 
completely different, and now you’ll learn why. 
Most likely your device’s screen DPI is much higher than the DPI of your desktop monitor, 
so the images and text will render visibly smaller on your device than on your monitor 
because of the compactness of the pixels on the device’s screen. Furthermore, the DPI of 
different devices also varies, causing this same stretching or shrinking effect between 
devices (see figure 5.1). 

Handling multiresolution devices  
129 
Figure 5.1 Four screens with different resolutions rendering the same image 
To aggravate the problem, even if you get two devices with the same DPI, the physical size 
of the screen may vary, leading to an overall larger real estate than the screen can render 
(see figure 5.2). 
Figure 5.2 Two screens with the same resolution but different sizes 
Creating visual assets, such as icons and images, and rendering text in a manner that looks 
good across all these varying sizes can be maddening because of the sheer number of 

130 
CHAPTER 5 Handling mutiresolution devices 
permutations of screen sizes and resolutions. To simplify the problem Flex Mobile introduces 
the idea of DPI buckets. 
DPI BUCKETS 
Rather than trying to target a device that’s 132 DPI, and then another that’s 163 DPI, 
followed by others that are 326 DPI, 252 DPI, 217 DPI, or 144 DPI, you’ll instead simplify 
the problem by creating a few buckets that all of the different DPI values will fall into. Flex 
Mobile identifies three main DPI values that represent a cross-section of the many different 
DPI values: 160 DPI, 240 DPI, and 320 DPI, as shown in figure 5.3. By creating these 
buckets, you can create assets to target multiple screen sizes without losing any quality of 
the assets. 
Figure 5.3 Three buckets visualized 
In this chapter we’ll look at new classes built into Flex Mobile made to simplify targeting 
various resolutions. We’ll also look at the new CSS media queries and how you can use these 
to vary your visuals, along with how you can pull information from the hardware itself to 
make sure the application looks great and performs well across all these screens. Finally, 
you’ll end by using the new SplashScreenImage created to render different splash screens 
based on the hardware’s DPI. For this chapter we’ll return to the Rotten Tomatoes 
application and give it a little more style. 

Handling multiresolution devices  
131 
PROVIDED ASSETS 
Don’t you hate it when you’re working from a book and they show you all sorts of images 
that you have no access to or will have to create on your own? Annoying, I know! When 
this happens I still read the book, but I stop following along with my coding. I’ve taken 
care of this issue with this simple link to download all the assets used in this chapter:  
https://github.com/downloads/jonbcampos/Flex-Mobile-In-Action/imagePak.zip. 
5.1 
Automatic scaling 
As discussed previously, you have a new hurdle to overcome in your code. You need to find a 
way to make the text, images, and layout smart enough to scale, stretch, and move as 
appropriate for the variety of devices it’ll be running on. If you don’t want to get too 
complicated, then your first option for dealing with multiresolution displays is to use the 
automatic scaling built into the Flex framework. The automatic scaling utilizes 
applicationDPI and runtimeDPI to determine the resulting size of visual components. 
CAUTION! 
I would caution against using this as your magic bullet, because you’ll lose some of your 
fine-grain controls that you may require for your application. To get started, automatic 
scaling is nice, but I’ve found that automatic scaling can get in the way of any 
customization that you’d set later. For best practice I recommend not using automatic 
scaling. 
When you enable automatic scaling, the Flex framework does some additional math in the 
background to determine the final renderable size of visual components. In this section we’ll 
look at how the automatic scaling built into Flex works and how to make it work for you. 
5.1.1 
Diving deep into automatic scaling 
First, the Flex framework pulls the applicationDPI and the runtimeDPI from the 
FlexGlobals instance. FlexGlobals is a single class in the Flex core classes that’s global 
to all Flex applications. The runtimeDPI is the actual bucket—160, 240, or 320—that the 
device’s DPI falls in. The applicationDPI is the DPI of the application. By default the 
applicationDPI and the runtimeDPI are the same value, determined by the device. If 
you’re using automatic scaling, then you’ll set the applicationDPI to a different value of 
160, 240, or 320. 
FlexGlobals.topLevelApplication.applicationDPI 
FlexGlobals.topLevelApplication.runtimeDPI 

132 
CHAPTER 5 Handling mutiresolution devices 
After obtaining the applicationDPI and runtimeDPI from FlexGlobals, the Flex 
framework determines the multiplier between the two values and uses this calculated 
multiplier to determine what sizes are appropriate for visual components. 
For example, if the runtimeDPI is 240 and the applicationDPI is 160, then the 
multiplier between the two values is 1.5. When developing your application, you’d set all the 
values of your visual components as you’d see fit for an application running at 160 DPI. 
When running on the 240 DPI devices, the Flex framework will take all visual components 
and multiply the set visual values by 1.5 to determine the actual values. Likewise, if the 
application is running on a device with a DPI in the 320 DPI bucket, the resulting multiplier 
will be 2 and any visual values will be multiplied by 2 (see figure 5.4). 
Figure 5.4 Automatic DPI scaling 
Next, we’ll look at how to enable and use automatic scaling. 
5.1.2 
Enabling automatic scaling 
Enabling automatic scaling is the simplest thing in the world. Back in the Rotten Tomatoes 
application you need to set the value of the applicationDPI: 
<?xml version="1.0" encoding="utf-8"?> 
<s:TabbedViewNavigatorApplication xmlns:fx="http://ns.adobe.com/mxml/2009"  
            xmlns:s="library://ns.adobe.com/flex/spark" 
            persistNavigatorState="true" 
            applicationDPI="160">                                        
    <s:ViewNavigator label="Browse" width="100%" height="100%"  
        firstView="views.BrowseView"/> 
    <s:ViewNavigator label="Search" width="100%" height="100%"  
        firstView="views.SearchView"/> 
Set the applicationDPI 

Handling multiresolution devices  
133 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
</s:TabbedViewNavigatorApplication> 
The applicationDPI can only be set at this point specifically using the MXML tag. This is 
done obviously to protect your application against some other developer setting the 
applicationDPI and messing up the visuals of your application without you knowing. 
With the applicationDPI set, the visual properties such as width and height are scaled 
to appear appropriate based on the runtimeDPI to applicationDPI ratio. 
SIDE NOTE 
For your main application you won’t be using automatic scaling. You can remove the 
applicationDPI setting from your application moving forward. 
5.1.3 
Considerations with automatic scaling 
When using automatic scaling it’s recommended to use the 160 DPI setting. Scaling values 
up for vector images and text works better than scaling down. But scaling up bitmap images 
leads to jagged images and pixilation. Scaling down vector images often leads to artifacts. 
One other consideration and reason to use images meant for the 160 DPI is file size. If 
you’re using and distributing all images for an application at 320 DPI when most of the target 
devices use 160 DPI and 240 DPI, then you’re increasing the size of your distributable file’s 
images by a multiplier of 1.5 or 2. If the final file size is more important to your application 
than supporting the larger DPI setting, then 160 DPI is your best bet. At the time of this 
writing, only the iPhone 4, Samsung Note, Samsung Galaxy Nexus, and new iPad support the 
320 DPI bucket. 
Depending on your application, you may want to have more than just different sizes for 
your layouts. If you want varying layouts depending on DPI, then you may find automatic 
scaling doesn’t provide the customization necessary for your application. In the next section 
we’ll look at using media queries for additional fine-grain control over the visualization of 
your application. 
5.2 
Using media queries in CSS 
One of the other ways to solve the daunting problem of creating an effective multiresolution 
application is to use the new CSS ability introduced with Flex 4.5: media queries. With media 
queries you can now set styles in CSS based on specific DPI resolutions.  
As you already know, Flex can use CSS (Cascading Style Sheets) to determine the look of 
an application. With Flex 4, CSS received important upgrades, giving Flex CSS even more 
control over the look of a Flex application. The purpose of Flex CSS is to give you, the 
developer, a central location to be able to cleanly change component styles without having to 
muck up your layout or ActionScript code with style properties (see table 5.1).  

134 
CHAPTER 5 Handling mutiresolution devices 
The obvious and biggest benefit to using CSS beyond organization is the ability to reuse 
styles across your entire application, making style changes in one file rather than searching 
through multiple MXML files to maintain consistency. 
Table 5.1 Side-by-side inline styles versus CSS sheets 
Inline styles 
CSS 
In view 
<s:Button label="Button Label” 
chromeColor="#2E1D79" 
color="#FFFFFF" 
fontSize="20"           
fontStyle="normal"        
fontWeight="bold" 
letterSpacing="2"/>          
In CSS sheet 
s|Button.BigBlueButton         
{ 
    chromeColor: 0x2E1D79; 
    color: 0xFFFFFF; 
    fontSize: 20; 
    fontStyle: normal; 
    fontWeight: bold; 
    letterSpacing: 2;          
} 
In view 
<s:Button label="Button Label” 
styleName="BigBlueButton"/>    
Anytime you need a BigBlueButton you only need to set the button’s styleName
property rather than resetting all of the properties for each instance of BigBlueButton. 
Hopefully, you can see how much simpler your code will look using style sheets. 
In this section you’ll use media queries in CSS to update the look of the application 
specific to the device. 
5.2.1 
Starting up the CSS file 
Before updating your CSS file for media queries, you first need to create your CSS file and 
add it to your application. Your CSS file is going to be the central location for your 
application-specific styles using a combination of styleNames, ID selectors, and descending 
styles sheets. You’ve already seen how to use styleNames to associate specific styles to 
visual components. You can use ID selectors to make a direct connection between styles and 
components with a specific ID, and descending styles let you connect specific sets of 
components based on their parent components. In your CSS file you’ll use each of these CSS 
features. 
First, you’ll create a new CSS file named main.css in a new package named assets.css. If 
you’re using Flash Builder, this is simple to do with the IDE. Right-click your assets.css 
package and select to create a new CSS file (see figure 5.5). 
Inline properties 
CSS styleName
identifier
CSS properties 
Button with 
styleName

Handling multiresolution devices  
135 
Figure 5.5 Creating a new CSS file 
Next, set the name of the CSS file and click Finish to complete the file-generation process 
(see figure 5.6). 
Figure 5.6 New CSS file 

136 
CHAPTER 5 Handling mutiresolution devices 
The generated CSS file is now completely empty: 
/* CSS file */ 
@namespace s "library://ns.adobe.com/flex/spark"; 
. . . 
If you make any changes to your CSS file at this point, the effects will be moot until you 
include your CSS sheet in your application. Although you can add the CSS sheet almost 
anywhere, it’s best to include the CSS sheet at the application level because then all children 
to your application will inherit from the application’s CSS sheet: 
<?xml version="1.0" encoding="utf-8"?> 
<s:TabbedViewNavigatorApplication xmlns:fx="http://ns.adobe.com/mxml/2009"  
            xmlns:s="library://ns.adobe.com/flex/spark" 
            persistNavigatorState="true"> 
    <s:ViewNavigator label="Browse" width="100%" height="100%"  
        firstView="views.BrowseView"/> 
    <s:ViewNavigator label="Search" width="100%" height="100%"  
        firstView="views.SearchView"/> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <fx:Style source="/assets/css/main.css"/>                             
</s:TabbedViewNavigatorApplication> 
With the CSS sheet included in your application, you can start making changes to the CSS 
sheet and see the effects in your application in design view or when you run it. 
5.2.2 
Adding color 
Using the CSS sheet that you just created, you’ll start by adding some color to your 
application. Currently the application is a drab gray, which isn’t becoming for a mobile 
application—even for developer art. Because the Rotten Tomatoes site has a natural 
treatment with greens and yellows, you’ll use these same tones in your application. 
Starting with the ActionBar, you’ll make a change to the coloring of your application 
using CSS: 
/* CSS file */ 
@namespace s "library://ns.adobe.com/flex/spark"; 
s|TabbedViewNavigatorApplication{ 
    backgroundColor: #327d00; 
} 
s|ActionBar {                                                             
    chromeColor: #327d00; 
} 
Include CSS sheet with style tag 
Class selector 

Handling multiresolution devices  
137 
s|ActionBar #titleDisplay {                                               
    color: #eded00; 
} 
s|TabbedViewNavigator #tabBar{ 
    chromeColor: #327d00; 
    color: #eded00; 
} 
. . . 
In your CSS sheet the first thing you do is use a class selector to target all components with 
the ActionBar class and set their chromeColor to a lovely green. To keep the treatment 
consistent, you also need to make the text color of the ActionBar a nice yellow instead of 
the default white. To do this you use a class selector tied with an ID selector to set the text 
color for all components with the ID titleDisplay within the ActionBar class 
components. To keep the look consistent you’ll also colorize the application’s TabBar to 
match the ActionBar using the same descendent selector you used for the 
titleDisplay.  
With this change you get a pretty ActionBar that appears appropriate for your 
application (see figure 5.7). 
Descendent ID selector 

138 
CHAPTER 5 Handling mutiresolution devices 
Figure 5.7 Before and after 
Understanding how your CSS sheet can change your application is just the first step. Next, 
you’ll start making changes to your application dependent on the device’s DPI. 
5.2.3 
Overriding CSS based on DPI 
Because you’re running your application on a variety of devices, you already know that you 
need to adjust the look of your application for each of the varying sizes. In your CSS file you 
can use media queries to determine which CSS setting to use: 
/* CSS file */ 
@namespace s "library://ns.adobe.com/flex/spark"; 
. . . 
@media (application-dpi:160) {                                            
     
} 
@media (application-dpi:240) {                                            
160 DPI selectors 
240 DPI selectors 

Handling multiresolution devices  
139 
     
} 
@media (application-dpi:320) {                                            
     
} 
By setting up some sections in your CSS file, you can segment out each of the selectors by 
DPI. Your DetailsView has the synopsis label to signify that the text below it is a synopsis 
of a movie. Going to the DetailsView.mxml you’ll add some selectors to your MXML code so 
you can access the synopsis label and the text below it from your CSS sheet: 
. . . 
<!-- second group --> 
<s:Label width="100%" text="Synopsis" styleName="separatorLabel"/> 
<s:Label id="details" width="100%" styleName="paragraphLabel"/> 
. . . 
With the styleNames established, you now have the ability to access these label 
components in your CSS sheet. Next, you’ll stylize your labels to fit in your application (see 
the following listing). 
Listing 5.1 main.css stylized media queries 
/* CSS file */ 
@namespace s "library://ns.adobe.com/flex/spark"; 
. . . 
@media (application-dpi:160) {                                            
    s|Label.separatorLabel{ 
        backgroundColor: #327d00; 
        color: #eded00; 
        paddingLeft: 10; 
        paddingTop: 5; 
        paddingBottom: 5; 
        fontSize: 18; 
    } 
     
    s|Label.paragraphLabel{ 
        paddingLeft: 10; 
        paddingRight: 10; 
        fontSize: 14; 
    } 
} 
@media (application-dpi:240) {                                            
    s|Label.separatorLabel{ 
320 DPI selectors 
160 dpi selectors 
240 dpi selectors 

140 
CHAPTER 5 Handling mutiresolution devices 
        backgroundColor: #327d00; 
        color: #eded00; 
        paddingLeft: 20; 
        paddingTop: 10; 
        paddingBottom: 10; 
        fontSize: 22; 
    } 
     
    s|Label.paragraphLabel{ 
        paddingTop: 10; 
        paddingBottom: 10; 
        paddingLeft: 20; 
        paddingRight: 20; 
        fontSize: 18; 
    } 
} 
@media (application-dpi:320) {                                            
    s|Label.separatorLabel{ 
        backgroundColor: #327d00; 
        color: #eded00; 
        paddingLeft: 20; 
        paddingTop: 10; 
        paddingBottom: 10; 
        fontSize: 32; 
    } 
     
    s|Label.paragraphLabel{ 
        paddingTop: 10; 
        paddingBottom: 10; 
        paddingLeft: 20; 
        paddingRight: 20; 
        fontSize: 24; 
    } 
} 
{chap 5 code}/src/assets/css/main.css
Here you set up the look of a nice separator bar within your DetailsView and give some 
padding to your text so that it isn’t right up against the sides of your application. With a little 
color and padding, you have a nice new look to your details page, and based on the DPI of 
the device, you change the font to be appropriately sized (see figure 5.8). 
320 dpi selectors 

Handling multiresolution devices  
141 
Figure 5.8 Details page visualized 
Making changes to your application via CSS is wicked cool. To go one step further you’ll 
make visual changes to your application, based not just on DPI but also on the device 
platform. 
5.2.4 
Adding in hardware-specific CSS media queries 
Building onto your CSS capabilities, you’ll need to specifically target individual platforms 
along with device DPI. In CSS you can target many different platforms, including Android, 
iOS, Linux, Macintosh, QNX, and Windows. You don’t have to target specific DPIs to target 
specific platforms, but it’s possible to target both if you so choose (see the following listing). 

142 
CHAPTER 5 Handling mutiresolution devices 
Listing 5.2 main.css target hardware and DPI with media queries 
/* CSS file */ 
@namespace s "library://ns.adobe.com/flex/spark"; 
. . . 
@media (application-dpi:160){ 
    . . . 
} 
@media (application-dpi:240){ 
    . . . 
} 
@media (application-dpi:320){ 
    . . . 
} 
@media (application-dpi:160) and (os-platform:"IOS") {                    
    s|Label.separatorLabel{ 
        backgroundColor: #327d00; 
        color: #eded00; 
        paddingLeft: 10; 
        paddingTop: 5; 
        paddingBottom: 5; 
        fontSize: 18; 
        textAlign:center; 
    } 
} 
@media (application-dpi:240) and (os-platform:"IOS") {                    
    s|Label.separatorLabel{ 
        backgroundColor: #327d00; 
        color: #eded00; 
        paddingLeft: 20; 
        paddingTop: 10; 
        paddingBottom: 10; 
        fontSize: 22; 
        textAlign:center; 
    } 
} 
@media (application-dpi:320) and (os-platform:"IOS") {                    
    s|Label.separatorLabel{  
        backgroundColor: #327d00; 
        color: #eded00; 
Targeting 160 DPI and iOS 
Targeting 240 DPI and iOS 
Targeting 320 DPI and iOS 

Handling multiresolution devices  
143 
        paddingLeft: 20; 
        paddingTop: 10; 
        paddingBottom: 10; 
        fontSize: 32; 
        textAlign:center; 
    } 
} 
{chap 5 code}/src/assets/css/main.css
I’ve noticed that many iOS devices like to center the labels rather than the Android way of 
left-justifying labels. So for each of the DPI values running on the iOS platform, the 
separatorLabel will be center aligned (see figure 5.9). 
Figure 5.9 Android 160 DPI versus iOS 160 DPI 
CSS is one solution to the multiscreen problem, allowing you to change the visual nature of 
your application based on DPI, platform, or both. In the next section we’ll discuss another 
option for switching content based on DPI, the new MultiDPIBitmapSource class. 

144 
CHAPTER 5 Handling mutiresolution devices 
5.3 
Images for multiscreen projects 
Now that you can change styles dynamically via CSS, you need to swap out images and icons 
based on the device’s resolution. New to Flex Mobile is the MultiDPIBitmapSource, a 
class created to select a specific image based on the device’s DPI. 
In this section you’ll use the new MultiDPIBitmapSource class built into the Flex 
framework to manage your assets at runtime. As a developer, you can set multiple sources 
to a single image source, and then at runtime the MultiDPIBitmapSource class will 
determine which source to load. This new class is extremely helpful when you need to create 
a single application that supports multiple screens. 
HEADS UP! 
One thing to note is that you don’t have to set all of the 160, 240, and 320 DPI images 
for this class to work. You can set just the DPI values you want to manage at runtime. 
5.3.1 
Organizing your images for multiscreen projects 
When creating a single application to work across multiple devices you’ll find yourself using 
multiple skin classes for the various DPI values and—as highlighted in this section—multiple 
images. Because you’re about to triple the number of images that your application is 
managing, assets organization is about to become paramount to your application’s success. 
Obviously, whatever works for you is the best solution, but the method I’m proposing works 
for me in small and large team projects. 
Within your images file you need to break up your visual assets, skins and images, by 
DPI bucket and then keep the naming schema the same (see figure 5.10). 
Figure 5.10 Your organized images 

Handling multiresolution devices  
145 
As your image assets grow, your assets file will stay organized and easy to manage. If you 
decide to not support a specific DPI bucket, then you can easily remove the entire folder. 
In the next segment you’ll use your three logos with the MultiDPIBitmapSource to 
switch out the image based on DPI bucket.  
5.3.2 
Using the MultiDPIBitmapSource with an image 
For your application you’ll want to add the Rotten Tomatoes logo (see figure 5.11) to your 
BrowseView instead of just using the text “Rotten Tomatoes.” You could always stretch the 
logo, but the quality may suffer beyond the desired level or you may want to use a 
completely different image because of the DPI. 
              320 DPI                                        240 DPI                          160 DPI 
Figure 5.11 Three different logo sizes 
Returning to BrowseView.mxml you need to switch out the titleContent with your 
image and the MultiDPIBitmapSource: 
<fx:Declarations> 
<!-- Place non-visual elements (e.g., services, value objects) here --> 
</fx:Declarations> 
<s:titleContent> 
    <s:Image>                                                             
        <s:source>                                                        
            <s:MultiDPIBitmapSource                                       
    source160dpi="@Embed('/assets/images/160dpi/rottentomatoes_logo.png')" 
    source240dpi="@Embed('/assets/images/240dpi/rottentomatoes_logo.png')" 
    source320dpi="@Embed('/assets/images/320dpi/rottentomatoes_logo.png')" 
            /> 
        </s:source> 
    </s:Image> 
</s:titleContent> 
     
<s:List width="100%" height="100%" 
With your image set in the titleContent with the MultiDPIBitmapSource your 
application now shows only the appropriate image by device DPI. 
Image component 
Image source in MXML 
MultiDPIBitmapSource with 3 sources 

146 
CHAPTER 5 Handling mutiresolution devices 
One downside to this approach is that you’ve now embedded three images instead of one, 
tripling the memory footprint of your assets in the final application. 
With the ability to switch out your images at runtime, you can ensure that the quality of 
your images stays consistent no matter the device DPI. But what if you want the ability to 
change the device DPI value that you’ve been so tied to this entire chapter? In the next 
section we’ll look at where this value is derived and how to bend it to your will. 
5.4 
Overriding DPI returns to customize applicationDPI values 
The biggest issue with creating applications that work based on the device’s resolution is that 
not all devices report their resolution accurately or you may want to override the value 
returned by the device for personal reasons. 
Earlier we looked at the applicationDPI and how it represents the value of the 
application’s DPI within one of the three buckets. Unless it’s set otherwise, you know that 
this value is set to match the runtimeDPI value. If you wondered where this value is 
determined, the answer is in the new Flex Mobile class RuntimeDPIProvider. By default, 
this class returns the screenDPI, the DPI value returned from the hardware itself, set by 
the device manufacturer.  
IMPORTANT NOTE 
The manufacturer doesn’t always set the screenDPI value correctly. If you find a 
situation where the screenDPI is incorrect, you can use the RuntimeDPIProvider 
to override the incorrect value. 
In this section we’ll look at how to see what settings the device is returning and, where 
necessary, how to override incorrect values. 
5.4.1 
Finding the capabilities values for each device 
Each device includes a set of runtime values that when combined create a near-unique 
profile of the specific device. The four values that create your profile are the 
screenResolutionX, screenResolutionY, manufacturer, and screenDPI, which 
represent the screen width, screen height, platform, and DPI, respectively: 
var screenResolutionX:Number = Capabilities.screenResolutionX; 
var screenResolutionY:Number = Capabilities.screenResolutionY; 
var manufacturer:String = Capabilities.manufacturer; 
var screenDPI:Number = Capabilities.screenDPI; 
With these four values together you can, with a high degree of confidence, conclude which 
device you’re running your application on. If another device is created with the same exact 
four values, then you may end up overriding the wrong device, but it’s a safe bet that these 
four values will be unique to a single device. 

Handling multiresolution devices  
147 
5.4.2 
Overriding the RuntimeDPIProvider 
As hinted at earlier, new within the Flex framework is a class called RuntimeDPIProvider, 
which is used to set the applicationDPI. To override the base functionality you’ll need to 
subclass the RuntimeDPIProvider and override the runtimeDPI getter method (see the 
following listing). 
Listing 5.3 CustomRuntimeDPIProvider 
package com.unitedmindset.utils{ 
    import flash.system.Capabilities; 
     
    import mx.core.DPIClassification; 
    import mx.core.RuntimeDPIProvider; 
     
    public class CustomRuntimeDPIProvider extends RuntimeDPIProvider{ 
        public function CustomRuntimeDPIProvider(){ 
            super(); 
        } 
         
        override public function get runtimeDPI():Number{ 
        var screenResolutionX:Number = Capabilities.screenResolutionX; 
        var screenResolutionY:Number = Capabilities.screenResolutionY; 
        var manufacturer:String = Capabilities.manufacturer; 
        var screenDPI:Number = Capabilities.screenDPI;                    
             
            //droid pro portrait 
            if(screenResolutionX == 480 &&                                
                screenResolutionY == 854 &&                               
                manufacturer == "Android Linux" &&                        
                screenDPI == 144)                                         
                return DPIClassification.DPI_240; 
            //droid pro landscape 
            else if(screenResolutionX == 854 &&                           
                screenResolutionY == 480 &&                               
                manufacturer == "Android Linux" &&                        
                screenDPI == 144)                                         
                return DPIClassification.DPI_240; 
            //finally 
            return super.runtimeDPI;                                      
        } 
    } 
} 
{chap 5 code}/src/com/unitedmindset/utils/CustomRuntimeDPIProvider.as 
In this listing you create a custom subclass of the RuntimeDPIProvider and override the 
runtimeDPI getter function. This method is run when the application starts up to determine 
Match device’s portrait 
mode
Device properties 
Match device’s 
landscape mode
Return original value if not one of 
overridden values

148 
CHAPTER 5 Handling mutiresolution devices 
the applicationDPI. Within the runtime getter function you match the device profile 
against both the portrait and landscape values. You match against both possible profiles 
because the application could start up in either the landscape or portrait mode. 
Finally, you need to include your custom RuntimeDPIProvider in your application: 
<?xml version="1.0" encoding="utf-8"?> 
<s:TabbedViewNavigatorApplication xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark" 
    persistNavigatorState="true" 
    runtimeDPIProvider="com.unitedmindset.utils.CustomRuntimeDPIProvider"> 
                                                                        
    <s:ViewNavigator label="Browse" width="100%" height="100%" 
        firstView="views.BrowseView"/> 
    <s:ViewNavigator label="Search" width="100%" height="100%" 
        firstView="views.SearchView"/> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <fx:Style source="/assets/css/main.css"/> 
</s:TabbedViewNavigatorApplication> 
#A  
With the included CustomRuntimeDPIProvider you can now make and fix changes to 
your applicationDPI as you see fit for your multiscreen applications. 
In the next section you’ll go further and create a splash screen that responds to multiple 
resolutions, again expanding the abilities of a single application to support multiple devices. 
5.5 
Splash screens 
Introduced in Flex Mobile is the idea of a splash screen. The splash screen is a lightweight 
preloader for an application that displays a single image. The reason applications use 
preloaders is to let the user know that some activity is in progress before the application can 
start up—specifically, loading the application into memory. When the application is loaded 
and ready for the user, the splash screen is removed and the application can be interacted 
with. 
In this section we’ll look at the two different options for the lightweight preloader splash 
screens provided by the Flex framework and how to best utilize these splash screens for 
multiscreen applications.  
5.5.1 
Basic splash screen 
The first option is to use the SplashScreen preloader class with a single image for all the 
various application sizes. To do this you need to add some code to your main application file 
to reference the correct image: 
<?xml version="1.0" encoding="utf-8"?> 
Included 
Custom
Runtime
DPIProvider 

Handling multiresolution devices  
149 
<s:TabbedViewNavigatorApplication xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark" 
    persistNavigatorState="true" 
    runtimeDPIProvider="com.unitedmindset.utils.CustomRuntimeDPIProvider" 
    preloader="spark.preloaders.SplashScreen"                             
    splashScreenImage="@Embed('/assets/images/splashscreenComplex.png')"> 
    <s:ViewNavigator label="Browse" width="100%" height="100%"  
        firstView="views.BrowseView"/> 
    <s:ViewNavigator label="Search" width="100%" height="100%"  
        firstView="views.SearchView"/> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <fx:Style source="/assets/css/main.css"/> 
</s:TabbedViewNavigatorApplication> 
To include the splash screen image, you have to embed the image for your splash screen and 
include the spark.preloaders.SplashScreen for the preloader class. With both of these 
properties set, you can see your splash screen when the application starts up (see figure 
5.12). 
Embed the 
image
Include the Preloader class 

150 
CHAPTER 5 Handling mutiresolution devices 
Figure 5.12 Your splash screen 
When using a single image you have a few options for how to render your splash screen. 
Utilizing stretch and zoom properties, you can have the splash screen fit your device’s screen 
as you desire. One issue with a single image is that if you have a design that you want to 
stretch for all screens, then the rendered image may not have the look you intend (see 
figure 5.13). 

Handling multiresolution devices  
151 
Figure 5.13 A single stretched image across devices 
You can see that the image stretching quickly becomes unacceptable for a release product. 
There are some considerations for creating a single image for your splash screen (see figure 
5.14). 
Figure 5.14 Usable splash screen 
As you can see, by creating a splash screen that doesn’t rely on the edges of the device, you 
can center your image, and the image works nicely across many different devices (see figure 
5.15). 

152 
CHAPTER 5 Handling mutiresolution devices 
Figure 5.15 Simple splash screen across devices 
With a good-looking single image for the preloader, we’ll next look at a way to create splash 
screens for specific devices and sizes. 
5.5.2 
Multiresolution splash screen 
Creating a centered image may not be the look you’re going for. Instead, you may prefer a 
more complex image and want to be able to customize the image to the device. If this is the 
case, then you may want to use the method where you create specific images for the DPI, 
orientation, and screen size.  
The other option for setting the splashScreenImage property is to give it a new 
component 
based 
on 
the 
SplashScreenImage 
with 
an 
array 
of 
SplashScreenImageSource components. To enable this feature you must create a second 
component based on the SplashScreenImage.  
The SplashScreenImageSource object is a special class that allows you to set an 
image with additional metadata, telling the SplashScreenImage preloader class which 
image to use based on the device’s configuration (see the following listing). You need to 
create this in the com.unitedmindset.utils package. 
Listing 5.4 RottenTomatoesSplashScreen.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:SplashScreenImage xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark"> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <!-- iPhone 3 -->                                                     
    <s:SplashScreenImageSource dpi="160" minResolution="460"  
Array of images 

Handling multiresolution devices  
153 
    source="@Embed(source='/assets/images/splash/Default.png')" /> 
    <!-- iPhone 4 --> 
    <s:SplashScreenImageSource dpi="320" minResolution="920"  
    source="@Embed(source='/assets/images/splash/Default@2x.png')" /> 
    <!-- iPad Portrait --> 
    <s:SplashScreenImageSource dpi="160" minResolution="1004"  
    source="@Embed(source='/assets/images/splash/Default-Portrait.png')" 
    aspectRatio="portrait"/> 
    <!-- iPad Landscape --> 
    <s:SplashScreenImageSource dpi="160" minResolution="1024" 
     source="@Embed(source='/assets/images/splash/Default-Landscape.png')" 
    aspectRatio="landscape"/> 
    <!-- Android smartphones Portrait --> 
    <s:SplashScreenImageSource dpi="240" minResolution="762"  
    source="@Embed(source='/assets/images/splash/Default-Android.png')" 
    aspectRatio="portrait"/> 
    <!-- Android smartphones Landscape --> 
    <s:SplashScreenImageSource dpi="240" minResolution="800"  
    source="@Embed(source='/assets/images/splash/Default-Android- 
    Landscape.png')" aspectRatio="landscape"/> 
    <!-- Android tablets Portrait --> 
    <s:SplashScreenImageSource dpi="160" minResolution="980"  
    source="@Embed(source='/assets/images/splash/Default-Android- 
    Tablet.png')" aspectRatio="portrait"/> 
    <!-- Android tablets Landscape --> 
    <s:SplashScreenImageSource dpi="160" minResolution="980"  
    source="@Embed(source='/assets/images/splash/Default-Android-Tablet- 
    Landscape.png')" aspectRatio="landscape"/> 
    <!-- Default --> 
    <s:SplashScreenImageSource  
    source="@Embed(source='/assets/images/splashscreenCenter.png')"/> 
</s:SplashScreenImage> 
{chap 3 code}/src/com/unitedmindset/utils/RottenTomatoesSplashScreen.mxml
With the various settings you can target individual sized screens in specific orientations. With 
the new custom splash screen component complete, the only task left is to include it in your 
application: 
<?xml version="1.0" encoding="utf-8"?> 
<s:TabbedViewNavigatorApplication xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark" 
    persistNavigatorState="true" 
    runtimeDPIProvider="com.unitedmindset.utils.CustomRuntimeDPIProvider" 
    preloader="spark.preloaders.SplashScreen" 
    splashScreenImage="com.unitedmindset.utils.RottenTomatoesSplashScreen"> 
    <s:ViewNavigator label="Browse" width="100%" height="100%" 
firstView="views.BrowseView"/> 

154 
CHAPTER 5 Handling mutiresolution devices 
    <s:ViewNavigator label="Search" width="100%" height="100%" 
firstView="views.SearchView"/> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <fx:Style source="/assets/css/main.css"/> 
</s:TabbedViewNavigatorApplication> 
Do remember that each additional splash screen embedded with your application adds to the 
final file size. If this is an issue, you may want to cut back on the quantity of splash screens 
you include. 
IOS ALERT! 
iOS devices have known sizes and specific names that you must adhere to, such as the 
names Default.png and Default@2x.png. You can see these specific rules at the iOS 
developer library: http://developer.apple.com/library/ios/#qa/qa1588/_index.html. 
With your splash screens configured by device, you can provide a truly unique experience for 
every screen that the application runs on. 
5.6 
Summary 
With the ability to scale your application based on the device using tools such as CSS and 
embedded images, you can create a single application file that not only works across 
platforms but also looks good across platforms. 
Some key points to take away from this chapter: 

Bitmap images scale down well and up poorly. 

Vector images scale up well and down poorly. 

Each embedded image adds to your final file size. 

CSS can target specific DPI sizes and manufacturers. 

You can override the runtimeDPI when necessary. 

The hardware isn’t always right. 

There are three DPI buckets to remember: 160 DPI, 240 DPI, and 320 DPI. 

Part 3  
Advanced mobile development 
In part 3 you’ll take your application from the ordinary to the extraordinary. Using new 
features and some old favorites, you’ll customize your application and development 
environment to give your application the strength to be ready for enterprise environments. 
You’ll start part 3 by changing your simple application to a Robotlegs-based MVC 
application. This overhaul will give you the flexibility to easily add features and simplify each 
section of your application. 
Moving from chapter 6 to chapter 7, you’ll take your MVC-based application and 
intelligently splinter it to work across various mobile platforms. This will give you the ability 
to customize your application to each mobile platform while utilizing the maximum amount of 
code reuse and minimizing your application complexity. 
In chapter 8 we’ll look at three popular topics in mobile development: generating 
revenue, native extensions, and user tracking. These three features, often considered out of 
reach by small teams, will be brought within reach and made easily manageable. 
As we move into chapter 9, we’ll focus on ways to improve the quality of your application 
by means invisible to the user. In this case we’ll focus on how to write unit tests, ensuring 
your application runs consistently after various code changes. 
Finally, the book rounds out with chapters 10 through 12, focusing on all the steps 
necessary to release your application into the various app stores. Chapter 10 lays out all of 
the features made possible by the often-neglected application descriptor file. Chapter 11 
looks at how to use Flash Builder to quickly build your application for various platforms; 
chapter 12 shows you how to use ANT to build your application for each platform reliably 
with a single click of a button. 
Once you’ve completed the process, you’ll have an amazingly powerful development 
stack, enabling you to quickly create mobile application for each of the various platforms.


157 
6  
MVC with mobile applications 
This chapter covers 

Principles of MVC development 

Using the Robotlegs framework 

Properly separating code 

Best practices for application development 

Making a tablet-friendly application 
You have an application pulling data, looking awesome, and using device-specific capabilities, 
yet right now I wouldn’t recommend the current application structure for a scalable, testable, 
releasable enterprise application. As your application grows, you find that adding features 
becomes continuously more difficult, and when you decide to split the application into 
platform-specific pieces, you end up with a lot of duplicate code resulting in harder to 
manage applications. Furthermore, the code is completely untestable, meaning that you 
can’t be sure that any code changes don’t result in further introduced bugs. 
The solution to these gaps in the application is using a concept called MVC, or Model-
View-Controller. 
By now, and probably more than once, you’ve heard the term MVC. Sometimes it’s used 
in the correct context as a way to plan and lay out an application, and sometimes it’s used 
incorrectly as a perfect solution to everything. 
WHAT IS MVC? 
The concept of MVC (see figure 6.1) is a tried and tested application development paradigm 
used to create scalable applications that use a clear separation of duties among their classes. 
By breaking up your code into smaller duties, you’ll find that the application will go from 
tightly coupled to loosely coupled, from hard to maintain to easy to update, from hard to 

158 
CHAPTER 6 MVC with mobile applications 
read to the epitome of clean code, and yes, dogs and cats living together, with mass hysteria 
circumvented. Your application is about to have an industrial-strength upgrade. 
Figure 6.1 MVC(S) visualized 
Although the concept is commonly called MVC, we’ll be discussing MVC(S), a slight and 
commonly accepted modification that continues the separation of duties with an additional 
segment. The four code segments that you’ll break your application into are models, views, 
controllers, and services. The separation of duties simplifies each individual section, 
providing focus to the application and breaking it down into small manageable segments of 
code that can be easily managed by teams or individuals. 
Tightly coupled? Loosely coupled? 
When we talk about an application that’s tightly coupled, we mean that much of the code 
within the application directly relies on the exact placement of methods or components. 
This is bad because you can program yourself into a corner, where every change to any 
file causes a large amount of application refactoring across many other files.  
If you create a loosely coupled application, which is the goal, then you can make pretty 
significant changes to classes within your application with only minor changes to other 
parts of the application. 
MODELS 
The model layer is my personal favorite; the full name is the data model layer. This layer 
contains all of the data for your application—absolutely no visualization of the data. The 
model doesn’t know anything about the other layers of the MVC(S) stack. Furthermore, the 
only way to interact with the data model is to use the public methods exposed specifically by 
the data model layer’s public interfaces.  
When creating an effective model layer, you need to change the way you think. No longer 
can you “do something” with the data held within your application, but instead you need to 
think of creating an API within your application that you interact with. This inner application 
API provides a protected layer to access the application data (see figure 6.2).  

MVC with mobile applications 
159 
Figure 6.2 Inner application API on the model layer 
Value objects, the model’s dumb cousin 
Some developers are a bit confused by the term value object (VO) and how it relates to 
the model. If you’re coming from other development languages, you may also know VOs 
as DTOs. Although the term VO isn’t Flex- or ActionScript-specific, the term isn’t used in 
all languages. The idea is that VOs are simple objects that use a collection of properties to 
represent an object. A common example is the PersonVO, which includes the name, age, 
and occupation properties to describe a person. These properties are almost always 
unique to the application and how the application represents these objects. 
The main difference between a model and a VO is that VOs typically lack the ability to 
perform any work. Sure a VO may include a toString() method, but a VO won’t 
change data, dispatch events, or interact with services—these are the job of models. 
Models typically manage lists of VOs and perform work on the VOs to accurately 
represent the data in the application. 
VIEWS 
The view layer is the layer that users see and interact with. This layer doesn’t know or have 
access to the model layer. With all due respect to the view layer, the view layer is “dumb.” 
The view layer just sits and looks pretty, waiting to be told what to do by the user or the 
controller layer (see figure 6.3). Remember when developing MVC applications that the view 
layer doesn’t include any logic, or the how in how an application works; the view layer does 
what it needs to do to look nice without any knowledge of the rest of the application. 

160 
CHAPTER 6 MVC with mobile applications 
Figure 6.3 The dumb view layer 
CONTROLLER 
The third layer and the C in MVC is the controller layer. You’ve probably already heard this 
layer being referred to as the glue in MVC applications. Although this is a good description of 
the controller layer, this doesn’t fully explain the responsibilities of the controller layer. 
This layer connects to the view layer, pulling information input from the user and giving 
the data to the model where necessary. The controller layer also listens to changes from the 
model and sets the model information to the view, acting as a mediator between the data 
model and the view layer. The controller knows of the model and the view, listening to 
changes from the view and the model and setting data using the application’s inner API (see 
figure 6.4). 
Figure 6.4 Controller’s connection 

MVC with mobile applications 
161 
SERVICE 
The final code segment is the service layer, as shown in figure 6.5. The service layer 
interacts with the world outside the application, pulling information from other sources such 
as databases, device sensors, and other applications’ web services to populate your 
application with data. This layer makes any necessary translation of data to domain-specific 
data—your value objects—and sets the data model using public methods on the application’s 
inner API. 
Figure 6.5 Service layer visualized 
In this chapter you’ll refactor your application using the popular MVC framework Robotlegs, 
which was created to build a scalable, testable, enterprise-ready application that you can 
proudly release and easily add features to. This chapter won’t focus on Flex Mobile–specific 
features but on best practices for creating applications. After refactoring your code into an 
MVC(S) application, you’ll be ready for the next chapter, where you’ll be customizing your 
application for each platform that you want to support. 
6.1 
What is Robotlegs? 
Imbued with the knowledge of MVC we can now look at a specific MVC microarchitecture 
framework, Robotlegs. There are various application frameworks including the infamous 
Cairngorm, PureMVC, Mate, Parsley, and Swiz, but I’ve found a favorite in Robotlegs and the 
way the Robotlegs framework works within an application. 
Although each of the frameworks works well and can be used when developing mobile 
applications, I like how Robotlegs uses dependency injection to simplify code and how the 
view mediators are created and destroyed automatically by the framework with each view. 
As you already know, your application’s views are created and destroyed often by the 
ViewNavigator, so the view mediator paradigm works well with your ViewNavigator
policies. 

162 
CHAPTER 6 MVC with mobile applications 
Just like any of the other frameworks, Robotlegs includes its own components and some 
best practices for putting together an application using the framework. 
Robotlegs 
Robotlegs is a pure AS3 microarchitecture (framework) with a light footprint and limited 
scope. Simply put, Robotlegs is there to help you wire your objects together. It provides 
the glue that your application needs to easily function in a decoupled way. Through the 
use of automated metadata-based dependency injection, Robotlegs removes boilerplate 
code in an application. By promoting loose coupling and avoiding the use of singletons 
and statics in the framework, Robotlegs can help you write code that’s highly testable. 
From http://www.robotlegs.org/ 
Figure 6.6 shows a good example of the Robotlegs framework broken into its individual 
parts for the Rotten Tomatoes application. With this diagram you can see the flow of data as 
it moves through the entire application. 
Figure 6.6 Robotlegs functional diagram 
Figure 6.7 continues to get more specific by showing the specific flow of data through a 
single process. Although just one feature is shown, you should see how you could reuse the 
same routines throughout your application, easily adding features using the same pattern for 
development. 

MVC with mobile applications 
163 
Figure 6.7 Search function diagram 
In this section we’ll quickly break down Robotlegs and see how it works, starting with the 
different Robotlegs actors. We’ll show some sample code in this section and in the following 
section you’ll update your application using the Robotlegs framework. 
6.1.1 
How Robotlegs works 
Robotlegs works by using a handful of custom classes that you’ll extend for your application 
to reduce the large amount of boilerplate application glue that you’d typically have to write 
to facilitate interapplication communication. Robotlegs does this by first creating a central 
application hub to route all of your application communication, the Context, using 
dependency injection to provide easy access references to your on-demand classes, and 
finally mapping various components together to facilitate the separation of duties that we 
discussed when investigating MVC. 
Looking at the various parts of the Robotlegs framework, we’ll start with the Context. 
CONTEXT 
The heart of a Robotlegs framework is the Context class (refer back to figures 6.6 and 6.7). 
The Context class is created when an application starts up and then serves as the central 
routing system for your app. Within the Context class you determine what commands are 
routed with which events, what classes are injected with your injection metadata, and also 
which views are mapped to which mediator (see listing 6.1). If this sounds like a lot to take 
in, don’t worry; you’ll be using each of these features in your application. If the terms, 
commands, injections, or mediators seem foreign, then be patient and file these terms away; 
in the following subsections we’ll address each term. 
Listing 6.1 Example context file 
package com.unitedmindset{ 
    import org.robotlegs.base.ContextEvent; 
    import org.robotlegs.mvcs.Context; 

164 
CHAPTER 6 MVC with mobile applications 
     
    public class nameContext extends Context{ 
     
public function nameContext(contextView:DisplayObjectContainer=null,  
    autoStartup:Boolean=true){ 
        super(contextView, autoStartup);                                  
    } 
         
    override public function startup():void{                              
commandMap.mapEvent(ExampleEvent.EXAMPLE, ExampleCommand,  
    ExampleEvent);                                                        
        injector.mapSingleton(ExampleService);                            
injector.mapSingletonOf(IExampleService, ExampleService);                 
        injector.mapSingleton(ExampleModel);                              
        mediatorMap.mapView(ExampleView, ExampleMediator);                
        dispatchEvent(new ContextEvent( ContextEvent.STARTUP_COMPLETE,  
        contextView));                                                    
    } 
         
    override public function shutdown():void  { }                         
         
} 
} 
The Context class, as you can tell, is simple. When the application starts up, the Context
class calls the startup method, and when the application shuts down, the Context class 
calls the shutdown method. Within the methods you set up and tear down your application 
and run any necessary bits of functionally. 
Startup and shutdown 
It’s common in the startup functionality to not just lay out your application’s mapping but 
to also make introductory service calls, connect to SQLite databases, and perform other 
functions so that the user doesn’t have to wait on them later. 
During shutdown it’s common to make any service calls that might need some cleanup 
and to persist data. Obviously, it isn’t wise to make service calls that may require 
responses, because the application will most likely be terminated on response. 
With mobile applications it’s also wise to remember that depending on how the 
application closes, the shutdown function may not be reached. If you have some 
Context constructor 
Startup function to set 
mappings 
Map an event to a command 
Map a service in the Injector 
Mapping service by interface 
Map models the same as service 
Map a view to a mediator 
Alert application is ready 
Shutdown function 

MVC with mobile applications 
165 
functionality that needs to be run when the application closes, you should make sure to 
respond to the viewDeactivate events on your views. 
In the next parts of this section we’ll break down how to wire various parts of a Robotlegs 
framework together, how to use the individual parts, and how to execute the needed code 
within the application. 
INJECTIONS 
First, we’ll look at the injections system, a simple way to retrieve classes within an 
application. This is how you’ll be able to quickly pull references to other parts of the 
application. In the context of your application you can set up classes into the Robotlegs 
injection system in a variety of ways; in the example context shown previously you used two 
different formats for injections. 
The first option sets a class as a singleton. The class is only created the first time it is 
requested. Any future requests to the class will return the previously created instance:  
injector.mapSingleton(ExampleService); 
Using dependency injection, the requested class is injected when requested. This is the 
entire concept behind dependency injection, the process of creating a class on demand based 
on a declaration or interface contract. In this case, the declaration is the ExampleService 
class definition: 
[Inject] 
public var service:ExampleService; 
The second option maps a class to an interface within the injection system. When you 
request the class with an interface, then the mapped class is returned: 
injector.mapSingletonOf(IExampleService, ExampleService); 
Again using dependency injection, Robotlegs will create the requested class. This time it’s 
based on an interface instead of a class definition: 
[Inject] 
public var service:IExampleService; 
There are a few other options for accessing data from the injector and for setting classes 
with the Robotlegs injector, but for the sake of your application this is all that you’ll need to 
know to work with Robotlegs. Now that you know how to inject classes around the 
application, let’s look at how the user will interact with the application using the 
view/mediator system. 
VIEW/MEDIATOR 
The second system you’ll plug into is the view/mediator system. This way, whenever a view 
is created or destroyed, the accompanying mediator is also created or destroyed, 
respectively. Within the context you map the view to the class that will mediate it: 
mediatorMap.mapView(ExampleView, ExampleMediator); 

166 
CHAPTER 6 MVC with mobile applications 
Now whenever an ExampleView class is created, the ExampleMediator is instantiated to 
match your view. When the view is ready, the onRegister() method is called on the 
mediator, giving you a convenient place to set data and add listeners to a view: 
public class ExampleMediator extends Mediator{ 
    public function ExampleMediator(){ 
        super(); 
    } 
     
    [Inject] 
    public var view:ExampleView; 
     
override public function onRegister():void{ . . . } 
. . . 
When the view is being removed, then the onRemove() method is called. This is a perfect 
function to persist view data and to remove event listeners from the connected view, 
allowing for clean garbage collection: 
public class ExampleMediator extends Mediator 
{ 
    public function ExampleMediator(){ 
        super(); 
    } 
     
    [Inject] 
    public var view:ExampleView; 
     
override public function onRemove():void{ . . . } 
. . . 
With this system set, you can easily add functionality to the views that you create and 
interact with the application’s models. This system facilitates the view and controller in MVC. 
Next, we’ll look at the event/command system built into Robotlegs. 
Garbage collection 
There are many specifics to garbage collection and best practices, but right now we’ll 
focus on what I believe trips up most developers: not cleaning up your event listeners. As 
you already know, event listeners create connections between instances in memory. 
When the runtime runs over instances in your application to determine what can be 
destroyed and what can’t, one of the factors in the garbage-collection logic is how many 
listeners these instances have connecting them to other instances.  
If there are no listeners connected and the instance isn’t connected to the display list, 
then the data can be cleaned up. But even if there’s just one listener hanging on, the 
instance isn’t garbage-collected and now your application has a memory leak. 

MVC with mobile applications 
167 
In Robotlegs you add and remove your listeners using the onRegister() and 
onRemove() methods specifically for this garbage-collection issue. 
EVENTS/COMMANDS 
The third system you’ll plug into is the event/command map. Any event fired within the 
application is routed through the application’s central event dispatcher. This central event 
dispatcher enables two features that are helpful to your applications. 
The first feature is that any event fired can be listened to by any other part of the 
application. This flattened communication simplifies how events within an application are 
responded to (see figure 6.8). 
Figure 6.8 Flattened communication 
The second feature enabled by using a central dispatcher within Robotlegs is the ability to 
route events directly to commands. 
Commands are simple classes with an extremely short lifespan—usually the period of a 
single function—that take care of a specific small piece of functionality. The limited 
functionality of a command may seem like a fault, but it’s actually a feature. By handling 
only a single piece of functionality, the command is kept simple, fast, easy to test, and highly 
reusable. You won’t have to worry about another instance of the command existing, nor will 
you have to worry about how the state of the application will affect the command. Instead, 
the command has access to only a small subset of data, and the entire state of the command 
is restricted to the information that the command knows from the event that called it. 

168 
CHAPTER 6 MVC with mobile applications 
If this functionality sounds familiar, that’s good. This methodology is often used in 
application frameworks and is called the command pattern. In this case the command 
pattern client is the context, instantiating the command when necessary. The invoker is the 
event that helps the client decide which command to create. And the receiver is the created 
command (see figure 6.9). 
Figure 6.9 Command pattern 
Within the Robotlegs’ context you set up the map by using the commandMap: 
commandMap.mapEvent(ExampleEvent.EXAMPLE, ExampleCommand, ExampleEvent); 
Now whenever an ExampleEvent of type ExampleEvent.EXAMPLE is fired, the 
ExampleCommand will be executed: 
dispatch(new ExampleEvent(ExampleEvent.EXAMPLE, otherData)); 
One feature of Robotlegs is that the invoking event is always injected into the invoked 
command, again using the injection method to simplify your application’s code: 
package com.unitedmindset.controllers{ 
    import com.unitedmindset.events.ExampleEvent; 
    import org.robotlegs.mvcs.Command; 
     
    public class ExampleCommand extends Command{ 
        public function ExampleCommand(){ 
            super(); 
        } 
         
        [Inject] 
        public var event:ExampleEvent; 
                 
        override public function execute():void{ 
            //do something 
        } 
    } 
} 

MVC with mobile applications 
169 
By dispatching your ExampleEvent with type ExampleEvent.EXAMPLE you’ve created a 
new instance of the ExampleCommand command. The command will be created, run the 
execute() method, and die as soon as the execute() method is complete. Commands 
are great pieces of code to execute number crunching, to interact with models or services, 
and to perform any other repeatable task you may encounter. 
In the next section we’ll look at the final player in Robotlegs, the Actor. 
ACTORS 
While extending the Robotlegs Command class may be obvious for command classes, and 
extending the Robotlegs’ Mediator class is obvious for your view mediators, what do you do 
with the Robotlegs Actor class? This one oddity doesn’t seem to line up with any other 
specific patterns within your application. 
The Actor class is a base class that you can use for any class that needs access to the 
Robotlegs framework and that isn’t specifically a Context, Mediator, or Command. The 
Actor class includes access to injections and the central dispatcher, giving you all the 
access necessary to affect your application. Once added into your Context, Actor classes 
are used to create data models and service classes. 
As you refactor your application, you’ll see exactly how Actor classes are used within the 
application. 
Now that you fully understand the different players within Robotlegs, your next move will 
be to update your Rotten Tomatoes application to use the Robotlegs framework. 
6.2 
Hitting the ground running with Robotlegs 
Based on the last section, you know that the context is the central hub for a Robotlegs-based 
application. You now need to update the Rotten Tomatoes application to use the Robotlegs 
framework, and along the way you’ll be adding in some features. 
In this section you’ll take your first steps into the application refactor by setting up the 
context and preparing it for the models, services, and mappings that you’ll be adding in the 
upcoming sections. 
6.2.1 
Creating the context shell 
You start by pulling the Robotlegs SWC file from the Robotlegs website. This is available at 
http://robotlegs.org. For a direct download link, use the Robotlegs GitHub download site: 
https://github.com/robotlegs/robotlegs-framework/downloads. 
Just as with the RottenTomatoesAS3.swc that you pulled earlier for the Rotten Tomatoes 
services, you add the SWC file into your libs folder to include the Robotlegs library (see 
figure 6.10). 

170 
CHAPTER 6 MVC with mobile applications 
Figure 6.10 Including the Robotlegs framework 
With your library included, you now have access to all the base classes that you need to use 
the Robotlegs framework. 
When creating an application using Robotlegs, the first thing that I always do is create a 
new context to add in the mappings as they’re created and ready. Create the new context, 
RottenTomatoesContext.as: 
package com.unitedmindset{     
    import flash.display.DisplayObjectContainer; 
    import org.robotlegs.mvcs.Context; 
     
    public class RottenTomatoesContext extends Context{ 
         
        public function RottenTomatoesContext( 
                     contextView:DisplayObjectContainer=null, 
                     autoStartup:Boolean=true){ 
            super(contextView, autoStartup); 
        } 
         
        override public function startup():void{} 
         
        override public function shutdown():void{} 
    } 
} 
With your context created, your next step is to include the context into your application and 
officially kick off your Robotlegs-based application. 

MVC with mobile applications 
171 
6.2.2 
Connecting the context and starting up the application 
Back in your RottenTomatoesApplication.mxml file you’ll need to return to the declarations 
section and add in the Context class: 
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark" 
        preloader="spark.preloaders.SplashScreen" 
        splashScreenImage="@Embed('/assets/images/splashscreen.png')"  
        xmlns:unitedmindset="com.unitedmindset.*"> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    <unitedmindset:RottenTomatoesContext contextView="{this}"/> 
    </fx:Declarations> 
    <fx:Style source="/assets/css/main.css"/> 
    . . . 
With this single line of code you’ve included your context file into the application. Make sure 
to set the contextView property with a reference to the application to make the round-trip 
connection. With this simple step complete, you can start adding code into your context in 
your startup method. 
Continuing with the context file you’ll add the first event/command map to connect the 
startup command and create the startup command for your application. Before making the 
mapping you must create StartupCompleteCommand.as: 
package com.unitedmindset.controllers{ 
    import org.robotlegs.base.ContextEvent; 
    import org.robotlegs.mvcs.Command; 
     
    public class StartupCompleteCommand extends Command{ 
         
        public function StartupCompleteCommand(){ 
            super(); 
        } 
         
        [Inject] 
        public var event:ContextEvent; 
         
        override public function execute():void{} 
    } 
} 
Later on, you’ll return to StartupCompleteCommand.as to run specific startup 
functionality, but this is a fun way to run and test your application and make sure that the 
Robotlegs machine is working. 
To call the StartupCompleteCommand, you add the mapping and finally dispatch the 
startup complete event (see the following listing). 

172 
CHAPTER 6 MVC with mobile applications 
. . . 
//imports 
import org.robotlegs.base.ContextEvent; 
. . . 
override public function startup():void 
{ 
    commandMap.mapEvent( 
    ContextEvent.STARTUP_COMPLETE, 
     StartupCompleteCommand,  
    ContextEvent); 
    dispatchEvent(new ContextEvent(  
    ContextEvent.STARTUP_COMPLETE,     contextView)); 
} 
. . . 
Remember that the context is the central hub of any Robotlegs application. Be prepared to 
return to this file often to add in new segments of code as they’re completed. The big benefit 
to starting your application by creating the context is that your application is already able to 
run using the framework, although it doesn’t do much now. With your application running on 
the Robotlegs’ engine you’re ready to move forward and add in functionality. You’ll start by 
transferring over your services into a proper service layer. 
REFACTORING CURRENT CODE 
Your refactor will start from the code you’ve been developing over the last five chapters. 
If you’ve been skipping around, you can get the current code from the book’s download 
section. During this refactor you’ll also be remaking the application’s package structure to 
conform to the Robotlegs way. See figure 6.11. 

MVC with mobile applications 
173 
Figure 6.11 New package structure 
6.3 
Separating your services 
As you already know, your application’s structure is currently created so that all of the logic, 
services, and view layers are completely built into single classes. Because you’re trying to 
create an application that has a clear separation of duties, you need to split up these 
multifaceted classes. In this section you’ll start the separation process by pulling out the 
service layer from the views. After moving the service layer into its own class, you can add 
the service class into the context for your application to use (see figure 6.12). 

174 
CHAPTER 6 MVC with mobile applications 
Figure 6.12 The service refactor 
You need to start this process by creating a service shell to add in public and private 
methods: 
package com.unitedmindset.services{ 
    import org.robotlegs.mvcs.Actor; 
     
    public class RotTomService extends Actor{ 
        public function RotTomService(){ 
           super(); 
        } 
    } 
} 
In this section you’ll refactor your service into a singular class and create the connections 
needed into the engine of the application. When this is complete, the service layer will stand 
alone, because you’ll have successfully decoupled the service layer from the rest of the 
application and provided a clear separation of duties. 
6.3.1 
Creating your public methods 
With the shell created you need to move forward and start creating an interface to interact 
with 
the 
application. 
These 
functions 
will 
kick 
off 
a 
service 
call 
to 
the 
RottenTomatoesService you used earlier. In section 6.3.2 you’ll handle the result and 

MVC with mobile applications 
175 
fault events as they’re returned and alert the rest of the application that the service call is 
complete. 
Which came first, the implementation or the interface? 
I start creating my services by creating the implementation and then create the 
interface—later implementations will work off the interface. I do this because when the 
service is first created, there’s so much renaming and moving of terms that changing the 
interface and the implementation gets annoying. You could start by creating the interface 
and use the rename refactor to help. That decision is yours. 
As you know from your previous version of the application, it pulls a few different lists from 
the Rotten Tomatoes API. The 10 functions translate into the 10 functions you’ll have in your 
service layer. 
The interface to the service layer is shown in the following listing. 
Listing 6.2 IRotTomService.as 
package com.unitedmindset.services{ 
    public interface IRotTomService{ 
     
    function getMoviesByTerm(term:String, limit:int, page:int):void; 
    function getBoxOfficeMovies(limit:int, page:int):void; 
    function getCurrentReleaseDvd(limit:int, page:int):void; 
    function getInTheaterMovies(limit:int, page:int):void; 
    function getNewReleaseDvd(limit:int, page:int):void; 
    function getOpeningMovies(limit:int):void; 
    function getTopRentals(limit:int):void; 
    function getUpcomingDvd(limit:int, page:int):void; 
    function getUpcomingMovies(limit:int, page:int):void; 
    function getReviewsById(id:String, limit:int, page:int):void; 
    } 
} 
{chap 6 code}/src/com/unitedmindset/services/IRotTomService.as
With your interface complete, you need to implement the interface with the service layer. 
There’s one bit of functionality that you’ll need to handle before a service call is created; you 
need to create the service component needed to call the Rotten Tomatoes API, as shown in 
the following listing. 
Listing 6.3 RotTomService.as implementation 
package com.unitedmindset.services{     
    import com.rottentomatoes.RottenTomatoesService; 
    import com.rottentomatoes.events.RottenTomatoesFaultEvent; 
    import com.rottentomatoes.events.RottenTomatoesResultEvent; 
    import com.unitedmindset.events.ServiceResponseEvent; 

176 
CHAPTER 6 MVC with mobile applications 
    import org.robotlegs.mvcs.Actor; 
    
    public class RotTomService extends Actor  
        implements IRotTomService{                                        
        public function RotTomService(){ 
            super(); 
            _createService(); 
        } 
         
        private var _service:RottenTomatoesService;                       
         
public function getMoviesByTerm(term:String, limit:int, page:int):void{ 
            _service.getMoviesByTerm(term, limit, page); 
        } 
         
        public function getBoxOfficeMovies(limit:int, page:int):void{ 
            _service.getBoxOfficeMovies(limit, page); 
        } 
         
        public function getCurrentReleaseDvd(limit:int, page:int):void{ 
            _service.getCurrentReleaseDvd(limit, page); 
        } 
         
        public function getInTheaterMovies(limit:int, page:int):void{ 
            _service.getInTheaterMovies(limit, page); 
        } 
         
        public function getNewReleaseDvd(limit:int, page:int):void{ 
            _service.getNewReleaseDvd(limit, page); 
        } 
         
        public function getOpeningMovies(limit:int):void{ 
            _service.getOpeningMovies(limit); 
        } 
         
        public function getTopRentals(limit:int):void{ 
            _service.getTopRentals(limit); 
        } 
         
        public function getUpcomingDvd(limit:int, page:int):void{ 
            _service.getUpcomingDvd(limit, page); 
        } 
         
        public function getUpcomingMovies(limit:int, page:int):void{ 
            _service.getUpcomingMovies(limit, page); 
        } 
         
Implement interface 
Service component 

MVC with mobile applications 
177 
        public function getReviewsById(id:String, limit:int, 
          page:int):void{ 
            _service.getMovieReviewById(id, "all", limit, page); 
        } 
         
private function _createService():void{                                   
            _service = new RottenTomatoesService(); 
            _service.apikey = "yourAPIKey"; 
                 
            _service.addEventListener(                                   
                    RottenTomatoesResultEvent.RESULT,                     
            _onService_ResultHandler);                                   
                 
            _service.addEventListener(                                   
                    RottenTomatoesFaultEvent.FAULT,                      
           _onService_FaultHandler);                                    
        } 
    } 
} 
{chap 6 code}/src/com/unitedmindset/services/RotTomService.as
With the service component created and the interface implemented, you can move forward 
by adding in the result and fault events for your service layer. 
6.3.2 
Transferring your result and fault events 
To ensure that your service layer doesn’t know about the rest of the application, you need to 
send out your result and fault methods using events rather than directly accessing methods 
on your application. To handle this you’ll create a new event that’s domain specific to your 
application. This new event, ServiceResponseEvent, alerts the rest of your system that a 
response returned from the service layer and identifies what type it is (see the following 
listing). 
Listing 6.4 ServiceResponseEvent.as 
package com.unitedmindset.events{ 
    import flash.events.Event; 
     
    public class ServiceResponseEvent extends Event{ 
     
public static const BOX_OFFICE_RESULT:String =  
    "boxOfficeResult";                                                    
    public static const CURRENT_DVD_RESULT:String = "currentDvdResult";   
    public static const IN_THEATERS_RESULT:String = "inTheatersResult";   
    public static const NEW_DVD_RESULT:String = "newDvdResult";           
    public static const OPENING_NOW_RESULT:String = "openingNowResult";   
    public static const TOP_RENTALS_RESULT:String = "topRentalsResult";   
Create service component 
Listen to events 
from our service 
Service response type 

178 
CHAPTER 6 MVC with mobile applications 
    public static const UPCOMING_DVD_RESULT:String = "upcomingDvdResult"; 
    public static const UPCOMING_THEATER_RESULT:String =                  
        "upcomingTheaterResult";                                          
    public static const SEARCH_RESULT:String = "searchResult";            
    public static const REVIEWS_RESULT:String = "reviewsResult";          
         
        private var _payload:Object;                                      
        public function get payload():Object { return _payload; }         
         
        public function ServiceResponseEvent(type:String, 
                 payload:Object){ 
            super(type); 
            _payload = payload; 
        } 
         
        override public function clone():Event{ 
            return new ServiceResponseEvent(type, payload); 
        } 
    } 
} 
{chap 6 code}/src/com/unitedmindset/events/ServiceResponseEvent.as
With the event application notice system ready, you’ll need to add the result and fault 
handler methods into the service layer to react to the responses from the Rotten Tomatoes 
API (see the following listing). This segment of code may seem long; the entire concept here 
is that you get back a result or fault from the service, check the type of service that was 
called, and then dispatch the correct event based on the serviceType. 
Listing 6.5 RotTomService.as result/fault handlers 
. . . 
private function                                                          
_onService_ResultHandler(event:RottenTomatoesResultEvent):void{           
    switch(event.serviceType){                                            
        case RottenTomatoesService.MOVIE_SEARCH_TEMPLATE: 
        dispatch(new ServiceResponseEvent( 
                         ServiceResponseEvent.SEARCH_RESULT, event)); 
            break; 
        case RottenTomatoesService.BOX_OFFICE_TEMPLATE: 
        dispatch(new ServiceResponseEvent( 
                         ServiceResponseEvent.BOX_OFFICE_RESULT, event)); 
            break; 
        case RottenTomatoesService.CURRENT_RELEASE_DVDS_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.CURRENT_DVD_RESULT, event)); 
            break; 
        case RottenTomatoesService.IN_THEATERS_TEMPLATE: 
Service response 
type
Result 
handler (by 
type) 

MVC with mobile applications 
179 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.IN_THEATERS_RESULT, event)); 
            break; 
        case RottenTomatoesService.NEW_RELEASE_DVDS_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.NEW_DVD_RESULT, event)); 
            break; 
        case RottenTomatoesService.OPENING_MOVIES_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.OPENING_NOW_RESULT, event)); 
            break; 
        case RottenTomatoesService.TOP_RENTALS_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.TOP_RENTALS_RESULT, event)); 
            break; 
        case RottenTomatoesService.UPCOMING_DVDS_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.UPCOMING_DVD_RESULT, event)); 
            break; 
        case RottenTomatoesService.UPCOMING_MOVIES_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.UPCOMING_THEATER_RESULT, event)); 
            break; 
        case RottenTomatoesService.MOVIE_REVIEWS_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.REVIEWS_RESULT, event)); 
            break; 
    } 
} 
private function                                                      
_onService_FaultHandler(event:RottenTomatoesFaultEvent):void{        
    switch(event.serviceType){                                        
        case RottenTomatoesService.MOVIE_SEARCH_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.SEARCH_RESULT, event)); 
            break; 
        case RottenTomatoesService.BOX_OFFICE_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.BOX_OFFICE_RESULT, event)); 
            break; 
        case RottenTomatoesService.CURRENT_RELEASE_DVDS_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.CURRENT_DVD_RESULT, event)); 
            break; 
        case RottenTomatoesService.IN_THEATERS_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
Fault handler 
(by type)

180 
CHAPTER 6 MVC with mobile applications 
        ServiceResponseEvent.IN_THEATERS_RESULT, event)); 
            break; 
        case RottenTomatoesService.NEW_RELEASE_DVDS_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.NEW_DVD_RESULT, event)); 
            break; 
        case RottenTomatoesService.OPENING_MOVIES_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.OPENING_NOW_RESULT, event)); 
            break; 
        case RottenTomatoesService.TOP_RENTALS_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.TOP_RENTALS_RESULT, event)); 
            break; 
        case RottenTomatoesService.UPCOMING_DVDS_TEMPLATE: 
        dispatch(new ServiceResponseEvent( 
        ServiceResponseEvent.UPCOMING_DVD_RESULT, event)); 
            break; 
        case RottenTomatoesService.UPCOMING_MOVIES_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.UPCOMING_THEATER_RESULT, event)); 
            break; 
        case RottenTomatoesService.MOVIE_REVIEWS_TEMPLATE: 
        dispatch(new ServiceResponseEvent(  
        ServiceResponseEvent.REVIEWS_RESULT, event)); 
            break; 
    } 
} 
. . . 
{chap 6 code}/src/com/unitedmindset/services/RotTomService.as 
With your service class complete, you need to need add the service into the context:  
. . . 
//imports 
import com.unitedmindset.services.IRotTomService; 
import com.unitedmindset.services.RotTomService; 
. . . 
override public function startup():void 
{ 
    . . . 
    //services 
    injector.mapSingletonOf(IRotTomService, RotTomService); 
    . . . 
} 
You now have a completely ready service layer to communicate with Rotten Tomatoes using 
the RottenTomatoesAS3 API. The only issue is that right now this service layer can’t 

MVC with mobile applications 
181 
communicate with the rest of the application. Next, you need to wire up the commands to 
request your data and respond to your service results. 
6.3.3 
Mapping your service events to service commands 
You’ve now created a completely standalone service layer for your application. This is 
important because you’re trying to create a well-structured MVC(S)–based application (see 
figure 6.13). 
Figure 6.13 You are here 
With your service layer ready, you need to set up the communication between the 
application and the service layer you just created. This starts with creating commands to 
interact with the service layer and ends with mapping the commands to a new event created 
to request data from the service layer (see figure 6.14). 
Figure 6.14 Requesting data from the service layer 
The new event you’re creating is the RequestDataEvent. As denoted by the name, this 
event requests data from the service layer, as shown in the following listing. 

182 
CHAPTER 6 MVC with mobile applications 
Listing 6.6 RequestDataEvent.as 
package com.unitedmindset.events{ 
    import flash.events.Event; 
     
    public class RequestDataEvent extends Event{ 
public static const BOX_OFFICE_LIST:String = "boxOfficeList";             
public static const CURRENT_DVD_LIST:String = "currentDvdList";           
public static const IN_THEATERS_LIST:String = "inTheatersList";           
public static const NEW_DVD_LIST:String = "newDvdList";                   
public static const OPENING_NOW_LIST:String = "openingNowList";           
public static const TOP_RENTALS_LIST:String = "topRentalsList";           
public static const UPCOMING_DVD_LIST:String = "upcomingDvdList";         
public static const UPCOMING_THEATER_LIST:String = "upcomingTheaterList"; 
public static const SEARCH_LIST:String = "searchList";                    
public static const REVIEWS_LIST:String = "reviewsList";                  
         
    private var _page:int;                                                
    public function get page():int { return _page; }                      
         
    private var _numOfResults:int;                                        
    public function get numOfResults():int { return _numOfResults; }      
         
    private var _term:String;                                             
    public function get term():String { return _term; }                   
         
    public function RequestDataEvent(type:String, page:int,  
    numOfResults:int, term:String=null){ 
        super(type); 
        _page = page; 
        _numOfResults = numOfResults; 
        _term = term; 
    } 
         
    override public function clone():Event{ 
        return new RequestDataEvent(type, page, numOfResults, term); 
    } 
    } 
} 
{chap 6 code}/src/com/unitedmindset/events/RequestDataEvent.as
With your event ready, you need to create the commands that will connect to the service 
layer and execute its methods. 
Constants 
Page result 
to request
Number of 
results to pull 
Extra term for 
search 
functionality 

MVC with mobile applications 
183 
HURRY UP ALREADY! 
In this section I’ll abbreviate some of the code shown, because it gets repetitive. Rather 
than showing commands for the box office in theater, top rentals, and the seven other 
features you’ll support, I’ll show just the search feature.  
First, you’ll call the command to request movies from the Rotten Tomatoes API search, as 
shown in the following listing. 
Listing 6.7 GetSearchCommand.as 
package com.unitedmindset.controllers.search{ 
    import com.unitedmindset.events.RequestDataEvent; 
    import com.unitedmindset.services.IRotTomService; 
    import org.robotlegs.mvcs.Command; 
     
    public class GetSearchCommand extends Command{ 
        public function GetSearchCommand(){ 
            super(); 
        } 
         
        [Inject] 
        public var event:RequestDataEvent;                                
         
        [Inject] 
        public var service:IRotTomService;                                
         
        override public function execute():void{ 
            service.getMoviesByTerm( event.term, event.numOfResults,  
            event.page);                                                  
        } 
    } 
} 
{chap 6 code}/src/com/unitedmindset/controllers/search/GetSearchCommand.as
This first command may seem extremely simple, but that’s what a command is: simple, 
straightforward, and effective. The command is created by the Robotlegs context when your 
RequestDataEvent is dispatched from anywhere in the application. The command receives 
the initiating event and uses the event’s properties to make the service call.  
With the request command complete, you can move on to the return command, which is 
used when the service is complete (see the following listing). 
Listing 6.8 GetSearchResultCommand.as 
package com.unitedmindset.controllers.search{ 
    import com.rottentomatoes.events.RottenTomatoesFaultEvent; 
    import com.rottentomatoes.events.RottenTomatoesResultEvent; 
Injected initiator event 
Injected service 
Executing the service 

184 
CHAPTER 6 MVC with mobile applications 
    import com.unitedmindset.events.ServiceResponseEvent; 
    import com.unitedmindset.models.SearchModel; 
    import org.robotlegs.mvcs.Command; 
     
    public class GetSearchResultCommand extends Command{ 
        public function GetSearchResultCommand(){ 
            super(); 
        } 
         
        [Inject] 
        public var event:ServiceResponseEvent;                            
         
        [Inject] 
        public var model:SearchModel;                                     
         
        override public function execute():void{ 
            if(event.payload is RottenTomatoesResultEvent){               
                var e:RottenTomatoesResultEvent = event.payload  
                as RottenTomatoesResultEvent; 
                model.setList( e.result as Array, e.total ) 
            } else if(event.payload is  
                RottenTomatoesFaultEvent){                                
                    var f:RottenTomatoesFaultEvent = event.payload as  
                    RottenTomatoesFaultEvent; 
                model.getFailed(f.fault); 
            } 
        } 
    } 
} 
{chap 6 code}/src/com/unitedmindset/controllers/search/GetSearchResultCommand.as
This command handles a little more logic than the GetSearchCommand but is still simple to 
use. The GetSearchResultCommand checks to see if the payload is a success, and if it is, 
it then sets the model with returned data. If the payload is a failure, then you need to let the 
model know that the service failed.  
To complete the process you need to add the mappings in the context to route the proper 
events to the correct commands (see the following listing). 
Listing 6.9 Request and response mappings 
//imports 
import com.unitedmindset.controllers.StartupCompleteCommand; 
import com.unitedmindset.controllers.boxoffice.*; 
import com.unitedmindset.controllers.currentdvd.*; 
import com.unitedmindset.controllers.intheaters.*; 
import com.unitedmindset.controllers.newdvd.*; 
import com.unitedmindset.controllers.openingnow.*; 
Injected service response 
event
Injected model to give data to 
If successful, 
set data
If failed, alert model 

MVC with mobile applications 
185 
import com.unitedmindset.controllers.reviews.*; 
import com.unitedmindset.controllers.search.*; 
import com.unitedmindset.controllers.toprentals.*; 
import com.unitedmindset.controllers.upcomingdvd.*; 
import com.unitedmindset.controllers.upcomingtheaters.*; 
import com.unitedmindset.events.*; 
//service calls                                                           
commandMap.mapEvent(RequestDataEvent.BOX_OFFICE_LIST, GetBoxOfficeCommand,  
RequestDataEvent); 
commandMap.mapEvent(RequestDataEvent.CURRENT_DVD_LIST,  
GetCurrentDvdCommand, RequestDataEvent); 
commandMap.mapEvent(RequestDataEvent.IN_THEATERS_LIST,  
GetInTheatersCommand, RequestDataEvent); 
commandMap.mapEvent(RequestDataEvent.NEW_DVD_LIST, GetNewDvdCommand,  
RequestDataEvent); 
commandMap.mapEvent(RequestDataEvent.OPENING_NOW_LIST,  
GetOpeningNowCommand, RequestDataEvent); 
commandMap.mapEvent(RequestDataEvent.SEARCH_LIST, GetSearchCommand,  
RequestDataEvent); 
commandMap.mapEvent(RequestDataEvent.TOP_RENTALS_LIST,  
GetTopRentalsCommand, RequestDataEvent); 
commandMap.mapEvent(RequestDataEvent.UPCOMING_DVD_LIST,  
GetUpcomingDvdCommand, RequestDataEvent); 
commandMap.mapEvent(RequestDataEvent.UPCOMING_THEATER_LIST,  
GetUpcomingTheatersCommand, RequestDataEvent); 
commandMap.mapEvent(RequestDataEvent.REVIEWS_LIST, GetReviewsCommand,  
RequestDataEvent); 
//service responses                                                      
commandMap.mapEvent(ServiceResponseEvent.BOX_OFFICE_RESULT,  
GetBoxOfficeResultCommand, ServiceResponseEvent); 
commandMap.mapEvent(ServiceResponseEvent.CURRENT_DVD_RESULT,  
GetCurrentDvdResultCommand, ServiceResponseEvent); 
commandMap.mapEvent(ServiceResponseEvent.IN_THEATERS_RESULT,  
GetInTheaterResultCommand, ServiceResponseEvent); 
commandMap.mapEvent(ServiceResponseEvent.NEW_DVD_RESULT,  
GetNewDvdResultCommand, ServiceResponseEvent); 
commandMap.mapEvent(ServiceResponseEvent.OPENING_NOW_RESULT,  
GetOpeningNowResultCommand, ServiceResponseEvent); 
commandMap.mapEvent(ServiceResponseEvent.SEARCH_RESULT,  
GetSearchResultCommand, ServiceResponseEvent); 
commandMap.mapEvent(ServiceResponseEvent.TOP_RENTALS_RESULT,  
GetTopRentalsResultCommand, ServiceResponseEvent); 
commandMap.mapEvent(ServiceResponseEvent.UPCOMING_DVD_RESULT,  
GetUpcomingDvdResultCommand, ServiceResponseEvent); 
commandMap.mapEvent(ServiceResponseEvent.UPCOMING_THEATER_RESULT,  
GetUpcomingTheatersResultCommand, ServiceResponseEvent); 
Service request commands 
Service response commands 

186 
CHAPTER 6 MVC with mobile applications 
commandMap.mapEvent(ServiceResponseEvent.REVIEWS_RESULT,  
GetReviewsResultCommand, ServiceResponseEvent); 
{chap 6 code}/src/com/unitedmindset/RottenTomatoesContext.as 
With these maps created you‘ve completed the entire round-trip and pulled your data from 
Rotten Tomatoes. But where does the data go? Currently you’re missing the models to hold 
the data returned from your service layer. In the next section you’ll create the models to 
hold the data. 
6.4 
Refactoring your data into models 
Currently your application includes a formal service layer and the communication necessary 
between the service layer and the rest of the application (see figure 6.15). Continuing to 
separate the various duties of the application, you’ll need to create a model layer, separating 
your application’s data from the rest of the components. 
Figure 6.15 You are here 
Your models will create an interface to your data (see figure 6.16). Using specific inputs 
you’ll be able to control the flow of data through the models. Furthermore, as the models are 
updated, they’ll alert the rest of the application, using events, as any changes occur, and 
facilitating the control and flow of data from central points within the application.  

MVC with mobile applications 
187 
Figure 6.16 Creating the M in MVC 
As with the commands used in the previous section, you won’t be creating every model 
required for your application, just one as an example of the required data models. In this 
case you’ll be creating the SearchModel because it’s the most complicated model due to 
the fact that it uses an additional method to add the search term to the model. In the next 
section we’ll look at the SearchModel and the slight changes necessary for each of the 
other eight models. 
For each of your main models you’ll base your models on your own IListModel
interface (see the following listing). 
Listing 6.10 IListModel.as 
package com.unitedmindset.models{ 
    import com.rottentomatoes.vos.ServiceFault; 
    import mx.collections.ArrayList; 
    public interface IListModel{ 
        function get loading():Boolean; 
        function get list():ArrayList; 
        function get total():int; 
        function get numOfResults():int; 
        function get currentPage():int; 
        function listNeedsRefresh():Boolean; 
        function getList(page:int=1):void; 
        function setList(value:Array, total:int):void; 
        function getFailed(fault:ServiceFault):void; 
        function isNextPage():Boolean; 
        function isPrevPage():Boolean; 
        function getNextPage():void; 
        function getPrevPage():void; 
    } 

188 
CHAPTER 6 MVC with mobile applications 
} 
{chap 6 code}/src/com/unitedmindset/models/IListModel.as
In the next section you’ll create your models, determine your inner application API, and 
finally create a model update event to alert the rest of the application when the model 
changes. When this section is complete, you’ll have created your model layer and included it 
in your application’s context. 
6.4.1 
Creating your model shell 
As you can probably tell from the IListModel interface shown previously, you’re going to 
extend the functionality of your application to include the ability to page through the 
returned data. You could have created one giant model to include each of the lists of movies, 
but I believe that creating smaller simpler classes is the way to go for upkeep, extensibility, 
and readability. In the following listing you can see the shell of the SearchModel, and in the 
next few paragraphs you’ll fill in the contents of your model. 
Listing 6.11 SearchModel.as shell 
package com.unitedmindset.models{ 
    import com.adobe.utils.StringUtil; 
    import com.rottentomatoes.vos.ServiceFault; 
    import com.unitedmindset.events.ModelUpdateEvent; 
    import com.unitedmindset.events.RequestDataEvent; 
    import mx.collections.ArrayList; 
    import org.robotlegs.mvcs.Actor; 
    import spark.managers.IPersistenceManager; 
    import spark.managers.PersistenceManager; 
         
    public class SearchModel extends Actor implements IListModel{ 
        public function SearchModel(){ 
            super(); 
        } 
         
        private static const TERM:String = "searchTerm";                  
        private static const LIST:String = "searchList";                  
        private static const TIMESTAMP:String = "searchTimestamp";        
        private static const CURRENT_PAGE:String = "searchCurrentPage"; 
        private static const TOTAL:String = "searchTotal";                
         
private var _persistenceManager:IPersistenceManager;                      
        private var _timestamp:Date;                                      
         
private var _loading:Boolean;                                             
        public function get loading():Boolean { return _loading; }        
         
        private var _list:ArrayList;                                      
Constants 
Private 
properties
Public protected 
properties 

MVC with mobile applications 
189 
        public function get list():ArrayList { return _list; }            
         
        private var _total:int;                                           
        public function get total():int { return _total; }                
         
        private var _numOfResults:int = 16;                               
        public function get numOfResults():int {return _numOfResults;} 
         
        private var _currentPage:int;                                     
        public function get currentPage():int { return _currentPage; } 
         
        private var _term:String;                                         
        public function get term():String { return _term; }               
        
        public function listNeedsRefresh():Boolean {return false;}        
        public function setTerm(value:String):void {}                     
        public function getList(page:int=1):void { }                      
        public function setList(value:Array, total:int):void { }          
        public function getFailed(fault:ServiceFault):void { }            
        public function isNextPage():Boolean { return false; }            
        public function isPrevPage():Boolean { return false; }            
        public function getNextPage():void { }                            
        public function getPrevPage():void {    }                         
private function _getPersistedData():void { }                             
        private function _persistData():void { }                          
    } 
} 
{chap 6 code}/src/com/unitedmindset/models/SearchModel.as
With your interface implemented and the model written out, you need to write out the 
implementations for each of the methods, and the model will be ready for use. 
For MVC purists 
MVC purists are probably sweating a little bit seeing the _getPersistedData() and 
_persistData() methods in this model. Technically it could be argued that these 
methods should be pulling data from a service layer and not directly from within the 
model. Ultimately, I agree that this is the right way to do it. But I’m a bit lazy, and it feels 
OK to me to handle the model this way without having to create another public method in 
the model. 
Because these functions still feel like part of the data model, I’m OK with simplifying a 
little and including them directly in the model. If you wish to be absolutely pure about it, 
feel free to create another service to the persistence layer and pull the data. 
Public protected 
properties 
Public protected 
properties 
Public protected 
properties 
Public protected 
properties 
Public methods 
Private methods 

190 
CHAPTER 6 MVC with mobile applications 
The first methods you’re going to take care of are the persistence methods. These methods 
will set and get data from the persistence layer when the model changes or is initiated, 
respectively. For the _getPersistedData() method you need to pull data from the 
persistence layer by name after initializing the _persistenceManager: 
private function _getPersistedData():void{ 
    _persistenceManager = new PersistenceManager(); 
    _persistenceManager.load(); 
    _list = _persistenceManager.getProperty(LIST) as ArrayList; 
    _timestamp = _persistenceManager.getProperty(TIMESTAMP) as Date; 
    _currentPage = _persistenceManager.getProperty(CURRENT_PAGE) as int; 
    _total = _persistenceManager.getProperty(TOTAL) as int; 
} 
USE CONSTANTS WHEN POSSIBLE INSTEAD OF STRINGS 
You’ll notice that you’re using constants instead of direct strings for the getProperty
name parameter; this is useful for two reasons. The first reason is this protects against 
misspelling a variable and creating a bug that will need to be fixed later. The second 
reason is even though the constant says LIST, the actual value can be searchList. 
Because you’ll have multiple lists, one in each model, by using the search prefix you 
can ensure that the list returned is unique to this specific model. If you were to reuse the 
value “list”, then any other list saved—also with the value “list”—to the 
PersistenceManager would override your list. This little change can prevent big 
disasters. 
With the _getPersistedData() method ready, you can include it in your constructor. Now 
whenever the SearchModel is initialized, any persisted data will be reset to your model with 
the values currently stored in the persistence layer of your application: 
public function SearchModel(){ 
    super(); 
    _getPersistedData(); 
} 
Moving on to setting the persisted model, you need to flush out the _persistData()
method. You’ll call this method whenever a value changes in your model and set all of the 
current values to the persistence layer: 
private function _persistData():void{ 
    _persistenceManager.setProperty(LIST, list); 
    _persistenceManager.setProperty(TIMESTAMP, _timestamp); 
    _persistenceManager.setProperty(CURRENT_PAGE, currentPage); 
    _persistenceManager.setProperty(TOTAL, total); 
    _persistenceManager.setProperty(TERM, term); 
    _persistenceManager.save(); 

MVC with mobile applications 
191 
} 
This completes the code necessary to cache your model’s data for future use. Next, you’ll 
flesh out the listNeedsRefresh() method. This method is meant to let you know if the 
model’s list needs to be refreshed or is still relevant. You’ll do this by making sure a list 
exists and checking to see if its last timestamp is within one hour: 
public function listNeedsRefresh():Boolean{ 
    return !list || !_timestamp || _timestamp.time < new Date().time -  
    3600000 /* one hour */;
} 
I thought about including this check in the getList() method, but by doing so you’ll be 
losing the ability to easily refresh the list if you wanted to give the user that ability. 
Going 
off 
track 
a 
bit 
for 
methods 
unique 
to 
the SearchModel 
and 
the 
SelectedMovieModel, you need to make public methods to set the search term and 
selected movies, respectively.  
PROTECT YOUR PROPERTIES 
You could have created these model properties as completely public, but this could be bad 
because the model wouldn’t be alerted if one of its properties changed. Instead, I prefer 
to only allow the get function to be public and have the property set through a method. 
These methods can be used to ensure the property is clean or to just alert the model that 
the property changed and persist the changed property. The decision is yours, but I’d 
consider this a best-practice move. 
You set the search term in the SearchModel and persist the term when it’s set, as well as 
clean the search term of any beginning or trailing empty, spaces using the 
StringUtil.trim() method that you used back in chapter 2: 
public function setTerm(value:String):void{ 
    _term = StringUtil.trim(value); 
    _persistData(); 
} 
And in the SelectedModelModel you set the selected movie SelectedMovieModel and 
persist the value when set. This will alert you that your SelectedMovieModel was selected 
and that some other methods may need to be called: 
import com.rottentomatoes.vos.MovieVO; 
private var _movie:MovieVO; 
public function get movie():MovieVO { return _movie; } 
public function setSelectedMovie(movie:MovieVO):void{ 
    _movie = movie; 

192 
CHAPTER 6 MVC with mobile applications 
    _persistData(); 
} 
After setting any additional variables that will be necessary for pulling data for the service 
layer, you need to initiate the getList() method. This method requires a new event type 
that you’ll use for your models. This event, called the ModelUpdateEvent, will be used to 
alert the rest of your application anytime a value updates in one of your models. By firing 
this event, your mediators, and the rest of the application, can easily react to changes from 
your models (see the following listing).  
Listing 6.12 ModelUpdateEvent.as 
package com.unitedmindset.events{ 
    import flash.events.Event; 
     
    public class ModelUpdateEvent extends Event{ 
         
        public static const BOX_OFFICE_LOADING_CHANGED:String =  
        "boxOfficeLoadingChanged"; 
        public static const BOX_OFFICE_LIST_CHANGED:String =  
        "boxOfficeListChanged"; 
        public static const BOX_OFFICE_FAULT:String = "boxOfficeFault"; 
        public static const CURRENT_DVD_LOADING_CHANGED:String =  
        "currentDvdLoadingChanged"; 
        public static const CURRENT_DVD_LIST_CHANGED:String =  
        "currentDvdListChanged"; 
        public static const CURRENT_DVD_FAULT:String =  
        "currentDvdFault"; 
        public static const IN_THEATER_LOADING_CHANGED:String =  
        "inTheaterLoadingChanged"; 
        public static const IN_THEATER_LIST_CHANGED:String = 
             "inTheaterListChanged"; 
        public static const IN_THEATER_FAULT:String = "inTheaterFault"; 
        public static const NEW_DVD_LOADING_CHANGED:String = 
             "newDvdLoadingChanged"; 
        public static const NEW_DVD_LIST_CHANGED:String = 
                 "newDvdListChanged"; 
        public static const NEW_DVD_FAULT:String = "newDvdFault";     
        public static const OPENING_NOW_LOADING_CHANGED:String = 
             "openingNowLoadingChanged"; 
        public static const OPENING_NOW_LIST_CHANGED:String = 
             "openingNowListChanged"; 
        public static const OPENING_NOW_FAULT:String = 
                 "openingNowFault"; 
        public static const TOP_RENTALS_LOADING_CHANGED:String = 
             "topRentalsLoadingChanged"; 
        public static const TOP_RENTALS_LIST_CHANGED:String = 

MVC with mobile applications 
193 
             "topRentalsListChanged"; 
        public static const TOP_RENTALS_FAULT:String = 
                 "topRentalsFault"; 
        public static const UPCOMING_DVD_LOADING_CHANGED:String = 
             "upcomingDvdLoadingChanged"; 
        public static const UPCOMING_DVD_LIST_CHANGED:String = 
             "upcomingDvdListChanged"; 
        public static const UPCOMING_DVD_FAULT:String = 
                 "upcomingDvdFault";     
        public static const UPCOMING_THEATER_LOADING_CHANGED:String = 
         "upcomingTheaterLoadingChanged"; 
        public static const UPCOMING_THEATER_LIST_CHANGED:String = 
             "upcomingTheaterListChanged"; 
        public static const UPCOMING_THEATER_FAULT:String = 
                 "upcomingTheaterFault"; 
        public static const SEARCH_LOADING_CHANGED:String = 
                 "searchLoadingChanged"; 
        public static const SEARCH_LIST_CHANGED:String = 
                 "searchListChanged"; 
        public static const SEARCH_FAULT:String = "searchFault"; 
        public static const REVIEWS_LOADING_CHANGED:String = 
             "reviewsLoadingChanged"; 
        public static const REVIEWS_LIST_CHANGED:String = 
                 "reviewsListChanged"; 
        public static const REVIEWS_FAULT:String = "reviewsFault"; 
         
        private var _value:Object;                                        
        public function get value():Object { return _value; }             
         
        public function ModelUpdateEvent(type:String, value:Object){ 
            super(type); 
            _value = value; 
        } 
         
        override public function clone():Event{ 
            return new ModelUpdateEvent(type, value); 
        } 
    } 
} 
{chap 6 code}/src/com/unitedmindset/events/ModelUpdateEvent.as
With your event created you can start using it to send out notifications when the model 
changes. In your application you’ll alert your mediators if the model’s list changes, if the 
model throws a fault, or if the model’s loading property changes. By knowing when the 
model is loading, you can give the user feedback that the model is in the loading state. 
Updated value 

194 
CHAPTER 6 MVC with mobile applications 
The first model update is fired when the model goes into loading mode to pull a specific 
page of movies: 
public function getList(page:int=1):void{ 
    _loading = true; 
    dispatch(new ModelUpdateEvent(ModelUpdateEvent.SEARCH_LOADING_CHANGED, 
     _loading)); 
     
    _currentPage = page; 
    dispatch(new RequestDataEvent(RequestDataEvent.SEARCH_LIST, 
     currentPage, numOfResults, term));
} 
In the getList() method you set the current page and use the RequestDataEvent that 
you created earlier to pull data from the service layer. When the result is returned from the 
service layer, you know that the model is set with the resulting data (see figure 6.17). 
Figure 6.17 Setting the model from the service layer 
The result command calls the setList() method on the model, alerting the model that its 
data was updated. When the data is set to the model, you alert the application that the 
loading state of the model is updated, set the necessary values, persist the values for later 
use, and finally alert the rest of the application that the specific list updated: 
public function setList(value:Array, total:int):void{ 
    _loading = false; 
    dispatch(new ModelUpdateEvent(ModelUpdateEvent.SEARCH_LOADING_CHANGED, 
     _loading)); 
     
    _total = total; 
    _list = new ArrayList(value); 
    _timestamp = new Date(); 
    _persistData(); 
     
    dispatch(new ModelUpdateEvent(ModelUpdateEvent.SEARCH_LIST_CHANGED, 
     list));
} 
But what if the service layer returns a fault? So that your model doesn’t stay stuck in loading 
mode, you alert the model that a fault occurred and then alert the rest of the application: 

MVC with mobile applications 
195 
public function getFailed(fault:ServiceFault):void{ 
    _loading = false; 
    dispatch(new ModelUpdateEvent(ModelUpdateEvent.SEARCH_LOADING_CHANGED, 
     _loading)); 
     
    dispatch(new ModelUpdateEvent(ModelUpdateEvent.SEARCH_FAULT, fault)); 
} 
Adding a new paging feature to your application, you’ll also need to provide methods to let 
the user know if there are other pages available to the model and then give access to these 
other pages. Your first two methods will let the rest of the application know if there’s a 
previous- or next-page option. Whenever the model list is updated, you can use the 
functions to find out if the next or previous pages exist: 
public function isNextPage():Boolean{ 
    return currentPage*numOfResults < total; 
} 
public function isPrevPage():Boolean{ 
    return currentPage>1; 
} 
When the user chooses to view the next or previous page, you need to call those methods on 
the model and your get/set functionality will be initiated. Here you add a check to ensure 
that the previous or next page exists prior to calling for the corresponding page: 
public function getNextPage():void{ 
    if(!isNextPage()) return; 
    getList( currentPage+1 ); 
} 
public function getPrevPage():void{ 
    if(!isPrevPage()) return; 
    getList( currentPage-1 ); 
} 
With these methods complete, your model is ready to go. If you’d like to continue building 
out these models, you could always create a property to return the maximum pages 
available or create a method to change the number of results that your model will return. 
In the next section you’ll add your newly created models right into the context for 
availability in your Robotlegs-based application. 
6.4.2 
Including the models in your context 
With your models created following the IListModel interface, you can add them into your 
application’s context. This will enable the ability to inject—using dependency injection to 
access a reference to the requested class—your models into other sections of your 
application, specifically your mediators and commands. 

196 
CHAPTER 6 MVC with mobile applications 
Within the RottenTomatoesContext.as startup method, you need to add each model 
into the injector: 
//imports 
import com.unitedmindset.models.*; 
//models 
injector.mapSingleton(BoxOfficeModel); 
injector.mapSingleton(CurrentDvdModel); 
injector.mapSingleton(InTheatersModel); 
injector.mapSingleton(NewDvdModel); 
injector.mapSingleton(OpeningNowModel); 
injector.mapSingleton(SearchModel); 
injector.mapSingleton(TopRentalsModel); 
injector.mapSingleton(UpcomingDvdModel); 
injector.mapSingleton(UpcomingTheatersModel); 
injector.mapSingleton(SelectedMovieModel); 
Now within mediators, services, and commands, you can inject your models as necessary 
using the Inject metadata tag: 
[Inject] 
public var model:BoxOfficeModel; 
In the next section you’ll add one more custom model to your application. Although the other 
models you’ve created represent different lists of data, this new model is meant to represent 
the state of the application. 
6.4.3 
Creating your state model 
With your lists of data modeled into appropriate models, there’s still one aspect of your 
application that needs to be modeled into the data layer; this is the application state. It’s 
important to store the application state here for the exact reasons that we discussed in 
chapter 2. By saving the application state, such as entered text and list position, you can 
recall the state of a view after it’s been created and destroyed through normal navigation. In 
additional to specific views, you can call the state of the application if the application is 
closed, such as returning to the last view the user was interacting with. After creating the 
ApplicationStateModel, you’ll use it for three features: 
 
Providing a convenient and consistent way to move between views within your 
application 
 
Creating a simple way to save the application state 
 
Centralizing the view state management code 
You can build many features into your application state model, but for this application you’ll 
create the ability to push and pop views in your application.  

MVC with mobile applications 
197 
APPLICATION STATE IN A MODEL? 
Again for the MVC purists, having the application state in a model may feel dirty, but I’d 
argue that the state of an application is another form of data that can be stored and 
recalled. As always, create what feels most comfortable for you, your team, and your 
application. 
If your application was more complicated, you could add many various toggle switches for 
online/offline modes and anything else necessary to store, but your application will be set 
with the two methods moveToView() and moveBackView() (see the following listing). 
Listing 6.13 ApplicationStateModel.as 
package com.unitedmindset.models{ 
    import com.unitedmindset.events.MoveToViewEvent; 
    import org.robotlegs.mvcs.Actor; 
    import spark.managers.IPersistenceManager; 
    import spark.managers.PersistenceManager; 
     
    public class ApplicationStateModel extends Actor{ 
        public function ApplicationStateModel(){ 
            super(); 
            _getPersistedData(); 
        } 
         
        private var _persistenceManager:IPersistenceManager; 
         
            private var _currentView:String;                              
            public function currentView():String { return _currentView; }; 
            public function moveToView(view:String, data:Object=null, 
     relatedObject:Object=null):void{}                                    
        
        public function moveBackView():void{}                             
        private function _getPersistedData():void{ 
            _persistenceManager = new PersistenceManager(); 
            // load properties 
            _persistenceManager.load(); 
        } 
         
        private function _persistData():void{ 
            // save properties 
            _persistenceManager.save(); 
        } 
Current view 
Move to a view 
Move back a view 

198 
CHAPTER 6 MVC with mobile applications 
    } 
} 
{chap 6 code}/src/com/unitedmindset/models/ApplicationStateModel.as
The ApplicationStateModel currently can save and retrieve the state of an application 
and controls the movement of your user through an application. When a user needs to move 
to a view, you use the moveToView() method. This method will pass the view that you’re 
moving to, any data that you need to pass through, and finally any related objects that you 
may want to also pass. All this function needs to do is dispatch the event to alert the 
application of the state change: 
public function moveToView(view:String, data:Object=null,  
    relatedObject:Object=null):void{ 
    dispatch(new MoveToViewEvent(MoveToViewEvent.PUSH_VIEW, view, data, 
     relatedObject)); 
    _currentView = view; 
} 
The second method will alert your application to move back to the previous view, again using 
an event: 
public function moveBackView():void{ 
    dispatch(new MoveToViewEvent(MoveToViewEvent.POP_VIEW, null)); 
} 
These are the only two functions necessary to control the state of this application. Make sure 
to also include the ApplicationStateModel in your application’s context: 
//imports 
import com.unitedmindset.models.ApplicationStateModel; 
//models 
injector.mapSingleton(ApplicationStateModel); 
The MoveToViewEvent passes the values as necessary to other parts of your application, as 
shown in the following listing. 
Listing 6.14 MoveToViewEvent.as 
package com.unitedmindset.events{ 
    import flash.events.Event; 
     
    public class MoveToViewEvent extends Event{ 
        public static const PUSH_VIEW:String = "pushView"; 
        public static const POP_VIEW:String = "popView"; 
         
        private var _view:String; 
        public function get view():String { return _view; } 
         
        private var _data:Object; 

MVC with mobile applications 
199 
        public function get data():Object { return _data; } 
         
        private var _relatedObject:Object; 
        public function get relatedObject():Object { return 
                 _relatedObject; } 
         
        public function MoveToViewEvent(type:String, view:String=null, 
         data:Object=null, relatedObject:Object = null){ 
            super(type); 
            _view = view; 
            _data = data; 
            _relatedObject = relatedObject; 
        } 
         
        override public function clone():Event{ 
            return new MoveToViewEvent(type, view, data,  
            relatedObject); 
        } 
    } 
} 
{chap 6 code}/src/com/unitedmindset/events/MoveToViewEvent.as
There are two best practices built into this methodology that I’d like to point out: decoupling 
code and centralizing your event dispatching. 
DECOUPLING VIEW STATE 
You’ll notice in the moveToView() method that you use a string value for the view and not 
the view class that would be required by the ViewNavigator. The main reason to send the 
string representation and not the actual class is that when you break the application into 
multiple applications, you may need to have a variety of view classes that aren’t remotely 
similar between the various devices. In a later section we’ll cover mediators, where you’ll 
add the logic to push the view class to the ViewNavigator from the string representation. 
If the idea of having different views between devices doesn’t make sense, put a pin in 
that thought. In the next chapter when you blow apart your application, you’ll see how to 
customize the view layer to each of the three main mobile platforms. 
In your application you’ll use the ViewNameUtil, managing these view strings in one 
class, as shown in the next listing. 
Listing 6.15 ViewNameUtil.as 
package com.unitedmindset.utils{ 
    public class ViewNameUtil{ 
         
    public static const BOX_OFFICE_VIEW:String = "Box Office"; 
    public static const CURRENT_DVD_VIEW:String = "Currently In Dvd"; 
    public static const IN_THEATERS_VIEW:String = "In Theaters"; 

200 
CHAPTER 6 MVC with mobile applications 
    public static const NEW_DVD_VIEW:String = "New To DVD"; 
    public static const OPENING_NOW_VIEW:String = "Opening Now"; 
    public static const TOP_RENTALS_VIEW:String = "Top Rentals"; 
    public static const UPCOMING_DVD_VIEW:String = "Coming Soon to DVD"; 
    public static const UPCOMING_THEATERS_VIEW:String = "Coming Soon to     
Theaters"; 
    public static const MAIN_MENU_VIEW:String = "Main Menu"; 
    public static const SEARCH_VIEW:String = "Search"; 
    public static const DETAILS_VIEW:String = "Details"; 
    } 
} 
{chap 6 code}/src/com/unitedmindset/utils/ViewNameUtil.as
This list of constants represents every necessary view for your application. Now to move to a 
requested view anywhere in your application, you’ll need to use the moveToView() method: 
[Inject] 
public var stateModel:ApplicationStateModel; 
. . . 
private function _onList_ChangeHandler(event:IndexChangeEvent):void 
{ 
    stateModel.moveToView(ViewNameUtil.DETAILS_VIEW, (event.target as 
List).selectedItem); 
} 
This particular example should look familiar. Previously when browsing for movies, if you 
clicked a list for a specific movie the list change handler would push your DetailsView onto 
the ViewNavigator. Now the ApplicationStateModel will initiate the view change, and 
another method—to be coded soon—will handle the push() and pop() methods. 
CENTRALIZING EVENT DISPATCHING 
The second best practice built into the ApplicationStateModel is that you’ve now 
successfully centralized the dispatching of your events completely to your models. Although 
you could just dispatch the MoveToViewEvent from any mediator or command, I find it’s 
good practice to code so that you aren’t constantly shooting off events from all parts of your 
application. This can get confusing for teams of developers to understand when and where 
an event is fired. By using only the models to send out events and only allowing mediators 
and commands to interact with the models through the model’s public methods, you can 
protect your application from becoming a mess of unchecked decentralized events being 
fired. 
BUT SERVICES DISPATCH EVENTS TOO! 
Yes, your service layer also dispatches result events, but you’ve limited a majority of your 
event dispatching to your models. For the most part, I feel that the service layer is pretty 

MVC with mobile applications 
201 
well buried and shouldn’t be changing nearly as often as the models, views, and 
mediators. 
Obviously, the framework doesn’t enforce this methodology, but you, like me, may find that 
by developing in this way, your life and code testing become much easier.  
6.5 
Splitting your code into views and mediators 
You’ve come a long way in the MVC(S) refactor of your application. Up until now you’ve 
separated your service layer, created the event/command structure for communication, 
separated out the model layer to control the application data, and created the necessary 
events to communicate the model changes to the rest of the application (see figure 6.18). 
Figure 6.18 You are here  
Finally, you’ll need to rip your view away from your application logic and move it to a 
formalized mediator. Previously you had the view components (how the view looks) and the 
event handlers (how the view acts) in the same class. This may seem good and simple 
enough, but it causes a nightmare for testing and reusability. By splitting these two pieces of 
functionality from one class into two, you’ll have an easier time making changes to each 
class without fear of hurting the other (see figure 6.19). 

202 
CHAPTER 6 MVC with mobile applications 
Figure 6.19 Splitting the current view into a view/mediator pair 
In this section you’ll create a mediator for each view in your application and move your 
handler logic into the new mediator. With these changes you’ll enable the ability to call 
methods on your model and listen for application events from anywhere. 
As with the previous sections you won’t create each and every view/mediator pair; 
instead, you’ll focus on the SearchView/SearchMediator pair. With this knowledge you 
could easily create the other pairs as you see fit. 
6.5.1 
Creating the view 
To start things off you can create the view that you’ll need to mediate later. As I’ve talked 
about previously, views are dumb. Intentionally, their functionality is extremely low and 
they’re meant to only know about how they look and not have any other hooks into the rest 
of the application. Your SearchView will include a list of results, a text input, a button to 
initiate the search method, and an additional ActionBar to display details about the search 
results (see figure 6.20). 

MVC with mobile applications 
203 
Figure 6.20 SearchView 
Because many of your views are extremely similar, you’re going to create two new classes 
for your view. The first class, ListBaseView.mxml, will be the base for all of your listing 
views. By basing all of your list views off this singular class, you’ll have much less code to 
manage (see the following listing). 
Listing 6.16 ListBaseView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark"  
    title="Loading..."> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <s:VGroup width="100%" height="100%"> 
        <s:List width="100%" height="100%" id="list">                     
            <s:itemRenderer> 
                <fx:Component> 
                    <s:IconItemRenderer 
                        iconField="thumbnailPoster" 
                        iconWidth="61" iconHeight="91" 
                        labelField="title"/> 
                </fx:Component> 
            </s:itemRenderer> 
        </s:List> 
        <s:ActionBar id="bottomActionBar" width="100%"/>                  
    </s:VGroup> 
     
List with 
IconItemRenderer
Bottom 
ActionBar to 
show list details

204 
CHAPTER 6 MVC with mobile applications 
    <!-- error label --> 
    <s:Label id="errorLabel" width="100%"                                 
             verticalCenter="0"                                           
             visible="false" includeInLayout="false"/>                    
     
    <s:BusyIndicator id="busyIndicator"                                  #D 
        verticalCenter="0" horizontalCenter="0"                          #D 
        includeInLayout="false" visible="false"/>                        #D 
</s:View> 
{chap 6 code}/src/com/unitedmindset/views/ListBaseView.mxml
With your ListBaseView.mxml ready, you can now build your SearchView.mxml that will 
extend ListBaseView by adding a text input and button to the view to initiate the search 
feature, as shown in the following listing. 
Listing 6.17 SearchView.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<views:ListBaseView xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark"  
    xmlns:views="com.unitedmindset.views.*"> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <views:titleContent>                                                  
    <s:TextInput prompt="Enter Movie Title" id="textInput"                
            width="100%"/>                                                
    </views:titleContent> 
    <views:actionContent>                                                 
    <s:Button label="Search" id="searchButton"/>                          
    </views:actionContent>                                                
</views:ListBaseView> 
{chap 6 code}/src/com/unitedmindset/views/SearchView.mxml
With your view ready, you can move forward and create the mediator to give the view some 
functionality. 
6.5.2 
Wiring up your mediators 
You’ll remember that each mediator includes two main methods: onRegister() and 
onRemove(). The onRegister() method is a great point to set the view with any values 
you may want to have as soon as the view is available as well as to attach any handler 
methods. The onRemove() method is a perfect place to remove any attached event 
handlers and also store the view’s state for future use, as shown in the next listing. 
Invisible Label to 
display error details 
BusyIndicator to 
indicate loading
Search 
text 
input 
Search 
button

MVC with mobile applications 
205 
Listing 6.18 SearchMediator.as 
package com.unitedmindset.views.mediators{ 
    import com.rottentomatoes.vos.ServiceFault; 
    import com.unitedmindset.events.ModelUpdateEvent; 
    import com.unitedmindset.models.ApplicationStateModel; 
    import com.unitedmindset.models.SearchModel; 
    import com.unitedmindset.utils.ViewNameUtil; 
    import com.unitedmindset.views.SearchView; 
    import flash.events.MouseEvent; 
    import org.robotlegs.mvcs.Mediator; 
    import spark.components.List; 
    import spark.events.IndexChangeEvent; 
     
    public class SearchMediator extends Mediator{ 
        public function SearchMediator(){ 
            super(); 
        } 
         
        override public function onRegister():void { . . . } 
         
        override public function onRemove():void { . . . } 
    } 
} 
{chap 6 code}/src/com/unitedmindset/views/mediators/SearchMediator.as 
With this shell set you need to now inject the models and the view that’s connected to the 
mediator. When you inject models you don’t have to state that you need to create a new 
model. By using the inject tag you’ll use the dependency injection built into Robotlegs to get 
the model, of a specific type, that you included in your application context: 
. . . 
public function SearchMediator(){ 
    super(); 
} 
[Inject] 
public var view:SearchView; 
[Inject] 
public var model:SearchModel; 
[Inject] 
public var stateModel:ApplicationStateModel; 
. . . 

206 
CHAPTER 6 MVC with mobile applications 
With these introductory steps complete, you’re ready to start adding functionality to your 
mediator using handler methods. In the next section you’ll add into your mediator the 
necessary methods to mediate your view. 
6.5.3 
Adding handler methods 
Moving forward and adding functionality to your mediator, you’ll need to add event handlers 
to make calls to and respond to changes from the SearchModel (see figure 6.21). 
Figure 6.21 Search data flow 
The search data flow starts with the user hitting the search button, so you’ll need to respond 
to the search button click event, setting the search term and calling the search method on 
the SearchModel: 
private function _onSearchButton_ClickHandler(event:MouseEvent):void{ 
    view.errorLabel.visible = view.errorLabel.includeInLayout = false; 
    model.setTerm( view.textInput.text ); 
    model.getList(); 
} 
When the SearchModel starts pulling data from Rotten Tomatoes, the model sends out a 
loading change event, signifying that the loading state of the model changed. Your view 
needs to show the loading state by responding to the loading change event: 
private function 
_onSystem_LoadingChangedHandler(event:ModelUpdateEvent):void{ 
    view.busyIndicator.visible = view.busyIndicator.includeInLayout = 
    event.value as Boolean; 
} 

MVC with mobile applications 
207 
Then when the SearchModel receives a response from the service layer, there are two 
possibilities for what may happen. The first possibility is that a successful response will come 
back from the service layer. When this happens, the SearchModel fires the list change 
event, signifying that the model’s values have updated: 
private function _onSystem_ListChangedHandler(event:ModelUpdateEvent):void{ 
    _setView(); 
} 
If the service layer returns with a fault event, then you need to show the fault to the user, 
letting them know that the service method completed and failed: 
private function _onSystem_FaultHandler(event:ModelUpdateEvent):void{ 
    var fault:ServiceFault = event.value as ServiceFault; 
    view.errorLabel.visible = view.errorLabel.includeInLayout = true; 
    view.errorLabel.text = fault.faultDetail; 
} 
Finally, with the data set to the view, if a user selects a movie title to see more details, you 
need to respond to this list change event and move to the details view: 
private function _onList_ChangeHandler(event:IndexChangeEvent):void{ 
    stateModel.moveToView(ViewNameUtil.DETAILS_VIEW, (event.target as 
     List).selectedItem); 
} 
One method you’ve already been using but we haven’t defined is the _setView() method. 
You move this functionality, which is used to set data to view, to just one method so that 
you don’t have the same code in multiple locations: 
private function _setView():void{ 
    view.list.dataProvider = model.list; 
    view.bottomActionBar.title = "Page: "+model.currentPage+" out of " 
    +Math.ceil(model.total/model.numOfResults)+" - Total Results: " 
    +model.total; 
} 
With all of your mediator’s methods ready, you need to use the onRegister() and 
onRemove() methods to connect and disconnect your mediator from the rest of the 
application. 
6.5.4 
Connecting and disconnecting your mediator 
Returning to the onRegister() and onRemove() methods in your mediator, you need to 
connect to the view and to the application’s central event dispatcher when the view is 
created and then disconnect when the view is removed. 
When your mediator is created, the onRegister() method is called based on the 
connected view being created. For your onRegister() method you’ll connect to the view 
components so that the mediator knows when things like the search button are clicked. Then 

208 
CHAPTER 6 MVC with mobile applications 
you connect to the eventDispatcher so you can respond to model update events. You 
may remember that all events fired from the Robotlegs framework get routed through a 
central event dispatcher; eventDispatcher is a reference to that central dispatcher. 
Finally, you’ll set the view with any applicable data that exists in the model at startup (see 
the following listing). 
Listing 6.19 SearchMediator.as onRegister() 
override public function onRegister():void{ 
     
    view.list.addEventListener(IndexChangeEvent.CHANGE,                   
    _onList_ChangeHandler);                                               
    view.searchButton.addEventListener(MouseEvent.CLICK,                  
    _onSearchButton_ClickHandler);                                        
    eventDispatcher.addEventListener(                                     
    ModelUpdateEvent.SEARCH_LIST_CHANGED,                                 
    _onSystem_ListChangedHandler);                                        
    eventDispatcher.addEventListener(                                     
    ModelUpdateEvent.SEARCH_LOADING_CHANGED,                              
    _onSystem_LoadingChangedHandler);                                     
         
    if(!model.listNeedsRefresh())                                         
        _setView();                                                       
} 
. . . 
{chap 6 code}/src/com/unitedmindset/views/mediators/SearchMediator.as
SearchMediator startup versus the others mediators 
Starting out, the search functionality is waiting for an input from the user, whereas the 
other views need to pull the data if it doesn’t exist already. In the SearchMediator 
onRegister() method you set the view with existing data with the following code: 
    if( !model.listNeedsRefresh() ) _setView(); 
For the rest of the mediators you need to pull the data if it doesn’t already exist with the 
following code: 
    if( model.listNeedsRefresh() )  
        model.getList();  
    else  
        _setView(); 
When you’re creating your other mediators, this is the code you’ll need to automatically 
pull the data if it doesn’t already exist. 
Connect 
to view
Connect to main 
eventDispatcher 
Set view with any data 
that’s ready

MVC with mobile applications 
209 
With your mediator registered, you now need to remove the event listeners from your 
mediator so that your mediator and view can be garbage-collected properly (see the 
following listing). 
Listing 6.20 SearchMediator.as onRemove() 
override public function onRemove():void{ 
    view.list.removeEventListener(IndexChangeEvent.CHANGE,                
     _onList_ChangeHandler);                                              
    view.searchButton.removeEventListener(MouseEvent.CLICK,               
    _onSearchButton_ClickHandler);                                        
     
    eventDispatcher.removeEventListener(                                  
    ModelUpdateEvent.SEARCH_LIST_CHANGED, _onSystem_ListChangedHandler);  
    eventDispatcher.removeEventListener(                                  
    ModelUpdateEvent.SEARCH_LOADING_CHANGED,                              
    _onSystem_LoadingChangedHandler);                                     
} 
{chap 6 code}/src/com/unitedmindset/view/mediators/SearchMediator.as 
With all of your handler methods connected and disconnected properly, you can mark your 
SearchMediator as complete. Now you can return to the application’s context and connect 
all of your views to their corresponding mediators: 
//imports 
import com.unitedmindset.views.*; 
import com.unitedmindset.views.mediators.*; 
//view/mediators 
mediatorMap.mapView(SearchView, SearchMediator); 
mediatorMap.mapView(BoxOfficeView, BoxOfficeMediator); 
mediatorMap.mapView(CurrentDvdView, CurrentDvdMediator); 
mediatorMap.mapView(InTheatersView, InTheatersMediator); 
mediatorMap.mapView(NewDvdView, NewDvdMediator); 
mediatorMap.mapView(OpeningNowView, OpeningNowMediator); 
mediatorMap.mapView(TopRentalsView, TopRentalsMediator); 
mediatorMap.mapView(UpcomingDvdView, UpcomingDvdMediator); 
mediatorMap.mapView(UpcomingTheatersView, UpcomingTheatersMediator); 
If you were to stop right now, your application would look like your original application with 
the added ability to page your results—not that you’d expect the MVC(S) structure and 
Robotlegs framework to make any difference in how the application looks. For a little fun, 
though, you’ll capitalize on your work and upgrade your application to work on tablet devices 
using the SplitViewNavigator, a new component for Flex 4.6. In the next section we’ll 
look at the application changes necessary to work on a tablet, and then you’ll create the 
ApplicationMediator to respond to application state changes. 
Remove view 
event 
listeners
Remove 
event 
dispatcher 
listeners

210 
CHAPTER 6 MVC with mobile applications 
Missing MainMenuView and DetailsView? 
Although there’s perfectly good code in the MainMenuView, DetailsView, and their 
accompanying mediators, in my opinion these views don’t hold any new concepts worth 
talking about. So that we don’t waste our time, I’ve included the entire code for these 
classes as a download. These downloads also provide the complete application at the end 
of each chapter. Don’t forget to register the mediators for these views in the context. 
6.6 
Application upgrade 
Right now, your application looks great on phones, but with a new tablet being released 
every week you need to be able to make applications that run on tablets too. To satisfy this 
need, you’re going to upgrade your application right now to specifically support tablets with a 
special tablet layout. The most amazing thing is that you can keep your application’s views 
almost entirely the way they are and update the main application. 
In this section you’re going to alter your views just a touch and use the new 
SplitViewNavigator to create an application that’s formatted for tablet devices (see 
figure 6.22). 
Figure 6.22 Your new application look 

MVC with mobile applications 
211 
6.6.1 
Changing the main application 
Currently you’re using one of the application types built into the Flex SDK to run your 
application, 
the 
TabbedViewNavigatorApplication. 
To 
create 
the 
SplitViewNavigator–based application you’ll need to change to the base application type 
and add the SplitViewNavigator component—still using your splash screen, your 
context, your CSS sheet, and even a ViewNavigator (see the following listing). 
Listing 6.21 RottenTomatoesApplication.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"                   
    xmlns:s="library://ns.adobe.com/flex/spark"                           
    preloader="spark.preloaders.SplashScreen"                             
    splashScreenImage="@Embed('/assets/images/splashscreen.png')"         
    xmlns:unitedmindset="com.unitedmindset.*"                             
    persistNavigatorState=”true”>                                         
    <fx:Declarations> 
<!-- Place non-visual elements (e.g., services, value objects) here --> 
    <unitedmindset:RottenTomatoesContext  
        contextView="{this}"/>                                            
    </fx:Declarations> 
    <fx:Style source="/assets/css/main.css"/>                             
    <s:SplitViewNavigator autoHideFirstViewNavigator="true"               
        width="100%" height="100%"                                        
        id="splitViewNavigator">                                          
        <s:ViewNavigator width="250" height="100%"                       
        id="menuNavigator"                                               
        firstView="com.unitedmindset.views.MainMenuView"/>               
        <s:ViewNavigator width="100%"  
            height="100%" id="navigator"/>                                
    </s:SplitViewNavigator> 
</s:Application> 
{chap 6 code}/src/RottenTomatoesApplication.mxml
This simple change enables you to use the SplitViewNavigator for your application, 
expanding how the application manages the views.  
One feature of the SplitViewNavigator is utilized by the simple property 
autoHideFirstViewNavigator. By setting this property to true, you’ll hide the menu 
when the application is in portrait mode and show the main menu when the application is in 
landscape mode (see figure 6.23). 
Main app with 
all previous 
settings
Application’s context 
Existing CSS sheet 
SplitViewNavigator
holding 2 ViewNavigators
Left-side 
ViewNavigator
(menu) 
Right-side ViewNavigator
(views)

212 
CHAPTER 6 MVC with mobile applications 
Figure 6.23 SplitViewNavigator  
Another feature of the SplitViewNavigator is that when the application is in portrait 
view, you can use the Callout component to show the main menu to the user, still allowing 
the user to navigate through the application even when the application is in portrait mode 
(see figure 6.24). 
Figure 6.24 Portrait SplitViewNavigator with callout 

MVC with mobile applications 
213 
To achieve this you need to provide something clickable on the views to launch the callout. 
Luckily, you don’t have to update each view because you based most of your views on the 
ListBaseView component. To update the ListBaseView component you’ll add a menu 
button that’s shown only when the application is in portrait mode. You can easily accomplish 
this by adding the portrait and landscape states and setting the menu button to be visible 
only in the landscape state: 
. . . 
<fx:Declarations> 
<!-- Place non-visual elements (e.g., services, value objects) here --> 
</fx:Declarations> 
    <s:states> 
        <s:State name="portrait"/> 
        <s:State name="landscape"/> 
    </s:states> 
    <s:navigationContent> 
        <s:Button id="homeButton" label="Menu" 
                  includeInLayout="false" visible="false" 
                  includeInLayout.portrait="true"  
  visible.portrait="true"/> 
    </s:navigationContent>
. . . 
LANDSCAPE AND PORTRAIT STATES 
By default you can add in the portrait and landscape states, and your Flex views will 
adjust based on the device’s orientation. Many views you’ll create will probably take 
advantage of these helpful states to look good on mobile devices. 
Now you need to go to your mediators and handle the click event from the homeButton: 
private function _onHomeButton_ClickHandler(event:MouseEvent):void{ 
    stateModel.moveToView(ViewNameUtil.MAIN_MENU_VIEW, null, 
     view.homeButton); 
} 
Make sure to wire up the event handler in the onRegister() and onRemove() methods, 
and your homeButton’s functionality will be good to go: 
override public function onRegister():void{ 
    . . . 
    view.homeButton.addEventListener(MouseEvent.CLICK, 
     _onHomeButton_ClickHandler); 
    . . . 
} 
override public function onRemove():void{ 

214 
CHAPTER 6 MVC with mobile applications 
    . . . 
    view.homeButton.removeEventListener(MouseEvent.CLICK, 
     _onHomeButton_ClickHandler); 
    . . . 
} 
With your views updated and working with your new SplitViewNavigator application, 
you can finally create your ApplicationMediator that will respond to changes from your 
ApplicationStateModel. 
6.6.2 
Building the ApplicationMediator 
With everything else ready to go, the last section to build on is ApplicationMediator. 
This mediator is crucial to providing a simple way to control the state of your application 
because it responds to changes in the ApplicationStateModel. As with the mediators 
that you created earlier, the ApplicationMediator will have the onRegister() and 
onRemove() methods and connect to the eventDispatcher to respond to changes by the 
ApplicationStateModel (see the following listing). 
Listing 6.22 ApplicationMediator.as 
package com.unitedmindset.views.mediators{ 
    import com.unitedmindset.events.MoveToViewEvent; 
    import com.unitedmindset.models.ApplicationStateModel; 
    import com.unitedmindset.utils.ViewNameUtil; 
    import com.unitedmindset.views.*; 
    import flash.display.DisplayObjectContainer; 
    import org.robotlegs.mvcs.Mediator; 
     
    public class ApplicationMediator extends Mediator{ 
        public function ApplicationMediator(){ 
            super(); 
        } 
         
        [Inject] 
        public var view:RottenTomatoesApplication;                        
         
[Inject] 
        public var stateModel:ApplicationStateModel; 
     
override public function onRegister():void{                   
        eventDispatcher.addEventListener(  
        MoveToViewEvent.PUSH_VIEW, _onSystem_PushViewHandler); 
        eventDispatcher.addEventListener( MoveToViewEvent.POP_VIEW, 
         _onSystem_PopViewHandler); 
        } 
         
Injections 
Add event 
listeners 

MVC with mobile applications 
215 
        override public function onRemove():void{                         
             eventDispatcher.removeEventListener(  
             MoveToViewEvent.PUSH_VIEW, 
         _onSystem_PushViewHandler); 
        eventDispatcher.removeEventListener( MoveToViewEvent.POP_VIEW, 
         _onSystem_PopViewHandler); 
        } 
         
        private function  
        _onSystem_PushViewHandler(event:MoveToViewEvent):void {}          
         
        private function  
        _onSystem_PopViewHandler(event:MoveToViewEvent):void {}           
    } 
} 
{chap 6 code}/src/com/unitedmindset/view/mediators/ApplicationMediator.as
With the majority of the class stubbed out, you can already see that you’re injecting your 
main application into the view property so that you can access the main application. After 
that you’re also injecting the instance of the ApplicationStateModel in case you need to 
access that. Finally, you’re attaching to the MoveToViewEvent push and pop events so that 
you can push and pop views on your application’s navigator. 
First, you’ll add in the functionality to push a view onto the navigator, and because there 
are now two navigators, you need to ensure that you push your view onto the correct 
navigator. You’ll never have to push views onto the navigator holding the main menu, so 
we’ll focus on pushing views onto the second navigator, as shown in the following listing. 
Listing 6.23 ApplicationMediator.as pushing a view 
private function _onSystem_PushViewHandler(event:MoveToViewEvent):void{ 
    switch(event.view){                                                   
        case ViewNameUtil.BOX_OFFICE_VIEW: 
            view.navigator.pushView(BoxOfficeView); 
            break; 
        case ViewNameUtil.CURRENT_DVD_VIEW: 
            view.navigator.pushView(CurrentDvdView); 
            break; 
        case ViewNameUtil.DETAILS_VIEW: 
            view.navigator.pushView(DetailsView, event.data); 
            break; 
        case ViewNameUtil.IN_THEATERS_VIEW: 
            view.navigator.pushView(InTheatersView); 
            break; 
        case ViewNameUtil.MAIN_MENU_VIEW: 
            //if in landscape, do nothing 
            //in portrait, show call out 
Remove event 
listeners 
Respond to push events 
Respond to pop events 
Push the proper class by name 

216 
CHAPTER 6 MVC with mobile applications 
            if(view.aspectRatio == "portrait"){                           
                view.splitViewNavigator.showFirstViewNavigatorInPopUp(  
                event.relatedObject as DisplayObjectContainer ); 
            } 
            break; 
        case ViewNameUtil.NEW_DVD_VIEW: 
            view.navigator.pushView(NewDvdView); 
            break; 
        case ViewNameUtil.OPENING_NOW_VIEW: 
            view.navigator.pushView(OpeningNowView); 
            break; 
        case ViewNameUtil.SEARCH_VIEW: 
            view.navigator.pushView(SearchView); 
            break; 
        case ViewNameUtil.TOP_RENTALS_VIEW: 
            view.navigator.pushView(TopRentalsView); 
            break; 
        case ViewNameUtil.UPCOMING_DVD_VIEW: 
            view.navigator.pushView(UpcomingDvdView); 
            break; 
        case ViewNameUtil.UPCOMING_THEATERS_VIEW: 
            view.navigator.pushView(UpcomingTheatersView); 
            break; 
    } 
} 
{chap 6 code}/src/com/unitedmindset/view/mediators/ApplicationMediator.as
Don’t forget to import and map your new mediator to your application within the Context
class: 
import com.unitedmindset.views.mediators.ApplicationMediator; 
override public function startup():void 
{ 
    . . . 
    mediatorMap.mapView(RottenTomatoesApplication, ApplicationMediator); 
    . . . 
} 
The logic here is simple; you look at what view is being requested by the view name and 
then push the proper view onto the second ViewNavigator. There’s one exception in the 
logic, and that’s the MainMenuView.  
As you know, you’re using the SplitViewNavigator with the main menu being shown 
at all times. If the main menu is called for, you need to determine what to do based on the 
design of this application. If the main menu is being called for and the application is in 
landscape mode, then you can ignore the request, because the main menu is already being 
shown. But if the application is in portrait mode and the main menu is being asked for, then 
Show main menu if necessary 

MVC with mobile applications 
217 
you need to pop up the main menu in a callout so that the user can still navigate the 
application. 
With this last code flourish, you’ve completed upgrading your application to a tablet-
based application using the Robotlegs framework.  
6.7 
Summary 
That’s it! Pat yourself on the back and feel extremely accomplished. You’ve come a long way 
in this chapter and now have a full application that you can be proud of. Your application is 
now using the enterprise-strength MVC framework called Robotlegs and is also now ready to 
run on larger tablet devices. These massive improvements should give you an application 
that you can be proud of. 
In the next chapter you’ll take this application and split it up to work effectively on 
multiple platforms with specific code per platform. 
Key takeaways: 

MVC concept 

Working with Robotlegs 

Creating simple views 

Making mediators 

Building effective data models 

Creating an application service layer 

Using the SplitViewNavigator component 

218 
7  
Architecting multiscreen 
applications 
This chapter covers 

Architecting multiscreen applications 

Customizing applications by platform 

Using a library 
Your amazing tablet-ready Robotlegs-based application is ready for testing, additional 
features, and—in this chapter—separating the application for platform-specific changes, be it 
Android Tablet, Android Phone, iPad, iPhone, BlackBerry Tablet, Sony Tablet, or any other 
place for custom application types. As new platforms and screen types are created, you need 
an application that’s easily customizable without being over architected or bloated by code or 
images. If you were to create just one application for all screens, this task would be almost 
impossible, but in this chapter you’ll split the application into platform-specific application 
files. 
If you’re creating an application for just one platform, then splitting your application is a 
luxury rather than a necessity, though helpful. When creating multiscreen applications, 
splitting the application makes it easier to customize your application to the platform. 
For example, if you’re creating an iOS application, you’ll need to include a back button to 
move to the previous screen. But if you include a visible back button in Android 
applications—ignoring the built-in back button—your users will be upset because you 
obviously didn’t design your application for the Android platform. In this chapter you’ll learn 
how to architect your application to be multiscreen optimized, how to use a library for 
maximum code reuse, and finally how to make platform-specific customizations. 

Architecting multiscreen applications  
219 
7.1 
Laying out a multiscreen application 
The basis of making a good multiscreen application is to use a hub-and-spoke application 
design paradigm centralized on a master library holding as many common components as 
possible (see figure 7.1). 
Figure 7.1 Hub and spoke application design 
By using a library as the core of your application stack, you can include your models, 
services, commands, context, utilities, custom renderers, and any other reusable classes, 
leaving only the creation of custom views and mediators for the spoke projects.  
Flex libraries are projects that can’t run on their own but instead are a way to easily 
collect all of your code into one container. You’ve already been using the result of libraries, 
SWC files—the compiled collection of code. The Flex framework is distributed using SWCs 
along with the RottenTomatoesAS3 API that you used previously. When your library is put 
together, each individual device’s application will be able to handle the device’s unique input 
style while the data models stay the same across all platforms. You can share your code 
rather than copying and pasting between applications. 
You’ve already created the structure using Robotlegs to make this possible without 
changing your application, along with using a central state model to simplify moving between 
views. You’ll also use the ViewNameUtil that you created earlier to refer to specific views 
without calling specific view classes. In this section we’ll look at what you’ll be putting into 
the library and how you’ll extend this library to create custom applications for each platform. 

220 
CHAPTER 7 Architecting multiscreen applications 
7.1.1 
Hub library 
First, you need to decide what classes you can move into your library that each of your 
applications will need to access to work properly. Earlier we said that the views and 
mediators will need to be customized to each platform, but everything else can be easily 
shared. 
Later, as you add features, you can decide if the features will be available to all 
applications within the library or only to specific platforms. Depending on your decision, 
you’ll put code into specific spoke projects or the hub library. 
Within the library you’ll include your data models, service layer, commands, utilities, 
events, and a context to tie these elements together that you can extend later (see figure 
7.2). 
Figure 7.2 Visualized library 
Next, we’ll look at how you’ll customize each spoke application to make it appropriate for 
each platform. 
7.1.2 
Spoke applications 
As you extend the library for each application, you only need to build the views, mediators, 
and a subclass of your context to include all the functionality from your base library, as 
shown in figure 7.3. 

Architecting multiscreen applications  
221 
Figure 7.3 Visualized spoke applications 
In the next section you’ll reorganize your current application into a library so that you can 
create platform-specific applications later. 
7.2 
Libraries 
Earlier we touched on what a Flex library is. Now we’ll go into some more detail as to what’s 
involved with a Flex library and how to use it, and then you’ll create your own to act as the 
hub of your overarching application. 
7.2.1 
What’s a Flex library? 
Flex library projects are similar to Flex applications because they can encompass code, 
images, and other compiled libraries—also known as SWC files, CSS files, and skins created 
for your library.  
Unlike Flex applications, there’s no starting point to a Flex library project in the way that 
Flex applications include an application file. Therefore the compiler doesn’t start at the root 
node, the application file, and determine what dependencies are required to run the 
application. Instead, the entire contents of the library are automatically compiled into the 
SWC file. 
Finally, it’s important to know that there are two ways to include the contents of a Flex 
library with your application. The first way, as you’re currently using the RottenTomatoesAS3 
library, is to use the compiled SWC that’s created from the library. As you already know from 
using the RottenTomatoesAS3.swc file, you still get your code hinting and other helpful tips 
using the SWC, but if you try to jump to the code implementation of the method, you get an 
error (see figure 7.4). 

222 
CHAPTER 7 Architecting multiscreen applications 
Figure 7.4 Source not found SWC error 
The second method to include your Flex library is to create a connection between the 
application and the Flex library (see figure 7.5). When using just the SWC, if you make a 
change to the library, then other projects won’t recompile to include the newest changes in 
the library. When you’re making a connection between the library and other projects, any 
changes in the library cause a recompile on each of the connected projects.  
Figure 7.5 Connected library 

Architecting multiscreen applications  
223 
Furthermore, if you decide to see the implementation of a method, you can skip right to the 
proper code. 
Advanced library users 
There are ways to connect the source code without connecting a library as well as many 
other advanced library features. I’d recommend you doing some additional research into 
Flex libraries as your requirements emerge.  
You now have all the information necessary to connect the library you create with your 
application. Next, you’ll go step by step and create your mobile application’s library. 
7.2.2 
Setting up the library 
You now create a new Flex library project by choosing New > Flex Library Project, similarly 
to the way you create a new Flex Mobile Project. With this option selected, you’ll get the 
following dialog box (see figure 7.6). 
Figure 7.6 New Flex Library Project dialog box 

224 
CHAPTER 7 Architecting multiscreen applications 
After naming your Flex library project, you set the Configuration option to the Mobile Library 
setting to include mobile-specific components such as the PersistenceManager that you 
used in your models. With this one setting change, you can click Finish and continue on. 
You’ll then have an empty library. Continuing with your mobile library, you’ll add 
packages to hold your classes as you move them over. 
With your structure ready it’s time to move over the common classes that you’ll make 
available 
to 
all 
subprojects. 
In 
this 
case, 
copy 
all 
packages 
except 
for 
com.unitedmindset.views and com.unitedmindset.mediators and make sure to 
remove the appropriate mappings from your context. As you can already tell from the 
library’s structure, many of your classes will move over directly with a quick copy-and-paste 
operation (see figure 7.7). 
Figure 7.7 Filled-in library structure 
Now that your classes are moved correctly, you’ll create the base context for your sub-
applications to extend. In the next section, you’ll create this new class. 

Architecting multiscreen applications  
225 
7.2.3 
Creating your base context 
For each of your sub-applications you’ll create and extend a base context that will include all 
of the injections and event/command mappings necessary to run your application. The 
view/mediator mappings will be missing from this base context because they’ll be specific to 
the platform. 
You can do some more copying and pasting here to make your life simple, creating 
RottenTomatoesBaseContext.as (see the following listing). 
Listing 7.1 RottenTomatoesBaseContext.as 
package com.unitedmindset{ 
import com.unitedmindset.controllers.boxoffice.*; 
import com.unitedmindset.controllers.currentdvd.*; 
import com.unitedmindset.controllers.intheaters.*; 
import com.unitedmindset.controllers.newdvd.*; 
import com.unitedmindset.controllers.openingnow.*; 
import com.unitedmindset.controllers.reviews.*; 
import com.unitedmindset.controllers.search.*; 
import com.unitedmindset.controllers.toprentals.*; 
import com.unitedmindset.controllers.upcomingdvd.*; 
import com.unitedmindset.controllers.upcomingtheaters. *; 
import com.unitedmindset.events.*; 
import com.unitedmindset.models.*; 
import com.unitedmindset.services.*; 
import flash.display.DisplayObjectContainer; 
import org.robotlegs.mvcs.Context; 
     
public class RottenTomatoesBaseContext extends Context{ 
    public function RottenTomatoesBaseContext(  
    contextView:DisplayObjectContainer=null, autoStartup:Boolean=true){ 
        super(contextView, autoStartup); 
    } 
         
    override public function startup():void{ 
        commandMap.mapEvent(RequestDataEvent.BOX_OFFICE_LIST,             
        GetBoxOfficeCommand, RequestDataEvent);                           
        commandMap.mapEvent(RequestDataEvent.CURRENT_DVD_LIST,            
        GetCurrentDvdCommand, RequestDataEvent);                          
        commandMap.mapEvent(RequestDataEvent.IN_THEATERS_LIST,            
        GetInTheatersCommand, RequestDataEvent);                          
        commandMap.mapEvent(RequestDataEvent.NEW_DVD_LIST,                
        GetNewDvdCommand, RequestDataEvent);                              
        commandMap.mapEvent(RequestDataEvent.OPENING_NOW_LIST,            
        GetOpeningNowCommand, RequestDataEvent);                          
        commandMap.mapEvent(RequestDataEvent.SEARCH_LIST,                 
Service request 
event/command maps 

226 
CHAPTER 7 Architecting multiscreen applications 
        GetSearchCommand, RequestDataEvent);                             #A 
        commandMap.mapEvent(RequestDataEvent.TOP_RENTALS_LIST,            
        GetTopRentalsCommand, RequestDataEvent);                          
        commandMap.mapEvent(RequestDataEvent.UPCOMING_DVD_LIST,           
        GetUpcomingDvdCommand, RequestDataEvent);                         
        commandMap.mapEvent(RequestDataEvent.UPCOMING_THEATER_LIST,       
        GetUpcomingTheatersCommand, RequestDataEvent);                    
        commandMap.mapEvent(RequestDataEvent.REVIEWS_LIST,                
        GetReviewsCommand, RequestDataEvent);                             
        commandMap.mapEvent(ServiceResponseEvent.BOX_OFFICE_RESULT,       
        GetBoxOfficeResultCommand, ServiceResponseEvent);                 
        commandMap.mapEvent(ServiceResponseEvent.CURRENT_DVD_RESULT,      
        GetCurrentDvdResultCommand, ServiceResponseEvent);                
        commandMap.mapEvent(ServiceResponseEvent.IN_THEATERS_RESULT,      
        GetInTheaterResultCommand, ServiceResponseEvent);                 
        commandMap.mapEvent(ServiceResponseEvent.NEW_DVD_RESULT,          
        GetNewDvdResultCommand, ServiceResponseEvent);                    
        commandMap.mapEvent(ServiceResponseEvent.OPENING_NOW_RESULT,      
        GetOpeningNowResultCommand, ServiceResponseEvent);                
        commandMap.mapEvent(ServiceResponseEvent.SEARCH_RESULT,           
        GetSearchResultCommand, ServiceResponseEvent);                    
        commandMap.mapEvent(ServiceResponseEvent.TOP_RENTALS_RESULT,      
        GetTopRentalsResultCommand, ServiceResponseEvent);                
        commandMap.mapEvent(ServiceResponseEvent.UPCOMING_DVD_RESULT,     
        GetUpcomingDvdResultCommand, ServiceResponseEvent);               
        commandMap.mapEvent(ServiceResponseEvent.UPCOMING_THEATER_RESULT, 
        GetUpcomingTheatersResultCommand, ServiceResponseEvent);          
        commandMap.mapEvent(ServiceResponseEvent.REVIEWS_RESULT,          
        GetReviewsResultCommand, ServiceResponseEvent);                   
        injector.mapSingletonOf(IRotTomService, RotTomService);           
        injector.mapSingleton(BoxOfficeModel);                            
        injector.mapSingleton(CurrentDvdModel);                           
        injector.mapSingleton(InTheatersModel);                           
        injector.mapSingleton(NewDvdModel);                              
        injector.mapSingleton(OpeningNowModel);                           
        injector.mapSingleton(SearchModel);                              
        injector.mapSingleton(TopRentalsModel);                           
        injector.mapSingleton(UpcomingDvdModel);                          
        injector.mapSingleton(UpcomingTheatersModel);                     
        injector.mapSingleton(SelectedMovieModel);                        
        injector.mapSingleton(ApplicationStateModel);                     
    } 
    override public function shutdown():void {} 
Service request 
event/command maps 
Service response 
event/command maps 
Service map 
Model layers 

Architecting multiscreen applications  
227 
    } 
} 
{chap 7 code}/src/com/unitedmindset/com/unitedmindset/RottenTomatoesBaseContext.as
With your base context created, you can move forward and create platform-specific 
applications while reusing the lion’s share of your code. 
Reuse of view code 
In the following sections I assume that you’ll do some copy and pasting for your views 
and mediators. If you’re absolutely sure that your views, and therefore the mediators, will 
be so similar that you can reuse their code, then by all means move some base version of 
your views and mediators into your library. If, however, your application’s view varies 
based on the platform—as I assume it will—then you’ll probably find that starting from 
scratch on your views is the easiest method to use to customize your application. For the 
upcoming examples I’ll assume that you found it easier to start from scratch. 
7.3 
Android application 
With your library created you can move forward and create an application specifically for the 
Android platform. Unique to the Android platform are the additional hardware buttons not 
found on other devices (see figure 7.8). Your application will respond to these input buttons, 
leaving the user feeling that the application is more native. 
Figure 7.8 Android hardware buttons 
In addition to the hardware buttons, Android applications have a consistent way of dealing 
with additional input options by bringing up a menu bar at the bottom of the screen (see 
figure 7.9). 

228 
CHAPTER 7 Architecting multiscreen applications 
Figure 7.9 Android menu UI 
In this section you’ll create and prep your Android application and then add in code to 
respond to the Android-specific features. 
7.3.1 
Setting up your Android application 
Hopefully you saved a copy of your existing application, making this next step extremely 
easy. As before, we won’t be looking at how to create each and every view because they’re 
so similar, and instead we’ll focus on SearchView. 
First, you’ll create a new Flex Mobile project and title it RottenTomatoesAndroid, 
making sure to add the RottenTomatoesLib in the fourth step (see figure 7.10). 

Architecting multiscreen applications  
229 
Figure 7.10 Adding the library to the Android project 
With your application ready, you can copy and paste over your existing platform-agnostic 
views and mediators before extending the base context for your Android application (see the 
following listing) along with the CSS files and images. 
Listing 7.2 RottenTomatoesContext.as 
package com.unitedmindset{ 
    import com.unitedmindset.views.*; 
    import com.unitedmindset.views.mediators.*; 
    import flash.display.DisplayObjectContainer; 
     
    public class RottenTomatoesContext extends  
        RottenTomatoesBaseContext{                                        
    public function RottenTomatoesContext(  
        contextView:DisplayObjectContainer=null,  
        autoStartup:Boolean=true){ 
Extend the base context 

230 
CHAPTER 7 Architecting multiscreen applications 
        super(contextView, autoStartup); 
    } 
         
    override public function startup():void{ 
    super.startup();                                                      
             
    mediatorMap.mapView(RottenTomatoesAndroid, 
        ApplicationMediator);                                             
    mediatorMap.mapView(MainMenuView, MainMenuMediator);                  
    mediatorMap.mapView(DetailsView, DetailsMediator);                    
    mediatorMap.mapView(SearchView, SearchMediator);                      
    mediatorMap.mapView(BoxOfficeView, BoxOfficeMediator);                
    mediatorMap.mapView(CurrentDvdView, CurrentDvdMediator);              
    mediatorMap.mapView(InTheatersView, InTheatersMediator);              
    mediatorMap.mapView(NewDvdView, NewDvdMediator);                      
    mediatorMap.mapView(OpeningNowView, OpeningNowMediator);              
    mediatorMap.mapView(TopRentalsView, TopRentalsMediator);              
    mediatorMap.mapView(UpcomingDvdView, 
        UpcomingDvdMediator);                                             
    mediatorMap.mapView(UpcomingTheatersView, UpcomingTheatersMediator);  
    } 
    } 
} 
{chap 7 Android code}/src/com/unitedmindset/com/unitedmindset/RottenTomatoesContext.as
Finally, you’ll set up your main application to look similar to your previous application, as 
shown in the following listing. 
Listing 7.3 RottenTomatoesAndroid.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark"  
    preloader="spark.preloaders.SplashScreen" 
    splashScreenImage="@Embed('/assets/images/splashscreen.png')" 
    xmlns:unitedmindset="com.unitedmindset.*"> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    <unitedmindset:RottenTomatoesContext id="context" 
     contextView="{this}"/> 
    </fx:Declarations> 
    <s:SplitViewNavigator autoHideFirstViewNavigator="true" 
        width="100%" height="100%" 
        id="splitViewNavigator"> 
        <s:ViewNavigator width="250" height="100%" id="menuNavigator"  
            firstView="com.unitedmindset.views.MainMenuView"/> 
        <s:ViewNavigator width="100%" height="100%" id="navigator"/> 
Include all base classes’ startup code 
Update the ApplicationMediator’s 
view injection to reference the 
RottenTomatoesAndroid class 
View/mediator 
map

Architecting multiscreen applications  
231 
    </s:SplitViewNavigator> 
</s:Application> 
{chap 7 Android code}/src/com/unitedmindset/RottenTomatoesAndroid.mxml
Now with your application re-created for the Android platform—so easy—you can move into 
the next section and customize your search view to use the Android-like menu.  
7.3.2 
Customizing the view/mediators for Android capabilities 
With your application re-created specifically for the Android platform, you can now add 
support for buttons that are only on the Android platform. To do this you head to the 
ListBaseView.mxml file and first add a menu to show to the user. 
Window dressing 
For this application there’s a lot of “pretty-ing” that you could do both in skinning and 
visual effects to make your application look exactly like an Android UI. For the sake of 
time we’ll skip these steps, because these nitpicky details don’t teach any new theories of 
mobile application development. 
For the menu you’ll use an ActionBar colored gray like the default Android menu UI placed 
at the bottom of the view and with “next” and “previous” buttons, as shown here: 
. . . 
    <s:ActionBar id="bottomActionBar" width="100%"/> 
</s:VGroup> 
     
<s:ActionBar id="menuGroup" 
        visible="false" 
        bottom="0" width="100%" 
        chromeColor="#999999"> 
    <s:actionContent> 
        <s:Button label="Previous Page" id="prevPageButton"/> 
        <s:Button label="Next Page" id="nextPageButton"/> 
    </s:actionContent> 
</s:ActionBar> 
. . . 
With the menu added to the ListBaseView, now every view that extends the 
ListBaseView also includes a menu ready for use. To utilize the menu you now add the 
logic within the mediator. First, you set the “previous” and “next” buttons to be enabled or 
disabled whenever the list value changes. This functionality is easy to add by adjusting the 
_setView() method: 
private function _setView():void{ 
    . . . 
    view.nextPageButton.enabled = model.isNextPage(); 
    view.prevPageButton.enabled = model.isPrevPage(); 

232 
CHAPTER 7 Architecting multiscreen applications 
} 
Next, you call for the next page or previous page when the user clicks the corresponding 
button: 
private function _onNextButtonHandler(event:MouseEvent):void{ 
    model.getNextPage(); 
} 
private function _onPrevButtonHandler(event:MouseEvent):void{ 
    model.getPrevPage(); 
} 
Then you respond to the hardware buttons by listening to the key down event. In the 
handler method you’ll determine which button was clicked and respond appropriately. For 
your application you’ll show the menu if the menu button is clicked and go to the search 
page if the search button is clicked. You’ll use the same coding tricks you learned in chapter 
4 to respond to the hardware buttons:  
import flash.events.KeyboardEvent; 
import flash.ui.Keyboard; 
private function _onKeyboardDownHandler(event:KeyboardEvent):void{ 
    switch(event.keyCode){ 
        case Keyboard.MENU: 
        view.menuGroup.visible = (view.menuGroup.visible)?false:true; 
            break; 
        case Keyboard.SEARCH: 
        stateModel.moveToView(ViewNameUtil.SEARCH_VIEW); 
            break; 
    } 
} 
With your handler methods created, the last task you complete is adding in the event 
listeners for your key down event and the previous/next button’s click events in the 
onRegister() method: 
override public function onRegister():void{ 
    . . . 
    view.stage.addEventListener(KeyboardEvent.KEY_DOWN, 
     _onKeyboardDownHandler); 
    view.nextPageButton.addEventListener(MouseEvent.CLICK, 
     _onNextButtonHandler); 
    view.prevPageButton.addEventListener(MouseEvent.CLICK, 
     _onPrevButtonHandler); 
    . . . 
} 
But don’t forget to remove your event listeners in the onRemove() method: 

Architecting multiscreen applications  
233 
override public function onRemove():void{ 
    . . . 
    view.stage.removeEventListener(KeyboardEvent.KEY_DOWN, 
     _onKeyboardDownHandler); 
    view.nextPageButton.removeEventListener(MouseEvent.CLICK, 
     _onNextButtonHandler); 
    view.prevPageButton.removeEventListener(MouseEvent.CLICK, 
     _onPrevButtonHandler); 
    . . . 
} 
With these simple changes your Android-specific functionality is complete. When the user 
hits the hardware menu button, a menu with the option to switch pages will appear. Then 
when the user changes pages, the functionality you’ve already coded in your model will 
handle the rest. With your Android application wrapped up, you can move forward with 
customizing your QNX/BlackBerry application. 
Embedded images 
Currently, only a few Android devices support the 320 DPI setting. If you don’t intend to 
support these devices, this would be a good time to remove any 320 DPI code and 
images from your application, keeping your final release file as small as possible. 
7.4 
Creating your QNX-specific application 
Building off your library, you’ll now create an application using the same data as your 
previous applications, specializing your new application for the QNX platform. As with the 
Android platform, you’ll add in the paging function off a menu customized to look appropriate 
for the QNX platform (see figure 7.11). 
Figure 7.11 QNX menu 
7.4.1 
Setting up the QNX application 
You’ll now create a new Flex Mobile application, titled RottenTomatoesQNX, this one 
targeting the BlackBerry Tablet OS (see figure 7.12), and you’ll link your newly created 
RottenTomatoesLibrary to your application. 

234 
CHAPTER 7 Architecting multiscreen applications 
Figure 7.12 Target BlackBerry Tablet OS  
With your application created and the RottenTomatoesLibrary included with the 
project—as shown earlier in figure 7.10—you need to check one more step: that the QNX 
libraries are included with your application. If necessary, feel free to review these steps from 
chapter 
2 
outlined 
in 
the 
following 
link: 
http://www.adobe.com/devnet/air/articles/packaging-air-apps-blackberry.html. 
As a final check, go to the Project Properties > Flex Build Packaging > BlackBerry Tablet 
OS. If everything is set up properly and the required libraries are included, then your options 
will match those in figure 7.13. 
Figure 7.13 BlackBerry packaging options 

Architecting multiscreen applications  
235 
You can now move forward with the creation of your application. As before with the Android 
application, you’ll re-create your main application; copy over views, mediators, CSS files, 
and images; and finally create a new RottenTomatoesContext extending your base 
context. 
First, you’ll copy over the views and mediators that you created before in the platform-
agnostic application. Then, create your RottenTomatoesContext, ensuring to extend the 
base context (see the following listing). Properly extending the base context will ensure that 
all of the functionality from the library is available to you. 
Listing 7.4 RottenTomatoesContext.as 
package com.unitedmindset{ 
    import com.unitedmindset.views.*; 
    import com.unitedmindset.views.mediators.*; 
    import flash.display.DisplayObjectContainer; 
     
    public class RottenTomatoesContext extends RottenTomatoesBaseContext{ 
        public function RottenTomatoesContext(  
        contextView:DisplayObjectContainer=null,  
        autoStartup:Boolean=true){ 
            super(contextView, autoStartup); 
        } 
         
        override public function startup():void{ 
            super.startup(); 
             
    mediatorMap.mapView(RottenTomatoesQNX, 
        ApplicationMediator);                                             
    mediatorMap.mapView(BoxOfficeView, BoxOfficeMediator); 
    mediatorMap.mapView(CurrentDvdView, CurrentDvdMediator); 
    mediatorMap.mapView(DetailsView, DetailsMediator); 
    mediatorMap.mapView(InTheatersView, InTheatersMediator); 
    mediatorMap.mapView(MainMenuView, MainMenuMediator); 
    mediatorMap.mapView(NewDvdView, NewDvdMediator); 
    mediatorMap.mapView(OpeningNowView, OpeningNowMediator); 
    mediatorMap.mapView(SearchView, SearchMediator); 
    mediatorMap.mapView(TopRentalsView, TopRentalsMediator); 
    mediatorMap.mapView(UpcomingTheatersView, UpcomingTheatersMediator); 
    mediatorMap.mapView(UpcomingDvdView, UpcomingDvdMediator); 
        } 
    } 
} 
{chap 7 QNX code}/src/com/unitedmindset/com/unitedmindset/RottenTomatoesContext.as
With these two steps complete, you’ll re-create your application before customizing your 
views for the QNX platform, as show in the following listing. 
Update ApplicationMediator’s view injection 

236 
CHAPTER 7 Architecting multiscreen applications 
Listing 7.5 RottenTomatoesQNX.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark" 
    preloader="spark.preloaders.SplashScreen" 
    splashScreenImage="@Embed('/assets/images/splashscreen.png')"  
    xmlns:unitedmindset="com.unitedmindset.*"> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    <unitedmindset:RottenTomatoesContext contextView="{this}"/> 
    </fx:Declarations> 
    <fx:Style source="/assets/css/main.css"/> 
    <s:SplitViewNavigator autoHideFirstViewNavigator="true" 
        width="100%" height="100%" 
        id="splitViewNavigator"> 
        <s:ViewNavigator width="250" height="100%" id="menuNavigator"  
            firstView="com.unitedmindset.views.MainMenuView"/> 
        <s:ViewNavigator width="100%" height="100%" id="navigator"/> 
    </s:SplitViewNavigator> 
</s:Application> 
{chap 7 QNX code}/src/com/unitedmindset/RottenTomatoesQNX.mxml 
Your QNX application is now ready for use and currently looks and feels just like the 
platform-agnostic application. In the next section you’ll customize the views to work 
specifically for the QNX platform. 
7.4.2 
Customizing the view/mediators for QNX capabilities 
You can now customize your views to fit the QNX platform and the gesture swipes. For your 
application you’ll give the user the ability to bring up a menu and page through the results. 
To do this you’ll add a pop-up to the ListBaseView, providing a menu to each of your list 
views. Then you’ll add the coding into your mediators to enable the menu slide-in and slide-
out functionality. 
EFFECTS AND UI 
For a touch of class you’ll have your menu slide in and bounce out using Flex Spark Effects. 
These effects, such as move, rotate, and fade effects, allow you to set the duration of the 
effect along with the starting and ending points. You’ll add these effects into your 
ListBaseView.mxml declarations to use them on the menu pop-up in the next part: 
<fx:Declarations> 
    <s:Sine id="sine"/> 
    <s:Bounce id="bounce"/> 
    <s:Move id="slideIn" easer="{bounce}"/> 
    <s:Move id="slideOut" easer="{sine}"/>
</fx:Declarations> 

Architecting multiscreen applications  
237 
With your effects ready, you can add your menu into the view. You wrap the menu in a 
PopupAnchor component for two reasons: to bring up the menu over the rest of the user 
interface components, and to set an anchor where the component needs to pop up: 
. . . 
    <s:ActionBar id="bottomActionBar" width="100%"/> 
</s:VGroup> 
<s:PopUpAnchor width="100%" popUpPosition="below" 
        id="menuPopup" popUpWidthMatchesAnchorWidth="true"> 
    <s:ActionBar chromeColor="#000000" id="menuGroup"> 
        <s:actionContent> 
            <s:Button label="Previous Page" id="previousPage"/> 
            <s:Button label="Next Page" id="nextPage"/> 
        </s:actionContent> 
    </s:ActionBar> 
</s:PopUpAnchor> 
. . . 
You can now add the logic into your mediator to run your menu. 
MENU-HANDLING LOGIC 
To show and hide the menu in your Android application you just toggle the visibility of the 
menu. For the QNX platform, you’ll pop up the menu when a user swipes down on their 
tablet. This process isn’t difficult but does have many steps: you must listen to the swipe 
event, respond to the swipe event, and then toggle the menu depending on its state. 
First, you’ll add into the onRegister() and onRemove() methods your functionality to 
add and remove your events listeners: 
override public function onRegister():void{ 
    . . . 
    view.slideOut.addEventListener(EffectEvent.EFFECT_END,  
    _onSlideOut_CompleteHandler); 
    _addQnxHandlers(); 
    . . . 
} 
override public function onRemove():void{ 
    . . . 
    view.slideOut.removeEventListener(EffectEvent.EFFECT_END, 
     _onSlideOut_CompleteHandler); 
    _removeQnxHandlers(); 
    . . . 
} 
The 
functionality 
to 
add 
the 
swipe 
is 
extremely 
simple. 
Implementing 
the 
_addQnxHandlers() and _removeQnxHandlers() to add and remove the required 
listeners is shown in the following listing. 

238 
CHAPTER 7 Architecting multiscreen applications 
Listing 7.6 Add and remove swipe handlers 
private function _addQnxHandlers():void{ 
    try{ 
        var c:Class = getDefinitionByName("qnx.system.QNXApplication") 
         as Class; 
        var q:QNXApplication;                                             
        c.qnxApplication.addEventListener(  
        QNXApplicationEvent.SWIPE_DOWN,  
        _onView_SwipeDownHandler);                                        
    } catch(error:Error){ 
        //do nothing 
    } 
} 
private function _removeQnxHandlers():void{ 
    try{ 
        var c:Class = getDefinitionByName("qnx.system.QNXApplication") 
        as Class; 
        var q:QNXApplication; 
        c.qnxApplication.removeEventListener(  
        QNXApplicationEvent.SWIPE_DOWN,  
        _onView_SwipeDownHandler);                                        
    } catch(error:Error){ 
        //do nothing 
    } 
} 
Now, when the swipe occurs, you toggle the menu’s visibility: 
private function _onView_SwipeDownHandler(event:QNXApplicationEvent):void{ 
    _toggleMenu(); 
} 
The toggle functionality is semi-complex and is dependent on whether you’re showing or 
hiding the menu. When you show the menu, you tell the pop-up to display, configure the 
slide-in effect, and set the state and listeners of the previous and next buttons. Then when 
you’re hiding the menu, you remove the listeners from the previous and next buttons, 
because they’ll be destroyed, and run the slide-out effect (see listing 7.7). The reason you 
add and remove the button’s listeners in this code rather than the onRegister() and 
onRemove() methods is that these buttons will be created and destroyed by the 
PopupAnchor component and will not be available when the onRegister() method is 
called. 
Listing 7.7 Toggle menu visibility 
private function _toggleMenu():void{ 
    if(view.menuPopup.displayPopUp)                                       
Get access to the QNX application 
Add swipe listener 
Remove swipe listener 
Toggle menu based on current 
visibility

Architecting multiscreen applications  
239 
        _hideMenu(); 
    else 
        _showMenu(); 
} 
private function _hideMenu():void{ 
    if(view.menuPopup.displayPopUp){ 
    view.nextPage.removeEventListener(MouseEvent.CLICK,  
    _onNextPage);                                                         
    view.previousPage.removeEventListener(MouseEvent.CLICK,  
    _onPreviousPage); 
         
    view.slideOut.yFrom = 0; 
    view.slideOut.yTo = -view.menuGroup.height;                           
    view.slideOut.play([view.menuGroup]); 
    } 
} 
private function _showMenu():void{ 
    view.menuPopup.displayPopUp = true;                                   
     
    view.slideIn.yFrom = -view.menuGroup.height;                          
    view.slideIn.yTo = 0; 
    view.slideIn.play([view.menuGroup]); 
     
    view.nextPage.addEventListener(MouseEvent.CLICK,  
    _onNextPage);                                                         
    view.previousPage.addEventListener(MouseEvent.CLICK, _onPreviousPage); 
    view.nextPage.enabled = model.isNextPage(); 
    view.previousPage.enabled = model.isPrevPage(); 
} 
When the slide-out effect is complete, you set the popped-up menu’s display to false, 
ensuring that the menu is removed completely: 
private function _onSlideOut_CompleteHandler(event:EffectEvent):void{ 
    view.menuPopup.displayPopUp = false; 
} 
With this code complete, your menu shows and hides completely based on the QNX bevel 
swipe event. To enable the paging functionality, the last code you add into your mediator will 
respond to the page button click handlers. Because the functionality is already coded into 
your model, the code in the handler methods is extremely simple: 
private function _onNextPage(event:MouseEvent):void{ 
    model.getNextPage(); 
} 
Remove listeners 
Configure and run effect 
Display pop-up 
Run slide-in effect 
Add listeners and paging button’s state 

240 
CHAPTER 7 Architecting multiscreen applications 
private function _onPreviousPage(event:MouseEvent):void{ 
    model.getPrevPage(); 
} 
Now that you’ve finished your QNX platform-specific code, you have two platform-specific 
applications written and ready for deployment. In the next section you’ll complete the third 
platform in the series, making the iOS-specific customizations. 
Embedded images 
Currently the only QNX device, BlackBerry PlayBook, supports only the 240 DPI setting. If 
you want, this would be a good time to remove any 160 DPI and 320 DPI code and 
images from your application, keeping your final release file as small as possible. 
7.5 
Creating your iOS-specific application 
With your library ready and the other platform-specific applications finished, the only thing 
left to do is create a mobile application specifically for the iOS platform. For the iOS platform 
you’ll take the same steps that you did in previous sections, fully utilize the iOS platform’s 
user interface with a slightly customized CSS sheet. 
To get started you’ll create a new Flex Mobile project targeting the iOS platform called 
RottenTomatoesIOS (see figure 7.14). 
Figure 7.14 New project targeting the iOS platform 
After ensuring that your application includes a reference to the RottenTomatoesLibrary
(see figure 7.10), you can move to the next section and re-create your application prior to 
customizing your application. 
In the next section you’ll re-create your application by creating a subclass to your 
RottenTomatoesBaseContext and moving over your views from your platform-agnostic 
project. 

Architecting multiscreen applications  
241 
7.5.1 
Setting up the iOS platform application 
Building out your application from a blank project into a working iOS application will go by 
quickly. You only need to copy over your CSS file, images, views, and mediators, then create 
a new context, and re-create your main application to match the platform-agnostic 
application used prior to your customization. 
After copying and pasting over the required files, you’ll create the new context to tie 
together all of the platform-agnostic views and mediators that you have ready in your 
application (see the following listing). 
Listing 7.8 RottenTomatoesContext.as 
package com.unitedmindset{ 
    import com.unitedmindset.views.*; 
    import com.unitedmindset.views.mediators.*; 
    import flash.display.DisplayObjectContainer; 
     
    public class RottenTomatoesContext extends  
        RottenTomatoesBaseContext{                                        
        public function RottenTomatoesContext(  
        contextView:DisplayObjectContainer=null,  
        autoStartup:Boolean=true){ 
            super(contextView, autoStartup); 
        } 
         
        override public function startup():void{ 
            super.startup();                                              
             
    mediatorMap.mapView(RottenTomatoesIOS,  
        ApplicationMediator);                                             
    mediatorMap.mapView(BoxOfficeView, BoxOfficeMediator);                
    mediatorMap.mapView(CurrentDvdView, CurrentDvdMediator);              
    mediatorMap.mapView(DetailsView, DetailsMediator);                    
    mediatorMap.mapView(InTheatersView, InTheatersMediator);              
    mediatorMap.mapView(MainMenuView, MainMenuMediator);                  
    mediatorMap.mapView(NewDvdView, NewDvdMediator);                      
    mediatorMap.mapView(OpeningNowView, OpeningNowMediator);              
    mediatorMap.mapView(SearchView, SearchMediator);                      
    mediatorMap.mapView(TopRentalsView, TopRentalsMediator);              
    mediatorMap.mapView(UpcomingDvdView, UpcomingDvdMediator);            
    mediatorMap.mapView(UpcomingTheatersView, UpcomingTheatersMediator); 
        } 
    } 
} 
{chap 7 iOS code}/src/com/unitedmindset/com/unitedmindset/RottenTomatoesContext.as
Extend library’s base context 
Include startup configuration 
Update ApplicationMediator’s view injection 
Map 
customized 
views to 
mediators

242 
CHAPTER 7 Architecting multiscreen applications 
The first two steps to re-creating your application are complete. The final step is to include 
the new context, kicking off your entire application, as shown in the next listing. 
Listing 7.9 RottenTomatoesIOS.mxml 
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"  
    xmlns:s="library://ns.adobe.com/flex/spark" 
    preloader="spark.preloaders.SplashScreen" 
    splashScreenImage="@Embed('/assets/images/splashscreen.png')"  
    xmlns:unitedmindset="com.unitedmindset.*"> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    <unitedmindset:RottenTomatoesContext  
        contextView="{this}"/>                                            
    </fx:Declarations> 
    <fx:Style source="/assets/css/main.css"/> 
    <s:SplitViewNavigator autoHideFirstViewNavigator="true" 
        width="100%" height="100%"  
            id="splitViewNavigator">                                      
        <s:ViewNavigator width="250" height="100%" id="menuNavigator"  
            firstView="com.unitedmindset.views.MainMenuView"/> 
        <s:ViewNavigator width="100%" height="100%" id="navigator"/> 
    </s:SplitViewNavigator> 
</s:Application> 
{chap 7 iOS code}/src/com/unitedmindset/RottenTomatoesIOS.as 
You’ve fully re-created the base application that you made in the last chapter. In the next 
section you’ll customize the list views to include new menu and paging options designed to 
look like other iOS user interfaces. 
7.5.2 
Customizing the view/mediators for iOS capabilities 
With your application re-created you can now move away from the setup process and into 
the steps to customize the application. 
First, you go to the CSS file, main.css, and make a small change. Because you’ll want 
your buttons to look proper for the iOS platform, you’ll turn on the bevel look for your 
ActionBars: 
s|ActionBar{ 
    chromeColor: #327d00; 
    defaultButtonAppearance: beveled; 
} 
With this one-line addition, all of your buttons will have a beveled look, giving your 
application an iOS platform appearance. 
Next, you go to the ListBaseView.mxml file and add your menu along with the button 
necessary to bring up the menu. Because the iOS hardware doesn’t include a hardware menu 
iOS context 
Main navigator 

Architecting multiscreen applications  
243 
button in the same way as the Android platform, you need to give the application an 
onscreen menu button: 
. . . 
<s:navigationContent> 
    <s:Button id="homeButton" label="Menu" 
        includeInLayout="false" visible="false" 
        includeInLayout.portrait="true" visible.portrait="true"/> 
</s:navigationContent> 
<s:actionContent> 
    <s:Button label="Menu" id="menuButton"/> 
</s:actionContent> 
. . . 
Then you add the menu user interface that you’ll show when the user selects to bring up the 
menu: 
. . . 
    <s:ActionBar id="bottomActionBar" width="100%"/> 
</s:VGroup> 
<s:ActionBar id="menuGroup" 
             visible="false" 
             bottom="0" width="100%" 
             chromeColor="#999999"> 
    <s:actionContent> 
        <s:Button label="Previous Page" id="prevPageButton"/> 
        <s:Spacer width="10"/> 
        <s:Button label="Next Page" id="nextPageButton"/> 
    </s:actionContent> 
</s:ActionBar> 
. . . 
Window dressings 
As with the other menus in the Android and QNX sections, you could have spent much 
more time creating a custom menu that visually fits perfectly with the platform. But these 
details are outside of the scope of the book and don’t teach new theories. 
You’ll now move to the mediator to respond to the menu button’s click event and display the 
menu. 
First, you create the menu button’s handler event. When a user clicks the menu button, 
you toggle the visibility of the menu: 
private function _onMenuButton(event:MouseEvent):void{ 
    view.menuGroup.visible = (view.menuGroup.visible)?false:true; 
} 

244 
CHAPTER 7 Architecting multiscreen applications 
When the user clicks the next or previous button, you use your model and call for the new 
page: 
private function _onPrevButton(event:MouseEvent):void{ 
    model.getPrevPage(); 
} 
private function _onNextButton(event:MouseEvent):void{ 
    model.getNextPage(); 
} 
Because you want to ensure that the next and previous buttons are clickable only when the 
corresponding page exists, you return to your _setView() method and add in the checks 
for existing pages: 
private function _setView():void{ 
    . . . 
    view.nextPageButton.enabled = model.isNextPage(); 
    view.prevPageButton.enabled = model.isPrevPage(); 
} 
Finally, with the methods complete, you need to return to your onRegister() and 
onRemove() methods, adding in and removing the event listeners, respectively: 
override public function onRegister():void{ 
    . . .     
    view.menuButton.addEventListener(MouseEvent.CLICK, _onMenuButton); 
    view.prevPageButton.addEventListener(MouseEvent.CLICK, _onPrevButton); 
    view.nextPageButton.addEventListener(MouseEvent.CLICK, _onNextButton); 
    . . . 
} 
override public function onRemove():void{ 
    . . . 
view.menuButton.removeEventListener(MouseEvent.CLICK, _onMenuButton); 
view.prevPageButton.removeEventListener(MouseEvent.CLICK, _onPrevButton); 
view.nextPageButton.removeEventListener(MouseEvent.CLICK, _onNextButton); 
    . . . 
} 
Now when the user clicks the onscreen menu button, a menu will pop up at the bottom of 
the screen as expected, giving your user access to the list’s paging features. This wraps up 
the current iOS customizations. You could stop now and start the deployment process with 
an application that feels more native than a platform agnostic application. But it’s time to 
move on to the next chapter and add in some advanced features. 

Architecting multiscreen applications  
245 
7.6 
Summary 
With the splitting surgery, you now have a single application building from a central library 
that can easily be customized to various platforms. I understand that the level of 
customization shown in this chapter was minimal, but hopefully you now see that by building 
an application in this fashion, you can easily make changes as necessary to a specific 
platform’s user interface without hurting the customized experience of other applications. 
In the next chapter we’ll continue to look at advanced features that you can add to your 
application, including ways to access native code, track your user, and make money from 
advertising. 
Key takeaways: 

Creating a library 

Building projects off a central library 

Customizing platform-specific projects to the target platform 

246 
8  
Extending your mobile application 
This chapter covers 

Getting paid using mobile ads 

Tying into native extensions 

Gaining insight with user tracking 
Your mobile application is more powerful than ever. It’s currently running on Android, iOS, 
and QNX devices, and you have a repeatable formula for success across any device that 
comes your way. 
In this chapter you’ll add new features into the application. Fully utilizing the architecture 
that you’ve worked so hard to create, you’ll find that adding these additional features goes 
quickly and the final payoffs are vast—literally. In this chapter you’ll be adding ads into the 
application, accessing native extensions, and finally incorporating user tracking. 
8.1 
Making money by adding ads 
Whether you’re developing the next big multi-million-dollar idea or just a fun weekend 
project that a few other users may get a kick out of at some point, you’ll want to throw an 
advertisement into your application and make some extra revenue. Wonderfully simple, 
advertisements are widely accepted and a quick and easy way to monetize even the smallest 
applications. 
As you include ads in your application, there are some fine points you need to be aware 
of when making a decision as to what ads to integrate and where. 
8.1.1 
Not all platforms support ads 
Some platforms have checks to ensure that only specific ad systems are allowed on their 
devices. For example, AdMob, a popular mobile ad system, isn’t allowed on any BlackBerry 

Extending your mobile application  
247 
devices. This is specifically done because BlackBerry wants you to use their ad delivery 
system when you’re using their device.  
In case you didn’t see a good reason to split up the application by platform (chapter 7), 
I’m sure you now see a benefit.  
To solve this issue you can include the appropriate ad system by platform without 
affecting the other platforms. 
8.1.2 
Not all ad systems are created equal 
Depending on the ad system you choose, your monetary reimbursement may be wildly 
different.  
Typically, there are two ways that you get paid when displaying advertisements. The first 
is to get paid an amount per thousand (CPM) impressions that you deliver to your users. An 
impression in this case is just displaying the ad to the user without any interaction. 
The second way to get paid is based on the number of clicks that the advertisement 
receives—also known as CPC (cost per click). Each time a user clicks on your ad, you’re paid 
for the click. The money you’ll receive for a click is much higher than the money you’ll 
receive for impressions because the ad is being interacted with. 
Some ad systems pay different amounts for a variety of different ad interactions, and you 
need to determine which system works best for you and your application. 
8.1.3 
Be honest or be punished 
Some developers—not you, though—try to find ways to encourage users to click on 
advertisements or to show ads at an extremely high volume to bring up their pay. You can 
pass on the word to those other developers that ad content companies look down on this sort 
of thing and will take action against you. Always double-check all the legal agreements for 
your system of choice and ensure you’re complying with their terms and conditions. If these 
content providers feel you aren’t being honest, they may turn off your ads or even take legal 
recourse against you. 
For this section you’re going to use ads provided by Google AdSense to make some 
money from your application. At the time of writing this book I’ve found that Google AdSense 
is one of the higher-paying ad systems, has a consistent rate of displaying ads, and works 
well with multiple platforms—and it’s free to use. You’ll be able to include ads into the 
Android and iOS platforms using AdSense but not the QNX platform. If you’d like to include 
ads into the QNX platform application, please refer to the BlackBerry advertising platform. 
Returning to the application, you’ll integrate with Google AdSense and show 
moneymaking ads to the users. The process is simple and uses a component that you 
already fully know how to use, the StageWebView. 
Google AdSense shows ads through an HTML segment. You know that using 
StageWebView you can show HTML data directly in your application using WebKit. 
Therefore, you’ll first sign up with Google AdSense, then create an HTML page that includes 

248 
CHAPTER 8 Extending your mobile application 
your advertisement, and finally include your HTML page with StageWebView in your 
application. 
Moving right into our first section, we’ll look at the steps you need to take to generate 
your ad with Google. 
8.1.4 
Integrating with Google AdSense 
To use AdSense the first thing you need to do is sign up for their service. Because their 
requirements may change over time, I won’t talk about the signup process; make sure that 
you sign up at www.google.com/adsense. Unlike other services online that just want to know 
your name and email account, AdSense pays you for your work. Therefore, AdSense needs 
more information to ensure that they can legally pay you and that the taxman gets his cut. 
I’m taking this time to warn you, because they’ll be asking for your social security number or 
tax ID number and many other private pieces of data. For AdSense there’s a wait period 
while your information is verified; this policy varies by advertiser. 
If you’re OK with handing over this data, then please sign up, and you can move forward 
to create your ad in AdSense.  
Initially within your dashboard you can easily see information about your earnings, page 
views, CPC count, and other data. You’ll need to head to My Ads and create your new ad 
(see figure 8.1). 
Figure 8.1 Navigate to My Ads. 
Within My Ads you’ll select Mobile Content so you can create your new mobile ad content 
(see figure 8.2). 

Extending your mobile application  
249 
Figure 8.2 Head to Mobile Content. 
Next, click to create a new ad, and then you can start determining the look of your ad (see 
figure 8.3). 
Figure 8.3 Create a new ad. 
Now feel free to spend some time customizing your ad, including the size of the ad you’ll 
want to use and whether to show images, text, or both, and colors. The one setting to check 
is that your Device Type is set to iPhones and other highend devices only (see figure 8.4). 
Figure 8.4 Customize your ad settings. 

250 
CHAPTER 8 Extending your mobile application 
Creating ads per platform 
Depending on your business structure, this may not be possible, but I’ve found it helpful 
to create ads by platform, such as RottenTomatoesAndroid, RottenTomatoesNook, and 
RottenTomatoesIOS. This way you can see the monetary value in your reports by 
platform. This level of detailed information may be overkill for you, but I’ve found it 
helpful to know where my revenue is coming from. I find that I’m most interested in 
platforms that are paying the bills. 
Once you’ve finished customizing your ad, you’ll be given a script block that’s intended to be 
inserted into an HTML page (see the following listing). 
Listing 8.1 Ad script block 
<script type="text/javascript"><!-- 
// XHTML should not attempt to parse these strings, declare them CDATA. 
  /* <![CDATA[ */ 
  window.googleAfmcRequest = { 
    client: '{your publisher id}',                                        
    format: '{your format}',                                              
    output: 'html', 
    slotname: '{slot name}',  
  }; 
  /* ]]> */ 
//--></script> 
<script type="text/javascript"    
src="http://pagead2.googlesyndication.com/pagead/show_afmc_ads.js"></script
> 
For your application you’ll take this script block, but as yet you don’t have any HTML page to 
add it into. You’ll now move forward and create the HTML page needed to display your ad. 
8.1.5 
Creating the HTML page 
You need to build an HTML page to display your ad in your application. This part is extremely 
simple but it’s good to know some of the places where you can customize your HTML page 
without hurting your ad. 
The intent of AdSense is to display advertisements based on the content on the page and 
on other ads the user may have clicked on. Although you can’t effect other ads interacted 
with, you can affect the content that’s around your ad. 
In addition to the ad content, you may want to update the look of your application. By 
default, all HTML pages have a white background. If the application space that your ad is 
being shown in is white, then this works just fine, but if the background is something 
different, then you’ll need to set a different background color for your HTML page. In the 
following code listing you can see segments such as {Title} that you can edit with your 
own information. 
Your publisher name 
Ad format 

Extending your mobile application  
251 
Listing 8.2 HTML ad page 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<html xmlns="http://www.w3.org/1999/xhtml"> 
<head> 
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>  
    <title>{Title}</title>                                                
<meta name="description" content=" 
    {description metadata} "/>                                            
<meta name="keywords" content=" 
    {keywords metadata} "/>                                               
<script type="text/javascript">                                           
<!--    
// XHTML should not attempt to parse these strings, declare them CDATA. 
/* <![CDATA[ */    
window.googleAfmcRequest = { 
client: '{your publisher id}', 
format: '{your format}',     output: 'html', 
slotname: '{your slotname}', 
}; 
/* ]]> */ 
//--></script> 
<script type="text/javascript" 
src="http://pagead2.googlesyndication.com/pagead/show_afmc_ads.js"> 
</script> 
<style type="text/css">                                                   
body {  
margin: 0px; 
padding: 0px; 
background-color: #FFFFFF; 
} 
</style> 
</head> 
<body> 
<div style="display: none">{some text content}</div>                  
</body> 
</html> 
With your HTML page ready, put it up at your favorite web-hosting solution. Next, you’ll 
include your ad in your application. 
8.1.6 
Integrating ads into your application 
You can now return to your Rotten Tomatoes applications and include your ad. You’ll achieve 
this feature addition by updating two sections, your ListBaseView.mxml and your mediators. 
For this section I’ll only show how to make this update once, but you can include these 
additions in your Android and iOS applications. 
Arbitrary title, won’t be shown 
Description metadata 
Keywords metadata 
Script block provided by AdSense 
HTML page styles 
More ad content 

252 
CHAPTER 8 Extending your mobile application 
First, you’ll update your ListBaseView to include a container to hold your 
advertisement: 
. . . 
        </fx:Component> 
    </s:itemRenderer> 
</s:List> 
<s:Group id="adHolder" width="100%" height="75"/> 
<s:ActionBar id="bottomActionBar" width="100%"/> 
. . . 
The adHolder group will serve as a container for sizing and layout to overlay the ad. With 
your ad holder ready, you can move to your mediator and add some methods to create the 
ad, remove the ad, position the ad, and respond when the user clicks on the ad (see the 
following listing). 
Listing 8.3 Ad methods 
private var _adWebView:StageWebView;                                      
private var _adLocation:String = 
    "http://your.com/ad.html";                                            
private function _createAd():void { . . . }                               
private function _positionAd():void { . . . }                             
private function _destroyAd():void { . . . }                              
private function _onAdClick(event:LocationChangeEvent):void 
    { . . . }                                                             
private function _onResizeHandler(event:ResizeEvent):void 
    { . . . }                                                             
As you’ve learned from chapter 4, when you include a website, you need to use a 
StageWebView. You’ll next create the StageWebView, set its location, and show the ad to 
the user: 
import flash.events.LocationChangeEvent; 
import flash.media.StageWebView; 
import mx.events.ResizeEvent; 
private function _createAd():void{ 
    view.addEventListener(ResizeEvent.RESIZE, _onResizeHandler); 
    if(!_adWebView){ 
        _adWebView = new StageWebView(); 
        _adWebView.loadURL( _adLocation ); 
_adWebView.addEventListener( 
LocationChangeEvent.LOCATION_CHANGE, _onAdClick); 
    } 
StageWebView instance 
Location of your ad 
Creates the ad 
Positions the ad 
Destroys the ad 
Handles user click on ad 
Repositions ad on resize 

Extending your mobile application  
253 
    _positionAd(); 
    _adWebView.stage = view.stage; 
} 
When you create the ad, you position it over the adHolder that you included in the 
ListBaseView: 
import flash.geom.Point; 
import flash.geom.Rectangle; 
private function _positionAd():void{ 
   if(_adWebView){ 
         var p:Point = view.localToGlobal(new Point(view.adHolder.x, 
         view.adHolder.y));                                               
         _adWebView.viewPort = new Rectangle(p.x, p.y, view.adHolder.width, 
         view.adHolder.height);                                           
    } 
} 
If the view changes orientation or resizes in any way, then you’ll reposition the ad to again 
properly float over the ad holder: 
private function _onResizeHandler(event:ResizeEvent):void{ 
   view.callLater(_positionAd);                                          
} 
When you need to remove the ad, you can safely remove the StageWebView with the 
_destroyAd() method: 
private function _destroyAd():void{ 
    view.removeEventListener(ResizeEvent.RESIZE, _onResizeHandler); 
    if(_adWebView){ 
        _adWebView.stage = null; 
        _adWebView.removeEventListener(  
        LocationChangeEvent.LOCATION_CHANGE, _onAdClick); 
        _adWebView = null; 
    } 
} 
Finally, when a user clicks on the ad, you need to go to the ad’s location using the device’s 
built-in web browser: 
import flash.net.URLRequest; 
import flash.net.navigateToURL; 
private function _onAdClick(event:LocationChangeEvent):void{ 
    if(event.location != _adLocation){                                    
        event.preventDefault();                                           
        navigateToURL( new URLRequest( event.location ) );                
        _adWebView.loadURL( _adLocation );                                
Reposition ad after movements 
Get global X & Y positions of adHolder 
Set ad over adHolder 

254 
CHAPTER 8 Extending your mobile application 
    } 
} 
With everything complete, you call the _createAd() method in the onRegister()
method and the _destroyAd() method in the onRemove() method: 
. . . 
override public function onRegister():void{ 
    . . . 
    _createAd(); 
} 
 
override public function onRemove():void{ 
    _destroyAd(); 
    . . . 
} 
. . . 
You’ve finished all the code necessary to display your ad within your mobile application. 
Remember that you must put your HTML page somewhere accessible. With this code 
complete, your advertisement is included in your application, and now you can start making 
money daily on your work. 
In the next section you’ll tie into your device’s native capabilities using a new feature 
introduced in AIR 3.0 called native extensions. 
8.2 
Native extensions 
The inclusion of native extensions is new to AIR 3.0. Native extensions allow you to include 
native code in your application to access native capabilities that may not already be exposed 
through AIR. This feature added to AIR 3.0 is extremely helpful if you have a custom device 
with custom features that you may need to integrate with Adobe AIR. 
Native code 
Originally it was intended that this section would include information detailing the native 
code necessary to create a native extension. But as anticipated, as soon as AIR 3.0 
released, new native extensions were released daily by various developers and Adobe 
herself. 
A 
continuous 
list of 
developed native extensions 
can 
be 
found 
at 
http://www.adobe.com/devnet/air/native-extensions-for-air.html. Rather than focus on 
the native code, we’ll focus on how to use the built native extensions. 
If you have an idea for a native extension, there are many articles posted by Adobe to 
help you create these new files. It would be a wonderful addition to the community if you 
helped fill any missing ANE files. 
When developed, native extensions compile into ANE (ActionScript Native Extension) files. 
ANE files are packaged with native code ready for use with AIR applications. Just because a 

Extending your mobile application  
255 
native extension is created doesn’t mean it was intended for all platforms. Depending on the 
code created, native extensions can be intended for a specific platform, multiple platforms, 
or all platforms. 
In the next section we’ll look at including a prepared ANE file into your application. For 
your application you’ll be using the Vibration native extension developed by Adobe to make 
your device vibrate when your data is updated. You can download the Vibration native 
extension 
at 
http://www.adobe.com/devnet/air/native-extensions-for-
air/extensions/vibration.html. The Vibration native extension is created for Android and iOS 
platforms, so again the changes you’re making are specifically for the Android and iOS 
applications—and again your platform separation pays off. 
8.2.1 
Including native extensions 
Including an ANE into your application is similar to including a typical SWC file except that 
there are a few more steps necessary to complete the task. When including ANE files you 
need to update two places before writing a single line of code. The first is the actual 
packaged ANE file that includes the native code, and the second is the application descriptor 
file. 
Before moving forward, ensure that you downloaded the Vibration.zip file from the Adobe 
native 
extension 
site 
and 
have 
the 
files 
listed 
in 
figure 
8.5, 
specifically 
the 
com.adobe.extension.Vibration.ane file. 
Figure 8.5 Native extension folder 
Using the project properties, we’ll first look at including the actual ANE file. 

256 
CHAPTER 8 Extending your mobile application 
INCLUDING THE ANE FILE 
To include an ANE file you open your project’s properties and adjust the Flex build paths (see 
figure 8.6). 
Figure 8.6 Flex build properties 
I’ve copied over to my project the file com.adobe.extensions.Vibration.ane into a new folder 
titled anes. To include any ANEs within the anes folder, you click the Add Folder button to 
include the anes folder (see figure 8.7). 

Extending your mobile application  
257 
Figure 8.7 Add ANEs dialog box 
With the anes folder included, you can use Flash Builder to inspect the ANE file and see what 
platform(s) the ANE supports, its identifier, and whether the ANE supports the AIR simulator 
(see figure 8.8). Remember, if the ANE doesn’t support the simulator, you can’t run the 
application in the simulator at all. 

258 
CHAPTER 8 Extending your mobile application 
Figure 8.8 ANE inspection 
Now your ANE is included with the application, and you can move forward to include the 
second part of the ANE, including the native extension in your application descriptor. 
INTEGRATING THE APPLICATION DESCRIPTOR 
Including the native extension in the Application Descriptor file is extremely simple. Open 
RottenTomatoesAndroid-app.xml and RottenTomatoesIOS-app.xml, and make sure the 
extensions tag is added into the application descriptors. Typically Flash Builder will 
automatically add in the <extensions/> tag if you’ve selected to update the application 
descriptor file (see figure 8.7). If you aren’t using Flash Builder and your IDE doesn’t fill in 
the <extensions/> tag for you, then add it yourself at the bottom of your application 
descriptors with the ANEs ID, as shown here: 
. . . 
    <extensions> 
    <extensionID>com.adobe.Vibration</extensionID> #A 
    </extensions> 
</application> 
#A The native extension’s ID 

Extending your mobile application  
259 
With this last addition your native extension is fully integrated with your application. For the 
iOS application you’re good to go, but for the Android application you definitely need to add 
the Vibration permission. This quick one-liner added into the Android manifest will allow your 
application access to the vibration feature: 
. . . 
<uses-permission android:name="android.permission.VIBRATE"/> 
. . . 
Not all ANEs will require adding permissions, but for this particular ANE you must add this 
specific permission. We can now move to the final section, which includes using the vibration 
code in your application. 
8.2.2 
Using a native extension 
You can now use a few lines of code and execute the vibration feature. Locate 
SearchMediator in either your Android or iOS application, and you can make your device 
vibrate when data returns from your service by adding the code in the following listing. 
Listing 8.4 SearchMediator.as with vibration 
. . . 
import com.adobe.nativeExtensions.Vibration; 
private var _vibrate:Vibration;                                           
private function _onSystem_ListChangedHandler(event:ModelUpdateEvent):void 
{ 
    _setView(); 
     
    if(Vibration.isSupported){                                            
        if(!_vibrate)                                                     
            _vibrate = new Vibration(); 
        _vibrate.vibrate( 500 );                                          
    } 
} 
. . . 
{chap 8 Android}/src/com/unitedmindset/views/mediators/SearchMediator.as
Running with native extensions provides the ability to integrate with any device feature. With 
this important AIR feature behind us, we can move forward to the next advanced feature: 
user tracking with Google Analytics. 
8.3 
Useful user tracking 
Understanding how your users use your application can change how you decide to add or 
remove features along the way. What issues your users may be experiencing and where 
you’re being successful in your efforts, along with the self-fulfillment of seeing people using 
your application, are extremely helpful to planning future versions of your application. 

260 
CHAPTER 8 Extending your mobile application 
When getting into user tracking, some developers (not us) quickly fall into the trap of 
tracking way too much information or tracking information that isn’t statistically helpful. 
Although the concepts of research methods, statistics, and A/B testing are outside the 
scope of this book, they’re all important concepts that I recommend looking into if you want 
to do some hard-hitting fact finding and application improvements based on the data you 
pull from your users. 
I love statistics! Where can I learn more? 
Many companies actively practice the testing methods and offer libraries of research on 
the matter. If you want to find out more about testing methodologies, you should start 
with some online searching. If you want to get in headfirst, you should take some college 
classes on the subject and continue to research books on the matter—I have. There’s an 
entire field of research on the subject. 
I would recommend doing some online searches for “a/b testing” to get you started; 
however as you delve into these fields you’ll find continual research into quantitative 
research methods and statistical analysis will become important. 
In the study of usage statistics you’ll find pretty quickly that, generally speaking, tracking 
each and every touch point is more than likely overkill. In addition, because each value you 
track adds additional service calls and data being held on an already taxed device, you 
should try to keep your tracking information to a minimum. 
I don’t want to insinuate that individual touch points aren’t important, though. If you’re 
trying to do some in-depth A/B testing on a specific view and trying to understand how a 
user fully interacts with your application, this level of detail may be helpful. But once this 
segment of usage testing is complete, it’s wise to clean up your tests and track only 
information that you’re actively investigating. 
In the case of your application you’ll track two types of events: specific user interactions 
and system-based events. User interaction events signify interactions taken by the user that 
happen on the view layer, such as tracking a touch point or button click. System-based 
events may track the data and return information based on result and fault events being 
thrown and other types of data. 
In this section you’ll use the Google Analytics for Flash library to send your tracking data 
to Google Analytics for later analysis. 
8.3.1 
Using Google Analytics for Flash 
For your application you’ll use the gaforflash library, created to utilize the Google Analytics 
API with ActionScript code. To fully use this library you’ll need to get the SWC file from 
http://code.google.com/p/gaforflash/
and 
then 
sign 
up 
with 
Google 
Analytics 
at 
http://www.google.com/analytics/. 

Extending your mobile application  
261 
In case you haven’t used it previously, Google Analytics is a free service that provides 
many different high-quality statistics about your users, their location, system capabilities, 
and usage trends (see figure 8.9). 
Figure 8.9 Google Analytics 
Once you’ve signed up for Google Analytics and created a profile, you’ll receive tracking 
information and code to put into your HTML page. Because you’re not building a website, the 
HTML code is worthless to you, but what you do need is your UA ID from the tracking 
information (see figure 8.10). 
Figure 8.10 Tracking info 
Profile by platform 
Depending on how you want to slice your data, this may not be necessary, but I prefer to 
have 
a 
profile 
per 
platform, 
such 
as 
RottenTomatoesAndroid 
and 
RottenTomatoesIOS. This gives me the ability to quickly understand the application 
usage by platform. 
With all of the required data ready to go, you can move back to your Rotten Tomatoes 
application and plug in your tracking information. 

262 
CHAPTER 8 Extending your mobile application 
8.3.2 
Plugging in tracking 
You’ll next create a new event, the TrackingEvent, to collect and distribute tracking 
information from the various parts of your application and route it back to your main 
ApplicationMediator (see figure 8.11). 
Figure 8.11 Tracking concept 
From figure 8.11 you can see that from anywhere in your application you may be firing your 
TrackingEvent to be caught by your singular ApplicationMediator and then sent to 
Google Analytics. Depending on the data you’re testing at the time, you may want to 
dispatch TrackingEvents from mediators for user interaction or from any other part of the 
application for data or service layer tracking.  
Next, you’ll create the TrackingEvent to distribute your tracking data. 
CREATING THE TRACKINGEVENT 
In your RottenTomatoesLibrary you’ll create your TrackingEvent (see listing 8.5). 
The TrackingEvent will have two different modes, tracking either events or pages. The 
page mode will let Google know when view changes occur, mimicking the same analytics 
you’d receive from changing web pages on normal websites. The event mode is different 
than typical analytics because you can completely customize the data sent and managed by 
Google Analytics. 
Listing 8.5 TrackingEvent.as 
package com.unitedmindset.events 
{ 
    import flash.events.Event; 
     
    public class TrackingEvent extends Event{ 

Extending your mobile application  
263 
        public static const PAGE:String = "page"; 
        public static const EVENT:String = "event"; 
         
        private var _category:String;                                     
        public function get category():String { return _category; } 
         
        private var _action:String;                                       
        public function get action():String { return _action; } 
         
        private var _label:String;                                        
        public function get label():String { return _label; } 
         
        private var _value:Number;                                        
        public function get value():Number { return _value; } 
         
        public function TrackingEvent(type:String, category:String, 
        action:String=null, label:String=null, value:Number=NaN, 
        bubbles:Boolean=false, cancelable:Boolean=false){ 
            super(type, bubbles, cancelable); 
            _category = category; 
            _action = action; 
            _label = label; 
            _value = value; 
        } 
         
        override public function clone():Event{ 
    return new TrackingEvent(type, category, action, label, value, bubbles,  
        cancelable); 
        } 
    } 
} 
{chap 8 Lib}/src/com/unitedmindset/events/TrackingEvent.as
The TrackingEvent includes four values to represent the information being tracked. The 
first value, category, represents groups of events or the page that is being viewed. The 
second value, action, is a string (paired with a category) used to track actions taken by 
your user. The third value, label, is an optional string that provides additional details for 
the category/action pairing. The final value, value, is an optional non-negative integer that 
associates numerical data with a tracking event – typically a unique GUID/ID number to 
identify individual users. You’ll now dispatch your TrackingEvent wherever you want to 
collect data about your application.  
INSERTING TRACKINGEVENT INTO YOUR COMMANDS 
If you’re like me, you probably like to keep your code as clean as possible, not littering up 
your beautiful application code with various code segments for side features like user 

264 
CHAPTER 8 Extending your mobile application 
tracking. To keep your code beautiful, you won’t put various tracking code segments in the 
models or services and instead put the tracking code into your commands. 
As with other steps we’ve discussed, we won’t show all the repetitive steps to this 
process, but instead just one that’s representative of your needs. 
For this example you’ll add tracking information to see how many times your user pulls 
what specific data, including the page number. This data is helpful for you to understand how 
often a user pulls data, and as a bonus you’ll know if your users look beyond the first page: 
import com.unitedmindset.events.TrackingEvent; 
import com.unitedmindset.utils.ViewNameUtil; 
override public function execute():void 
{ 
    dispatch( new TrackingEvent(TrackingEvent.EVENT, "Request Data",  
    ViewNameUtil.BOX_OFFICE_VIEW, "Page  
    "+event.page) );                                                      
     
    service.getBoxOfficeMovies(event.numOfResults, event.page); 
} 
With this one-line addition you can see what lists of data your users are interested in. Over 
time, if you find out that statistically most of your users only look as far as page 2 for 
movies, then you may consider pulling back more results and removing the paging feature 
for simplicity. 
PLUGGING THE TRACKINGEVENT INTO YOUR MEDIATORS 
Another set of data that you may want to track isn’t data-based but instead is based on user 
input. In this case you’ll want to put some tracking in your mediators, enabling tracking on a 
completely different level. Here you’ll add tracking to your ApplicationMediator to see 
when a user switches views by adding some tracking into your push view handling method: 
Page tracking 
Typically I’d create a new command to handle this specific event because of its interaction 
with the ApplicationStateModel. But I felt this would be a quick way to show page 
tracking and tracking in a mediator in one method.  
private function _onSystem_PushViewHandler(event:MoveToViewEvent):void 
{ 
    dispatch( new TrackingEvent(TrackingEvent.PAGE, 
        event.view) );                                                    
     
    switch(event.view) 
. . . 
Tracking event 
Page tracking 

Extending your mobile application  
265 
This tracking segment sends off information to Google Analytics whenever a user goes to a 
new view. With this data you can find which lists of data are more interesting for your users. 
With your tracking in place for your commands and page changes, you can move on to the 
next section, sending your data out to Google. 
8.3.3 
Integrating with tracking events in an application 
Because you’ll probably want to have per-platform tracking, you can’t put your tracking 
settings in the library. Instead you’ll put them in the application, specifically the 
ApplicationMediator, because you only need one instance of the tracker at a convenient 
location.  
For MVC purists 
Yes, the user tracking is a service and should go in your service layer. But in the interest 
of time and effort, you’re going to simplify your code and add this information in one 
convenient spot. If you’d like to create a new service for tracking and include the code 
there, that’s up to you. 
Within the ApplicationMediator you need to listen for the TrackingEvents that are 
fired from other parts of the application and send the data to Google. 
To include tracking into your application, you’ll include the tracker component and create 
it during the onRegister() method of the ApplicationMediator: 
. . . 
import com.google.analytics.GATracker; 
private var _tracker:GATracker;                                           
override public function onRegister():void{ 
    _tracker = new GATracker(view, "yourUA-ID”);                         
    eventDispatcher.addEventListener(TrackingEvent.PAGE,                 
    _onSystem_TrackingPageHandler);                                      
    eventDispatcher.addEventListener(TrackingEvent.EVENT,                
    _onSystem_TrackingEventHandler);                                      
. . . 
The GATracker requires two variables to create a new instance. The first parameter is a 
display object to connect the GATracker to, keeping the tracker from being garbage-
collected, and the second parameter is your UA ID. If you use an invalid ID, an error will be 
thrown. With these variables set, your tracking instance will be created, and you can route 
your tracking events to your tracker. 
Tracker instance 
Create 
tracker 
instance

266 
CHAPTER 8 Extending your mobile application 
Debug mode 
If you want to watch the tracking information as it’s sent out to ensure that the proper 
parameters are being sent, turn on debug mode when instantiating the GATracker. Set 
the GATracker to debug mode during instantiation: 
    _tracker = new GATracker(view, "yourUA-ID", "AS3", true); 
When running in debug mode no tracking data will be sent to Google; instead, a display 
object will be added to the application, outputting all the tracking information for you to 
see. 
While listening for the tracking event you’ll add two methods to handle these system events: 
private function _onSystem_TrackingPageHandler(event:TrackingEvent):void{ 
    _tracker.trackPageview(event.category); 
} 
private function _onSystem_TrackingEventHandler(event:TrackingEvent):void{ 
_tracker.trackEvent(event.category, event.action, event.label, 
event.value); 
} 
With these functions complete, you’ve successfully added tracking into your application, and 
within 24 hours you’ll be receiving tracking data. 
8.4 
Summary 
In this chapter you added three amazing advanced features that will make you money, 
access native features, and provide statistics about your users’ usage. Moving forward, you 
should be able to easily add any of these features into other mobile applications. 
Key takeaways: 

Making money with Google AdSense 

Using a StageWebView to display an ad 

Including native extensions 

Accessing native code 

User tracking with Google Analytics 

Debugging user tracking 

267 
9  
Effective unit testing 
This chapter covers 

Creating unit tests 

Making an assertion 

Synchronous and asynchronous tests 

Testing your code 
Currently your application shows Rotten Tomatoes data, uses the native capabilities of the 
device, makes you money, and runs on the QNX, Android, and iOS platforms. Although you 
could run straight to the next chapter and start deploying your application to the various 
markets, there’s something you’ll want to do first—ensure that even if you change one line of 
code later your application continues to run as expected.  
FlexUnit 4 
Built into Flash Builder is one of the most popular ActionScript-based unit-testing 
frameworks, called FlexUnit 4. The unit-testing code you’re using and the IDE built into 
Flash Builder both depend on this specific framework. If you want to see more about 
FlexUnit 4, visit their site: http://flexunit.org.  
For the remainder of the chapter I’ll refer to FlexUnit 4 as FlexUnit. 
This means it’s time to introduce unit testing into your application and verify that your code 
does exactly what we said it should do.  
9.1 
What is unit testing? 
Unit tests are code developed to run and verify that small units of code do what they’re 
supposed to by returning a specific value. Through unit tests you ensure that for all cases of 

268 
CHAPTER 9 Effective unit testing 
X your methods return Y successfully. If for some strange reason your method given value X 
doesn’t return Y, then the test fails and you know that this code needs additional 
development. As you build out unit tests, you ensure that you test against enough use cases 
that every possible value and permutation of your code is tested and ensured to run without 
fault. When developing unit tests, the more permutations that you write tests against, the 
stronger your test suite, and ultimately the more bug free your code will be. 
One benefit to unit testing is the ability to quickly check at any time in the development 
cycle whether your code is passing all of your possible use cases. If you refactor your code at 
the end of your changes, you can run your tests and feel comfortable that your changes 
won’t negatively impact the rest of the application. 
With the concept of unit testing down, let’s look at the various testing ideologies. It’s 
important to understand these ideologies so you can decide which ideology you’ll want to 
practice. 
9.1.1 
Test-driven development 
For the sake of time and learning, we jumped right into coding with this book and only now 
at the end are looking at unit testing. For some developers this practice is completely 
backwards from the normal development flow that’s test-centric. This other form of 
development is called test-driven development, or TDD. This widely-practiced form of 
development expects you to write all tests prior to writing functional code. By writing tests 
that you know will fail, followed by writing code designed to pass the tests, you’re allowing 
tests to drive development rather than just coding.  
Following best practices stated by TDD, ideally every function and feature would have 
tests, and when all the tests pass, the application is complete. Then as new features are 
added to the application, new tests are written and the application grows with the ability to 
ensure that each and every piece of functionality works as intended. 
9.1.2 
Test-behind development 
If test-driven development isn’t for you, this isn’t the end of the world; you may fall into a 
category of developers who write tests after coding is complete to double-check their code 
and to have proper tests prepared against future refactors. 
It’s good that you’re still writing tests to ensure that your code runs as expected, but now 
you’ve probably made your life harder by having to write all of your tests at the end of your 
development cycle. Mentally this can be taxing. 
9.1.3 
Flying blind 
You may be of the mindset that you adequately test functionality before continuing onto new 
sections of code. Although this is great practice, you may not take into account all the 
possible permutations that a function may come across, leaving possible bugs in your code. 
Well-written unit tests validate the far corners of your application that you may even forget 

Effective unit testing  
269 
are there. This is another reason why writing unit tests is helpful, protecting you from bugs 
that may be missed when running your application during development. 
Just because an application is small doesn’t mean that the application isn’t complex or 
that before every release you’ll be able to test each and every feature in every permutation, 
ensuring that your application is without error. It’s because you can’t test every possibility 
before every release that flying blind can quickly lead to small errors that cause big 
problems. It’s always considered best practice to write tests at some point against your code 
prior to initial release. 
Next, we’ll look at some of the terms we’ll be using when discussing unit testing. 
9.2 
Testing terms 
As we get into unit testing there are many new terms that you need to understand before 
rushing right into the code. Don’t worry if prior to now you haven’t heard the terms test 
suite, test case, or test method or have been unsure of what assert means. We’ll go into 
each one with code examples in the sections to follow. 
9.2.1 
Test suite 
A test suite is a collection of test cases combined to provide organization to your tests. When 
you’re working in teams, test suites are helpful because you can run particular suites of tests 
rather than all the possible tests, narrowing the tested code (see the following listing).  
Listing 9.1 Test suite example 
package test.unitedmindset{ 
    import test.unitedmindset.models.ApplicationStateModelTest; 
     
    [Suite] 
    [RunWith("org.flexunit.runners.Suite")]                               
    public class ModelsTestSuite{ 
    public var test1:test.unitedmindset.models.ApplicationStateModelTest; 
                                                                          
    } 
} 
Test suites usually cover feature sets or segments of code such as models or services. For 
test suites you don’t need to add instances of your tests, just a reference to the tests you’ll 
run within the suite. The suite will create and run the tests when necessary in no particular 
order. 
Because test suites are collections of test cases, we discuss text cases next. 
Metadata 
Test case to run 

270 
CHAPTER 9 Effective unit testing 
9.2.2 
Test case 
Test cases include a collection of test methods and typically correspond to classes. This 
means that a specific test case tests a specific class (see the following listing). 
Listing 9.2 Test case example 
package test.unitedmindset.models{ 
    public class ApplicationStateModelTest{ 
     
        [Before]                                                          
        public function setUp():void { . . . }                            
         
        [After]                                                           
        public function tearDown():void { . . . }                         
         
        [BeforeClass]                                                     
        public static function setUpBeforeClass():void { . . . }          
         
        [AfterClass]                                                      
        public static function tearDownAfterClass():void { . . . }        
         
        [Test]                                                            
        public function testMoveBackView():void { . . . }                 
    } 
} 
To reinforce this 1:1 ratio, test cases are typically named after their corresponding class. For 
example, 
if 
you 
were 
testing 
ApplicationStateModel.as, 
you’d 
have 
an 
ApplicationStateModelTest.as class as the test case. 
You’ll also find that many developers package their test cases in a way that mirrors the 
tested 
code. 
For 
example, 
if 
you 
were 
testing 
com.unitedmindset.models.ApplicationStateModel, then the related test would be 
the test.unitedmindset.models.ApplicationStateModelTest package.  
The first action I take when getting started with testing is to mirror my application’s 
com.* package structure. 
Test cases include collections of test methods. Next, we’ll break down a test method. 
9.2.3 
Test method 
A test method is a specific method that tests another method in the class that your test case 
mirrors. In this case if you’re testing the ApplicationStateModel, one such method 
you’d 
test 
is 
the 
moveBackView() 
method. 
Therefore, 
the 
test 
method 
for 
moveBackView() is testMoveBackView(). 
. . . 
[Test] 
Run before every test 
Run after every test 
Run once at beginning 
of all tests
Run once at end of all 
tests
A test method 

Effective unit testing  
271 
public function testMoveBackView():void { . . . } 
. . . 
Like the test case, test methods usually follow a simple naming convention: “test” + name of 
method + testing information + expected result. Using this naming convention, if you were 
to 
test 
the 
moveToView() 
method, 
you 
might 
create 
a 
test 
such 
as 
testMoveToViewNullDataNoEvent()—a test that provides no data and therefore fires no 
event. It’s common to include multiple tests per method in order to test a variety of 
situations. 
Always starting with the word test ensures that you know you’re testing and then what 
you’re testing. You check your anticipated value by using asserts. 
9.2.4 
Assert 
Asserts are the final and smallest pieces to unit testing, methods that validate that the value 
returned from your tested code is as you expect. 
. . . 
//MathFormulaUtil.addTwoNumbers(1,2) = 3 
Assert.assertEquals(3, MathFormulaUtil.addTwoNumbers(1,2)); 
. . . 
There are many kinds of assertions you can make, but ultimately for each assertion you need 
to explicitly state that based on a specific set of parameters you expect that the result will 
equal—or not equal—a specific value. 
Unit test purists typically include only one assert per test method so that test methods 
aren’t muddied up by trying to do too much testing in one test method. 
9.2.5 
What do you unit test? 
With a basic understanding of unit testing behind us, the next question should be, “So what 
do I unit test?” The short answer is, “Everything—every piece of code can be tested.” You 
can write tests for synchronous data, immediately returned from the method, or 
asynchronous data, returning data based on events. Using various testing methodologies 
such as mock objects, you can even test your services without relying on the Rotten 
Tomatoes data. 
If you find that you’re having a hard time writing tests against your code, the problem is 
probably that you’re trying to test too much in an individual test or that you’re writing code 
that isn’t testable. To solve the first issue, make sure that you’re testing individual units of 
code, and then testing will be easy. Solving your coding practices takes time, but when 
writing unit tests you’ll find new ways to code, writing better and testable code. 
In this chapter you’ll write tests against your existing code starting with synchronous 
tests and then moving onto asynchronous tests. In the following sections we’ll define the 
difference between synchronous and asynchronous tests and show how to code these tests. 

272 
CHAPTER 9 Effective unit testing 
9.3 
Synchronous unit tests 
Most unit tests are fairly straightforward; you call a function and check that the value 
returned from the function is correct. In this case you know exactly when the results from 
the method will be ready and can check the values at the appropriate time. 
For your first test you’ll need to create a new method in your application that will allow 
you to easily write a test. The method you’ll create will accept a MovieVO, one of the value 
objects provided by the RottenTomatoesAS3 SWC to represent a movie title returned by the 
RottenTomatoesService, and return a String with the movie’s rating and runtime 
formatted for display. 
Currently your lists in the Rotten Tomatoes application show a title and icon in your 
renderer. You’re going to show a second set of data in the message field, displaying the 
MPAA rating and movie runtime for users (see figure 9.1). 
Figure 9.1 Completed renderer 
First, you’ll create the RendererUtil class to provide a function for your item renderer’s 
messageFunction. 
9.3.1 
Creating a RendererUtil class 
The RendererUtil class is a simple class that holds static methods for renderer functions, 
formatting the renderer’s data into proper labels (see the following listing). 
Listing 9.3 RendererUtil.as 
package com.unitedmindset.utils{ 
    import com.rottentomatoes.vos.MovieVO; 
    public class RendererUtil{ 
        public static function movieMessageFunction(item:Object):String 
        { 
            if(item is MovieVO){                                       
                var movie:MovieVO = item as MovieVO; 
                 
                var label:String = ""; 
                if(movie.mpaaRating)                                   
                    label += "Rated: "+movie.mpaaRating; 
                if(movie.mpaaRating && movie.runtime) 
Verify you’re formatting a MovieVO 
Add the MPAA rating 

Effective unit testing  
273 
                    label += " "; 
                if(movie.runtime)                                      
                    label += "Runtime: "+movie.runtime+"min"; 
                return label; 
            } 
            return null; 
        }     
    } 
} 
{chap 9 Lib}/src/com/unitedmindset/utils/RendererUtil.as
With your renderer function created, you can return to your ListBaseView.mxml classes and 
include your function: 
. . . 
<s:IconItemRenderer 
    iconField="thumbnailPoster" 
    iconWidth="61" iconHeight="91" 
    labelField="title" 
    messageFunction="{RendererUtil.movieMessageFunction}"> 
    <fx:Script> 
    <![CDATA[ 
        import com.unitedmindset.utils.RendererUtil; 
    ]]> 
    </fx:Script> 
</s:IconItemRenderer> 
. . . 
This bit of development isn’t special or new, just window dressing. Next, you’ll create a unit 
test around your RendererUtil.movieMessageFunction(). 
9.3.2 
Testing a utility class 
With your utility class ready, you can use Flash Builder to help create your test case. Luckily 
for us, Flash Builder has a built-in wizard for creating test cases. 
To start the process you’ll create a new test case using your “new” menu (see figure 9.2). 
Add the runtime 

274 
CHAPTER 9 Effective unit testing 
Figure 9.2 New test case 
The first step in the wizard is to name your class (see figure 9.3). Then you’ll select the class 
you’re testing, RendererUtil.as, to move to the next step. By selecting the class you 
intend to test, the wizard can give you the option to select specific methods to create test 
methods for. 
Figure 9.3 New Test Case wizard 

Effective unit testing  
275 
Next, you’ll select the methods within the class that you intend to test. The wizard breaks 
down all possible methods within a class. You don’t need to select all of the methods because 
many of them don’t matter for your test case; you’ll select the movieMessageFunction 
method (see figure 9.4). 
Figure 9.4 Select methods 
The generated code is shown in the following listing. 
Listing 9.4 RendererUtilTest.as 
package test.unitedmindset.utils{ 
    import flexunit.framework.Assert; 
     
    public class RendererUtilTest{         
        [Before]                                                          
        public function setUp():void { }                                  
         
        [After]                                                           
        public function tearDown():void { }                               
         
        [BeforeClass]                                                     
        public static function setUpBeforeClass():void { }                
         
Code to run before every 
test
Code to run after every test 
Code to run 
once at the 
beginning

276 
CHAPTER 9 Effective unit testing 
        [AfterClass]                                                      
        public static function tearDownAfterClass():void { }              
         
        [Test]                                                            
        public function testMovieMessageFunction():void{                  
            Assert.fail("Test method Not yet implemented");               
        }                                                                 
    } 
} 
{chap 9 Lib}/src/test/unitedmindset/utils/RendererUtilTest.as
With your class set up, you can continue adding tests as necessary to ensure that your code 
does what you intend for it to do. Before writing additional code, you need to understand the 
generated code and the features that the code provides. 
ORDER OF OPERATION 
When you’re running your tests, the order of the tests doesn’t matter, though with the order 
attribute you can run tests in order. What matters is the sequence of methods that fire as 
you run your tests. When using all of the metadata tags, the order is shown in figure 9.5. 
Figure 9.5 Test sequence 
Understanding the order in which your tests fire is important. Next, we’ll look at the 
metadata tags that enable this order. You can use all of these tags or none of these tags 
when creating unit tests, although the functionality they provide is extremely helpful during 
unit testing. 
[BEFORECLASS] 
A method tagged with the [BeforeClass] metadata tag is run once at the beginning of the 
class. This is a great time to set up variables that will be used through all the tests, 
connections to databases, load WSDLs, and other one-time actions. 
There are other attributes that you can add to the [BeforeClass] tag such as order, 
description, timeout, async, ui, and any others that you may want to define: 
[BeforeClass(description="sets up functionality before all tests")] 
public static function setUpBeforeClass():void { } 
Code to run 
once at the end
Metadata 
signifying your 
test

Effective unit testing  
277 
[BEFORE] AND [AFTER] 
The [Before] metadata tag tells the FlexUnit framework to run the method once before 
each test, whereas the [After] metadata tag tells the framework to run the method once 
after each test. The reason why you’d want to run a method before and after each test is to 
properly set up, or reset, the test environment. The [Before] metadata tag paired with the 
[After] metadata tag is the perfect system to set up and tear down the test environment 
between each test. This is vitally important, because you wouldn’t want the values from 
earlier tests affecting later tests. 
You can add additional attributes to either of these tags, such as order, description, 
timeout, async, ui, and others you may want to define: 
[Before(description="sets up tester before each test")] 
public function setUp():void { } 
[After(description="tears down tester after each test")] 
public function tearDown():void { } 
[TEST] 
Methods tagged with the [Test] metadata tag are your actual tests. Methods tagged with 
the [Test] metadata tag are expecting to include Assert statements specifying the 
expected values of a test or—in the case of an asynchronous test—waiting for a method to 
run Assert statements. 
Like the other metadata-based methods, the [Test] metadata can have the order, 
description, timeout, async, 
or ui 
attribute along 
with 
the expects 
or 
dataProvider attribute: 
[Test(order=1,description="provides null")] 
public function testFunctionNull():void { } 
[Test(order=2,description="provides one", 
expects="flexunit.framework.AssertionFailedError")] 
public function testFunctionError():void { } 
[AFTERCLASS] 
The [AfterClass] metadata tag sets a method to run once at the end of the test class. 
Opposite of the [BeforeClass], this is a good place to close database connections, empty 
tables, and perform any other cleanup that may be necessary.  
Like the [BeforeClass] there are other attributes that you can add to the 
[AfterClass] tag such as order, description, timeout, async, ui, and any others 
that you may want to define. 
Now that you fully understand how to create a test case, you can return to your 
RendererUtilTest.as and add a few more tests. In this way, you can completely test 
your function, ensuring it works as intended (see the following listing). 

278 
CHAPTER 9 Effective unit testing 
Listing 9.5 Additional tests 
. . . 
import com.rottentomatoes.vos.MovieVO; 
import com.unitedmindset.utils.RendererUtil; 
public class RendererUtilTest 
{ 
. . . 
[Test] 
public function testMovieMessageFunctionNull():void{ 
    Assert.assertNull( RendererUtil.movieMessageFunction(null) );         
} 
[Test] 
public function testMovieMessageFunctionMovieWithNoMpaa():void{ 
    var movie:MovieVO = new MovieVO();                                    
    movie.mpaaRating = null;                                              
    movie.runtime = 100;                                                  
    Assert.assertEquals( "Runtime: 100min",                               
    RendererUtil.movieMessageFunction(movie) );                           
} 
[Test] 
public function testMovieMessageFunctionMovieWithNoRuntime():void{ 
    var movie:MovieVO = new MovieVO();                                    
    movie.mpaaRating = "PG";                                              
    movie.runtime = 0;                                                    
    Assert.assertEquals( "Rated: PG",                                     
    RendererUtil.movieMessageFunction(movie) );                           
} 
[Test] 
public function testMovieMessageFunctionCompleteMovie():void 
{ 
    var movie:MovieVO = new MovieVO();                                    
    movie.mpaaRating = "PG";                                              
    movie.runtime = 100;                                                  
    Assert.assertEquals( "Rated: PG Runtime: 100min",                     
    RendererUtil.movieMessageFunction(movie) );                           
} 
[Test] 
public function testMovieMessageFunctionString():void{ 
    Assert.assertNull( RendererUtil.movieMessageFunction("") ); 
} 
{chap 9 Lib}/src/test/unitedmindset/utils/RendererUtilTest.as

Effective unit testing  
279 
With these synchronous tests complete, you can be sure that if any code in the 
RendererUtil.movieMessageFunction() method changes, your tests will catch any errors 
that arise. 
In the next section you’ll create new tests to ensure that your services always work 
correctly. The difference in your service testing is that your services require asynchronous 
tests rather than your current synchronous tests. 
9.4 
Asynchronous test for event-driven tests 
In the last section creating a unit test was made simple because you knew exactly when the 
result would be ready for you. But, because of the asynchronous nature of ActionScript 
development, you can’t always be sure when or if a value will be available. In this case you 
need to tie into the event structure of ActionScript and create your tests in such a way that 
you can listen for events fired by the classes you’re testing. Then, when the events are fired, 
you can check that the expected values exist and your unit test is complete (see figure 9.6). 
Figure 9.6 Asynchronous tests 
You’ll next create a test case for one of your service calls using the [aysnc] tag. 
9.4.1 
Testing a service call 
Tests written against services are a bit different than other unit tests you may have created 
previously, because you probably don’t know the exact data that will be returned from the 
service. In the earlier synchronous unit test, you knew the exact value that would be 
returned from the method given the provided data, but in this case you know that the data 
returned will follow some guidelines but not the exact name of every title returned. 
Therefore, you won’t be strictly unit testing the returned data and instead will make sure 
that the data returned follows the guidelines you set and—where possible—the data 
matches. 
In this case you’ll be calling for titles that are currently in the box office. The quantity and 
names of the movies may change over time, but you know that you should expect a result 
and that no more than a specific quantity of movies should be returned. In your unit tests 

280 
CHAPTER 9 Effective unit testing 
you’ll ensure that you receive a response and that the number of results is less than the 
requested quantity; otherwise your test will fail. 
With the previous synchronous test the method you tested was completely self-enclosed 
requiring no setup or teardown. To complete the service unit tests you’ll need two things, an 
instance of the service and an event dispatcher, to serve as the event hub for your events. 
Replicating the central event dispatcher 
As you know, Robotlegs includes a single event dispatcher at the heart of the application. 
This is the same event dispatcher that you’re using to pass events all over your 
application. For your tests you aren’t creating a context or the rest of the application’s 
moving parts; you do this specifically so you can test the smallest amount of code 
possible, stopping your tests from being contaminated by extraneous code. Because the 
application’s central event dispatcher isn’t created and wired through the context, you’ll 
need to create your own event dispatcher and use it in place of the missing event 
dispatcher. From then on, you can listen to events from your own event dispatcher 
created and destroyed within your test case. 
You’ll want to create the service and the event dispatcher in the setup method and clean up 
the service and event dispatcher during the teardown process. In this way your test 
environment is cleaned up between each test method (see the following listing). Now you’ll 
create a test for your RotTomService in the test.unitedmindset.services package. 
Listing 9.6 Setup and teardown methods 
package test.unitedmindset.services 
{ 
    import com.rottentomatoes.events.RottenTomatoesFaultEvent; 
    import com.rottentomatoes.events.RottenTomatoesResultEvent; 
    import com.unitedmindset.events.ServiceResponseEvent; 
    import com.unitedmindset.services.RotTomService; 
    import flash.events.EventDispatcher; 
    import flashx.textLayout.debug.assert; 
    import flexunit.framework.Assert; 
    import org.flexunit.async.Async; 
     
public class RotTomServiceTest 
{         
private var _service:RotTomService; 
private var _serviceDispatcher:EventDispatcher; 
[Before] 
public function setUp():void{ 
    _serviceDispatcher = new EventDispatcher();                        
    _service = new RotTomService();                                    
Create the event dispatcher 
Create the service instance 

Effective unit testing  
281 
    _service.eventDispatcher = _serviceDispatcher;                     
} 
[After] 
public function tearDown():void{ 
    _service.eventDispatcher = null;                                   
    _serviceDispatcher = null; 
    _service = null; 
} 
} 
{chap 9 Lib}/src/test/unitedmindset/services/RotTomServiceTest.as 
You can now start writing the actual tests for your services. 
9.4.2 
Writing the tests 
Now comes the easy process of writing tests. Following best practices for unit testing, you’ll 
test various values around the possible value inflection point. This means that for the limit 
parameter, which is an integer, good values to test are -1, 0, 1, and some values around the 
maximum inflection point—in your case 10. By testing around the possible values, you 
ensure that all possibilities are covered. 
To test these four values you’ll create four unit tests, one for each value. Using a 
structure built into FlexUnit 4 specifically for asynchronous tests, you’ll use the 
Async.asyncHandler() method to call the result handler when a result returns or the 
timeout handler in case you want the test to fail if the asynchronous operation takes too 
long. Finally, when the result handler is called, you check that the result is of the proper type 
and that you have less than or equal to the requested quantity. The method you’re testing, 
_service.getBoxOfficeMovies(), should return a minimum of one movie regardless of 
the parameter value (see the following listing). 
Listing 9.7 Box office tests 
import com.rottentomatoes.events.RottenTomatoesResultEvent; 
import com.unitedmindset.events.ServiceResponseEvent;  
import flexunit.framework.Assert;  
import org.flexunit.async.Async;  
[Test(async)] 
public function testGetBoxOfficeMoviesRequest1():void{                    
    _serviceDispatcher.addEventListener(                                  
    ServiceResponseEvent.BOX_OFFICE_RESULT, Async.asyncHandler(this,      
   _onGetBoxOffice_resultHandler, 2000, {"expectedResult":1},            
    _onGetBoxOffice_timeoutHandler), false, 0, true);                     
    _service.getBoxOfficeMovies(1, 1);                                    
} 
Connect the event dispatcher 
Disconnect and destroy event dispatcher 
Requesting 1 result, 
expecting 1 result

282 
CHAPTER 9 Effective unit testing 
[Test(async)] 
public function testGetBoxOfficeMoviesRequest0():void{                    
    _serviceDispatcher.addEventListener(                                  
    ServiceResponseEvent.BOX_OFFICE_RESULT, Async.asyncHandler(this,      
    _onGetBoxOffice_resultHandler, 2000, {"expectedResult":1},            
    _onGetBoxOffice_timeoutHandler), false, 0, true);                     
    _service.getBoxOfficeMovies(0, 1);                                    
} 
[Test(async)] 
public function testGetBoxOfficeMoviesRequestNeg1():void{                 
    _serviceDispatcher.addEventListener(                                  
    ServiceResponseEvent.BOX_OFFICE_RESULT, Async.asyncHandler(this,      
    _onGetBoxOffice_resultHandler, 2000, {"expectedResult":1},            
    _onGetBoxOffice_timeoutHandler), false, 0, true);                     
    _service.getBoxOfficeMovies(-1, 1);                                   
} 
[Test(async)] 
public function testGetBoxOfficeMoviesRequest10():void{                   
    _serviceDispatcher.addEventListener(                                  
    ServiceResponseEvent.BOX_OFFICE_RESULT, Async.asyncHandler(this,      
    _onGetBoxOffice_resultHandler, 2000, {"expectedResult":10},           
    _onGetBoxOffice_timeoutHandler), false, 0, true);                     
    _service.getBoxOfficeMovies(10, 1);                                   
} 
private function _onGetBoxOffice_resultHandler(event:ServiceResponseEvent,  
    object:Object):void{                                                  
    Assert.assertTrue( event.payload is RottenTomatoesResultEvent );      
    Assert.assertTrue( (event.payload as RottenTomatoesResultEvent).result 
    is Array );                                                           
    Assert.assertTrue( ((event.payload as RottenTomatoesResultEvent).result 
    as Array).length <= object.expectedResult );                          
} 
private function _onGetBoxOffice_timeoutHandler(object:Object):void{      
    Assert.fail("Pending Box Office Service Never Occurred");             
}                                                                         
{chap 9 Lib}/src/test/unitedmindset/services/RotTomServiceTest.as
With this understanding you can create tests for the remainder of the service methods and 
your classes by using either asynchronous tests or synchronous tests. In the next section 
we’ll look at how to run the test you’ve created using Flash Builder. 
Requesting 0 results, 
expecting 1 result 
Requesting -1 
results, expecting 
1 result
Requesting 10 
results, expecting 
10 results
Test resulting values match request count 
Fail on timeout 

Effective unit testing  
283 
9.5 
Running tests from the IDE 
Your battery of tests is complete, or maybe you just started writing your first tests and you 
want some immediate gratification that you’re doing a good job. Either way, you need to 
understand how to run your tests so you can see what code is passing and what code is 
failing.  
There are two different ways you can run your unit test. The first way is to use the Flash 
Builder IDE to run your unit tests. When using Flash Builder, the IDE will generate a simple 
application to run your tests, run the application, receive information from the tests, and 
finally display the results. If you don’t want to use Flash Builder, then you can create the 
simple application yourself and use a FlexUnit-provided user interface to display the results. 
The FlexUnit user interface displays the results directly within an application in the same way 
that you’ve been running your current Rotten Tomatoes application. Either of these methods 
will accomplish the job, run your tests, and display the results. 
In this section we’ll look at using the IDE and handwriting the necessary application to 
execute your unit tests. 
9.5.1 
Using Flash Builder to run FlexUnit tests 
By now you’ve already seen how well Flash Builder integrates with FlexUnit by using Flash 
Builder to generate code for your FlexUnit tests. Now it’s time to go one step further and 
execute your developed FlexUnit tests using Flash Builder. 
Using the Package Explorer you need to select either a group or individual test suites, 
test cases, or even specific test methods (see figure 9.7). 
Figure 9.7 Selecting a test suite, test case, or test method 

284 
CHAPTER 9 Effective unit testing 
When you right-click any of these selections, Flash Builder will know that you’re intending to 
run a unit test, and you’ll have a new option enabled in Flash Builder: Execute FlexUnit Tests 
(see figure 9.8). 
No TestSuite 
In the download code I’ve included a TestSuite, but for the book we’ve skipped this 
class because showing the TestSuite doesn’t teach any new concepts. 
Figure 9.8 Execute FlexUnit tests 
Once you select this method, your Flash Builder will prepare and execute the test runner with 
your selected tests (see figure 9.9). 

Effective unit testing  
285 
Figure 9.9 Executing unit tests 
This is only one portion of the output that’s provided through Flash Builder. Within the 
FlexUnit Results tab you can see further details about your FlexUnit tests. These details show 
how long specific test methods took to run, how many tests passed or failed, and, if a test 
failed, what the results were next to the intended results (see figure 9.10). 
Figure 9.10 FlexUnit results with intended failure  
This wonderfully easy method for running unit tests will take away any reasons you have to 
not create unit tests for your application’s code. 

286 
CHAPTER 9 Effective unit testing 
If you’re an inquisitive developer, you’ve probably already noticed that Flash Builder 
created a new file for you called FlexUnitApplication.mxml. This generated file is the 
generated application that I touched on earlier that’s created by Flash Builder to run your 
tests (see the following listing). 
Listing 9.8 FlexUnitApplication 
<?xml version="1.0" encoding="utf-8"?> 
<!-- This is an auto generated file and isnt intended for modification. --> 
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
               xmlns:s="library://ns.adobe.com/flex/spark" 
               xmlns:flexui="flexunit.flexui.*" 
               creationComplete="onCreationComplete()"> 
    <fx:Script> 
    <![CDATA[ 
    import test.unitedmindset.utils.RendererUtilTest; 
             
    public function currentRunTestSuite():Array{                          
        var testsToRun:Array = new Array(); 
        testsToRun.push(test.unitedmindset.utils.RendererUtilTest); 
        return testsToRun; 
    } 
                     
    private function onCreationComplete():void{                           
        testRunner.runWithFlexUnit4Runner(currentRunTestSuite(),  
        "RottenTomatoesLibrary"); 
    } 
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <flexui:FlexUnitTestRunnerUISpark id="testRunner" portNumber="8765"> 
    </flexui:FlexUnitTestRunnerUISpark>                               
</s:Application> 
It’s not recommended to try to alter FlexUnitApplication because any changes will be 
automatically destroyed each time you execute your FlexUnitApplication. If you want 
to create a more permanent testing application that you can alter and personalize, it’s time 
to move into the next section. In the next section you’ll create a testing application that you 
can adjust to run any tests or subset of tests you wish and provide you the ability to 
personalize your application. 
Selects tests to run 
Runs FlexUnit tests 

Effective unit testing  
287 
9.5.2 
Creating an application to run FlexUnit tests 
Being able to run FlexUnit tests quickly is extremely helpful for the tester on the go, but 
what if you want to create a permanent testing harness that has more features than the 
quickly executed tests? In this case you need to create your own application.  
There are a few reasons to create your own application for FlexUnit tests. The first is to 
have an application prepared with a specific set of tests. When creating tests it’s fine to run 
immediate tests, but you may not want to share these tests with your entire team while 
they’re in development. Therefore these tests won’t be added into your test-running 
application yet. The second reason to create your own application for FlexUnit tests is to 
create an application that works with automated build systems. We’ll talk more about 
automated systems in chapter 12. Finally, you may want to create your own FlexUnit 
application to add some additional functionality, such as user authentication or specialized 
reporting. 
To get started you’ll need to create a new project to run your unit tests; you’ll name this 
new Flex Mobile project RottenTomatoesFlexUnit (see figure 9.11). 
Figure 9.11 New Flex Mobile project RottenTomatoesFlexUnit 
With your blank application you’ll first need to add the FlexUnit Runner component (see 
listing 9.9).  
Missing FlexUnitTestRunnerUIMobile 
Built into Flash Builder is a series of libraries required to enable FlexUnit. Whenever you 
select to create a FlexUnit class or execute FlexUnit tests, these libraries are included with 

288 
CHAPTER 9 Effective unit testing 
your project. If your project throws errors for the FlexUnitTestRunnerUIMobile
component, then you’re probably missing these libraries (see figure 9.12). You can get 
Flash Builder to include these libraries by selecting Execute FlexUnit Tests or starting to 
create a FlexUnit class. 
Figure 9.12 FlexUnit libraries 
This component executes the unit tests and displays results from the executed tests, as 
shown in the following listing. 
Listing 9.9 Blank Flex Mobile application with FlexUnit runner 
<?xml version="1.0" encoding="utf-8"?> 
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
                     xmlns:s="library://ns.adobe.com/flex/spark" 
                    xmlns:flexui="flexunit.flexui.*"> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <flexui:FlexUnitTestRunnerUIMobile id="runner">                       
    </flexui:FlexUnitTestRunnerUIMobile> 
</s:Application> 
{chap 9 FlexUnit}/src/RottenTomatoesFlexUnit.mxml
UI runner 

Effective unit testing  
289 
The FlexUnit test runner needs some additional data to run the tests. By populating the data
property with a special FirstViewDataVO component, you provide the test runner with an 
array of tests to run and the name of your tests: 
<flexui:FlexUnitTestRunnerUIMobile id="runner"> 
    <flexui:data> 
        <flexui:FirstViewDataVO tests="{currentRunTestSuite()}"  
                projectName="RottenTomatoesAppTests"/> 
    </flexui:data> 
</flexui:FlexUnitTestRunnerUIMobile> 
You also provide the function that creates the array of tests for your component: 
<fx:Script> 
<![CDATA[ 
. . . 
public function currentRunTestSuite():Array{ 
    var tests:Array = []; 
    tests.push(test.unitedmindset.utils.RendererUtilTest); 
    tests.push(test.unitedmindset.services.RotTomServiceTest); 
    . . . 
    return tests; 
} 
. . . 
]]> 
</fx:Script> 
That’s it. The only thing you need to do now is run your tests when the application’s 
creationComplete function fires: 
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
                     xmlns:s="library://ns.adobe.com/flex/spark" 
        creationComplete="creationCompleteHandler(event)"  
        xmlns:flexui="flexunit.flexui.*"> 
    <fx:Script> 
    <![CDATA[ 
    import mx.events.FlexEvent; 
    import test.unitedmindset.services.RotTomServiceTest; 
    import test.unitedmindset.utils.RendererUtilTest; 
             
    protected function creationCompleteHandler(event:FlexEvent):void{ 
        runner.runWithFlexUnit4Runner(); 
    } 
     
    public function currentRunTestSuite():Array{ 
    var tests:Array = []; 
    tests.push(test.unitedmindset.utils.RendererUtilTest); 
    tests.push(test.unitedmindset.services.RotTomServiceTest); 
    . . . 

290 
CHAPTER 9 Effective unit testing 
    return tests; 
} 
The results returned aren’t pretty, but they integrate directly back to Flash Builder and 
provide vital data: whether your tests passed or failed (see figure 9.13). Running your 
RottenTomatoesFlexUnit application the same way you’ve run your mobile applications 
before will provide the user interface you intended. 
Figure 9.13 Flex Mobile unit test results 
Your application can now run mobile-specific unit tests directly on your devices, supporting 
even mobile-specific hardware capabilities.  
9.6 
Summary 
You should be extremely excited about the new capabilities that you hold in your hands and 
within your application. The quality of your code when unit tested will increase many times 
over, and there are few joys in coding nearly as great as seeing your tests pass. 
In the next chapters you’ll take your perfect code and deploy your application to the 
various mobile markets. 
Key takeaways: 
 
Writing effective flex unit tests 
 
Running FlexUnit on mobile devices 

291 
10  
The almighty application descriptor 
This chapter covers 

Understanding mobile permissions 

General application descriptor settings 

Release extras 
Over the last chapters we’ve gone far beyond just creating a mobile application. Your 
application now includes many advanced features and the ability to validate the application 
using unit tests, but it can still fall flat on its face. This won’t be because of the code you’ve 
written, but instead because of the code you’ve yet to write. 
When preparing for deployment, you still have many advanced options beyond code 
development to take into account prior to making your first real release. Taking certificates 
and permissions into account, you need to investigate every last option to make sure that 
your first release is successful in every way possible. 
In this chapter we’ll discuss some of the general settings for the application descriptor, 
and then we’ll look at specific options by platform, giving your application that final special 
touch rarely utilized by other common applications. 
10.1 General application descriptor settings 
If you haven’t done AIR development previously, you probably didn’t even know that the 
application descriptor existed before diving into this book. If you’ve done AIR development 
on the desktop before, you’re probably used to just setting your application’s name and 
version number to get your application ready to go. 
In this section we’ll focus on the non-platform-specific settings within the application 
descriptor file before moving into the platform-specific settings. After this section you’ll be 
able to fly through the general settings in an application descriptor and feel comfortable 
making changes as necessary for your application. 

292 
CHAPTER 10 The almighty application dexcriptor 
10.1.1 AIR version 
The first bit of data within the application descriptor tells you the AIR version number that 
you’re targeting for your application. If for any reason you need to roll back, or forward, to a 
specific AIR version, you’ll find the value for this setting in the first line: 
<?xml version="1.0" encoding="utf-8" standalone="no"?> 
<application xmlns="http://ns.adobe.com/air/application/3.1"> 
. . . 
</application> 
From this segment of code you can immediately see that you’re targeting the AIR 3.1 release 
for your application. If AIR 3.1 isn’t installed on the device, then the device will go out into 
the various markets and try to update itself to the correct version number. 
MINIMUMPATCHLEVEL 
The other attribute that can be added to the application tag is minimumPatchLevel: 
<?xml version="1.0" encoding="utf-8" standalone="no"?> 
<application xmlns=http://ns.adobe.com/air/application/3.1 
    minimumPatchLevel=”123456”> 
. . . 
</application> 
If for some reason you need to target a specific patch within an AIR release, you can add this 
attribute with the specific patch number. If the AIR version and patch number on the device 
are lower than the requested values, your device will seek out the proper patch.  
10.1.2 The all-important application ID 
The application ID may seem too simple to talk about, but if you don’t give it enough 
respect, you’ll find yourself and your application in a lot of trouble. Located in your 
application descriptor file, the ID provides a unique identifier for the markets you’ll deploy 
to: 
<id>com.unitedmindset.RottenTomatoes</id> 
There are some caveats to the application ID that you should be aware of. 
THE APPLICATION ID MUST BE UNIQUE 
If two applications have the same ID, then you have an ID conflict. In case of conflicts, the 
market is smart enough to reject duplicate IDs. If you’re side-loading applications, your 
devices won’t allow you to install the second application. This means that if you create an 
application and set the ID to Gallery, there’s a high probability that this ID will conflict with 
the device’s Gallery application and your application won’t be loadable.  
To make your application’s ID unique, it’s recommended to always use reverse domain 
naming. This means if your company’s website is http://www.mycompany.com and the 

The almighty application descriptor 
293 
application’s name is Gallery, then the best ID for your application will be similar to 
com.mycompany.Gallery. 
APPLICATION ID CAN’T CHANGE ONCE YOUR APPLICATION IS DEPLOYED 
Your application name can change; application permissions and even every line of the 
underlying code can change, just not the application ID. If you deploy your application and 
there’s something as silly as a misspelling in your application ID, you have two choices. 
Leave the misspelling the way it is or upload an entirely different application to each market 
with the fixed ID. If this is the case, you’ll have to convince your users to install the different 
application in order to receive any updates. 
The biggest takeaway to this section is to make sure that your application ID is unique 
and correct before your first deployment to any market. 
10.1.3 Application name and filename 
After the application ID you get into the <filename/> and <name/> tags within your 
application descriptor. 
The <filename/> tag sets the name of the file once it’s installed on the mobile device. 
This value is important to the operating system, not your users. You can use letters, 
numbers, and some special characters for your filename but no spaces, and you can’t end 
with a period: 
<filename>rottentomatoes</filename> 
The <name/> tag sets the name of the application shown to the user on your mobile device:  
<name>Rotten Tomatoes</name> 
You can use spaces, numbers, and some special characters for the name of your application. 
This name can change between releases and is shown with your application icon. In section 
10.1.6 we’ll look further into the application icons. 
10.1.4 Version number 
Previously, for AIR development, you used the <versionLabel/> tag to set the value of 
your application’s version. The value of the version didn’t matter because you could set the 
value to be just about anything: v1, 1.0.0, or howdy doody. For mobile development you 
don’t care about <versionLabel/>. 
The <versionNumber/> is much stricter than the <versionLabel/> tag and very 
important for mobile development. The <versionNumber/> must be in a <0-999>.<0-
999>.<0-999> format: 
<versionNumber>1.0.0</versionNumber> 
As you release new versions of your application, you must increment the value of the 
<versionNumber/>. You don’t have to increment by 1 each time, but the newer version’s 
value must be greater than the older version’s value (see table 10.1). 

294 
CHAPTER 10 The almighty application dexcriptor 
Table 10.1 Correct and incorrect version incrementing 
Before 
After 
Correct 
1.0.0 
1.0.1 
Incorrect 
2.0.0 
1.9.999 
Correct 
1.3.5 
2.0.1 
10.1.5 Initial window settings 
The next section of settings will affect how the application is shown to the user in the 
<initialWindow/> tag: 
<initialWindow> 
    <content>[This value will be overwritten by Flash Builder  
    in the output app.xml]</content> 
    <autoOrients>true</autoOrients> 
    <fullScreen>false</fullScreen> 
    <softKeyboardBehavior>none</softKeyboardBehavior> 
    <renderMode>auto</renderMode> 
</initialWindow> 
The <initialWindow/> tag includes multiple settings for how to display your application 
on the mobile device. There are more tags available within the <initialWindow/>, but 
they’re ignored for mobile development. 
CONTENT 
The first value, <content/>, is set during the build process. This is the filename of the 
compiled application you’ll run. In chapter 12 we’ll look in depth at the <content/> tag 
during the build process, but for now just plan to not change this tag at all. 
AUTO-ORIENT AND ASPECT RATIO 
The second value, <autoOrients/>, can either be true or false. If it’s set to true, then 
as the user turns their device the application will receive orientation change events to 
reorient the user interface based on the device orientation.  
If the value is set to false, the application won’t receive the orientation change events 
and will stay in the initial orientation. Setting the <autoOrients/> to false is helpful for 
games or applications where you don’t want the orientation to change between landscape 
and portrait modes. 
This leads to the next, optional tag: <aspectRatio/>. If you decided that you don’t 
want the application to auto-orient and you want to ensure that the application runs in a 
specific orientation, then you need to add in the <aspectRatio/> tag; the two possible 
values are landscape and portrait. By setting the aspect ratio to landscape or 

The almighty application descriptor 
295 
portrait you explicitly set that the application will start in landscape or portrait mode 
respectively. 
FULL SCREEN 
The <fullScreen/> tag, either true or false, determines if your application will take the 
entire window or share the possible display space with the operating system’s status bar or 
any other user input elements. 
SOFT KEYBOARD BEHAVIOR 
The <softKeyboardBehavior/> tag determines the application functionality when a soft 
keyboard is shown to the user. 
The first option for the <softKeyboardBehavior/> tag is none. This means that no 
action will be taken by the hardware to make sure that the focused text input that requested 
the soft keyboard is visible onscreen. This is the recommended setting. When it’s set to none 
you’ll need to move the text input as necessary to ensure that the text being entered can be 
seen: 
<softKeyboardBehavior>none</softKeyboardBehavior> 
The other option for the <softKeyboardBehavior/> tag is pan. This means that the 
device will automatically pan and resize your application to bring the focused text input into 
view. This is the default setting if no tag is included in the <initialWindow/> tag.  
RENDER MODE 
The final setting, <renderMode/>, can make a monumental difference to your application’s 
rendering abilities. The three options for render mode are cpu, gpu, and the default, auto. 
By setting the render mode to gpu you’re explicitly telling the hardware to render your 
graphics rather than the CPU. Flex applications currently aren’t designed for GPU acceleration 
and will be slowed down by running on the GPU. It’s recommended to leave this value set to 
auto. 
10.1.6 Application icons 
One tag not to miss is the <icon/> tag. This tag includes the information for the various 
icons for your application. These are the icons that users will associate with your application 
when they try to find your icon in their list of available applications. 
Each platform uses a variety of icons of various sizes throughout the operating system to 
represent your application. It’s recommended to fill in each icon value rather than try to pick 
and choose which icons you support: 
<icon> 
    <image16x16>/assets/icons/icon16.png</image16x16> 
    <image32x32>/assets/icons/icon32.png</image32x32> 
    <image36x36>/assets/icons/icon36.png</image36x36> 
    <image48x48>/assets/icons/icon48.png</image48x48> 
    <image57x57>/assets/icons/icon57.png</image57x57> 

296 
CHAPTER 10 The almighty application dexcriptor 
    <image72x72>/assets/icons/icon72.png</image72x72> 
    <image114x114>/assets/icons/icon114.png</image114x114> 
    <image128x128>/assets/icons/icon128.png</image128x128> 
</icon> 
Depending on your icon, you may be able to use just one image scaled for each of the sizes, 
or you may decide to remake your icon based on the size. Either way, you’ll need each of the 
shown sizes to cover the various platforms. 
512 X 512 
I recommend first creating your icon at 512 x 512 and then scaling down. For the various 
stores this is the largest icon I’ve seen requested. If you have this size, you can scale 
down and cover all sizes rather than having to remake your icon to a larger size. 
10.1.7 Certificate file 
Outside of your application and the application descriptor files, the other important file you 
need to keep close to your chest is your certificate file. Your certificate uniquely identifies 
you, so if someone else gets access to your certificate and its password, any other malicious 
developer could impersonate you and your application. 
A malicious developer could release an update of your application without your 
permission to all of your users, getting usernames, passwords, credit cards numbers, and 
any other secure data that a malicious developer may want to exploit. Be sure to keep your 
certificate file and its accompanying password secure. 
Having discussed the certificate file and general permissions, we can move on to look at 
platform-specific permissions within the application descriptor, starting with Android. 
10.2 Customizing your Android permissions 
Within the application descriptor file is a section specifically devoted to the Android platform 
(see listing 10.1). As discussed in chapter 4, this is the section for permission tags, giving 
you access to Android device capabilities. In addition to permissions, you can add other tags 
to filter your application to specific devices and give your application even more features that 
are enabled only through your application descriptor. 
Listing 10.1 Android layout 
. . . 
<android>                                                                 
    <manifestAdditions><![CDATA[ 
        <manifest>                                                        
            <!—- permissions -->                                          
            <application>                                                 
                <!—- metadata --> 
                <activity>                                                
System metadata 
Array of manifest elements 
Manifests include your permissions 
and other filters
Application metadata 
Application activity Information and intents 

The almighty application descriptor 
297 
                    <!—- intents -->  
                </activity> 
            </application> 
        </manifest> 
    ]]></manifestAdditions> 
</android> 
. . . 
{chap 10 Android}/src/RottenTomatoesAndroid-app.xml
By the end of this section you’ll understand how to insert new permissions as necessary, 
filter your application within markets using Android support options, and finally enable some 
additional features using the application intents options. 
10.2.1 Available permissions 
Within the Android manifest tag you can add device permissions to your application. By 
default the application descriptor gives you a commented-out list of some of the most 
common Android permissions (see the following listing). 
Listing 10.2 Default Android permissions 
. . . 
<manifest android:installLocation="auto"> 
<uses-permission android:name="android.permission.INTERNET"/> 
<!— 
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/> 
<uses-permission android:name="android.permission.READ_PHONE_STATE"/> 
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/> 
<uses-permission android:name="android.permission.DISABLE_KEYGUARD"/> 
<uses-permission android:name="android.permission.WAKE_LOCK"/> 
<uses-permission android:name="android.permission.CAMERA"/> 
<uses-permission android:name="android.permission.RECORD_AUDIO"/> 
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/> 
<uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/> 
--> 
</manifest> 
. . . 
This isn’t the entire list of available permissions that your application can use; this is a 
simple list of a few of the most common. For the entire list, please reference the Android 
Developer Guide: http://developer.android.com/reference/android/Manifest.permission.html. 
When creating ANE files it’s important to remember that if your ANE requires a specific 
permission you must manually add it to your Android manifest file. 
In the next part we’ll look at the metadata you can add to filter your application within 
Android markets based on your own parameters. 

298 
CHAPTER 10 The almighty application dexcriptor 
10.2.2 Filtering permissions 
The Android manifest file holds power not just over how the application runs but also where 
it can run. Android markets use the manifest file to determine if the application should be 
available for download based on the target device. Ultimately there are two ways to filter an 
application that you’ll focus on: screen size or the features of the available hardware. 
SUPPORTS SCREENS 
One helpful filter is the <supports-screens/> filter. This filter allows you to determine 
specific screen sizes that you’ll support—meaning that if you want to just target phones or 
tablets, this is the tag to set that filter (see the following listing). 
Listing 10.3 Supports screens tag* 
<manifest android:installLocation="auto"> 
<supports-screens android:resizeable=["true"| "false"] 
                  android:smallScreens=["true" | "false"] 
                  android:normalScreens=["true" | "false"] 
                  android:largeScreens=["true" | "false"] 
                  android:xlargeScreens=["true" | "false"] 
                  android:anyDensity=["true" | "false"] 
                  android:requiresSmallestWidthDp="integer" 
                  android:compatibleWidthLimitDp="integer" 
                  android:largestWidthLimitDp="integer"/> 
<uses-permission . . ./> 
. . . 
</manifest> 
*From the Android Developer Guide 
If you wanted to filter your application to just a tablet, the following tag would accomplish 
this task: 
. . . 
<manifest android:installLocation="auto"> 
    <supports-screens android:smallScreens="false"  
            android:normalScreens= "false"  
            android:largeScreens="true"  
            android:xlargeScreens="true"  
            android:anyDensity="true" /> 
    . . . 
If you want to find out more information about the <supports-screens/> tag, you can 
read 
up 
on 
it 
in 
the 
Android 
Developer 
Guide: 
http://developer.android.com/guide/topics/manifest/supports-screens-element.html. 
Another filter option is to filter your application based on the device features rather than the 
screen size. 

The almighty application descriptor 
299 
USES FEATURES 
I would consider the <uses-features/> tag the most important filter for your applications. 
If your application relies heavily on the camera, why would you want users without a camera 
to be able to download your application? You wouldn’t. In this case you’ll use the <uses-
features/> tag to specify that you’re using a specific feature and are requiring this feature 
prior to download. 
As an example, if your application relies on GPS, then with a simple tag you can make 
sure that any devices without GPS support will be unable to view or download your 
application: 
<manifest android:installLocation="auto"> 
    . . . 
    <uses-feature android:required="true"  
            android:name="android.hardware.location.gps"/> 
    . . . 
There are many options available to you when filtering by device capability; to see the entire 
list 
visit 
the 
Android 
Developer 
Guide: 
http://developer.android.com/guide/topics/manifest/uses-feature-element.html. 
Be aware when using filters that you’re quickly reducing the number of users who can 
download the application. Furthermore, if you add a filter to later releases, existing users 
won’t be able to receive new updates. 
In the next section we’ll discuss additional features you can support that are enabled with 
the Android manifest file. 
10.2.3 Permission features 
There are additional features for your application that you can activate using the manifest file 
such as launching your application, determining the install location, and setting your 
application to run on multiple screens by default. There are more options, but with an 
understanding of these three options you can broaden your understanding for any other 
features. 
LAUNCHING APPLICATION 
Integrating your application into a larger system adds value to your application. If you’d like 
to launch your application from another application or website, the added convenience would 
wow users because they’d receive the information they want through their integrated device. 
This may already sound complicated, but you’ll use the idea of intents to launch your 
application. Intents are simple mechanisms within the Android system, similar to the events 
you’ve already been using. 
To activate this particular intent, you need a URL with a custom URI. This URI can be 
anything you want, and for your application you’ll use rottentomatoes. This means that 
anytime a user clicks a link that looks similar to rottentomatoes://some.extra.stuff, 
the Android system will know that your application needs to be launched.  

300 
CHAPTER 10 The almighty application dexcriptor 
In 
addition 
to 
launching 
the 
application, 
on 
the 
main 
application’s 
InvokeEvent.INVOKE event the arguments available past the rottentomatoes: custom 
URI are available from to the InvokeEvent. This helpful communication protocol provides 
an easy way to start an application and provide the application with some initial state data. 
To enable this functionality you’ll include a few extra tags in the Android manifest’s 
application tag, as shown in the following listing. 
Listing 10.4 Android application tag 
. . . 
<application> 
<activity android:excludeFromRecents="false">                             
<intent-filter> 
        <action android:name="android.intent.action.MAIN"/>               
        <category android:name="android.intent.category.LAUNCHER"/> 
    </intent-filter> 
    <intent-filter> 
        <action android:name="android.intent.action.VIEW"/> 
        <category android:name="android.intent.category.BROWSABLE"/>      
        <category android:name="android.intent.category.DEFAULT"/> 
        <data android:scheme="rottentomatoes"/>                           
    </intent-filter> 
</activity> 
</application> 
. . . 
{chap 10 Android}/src/RottenTomatoesAndroid-app.xml
With 
the 
options 
set, 
you 
can 
access 
the 
launch 
feature 
within 
your 
RottenTomatoesAndroid application (see the following listing). 
Listing 10.5 RottenTomatoesAndroid.mxml—access launch feature 
. . . 
private function _onView_preinitializeHandler(event:FlexEvent):void       
{ 
    NativeApplication.nativeApplication.addEventListener(  
    InvokeEvent.INVOKE, _onApp_invokeHandler);                            
} 
private function _onApp_invokeHandler(event:InvokeEvent):void 
{ 
    NativeApplication.nativeApplication.removeEventListener(  
    InvokeEvent.INVOKE, _onApp_invokeHandler);                            
    var arguements:Array = event.arguments;                               
    //do something 
} 
. . . 
Application tag 
Enable main 
launcher
Enable 
accessible 
from browser 
Your custom URI 
PreInitialize event from main application 
Listen to InvokeEvent 
Clean up InvokeEvent
listener 
Get arguments passed from 
URL 

The almighty application descriptor 
301 
{chap 10 Android}/src/RottenTomatoesAndroid.mxml
With this functionality wrapped up, you can now launch your application from other 
applications or even websites browsed by your user. In the next section, you’ll determine 
where the application can be installed on your device. 
INSTALL LOCATION 
This option of where the application is installed is available to you in the manifest elements. 
Based on your selection you can explicitly state that your application is installed only on the 
device, on the SD card (if one exists), or wherever the user prefers: 
. . . 
<manifestAdditions><![CDATA[ 
     <manifest android:installLocation="auto|preferExternal|internalOnly">
. . . 
By selecting between one of the three options, you can set the install location of your 
application. 
Beware the SD card 
You’ll notice that there are some applications that can be moved to the SD card and some 
that can’t. Data stored on the SD card can easily be removed from the device, because 
the SD card is easily removed, transferred to another computer or device, and eventually 
accessed. Furthermore, data stored to the SD card is set to be readable by any other 
application, again lowering the possible security threshold. 
Data secured on the device itself isn’t foolproof, but it’s much better secured than on the 
SD card. Depending on your data, make the decision that makes sense for your 
application and determine where your application can be installed. 
In the next section we’ll look at how changing Android metadata can affect an application for 
a specific device.  
DUAL-SCREEN SUPPORT 
The Sony Tablet S is different from any other currently available tablets because it has two 
screens instead of just one main screen. Specifically for the Sony Tablet S, metadata is 
available to enable the dual-screen functionality at startup. In the future there may be other 
tablets beyond the Sony Tablet S that include custom metadata to enable device-specific 
capabilities. 
Within the application tag you can include your new tag to enable the dual-screen 
capability: 
. . . 
<application android:enabled="true"> 
    <meta-data android:name="to.dualscreen" android:value="true"/> 
    <activity android:excludeFromRecents="false"> 

302 
CHAPTER 10 The almighty application dexcriptor 
        <intent-filter> 
        . . . 
For now this value affects only the Sony Tablet S, but in the future more manufacturers may 
use this application metadata to control device capabilities. 
With this thorough investigation into the Android permissions, you should feel 
comfortable making changes to your application’s permissions for the Android platform. With 
these changes you can customize what features your application can use, where your 
application can be found, and even what additional features it supports. Next, we’ll look at 
the QNX platform and manifest options. 
10.3 QNX permissions for deployment 
The QNX platform includes its own descriptor file beyond the normal application descriptor, 
called the blackberry-tablet.xml. This new file includes information about the splash screens, 
application permissions, and the catalog. 
In this section we’ll look at the permissions for the QNX platform, how to customize the 
splash screen and the application icon, and how to use the categories system built into the 
QNX platform to determine where your application can be found on your user’s device. 
10.3.1 Available permissions 
Unlike the Android platform, the QNX platform has a finite list of options for the device. 
These permissions, called actions within QNX, provide access to restricted functions for the 
application (see table 10.2). 
Table 10.2 QNX actions* 
Values 
Capability 
API 
access_shared 
Access the shared filesystem
The following APIs might require this 
permission if they try to access the 
shared directory: 
flash.filesystem.FileStream 
flash.filesystem.File 
flash.media.CameraRoll 
flash.media.CameraUI 
play_audio 
Access the audio controls
qnx.media.MediaControl 
flash.media.Sound 

The almighty application descriptor 
303 
read_device_ident
ifying_informatio
n 
Access the PIN and serial number 
of the tablet 
qnx.system.Device.pin 
qnx.system.Device.serialNumb
er 
read_geolocation 
Access the current location of the 
tablet 
flash.sensors.Geolocation 
record_audio 
Access the audio stream from the 
microphone 
flash.media.Microphone 
set_audio_volume 
Access the volume control 
qnx.media.MediaControl 
use_camera 
Access data from one or more 
cameras 
flash.media.Camera 
flash.media.CameraUI 
*All data is from the BlackBerry Developer Guide 
Now that you understand what actions are available, you need to return to the blackberry-
tablet.xml file and include the actions required by your application: 
<?xml version="1.0" encoding="UTF-8"?> 
<qnx> 
   . . . 
   <permission>access_internet</permission> 
. . . 
</qnx> 
With this line you’ve included the access_internet action as a permission, giving your 
application access to the entire internet. In the next section we’ll look at customizing your 
application using a custom splash screen and icon. 
10.3.2 QNX splash screen and icon 
QNX applications need two files to improve their visual appeal: the application icon and 
splash screen. The application icon is used within your device’s menu to help the user find 
your application. The splash screen is shown while the application is going through the 
loading process, giving your users feedback before even the splash screen preloader that we 
looked at in chapter 5. 

304 
CHAPTER 10 The almighty application dexcriptor 

The icon file needs to be a JPG or PNG file sized at 86 × 86. 

The splash screen needs to be a JPG or PNG file sized at 1024 × 600. 

A second optional splash screen can be included for portrait mode in JPG or PNG form 
sized at 600 × 1024. You separate the landscape and portrait files with a colon (:). 
With these files you can move to your blackberry-tablet.xml and include them within your 
application (see the following listing). 
Listing 10.6 Splash screen and icon files 
<?xml version="1.0" encoding="UTF-8"?> 
<qnx> 
    . . . 
    <icon> 
        <image>/assets/images/icons/icon86.png</image>                    
    </icon> 
    <splashscreen>/assets/images/landscape-splash.png: 
     /assets/images/portrait-splash.png </splashscreen>                   
    . . . 
</qnx> 
{chap 10 QNX}/src/blackberry-tablet.xml
Your splash screen and application icon are now ready, so we can move on to determine the 
category in which to include your application on the device. 
10.3.3 Categories 
Currently QNX devices support two categories for your applications: media and games (see 
the following listing). This affects how a user navigates to your application within the QNX 
operating system by looking in the “Media”, “Games”, or “All” category. 
Listing 10.7 Category tag 
<?xml version="1.0" encoding="UTF-8"?> 
<qnx> 
    . . . 
    <category>core.games</category> 
    . . . 
</qnx> 
{chap 10 QNX}/src/blackberry-tablet.xml
One caveat to using the <category/> tag is that you can select only one category, either 
core.games or core.media. The category tag is completely optional, but without the 
<category/> tag your app will only be discoverable in the “All” category. 
These tags include all the possible tags for the blackberry-tablet.xml. There are other 
tags such as the <author/>, <authorId/>, and <buildId/> that are necessary during 
the release process. We’ll touch on these tags in chapter 11. As a high-level overview, the 
Icon image 
Splash screen(s) 

The almighty application descriptor 
305 
<author/> tag represents the company you entered when signing up as a vendor with 
BlackBerry, and the <authorId/> represents the ID assigned by the signing authority 
during the signup process. Finally, the <buildId/> is a number that allows you increment 
build versions after signing with BlackBerry without changing the <versionNumber/> tag 
we discussed previously. 
With BlackBerry behind us, we can look at the permissions for iOS development. 
10.4 Key points to iOS permissions 
In the application descriptor file there’s a section specifically for the iOS platform within the 
<iPhone/> tag. The iOS platform doesn’t require feature permissions to access device 
capabilities such as camera and GPS, but with the iOS <infoAdditions/> tag you can 
make some changes to your application, how it looks, and what devices your application is 
able to run on. 
In this section we’ll look at how to filter your application specifically to iPhones or iPads, 
along with other various features for your application enabled by the <iPhone/> tag. 
10.4.1 Filtering by device 
There are only two categories of Apple devices that you need to worry about: iPhone 
(including the iPod Touch) and iPad (either the first iPad or the iPad 2). If you want to have 
an application available for only a specific set of devices, you can use the 
<InfoAdditions/> tag to filter your application from the App Store based on the user’s 
device.  
Using the <InfoAdditions/> tag, you can filter your application so that all of the tablet 
layout work isn’t wasted on phones with smaller screens: 
<iPhone> 
    <InfoAdditions><![CDATA[ 
        <key>UIDeviceFamily</key> 
            <array> 
            <string>1</string>                                            
            <string>2</string>                                            
        </array> 
        . . . 
    ]]></InfoAdditions> 
</iPhone> 
By including a 1, 2, or both, you can filter your application by device in the App Store. Next, 
you’ll use your <iPhone/> tag to further customize your application. 
1 to include iPhones and iPod Touch 
2 to include iPad 1 and iPad 2 

306 
CHAPTER 10 The almighty application dexcriptor 
10.4.2 Enabling features 
As you get down to the final steps before release every detail matters. Adjusting the values 
in the following subsections will give you control over fine-grain visual and application 
features that you may not have noticed until after your application hit the App Store. 
REQUIRE PERSISTENT WIFI 
By including the <UIRequiresPersistentWiFi/> tag, you specify that a Wi-Fi connection 
stays open the entire time your application is in use. This changes the default functionality, 
which will close the Wi-Fi connection after 30 minutes: 
<iPhone> 
    <InfoAdditions><![CDATA[ 
        . . . 
        <key>UIRequiresPersistentWiFi</key> 
        <true/> 
        . . . 
    ]]></InfoAdditions> 
</iPhone> 
EXIT ON SUSPEND 
By default, when a user hits the Home button, iOS applications are suspended and—
depending on system resources—eventually completely closed by the operating system. 
Using the UIApplicationExitsOnSuspend key, you can completely close the application 
instead of suspending when not being used: 
<iPhone> 
    <InfoAdditions><![CDATA[ 
        . . . 
        <key>UIApplicationExitsOnSuspend</key> 
        <true/> 
        . . . 
    ]]></InfoAdditions> 
</iPhone> 
STATUS BAR STYLE 
You could always hide the status bar by setting the application to run in full-screen mode, 
but with the iOS platform you can also control how the status bar looks to make it 
appropriate for your application’s UI. By default the status bar is a gray color: 
<iPhone> 
    <InfoAdditions><![CDATA[ 
        . . . 
        <key>UIStatusBarStyle</key> 
        <string>UIStatusBarStyleDefault</string> 
        . . . 
    ]]></InfoAdditions> 
</iPhone> 

The almighty application descriptor 
307 
You could also change the status bar to an opaque black color: 
<iPhone> 
    <InfoAdditions><![CDATA[ 
        . . . 
        <key>UIStatusBarStyle</key> 
        <string>UIStatusBarStyleBlackOpaque</string> 
        . . . 
    ]]></InfoAdditions> 
</iPhone> 
Or you could change the status bar to a black translucent color (alpha 0.5), showing the 
application’s background color through the status bar: 
<iPhone> 
    <InfoAdditions><![CDATA[ 
        . . . 
        <key>UIStatusBarStyle</key> 
        <string>UIStatusBarStyleBlackTranslucent</string> 
        . . . 
    ]]></InfoAdditions> 
</iPhone> 
PRERENDERED ICON 
No matter the design of your application’s icon, Apple will adjust your application icon to fit 
with the Apple way of doing things. To fit the Apple way, your application icon will be given 
rounded corners and a nice highlight by default.  
The rounded corners can’t be changed but the highlight can. If you don’t want the 
highlight, you can remove it by using the UIPrerendereredIcon key: 
<iPhone> 
    <InfoAdditions><![CDATA[ 
        . . . 
        <key>UIPrerenderedIcon</key> 
        <true/> 
        . . . 
    ]]></InfoAdditions> 
</iPhone> 
After using the UIPrerenderedIcon key, you can see the highlight is removed (see the 
before and after in figure 10.1). 

308 
CHAPTER 10 The almighty application dexcriptor 
                
Figure 10.1 Before and after UIPrerenderedIcon 
With this little change, you can retain control over the design of your application icon. 
REQUESTED DISPLAY RESOLUTION 
By default the <requestedDisplayResolution/> is set correctly, high, supporting 
retina displays of the iPhone 4 along with other screen resolutions. If you’d like to set the 
value to standard, then when running on higher-resolution iOS devices the application size 
will remain capped at 480 x 320 rather than the full device resolution. 
<iPhone> 
    <InfoAdditions><![CDATA[ 
        . . . 
        <requestedDisplayResolution>high</requestedDisplayResolution> 
        . . . 
    ]]></InfoAdditions> 
</iPhone> 
LAUNCHING AN APPLICATION WITH A CUSTOM URI 
The final feature we’ll discuss is showing how you can use a custom URI to launch your 
application, as you would on the Android system. Using a custom URI you can allow other 
applications or websites to launch your application and provide additional data for application 
state or anything else you may want to pass. 
To enable this feature in the <iPhone/> information block, you need to include a new 
section of XML (see the following listing). 
Listing 10.8 Enable custom URI launch 
<iPhone> 
    <InfoAdditions><![CDATA[ 
    . . . 
    <key>CFBundleURLTypes</key>                                           
        <array> 
            <dict> 
                <key>CFBundleURLSchemes</key> 
                <array> 
                    <string>rottentomatoes</string>                       
                </array> 
                <key>CFBundleURLName</key> 
                <string>our.app.ID</string>                               
Array of URL types 
Your custom URI 
Your application ID 

The almighty application descriptor 
309 
            </dict> 
        </array> 
    . . . 
    ]]></InfoAdditions> 
</iPhone> 
{chap 10 iOS}/src/RottenTomatoesIOS-app.xml
With your application descriptor ready, you can move back to your RottenTomatoesIOS
application and update your ApplicationMediator to handle the Invoke action’s data, 
as shown in the following listing. 
Listing 10.9 RottenTomatoesIOS.mxml—accept launch action 
. . . 
private function _onView_preinitializeHandler(event:FlexEvent):void       
{ 
    NativeApplication.nativeApplication.addEventListener( 
    InvokeEvent.INVOKE, _onApp_invokeHandler);                            
} 
private function _onApp_invokeHandler(event:InvokeEvent):void 
{ 
    NativeApplication.nativeApplication.removeEventListener(  
    InvokeEvent.INVOKE, _onApp_invokeHandler);                            
    var arguements:Array = event.arguments;                               
    //do something 
} 
. . . 
{chap 10 iOS}/src/RottenTomatoesIOS-app.xml
This wraps up the launch application feature enabled by the application descriptor. Now, 
using other applications or websites, you can launch your application from anywhere, giving 
the user a better experience. 
10.5 Summary 
Now that you understand all of the abilities of the all-powerful application descriptor, you can 
make final touches to your application that will leave it head and shoulders above the rest. 
Mastering the application descriptor provides system and market integration that code alone 
can’t. 
Key takeaways: 

Securing your certificate file 

Launching your application with a custom URI 

Customizing your applications 

Including custom permissions 
Respond to 
PreInitialize
event
Listen to InvokeEvent 
Clean up InvokeEvent
listener
Get arguments passed from URL 

310 
11  
Building your application with Flash 
Builder 
This chapter covers 

Releasing the Android application 

Exporting the QNX (BlackBerry) application 

Compiling the iOS application 

Uploading to markets 
Your application is ready, and every last touch that can be made is complete. Now is the final 
step where you build your application, one release per platform, giving you a set of release 
files to deploy to each market. 
Flash Builder was created to make this release process as simple as possible, and in this 
section you’ll see how Flash Builder does this. By the end of this chapter you’ll have looked 
at all of the required steps necessary to produce a release-quality build of your application 
along with the information necessary to upload your application into the various markets. 
11.1 Exporting a release build with Flash Builder 
Built into Flash Builder is an effective build system created to provide release-quality files for 
the various markets. Until now you’ve created debug-quality builds to deploy locally directly 
to your test devices. The files you’ve been using up until now may run on a device but 
wouldn’t be files you’d want to use as a release. The big difference is that release files are 
optimized to include the smallest amount of code, no debugger information, and only the 
required images and other files. These code improvements affect not only file size but also 
code execution speed. 

Building your application with Flash Builder  
311 
To start the release build process within Flash Builder for any of the mobile platforms, 
you must go to Project > Export Release Build (see figure 11.1). This starts a wizard for each 
of the release builds based on the project’s configuration.  
Figure 11.1 Export Release Build 
In the next section we’ll list all of the information required by platform to make a release-
quality build for each market. 
11.2 Android release process 
The easiest of the three release builds to make is the Android platform. Whether you have an 
account with the Android market or not, you can still make this build—although an account is 
required for publishing to any of the markets. 
Rewind 
In chapter 2 I offered an alternative resource for packaging and releasing applications. If 
you’d 
like 
to 
check 
out 
an 
additional 
resource, 
you 
can 
find 
it 
at 
http://www.adobe.com/devnet/air/articles/packaging-air-apps-android.html. 
Once you’ve selected Export Release Build, the first dialog box will come up, asking you to 
select which project to build. In this case you’ll build the RottenTomatoesAndroid project 
(see figure 11.2). 

312 
CHAPTER 11 Building your application with Flash Builder 
Figure 11.2 Choose RottenTomatoesAndroid. 
Once you’ve selected to build the Android project, you get right into the final packaging. The 
first option you have is to export a signed package for each target platform. This is helpful so 
that you can test the final release build one more time. Then you select whether to build a 
captive runtime or a shared runtime release. 
If you select shared runtime, you need to determine the link to use for the AIR 
application. When releasing to the Android market you’ll use the Android Market link, and if 
you’re releasing to the Amazon market you’ll use the Amazon Appstore link. This is the link 
to download the AIR app if AIR wasn’t installed previously (see figure 11.3). 
Figure 11.3 Android Deployment options 

Building your application with Flash Builder  
313 
If you decide to build an application with a captive runtime, then you don’t select where to 
find the AIR runtime, because the runtime is included in the release package. 
After determining your deployment options, you’ll set up your application certificate. As 
discussed in chapter 10, the application certificate identifies you as the developer (see figure 
11.4). If you need to make a new certificate, Flash Builder can help you with this too—make 
sure to save the certificate for later use. 
If you’re using an existing certificate, you’ll only need to browse to the certificate and 
include the certificate password. 
Figure 11.4 Android Digital Signature tab 
You can now choose your package contents, determining the additional files to package with 
your application. During development any embedded assets are already built into your 
package, but if you have additional files that are loaded at runtime, these files need to be 
packaged or they’ll be missing from the application (see figure 11.5). 
Figure 11.5 Android Package Contents tab 

314 
CHAPTER 11 Building your application with Flash Builder 
The final step is to package your native extensions. When you’re using native extensions, 
make sure to package them with the application or the application will fail (see figure 11.6). 
Figure 11.6 Android Native Extensions tab 
When your settings are complete, click the Finish button and Flash Builder will prepare the 
final APK for upload to your market of choice. 
In the next section we’ll look at all the steps necessary to create a BAR file for the 
BlackBerry App World market. 
11.3 QNX release process 
The most complicated of the three platforms for release is the QNX platform. To make a 
release build for the QNX platform you must have an account with BlackBerry App World. 
Rewind 
In chapter 2 I offered an alternative resource for packaging and releasing applications. If 
you’d 
like 
to 
check 
out 
an 
additional 
resource, 
you 
can 
find 
it 
at 
http://www.adobe.com/devnet/air/articles/packaging-air-apps-blackberry.html. 
After you select to export a release build, the first dialog in the release wizard will ask you to 
select the project and application to build. In this case you’ll build RottenTomatoesQNX 
(see figure 11.7). 

Building your application with Flash Builder  
315 
Figure 11.7 Choose RottenTomatoesQNX. 
After you’ve selected to build a QNX application, you’ll configure your digital signing for the 
QNX platform (see figure 11.8). 
Figure 11.8 QNX digital signing 
If you’ve configured your code signing previously, then you can move on to package 
contents. If you still need to configure your QNX code signing, you’ll check the Enable Digital 
Signing check box and configure digital signing for your application (see figure 11.9). Flash 
Builder has a code-signing wizard you can use to help you configure the QNX code signing. 
During the code-signing setup, you’ll also set up your certificate file. This is the same 

316 
CHAPTER 11 Building your application with Flash Builder 
certificate file we discussed in chapter 10 that uniquely identifies you as the developer of 
your application. 
Figure 11.9 Code signing 
After the digital signature is complete, you can move on to the package contents. Here you 
can explicitly include or exclude any files that you’ll need to load at runtime (see figure 
11.10). If you forget to include a specific file that you intend to load at runtime, you’ll have 
runtime faults from the missing files. 
Figure 11.10 QNX Package Contents tab 
Next you can configure your permissions using a simple user interface (see figure 11.11). 

Building your application with Flash Builder  
317 
Figure 11.11 QNX Permissions tab 
After configuring your permissions you should make sure to include any required native 
extensions (see figure 11.12). If you neglect to package a required native extension, then 
you’ll have runtime errors because of missing code. For your application the QNX platform 
doesn’t require any native extensions. 
Figure 11.12 QNX Native Extensions tab 
Finally, you can make any changes to the package using the Advanced tab. In the early days 
of QNX development you’d use this tab to set the SWF version—using the code -swf-

318 
CHAPTER 11 Building your application with Flash Builder 
version=13. Currently you don’t need to make any changes to your package on the 
Advanced tab (see figure 11.13). 
Figure 11.13 QNX Advanced tab 
The only thing left to do is click Finish. If everything is configured properly, then in a 
moment you’ll have a new BAR file for your application. 
Common QNX release errors 
There are three extremely common issues with releasing a QNX application: 
Build version already registered—If you’ve already run a build for the specific version 
number and build ID—whether you’ve uploaded the BAR file or not—the build process will 
fail. Make sure to keep updating the build number as you create new builds. 
Can’t sign .bar file—You have to be online to properly sign your application with RIM, 
the company behind QNX. Make sure you’re online before building your application. 
Bad certificate—I’ve found that you can’t reuse certificates between QNX and other 
platforms. Use the BlackBerry keytool—or the code-signing wizard—to create a proper 
certificate. In section 12.7 we’ll look at how to use the BlackBerry keytool. 
In the next section we’ll go through the release steps for the iOS platform. 

Building your application with Flash Builder  
319 
11.4 iOS release process 
The final platform to export a release build to is the iOS platform. Similar to the QNX 
platform, 
this 
release 
requires 
an 
account 
with 
the 
iOS 
developer 
program: 
http://developer.apple.com/programs/ios/. 
Once you’ve signed up with the iOS developer program, you can create iOS certificates 
and provisioning files. These are the two files necessary, beyond your code, to create an iOS 
release file. 
Rewind 
In chapter 2 I offered an alternative resource for packaging and releasing applications. 
For iOS I specifically point back to this resource, because Adobe will keep this resource up 
to date. This resource will show you how to use the iOS provisioning file and certificate 
using the iOS developer portal. If you’d like to check out an additional resource, you can 
find it at http://www.adobe.com/devnet/air/articles/packaging-air-apps-ios.html. 
After you’ve prepared the iOS certificate and provisioning file, you can move to the first step: 
selecting to export a release build. From this first dialog you’ll select to build the 
RottenTomatoesIOS application (see figure 11.14). 
Figure 11.14 Choose RottenTomatoesIOS. 
Once you’ve selected to build the RottenTomatoesIOS application, you’ll be directed to the 
deployment options. Android provides the option to deploy as either a captive runtime 
application or a shared runtime application; for iOS you don’t have that option (see figure 
11.15). Because you’re only able to use a captive runtime, you can move to the next tab, 
Digital Signature. 

320 
CHAPTER 11 Building your application with Flash Builder 
Figure 11.15 iOS Deployment options 
The digital signature requires many files to continue forward. The first required file is the iOS 
developer certificate. If you need additional help creating a developer certificate, Flash 
Builder includes a Learn More link with these details; you can also refer to the link provided 
earlier. 
After entering your developer certificate number and the password, you’ll point Flash 
Builder to your provisioning file. Depending on the type of provisioning file that you created, 
you’ll select to create either an ad hoc release package or a final release package (see figure 
11.16). 
Ad hoc release files are IPA release-quality builds that are available for use on only a 
limited quantity of test devices. After testing your ad hoc release file using your ad hoc 
provisioning file, it’s time to create a final release file using your release provisioning file. The 
final release file is the IPA file that you need to upload to the App Store for general release. 

Building your application with Flash Builder  
321 
Figure 11.16 iOS Digital Signature tab 
Continuing on to the Package Contents tab after setting the certificate and provisioning file, 
you can select what additional files will be packaged with your IPA file. Any files embedded in 
the code will automatically be included in your packaged file, but any files that are loaded at 
runtime won’t be packaged with the application. You need to explicitly include these files to 
prevent runtime errors (see figure 11.17). 
Figure 11.17 iOS Package Contents tab 

322 
CHAPTER 11 Building your application with Flash Builder 
Finally, you’ll include any native extensions your application relies on. By default, these 
extensions and their associated code aren’t included in the package, so you need to explicitly 
include the required extensions (see figure 11.18). 
Figure 11.18 iOS Native Extensions tab 
This completes the iOS packaging process. If everything is configured properly, you’ll have a 
release IPA file ready for upload to the Apple App Store.  
With your various release files created, you can now focus on uploading the application to 
the various markets. 
Take a break and get a drink 
The packaging process with iOS takes some time and provides little feedback during the 
process. Depending on the processing power of your machine, you’ll have around 10 
minutes, so go relax. 
11.5 Releasing to markets 
Sadly, as markets keep changing, so does the upload process for each of the markets. Even 
within the time frame of creating this book, the Android market’s upload process has 
changed twice. Therefore, we won’t be showing screen shots and steps for each of the 
markets, but we’ve provided links that will provide more information regarding this process. 
Android: http://developer.android.com/guide/publishing/publishing.html  
Amazon: https://developer.amazon.com/help/faq.html  

Building your application with Flash Builder  
323 
BlackBerry: https://appworld.blackberry.com/isvportal/home/login.seam  
iOS: http://www.adobe.com/devnet/flash/articles/app_store_guide.html  
11.6 Summary 
With this chapter complete, you should have a build file created and uploaded to each major 
market. You can proudly show off your work to each of your friends by tweeting the link to 
your amazing application. 
But what if you wanted more? What if you wanted to integrate your application build 
process with an automated build system?  
In this case, using Ant, you’re able to integrate into your automated build system. These 
automated build systems, such as Hudson or Jenkins, continuously rebuild and test your 
application during active development, providing instant feedback on failing code. In the next 
chapter, we’ll cover how to use Ant to make your release files using build scripts that can 
integrate with automated build systems. 
Key takeaways: 
 
Releasing your application using Flash Builder 
 
Uploading your application to the markets 

324 
12  
Automated builds using Ant 
This chapter covers 

Using Ant 

Running unit tests with Ant 

Building ASDocs 

Creating release files with Ant 
You’ve come a long way, but this is the end. You’ve created your application. You’ve double-
checked it for every possible failure and added features into it that will bring you fame and 
fortune, and you can release it to the world. 
But what if you want to go further? 
In this chapter we’ll look at what further actually means by discussing another language, 
simple to master, called Ant. Using Ant you can integrate with the most advanced automated 
build systems and create your release files in a blink of an eye, consistently perfect, and 
ready for release. We’ll start by looking at what Ant is and how to use it, and then we’ll go 
into how to build every part of your application using Ant. 
12.1 Building with Ant 
Previously if you wanted to run your units tests and build each of your applications, you’d 
have to follow a specific ritual to complete the tasks; any steps forgotten in the ritual would 
lead to a faulty release. Once you’ve mastered the ritual, what happens on the day that a 
release needs to be made and you’re out enjoying a beachside vacation? Unless you’ve left 
super-explicit instructions for the rest of your team, the likelihood of a successful release is 
low. 
Enter Ant. 

Automating builds using Ant  
325 
Ant is a Java-based build tool that runs through an explicit set of instructions in order. 
Using Ant you can create a build system to run through any set of instructions and provide 
you feedback through the entire process. These Ant files are simply XML files with a list of 
commands written in XML.  
If you need to create a build only if certain conditions pass, you can do that.  
If you need to run your unit tests for errors before building, you can do that.  
If you need to build documentation against your application, you can do that.  
There are also many code introspection features available to you when using build scripts 
that will show you new ways to make your code better. Finally, if you need to pass on the 
release process to another developer, they don’t have to learn your well-honed release ritual. 
Now they can just run your Ant build script to complete the build process. 
We won’t be going into all the features of Ant or code introspection in this chapter, but in 
this section we’ll look at some examples of build scripts and how to run them. In later 
sections you’ll create build scripts for each of the platforms, as well as a few other special 
features. 
Ant in Action 
If you’re interested in going deeper into Ant, please check out Ant in Action: 
http://www.manning.com/loughran/. 
We’ll be covering Ant builds specifically for your projects, but the Ant language is helpful 
for many situations. 
Before we dive directly into how to use Ant, you need to understand all the different terms 
surrounding Ant. In the next section we’ll define such key terms as build file, targets, and 
properties file. 
12.1.1 Ant terms 
We’ll first look at an example build file. Don’t worry about XML tags that you may not be 
familiar with; these are the Ant tags that make up the Ant markup language. We’ll look at 
each tag as it comes up, along with some best practices for writing Ant scripts. 
BUILD FILE 
Ant build files are extremely simple and easy to read, so you don’t need to start by looking 
at individual lines of syntax to understand the entire file. Instead, you can look at an entire 
file and break down the syntax. 
In the following build file you’ll see that it starts with the <project/> XML tag, stating 
that this file is an Ant build script. Within the <project/> tag you set the project’s name, 
the basedir—the directory to use as the base directory for relative paths—and the default 
target to run as the main entry point for the Ant build file. Setting a default target doesn’t 
restrict your Ant build file from running any other targets; it just sets a default if no specific 
target is specified. 

326 
CHAPTER 12 Automated builds using Ant 
<?xml version="1.0" encoding="UTF-8"?> 
<project name="Example Build File" basedir="." default="public-target"> 
    <property file="build.properties"/>                                   
     
    <target name="public-target" depends="-private-target" 
        description="a public target">                                    
        <echo>${PUBLIC_OUTPUT}</echo>                                     
    </target> 
     
    <target name="-private-target">                                       
        <echo>${PRIVATE_OUTPUT}</echo> 
    </target> 
     
</project> 
This is an example ANT file; you can make it, but it isn’t important. By reading over the build 
file you’re probably already putting together some assumptions about Ant markup. 
PROPERTY 
The first assumption is the <property/> tag. This tag specifies an external file for your 
build file’s variables and external paths. You don’t have to use a properties file, but it’s 
recommended because then you can easily update paths specifically for each computer that’s 
running the build file rather than changing the build file itself. These property files define the 
values for your variables. 
TARGET 
The second assumption is about the <target/> tag. Targets are similar to methods in 
ActionScript. Although there aren’t really public and private methods, when giving the target 
a description you specify that a target is listed as a main target for use with the Ant 
projecthelp command. Many developers use the “-” identifier before a target to specify 
that the target is a private target; this is optional.  
Don’t worry too much about the projecthelp command right now. When we look at 
how to run Ant files in a command line, we’ll dive deeper into this option. 
DEPENDS 
With the public-target you use the depends tag to call the -private-target. This 
means that the -private-target is always run before the public-target, which is 
helpful for situations where you need to set up some information prior to running your 
public-target. 
VARIABLES 
The third assumption is the ${PUBLIC_OUTPUT} and ${PRIVATE_OUTPUT} data. The ${x}
specifies an Ant variable with the name x. In this case there are two Ant variables named 
PUBLIC_OUTPUT and PRIVATE_OUTPUT. These variables aren’t defined in your build file but 
Connected build properties 
for variables
Public target calls a private target 
Console output 
Private target called by public target 

Automating builds using Ant  
327 
instead reside in the connected properties file. Next, we’ll look at the connected properties 
file so you can understand how to make your own later. 
PROPERTIES FILE 
The build.properties file for the build script is extremely simple because it contains only two 
variables: 
PUBLIC_OUTPUT=Running Public Target 
PRIVATE_OUTPUT=Running Private Target 
By changing the variables, you can change the output of your build script. In the next section 
we’ll look at how to run your build script through either Flash Builder or the command line. 
12.1.2 Running Ant 
Ant scripts can be run directly from the Flash Builder IDE or the command line, whichever 
you feel most comfortable with. 
FROM FLASH BUILDER 
Within Flash Builder you can see the structure of the Ant file within the Outline window of the 
Flash Builder (Eclipse) IDE (see figure 12.1). 
Figure 12.1 Outline window 
From the Outline window you can right-click any of the targets and select to run the target 
(see figure 12.2). 

328 
CHAPTER 12 Automated builds using Ant 
Figure 12.2 Run from IDE. 
After you select to run the Ant build file, your output will be sent to the console: 
Buildfile: /path/to/ant/file/build.xml 
-private-target: 
     [echo] Running Private Target 
public-target: 
     [echo] Running Public Target 
BUILD SUCCESSFUL 
Total time: 814 milliseconds 
That’s it! You’ve run an Ant file from Flash Builder. If you want another way to run your build 
script, let’s look at how to use the command line to run an Ant file. 
FROM THE COMMAND LINE 
From Flash Builder you can easily run an Ant build file, but when you’re using the command 
line you can get a few more options that aren’t available from Flash Builder. Using either the 
command line (WIN) or terminal (MAC), you need to access the directory containing the 
build file. On my computer, the build file is within the RottenTomatoesAndroid directory. To 
access this directory I just use the change directory command: 
cd Documents/work/book/RottenTomatoesAndroid/ 
By changing to the RottentTomatoesAndroid directory you can run your build file: 
ant -buildfile example.xml 
By using the –buildfile command you can specify the build file that you choose to run. 
The output of the build file is exactly the same as the Flash Builder console output: 
Buildfile: /path/to/build/file/example.xml 
-private-target: 
     [echo] Running Private Target 
public-target: 
     [echo] Running Public Target 

Automating builds using Ant  
329 
BUILD SUCCESSFUL 
Total time: 0 seconds 
If you use the –buildfile command without any other tags, Ant runs the default target. 
You could also rewrite the –buildfile command to specifically run the public-target: 
ant -buildfile example.xml public-target 
Finally, if you don’t know what targets are available, you can always use the projecthelp 
command to get a list of all the available targets within a build script: 
ant -buildfile example.xml -projecthelp 
Here’s the -projecthelp output: 
Buildfile: /path/to/build/file/example.xml 
Main targets: 
public-target  a public target 
Default target: public-target 
There are additional commands that you can use if you want to get more into Ant, but for 
your current needs these two methods will suffice. In the following section you’ll create your 
first build file to run your FlexUnit tests using Ant. 
12.2 Your build setup 
For your project you’ll need to set up multiple build scripts: one to build the library, one to 
build the Android APK files, one to build the QNX BAR file, and one to build the iOS IPA file. 
The concept behind each build file is that you’ll run your unit tests to first check that the 
code is correct and tested, then build and package your release file, and finally create 
documentation on your application (see figure 12.3). 
Figure 12.3 Build structure 
For each of the four build scripts you’re creating, you’ll also create a properties file to run. 
There will be plenty of copy and pasting between the build script and properties file because 
most of the required methods are similar, with only some slight alterations. 
To get started you can create build.xml and build.properties files for each of your projects 
(see figure 12.4). 

330 
CHAPTER 12 Automated builds using Ant 
Figure 12.4 Project structures 
With your files laid out, you need to add some paths to your properties files and a simple 
layout to all of your build files. 
12.2.1 Prepping your property files 
Setting up the property files correctly is the cornerstone to creating a proper build file. 
Although the values that I show can be used as a guide, the final values you’ll use will need 
to be unique to your computer and your paths. Make sure to check that all the paths you set 
are correct for your computer. 
In later sections you’ll add to the properties files as required by platform, but the 
following values can be used as a basis for all of your build files. 
FLEX PATHS 
The first set of properties that you’ll include is required to integrate the Flex SDK. These 
three properties set the path to your Flash Builder installation and then create a few more 
paths based on the Flash Builder location. I include the default paths for MAC and Windows; 
select the path that works for your computer: 
#mac 
FLASH_BUILDER=/Applications/Adobe\ Flash\ Builder\ 4.6 
#win 
#FLASH_BUILDER=C:/Program\ Files\ (x86)/Adobe/Adobe\ Flash\ Builder\ 4.6 
FLEX_HOME=${FLASH_BUILDER}/sdks/4.6.0 
FLEX_TASKS=${FLEX_HOME}/ant/lib/flexTasks.jar 
PROJECT PATHS 
The second set of paths you’ll set up is a set of project paths, which defines the locations of 
your source code, libs, and workspace—the directory that holds all of your projects: 
WORKSPACE=/Users/yourname/Documents/Adobe\ Flash\ Builder\ 4.6 
BUILD_DIR=build 
RELEASE_DIR=release 
SRC_DIR=src 
LIBS_DIR=libs 

Automating builds using Ant  
331 
ANES_DIR=anes 
ASSETS_DIR=${SRC_DIR}/assets 
FLEXUNIT_DIR=${WORKSPACE}/RottenTomatoesFlexUnit 
LIBRARY_DIR=${WORKSPACE}/RottenTomatoesLibrary 
DOCS_DIR=docs 
REPORTS_DIR=reports 
If you’ve changed the names of any of the source folders or the projects, this is the time to 
include your changes. 
FLEXUNIT PATHS 
The final set of paths includes the proper FlexUnit libraries. If you already set the path to 
Flash Builder correctly, then you should not have to make any changes to this section. It’s 
good practice to double-check on your computer that the files exist where you intend them 
to be. 
FLEXUNIT_COMMON_DIR=${FLASH_BUILDER}/eclipse/plugins/com.adobe.flexbuilder.
flexunit_{your version}/flexunitframework/libs/version4libs/Common 
FLEXUNIT_FLEX_PROJECT_DIR=${FLASH_BUILDER}/eclipse/plugins/ 
[CA] com.adobe.flexbuilder.flexunit_{your 
version}/flexunitframework/libs/version4libs/FlexProject 
FLEXUNIT_FLEX_PROJECT_EXTENDED_DIR=${FLASH_BUILDER}/eclipse/plugins/ 
[CA] com.adobe.flexbuilder.flexunit_{your 
version}/flexunitframework/libs/version4libs/FlexProject_Extended 
FLEXUNIT_LOCAL_DIR=${FLASH_BUILDER}/eclipse/plugins/ 
[CA] com.adobe.flexbuilder.flexunit_{your 
version}/flexunitframework/locale/version4locale 
The FlexUnit version number may vary based on your version. Make sure the path is correct 
for your system. 
12.2.2 Laying out your build file 
With your property files set up, you can now lay the groundwork for your build files. For your 
build file you’ll need a variety of targets to run as your “methods.” In addition to what is built 
into Ant, you’ll expand the capabilities of Ant by including some additional classes through 
the <taskdef/> tag. The <taskdef/> tag defines additional tasks that your build file can 
use. This is what you’re using to include the mxmlc, compc, asdoc, and flexunit tasks 
(see the following listing). 
Listing 12.1 build.xml structure 
<?xml version="1.0" encoding="UTF-8"?> 
<project name="Build File" basedir="." default="build">                   
    <property file="build.properties"/>                                   
    <taskdef name="mxmlc" classname="flex.ant.MxmlcTask"                  
classpath="${FLEX_TASKS}"/>                                               
Main project tag 
Properties file 
Defines additional tasks 

332 
CHAPTER 12 Automated builds using Ant 
    <taskdef name="compc" classname="flex.ant.CompcTask"                  
    classpath="${FLEX_TASKS}"/>                                           
    <taskdef name="asdoc" classname="flex.ant.AsDocTask"                  
    classpath="${FLEX_TASKS}"/>                                           
    <taskdef resource="flexUnitTasks.tasks"                               
    classpath="${FLEXUNIT_DIR}/flexunit/flexUnitTasks-4.1.0-8.jar"/> 
     
    <target name="build"></target>                                        
    <target name="-preclean"></target>                                    
    <target name="-postclean"></target>                                   
    <target name="run-tests"></target>                                    
    <target name="run-asdoc"></target>                                    
     
</project> 
For all of the build files, the –preclean and –postclean targets are the same.  
The –preclean target starts by destroying the build and release folders from any 
previous builds and creates the build and release folders for the current build cycle. The build 
folder will hold temporary files created during the build process that aren’t necessary after 
the release build is created. The release folder is the final folder that will hold the file ready 
for release: 
<target name="-preclean"> 
    <delete dir="${BUILD_DIR}" failonerror="false"  
        includeemptydirs="true"/> 
    <delete dir="${RELEASE_DIR}" failonerror="false"  
        includeemptydirs="true"/> 
    <mkdir dir="${BUILD_DIR}"/> 
    <mkdir dir="${RELEASE_DIR}"/>
</target> 
The –postclean target deletes the temporary build folder that you created, leaving your 
project clean after your build is complete: 
<target name="-postclean"> 
    <delete dir="${BUILD_DIR}" failonerror="false"  
        includeemptydirs="true"/> 
</target> 
Your property file and build.xml are stubbed out and almost ready to be filled with platform-
specific build data. In the next section you’ll add in your FlexUnit tests to your build script so 
that each time you make a build, you can make sure all your unit tests pass before making a 
bad build. 
12.3 Using Ant to run FlexUnit 
Running FlexUnit through Ant is a somewhat complicated procedure. To run the unit tests 
you’ve created, you first need some additional libraries from the FlexUnit site, 
Defines additional 
tasks
Main build target 
Clean directories for build 
Clean directories after build 
Run tests 
Run asdoc 

Automating builds using Ant  
333 
http://flexunit.org. This is because by default the continuous integration libraries aren’t 
included with the version of FlexUnit that ships with Flash Builder. 
To 
get 
these 
libraries 
go 
to 
the 
Download 
page 
of 
flexunit.org 
(http://flexunit.org/?page_id=14) and download the full project download, including all SWC 
libraries with all CI listeners for the 4.1 SDK. After downloading and unzipping the folder, 
you’ll move the specific files into a new folder within the RottenTomatoesFlexUnit 
project (see figure 12.5). 
Figure 12.5 Include FlexUnit dependencies 
After moving all of the *.swc and *.jar files to the new flexunit folder within 
RottenTomatoesFlexUnit, you’ll include the folder within your project by adding the 
flexunit folder as an SWC folder (see figure 12.6). 

334 
CHAPTER 12 Automated builds using Ant 
Figure 12.6 Choose Add SWC Folder. 
You now have all of the external libraries you need to complete running FlexUnit through 
Ant. With the proper files you can return to your FlexUnit application and make some 
changes for the continuous integration. 
The concept for running your application requires a few steps: 
1. Compile the FlexUnit application. 
2. Run your application on a headless player. 
3. Render the results into an XML-based report. 
First, you’ll update the FlexUnit application to include the continuous integration code. 
12.3.1 Updating your Test Runner application 
Returning to RottenTomatoesFlexUnit.mxml, you already have an application that runs your 
unit tests reliably on mobile devices, as shown in the following listing. 
Listing 12.2 Current RottenTomatoesFlexUnit.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark" 
        creationComplete="creationCompleteHandler(event)"  
        xmlns:flexui="flexunit.flexui.*"> 
    <fx:Script> 
        <![CDATA[ 
    import mx.events.FlexEvent; 
    import test.unitedmindset.services.RotTomServiceTest; 

Automating builds using Ant  
335 
    import test.unitedmindset.utils.RendererUtilTest; 
            
    protected function creationCompleteHandler(event:FlexEvent):void 
    { 
        runner.runWithFlexUnit4Runner();                                 
    } 
             
    public function currentRunTestSuite():Array                          
    { 
        var tests:Array = [];  
        tests.push(test.unitedmindset.utils.RendererUtilTest); 
        tests.push(test.unitedmindset.services.RotTomServiceTest); 
        return tests; 
    }         
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <flexui:FlexUnitTestRunnerUIMobile id="runner"> 
        <flexui:data> 
            <flexui:FirstViewDataVO tests="{currentRunTestSuite()}"  
                projectName="RottenTomatoesAppTests"/> 
        </flexui:data> 
    </flexui:FlexUnitTestRunnerUIMobile> 
</s:Application> 
{chap 12 FlexUnit}/src/RottenTomatoesFlexUnit.mxml
You’ll make some changes to this application to include the continuous integration listeners 
for Ant integration (see the following listing). 
Listing 12.3 Updated RottenTomatoesFlexUnit.mxml 
<?xml version="1.0" encoding="utf-8"?> 
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"  
        xmlns:s="library://ns.adobe.com/flex/spark" 
        creationComplete="creationCompleteHandler(event)"  
        xmlns:flexui="flexunit.flexui.*"> 
    <fx:Script> 
    <![CDATA[ 
    import mx.events.FlexEvent;     
    import org.flexunit.listeners.CIListener;                            
    import org.flexunit.runner.FlexUnitCore; 
    import test.unitedmindset.services.RotTomServiceTest; 
    import test.unitedmindset.utils.RendererUtilTest; 
             
    protected function creationCompleteHandler(event:FlexEvent):void 
Runs tests with mobile test runner 
Creates list of tests 
Add continuous integration 
imports

336 
CHAPTER 12 Automated builds using Ant 
    { 
        var core:FlexUnitCore = new FlexUnitCore();                      
        core.addListener( new CIListener() ); 
        core.run( currentRunTestSuite() ); 
        runner.runWithFlexUnit4Runner(); 
    } 
             
    public function currentRunTestSuite():Array 
    { 
        var tests:Array = []; 
        tests.push(test.unitedmindset.utils.RendererUtilTest); 
        tests.push(test.unitedmindset.services.RotTomServiceTest); 
        return tests; 
    } 
             
    ]]> 
    </fx:Script> 
    <fx:Declarations> 
    <!-- Place non-visual elements (e.g., services, value objects) here --> 
    </fx:Declarations> 
    <flexui:FlexUnitTestRunnerUIMobile id="runner">                      
        <flexui:data>
            <flexui:FirstViewDataVO tests="{currentRunTestSuite()}"  
                projectName="RottenTomatoesAppTests"/>
        </flexui:data> 
    </flexui:FlexUnitTestRunnerUIMobile>
</s:Application> 
{chap 12 FlexUnit}/src/RottenTomatoesFlexUnit.mxml
That’s it—your Flex application will now integrate with the Ant components. Next, you’ll 
move forward to your build files to include the FlexUnit Ant code. This marks the end of your 
ActionScript code for the remainder of the book. From this point on, we’ll focus entirely on 
Ant code. 
12.3.2 The FlexUnit Ant target 
Starting with the build.xml in the RottenTomatoesLibrary, you’ll add Ant code into your 
run-tests target. You’ll start by running the tests within the library prior to building the 
actual library. If you’ve created custom tests for each platform, you can copy the same 
FlexUnit Ant code into those build.xml files. For the purposes of this book we’ll just show how 
to run the FlexUnit tests against your library tests that you created in chapter 9. 
To get started you’ll want to delete any old reports that you generated on previous builds 
(so that an old report won’t muck up your new reports), and create a new folder to hold the 
reports from this build: 
<target name="run-tests"> 
Add continuous 
integration classes
Remove previous 
test runner

Automating builds using Ant  
337 
    <delete dir="${REPORTS_DIR}" includeemptydirs="true"/> 
    <mkdir dir="${REPORTS_DIR}"/> 
</target> 
Next, you’ll build your test runner application using the mxmlc task provided by the Flex 
SDK. The mxmlc task is used to build applications into SWF files. As the first significant piece 
of Ant code you’re using, this may seem complicated, but we’ll discuss each part: 
<target name="run-tests"> 
    . . . 
    <mxmlc file="${FLEXUNIT_DIR}/src/RottenTomatoesFlexUnit.mxml" 
        output="${BUILD_DIR}/Testrunner.swf">                             
            <load-config filename="${FLEX_HOME}/frameworks/airmobile- 
            config.xml" />                                               
            <source-path path-element="${FLEXUNIT_DIR}/src"/>            
            <source-path path-element="${SRC_DIR}"/>                      
            <library-path dir="${LIBS_DIR}" includes="*.swc"  
                append="true"/>                                           
            <library-path dir="${FLEXUNIT_DIR}/flexunit" includes="*.swc"  
                append="true"/>                                           
            <verbose-stacktraces>true</verbose-stacktraces>              
            <headless-server>true</headless-server>                      
    </mxmlc> 
    . . . 
</target> 
With the mxmlc segment complete, you can run the compiled testrunner.swf directly 
after compiling the application. Remember that one feature of Ant is that if any errors 
stopped you from compiling your application, the build will fail and stop immediately: 
<target name="run-tests"> 
    . . . 
    </mxmlc> 
    <flexunit swf="${BUILD_DIR}/Testrunner.swf"                           
        toDir="${REPORTS_DIR}"                                            
        haltonfailure="false"                                             
        verbose="true"                                                    
        localTrusted="true"/>                                             
    . . . 
</target> 
The one point from the flexunit task that I want to highlight is the haltonfailure
attribute. For my build file I set this to false so that the build would continue. You may 
remember that you coded your unit tests with an intentional error to highlight how error 
results output. If you were to set this value to true, your build would never move forward. 
For production systems you’ll probably want this value to be true, but just for this case 
leave it false. 
Build specified file 
Include Flex Air Mobile Configurations 
Include *.swc files from current project 
Include source 
code from 
flexunit
project 
Include 
source code 
from current 
project 
Include *.swc files from flexunit project 
Provide 
verbose  
stacktrace for 
errors 
Configure to 
run on 
headless-
server
Run Testrunner.swf 
Send output reports directory 
Don’t stop if errors thrown 
Include full stacktraces 
Use local trusted security sandbox 

338 
CHAPTER 12 Automated builds using Ant 
When your flexunit task is complete, you can create your report using the 
junitreport task included with Ant. This task takes the XML output and creates HTML 
reports that you can read or that can be read by continuous integration systems: 
<target name="run-tests"> 
    . . . 
    <junitreport todir="${REPORTS_DIR}">                                  
        <fileset dir="${REPORTS_DIR}">                                    
            <include name="TEST-*.xml"/> 
        </fileset> 
        <report format="frames" todir="${REPORTS_DIR}/html"/>             
    </junitreport> 
</target> 
You’ve completed your flexunit code and can now run your unit tests each time you make 
a build. If you have custom unit tests for each platform, you could move this code to the 
other build.xml files to run their unit tests prior to building the release file. 
Next you’ll generate ASDocs for your code. 
12.4 Showing off your code with ASDocs 
Many developers have looked at the ActionScript reference documents (see the following 
link) and wanted an easy way to create the same complex, interlinking documentation: 
http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/package-
summary.html. The possibility exists, and the tool to enable these beautiful docs is found in 
the asdoc task. In this section we’ll look at the small bit of code necessary to create your 
own ASDocs for each of your projects. 
12.4.1 Start by cleaning your old docs 
As you’ve learned from the flexunit section, the first thing you should do is remove all of 
the old generated docs. You do this by deleting the current docs folder and then creating a 
new one. This is a two-line process: 
<target name="run-asdoc"> 
    <delete dir="${DOCS_DIR}" includeemptydirs="true"/> 
    <mkdir dir="${DOCS_DIR}"/> 
</target> 
After you’ve cleaned up your current documents folder, you can move to the next section to 
build your docs. 
12.4.2 Building your ASDocs 
Building ASDocs using the asdoc task is similar to building an application. You’ll say where 
your source exists, what libraries to include—but not what documents—and where you want 
to output the ASDocs after they’re generated (see the following listing). 
Output report to reports directory 
Include TEST-*.xml files in report 
Format report using frames 

Automating builds using Ant  
339 
Listing 12.4 Use asdoc task 
<target name="run-asdoc"> 
    <!-- clean docs --> 
    <delete dir="${DOCS_DIR}" failonerror="false" includeemptydirs="true"/> 
    <mkdir dir="${DOCS_DIR}"/> 
    <!-- run docs --> 
    <asdoc output="${DOCS_DIR}"                                           
        main-title="Rotten Tomatoes Library"                              
        window-title="Flex Mobile In Action"                              
        footer="These docs were generated with the asdoc task">           
            <load-config filename="${FLEX_HOME}/frameworks/airmobile- 
            config.xml" />                                                
            <doc-sources path-element="${SRC_DIR}"/>                      
            <source-path path-element="${SRC_DIR}"/> 
            <library-path dir="${LIBS_DIR}" includes="*.swc"  
            append="true"/>                                               
            <external-library-path dir="${FLEXUNIT_COMMON_DIR}"           
            includes="*.swc" append="true"/>                              
            <external-library-path dir="${FLEXUNIT_FLEX_PROJECT_DIR}"     
            includes="*.swc" append="true"/>                              
            <external-library-path                                        
            dir="${FLEXUNIT_FLEX_PROJECT_EXTENDED_DIR}" includes="*.swc"  
            append="true"/>                                               
            <external-library-path dir="${FLEXUNIT_LOCAL_DIR}"            
            includes="*.swc" append="true"/>                              
    </asdoc>
</target> 
Once the tool completes, you should have a large set of HTML files within the docs folder in 
your library. If you open the index.html file, you can view all of your generated docs (see 
figure 12.7). 
Provide the output location 
Main title for each page 
Window title for each page 
Footer text for each page 
Configuration file for Flex Mobile project 
What to document 
Additional 
libraries to 
include

340 
CHAPTER 12 Automated builds using Ant 
Figure 12.7 Generated docs 
You can copy and paste the ASDocs code and put it in each of the build.xml files for your 
many projects. In the next section, you’ll start building your different projects, starting with 
building the RottenTomatoesLibrary. 
12.5 Building your library 
Building a library into a SWC is easy, and based on your current Ant experience it can be 
completed in a few lines of code. In this section you’ll complete the build target to run your 
dependent targets and then use the compc task to build your library. 
12.5.1 Completing the build target 
Your library build script already includes targets for build, -preclean, -postclean, 
run-tests, and run-asdoc. You’ll add a build-lib target to build your library, and then 
you’ll include all of your build steps in order within the build target (see the following listing). 

Automating builds using Ant  
341 
Listing 12.5 Current build script with build-lib target 
<?xml version="1.0" encoding="UTF-8"?> 
<project name="Android Build File" basedir="." default="build"> 
    <!-- setup --> 
    <description>Build Script for Rotten Tomatoes Application</description> 
    <property file="build.properties"/> 
    <taskdef name="mxmlc" classname="flex.ant.MxmlcTask"  
    classpath="${FLEX_TASKS}"/> 
    <taskdef name="compc" classname="flex.ant.CompcTask"  
    classpath="${FLEX_TASKS}"/> 
    <taskdef name="asdoc" classname="flex.ant.AsDocTask"  
    classpath="${FLEX_TASKS}"/> 
    <target name="build">                                                
        <antcall target="-preclean"/>                                    
        <antcall target="run-tests"/>                                    
        <antcall target="build-lib"/>                                    
        <antcall target="run-asdoc"/>                                    
        <antcall target="-postclean"/>                                   
    </target> 
    <target name="build-lib"></target>                                   
    <target name="-preclean"> 
            <delete dir="${BUILD_DIR}" includeemptydirs="true"/> 
            <delete dir="${RELEASE_DIR}" includeemptydirs="true"/> 
            <mkdir dir="${BUILD_DIR}"/> 
            <mkdir dir="${RELEASE_DIR}"/> 
    </target> 
     
    <target name="-postclean"> 
        <delete dir="${BUILD_DIR}" includeemptydirs="true"/> 
    </target> 
    <target name="run-tests"> 
    <!-- run project specific tests --> 
    </target> 
     
    <target name="run-asdoc"> 
    <!-- build project specific docs--> 
    </target> 
     
</project> 
{chap 12 Lib}/build.xml
Build target calls other targets 
Builds the library 

342 
CHAPTER 12 Automated builds using Ant 
In 
the 
next 
section 
you’ll 
fill 
in 
the 
build-lib 
target 
to 
compile 
your 
RottenTomatoesLibrary. 
12.5.2 build-library target 
With your target ready you just need to use the compc task to build your library. The compc
task specifically is used to compile modules and libraries such as yours: 
<target name="build-lib"> 
    <compc output="${RELEASE_DIR}/RottenTomatoesLibrary.swc">             
            <load-config filename="${FLEX_HOME}/frameworks/airmobile- 
            config.xml"/>                                                 
            <source-path path-element="${SRC_DIR}"/>                      
            <include-sources dir="${SRC_DIR}" includes="*"  
            excludes="test/** FlexUnitApplication-app.xml  
            FlexUnitApplication.mxml"/>                                   
            <library-path dir="${LIBS_DIR}" includes="*.swc"  
            append="true"/>                                               
    </compc> 
</target> 
You saw most of these settings when you compiled the flexunit application. The one 
section that should look different is the section where you define what source classes to 
include or exclude. For a release-quality library, you want to include all of your classes 
except for any classes that are part of your unit tests. You do this because you don’t need to 
include these classes for other applications that may want to include your library. This isn’t 
required, just recommended. 
Once you’ve completed this target, your library build script is complete. For fun I 
recommend running the build target now and watching everything run and build. Although 
this is helpful, this is only one step in a longer journey. Next, you’ll package your Android 
application for market release.  
12.6 Packaging for Android 
The process of packaging an application for release takes a few steps, requiring multiple 
targets. The main idea is that you’ll need to prep a few files for compilation—specifically the 
ANEs—compile the application, prepare a few more files for packaging, and then package 
your application for both the Android and Amazon markets (see the following listing). 
Listing 12.6 Current build script with package targets 
<?xml version="1.0" encoding="UTF-8"?> 
<project name="Android Build File" basedir="." default="build"> 
    <!-- setup --> 
    <description>Build Script for Rotten Tomatoes Application</description> 
    <property file="build.properties"/> 
    <taskdef name="mxmlc" classname="flex.ant.MxmlcTask"  
Include all swcs in libs folder 
Include all classes (exclude testing) 
Load the AIR mobile config 
Where swc will be outputted 
Define source path of 
library 

Automating builds using Ant  
343 
    classpath="${FLEX_TASKS}"/> 
    <taskdef name="compc" classname="flex.ant.CompcTask"  
    classpath="${FLEX_TASKS}"/> 
    <taskdef name="asdoc" classname="flex.ant.AsDocTask"  
    classpath="${FLEX_TASKS}"/> 
    <target name="build">                                                 
        <antcall target="-preclean"/>                                     
        <antcall target="run-tests"/>                                     
        <antcall target="package"/>                                       
        <antcall target="run-asdoc"/>                                     
        <antcall target="-postclean"/>                                    
    </target> 
    <target name="-preclean"> 
            <delete dir="${BUILD_DIR}" includeemptydirs="true"/> 
            <delete dir="${RELEASE_DIR}" includeemptydirs="true"/> 
            <mkdir dir="${BUILD_DIR}"/> 
            <mkdir dir="${RELEASE_DIR}"/> 
    </target> 
     
    <target name="-postclean"> 
        <delete dir="${BUILD_DIR}" includeemptydirs="true"/> 
    </target> 
    <target name="package">                                               
        <antcall target="-move-anes"/> 
        <antcall target="-compile"/> 
        <antcall target="-move-descriptor"/> 
        <antcall target="-move-assets"/> 
        <available file="${KEYSTORE}"  
        property="CERTIFICATE_EXISTS"/>                                   
        <antcall target="-certificate"/> 
        <antcall target="-package-android"/> 
        <antcall target="-package-amazon"/> 
    </target> 
    <target name="-move-anes"></target>                                   
    <target name="-compile"></target>                                     
    <target name="-move-descriptor"></target>                             
    <target name="-move-assets"></target>                                 
    <target name="-certificate" unless="${CERTIFICATE_EXISTS}"></target>  
    <target name="-package-android"></target>                             
    <target name="-package-amazon"></target>                              
    <target name="run-tests"> 
    <!-- run project specific tests --> 
Default build target 
Call packaging targets 
Check if certificate exists 
Prepare ANE files for compile 
Compile project to SWF 
Move descriptor for packaging 
Move assets for packaging 
Create certificate as necessary 
Package Android APK 
Package Amazon APK 

344 
CHAPTER 12 Automated builds using Ant 
    </target> 
     
    <target name="run-asdoc"> 
    <!-- build project specific docs--> 
    </target> 
     
</project> 
{chap 12 Android}/build.xml
If you forgot to create the build.properties file, go back and check out section 12.2.1. 
The code that’s included is right in line what you’ve done for the last few sections. The 
one change is the line that checks for the certificate file. The <available/> tag checks to 
see if a file exists and sets the Boolean value to the CERTIFICATE_EXISTS property: 
<available file="${KEYSTORE}" property="CERTIFICATE_EXISTS"/> 
Then when you call the –certificate target, you run the target only if the certificate 
doesn’t exist. This is helpful so you don’t keep re-creating the same certificate file: 
<target name="-certificate" unless="${CERTIFICATE_EXISTS}"></target> 
With the outline complete, you’ll use the next few sections to fill in the code. You’ll start by 
doing what is necessary to compile your application. 
12.6.1 Compiling the Android project 
Even though you want to end up with an APK file, you still must compile your application to a 
regular old SWF file before packaging your application with a few other files into an APK file. 
Before you can compile your application, you’ll want to pull together all the necessary files in 
one convenient place. This includes all of your ANE files, your library files, and your project’s 
source code. First you’ll need to do some work on your ANE files. 
MOVING THE ANES 
In the future if you’re making an application that doesn’t include an ANE you won’t have to 
go through this step. For your application you’ll rename the ANE file to end with .swc so it 
can be included with your compiling. You don’t want to rename the file and affect the rest of 
your development, so you’ll make a clean copy and put the copy into your temporary build 
folder. 
This entire process is handled in one line of code with Ant: 
<target name="-move-anes"> 
    <copy file="${ANES_DIR}/com.adobe.extensions.Vibration.ane" 
        tofile="${BUILD_DIR}/Vibration.swc"/> 
</target> 
Once your ANE files are ready, you can compile your SWF file. 

Automating builds using Ant  
345 
BUILDING THE SWF FILE 
Now, using the mxmlc task, you can build the SWF file. Building the SWF file is simple with 
the mxmlc tag, but there are a few caveats that you need to take into account. First, you 
want to make sure that you create a SWF file without all the debug code. To do this you’ll set 
the debug flag to false. The second caveat is based on the computer running the build file. 
Depending on the capabilities of the computer, you may not need to fork the process or set 
the max memory. To ensure that this build file works on all computers, you’ll fork the 
compile, which runs the compiler code in a separate Java Virtual Machine instance, and set 
the max memory limit to prevent out-of-memory errors. The last caveat is based on the fact 
that you’re including an ANE. To properly include ANE files in the compiler, you don’t add the 
ANE through the source or library but instead as an external library path. 
Now that we’ve explained the process, you can see that the code to do this is extremely 
simple: 
<target name="-compile"> 
    <mxmlc file="${SRC_DIR}/RottenTomatoesAndroid.mxml"                   
        output="${BUILD_DIR}/RottenTomatoesAndroid.swf"                   
        debug="false"                                                     
        failonerror="true"                                                
        fork="true" maxmemory="512m">                                     
            <load-config filename="${FLEX_HOME}/frameworks/airmobile- 
            config.xml" />                                                
            <source-path path-element="${SRC_DIR}"/>                      
            <library-path dir="${LIBS_DIR}" includes="*.swc"  
            append="true"/>                                               
            <library-path dir="${LIBRARY_DIR}/bin" includes="*.swc"  
            append="true"/>                                               
            <external-library-path dir="${BUILD_DIR}" includes="*.swc"  
            append="true"/>                                               
    </mxmlc> 
</target> 
Your application now compiles to a SWF file and is ready for packaging. In the next section 
you’ll start the process of preparing all the necessary files for packaging and then package 
your application into a releasable APK file. 
12.6.2 Packaging the Android project 
If you run your build script now, you’ll end with your temporary build file holding only the 
SWF file you need to include in the final package. To create a proper package for release, 
you also need to include your application descriptor with additional information about your 
application, any assets that you’ll want to load at runtime, and the certificate that identifies 
you as the application’s developer. 
Compile 
RottenTomatoesAndroid 
Output 
compiled file 
Don’t include debug information 
If compilation fails stop build 
Protect against memory failures 
Use AIR mobile default options 
Include application’s 
source
Use AIR mobile default options 
Include RottenTomatoesLibrary swc 
Include your ANEs 

346 
CHAPTER 12 Automated builds using Ant 
PREPARING THE APPLICATION DESCRIPTOR 
The first step toward creating an APK file is to prepare the application descriptor for 
inclusion. The big issue is that within the application descriptor file is the <content/> XML 
tag containing the following: [This value will be overwritten by Flash Builder 
in the output app.xml]. You don’t want to permanently change the application 
descriptor, so instead you’ll make a copy of the application descriptor and then replace the 
current contents with the name of your application file: RottenTomatoesAndroid.swf. 
<target name="-move-descriptor"> 
    <copy todir="${BUILD_DIR}" file="${SRC_DIR}/RottenTomatoesAndroid- 
    app.xml" overwrite="true"/> 
    <replace file="${BUILD_DIR}/RottenTomatoesAndroid-app.xml" token="[This  
    value will be overwritten by Flash Builder in the output app.xml]"  
    value="RottenTomatoesAndroid.swf"/> 
</target> 
These two lines will make a copy of the application descriptor into the temporary build file 
and 
then 
replace 
the 
<content/> 
tag’s 
current 
value 
with 
the 
string 
RottenTomatoesAndroid.swf. 
MOVING ASSETS 
If you used Flash Builder to make any release builds, you may remember that one of the 
steps was to select what additional assets and files you want to include with your package 
for those assets that are loaded at runtime. For your application, all of these files can be 
found in the assets folder. Your code will copy over your images from the current assets 
folder to an assets folder you’ll create in the build folder. For future applications you may 
also include XML files, sound and video, and anything else. For this application you just need 
the images: 
<target name="-move-assets"> 
    <copy todir="${BUILD_DIR}/assets" includeemptydirs="false"  
        overwrite="true"> 
        <fileset dir="${ASSETS_DIR}"> 
            <include name="**/*.png"/> 
        </fileset> 
    </copy> 
</target> 
All of your files are prepared; you’ll to make sure you have your certificate ready, and then 
you can package your application. 
CREATING A CERTIFICATE 
Previously you built into the package target logic to make sure that a certificate is only 
created if a certificate doesn’t exist. If you do need to create a certificate, you’ll use the ADT 
tool included with the Flex SDK. 

Automating builds using Ant  
347 
Along with a path to the ADT tool you’ll add some additional values to the build.properties 
file specifically for the Android build process. You’ll need to have a path to the ADT 
executable, different paths for Windows and Mac, and values for your certificate: 
#mac 
ADT=${FLEX_HOME}/bin/adt 
#pc 
#ADT=${FLEX_HOME}/bin/adt.exe 
# Certificate 
STORETYPE=pkcs12 
KEYSTORE=cert.p12 
CERT_NAME=Your-SelfSignedCertificate 
CERT_ORG_UNIT='Software Development' 
CERT_ORG_NAME=Flex_Mobile_In_Action 
CERT_COUNTRY=US 
CERT_KEY_TYPE=2048-RSA 
CERT_PASSWORD=YourP@ssword 
After updating the build.properties file, you’ll use the <exec/> tag to run the ADT 
executable, providing values for the certificate: 
<target name="-certificate" unless="${CERTIFICATE_EXISTS}"> 
    <exec executable="${ADT}" failonerror="true"> 
        <arg line="-certificate"/> 
        <arg line="-cn ${CERT_NAME}"/>                                    
        <arg line="-ou ${CERT_ORG_UNIT}"/>                                
        <arg line="-o ${CERT_ORG_NAME}"/>                                 
        <arg line="-c ${CERT_COUNTRY}"/>                                  
        <arg value="${CERT_KEY_TYPE}"/>                                   
        <arg value="${KEYSTORE}"/>                                        
        <arg value="${CERT_PASSWORD}"/>                                   
        <arg value="-validityPeriod 50"/>                                 
    </exec> 
</target> 
This completes creating the certificate. Now if a certificate doesn’t exist, your Ant file will 
create one as necessary. The only thing left to do is package up all of your files into an APK 
file. 
PACKAGING FOR THE MARKETS 
All of your files are in the right place. You’ll use the ADT tool provided by the Flex SDK and 
include the build.properties in the last section to combine all of your files into an APK file: 
<target name="-package-android"> 
    <exec executable="${ADT}" failonerror="true">                         
        <arg line="-package"/> 
        <arg line="-target apk"/> 
Certificate name 
Organization unit 
Organization name 
Certificate country 
Certificate type 
Certificate filename 
Certificate password 
Valid for 50 years 
Package using ANT 

348 
CHAPTER 12 Automated builds using Ant 
        <arg line="-storetype ${STORETYPE}"/>                             
        <arg line="-keystore ${KEYSTORE}"/> 
        <arg line="-storepass ${CERT_PASSWORD}"/> 
        <arg line="${RELEASE_DIR}/RottenTomatoesAndroid.apk"/>            
        <arg line="${BUILD_DIR}/RottentomatoesAndroid-app.xml"/>          
        <arg line="-C ${BUILD_DIR} RottenTomatoesAndroid.swf assets"/>    
        <arg line="-extdir ${ANES_DIR}"/>                                 
    </exec> 
</target> 
The APK file you’ve created is ready for the Android market APK; next, you’ll make one for 
the Amazon market. The only difference between the two is the line that says where to 
download the AIR runtime. Obviously, this change is optional depending on whether you plan 
to release to the Amazon market. The one variant line is noted in the following code:  
<target name="-package-amazon"> 
    <exec executable="${ADT}" failonerror="true"> 
        <arg line="-package"/> 
        <arg line="-target apk"/> 
        <arg line="-airDownloadURL                                        
             http://www.amazon.com/gp/mas/dl/android?p=com.adobe.air"/> 
        <arg line="-storetype ${STORETYPE}"/> 
        <arg line="-keystore ${KEYSTORE}"/> 
        <arg line="-storepass ${CERT_PASSWORD}"/> 
        <arg line="${RELEASE_DIR}/RottenTomatoesAmazon.apk"/> 
        <arg line="${BUILD_DIR}/RottentomatoesAndroid-app.xml"/> 
        <arg line="-C ${BUILD_DIR} RottenTomatoesAndroid.swf assets"/> 
        <arg line="-extdir ${ANES_DIR}"/> 
    </exec> 
</target> 
This wraps up the Android development section and leaves you with a build script that will 
create a new APK file after running your unit tests and building your application 
documentation, all with a single keystroke. Although Flash Builder simplifies making a 
release, build scripts like the one you’ve just completed make it even simpler. From now on, 
if other members of your team need to make a release build of your Android application, 
they don’t need to learn the Flash Builder wizard; they just need to run your build script. 
In the next section you’ll create a similar build script for the QNX platform, slightly 
altered for the nuances of the QNX platform. 
12.7 Packaging for QNX (BlackBerry) 
Now that you’ve finished the Android build script, you can work on packaging your QNX 
application with Ant. Like the Android build process, you’ll compile the application into a SWF 
file, prepare any files necessary for packaging, and then package the application. Unlike the 
Android build script, there are a few changes that need to be made. First, when you compile 
Include the certificate 
Output resulting APK 
to release folder 
Include 
application 
descriptor 
folder 
Include assets folder 
and compiled SWF file
Include ANEs 
AIR download link 

Automating builds using Ant  
349 
the application you need to include the QNX libraries for it to work on QNX devices. Second, 
you need to use BlackBerry-specific executable files to create a certificate and package the 
application. Finally, BlackBerry requires a signing process that I call “double-signing” to sign 
your application with BlackBerry (see the following listing). 
Listing 12.7 Current build script with package targets 
<?xml version="1.0" encoding="UTF-8"?> 
<project name="QNX Build File" basedir="." default="build"> 
    <property file="build.properties"/> 
    <taskdef name="mxmlc" classname="flex.ant.MxmlcTask"  
    classpath="${FLEX_TASKS}"/> 
    <taskdef name="compc" classname="flex.ant.CompcTask"  
    classpath="${FLEX_TASKS}"/> 
    <taskdef name="asdoc" classname="flex.ant.AsDocTask"  
    classpath="${FLEX_TASKS}"/> 
     
    <target name="build">                                                 
        <antcall target="-preclean"/>                                     
        <antcall target="run-tests"/>                                     
        <antcall target="package"/>                                       
        <antcall target="run-asdoc"/>                                     
        <antcall target="-postclean"/>                                    
    </target> 
     
    <target name="-preclean"> 
        <delete dir="${BUILD_DIR}" includeemptydirs="true"/> 
        <delete dir="${RELEASE_DIR}" includeemptydirs="true"/> 
        <mkdir dir="${BUILD_DIR}"/> 
        <mkdir dir="${RELEASE_DIR}"/> 
    </target> 
     
    <target name="-postclean"> 
        <delete dir="${BUILD_DIR}" includeemptydirs="true"/> 
    </target> 
     
    <target name="package">                                               
        <antcall target="-compile"/> 
        <antcall target="-move-descriptor"/> 
        <antcall target="-move-assets"/> 
        <available file="${KEYSTORE}"  
        property="CERTIFICATE_EXISTS"/>                                   
        <antcall target="-certificate"/> 
        <antcall target="-package"/> 
        <antcall target="-sign-application"/> 
    </target> 
     
Default build target 
Runs package targets 
Checks if certificate file exists 

350 
CHAPTER 12 Automated builds using Ant 
    <target name="-compile"></target>                                     
    <target name="-move-descriptor"></target>                             
    <target name="-move-assets"></target>                                 
    <target name="-certificate"  
        unless="${CERTIFICATE_EXISTS}"></target>                          
    <target name="-package"></target>                                     
    <target name="-sign-application"></target>                            
     
    <target name="run-tests"> 
    <!-- run project specific tests --> 
    </target> 
     
    <target name="run-asdoc"> 
    <!-- build project specific docs --> 
    </target> 
     
</project> 
{chap 12 QNX}/build.xml
If you forgot to create the build.properties file, go back and review section 12.2.1. 
Like the Android build file, the one segment of code that’s new to this build file is the 
<available/> tag in the package target. The <available/> tag checks to see if the 
requested file is available and puts the Boolean result in the CERTIFICATE_EXISTS 
property: 
<available file="${KEYSTORE}" property="CERTIFICATE_EXISTS"/> 
Then when you get to the point of running the target, you run the target only if 
CERTIFICATE_EXISTS is false: 
<target name="-certificate" unless="${CERTIFICATE_EXISTS}"></target> 
In the next section you’ll compile your application with the required QNX libraries. 
12.7.1 Compiling the QNX project 
To compile the QNX application you’ll use a combination of the Flex SDK and the BlackBerry 
Tablet SDK that you installed before developing your application. 
Install the BlackBerry Tablet SDK 
If you haven’t installed the BlackBerry Tablet SDK yet, you can find the instructions for 
doing 
this 
at 
http://www.adobe.com/devnet/air/articles/packaging-air-apps-
blackberry.html. 
Including the BlackBerry Tablet SDK will require you to add a few more paths into your 
build.properties file. Remember that it’s important to get your paths correct for your 
Compiles application 
Moves application descriptor 
for packaging
Prepares assets for packaging 
Creates certificate if necessary 
Packages application 
Double-signs 
application for
release

Automating builds using Ant  
351 
computer for the build script to work. The values included in the book are for my computer, 
although if you installed everything in the default locations, the values may match. 
I’ve installed the BlackBerry tablet SDK in the SDK folder alongside the other Flex SDKs 
installed on my computer within Flash Builder: 
BLACKBERRY=${FLASH_BUILDER}/sdks/blackberry-tablet-sdk-1.1.1 
BLACKBERRY_FRAMEWORK=${BLACKBERRY}/frameworks/libs 
QNX_SCREEN_DIR=${BLACKBERRY_FRAMEWORK}/qnx-screen 
BLACKBERRY_LIBS=${BLACKBERRY_FRAMEWORK}/blackberry 
BLACKBERRY_AIR_LIBS=${BLACKBERRY_FRAMEWORK}/air 
With your properties set properly, you can compile your SWF file: 
<target name="-compile"> 
    <mxmlc file="${SRC_DIR}/RottenTomatoesQNX.mxml"                       
        output="${BUILD_DIR}/RottenTomatoesQNX.swf"                       
        debug="false"                                                     
        failonerror="true"                                                
        fork="true" maxmemory="512m">                                     
            <load-config filename="${FLEX_HOME}/frameworks/airmobile- 
            config.xml" />                                                
            <source-path path-element="${SRC_DIR}"/>                     
            <library-path dir="${LIBS_DIR}" includes="*.swc"  
            append="true"/>                                              
            <library-path dir="${LIBRARY_DIR}/bin" includes="*.swc"  
            append="true"/>                                               
            <library-path dir="${QNX_SCREEN_DIR}" includes="*.swc"  
            append="true"/>                                               
            <library-path dir="${BLACKBERRY_LIBS}" includes="*.swc"  
            append="true"/> 
            <library-path dir="${BLACKBERRY_AIR_LIBS}" includes="qnx- 
            air.swc" append="true"/> 
    </mxmlc> 
</target> 
For the most part this build segment is similar to previous build segments with the inclusion 
of various source directories and library files. The one segment that may not be obvious, 
unless you already looked at the Android compile build code, is the fork and maxmemory 
attributes. 
Depending on your computer these attributes may not be necessary, but for some 
computers you need to cap the memory—using the maxmemory attribute—used by the 
computer to prevent an out-of-memory fault. Furthermore, you use the fork attribute to 
run your compiler on a different Java Virtual Machine instance from the rest of the build 
script. 
If all goes well, you should end up with the RottenTomatoesQNX.swf file in the temporary 
build directory, ready for packaging. In the next section you’ll package up your application 
using the BlackBerry packager executable. 
Compile RottenTomatoesQNX.mxml 
Output to build directory 
Don’t include debug information 
Stop build if compiling fails 
Protect against memory faults 
Include AIR mobile default configuration 
Include application’s library swcs 
Include RottenTomatoesLibrary.swc 
Include QNX libraries 
Include 
application’s 
source directory

352 
CHAPTER 12 Automated builds using Ant 
12.7.2 Packaging the QNX project 
Right now, unless you’ve gone through the Android build process, you’re probably wondering 
why you went through the process of creating a SWF file when what you really want is a BAR 
file. The answer is that a BAR file is just a compressed file containing a SWF file— the one 
you just built— any assets you may want to load at runtime, your developer certificate, and 
your application descriptor files. Now you’ll gather all of these files together so you can 
package them into a BAR file. 
ADDING PROPERTIES 
Before getting into your build script, you’ll add a few paths to your properties file for some of 
the executables and certificate properties you’ll need through the packaging process. The 
first set of properties you’ll add is for the BlackBerry executables. Depending on whether 
you’re using Windows or MAC, you’ll select between the different paths included here: 
#mac 
KEYTOOL=${BLACKBERRY}/bin/blackberry-keytool 
SIGNER=${BLACKBERRY}/bin/blackberry-signer 
PACKAGER=${BLACKBERRY}/bin/blackberry-airpackager 
#win 
#KEYTOOL=${BLACKBERRY}/bin/blackberry-keytool.bat 
#SIGNER=${BLACKBERRY}/bin/blackberry-signer.bat 
#PACKAGER=${BLACKBERRY}/bin/blackberry-airpackager.bat 
After you’ve set the executable paths, you’ll add in properties for your certificate that you 
may need to create: 
STORETYPE=pkcs12 
KEYSTORE=cert.p12                                                         
CERT_NAME=Your-SelfSignedCertificate                                      
CERT_ORG_UNIT='Software Development'                                      
CERT_ORG_NAME=Flex_Mobile_In_Action                                       
CERT_COUNTRY=US                                                           
CERT_KEY_TYPE=2048-RSA 
CERT_PASSWORD=YourP@ssword                                                
CSK_PASSWORD=YourCSKPassword                                              
Most of the certificate values you can set to be unique to your organization; others are fixed, 
specifically the STORETYPE and CERT_KEY_TYPE. The last value, the CSK_PASSWORD, is set 
when you’re setting up your developer account with BlackBerry. 
CSK password 
If you need help preparing your CSK password, please check out the following link and 
the section “Getting the required certificates”:  
http://www.adobe.com/devnet/air/articles/packaging-air-apps-blackberry.html
Certificate filename 
Certificate name 
Organization unit 
Organization name 
Your country of origin 
Certificate password 
Password you gave to BlackBerry 

Automating builds using Ant  
353 
Once you’ve set all of the values as you see fit, you can start preparing the application 
descriptor for packaging. 
PREPARING THE APPLICATION DESCRIPTOR 
To make the packaging process a bit easier, you need to make some changes to your 
application descriptor. Within the application descriptor is the <content/> tag, labeling the 
main application file for your mobile application. By default the content of the <content/> 
tag is [This value will be overwritten by Flash Builder in the output 
app.xml]. You’ll change this value to the name of your SWF file, RottenTomatoesQNX.swf, 
for your BAR package. But you don’t want to mutilate the original application descriptor to 
make this one change. The easiest way to make this change cleanly is to make a copy of 
your application descriptor and then adjust the copy instead of the original. 
In addition to the main application descriptor you need to have a copy of your blackberry-
tablet.xml file for packaging. You can take care of all these needs in a few lines of code in 
your build script: 
<target name="-move-descriptor"> 
    <copy todir="${BUILD_DIR}" file="${SRC_DIR}/blackberry-tablet.xml"  
    overwrite="true"/> 
    <copy todir="${BUILD_DIR}" file="${SRC_DIR}/RottenTomatoesQNX-app.xml"  
    overwrite="true"/> 
    <replace file="${BUILD_DIR}/RottenTomatoesQNX-app.xml" token="[This  
    value will be overwritten by Flash Builder in the output app.xml]"  
    value="RottenTomatoesQNX.swf"/> 
</target> 
With your application descriptor taken care of, you can organize your asset files for 
packaging. 
MOVING ASSET FILES 
By default any files embedded in code are automatically added to your SWF file. But if you 
have files that are loaded at runtime, these files won’t be part of the package unless you 
explicitly say to package them. To get over this little hump, you’ll move any files from your 
main application into your temporary build directory for final packaging. 
For your application you need to copy over any images in your assets folder: 
<target name="-move-assets"> 
    <copy todir="${BUILD_DIR}/assets" overwrite="true"> 
        <fileset dir="${ASSETS_DIR}"> 
            <include name="**/*.png"/> 
        </fileset> 
    </copy> 
</target> 
For more complex applications this step may become much more complicated. For your 
application this is all you need. You’re ready to create a certificate before the final packaging. 

354 
CHAPTER 12 Automated builds using Ant 
CREATING A CERTIFICATE 
If you’ve already used Flash Builder to make a BAR file, then you’ll have a certificate ready. 
If not, you’ll create one from the build script. As we discussed earlier, you need to check to 
make sure that the certificate doesn’t already exist prior to trying to make it; this way you 
don’t keep re-creating the same certificate. 
For the QNX certificate process you can’t reuse other certificates; instead you’ll use the 
BlackBerry keytool executable to create a BlackBerry-specific certificate. You’ll use the 
<exec/> tag to run the BlackBerry keytool executable to create the certificate: 
<target name="-certificate" unless="${CERTIFICATE_EXISTS}"> 
    <exec executable="${KEYTOOL}" failonerror="true"> 
        <arg line="-genkeypair"/> 
        <arg line="-keystore ${KEYSTORE}"/> 
        <arg line="-storepass ${CERT_PASSWORD}"/> 
        <arg line='-dname "cn=${CERT_ORG_NAME}"'/> 
        <arg line="-alias author"/> 
    </exec> 
</target> 
This target is now complete, and the required properties were provided to the executable. 
Now you can go forth and package your BAR file. 
PACKAGING THE BAR FILE 
Unlike the other build scripts, you won’t be using the ADT tool provided by the Flex SDK to 
package your application because BlackBerry requires you use their packager tool provided 
by the BlackBerry Tablet SDK. For the packager you’ll provide all of your prepared files and 
publisher information: 
<target name="-package"> 
    <exec executable="${PACKAGER}" failonerror="true"> 
        <arg line="-package ${RELEASE_DIR}/RottenTomatoesQNX.bar"/> 
        <arg line="-publisher ${CERT_ORG_NAME}"/> 
        <arg line="${BUILD_DIR}/RottenTomatoesQNX-app.xml"/> 
        <arg line="${BUILD_DIR}/RottenTomatoesQNX.swf"/> 
        <arg line="${BUILD_DIR}/blackberry-tablet.xml"/> 
        <arg line="${BUILD_DIR}/assets"/> 
    </exec> 
</target> 
You’ll notice that you haven’t provided your publisher certificate yet; this is because in the 
next section you’ll use another executable to sign the generated BAR file with the certificate. 
12.7.3 Double-signing the BAR file 
For the other platforms, as soon as the APK or IPA file is available you can start uploading 
your application to the market. With the BAR file, you still need to sign your application with 
BlackBerry before you can upload it to the BlackBerry App World store. 

Automating builds using Ant  
355 
This signing process requires internet access, because you need to communicate with the 
BlackBerry servers for signing. 
You’ll use the BlackBerry signer executable to double-sign your application with 
BlackBerry. The two-step process checks your version number to ensure uniqueness with 
BlackBerry and signs your application with both your certificate and BlackBerry data. 
<target name="-sign-application"> 
    <exec executable="${SIGNER}" failonerror="true"> 
            <arg line="-verbose -cskpass ${CSK_PASSWORD} -keystore  
            ${KEYSTORE} -storepass ${CERT_PASSWORD}  
            ${RELEASE_DIR}/RottenTomatoesQNX.bar RDK"/> 
    </exec> 
    <exec executable="${SIGNER}" failonerror="true"> 
    <arg line="-verbose -keystore ${KEYSTORE} -storepass  
            ${CERT_PASSWORD}  ${RELEASE_DIR}/RottenTomatoesQNX.bar  
            author"/> 
    </exec> 
</target> 
This marks the end of your QNX work with this amazing BAR build script. Once this process is 
complete, in your release folder you’ll have your final, signed, and releasable BAR file that’s 
ready to be uploaded to the BlackBerry App World store.  
If you went through the Flash Builder release wizard for BlackBerry, I’m sure you’ll agree 
that running just one build script is easier than all of the other steps necessary to make your 
BAR file. 
You’re now ready to move onto the final platform and build your iOS application with Ant. 
12.8 Packaging for iOS 
Having finished the Android and QNX build scripts, you’ve now reached the final one, iOS. 
Like the other build scripts, the purpose of the iOS build script is to prepare, compile, and 
package your application for release to the App Store. The main difference between the 
Android build script and the iOS build script is the lack of certificate creation. The reason why 
you can’t create your certificate from the build script is that you have to get your certificate 
from the iOS provisioning portal: http://developer.apple.com/devcenter/ios/index.action.  
Required files 
To build your application you must have a certificate and provisioning file for distribution. 
If you haven’t pulled these files already or need help getting these files, please visit this 
link: 
http://www.adobe.com/devnet/air/articles/packaging-air-apps-ios.html 

356 
CHAPTER 12 Automated builds using Ant 
With the required files you can begin packaging your application. For your iOS build script 
you’ll move your ANE file, compile the SWF file, prepare your assets and application 
descriptor, and finally package your application with the ADT executable provided by the Flex 
SDK (see the following listing). 
Listing 12.8 Current build script with package targets 
<?xml version="1.0" encoding="UTF-8"?> 
<project name="iOS Build File" basedir="." default="build"> 
     
    <property file="build.properties"/> 
    <taskdef name="mxmlc" classname="flex.ant.MxmlcTask"  
    classpath="${FLEX_TASKS}"/> 
    <taskdef name="compc" classname="flex.ant.CompcTask"  
    classpath="${FLEX_TASKS}"/> 
    <taskdef name="asdoc" classname="flex.ant.AsDocTask"  
    classpath="${FLEX_TASKS}"/> 
     
    <target name="build">                                                
        <antcall target="-preclean"/>                                    
        <antcall target="run-tests"/>                                    
        <antcall target="package"/>                                      
        <antcall target="run-asdoc"/>                                    
        <antcall target="-postclean"/>                                   
    </target> 
     
    <target name="-preclean"> 
            <delete dir="${BUILD_DIR}" includeemptydirs="true"/> 
            <delete dir="${RELEASE_DIR}" includeemptydirs="true"/> 
            <mkdir dir="${BUILD_DIR}"/> 
            <mkdir dir="${RELEASE_DIR}"/> 
    </target> 
     
    <target name="-postclean"> 
        <delete dir="${BUILD_DIR}" includeemptydirs="true"/> 
    </target> 
     
    <target name="package">                                               
        <antcall target="-move-anes"/>                                    
        <antcall target="-compile"/>                                      
        <antcall target="-move-descriptor"/>                              
        <antcall target="-move-assets"/>                                  
        <antcall target="-package-ios"/>                                  
    </target> 
     
    <target name="-move-anes"></target>                                   
    <target name="-compile"></target>                                     
Default build target 
Calls packaging targets 
Moves ANEs for compiling 
Compiles SWF file 

Automating builds using Ant  
357 
    <target name="-move-descriptor"></target>                             
    <target name="-move-assets"></target>                                 
    <target name="-package-ios"></target>                                 
     
    <target name="run-tests"> 
    <!-- run project specific tests --> 
    </target> 
     
    <target name="run-asdoc"> 
    <!-- build project specific docs --> 
    </target> 
     
</project> 
{chap 12 iOS}/build.xml
If you forgot to create the build.properties file, go back and check out section 12.2.1. 
Your build script includes all the necessary package targets. In the next section you’ll 
build out the compile section before packaging your application. 
12.8.1 Compiling the iOS project 
The process of creating an IPA file doesn’t go straight from source code to IPA file; there’s a 
pit stop in SWF file land. An IPA file is a ZIP file containing a SWF file, application descriptor, 
additional assets, and certificate. Therefore you need to compile your application into a SWF 
file before you can make your IPA file in the packaging step. 
You’ll start your compiling process by prepping your ANE file for SWF compiling. 
MOVING ANES 
ANE files by themselves can’t be compiled into your SWF file; you can get around this by 
making a slight adjustment to your ANE file and making it look like a SWC file. If you weren’t 
using ANE files, this step wouldn’t be necessary, but because you are, this step is required. 
For this step you’re copying the ANE to the temporary build folder and renaming it as an 
SWC file at the same time: 
<target name="-move-anes"> 
    <copy file="${ANES_DIR}/com.adobe.extensions.Vibration.ane"  
    tofile="${BUILD_DIR}/Vibration.swc"/> 
</target> 
With your ANE prepped you can go ahead and compile your application to the necessary SWF 
file. 
COMPILING THE SWF FILE 
To compile your SWF file you’ll use the mxmlc task provided by the Flex SDK. For the mxmlc
task you need to determine the main application to compile, the source code, and a few 
other options: 
Copies and edits application 
descriptor
Moves assets for packaging 
Packages IPA file 

358 
CHAPTER 12 Automated builds using Ant 
<target name="-compile"> 
    <mxmlc file="${SRC_DIR}/RottenTomatoesIOS.mxml"                       
        output="${BUILD_DIR}/RottenTomatoesIOS.swf"                       
        debug="false"                                                     
        failonerror="true"                                                
        fork="true" maxmemory="512m">                                     
           <load-config filename="${FLEX_HOME}/frameworks/airmobile- 
           config.xml" />                                                 
           <source-path path-element="${SRC_DIR}"/>                      #G 
           <library-path dir="${LIBS_DIR}" includes="*.swc" 
           append="true"/>                                                
       <library-path dir="${LIBRARY_DIR}/bin" includes="*.swc"  
       append="true"/>                                                    
       <external-library-path dir="${BUILD_DIR}" includes="*.swc"  
       append="true"/>                                                    
    </mxmlc> 
</target> 
Most of the settings required for compiling an application define the location for the code that 
will be compiled. There are a few settings that aren’t as obvious.  
The first setting is the debug attribute. The debug attribute determines whether you’ll 
include all of debug information with your compiled application. For a release-quality build 
you’ll definitely want to have this value be false. 
The next two attributes are fork and maxmemory. These attributes are included to 
protect your build against out-of-memory errors. Depending on the computer running the 
build, this setting may not be necessary, but on computers without large sets of available 
memory, the compiler may request more memory than is available and fail. To protect 
against this, you’ll set the maximum memory that the Java Virtual Machine can use. The 
fork attribute tells the mxmlc task to run on its own instance of the Java Virtual Machine, 
freeing up resources for the mxmlc task. 
Once the mxmlc task is complete, you’ll have your RottenTomatoesIOS.swf file ready for 
inclusion in your IPA package. You can now move forward to the next section and prepare 
your other files for packaging. 
12.8.2 Packaging the iOS project 
With your SWF file ready you can begin preparing your other files for packaging. In this 
section you need to adjust your application descriptor, move your assets to the temporary 
build folder, and finally package everything up into an IPA file. 
PREPARING THE APPLICATION DESCRIPTOR 
As it stands right now, your application descriptor isn’t ready for packaging. If you use it the 
way it is, your build would fail because the content is missing. This error doesn’t make a 
whole lot of sense until you go into your application descriptor and see that there’s a 
<content/> tag and its content is [This value will be overwritten by Flash 
Selected application to 
compile 
Output location 
Don’t include debug 
information 
Stop 
build if 
compiler 
fails
Protect against memory errors 
Include AIR mobile default selections 
Include project’s 
source folder
Include project’s library folder 
Include RottenTomatoesLibrary 
Include ANEs 

Automating builds using Ant  
359 
Builder in the output app.xml]. This tells you that you need to replace this text 
with the name of your application SWF, RottenTomatoesIOS.swf, during the build process. 
You don’t want to alter the original application descriptor file, so instead you’ll make a copy 
of the application descriptor and then replace the offending text. This is the functionality that 
the –move-descriptor handles for you: 
<target name="-move-descriptor"> 
    <copy todir="${BUILD_DIR}" file="${SRC_DIR}/RottenTomatoesIOS-app.xml"  
    overwrite="true"/> 
    <replace file="${BUILD_DIR}/RottenTomatoesIOS-app.xml" token="[This  
    value will be overwritten by Flash Builder in the output app.xml]"  
    value="RottenTomatoesIOS.swf"/> 
</target> 
With your application descriptor ready, you can prepare your additional assets for packaging.  
MOVING ASSETS 
The next set of files that you need to prep for packaging is your additional assets. Although 
assets that you embed into your application are already included in the SWF file, any assets 
that you link to or load at runtime won’t be included in your application. Furthermore, you 
don’t want to include every possible file because each file adds to the size of your final IPA 
file. Therefore, when you prepare your assets, you’re going to move just the images from 
your assets folder and not any other file: 
<target name="-move-assets"> 
    <copy todir="${BUILD_DIR}/assets" includeemptydirs="false"  
        overwrite="true"> 
            <fileset dir="${ASSETS_DIR}"> 
                <include name="**/*.png"/> 
           </fileset> 
    </copy>
</target> 
The assets you intend to package in your IPA file are ready, and you can move on to 
packaging your IPA file with the ADT executable provided by the Flex SDK. 
PACKAGING THE IPA FILE 
The process of creating an IPA file is slightly different than any other platform because ADT, 
which is provided by the Flex SDK, does a lot of extra work to prepare the final file. The code 
is fairly straight forward, but when you run this packaging command you may want to take a 
lunch break or pour a drink because this will take a while. 
Before we get to packaging, you need to add a few lines into your build.properties
file for the packager to work. Remember that the values I provide are for example purposes, 
so you’ll have to alter these values with your own filenames and password values. 

360 
CHAPTER 12 Automated builds using Ant 
The first value you need to add is a path to the ADT executable. Depending on whether 
you’re on a Mac or PC, you’ll select one path or the other, but as long as your path to the 
Flex SDK was set properly beforehand, then the provided values should work for you: 
#mac 
ADT=${FLEX_HOME}/bin/adt 
#win 
#ADT=${FLEX_HOME}/bin/adt.exe 
Next, you’ll add paths and values for your certificate and provisioning file provided to you 
from the iOS provisioning portal discussed in section 12.9. For me, the provisioning file and 
certificate are found under the root of the RottenTomatoesIOS folder: 
PROVISIONING_FILE=YourProvisioningFile.mobileprovision 
STORETYPE=pkcs12 
KEYSTORE=cert.p12 
CERT_PASSWORD=YourP@ssword 
With your build.properties updated, you have all the values necessary to build your IPA file: 
<target name="-package-ios"> 
    <exec executable="${ADT}" failonerror="true"> 
        <arg line="-package"/>                                            
        <arg line="-target ipa-app-store"/>                               
        <arg line="-provisioning-profile ${PROVISIONING_FILE}"/>          
        <arg line="-storetype ${STORETYPE}"/>                             
        <arg line="-keystore ${KEYSTORE}"/>  
        <arg line="-storepass ${CERT_PASSWORD}"/> 
        <arg line="${RELEASE_DIR}/RottenTomatoesIOS.ipa"/>                
        <arg line="${BUILD_DIR}/RottentomatoesIOS-app.xml"/>             #F 
        <arg line="-C ${BUILD_DIR} RottenTomatoesIOS.swf assets"/>        
        <arg line="-extdir ${ANES_DIR}"/>                                 
    </exec> 
</target> 
Once everything is ready, you can start running your packaging build script back from the 
beginning, the build target. When you get to the –package-ios target, the process will 
appear to freeze, but don’t worry, this is supposed to happen. The ADT executable won’t 
provide you any console feedback until the process is complete, which could take around 10 
minutes, so be patient. 
With the –package-ios target completed, you’ve now successfully built an IPA file using 
Ant. This puts a wrap on your iOS coding for the book. You should be proud because you 
have a build script that tests, packages, and documents your iOS without having to 
remember all the steps through a wizard. 
Packaging your app 
Targeting an app store release 
Your release 
provisioning file
Including your 
certificate and 
password
Outputting to 
release 
directory 
Including 
application 
descriptor
SWF file with 
additional assets
ANE folder as 
external directory 

Automating builds using Ant  
361 
12.9 Final steps 
Because we’re in the last section of the last chapter, we should look at a few places where 
you can extend your build files to go above and beyond the normal workday. In this section 
we’ll look at how you can use additional build tools to give you additional information about 
the code you’ve written and simplify your build process yet again. 
12.9.1 FlexPMD, FlexCPD, and FlexMetrics 
Although you may already be an ActionScript and Flex expert, there are always things you 
can do to improve your code. Adobe provides three such tools that you can integrate with 
Flash Builder or your build scripts: FlexPMD, FlexCPD, and FlexMetrics. The true beauty of 
creating build scripts and integrating these tools comes when you integrate all these tools 
with a continuous integration build system. Web applications like Hudson (http://hudson-
ci.org/) and Jenkins (http://jenkins-ci.org/) will automatically run your build script and 
reporting tools each time you push code into your code repositories run by tools like SVN, 
CVS, or—my favorite—GIT. This level of feedback will improve your coding practices and the 
code you write. 
FLEXPMD 
The first, FlexPMD, builds on the popular Java PMD tool. After running the FlexPMD tool, 
you’ll receive a nice report outlining the following possible offenders within your code: 
 
Unused code (functions, variables, constants) 
 
Inefficient code (misuse of dynamic filters, heavy constructors) 
 
Over-complex code (nested loops, too many conditionals) 
 
Over-long code (classes, methods) 
 
Incorrect use of the Flex component lifecycle (commitProperties) 
If you want to include FlexPMD in your build scripts or within Flash Builder, visit the FlexPMD 
open 
source 
site 
for 
step-by-step 
instructions: 
http://opensource.adobe.com/wiki/display/flexpmd/FlexPMD. 
FLEXCPD 
The second, FlexCPD, is a close cousin to FlexPMD. FlexCPD is a “copy and paste detector.” 
Although copying and pasting isn’t a crime, if you’re doing it too often in code you leave 
yourself open to a few possible big mistakes. The first mistake happens when you copy and 
paste code without making necessary adjustments for the copied code to fit the required 
functionality, leading to buggy code that may need to be revisited for correctness. The 
second is that you’re missing the chance to simplify your code by creating a single method 
that can be used in multiple places. 

362 
CHAPTER 12 Automated builds using Ant 
If you want to include FlexCPD in your build scripts or within Flash Builder, visit the 
FlexCPD 
open 
source 
site 
for 
step-by-step 
instructions: 
http://opensource.adobe.com/wiki/display/flexpmd/FlexCPD. 
FLEXMETRICS 
The third, FlexMetrics, builds on FlexPMD and provides metrics on each of your packages. 
Specifically, FlexMetrics will tell you about your code-to-comments ratio, reminding you to 
write comments throughout your code along with a few other fun metrics. 
If you want to include FlexMetrics in your build scripts or within Flash Builder, visit the 
FlexMetrics 
open 
source 
site 
for 
step-by-step 
instructions: 
http://opensource.adobe.com/wiki/display/flexpmd/FlexMetrics.  
12.9.2 Master build file 
Even though you have four amazing build scripts that create your library, APK, BAR, and IPK 
files, as a developer you should always strive to make your life a bit easier. In this case you 
could simplify your life by reducing the number of build scripts to one—one master build 
script to run all of the other build scripts you’ve already created (see figure 12.8). 
Figure 12.8 Master build script layout 
This single build script placed in your workspace above the rest of your projects calls all of 
your other build scripts, as shown in the following listing. 
Listing 12.9 Master build script 
<?xml version="1.0" encoding="UTF-8"?> 
<project name="Master Build File" default="build"> 
     

Automating builds using Ant  
363 
    <target name="build"> 
            <ant antfile="RottenTomatoesLibrary/build.xml"  
            inheritall="false"/>                                          
            <ant antfile="RottenTomatoesAndroid/build.xml"  
            inheritall="false"/>                                          
            <ant antfile="RottenTomatoesQNX/build.xml" 
            inheritall="false"/>                                          
            <ant antfile="RottenTomatoesIOS/build.xml"  
            inheritall="false"/>                                          
    </target> 
     
</project> 
{main project]/build.xml 
This little touch of class lets you create new builds for each of your platforms by running one 
script. With the extreme ease of building release files, there should be no reason why anyone 
on your team should have any problem building a tested release file. Obviously, this is a 
secret that you shouldn’t share with the rest of your team because your skills for creating 
amazing release files will make you a super hero in the office. 
12.10 Summary 
We’ve reached the very end. Just a few chapters ago we were looking at the basics of Flex, 
starting up a mobile application, and making service calls. In no time at all you made an 
application that could run at multiple resolutions; refactored to an MVC(S) framework using 
Robotlegs; added native extensions, ads, and user tracking; and created unit tests for your 
application. You’ve just completed a monster undertaking, using Ant to make release files for 
each of the markets and allowing you to integrate with continuous-build systems. With all of 
these topics there isn’t an application too big or too small that you can’t complete.  
Key takeaways: 
 
Creating build scripts with Ant 
 
Using Ant to build Android, QNX, and iOS release files 
 
Running automated unit tests 
 
Creating a master build script 
Build your library 
Build your APK file 
Build your BAR file 
Build your IPK file 

