www.allitebooks.com

Kohana 3.0 
Beginner's Guide
Develop professional web applications with Kohana
Jason D. Straughan
   BIRMINGHAM - MUMBAI
www.allitebooks.com

Kohana 3.0 
Beginner's Guide
Copyright © 2011 Packt Publishing
All rights reserved. No part of this book may be reproduced, stored in a retrieval system, 
or transmitted in any form or by any means, without the prior written permission of the 
publisher, except in the case of brief quotations embedded in critical articles or reviews.
Every effort has been made in the preparation of this book to ensure the accuracy of the 
information presented. However, the information contained in this book is sold without 
warranty, either express or implied. Neither the author, nor Packt Publishing, and its dealers 
and distributors will be held liable for any damages caused or alleged to be caused directly or 
indirectly by this book.
Packt Publishing has endeavored to provide trademark information about all of the 
companies and products mentioned in this book by the appropriate use of capitals. 
However, Packt Publishing cannot guarantee the accuracy of this information.
First published: August 2011
Production Reference: 1180811
Published by Packt Publishing Ltd.
Livery Place
35 Livery Street
Birmingham B3 2PB, UK
ISBN 978-1-849512-40-4
www.packtpub.com
Cover Image by Asher Wishkerman (a.wishkerman@mpic.de)
www.allitebooks.com

Credits
Author
Jason D. Straughan
Reviewers
Geert De Deckere
Paul Liversidge
Acquisition Editor
Tarun Singh
Development Editor
Chris Rodrigues
Technical Editor
Ajay Shanker
Indexer
Hemangini Bari
Project Coordinator
Michelle Quadros
Proofreader
Clyde Jenkins 
Graphics
Nilesh Mohite
Production Coordinator
Adline Swetha Jesuthas
Cover Work
Adline Swetha Jesuthas
www.allitebooks.com

About the Author
Jason D. Straughan lives in the beautiful Texas Hill Country, where he builds web 
applications, writes, and spends time with his family. He began programming in grade school, 
developing professionally in the early 1990s, and has spent his career working in project 
management and software development. His passion for open source technologies and 
the Web experience has been a driving force in his appreciation for PHP and the Kohana 
framework.
Jason spends his days as a software engineer at Live Oak 360, a custom application 
development company focused on complex solutions and unique social platforms. During 
his time at Live Oak 360 and its sister company, 44Doors, Jason has assisted with the 
development of two software-as-a-service products, BudURL and BearHug, in addition 
to several custom application platforms. He also provides consultation and training to 
a select number of private clients, and is a founding partner in Straughan Photography 
(SanAntonioWeddingPhotography.com) with his wife and managing partner, Chrystina.
You can follow Jason's blog, and read more about Kohana and web-related topics at 
www.JDStraughan.com.
Most of all, I would like to think my wife, Chrystina, and my son, Michael, 
for all their love and support. This book would never have become a reality 
had it not been for their patience and understanding during many evenings 
and weekends of writing.

I would also like to thank: Dr. Ken Jones, not only for convincing me to 
use PHP in the first place, but also for always offering inspiration and wise 
counsel; James Zimmermann, who has provided constant encouragement 
and optimism during this endeavor; and David Salazar, who is always willing 
to talk about code, and for introducing me to Kohana many years ago. 
Throughout the course of the writing, Isaac Castillo acted as an enthusiastic 
and helpful tester, sometimes without even knowing it—thanks Isaac.
www.allitebooks.com

The technical reviewers for this book have provided many valuable insights, 
enhancements, and suggestions that are reflected in the final draft. 
This group of reviewers had a significant impact on the final text, and I 
genuinely thank each and every one who contributed. Specifically, I would 
like to thank Geert De Deckere for his level of dedication to the project, and 
for being a great resource throughout the revision process.

Last, but not least, I congratulate the Kohana development team and 
community for consistently producing an incredible framework. Without 
these dedicated and outstanding developers, there wouldn't be a Kohana 
framework for us to use, much less write about.
www.allitebooks.com

About the Reviewers
Geert De Deckere is a web designer and developer living in Belgium. Mostly in the earlier 
years of Kohana, he was involved in the development of the framework. Also, he is the 
creator of http://kohanajobs.com/. When he is not building websites or playing around 
with regular expressions, he enjoys cycling. His personal website can be found at http://
geertdedeckere.be/.
Paul Liversidge is a freelance ICT management consultant by day, and a web developer 
by night. As a consultant, his role is to turnaround ailing ICT departments through the 
innovative use of technology, adopting best practice processes, and addressing the most 
critical assets—the people. With a technical background in network and server design, 
project management expertise and business acumen gained from multiple business sectors, 
he brings a formidable breadth of experience to bear on any ICT issue.
As a web developer, he's excited by all things shiny, such as jQuery, Kohana, and pushing 
PHP, MySQL, CSS, and HTML forward. A frequent contributor to open source products that 
struggles to balance the responsibilities of a wife, two kids, and a dog, with a mania for 
writing code.
Paul is originally from Yorkshire in the UK, but now calls Vancouver, BC, Canada home.
I'd like to thank my wife and kids for allowing me to steal some time from 
them to review this book and my poor despondent dog that lost out on 
his long walks in the park. I'd also like to say a big thank you to Woody Gilk 
(Shadowhand) for sharing Kohana with the wider community, and I hope 
that my own involvement in reviewing this book has helped to widen the 
usage of Kohana.
www.allitebooks.com

www.PacktPub.com
Support files, eBooks, discount offers and more
You might want to visit www.PacktPub.com for support files and downloads related to your 
book. 
Did you know that Packt offers eBook versions of every book published, with PDF and ePub 
files available? You can upgrade to the eBook version at www.PacktPub.com and as a print 
book customer, you are entitled to a discount on the eBook copy. Get in touch with us at 
service@packtpub.com for more details.
At www.PacktPub.com, you can also read a collection of free technical articles, sign up for a 
range of free newsletters and receive exclusive discounts and offers on Packt books and eBooks.
http://PacktLib.PacktPub.com 
Do you need instant solutions to your IT questions? PacktLib is Packt's online digital book 
library. Here, you can access, read and search across Packt's entire library of books. 
Why Subscribe?


Fully searchable across every book published by Packt


Copy & paste, print and bookmark content


On demand and accessible via web browser
Free Access for Packt account holders
If you have an account with Packt at www.PacktPub.com, you can use this to access 
PacktLib today and view nine entirely free books. Simply use your login credentials for 
immediate access.
www.allitebooks.com

www.allitebooks.com

Table of Contents
Preface	
1
Chapter 1: Getting Started	
11
System requirements	
12
Case Study	
12
Downloading and installing from the Web	
13
Time for action – Downloading from web	
13
Installing Kohana from GitHub	
14
Time for action – downloading using Git	
14
Advanced installation with Git	
17
Taking inventory	
18
Preparing the Filesystem	
19
Testing the environment	
20
Configuring Kohana for Development Environment	
22
Time for action – Setting your Timezone	
22
Configuring URL settings	
23
Time for action – setting base URL	
23
Setting up the Application Environment	
24
Time for action – Setting Kohana::$environment	
24
Enabling modules	
25
Time for action – Enabling the User Guide	
25
Creating a default config file	
26
Server configuration	
27
Configuring Apache	
27
Configuring nginx	
28
Testing your configuration	
28
Summary	
31
www.allitebooks.com

Table of Contents
[ ii ]
Chapter 2: Using Views and Controllers	
33
What are controllers and views?	
34
Anatomy of a view	
34
Anatomy of a controller	
35
Updating our Welcome Controller	
37
Time for action – Getting our controller action to use a view file	
37
Passing data to the view	
38
Using the factory( ) method	
39
Time for action – Passing data via the factory method	
39
Using view variables	
40
Time for action – Passing data as view variables	
40
Using the set( ) method	
41
Time for action – Passing data using the set() method	
41
Using the bind( ) method	
42
Time for action – Passing data using the bind( ) method	
42
Putting it all together	
44
Time for action – Passing data using multiple methods	
44
Using the Template Controller	
46
Time for action – Extending Kohana's Template Controller	
46
Examining the Template controller	
48
Setting global view variables	
50
Time for action – Setting global view variables	
50
Binding global view variables	
52
Time for action – Binding global view variables	
53
Beyond the Welcome Controller	
53
Creating new controllers	
54
Time for action – Creating our first controller	
54
Time for action – Expanding on our first controller	
55
Creating a base controller	
58
Time for action – Creating an abstract controller	
58
Putting it all together	
60
Time for action – Adding stylesheets to template	
61
Adding structure to view files	
65
Time for action – Adding header and footer view files	
65
Summary	
68
Chapter 3: Routing and Request Handling	
69
Hierarchy is King in Kohana	
70
Cascading filesystem	
70
Request flow in Kohana	
72
Using the Request object	
74

Table of Contents
[ iii ]
Creating a profile page to render messages	
76
Time for action – Creating a profile page with messages	
77
Calling a new request inside a request	
79
Time for action – Creating a request within a request	
79
Routing in Kohana	
83
Time for action – Making profiles dynamic using ID	
84
Creating friendly URLs using custom routes	
86
Time for action – Creating a Custom Route	
86
Making routes explicit	
88
Time for action – Adding regex to a route	
88
Allowing additional data in a URI	
89
Time for action – Allowing additional segments in a route	
89
Using subdirectories with routes	
90
Time for action – Using Subdirectories and Routes	
91
Summary	
93
Chapter 4: Working with Helpers and Classes	
95
Autoloading classes	
96
Introducing helpers	
96
The Date class	
97
The HTML Class	
98
The HTML::chars() method	
99
The HTML::obfuscate() method	
99
The HTML::anchor() method	
100
The HTML::image() method	
101
The HTML::mailto() method	
101
The Inflector Class	
101
The URL class	
103
The URL::title() method	
103
The URL::base() method	
103
The URL::query() method	
104
The Arr (Array) Class	
104
The Arr::get() method	
105
The Arr::extract() method	
105
The Arr::pluck() method	
105
The Arr::merge() method	
106
The Arr::overwrite() method	
107
The Arr::flatten() method	
108
The Arr::unshift() method	
109
The Arr::map() method	
109
The Arr::is_array() method	
110
The Arr::range() method	
110
The Cookie class	
111
The Encrypt (Encryption) Class	
112
Time for action – Creating configuration for Encryption	
113

Table of Contents
[ iv ]
The Feed Class	
115
The Form Class	
118
Time for action – Creating a login form using the Form helper class	
119
Time for action – Creating a signup form for new users	
122
Extending Helpers	
127
Transparent Class Extension	
127
Time for action – Extending the HTML helper method	
127
Creating your own helpers	
130
Summary	
130
Chapter 5: Installing and Configuring Modules	
131
Anatomy of a Module	
131
Loading and configuring modules	
132
Bundled modules	
133
User guide module	
134
Image module	
135
oAuth module	
138
Database and ORM modules	
138
Time for action – Configuring your application to use a database	
139
Time for action – Creating a database table and using the query builder	
141
Pagination module	
145
Time for action – Adding pagination to database results	
146
Auth module	
151
Code Bench module	
152
Cache and Unit Test modules	
153
Installing modules	
153
Installing modules from source files	
153
Time for action – Installing a module from an archive	
154
Installing modules via Git	
156
Time for action – Installing a module using git 	
156
Creating your own modules	
159
Summary	
160
Chapter 6: Interacting with the Database	
161
Anatomy of a model	
161
Creating models	
162
Using the Database module	
163
Configuring the Database module	
163
Creating and running queries	
165
Using the Query Builder	
169
Select statements	
169
Using results	
175

Table of Contents
[ v ]
Time for action – Refactoring Model_Message to allow dynamic search	
179
Insert statements	
185
Time for action – Adding the ability to insert messages in case study site	
185
Updating statements	
192
Time for action – Add ability to edit messages in case study site	
193
Delete statements	
201
Time for action – Add ability to delete messages from the case study site	
202
Other functions and expressions	
209
Using the Database Module with sessions	
211
Configuring database sessions	
211
Time for action – Adding session handling with the database adapter	
211
Using Database Sessions	
212
Summary	
213
Chapter 7: Using the ORM and Auth Modules	
215
Using the ORM module	
215
Setting up the ORM module	
216
Convention over configuration	
216
ORM API Overview	
217
Time for action – Updating Message Model to use ORM	
224
ORM, Forms, and Validation	
230
The Validation class	
230
Time for action – Adding validation to Message Model	
234
ORM and Relational Data	
238
Using the Auth module	
241
Configuring the Auth module	
241
Time for action – Adding users and Auth to case study site	
241
Implementing the Auth module	
243
Time for action – Adding the Auth functionality to the case study site	
244
Securing controllers and actions	
258
Time for action – Adding secure actions to the case study site	
258
Summary	
262
Chapter 8: Troubleshooting and Error Handling	
263
Debugging code with Kohana	
263
Debugging with the Kohana class	
264
Error and exception handling	
268
Time for action –  Adding error messages to signup form	
269
Disabling the error handler	
272
Viewing the error logs	
273
Handling 404 redirects	
273
Time for action – Adding a custom 404 page	
274
Profiling our applications	
277

Table of Contents
[ vi ]
Time for action – Adding profiling to the case study project	
278
Summary	
281
Chapter 9: Securing and Deploying Kohana 3	
283
Securing our applications	
283
XSS attacks	
284
Time for action – Securing against  XSS risks	
285
SQL injection	
288
Cookies and sessions	
289
Securing cookies	
289
Securing sessions	
291
Configuring the application environment	
292
Preparing for production	
294
Removing unnecessary files	
295
Directory structure considerations	
295
Multiple Application Configuration	
297
Updating the Configuration settings	
298
Summary	
299
Appendix: Upgrading from CodeIgniter and Kohana 2	
301
What makes Kohana different from CodeIgniter?	
302
Moving from CodeIgniter to Kohana	
304
Autoloading classes	
304
Strict PHP 5 codebase	
304
Included ORM	
304
Modules	
305
Moving from Kohana 2.x	
305
GET and POST methods	
306
Directory structure	
306
Naming conventions	
307
Views	
308
Updated ORM	
308
Routing and requests	
310
Upgrading from Kohana 3.0 to 3.1	
312
Request and response classes	
312
Security enhancements	
313
Bootstrapping and the front controller	
313
Validation library	
314
Other changes	
314
Index	
317

Preface
The Kohana framework for PHP 5 is a robust library for rapidly creating applications. No 
previous experience with Kohana, CodeIgniter, or MVC frameworks is assumed or needed to 
understand and use this book, and any previous experience will only assist you as we learn 
the Kohana framework from the ground up.
Brief history of Kohana
Before Kohana, there was CodeIgniter. Developed by EllisLab, and the driving force behind 
Expression Engine, CodeIgniter, gained huge popularity in the PHP community, especially 
among developers seeking MVC solutions for their growing needs.
Eventually, CodeIgniter was forked to bring it up to speed with PHP 5, and Kohana was born. 
Kohana 2 relied on the open source community for its development, and quickly grew into a 
production-ready framework, used by developers all over the world.
Kohana 3 is a completely rebuilt framework, utilizing a HMVC design pattern, and leveraging 
the power of PHP 5 like never before. Although Kohana 2 is still being supported, all new 
applications written with Kohana are recommended to use the Kohana 3 release to allow for 
a longer support cycle. Kohana 3 is not backwards compatible with Kohana 2 or CodeIgniter, 
and migration can be difficult.
If you have experience with Kohana 2, and would like to see the differences in more details, 
and understand the process of moving from Kohana 2 to Kohana 3, please take at look at the 
Appendix: Upgrading from CodeIgniter and Kohana 2. This is also a good resource if you have 
a Kohana 2 application you want to migrate to the Kohana 3 platform.

Preface
[ 2 ]
Kohana's user guide and API reference
Kohana ships with a complete user guide and API reference. In Chapter 1, we will install 
the framework with the user guide module, allowing us to browse the guide from 
within our application. The official guide is available on the Kohana website at http://
kohanaframework.org/guide/about.kohana
The guide contains basic information about Kohana, installation, configuration, and tutorials. 
Most importantly, it includes the API reference, which allows easily us to explore and view 
the methods and properties of every class in the library see.
As we build our applications, the guide expands to include our code, documentation, 
and help files. This can be quite a resource for developing large projects with multiple 
developers, revisiting old projects for which you need to refresh your memory, and 
making it generally easier to find your way around.
It is a good idea to familiarize yourself with the documentation online, and spend some 
time looking over the pages and API Reference.
Structure and patterns
In order for Kohana to work properly, some basic patterns and coding conventions must be 
followed. You are encouraged to follow the Allman/BSD style that is consistent throughout 
the framework; however, not following exactly will not break your application.
That being said, not following certain coding conventions will prevent Kohana from 
autoloading your files, and thereby breaking your application. Because Kohana embraces 
Convention over Configuration, the naming of your directories, files, and classes determine 
how (and if) they are automatically loaded into the framework. This is a great feature as we 
do not have to write a lot of include() or require() statements, and it eliminates the 
need for trying to find files before we can use them.
Another advantage of using this convention is we can utilize Kohana's cascading filesystem, 
which allows us to easily extend and override lower-level classes. Essentially, this means 
we can put a class in a module, and use it directly. All we need to do to extend it in our 
application is to drop a file with the same name into our application directory structure, 
and we can begin extending and overloading the class. We will get into this in more detail in 
Chapter 3.
To begin working with Kohana, there are a few very important rules you must know, and we 
will cover the rest of the nuances as we progress through the book. The main thing to know 
now is: all class names must adhere to the following conventions:


All classes live in the /classes/ directory, usually located in the application 
directory or in a module.

Preface
[ 3 ]


Underscores ( _ ) represent directories, example: Controller_Foo would be 
located in classes/controller/foo.


All class filenames and directory names must be lowercase.
To get a more detailed look at the conventions and patterns used in Kohana, please visit:  
http://kohanaframework.org/guide/about.conventions. For more information 
and examples of Allman/BSD syntax, please visit http://en.wikipedia.org/wiki/
Indent_style#Allman_style_.28bsd_in_Emacs.29
HMVC in a nutshell
Most modern PHP frameworks use, or at least offer, a Model View Controller (MVC) pattern 
for constructing and organizing your project. The advantages of using Object-Oriented 
Programming (OOP) were recognized with the release of PHP 5, and the development 
community quickly began finding ways to create more reusable, lightweight, and expandable 
code. The MVC pattern fits perfectly for web application development, allowing developers 
to create code once, and use it across multiple projects.
The MVC design pattern allows presentation, data, and logic layers to all be coded separately 
and used together. Traditionally, MVCs use a front-controller to handle all requests, route 
and load a controller, and the render the output from a view.
Hierarchical MVC (HMVC) takes this approach one step further. Much like AJAX allows web 
browsers to interact with the server without reloading the page, HMVC allows your server-
side application to handle multiple requests without having to display a page every time.
Where MVCs allow for one controller to be loaded and executed, the HMVC pattern loads a 
primary controller, and then allows requests to be created repeating the loop of routing and 
loading controllers, and allowing for even more requests.
Although this can be confusing at first, it is actually quite powerful. Having full control over 
routing and requests gives developers a lot of flexibility and power when writing code. We 
will take a much deeper look at the HMVC structure in Kohana when we explore routing and 
request handling in Chapter 3.
Models, Views, and Controllers
Finding the right place for our code is important, especially as our application grows. Anyone 
who has ever worked on a project consisting of more than a few pages quickly realizes that 
code can become convoluted in no time, and good organization pays off.
To keep our code clean and DRY (an acronym for Don't Repeat Yourself—a motto meaning 
write code once), we will use Models, Views, and Controllers to house our data logic, 
business logic, and presentation files.

Preface
[ 4 ]


CONTROLLERS – These are the driving force behind our applications. Our controllers 
are loaded immediately after the request, and will delegate data modeling to our 
models, and presentation duties to our views. Controllers are where we utilize our 
models and prepare our data for output.


MODELS – Any external data that needs to be used by our application will live in a 
model. More often than not, models are used to interact with a database or other 
data store. We will store any methods necessary for creating, updating, reading, and 
deleting data from any data stores with which we interact.


VIEWS – Perhaps the easiest way to think of views is just to imagine HTML. These 
are the files where all of our markup will go, with minimal logic. View files should 
contain the least amount of PHP code of the three types, and should utilize PHP's 
alternative syntax for control structures when it is necessary to use server-side 
scripting.
The above definitions are made with broad strokes, and I do not suggest they completely 
outline where and how to use each. In Chapter 2, we will take an in-depth look at Controllers 
and Views, and in Chapter 6 we use Models to interact with our database. For now, knowing 
the basic use for each of the MVC layers will give you an idea of how it all fits together.
Alternative syntax
It is not uncommon for HTML and PHP to be intermixed within the same document. In fact, 
many of us began web development by making very long files with PHP and HTML so mixed 
together, it was sometimes hard to tell them apart.
Kohana allows us to keep our business logic in our controllers and models, and our markup 
in views. Although view files are used for presentation, and mainly consist of HTML code, we 
will need do have some PHP for dynamic content.
Instead of using curly braces everywhere, making our code confusing to read, we will be 
using PHP's alternative syntax. You can read more about alternative syntax here: http://
php.net/manual/en/control-structures.alternative-syntax.php
Routing and request overview
As explained earlier, Kohana utilizes the HMVC design pattern, and allows us to create 
requests essentially anywhere within our applications. The request flow is the order in which 
files are loaded, starting with index.php and moving throughout the framework, loading 
essential files, processing the requests, and rendering any output. We will examine the 
request flow and routing systems throughly in Chapter 3, giving examples and analysis of the 
entire process.

Preface
[ 5 ]
What this book covers
Chapter 1, Getting Started, covers Kohana 3 installation—displaying the default welcome 
content and user guide for the framework.
Chapter 2, Using Views and Controllers, will jump into using Kohana's controllers and views, 
and make something more robust than a simple "hello, world" script.
Chapter 3, Routing and Request Handling, will talk about the way Kohana routes our 
requests, and how to use request handling and routing to make our applications more 
robust. We will also learn more about Kohana's cascading filesystem, the Heirarchy aspect 
of HMVC, and how Kohana works at runtime.
Chapter 4, Working with Helpers and Classes, will look at some of the helper and 
service-oriented classes provided in Kohana, and take a look at extending their 
functionality, and creating a few of our own.
Chapter 5, Installing and Configuring Modules, will cover how to extend Kohana's core 
functionality by implementing modules. We will be exploring the modules that ship with the 
framework, learn how to use third-party modules, and how to create modules of our own.
Chapter 6, Interacting with the Database, will take a more detailed look at the Database and 
ORM modules, their use, and a more in depth look at some of the official modules that use 
and rely on these very important modules. Working with databases has never been more 
fun and easy, and in this chapter, we will expand our case study website to make it work with 
dynamic data, user authentication, and related data.
Chapter 7, Using the ORM and Auth Modules, will take an in-depth look at two modules that 
rely on the Database module to function: the ORM and the Auth modules. By implementing 
these modules in your projects, you can make working with data even easier and authorizing 
users a breeze.
Chapter 8, Troubleshooting and Error Handling, will be covering troubleshooting and error 
handling, and we will be able to see how to detect and debug errors in our applications 
while adding the final touches to the case study site.
Chapter 9, Securing and Deploying Kohana, will discuss methods to secure our applications, 
and keep our code safe from attacks.
Appendix, Upgrading from CodeIgniter and Kohana 2, will look at migrating from an earlier 
version of Kohana and CodeIgniter to the newest version of Kohana.
www.allitebooks.com

Preface
[ 6 ]
Who this book is for
If you are a developer who understands PHP, has some experience with Object-Oriented 
Programming (OOP), and has a desire to harness the power of a Hierarchical Model-View-
Controller (HMVC) framework, then this book is for you.
Conventions
In this book, you will find several headings appearing frequently.
To give clear instructions of how to complete a procedure or task, we use:
Time for action – heading
1.	 Action 1
2.	 Action 2
3.	 Action 3
Instructions often need some extra explanation so that they make sense, so they are 
followed with:
What just happened?
This heading explains the working of tasks or instructions that you have just completed.
You will also find some other learning aids in the book, including:
Pop quiz – heading
These are short multiple-choice questions intended to help you test your own 
understanding.
Have a go hero – heading
These set practical challenges and give you ideas for experimenting with what you have 
learned.
You will also find a number of styles of text that distinguish between different kinds of 
information. Here are some examples of these styles, and an explanation of their meaning.
Code words in text are shown as follows: "Because Kohana utilizes a front controller design 
pattern, the only application file that must be exposed is our index.php file."

Preface
[ 7 ]
A block of code is set as follows: 
foreach (ORM::factory('post', 1)->where('active', '=', 1)->author- 
>find_all() as $author) 
{ 
echo $author->name . '<br />'; 
}
When we wish to draw your attention to a particular part of a code block, the relevant lines 
or items are set in bold:
<div class="field"> 
   <?php $body = isset($value) ? $value : ''; ?> 
   <?php echo Form::textarea('content', $body); ?> 
</div>
Any command-line input or output is written as follows:
$ git clone https://github.com/kohana/kohana.git -b 3.0/master
egotist
New terms and important words are shown in bold. Words that you see on the screen, 
in menus or dialog boxes, for example, appear in the text like this: " By clicking the Edit 
Message link, you can now edit the message:".
Warnings or important notes appear in a box like this.
Tips and tricks appear like this.
Reader feedback
Feedback from our readers is always welcome. Let us know what you think about this book—
what you liked or may have disliked. Reader feedback is important for us to develop titles out 
of which you really get the most.
To send us general feedback, simply send an e-mail to feedback@packtpub.com, and 
mention the book title via the subject of your message.

Preface
[ 8 ]
If there is a book that you need and would like to see us publish, please send us a note in the 
SUGGEST A TITLE form on www.packtpub.com, or e-mail suggest@packtpub.com.
If there is a in which that you have expertise, and you are interested in either writing or 
contributing to a book, see our author guide on www.packtpub.com/authors.
Customer support
Now that you are the proud owner of a Packt book, we have a number of things to help you 
to get the most from your purchase.
Downloading the example code for this book
You can download the example code files for all Packt books you have purchased 
from your account at http://www.PacktPub.com. If you purchased this 
book elsewhere, you can visit http://www.PacktPub.com/support and 
register to have the files e-mailed directly to you.
Errata
Although we have taken every care to ensure the accuracy of our content, mistakes do 
happen. If you find a mistake in one of our books—maybe a mistake in the text or the code—
we would be grateful if you would report this to us. By doing so, you can save other readers 
from frustration and help us improve subsequent versions of this book. If you find any 
errata, please report them by visiting http://www.packtpub.com/support, selecting 
your book, clicking on the errata submission form link, and entering the details of your 
errata. Once your errata are verified, your submission will be accepted, and the errata will 
be uploaded on our website, or added to any list of existing errata, under the Errata section 
of that title. Any existing errata can be viewed by selecting your title from http://www.
packtpub.com/support.
Piracy
Piracy of copyright material on the Internet is an ongoing problem across all media. At Packt, 
we take the protection of our copyright and licenses very seriously. If you come across any 
illegal copies of our works, in any form, on the Internet, please provide us with the location 
address or website name immediately so that we can pursue a remedy.
Please contact us at copyright@packtpub.com with a link to the suspected pirated 
material.
We appreciate your help in protecting our authors, and our ability to bring you valuable 
content.

Preface
[ 9 ]
Questions
You can contact us at questions@packtpub.com if you are having a problem with any 
aspect of the book, and we will do our best to address it.


1
Getting Started
To start using Kohana 3, you must first learn how to install and configure the framework. 
Here, you will learn how to install Kohana from the website and via the official Git repository, 
configure Kohana for development, and display the default welcome page.
This chapter includes:


System requirements


Installation from Kohana's website


Installing from Kohana's Git repository


Overview of Kohana's filesystem


Configuring the framework for a development environment


Displaying your welcome page
No previous experience or exposure to Kohana is required to follow the instructions and 
examples in this book. You will start off by setting up the framework from scratch, examine 
the necessary steps to configure Kohana, and apply your knowledge by building a real 
application.
By the end of this chapter, you will have a full Kohana 3 installation displaying the default 
welcome content and user guide for the framework.
So, let's get started!

Getting Started
[ 12 ]
System requirements
The exact system requirements for Kohana are somewhat fluid, with newer versions of the 
framework requiring newer versions of PHP. The basic requirements are essentially the 
same: a newer version of PHP5, some common extensions, and a few optional extensions 
that allow Kohana to do more. My experience has been that most hosting providers, and 
out-of-the-box development servers (WAMP, MAMP, XAMPP, etc), come pretty well suited 
for Kohana right out of the box.
At the time of writing, Kohana requires the following:


PHP 5.2.3 or newer


PCRE with UTF-8 Support


PHP SPL Enabled


PHP Reflection Enabled


Filters Extension


Iconv Extension


Native MBString (not overloaded by extension)


Character Type (CTYPE) Extension
The following extensions are not required, however, they are recommended for full 
functionality. Through the course of this book, you will assume these extensions will be 
present: cURL, mcrypt, GD, and PDO.
Again, most providers and development packages should work fine. Also, during 
installation, Kohana will check for all the required and optional extensions and let 
us know if anything is out of order. For more information, visit the Kohana website 
at http://kohanaframework.org
Don't worry about getting too caught up with the system requirements. Everything that is 
required, even optionally, is open source and free, installed on most systems, and there is 
a lot of support out there. Let's move right along and prepare to get Kohana installed and 
running on your system.
Case Study
Throughout the course of this book, you will be creating a web application that will allow 
users to create simple profiles, post messages for their friends, and manage their public 
page. Because this site is for sample purposes, we will be concentrating on backend code, 
and not the HTML, CSS, and JavaScript that would normally go into a site scheduled for 
production. You will create a fully functioning application, and secure it for a production 
environment.

Chapter 1
[ 13 ]
Our sample application will be called "Egotist", and will encourage users to befriend each 
other and share details about their daily activities. They will be able to post comments, and 
see comments that are posted by their 'friends'. We will implement basic authorization, 
session handling, a database for your posts, users, and friendships, and do it all in Kohana.
Downloading and installing from the Web
Kohana's website http://kohanaframework.org/ hosts an archive of the latest releases 
in its download section. Here, you will also find user forums, documentation, and other 
releases of the framework.
The website makes it very easy to obtain and install the most current stable release of 
Kohana, browse the documentation, and interact with the Kohana community.
Time for action – Downloading from web
Let's take a look at installing Kohana from their website:
1.	 Open http://kohanaframework.org/ in your web browser.
2.	 Navigate to the download page and select the newest 3.0.x version marked Stable.
3.	 Clicking the download link will retrieve a file named Kohana-3.X.X.zip (where X could 
be any number, representing the version of the framework).
4.	 Create a web directory called egotist.
5.	 Unzip the downloaded file into your egotist site folder on your development 
environment.
A listing of your /egotist/ directory should contain the framework:

Getting Started
[ 14 ]
What just happened?
As you can see, you have unarchived Kohana into your webroot directory. Take note of the 
mark-down (.md) files, especially those labelled DEVELOPERS, TESTING, and README. It is 
recommended that you give these files a read. Also, notice the framework comes complete 
with index.php, a system folder, application folder, and modules folder.
Although installing Kohana via the download archive is a quick and easy way of obtaining 
the framework, the code repository is hosted and maintained on GitHub (http://github.
com), and can be accessed and updated via this resource. If you would like to install Kohana 
via GitHub, the next section is for you.
Installing Kohana from GitHub
In a nutshell, Git is a Distributed Version Control System (DVCS) or Source Code Management 
(SCM) tool written by Linus Torvalds originally designed for the Linux kernel developers. Its 
popularity, especially amongst open source developers, has grown considerably in recent 
years, for many reasons. Git provides developers with many features that make working with 
your code more convenient. Using Git, you can easily create and merge different branches, 
create forks of existing repositories, and issue pull requests for patches or upgrades made to 
forked projects. The distributed nature of Git allows every team member to keep the entire 
repository duplicated in their environment. GitHub is a storage solution for Git repositories, 
with free hosting for open source projects. Kohana uses GitHub for hosting, and you can get 
Kohana directly from GitHub.
Installing Kohana via GitHub makes it easier to keep your application up to date with the 
most recent releases of both the Kohana 3 system files, but also any submodules that you 
may be using that are also hosted on GitHub. When you want to use one of hundreds of 
actively developed modules for Kohana, installing them using Git will be painless.
To access repositories on GitHub, you must first have Git installed on your system. For more 
information on installing and using Git, please visit http://git-scm.com/. Git is free and 
open-source, and is available for all popular operating systems. Most providers that offer 
secure shell access also offer Git.
Time for action – downloading using Git
The Kohana repository can be found at http://github.com/kohana/kohana, where 
you find the most current version of Kohana 3 in the 'trunk' of the repository. Git allows for 
tagging and branching of projects, and the Kohana team has done a very good job of tagging 
releases and creating branches for new release cycles.

Chapter 1
[ 15 ]
For your development project, you will simply use the most current stable release in the 
trunk of the master branch that contains the basic framework with official modules. This is 
easiest way to keep the current stable version of Kohana for your projects.
1.	
First, let's create a place to put your application. For the case study in this book, 
you will be creating a social networking application called Egotist. So, in your web 
directory, let's create a directory named egotist.
2.	
Now, you can run the following command to retrieve Kohana and place it in your 
egotist directory:
		
$ git clone https://github.com/kohana/kohana.git -b 3.0/master 
egotist
Git should retrieve the repository, and make a copy of it into your site directory. 
Remember to execute the command from within your egotist or site root 
directory.
www.allitebooks.com

Getting Started
[ 16 ]
3.	
After the clone has completed, you can list the contents of your site root directory. 
It should contain all the Kohana files with a few files associated with Git and all the 
submodules in place for your system and modules directories.
Included in the repo are some submodules, the 'official' modules sanctioned by the Kohana 
3 development team to be included in the basic installation of the framework. The master 
Kohana repository keeps these submodule locations up to date. Right now these submodules 
have not downloaded any files to your system.
1.	
Download each of these repositories directly into your project, you will want to 
update these submodules by running the following:
	
$ gitsubmodule init

Chapter 1
[ 17 ]
2.	
Now that you have let Git know about the submodules you want to install, you need 
to do an initial update to clone all the submodules into your install.
	
$ gitsubmodule update
The update may take a little while. Git will go through each 
submodule and download its newest stable release.
What just happened?
The Git clone available at https://github.com/kohana/kohana.git tells Git to clone, 
or to make an exact copy of, the repository located at https://github.com/kohana/
kohana.git, the second argument, –b 3.0/master tells GitHub which branch you want 
to clone, and the final argument tells Git where to place the cloned repository, in this case 
the egotist directory.
In the future, updating the codebase will be as simple as returning to the site root and 
running:
   $ git pull
   $ gitsubmodule update
The first command will pull, or download, the newest content from GitHub in the master 
branch. The second command updates, or downloads, all the submodules you have installed 
for your project.
Currently, you are only updating submodules that are included with the Kohana install. Later, 
in Chapter 5, you will be adding modules to your project, and some of these will be installed 
using Git. Once installed, they can be updated in a similar fashion.
Advanced installation with Git
By cloning the kohana.git repository, you got a copy of the entire repository that is meant 
to build the compressed files for download, and it is not really designed to be cloned into 
projects for use. The method described above is used by many beginners, but has some 
drawbacks. First, the repo is now pointed to Kohana/Kohana.git, not the repository you 
wish to use for your project. Secondly, it has all the commits for the files in the application 
path, where your files will eventually live for your project. Next, when you update your 
application, Git will want to merge the changes in your application directory with the repo. 
Lastly, you are tied to the directory structure that this repo subscribes to, making changes 
like we will explore later in the book harder, if not impossible.

Getting Started
[ 18 ]
Creating your project's directory structure and using existing repositories on GitHub as 
submodules will make your application more flexible, and easier to maintain. Although 
there are a few more steps involved here, the savings in the long run are enormous.
If you are running a UNIX-compatible operating system, like Linux or Mac OS X, you can 
use an install a script written by Kohana's Benevolent Dictator for Life, Woody Gilk, aka 
shadowhand, which handles this process quite elegantly. The script, and instructions for use, 
can be found here: https://github.com/shadowhand/kohana-installer.
If you prefer to set up your application environment by hand, you can create your directory 
structure, add the Kohana core repository (https://github.com/kohana/core) to 
your system directory, add all the modules you need to your modules path, create your 
application structure, bootstrap, and front controller. This provides you with the most 
flexibility and is the preferred method for most professional developers. For a full tutorial 
on installing Kohana in this manner, please visit: http://kohanaframework.org/3.0/
guide/kohana/tutorials/git
Although you can use Git to manage the code for your project, we will leave Git behind 
here, and move forward with your Kohana project. For more information on Git, please 
visit http://git-scm.com.
Now, your development directory has the Kohana 3 framework with the official submodules 
in place, ready for configuration. Before you dive into installation, let's make sure your 
environment is properly set up to handle Kohana 3.
Taking inventory
A quick look at the files you have downloaded reveals some files you are familiar with, 
and others that you may not be. You can see there is the standard index.php file, some 
mark-down files, a readme file, and 3 sub-directories: application, modules, and system. 
One of the nice things about Kohana is that it comes with the file structure and core files 
necessary to get your project up and running very quickly.
We will explore Kohana's routing a bit more later on, but it is important to know that 
index.php will be the first file loaded by the framework. The index file will create the 
necessary configurations and definitions to run Kohana, and then bootstrap the application 
by loading application/bootstrap.php. You will be working with bootstrap.php 
very soon when you begin configuring Kohana for first use.

Chapter 1
[ 19 ]
The application directory is where the majority of your code will live. This is where you will 
create your application's controllers, models, config files, and views. You will also keep your 
logs and various other items here, well-organized, and easy to access and update. Unlike 
previous versions of Kohana and CodeIgniter, all of the classes for your app (Controllers, 
Helpers, Models, etc) will live in the application/classes directory, in their respective 
sub-directories (application/classes/model, application/classes/controller, 
etc). You may remember that helper classes in previous versions of the framework had their 
own designated place to live, and now simply reside in application/classes, and are 
not designated has 'helpers'.
The system folder houses the core files for Kohana, and although you are free to override any 
file in the library, you are discouraged from changing the contents of any files in the system 
directory. If you need to make changes to the Kohana system, you can do so by extending 
and overriding classes in the framework. We will cover this in more detail when you explore 
routing and requests in Chapter 3.
Any modules you install or create will be stored in the modules folder. Kohana comes with 
some modules bundled with the distribution, like the user-guide, database, oAuth, and 
others. There are hundreds of modules available from other developers online, and we will 
learn how to create your own modules in Chapter 5. Although these modules ship with the 
framework, they are not enabled by default. We will cover how these modules are activated 
and used later in the book.
Preparing the Filesystem
In order for Kohana to work properly, it must have the ability to write cache and log files 
to the filesystem. By default, the framework uses application/cache for caching, and 
application/logs for its log files. You can change these locations in the index.php or 
application/bootstrap.php files, however, the default location is just fine for your needs.
To make these directories writeable, you will need to change their permissions. Using a Linux 
system, you can accomplish this using the chmod command. On a Windows system, you 
need to make sure the folder is writeable by your web server.
Make sure you are in your site directory, in your 
case /egotist/.
	
$ chmod -R 777 application/cache
	
$ chmod -R 777 application/logs

Getting Started
[ 20 ]
While changing the permissions for your cache and logs on your development environment 
to full access to all users, on your production servers you will want to enforce a bit of 
security, and your web server should be the owner or a member of the group with write 
access to this directory. For development purposes, it is usually okay to leave these 
directories writable for all users.
Next, you might want to create a public folder where you will place your front-facing files. 
Our application will have CSS and images, and may grow to have publicly accessible media. 
Let's create a directory named public where you can organize these files as you are 
building your application.
	
$ mkdir public
Inside this public folder you can create three directories to house your JavaScript, CSS files, 
and images:
	
$ cd public
	
$ mkdirjs
	
$ mkdircss
	
$ mkdir images
Now, you have a place to organize your supporting files for your project, and once you begin 
development, adding stylesheets, images, and JavaScript files will be a breeze.
It is worth noting that when you prepare your app for production, you will move your 
framework outside of the web root folder for your site, and only expose the files necessary 
to run your application. Alternate directory structures not only allow you to minimize 
the available public directories and files, it can also allow you to share the framework 
and modules across several projects and applications. Many developers set up their 
development, staging, and production environments all using a shared directory structure. 
For more information on site structure and filesystem concerns in a production environment, 
please see Chapter 9.
Testing the environment
Kohana ships with a nice install script that will let you know if your web server and PHP 
installation are properly configured to handle the framework. Most hosting providers that 
I have used have no problems meeting the system requirements for Kohana 3, and local 
development environments typically work out of the box.
To test the installation on your system we will browse to your local installation, located 
at http://localhost/egotist (your URL may vary depending on your web server 
configuration).

Chapter 1
[ 21 ]
A successful installation will result in the following page being displayed:
If you have any areas that did not pass, please correct these issues before proceeding with 
the configuration of the application. For the examples in this book, we will assume that all 
the optional extensions have passed.

Getting Started
[ 22 ]
Configuring Kohana for Development Environment
Kohana needs some setup before you can begin using it. The front controller, bootstrap, and 
basic config files all need to be set up. You need a place to put your configuration options, 
and a place to put your public files like stylesheets and JavaScript. We will want to enable 
modules, set your default timezone, application environment, and prepare your project for 
use.
This may sound a bit daunting, but thankfully, Kohana has done most of the heavy lifting 
for you. You just need to change a few files.
First, let's remove the install.php file in your site root directory. Now that you 
have tested your system environment, you will not be needing this file any longer. If you 
plan on re-testing in the future, or testing on other systems, you can simply rename it 
install_old.php for future use.
Now that the install.php is out of our way, Kohana's front controller index.php 
will continue to load the bootstrap, located in the application directory, and named 
bootstrap.php.
Time for action – Setting your Timezone
We need to tell Kohana a little bit about your system and the desired setup. Let's do this by 
making a few changes to your bootstrap.php file in the /application directory.
Let's begin by opening the application/bootstrap.php file.
The first setting in the bootstrap.php file contains your timezone information:
date_default_timezone_set('America/Chicago');
You can set your default timezone to any identifier recognized by PHP's Date/Time library. 
For a complete list of supported timezones, please visit: http://www.php.net/manual/
en/timezones.php.
Next, you are able to set your default locale:
setlocale(LC_ALL, 'en_US.utf-8');
For more information on setting your locale in PHP, please refer to http://php.net/
setlocale.

Chapter 1
[ 23 ]
What just happened?
For most installations, the locale settings will be fine. Both the default timezone and locale 
can be reset later in your code if you need to do internationalization or have users set their 
local timezones for example.
Although having the right time is nice, it is much more important to have working URLs. 
Without them, your users will never get to view or use your application. Next, you will let 
Kohana know about your URL scheme.
After these settings, you will see some setting for autoloading, SPL, and application 
environment. For your development setup, you will leave these at their default values. 
We will delve into the production ready setup in Chapter 9.
Configuring URL settings
Below the environment setting block, you see the Kohana::init() method call, initializing 
Kohana and allowing us to pass an array of default options to the framework in the form of 
name/value pairs. For now, you are only concerned with your base_url and index_file 
settings.
We will use the URL http://localhost/egotist/ for your base URL. You will want to 
use the URL that points to your Kohana installation. For local installations, it is common to 
use the http://localhost/ domain; if you are developing on a live server, you might 
want to use that URL. Either way, it is recommended to use the full path to your site here, 
as it will be used later for accessing files, creating links, and all sorts of goodness.
Time for action – setting base URL
1.	 In your bootstrap.php file, find the following block of code:
Kohana::init(array(
   'base_url'   => '/›
));
2.	 Now update the array being passed to Kohana::init() with the following values, 
using your base URL for the base_url value:
Kohana::init(array(
   'base_url'   => '/egotist/›,
   ‹index_file› => ‹›
));

Getting Started
[ 24 ]
What just happened?
Here you set the base URL for your application, and have the opportunity to define your 
index file that will act as your front controller. For the case study site, we will hide the index 
file, so this can be left blank.
Hiding the index file is an optional step, however, all the example URLs for your local site 
will reflect this change, and will not include the index.php file in your URLs. This is a very 
common practice that creates clean, readable URLs for your applications. You will need to 
configure your web server to reroute all requests to your index.php file, so it will not be 
necessary for users to include it in the URL. If you do not set it to blank here, Kohana will 
include it when it creates URLs for us when you use the built in helper methods.
Setting up the Application Environment
When developing your application, you may need some features to be accessible only in your 
development environment, and others only when in production. This may include profiling, 
additional information, features not ready for prime time, error stacks, and other code that 
is only meant for certain environments. You could even have configuration options based on 
environment settings.
Time for action – Setting Kohana::$environment
1.	 For the time being, let's define your KOHANA_ENV constant right after the 
"Configuration and Initialization" comment in your bootstrap.php file by 
adding this line:
Kohana::$environment = Kohana::DEVELOPMENT;
2.	 The next block of code in the bootstrap.php reads as follows:
if (isset($_SERVER['KOHANA_ENV']))
{
  Kohana::$environment = $_SERVER[‹KOHANA_ENV›];
}
What just happened?
With your constant defined, the static property Kohana::$environment will be set 
to 'development', allowing your application to perform tests against the static property 
and determine your application environment. Although this is the default setting for the 
environment, now you have a place to easily change between the environment settings 
for testing and learning. The four constants that ship with the framework for defining the 
environment are PRODUCTION, STAGING, TESTING, and DEVELOPMENT.

Chapter 1
[ 25 ]
For your case study, you will be using two environment settings: Kohana::DEVELOPMENT 
and Kohana::PRODUCTION. When you prepare your application for deployment on your 
production server, you will want to change the value of KOHANA_ENV to production.
Enabling modules
Lastly you will want to look at the Kohana::modules method, and the array of options 
that are commented out. As you build your application, you will be utilizing several of these 
modules, adding other modules, and creating your own.
Time for action – Enabling the User Guide
Let's remove the comments for the 'userguide' module so your code block looks like this:
Kohana::modules(array(
   // 'auth'       => MODPATH.'auth',       	
// Basic 
authentication
   // 'cache'      =>MODPATH.'cache',      	// Caching with multiple 
backends
   // 'codebench'  => MODPATH.'codebench',  // Benchmarking tool
   // 'database'   =>MODPATH.'database',   	// Database access
   // 'image'      =>MODPATH.'image',      	// Image manipulation
   // 'orm'        => MODPATH.'orm',        	
// Object 
Relationship Mapping
   // 'oauth'      => MODPATH.'oauth',      	
// OAuth 
authentication
   // 'pagination' =>MODPATH.'pagination', 	// Paging of results
   // 'unittest'   => MODPATH.'unittest',   	
// Unit testing
   'userguide'  	 => MODPATH.'userguide',  	// User guide and API 
documentation
));
What just happened?
The Kohana::modules() method accepts an array of key/value pairs representing a 
module and its path. The default modules that ship with Kohana are listed for us, and 
commented out to prevent them from loading without being activated and configured.
When you create or add modules to your project, you will want to add them here. To use any 
of the modules that ship with Kohana you simply uncomment the line. You should know that 
most modules require some configuration. We will be getting into modules for Kohana more 
in Chapter 5.
Save your bootstrap.php file and see what it takes to get a basic configuration file in place 
so you can keep your application's options in one, easy to find place.

Getting Started
[ 26 ]
Creating a default config file
As you create parts of your application, you are going to want to access config files. When 
you set up your database, use sessions or cookies, install or create modules, or have 
information that may change, you will want to organize these options in one place.
In your application directory, there is a sub-directory placed there for us called config. In this 
folder, you can create configuration files, and access them via a static method. For now, you 
will load some basic data into a config file for Egotist.
In application/config, create a file called site.php and insert the following code:
<?php defined('SYSPATH') or die('No direct script access.');
return array(
   'name' => 'Egotist',
   'tag_line' => "Let's talk about me!"
);
Now, whenever you want to access your site name and tag line, you can do so using the 
following code:
$site_config = Kohana::config('site');
This will find your file named site.php in the application/config folder, and load 
the array into $site_config. You could then access your config options like so:
$site_name = $site_config['name'];
$tag_line = $site_config['tag_line'];
We do not need to load the entire array if you only need a single config option. If, for 
example, you needed the app_name variable only, you could get it using this:
$site_name = Kohana::config('site.name');
Kohana will return the value of the array for any keys using the above dot syntax. This allows 
us to retrieve the value without having to get the entire array. Kohana also allows us to nest 
arrays within your config files. You can change your application/config/site.php file 
to read as follows:
return array(
   'name' => 'Egotist',
   'details' => array(
      'tag_line' => "Let's talk about me!",
      'alt_tag_line' => "Today's subject: ME!";
   );
);

Chapter 1
[ 27 ]
We can still access the array directly:
// Load site config array
$site_config = Kohana::config('site');
// Echo site name and details
echo $site_config['name']; // Egotist
echo $site_config['details']['tag_line'] // Lets talk about me!
echo $site_config['details']['alt_tag_line'] // Today's subject: ME!
Alternatively, you can access nested options using the dot syntax method described above:
echo Kohana::config('site.name'); // Egotist
echo Kohana::config('site.details.tag_line'); // Lets talk about me!
echo Kohana::config('site.details.alt_tag_line') // Today's subject: 
ME!
As you build your application, your config folder will contain files for your database, 
sessions, modules, and other files and components. This will allow us to keep your code 
DRY (an acronym for Don't Repeat Yourself) and easy to maintain.
Let's save your site.php config file and take a look at configuring your web server to 
properly handle URL rewriting for your project.
Server configuration
For Kohana to function properly, it needs to rewrite all incoming URLs to route through your 
index.php file. Kohana ships with a file named example.htaccess, which provides a very 
good outline for what is needed to accomplish this task on an Apache web server.
Configuring Apache
Let's begin by opening and examining example.htaccess:
# Turn on URL rewriting
RewriteEngine On
# Installation directory
RewriteBase /site_name/
# Protect hidden files from being viewed
<Files .*>
   Order Deny,Allow
   Deny From All
</Files>
# Protect application and system files from being viewed
RewriteRule ^(?:application|modules|system)\b.* index.php/$0 [L]
# Allow any files or directories that exist to be displayed directly
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
# Rewrite all other URLs to index.php/URL
RewriteRule .* index.php/$0 [L]

Getting Started
[ 28 ]
You will want to alter the RewriteBase to contain the location that you put in bootstrap.
php for base_url. For your example site, it would read:
RewriteBase /egotist/
This lets Apache know where to find your site, and to rewrite all requests to /egotist/
index.php/and allow Kohana to do its magic.
You will need to save the file as .htaccess, or save and rename it without the example 
prepended. Most web hosting providers allow .htaccess files in their web root folder to 
make alterations to Apache's default configuration.
Configuring nginx
Of course, you are not required to use Apache as your web server. There are other web 
servers that are gaining popularity, one of the most notable being nginx. The official Kohana 
documentation shows this configuration for nginx:
location /egotist/ {
    index     index.php index.html index.htm;
    try_files $uriindex.php;
}
 
location = index.php {
    include       fastcgi.conf;
    fastcgi_pass  127.0.0.1:9000;
    fastcgi_indexindex.php;
}
For more information on configuring Kohana for clean URLs with Apache or nginx, please 
visit: http://kohanaframework.org/3.0/guide/kohana/tutorials/clean-urls.
Testing your configuration
If everything goes well, you should see the default Kohana welcome controller's "hello, 
world" greeting, letting us know all is right with your application so far. Let's browse to 
your site and check it out:

Chapter 1
[ 29 ]
Kohana has a very simple default welcome page, showing us the ever popular "hello, world!" 
text. Later, we will be replacing this with a more robust page, but for now, this is much better 
than an error page.
Although this lets us know you are viewing your basic welcome controller properly, you will 
also want to make sure the URL rewriting is working properly, and your userguide module 
has loaded. To do this, you can browse to http://localhost/egotist/guide, where 
you can view and browse the official Kohana user guide:

Getting Started
[ 30 ]
Looks like you are all set! This is a local copy of the Official Kohana User Guide, and it is 
included with every installation. You know your setup is working correctly by viewing this 
page for three reasons:


Our modules are configured correctly, or you cannot see the User Guide


Our .htaccess are set up right, or you would need index.php in the URL


bootstrap.php is also properly configured
If you are unable to view the User Guide from your local installation, be sure to check the 
settings in your .htaccess and bootstrap.php files.
The API Browser will show all the classes used by Kohana, including classes you create or 
modify. By exploring different classes, you will find the ability to drill down into methods 
and properties, making it easy to learn more about Kohana's functionality.
While you build your application, you will be paying close attention to proper documentation 
techniques, and will be expanding the API Browser as you code, simplifying the 
documentation process, and making your lives much easier when you need to go back and 
see how something works.
In Chapter 8, we will delve further into using and expanding the User Guide. For now, it is 
important to know it is here, and take the time to explore and familiarize yourself with its 
content and layout.
Pop quiz – Installation and Configuration
Throughout the course of the book, you will be testing your knowledge while reviewing what 
you have recently learned.  You are encouraged to test yourself when these sections appear 
to ensure you have a good understanding of the topics you are covering.
1.	 For the framework to run properly, it must have write access for logging and 
caching. Which directories must be modified to allow for these actions?


application/system and application/logs/


application/cache/ and application/logs/


kohana/cache/ and kohana/logs/


egotist/logs/ and application/kohana/

Chapter 1
[ 31 ]
2.	 When you configure Kohana for your server environment, you must set the base_
url and index_file. Which method is used to set these options?


Kohana::$environment


Kohana::init()


Kohana::config()


Kohana::base_url()
3.	 Config options can be accessed as either a complete array of all options for a 
particular configuration file, or directly using dot notation. Which of the following 
examples would return the background color from a config file named test.php?


Kohana::config('background-color', 'test')


$backgroundColor = Kohana::config('test')


Kohana::config('test.background-color')


Kohana::config['test']['background-color']
Summary
So far you have accomplished a lot. You reviewed the system requirements necessary for 
your environment. Then you learned how to install Kohana from both the official website 
and GitHub repositories. Next, you prepared the filesystem and tested your installation 
using the Kohana Environment Test run via install.php. After passing your install test, 
you configured your application for development—preparing yourselves to build on a stable 
foundation. Our Egotist application has its environment variable set, you have created places 
for your config files, stylesheets, JavaScript, and images. Lastly, you were greeted with the 
sign of a working Kohana installation, "hello, world".
We also discussed using the install test script, preparing for production, and how to keep 
your Kohana installation up to date using Git. Now that we've learned how to install and 
configure Kohana for development, let's go develop something!
In the next chapter, you will jump in to using Kohana's controllers and views, and make 
something more robust than a simple "hello, world" script.


2
Using Views and Controllers
One of the best features of the MVC pattern is the clear separation of logic and presentation. 
Kohana's structure makes it even easier by providing the basic file structure and files needed 
to quickly get our app going.
In the last chapter, we configured Kohana and displayed the default controller. In this 
chapter, we will:


Learn the anatomy of a view file


Learn the anatomy of a controller


Create and extend controllers


Create and use controller actions


Create view files


Implement templates


Create an application controller
By the end of this chapter, we will have created controllers and views, utilized Kohana's 
template system, leveraged some of the power of the HMVC pattern, and used it all together 
to bring our first bit of interactivity to the case study site.
Let's get started!

Using Views and Controllers
[ 34 ]
What are controllers and views?
Simply put, controllers handle the request and pass data between models and views, while 
views display the output for the user. Controllers are classes that contain specialmethods 
named action methods or controller actions that can be called via a request. The action 
methods can then send data to models, compute data, render views, call requests, or all of 
the above. Most of the controllers we will create will be defining actions that render views as 
web pages.
Controllers in Kohana are organized in the classes sub-directory of either an application, 
directory, or a module. For this chapter, we will be working in the application directory 
of our site root, and we will work with modules later in Chapter 5.
In a typical web-based application, views will contain primarily HTML, either hard-coded 
or as generated output. The controller can pass data to the views, and can render multiple 
views on to one page. Views can therefore be nested, used as templates, or called as needed 
for different actions.
Anatomy of a view
A view can be any markup that we plan on presenting to the user in our applications. As 
web developers, we use views to create the final HTML that is displayed to our users. As 
we create applications, we will be creating many view files: some for our headers, footers, 
navigation menus, and so on. When we put them all together, then pass some data to them 
to make them data-driven, the final product will be a fully rendered web page.
View files will contain a mixture of HTML and PHP using alternative syntax. It is considered a 
best practice to only use scripting in the views to render output, and not to perform business 
logic: that is what models do. By following the practice of building skinny controllers and fat 
models, our views will only have to display the rendered material.
In Kohana, by default, view files are stored in the application/views/ directory when 
used in the application, and in modules/<module name>/views/ when used in a module. 
For now, let's just focus on the application/views/ directory.
In this directory, we can organize our view files in sub-directories to our heart's content. For 
our case study application, we will be creating directories to hold different view files, and 
then calling them from our controllers and making them dynamic. We can also render views 
from within other view files. This would be used in a header view calling a nested navigation 
view, for example.

Chapter 2
[ 35 ]
Anatomy of a controller
Let's open the default controller application/classes/controller/welcome.php 
in our site root directory. It should look like this:
<?php defined('SYSPATH') or die('No direct script access.');
classController_Welcome extends Controller {
   
public function action_index()
{
      $this->request->response = 'hello, world!';
   }
} // End Welcome
Reading through this code, we can learn a good deal about our controller. Let's begin with 
the first line:
<?php defined('SYSPATH') or die('No direct script access.');
This checks to see if SYSPATH is defined, thereby checking if the controller was loaded after 
index.php, ensuring the framework is loaded and the script was not called directly. 
Any attempt to access this controller directly will result in the script failing and displaying 
the text inside the die()construct.
classController_Welcome extends Controller{
Here the class is declared, and we know it is extending the Controller class, thereby 
inheriting all methods and properties from the Controller class. There are a few rules to 
which we must adhere when creating and naming controllers:


The file must be located in a classes/controller/subdirectory, usually in 
the application directory or in a module.


The filename of the controller must be all lowercase and end with .php.


The class name must match the capitalized file name with Controller_ prepended. 
All underscores are converted to directory seperators, so a class named 
Controller_Welcome would be located at classes/controller/welcome.
php. Directory namespaces can be prepended also, so a class named Controller_
User_Profile would be located at classes/controller/user/profile.php.


The class must extend Kohana's base Controller class.
We see that the class meet the above four requirements. The file the controller lives in is 
named welcome.php, and is located in application/classes/controller/, meeting 
the first and second rules as outlined above. The class is named Controller_Welcome, 
where welcome is the filename capitalized, and Controller_ is prepended, passing the 
third rule. The Controller_Welcome class extends Controller, passing the last rule.
www.allitebooks.com

Using Views and Controllers
[ 36 ]
The next line of code reads:
public function action_index()
This creates a new controller action named index. Controllers, like any class, can contain 
private, protected, and public methods and properties, and can inherit and override 
properties and methods from their parent classes.
Any method in a Controller class in Kohana that is public, and prefixed with action_ 
is considered a Controller Action and can be directly accessed by our users, and it is the 
method that will perform tasks for our applications.
In Chapter 3, we will take a more detailed look at routing and request handling, but for now 
we need a to understand how Kohana will route user requests by default.
A URL that looks like this:
http://yoursite.com/welcome/index
will be sent to index.php by our server rewrite rule, and will be routed to the 
Welcome_Controller class and the index action.
When we do not specify a controller, Kohana will default to the action_index() method. 
The following URL would be the same:
http://yoursite.com/welcome
In our application/bootstrap.php file, we have the following code block:
Route::set('default', '(<controller>(/<action>(/<id>)))')
   ->defaults(array(
      'controller' => 'welcome',
      'action'     => 'index',
   ));
Currently, our application will automatically call the index action of the welcome controller 
if no other route is defined. This is why the output of the Welcome_Controlleraction_
index() method is called when we do not specify anything in our URI.
Finally, inside our action_index() method, we see:
$this->request->response = 'hello, world!';
This line sets the response to a string of 'hello, world!', and it is then displayed on the screen 
for all to see. Because we will be using views for presentation, we will not be printing or 
echoing text directly from our controllers; that is what views do, after all.

Chapter 2
[ 37 ]
Updating our Welcome Controller
Currently, our site only shows the words "hello, world". To remedy this, we will have our 
index action render a view, and pass some data to the view to be displayed. This is a process 
that we will repeat a lot when creating sites with Kohana, and we will be expanding on 
the Controller/View relationship with almost every addition to the application. You are 
encouraged to follow along with the examples in this chapter, and to consult the source code 
that accompanies this chapter online.
Time for action – Getting our controller action to use a view file
A vanilla Kohana 3 installation contains a default route to a controller named welcome.
php. To get our feet wet with controllers, let's open and manipulate the default welcome 
controller.
1.	 Locate and open application/classes/controller/welcome.php.
2.	 Modify your action_index() method as follows:
public function action_index()
{
   $this->request->response = View::factory('welcome');
}
3.	 Create and open a file named welcome.php in application/views/.
4.	 In the application/views/welcome.php file, insert the following code:
   <h1>Welcome to Kohana 3</h1>
   <p>This is thewelcome.php view</p>

Using Views and Controllers
[ 38 ]
5.	 Enter the URL http://localhost/egotist/ into a browser and view the output:
What just happened?
By altering the index action in our Welcome Controller, we were able to call a view file and 
render it as our output. Let's take a look at this line in the action_index() method:
$this->request->response = View::factory('welcome');
The View class has a static method factory() that accepts two parameters: one for 
the view file, and a second for an array of values to be used by the view. The factory() 
method returns a new View object. Kohana will auto-render the view file passed unless it 
is told to do otherwise.
The method completes and renders our welcome.php view file, displaying our HTML in 
the browser as shown above.
Passing data to the view
As mentioned earlier, one of the main features of controllers is their ability to pass data to 
the view files. This is what allows us to keep our logic in the controllers and models, and our 
presentation in the view. There are several ways to accomplish this, and we will explore a 
few below.

Chapter 2
[ 39 ]
Using the factory( ) method
In our current action_index() method, we are creating the View object using the 
factory() static method. The method accepts a second argument of an array that is then 
accessible in the view file. A few small changes will turn our static welcome page into a 
dynamic view.
Time for action – Passing data via the factory method
To create and output data from our controller, we will need to modify both the controller 
action and the view file.
1.	 Open the controller file located at application/classes/controller/
welcome.php.
2.	 Modify our action_index() method as follows:
public function action_index()
{
   $data = array();
   $data[‹site_name›] = ‹Egotist›;
   $data[‹random›] = rand(1,10);
   $this->request->response = View::factory(‹welcome›, $data);
}
3.	 Now, we will need to open our view file located at application/views/
welcome.php and modify the file as follows:
<h1>Welcome to <?php echo $site_name; ?></h1>
<p><?php echo $random; ?> is a number between 1 and 10</p>

Using Views and Controllers
[ 40 ]
4.	 Refreshing the browser to view the output, we see the following:
What just happened?
In the controller's index action, the $data array was passed as the second argument in the 
View object's factory method. This array contains two values: one is a string that contains the 
site name, and the other is a random integer between 1 and 10. These array key/value pairs 
are accessible in the view script as local variables.
Using view variables
Currently, we are creating the data for the view file before instantiating the View object, 
and then passing the array of view variables into the view's factory method. Creating and 
managing an array of data for the view can be cumbersome and confusing. Thankfully, this is 
not our only option.
We know an instance of the View object is being returned by our factory method, which we 
are then passing to the Request object to render our view. We can manipulate the instance 
of the View and use its magic __set() method to create view variables.
Time for action – Passing data as view variables
To create and output data from our controller, we will need to modify the controller action, 
removing the $data array and replacing it with a $view variable:
1.	 Open the controller file located at application/classes/controller/
welcome.php.

Chapter 2
[ 41 ]
2.	 Modify the action_index() method as follows:
public function action_index()
{
   $view = View::factory(‹welcome›);
   $view->site_name = ‹Egotist›;
   $view->random = rand(1,10);
   $this->request->response = $view;
}
3.	 Refresh your browser and view the output, the page should be exactly the same 
(with a new random number).
What just happened?
Instead of creating the array of key/value pairs we want to display in the view, we are 
creating an instance of the View object by calling the static method factory(). Using 
the factory method, we are then sending the object directly to the Request object. In this 
example,we added values in the object that will be available as variables in the view script.
There were no changes necessary to the view file, because the same names were used for 
our view variables. If we had added or changed the names of the variables, we would have 
had to make the same changes to the view script.
Using the set( ) method
The View object has another method that can be used to pass variables to the view. By using 
the set() method, we can add data to the view by setting the name as the first parameter, 
and the value as the second. Because factory() returns an instance of the View object, 
we can chain the set() method to it. Additionally, set() also accepts a key/value pair as a 
single argument.
Time for action – Passing data using the set() method
To create and output data from our controller, we will need to modify the controller action; 
however, the view file will remain the same.
1.	 Open the controller file located at application/classes/controller/
welcome.php
2.	 Modify the action_index() method as follows:
   public function action_index()
   {
      $view = View::factory(‹welcome›)

Using Views and Controllers
[ 42 ]
         ->set(‹site_name›, ‹Egotist›)
         ->set(‹random›, rand(1,10));
      $this->request->response = $view;
   }
3.	 Refresh your browser and view the output; it should be exactly the same.
What just happened?
The View object's factory() method returns an instance of the View object, and then we 
chained the set() method with parameters for our view variable names and values. This 
could also be written with the same outcome as:
   public function action_index()
   {
      $view = View::factory('welcome');
      $view->set('site_name', 'Egotist');
      $view->set('random', rand(1,10));
      $this->request->response = $view;
   }
Using the set() method makes it easy to read code, and can be a good pattern to use when 
the values for the view variables will be computed elsewhere, and then set once the view is 
instantiated.
Again, there were no changes necessary to the view file because the same names were used 
for our view variables.
Using the bind( ) method
Creating view variables, and then passing their values by reference can be a powerful way 
to ensure the variables we need in our view are assigned to the view, even if we have not 
created the values for the variables yet. Kohana's View class gives us the bind() method to 
do just that.
Time for action – Passing data using the bind( ) method
To use the bind() method, we will once again be modifying the index action in the 
Welcome Controller.
1.	 Open the controller file located at application/classes/controller/
welcome.php

Chapter 2
[ 43 ]
2.	 Modify the action_index() method as follows:
   public function action_index()
   {
      $view = View::factory(‹welcome›)
         ->bind(‹site_name›, $site_name)
         ->bind(‹random›, $random);
      $site_name = ‹Egotist›;
      $random = rand(1, 10);
      $this->request->response = $view;
   }
3.	 Refresh your browser and view the output; it should be exactly the same.
What just happened?
Just like the previous example, where we used the set() method to pass variables to the 
view chained to the factory() method, this example adds variables to the View object. 
The main difference here is the variables being set do not exist yet, and are being passed by 
reference behind the scenes. This allows us to create all the view variables necessary for the 
action to execute properly at the same time we create our view object.
If we forget to set the $site_name variable, like so:
   public function action_index()
   {
      $view = View::factory('welcome')
         ->bind('site_name', $site_name)
         ->bind('random', $random);
      $random = rand(1, 10);
      $this->request->response = $view;
   }
There would not be an error in the view that $site_name was not set. It will simply be 
null, and not display any text for that spot in the view.
This may be desirable in places where we do not need to worry about whether the variable 
is null, however, it may be better to use the set() method, and then use PHP's isset() 
to determine whether the variable is available.

Using Views and Controllers
[ 44 ]
Putting it all together
In the last few pages, we have learned several ways to pass data to, and display data in, our 
view scripts. Let's see how this can apply to our welcome page.
Time for action – Passing data using multiple methods
Once again we will be altering the Welcome Controller and View scripts. This time, the 
objective is to leverage our new knowledge of how data works in our controllers, and how to 
properly set and display the data in the view.
1.	 Open the controller file located at application/classes/controller/
welcome.php.
2.	 Modifythe action_index() method as follows:
   public function action_index()
   {
      $view = View::factory(‹welcome›)
         ->bind(‹random›, $random);
      $random = rand(1, 10);
      $view->site_name = ‹Egotist Beta›;
      $this->request->response = $view;
   }
3.	 Now, we will need to open the view file located at application/views/
welcome.php.
4.	 Modify the view file as follows:
<h1>Welcome to <?phpechoisset($site_name) ? $site_name : 
'Egotist'; ?></h1>
<p><?php echo$random; ?> is a number between 1 and 10</p>
5.	 Refresh your browser, and view the output:

Chapter 2
[ 45 ]
What just happened?
The random number is set using the bind() method, allowing us to perform the logic 
associated with the number later in the method. We then used the magic set method to 
create a view variable for $site_name, and gave it a new name of "Egotist Beta" so we 
could see the difference when we refreshed our browser.
In the view script, we are now checking for the existence of $site_name prior to displaying 
it, and defaulting to "Egotist" if the $site_name is not specified.
Removing the following line of code in our Welcome Controller's action_index() method 
will prevent $site_name from being set as a view variable:
$view->site_name = 'Egotist Beta';
A quick refresh would show that the app did not break, because we were checking to make 
sure the variable was set before we printed it out.
Pop quiz – Controller conventions and View variables
1.	 In order for a controller to be valid, it must be located in the classes/
controller/ directory of the application or module, the filename must be 
lowercase, and the class should map to the filename and have Controller_ 
prepended to it. Also, every controller must extend which class?
a.	 class Kohana_URL
b.	 class Kohana_HTML
c.	
class Controller
d.	 class HTML

Using Views and Controllers
[ 46 ]
2.	 There are several ways to pass view variables from controllers to views. Which 
method allows you to pass a view variable by reference, so you can manipulate it 
without having to repass?
a.	
set()
b.	 bind()
c.	
_refer()
d.	 __set()
Using the Template Controller
Kohana ships with a Template Controller that makes it easy to implement layout and 
template files for rendering our site's pages. Essentially, the Template Controller sets an 
object property for the template and instantiates a View object. The template controller 
also sets auto rendering to true by default, and sends the template to the Request object.
Using Kohana's Template Controller makes it faster and easier for us to create our web 
applications, and allows for less work in our controller actions. In our case study site, we will 
be implementing the Kohana Template Controller, and creating base controllers that we will 
extend as the application grows.
Time for action – Extending Kohana's Template Controller
Once again, we will be altering the Welcome Controller and View scripts. This time, the 
objective is to leverage our new knowledge of how data works in our controllers, and 
how to set and display the data in the view properly.
1.	 Open the controller file located at application/classes/controller/
welcome.php.
2.	 Modify the class declaration so it reads:
ClassController_Welcomeextends Controller_Template {
3.	 Modify the action_index() method as follows:
   public function action_index()
   {
      $content = View::factory(‹welcome›)
         ->bind(‹random›, $random);
      $random = rand(1, 10);
      $content->site_name = ‹Egotist Beta›;
      $this->template->content = $content;
   }

Chapter 2
[ 47 ]
4.	 Now, we will need to create a template view file in application/views/ named 
template.php.
5.	 Add the following code to the new application/views/template.php file:
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
«http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd»>
<html>
<head>
<title>Egotist App</title>
</head>
<body>
<?php echo $content; ?>
</body>
</html>
6.	 Refresh your browser and view the output; it should appear to be the same.
7.	 In your browser, view the page source to inspect the HTML that was generated. It 
should look like this:

Using Views and Controllers
[ 48 ]
What just happened?
We started out by changing the inheritance of our Welcome Controller class. As we learned 
earlier, all of our controller classes are required to extend Kohana's Controller class. The 
Controller_Template class provided by the framework does indeed extend the base 
Controller class, so our Welcome Controller is the grandchild of the Controller class, so all is 
good there.
By extending the Template Controller, we gain the ability to use a view file as our template 
(or layout) file, and then pass data to that template.
In the action_index() method, we changed our welcome view from being set in a 
variable named $view, and instead had it assigned to a variable named $content. Then, 
we removed the call to $this->request->response, and instead had the object go to 
$this->template->content.
The reason for this is simple: the Template Controller creates a View object for us, and we 
are simply assigning view variables to it. We will cover the Template controller in more 
detail in the following section.
Next, we created the application/views/template.php view file. It contains the basic 
doctype declarations and structure for our HTML document. Inside the body tag, we are 
echoing the $content variable, and this is where our welcome view is being displayed.
As we can see, using Kohana's template controller is very useful for keeping our view files 
clean and organized. As our application grows, having templates, organized views, and thin 
controllers will make the application stronger, and our stress levels lower.
To best cover the Template controller, now would be a good time for us to open up the 
source code for the controller and get a better understanding of how it works.
Examining the Template controller
Looking over the source code for Kohana classes is one of the best ways to learn how to 
properly use the framework. Opening the Template controller located in system/classes/
kohana/controller/template.php reveals the following code:
<?php defined('SYSPATH') or die('No direct script access.');
/**
 * Abstract controller class for automatic templating.
 *
 * @package    Kohana
 * @category   Controller
 * @author     Kohana Team
 * @copyright  (c) 2008-2010 Kohana Team
 * @license    http://kohanaframework.org/license

Chapter 2
[ 49 ]
 */
abstract class Kohana_Controller_Template extends Controller {
   /**
    * @var  View  page template
    */
   public $template = 'template';
   /**
    * @varboolean  auto render template
    **/
   public $auto_render = TRUE;
   /**
    * Loads the template [View] object.
    */
   public function before()
   {
      if ($this->auto_render === TRUE)
      {
         // Load the template
         $this->template = View::factory($this->template);
      }
      return parent::before();
   }
   /**
    * Assigns the template [View] as the request response.
    */
   public function after()
   {
      if ($this->auto_render === TRUE)
      {
         $this->request->response = $this->template;
      }
      return parent::after();
   }
} // End Controller_Template
Here, we see this class is actually very simple, and it acts as an intermediary between the 
base controller for the framework and our concrete implementations in our applications 
directory.
This class has two public properties, auto_render and template, which can be overridden 
to modify the functionality easily. Next, the before() function is just creating an instance of 
a View object for the template, while the after() method is creating the response body.

Using Views and Controllers
[ 50 ]
The Template controller is very light, and simple, but provides an efficient and elegant way 
to organize our layouts while providing a base for us on which to build. This theme is very 
common through out the framework.
Have a go hero – Explore controllers and view variables
Now that we have implemented a template and view variables, there is a lot of fun to be 
had. You can experiment by passing different variables in different ways. You can even mix 
and match the different methods of passing view variables all in the same action method.
Try having the controller generate the date, compute sunrise, and return the data to your 
view. As you manipulate the template, view, and view variables, you will get a better 
understanding of what is happening and how it all fits together.
Now would also be a good time to explore the code in the system/ directory. Find the 
Controller classes and see what Kohana is doing. This will let you see first hand the 
code you are extending, and give you a better understanding of what is under the hood.
Setting global view variables
As we learned in the previous example, the template is simply a view that has view variables. In 
the case above, the $content view variable in the template was another view, in this case the 
welcome view. In the index action we assigned some view variables to the content view that 
are only accessible in the welcome.php view file, as that is the object on which they are set.
With our template, we may want to add the ability to set the page title from the controller, 
and have it displayed in the <head> section of our template file. If we also want to access 
this view variable in the welcome view, we will need to set it as a property on that object 
also. To avoid having to do this, Kohana allows us to set global view variables that we can 
access from any view we are rendering.
Time for action – Setting global view variables
Just like the set() method we used earlier to set view variables for a specific View object, in 
a similar fashion, we can set global view variables for use in multiple views.
1.	 Open the controller file located at application/classes/controller/
welcome.php.
2.	 Modifythe action_index() method as follows:
   public function action_index()
   {
      View::set_global(‹site_name›, ‹Egotist Beta›);
      

Chapter 2
[ 51 ]
      $content = View::factory(‹welcome›)
         ->bind(‹random›, $random);
      $random = rand(1, 10);
      $this->template->content = $content;
   }
3.	 Open thetemplate.php file located in application/views/.
4.	 Modifiy the template file to show the $site_name variable for the title tag:
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
«http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd»>
<html>
<head>
<title><?php echo $site_name;?></title>
</head>
<body>
<?php echo $content; ?>
</body>
</html>

Using Views and Controllers
[ 52 ]
5.	 Refresh your browser and view the output; it should be exactly the same, however, 
the page title should now be Egotist Beta. A quick glance at the source code reveals:
What just happened?
By using the set_global() static method available in Kohana's View class, we created a 
view variable named $site_name that can be accessed directly from any view file rendered. 
We then successfully named the site name variable from both the template view and the 
welcome view that was rendered inside the body tags in the template.
Viewing the page source lets us see that the title tag was properly printed, and the content 
variable successfully output the welcome view, complete with $site_name and the bound 
random number.
Binding global view variables
When we began setting view variables earlier in this chapter, we also learned how to bind 
variables to be passed by reference to our views. By binding the variables, we guaranteed 
they were set as assigned as variables before we had done anything with them.
We can also bind global view variables in a similar fashion.

Chapter 2
[ 53 ]
Time for action – Binding global view variables
Just like the bind() method we used earlier to bind view variables for a specific View 
object, we can bind global view variables for use in multiple views.
1.	 Open the controller file located at application/classes/controller/
welcome.php.
2.	 Modify the action_index() method as follows:
   public function action_index()
   {
      View::bind_global('site_name', $site_name);
      $site_name = 'Egotist Beta';
      
      $content = View::factory('welcome')
         ->bind('random', $random);
      $random = rand(1, 10);
      $this->template->content = $content;
	
}
3.	 Refresh your browser and view the output; it should be exactly the same markup.
What just happened?
The bind_global() static method in Kohana's View class allows us to bind a view variable 
in the same way set_global() lets us set one. By binding the $site_name variable as a 
global view variable, we were able to pass the $site_name variable by reference, and then 
set it later in the controller without having to re-assign it to the view.
Because we were just changing the way we passed the variable, and not the name of the 
variable itself, there were no changes necessary in our view files.
Beyond the Welcome Controller
Our Welcome Controller is now extending the Template Controller, which in turn is extending 
Kohana's Controller class. As our application grows, each controller that extends the 
Template Controller will most likely have redundant information that needs to be set. This 
could be navigation items, document titles, generated keywords, or any other information 
that may be set in every controller to be used in the template.
Before we can create a new controller to sit between the Template Controller and the 
controllers with which we will build our application, we need to know how to create a new 
controller from scratch.

Using Views and Controllers
[ 54 ]
Creating new controllers
Up to this point, we have been manipulating the welcome controller that was included in our 
Kohana 3 installation. Although we have covered the requirements for creating controllers in 
Kohana, nothing beats actually jumping in and making a new controller.
For the case study application, Egotist, the user will need to see some basic pages like about 
us, why Egotist, and so on. Although in many cases, these may be content-managed pages 
that are dynamically called from a database, we have not yet covered data stores in Kohana, 
and will be rendering these pages from view files.
To do this, we need to create a controller for viewing pages, and then create the view files 
necessary.
Time for action – Creating our first controller
We already know the rules to create a new controller, and have experience manipulating the 
action methods to generate the outcome we desire. With this knowledge in place, it is time 
to put it to action and create a controller for viewing pages in our application.
1.	 Create a new file located in application/classes/controller/ named page.
php.
2.	 Open the page.php file for editing, and insert the following code:
<?php defined('SYSPATH') or die('No direct script access.');
classController_Page extends Controller_Template {
   public function action_about()
   {
      View::set_global(‹site_name›, ‹Egotist Beta›);
      
      $content = View::factory(‹pages/about›);
       $this->template->content = $content;
   }
}
3.	 Because we are asking for a view file located at pages/about, we will need 
a view file for the action to call. To accomplish this, create a new directory in 
application/views/, and name it pages.
4.	 In the new directory, application/views/pages/, create a file named about.
php.

Chapter 2
[ 55 ]
5.	 Open application/views/pages/about.php, and insert the following code:
<h2>About Egotist</h2>
<p>We could go on and on about ourselves, and we think you 
could too!  That is why we build this wonderful application, 
so people like you could tell the world every little thing you 
were doing.</p>
6.	 Direct your browser to http://localhost/egotist/page/about; it should 
look similar to this:
What just happened?
By following the naming conventions for our controller filename, class name, and action 
methods, we were able to create a new controller that uses our template file and displays a 
HTML web page in just a dozen or so lines of code.
Because we are using Kohana's template controller, we only had to set the content view 
variable with our desired view, and also set the $site_name so the view template would 
properly print the title tag for our about page. Let's add another page to our page controller 
and see how this looks with more than one action method.
Time for action – Expanding on our first controller
Now that we have a pages controller, it will be easy to add static pages to our site. Let's start 
by adding another page that explains the benefits of using Egotist.
1.	 Locate and open the file located at application/classes/controller/page.
php.

Using Views and Controllers
[ 56 ]
2.	 Open the file for editing, and insert the following code, under our action_
about() method:
   public function action_why_egotist()
   {
      View::set_global(‹site_name›, ‹Egotist Beta›);
      
      $content = View::factory(‹pages/why_egotist›);
      $this->template->content = $content;
   }
3.	 In the application/views/pages/ directory, create a file named 
why_egotist.php.
4.	 Open application/views/pages/why_egotist.php, and insert the 
following code:
<h2>Why Egotist?</h2>
<p>Because the world wants to know when you:</p>
<ul>
   <li>Go to the store</li>
   <li>See a movie</li>
   <li>Want to share a personal thought or feeling</li>
   <li>Need to vent about nothing</li>
</ul>
<p>If constantly trying to let all your friends know just how 
cool you are, Egotist is the app for you!</p>
5.	 Direct your browser to http://localhost/egotist/page/why_egotist; it 
should look similar to this:

Chapter 2
[ 57 ]
What just happened?
Okay, now this is getting too easy. By simply creating another controller action and following 
the naming conventions, we were able to add another page by just creating the view 
content, setting the global view variable, and calling the view file for the page in question.
There are a few issues here that should be addressed, though. Let's take a look at our 
new controller in its entirity. Opening and viewing the file application/classes/
controller/page.php reveals the following code:
<?php defined('SYSPATH') or die('No direct script access.');
classController_Page extends Controller_Template {
   public function action_about()
   {
      View::set_global('site_name', 'Egotist Beta');
      $content = View::factory('pages/about');
      $this->template->content = $content;
   }
   public function action_why_egotist()
   {
      View::set_global('site_name', 'Egotist Beta');
      $content = View::factory('pages/why_egotist');
      $this->template->content = $content;
   }
}
In both the action_about() and action_why_egotist() methods, we are setting the 
same global view variable, and this is creating unneeded repetition. Also, the application is 
extremely simplistic now, but as it grows, there may be many variables being set and passed 
to the template and different views; we may even have multiple template files at some point 
(think mobile vs. desktop). Each time we create a new feature on which all pages depend, we 
will need to add them to each and every controller action. This could get ugly.
To remedy this, we can put all the redundant code in a constructor, or extend the before() 
statement as we will see later, or create a service method. Each of these options would work, 
but then we would need to duplicate this effort in every new controller. The best option is to 
create a base controller, and then have our application controllers extend it.

Using Views and Controllers
[ 58 ]
Creating a base controller
Our application gained significant strength by switching from extending Kohana's Controller 
class to its Template Controller class. The Template Controller extends the Controller class, 
but adds the functionality to load and prepare a template view, making development easier.
Using this same pattern, we can create a base controller for our app, have it extend the 
Template Controller, and in turn have our application controller extend our new base controller.
Time for action – Creating an abstract controller
The case study application will have many controller actions that will all share the same 
layout, and many of the same features and view variables. We can house these common 
features in a controller that sits between the Template Controller and our extended 
controller.
1.	 Create a file located at application/classes/controller/ named 
application.php.
2.	 Open and add the following code to the application.php:
<?php defined('SYSPATH') or die('No direct script access.');
abstract class Controller_Application extends Controller_
Template {
   public function before() 
   {
      parent::before();
      View::set_global(‹site_name›, ‹Egotist Beta›);
      
      $this->template->content = ‹›;
      $this->template->styles = array();
      $this->template->scripts = array();
   }
      
}
3.	 Open the application/classes/controller/welcome.php and 
application/classes/controller/page.php files, and change the class 
declarations to extend Controller_Application instead of Controller_
Template.

Chapter 2
[ 59 ]
4.	 In application/classes/controller/page.php, remove the following line 
from the action_about() and action_why_egotist() methods:
View::set_global('site_name', 'Egotist Beta');
5.	 In application/classes/controller/welcome.php, remove the following 
lines from the action_index() method:
View::bind_global('site_name', $site_name);
site_name = 'Egotist Beta';
6.	 Lastly, we will need to update our Welcome and Page controller one more time 
to have them extend the Application controller. Modify their class declarations as 
follows:


classController_Welcome extends Controller_Application and


classController_Page extends Controller_Application
7.	 Refresh your browser and view the output; the page should be exactly the same as 
it did in the previous section, only now the code is more organized and abstracted.
What just happened?
By creating this controller as an abstract class, we are telling PHP that this controller is 
designed to be extended and not called directly. This allows us to put common code in this 
class, and have it accessible by any controllers that are its children or grandchildren.
The next statement overrides the Template Controller's before() method. When we cover 
routing and request handling in more detail, we will get a more involved look into methods 
like before() and after(), but for now it is okay to think of the before() method as a 
sort of constructor, or a method that will be run before any other methods in the controller.
Just like when we override the constructor of a parent class, it is very common to 
resolve the scope and inherit the functionality of the overridden method. By calling 
parent::before(), we are invoking the before() method of the Controller_
Template class.
Next, we are setting the global view variable, $site_name, thereby removing the need 
for every controller or action method in our application from having this redundant code. 
By setting the site name variable here, we were able to remove calling it from the three 
action methods that are currently in existence in our application. Now, when we add future 
common variables, we can do so in our Application Controller and skip all the copy and 
pasting.

Using Views and Controllers
[ 60 ]
We then initialize the content view variable to prevent errors in our template when it 
attempts to print the variable.
Lastly, we are creating two view variables for future use in our template. These are for our 
JavaScript and CSS files that we may want to use in our application to make it look better, 
enhance the user experience, or both. Right now, our view pages are very bland, using only 
the browser's default styles. It is about time to put some of our new knowledge to good use 
and make this application presentable.
Pop quiz – Controllers and views
1.	 To set a view variable and make it accessible to all View objects at time of render, 
Kohana provides which method:
a.	
View::bind()
b.	 View::set()
c.	
View::set_global()
d.	 Url::base()
2.	 Your application now has a few controllers. The site name is being set globally in the 
Application Controller, which extends what class?
a.	
Controller_Template
b.	 Controller
c.	
Url::base()
d.	 Controller_Welcome
Putting it all together
Now that we have some experience creating views and controllers in Kohana, and have seen 
some of the patterns that can be used to make coding in Kohana easier, it is time to apply 
some of this knowledge and fix up the Egotist case study application.
One of the first things we can do is create and link some stylesheets that will be used 
throughout our application to give our site some style. Since we created the template view 
variable to store an array of stylesheets, it should be easy to load the files from our template 
programmatically.
Although we could directly add the links to our stylesheets in our template view file, there 
may be times when we have more than one template, and this again creates more than one 
place to copy and paste updates. By keeping the number of places necessary to update code 
at a minimum, our application will be easier to maintain.

Chapter 2
[ 61 ]
Time for action – Adding stylesheets to template
For our case study site, we will need to create and use a reset and a common CSS file for use 
on publicly viewable pages. For the reset.css file, we will use Eric Meyer's reset stylesheet 
that is freely available at http://meyerweb.com/eric/tools/css/reset/.
1.	 Create a new directory in your site root named media. This is the place we will store 
images, CSS, and JavaScript files.
2.	 In the new media directory, create a directory named css.
3.	 Create a new file in media/css named reset.css, and use the reset available 
at http://meyerweb.com/eric/tools/css/reset/for its contents. It should 
look similar to this:
html, body {
   height: 100%;
   background-color: #EEE;
   font-family: Verdana;
}
#container {
   width: 940px;
   margin: auto;
   min-height: 100%;
   background: url(‹../images/background.png›);
}
#header {
   width: 720px;
   margin: 0 auto 10px;
}
#logo {
   width: 200px;
   float: left;
   margin: 12px;
}
p#tagline {
   width: 275px;
   float: right;
   margin: 30px 90px 10px 10px;
   color: #999;
   font-size: 18px;
   font-weight: bold;

Using Views and Controllers
[ 62 ]
}
ul#main_nav {
   clear: both;
   padding: 10px;
   text-align: center;
   background-color: #CCC;
}
ul#main_nav li {
   display: inline;
   margin: 0 10px;
}
ul#main_nav li a {
   text-decoration: none;
   color: #333;
   font-weight: bold;
}
ul#main_nav li a:hover {
   text-decoration: underline;
}
#content {
   width: 680px;
   margin: 25px auto;
   color: #333;
   line-height: 1.3;
}
#content h1 {
   font-size: 24px;
   padding-bottom: 8px;
}
#content h2 {
   font-size: 18px;
   padding-bottom: 8px;
}
#contentul {
   list-style-type: disc;
   margin: 8px 0 8px 35px;
}
#footer {
   width: 680px;

Chapter 2
[ 63 ]
   margin: 0 auto 10px;
   padding-top: 18px;
   color: #666;
}
These CSS files and the images associated with them are available with 
the source code that accompanies this book.
4.	 Open and edit the Application Controller located at application/classes/
controller/application.php, modifying the following code:
   $this->template->styles = array(
         ‹reset›,
         ‹common›
      );      
5.	 Open and edit the template view file located at application/views/template.
php, modifying the following code inside the head tag:
<head>
<?phpforeach ($styles as $style) : ?>
   <linkrel=»stylesheet» href=»<?php echo URL::base(); ?>media/
css/<?php echo $style; ?>.css» type=»text/css» media=»screen» 
/>
<?phpendforeach; ?>
<?phpforeach ($scripts as $script) : ?>
   <scriptsrc=»<?php echo URL::base(); ?>media/js/<?php echo 
$script; ?>.js» /></script>
<?phpendforeach; ?>
<title><?php echo $site_name; ?></title>
</head>

Using Views and Controllers
[ 64 ]
6.	 A refresh of our «why_egotist» page source shows our stylesheets are being added:
What just happened?
We began by adding a couple of basic stylesheets to the application, organizing them in a 
folder named media in which will we be keeping our frontend assets. Because the focus of 
this book and exercise is on the Kohana framework, we will not spend a lot of time making 
our application very pretty, nor will we spend time reviewing the CSS, or testing for all edge 
use cases. The scope of this book can only cover so much.
After creating the basic stylesheets needed to complete this chapter, we then added the 
names of these files to our Application Controller, passing them to the template view as an 
array in a view variable.
By using our Application Controller to keep the list of stylesheets in one place, we can make 
it quick and easy to add, remove, or update the files we want to load. This will also allow us 
to make our application more advanced if needed, by overriding or having other means of 
creating the stylesheet array.

Chapter 2
[ 65 ]
In the template view file, we then created two foreach loops, iterating through the arrays 
for stylesheets and JavaScript files, and creating the corresponding HTML code necessary to 
load the files. Examining the code that is executed for each array value in our styles array, we 
see this line of code:
<linkrel="stylesheet" href="<?php echo url::base(); ?>media/css/<?php 
echo $style; ?>.css" type="text/css" media="screen" />
There is a similar line of code in the foreach block that iterates through the scripts array. 
This line of code should mostly make sense: it is a link tag, and it is loading the CSS file with 
the name of the array value concatenated to CSS. The link location is being passed, but it is 
starting with an unfamiliar bit of code:
<?php echo URL::base(); ?>
This helper method, or static method provided by the framework to make coding easier, 
returns the base URL, generated using the values set in our bootstrap file. Another similar 
method is the URL::site() method, which returns the generated URL for our site. We will 
cover methods like this more in Chapter 4, where we will learn about Kohana's using classes 
and helper methods.
Even though we have some stylesheets loading the structure of our application is lacking, 
even for an example site. Adding some basic structure, like a header and footer, is very easy 
using what we know about Kohana 3. Let's spruce up our view files.
Adding structure to view files
For us to test and use the application, and eventually for our users, we will need some basic 
site structure and navigation. This will make testing and developing the site as we move 
forward easier. Also, now we can put some more of our new knowledge to work.
Time for action – Adding header and footer view files
The stylesheets we added do no good if there is no document structure for it to style, 
and without basic features like a navigation menu, we cannot even test our site without 
constantly typing in the address bar. To fix this, we can add a header and footer view, and 
make some minor alterations to our template view.
1.	 Locate and open the file located at application/views /template.php.
2.	 Open the file for editing, and update the following code inside the body tag:
<body>
   <div id=»container»>
      <div id=»header»>
      <?php echo View::factory(‹common/header›); ?>

Using Views and Controllers
[ 66 ]
      </div>
      <div id=»content»>
      <?php echo $content; ?>
      </div>
      <div id=»footer»>
      <?php echo View::factory(‹common/footer›); ?>
      </div>
   </div>
</body>
3.	 In the application/views/ directory, create a folder named common.
4.	 Inside the new application/views/common/ directory, create a file named 
header.php, and open it for editing. In this new file, add the following code:
<div id="logo">
   <imgsrc=»<?phpechoURL::base(); ?>media/images/logo.png» 
alt=»<?php echo $site_name; ?>» />
</div>
<p id=»tagline»>
   <em>Because it›s all about you!</em>
</p>
<ul id=»main_nav»>
   <li><a href=»<?phpechoURL::site(); ?>»>Home</a></li>
   <li><a href=»<?phpechoURL::site(‹page/about›); ?>»>About <?php 
echo $site_name; ?></a></li>
   <li><a href=»<?phpechoURL::site(‹page/why_egotist›); ?>»>Why 
use Egotist?</a></li>
</ul>
Inside the new application/views/common/ directory, create a file 
named footer.php, and open it for editing.  In this new file, add 
the following code:
<p>Copyright &copy; 2011 - <?phpecho$site_name; ?></p>

Chapter 2
[ 67 ]
5.	 Refreshing your browser (with the images from the code provided with this book) 
should yield the following results when you browse to http://localhost/
egotist/page/why_egotist:
Clicking on the navigation links should take you to the respective pages.
What just happened?
The document structure provided the necessary tags for our CSS to have some effect. Apart 
from rendering the header and footer views from within the template view, most of the 
additional code in the template.php file should be self-explanatory; let's take a look at the 
header view render, which is new to us:
<?phpechoView::factory('common/header'); ?>
We have encountered the View::factory() static method a few times already, and know 
that it returns a new View object using the view file passed to it. Up until now, we have 
created the View objects in a controller, and have allowed the auto rendering to handle our 
view generation. As we can see, creating new views inside of a view script is just as easy.
The header view file simply contains the site's logo, a tagline, and the navigation menu. As 
the application grows, or changes design, the logic in the controllers is completely separate 
from our views and template. Changing anything we have created so far only requires visiting 
one piece of code. This is the goal of DRY, or Don't Repeat Yourself.

Using Views and Controllers
[ 68 ]
The footer is handled the same way as the header: we are creating a new View object with 
the footer view file, and then rendering it and printing the generated output. Once all this is 
put together, the end result is a working site, with three pages and very little custom code.
Have a go hero – Customize quickly and easily
Now that the application is showing some signs of life, and we have a good grasp on how the 
template, controllers, views, and file system are all working together to deliver rich content 
with little code, we can now begin to customize our application's look and feel.
By adding, updating, or modifying view variables and stylesheet code, we can make a lot 
of changes with little effort. Assume the case study site was to change names completely. 
How hard would it be to make the changes sitewide? Pick a new name for the application, 
and have it change in the title tag, nav menu, and so on, and see how easy it is to maintain a 
Kohana 3 application.
Summary
When we began this chapter, our Kohana application was installed, but did not do much. 
After creating just a few files, and writing very little code, we have a working site with three 
pages. We have learned how to create and use view variables, create our own controllers, 
and extend Kohana's controller files to add more flexibility to our applications.
By taking advantage of Kohana's Template Controller, we have eliminated almost all 
repetitive code, made updating and maintenance easier, and abstracted code to make 
reusability in future application features easy to implement.
We also used our case study site to see real world examples of how to put all of our new 
knowledge into action. In our template view, we learned how to render other view files 
outside of the controller. We also applied basic styling and document structure to every page 
in the application by using the template and application controllers to do the heavy lifting.
Now that we have learned how to create and use Controllers and Views in Kohana, let's take 
a more in depth look at how routing and request handling works in the framework.
In the next chapter, we will learn about the way Kohana routes our requests, and how to use 
request handling and routing to make our applications more robust. We will also learn more 
about Kohana's cascading filesystem, the Heirarchy aspect of HMVC, and how Kohana works 
at runtime.

3
Routing and Request Handling
What is HMVC, and what makes it so great?
Frameworks utilizing the MVC design pattern are becoming very common in 
web development, but you may not be familiar with the Hierarchical aspect that 
is used in Kohana 3. Combine HMVC with a cascading filesystem, a powerful 
Routing class, and a new request flow, and it can all seem a bit daunting. This 
chapter focuses on answering all your questions about HMVC, routing, request 
flow, and the cascading filesystem in Kohana.
Now that we have installed Kohana and created our first views and controllers, it is time to 
take a look at the inner workings of the framework, so we will have the knowledge necessary 
to create web applications that take advantage of Kohana’s most powerful features.
In this chapter, we will learn:


What HMVC is, and how it works


Kohana’s Request Flow


How to use the Request class


Routing in Kohana


How to use Routing in our applications


Advanced routing techniques
The topics covered in this chapter are important to every application build using Kohana. 
By the end of this chapter, we will have a strong understanding of the foundation of the 
framework, and a working knowledge of how it is applied in real work senarios. Let’s begin 
by exploring Kohana’s hierarchy.

Routing and Request Handling
[ 70 ]
Hierarchy is King in Kohana
Kohana is layered in more ways than one. First, it has a cascading files system. This means 
the framework loads files for each of it’s core parts in a hierarchical order, which is explained 
in more detail in just a bit. Next, Kohana allows for controllers to initiate requests, making 
the application workflow follow a hierarchical design pattern. These features are the 
foundation of HMVC, which essentially is a cascading filesystem, flexible routing and request 
handling, the ability to execute sub-requests combined with a standard MVC pattern.
The framework manages locating and loading the right file by using a core method named 
Kohana::find_file(). This method searches the filesystem in a predetermined order 
to load the proper class first. The order the method searches in is (with default paths):


Application path (/application)


Modules (/modules) as ordered in bootstrap.php


System path (/system)
Cascading filesystem
As the framework loads, it creates a merged filesystem based on the order of loading 
described above. One of the benefits of loading files this way is the ease to overload classes 
that would be loaded later in the flow. We never have to, nor should we, alter a file in the 
system directory. We can override the default behavior of any method by overloading it in 
the application directory.
Another great advantage is the consistency this mechanism offers. We know the exact load 
order for every class in any application, making it much easier to create custom code and 
know exactly where it needs to live.

Chapter 3
[ 71 ]
Kohana Framework Cascading Filesystem
application
classes/
controller/
views/
kohana/
cookie.php
welcome.php
error.php
welcome.php
classes/
controller/
views/
kohana/
cookie.php
welcome.php
error.php
welcome.php
classes/
model/
views/
user.php
welcome.php
user.php
modules/common
classes/
config/
database.php
database.php
modules/database
system
classes/
kohana/
cookie.php
cookie.php
views/
kohana/
error.php
merged
classes/
cookies.php
controller/
welcome.php
database.php
encrypt.php
cookie.php
encrypt.php
model/
user.php
config/
database.php
views/
kohana
error.php
user.php
welcone.php
kohana/
kohanaframework.org
some rightsreserved
cc
This image shows an example application being merged into the final file structure that will 
be used when completing a request. We can see how some classes in the application layer 
are overriding files in the modules. As we will find later in the book, there could also be 
modules that could be loaded in place of core system files.
This makes it easier to visualize how modules extend and enhance the framework by building 
on the system core. Our application then sits on top of the system and module files, and then 
can build and extend the functionality of the module and system layers. Kohana also makes it 
easy to load third-party libraries, referred to as vendor libraries, into the filesystem.

Routing and Request Handling
[ 72 ]
Each of the three layers has five basic folders into which Kohana looks:


Classes (/classes) contain all autoloaded class files.  This directory includes our 
Controller, Models, and their supporting classes.  Autoloading allows us to use 
classes without having to include them manually.  Any classes inside this directory 
will automatically be searched and loaded when they are used.


Config files (/config) are files containing arrays that can be parsed and loaded 
using the core method Kohana::config().  Some config files are required to 
configure and properly load modules, while others may be created by us to make 
our application easier to maintain, or to keep vendor libraries tidy by moving config 
data to the framework.  Config files are the only files in the cascading filesystem that 
are not overloaded; all config files are merged with their parent files.


Internationalization files (/i18n) make it much easier to create language files that 
work with our applications to deliver the proper content that best suits the language 
of our users.  Internationalization is beyond the scope of this book and will not be 
included in our case study site.


Messages (/messages) are much like configuration files, in that they are arrays that 
are loaded by a core Kohana method.  Kohana::	message() parses and returns 
the messages for a specific array.  This functionality is very useful when creating 
forms and actions for our applications.


View files (/views) are the presentation layer of our applications, where view files 
and template files live. We have created views in the previous chapter, and know 
what goes in this directory.
Request flow in Kohana
Now that we have seen how the framework merges files to create a set of files to load on 
request, it is a good place to see the flow of the files in Kohana. Remember that controllers 
can invoke requests, making a bit of a loop between controllers, models, and views, but the 
frameworks always runs in the same order, beginning with the index.php file.
The index.php file sets the path to the application, modules, and system directories 
and saves them to as constants that are then defined for global use. These constants are 
APPPATH, MODPATH, and SYSPATH, and they hold the paths for the application, modules, 
and system paths respectively. After the error-reporting levels are set, Kohana looks to see if 
the install.php file exists. This is the file we saw when we installed Kohana that ran some 
environment tests for us to confirm a proper installation.
If the install file is not found, Kohana takes the next step in loading the framework by loading 
the core Kohana class. Next, the index file looks for the application’s Kohana class, first in the 
application directory, then in the system path. This is the first example of Kohana looking for 
our files before it looks for its own.

Chapter 3
[ 73 ]
The last thing the index file does is bootstrap our application, by requiring the bootstrap.
php file and loading it.
You probably remember having to configure the bootstrap file when we installed Kohana. 
This is the file in which we set our base URL and modules; however, it is a bit more important 
than just basic installation and configuration.
The boostrap begins by setting a some basic environment settings, like the default timezone 
and locale. Next, it enables the autoloader, and defines the application environment. This 
tells the framework whether our application is in a production or development environment, 
allowing it to make decisions based on its environment-specific settings.
Next, the default options are set and Kohana is initialized, with the Kohana::init() 
method being called. After Kohana’s initialization, it sets up logging, configuration reading, 
and then modules.
Modules are loaded defined using an array, with the module name as the key, and the path 
to the module as the value. The modules load order is listed in this array, and are all subject 
to the same rules and conventions as core and application code.
Each module is added to the cascading file system as described above, allowing files to 
override any that may be added later when the system files are merged. Modules can 
contain their own init files, named init.php, that act similar to the application bootstrap, 
adding routes specific to the modules for our application to use.
The last thing the bootstrap does in a normal request flow is to set the routes for the 
application. Kohana ships with a default route that loads the index action in the welcome 
controller.
The Route object’s set method accepts an array that defines the name, URI, and defaults for 
the parameters set for the URI. By setting default controllers, actions, and params, we can 
have dynamic URLs that have default values if none are passed.
If no controller or action is passed in the URI on a vanilla Kohana install, the welcome 
controller will be loaded, and the index action invoked as outlined in the array passed to the 
Route::set() method in the boostrap.
Once all the application routes are set via the Route::set() method and init.php files 
residing in modules, Request::instance() is invoked, setting the request loop into 
action. As the Request object processes the request, it looks through routes until it finds 
the right controller to load. The request object then instantiates the controller, passing the 
request to the controller for it to use.

Routing and Request Handling
[ 74 ]
The Controller::before() method is then called, which acts much like a constructor. 
By being called first, the before() method allows any logic that need to be performed 
before a controller action is run to execute. Once the before method is complete, the object 
continues to load the requested functions, just like when a constructor is complete.
The controller action, a method in the controller class, is then called, and once complete, it 
returns the request response. The action method is where the business logic for the request 
will reside.
Once the action is complete, the Controller::after() method is called, much like the 
destructor of a standard PHP class.
Because of the hierarchical structure of Kohana, any controller can initiate a new request, 
making it possible for other controllers to be loaded, invoking more controller actions, which 
generate request responses.
Once all the requests have been fulfilled, Kohana renders the final request response.
The Kohana request flow can seem like it is long and complex, but it can also be looked at as 
very clean and organized. By using a front controller design pattern, all requests are handled 
by just one file: index.php. Each and every request that is handled by our applications will 
begin with this one file. From there the application is bootstrapped, and then the controller 
designed to handle the specific request is found, executed, and displayed. Although, as we 
have seen, there is more that is happening, for most of our applications, this simple way 
of looking at the request flow will make it easy to create powerful web applications using 
Kohana.
Using the Request object
The request flow in Kohana is interesting, and it is easy to see how it can be powerful on a 
high level, but the best way to understand HMVC and routing in Kohana is to look at some 
actual code, and see what the resulting outcome is for real world scenarios.
Kohana’s Request object determines the proper controller to invoke, and acts as a wrapper 
for the response. If we look at the Template Controller that we are extending in our 
Application Controller for the case study site, we can follow the inheritance path back to 
Kohana’s template controller, and see the request response.
One of the best ways to understand what is happening inside the framework is to drill down 
through the filesystem and look at the actual code. One of the great advantages of open 
sources frameworks is the ability to read the code that makes the library run.

Chapter 3
[ 75 ]
Opening the welcome controller located at application/classes/controller/
welcome.php, we see the following class declaration:
class Controller_Welcome extends Controller_Application
The first thing we see in the base controller class is that it extends another Controller, and 
then we see the declaration of an object property named $request. This variable holds 
the Kohana_Request object, the class that created the original controller call. In the 
constructor, we can see that the Kohana_Request object is being type-hinted for the 
argument, and it is setting the $request object property on instantiation. All that is left in 
the base Controller class is the before() and after() methods with no functionality.
We can then open our Application Controller that we created in the last chapter, located at 
application/classes/controller/application.php. The class declaration in this 
controller looks like this:
abstract class Controller_Application extends Controller_Template
In this file, we can see the before() method loading the template view into the template 
variable, and in the after() method, we see the Request obeject ($this->request) 
having the response body set, ready to be rendered. This class, in turn, extends the Template 
Controller.
The Template Controller is part of the Kohana system. Since we have not created any 
controllers in our application or modules the original template controller that ships with 
Kohana is being loaded. It is located at system/classes/controller/template.php. 
The class declaration in this controller looks like:
abstract class Controller_Template extends Kohana_Controller_Template
Here things take a twist, and for the first time, we are going to have to leave the /classes/
controller/ structure to find an inherited class. The Kohana_Controller_Template 
class lives in system/classes/kohana/controller/template.php. The class is fairly 
short and simple, and it has this class declaration:
abstract class Kohana_Controller_Template extends Controller
This controller (system/classes/controller.php) is the base controller that all requested 
controller classes must extend. Examining this class will let us see the Request class enter the 
Controller loop and the template view get sent to the Request object as the response.
Walking through the Welcome Controller’s heritage is a great way of seeing how the Request 
object loads a controller, and how the parent classes all contribute to the request flow in 
Kohana. It may seem like pointless complexity at first, however, the benefits of transparent 
extension are very powerful, and Kohana makes the mechanisms work all behind the scenes. 
But one question still remains: How is the request object aware of the controllers and routes?
www.allitebooks.com

Routing and Request Handling
[ 76 ]
Athough dissecting Kohana’s Request Class could be a chapter unto itself, a lot can be 
answered by looking at the contstructor in the system/classes/kohana/request.php 
file. The constructor is given the URI, and then stores object properties that the object will 
later use to execute the request.
The Request class does have a couple of key methods that can be very helpful. The first is 
Request::controller(), which returns the name of the controller for the request, and 
the other is Request::action(), which similarly returns the name of the action for the 
request.
After loading the routes, the method then iterates through the routes, determines any 
matches for the URI, and begins setting the controller, action, and parameters for the route. 
If there are not matches for optional segments of the route, the defaults are stored in the 
object properties.
When the Request object’s execute() method is called, the request is processed, and 
the response is returned. This happens by first processing the before() method, then the 
controller action being requested, then the after() method for the class, followed by any 
other requests until all have completed.
The topic of initiating a request from within a controller has arisen a few times, and is the 
best way to illustrate the Hierarchical aspect of HMVC. Let’s take a look at this process by 
creating a controller method that initiates a new request, and see how it completes.
Creating a profile page to render messages
In our case study site, users will be creating text messages that will be listed on the site.  
These messages will be displayed on their public profile pages, and as the site grows, they 
may be viewed elsewhere.
Although the first draft of the site will only show the messages on the user’s page, there 
could be growth where this content could be rendered in a mobile environment, in other 
pages, in widgets, or elsewhere.  Listing the user’s messages is a core function of the 
application, after all.
If we created the logic and view to display the messages inside the same controller action 
that renders the user’s profile page, reusing the code would be difficult, if not impossible.  To 
prevent having to write this logic in several places inside the Egotist application, it is better 
to create a controller that handles the logic for listing messages for a user, and a view to list 
out the messages, and then have any pages that use the list to request it from within their 
corresponding actions.

Chapter 3
[ 77 ]
Time for action – Creating a profile page with messages
Using the case study site to illustrate this process, we are going to add a profile controller to 
handle the public pages for our users. The default page for user’s public pages will be their 
profile page, with all of their recent messages and information. For now, we will just pass a 
fake username and some messages to test functionality.
1.	 Create a new controller in our application/classes/controller directory 
named profile.php. This will be our Profile Controller that will be used to display 
user profiles and related items. In the newly created file, insert the following code:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
class Controller_Profile extends Controller_Application {
   public function action_index()
   {      
      $content = View::factory(‹profile/public›)
         ->set(‹username›, ‹Test User›)
         ->bind(‹messages›, $messages);
      $messages = array(
         ‹This is test message one›,
         ‹This is test message two›,
         ‹This is test message three›
      );
      
      $this->template->content = $content;
   }
}
2.	 As we see, this controller’s default action is going to render a view in a directory 
named profile, with the view file named public. To create this view, we will 
need to make a folder called profile in the application/views directory.
3.	 In our newly created application/views/profile directory, create and 
open a file named public.php. In this file, insert the following code:
<h2>Public Profile for <?= $username; ?></h2>
<h3>Recent Messages:</h3>
<?php foreach ($messages as $message) : ?>
   <p class=»message»>
      <?= $message; ?>
   </p>
<?php endforeach; ?>

Routing and Request Handling
[ 78 ]
4.	 Open the page http://localhost/egotist/profile/, it should look like this:
What just happened?
The only thing new here are the actual files. Creating a controller, action, and view are not 
new concepts to us, and we have experienced binding and setting view variables in previous 
examples. What we did create was another page, one that will be growing and becoming a 
very important part of the case study application.
We are at one of the cross roads in application development, where we are best served by 
thinking about how the application could act in the future, and architect our code in such a 
manner to anticipate future needs while minimizing code complexity.
We can assume a few things about how this page may act in the future. First of all, it will be 
rendering dynamic text for each user; therefore, it must have a way to retrieve data based on 
a particular user. The most common way of doing this is using a database, and retrieving the 
data from tables filled with user data.
It is also very possible that the messages listed for a user may be viewed in other means, like 
mobile applications or widgets, and retrieving and listing these messages would be necessary 
for these other locations.

Chapter 3
[ 79 ]
Calling a new request inside a request
Object-oriented programming has many great advantages, too many to list here, but 
code reusability and abstraction are paramount in leveraging this style of programming. 
The principle of Don’t Repeat Yourself (DRY) coding is easier to achieve when we write 
abstracted code that can be used throughout our projects without having to live in more 
than one place.
Creating controllers that handle specific tasks that can be called directly, or requested from 
within other controllers or views, makes it much easier to create reusable, DRY code. Our 
current profile controller has a variable for our user’s name, and an array of their messages. 
Once a database is added, there will be code to retrieve this, and possibly more, information 
that will be passed to the view.
Having the logic to handle all of this in the current controller action does not allow for the 
messages code to be reused in other parts of the site, and is not taking advantage of the 
HMVC architecture inherent in Kohana. To make our code more reusable and easier to 
maintain, we should create a controller and view to handle listing user messages.
Time for action – Creating a request within a request
Having messages handled and rendered by a separate class allows us to abstract our code 
for more portability and reuse. Although the messages logic is very simple right now, only 
passing test data in an array, once a data store and more information tied to messages are 
introduced, the process could become more complex and needed in other parts of the 
application.
To fix this, we can simply move the logic to a new controller class.
1.	 Create a new controller in our application/classes/controller/ 
directory named messages.php. This will be our Messages Controller that 
will be used to display user profiles and related items. In the newly created 
file, insert the following code:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
class Controller_Messages extends Controller {
   public function action_index()
   {      
      URL::redirect();	
   }
   public function action_get_messages() 
   {
      

Routing and Request Handling
[ 80 ]
      $messages = array(
         ‹This is test message one›,
         ‹This is test message two›,
         ‹This is test message three›
      );
      
      $this->request->response = View::factory(‹profile/messages›)
         ->set(‹messages›, $messages);
   }
}
2.	 As we see, this controller’s get_messages() action is going to render a view in a 
directory named profile, with the view file named messages. Create and open a file 
named messages.php in our application/views/profile directory. 
In this file, insert the following code:
<?php foreach ($messages as $message) : ?>
   <p class=»message»>
      <?= $message; ?>
   </p>
<?php endforeach; ?>
3.	 Open the page http://localhost/egotist/messages/get_messages/; 
it should look like this:
The Messages Controller is called and shows the listed messages per the view file. 
The get_messages action is passing the messages to the view.

Chapter 3
[ 81 ]
4.	 To incorporate this new controller into our existing application, we will 
need to alter our Profile Controller. Open the file located at application/
classes/controller/profile.php and modify it like this:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
class Controller_Profile extends Controller_Application {
   public function action_index()
   {      
      $content = View::factory(‹profile/public›)
         ->set(‹username›, ‹Test User›)
         ->bind(‹messages›, $messages);
      
      $messages = Request::factory(‘messages/get_messages’)-
>execute()->response;
     
      $this->template->content = $content;
   }
}
5.	 Now that our Profile Controller is passing a rendered view into the messages 
view variable instead of an array, we will need to alter our profile view 
script. Open the view located in our application/views/profile 
directory named public.php, and change the code to look like this:
<h2>Public Profile for <?= $username; ?></h2>
<h3>Recent Messages:</h3>
<?= $messages; ?>
6.	 Open the page http://localhost/egotist/profile/; it should look like this:

Routing and Request Handling
[ 82 ]
What just happened?
Again, the creation of a new controller and view should be familiar to us, but there are some 
things happening this time that are different from our previous experiences. In the Messages 
Controller, we have an index, or default action that is simply redirecting users back to the 
home page. As this controller only has one action we are using right now, any accidental 
navigation to this controller should default to returning users to the default controller and 
action for the application.
We then created our first non-default action, action_get_messages(). When we viewed 
this controller action directly, we saw the messages being rendered to the browser, without 
any template surrounding the HTML.
This is because the Messages Controller is not extending our Application Controller or the 
Template Controller, but is extending Kohana’s base Controller directly. This is because we 
want the rendered messages view to be diverse, and have the ability to be rendered inside 
of other views or controllers.
When we altered our Profile Controller class, we removed the logic that is now living in 
the Messages Controller, and replaced the $messages view variable contents with this 
line of code:
$messages = Request::factory(‘messages/get_messages’)->execute()-
>response;
Here, we are calling the factory method on the Request object, and telling it to request 
the Messages Controller’s get_messages action. This is the same request that would be 
fired if we browsed to http://localhost/egotist/messages/get_messages/. 
The execute() method then parses the request and loads the response into the Request 
object’s $request property, which we are calling via chaining. The same line of code could 
be written as follows for more clarity:
$request = Request::factory(‘messages/get_messages’);
$request->execute();
$messages = $request->response;
In our modified profile view, we replaced the foreach loop that iterated through the 
messages array and displayed the values with a simple echo statement that prints the 
results of the Messages request response.
By using this pattern when writing our controllers, we will find our code to be easy to 
read, maintain, and reuse. As our applications grow, take on new functionality, and require 
maintenance, this style of coding will make it easier and faster to keep our applications up 
to date.

Chapter 3
[ 83 ]
Now that we have some experience with the Request object in Kohana, it is a good time to 
explore how we can use routes to keep our users, and data, flowing to the proper controller 
actions, and how to build dynamic applications using Kohana’s routing abilities. 
Have a go hero – Create a request from within a view
In the case study application, we have created a request from within our Profile Controller, 
and assigned the executed response to a view variable, which we are then outputting inside 
the profile view script. Although keeping logic in the controller is important, if no other 
manipulation is being done, simply content being rendered for output, it can just as well live 
inside the view.  See if you can eliminate the request for messages from the controller, move 
it to the view, and not change the final output that is rendered when visitng the page.
Routing in Kohana
If you remember, the bootstrap file comes preconfigured with a default route that follows a 
very simple structure:
Route::set(‘default’, ‘(<controller>(/<action>(/<id>)))’)
   ->defaults(array(
      ‘controller’ => ‘welcome’,
      ‘action’     => ‘index’,
   ));
This tells Kohana that when it parses the URL for any request, it first finds the base_url, 
and then the next segment will contain the controller, then the action, then an ID. These are 
all optional setgments, with the default controller and action being set in the array. We have 
taken advantage of this route with other controllers like our Profile and Message controller.
When we visit http://localhost/egotist/profile, the route sets the controller to 
profile, and since no action or ID is explicitly defined in the URL, the default action of ‘index’ 
is used. When we requested http://localhost/egotist/messages/get_messages 
from within our Profile Controller, we also followed this route; however, neither defaults 
were needed, and the route asked for the Messages Controller and its get_messages 
action.
In our Profile controller, we are only using one array of example messages to test 
functionality and the expected behavior of our application. When we implement a 
data store and have multiple users with profiles in our application, we will need a way 
to decipher which profile a user wants to see.
Because the default route already has an available parameter for ID, we can use that to pass 
an ID to our Profile Controller’s index action, and have the messages controller then find the 
proper messages for that user.

Routing and Request Handling
[ 84 ]
Time for action – Making profiles dynamic using ID
Once a database is tied to our application, and more than one user has a profile, we will 
need some way of knowing which profile to display. A simple and effective way to do this is 
to pass a user ID in the route, and have our controller use that ID to find the right messages 
for the right user. Let’s add some more test data to our messages system, and use an ID to 
display the right messages.
1.	 Open the Profile Controller in our application/classes/controller/ 
directory named profile.php. Since the action_index() method 
is the controller action that is called when a profile is viewed, we will 
need to edit it to look for the ID parameter in the URI like this:
public function action_index()
{
   $content = View::factory(‹profile/public›)
      ->set(‹username›, ‹Test User›)
      ->bind(‹messages›, $messages);
      
   $id = (int) $this->request->param(‘id’);
      
   $messages_uri = “messages/get_messages/$id”;
      
   $messages = Request::factory($messages_uri)->execute()-
>response;
      
   $this->template->content = $content;
}
2.	 Now, we are retrieving the ID from the route and passing it along in our 
request to the Messages Controller.  This means that class must also be 
updated. Open the messages.php file located in application/classes/
controllers/ and modify its action_get_messages() method as follows:
public function action_get_messages() 
{
   $id = (int) $this->request->param(‘id’);
   
   $messages = array(
      1 => array(
         ‘This is test message one for user 1’,
         ‘This is test message two for user 1’,
         ‘This is test message three for user 1’
      ),
      2 => array(
         ‘This is test message one for user 2’,

Chapter 3
[ 85 ]
         ‘This is test message two for user 2’,
         ‘This is test message three for user 2’
      )
   );
   
   $messages = array_key_exists($id, $messages) ? $messages[$id] : 
NULL;
   
   $this->request->response = View::factory(‘profile/messages’)
      ->set(‘messages’, $messages);
   
}
3.	 Open the page http://localhost/egotist/profile/index/2/. 
It should look like this:
Browsing to http://localhost/egotist/profile/index/1/ will show the 
messages for user 1, i.e., the test messages placed in the message array under key 1.
What just happened?
At the very beginning of our index action in our Profile Controller, we set our $id variable by 
getting the ID parameter from the route. Since Kohana has parsed our route for us, we can 
now access these parameters via the request object’s param() method.
Once we got the ID variable, we then created and executed the request for the message 
controller’s get_messages action, and passed the ID to that method for it to use.

Routing and Request Handling
[ 86 ]
In the Message Controller, we used the same method to extract the ID from the request, 
and then used that ID to determine which messages from the messages array to display. 
Although this works fine for illustrating routing for these two users, the code is far from 
ready, even without a data store or real user data, but it does show how the parameters can 
be read and used.
Because most of the functionality in the controller will be replaced with our database and 
more precise data being passed around, we can overlook the incompleteness of the current 
controller actions, and begin looking at creating a URL that is better looking than http://
localhost/egotist/profile/index/2/ for finding a user profile by ID.
Creating friendly URLs using custom routes
Consider how nice it would be if our users could browse to a profile without putting ‘index’ 
in the action portion of the URI, like this: http://localhost/egotist/profile/2. This 
looks much more pleasing, and is more in line with what we would like our URLs to look like 
in web apps. It is in fact very easy to have Kohana use a route to remove the index action 
from the URI.
Routes not only make our URLs more pleasing and descriptive, but they make our application 
easier to maintain in the long run. We have more control over where our users are being 
directed from how the URL is constructed, without having to create controller actions 
designed to handle routing.
Time for action – Creating a Custom Route
So far, we have been using the default route that is in our application bootstrap. As our 
application grows, so will the number of available ‘starting points’ for our user’s requests. 
Not every controller, action, or parameter has to comply with the default route, and this 
gives us a lot of flexibility and freedom.
We can add a custom route to handle user’s profiles by adding it to our bootstrap.php 
file.
1.	 Open the bootstrap.php file located in application/
directory and modify the routes block so it looks like this:
/**
 * Set the routes. Each route must have a minimum of a name, a URI  
 * and a set of defaults for the URI.
 */
   
Route::set(‘profile’, ‘profile/<id>’)
   ->defaults(array(

Chapter 3
[ 87 ]
      ‘controller’ => ‘profile’,
      ‘action’     => ‘index’,
   ));
Route::set(‘default’, ‘(<controller>(/<action>(/<id>)))’)
   ->defaults(array(
      ‘controller’ => ‘welcome’,
      ‘action’     => ‘index’,
   ));
2.	 Now, we can view the profile pages without having to pass the index action in the 
URL. Open http://localhost/egotist/profile/2 in a browser; it should look 
like this:
3.	 Browsing to profiles with a more friendly URL is made possible through 
Kohana’s routes.

Routing and Request Handling
[ 88 ]
What just happened?
By setting routes using the Route::set static method, we are essentially creating filters 
that will be used to match requests with routes. We can name these routes; in this case 
we have one named default, and one named profile. Kohana uses the second parameter 
in the set() method to compare against the requested URI, and will call the first route 
that matches the request. Because it uses the first route that matches the request, it is 
very important when ordering route definitions. If we put the default route before the 
profile route, the profile route will never be used, as the default route would always 
match first.
Because it looks for a match, it does not use discretion when determining the right route 
for a request. So if we browse to http://localhost/egotist/profile/index/2, we 
will be directed to the default route, and get the same result. The default route may not be 
available for all the routes we create in the future, so create routes that are as explicit as we 
can for our needs.
Right now, our application assumes any data that is passed after a controller segment named 
‘profile’ must be the ID for which we are looking. In our current application setup, we only 
need digits. If a user passes data into the URL that is not numeric for the ID parameter, we 
do not want it to go to that route. This can be accomplished easily inside the Route::set() 
method.
Making routes explicit
Having routes that are properly defined means having routes that are explicit so they match 
only the request to which they are designed. Kohana::set() offers a third argument that 
accepts an array of URI segment keys and regular expression values. The URI segment keys 
are enclosed in angle brackets (<…>). The method then applies these regex filters to the 
segments when determining if there is a match.
Time for action – Adding regex to a route
Modifying our profile route with a regular expression will allow Kohana to send requests only 
to that route where the ID is a number.
Open our bootstrap.php file, located in application/directory, and modify the 
route’s set method for the profile route so it looks like this:
Route::set(‘profile’, ‘profile/<id>’, array(‘id’ => ‘[0-9]+’))
   ->defaults(array(
      ‘controller’ => ‘profile’,
      ‘action’     => ‘index’,
   ));

Chapter 3
[ 89 ]
What just happened?
The regular expression [0-9]+ will only match one or more numeric characters, no matter 
how long. This works fine for requiring that the route only match requests where the URI has 
‘profile’ in the first segment, and a numerical value in the second segment.
While this is great for finding a user by their ID, and the URL that a user would use to find the 
profile is nicer than it was before, it is still not as descriptive as it could be. It would be nice if 
the user’s name were also allowed to be passed into the path, even if the application had no 
use for it, it would add more description to the possible destination.
Allowing additional data in a URI
Apart from being easier to read and type, friendly URLs can also help to describe the 
content on the page for users and search engines. It is not uncommon to pass additional 
data in the route to better describe the page, even though it is optional and not used by 
the application itself.
Unfortunately, if we wanted to link to a profile with the user’s name appended to the URI, it 
would not find the route we have defined. If we linked to http://localhost/egotist/
profile/2/some-users-name, we would get an application error, as there is not a route 
that is defined that matches this scheme, and the default route will look for a method named 
action_2 in the profile controller, as defined in the default route in our bootstrap file.
Time for action – Allowing additional segments in a route
By making a simple modification to our profile route, we can match any URI that has the 
basic requirements for our route, and allow some optional data to be passed. Although 
we will ignore this data in our controllers, other places, like search engines, may find it 
very useful.
Open the bootstrap.php file located in application/directory and modify the 
route’s set method for the profile route so it looks like this:
Route::set(‘profile’, ‘profile/<id>(/<optional>)’, array(
      ‘id’ => ‘[0-9]+’, 
      ‘optional’ => ‘.*’)
   )->defaults(array(
      ‘controller’ => ‘profile’,
      ‘action’     => ‘index’,
   ));

Routing and Request Handling
[ 90 ]
What just happened?
By adding the third segment to our URI structure for the profile route, we are allowing 
additional data to be passed after the ID, and still match the route we are wanting. If you 
notice, we also added another regular expression  that will match any character, 0 or more 
times, to the third argument’s array, with a key referencing the new optional segment. 
Segments are defined as optional when they are enclosed in a set of parenthesis.
Without this regular expression, only one additional segment is allowed, but with the regex, 
we can now pass all the additional segments of data we wish, and still match this route. A 
quick glance at http://localhost/egotist/profile/2/some-user/more-data/
even-more-stuff still shows our profile page for user number 2:
Using subdirectories with routes
The controller directory can quickly become overrun with files, making an otherwise well-
organized project become cluttered and hard to navigate. Besides being able to set default 
controllers and actions for a route, we can also define the directory that a route’s controllers 
live in. This can make organizing our files much easier.

Chapter 3
[ 91 ]
Time for action – Using Subdirectories and Routes
We can assume there are going to be more than the five files in our classes/controller 
directory as our application grows. By organizing our controller classes in subdirectories, 
and then using our routes to define the location of our classes, we can better organize our 
application and prepare for future growth.
We can add a directory to our route, and then update our controller’s class declarations to 
better organize our files.
1.	 Open the bootstrap.php file located in application/directory, and 
modify our profile route so it looks like this, adding the user-messages 
route below our profile route:
Route::set(‘profile’, ‘profile/<id>(/<optional>)’, array(
      ‹id› => ‹[0-9]+›, 
      ‹optional› => ‹.*›))
   ->defaults(array(
      ‘   directory’ => ‘user’,
      ‘controller’ => ‘profile’,
     ‹action›     => ‹index›,
   ));
   
Route::set(‘user-messages’, ‘messages/<action>/<id>(/<optional>)’, 
array(
      ‘id’ => ‘[0-9]+’, 
      ‘optional’ => ‘.*’))
   ->defaults(array(
       ‘directory’ => ‘user’,
      ‘controller’ => ‘messages’,
      ‘action’     => ‘index’,
   ));
2.	 Next, we will need to create the user subdirectory inside our application/
classes/controller/ directory.
3.	 Inside our new application/classes/controller/user directory, move 
the Profile Controller  inside of it, and change its class declaration to match 
its new location:
class Controller_User_Profile extends Controller_Application 

Routing and Request Handling
[ 92 ]
4.	 Inside the new application/classes/controller/user directory, move 
the Messages Controller  inside of it, and change its class declaration to match 
it’s new location:
class Controller_User_Messages extends Controller {
5.	 A quick reload of http://localhost/egotist/profile/2/some-
user shows everything is working fine, as nothing has changed.
What just happened?
Inside our route named ‘profile’, we added an additional array key for directory in the 
defaults array settings, and assigned it the value of ‘user’. This tells Kohana that the 
controllers for this route will need to be located inside a classes/controller/user 
directory, and will need to start with the class name Controller_User, based on the 
framework’s naming conventions for controllers.
We also had to create an additional route for our Messages Controller, since it serves users 
also, it makes sense to move it into this subdirectory also. Now, when the request for messages 
is made inside the Profile Controller, Kohana will know to find it in the user subdirectory.
After moving our Profile and Messages Controllers inside a subdirectory named user, we 
had to open the files and change their class names to include their path, changing the 
Controller_ prefix to Controller_User.
Now, whenever a request has a URI with a first segment of profile or messages, Kohana will 
attempt to match it to one of our custom routes.
Pop quiz – Understanding Routes and the Kohana Filesystem
1.	 The Route::set method is used to create filters for the request with which to be 
matched. The method takes three arguments. In what order are they accepted?
a.	 Route Name, URI, Array of Regular Expressions
b.	 Array of Regular Expressions, URI, Route Name
c.	
URI, Array of Regular Expressions, Route Name
d.	 Route Name, Array of Regular Expressions, URI
2.	 Kohana’s cascading filesystem has three layers that it merges together when 
processing a request. What order are these layers merged in order of importance?
a.	 Modules, System, Application
b.	 Application, System, Modules
c.	
Application, Modules, System
d.	 System, Modules, Application

Chapter 3
[ 93 ]
3.	 When adding routes to your application layer, they need to be created using the 
Kohana::set() method and should be located inside which file?
a.	
index.php
b.	 application/bootstrap.php
c.	
application/classes/init.php
d.	 application/views/template.php
Summary
Kohana’s request flow and routing is one of the fundamental aspects of the framework, and 
is very important to understand as you move forward as a Kohana developer. By creating and 
using some custom routes, you were able to see how real world scenarios can be handled 
gracefully by Kohana.
You were also able to add to the case study site to see exactly how these principles are 
related to executable code. Even though most of the code added in this chapter was example 
data, when it comes time to adding information from the database, you will have the 
understanding necessary to manipulate the routes and requests to properly use that data.
After this chapter, you should have a firm grasp on creating, using, and now requesting 
Kohana’s Controller classes.
In the next chapter, we will look at some of the helper and service-oriented classes provided 
in Kohana and take a look at extending their functionality, and creating a few of our own.


4
Working with Helpers and Classes
In this chapter, we will learn to utilize Kohana's helper classes to make our code faster to 
write and easier to use. By using some of the more commonly used classes, our application 
will be easier to read and maintain.
In this chapter, we will learn:


Autoloading classes In Kohana


An overview of helpers


Working with dates and times using the Date helper


Rendering and filtering HTML with the HTML, Inflector, and Form classes


How to keep things secure using the Encrypt and Cookie classes


Using the Arr helper to manipulate arrays


How to create and parse RSS feeds in one line


How to extend the core helper classes, and how to create your own
In previous versions of Kohana, and in some other MVC frameworks like CodeIgniter, 
helpers are defined classes that have their own directory. Now, helpers are treated as first 
class citizens, and can be thought of as service classes, implementing design patterns to 
make code more reusable. In this chapter, we will get familiar with some of the helper 
methods that come included with the framework, learn how to extend core classes to add 
functionality, and how to create our own helpers for our projects.

Working with Helpers and Classes
[ 96 ]
Autoloading classes
By using the autoloading capability of PHP5, we are no longer required to list all the 
include() and require() statements that are necessary in older applications. Kohana 
uses the __autoload() magic method along with the cascading filesystem to create an 
easy means for loading classes.
In our bootstrap file (application/bootstrap.php), we can see the following line of code:
spl_autoload_register(array('Kohana', 'auto_load'));
This registers the Kohana::auto_load() method as the default autoloader for our 
application. We can create custom autoloaders; however, for most projects this will not 
be necessary.
When a class is called that we have not loaded already, this autoload method will be 
invoked. On a high level, Kohana::auto_load() is a fairly simple method that applies 
the filesystem rules to the class being loaded. In short, the underscores are converted to 
slashes, the string is converted to lowercase, and the file is searched for in the classes/ 
sub-directory of Kohana's cascading filesystem.
Because of the cascading filesystem, this makes inheritance very easy, and therefore 
extending the functionality of the framework becomes transparent. When we begin to cover 
extending the core functionality of Kohana we will not be required to load the parent classes, 
manually instead we will simply call them in our class declaration and move on.
Introducing helpers
In previous versions of Kohana, and in other MVC frameworks like CodeIgniter, helpers are 
separated from other library code, and are given their own directory in the filesystem. There 
is no longer a restriction on where these classes live or are called, and they are auto-loaded 
just like any other class in Kohana. We will refer to methods that provide the functionality of 
helpers in the traditional method, being formatting and providing additional functionality to 
standard features, as helpers in this chapter.
Unlike module code, and other library code, helpers are classes that contain static methods 
(in most cases). Without having to create instances of each class, they become very easy to 
implement and 'help' us do common tasks like formatting or performing tasks that live in a 
more global namespace.

Chapter 4
[ 97 ]
Most helper classes contain several methods that all share a common theme. In the user 
guide's API Browser, there are many classes listed, and a majority of them are there to assist, 
or help, us with our tasks. Each class has several methods, all dedicated to working with 
something associated with the class' name. For instance, the Date Class has many methods 
that are designed to work with dates and time.
There are a few helper classes that are commonly used in many applications, and we will 
take a look at how to use these more common classes in more detail.
The Date class
Working with dates and times in PHP can be difficult, despite all the native functions and 
classes that are included with the language. Some common tasks web developers face every 
day are listing years for select boxes, finding the range between two dates or times, and 
manipulating information based on time zones. Kohana's Date Class provides many methods 
to help us when manipulating dates and times in our applications.
A common task is having to list the number of days in a particular month. Determining how 
many days are going to be in February of 2019 could take several lines of code, but Kohana 
makes it easy:
$days = Date::days(2, 2019);
The above code will create an array in $days with 28 values, looking like this:
Array ( [1] => 1 [2] => 2 [3] => 3 [4] => 4 [5] => 5 [6] => 6 [7] => 7 
[8] => 8 [9] => 9 [10] => 10 [11] => 11 [12] => 12 [13] => 13 [14] => 
14 [15] => 15 [16] => 16 [17] => 17 [18] => 18 [19] => 19 [20] => 20 
[21] => 21 [22] => 22 [23] => 23 [24] => 24 [25] => 25 [26] => 26 [27] 
=> 27 [28] => 28 )
We can then use this to create a select box for date selection, or count the array for number 
of days, and move on, not having to write functionality to do the hard work for us. The 
months(), years(), seconds(), hours(), and minutes() methods all work in a similar 
fashion, and each contain additional options that can be found in the userguide.
The first conversion method in the Date Class is a function to convert 12-hour formatted time 
into a 24-hour format. The Date::adjust() method accepts two parameters, the first is 
the hour as an integer, and the second is a string that accepts 'am' or 'pm'. Let's take a look:
<?php echo Date::adjust(8, 'pm'); // Prints "20" ?>
The ampm() method simply determines whether a 24-hour-based time is AM or PM in a 
12-hour format:
<?php echo Date::ampm(13); // Prints 'PM' ?>
<?php echo Date::ampm(3); // Prints 'AM' ?>

Working with Helpers and Classes
[ 98 ]
Social networking sites have made 'fuzzy' time stamps very popular. Instead of displaying 
the exact time and date for new messages, they commonly use timestamps that are more 
human readable, like "3 minutes ago" or "moments ago". Kohana makes it very easy to use 
this in our applications:
<?php echo Date::fuzzy_span(time() – 5); // Prints "moments ago" ?> 
<?php echo Date::fuzzy_span(time() – 500); // Prints "a few minutes 
ago" ?> 
<?php echo Date::fuzzy_span(time() – 5000); // Prints "a couple of 
hours ago" ?> 
And so on. For a complete list of all the possible output text options, take a look at the code 
in /system/classes/kohana/date.php in the fuzzy_span() method. The method has 
a long list of if..elseif blocks that sets the return text.
The Date class has a few other methods at which you may want to take a look. Like all of the 
helper methods, you are encouraged to look in the API Browser at the available methods, 
and take a look at the source code.
Have a go hero – Customizing fuzzy date text
You may create applications in the future that will use the fuzzy dates, but decide that you do 
not want to use the text that is currently used in the framework. Because you want to keep 
the rest of the functionality of the Date class, you decide to override the fuzzy_span() 
function by extending the Date class inside your application. Based on what you learned in 
the last chapter, how would you create your custom messages while preserving the rest of 
the Date class's functionality, without altering any code in the /system/ directory?
The HTML Class
The HTML class provides a programmatic syntax for rendering and converting HTML 
elements. These helper methods can be very useful when we are passing data into form 
elements, and would rather have a nice interface in the place of heavy concatenation. 
Most of the standard HTML elements are represented.
There are a few methods designed specifically for converting strings for use in HTML. 
These methods are often used in conjunction with other code; however, they can be 
used standalone also.

Chapter 4
[ 99 ]
The HTML::chars() method
Converting user-generated content into HTML entities is a good defence against cross-site 
scripting (XSS) vulnerabilities. This method runs PHP's htmlspecialchars() function on 
the passed value with ENT_QUOTES, the configured character set, and sets double-encode 
to true.
<?php echo HTML::chars('<script type="javascript">alert("xss");</
script>'); ?> 
By passing the above JavaScript through the HTML::chars() method, the HTML output will 
look like this:
&lt;script type=&quot;javascript&quot;&gt;alert(&quot;xss&quot;);&lt;/
script&gt;
This will print the above text, but will not execute the script. Any time untrusted data is to 
be displayed in an application, we should always run the HTML::chars() method. This 
includes any data that has been input by a user.
The HTML::obfuscate() method
Sometimes, we want to display text in HTML, but we do not want the output to be easily 
read by scripts, like spiders and crawlers. This is often used for SPAM prevention. One 
method for accomplishing this is to obfuscate the text using HTML entities and Hex character 
encoding:
<?php echo HTML::obfuscate('Some Member Name'); ?>
The above code will output something like this:
&#83;&#x6f;m&#x65;&#x20;&#x4d;e&#109;b&#x65;r&#x20;&#78;&#97;&#109;e
One of the most common items that we obfuscate as developers are email addresses, and 
Kohana has a method especially for email obfuscation.
The HTML::email() method
This method allows us to easily pass an email address and get back a randomly generated 
string that will read as an email, but prove more difficult for data miners.
<?php echo HTML::email('someone@somewhere.com'); ?> 
The above code will output something similar to this:
&#115;o&#109;&#101;on&#101;&#64;&#115;&#111;mewh&#x65;&#x72;&#x65;.&#
x63;om

Working with Helpers and Classes
[ 100 ]
This will be read by the browser and displayed as readable text, but will be obfuscated in the 
source. In other words, our user will see "someone@somewhere.com" but when we view 
source, the HTML entities and Hexadecimal character encoded string will be in it's place. If a 
crawler were searching for email addresses, it would come up empty handed.
Because the HTML::obfuscate()and HTML::email() methods randomly determine 
which characters are encoded, and what way they are encoded, the complexity for 
accurately scraping our pages becomes a bit higher.
The rest of the HTML class' helper methods deal with the rendering of elements. They 
provide a more elegant solution to concatenating long strings in our views to create HTML. 
These can also be used in our application code, making it possible to incorporate rendered 
elements into a view variable for output in the presentation layer.
The HTML::anchor() method
The anchor tag is used in virtually every web application. To create an anchor using the 
HTML class, we can simply do this:
<?php echo HTML::anchor('/welcome', 'Welcome Page'); ?>
If added into our case study site, this would create the following HTML:
<a href="http://localhost/egotist/welcome">Welcome Page</a>
The first parameter of HTML::anchor() is the URL for the link, the second an optional title, 
and the third allows for attributes to be assigned to the element. If no title is passed, the 
link will be used in its place. There is also an optional fourth parameter that will accept the 
protocol for the link.
To pass attributes to the element, we can do something like this:
<?php echo HTML::anchor('/welcome', 'Welcome Page', array(
   'class' => 'foobar'
)); ?>
This would output:
<a href="http://localhost/egotist/welcome" class="foobar">Welcome 
Page</a>
The HTML helper has a very similar method to anchor() named file_anchor(). The only 
difference between these two methods is file_anchor() will use the basename(), or file 
name, of the file as the default link title.

Chapter 4
[ 101 ]
The HTML::image() method
Next to links, images are another very common element in web applications. The 
HTML::image() method returns a rendered img element. There are three parameters: 
the first is the file location, the second is an array of attributes, and the last is a tool that 
determines whether the index file should be prepended to the URL if a relative path is 
provided. The last two parameters are optional.
  <?php echo HTML::image('link/to/file.png', array('alt' => 'Alt 
Text')); ?>
The above code will output this HTML:
<img src="http://localhost/egotist/link/to/file.png" alt="Alt Text" />
The image(), script(), and style() methods all work exactly the same, with the latter 
two creating <script> and <style> elements with attributes.
The HTML::mailto() method
The HTML::mailto() helper is only slightly different, in that it takes an email address as 
the first parameter, then an optional title and attributes.
<?php echo HTML::mailto('someone@somewhere.com', 'Email Someone', 
array('class' => 'email_addy')); ?>
The above code will return something like this:
<a href="&#109;&#097;&#105;&#108;&#116;&#111;&#058;&#x73;o&#109;e&#x6
f;&#110;&#x65;&#64;&#115;&#111;&#x6d;&#x65;w&#x68;&#101;r&#x65;&#x2e
;c&#111;&#109;" class="email_addy">Email Someone</a>
This method simply runs the HTML::email() method and then wraps the result in a 
mailto: link. Again, because the obfuscation method is random, your results may vary 
slightly in the obfuscated portion of the email address.
The Inflector Class
Manipulating words as strings is the focus of the inflector class. This can come in handy 
when calling methods programmatically; changing a string from singular to plural for 
multiple reasons (say to get a database name from an object name), and to convert dashed, 
underscored, and camelized text to a human readable form.
Changing text from almost any form to camel case can be accomplished with 
Inflector::camelize():
<?php echo Inflector::camelize('foo bar baz'); // Returns: fooBarBaz 
?> 

Working with Helpers and Classes
[ 102 ]
The decamelize() method takes camelized text and returns as normal text with spaces:
<?php echo Inflector::decamelize('fooBarBaz'); // Returns: foo bar baz 
?>
The underscore() method is similar to camelize, but instead of creating camel case, it 
creates underscored text:
<?php echo Inflector::underscore('narwhals are real'); // Returns: 
narwhals_are_real ?>
The humanize() method takes dashed or underscored text, and turns it into human 
friendly text:
<?php echo Inflector::humanize('narwhals_are_real'); // Returns: 
narwhals are real ?> 
<?php echo Inflector::humanize('bacon-tastes-good'); // Returns: bacon 
tastes good ?>
Although changing text to make it easy for programming is nice, being able to change text for 
human consumption is even nicer. The amount of intelligence needed to change words that 
can be read by humans is much higher than simply manipulating spaces, underscores, and 
dashes.
To change words from plural to singular, simply pass them into the 
Inflector::singular() method:
<?php echo Inflector::singular('narwhals'); // Returns: narwhal ?>
<?php echo Inflector::singular('patience'); // Returns: patience ?>
If the text is already singular, or is uncountable, it will remain unchanged. The opposing 
method to singular() is plural():
<?php echo Inflector::plural('narwhal'); // Returns: narwhals ?>
<?php echo Inflector::plural('patience'); // Returns: patience ?>
As we can see, patience did not change. This is because it is considered 'uncountable' in 
that there is no 'patiences'; the plural of patience is patience.
To determine whether a word is uncountable, Kohana provides the 
Inflector::uncountable() method:
<?php echo Inflector::uncountable('narwhal'); // Returns: FALSE ?>
<?php echo Inflector::uncountable('patience'); // Returns: TRUE ?>
The list of uncountable words can be found in /system/config/inflector.php. In this 
file there is an array of uncountable words, and an array of irregular words.

Chapter 4
[ 103 ]
The URL class
Working with URLs can be tricky business. There are issues with characters, character types, 
paths, and protocols. These can all combine to create many headaches when developing web 
applications, however, the URL class makes many of these chores easy to accomplish with 
very little code.
A common task for developers is to create URL friendly slugs to insert into URLs, and like any 
good helper, the URL class makes this simple. The next three methods in the URL class are 
designed to create URLs and query strings.
The URL::title() method
The URL::title() method is great for creating slugs from page titles, and then including 
the slug in links to the page. Even if the slug is not used for database retrieval or any other 
purpose, it helps make the URL more readable, lets users see the title in the URL, and most 
importantly, it is great for search engine optimization.
<?php echo URL::title('Narwhals are real - "Breaking News"'); // 
Prints: narwhals-are-real-breaking-news ?>
The URL::title() method first appears like it should be a member of the HTML class. 
Upon further inspection, we will notice this method takes text conversion another step by 
ensuring the rendered result is safe for inclusion in a URL.
When we set up our application's bootstrap file, we set the base URL that Kohana will use 
when creating a new URL.
The URL::base() method
The URL::base() method is used to create the base URL for our application. By using this 
method, any time we need to update our base URL site wide, we only need to change it in 
our bootstrap file.
<?php echo URL::base(); //Returns http://localhost/egotist/ (in case 
study app) ?>
The URL::base() method accepts two optional parameters: the first is a bool to include 
the index file, and the second is the protocol we want to use when rendering the URL. In the 
case study site, egotist, we set the index file configuration as an empty string, so there will 
be nothing to pass. Sometimes URL redirection is not available, and including index.php in 
URLs may be unavoidable. If we need to pass a file as our front controller, we could do so in 
the first parameter.
<?php echo URL::base(FALSE, 'https'); // Prints: https://localhost/
egotist/ ?>

Working with Helpers and Classes
[ 104 ]
By passing https in the second parameter, the protocol for the URL is set. This is great to 
use on links we know need to go to secure pages.
Building on the functionality of the URL::base() method is URL::site(). This method 
accepts a URI as a string and the desired protocol. Left empty, it will return the same value as 
URL::base().
<?php
echo URL::site('foo/bar/baz'); 
// Prints: http://localhost/egotist/foo/bar/baz
echo URL::site('foo/bar/baz', 'https'); 
// Prints: https://localhost/egotist/foo/bar/baz
echo URL::site(); 
// Prints: http://localhost/egotist/
?>
The last helper method in the URL class is used to help create query strings for our URLs.
The URL::query() method
This method builds a GET query string that is ready to be attached to any URL.
<?php echo URL::query(array('page' => 12, 'keyword' => 'narwal')); ?>
The above code will return:
?page=12&keyword=narwhal
This is very helpful when creating URLs or links where a GET method is used to generate 
page information. In one line, we can either create or pass an array into the method, and get 
a properly formatted, URL safe query string in return. If you want to reuse or overwrite the 
current query string values, simply set the second parameter of the URL::query() method 
to true.
The URL class is short and sweet, but it is probably the most used helper in a Kohana 
application. If we use URL::base() and URL::site() for every link you create and 
resource we load, our programs will be easier to maintain; using URL::title() and 
URL::query() will make our URLs safe, friendly, and dynamic.
The Arr (Array) Class
This helper adds additional array helpers that PHP does not have. Although it is relatively 
easy to accomplish many tasks using PHP's native array functions, the Arr class provides 
some very useful additions that have good use cases in web applications.

Chapter 4
[ 105 ]
It is very common for developers to set a default value for a variable, and then determine 
whether the variable was set via $_GET or $_POST (or other methods), and then replace 
the default value with a new one.
The Arr::get() method
The Arr::get() method gets the value for a single array key from a specified array, and if 
that key does not exist, it will use the default value. This method accepts three parameters: 
the first is the array being searched, the second is the key that is being retrieved, and the last 
is an optional default value. If no default value is given, then NULL is used.
A good use case for Arr::get() would be setting data that could be entered by a user via 
a form. We could create a variable based on the input from a POST request, and if none is 
given, set the variable to null. This will prevent PHP warnings is no value is set.
<?php $middle_name = Arr::get($_POST, 'middle_name'); ?> 
Alternatively, we could use this method to set the default value if the key does not exist. A 
common use case for this may be to have the page passed as a GET parameter in the URL, 
and if none is given to default to page 1.
<?php $page = Arr::get($_GET, 'page', 1); ?>
This method saves a few lines of code every time a value is needed from an array, and if 
none is given, to have an elegant way to handle default values.
The Arr::extract() method
The extract() method does the same thing as get(), but extract() accepts multiple 
keys to be retrieved from the haystack.
<?php $page_info = Arr::extract($_GET, array('page', 'slug'), 'Not 
Set'); ?>
This line of code would assign a new array to $page_info that contains two keys: 'page' 
and 'slug'. If the $_GET array contains these keys, they will be set the values from the 
$_GET array, otherwise they will be the defaults value in the third parameter. If no defaults 
were given, NULL would be assigned in its place.
The Arr::pluck() method
To get the values from a key from multiple arrays can be accomplished with the 
Arr::pluck() method. This accepts a list of arrays (an array of arrays) and then searches 
each of them for a key, and returns an array of all the values. To conceptualize this, look at 
the following example:
<?php

Working with Helpers and Classes
[ 106 ]
$array_1 = array(
   'first_name' => 'Joe', 
   'last_name' => 'User'
);
$array_2 = array(
   'first_name' => 'Jason', 
   'last_name' => 'Straughan'
);
$array_3 = array(
   'first_name' => 'Ken', 
   'last_name' => 'Jones'
);
$arrayList = array($array_1, $array_2, $array_3);
$first_names = Arr::pluck($arrayList, 'first_name');
?>
This will create an array $first_names containing three values: 'Joe', 'Jason', and 
'Ken'.
This is a very helpful method to use when we need to merge several arrays and get similar 
data from each.
The Arr::merge() method
Speaking of merging arrays, the Arr::merge() method does exactly that. Anytime we 
need to combine two or more arrays into a single array, merge() is ready. When using 
Arr::merge() there are a few factors of which we need to be aware. First, associative 
arrays are merged recursively. Secondly, associative values are replaced and new ones are 
preserved if none exists. The nice thing about this method is that all keys are maintained.
<?php
$array_1 = array(
   'id' => 1,
   'favorite_foods' => array(
      'bacon', 'cheeseburgers', 'pizza'
   )
);
$array_2 = array(
   'id' => 2,
   'favorite_foods' => array(
      'bacon', 'narwhal stew'
   )
);

Chapter 4
[ 107 ]
$merged = Arr::merge($array_1, $array_2);
?>
A var_dump() of $merged yields the following:
array(2) { 
   ["id"]=> int(2) ["favorite_foods"]=> 
      array(4) { 
   [0]=> string(5) "bacon" 
         [1]=> string(13) "cheeseburgers" 
         [2]=> string(5) "pizza" 
         [3]=> string(12) "narwhal stew" 
      }
 }
As we can see, the 'id' key now has the value from the second array, but the 'favorite_
foods' array now contains a merge of both arrays with no duplicates. This can be used when 
combing an array of default values with a set of optional values, among other things.
The Arr::overwrite() method
If we would like to merge two arrays, overwriting the values from one array with the other's, 
there is another method to handle that. The Arr::overwrite() method accepts two 
arrays, and replaces any values present in the first array with the values from the second. 
The main difference between this and Arr::merge() is Arr::overwrite() does not add 
keys from the second array that do not exist in the first.
<?php
$defaults = array(
   'page' => '1',
   'keywords' => null,
   'sort_order' => 'asc',
   'order_by' => 'name'
   
);
$new_values = array(
   'page' => '12',
   'keywords' => 'narwal, bacon',
   'order_by' => 'rank',
   'username' => 'jdstraughan'
);
$values = Arr::overwrite($defaults, $new_values);
?>

Working with Helpers and Classes
[ 108 ]
This will create an array assigned to $values that contains the following data:
array(4) { 
   ["page"]=> string(2) "12" 
   ["keywords"]=> string(13) "narwhal, bacon" 
   ["sort_order"]=> string(3) "asc" 
   ["order_by"]=> string(4) "rank" 
}
Here, the $new_values are replacing the values for any keys that are present in the 
$defaults array. This is a good use case we may use in many applications, where our 
class has default properties and based on GET, POST, or route input these values must be 
overwritten. Also, notice that the 'username' key was not added to the $values array. This 
key is not present in the first array, and is therefore not included in the new array.
The Arr::flatten() method
We can also convert multidimensional arrays to single-dimensional arrays in one line using 
the Arr::flatten() method.
<?php
$multi = array(
   'id' => 1,
   'favorite_foods' => array(
      'bacon', 'cheeseburgers', 'pizza'
   )
);
$flat = Arr::flatten($multi);
?>
This will create an array assigned to $flat that looks like this:
array(4) { 
   ["id"]=> int(1) 
   [0]=> string(5) "bacon" 
   [1]=> string(13) "cheeseburgers" 
   [2]=> string(5) "pizza" 
}
The flatten() method will preserve associative keys, and create indexed keys for non-
associative values. In this case, ID was preserved and the values for favorite_foods were 
assigned indexed keys.

Chapter 4
[ 109 ]
The Arr::unshift() method
PHP has a great array function named array_unshift() that prepends a new value to an 
array. This can be very handy when we need to add some information to the beginning of 
an array.
Arr::unshift() provides us with some improved functionality in that we can specify the 
key and the value to be prepended to the array. If the key exists, it will be replaced by the 
new value, and the size of the array will remain the same. To use Arr::unshift(), pass 
the array we are unshifting as the first parameter, the key as the second, and the value as 
the third.
<?php
$user = array(
   'first_name' => 'Jason', 
   'last_name' => 'Straughan',
   'username' => 'jdstraughan'
);
$user = Arr::unshift($user, 'id', 42);
?>
The $values variable will now contain the following array:
array(4) { 
   ["id"]=> int(42) 
   ["first_name"]=> string(5) "Jason" 
   ["last_name"]=> string(9) "Straughan" 
   ["username"]=> string(11) "jdstraughan" 
}
Here, we can see that the 'id' key is added to the beginning of the array.
$user['id'] = 42;
The above code would add the key/value pair to the end of the array natively.
The Arr::map() method
Anther example of a PHP function with similar functionality in Kohana is array_map(). This 
function in PHP allows us to run a callback function against an array's elements and returns 
an array of the results. The Arr::map() function is similar, but it runs the callback function 
recursively; unlike array_map(), it only will run against one array.
<?php
$user = array(
   'id' => 42,

Working with Helpers and Classes
[ 110 ]
   'userinfo' => array(
      'first_name' => 'Jason', 
      'last_name' => 'Straughan',
      'username' => 'jdstraughan'
   )
);
$big_user = Arr::map('strtoupper', $user);
?>
This will create an array $big_user with all values being passed through strtoupper().
array(2) { 
   ["id"]=> string(2) "42" 
   ["userinfo"]=> array(3) { 
      ["first_name"]=> string(5) "JASON" 
      ["last_name"]=> string(9) "STRAUGHAN" 
      ["username"]=> string(11) "JDSTRAUGHAN" 
   } 
}
The Arr::is_array() method
Another great method in the Arr class is the is_array() method. The Arr::is_array() 
method takes PHP's is_array() method a step further, and checks if the variable in 
question is an array or is an object that implements PHP's Traversable interface. Although 
the latter is not actually an array, it behaves very much in the same way.
<?php Arr::is_array(array()); // TRUE ?>
<?php Arr::is_array(new ArrayObject); // TRUE ?>
<?php is_array(new ArrayObject); //FALSE ?>
Not only can we check if a variable contains an array, with the is_assoc() method, we can 
see if it is an associative array.
<?php echo Arr::is_assoc(array('page' => 12, 'keyword' => 'narwhal')); 
// TRUE ?>
<?php echo Arr::is_assoc(array('page', 'keyword')); // FALSE ?>
The Arr::range() method
The last Array function we are going to cover is the Arr:range() method. This function 
simply creates an array of a range of numbers, and can be used for creating test data, select 
boxes, or any time we need an array full of an ordered set of numbers. The first parameter 
is the increment, or step, that should be applied, and the second is for the maximum value 
of the range. The increment must be greater than zero, and it will also be the first number in 
the range.

Chapter 4
[ 111 ]
<?php $range = Arr::range(1, 10); ?>
The above code will create an array with the following elements:
array(10) { [1]=> int(1) [2]=> int(2) [3]=> int(3) [4]=> int(4) [5]=> 
int(5) [6]=> int(6) [7]=> int(7) [8]=> int(8) [9]=> int(9) [10]=> 
int(10) }
Here we see it starting at 1, and increasing through 10. To count by twos, simple change the 
first value:
<?php $range = Arr::range(2, 10); ?>
Now, we can see that the range starts with 2, and contains all the even numbers through 10:
array(5) { [2]=> int(2) [4]=> int(4) [6]=> int(6) [8]=> int(8) [10]=> 
int(10) }
As we can see, the Arr class is a nice addition to the functionality inherent in PHP. As far 
as helper classes in Kohana go, Array is one of the most powerful. Proper usage of these 
methods can save hours of programming, and leave us with more time to write great 
applications.
The Cookie class
Working with cookies just got a lot safer, and a lot easier. The Cookie method is short and 
sweet, and makes working with cookies fun again.
Tampering with cookies is an all-time favorite pastime for most hackers and can present 
several security risks to our application. To help prevent attacks on our sites, encrypting 
our cookies and validating their contents is critical.
By using Kohana's Cookie class to set and retrieve our cookies, we have access to one-line 
commands that handle all the encryption and validation intuitively, without even having to 
think about it.
The Cookie::set() method is very straightforward. The first parameter is the name of 
the cookie, the second is the value, and the third, optional, parameter is the expiration 
in seconds. It should be noted here that PHP's setcookie() function accepts a UNIX 
timestamp, where the Cookie::set() method accepts the cookie's lifetime in seconds:
<?php Cookie::set('username', 'jdstraughan'); ?>
The above code will create a new cookie with the name 'username' and a value that has 
an encrypted signature prepended to the value. This way, if the value is manipulated, the 
signature will not match and Kohana will not allow the value to be retrieved via the Cookie 
class.

Working with Helpers and Classes
[ 112 ]
Printing out the contents of the $_COOKIE global variable's value for our username cookie 
will reveal the contents of the cookie:
84330a7f8b2fc797f215979f83ad38b4dbe81f53~jdstraughan
If someone were to alter the jdstraughan portion of the cookie, it would not pass the 
validation in Cookie::get(), and, by default, NULL would be returned in place of the 
altered data. We should always use the Cookie::get() method to retrieve any cookies we 
have created:
<?php $username = Cookie::get('username'); ?>
This will check the signature of the cookie to verify its authenticity, and then return the value 
as a string. The $username variable would now contain 'jdstraughan'. There is a second, 
optional parameter that will set a default value in the case that the key did not exist or does 
not pass validation.
Deleting a cookie is at minimum a two-step process in PHP. First, we need to remove the 
cookie's name and value from the global $_COOKIE variable, and then we need to set the 
cookie's value to NULL, and expire the cookie by setting the expiration value to a time in the 
past. This can be a lot to remember, and is not fun to have to type every time we want to 
remove a cookie.
Using the Cookie::delete() method turns this into a one step process:
<?php Cookie::delete('username'); ?>
This removes the cookie, expires it, and allows us to move on without having to go back and 
make sure we expired our cookie properly and deleted it from the $_COOKIE super variable.
The Encrypt (Encryption) Class
While we are on the topic of security, it is worth looking into the encryption helper. It is 
considered a best practice to protect our users against the possible loss of data, and not have 
that data human readable outside of the application. A good example of this may be for the 
email addresses of our customers that are stored inside of a database.
Recently, a very large web application had their database compromised, and all the user data 
was displayed for the entire world to see. This included email addresses in plain text, and 
passwords that had antiquated encryption techniques that were easy to decrypt. The hackers 
were able to show the email addresses, usernames, and passwords in human readable text 
for everyone to see.

Chapter 4
[ 113 ]
This scenario would have been easily avoided if the company in question had used proper 
encryption techniques when storing their user's data. Kohana's Encrypt class uses MCRYPT 
(http://mcrypt.sourceforge.net/), an encryption library that allows multiple 
encryption techniques to be easily applied to data. Without spending years of our lives 
studying cryptography, we can safely store and retrieve data in a few lines of code.
Unlike most of the other helpers we have looked at, the Encrypt class relies on a 
configuration file to provide the information it needs to work.
Time for action – Creating configuration for Encryption
Let's add an encryption configuration to the Egotist application. Although we will not be 
using it directly in the app just yet, once the database is added we will want to be able to 
easily add some data that needs to be encrypted.
1.	 Create a new file in /application/config/ named encrypt.php.
Open /application/config/encrypt.php for editing and add the 
following code:
<?php echo defined('SYSPATH') or die('No direct script access.');
return array(
   'default' => array(
      'key' => 'narwhals-are-cool!42',
      'cipher' => MCRYPT_RIJNDAEL_128,
      'mode'   => MCRYPT_MODE_NOFB,
   ),
);
2.	 Save the modified application/config/encrypt.php file.
What just happened?
The Encrypt class has a constructor that sets up MCRYPT for us, and lets us know which 
cipher and mode to use, and what the unique key should be. Without this key, or password, 
the data cannot be decrypted.
The key in the above example, 'narwhals-are-cool!42' is required to extract any data 
that is encrypted via the Encrypt class. If we change the key, all data that is in the database 
will not be accessible for decryption, so it is important to keep this code safe, especially in 
production environments.
To see how this works, let's look at the methods we will use to create and extract 
encrypted data.

Working with Helpers and Classes
[ 114 ]
Encoding, like all the other helper methods, is a simple one liner:
<?php 
$encrypt = Encrypt::instance();
$email = $encrypt->encode('super.secret.person@example.com'); 
?>
Echoing out the contents of $email reveals an encrypted string:
h7XFHONz2TjFtzA5BJFXuKusD9ogCE0rwu5eXPuatqSz5nTxA909F8IWaNekOaE=
This value will be different in your environment.
Because of the design pattern used in Encrypt, we cannot call the helper methods statically. 
By creating an instance of the object, we can then call the method through the normal 
means. We can shorten the code to one line if we are not going to be using the object later 
in the same method, like this:
<?php $email = Encrypt::instance()->encode('super.secret.person@
example.com'); ?>
Because the Encrypt::instance() method returns an Encrypt object, we can chain 
methods for shorter code.
The complimentary method to encode() is decode(), and as you can guess, it uses the key 
to decrypt the data, returning the original information:
<?php 
$encrypt = Encrypt::instance();
$encrypted_email = $encrypt->encode('super.secret.person@example.
com'); 
$decrypted_email = $encrypt->decode($encrypted_email); 
echo $decrypted_email; 
?>
This simple script will encode an email address, just like we saw above, and then decode it 
and print the contents in plain text. We can see how simple it is to encode and decode data 
in just a few lines of code.
When we cover working with databases in Chapter 6, the encryption class will be used to 
store email addresses for our users. Whenever we are storing data that we think could pose 
a security risk, it is probably wise to encrypt it.

Chapter 4
[ 115 ]
The Feed Class
Almost every site on the web has an RSS or ATOM feed; it seems every client wants them, 
every site has them, and every developer has to make them. The Feed class gives us two 
methods to take care of RSS and ATOM feeds: one for creating a feed, and one for parsing 
them.
Without having to create XML renderers and parsers, import third-party libraries, and 
waste hours of time checking all the nuances between the different feed versions and 
their requirements, we can just let Kohana do the hard work.
To create a new RSS/ATOM feed, the Feed::create() method just needs the array of feed 
info (title, date created, pubDate, etc.) for the first parameter, an array of items for 
the second, and optionally, we can pass the format (rss2, atom, rss) as the third.
Let's take a quick look at how easy it is to create a RSS feed:
<?php 
$info = array(
   'title' => 'Test Feed'
);
$items = array(
   array(
      'title' => 'Test Feed Item One',
      'summay' => 'This is a test feed item...',
   'pubDate' => date('r', time())
   ),
   array(
      'title' => 'Test Feed Item Two',
      'summay' => 'This is a test feed item...',
      'pubDate' => date('r', time() - 2500)
   )
);
echo Feed::create($info, $items); 
This will output the following RSS2 feed:
<rss version="2.0"> 
  <channel> 
    <title>Test Feed</title> 
    <link>http://localhost/egotist/</link> 
    <generator>KohanaPHP</generator> 
    <item> 
      <title>Test Feed Item One</title> 
      <summay>This is a test feed item...</summay> 

Working with Helpers and Classes
[ 116 ]
      <pubDate>Tue, 14 Dec 2010 18:39:55 -0600</pubDate> 
    </item> 
    <item> 
      <title>Test Feed Item Two</title> 
      <summay>This is a test feed item...</summay> 
      <pubDate>Tue, 14 Dec 2010 17:58:15 -0600</pubDate> 
    </item> 
  </channel> 
</rss>
Okay, we see more data here than what we passed into the method. First of all, the feed is 
RSS version 2.0, but we did not specify a format. This is because the format will default to 
RSS 2.0 if no format is provided.
Once the database is in place for our case study site, we will be able to create the items array 
on the fly from our database. Here, we can see an example of an $info array with a title, 
and the $items array with some test news data. Once the arrays are created, with one line 
of code echoing the Feed::create() method, we will get the result.
Next, we see the link and generator elements have been added for us, defaulting to the 
current URL and KohanaPHP as the generator. To replace these, we can simply add them to 
our $info array like this:
$info = array(
   'title' => 'Test Feed',
   'link' => URL::site('some/link/location'),
   'generator' => 'Egotist Beta'
);
Notice anything? For the link value the URL helper is being used to create an absolute URL 
for the link to the feed location.
Now, the beginning of the output feed should look like this:
<rss version="2.0"> 
  <channel> 
    <title>Test Feed</title> 
    <link>http://localhost/egotist/some/link/location</link> 
    <generator>Egotist Beta</generator> 
    <item> 
      <title>Test Feed Item One</title> 
      <summay>This is a test feed item...</summay> 
      <pubDate>Tue, 14 Dec 2010 18:47:36 -0600</pubDate> 
    </item> 
    <item> 
      <title>Test Feed Item Two</title> 

Chapter 4
[ 117 ]
      <summay>This is a test feed item...</summay> 
      <pubDate>Tue, 14 Dec 2010 18:05:56 -0600</pubDate> 
    </item> 
  </channel> 
</rss>
As of version 3.0.10 of Kohana, formats other than RSS2 are not supported, although the 
documentation does claim they are. RSS 1.0, 2.0, and ATOM 1.0 should all be implemented 
at some point, according to the documentation available at this time.
Parsing a feed is even easier then creating one. We can now parse the feed we just created 
by adding the Feed::parse() method:
<?php 
$info = array(
   'title' => 'Test Feed',
   'link' => URL::site('some/link/location'),
   'generator' => 'Egotist Beta'
);
$items = array(
   array(
      'title' => 'Test Feed Item One',
     'summay' => 'This is a test feed item...',
     'pubDate' => date('r', time())
   ),
   array(
      'title' => 'Test Feed Item Two',
      'summay' => 'This is a test feed item...',
      'pubDate' => date('r', time() - 2500)
   )
);
$feed = Feed::create($info, $items, 'atom');
$parsed = Feed::parse($feed);
?>
Now the feed is being created, and stored as a string in $feed. This could be any RSS feed 
from anywhere on the Web. The $parsed variable will now hold an associative array of 
items, looking like this:
array(2) {
  [0]=>
  array(3) {
    ["title"]=>
    string(18) "Test Feed Item One"

Working with Helpers and Classes
[ 118 ]
    ["summay"]=>
    string(27) "This is a test feed item..."
    ["pubDate"]=>
    string(31) "Tue, 14 Dec 2010 19:04:01 -0600"
  }
  [1]=>
  array(3) {
    ["title"]=>
    string(18) "Test Feed Item Two"
    ["summay"]=>
    string(27) "This is a test feed item..."
    ["pubDate"]=>
    string(31) "Tue, 14 Dec 2010 18:22:21 -0600"
  }
}
The Feed::parse() method accepts an optional second parameter that will limit the 
number of items parsed and returned. If our feed had 50 items, for example, and we only 
wanted the first five, we could simply do this:
<?php Feed::parse('http://www.example.com/feed.rss', 5); ?>
And we would get back an array consisting of no more than 5 items.
The Form Class
Creating forms are probably not most web developer's favorite jobs. We have all created 
many different forms, validated them, rendered them, written the markup, and so on. 
Finding a programmatic means for rendering form elements is indeed a nice feature.
Not only does this make more complex tasks like dynamically rendering forms easier, it 
makes just having to create forms in general easier. Let's take a look at a few of the helper 
methods, and then create a login form and message submission form for our case study site.
To start any form, we need the opening form tag. The Form::open() method renders the 
tag and will by default use its current location for the action, and will default the method to 
'post' and the accept-charset attribute to 'utf-8'.
<?php echo Form::open(); ?>
will render:
<form action="http://localhost/egotist/" method="post" accept-
charset="utf-8">

Chapter 4
[ 119 ]
Because we did not specify an action, the Form::open() method sets the action URL to the 
current page. By specifiying the action in the first parameter and an array of attributes in 
the second, we can customize our form's opening tag as needed. For example:
<?php echo Form::open(URL::site('form/submit-to-page'), array(
   'enctype' => 'multipart/form-data',
   'class' => 'form1'
)); ?>
Will render the following:
<form action="http://localhost/egotist/form/submit-to-page" 
method="post" accept-charset="utf-8" class="form1" enctype="multipart/
form-data">
Once we have a form open, it makes perfect sense that we may want to close it. 
Form::close() is a convenient way to keep our code looking uniform, and it simply 
returns </form>.
Many of the standard form elements all have the same API for rendering their respective 
elements. Form::input(), button(), hidden(), password(), and submit() all 
basically do the same thing. They all render the form element after which they are named 
and they all accept three identical parameters.
The first parameter for all three is the name of the element as a string. The second is the 
value for the element, and the third is an array of attributes that will be rendered like we 
saw above. In some of the helpers the second parameter is optional, but the third is optional 
in all of them.
The <label> tag is associated to form elements, and is often rendered along with form 
elements when we are creating a form. The Form::label() method accepts the name 
of the field it is associated with as the first parameter, and optionally the display text as the 
second, and the array of attributes as the final parameter. If no display text is given, the 
method will humanize the elements name and return it in a more readable version.
To see how these helpers can work together to make form generation easy, let's create a 
few forms that we can use later in our case study site.
Time for action – Creating a login form using the Form 
helper class
Our case study site will need a few forms to operate before it goes live. We will handle the 
backend code for these later; however, we can create the markup now.

Working with Helpers and Classes
[ 120 ]
1.	 Create a new directory in our application/views/ directory, and name it 
account.
2.	 In the new application/views/account folder, create a file named login.php 
and open it for editing.
3.	 Place the following code into the login.php file:
<?php echo Form::open(); ?>
   
   <?php echo Form::label('username', 'Username')?>
   <?php echo Form::input('username'); ?>
   
   <?php echo Form::label('password', 'Password')?>
   <?php echo Form::password('password'); ?>
   
   <?php echo Form::submit('submit', 'Login'); ?>
   
<?php echo Form::close(); ?>
4.	 Be sure to save the new file.
5.	 Create a new file in application/classes/controller/user/ named 
account.php and open it for editing.
6.	 In the newly created file application/classes/controller/user/
account.php, add the following code:
<?php echo defined('SYSPATH') or die('No direct script access.');
class Controller_User_Account extends Controller_Application {
   public function action_login()
   {            
      $content = View::factory('account/login');    
      $this->template->content = $content;
   }
}
7.	 Now that we have a view file, and a controller, we need a route to make getting to 
the login page easy. To do this, open the application/bootstrap.php file, and 
add the following code at the beginning of the Routes declarations:
Route::set('login', 'login')
   ->defaults(array(
      'directory' => 'user',
      'controller' => 'account',
      'action'     => 'login',
   ));

Chapter 4
[ 121 ]
8.	 Save all your files and point your browser to http://localhost/egotist/
login; you should see the following page:
And a quick look at the source code reveals the following markup for the form:
<form action="http://localhost/egotist/login" method="post" accept-
charset="utf-8">  
   <label for="username">Username</label>  
   <input type="text" name="username" />  
   <label for="password">Password</label>  
   <input type="password" name="password" />  
   <input type="submit" name="submit" value="Login" />  
</form>
What just happened?
Creating a new controller and view should be old news to us by now, so we can skip 
explaining the process that was needed to create these files. Because we do not have a route 
that searches our user directory for controllers and actions, we needed to set an explicit 
route in our bootstrap file, which is great for pages like login, logout, password_reset, etc.; as 
we do not want to have to use a lengthy URL to get to these pages.
The controller action we created only allows the form to be generated; there is no validation 
or actions being taken on the form data at this point. After we have added a database to our 
site, we will revisit this controller and add form-handling functionality.
The real magic in this form creation was the seven very short lines of code that were 
necessary to create the markup. Now, form rendering can not only look nice, but it can be 
easier to write, maintain, and makes dynamic generation of forms much easier.

Working with Helpers and Classes
[ 122 ]
This may seem like only little benefit now, but just imagine generating different forms for 
different users, for example. By using this helper, we can create forms, and then render only 
the elements we need in an elegant manner.
Time for action – Creating a signup form for new users
Other forms that our case study site will need will be a user signup form and a password 
reset form. Let's create one more form together, and then have you create one on your own:
1.	 Open the application/classes/controller/user/account.php file for 
editing and add the following method below the action_login() method.
   public function action_signup() 
   {
      $content = View::factory('account/signup');    
      $this->template->content = $content;
   }
2.	 Create a new file in application/views/account named signup.php, and 
open it for editing.
3.	 In the new application/views/account/signup.php file, insert the 
following code:
<h1>Sign up for Egotist.. You know you want to!</h1>
<?php echo Form::open(); ?>
   <div class="form-field">
      <?php echo Form::label('first_name')?>
      <?php echo Form::input('first_name'); ?>  
   </div>
   <div class="form-field">
      <?php echo Form::label('last_name')?>
      <?php echo Form::input('last_name'); ?>    
   </div>
   <div class="form-field">
      <?php echo Form::label('email', 'Email Address')?>
      <?php echo Form::input('email'); ?>  
   </div>  
   <div class="form-field">
      <?php echo Form::label('password'); ?>
      <?php echo Form::password('password'); ?>  
   </div>
   <div class="form-field">

Chapter 4
[ 123 ]
      <?php echo Form::label('password_confirm', 'Confirm 
Password')?>
      <?php echo Form::password('password_confirm'); ?>  
   </div>
  <div class="form-field">
    <?php echo Form::submit('submit', 'Create new account'); ?>  
  </div>
<?php echo Form::close(); ?>
4.	 Next, we will need to add another route to the bootstrap.php file. Open it for 
editing, and insert the following code below our new 'login' route:
Route::set('signup', 'signup')
  ->defaults(array(
    'directory' => 'user',
    'controller' => 'account',
    'action'     => 'signup',
  )); 
5.	 After saving all your modified files, direct your browser to the signup page 
(http://localhost/egotist/signup); you should see the following result:
6.	 View the page source and notice the rendered form markup:
<form action="http://localhost/egotist/signup" method="post" 
accept-charset="utf-8"> 

Working with Helpers and Classes
[ 124 ]
  <div class="form-field"> 
    <label for="first_name">First Name</label>    
    <input type="text" name="first_name" />  
  </div> 
  
  <div class="form-field"> 
    <label for="last_name">Last Name</label>  
    <input type="text" name="last_name" />    
  </div> 
  
  <div class="form-field"> 
    <label for="email">Email Address</label>  
    <input type="text" name="email" />  
  </div>  
  
  <div class="form-field"> 
    <label for="password">Password</label>  
    <input type="password" name="password" />  
  </div> 
  
  <div class="form-field"> 
    <label for="password_confirm">Confirm Password</label>  
    <input type="password" name="password_confirm" />  
  </div> 
  
  <div class="form-field"> 
    <input type="submit" name="submit" value="Create new account" 
/>  
  </div> 
  
</form>
What just happened?
In the exact same manner we created the login form, this signup form is just a controller 
action with a view script that is using the Form helper to render the form. In this case, we 
wrapped each element and its label in a div to make each group block level elements that 
will be rendered on separate lines. This will also make styling of the form easier if a new 
design is implemented.
Along with the Form helper methods we have now learned about, there are few more we 
will see in use as the case study site expands. Just like the input methods we have already 
been using, the other common form elements are also represented.
The Form::checkbox() method creates, you guessed it, a checkbox. Where the other 
input methods we have used so far only have three parameters, checkbox has four. The first 
parameter is for the name of the element, the second is the value, the third is a Boolean that 
determines whether the box is checked, and the last is an array of attributes, just like the 
other elements.

Chapter 4
[ 125 ]
<?php echo Form::open(); ?>
  
  <?php echo Form::label('terms', 'Terms of service')?>
  <?php echo Form::checkbox('terms', 'agree', false, array('class' => 
'terms')); ?>
  By checking this box you agree to our Terms of Service
  
  <?php echo Form::submit('submit', 'Agree to Terms of Service'); ?>
  
<?php echo Form::close(); ?>
This will produce the following markup:
<form action="http://localhost/egotist/" method="post" accept-
charset="utf-8">  
  
  <label for="terms">Terms of service</label>  
  <input type="checkbox" name="terms" value="agree" class="terms" />  
  By checking this box you agree to our Terms of Service
  
  <input type="submit" name="submit" value="Agree to Terms of Service" 
/>  
  
</form>
Form::checkbox() and Form::radio() work identically, with the latter creating 
radio-type inputs instead of checkbox-type inputs.
Uploading files is also one of the roles of a form. The Form::file() method is designed 
to create file upload fields, and it is much like the other input fields, except it does not have 
the second parameter for the value. We just have to pass the name and an optional array of 
attributes to create a file upload field:
<?php echo Form::file('avatar'); ?>
The above code will produce:
<input type="file" name="avatar" />
Creating select elements with the form helper is much more DRY, as we can just pass a name 
to Form::select(), then an array of options, a default selected option, and the array of 
attributes if we need.
  <?php $colors = array(
    'red' => 'Red',
    'blue' => 'Blue',
    'green' => 'Green'
  ); ?>
  
  <?php echo Form::label('fav_color', 'What is your favorite color?'); 
?>
  <?php echo Form::select('fav_color', $colors, 'red'); ?>

Working with Helpers and Classes
[ 126 ]
The above code will create a select box:
<label for="fav_color">What is your favorite color?</label>  
<select name="fav_color"> 
  <option value="red" selected="selected">Red</option> 
  <option value="blue">Blue</option> 
  <option value="green">Green</option> 
</select>
The last Form helper method we are going to cover is Form::textarea(). By passing 
the name, body text (as a string), and an array of optional attributes, we get a textarea 
form field.
<?php echo Form::label('message', 'New Message'); ?>
<?php echo Form::textarea('message'); ?>
Produces:
<label for="message">New Message</label>  
<textarea name="message" cols="50" rows="10"></textarea>
Remember, we can override the rows, cols, and create more attributes by adding an array 
containing the key/value pairs, just like all the previous form helper methods.
Now that we have created two custom pages with forms for signup and login, it is time to 
create a simple password reset form on our own.
Have a go hero – Creating a lost password reset form
If a user loses a password, then he or she need a way to recover it without having you 
manually doing it for them. Compared to the last two forms, this one is even simpler 
(at least to render it).
Like the login and signup pages, it will need a custom route so it can be accessed via 
http://localhost/egotist/forgot_password; it will need a controller action in the 
account controller, and it will need a view with an explanation that an e-mail address must 
be entered into the form and instructions for getting a new password will be sent to them. It 
needs a form input field for their email address, a label letting them know to insert an email 
address, and a submit button that says "Reset Password".
You need to create this page and have it render the reset password form. This route, 
controller action, and view script are all included in the source code for this chapter if you 
need to take a peek and check our work.

Chapter 4
[ 127 ]
Extending Helpers
Sometimes our application needs some specific helper methods that will make our code 
more reusable throughout our project. All of the above helpers have a fair amount of added 
functionality on a library level. When we are writing application code, we may need additional 
HTML helpers, specialized filters, or other methods not included in the Kohana core.
Luckily, like using the helper classes, extending them is very easy.
Transparent Class Extension
Remember the Hierarchical aspect of Kohana's HMVC architecture? Because of the cascading 
filesystem, any classes that are located in our application directory will be loaded in the place 
of any files located in the system directory. Because of this system, we can create any class 
with the same name as the core system file, and then extend the core file by prepending it 
with "Kohana_".
Time for action – Extending the HTML helper method
In the Egotist case study site, we will need to list messages that users create, and this 
functionality may appear in several places throughout the site. You can extend the HTML 
helper class to have a message() method that wraps message text, publish info, and 
author name properly formatted in HTML. To accomplish this, we will simply extend the 
HTML class from within our application directory.
1.	 Create a new file in application/classes named html.php, and open it for 
editing.
2.	 In the new application/classes/html.php file, insert the following code:
<?php echo defined('SYSPATH') or die('No direct access allowed.');
/**
 * Extending the HTML helper class
 */
class HTML extends Kohana_HTML {
  /**
   * Format a message in a div with spans for author and fuzzy 
time
   * 
   * @param string The content of the message
   * @param string The author of the message
   * @param int The timestamp the message was published
   * @return string
   * @uses HTML::chars

Working with Helpers and Classes
[ 128 ]
   * @uses Date::fuzzy_span
   */
  public static function message($content, $author, $timestamp)
  {
    $formatted = '<div class="message">';
    $formatted .= self::chars($content);
    $formatted .= '<span class="author">' . self::chars($author) . 
'</span>';
    $formatted .= '<span class="published">' . Date::fuzzy_
span($timestamp) . '</span>';
    $formatted .= '</div>';
    return $formatted;
  }
  
}   
3.	 Save the newly extend HTML helper.
What just happened?
By creating the file in our application directory, Kohana will see it first, then use the 
system class as the base object since it is extending it. By creating a new method named 
message(), we have made our own HTML rendering function.
The message content and author name variables are first cleaned by HTML::chars() 
before being returned, and the timestamp is converted using Date::fuzzy_span(). Your 
helper is not only rendering markup, it is filtering and converting our data for us. Now we can 
pull messages directly from the database or another source, and easily output them cleanly 
and safely.
We will be listing messages once we have a database and some working forms in place for 
messages to be inputed into the application. By creating a quick test for our method, we can 
see how it works, and make sure it functions properly.
Here's a basic example of our new method's functionality:
<?php
$content = 'This is a test message';
$author = 'Joe Tester';
$timestamp = time() - 2500;
echo  Html::message($content, $author, $timestamp);
?>

Chapter 4
[ 129 ]
The above code will render the following HTML:
<div class="message">
  This is a test message
  <span class="author">Joe Tester</span>
  <span class="published">less than an hour ago</span>
</div> 
You may notice the documentation is very verbose. By taking a look at http://
localhost/egotist/guide/api/html, we can see our new method in the user guide:
Now, the documentation for our project contains the same code we will be using to write 
our application. Extending helper classes for specific functionality is a great way to make our 
code easy to write, and easier to update. Imagine if we want to wrap every message content 
in a paragraph tag, but messages are on dozens of pages? Now, we can just update the 
helper method and update the entire application in seconds.

Working with Helpers and Classes
[ 130 ]
Creating your own helpers
Creating your own helpers is exactly like extending the core system classes; you just don't 
need to extend anything. You can create helpers for any code that may need to be reused 
several times inside your project, or for repetitive functionality. Just remember to put your 
helper classes in your application/classes directory, and try to keep your methods static.
Summary
We learned a lot in this chapter, mostly about very specific functions that help us write and 
render code. We learned about auto-loading classes in Kohana, how to use most of the 
helper methods in the core framework library, and how to extend and create our own.
We also were able to create code for the case study site and see our new code appear in the 
user guide. We have learned a lot about the framework, and are well on our way to using 
Kohana in our projects.
In the next chapter, we will be learning how to extend Kohana's core functionality by 
implementing modules. We will be exploring the modules that ship with the framework, 
learn how to use third-party modules, and how to create modules of our own.

5
Installing and Configuring Modules
Modules are like plugins for the framework; they add functionality and can be used to extend 
the core system files, or provide some other functionality not inherent in the framework.
In this chapter, we will learn:


What a modules is, and how it works


How to load modules into our applications


Working with Kohana's bundled modules


Configuring modules for use


Installing new modules from the web


Installing new modules as Git submodules


Creating your own modules
Anatomy of a Module
As mentioned above, modules act as plugins do for other applications. In Kohana's cascading 
filesystem, application data is loaded first, then the modules, then system files. Because of 
this system, modules have a higher precedence than core system files, but application files 
will always have the highest precedence.
Modules can therefore extend core functionality and add to or modify the way the core 
framework operates. Any code that is not application-specific and has some level of 
reusability can be a module, so can entire packages, like a CMS, or Forum system.
Kohana does ship with a handful of 'official' modules, the User Guide being one of them. 
If you remember from Chapter 1, we enabled the user guide module in our bootstrap file 
for the case study site. By controlling the loading and order of modules, they can be easily 
included and excluded from our applications.

Installing and Configuring Modules
[ 132 ]
Modules work just like miniature applications in Kohana. Inside the modules directory, there 
is a directory for every module that shipped with the framework. Each of these modules 
then follows the same file structure as the application folder. There is a place for classes, 
controllers, views, config, and so on. When the filesystem is loaded, the bootstrap file in turn 
loads all the active modules.
Loading and configuring modules
Loading new modules into your application is extremely simple.
The best way to illustrate the loading of the modules is to open and view your 
bootstrap.php file, located in your application directory. Specifically, take a 
look at this section of code:
/**
 * Enable modules. Modules are referenced by a relative or absolute 
path.
 */
Kohana::modules(array(
   // 'auth'       => MODPATH.'auth',       // Basic authentication
   // 'cache'      => MODPATH.'cache',      // Caching with multiple
                                               backends
   // 'codebench'  => MODPATH.'codebench',  // Benchmarking tool
   // 'database'   => MODPATH.'database',   // Database access
   // 'image'      => MODPATH.'image',      // Image manipulation
   // 'orm'        => MODPATH.'orm',        // Object Relationship
                                               Mapping
   // 'oauth'      => MODPATH.'oauth',      // OAuth authentication
   // 'pagination' => MODPATH.'pagination', // Paging of results
   // 'unittest'   => MODPATH.'unittest',   // Unit testing
   'userguide'     => MODPATH.'userguide',  // User guide and API
                                               documentation
   ));
Here, we see the Kohana::modules() method being passed an associative array of 
module names and locations. Each of these modules is residing in the directory assigned 
to the constant, MODPATH, which should be the /modules directory in your case study 
application. The MODPATH constant can be modified, and is declared in the index.php file.
In the case study site, we enabled the userguide module so we could use the local guide, 
and to test the installation and server configuration. By uncommenting the line of code, 
Kohana then added it to the array, and Kohana::modules() loaded the userguide 
module.

Chapter 5
[ 133 ]
To enable, or load other bundled modules, simply uncomment the line of code for the 
module, and Kohana will load it. You should know that some modules are dependent on 
other modules, and some need configuration beyond just being loaded.
Some modules have README.MD markdown files that contain setup or install instructions, 
while others have this information on their Github page, web page, while others have no 
instructions at all. This really depends on the developer, the location of the files, and the 
level of community support for the module.
You will find that some modules have dependencies on other modules. While this may not 
always be apparent, it is usually outlined in the module's documentation. The ORM, for 
example, is dependent on the Database module. The ORM maps data and uses the Database 
module's query method, utilizing the abstracted database library to connect and run on 
different data storage platforms.
If a module has a config directory, it is always a good indication that the module is 
configurable, and we should probably override and edit any files defined in the config 
directory. Remember, because of the HMVC design patterns used to create Kohana, we 
should never modify module or system files directly, unless you are the author of the 
module, or have forked the project for your own. Instead, we should override any files for 
which we need custom functionality, including configuration files.
All we need to do is name a file in your application/config directory that has the same 
name and structure as the file(s) in the module's config directory. The modules that are 
listed in our bootstrap.php file are all included with the framework, and are considered 
the core, or official, modules. Several of these modules have configuration files associated 
with them, and as they are covered throughout the chapter, there will be several examples 
of how to override the configuration files properly without modifying the module code.
You may wonder why it is so important that the module and system code is not altered. 
The main reason is updates. When the framework, official modules, or third-party modules 
are updated or patched, we will probably want to update our application also. If not every 
patch, we will likely be performing updates during the lifetime of our projects. When we do 
perform these updates, we will not have to handle merges and update the files; remember 
where config files live and which ones need updating. The cascading filesystem will always 
know to use our application level config files with the respective modules.
Bundled modules
There are a select group of 'official' modules that are bundled with Kohana on a typical 
install. Each of these modules provide some features that directly complement the core or 
are deemed worthy enough to be included in the official distribution. These modules provide 
very important functionality, but are not necessary for the core operation of the framework.

Installing and Configuring Modules
[ 134 ]
Take the Database module for example; it is not absolutely necessary to run the framework, 
and some applications will not need a database, but many will. It is included because the 
vast majority of web applications require some sort of database to run.
It is worth exploring each of the bundled modules in some detail. Some of the modules will be 
covered in great detail over the next two chapters, like the Database and ORM modules. In this 
section, we will overview each of the core modules, how to configure them, and how they can 
be used in our applications. For a greater understanding of each, you are encouraged to visit 
their Github pages and read the user guide documentation and code for each.
User guide module
When we first set up the case study site, Egotist, we also enabled the user guide module. 
We have been able to access the user guide locally, and have also seen code that we have 
written become integrated into the local user guide for our reference.
The user guide contains a set of pages that serve as the documentation for Kohana. This 
module not only houses the default pages, it also allows for expansion by having pages 
added by enabled modules, and allows the API Browser to be built on the fly, keeping our 
project's documentation always up to date.
This particular module needed no configuration, it just needed to be enabled in the 
bootstrap.php file, and it was ready to do its job. It does, however, have a configuration 
file that allows us to set certain aspects of the guide optionally.
Opening the /modules/userguide/config/userguide.php file and looking at its 
contents, let's us see what is available for configuration.
<?php defined('SYSPATH') OR die('No direct access allowed.');
return array
(
   // Enable the API browser.  TRUE or FALSE
   'api_browser'  => TRUE,
   // Enable these packages in the API browser.  
   // TRUE for all packages, or a string of comma seperated packages, 
   // using 'None' for a class with no @package
   // Example: 'api_packages' => 	
   // 'Kohana,Kohana/Database,Kohana/ORM,None',
   api_packages' => NONE,
   // Leave this alone
   'modules' => array(
      // This should be the path to this modules userguide pages,
      // without the 'guide/'. Ex: '/guide/modulename/' 
      // would be 'modulename'

Chapter 5
[ 135 ]
      'userguide' => array(
         // Whether this modules userguide pages should be shown
         'enabled' => TRUE,
         // The name that should show up on the userguide index page
        'name' => 'Userguide',
         // A short description of this module, 
         //shown on the index page
         'description' => 'Documentation viewer and api generation.',
         
         // Copyright message, shown in the footer for this module
         'copyright' => '&copy; 2008–2011 Kohana Team',
     )   
   )
);
Here, we see we can enable or disable the API Browser or decide which modules will be 
included in the browser. This can be helpful if there are some modules that we either do not 
want to see, or do not want to make available in the browser. Almost every module has a 
configuration file that you can overload and merge for customization or configuration.
Image module
Image manipulation is a common task for web applications. Users upload files for avatars, 
posts, and a multitude of other reasons, and most of these images have to be altered in 
some way. Most sites that allow avatars, for example, keep all the avatar images the same 
size. Instead of requiring users to pre-edit their images for our particular size requirements, 
we can have the images cropped before we save them for later use.
The Image module currently uses the GD Image library to handle image manipulation; 
however, its design does allow for other drivers to be used (like ImageMagick). Because 
of the level of abstraction used, we do not need to know the commands for GD or 
ImageMagick; all we need to know is the methods available from the module, and then 
we can manipulate images programmatically, using a familiar syntax.
Like all other bundled modules, we will need to enable the Image module 
by uncommenting the module in our bootstrap.php file in the array in 
Kohana::modules(). Once we have made this change, we can now see 
the module's documentation in the user guide. Point your browser to your local 
guide (http://localhost/egotist/guide/), and you will notice a new 
section for Kohana/Image, and the module's API information has been added to 
the API browser.
www.allitebooks.com

Installing and Configuring Modules
[ 136 ]
Using the Image module is simple; we just pass the image file to the Image::factory() 
method, and then manipulate with one of the many helper style methods available, and 
then we can save() or render() the manipulated image.
The methods available to manipulate images are crop(), resize(), rotate(), 
reflection(), flip(), sharpen(), background(), and watermark(). Each of these 
methods are run on the image object once it is loaded via the factory() method, and the 
output as a binary string using render(), or save the image as a file using save().
To load a file to be used by the Image module, just pass the file in to the factory method 
and create a variable to hold the new object like this:
$image = Image::factory('some-location/some-image.png');
Now, we can run various methods on the image to change it. The list below gives an 
overview of the most common Image methods available for use.


Image::crop(): The crop method takes a width and height and will crop from the 
center of the image.  If we pass TRUE in to the third parameter, it will crop from the 
bottom.  We can even pass coordinates into the third and fourth parameters and set 
the crop from location.  For most cases, we will just need to pass in the size.
$image->crop(100, 150);
This line of code will crop the image to 100px wide by 150px high.


Image::resize(): The resize() method is similar, however, it changes the size 
of the image instead of cropping it. Also, we can pass either the desired height or 
width, and the function will automatically determine the length of the other side. 
This method can also maintain or ignore aspect ratios based on the third parameter. 
Consult the API browser for reference for all the functionality of this method:
$image->resize(100, NULL);
This line will resize the image to a width of 100 and will calculate the height based 
on aspect ratio.


Image::rotate(): Rotate does exactly what is says, it will rotate an image by a 
set number of degrees. Just tell it how far to rotate the image, and it will make it 
happen.
$image->rotate(-45);
The above code will rotate the image 45 degrees counter-clockwise. Positive 
numbers will be rotate clockwise.

Chapter 5
[ 137 ]


Image::reflection(): Reflections are a nice touch to a lot of designs for 
user interfaces and general site design. The reflection() method will let us 
dynamically create images with the reflection effect in a programmatic function. All 
we need to do is tell the method the height of the desired reflection, the opacity on 
a scale of 1 – 100, and whether or not we want the reflection to include a fade-in 
effect.
$image->reflection(25, 75, TRUE);
This will create a reflection under the image that is 25 pixels tall, has an opacity of 
75%, and does have the fade-in effect.


Image::flip(): The flip() method flips an image along either its vertical or 
horizontal axis. This method accepts one of two constants that are created when 
the object is created that have the horizontal and vertical axis positions assigned 
to them. These constants are Image::HORIZONTAL and Image::VERTICAL. 
Use these to determine which way to flip the image.
$image->flip(Image::HORIZONTAL);
This will 'flip' the image horizontally. Using Image::VERTICAL would do the 
opposite: flip it vertically.


Image::sharpen(): Sharpening images is as easy as the sharpen() method. 
By passing an integer that specifies the percentage to sharpen, the function runs 
a sharpening algorithm to produce a digitally sharpened image.
$image->sharpen(25);
will sharpen the image by 25%.


Image::background(): When an image has alpha transparency, the image 
essentially has no background color. Sometimes, we may want these images to have 
a background color and need it to happen inside our application, without having to 
have a manually manipulate each image file. The background() function does just 
that; tell it a color and opacity, and it will add the background color on the fly.
$image->background('#FFF');
This will set the background color for our image to white, and since no opacity 
integer was passed, it will fill it at 100% opacity.


Image::watermark(): Watermarks are a good way to show ownership or display 
other information directly on an image. The watermark() function will take one 
image file, and place it on top of another image file. This can be very useful when 
displaying images that we do not want used outside of our site, or we need to 
display examples that have a watermark to let users know they are samples.
$image->watermark('my-watermark.png');

Installing and Configuring Modules
[ 138 ]
The above code will add a watermark image to the center of the image. For more 
options for using the watermark() method, such as manipulating the offset and 
opacity of the watermark, please consult the API Browser and user guide.


Image::save(): As mentioned earlier, saving or rendering the manipulated image 
are the two options for completing the process. In most cases, saving will be used; 
often after the image name has been added to a database or other data store. 
Simply run the save() method with the file name of the save location.
$Image->save('images/uploads/filename.png');
This will save the image to the desired location.
As you can see, making images the right size, making reflections, adding watermarks, 
rotating and flipping, changing background colors, and sharpening images can be done 
dynamically, using one line methods to accomplish many manipulations before finally 
saving the file. The Image module adds a very helpful library to the Kohana framework.
oAuth module
Open Authorization (oAuth) is an open standard for authorization that has been widely 
adopted by the Internet community. Many popular website and services, like Twitter, 
Facebook, and LinkedIn, all use oAuth to authorize third-party applications to use certain 
services like APIs or to act on behalf of a user, or gain access to some of the user's 
information.
The oAuth module comes with the methods necessary to connect and use oAuth in your 
applications. It even has provider classes for use with Twitter and Google's oAuth clients, 
and handles the access and request tokens, URL authorization, and so on.
This module does come with a base configuration file for use with Twitter that will need to 
be overridden in your application directory if your application will utilize the Twitter API.
To use oAuth in an application, we need to uncomment the oAuth module in the 
bootstrap.php file. As oAuth is outside of the scope of a beginners guide to 
this framework, you can consult the user guide for more information at http://
kohanaframework.org/3.0/guide/oauth. This module does make it easy to 
communicate with a service that utilizes oAuth for authentication.
Database and ORM modules
Although not all web applications use a database, it is safe to say that most do. Since it is 
not necessary for web development, the database library is not included in the core of the 
Kohana framework, but it is included as an official module.

Chapter 5
[ 139 ]
The Database module provides an abstracted library to interact with common database 
systems through a single interface and in a programmatic fashion that follows the Kohana 
coding standards. By abstracting the database functionality to a simple, yet powerful set 
of methods, the Database module makes it easy to use a variety of database solutions to 
manage our application's data. Kohana's official Database module ships with drivers for 
both the PHP-PDO library (http://php.net/manual/en/book.pdo.php) and MySQL 
databases.
The Database module is enabled by uncommenting the database value in the 
Kohana::modules() method inside the bootstrap.php file, like all other official 
modules. We will also need to configure our application to use the database by setting 
up a configuration file. 
Time for action – Configuring your application to use a database
Like other modules, to configure the database we will need to merge the supplied config 
file with one in our /application/config directory with the same name. In this case, 
we need to create and configure the database configuration file as specified in /modules/
database/config/database.php.
1.	 Create a new database in your development environment using MySQL. You 
will need to take note of your database name, username, and password. 
Other details may be necessary based on your environment. For the example 
site referenced in the text, the database will be named egotist_db.
2.	 Be sure the database module is enabled in the /application/
bootstrap.php file by ensuring it is not commented out.
3.	 Create a new file in the /application/config directory named database.php.
4.	 Open the newly created /application/config/database.php file for editing.
5.	 Edit the new database.php file in your /application/
config directory so it looks like this:
<?php defined('SYSPATH') or die('No direct access allowed.');
return array
(
   'default' => array
   (
      'type'       => 'mysql',
      'connection' => array(
         /**
         * The following options are available for MySQL:

Installing and Configuring Modules
[ 140 ]
          *
          * string   hostname     server hostname, or socket
           * string   database     database name
          * string   username     database username
          * string   password     database password
          * boolean  persistent   use persistent connections?
          *
          * Ports and sockets may be appended to the hostname.
          */
         'hostname'   => 'localhost',
         'database'   => 'egotist_db',
         'username'   => 'your_username',
         'password'   => 'your_password',
         'persistent' => FALSE,
      ),
      'table_prefix' => '',
      'charset'      => 'utf8',
      'caching'      => FALSE,
      'profiling'    => TRUE,
   ),
); 
6.	 Change the your_username and your_password fields in the above code to 
match your username and password for the database on your development 
environment. You may also need to change the database name and hostname 
values to match your database setup.
7.	 Save your new configuration file, and you can now view the Database module 
in your user guide.
What just happened?
Congratulations! You just added database functionality to the application. By enabling and 
configuring the Database module, we just made interacting with MySQL very simple, and our 
application is now ready to begin interacting with the database using syntax that is familiar 
to Kohana development, not a bunch of queries that are written in some SQL syntax.
Like other Kohana modules, all we needed to do was enable the module by allowing it to be 
passed to Kohana::modules() in the /application/bootstrap.php file. Then, we 
merged the default configuration file for the module with values that matched the database 
on our system without altering any code in the module. Now, our application is ready to 
begin using the Database module.

Chapter 5
[ 141 ]
We will briefly cover the database module here, limiting our scope to a basic overview 
and a few examples, so we can have some database records to use when illustrating other 
modules and examples throughout the course of the book. While the database module will 
be covered here as basic coverage, the next chapter is dedicated to using the Database and 
ORM modules in your applications.
Once the database is configured, using it in our application with the database module is 
as simple as creating code that implements the data store. Although we can put the data 
layer code in our controllers, it is considered a good practice to place this code into models. 
Whenever you are interacting with the database to create, read, update, or delete data, it 
should happen from a model.
Models are like views and controllers; however, they are only concerned with creating an 
interface for your application to interact with the data it represents, or models. We will cover 
models more in the next chapter also, but we should understand their basic place in the (H)
MVC design now.
The DB class is essentially a helper class for the Database module that allows for easy CRUD 
(create, read, update, delete) functions via the Query Builder. These helper methods make 
it easy to manage database records with an interface that is very familiar in the Kohana 
framework. Again, we will be covering the Database module in more detail in the next 
chapter, and these few methods do not encompass the entire module.
Time for action – Creating a database table and using the 
query builder
1.	 In the database you have created for egotist, which in the case study examples 
is named egotist_db, create a new table named messages with some basic 
columns using the following query:
CREATE TABLE `messages` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `content` varchar(240) NOT NULL,
  `date_published` int(10) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 
2.	 In this newly created table, create some test data. You can 
do this manually or just run the following query:
INSERT INTO `messages` (`id`,`user_id`,`content`,`date_published`)
VALUES
   (1,1,'This is a test message',1292937495),

Installing and Configuring Modules
[ 142 ]
   (2,1,'Another test message for the system',1292937511),
   (3,1,'This message is a bit longer than the rest, but it is 
still within the limits',1292937524),
   (4,1,'Test message number 4 for user number 1',1292937557),
   (5,1,'How about some more test messages?',1292937589),
   (6,1,'Just another test message',1292937615);
3.	 Create a new file in the /application/classes/model directory named 
message.php.
4.	 In the new file /application/classes/model/message.php, insert the 
following code:
<?php defined('SYSPATH') or die('No direct script access.');
/**
 * Message Model
 * Handles CRUD for user messages
 */
class Model_Message {
   
   // Table name used by this model
   protected $_table = 'messages';
   
   /**
    * Adds a new message for a user
    * 
    * @param   string   user_id
    * @param   string   user's message
    * @return  Database
    */ 
   public function add($user_id, $message) 
   {
      $data = array('user_id', 'message', 'date_published');
      
      return DB::insert($this->_table, $data)
         ->values($user_id, $message, time())
         ->execute();
   }
   
   /**
    * Gets all messages
    *
    * @return  array

Chapter 5
[ 143 ]
    */ 
   public function get_all()
   {
      return DB::select()
         ->from($this->_table)
         ->execute()
         ->as_array();
   }
   /**
    * Deletes a message from the DB
    * 
    * @param   string   user_id
    * @param   string   user's message
    * @return  Database
   */ 
   public function delete($user_id, $message)
   {
      return DB::delete($this->_table)
         ->where('user_id', '=', $user_id)
         ->where('message', '=', $message)
         ->execute();
   }
   
}
5.	 Now that we have created a model to handle base communication with our 
database, we will need to have a place to show the results. We can use the welcome 
page to display some test messages to ensure the model is working correctly. To 
do this, we need to open the Welcome Controller located in /application/
classes/controller/welcome.php and edit it to show the following changes:
<?php defined('SYSPATH') or die('No direct script access.');
class Controller_Welcome extends Controller_Application {
   public function action_index()
   {
      $content = View::factory('welcome')
         ->bind('messages', $messages);
      $message = new Model_Message;
      $messages = $message->get_all();
      $this->template->content = $content;
   }
}

Installing and Configuring Modules
[ 144 ]
6.	 And finally, we will need to alter the welcome view to display the database results. 
Open /application/views/welcome.php, and alter it to look like the 
following code:
<h1>Recent Messages on Egotist</h1>
<?php foreach ($messages as $message) : ?>
   <p class="message">
      <?php echo $message['content']; ?>
      <br />
      <span class="published">
          <?php echo Date::fuzzy_span($message['date_
published'])?>
      </span>
   </p>
   <hr />
<?php endforeach; ?>
7.	 Now, point your browser to your http://localhost/egotist/, and you 
should see a screen similar to the following:

Chapter 5
[ 145 ]
What just happened?
First, we created a new database table to house our messages. There is nothing tying the 
user_id field to any other tables yet, but in the future we will want to link the user that left 
the message with the message data. Then, we added some sample data to allow for testing 
the get_all() model method.
Then, we created our first model, one that will let us add, get, and delete messages from the 
messages database table. All the methods use the Database module, more specifically the 
DB class to select, insert, and delete records in the database.
The get_all() method in the message model queries the database with a select 
statement, and returns an array of records for the given query. This example is very basic, 
and does not limit based on time, tie to user information, or any of the other features it will 
need to be fully implemented, but it does show the bare bones requirements for selecting 
records from the database using this module. The add() and delete() methods are not 
yet being used, but can be used in your testing to add and remove messages using the same 
style of syntax that we retrieved them with.
Again, we will be covering the database module in more detail in the next chapter, and this 
introduction can serve as our first glimpse and models and the Database module. By looking 
at the code we created, we should have a basic understanding of how the Database module 
is different from the standard SQL code being used in procedural scripts.
Along with the Database module, the framework includes an ORM module also. Object 
Relational Mapping (ORM) is a way for data to be represented in objects, allowing for an 
object-oriented approach to handling database data. The ORM allows all models to interact 
with our databases like they were all objects, and therefore makes your code syntax more 
common throughout our applications. In the next chapter, we will be using the ORM module 
along with the Database module and models to make our applications data driven.
Now that we have our database up and running, albeit with very minimal data, we can begin 
to explore a few modules that interact with the database module nicely. By utilizing modules 
that interact with the database through the framework, we can easily leverage even more 
power to write less code and get more results.
Pagination module
It is considered good practice to show only a portion of very large sets of data in web 
applications. Even though there may be thousands of search results for any given search, 
Google does not show all of them; instead, they paginate the results by showing you a set 
number, usually 10 at a time, and let us choose which 'page' of data to view.

Installing and Configuring Modules
[ 146 ]
Adding pagination to an application can be a large task, and combined with using a database, 
it can get very complex. The Pagination module makes is very easy to add pagination links to 
our results, and it easily integrates with our database queries to set limit and offset values 
properly.
Time for action – Adding pagination to database results
To illustrate how easy it is to add pagination, complete with database limits and offsets, 
and generate the pager links necessary for our users to navigate the results, we can add 
pagination to our test messages that are being displayed on our welcome page. Right now 
our welcome page will list all the messages in the table, no matter whether there are 6 or 
60. By introducing pagination, we can display a set number of messages and then allow our 
users to select different pages from a set of links.
1.	 In the /application/bootstrap.php file, uncomment the pagination module 
in the Kohana::modules() method to enable the pagination module.
2.	 Open you message model file located at /application/classes/model/
message.php for editing, and alter the get_all() method so it looks like this:
/**
 * Gets all messages
 *
 * @return  array
 */ 
public function get_all($limit = 10, $offset = 0)
{
   return DB::select()
      ->from($this->_table)
      ->order_by('date_published')
      ->limit($limit)
      ->offset($offset)
      ->execute()
      ->as_array();
}
3.	 Below this method, add the following new code, then save the file:
/**
 * Counts all messages
 * 
 * @return int
 */

Chapter 5
[ 147 ]
public function count_all() 
{
   return DB::select(DB::expr('COUNT(*) AS message_count'))
      ->from($this->_table)
      ->execute()
     ->get('message_count');
}
4.	 Now, open the Welcome controller located at /application/classes/
controller/welcome.php, and alter the action_index() method 
with the following code:
public function action_index()
   {      
      $content = View::factory('welcome')
        ->bind('messages', $messages)
        ->bind('pager_links', $pager_links);
   
   $message = new Model_Message;
   
   $message_count = $message->count_all();
   
   $pagination = Pagination::factory(array(
      'total_items'    => $message_count,
      'items_per_page' => 3,
   ));
   
   $pager_links = $pagination->render();
   
   $messages = $message->get_all($pagination->items_per_page, 
$pagination->offset);
   
   $this->template->content = $content;
}
5.	 Open the welcome page view located at /application/views/welcome.
php, and add the following highlighted code to your welcome view:
<h1>Recent Messages on Egotist</h1>
<?php foreach ($messages as $message) : ?>
   <p class="message">
       <?php echo $message['content']; ?>
     <br />
     <span class="published"><?php echo Date::fuzzy_
span($message['date_published'])?></span>
   </p>
   <hr />

Installing and Configuring Modules
[ 148 ]
<?php endforeach; ?>
<?php echo $pager_links; ?>
6.	 Save all the altered files and point your browser to http://localhost/egotist/; 
you should see the following page, complete with working pagination links.
Clicking on the next page will reveal the next three messages from the database.
What just happened?
Like all the modules we have used so far, we started out by enabling the module in our 
bootstrap.php file so Kohana knew to load the module and make its resources available 
for our use. Next, we altered our existing Messages model, specifically the get_all() 
method, to now accept parameters for the query's limit and offset. The limit in a SQL query 
is the number of results to return, and the offset is the number of records that should be 
'skipped' when returning the results.

Chapter 5
[ 149 ]
Using the database query builder, we just have to pass the integer for limit and offset into 
their respective methods, and the DB class will build the necessary parameters into the 
query. By specifying default values of 10 for the limit and 0 for the offset in the function 
declaration, we are telling the method to return the first 10 results for any given query if 
none is specified. The order_by() method was added to the chain to ensure the results 
always followed a particular order, and since the title is for Recent Messages, it makes sense 
to order by the publish date timestamp.
Next, we added a new method to our Message model that simply returns a count of all the 
records in the table. This will be important when we are implementing the Pagination class, 
because to know how many pages are available it must know how many possible results 
there are, and how many results are allowed per page. This new function will return an 
integer of the exact number of messages that can be returned for the get_all() method.
Now that our model is prepared to handle limits, offsets, and can count the number of 
all our messages, we had to update our controller to use the Pagination module. In our 
welcome.php controller file, we added some code to our existing index action. First, we 
added another bind() method to our view object, allowing for a view variable named 
$pager_links to be passed to our view script.
Then, directly after instantiating our Message model, we obtained a count of all the 
messages. After that, we created a new Pagination object by using the factory() method 
in the Pagination class, passing in an array of parameters to set the total items (the message 
count), and the desired number of results per page. Lastly, we added the $pagination 
object's property values that it calculated for our limit and offset amounts.
By using the pagination module, we have already been able to accurately create the limit and 
offset for our database results. Now our queries are faster (smaller result set), and ours user 
are getting better information. But wait, there's more.
Next, we added one more line to your controller action, rendering the pagination links and 
storing them in the view variable $pager_links. By echoing this variable out in our view 
script, the links were also generated by the module, making adding pagination an extremely 
simple process.
Now, the home page for your case study site displays data dynamically from the database, 
and has pagination links that not only work, but also were simple to create.
The pagination class uses a factory pattern, using the Pagination::factory() method 
to get an instance of the Pagination class. This method will accept an array of configuration 
options that we can use to override the default options in the module's configuration file 
located at /modules/pagination/config/pagination.php. In the above example, 
we set the 'items_per_page' value to 3, and the 'total_items' value, which is a 
default of 0 in the config file, to the actual number of messages that are being returned for 
pagination. We could also set the view, and other more advanced options here.

Installing and Configuring Modules
[ 150 ]
The module uses the information it is given to not only generate the views for the pager 
links, it also creates a few object properties with values that are very important for 
generating the right data for our results. The two most import values we need for generating 
the resultset are the items per page and the limit. In your above example code, we see these 
values are in the items_per_page and limit object properties, and are created when the 
Pagination object is instantiated.
The full list of object properties that are stored and available when the Pagination object is 
created and configured are:
total_items           // The total number of items to be paginated
items_per_page        // The number of items to be displayed per page
total_pages           // The total number of pages
current_page          // The current page being displayed
current_first_item    // The first item displayed in the current set
current_last_item     // The last item displayed in the current set
previous_page         // Page number of the previous page
next_page             // Page number of the next page
first_page            // Is this the first page? (bool)
last_page             // Is this the last page? (bool)
offset                // Offset value for DB
The class also has a method for generating a URL for a particular page, and a method 
for determining whether a page is correct. These methods, Pagination::url() and 
Pagination::valid_page() respectively, are mainly used when creating new pager link 
views or custom pagination links.
We can customize the pagination module by overriding the configuration file, just like many 
of the other modules we have covered so far. Here, we can set many different options 
for the module, most often the default view for pager links is added to or changed. The 
module comes with two different sets of pager link views, the default being 'pagination/
basic', located at /modules/pagination/views/pagination/basic.php, and 
'pagination/floating', located at /modules/pagination/views/pagination/
floating.php.
The Pagination module can be simple to use, but it can also be customized, extended, and 
used to create a wide array of solutions to pagination needs. For the scope of this book, 
and for the need of most applications, the basic use of this module is indeed enough to add 
pagination to our results, make the rendered links work, and look great. We can spice them 
up with some CSS, and move on to creating other parts of our application.

Chapter 5
[ 151 ]
Have a go hero – Explore the Pagination module
The Pagination module is a great place to get introduced really to the inner working and 
configuration of modules. Because of the number of options and ease of use, it is very 
flexible, and you can immediately see the results of any changes you make. By modifying the 
code already in the welcome controller, change the number of items displayed to a larger 
amount, and while you are in the code, see just how much control you can wield over the 
pagination results and links. To save on code and gain more options in the view, you can bind 
the pagination object to the view, and then echo the pagination view variable and allow the 
objects magic __toString() method to create the pagination links for you.
Now that our case study site has messages being displayed, and a column in the database 
table that is intended to link to a user's information, maybe it is time to explore some user 
authorization so you can start adding some test users to the database. This can be a daunting 
task, but thanks to the next module in the official Kohana bundle, user authorization just got 
a lot easier.
Auth module
User authorization made simple, with a nice interface for managing user authentication. 
Although you can implement this module without a database, it is best used, and 
most simple to use, when it is combined with the ORM module to manage our user's 
authentication, password encryption, etc. properly.
This module is very powerful, and makes the entire process of managing users and their 
data much easier. When we pair it with Kohana's session management and the ORM module, 
it becomes a powerhouse that makes development a breeze.
In the next chapter, when the ORM is implemented, we will get the opportunity to add the 
Auth module to our case study site, add database-driven sessions, and our site will allow for 
user creation, login, logout, and other functions commonly associated with user accounts 
on a web application. Best of all, the Auth module keeps security in mind during the entire 
process.
Enabling and configuring the Auth module is just like other modules we have encountered 
so far. By uncommenting the module in /application/bootstrap.php and merging 
the config file with our data, we can get this module up and running in minutes. In the next 
chapter, and we will have this module fully configured and operational in your case study 
application.

Installing and Configuring Modules
[ 152 ]
Code Bench module
Benchmarking is a useful method, employed by many software developers to determine the 
speed that different procedures take to run, thereby letting them know which is the most 
efficient method to accomplish a given task, and to test different methods against each 
other.
Knowing how individual pieces of code run lets us understand a great deal about our code, 
regular expressions, and can lead to much more efficient and better performing code.
The Kohana Code Bench module allows us to create classes that can be tested for 
benchmarking analysis and display a graphic representation of your results. There are some 
basic rules we need to follow, and the module comes with several examples to get us started.
To use the module, we need to enable it in our bootstrap file and point your browser to 
http://localhost/codebench. Then, we can input the name of the class you want to 
analyze, and click Run. We can use the Bench_Validurl class provided as an example to 
see the output in a browser:

Chapter 5
[ 153 ]
The Code Bench module is very powerful, and looking through the documentation at 
http://kohanaframework.org/3.0/guide/codebench and viewing the example 
bench classes in the /modules/codebench/classes/bench/ directory will help you 
understand how to use this module in the future.
We will not be implementing the Code Bench module in our case study site, as it is a more 
advanced feature than can be covered in a beginning series, but this is a very powerful 
module, and you should be aware of its existence, and are encouraged to explore and use 
this module in your future projects.
Cache and Unit Test modules
The last two 'official' modules that are included in the framework's core package are the 
Cache and Unit Test modules. The unit test module provides an interface for code testing 
using the PHPUnit library. The Cache module allows for integration with caching technology 
like memcache and APC. These modules are outside of the scope for a beginner's guide, 
and although they are very powerful, you should be aware of their existence. For more 
information on these modules, you are encouraged to visit their respective GitHub pages and 
the Kohana User Guide.
Installing modules
Apart from the group of official modules that are bundled with Kohana, there are hundreds 
of modules available for download all over the Internet. The vast majority of these modules 
can be found on GitHub, and can be downloaded using Git or via compressed files with all 
the source content.
Installing and configuring these modules follows the same process as the bundled modules, 
and many of the more stable modules have a fair amount of documentation. Some modules 
even have entire websites, wiki, forums, or other means of community involvement, so 
finding support and other developers using these modules is easy to obtain.
Installing modules from source files
When we get the source files for a third-party download, we can place them in the /
modules directory and then add them to our bootstrap.php file like any of the included 
modules. Most likely, the files are all archived, so we can extract them directly into your 
modules directory.
Most modules that are created and distributed for Kohana are located on GitHub. Here, 
we can find modules, and then click the download button to retrieve either a zipped or 
tar-balled archive of the desired module. By then downloading, extracting, enabling and 
configuring the module, we can have it ready to use in our system.

Installing and Configuring Modules
[ 154 ]
Say, for example, we wanted to use the 'mailer' module that was created by the GitHub 
user 'themusicman' and thought it would work well in our application, we could visit the 
GitHub page for the project located at https://github.com/themusicman/Mailer to 
download and install the module.
Time for action – Installing a module from an archive
If you plan to install modules via Git, you may want to skip this section and continue onto the 
next section that is designed for Git users.
1.	 Create a new directory named mailer in your application/modules/ directory.
2.	 Go to GitHub to the desired module's page, in this case the mailer module 
is located at https://github.com/themusicman/Mailer.
3.	 Click the Downloads button and choose the .zip file.
4.	 After the .zip file has completed downloading, unzip the archive contents into 
your /application/modules/mailer directory.
5.	 Open your /application/bootstrap.php file for editing.
6.	 Edit the Kohana::modules() method call in your bootstrap file so it looks like this:
/**
 * Enable modules. 
 * Modules are referenced by a relative or absolute path.
 */
Kohana::modules(array(
   'auth'       => MODPATH.'auth',       // Basic authentication
   // 'cache'      => MODPATH.'cache',   // Caching with multiple
                                            backends
   'codebench'  => MODPATH.'codebench',  // Benchmarking tool
   'database'   => MODPATH.'database',   // Database access
   'image'      => MODPATH.'image',      // Image manipulation
   // 'orm'        => MODPATH.'orm',     // Object Relationship
                                            Mapping
   // 'oauth'      => MODPATH.'oauth',   // OAuth authentication
   'pagination' => MODPATH.'pagination', // Paging of results
   // 'unittest'   => MODPATH.'unittest',// Unit testing
   'userguide'  => MODPATH.'userguide',  // User guide and API
                                            documentation
   'mailer' 	  => MODPATH.'mailer',         // Mailer module
)); 

Chapter 5
[ 155 ]
7.	 Create a new file in your /application/config directory named mailer.php, 
and insert the code from the /modules/mailer/config/mailer.php file, and 
edit as needed to get your mail server options in place. It should look similar to this:
<?php defined('SYSPATH') or die('No direct script access.');
/**
 * SwiftMailer transports
 *
 * @see http://swiftmailer.org/docs/transport-types
 *
 * Valid transports are: smtp, native, sendmail
 *
 * To use secure connections with SMTP, 
 * set "port" to 465 instead of 25.
 * To enable TLS, set "encryption" to "tls".
 * To enable SSL, set "encryption" to "ssl".
 *
 * Transport options:
 * @param   null  	 native: no options
 * @param   string  sendmail: 
 * @param   array   smtp: hostname, username, password, port, 
encryption (optional)
 *
 */
return array
(
   'transport'	
=> 'smtp',
   'options'	 => array
       (
         'hostname'	=> 'yourmailserver.com',
         'username'	=> 'yourname@yourmailserver.com',
         'password'	=> 'p@ssw0rd',
         'port'	
	
=> '25',
         'encryption'=> 'tls'
      ),
); 
8.	 Save all your files, and you are ready to use the module in your application.

Installing and Configuring Modules
[ 156 ]
What just happened?
Installing a module from the source files is this simple, no matter which module we choose. 
Besides having to download and unzip a file, the setup of this module follows the same steps 
as the other modules we have created so far.
We were required to add the line for the Mailer module to the Kohana::modules() 
method in the /application/bootstrap.php file, where with the official modules the 
lines were already there, they were just commented out. By naming the module's directory 
after the name of the module, and then using the same name and path in the bootstrap, 
we will make it easy to keep your modules organized. In most cases, like with this module, 
we can simply add it to the end of the Kohana::modules() array parameter and have no 
issues.
Updating our modules using this method will require us to download newer versions of the 
modules and manually copy the new files into our module directory. A simpler, and more 
efficient way of installing and updating your modules is using Git.
Installing modules via Git
Since most of the available modules are on GitHub, it is very simple to add submodules to 
our Git-enabled project. If you are using Git with your case study site, you can add modules 
to it by simply using Git to pull the latest version of the module, and then it is easier to 
update as you can also use Git to update your submodules.
Just like when we originally installed Kohana via Git in the beginning of the book, we can 
add to our project using Git to download and update your Kohana modules.
Time for action – Installing a module using git 
Let's take another look at installing the Mailer module for Kohana; this time using Git instead 
of downloading a zipped archive.
1.	 Open a terminal window and go to the egotist web root directory.
2.	 By visiting the GitHub project page for the module we want to install, in this 
case the Mailer Module located at https://github.com/themusicman/
Mailer, we can get the URL for the project we want to add as a Git submodule. 
On this page, we can see it is 'https://github.com/themusicman/
Mailer.git'. We will need this location in the next step.
3.	 In the webroot directory for our egotist project, run the following command:
git submodule add https://github.com/themusicman/Mailer.git 
modules/mailer

Chapter 5
[ 157 ]
4.	 Once the mailer submodule has completed cloning, we can initialize and 
then update the submodules using the following two commands:
git submodule init
git submodule update
(You may need to run 'sudo' on some systems or have root privileges to execute these 
commands.)
5.	 Continue to enable and configure the module as described in the section above.
6.	 Open the /application/bootstrap.php file for editing.
7.	 Edit the Kohana::modules() method call in your bootstrap file so it looks like this:
/**
 * Enable modules. 
 * Modules are referenced by a relative or absolute path.
 */
Kohana::modules(array(
   'auth'       => MODPATH.'auth',       // Basic authentication
   // 'cache'   => MODPATH.'cache',   // Caching with multiple 
                                         backends
   'codebench'  => MODPATH.'codebench',  // Benchmarking tool
    'database'   => MODPATH.'database',   // Database access
   'image'      => MODPATH.'image',      // Image manipulation
   // 'orm'     => MODPATH.'orm',     // Object Relationship 
                                         Mapping
   // 'oauth'   => MODPATH.'oauth',   // OAuth authentication
   'pagination' => MODPATH.'pagination', // Paging of results
   // 'unittest'=> MODPATH.'unittest',// Unit testing
   'userguide'  => MODPATH.'userguide',  // User guide and API 	
                                            documentation
   'mailer'    => MODPATH.'mailer',         // Mailer module
)); 
8.	 Create a new file in the /application/config directory named mailer.php. 
and insert the code from the /modules/mailer/config/mailer.php file, and 
edit as needed to get your mail server options in place. It should look similar to this:
<?php defined('SYSPATH') or die('No direct script access.');
/**
 * SwiftMailer transports
 *
 * @see http://swiftmailer.org/docs/transport-types

Installing and Configuring Modules
[ 158 ]
 *
 * Valid transports are: smtp, native, sendmail
 *
 * To use secure connections with SMTP, 
 * set "port" to 465 instead of 25.
 * To enable TLS, set "encryption" to "tls".
 * To enable SSL, set "encryption" to "ssl".
 *
 * Transport options:
 * @param   null  	 native: no options
 * @param   string  sendmail: 
 * @param   array   smtp: hostname, username, password, port, 
encryption (optional)
 *
 */
return array
(
   'transport'	
=> 'smtp',
   'options'	 => array
      (
         'hostname'	=> 'yourmailserver.com',
         'username'	=> 'yourname@yourmailserver.com',
         'password'	=> 'p@ssw0rd',
         'port'	
	
=> '25',
      ),
); 
9.	 Save all your files, and you are ready to use the module in your application.
What just happened?
We were able to easily download and install this third-party module into our Kohana project 
using a few lines and the wonder of Git. Now, when we want to update our module to the 
newest release, we can just have Git go and retrieve the new commits, and we are good to 
go.
The rest of the setup is very similar to other modules we have used in this project already: 
we had to update the bootstrap, override a configuration file, and then use the module in 
our code.

Chapter 5
[ 159 ]
Sending email from our application may come in down the line, and this module will make 
it easier to implement. For full documentation and use of the module the readme file is 
included in the package, or we visit the project's home page at https://github.com/
themusicman/Mailer.
There are hundreds of modules out there for us to use, get ideas from, read, and play with. 
We are encouraged to fork this code and make our own or contribute back to modules 
that we find useful, or have bug fixes or feature requests for them. Most module authors 
appreciate any feedback, and a bug fix or bit of help along the way is usually very welcomed.
A good repository to follow that 'tracks' a lot of the modules available for Kohana 3 can 
be found at https://github.com/kolanos/kohana-universe, with a full list of 
the modules that are tracked available at https://github.com/kolanos/kohana-
universe/tree/master/modules. There is also a newer resource at http://kohana-
modules.com that tracks most of the public modules available.
Of course, if there is not a module out there that is suitable for our needs, we can always 
make our own. We can host our modules on GitHub, and by contacting Kohana, and making 
our module public, we may even get some free hosting for our module via the Kohana team 
if they find it stable, useful, and worth the space. Either way, creating modules is a great way 
to expand the framework and the community.
Creating your own modules
A module is just like another application directory that lives between the application and 
system layers in the cascading filesystem. With this in mind, creating a module is very simple. 
All we have to do is create a new directory in our modules directory with the name of the 
module we wish to create, and mimic the directory structure for an application.
It is important that you include an init.php file for routing, and then create classes, 
models, config files, etc. as needed to make our module work.
If our module could be used by the public, and does not contain proprietary code, we are 
encouraged to create a Git project and share the module with the Kohana community, we 
may just find a lot of people can use, and contribute to, our module and its stability, features, 
and general use.
Pop quiz – Working with Modules 
1.	 When adding or enabling a new module, the module needs to be added to the array 
passed to Kohana::modules() in which file?
a.	
/application/classes/controller.php
b.	 /application/bootstrap.php

Installing and Configuring Modules
[ 160 ]
c.	
.htaccess
d.	 index.php
2.	 Configuring a module with a config file requires you to do which of the following 
(choose one)?
a.	 Edit any files in the module's config file directly in the module directory
b.	 Nothing, all Kohana modules come preconfigured and require no special 
treatment
c.	
Override the config files in your /application/config directory
d.	 Create a new module and extend the one you want to customize
3.	 Which of the official bundled modules that ships with Kohana can be used to 
communicate with web services like those offered by Twitter and Google?
a.	 Auth Module
b.	 Image Module
c.	
ORM Module
d.	 oAuth Module
Summary
We learned a lot in this chapter about modules, from understanding the purpose of each of 
the core modules, to installing and creating new modules into our projects. We were able 
to install, configure, customize, and really get familiar with Kohana's module aspect, and we 
will quickly begin to build on our new knowledge as we begin to use the modules in our case 
study site.
In the next chapter, we will take a more detailed look at the Database and ORM modules, 
their use, and a more in depth look at some of the official modules that use and rely on 
these very important modules. Working with databases has never been more fun and easy, 
and in the next chapter, we will expand our case study website to make it work with dynamic 
data, user authentication, and related data.

6
Interacting with the Database
Dynamic web applications rely on data stores to provide constantly up-to-date information. 
MySQL is one of the most popular databases used with PHP, and working with a database is 
essential when building LAMP applications. This chapter will cover how Kohana works with 
MySQL using the Database module and Query Builder.
In this chapter, we will learn:


The Model in HMVC—how they work and how to use them


How to create our own models


How to extend models


Configuring the Database module


Using the Database module in our applications


Using the Query Builder to create programmatic SQL queries


How to implement database-driven sessions
Anatomy of a model
In the last chapter, we had the opportunity to create a model to use with the Database 
module. The model was simply a class that allowed us to manipulate data from the 
controller, and get data back to the controller. That is the basic function of a model: to act 
as the intermediary between our application and our data.
We have already learned how to create a view for the presentation layer and a controller 
to handle the application and requests; the only area really left is the data layer, and that is 
exactly what models are here to do.

Interacting with the Database
[ 162 ]
A properly built HMVC application will typically have large models compared to relatively 
small controllers. By placing all the methods needed to create and read database records in 
the message model, we made the controller action only a few lines long. Best of all, when 
another controller needs to get or add messages, the code is already written and accessible.
There are a few basic practices we will want to follow in order for our models to work. In the 
previous example, the code was provided for us, however, when we write our own models in 
the future, we will need to know what is necessary to make them work.
Creating models
Models should be located in the /application/classes/model/ directory and should 
have a filename that is the singular of the table name they represent. For example, if we 
have a table named `users`, we should name the file for our model, user.php. When 
we create the class definition for our model, it should be in the format of Model_ then 
the name of the model, in this case User. So, using the example `users` table, the class 
definition for user.php would be:
class Model_User
Once we have our model, we can create service methods to handle all the database queries 
in a nice, programmatic manner. In the previous chapter, we created methods to count, 
retrieve, create, and delete messages from a database, making it very easy to perform 
these actions from our controller while giving us one place for the code to live, where any 
controller that needs data from that domain can do so.
Like all other classes in Kohana, class inheritance plays a big part in how models work. 
Models can exist in the application, as well as in modules. An application can have several 
layers of models, and then can extend models in modules to inherit even more power. When 
we begin to use the ORM, for example, all our models that utilize it will need to extend the 
ORM model inside the module.
Creating and extending models in our applications is a task that will be very common, and 
will be responsible for most of the functionality of our applications. As we are exploring the 
database modules for Kohana, we will be creating and using models for every database table.
As we create, extend, and use these models, you should note how we try to place as much of 
the code as possible into model methods versus controller action methods. This will allow for 
more code reuse, and also give us a precise location to update and debug the application's 
data layer.

Chapter 6
[ 163 ]
Models provide us with a place to store all the interaction with a particular data set or 
conceptual entity in an application. This gives us a place to put our methods that perform 
activity associated with the data or entities in our applications, and promotes easy reuse 
while keeping our controller lean. If we think of the models as the places where the APIs for 
our application entities live, and where we put methods that act on data, then we will be 
using them properly.
Since we are using a database for our data layer, our models will usually interact directly 
with our database. In the case study site, like many common PHP applications, MySQL is the 
database server that will be used. As we learned in the last chapter, Kohana's Database and 
ORM modules both work with MySQL out of the box.
Using the Database module
In the last chapter, we enabled the Database module and provided the basic configuration 
necessary to get it up and running. In that example, the simplicity of the module was 
shown, and quickly we were manipulating a MySQL database table. A proper understanding 
of the module, its configuration, and the common methods used to use databases in our 
applications is important to have.
Configuring the Database module
When we merged the database configuration file by creating the file /application/
config/database.php, we created an array of options that are used to configure 
the module when it is run. Here, we set the default configuration for our development 
environment, and then allowed Kohana to connect using our specific settings.
Let's take a look at the default configuration file located at /modules/database/config/
database.php:
<?php defined('SYSPATH') or die('No direct access allowed.');
return array
(
   'default' => array
   (
      'type'       => 'mysql',
      'connection' => array(
         /**
          * The following options are available for MySQL:
          *
          * string   hostname     server hostname, or socket
          * string   database     database name
          * string   username     database username

Interacting with the Database
[ 164 ]
          * string   password     database password
          * boolean  persistent   use persistent connections?
          *
          * Ports and sockets may be appended to the hostname.
          */
         'hostname'   => 'localhost',
         'database'   => 'kohana',
         'username'   => FALSE,
         'password'   => FALSE,
         'persistent' => FALSE,
      ),
      'table_prefix' => '',
      'charset'      => 'utf8',
      'caching'      => FALSE,
      'profiling'    => TRUE,
   ),
   'alternate' => array(
      'type'       => 'pdo',
      'connection' => array(
         /**
          * The following options are available for PDO:
          *
          * string   dsn         Data Source Name
          * string   username    database username
          * string   password    database password
          * boolean  persistent  use persistent connections?
          */
         'dsn'        => 'mysql:host=localhost;dbname=kohana',
         'username'   => 'root',
         'password'   => 'r00tdb',
         'persistent' => FALSE,
      ),
      /**
       * The following extra options are available for PDO:
       *
       * string   identifier  set the escaping identifier
       */
      'table_prefix' => '',
      'charset'      => 'utf8',
      'caching'      => FALSE,
      'profiling'    => TRUE,
   ),
);

Chapter 6
[ 165 ]
As we can see, the returned array contains two keys, one for the default setting, and one 
for a setting named alternate. The default key holds an array of settings for a MySQL 
connection, while the alternate key holds an array of options for a PDO connection. If no 
database config key is specified, Kohana will look for, and load, the default settings.
To create an instance of our database object, we simply use the instance() static method.
$db = Database::instance();
This will create a new instance of the database class that has loaded the default 
configuration settings from the database config file. To load the alternate settings, 
we would pass the array key name into the instance method:
$db = Database::instance('alternate');
Now, the database object will load the alternate settings from the database configuration 
file. The case study site will only be connecting to one database, and most small applications 
only use one database connection, so the default configuration should be the only database 
group we will be using for small to medium size applications.
When we are using models to interact with the database, the system loads the default 
database group settings to use when we execute queries. This can be overridden in our 
application by setting the Database::$default property to the database group being used.
Now that we understand the configuration file, and how to use it to configure our default 
and any alternate database groups, it is time to begin using the module to interact with our 
data store.
The Database module offers two main avenues to run queries on our database. The first, 
more primitive route is through the Database_Query class, which provides an abstract 
interface for sending queries. The second method is the Query Builder, a class with a set of 
helpers designed to make creating queries more programmatic. First, we will take a look at 
the Database_Query class.
Creating and running queries
Because the Database module constructs any queries before connecting to the database, 
all queries are first assembled, and then when they are executed, the module makes the 
database connection and sends the queries. This approach, referred to as 'lazy loading', 
saves resources by not making unnecessary connections to the database.
When using the Database module, it is nice to know this. We will be building queries, and 
then executing them once they are ready. This will be true even when we move onto using 
the query builder, and is an important factor to keep in mind during development.

Interacting with the Database
[ 166 ]
To create queries, we must first get an instance of the Database_Query class. The 
constructor for this object requires two parameters: one for the type of query, and the 
second for the actual SQL statement. The $type, or first parameter, accepts one of the 
Database query types. These are constants defined in the abstract Kohana_Database 
class, and by default consist of the following class constants: SELECT, INSERT, UPDATE, 
and DELETE.
To create a new instance of the Database_Query class, we can pass the arguments and 
query as follows:
$query = new Database_Query(Database::SELECT, 'SELECT * FROM 
messages');
This will assign the following SQL statement to the variable $query. Printing the contents 
of $query will produce:
SELECT * FROM messages
To run this query, we would simply run the execute() method:
$query->execute();
The DB class provided with the Database module consists of methods designed to make 
using the module easy. The DB::query() static method accepts the same parameters as 
the Database_Query constructor, and returns a new instance of the Database_Query 
class. This convenient method allows us to chain our database query method as follows:
$query = DB::query(Database::SELECT, 'SELECT * FROM messages')-
>execute();
This would create the query in the exact same way, but it allows us to chain the execute 
method directly onto the query. DB::query() is most commonly used for creating and 
using Database_Query objects.
One of the best practices to prevent SQL injection attacks is to use prepared statements. We 
can accomplish this by creating a template query with parameters that are then inserted into 
the statement:
$query = DB::query(Database::SELECT, 'SELECT * FROM messages WHERE 
user_id = :user_id');
Now, we can set the :user_id parameter using the param() method like this:
$query->param(':user_id', 1);
Printing out the $query variable will now produce the following SQL query:
SELECT * FROM messages WHERE user_id = 1

Chapter 6
[ 167 ]
We could use dynamic data without worrying about SQL injection attacks using this method 
as follows:
$query = DB::query(Database::SELECT, 'SELECT * FROM messages WHERE 
user_id = :user_id');
$query->param(':user_id', (int) Arr::get($_POST, 'user_id'));
$query->execute();
This could also be written using method chaining:
$query = DB::query(Database::SELECT,
   'SELECT * FROM messages WHERE user_id = :user_id')
   ->param(':user_id', (int) Arr::get($_POST, 'user_id'))
   ->execute();
If we have a query with more than one parameter, the parameters() method allows for 
multiple parameters in a prepared statement to be passed at one time.
Consider the following DB::query() statement:
$query = DB::query(Database::SELECT,
   'SELECT * FROM messages WHERE user_id = :user_id AND date_published 
< :date_filter')
   ->param(':user_id',(int) Arr::get($_POST, 'user_id'))
   ->param(':date_filter',Arr::get($_POST, 'date_filter'))
   ->execute();
This could be rewritten using the parameters() method as follows:
$query = DB::query(Database::SELECT,
   'SELECT * FROM messages WHERE user_id = :user_id AND date_published 
< :date_filter')
   ->parameters(array(
      ':user_id'=>(int) Arr::get($_POST, 'user_id'),
      ':date_filter' =>Arr::get($_POST, 'date_filter')
   ))
   ->execute();
We can also bind parameters to references to variables by using the bind() method. This is 
very similar to the bind() method used for creating references for view variables. By using 
bind(), we can set a variable as the value for a prepared statement parameter, and then 
assign the final value to the parameter later in our script. Consider the following code:
$query = DB::query(Database::SELECT, 
   'SELECT * FROM messages WHERE user_id = :user_id AND date_published 
< :date_filter')
   ->bind(':user_id', $user_id)
   ->bind(':date_filter', $date_filter);

Interacting with the Database
[ 168 ]
$user_id = 1;
$date_published = time();
Printing the contents of $query will produce the following code:
SELECT * FROM messages WHERE user_id = 1 AND date_published 
<1308019508
Running the execute statement returns a Result object that implements the SPL iterator 
interface. This allows our result to be iterated, and each row in the result set to be accessed 
via this object. To print the user_id for every message in the database, we could do the 
following:
$query = DB::query(Database::SELECT, 
   'SELECT * FROM messages WHERE date_published < :date_filter')
   ->bind(':date_filter', $date_filter);
$date_filter= time();
$results = $query->execute();
foreach ($results as $result) {
   echo $result['user_id'];
}
This code will print the user_id of every row in the messages database table. Each iteration 
will contain an array of name value pairs for the query result. To have each result contain an 
object, we can use the as_object() method:
$query = DB::query(Database::SELECT, 
   'SELECT * FROM messages WHERE date_published < :date_filter')
   bind(':date_filter', $date_filter);
$date_filter = time();
$results = $query->as_object()->execute();
foreach ($results as $result) {
   echo $result->user_id;
}
Now, instead of using $result['user_id'] to access the user_id value, we can access the 
object property $result->user_id. The as_array() method is the opposing method to 
as_object().
Although the Database Query class is nice way to interact with the database, writing SQL 
queries longhand can have several disadvantages. For most queries that are used in web 
applications built with Kohana, the Query Builder lets us use a nice interface to create SQL 
queries for the Database Query class.

Chapter 6
[ 169 ]
Using the Query Builder
By using the methods provided by the Database module to build our database queries, we 
can take advantage of the abstraction to write database agnostic code. It is also worth noting 
that the Query Builder adds backticks to all our table and column names, as well as values. 
These quotes can be specific to the database server being used.
The Query Builder ships with four basic types of queries: select, insert, update, and delete. 
Each of these classes contains several methods to help us create the queries necessary to 
perform each of these functions.
Select statements
Building a select statement begins with the DB::select() method. This method begins the 
SQL SELECT statement for the appropriate database we are using by returning an instance of 
the Database_Query_Builder_Select class, which will make chaining methods possible:
$query = DB::select();
The above code will create the following query:
SELECT *
This method not only begins the query, it also accepts a list of column names that we would 
like to select. The following code will specify which columns we would like to be selected in 
the query:
$query = DB::select('user_id', 'content', 'date_published');
Printing the $query variable will show the following SQL query:
SELECT `user_id`, `content`, `date_published`
Notice the column names have been backticked for MySQL automatically by the Query 
Builder.
For a SELECT statement to properly function, a FROM clause is needed to tell the database 
from which table we are selecting data. The from() method accomplishes this for us by 
appending the FROM clause to our statement.
$query = DB::select('user_id', 'content', 'date_published')
   ->from('messages');
The above code will produce the following statement:
SELECT `user_id`, `content`, `date_published` FROM `messages`

Interacting with the Database
[ 170 ]
Once again, the Database Builder has automatically added the backticks, this time including 
the table name. Not only is the Query Builder making it easier to write SQL statements, it is 
ensuring the content is properly escaped and quoted.
If we have an array of column names from which we wish to select, there is no need to 
convert them to a comma separated, quoted string. The select_array() method will 
take an array of column names and treat it exactly the same way:
$columns = array('user_id', 'content', 'date_published');
$query = DB::select_array($columns)
   ->from('messages');
This will create the exact same statement as listed above.
To get more specific information from the database, it is common to use WHERE clauses to 
get the exact data in a result that we need. The where(), and_where(), and or_where() 
method allows us to accomplish this programmatically.
The where() methods all accept three parameters: the first is the column or alias name 
being searched on, the second is the operator to be used, and the last is the value being 
searched. Take the following query:
$query = DB::select('user_id', 'content', 'date_published');
$query->from('messages')
$query->where('user_id', '=', 1);
$query->and_where('date_published', '<', time());
This will produce the following query:
SELECT `user_id`, `content`, `date_published` 
   FROM `messages`
   WHERE `user_id` = 1 
      AND `date_published` < 1295742648
There, where() method is smart enough to know if there are more than one where(), it 
will append AND statements instead of adding more WHERE clauses. Consider this example, 
with chaining this time:
$query = DB::select('user_id', 'content', 'date_published')
   ->from('messages')
   ->where('user_id', '=', 1)
   ->where('date_published', '<', time());
This will produce the exact same query, and it nice as we could dynamically add where() 
methods without having to first check if one already exists.

Chapter 6
[ 171 ]
The or_where() method works in a similar manner:
$query = DB::select('user_id', 'content', 'date_published')
   ->from('messages')
   ->where('user_id', '=', 1)
   ->or_where('date_published', '<', time());
The above code will produce the following query:
SELECT `user_id`, `content`, `date_published` 
   FROM `messages`
   WHERE `user_id` = 1 
       OR `date_published` < 1295742971
Just like the where() method, the or_where() method is smart enough to know if more 
that one has been used, and it will not attempt to insert another WHERE statement into the 
clause. Take for example:
$query = DB::select('user_id', 'content', 'date_published')
   ->from('messages')
   ->where('user_id', '=', 1)
   ->or_where('date_published', '<', time())
   ->or_where('content', '=', 'some text');
The above code would produce:
SELECT `user_id`, `content`, `date_published` 
   FROM `messages`
   WHERE `user_id` = 1 
      OR `date_published` < 1295743085 
      OR `content` = 'some text'
As we can see, the second or_where() method simple produced an OR statement in the 
WHERE clause with the conditions you set. Also, the string 'some text' has been automatically 
quoted for us, where integers were not.
Sometimes, we have multiple conditionals that need to be adhered to in a WHERE clause. 
Consider a query where we want all messages with a user_id of 1 and a publish date that 
is over a week old OR a user_id of 2 with a publish date that is less than a week old.  The 
following query would not work:
$query = DB::select('user_id', 'content', 'date_published')
   ->from('messages')
   ->where('user_id', '=', 1)
   ->where('date_published', '>', time() - 604800)
   ->or_where('user_id', '=', 2)
   ->and_where('date_published', '<', time() - 604800)

Interacting with the Database
[ 172 ]
This would produce the following SQL:
SELECT `user_id`, `content`, `date_published` 
   FROM `messages` 
   WHERE `user_id` = 1 
   AND `date_published` > 1295142443 
   OR `user_id` = 2 
   AND `date_published` < 1295142443
This is not the query that we need. To retrieve the result set for which we are looking, it is 
necessary to wrap the two where clauses in braces. To accomplish this, the Query Builder 
provides open and closing braces for where(), or_where(), and and_where() methods 
that wrap groups of conditions in braces:
$query = DB::select('user_id', 'content', 'date_published')
   ->from('messages')
   ->where_open()
   ->where('user_id', '=', 1)
   ->and_where('date_published', '>', time() - 604800)
   ->where_close()
   ->or_where_open()
   ->where('user_id', '=', 2)
   ->and_where('date_published', '<', time() - 604800)
   ->or_where_close();
Now the query has been properly created with the WHERE clause correctly representing your 
desired conditions:
SELECT `user_id`, `content`, `date_published` 
   FROM `messages` 
   WHERE 
   (
      `user_id` = 1 
      AND `date_published` > 1295142668
   ) 
   OR 
   (
      `user_id` = 2 
      AND `date_published` < 1295142668
   )
By opening and closing where clauses, we can create queries that require multiple conditions 
in a clause. These methods are where_open(), where_close(), or_where_open(), 
or_where_close(), and_where_open(), and and_where_close(). By using these 
methods in conjunction with other where methods, we can create very specific queries that 
gather the exact data for which we are looking.

Chapter 6
[ 173 ]
Getting the right data is not always enough; sometimes we need it in a particular order. 
Ordering results is accomplished by the order_by() method, which creates the SQL ORDER 
BY clause. To add ordering to a query, we simply add the order_by() method as follows:
$query = DB::select('user_id', 'content', 'date_published')
   ->from('messages')
   ->where('user_id', '=', 1)
   ->order_by('date_published');
This would produce:
SELECT `user_id`, `content`, `date_published` 
   FROM `messages`
   WHERE `user_id` = 1 	
   ORDER BY `date_published`
The order_by() method's first parameter accepts the column to be ordered, and the 
second parameter determines the direction. We can also chain order_by() methods 
one after the other:
$query = DB::select('user_id', 'content', 'date_published')
   ->from('messages')
   ->where('user_id', '=', 1)
   ->order_by('date_published', 'ASC')
   ->order_by('user_id', 'DESC');
The above code will produce the following query:
SELECT `user_id`, `content`, `date_published` 
   FROM `messages` 
   WHERE `user_id` = 1 
   ORDER BY `date_published` ASC, `user_id` DESC
As we can see, the ORDER BY clause is in the order you specified, and it has the appropriate 
directions assigned to the proper tables, which have been quoted for you.
Apart from ordering results, it is important to limit the number of results that are returned. 
The SQL statement LIMIT accomplishes this, and it is created by the Query Builder using the 
limit() method. This method accepts an integer as its parameter, and will generate LIMIT 
statement for us:
$query = DB::select('user_id', 'content', 'date_published')
   ->from('messages')
   ->where('user_id', '=', 1)
   ->order_by('date_published', 'ASC')
   ->order_by('user_id', 'DESC')
   ->limit(10);

Interacting with the Database
[ 174 ]
This will produce the following query, limiting the result set to 10 rows:
SELECT `user_id`, `content`, `date_published` 
   FROM `messages` 
   WHERE `user_id` = 1 
   ORDER BY `date_published` ASC, `user_id` DESC 
   LIMIT 10
Along with LIMIT, OFFSET is used to create the starting point for the resultset. This is used 
in pagination and elsewhere, and is a common statement along with LIMIT. To create an 
offset, the Query Builder provides the offset() method, that also takes an integer as an 
argument.
$query = DB::select('user_id', 'content', 'date_published')
   ->from('messages')
   ->where('user_id', '=', 1)
   ->order_by('date_published', 'ASC')
   ->order_by('user_id', 'DESC')
   ->limit(10)
   ->offset(10);
This code will produce this SQL query:
SELECT `user_id`, `content`, `date_published`
   FROM `messages` 
   WHERE `user_id` = 1 
   ORDER BY `date_published` ASC, `user_id` DESC 
   LIMIT 10
   OFFSET 10
When we need to select data from more than one table, we need to JOIN the tables in the 
query. The Query Builder uses the join() and on() methods to accomplish this by creating 
the JOIN clauses:
$query = DB::select('user_id', 'content', 'date_published')
   ->from('messages')
   ->join('users')
   ->on('users.id', '=', 'messages.id');
The above code will produce:
SELECT `user_id`, `content`, `date_published` 
   FROM `messages` 
   JOIN `users` 
      ON (`users`.`id` = `messages`.`user_id`)

Chapter 6
[ 175 ]
The join() method accepts a second parameter for the join type. The second parameter 
is prepended to the JOIN statement. To create a LEFT JOIN, for instance, we would use 
join('table_name', 'LEFT'), likewise an INNER JOIN would be join('table_
name', 'INNER').
We can also create GROUP BY clauses using the group_by() method, and filter them using 
the having(), and_having(), and or_having() methods. These will produce grouping 
clauses in the same way the Database Builder has build all other statements for us. Another 
notable method is distinct(), which will add the DISTINCT selector to the query.
Using results
Once we have executed the select query for a Database object, we will need to know how to 
access the results in our applications. In the above example, we used the default returned 
object to iterate through the results of a query, and were able to see how the result could be 
returned as an array.
To further expand on how we can use the results of the Database module queries, we should 
know there are four main ways we can get our results: as a Result object (in our case a 
Database_MySQL_ResultObject), as an array, as a Standard Object, or as one row.
Take the following code for example:
$query = DB::select()
   ->from('messages')
   ->where('id', '<', 3);
$result = $query->execute();
This will return two results from our case study database, provided it has not been altered, 
and the $result variable will contain an instance of Database_MySQL_Result. When we 
iterate through the result object, each row's content will be stored in an array. To have the 
data accessible as an object, we can use the as_object() method like this:
$query = DB::select()
   ->from('messages')
   ->where('id', '<', 3);
$result = $query->as_object()->execute();
The as_array() method can be invoked on the executed object and convert the result to 
an array:
$query = DB::select()
   ->from('messages')
   ->where('id', '<', 3);
$result = $query->execute()->as_array();

Interacting with the Database
[ 176 ]
This will create a multi-dimensional array assigned to $result that looks like this:
array(2) {
  [0]=>
  array(4) {
    ["id"]=>
    string(1) "1"
    ["user_id"]=>
    string(1) "1"
    ["content"]=>
    string(22) "This is a test message"
    ["date_published"]=>
    string(10) "1292937495"
  }
  [1]=>
  array(4) {
    ["id"]=>
    string(1) "2"
    ["user_id"]=>
    string(1) "1"
    ["content"]=>
    string(35) "Another test message for the system"
    ["date_published"]=>
    string(10) "1292937511"
  }
}
By adding the as_object() method back to the pre-executed object, the result will now 
produce an array of Standard Objects with the results contained within. Let's look at the 
following code:
$query = DB::select()
   ->from('messages')
   ->where('id', '<', 3);
$result = $query->as_object()->execute()->as_array();
This will now make our array contain two objects, versus a nested array. This would allow 
us to access each column's data via an object property. Dumping the contents of $result 
would show an array of objects that looks like this:
array(2) {
  [0]=>
  object(stdClass)#29 (4) {
    ["id"]=>
    string(1) "1"
    ["user_id"]=>

Chapter 6
[ 177 ]
    string(1) "1"
    ["content"]=>
    string(22) "This is a test message"
    ["date_published"]=>
    string(10) "1292937495"
  }
  [1]=>
  object(stdClass)#30 (4) {
    ["id"]=>
    string(1) "2"
    ["user_id"]=>
    string(1) "1"
    ["content"]=>
    string(35) "Another test message for the system"
    ["date_published"]=>
    string(10) "1292937511"
  }
}
How we are using our results will largely depend on how we will want to retrieve them. 
Loading a lot of results into an array or Standard Class Object can take up a considerable 
amount of memory, which is saved by using the default result object.
The last way to retrieve data from your queries is to return only the first row. This is very 
useful when we only need one record. To get only the first record back from a query, use 
current() as follows:
$query = DB::select()
   ->from('messages')
   ->where('id', '<', 3);
$result = $query->execute()->current();
This will load $result with the following array, containing only the first row from the result 
set:
array(4) {
  ["id"]=>
  string(1) "1"
  ["user_id"]=>
  string(1) "1"
  ["content"]=>
  string(22) "This is a test message"
  ["date_published"]=>
  string(10) "1294113495"
}

Interacting with the Database
[ 178 ]
We can also get the result back as an object using the as_object() method:
$query = DB::select()
   ->from('messages')
   ->where('id', '<', 3);
$result = $query->as_object()->execute()->current();
The above code will return the Standard Class Object and assign it to $result:
object(stdClass)#31 (4) {
  ["id"]=>
  string(1) "1"
  ["user_id"]=>
  string(1) "1"
  ["content"]=>
  string(22) "This is a test message"
  ["date_published"]=>
  string(10) "1294113495"
}
Having multiple options on the way we want to get your data back from your queries is one 
of the nicer parts of the Database module, and picking the right type for the right situation 
can pay off when we are trying to accomplish different tasks. You are encouraged to use, try, 
and play with the Database module as much as possible; you will likely be using it in most 
apps.
One of the best parts about using the query builder over prepared statements or native SQL 
queries is the ability to make dynamic queries easily. By creating the query object, we can 
then add methods to manipulate the query based on a variety of factors.
In the case study site, the user messages controller is far from complete. Right now, the code 
just has an array that illustrates how the URI can be used to determine the user's ID, and 
then sends data to the view based on the contents of the URI.
To make the queries necessary to get all messages from a user, we have a couple of choices. 
First, we can create a new method in our Message model that gets all messages for a user, 
and leave the get_all() method to retrieve all messages from the system.
The second, and easier, option is to refactor the get_all(), which currently accepts a 
limit and offset as parameters. By adding a third, optional, parameter for user_id, and 
then adding the WHERE clause only when needed, we can begin to harness the power of 
the Query Builder.

Chapter 6
[ 179 ]
Time for action – Refactoring Model_Message to allow 
dynamic search
1.	 First, we will need to update our Message model located at /
application/classes/model/message.php by opening it 
for editing and making the following changes (highlighted):
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
/**
 * Message Model
 * Handles CRUD for user messages
 */
class Model_Message {
   
   // Table name used by this model
   protected $_table = ‘messages’;
   
   /**
    * Gets all messages
    *
    * @param    int     $limit
    * @param    int    $offset
    * @param    int    $user_id
    * @return   array
    */ 
   public function get_all($limit = 10, $offset = 0, $user_id = 
null)
   {
      $query = DB::select()
         ->from($this->_table)
         ->order_by('date_published', 'DESC')
         ->limit($limit)
         ->offset($offset);
      if ($user_id) 
      {
         $query->where(‘user_id’, ‘=’, (int) $user_id);
      }
      return $query->execute()->as_array();
   }
   

Interacting with the Database
[ 180 ]
   /**
     * Counts all messages
    * 
    * @param	 	
int	
	
$user_id [OPTIONAL]
    * @return 	
int
    */
   public function count_all($user_id = null) 
   {
      $query = DB::select(DB::expr(‘COUNT(*) AS message_count’))
         ->from($this->_table);
      if ($user_id) 
      {
         $query->where(‘user_id’, ‘=’, (int) $user_id);
      }
      return $query->execute()->get(‘message_count’);
   }
}
2.	 Now, we will need to refine our controller action to incorporate the Message 
model, the Pagination module, and handle the new results properly. We will need 
to open the User_Messages controller for editing located at /application/
classes/controller/user/messages.php, and change the code as follows:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
class Controller_User_Messages extends Controller_Application 
{
   public function action_get_messages() 
   {
      $messages = new Model_Message;
      
      $user_id = $this->request->param(‘id’);
      
      $message_count = $messages->count_all($user_id);
      
      $pagination = Pagination::factory(array(
         ‘total_items’    => $message_count,
         ‘items_per_page’ => 3,
      ));
      
      $pager_links = $pagination->render();
      
      $messages = $messages->get_all($pagination->items_per_page,
   $pagination->offset, $user_id);
      

Chapter 6
[ 181 ]
      $this->template->content = View::factory(‘profile/messages’)
         ->set(‘messages’, $messages)
         ->set(‘pager_links’, $pager_links);
   }
      
}
3.	 With the controller using new view variables, and the pagination class in place, 
we will need to update our view script. Open and edit the file located at /
application/views/profile/messages.php and make these changes:
<?php foreach ($messages as $message) : ?>
   <p class=”message”>
      <?php echo $message[‘content’]; ?>
      <br />
      <span class=”published”>
         <?php echoDate::fuzzy_span($message[‘date_published’])?>
      </span>
   </p>
   <hr />
<?php endforeach; ?>
<?php echo $pager_links; ?>
4.	 Be sure to save all changed files. Now, for the sake of testing, let's load the 
messages table with some more messages. We can run the following INSERT 
statement on our database, or simply fill it up with some random data of our own; 
just make sure there are a few messages for every user:
INSERT INTO `messages` (`id`,`user_id`,`content`,`date_published`)
VALUES
   (null, 2, 'Narwhals are cool', UNIX_TIMESTAMP()),
   (null, 2, 'Narwhals are really the bomb', UNIX_TIMESTAMP()),
   (null, 2, 'Also, I really like bacon', UNIX_TIMESTAMP()),
   (null, 3, 'MMMmmm, bacon.', UNIX_TIMESTAMP()),
   (null, 3, 'MMMmmm, purple...', UNIX_TIMESTAMP()),
   (null, 3, 'MMMmmm, Narwhal bacon', UNIX_TIMESTAMP()),
   (null, 3, 'MMMmmm, purple Narwhal bacon', UNIX_TIMESTAMP()),
   (null, 3, 'Mmm purple Narwhal bacon and syrup', UNIX_
TIMESTAMP()),
   (null, 2, ‘Is syrup better than jelly?’, UNIX_TIMESTAMP());

Interacting with the Database
[ 182 ]
5.	 Now, we can point our browser to http://localhost/egotist/messages/
get_messages/X, where X is the user_id of the messages we wish to view. To see 
the messages for the user with an ID of 2, just visit http://localhost/egotist/
messages/get_messages/2, and you should see something similar to this:
6.	 Next, we can test the script by looking at user ID 3 by altering the URL to 
http://localhost/egotist/messages/get_messages/3, and 
we should see something like this:

Chapter 6
[ 183 ]
7.	 Finally, the home page is getting all messages, and does not pass the user ID. 
To make sure that it is still working, browse over to http://localhost/
egotist/, and you should see the home page working as normal, 
just with more pages for messages.

Interacting with the Database
[ 184 ]
What just happened?
First, we had to refactor the message model to allow for the user_id to be passed into our 
model methods, and then optionally include it in our searches, depending on whether or not 
it is set. By setting the default value on the $user_id variable to null, we are allowing our 
methods to serve two purposes: to either return all messages, or all messages based on a user.
To accomplish this, we had to alter our Query Builder object to chain all the methods we 
knew we would need, then conditionally add the where() method only when needed, and 
then return the executed query result.
Not only did we add the optional user_id to the get_all() method when we refactored 
the class, we also added it to our new count_all() method. Without getting the right 
number of rows being returned for the set, the pagination module would not know the 
proper number of results to paginate. Now, when only messages for a particular user are 
returned, the count will match the number of results.
The rest of the model has been deleted for now, allowing for the Query Builder to be more 
adequately used during the rest of this chapter. Don't worry, the other methods will be 
returning soon.
Once we had the model all worked out, we had to update our controller action to ask for the 
user_id from the Request class, and then pass the $user_id into your count_all() and 
get_all() method requests. By implementing the pager, then setting the view variables, 
our user messages page now has pagination, and our model has two methods that can serve 
multiple purposes.
Updating the view script only required a few lines of code, adding the 
$message['content'] display and the pagination links. Using the database module with 
Kohana has made this additional functionality very easy to implement.
It is good to be able to use the Query Builder to create select statements for your queries, 
but without the ability to insert data there would be nothing to select. The next portion of 
the Query Builder we will need to know how to use is how to create and execute INSERT 
queries.
Have a go hero – Adding new messages page using query builder
Now that you have some working example of using the query builder to select and return 
results, and you know how to add controller actions and named routes, it is time to create 
some additional functionality for the case study site. By adding a new page at http://
localhost/egotist/new, your users can see all new posts from the last 24 hours. Add 
a new controller action to the existing User Messages Controller, and modify the Message 
Model to accommodate this change. You will also need to add a new named route to the 
bootstrap to handle the request properly.

Chapter 6
[ 185 ]
Insert statements
Much like the DB::select() method creates the chainable Database_Query_Builder_
Select object, the DB::insert() does a similar job building INSERT statements using 
the Database_Query_Builder_Insert class. The insert() method accepts two 
parameters, the first for the table name, and the second for the values:
$query = DB::insert('messages', array('user_id', 'content', 'date_
published'));
The above code will create a new Query Builder Insert object that will create the following 
SQL query:
INSERT INTO `messages` (`user_id`, `content`, `date_published`)
   VALUES
Obviously this statement is not complete. Without values to insert into the table, the 
INSERT query is useless. To add values to the object, use the values() method:
$query = DB::insert('messages',array(
      'user_id', 
      'content', 
      'date_published'
   ))->values(array(1, 'Test Content', time()));
This will add the values to the query:
INSERT INTO `messages` (`user_id`, `content`, `date_published`) 
   VALUES (1, 'Test Content', 1295750628)
As we can see, the complete query has been assembled, and all proper backticks, quotes, 
and necessary escaping have been automatically added for us.
We can also use the select() method to create sub-queries where the results are used 
as a value for the INSERT. Like other Database module queries, we run the query object 
by calling the execute() method.
Time for action – Adding the ability to insert messages in 
case study site
Up until now, all messages for the case study site have had to be directly inputted into the 
database. Our users are going to need a way to add messages via the web interface, and 
using the query builder is a nice way to add this functionality.

Interacting with the Database
[ 186 ]
1.	 First, we will need to add (or update if you did not remove in last example) the add 
method in the Message model to allow for new messages to be inserted into 
the database using the Query Builder. To accomplish this, open the model at 
/application/classes/model/message.php, and add the following method 
to the top of the class, so the class should resemble this (highlighted code is from 
last chapter):
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
/**
 * Message Model
 * Handles CRUD for user messages
 */
class Model_Message {
   
   // Table name used by this model
   protected $_table = ‘messages’;
   
   /**
    * Adds a new message for a user
    * 
    * @param   int      user_id
    * @param   string   user’s message
    * @return  Database
    */ 
   public function add($user_id, $content) 
   {
      $data = array(‘user_id’, ‘content’, ‘date_published’);
            
      return DB::insert($this->_table, $data)
          ->values(array($user_id, $content, time()))
          ->execute();
   }
   
   /**
    * Gets all messages
    *
    * @param   int   $limit
    * @param   int   $offset
    * @param   int   $user_id
    * @return  array    */ 
   public function get_all($limit = 10, $offset = 0, $user_id = 
null)

Chapter 6
[ 187 ]
   {
      $query = DB::select()
          ->from($this->_table)
          ->order_by(‘date_published’, ‘DESC’)
          ->limit($limit)
          ->offset($offset);
      if ($user_id) 
       {
         $query->where(‘user_id’, ‘=’, (int) $user_id);
      }
      return $query->execute()->as_array();
   }
   
   /**
    * Counts all messages
    * 
    * @param	 	
int	
	
$user_id
    * @return	int
    */
   public function count_all($user_id = null) 
   {
      $query = DB::select(DB::expr(‘COUNT(*) AS message_count’))
         ->from($this->_table);
       if ($user_id) 
      {
         $query->where(‘user_id’, ‘=’, $user_id);
      }
      return $query->execute()->get(‘message_count’);
   }
   
}
2.	 Next, we will need to update the controller located at /application/classes/
controller/user/messages.php, and edit it to include an action for adding 
messages (new code highlighted):
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
class Controller_User_Messages extends Controller_Application {
   public function action_index()
   {      
       URL::redirect();

Interacting with the Database
[ 188 ]
   }
   public function action_get_messages() 
   {
      $messages = new Model_Message;
      
      $user_id = $this->request->param(‘id’);
      
      $message_count = $messages->count_all($user_id);
      
      $pagination = Pagination::factory(array(
         ‘total_items’    => $message_count,
         ‘items_per_page’ => 3,
      ));
      
      $pager_links = $pagination->render();
      
      $messages = $messages->get_all($pagination->items_per_page, 
$pagination->offset, $user_id);
      
       $this->template->content = View::factory(‘profile/
messages’)
         ->set(‘messages’, $messages)
         ->set(‘pager_links’, $pager_links);
   }
      
   public function action_add() 
   {
      $messages = new Model_Message;
      
      $user_id = $this->request->param(‘id’);
      
      $this->template->content = View::factory(‘profile/message_
form’);
      
      if (isset($_POST[‘content’]))
      {
         $messages->add($user_id, (string) $_POST[‘content’]);
         $redirect = URL::site(“messages/get_messages/$user_id”);
         Request::instance()->redirect($redirect);
      }   
      
   }
}

Chapter 6
[ 189 ]
3.	 Now that the controller and model are ready, we can create a quick view script to 
create the form and submit it back to your controller. Create a new file in 
/application/views/profile/, and name it message_form.php. Open 
this new file, and create the following script:
<h2>Add New Message</h2>
<?php echo Form::open(); ?>
   <div class=”field”>
      <?php echo Form::textarea(‘content’); ?>
   </div>
   <div class=”field”>
       <?php echo Form::submit(‘add_message’, ‘Create New 
Message’); ?>
   </div>
<?php echo Form::close(); ?>
4.	 Finally, modify the bootstrap.php route to update the user-messages, and add 
a route for user-add-messages routes like this:
Route::set(‘user-messages’, ‘messages/get_
messages(/<id>(/<optional>))’, array(‘id’ => ‘[0-9]+’, ‘optional’ 
=> ‘.*’))
   ->defaults(array(
      ‘directory’ => ‘user’,
      ‘controller’ => ‘messages’,
      ‘action’     => ‘get_messages’
   ));
   
Route::set(‘user-add-message’, ‘messages/add(/<id>)’, array(‘id’ 
=> ‘[0-9]+’))
   ->defaults(array(
       ‘directory’ => ‘user’,
       ‘controller’ => ‘messages’,
       ‘action’     => ‘add’
   ));

Interacting with the Database
[ 190 ]
5.	 Now, we can point our browser to http://localhost/egotist/messages/
add/X, where X is the user_id for which we want to add a message. We can test 
with user 2 by browsing to http://localhost/egotist/messages/add/2:
6.	 After submitting the form, the new message is added, and we are redirected to 
the messages page for user 2. You should see a new message located in the 
message stream for user 2 after testing the form:

Chapter 6
[ 191 ]
What just happened?
Creating the add() method in our Message model really illustrates how the query builder 
can make working with the database very elegant and simple. The DB::insert() method 
sets up the table and column names, and the values() method assembles the array of data 
to be inserted, then the query is executed, and our row is added.
After our model method was created, we needed to create the controller action for the 
add page. In this action we are really just checking if the $_POST variable is set, and if it 
is, we are invoking the add() method on the Message model, and passing the relevant 
information. After the database update is complete, our visitor is redirected back to their 
message list, where they can view their newly created message.
Although this action is very minimal, and is not complete in the aspect there is no form 
validation, security, and other basics that would normally be used with forms, like error 
handling and messages, but we are trying to concentrate on database manipulation more 
than form handling. In a production environment, we would certainly want to spend 
some more time making this controller more robust, making the user_id pulled from an 
authorized source, etc.
Next, we needed to create a view script to display the form for adding messages. By using 
the Form helper class, we created a form very quickly, with minimal code. This renders a 
form with the entire HTML for our users to quickly add their messages.

Interacting with the Database
[ 192 ]
Adding a route to the bootstrap to allow for the adding of messages should be pretty 
self-explanatory at this point, but it is required for the custom URL, and makes sure our 
users are going to the right place.
With a small amount of code, the form, database, controller action, route, and basic logic 
required to add messages to our database has all come together. Now that users can add 
messages, there is a good chance they are going to want the ability to edit them soon.
Updating statements
Like the other Query Builder classes, the Database_Query_Builder_Update class can be 
accessed via the DB class using the static method update(). This method accepts the table 
name as a parameter, and will begin the creation of the UPDATE SQL query:
$query = DB::update('messages');
The above code will create the following query:
UPDATE `messages`
To set records to new values, we are given the set() method. Set accepts an array of 
column names and values that will be updated in the database table. To update the 
content row in the messages table, we could build the query like this:
$query = DB::update('messages')->set(array(
      'content' => 'New Content'
   ));
This will create a query with the SET clause completed:
UPDATE `messages` 
   SET `content` = 'New Content'
This query would update every row setting the content column with the value "New 
Content". If we only wanted to update the messages row with an ID of 2, we could add a 
where() method to create a WHERE clause.
$query = DB::update('messages')->set(array(
      'content' =>'New Content'
   ))
   ->where('id', '=', 2);
This will produce the following SQL statement:
UPDATE `messages` 
   SET `content` = 'New Content' 
   WHERE `id` = 2

Chapter 6
[ 193 ]
The same methods that are available to you to refine a SELECT query are available in our 
UPDATE queries, also. We can use all the where(), or_where(), and_where(), and their 
open and close methods, we can create prepared statements and use the param() and 
parameters() methods, and we can use bind() to create references to variables that we 
can set prior to an execute().
These methods can be combined to create just about any UPDATE query that we would 
use for our applications. Like other Query Builder objects, the query is not run until the 
execute() method is invoked. This allows us to set any variables we have created via 
prepared statements, bind(), or to alter the query dynamically by adding conditional 
clauses as needed prior to running the query.
Time for action – Add ability to edit messages in case study site
When a user submits a message on our case study site, they may want to edit it. We can add 
the ability to edit messages for the first fifteen minutes they are posted. Until we have a user 
authorization and session system in place, we will have to rely on the URI to know which user 
is currently using the system. Although this is impractical in a real world scenario, this works 
fine for the example.
1.	 First, we will need the ability to get a single message, and the ability to update 
the message in the database. To accomplish this, our Message model will need 
a couple of more methods. Add the get_message() and edit() methods to 
our model in /application/classes/model/message.php so it looks like 
this (changes are highlighted):
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
/**
 * Message Model
 * Handles CRUD for user messages
 */
class Model_Message {
   
   // Table name used by this model
   protected $_table = ‘messages’;
   
   /**
    * Adds a new message for a user
    * 
    * @param   string   user_id
    * @param   string   user’s message
    * @return  Database
    */ 

Interacting with the Database
[ 194 ]
   public function add($user_id, $message) 
   {
      $data = array(‘user_id’, ‘content’, ‘date_published’);
      
      return DB::insert($this->_table, $data)
         ->values(array($user_id, $message, time()))
         ->execute();
   }
   
   /**
    * Updates a message
    * 
    * @param  int	
	
message_id
    * @param  string	
content
    * @return Database
    */
   public function edit($message_id, $content) 
   {
      return DB::update($this->_table)
         ->set(array(
            ‘content’ => $content
         ))
         ->where(‘id’, ‘=’, $message_id)
         ->execute();
   }
   
   /**
    * Gets a message based on id
    * 
    * @param 	int	
	
message_id
    * @return 	
Database
    */
   public function get_message($message_id) 
   {
      return DB::select()
         ->from($this->_table)
         ->where(‘id’, ‘=’, $message_id)
         ->execute()
         ->current();
   }
   

Chapter 6
[ 195 ]
   /**
    * Gets all messages
    *
    * @param	 int	
$limit
    * @param	 int	
$offset
    * @param	 int	
$user_id
    * @return  array
    */ 
   public function get_all($limit = 10, $offset = 0, $user_id = 
null)
   {
      $query = DB::select()
         ->from($this->_table)
         ->order_by(‘date_published’, ‘DESC’)
         ->limit($limit)
         ->offset($offset);
      if ($user_id) 
      {
         $query->where(‘user_id’, ‘=’, (int) $user_id);
      }
      
       return $query->execute()->as_array();
   }
   
   /**
     * Counts all messages
    * 
    * @param	 int	
$user_id [OPTIONAL]
    * @return 	
int
    */
   public function count_all($user_id = null) 
   {
      $query = DB::select(DB::expr(‘COUNT(*) AS message_count’))
         ->from($this->_table);
      if ($user_id) 
      {
         $query->where(‘user_id’, ‘=’, (int) $user_id);
      }
      return $query->execute()->get(‘message_count’);
   }

Interacting with the Database
[ 196 ]
      
}
2.	 Next, we will need a controller action to handle the request. Update the 
User Messages controller at /application/classes/controller/
user/messages.php, so it contains the new action_edit() method:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
class Controller_User_Messages extends Controller_Application {
   public function action_index()
   {
       URL::redirect();
   }
   public function action_get_messages() 
   {
      $messages = new Model_Message;
      $user_id = $this->request->param(‘id’);
      $message_count = $messages->count_all($user_id);
      $pagination = Pagination::factory(array(
         ‘total_items’    => $message_count,
         ‘items_per_page’ => 3,
      ));
      $pager_links = $pagination->render();
      $messages = $messages->get_all($pagination->items_per_page, 
$pagination->offset, $user_id);
      $this->template->content = View::factory(‘profile/messages’)
         ->set(‘messages’, $messages)
         ->set(‘pager_links’, $pager_links);
   }
   public function action_add() 
   {
      $messages = new Model_Message;
      $user_id = $this->request->param(‘id’);
      $this->template->content = View::factory(‘profile/message_
form’);
      if ($_POST && $_POST[‘content’])
      {
         $messages->add($user_id, $_POST[‘content’]);

Chapter 6
[ 197 ]
         $redirect = url::site(“messages/get_messages/$user_id”);
         Request::instance()->redirect($redirect);
      }      
      
   }
   public function action_edit() 
   {
      $user_id = $this->request->param(‘user_id’);
      $message_id = $this->request->param(‘message_id’);
      $messages = new Model_Message;
      $message = $messages->get_message($message_id);
      if ($message[‘user_id’] != $user_id) {
         throw new Exception(“User is not owner of the message”);
      }
      $this->template->content = View::factory(‘profile/message_
form’)
         ->bind(‘value’, $message[‘content’]);
      if ($_POST && $_POST[‘content’])
      {
         $messages->edit($message_id, $_POST[‘content’]);
         $redirect = url::site(“messages/get_messages/$user_id”);
         Request::instance()->redirect($redirect);
      }
   }
}
3.	 Now, we can update the /application/views/profile/message_
form.php file to accommodate both creating and modifying messages:
<?php $form_type = Request::instance()->action == ‘add’ ? ‘Create 
New’ : ‘Edit’ ?>
<h2><?php echo $form_type; ?> Message</h2>
<?php echo Form::open(); ?>
   <div class=”field”>
     <?php $body = isset($value) ? $value : ‘’; ?>
     <?php echo Form::textarea(‘content’, $body); ?>
   </div>
   <div class=”field”>

Interacting with the Database
[ 198 ]
      <?php echo Form::submit(‘message_form’, “$form_type 
Message”); ?>
   </div>
<?php echo Form::close(); ?>
4.	 Next, we will need to add a route to our /application/bootstrap.php 
file so the user will go to the proper page. Add this route below your 
'user-add-message' route:
Route::set('user-edit-message', 'messages/edit(/<user_
id>(/<message_id>))', array('id' => '[0-9]+'))
   ->defaults(array(
      'directory' => 'user',
      'controller' => 'messages',
       'action'     => 'edit'
   ));
5.	 Lastly, we need to add a link that is displayed for the first 15 minutes 
a new message is posted. Edit the messages view at /application/
views/profile/messages.php to include an edit link:
<?php foreach ($messages as $message) : ?>
   <p class=”message”>
      <?php echo $message[‘content’]; ?>
      <br />
      <span class=”published”><?php echo Date::fuzzy_
span($message[‘date_published’])?></span>
      <?php if (time() - $message[‘date_published’] < 900) : ?>
         <div class=”options”>
            <a href=”<?php echo url::site(“messages/edit/
{$message[‘user_id’]}/{$message[‘id’]}”) ?>”>Edit Message</a>
         </div>
      <?php endif; ?>
   </p>
   <hr />
<?php endforeach; ?>
<?php echo $pager_links; ?>
6.	 Now, we can point our browser to http://localhost/egotist/messages/
get_messages/2, and we should see a new user message for user 2. If it 
has been more than 15 minutes, create a new message to view the link.

Chapter 6
[ 199 ]
7.	 By clicking the Edit Message link, you can now edit the message:

Interacting with the Database
[ 200 ]
8.	 After making changes and submitting the form, the message is now appearing 
as updated:
What just happened?
To take advantage of the Query Builder update functions, we first needed to create a method 
in our Message model to house the query. The new edit() method updates the table with 
the new content, based on the message_id, and then executes the query. This method will 
be called from your controller action when the form is submitted.
We also had to create a new method to retrieve the data from one row containing the 
message being updated. This method will allow us to pre-populate the form with the 
inherent data. Once these two methods were created, we had to create a controller action 
to handle the update request.
In our new action_edit() method, we retrieved the user_id and message_id from 
the URI via the Request object. Then, we created a new instance of our Message model, and 
invoked the get_message() method to retrieve the messages that is being updated. We 
quickly check that the user is the owner of the message and throw an exception if they are 
not the same. This is far from enough security, and the form, like the add message form, is 
the bare bones code necessary to illustrate the Database module's features.

Chapter 6
[ 201 ]
Next, we test whether the form has been submitted, and if it has, we invoke the edit() 
method of the Message model and pass it the new message content for the message_id 
being updated. Once the query has been run, we are redirecting your users back to their 
message queue.
Again, we created a custom route to allow for a nice URL and the ability to obtain the 
message_id and user_id via the URI. After we made this change, there was only a couple 
of things left to get the update feature working: we needed to create a link to the update 
form, and modify the user form to allow for adding and updating.
By adding a check to the age of the message, and then adding a link to the update page for 
the message, we have created a way for our users to reach the form. Instead of creating 
a new view script to house the form, we were able to modify the existing view for adding 
messages to make is compatible with both new, and edited, messages.
Now that our users can add, view, and update messages, the next logical step is to allow 
them to delete messages in the same way they can update them.
Delete statements
Deleting data from the database is as important as selecting, updating, or inserting data. 
To round out the Query Builder, the Database module has a method to instantiate the 
Database_Query_Builder_Delete class, with methods designed to creating DELETE 
SQL queries in the same way other queries have been created so far.
$query = DB::delete('messages');
The above code will create the following query:
DELETE FROM `messages`
Now, we can refine the query by adding clauses to narrow the resultset of the query, and 
delete the exact row(s) we want. To delete a message with the ID of 3, we could do this:
$query = DB::delete('messages')->where('id', '=', 3);
This would create the following SQL query:
DELETE FROM `messages` 
   WHERE `id` = 3
Just like DB::update(), the delete() method can be chained with most of the methods 
that are available to DB::select(), making it easy to create SQL queries to delete rows 
from your databases programmatically.

Interacting with the Database
[ 202 ]
Time for action – Add ability to delete messages from the 
case study site
In the case study application, the ability to edit messages for the first 15 minutes allows 
users to make corrections to their posts while they are still new. It would be nice if they had 
the ability to delete the message for the first 15 minutes also.
1.	 First, the model needs a way to delete the record from the database. 
Create a new method in /application/classes/controller/
user/message.php and name it action_delete(). After adding 
the code to the method, our model should look like this:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
/**
 * Message Model
 * Handles CRUD for user messages
 */
class Model_Message {
   
   // Table name used by this model
   protected $_table = 'messages';
   
   /**
    * Adds a new message for a user
    * 
    * @param   string   user_id
    * @param   string   user's message
    * @return  Database
    */ 
   public function add($user_id, $message) 
   {
      $data = array('user_id', 'content', 'date_published');
      
      return DB::insert($this->_table, $data)
         ->values(array($user_id, $message, time()))
         ->execute();
   }
   
   /**
    * Updates a message
    * 
    * @param  int	
	
message_id
    * @param  string	
content

Chapter 6
[ 203 ]
    * @return Database
    */
   public function edit($message_id, $content) 
   {
      return DB::update($this->_table)
         ->set(array(
            'content' => $content
         ))
         ->where('id', '=', $message_id)
         ->execute();
   }
   
   /**
    * Gets a message based on id
    * 
    * @param 	int	
	
message_id
   * @return 	Database
    */
   public function get_message($message_id) 
   {
      return DB::select()
         ->from($this->_table)
         ->where('id', '=', $message_id)
         ->execute()
         ->current();
   }
   
   /**
    * Gets all messages
    *
    * @param	 int	
$limit
    * @param	 int	
$offset
    * @param	 int	
$user_id
    * @return  array
    */ 
   public function get_all($limit = 10, $offset = 0, $user_id = 
null)
   {
      $query = DB::select()
         ->from($this->_table)
         ->order_by('date_published', 'DESC')
         ->limit($limit)

Interacting with the Database
[ 204 ]
         ->offset($offset);
   
      if ($user_id) 
      {
          $query->where('user_id', '=', (int) $user_id);
      }
      
      return $query->execute()->as_array();
   }
   
   /**
     * Counts all messages
    * 
    * @param	 int	
$user_id [OPTIONAL]
    * @return 	
int
    */
   public function count_all($user_id = null) 
   {
      $query = DB::select(DB::expr('COUNT(*) AS message_count'))
         ->from($this->_table);
      
      if ($user_id) 
      {
         $query->where('user_id', '=', (int) $user_id);
      }
      return $query->execute()->get('message_count');
   }
   
   /**
    * Deletes a message from the DB
    * 
    * @param   int   id
    * @return  Database
    */ 
   public function delete($id)
   {
      return DB::delete($this->_table)
         ->where('id', '=', $id)
         ->execute();
   }
      
}

Chapter 6
[ 205 ]
2.	 Next, you can add the action_delete() method to the user message controller. 
After editing, the file should look like this, with the new code highlighted:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
class Controller_User_Messages extends Controller_Application {
   public function action_index()
   {
       URL::redirect();	
   }
   public function action_get_messages() 
   {
      
      $messages = new Model_Message;
      
      $user_id = $this->request->param(‘id’);
       
       $message_count = $messages->count_all($user_id);
       
      $pagination = Pagination::factory(array(
         ‘total_items’    => $message_count,
         ‘items_per_page’ => 3,
      ));
      
      $pager_links = $pagination->render();
      
      $messages = $messages->get_all($pagination->items_per_page, 
$pagination->offset, $user_id);
   
      $this->template->content = View::factory(‘profile/messages’)
         ->set(‘messages’, $messages)
         ->set(‘pager_links’, $pager_links);
   }
   
   public function action_add() 
   {
       $messages = new Model_Message;
       
       $user_id = $this->request->param(‘id’);
       
       $this->template->content = View::factory(‘profile/message_
form’);
      
      if (isset($_POST[‘content’]))
      {
         $messages->add($user_id, (string) $_POST[‘content’]);
         $redirect = URL::site(“messages/get_messages/$user_id”);
         Request::instance()->redirect($redirect);

Interacting with the Database
[ 206 ]
      }
      
   }
      
   public function action_edit() 
   {
      
      $user_id = $this->request->param(‘user_id’);
      
      $message_id = $this->request->param(‘message_id’);
      
      $messages = new Model_Message;
      
      $message = $messages->get_message($message_id);
      
      if ($message[‘user_id’] != $user_id) {
         throw new Exception(“User is not owner of the message”);
      }
      
      $this->template->content = View::factory(‘profile/message_
form’)
         ->bind(‘value’, $message[‘content’]);
      
      if ($_POST && $_POST[‘content’])
      {
         $messages->edit($message_id, $_POST[‘content’]);
         $redirect = url::site(“messages/get_messages/$user_id”);
         Request::instance()->redirect($redirect);
      }      
      
   }
      
   public function action_delete() 
   {
      
      $user_id = $this->request->param(‘user_id’);
      
      $message_id = $this->request->param(‘message_id’);
      
      $messages = new Model_Message;
      
      $message = $messages->get_message($message_id);
      
      if ($message[‘user_id’] != $user_id) {
         throw new Exception(“User is not owner of the message”);
      }
      
      $messages->delete($message_id);
      
      $redirect = url::site(“messages/get_messages/$user_id”);
      Request::instance()->redirect($redirect);
      
   }

Chapter 6
[ 207 ]
   
}
3.	 Now, we need to add a link to the listings in the view script. Open and 
edit the view file at /application/views/profile/messages.
php, and add the link. The complete file should look like this:
<?php foreach ($messages as $message) : ?>
   <p class=”message”>
      <?php echo $message[‘content’]; ?>
      <br />
      <span class=”published”><?php echo Date::fuzzy_
span($message[‘date_published’])?></span>
      <?php if (time() - $message[‘date_published’] < 900) : ?>
         <div class=”options”>
            <a href=”<?php echo url::site(“messages/edit/
{$message[‘user_id’]}/{$message[‘id’]}”) ?>”>Edit Message</a> | 
            <a href=”<?php echo url::site(“messages/delete/
{$message[‘user_id’]}/{$message[‘id’]}”) ?>”>Delete Message</a>
         </div>
      <?php endif; ?>
   </p>
   <hr />
<?php endforeach; ?>
<?php echo $pager_links; ?>
4.	 Lastly, add a route in the /application/bootstrap.php file under the 
'user-edit-message' route:
Route::set(‘user-delete-message’, ‘messages/delete(/<user_
id>(/<message_id>))’, array(‘id’ => ‘[0-9]+’))
   ->defaults(array(
      ‘directory’ => ‘user’,
      ‘controller’ => ‘messages’,
      ‘action’     => ‘delete’
   ));

Interacting with the Database
[ 208 ]
5.	 Now, we can view your messages for user 2 at http://localhost/egotist/
messages/get_messages/2:
6.	 Clicking the Delete link will remove the message from the database:

Chapter 6
[ 209 ]
What just happened?
The delete functionality followed the same basic flow as search, insert, and update. First, we 
needed to create the appropriate model method, and then we needed to add the controller 
action and custom route. Because there is not a view for the delete, we simply redirected on 
complete.
In a production environment, we would want to add security, user authorization, and 
confirmation for the delete. Again, this exercise is meant to illustrate the database functions, 
and you are encouraged to play with the source code to make it more secure and useable.
Other functions and expressions
Sometimes, we need to create expressions or use other database functions that are not 
provided via the Query Builder. If we know, for example, that our Database server will always 
be MySQL, and we want to insert an expression that is MySQL specific, and still want to 
utilize the Query Builder, we can do so with the DB::expr() method.
This method allows database expressions to be added to the query builder without 
automatic escaping. This allows us to pass database functions into the query builder to 
have them included in the compiled statement.

Interacting with the Database
[ 210 ]
Take, for example, the COUNT() function available in MySQL databases. To execute the 
COUNT() function on a table, we could add it via the Query Builder as follows:
$query = DB::expr('COUNT(messages.id)');
This would produce:
COUNT(messages.id)
To add this into a query we could do the following:
$query = DB::select(DB::expr('COUNT(id)'))
   ->from('messages');
The above code produces:
SELECT COUNT(id) 
   FROM `messages`
Using this method can open up a lot of possibilities for using database-specific functions with 
the Query Builder. While most queries can be built directly using the methods available for 
the Query Builder, there may be times when we must run a database expression directly.
Take a look at our Message model from the case study site, specifically the count_all() 
method:
public function count_all($user_id = null) 
{
   $query = DB::select(DB::expr('COUNT(*) AS message_count'))
      ->from($this->_table);
   if ($user_id) 
   {
      $query->where('user_id', '=', $user_id);
   }
   return $query->execute()->get('message_count');
}
Here, we see the DB::expr() method being used to have the MySQL COUNT() function 
passed in the query. Unlinke params and prepared statements, DB expressions are not 
escaped, so be careful when using DB::expr() and user inputs. Now that we have a good 
grasp on how to use the Database module, we are ready to see how the Session class can 
use the Database module to make persistent sessions.

Chapter 6
[ 211 ]
Using the Database Module with sessions
The Session class that is included with Kohana makes creating and using sessions very 
simple. Combined with the Database module, sessions can become persistent by storing 
them in the database, and using a cookie to access the session data. This way, when a user 
closes their browser, the session can still be active when they re-open it, provided they did 
not erase their cookies.
Configuring database sessions
To configure sessions for use with our application, we first need to create a configuration 
file for sessions, and specify the adapter you wish to use. The session library in Kohana ships 
with three adapters: one for native PHP session handling, one for using cookies, and finally 
the database session adapter.
Time for action – Adding session handling with the 
database adapter
For the case study site, the database session option is nice in that our application can take 
advantage of the persistent storage of session data, and our users will be able to have 
options like "remember me".
1.	 First, we will need a table to store the session data. To do this, we can create a new 
table named 'sessions' and use the following SQL query to create the table:
CREATE TABLE `sessions` (
  `session_id` varchar(24) NOT NULL,
  `last_active` int(10) unsigned NOT NULL,
  `contents` text NOT NULL,
  PRIMARY KEY (`session_id`),
  KEY `last_active` (`last_active`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
2.	 Next, we will need to create a session config file to let the session class 
know where to store the data. To do this, create a new config file in /
application/config/ named session.php, and add the following code:
<?php
   
return array(
   'database' =>array(
      'table' => 'sessions'
   ),
);

Interacting with the Database
[ 212 ]
What just happened?
As mentioned earlier, the session class ships with three adapters, and the case study site will 
be using the database adapter as it has the richest features. To accomplish storing session 
data in a database, we needed to create a table to store the information.
Our new table has a column for the session_id, the last active timestamp, and a column to 
store the contents of the session.
Next, we needed to create a configuration file to let the class know which adapter it will be 
using. Now that the session is in place, we can see just how easy it is to use in your projects.
Using Database Sessions
Storing and retrieving data from sessions using the session class is very simple. Now that the 
database adapter is enabled and properly configured, we can begin storing information in 
sessions, and retrieve the data when needed in a very simple manner.
Once the Auth module is up and running, we will be using the Session class more, and will 
know if a user is logged in, who they are, etc., based on their session information. For now, 
let's take a look at how sessions work in Kohana.
To store information in a session, we use the Session::instance() method, and pass 
the adapter in as the first parameter. The instance() method returns a Session object, so 
it is chainable. The set() method accepts a key as the first argument, and the value as the 
second:
Session::instance('database')->set('user_id', 1);
This will store the name/value pair of user_id = 1 in the session. To retrieve, we would 
just use the get() method:
$user_id = Session::instance('database')->get('user_id');
echo $user_id;
This will print 1, provided the previous set() was run prior to this. Getting and setting data 
in your session is just this simple, create a config, set up the table, and then set() and 
get() data as we need to in our projects.

Chapter 6
[ 213 ]
Pop quiz – Using the Database Module 
1.	 To use the Database Module, you must first get a new instance of Database_
Query, which can be instantiated by creating a new instance of the class, or by using 
which convenience method?
a.	
Database_Query::instance()
b.	 DB::query()
c.	
DB::instance()
d.	 Database::query()
2.	 The Database_Query object can hold prepared statements and have the 
parameters updated via which method?
a.	
Database_Query::bind()
b.	 Database_Query::param()
c.	
Database_Query::compile()
d.	 Database::query()
3.	 The Query Builder allows SQL queries to be built programmatically and has several 
abstracted methods to create query clauses and expressions. Which Query Builder 
method allows for custom SQL to be passed to the Query Builder without being 
escaped?
a.	
DB::no_escape()
b.	 DB::raw_query()
c.	
DB::expr()
d.	 DB::select_custom()
Summary
We learned a lot in this chapter about the database module; more specifically we covered 
how to use, create, and extend models, and we took an in-depth look at the Kohana 
Database module. We discovered how the database module and its query builder provide a 
nice abstracted layer for using common database solutions with our applications.
In the next chapter, we will take an in-depth look at two modules that rely on the Database 
module to function: the ORM and the Auth modules. By implementing these modules in 
your projects, you can make working with data even easier, and authorizing users a breeze.


7
Using the ORM and Auth Modules
The ORM provides an interface for working with database data in an object-oriented manner. 
By handling relationships and queries, the ORM allows us to work with our data like any 
other object. The Auth module makes working with users much easier. Combined with the 
ORM, the Auth module can secure our controllers and actions, handle login and logout, and 
provide an easy way to have users in our application.
In this chapter, we will learn:


What the ORM is, and how it is used


How to enable and configure the ORM


API overview of ORM methods


Having our models use the ORM


How to use the ORM with related tables


How to validate data when using the ORM


Enabling and configuring the Auth module


How to add user authentication to our applications
Using the ORM module
The other official module that ships with Kohana and is used to interact with the database is 
the ORM module. This module works along side the Database module to provide an object 
oriented way to manipulate the data stored in a database.
In a nutshell, Object Relational Mapping allows us to manipulate database data just like we 
would any other object in PHP. By defining the relationships between tables and some basic 
configuration, we can then read, change, and save the data in a manner that is familiar and 
works like native objects.

Using the ORM and Auth Modules
[ 216 ]
Some of the advantages of using the ORM module are the ease of use and ability to use 
databases without writing any SQL. This makes it unnecessary to write model methods to 
handle mundane tasks like inserting, updating, deleting, and select methods that are used to 
house queries dedicated to interacting with a database table.
The other advantage of the ORM is how it handles related database objects and makes 
working with related data much more intuitive. The ORM is powerful enough to handle our 
joins, pivot tables, and related data with ease, giving us a nice interface with understandable 
syntax to access and manipulate our data.
To begin using the ORM, it must first be enabled.
Setting up the ORM module
There are two main differences in the ORM module that we have not encountered in 
previous modules. First of all, the ORM requires no configuration file, and all configuration is 
done in the models that extend this module. Secondly, the ORM depends on the Database 
module, so it must first be enabled and configured.
To enable the ORM, we simply make sure it is added or uncommented in the 
Kohana::modules() method inside our /application/boostrap.php file. Once this 
has been accomplished, we are ready to begin using the ORM.
To start using the ORM, we must first create or update a model to inherit the ORM model, 
which will expose all the methods we will need to utilize this module. By extending the ORM 
model, we will then configure the model to be aware of certain aspects about the data it 
represents. Luckily, most configuration can be avoided by following some conventions while 
creating our applications.
Convention over configuration
There are some basic rules that we need to follow to get the ORM running in our models to 
prevent having to configure every model. This 'convention over configuration' way of coding 
can make for less code that is cleaner and easier to read and write. That being said, we can 
configure any model to override the defaults that the module is expecting.
For the remainder of this chapter, it will be assumed we are using the MySQL driver for the 
Database module to connect to our database. Additional or other configuration may be 
needed if using the PDO connector.
The easiest way to use the ORM is to adhere to the following conventions:
1.	 Make table names plural (i.e.: users).
2.	 Make model's filename singular (i.e.: application/classes/model/user.php).
3.	 Make the model class name singular (i.e.: Model_User).

Chapter 7
[ 217 ]
4.	 Make the primary key name 'id', and set it to auto_increment.
5.	 Make any pivot tables use alphabetical order (i.e.: roles_users).
By following these conventions, creating a model to handle the messages table using the 
ORM would be handled by naming the table `messages` with a model named message.
php and with a class name of Model_Message, and our table would have a column named 
`id` that was indexed as a primary key with auto_increment on. The pluralization for the 
default table name is created by the Inflector helper, which we covered in Chapter 4.
Since we have already met these requirements in our case study Message Model, it is not 
necessary to configure the model further to use the ORM, we will simply have to extend the 
ORM model to begin to utilize the module's functionality.
ORM API Overview
By now, we should be more familiar with the API browser located in the Userguide Module, 
and should have a good understanding of how to browse through the methods for a 
particular class and see what functionality is available to us. The ORM is a fairly complex 
module for a beginning developer, and you may need to consult the API browser and 
documentation as you are learning how to use this module.
That being said, we will cover the core functionality of the module throughout this chapter, 
and look at the common methods we will use while creating our applications. You should be 
aware that this module can be much more in-depth than we can cover in one chapter, but 
having a good start will help you become a proficient user of the ORM.
The first thing we should know is that the ORM allows us use the Database query method 
to manipulate our queries. Any ORM object can have these methods invoked to create the 
desired result properly. In the ORM class, the following property declaration shows all the 
DB methods available to us:
// Callable database methods
protected static $_db_methods = array
(
   'where', 'and_where', 'or_where', 'where_open', 'and_where_open',
   'or_where_open', 'where_close','and_where_close',
   'or_where_close', 'distinct', 'select', 'from', 'join', 'on',
   'group_by','having', 'and_having', 'or_having', 'having_open',
   'and_having_open', 'or_having_open','having_close', 
   'and_having_close', 'or_having_close', 'order_by', 'limit', 
   'offset', 'cached','count_last_query'
);

Using the ORM and Auth Modules
[ 218 ]
With just this knowledge, we already have over two dozen methods with which we have 
some familiarity. Each one of these methods performs the same functionality to our ORM 
queries as it did when used in the Database module.
In order to gain all this functionality, our models will need to inherit all the power from the 
ORM. Any models that will be using the ORM module will simply extend it, and that's it. 
Consider our Message Model that we created last chapter for our case study site. The class 
declaration looks like this:
class Model_Message {
To use the ORM on this module, we would simply inherit the ORM model as a parent:
class Model_Message extends ORM {
By utilizing the conventions mentioned above, no other configuration is necessary. If we did 
not follow the conventions, we would need to create some object properties to override 
the defaults for which the model will look. Using the conventions saves time, and makes the 
ORM much more flexible and easy with which to work.
We have a couple of options when it comes to using our new ORM model in our projects. We 
can either instantiate the new object directly as usual:
$message = new Model_Message;
Or we can use the ORM's factory method:
$message = ORM::factory('message');
This would then load a new instance of the message model, just like before. Now we have an 
entire new way to create and manipulate our data in this object.
Selecting and loading records using the ORM is very simple and elegant. Using the Database 
module, finding all records in the Messages table required the following code:
DB::select()
   ->from('messages')
   ->execute();
The find_all() method returns an ORM object that contains all records from the 
database. To refactor the above Database module code to use the ORM would require only 
the find_all() method to be called on the message model:
$messages->find_all();

Chapter 7
[ 219 ]
With the ORM, we are also given a find() method that loads one record into the object. 
It can be a part of a more complex query and return only one result, or we can pass the 
primary key ID for a particular record, and it will load it. If we wanted to load the message 
with id 2 using the Database module, we would write something like:
DB::select()
   ->from('messages')
   ->where('id', '=', 2)
   ->execute()
   ->current();
Using the ORM's find() method:
$messages->find(2);
As we can see, simple queries can be done with relative ease, and does not require writing 
queries, or even using a query builder. As our selects become more complex, we may need 
to add some more specific clauses, and the ORM will apply them prior to running the query.
Take, for example, a query where we would want all messages where the date published was 
in the last 15 minutes. Using the Database module, we could write:
DB::select()
   ->from('messages')
   ->where('date_published', '=<', time() - 900)
   ->execute();
Using the ORM:
$message->where('date_published', '=<', time() - 900)->find_all();
By using the same WHERE clause, and using the exact same method, we were able to make 
the same query using the ORM. I know that there were only a few characters of code 
saved in this example, and it may not seem worth the change now. We are only beginning 
to scratch the surface of this module, and the real power will be shown when we begin to 
relate tables and data to each other.
An ORM record is represented as an object with all the columns mapped to object 
properties. This way we can access (get), and change (set), our data via a familiar interface. 
To print the contents of a message with an id of one, we would just load the message, and 
then echo the desired property's value:
$message = new Model_Message;
$message->find(1);
echo $message->content;

Using the ORM and Auth Modules
[ 220 ]
This code will create a new instance of the Model_Message, then load the row with an 
id of 1, mapping all the columns and values to object properties. Then, when we access 
these properties, the values are returned, just like any other object in PHP. When we echo 
$message->content, the value for that column in the loaded row will be displayed.
These object properties can be manipulated as well as simply retrieved. We can update any 
record by setting the value of any property:
$message = new Model_Message;
$message->find(1);
$message->content = 'New message content';
echo $message->content;
This will now print "New message content", no matter what the database has for the value 
of content for the row with an id of 1. This code does not, however, actually update the 
database. The reason is simple: the ORM waits until we can complete all the manipulations 
to perform a query.
If we wanted to change the contents of the row with the updated data, we would need 
to run the save() method. This method allows the ORM to build the query and execute 
it on our database. To persist the new content to the datastore, we would need to do the 
following:
$message = new Model_Message;
$message->find(1);
$message->content = 'New message content';
$message->save();
echo $message->content;
This code would print the exact same message; however, it would first execute the UPDATE 
query on the database. The save() method is fairly intelligent, and can not only build the 
query, it can also determine whether the query should be an INSERT or UPDATE statement. 
That's right, we can create new objects, and therefore new records, in the exact same 
manner, just on an empty instance of the model.
To create a new message, we could simply do the following:
$message = new Model_Message;
$message->user_id = 1;
$message->content = 'New message content';
$message->date_created = time();
$message->save();

Chapter 7
[ 221 ]
Because the object had not loaded in records, the save() method knows that this is a new 
record, and will automatically use an INSERT here, where it used an UPDATE in the previous 
example. This intelligence makes working with database records so much easier, and once 
we begin to think about our datastore in an object-oriented way, the ORM becomes even 
more exciting.
Of course, most of this logic will live inside of our model, and not in a controller or view. 
When we are creating methods inside our model, we obviously do not need to create a 
new instance, and would use the $this keyword to perform the workload. To create a new 
message inside a model, the previous example would look like this:
public function create() 
{
   $this->user_id = 1;
   $this->content = 'New message content';
   $this->date_published = time();
   $this->save();
}
Of course this example would never be used in a real model as we would want the inserted 
values to be dynamic, and this function would need to be abstract, allowing for the controller 
to determine the inserted data. However, it does illustrate that because the controller would 
need to create a new instance of the Message Model, the function would simply assign the 
values to the object, and then save the new contents.
The values() method accepts an associative array of properties and values that can be 
used in the same way. To make this function practical, we could refactor it like this:
public function create(array $data) 
{
   $this->values($data);
   $this->save();
}
Now, in a controller, we could add a new row by doing the following:
$message = new Model_Message;
$data = array(
      'content' => 'Example message.',
      'user_id' => 1,
      'date_published' => time()
   );
$message->create($data);

Using the ORM and Auth Modules
[ 222 ]
This would create a new message with the contents of $data automatically inserted into the 
query. However, the following code would perform an update if a row with an id of 1 existed 
in the table:
$message = new Model_Message;
$message->find(1);
$data = array(
      'content' => 'Example message.',
      'user_id' => 1,
      'date_published' => time()
   );
$message->create($data);
We can ensure that the create() method never attempts to update a record a couple of 
different ways. One way is to test whether a record is loaded in our model method like this:
public function create(array $data) 
{
   if (!$this->empty_pk() && !isset($this->_changed[$this->_primary_
key]))
   {
      throw new Exception('Cannot create new message, object contains 
a loaded message already');
   }
   $this->values($data);
   $this->save();
}
This will work, or we could use the clear() method to nullify the object and return it to an 
empty state. By checking $this for an empty primary key if it has changed lets us know the 
message object is not loaded. The model method could look like this:
public function create(array $data) 
{
   $this->clear();
   $this->values($data);
   $this->save();
}
Now, the create() method will always add the data to an empty instance, thereby creating 
an INSERT statement no matter how the code is written.
Lastly, we will need to know how to remove records from the database. The ORM comes 
with a handy delete() method that will optionally accept the ID of a record. To delete a 
record with the id of 2, we could do the following:
$message->delete(2);

Chapter 7
[ 223 ]
Or, we could delete the currently loaded message:
$message = new Model_Message;
$message->find(2);
$message->delete();
Although both of these examples have the same end result, the flexibility allows us to apply 
whichever is more applicable to our situation. We can either delete a record based on its 
primary key ID, or we can delete the record to which is currently being pointed by the ORM. 
The delete_all() method works much in the same way as delete when more than one 
record is loaded. For example:
$message = new Model_Message;
$message->where('id', '<', 100);
$message->delete_all();
This would delete all the records with an id of less than 100.
Another helpful method is count_all(). It simply counts the number of records for an 
object:
$message = new Model_Message;
$message->where('id', '<', 100);
echo $message->count_all();
It would print the number of messages that had an ID that was less than 100.
We will be covering some more of the methods and properties available to us we when 
we begin covering related tables and relationships a bit later in the chapter. The functions 
outlined above will all serve us well when working with all sorts of data, from just about any 
table. Once relationships are introduced, there will be a little bit of added complexity, but a 
whole lot of added power.
It is worth noting that this being a beginning text for the framework, it is limited to showing the 
basic functionality available. In practice, we should create exception handlers for our model 
methods, and use try/catch blocks for our queries, catching and handling any exceptions 
that are thrown our way. We will touch on this a bit later, but you should be aware that using 
good coding practices and standards still apply to code written using the ORM.

Using the ORM and Auth Modules
[ 224 ]
Time for action – Updating Message Model to use ORM
To illustrate how the ORM is used to create, update, read, and delete database data by 
invoking methods on a data object, we can convert the Messages model to use the ORM. 
This will allow us to update the case study site to reap the benefits, and learn the basics of 
using this powerful module. It will also allow us to add our related data to the Messages 
object easily once we have expanded the application.
Since our Message model already follows the requirements for the ORM module without 
advanced configuration, making the switch is very easy.
1.	 First, we will need to rewrite our Message Model to utilize the ORM. Because the 
ORM can perform many of the tasks that we had to implement in our model, the 
file will be much shorter. Open our Message Model, located at /application/
classes/model/message.php, and edit it to use the ORM:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
/**
 * Message Model
 * Handles CRUD for user messages
 */
class Model_Message extends ORM {
   
   /*
    * Adds a new message for a user
    * 
    * @param   int      user_id
    * @param   string   user's message
    * @return  self
    */ 
   public function create($user_id, $content) 
   {
      $this->clear();
      $this->user_id = $user_id;
      $this->content = $content;
      $this->date_published = time();
      return $this->save();
   }
   
   /**
    * Updates a message
    * 
    * @param  int      message_id

Chapter 7
[ 225 ]
    * @param  string   new message
    * @return self
    */
   public function update($message_id, $content) 
   {
      $this->find($message_id);
      $this->content = $content;
      return $this->save();
   }
   
   /**
    * Gets all messages
    *
   * @param      int      limit
    * @param      int     offset
    * @param   int   user id OPTIONAL
    * @return  self
    */ 
   public function get_all($limit = 10, $offset = 0, $user_id = 
null)
   {
      $this->order_by('date_published', 'DESC')
         ->limit($limit)
         ->offset($offset);
      if ($user_id) 
        {
         $this->where('user_id', '=', $user_id);
        }
      return $this->find_all();
   }
   
}
2.	 Now that the model has changed, we will need to make some modifications to our 
controller that uses the Message model. Open the User Messages controller in /
application/classes/controller/user/messages.php, and modify the 
code appropriately:
<?php defined(‘SYSPATH’) or die('No direct script access.');
   
class Controller_User_Messages extends Controller_Application {
   
   public function action_index()
   {
      URL::redirect();

Using the ORM and Auth Modules
[ 226 ]
   }
   public function action_get_messages() 
   {
      $messages = new Model_Message;
      $user_id = $this->request->param('id');
      if ($user_id) 
      {
         $message_count = $messages->where('user_id', '=', $user_
id)->count_all();
      }
      else 
         {
            $message_count = $messages->count_all();
         }
                    $pagination = Pagination::factory(array(
                    'total_items'    => $message_count,
                    'items_per_page' => 3,
              ));
             $pager_links = $pagination->render();
             $messages = $messages->get_all($pagination->items_
per_page, $pagination->offset, $user_id);
             $this->template->content = View::factory('profile/
messages')
                   ->set('messages', $messages)
                    ->set('pager_links', $pager_links);
      }
      public function action_add() 
      {
             $messages = new Model_Message;
             $user_id = $this->request->param('id');
             $this->template->content = View::factory('profile/
message_form');
             if ($_POST && $_POST['content'])
             {
                    $messages->create($user_id, $_
POST['content']);
                    $redirect = url::site("messages/get_
messages/$user_id");

Chapter 7
[ 227 ]
                    Request::instance()->redirect($redirect);
              }
       }
       public function action_edit() 
      {
             $user_id = $this->request->param('user_id');
             $message_id = $this->request->param('message_id');
             $messages = new Model_Message;
             $message = $messages->find($message_id);
             if ($message->user_id != $user_id`) {
                     throw new Exception("User is not owner of the 
message");
             }
             $this->template->content = View::factory('profile/
message_form')
                  ->set('value', $message->content);
             if ($_POST && $_POST['content'])
             {$messages->update($message_id, $_POST['content']);
                  $redirect = url::site("messages/get_
messages/$user_id");
                  Request::instance()->redirect($redirect);
          }
          
    }
       public function action_delete() 
       {
             $user_id = $this->request->param('user_id');
             $message_id = $this->request->param('message_id');
             $message = new Model_Message;
             $message->find($message_id);
             if ($message->user_id != $user_id) {
                    throw new Exception("User is not owner of the 
message");
             }
             $messages->delete();

Using the ORM and Auth Modules
[ 228 ]
            
             $redirect = url::site("messages/get_messages/$user_
id");
             Request::instance()->redirect($redirect);
            
        }
}
3.	 There are two view files that are rendered by the controller that will also have 
changes.  First, open the Welcome view located at /application/views/
welcome.php, and modify it as follows:
<h1>Recent Messages on Egotist</h1>
<?php foreach ($messages as $message) : ?>
       <p class="message">
              <?php echo $message->content; ?>
              <br />
              <span class="published">
                     <?php echo Date::fuzzy_span($message->date_
published)?>
            </span>
       </p>
       <hr />
<?php endforeach; ?>
<?php echo $pager_links; ?>
4.	 Next, open and edit the user messages view at /application/views/profile/
messages.php, and edit as follows:
<?php foreach ($messages as $message) : ?>
         <p class="message">
              <?php echo $message->content; ?>
              <br />
              <span class="published">
                     <?php echo Date::fuzzy_span($message->date_
published)?>
              </span>
              <?php if (time() - $message->date_published < 900) : 
?>
                    <div class="options">

Chapter 7
[ 229 ]
                           <a href="<?php echo 
url::site("messages/edit/{$message->user_id}/{$message->id}") 
?>">Edit Message</a> | 
                           <a href="<?php echo 
url::site("messages/delete/{$message->user_id}/{$message->id}") 
?>">Delete Message</a>
                    </div>
             <?php endif; ?>
      </p>
      <hr />
<?php endforeach; ?>
<?php echo $pager_links; ?>
5.	 Now we can save all files and test all our views. We should notice that all 
functionality remains the same; the only changes were behind the scenes.
What just happened?
The model certainly changed the most, resulting in a complete re-write. Because the ORM 
contains several methods in that had similar functionality, or had the same name (like delete 
and add), we needed to remove any methods that were no longer needed. The delete() 
method, for example, is already defined in the ORM model, and its functionality is very much 
the same. Also, finding one message can be accomplished with the find() method in the 
ORM, and the find_all() method will get all messages. Likewise, count_all() already 
exists, and will count all records in an object.
What we have created is a model that contains almost identical functionality, but only has 
three custom methods. The create() method simply creates a new record, update() 
allows us to easily update an existing record, and get_all() handles our query with the 
pagination and optional user association.
We may have noticed the create() and update() methods use the exact same syntax 
and interface to accomplish their tasks. Remember, the ORM does not make a distinction 
between inserting or updating data; it simply lets us manipulate an object, and on save() 
it is stored to the database.
The get_all() method is there to return all the results given the pagination information 
and an optional user ID. By utilizing DB methods to refine the query, the ORM can then use 
the find_all() method to load the records into an iterable object.
Next, the controller actions needed to be updated to use the newly re-written model. 
Throughout the controller, we had instantiated the models using the new Model_Message 
syntax, requiring no changes to implement the ORM. That made it easier to make the 
necessary changes, and find the code that needed to be refactored.

Using the ORM and Auth Modules
[ 230 ]
To begin, we needed to update any methods calls that no longer existed, or had a new name. 
This required the add() method to be changed to create() when called inside of our edit 
action, and the get_message() method to be scrapped in favor or the ORM's inherent 
find() method.
Next, to take advantage of the ORM's count_all() method, we created the conditional 
to attach a where clause if a user_id was specified, and to ignore it if not. Then, by using 
count_all(), we can know how many records will exist in our result. A todo doc comment 
was added to remind us when we are back here refactoring the user ID test code once we 
have a user table, that we will want to move these conditionals to the model and refactor 
the count code. For now, it makes sense to keep the user_id temporary test code together.
We also needed to update the delete action in the controller to use the ORM's inherent 
delete function. First, we loaded the message using the supplied message ID, and then 
checked for the right user (of course, it is still test code that accepts the user ID from the 
URI), and then we delete the record.
Because we are now getting objects back for our results, we need to access the properties 
properly, not as array keys. We needed to update our controller, and views to use object 
notation to access the properties. Inside our controller, and the two dependent views, the 
only real changes were making $foo['bar'] look like $foo->bar;.
Now that our messages are using the ORM, it is a good time to introduce another of the 
great features of this module: It works great with the validation library to make working 
with forms that interact with a database easy and intelligent.
ORM, Forms, and Validation
The validation library is used to compare data against validators to determine whether the 
data meets the expectations of the application. When the helpers and classes were covered 
earlier in the book, validation was basically overlooked in favor of introducing it with the 
ORM. Let's take a few minutes to get familiar with this class now, and then see how it 
integrates with the ORM module to make things work even better.
The Validation class
Validation is part of the core functionality of the framework, and is not dependent on any 
particular model. We can use it standalone, and simply pass an array, usually a POST, into its 
constructor, and then add some rules against which it will check the data.
We can use the class as follows:
$data = new Validate(array(
   'first_name' => 'joe',
   'last_name' => 'tester'
));

Chapter 7
[ 231 ]
Then, every rule we add will be run against the data:
$data->rule('first_name', 'not_empty');
$data->rules('last_name', array(
   'not_empty' => NULL,
   'max_length' => 50
));
This will assign the 'not empty' rule to the first_name value, and then check the last_
name value for emptiness and its maximum length once the check() method is run. We can 
see if we had a form with the first_name and last_name fields submitted via POST, then 
we could easily do this:
$post = new Validate($_POST);
$post ->rule('first_name', 'not_empty');
$post ->rules('last_name', array(
    'not_empty' => NULL,
   'max_length' => 50
));
As we can see, the rule() method allows us to pass the array key name as the first 
parameter, and the second is for the validator. Optionally, there is a third param for methods 
that require additional arguments. For example, to use the max_length rule, we must 
specify a length as an integer.
$post->rule('first_name', 'max_length', 50);
The rules() method accepts a key name, and then an array of rules and their options. Any 
rules that do not have additional parameters, like not_empty, are just passed null for the 
value. These two methods allow us to check our data thoroughly and easily for anything that 
is not acceptable.
The user guide provides the following table to illustrate all the rules available to us for 
validating our data. For an interactive version of this table, we can visit our local userguide at 
http://localhost/egotist/guide/security.validation and viewing the section 
on Default Rules. The following table illustrates this similarly, with some addition information 
for easy reference.
Validation Rule
What it does
Validate::not_empty()
Checks that the value is not NULL, FALSE, or 
an empty array or object.
Validate::regex($value, $regex)
Checks value against a regular expression 
that is passed as the second argument.

Using the ORM and Auth Modules
[ 232 ]
Validation Rule
What it does
Validate::min_length($value, 
$length)
Checks the length of a value is at least as long 
as the minimum length defined.
Validate::max_length($value, 
$length)
Checks the length of a value is no longer than 
the maximum length defined.
Validate::exact_length($value, 
$length)
Checks the length of a value is exactly the 
same length as defined.
Validate::email($email, 
$strict)
Verifies the format of an email address, with 
an option boolean option for strict validation.
Validate::email_domain($email)
Verifies the existence of a valid MX record for 
the email domain. NOTE: This requires PHP 
5.3+ on Windows.
Validate::url($url)
Checks that the $url is a valid format.
Validate::ip($ip, $allow_
private)
Checks an IP address for a valid range, 
optionally allowing private range IP addresses 
to be excluded.
Validate::phone($number, 
$lengths)
Verifies the number of digits in a string of 
numbers, with an optional array of lengths if 
check needs to differ from the default length 
checks of 7, 10, and 11.
Validate::credit_card($number, 
$type)
Checks a credit card number for valid format. 
Optionally, card types can be set, and the 
Luhn algorithm can be invoked to verify 
number is of a valid credit card format. 
Validate::date($str)
Verifies the value is a valid date.
Validate::alpha($str, $utf8)
Verifies a value only contains alphabetic 
characters. UTF8 compatibility can be invoked 
via optional second parameter.
Validate::alpha_numeric($str, 
$utf8)
Verifies a value only contains alphanumeric 
(alphabetical and number) characters. UTF8 
compatibility can be invoked via an optional 
second parameter.
Validate::alpha_dash($str, 
$utf8)
Verifies a value only contains alphanumeric 
characters and dashes. UTF8 compatibility 
can be invoked via an optional second 
parameter.

Chapter 7
[ 233 ]
Validation Rule
What it does
Validate::digit($str, $utf8)
Verifies that a value only contains digits with 
no dashes or dots. UTF8 compatibility can be 
invoked via an optional second parameter.
Validate::decimal($str, 
$places, $digits)
Verifies a value is formatted as a decimal. 
Optionally, the number of places and number 
of digits can be checked for proper lengths.
Validate::numeric($str)
Verifies a value is a number, including 
decimal points and negative numbers.
Validate::range($number, $min, 
$max)
Verifies a number is larger than the set 
minimum and smaller than the set maximum 
sizes.
Validate::color($str)
Verifies that a value is a hex color code. Code 
can be 3 or 6 character format. The leading 
hash is not required to be a valid color code.
Validate::matches($value, 
$match)
Verifies the value is the same (===) as the 
specified matched field.
Apart from checking values against rules, we can also assign methods to filter the data and 
perform callbacks. Filters allow each piece of data to be run through a function and have the 
result replace the value. For instance, if we were to create a filter to trim the first_name 
value, we could do it like this:
$post->filter('first_name', 'trim');
This would run the PHP function trim() to the value assigned to the array key first_
name. This would remove any whitespace around the value, and then re-assign the new 
value to first_name. Filters can be very helpful when processing user-generated data 
from form submissions.
Callbacks run after filters and rules, and are used to manipulate the data after the rules 
and filters have been applied. They work much like filters; however, they will run methods 
that are in the model scope versus native functions. For a detailed look at callbacks, and 
the validation class in general, we are encouraged to read the section of the user guide on 
Security > Validation and look at the examples and code provided.
Finally, we can also create an object property for our labels. This will be the human-friendly 
version of our model's property names. Assume that we have a column named first_
name; when we get an error message, for instance, we would not want it to default to 
something like "first_name cannot be empty". By assigning a label of "First Name" to our 
first_name property, we would get a message like "First Name cannot be empty". We'll 
look at this more in depth in a few pages.

Using the ORM and Auth Modules
[ 234 ]
Once we have assigned all of our filters, rules, labels, and callbacks to our validation object, 
we can then run the check() method to run each of the methods against our data. If the 
check() succeeds, we can then know the data is ready for processing, and if it fails, we can 
use the errors() method to recover the error information, and then display that in our 
view. Consider the following code:
if ($post->check())
{
   $message->create($post);
   $this->request->redirect('thankyou_page');
}
$errors = $post->errors();
$content = View::factory('some_view')
   ->set('errors', $errors)
   ->set('post', $post);
This code would run the create() method and redirect to a page named thankyou_page 
if the validation passed, and if not, it would load some_view and allow the post, and errors 
to be passed back. Then, above our form, some code like this would display any error 
messages:
<?php if ($errors) : ?>
   <ul class="error">
   <?php foreach ($errors as $error) : ?>
            <li><?php echo $error; ?></li>
   <?php endforeach; ?>
</ul>
<?php endif; ?>
This would simply loop through the errors array and display each message. Messages can 
be overridden by placing files in the /application/messages/ directory with arrays that 
point to the appropriate message.
The user guide has a very nice section on the Validation class in the section on security. It is 
a good place to get acquainted with the class, and has many good examples. The best part 
about the validation class is how easily it integrates with the ORM in our models.
Time for action – Adding validation to Message Model
1.	 First, we need to add some basic filters, rules, and labels to our Message model. To 
do this, open the /application/classes/model/message.php file, and add 
the following properties to the class:
protected $_rules = array(
       'user_id' => array(
       'not_empty' => NULL,

Chapter 7
[ 235 ]
             'digit' => NULL
       ),
       'content' => array(
              'not_empty' => NULL,
              'min_length' => array(2),
              'max_length' => array(240),
       ),
       'date_published' => array(
              'not_empty'  => NULL,
              'exact_length' => array(10)
       ),
);
protected $_filters = array(
       NULL => array('trim' => NULL)
);
protected $_labels = array(
       'user_id' => 'User Id',
       'content' => 'Content',
       'date_published' => 'Date Published'
);
2.	 Next, we will need to update the add action in our controller. Open the controller at 
/application/classes/controller/user/messages.php for editing, and 
refactor the action_add() method as follows:
public function action_add() 
{
       $messages = new Model_Message;
       $user_id = $this->request->param('id');
       $this->template->content = View::factory('profile/message_
form')
             ->bind('errors', $errors);
       if ($_POST)
       {
             $_POST['user_id'] = $user_id;
             $_POST['date_published'] = time();
             $messages->values($_POST);
             if ($messages->check())
             {
                    $messages->save();

Using the ORM and Auth Modules
[ 236 ]
                    $redirect = url::site("messages/get_
messages/$user_id");
                    Request::instance()->redirect($redirect);
             }
             else 
             {
                    $errors = $messages->validate()-
>errors('messages/add');
             }
             
       }           
     
}
3.	 Finally, we will want to add the ability for our error messages to be viewed by our 
users. Open the view for adding messages at /application/views/profile/
message_form.php, and add edit so it looks like this:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
     
$form_type = Request::instance()->action == 'add' ? 'Create New' : 
'Edit' ?>
<?php if ($errors): ?>
       <h2 class="error">There were form errors.</h2>
       <ul class="errors">
       <?php foreach ($errors as $error): ?>
             <li><?php echo $error ?></li>
       <?php endforeach; ?>
       </ul>
<?php endif; ?>
<h2><?php echo $form_type; ?> Message</h2>
<?php echo Form::open(); ?>
       <div class="field">
             <?php $body = isset($value) ? $value : ''; ?>
             <?php echo Form::textarea('content', $body); ?>
      </div>
      <div class="field">
             <?php echo Form::submit('message_form', "$form_type 
Message"); ?>
      </div>
     
<?php echo Form::close(); ?>

Chapter 7
[ 237 ]
4.	 Now, we can browse to http://localhost/egotist/messages/add/2 to test 
adding a message for user ID 2. Try submitting a message with no value, and we 
should get the following error message displayed:
What just happened?
By adding the validation rules to the $_rules class property array, we are attaching the 
validation rules to each object property that gets run through the check() method. 
Specifically, we set rules for emptiness, minimum, maximum and exact lengths, and content 
type. Once we integrate the Auth module, we will add some more stringent validation for 
user_id also.
Next, we added a filter to remove all leading and trailing whitespace from all properties by 
running PHP's trim() function on all values. We also created some human-friendly labels 
for what will become our field names.
Next, we updated our controller action to load the POST values into the Message model, and 
we added the user_id for now, and set the date published to the current timestamp. Then, 
we invoked the check() method, running all the validators on our values.
If the check is successful, we go on to save the data and then redirect our user back to the 
message stream. A failure on any validation will then assign the error messages array to a 
view variable.

Using the ORM and Auth Modules
[ 238 ]
Lastly, we updated the view script to iterate through the array of error messages, and display 
them for our users to understand. The test shows that a user will see a message indicating 
whether the message content was empty, and used the label for the property name. We can 
test the other validation rules, add some of our own, and then view the error messages to 
get a feel for how it works.
As we can see, the ORM makes it very easy to accomplish validation, error message handling, 
and filtering of our data. The other thing it does a fantastic job of is making our related data 
much easier with which to work.
ORM and Relational Data
When thinking about things in an object-oriented way, it is very logical to think that an 
object's related properties should be able to be accessed directly. Unfortunately, when we 
write native SQL and then are left with a resultset, we are not able to access joined tables in 
a simple and elegant fashion.
The ORM solves this problem, and it solves it well. There is no need to write complex joins 
constantly reminding our application of how these related tables all go together. With the 
ORM module, our models can be aware of the relationships, understand the way the tables 
interact with one another, and then act accordingly.
When we think about messages that belong to a particular user, and we think of that user 
as the "owner" of their messages, we can begin to imagine how these tables might look. We 
would have a users table, full of user data. Then, we would have a message table, where 
some of the messages would belong to a user. Each user could have many messages, but 
each message can only have one user.
This scenario is referred to as a "one-to-many" or "has many/belongs to" relationship, in that 
the user "has many" messages, and each message "belongs to" a user. We would define the 
relationship in each model, and then the ORM would know about this relationship. Once in 
place, we could then access all the messages for a particular user similar to this:
$user = ORM::factory('user')->find(1);
foreach ($user->messages as $message) {
   echo $message->content;
}
The User model would be aware of the Message model, and would be able to access all the 
messages based on the defined relationship in each model. Defining relationships in our 
models is very simple. First, we need to define the relationship type, and then we need to let 
the model know about any specific configuration information.

Chapter 7
[ 239 ]
To add a belongs-to relationship to a model, we just add the $_belongs_to property and 
assign the alias name, and then we can optionally configure the model name and foreign_
key, if they do not follow the ORM convention. If we were adding this to our message 
model, and we were adding a relationship to a users table, we would add the following class 
property:
protected $_belongs_to = array('user' => array());
By adding this property, and defining the alias as 'user', we have let the ORM know that 
each message has an owner to which we will refer as 'user'. Because we are using the 
conventional model name and foreign key name (user_id), then nothing is required in 
the options array. If we named our alias something different, we would have to configure it 
more. Consider this:
protected $_belongs_to = array('author' => array(
   'model' => 'user',
   'foreign_key' => 'user_id'
));
Now, we would be able to access the user property like this:
$user->author->first_name;
This would presume our user table had a first_name property. As we can see, adding a 
belongs-to relationship is very simple. To make this example work, we would also have to 
define the has-many relationship on the users model. Let's take a look at how we add a 
has-many relationship:
protected $_has_many = array('messages' => array());
As we see, this relationship is defined the exact same way as the belongs-to. In fact, in the 
array for optional configuration, we can also pass the model and foreign key in the exact 
same way. If they follow the naming conventions, no configuration is needed for a many to 
one relationship.
We can define a has-one relationship in the same way. Let's assume each user has one 
avatar, and the location and meta data for all the avatars are in a separate table. We could 
add the following to our user model:
protected $_has_one = array('avatar' => array());
And in our avatar table:
protected $_belongs_to = array('user' => array());
Now, we could access our user's avatar path like this:
$user->avatar->path;

Using the ORM and Auth Modules
[ 240 ]
The last type of relationship is the many-to-many. This is the type of relationship where one 
object could have many of the other, and vice-versa. Consider how tags work in a blog. A 
blog typically has posts, and each post has tags. These tags are stored in one table, and the 
posts in another. Each post can have more than one tag, and each tag can be assigned to 
more than one post.
To accomplish this, a table is created to facilitate the relationship, commonly referred to as 
a pivot table. This table would contain the post IDs, and the tag IDs, and each line would 
represent a relationship between a particular post and its corresponding tag. Writing all the 
SQL for many-to-many relationships can be time consuming, and repeating every time we 
need related data only makes it worse. Fortunately, the ORM makes this task simple also, 
and many-to-many relationships can easily be defined, and the related data is available to 
our models.
Continuing using the hypothetical scenario of posts and tags, let's assume the tables already 
exist for each (tags and posts). The pivot table would need to contain the tag_id, and the 
post_id, and to follow the naming conventions the table would need to be named posts_
tags (in alphabetical order). To define the relationship in each model, we would need to use 
the has-many-through declaration. To declare the relationship in the tag model, we would do 
this:
protected $_has_many = array('posts' => array(
   'model' => 'post',
   'through' => 'posts_tags'
));
Conversely, the post model would need the following:
protected $_has_many = array('tags' => array(
   'model' => 'tag',
   'through' => 'posts_tags'
));
If the pivot table did not meet the naming conventions, we would need to create a new 
model for it, and define a belongs-to each of the related tables. For more information on 
this, please consult the documentation located at http://kohanaframework.org/3.0/
guide/orm/relationships.
We can add a relationship between a tag and a post now by using the add() method. This 
allows us to relate one object property to another, and the ORM will define the relationship 
in the pivot table:
$post->add('tag', $tag);
We can remove in the same way:
$post->remove('tag', $tag);

Chapter 7
[ 241 ]
Once we have some users in our case study site, defining and utilizing ORM relationships will 
make finishing the core features simple, and will set a good foundation for expanding and 
adding additional features and options for our users.
Speaking of users, the case study site would be a lot closer to a working model if we had 
some users and an authentication system.
Using the Auth module
The Auth module requires the Database module, and optionally the ORM module, to be 
enabled and installed for use. The Auth module provides an easy way to authorize users for 
secure access to our application, and assigns every user a role. These roles can be used to 
add restrictions to entire controller, or individual actions.
For the purposes in this book, we will assume we are using the ORM and the Session 
modules, and have them properly configured and enabled. Conveniently, the Auth module 
also comes with an ORM model that we can inherit to make adding users nice and easy.
There is not any difficult configuration to use the Auth module, provided we use it as it 
comes. Of course, like any module, it can be overridden for specific needs, and the actual 
user model is just inheriting the base Auth User Model. To get this module up and running, 
we need to create a few database tables, create a config file with some basic information, 
and create a model to extend the Auth's User model.
Configuring the Auth module
Like most modules, the Auth module comes with a generic config file that we can merge in 
our application for specific options. Because the Auth module also requires some database 
structure to work properly, it also comes with a basic schema to get us started. For the 
purposes of this case study site, we will be using the included SQL for our structure, and will 
utilize the basic functionality of this powerful module.
Time for action – Adding users and Auth to case study site
1.	 Create the base MySQL table structure and the required rows by running the 
provided SQL query located in /modules/auth/mysql.sql against our database. 
The SQL statement should look like this:
CREATE TABLE IF NOT EXISTS `roles` (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `name` varchar(32) NOT NULL,
  `description` varchar(255) NOT NULL,
  PRIMARY KEY  (`id`),

Using the ORM and Auth Modules
[ 242 ]
  UNIQUE KEY `uniq_name` (`name`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;
INSERT INTO `roles` (`id`, `name`, `description`) VALUES(1, 
'login', 'Login privileges, granted after account confirmation');
INSERT INTO `roles` (`id`, `name`, `description`) VALUES(2, 
'admin', 'Administrative user, has access to everything.');
CREATE TABLE IF NOT EXISTS `roles_users` (
  `user_id` int(10) UNSIGNED NOT NULL,
  `role_id` int(10) UNSIGNED NOT NULL,
  PRIMARY KEY  (`user_id`,`role_id`),
  KEY `fk_role_id` (`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
CREATE TABLE IF NOT EXISTS `users` (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `email` varchar(127) NOT NULL,
  `username` varchar(32) NOT NULL DEFAULT '',
  `password` char(50) NOT NULL,
  `logins` int(10) UNSIGNED NOT NULL DEFAULT '0',
  `last_login` int(10) UNSIGNED,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `uniq_username` (`username`),
  UNIQUE KEY `uniq_email` (`email`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;
CREATE TABLE IF NOT EXISTS `user_tokens` (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_id` int(11) UNSIGNED NOT NULL,
  `user_agent` varchar(40) NOT NULL,
  `token` varchar(32) NOT NULL,
  `created` int(10) UNSIGNED NOT NULL,
  `expires` int(10) UNSIGNED NOT NULL,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `uniq_token` (`token`),
  KEY `fk_user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
ALTER TABLE `roles_users`
  ADD CONSTRAINT `roles_users_ibfk_1` FOREIGN KEY (`user_id`) 
REFERENCES `users` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `roles_users_ibfk_2` FOREIGN KEY (`role_id`) 
REFERENCES `roles` (`id`) ON DELETE CASCADE;

Chapter 7
[ 243 ]
ALTER TABLE `user_tokens`
  ADD CONSTRAINT `user_tokens_ibfk_1` FOREIGN KEY (`user_id`) 
REFERENCES `users` (`id`) ON DELETE CASCADE;
2.	 Now, override the config by creating a new file located at /application/config/
auth.php, and insert the following code:
<?php defined(‘SYSPATH’) or die(‘No direct access allowed.’);
return array(
       'driver'       => 'ORM',
       'hash_method'  => 'sha1',
       'salt_pattern' => '2, 4, 5, 7, 12, 16, 25, 27, 29, 30',
       'lifetime'     => 1209600,
       'session_key'  => 'auth_user',
);
What just happened?
The SQL code will create the necessary tables to begin using the Auth module. These include 
tables for our users, roles, and user tokens. These tables will be used by our user model to 
store information about our users, their access roles, and information tied to our users.
Next, we created the configuration module to use the ORM, and we updated the salt 
pattern. It is important to use a salt pattern that is different from the one that is provided 
with the module to ensure that our encrypted passwords are not able to be compromised by 
reducing encryption entropy.
Although the configuration of the module gets us a long way towards using it in our 
application, we will still need to implement it in our project.
Implementing the Auth module
In our case study site, we have already created placeholders for user associations by creating 
columns for user_id and the like. It is also apparent there needs to be some way for users 
to identify themselves so they can create messages, update their profiles, and otherwise 
interact with the application and have their actions associated with their account.
By implementing a system to accomplish these things, and then tying the users table to the 
existing relationship placeholders, our application will become one step closer to being a 
usable site. Creating authorization systems, login scripts, logout scripts, password hashing, 
and all the other necessary processes necessary to handle users can take weeks. By using the 
Auth module, we save time, and probably gain a few extra features, too.

Using the ORM and Auth Modules
[ 244 ]
Time for action – Adding the Auth functionality to the case 
study site
1.	 Create a new user model that extends the Auth_User model by creating a new file 
/application/classes/model/user.php with the following code:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
class Model_User extends Model_Auth_User {
       protected $_has_many = array(
              'user_tokens' => array('model' => 'user_token'),
              'roles'       => array('model' => 'role', 'through' 
=> 'roles_users'),
              'messages'     => array('model' => 'message')
       );
       protected $_labels = array(
             'username'         => 'Username',
             'email'            => 'Email Address',
             'password'         => 'Password',
             'password_confirm' => 'Password Confirmation'
      );
        
       protected $_ignored_columns = array('password_confirm');
       public function validate_create($array) 
       {
              $array = Validate::factory($array)
                    ->label('username', $this->_
labels['username'])
                    ->label('email', $this->_labels['email'])
                    ->rules('username', $this->_rules['username'])
                    ->rules('email', $this->_rules['email'])
                    ->rules('password', $this->_
rules['password']);
              foreach($this->_callbacks as $key => $value)
              {
                    foreach ($value as $validator) 
                    {
                          $array->callback($key, array($this, 
$validator));
                    }
              }

Chapter 7
[ 245 ]
              return $array;
       }
       public function validate_update($array) 
       {
              $array = Validate::factory($array)
                    ->rules('username', $this->_rules['username'])
                    ->rules('email', $this->_rules['email'])
                    ->label('username', $this->_
labels['username'])
                    ->label('email', $this->_labels['email']);
              foreach($this->_callbacks as $key => $value)
             {
                    $array->callback($key, array($this, $value));
             }
             return $array;
       }
       
       public function validate_update_password($array) 
       {
              $array = Validate::factory($array)
                    ->rules('password', $this->_rules['password'])
                    ->rules('password_confirm', $this->_
rules['password_confirm'])
                    ->label('password', $this->_
labels['password'])
                    ->label('password_confirm', $this->_
labels['password_confirm']);
             return $array;
       }
     
}
2.	 Update the Message model at /application/classes/model/message.php, 
and add the following property at the beginning of the class, leaving all other code 
intact:
class Model_Message extends ORM {
       protected $_belongs_to = array('user' => array());
      ... existing code ...
}

Using the ORM and Auth Modules
[ 246 ]
3.	 Update the user account controller to add functionality to sign up, log in, and log 
out. Open and edit /application/classes/controller/user/account.php, 
and insert the following code:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
class Controller_User_Account extends Controller_Application {
       public function action_login()
       {
             if (Auth::instance()->logged_in())
             {
                    Request::instance()->redirect('profile/
private');
             }
             $this->template->content = View::factory('account/
login')
            ->bind('user', $user)
            ->bind('errors', $errors);	
             if ($_POST)
             {
                    $user = ORM::factory('user');
                    $status = $user->login($_POST);
                    if ($status)
                    {
                          Request::instance()->redirect('profile/
private');
                    }else
                    {
                             $errors = $_POST->errors('login');
                    }
              }
      }
       public function action_logout()
       {
             Auth::instance()->logout();
             Request::instance()->redirect('login');
       }
       public function action_signup() 
       {
             $content = View::factory('account/signup');
             $this->template->content = $content;

Chapter 7
[ 247 ]
             if ($_POST)
             {
                    $user = new Model_User;
                    $post = $user->validate_create($_POST);		
                    if ($post->check())
                    {
                          $user->values($post);
                          $user->save();
                          $user->add('roles', 
ORM::factory('role')->find(1));
                    }
                    else
                    {
                    $this->errors = $post->errors('signup');
                          Request::instance()->redirect('signup');
                    }
                    Request::instance()->redirect('');
            }
       }
}
4.	 Update the signup view in /application/views/account/signup.php, 
replacing the first and last name fields with a user name.
<h1>Sign up for Egotist.. We know we want to!</h1>
<?php echo Form::open(); ?>
       <div class="form-field">
             <?php echo Form::label('username', 'Username')?>
             <?php echo Form::input('username'); ?>
       </div>
       <div class="form-field">
              <?php echo Form::label('email', 'Email Address')?>
              <?php echo Form::input('email'); ?>	
       </div>
       <div class="form-field">
             <?php echo Form::label('password', 'Password')?>
             <?php echo Form::password('password'); ?>	
       </div>
      <div class="form-field">

Using the ORM and Auth Modules
[ 248 ]
               <?php echo Form::label('password_confirm', 'Confirm 
Password')?>
               <?php echo Form::password('password_confirm'); ?>
      </div>
      <div class="form-field">
              <?php echo Form::submit('submit', 'Create new 
account'); ?>	
      </div>
<?php echo Form::close(); ?>
5.	 Update user profile controller located at /application/classes/controller/
user/profile.php with the following code:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
class Controller_User_Profile extends Controller_Application {
       public function action_index()
       {
             $id = $this->request->param('id');
             $user = new Model_User($id);
             if (!$user->id) 
             {
                    throw new Exception('Not a valid user');
             }
             $content = View::factory('profile/public')
                    ->set('user', $user)
                    ->bind('messages', $messages)
                    ->bind('pager_links', $pager_links);
             $pagination = Pagination::factory(array(
                    'total_items'    => $user->messages->count_
all(),
                    'items_per_page' => 3,
             ));
             $pager_links = $pagination->render();
             $messages = $user->messages->limit($pagination-
>items_per_page)->offset($pagination->offset)->find_all(); 
             $this->template->content = $content;
       }
       public function action_private()

Chapter 7
[ 249 ]
       {
              $this->request->param('id');
             
             $content = View::factory('profile/private')
                    ->bind('user', $user)
                    ->bind('messages', $messages)
                    ->bind('pager_links', $pager_links);
             
             $user = Auth::instance()->get_user();
             
             $pagination = Pagination::factory(array(
                     'total_items'    => $user->messages->count_
all(),
                     'items_per_page' => 3,
             ));
             
             $pager_links = $pagination->render();
             
             $messages = $user->messages->limit($pagination-
>items_per_page)->offset($pagination->offset)->find_all(); 
             
             $this->template->content = $content;
       }
             
             
}
6.	 Update the public profile view to utilize the new user object, and to add pagination. 
The view is located at /application/views/profile/public.php.
<h2>Public Profile for <?php echo $user->username; ?></h2>
             
<h3>Recent Messages:</h3>
             
<?php foreach($messages as $message) : ?>
         <p class="message">
              <?php echo $message->content; ?>
              <br />
              <span class="published"><?php echo Date::fuzzy_
span($message->date_published)?></span>
              <?php if (time() - $message->date_published < 900) : 
?>
                    <div class="options">
                            <a href="<?php echo 
url::site("messages/edit/{$message->user_id}/{$message->id}") 
?>">Edit Message</a> | 
                            <a href="<?php echo 
url::site("messages/delete/{$message->user_id}/{$message->id}") 
?>">Delete Message</a>
                    </div>

Using the ORM and Auth Modules
[ 250 ]
             <?php endif; ?>
       </p>
       <hr />
<?php endforeach; ?>
             
<?php echo $pager_links; ?>
7.	 Create a private profile view /application/views/profile/private.php, 
and insert the following code for our view script:
<h2>Private Profile for <?php echo $user->username; ?></h2>
<h3>Our Recent Messages:</h3>
<?php if (count($messages)) : ?>
       <?php foreach($messages as $message) : ?>
              <p class="message">
                    <?php echo $message->content; ?>
                    <br />
                    <span class="published"><?php echo 
Date::fuzzy_span($message->date_published)?></span>
                    <?php if (time() - $message->date_published < 
900) : ?>
                          <div class="options">
                                 <a href="<?php echo 
url::site("messages/edit/{$message->user_id}/{$message->id}") 
?>">Edit Message</a> | 
                                 <a href="<?php echo 
url::site("messages/delete/{$message->user_id}/{$message->id}") 
?>">Delete Message</a>
                          </div>
                    <?php endif; ?>
              </p>
            <hr />
       <?php endforeach; ?>
<?php else: ?>
       <p>We have no messages in the system.</p>
<?php endif; ?>
<p><?php echo HTML::anchor('messages/add', 'Create New Message'); 
?></p>
<?php echo $pager_links; ?>
8.	 Update messages controller›s add, update, and delete actions in the file located at /
application/classes/controller/user/messages.php. We will not need 
to update the index or get_messages actions.

Chapter 7
[ 251 ]
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
class Controller_User_Messages extends Controller_Application {
       ... existing code ...
       public function action_add() 
       {
              $user = Auth::instance()->get_user();
              $message = new Model_Message;
              $message->user = $user;
              $this->template->content = View::factory('profile/
message_form')
                     ->bind('errors', $errors);
             if ($_POST)
             {
                    $_POST['date_published'] = time();
                    $message->values($_POST);
                    if ($message->check())
                    {
                           $message->save();
                           $redirect = url::site("messages/get_
messages/$user->id");
                            Request::instance()-
>redirect($redirect);
                    }
                    else 
                    {
                            $errors = $message->validate()-
>errors('messages/add');
                    }
                    
             }           
       }
       public function action_edit() 
       {
             $user = Auth::instance()->get_user();
             $message_id = $this->request->param('message_id');
             $messages = new Model_Message;
             $message = $messages->find($message_id);

Using the ORM and Auth Modules
[ 252 ]
             if ($message->user_id != $user->id) {
                     throw new Exception("User is not owner of the 
message");
             }
             $this->template->content = View::factory('profile/
message_form')
                   ->set('value', $message->content);
              if ($_POST && $_POST['content'])
              {
                    $messages->update($message_id, $_
POST['content']);
                    $redirect = url::site("messages/get_
messages/$user_id");
                    Request::instance()->redirect($redirect);
               }        
       }
       public function action_delete() 
       {
             $user = Auth::instance()->get_user();
             $message_id = $this->request->param('message_id');
             $message = new Model_Message;
             $message->find($message_id);
             if ($message->user_id != $user->id) {
                    throw new Exception("User is not owner of the 
message");
             }
             $message->delete();
             $redirect = url::site("messages/get_messages/$user_
id");
             Request::instance()->redirect($redirect);
             
      }
}
9.	 Update the header view located at application/views/common/header.php  
under main_nav, and add the following code to allow our users to have links to sign 
up, log out, and log in:
<p id=”account”>

Chapter 7
[ 253 ]
<?php if (Auth::instance()->logged_in() 
      && $user = Auth::instance()->get_user()) : ?>
      Logged in as <?php echo $user->username; ?>.  <?php echo 
HTML::anchor('logout', 'Logout'); ?>
<?php else: ?>
       <?php echo HTML::anchor('login', 'Login'); ?> | <?php echo 
HTML::anchor('signup', 'Signup'); ?>
<?php endif; ?>
</p>
10.	Update bootstrap, after route for ‹signup› we will need to add the following routes 
to allow the private profile to be viewed, and logouts to occur:
Route::set(‘logout’, ‘logout’)
       ->defaults(array(
              'directory' => 'user',
              'controller' => 'account',
              'action'     => 'logout',
      ));
Route::set('profile-private', 'profile/private')
          ->defaults(array(
             'directory' => 'user',
             'controller' => 'profile',
             'action'     => 'private',
      ));
What just happened?
First, we had to create a user model to work with our new users table. Instead of having 
to create all the methods necessary to handle user authentication, we extended the Auth 
module's user model, and inherited all the functionality of that model.
It is a good idea to look over the actual model we extended, and the user guide API browser, 
to get familiar with the methods that are available on that model. We can use these in our 
projects to simplify the addition of authentication and users. We will be using several of the 
available methods during this chapter, which will give us a good working knowledge of the 
basic features of this model.

Using the ORM and Auth Modules
[ 254 ]
In our new user model, we began by adding the messages model relationship to the existing 
relationships defined in the Auth User model. This will allow the model to continue to use 
the necessary relationships for the module, and also add the ability to use the message 
object from a user.
Next, we updated the labels to be more human readable, and set the password confirmation 
as an ignored column. This tells the ORM that this property is not represented in the 
database.
After defining these properties, we began to create some methods to be used by our 
controllers. By creating validation methods, we made it easy to run the validators with 
callbacks on our submitted values. The callbacks will execute methods that come with 
the Auth model to validate our values further prior to insertion into the database.
Next, we added a relationship from our message model back to our user model. This 
completed the necessary steps for both model to be related, and allows us to use them via 
each other.
We then updated our account controller to add actions for logging in, out, and signing up 
new users. These actions followed the conventions we have used before to validate post 
data, and then use our model to save the values to the database. The main difference is 
that we used some of the Auth model's methods to perform our tasks.
In the login action, we used the user model's login method to verify the username and 
password against the data stored in the database, using our application's custom salt to 
generate the password match. The logout action similarly uses the model's logout method 
to perform the session handling.
The signup action is used to process new users, and we rely on the inherited model methods 
to encrypt the password, and on model rules to validate the inputted data. We did need to 
use the ORM's add() method to add a relationship between a role and a user.
The Auth module uses roles to determine the level of a user. The module comes with two 
roles pre-installed in the database: login and admin. We can add as many roles as we would 
like, and then determine which actions can be used by certain roles. The add() method 
requires an instance of ORM to add the two together, and by getting the ID of 1, we are 
adding the 'login' role to the new user.
Our placeholder signup form had input fields for the first and last name, and our user model 
needed only a username. All this view required was updating the form fields, and it was 
ready to use with our updated controller action.
Since we no longer are passing the test user IDs around, and have a user model to use in our 
controllers, we needed to update our profile controller to use a real user object. The index 
action only required a few minor changes to get the user and ID.

Chapter 7
[ 255 ]
After we modified the index action, we needed to create an action to provide private 
profiles. This method gets a user using the Auth module's get_user() method, and 
then gathers information about that user for display in the view.
Next, we updated the public view file to utilize the new user object and to add pagination. 
This required very few changes, and we then moved on to creating a very similar view for 
our user's private profiles. This page could be used to update passwords, profile information, 
email addresses, etc. in the future.
Next, we needed to update the message controller to properly tie new messages to the 
currently logged in user. Now that we have a user object, we can simply add messages and 
let the ORM do the necessary work to handle creating the relationship. We also were able 
to modify the checks we have in place to determine whether our user is the owner of the 
message he or she are trying to edit or delete.
Lastly, we added a few links to allow logged-in users to log out, and logged out users to 
either log in or sign up. We had to add the private profile link to the bootstrap, and we 
were all done.
Testing the changes will show how the addition of the Auth module and the code above 
makes it possible for users to sign up, log in, add messages, and log out. Go ahead and 
point our browser to http://localhost/egotist/signup:

Using the ORM and Auth Modules
[ 256 ]
After signing up for the application, we can then click on the Login button and enter our 
username and password:
Once we have successfully logged in, we are taken to our private profile.

Chapter 7
[ 257 ]
Here, we can click on the link to create a new message, and then add a message as a logged 
in user:
Once our message is added, it is tied to our user account and displayed:

Using the ORM and Auth Modules
[ 258 ]
Clicking on Logout will log us out of the application. If we attempt to go back to our private 
profile, we should be redirected to the site's login page.
There is a problem: there is no real security to keep people from attempting to view pages 
that require a user session. The private profile, for instance, requires a logged-in user. If 
we attempt to browse to that page directly, and have not logged in, we will encounter an 
application error. To fix this, we need to redirect users away from pages they cannot access 
by logging in, and give no access warnings to people who attempt to view pages they do not 
have the proper level to view.
Securing controllers and actions
By adding controller and action level security, we can check whether a user is logged in and 
determine whether that user has the proper roles to access the controller or action. This 
can also be used to redirect users who are not logged in back to a login page where they can 
proceed to access the application.
Time for action – Adding secure actions to the case study site
By using the base application controller that we created earlier, combined with the Auth 
module, we can secure our application quickly and easily for user actions.
1.	 First, we will need to add some authentication checks and redirects to our 
base controller. Open and edit the /application/classes/controller/
application.php file, and add the following code:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);
abstract class Controller_Application extends Controller_Template 
{
       public $assert_auth = FALSE;
       public $assert_auth_actions = FALSE;
       public function before() 
      {
              parent::before();
             $this->_user_auth();
             View::set_global('site_name', 'Egotist Beta');
             $this->template->content = '';
             $this->template->styles = array(
                    'reset',
                    'common'

Chapter 7
[ 259 ]
              );
             $this->template->scripts = array();
       }
       protected function _user_auth() 
       {
              $action_name = Request::instance()->action;
              if (($this->assert_auth !== FALSE 
              && Auth::instance()->logged_in($this->assert_auth) 
=== FALSE)
              || (is_array($this->assert_auth_actions) && array_
key_exists($action_name, $this->assert_auth_actions)
              && Auth::instance()->logged_in($this->assert_auth_
actions[$action_name]) === FALSE)) 
             {
                    if (Auth::instance()->logged_in()) 
                    {
                           Request::instance()
                                 ->redirect('admin/auth/
noaccess');
                    } 
                    else 
                    {
                           Request::instance()
                                 ->redirect('admin/auth/login');
                    }
             }
       }
}
2.	 Add a new controller action to our account controller to load the no access view 
content. Create a new method in the /application/classes/controller/
user/account.php file:
public function action_noaccess()
{
       $content = View::factory('account/noaccess');
}
3.	 Create a no access view by creating a new file at /application/views/
account/noaccess.php with the following HTML:
<h1>You do not have access to view this page.</h1>

Using the ORM and Auth Modules
[ 260 ]
4.	 Update application/bootstrap.php, and add the following route below the 
logout route:
Route::set(‘noaccess’, ‘noaccess’)
       ->defaults(array(
              'directory' => 'user',
              'controller' => 'account',
              'action'     => 'noaccess',
       ));
5.	 Add the following property to the user profile controller directly under the class 
declaration. The file is located at /application/classes/controller/user/
profile.php.
public $assert_auth_actions = array(
       'private' => array('login')
);
6.	 Add the following property to the user messages controller directly under the class 
declaration. The file is located at /application/classes/controller/user/
messages.php.
public $assert_auth_actions = array(
       'add' => array('login'),
       'edit' => array('login'),
       'delete' => array('login')
);
What just happened?
First, we added two public properties to our application controller. If we remember, this is 
the base controller we extend throughout our application to allow for abstract properties 
and methods to be used throughout all our controllers. By adding these properties, we are 
allowing all controllers and actions to be overridden when necessary.
Next, we added a protected function named _user_auth() that determines whether a 
user has the proper credentials to access the requested controller action. If the user is not 
logged in, and the action requires them to be, they are redirected to the login page. If they 
are logged in, and do not meet the role requirements, they are redirected to a page that lets 
them know they do not have access to the requested resource.
Lastly, we needed to override the secure actions property on controllers that have actions 
that we need logged in users to access. In our user profile controller, we added the login role 
to the array of assert_auth_actions for the action_private() method. In our user 
messages controller, we also added the login role to our add, edit, and delete actions.

Chapter 7
[ 261 ]
If any of our users attempt to access any of these actions without being logged in, the 
application controller will know to redirect them to the login action and make them log in 
before proceeding. We can test this by logging out of the case study site and then attempting 
to access the add message page at http://localhost/egotist/, and the application will 
redirect us back to the login screen. After logging in, the page is accessible again.
Have a go hero – Adding new messages page using query builder
Now that we have the ability to log in and add authentication to controllers and controller 
actions, users are redirected back to the login page whenever they try to access a secure 
page. This works fine; however, when they log in they are redirected back to their private 
profile page. It would be much better if they were automatically redirected to the page they 
requested if they were sent to the login page as the result of an authentication check. Using 
the base controller authentication checks, the session handler, and some redirect variables, 
you can add this functionality to the case study site.
Pop quiz – Using the ORM  and Auth modules
1.	 We can add validators directly to models that use the ORM by adding them to which 
object property?
a.	
$_filters
b.	 $_rules
c.	
$_callbacks
d.	 $_validators
2.	 The ORM allows us to instantiate a model in two different ways. To get a new 
instance of the message model, we can call a "new Model_Message" or what 
other method?
a.	
ORM::factory('message')
b.	 ORM::instance('message')
c.	
ORM::factory()->instance('message')
d.	 ORM::instance()->factory('message')
3.	 The Auth module creates a relationship between the user and what other model to 
determine access levels?
a.	 tokens
b.	 permissions
c.	
roles
d.	 validators

Using the ORM and Auth Modules
[ 262 ]
4.	 Accessing a logged in user's model object via the Auth module can be accomplished 
via which of the following methods?
a.	
Auth::get_user()
b.	 Auth::instance()->user->get()
c.	
Auth::instance()->get_user()
d.	 Auth::user()
Summary
We learned a lot in this chapter about the ORM and Auth modules; more specifically, we 
covered how to enable, configure, and use the ORM and Auth modules. By using these 
modules in our application, we saved countless lines of code, and picked up validation, 
filters, relationships, and so much more for free. By adding the Auth module to the case 
study site, we were able to see the ORM and user authentication in action together.
Now that we have added user functionality, our application is well on its way to becoming 
usable, and is almost ready for users to start signing up and posting messages. In the next 
chapter, we will be covering troubleshooting and error handling, and will be able to see how 
to detect and debug errors in our applications while adding the final touches to the case 
study site.

8
Troubleshooting and Error Handling
Sometimes things don't always work the way we expect when we are writing code. Every 
programmer has experienced broken code due to typos, using the wrong name, unexpected 
bugs, or any number of the mistakes that are made while crafting an application. Although 
PHP does provide some information when something goes wrong, having additional tools 
to make troubleshooting and debugging our applications can make the process more 
efficient. Kohana provides many tools to help us with debugging and handling our errors and 
exceptions.
In this chapter, we will learn:


How to debug our code using the Kohana class


How to display source code and location in debug data


Rendering variable data in browser friendly formats


Working with 404 errors


How to use Kohana's error handler


Using and understanding the backtrace stack


Profiling our application for better performance
Debugging code with Kohana
Using PHP's native functions for debugging is not always the most elegant way to find out 
what is happening that is causing our code to behave differently than what we intended. It 
is common for developers to use native functions like var_dump(), var_export(), and 
print_r(), followed by die() or exit() functions to figure out what is happening.

Troubleshooting and Error Handling
[ 264 ]
Although these functions do provide some details about what is happening to a particular 
variable, they are not completely suited for web development. To get good formatting with 
var_dump() or var_export(), for example, we really need to view the marked-up source 
code, and this is not always the best option when our data is dynamic or not accessible 
during a reload.
Debugging with the Kohana class
The Kohana::debug() method provides nearly identical functionality to var_export(), 
but conveniently renders the output as HTML. This incredibly increases the readability of the 
debug information when using a browser. To use Kohana::debug, we can simply pass it a 
variable and then view the output:
$array = array(
   'item one', 
   'item two', 
   array('three' => 'item three')
);
echo Kohana::debug($array);
exit;
This code will generate the following output in a browser:

Chapter 8
[ 265 ]
As we can see, it outputs very similar contents to var_dump(), and put its nicely formatted 
and easy to read. Let's take a look at the rendered mark-up:
<pre class= "debug "><small>array</small><span>(3)</span><span>(
    0 =><small>string</small><span>(8)</span>  "item one "
    1 =><small>string</small><span>(8)</span>  "item two "
    2 =><small>array</small><span>(1)</span><span>(
         "three " =><small>string</small><span>(10)</span>  "item 
three "
    )</span>
)</span></pre>
By wrapping the output in a pre element, and then providing additional mark-up for each 
line, type, and meta data, the Kohana::debug() method can prove to be very useful. 
This is nice for arrays, but print_r does a good job with them also. Let's take a look what 
happens when we feed an object to the debug method. Consider the following:
$message = new Model_Message;
echo Kohana::debug($message->find_all());
exit;
The $message->find_all() method should return an object of type Database_MySQL_
Result, and we can see the output nicely formatted in a browser:

Troubleshooting and Error Handling
[ 266 ]
This method works nicely for seeing what is happening inside our code. As we are learning 
the Kohana framework, and we are unsure about what is being stored inside our variables, 
then Kohana::debug() can become a powerful ally in helping us see what is happening, 
and helping complete our fluency with the framework.
There is no limit to the number of variables we can pass to Kohana::debug(), and we can 
mix and match variable types. Combining the first two examples will still render the debug 
information needed:
$array = array(
   'item one', 
   'item two', 
   array('three' => 'item three')
);
$message = new Model_Message;
echo Kohana::debug($array, $message->find_all());
exit;
This will print the formatted debug information for both variables:
The more we use Kohana::debug(), the more valuable it seems to become. It is very easy 
to see the contents of any type of variable, and when using the browser to view variable 
data, it really shines. This method is one no Kohana developer should be without.

Chapter 8
[ 267 ]
Another great method is the Kohana::debug_source() method. This is used to 
display the source code around the called line of code in a file. The method accepts three 
parameters: the first is the file from which the source is to be displayed, the second is the 
line number to show, and the last is the padding, or number of lines in each direction to 
show. The default padding is five lines before and after the line number specified.
To illustrate this method, we can add the following line of code in the Welcome Controller's 
index action:
echo Kohana::debug_source(__FILE__, __LINE__, 15);
For this illustration, I have located that line of code directly above the instantiation of the 
pagination class. The output will show the source code, with 15 lines before and after, 
rendered above the page:

Troubleshooting and Error Handling
[ 268 ]
You can see that on line 18, the Kohana::debug_source() method is invoked, and the 
current file and line number are passed in, and the padding is set to 15 lines. This can be 
very helpful when we want to see the source code for a particular section of code in the 
rendered output. When we begin using the backtrace to debug our errors, we will also see 
this method in action.
Viewing source and debug information is very helpful, but sometimes all we need to know 
is the path to a particular location, but we do not want to share our complete installation 
path with everyone who can view it, or maybe it just isn't necessary. Kohana::debug_
path() does exactly that, it displays the path to a file, but does not show the full installation 
directory. This code in our Welcome Controller:
echo Kohana::debug_path(__FILE__);
will output:
APPPATH/classes/controller/welcome.php
Now we know the file lives in whatever directory is assigned as our APPPATH, and have the 
rest of the information we need.
These methods are all very helpful when we are trying to debug variables and information 
about particular parts of our application. When errors or exceptions occur inside our 
application, the more relevant information we have to work with can make understanding 
and finding solutions for errors quicker and easier.
Error and exception handling
When errors or exceptions arise in our code, Kohana tries to provide us with as much 
information as possible to assist us in resolving the issue. The framework converts errors into 
exceptions so it can handle them in the same fashion as internal exceptions, and process the 
necessary functions to render a helpful page of information.
According to the user guide (which can be viewed on our local case study site by visiting 
(http://localhost/egotist/guide/debugging.errors), the following information 
is provided by the framework:


Exception class


Error level


Error message


Source of the error, with the error line highlighted


A debug backtrace of the execution flow


Included files, loaded extensions, and global variables

Chapter 8
[ 269 ]
When a bug or error is introduced into our code, and it causes a PHP error or application 
exception, the Kohana exception handler will take over and create the debug information 
listed above. The rendered page is not only full of valuable information, but it allows us to 
drill down into the source code of each called file in the trace, and view the arguments that 
are passed around the methods in these files.
Time for action –  Adding error messages to signup form
To illustrate the exception handler, let's introduce a bug into one of the view files on the case 
study site. Since we are on the topic of handling errors, the signup page, for one, does not 
have any error messages displayed back to the user if they do not pass validation on each of 
the form fields. We can add this functionality, and debug it when it does not work properly:
1.	 First, we will need to update our controller action for our signup page. Open the 
file located at /application/classes/controller/user/account.php, 
and update the action_signup() function with the following code:
public function action_signup() 
{
    $content = View::factory('account/signup')
          ->bind('errors', $errors);
    $this->template->content = $content;
    if ($_POST)
    {
          $user = new Model_User;
          $post = $user->validate_create($_POST);	
	
	
          if ($post->check())
          {
                 $user->values($post);
                 $user->save();
                 $user->add('roles', ORM::factory('role')-
>find(1));
                 Request::instance()->redirect('login');
          }
          else
          {
          $errors = $post->errors('signup');
          }
    }     
}

Troubleshooting and Error Handling
[ 270 ]
2.	 Now, we will need to update the view to display the error messages if they exist. 
Open the view file at /application/views/account/signup.php, and update 
with the following code above our<?php echo Form::open(); ?> statement:
<?php if ($errors): ?>
       <h2 class=»error»>There were form errors.</h2>
       <ul class=»errors»>
      <?phpforeach($erroras $error): ?>
              <li><?php echo $error ?></li>
      <?phpendforeach; ?>
      </ul>
<?phpendif; ?>
3.	 Now, we can test the signup form by browsing to http://localhost/egotist/
signup and submitting the form with every field blank. We are expecting to see the 
validation errors displayed nicely at the top of the page.

Chapter 8
[ 271 ]
What just happened?
First, we updated the controller to bind the error messages to a view variable so they 
could be displayed in our view. Next, we needed to update our view to display the errors 
if anywhere found. Unfortunately, there is a problem in the code, and when the form is 
submitted with errors, we are getting an undefined variable error exception.
As we can see, this is an error that was converted to an exception by the class 
ErrorException. Next, we can see the error level (Notice), and error message. Under the 
error message, the backtrace is shown with the source for the offending line highlighted with 
the surrounding code visible.
By continuing down the backtrace, we can see the order of events all the way back to our 
front controller, index.php. By clicking on any of the files, we will be shown the source 
code for the referenced line, and the surrounding code by five lines below and above the 
line referenced.
If we click on the arguments link for any method in the backtrace, we will be shown the 
arguments passed and their values. This can be extremely helpful when more complex errors 
arise, and we need even more details to further understand the issue at hand.
In the error above, it is fairly easy to see what the problem is. The error is for an undefined 
variable, and the signup.php view file is already displayed for you, with the offending line 
highlighted. The code in question is the foreach statement that loops through the $errors 
array:
<?phpforeach ($error as $error): ?>
Clearly, this is a typo that should read:
<?phpforeach ($errors as $error): ?>

Troubleshooting and Error Handling
[ 272 ]
After making the correction and refreshing the page, we should see the working page with 
our form error messages displayed for our user:
Having the code visible and an entire backtrace that we can drill down through on one 
simple page makes debugging errors quick and easy. Using the Kohana error handling in our 
development environment will make finding and fixing errors much more efficient, and our 
time can be spend developing, not debugging.
Have a go hero – Add error messages to login form
Now that we have implemented error messages for form errors on the signup and message 
forms, you are ready to add them on the login form also. To do this,you will need to modify 
the controller action and view to render human friendly error messages when form fields fail 
validation. After updating the controller and view, you should test the login form, and see 
what happens when you submit a blank form.
Disabling the error handler
If we choose not to use the Kohana error handler, and would prefer to use PHP's native 
errors, we can disable it in our bootstrap.php file. Simply add 'errors' => FALSE to 
our Kohana::init() options array.

Chapter 8
[ 273 ]
When we move our applications to a production environment, we will want to disable the 
error messages being displayed, and will likely opt for a less informative error page. This 
page should just tell the user that there has been an error, and let them know that someone 
will be along to correct it. This is nice, but how are we supposed to know what happened so 
we can attempt to fix it? Thankfully, Kohana logs all the errors and stores them in an archive 
for us to read when necessary.
Viewing the error logs
Every time our application encounters an error or exception, the framework adds an entry 
into the logs. These logs, by default, are stored in our /application/logs/ directory and 
are organized by year, month, and day. Inside each log file is a list of time-stamped error 
messages that we can view and use for debugging.
By opening the log file that corresponds with today, I can see the error message that was 
generated when undefined variable error was thrown. In the log file, it looks like this:
2011-02-12 17:54:21 --- ERROR: ErrorException[ 8 ]: Undefined 
variable: error ~ APPPATH/views/account/signup.php [ 5 ]
Although there is not a backtrace provided, we are able to see errors of which we were not 
necessarily aware. If another user had encountered this error, we would now have a starting 
point to begin to reproduce and fix the problem.
This message lets us know when the error happened, what the exception and message were, 
and the offending file and line number. All of this information can get us well on our way to 
understanding the issue, duplicating the problem, and determining a resolution.
Sometimes the problem is incredibly simple, and the solution is obvious. Every day, people 
all over the Internet attempt to view pages that don't exist. There is not a real solution to 
this; we simply need to display a 404 error page. Kohana does not come with one out of the 
box, so it is up to us to create one.
Handling 404 redirects
When our users stumble across a page on our site that does not exist, we do not necessarily 
want them to be alerted with an application error or our web server's standard 404 page. 
Kohana does not ship with a default 404 page, and it is up to us to determine how we would 
like to accomplish this task.

Troubleshooting and Error Handling
[ 274 ]
The case study site currently displays an exception page when we browse to a page that does 
not exist. Point our browser to http://localhost/egotist/narwhals, and see what is 
rendered:
As you can see, the Kohana routing is invoked, and it looks for a  "narwhals " controller, 
which it cannot find, so it throws an exception. To correct this, we will need to show our 
users a 404 page when their request does not reflect an available page.
Time for action – Adding a custom 404 page
1.	 When a request for a page cannot be found, the standard HTTP response code 
the browser expects is the 404, or Not Found, error. This tells the browser that the 
server is responding, but the requested resource could not be found. Our users do 
not necessarily understand HTTP standard response codes, so we need a human 
friendly page to show our users when they ask for something that does not exist.
2.	 Open the bootstrap.php, and replace and remove the following code:
if ( ! defined('SUPPRESS_REQUEST'))
{
   /**
    * Execute the main request. A source of the URI can be passed, 
eg: $_SERVER[‹PATH_INFO›].
    * If no source is specified, the URI will be automatically 
detected.
    */

Chapter 8
[ 275 ]
   echo Request::instance()
              ->execute()
              ->send_headers()
              ->response;
}
3.	 Now, insert the following code where the previous code was placed. We are just 
replacing the old code with this new snippet:
/**
 * Execute the main request using PATH_INFO. If no URI source is 
specified,
 * the URI will be automatically detected.
 */
$request = Request::instance();
try
{
       // Attempt to execute the response
       $request->execute();
}
catch (Exception $e)
{
       if (Kohana::$environment == Kohana::PRODUCTION)
       {
              // Just re-throw the exception
              throw $e;
       }
       // Log the error
       Kohana::$log->add(Kohana::ERROR, Kohana::exception_
text($e));
       // Create a 404 response
      $request->status   = 404;
      View::set_global(‹site_name›, ‹Egotist Beta›);
      $request->response = View::factory(‹template›)
              ->set(‹title›, ‹404›)
              ->set(‹styles›, array(
                    ‹reset›,
                    ‹common›))
              ->set(‹scripts›, array())
              ->set(‹content›, View::factory(‹errors/404›));
}
/**
 * Display the request response.

Troubleshooting and Error Handling
[ 276 ]
 */
echo $request->send_headers()->response;
4.	 Now, we will need to create a view to be displayed when a user is shown the 404 
page. Create a new view folder in /application/views/ named errors.
5.	 In the new /application/views/errors/ directory, create a new file named 
404.php with the following contents:
<?php defined('SYSPATH') or die('No direct script access.'); ?>
<h1>The page werequested does not exist or could not be found.</
h1>
6.	 Now, we can refresh the page and see a friendly page not found message:
What just happened?
The legacy code simply executed the request and sent the response. We replaced this code 
with something that first creates an instance of the request, and then attempts to execute it. 
If the execution fails, it will throw an exception that the catch block will handle.

Chapter 8
[ 277 ]
The error is then logged, and a 404 response is generated. Because our template relies on 
some setting for styles, site name, etc., we needed to set some view variables for our new 
404 page. Then, after the try/catch block, the request is executed and sent to the end 
user.
Next, we created a very simple view script to display to the user when a 404 page is 
encountered. The rendered page is much more helpful than an exception error, and will 
provide better usability for our application.
The above method is based on the bootstrap posted by Kohana's founder and Benevolent 
Dictator for Life, Woody Gilk (shadowhand), that is located at https://github.com/
shadowhand/wingsc/blob/master/application/bootstrap.php. This is not the 
only solution for sending users to a 404 page. There are several very good solutions available 
online that offers other methods to handle this issue. Some provide more functionality or 
flexibility to make handling these types of errors more elegant.
A great article by Mathew Davies located at http://kohanaframework.org/3.0/
guide/kohana/tutorials/error-pages gives some very good examples of improving 
the included exception handling. The  "unofficial Kohana 3 wiki " also provides a solution by 
catching Reflection exceptions. To view this tutorial visit: http://kerkness.ca/wiki/
doku.php?id=routing:404_pages_by_catching_reflection_exception.
Sometimes the issues with our projects are not necessarily bugs or errors. Even a working 
application can have other problems, like performance and load times. There are often times 
more efficient ways to perform certain tasks, or areas of an application that are taking far too 
long to complete and could be refactored or handled differently. To find these bottlenecks, 
inefficient code, or explanations for performance issues, profiling can provide the relevant 
information we need.
Profiling our applications
The more information we have about our application, the more we can do to make it work 
exactly how we want. Generating statistics about the performance and execution of our 
application can provide the much-needed insight to tweak and tune our scripts to their 
maximum potential.
To create the code necessary to measure the performance of our application accurately and 
then display the data could take quite a long time. Implementing other profiling libraries 
would mean adding more code to our projects, and having to maintain this codebase.

Troubleshooting and Error Handling
[ 278 ]
Time for action – Adding profiling to the case study project
Kohana not only provides a profiler for our use that is unbelievably simple to use, they made 
it powerful as well.  With only a few lines of code, we can have a wealth of information about 
the performance of our application.
1.	 First, let's open the/application/boostrap.php file and check the environment 
variable and make sure it is set to the development constant:
Kohana::$environment = Kohana::DEVELOPMENT;
2.	 In the footer view, located at /application/views/common/footer.php, add 
the following code at the bottom of the file:
<?phpif (Kohana::$environment == Kohana::DEVELOPMENT) : ?>
<div id=»kohana-profiler»>
   <?phpecho View::factory(‹profiler/stats›) ?>
</div>
<?phpendif; ?>
3.	 Now, as long as we are using the development environment, the profiler will run and 
display the results in the footer. Go to the case study site's home page, and view the 
output:

Chapter 8
[ 279 ]

Troubleshooting and Error Handling
[ 280 ]
What just happened?
First, we explicitly defined the application environment in the bootstrap file, and then used 
that information to determine whether we were in development or production. If we set the 
environment variable to production, the profiler data will not be displayed.
In our footer, we added the profiler statistics and have them echoing out on every page. 
This will allow us to get stats and information about the requests, framework calls, database 
queries, and overall load times and memory usage.
Being able to see the SQL queries being performed and the amount of time they take can 
quickly alert us to queries that are malformed or under normalized. Sometimes retrieving 
data in a different fashion can greatly affect performance, and profiling can help pinpoint the 
queries that need examining.
Application execution time and memory use are both very important factors to consider 
when we are working on a project. If our pages take too long to load, our users may not 
continue to use our application. If the memory use and database retrieval times are too high, 
our hosting services will require more hardware, and will in turn create a more expensive 
hosting solution.
By writing efficient code, and using profiling statistics to find bottlenecks and inefficiencies 
for correction, we can write code that not only works, but also works well. If our code is fast, 
efficient, and effective, we can always combat high traffic with front-end optimization and 
additional resources.
Pop quiz – Troubleshooting and Error Handling
1.	 Which of the following methods is used to display a variable's data in a browser 
friendly format?
a.	
Kohana::show_errors()
b.	 Debug::dump()
c.	
Kohana::debug()
d.	 Kohana::debug_html()
2.	 How many variables can we pass to Kohana::debug()?
a.	 One
b.	 Two
c.	
10
d.	 Unlimited

Chapter 8
[ 281 ]
3.	 What method is used to show the source code for a specific area of a file?
a.	
Kohana::debug_source()
b.	 Kohana::source_debug()
c.	
Kohana::show_source()
d.	 Kohana::render_markup()
4.	 To disable Kohana's internal exception handler, we will need to set the 'errors' to 
FALSE in which method in our bootstrap?
a.	
Route::set()
b.	 Kohana::$environment
c.	
Kohana::$log
d.	 Kohana::init()
Summary
In this chapter, we learned a lot about error handling and troubleshooting our applications 
in Kohana. More specifically, we covered how to use Kohana's internal debug methods to get 
browser friendly variable dumps, using the exception handler to get more information on 
errors, using the error logs in development mode, creating custom 404 pages, and profiling 
our applications to understand performance issues.
Not all problems with our applications will come in the form of errors or requests for pages 
that do not exist. Unlike the bugs in our code, we have no way of fixing our users. Some of 
them will prove to be malicious, and our applications will need to be secure to keep these 
users from wreaking havoc, using our site for spam, or just making a mess of things. In the 
next chapter, we will discuss methods to secure our applications, and keep our code safe 
from attacks.


9
Securing and Deploying Kohana 3
If there is any one rule of web development, it is to never trust users. After we release an 
application into the wild, people will begin to use our application, spiders will begin to crawl 
and index our site, and eventually the security will be tested. Kohana ships with many great 
features to aid us in protecting our application from common dangers, and along with some 
good practices, we can prepare our applications for the world.
In this chapter, we will learn:


XSS attacks, and how to prevent them


Protecting against SQL injection


Securing cookies and session data


Preparing our application for production


Using Kohana with multiple applications


Final considerations for going live
Securing our applications
There are entire series of books, college courses, and careers dedicated solely to web 
application security, and it should be noted that the information provided in this chapter is 
an overview of some features and methods that are available to help minimize the security 
risk that is inherent in web applications. By using good security practices and never trusting 
user-generated data without sanitizing, we can eliminate the vast majority of possible attacks 
against our applications.
Kohana does provide several features to aid us in protecting our applications from malicious 
users. One of the most basic security features we can employ is to sanitize all user-generated 
data that is being stored in a database or rendered in a browser. Cross-site scripting (XSS) 
attacks are becoming more common, and one of the basic ways to invoke an XSS attack is via 
injected JavaScript.

Securing and Deploying Kohana 3
[ 284 ]
XSS attacks
Cross-site scripting (XSS) attacks are carried out by injecting client-side (usually JavaScript) 
code into a web page. When that page is then visited by other users, the code is executed 
and the possibilities are nearly endless as to what they can do. XSS attacks are by and large 
the most prolific and successful hacks against web applications. Although these attacks are 
relatively easy to execute, preventing them can be even easier.
Let’s take a look at the case study site. When a user creates a message, that message is 
stored in the database, and then directly output in the page. Because there is not any 
consideration given to the content that could be input, other than form validation, this 
leaves a very large risk to XSS attacks.
For an attacker to successfully use our site successfully to exploit our users, they first need to 
be able to run a script on the site. JavaScript is the method of choice for these attacks, and 
can be easily injected by including it in a message.
If a user posts the following message, for example:
Hello World<script type=”text/javascript”>alert(‘XSS Code Goes 
Here’);</script>
It will pass the form validation and be inserted into the database. When the page 
containing this message is displayed, the following JavaScript alert box will be shown:
After the alert box is shown, the “Hello World” message is displayed along with the other 
messages, like nothing ever happened. Of course, the script did not need to alert anyone of 
anything, it simply could have just run the malicious code and gone on about its day, no one 
the wiser.
This is a very harmless example, however, once it is known that JavaScript can be executed, 
the sky is the limit. An attacker can load larger JavaScript files from other locations, use XHR 
requests to store visitor information, and wreak all sorts of havoc on our site. Thankfully, this 
can easily be prevented by properly sanitizing our data.

Chapter 9
[ 285 ]
There are several different ways we can address this issue. First, if we are not wanting any 
HTML to be displayed in the messages, we can convert any special characters to HTML 
entities. Second, we could use PHP’s strip_tags() function, but this can end up removing 
unwanted text if it matches, and could be troublesome. Lastly, if we did want some HTML to 
be rendered, we could use a library like HTML Purifier (http://htmlpurifier.org/) and 
the Kohana module for it (https://github.com/shadowhand/purifier).
Time for action – Securing against  XSS risks
We really do not need to show any HTML in our messages, they really should just be text. 
We can go ahead and use the HTML::chars() helper to run displayed messages through 
htmlspecialchars() and fix this security flaw:
1.	 Open and edit the view at /application/views/welcome.php, and update 
with the following code:
<h1>Recent Messages on Egotist</h1>
<?php foreach ($messages as $message) : ?>
   <p class=”message”>
           <br />
          <span class=”published”>
                <?php echo Date::fuzzy_span($message->date_
published)?> 
           </span>
   </p>
   <hr />
<?php endforeach; ?> 
<?php echo $pager_links; ?>
2.	 Open and edit the view at /application/views/profile/public.php, 
and update with the following code:
<h3>Your Recent Messages:</h3>
<?php if (count($messages)) : ?>
   <?php foreach($messages as $message) : ?>
           <p class=”message”>
                 <br />
                <span class=”published”><?php echo Date::fuzzy_
span($message->date_published)?></span>
          </p>
          <hr />
   <?php endforeach; ?>
<?php else: ?>

Securing and Deploying Kohana 3
[ 286 ]
 <?php endif; ?>
<?php echo $pager_links; ?>
Open and edit the view at /application/views/profile/private.php 
and update with the following code:
<h3>Your Recent Messages:</h3>
<?php if (count($messages)) : ?>
   <?php foreach($messages as $message) : ?>
          <p class=”message”>
                  <br />
                 <span class=”published”><?php echo Date::fuzzy_
span($message->date_published)?></span>
                 <?php if (time() - $message->date_published < 
900) : ?>
                       <div class=”options”>
                              <a href=”<?php echo 
url::site(“messages/edit/{$message->user_id}/{$message->id}”) 
?>”>Edit Message</a> | 
                              <a href=”<?php echo 
url::site(“messages/delete/{$message->user_id}/{$message->id}”) 
?>”>Delete Message</a>
                        </div>
                 <?php endif; ?>
            </p>
          <hr />
   <?php endforeach; ?>
<?php else: ?>
   <p>You have no messages in the system.</p>
<?php endif; ?>
<p><?php echo HTML::anchor(‘messages/add’, ‘Create New Message’); 
?></p>
<?php echo $pager_links; ?>
Open and edit the view at /application/views/profile/messages.
php and update with the following code:
<?php foreach ($messages as $message) : ?>
   <p class=”message”>
           <br />
          <span class=”published”>
                 <?php echo Date::fuzzy_span($message->date_
published)?>
          </span>
          <?php if (time() - $message->date_published < 900) : ?>
                <div class=”options”>
                       <a href=”<?php echo url::site(“messages/
edit/{$message->user_id}/{$message->id}”) ?>”>Edit Message</a> | 

Chapter 9
[ 287 ]
                       <a href=”<?php echo url::site(“messages/
delete/{$message->user_id}/{$message->id}”) ?>”>Delete Message</a>
                 </div>
           <?php endif; ?>
   </p>
   <hr />
<?php endforeach; ?>
<?php echo $pager_links; ?>
3.	 Open our header view file, and clean the username that is displayed when a user is 
logged in. This view is located at /application/views/common/header.php 
and should be edited as follows:
<div id=”logo”>
   <img src=”<?php echo url::base(); ?>media/images/logo.png” 
alt=”<?php echo $site_name; ?>” />
</div>
<p id=”tagline”>
   <em>Because it’s all about you!</em>
</p>
<ul id=”main_nav”>
   <li><a href=”<?php echo url::site(); ?>”>Home</a></li>
   <li><a href=”<?php echo url::site(‘page/about’); ?>”>About 
<?php echo $site_name; ?></a></li>
   <li><a href=”<?php echo url::site(‘page/why_egotist’); ?>”>Why 
use Egotist?</a></li>
</ul>
<p id=”account”>
<?php if (Auth::instance()->logged_in() && $user = 
Auth::instance()->get_user()) : ?>
 <?php else: ?>
   <?php echo HTML::anchor(‘login’, ‘Login’); ?> | <?php echo 
HTML::anchor(‘signup’, ‘Signup’); ?>
<?php endif; ?>
</p> 
What just happened?
In the welcome view, we started by running the HTML::chars() helper method on any 
usernames and message content that is being displayed on the page. It is possible that a 
username could also contain malicious data, and we don’t want that displaying unfiltered 
either. The HTML::chars() helper simply calls PHP’s htmlspecialchars() function, but 
it is shorter and easier to type.

Securing and Deploying Kohana 3
[ 288 ]
While we were preventing XSS attacks by securing our messages and usernames, we also 
added some minor functionality. Adding the author’s username and a link to their public 
messages was very simple. Because of the ORM’s relationships, simply calling $message-
>user->username outputs the name of the author of the message.
In the next few files, we repeated this same refactoring: using HTML::chars() to convert 
message content and usernames to special characters.
The other place a username is displayed is in the “Logged in” section in the header, and 
this could also pose a threat. We applied the same sanitization in the header file where 
the logged in user’s name is displayed.
Typically, we should be thinking about XSS attacks constantly while we are writing our code, 
especially in our view scripts. The vulnerabilities we just closed were left exposed for the 
sake of illustration in this book, but you are advised to use the methods described above 
while crafting any scripts for any application. You should also be aware that view scripts are 
not the only place that an attacker’s code could be run. Any time we are using data that is 
not trusted, we should think about the potential risks, and attempt to prevent them when 
possible.
Another popular target for web applications is the database. SQL injection is a common 
problem that can occur when developers are not carful about running queries that contain 
unsanitized data, and can potentially bring down an application, expose sensitive data, or 
display user’s information. Kohana does provide us with some tools to keep this style of 
attack at bay.
SQL injection
SQL injection is a form of attack where variable data contains SQL statements that were 
never intended to be executed. This type of attack can be very successful when the target 
does not properly escape or filter variable data that is inserted into SQL queries.
Because many developers do not properly escape user-generated data when forming their 
SQL queries, the database layers of many web applications have vulnerabilities to this style of 
attack. By appending or crafting additional SQL statements into a form field, this value is then 
inserted into a query, for example, and attacker can view, alter, or delete stored information.
The popular web comic xkcd has a wonderful strip illustrating SQL injection where “little 
Bobby Tables” wreaks havoc on the school’s database by using his name as a SQL injection 
string.  You can read the strip here: http://xkcd.com/327.
Thankfully, Kohana’s Database module automatically escapes our variables when they are 
inserted, provided we are not writing our queries manually. As long as we are using the 
database builder to construct our queries, we will not need to escape our data manually. 
But what happens if we are not using the database builder?

Chapter 9
[ 289 ]
Kohana has us covered there also. Depending on the database driver we are using, 
the escape characters could be different. Because the Database library is agnostic, it 
provides a universal escape method that is unique to each database type. We can use 
the Database::escape() method to properly escape any data we are going use in a 
constructed query.
We also have the option of using prepared statements to construct our queries, and then 
passing the parameters into the statement using the DB::query() method combined with 
the DB::param() method. This will allow us to construct pre-built statements and add the 
parameters as needed. This way, the database will know there are variables being passed to 
it and can treat them accordingly.
Because the case study site is using the ORM and Query Builder to construct all the SQL 
queries that are needed to run the application, there is no further action necessary to 
harden the application from database injection attacks. If we find ourself writing queries, 
please be mindful of this security risk and escape our data judiciously.
Cookies and sessions
Cookies and sessions provide much needed functionality for applications where data needs 
to be accessible from our application; however, they do provide attackers another means 
of infiltrating our application. Session hijacking and cookie manipulation can pose serious 
threats to our projects, and should not be taken lightly.
The basic function of cookies and sessions is the same: We need the ability to access data 
stored that is associated with our user. While sessions provide a more persistent solution 
when combined with the database storage option, and can hold more information, cookies 
are more short term, and because all the data is stored on the user’s machine, less secure.
Kohana not only provides a very easy way to work with cookies and sessions, it also makes 
it very simple to keep them secure. Both the cookie and session classes provide some very 
thoughtful methods to thwart potential attacks.
Securing cookies
Kohana makes setting and getting cookie data very simple, as we have seen earlier in this 
book. The Cookie class also allows us to set encryption, expiration, and other restrictions 
to limit the exposure of our cookies and their vulnerability to unwanted manipulation.
The first line of defense is to encrypt our cookie data, and salt it with a unique string. By 
salting the cookie, we are further increasing the complexity to decrypt the stored data. It is 
important to use a salt string that is unique, and not known to others. This string should be 
secret, and all cookies should use a salt to set and retrieve any information. The purpose of 
the salt is to ‘sign’ the cookie. If an attacker alters the contents of the cookie, the signature 
will not match, and the Cookie::get() method will delete the cookie.

Securing and Deploying Kohana 3
[ 290 ]
We can set the salt for our cookies by assigning a value to the Cookie class’s $salt property:
Cookie::$salt = ‘Daisy, Daisy, Give me our answer do’;
By setting an expiration for our cookies, we are not only making sure the data is still relevant 
to our needs, we are also limiting the amount of time a cookie can be exposed to brute 
force attacks. With proper salting, the entropy of the encryption should be very high, and 
combined with a reasonable expiration date, our cookies are pretty secure.
To set the expiration for a cookie, we need to assign an integer to the $expiration 
property in the Cookie class. Using the Date helper class makes it human readable:
Cookie::$expiration = Date::WEEK;
There are a few more methods available to us to limit the exposure of our cookies further. 
Using the Cookie::$path property allows us to specify the exact path of the URI in which 
the cookie is allowed, and the Cookie::$domain property will set the domain from which 
the cookie can be accessed.
To set the domain for a cookie, we can do the following:
Cookie::$domain = ‘www.packtpub.com’; 
To allow the cookie to be accessed from all subdomains, we can simply use a leading dot:
Cookie::$domain = ‘.packtpub.com’;
To specify a particular path:
Cookie::$path = ‘/somepath/’;
Also, we can restrict the cookie to only HTTPS (secure) connections:
Cookie::$secure = TRUE;
Lastly, we can prevent JavaScript from accessing our cookies by requiring that our cookies 
should be only accessible through the HTTP protocol. This is an effective way to reduce XSS 
attacks, although it is not supported by all browsers. See http://php.net/setcookie for 
more information. We can set this using the Cookie class as follows:
Cookie::$httponly = TRUE;
To protect the case study site further, we can implement better cookie security by creating 
a default salt and expiration for any cookies created in the application. By modifying the 
bootstrap, we can ensure that all cookies we write will have a salt and expiration, and 
therefore will add more security to our data.

Chapter 9
[ 291 ]
To add salted cookies and cookie expiration to the case study site, open the bootstrap 
(/application/bootstrap.php) file, and add the following lines of code in the 
configuration section directly above the Kohana::init() section:
Cookie::$salt = ‘N@rwhals can tr!force’;
Cookie::$expiration = Date::WEEK;
By adding this code to the bootstrap, every cookie we create will be salted and have an 
expiration of one week set by default. We can override these setting when we create our 
cookies, or allow the default application settings to take effect.
This is a simple way to make sure we keep the data we store in our user’s browsers safe 
and free from manipulation. Combined with good programming practices, and not storing 
sensitive information in cookies, we can prevent many attacks that could potentially expose 
our users, and our application, to unwanted intrusion.
Securing sessions
Sessions are important in many applications, and we rely on the information contained in 
sessions for our applications to work properly. User authorization, authentication states, 
and other vital data is stored in sessions, and session hijacking is a favorite exploit used by 
hackers.
By stealing or mimicking another user’s session information, a hacker can masquerade as 
another user, maybe even a user with authentication levels higher than their own, or access 
to parts of the application that most users do not have. They can also then use their fake 
identity to cause all sorts of damage, and do so under the guise of another account.
Protecting our application and users from this form of attack is simple when we use the 
Session library and configure it properly. Like the Cookie class, the Session class allows us 
to encrypt and expire our data, further preventing the possibility of an attacker gaining 
unwanted access.
Depending on the driver we are using for our session handling, there are different 
configuration options available. In the case study site, we are using the database driver to 
store our persistent information. This allows our data to be stored longer, and retrieved 
even after the user’s browser has been closed and reopened. The framework also offers the 
native PHP session handler and an optional cookie adapter. For full configuration options for 
all three adapters, please refer to the user guide (http://kohanaframework.org/3.0/
guide/kohana/sessions#session-adapters).Currently, the case study site is not 
defining encrytption or expiration times for sessions. Adding these security enhancements to 
the application is very simple, and only requires adding only a couple of lines of code. Open 
the session configuration file at /application/config/session.php, and edit it to 
include the following options:
<?php defined(‘SYSPATH’) or die(‘No direct script access.’);

Securing and Deploying Kohana 3
[ 292 ]
   
return array(
   ‘database’ => array(
          ‘table’ => ‘sessions’,
    ),
);
Now that the configuration file includes the encrypted and lifetime information, our sessions 
will expire after the lifetime value, and the contents will be stored in our database after it is 
encrypted. This is a very simple step that can prevent session hijacking and data theft from 
our users and application.
Configuring the application environment
The application environment lets the framework, and our application code, know what 
audience the application is serving. While in development mode, we want full stack 
trace information for errors so we quickly and easily debug any issues as they arise. In a 
production environment, this could be giving away valuable information to our visitors.
When an error is thrown, for example, the stack trace can include the names of our files, 
directories, database table information, raw queries, and other data that is not meant for 
our users to be viewing. Not only is it unprofessional looking, it can pose a significant 
security risk.
The userguide offers the following example for setting our Kohana environment. 
We can replace the current Kohana::$environment settings with this code in the 
bootstrap.php file:
/**
 * Set the environment string by the domain 
 * (defaults to Kohana::DEVELOPMENT)
 */
Kohana::$environment = ($_SERVER[‘SERVER_NAME’] === ‘localhost’) ?
Kohana::DEVELOPMENT: Kohana::PRODUCTION;
This will check for the environment based on the current server name. If we are using a 
server name other than localhost, we will need to make the appropriate change.
We will also want to make sure the request execution is in a try/catch block, so we 
can catch and handle any application errors without displaying the stack trace and error 
information to our users. Because we have already done this to accomplish 404 page 
handling in our project, no further configuration to the bootstrap is necessary.

Chapter 9
[ 293 ]
The example bootstrap that the user guide uses to illustrate a good production setup looks 
like this:
/**
 * Set the environment string by the domain (defaults to 
Kohana::DEVELOPMENT).
 */
Kohana::$environment = ($_SERVER[‘SERVER_NAME’] !== ‘localhost’) ? 
Kohana::PRODUCTION : Kohana::DEVELOPMENT;
/**
 * Initialise Kohana based on environment
 */
Kohana::init(array(
    ‘base_url’   => ‘/’,
    ‘index_file’ => FALSE,
    ‘profile’    => Kohana::$environment !== Kohana::PRODUCTION,
    ‘caching’    => Kohana::$environment === Kohana::PRODUCTION,
));
 
/**
 * Execute the main request using PATH_INFO. If no URI source is 
specified,
 * the URI will be automatically detected.
 */
$request = Request::instance($_SERVER[‘PATH_INFO’]);
 
try
{
    // Attempt to execute the response
    $request->execute();
}
catch (Exception $e)
{
    if (Kohana::$environment === Kohana::DEVELOPMENT)
    {
        // Just re-throw the exception
        throw $e;
    }
 
    // Log the error
    Kohana::$log->add(Kohana::ERROR, Kohana::exception_text($e));
 
    // Create a 404 response
    $request->status = 404;
    $request->response = View::factory(‘template’)
      ->set(‘title’, ‘404’)
      ->set(‘content’, View::factory(‘errors/404’));

Securing and Deploying Kohana 3
[ 294 ]
}
 
if ($request->send_headers()->response)
{
    // Get the total memory and execution time
    $total = array(
      ‘{memory_usage}’ => number_format((memory_get_peak_usage() - 
KOHANA_START_MEMORY) / 1024, 2).’KB’,
      ‘{execution_time}’ => number_format(microtime(TRUE) - KOHANA_
START_TIME, 5).’ seconds’);
 
    // Insert the totals into the response
    $request->response = str_replace(array_keys($total), $total, 
$request->response);
}
 
 
/**
 * Display the request response.
 */
echo $request->response;
Referring to this bootstrap configuration for future projects would be wise, and looking 
over the code for a complete understanding of what the author is doing in this code is very 
helpful when considering what is needed for production.
Apart from testing and utilizing the security features that we have learned about in the 
framework, there are a few other considerations we will need to think about when preparing 
our application for a production environment. Generally, the production and development 
systems differ significantly; however, there are some things that we will always want to think 
about.
Preparing for production
Once our application is complete, we will want to publish it for our users. When we do this, 
there are some steps that we will want to take to secure and deploy our project properly. 
This process is not difficult, but we should be vigilant to minimize the possibility for errors, 
and maximize the potential for success.
Before we begin configuring and structuring our application for prime time, we should 
probably do a little house-cleaning first.

Chapter 9
[ 295 ]
Removing unnecessary files
The framework ships with several files that we will not need when our site is in production. 
Although it is not completely necessary to remove these files, their presence is unneeded, 
and any information that we are providing could be used to gain more knowledge about our 
program that we care to distribute.
We should peruse our files for bloat, removing example .htaccess files, test bootstraps, 
example controllers, unneeded mark-down documents, and other meta data files that we 
do not need to execute the application. Having different bootstraps for every environment 
is encouraged, allowing modules like the API Browser to be disabled in production, further 
limiting the amount of information we are distributing to potential attackers.
This is also a good time to compress our CSS and JavaScript files in our media directory. By 
compressing and minifying our scripts and styles, we will decrease our page load times and 
decrease the amount of data that our users must download to properly experience our 
application.
Directory structure considerations
Our hosting options will greatly affect the way we can structure our application. If we are 
using a dedicated or virtual private server, then we are usually allowed to configure and 
setup our web server however we prefer. If we are using a shared hosting environment, our 
options may be more limited; however, the methods described here should work on the vast 
majority of shared hosts.
Because Kohana utilizes a front controller design pattern, the only application file that must 
be exposed is our index.php file. Because this file defines the location for our application, 
module, and system directories, they can live practically anywhere on our server. Most 
shared hosts allow us to view one directory level above the web root, and if they do not, 
some .htaccess changes will usually allow us some flexibility.
If we move the index.php file, along with any other files that will need to be directly 
accessed, like our CSS, JavaScript and other media (like images), and only expose that 
directory to the public, then our code is protected, even if the directory contents are 
accidently viewable by our audience.
Setting up our application to expose only our public files is very easy using the front 
controller pattern used by Kohana. Remember, every single request for our application is 
going to be routed to the index.php file. In this file, the paths to our application, system, 
and module directories are defined, and all routing and requests begin and end with this 
front controller. This makes it very simple to arrange our files for production.

Securing and Deploying Kohana 3
[ 296 ]
Consider the following directory structure:
application/
modules/
system/
public/
   .htaccess
   index.php
   media/
      css/
      js/
      images/
Here, our web server would use the public directory as our document root, and our index.
php file would define the proper paths for the framework to operate. Using this structure, 
even if the directory was accidently left open, and the files could be read, no important 
information would be available.
To use this structure, we would need to update our webserver to use our /public/ 
directory and make the following changes to the path definitions in our index.php file:
$application = ‘../application’;
$modules = ‘../modules’;
$system = ‘../system’;
This allows Kohana to know exactly where the include paths need to point. Theoretically, 
we could put these directories anywhere we desire, just as long as they are readable by the 
front controller. By exposing the least amount of information possible, we are reducing the 
risk of having our application live on the Web.
Have a go hero – Structure case study site for production
Although the case study site still leaves a lot to be desired in forms of additional 
functionality, design aspects, and usability, it has served as a great example application for 
learning the framework. Now, you can prepare the directory and file structure of the project 
to fit the example directory structure shown above. Create a new public directory, move 
the front controller and media files into it, and update the necessary settings to access the 
included framework files from outside the document root.
Remember, as you continue in your Kohana development endeavors, the case study site is 
always there for you to test, add on to, and use as a sandbox for continued experimentation.

Chapter 9
[ 297 ]
Multiple Application Configuration
The other major advantage to the front controller pattern, especially when combined with 
transparent extension, is the ability to have more than one application using the same 
framework core and modules. Think about it; if we have more than one Kohana application 
running on the same server, there is no need to have multiple installations of the same 
system and modules directories, housing the exact same files.
Defining the structure and environment is almost infinite in possibilities, and we can design 
our server setup however works best for our needs. The user guide provides some examples 
on how we can accomplish this task, and we can further explore our options by reading the 
examples provided there if we need further ideas on how we can accomplish sharing Kohana.
A basic shared setup may have a directory structure similar to this:
apps/
    site_one/
        application/
        www/
    site_two/
        application/
        www/
kohana/
    3.0/
    3.1/
    ...
modules/
   auth/
   database/
   ...
Here our applications all live in the /apps/ directory, and have their own /application/ 
and /www/ directories to store their application logic and public files. Each application’s 
index.php file would select the proper location of the application, Kohana core, and 
module directories without having to keep more than one copy.
This configuration can make updating our sites easier as we only have one place that we 
must keep up to date. This also makes it easy to have more than one version of Kohana 
present, so we can have applications that are using different versions, all sharing the same 
structure. For example, this could be a great way to structure a staging server where we may 
have several different projects all using the same server.
By setting up our servers this way, we are also only having to keep one set of modules 
updated, and common modules that we share between applications are also stored in one, 
easy-to-find location.

Securing and Deploying Kohana 3
[ 298 ]
Updating the Configuration settings
When it comes time to move our application to its new home, we will need to remember 
that there are some additional configuration settings that will be different than in 
development. If we are using Apache as our web server, for example, we will need to update 
the .htaccess file to reflect the new server environment properly. Some people prefer to 
use the virtual host configuration for production, and forego using .htaccess altogether. 
Either way, we will need to let the web server know where the index.php file is located, 
and how to properly rewrite the URLs. Usually, this just means editing the RewriteBase 
location in the .htaccess file.
Next, we will want to update the bootstrap.php file one last time. Here, we will want to 
set the base URL for our new location in the Kohana::init() method for the base_url 
key. This is very important. Without this step our links will not be right, and our application 
will likely not work at all until it is updated.
Modules will need to be considered when deploying to production. The API Browser in the 
userguide module, for example, shows a lot of information about our application to the 
world, and this module will need to be turned off in production. Also, the salt in the Auth 
module should be changed on the production server.
Once we have properly configured our application, it is ready for the world. Kohana’s security 
and reliability make deploying and hosting complex web application simple, and hopefully 
you have found the configuration and setting for production quick, simple, and painless.
Pop quiz – Preparing an application for production
1.	 Which of the following properties holds the current application environment 
setting?
a.	
Kohana::$application
b.	 Kohana::$production
c.	
Kohana::$environment
d.	 Environment::$kohana
2.	 Kohana provides which method to to invoke htmlspecialchars() on a string?
a.	
XSS::filter()
b.	 Filter:: clean()
c.	
HTML::clean()
d.	 HTML::chars()

Chapter 9
[ 299 ]
3.	When writing SQL queries without the aid of the Query Builder or prepared 
statements, which method will properly escape data based on the database used?
a.	
Database::mysql_real_escape_string()
b.	 Kohana::htmlspecialchars()
c.	
MySQL::escape()
d.	 DB::escape()
4.	 You can increase the entropy of encrypted cookies by salting them. What is the 
method used to salt cookies?
a.	
Salt::cookie()
b.	 Cooke::salt()
c.	
Session::salt()
d.	 Cookie::encrypt()
Summary
In this chapter, we learned about securing our applications and preparing them for the 
production environment. More specifically, we covered what XSS attacks are, and how to 
prevent them, preventing SQL injection using the Database library, escaping SQL statements 
for manual queries, securing session and cookie data, and configuring an application to be 
used in production.
In the next chapter, we will look at migrating from earlier version of Kohana and CodeIgniter 
to the newest version of Kohana.


Upgrading from CodeIgniter and 
Kohana 2
Kohana began as a fork of CodeIgniter, getting its roots from the popular, open-source 
project that became one of the first major MVC frameworks to entice PHP developers. 
CodeIgniter is often sited as a great framework to introduce PHP developers to the MVC 
pattern, and has a large and faithful following. Kohana built upon the CodeIgniter philosophy 
and code base, and quickly had a framework that took advantage of newer versions of 
PHP, and the community-driven nature of the project brought with it many developers that 
embraced the Kohana 'upgrade'.
The newest version of Kohana, version 3.x, is the result of a complete rewrite, leaving any 
legacy ties to CodeIgniter behind. As the framework continues to mature, more developers 
are finding themselves wanting to move away from older versions of Kohana, or CodeIgniter, 
and embrace the new features available with the newest iteration of the framework.
In this chapter, you will learn:


The differences between CodeIgniter and Kohana


How to make the move from CodeIgniter to Kohana 3.x


The differences between Kohana 2 and Kohana 3


Migrating from Kohana 2 to Kohana 3


Porting your code to the newest version of Kohana


Upgrading from Kohana 3.0.x to 3.1.x

Upgrading from CodeIgniter and Kohana 2
[ 302 ]
Determining the practicality of porting existing applications to the newer versions of Kohana 
will need to be weighed on a case-by-case basis. Most Kohana developers would likely argue 
that moving form CodeIgniter or Kohana 2.x to Kohana 3.x would be more appropriately 
be referred to as a rewrite, and not simply porting code over. This was not the case when 
moving code from CodeIgniter to earlier versions of Kohana, where the API was so much 
alike, that the process could be very easy, depending on the complexity of your application.
To better understand the path from CodeIgniter to Kohana, it is good to recognize the 
differences between the frameworks first, and then look at how you can make the 
transition to Kohana from its predecessor.
What makes Kohana different from CodeIgniter?
There are several different views on what should be considered the primary differences 
between these two frameworks. Both are popular, well-used PHP frameworks, and both 
have many similarities. The reason for their similarities is simple: Kohana began as a fork of 
the CodeIgniter codebase, and was done so with the idea of community development and 
PHP 5 compatibility.
The first two major versions of Kohana were so similar to CodeIgniter, you could almost copy 
your application directory content between the two frameworks, tie up some loose ends 
(like view variables and helpers), and your application was successfully ported from one to 
the other.
As time passed, Kohana's development process and release cycle began to take shape. Early 
in the framework's development, there were some concerns with development instability 
amongst the community; however, over time the dev team has been able to develop 
a continuous integration environment with a good release cycle. This results in faster 
adaptation of new opportunities at some cost; for example, the API changes between dot 
releases like the ones experienced between 3.0 and 3.1. This is offset by having one year 
of support for each release to iron out bugs and stabilize the code base for that particular 
release.
Where CodeIgniter hung onto its PHP 4 base, and had a lot of procedural-style code working 
under the hood (like a single view variable), Kohana moved towards the more powerful 
aspects of the emerging OOP technologies that PHP 5 was offering.
By embracing the newest features in PHP, particularly object-oriented additions like the SPL 
and autoloading, Kohana had to break the backward compatibility that is often associated 
with CodeIgniter. Many critics of Kohana point to this exact argument as a reason not to 
make the switch.

Appendix
[ 303 ]
I am not a Kohana evangelist (at least not officially), and my job is not to convert people 
from one framework to another. Personally, I think both frameworks have been great for 
the PHP community as a whole; both are well written and do their jobs well. That being 
said, sometimes backwards compatibility is a hindrance, not an asset.
By recognizing that there could be incompatibilities between major releases of Kohana, 
you can plan to develop you applications in the version that makes the most sense for you, 
and based on the history of the framework, that branch will not be completely abandoned 
in mid-development. The official team has a good record of leaving time in the dev cycle 
of a major release to stabilize the code base. For more information on the release cycles 
for Kohana, you can visit https://github.com/kohana/kohana/wiki/Kohana-
Development-Procedures.
Going back to one of the primary reasons for the fork, the Kohana community wanted to 
utilize the OOP power that was new in PHP 5. Maintaining backwards compatibility became 
too much of a burden, and in version 3 of the framework, Kohana grew from its roots and 
combined its experience with the CodeIgniter base with the new offerings in the language.
The result is a new version that more appropriately matches the changes that PHP has gone 
through over the last few years. With this newest version, and the complete rewrite, the 
similarities are very few and far between, other than their respective histories.
Probably the largest difference I hear from people concerns the documentation. CodeIgniter 
is very well documented, and has historically kept its user guide up to date and chalked 
full of example code. The CI community is also known for its vast user forums and support 
among the community.
Kohana, on the other hand, has had a reputation of little documentation, or documentation that 
is outdated or incomplete. In the past this has been the case; however, the well-commented 
code has been the 'user guide' of choice for many of the more devout users. Recently, this has 
changed, and the documentation and user guide has been improving with every update, and 
continues to have more offerings almost daily. Nothing beats reading the Kohana source code, 
and the API Browser and well-documented code base makes doing so pretty simple.
Of course, there are also the modules. Kohana ships with the ORM, Auth module, SPL, 
autoloading, and many other features that are absent in the CI platform, but moreover, the 
modules available for the Kohana framework make it easy to find libraries written specifically 
for the framework for use in your projects.
Many module developers keep their repositories on GitHub (http://github.com), and 
you can search there for modules. More recently, a new site, http://kohana-modules.
com, has begun collecting modules that meet their core requirements and making it easier 
for developers to extend the base framework.

Upgrading from CodeIgniter and Kohana 2
[ 304 ]
Moving from CodeIgniter to Kohana
If you have experience with the CodeIgniter framework, this section is for you. If you are 
not familiar with CodeIgniter, or do not have much experience with it, you may want to skip 
ahead to the next session, where Kohana 3 is compared to its own earlier versions.
Kohana 2.x was extremely easy for CI users with PHP 5 experience to move to. As stated 
earlier, Kohana 3 is a complete rewrite of the framework, with no backwards compatibility, 
and is completely different from versions 1 and 2 of CodeIgniter.
There are some things that are most noteworthy for developers that have used CI in the 
past, and are beginning their journey into Kohana. In the sub-sections that follow, some of 
the more important differences or upgrades are outlined, with some of the more general 
changes and things of which you should be aware.
Autoloading classes
One of the first advantages a CodeIgniter developer finds when making the transition to 
Kohana is the beauty of PHP 5 autoloading. Not having to add classes to the autoload config 
file or using the Loader library to make your classes available is very nice. The ability to call 
any class in your application without worrying about cumbersome config files and include 
methods is one of first things new CI converts discover, and enjoy.
Strict PHP 5 codebase
Many developers that use open source technologies are often searching the source code, 
rather than the docs, for answers to their needs. A quick glance at the Kohana 3 code base 
will reveal strict PHP 5 principles, with interfaces, abstract classes, strong use of design 
patterns, and transparent extension to make customization a snap.
By applying these same techniques to your application and module code, you can enjoy the 
benefits of OOP PHP without having to struggle with a legacy-burdened code base. With the 
wide adaptation of PHP 5, and most recently 5.3, the language is expanding and maturing, 
and your coding practices should mature along with it.
Included ORM
Although the CI and Kohana Query Builders have a lot in common, and both libraries are 
database-agnostic with a similar database abstraction layer, the Kohana 3 database library 
offers far more flexibility and extendibility. After fully exploring the database library, most CI 
developers quickly move directly into the unchartered territory of the ORM.

Appendix
[ 305 ]
Kohana's Object Relational Mapper, which is an official module of the framework, is a great 
addition to the database library for CRUD (Create, Read, Update, Delete) operations and 
basic ORM functionality. As demonstrated in previous chapters in this book, the ORM is a 
powerful tool that makes working with your databases more simple and programmatic.
Best of all, if you choose to use a different database abstraction or ORM library for your 
application, the process of adding modules to your projects is also very easy with Kohana, 
and when coupled with the autoloading of classes, extending the framework with modules is 
a big hit with Kohana devs that are moving from CodeIgniter.
Modules
CodeIgniter does allow for you to create your own libraries, but these are a far cry from 
the power of modules in Kohana 3. Libraries in CI are just that, classes that are designed 
to perform a task. With CI you can either create your own libraries, or extend the existing 
libraries included with the framework.
Kohana takes this concept to an entirely new level with the concept of modules. As modules 
are directly located in the application hierarchy, they have the power to override the core 
and provide functionality for the application. By housing their own configuration files, view 
scripts, class structure, and other framework specific areas, modules can become much more 
powerful than a CI library.
There are complete applications that can run in a submodule. Consider a lightweight CMS 
that was a module for Kohana 3. You could load it into any project, extend and override as 
needed, and rely on the module's view scripts, config files, and assets without having to add 
to your application path.
Lastly, Kohana has a growing community of module developers that are openly sharing their 
creations with the world. At the time of this writing, the Kohana-modules.com (http://
kohana-modules.com) is tracking over 500 publicly available modules, and that number is 
growing steadily.
Moving from Kohana 2.x
Even though official development of version 2.x ended in late 2009, the community has 
continued to use it for quite some time, and there are still developers slowing making the 
switch to the newest versions. This is understandable, as the 3.x versions are not backward 
compatible, and as a rewrite have an entirely new APIs.

Upgrading from CodeIgniter and Kohana 2
[ 306 ]
There are still several similarities between the two, and it is easy to tell you are still using 
Kohana. Most of the changes made to for the new version are focused on better utilizing 
the PHP 5 language, particularly the object-oriented additions. This is a very welcome step 
by experienced PHP developers, but can be a little daunting to those who do not have much 
experience with PHP 5, or other OOP languages.
Because version 3.x is so different from previous versions of Kohana, there is no definitive 
process to port your applications from one version to the next. Unless Kohana 3 has some 
offerings that are absolutely necessary for your legacy projects, you may want to consider 
leaving them in their current framework, as moving them to Kohana 3 will most likely require 
a complete rebuild of your application.
If, however, you are an experienced Kohana 2.x developer, and you are beginning a new 
project, you absolutely should consider using the newest version. Not only is it more 
powerful, the dev team is committed to supporting every release for one full year, with two 
releases always being supported concurrently (much like PHP does). As you are making your 
transition between the versions, there are a few major changes that are worth pointing out.
GET and POST methods
Kohana 2 provided an Input class to help you work with $_GET and $_POST variables, 
however, this class is no longer provided in the framework, and you are advised to revert 
back to using the native PHP $_GET and $_POST variables.
One of the key advantages to using the Input library was the ability to set default values 
for these fields easily. Using the Array class, specifically the Arr::get() method, you can 
accomplish this same functionality. Consider the following:
$foo = Arr::get($_POST, 'foo', 'bar');
This code would default the value of $foo to 'bar' if no key exists in the $_POST array, but 
will use the value in the $_POST array if the key does exist. Using this method to assign 
default values is the preferred method in Kohana 3.
Directory structure
A major change for the framework is the new directory structure that supports the cascading 
filesystem and promotes transparent extension. By utilizing the application, modules, system 
(core) approach, the development team has provided more power and flexibility to web 
developers.
In Kohana 2, each class was designated a particular place to live. Classes with static helper 
methods were placed in a helpers directory, libraries and models had their own place 
to live in the application directory, there was a vendor directory, and they all had a 
purpose.

Appendix
[ 307 ]
Now, the classes directory, either in an application or module location, contains all the 
controller, model, library, and helper classes. You are no longer bound by conventions for 
how you organize these files, but you are encouraged to use the basic structure provided by 
the framework.
The new routing and request handling, combined with the new directory structure and 
cascading file system, greatly increases the extendibility and encourages module development 
within the community. At first, developers moving from Kohana 2 may find the new structure 
cumbersome, but after a little bit of experience, most find it to be a vast improvement.
Naming conventions
Along with a new directory structure, Kohana 3 introduced a new system of class 
declarations and naming conventions. This is one of the primary areas where we can see 
the Kohana design shifting further away from CodeIgniter and moving even closer to Zend 
Framework conventions.
Like Zend Framework, class names follow a pattern that describes their location and 
filename. All classes are named by their parent directories inside the classes directory, 
separated by underscores, and ending with their base filename. For example, a file with a 
location of:
/application/classes/controller/welcome.php
would have a class name of Controller_Welcome.
Likewise, because of the cascading filesystem, the following file would have the same class 
name:
/modules/example/classes/controller/welcome.php
Both of these files would be named Controller_Welcome, and the cascading filesystem 
would look for the controller first in the application path, then in the module path, and lastly 
in the system path.
Inside the classes directory, you can also have other files, all following the same naming 
convention. Consider a model with the following class declaration:
class Model_Comment extends Model_Common
This would look for a file named comment.php in a directory inside classes/model/, and 
would first check for it in the application directory, then in the modules directory, and 
finally in the system location. It would do the same for the class Model_Common, and they 
do not both need to live in the same level, i.e., Model_Comment could be on the application 
level, while Model_Common could live inside a module.

Upgrading from CodeIgniter and Kohana 2
[ 308 ]
A class simple declared as something like:
class Example {
would need to live at /classes/example.php.
Another change that goes along with this new convention is for controller actions. It is very 
simple: Any action must begin with action_. So, inside your Controller_Welcome class, 
you could have an action_index() method that is the default action for that controller. 
This is very easy to remember, and makes perfect sense.
Once you make the switch, and understand the new naming convention for classes, finding 
any class and extending the functionality of any feature or module becomes transparent. 
This may be a significant change for developers that are moving from Kohana 2, but it is one 
that definitely makes the framework better.
Views
In Kohana 2, the view was within the scope of the controller. Essentially, this meant you 
always had access to the controller object by using the $this variable to access the 
controller. In Kohana 3, this changes completely, with the view object no longer directly 
coupled to any controller.
While this may seem strange at first, it allows great freedom for view reuse, and the loose 
coupling approach provides extreme amounts of flexibility over the previous method. By 
binding and setting your view variables, and passing them directly to your view object, you 
are able to set the object properties that you will use as view variables, and do not need 
direct access to any given controller.
You can couple the controller to the view object by setting a view variable containing $this; 
however, it is not recommended, as it requires that view to depend on controller information 
that is not directly appropriated to it. You are encouraged to reuse views, and allow for your 
view object to be empowered by controllers, not belong directly to them.
Updated ORM
One of the best additions that were made in Kohana 2 was the inclusion of the ORM library. 
This feature alone enticed countless developers to try Kohana 2, as it made simple CRUD 
operations painless. There are changes to both the database library and the ORM in Kohana 
3, and they are all for the better.
First of all, the ORM and Database libraries are modules, and not included as part of the core 
system files, although they are both considered official modules and are supported by the 
development team.

Appendix
[ 309 ]
The new ORM also sports a new relationship model and iterator. The ORM_Iterator is now 
gone in favor of a refactored Database_Result class. This will change the way you access 
related data in your ORM results.
Where in 2.3, you could expect something like this to display all your post titles:
foreach (ORM::factory('post', 1)->where('active', '=', 1)->author as 
$author) 
{
   echo $author->name . '<br />';
}
In 3.x, you will need to call the Database_Result's find_all() method and refactor your 
query:
foreach (ORM::factory('post', 1)->where('active', '=', 1)->author-
>find_all() as $author) 
{
   echo $author->name . '<br />';
}
As you can see, this is a minor change and should be easy to which to adjust. As you are 
making the switch to the new ORM module, you will find several small differences, but the 
general interface is very familiar and similar to the 2.3 library. The relationships have also 
become easier to define and more flexible.
In the previous ORM, you defined your foreign-key relationships an object property, where 
now you can do so as part of the relationship definition. When you create your relationship, 
if the foreign key is not compliant with the naming convention, you can set it as a key value 
pair inside your foreign model array properties.
Speaking of related models and tables, there is another significant change worth mentioning. 
The has_many_and_belongs_to_many object property has been replaced with an 
additional option for the has_many class property. By defining a through key, with the pivot 
table defined as the value, the ORM knows this is a "has many" relationship for both related 
objects.
Here is an example of a class definition with a has many relationship using a pivot table and 
an explicitly defined foreign key:
class Model_User extends Model_Auth_User {
   
   protected $_has_many = array(
          'user_tokens' => array('model' => 'user_token'),
          'roles'       => array(
                 'model' => 'role', 
                 'through' => 'roles_users'

Upgrading from CodeIgniter and Kohana 2
[ 310 ]
                 'foreign_key'   => 'user_id'
          ),
          'messages'     => array('model' => 'message')
   );
   
   ...
Here, we see the model has multiple "has many" relationships, with only one being bi-
directional. It is easy to tell which is a "has many belongs to many", as only one has a 
through key defined. The other two relationships are "has many belongs to one", in that 
user_tokens and messages each only have one user, while any user can have many 
messages or user_tokens.
If you are a user of the Kohana 2.3 ORM, you will love the newest version. With more 
flexibility and an improved design, it has definitely grown from its previous experience. While 
the ORM is quite nice, there are several modules that have surfaced to offer rich feature sets 
for ORM and Database Abstraction in general.
A couple of modules worth looking at that are available for Kohana 3 and provide good 
database abstraction include:
Jelly ORM: http://jelly.jonathan-geiger.com
Sprig: https://github.com/sittercity/sprig
There are others also, including ORMs for MongoDB and other datastorage solutions.  To find 
more alternatives, and many modules in general, visit http://kohana-modules.com.
Routing and requests
A complete rewrite of a framework creates a lot of changes, and the core routing and 
request handling was not only affected, it got a complete overhaul. It is almost best to 
forget everything you remember about Kohana 2.3 routing, and simply start over with the 
new version.
Gone are the predefined URI maps and routing arrays for custom routes. In the new Kohana, 
you are able to control your URI mapping completely, and define routes for your application 
and modules separately an as objects.
This provides you with even more options for controlling your routes, as you are no longer 
restricted by the old controller/action/params and can now define your routing 
however you like. Although you could rearrange the URI in Kohana 2 using the routes array 
and some regex, the new Routes class makes things much more robust.

Appendix
[ 311 ]
The new Routes object loads defined routes in order, and it acts on the first match it makes. 
It also allows you to define unlimited parameters and defaults for them, as well as regular 
expression matching for each dynamic parameter.
Take, for example, the user-add-message route as defined in the bootstrap.php file in 
your case study site:
Route::set('user-add-message', 'messages/add(/<id>)', array('id' => 
'[0-9]+'))
   ->defaults(array(
          'directory' => 'user',
          'controller' => 'messages',
          'action'     => 'add'
   ));
Here the URI has both static and dynamic properties. The match must begin with 
messages/add, and the next optional segment must be a number that will be assigned to 
the parameter named id. In the case study site's bootstrap, you also defined the default 
route as follows:
Route::set('default', '(<controller>(/<action>(/<id>)))')
   ->defaults(array(
          'controller' => 'welcome',
          'action'     => 'index',
   ));
Here you have the default route that should be used, and have defined the default controller 
and action. In Kohana 2, the default controller was defined in the routes array with a key of 
_default, where you now can define as a default option for a URI segment.
You are free to define as many routes as you need, and set defaults for segments that may 
be optional. As you are constructing your applications, you will find the new routing interface 
to be a vast improvement over 2.3, and find yourself constructing routes that provide tons of 
flexibility and power to your projects.
Overall, the changes from Kohana 2 to 3 may seem overwhelming. PHP as a language has 
matured a lot since the community forked CodeIgniter and created what was to become the 
Kohana framework. With progress comes new ways of doing things, and Kohana 3 is a result 
of that forward progress of web development in PHP.
While the changes mentioned above do not encompass all the differences, they should 
provide you with a strong foundation to begin to make the switch. Understanding the 
fundamental differences between the two versions will allow you to concentrate on what 
is new. As always, a good read through the source code is unmatched by any amount of 
documentation.

Upgrading from CodeIgniter and Kohana 2
[ 312 ]
Upgrading from Kohana 3.0 to 3.1
With any new version come upgrades. The Kohana 3 development cycle calls for a new 
release every 6 months, supported for one year. This means there will always be 2 releases, 
with support expiring for the latest 6 months apart. As of the time of this writing, Kohana 
3.1 has been released, and is offered along side of 3.0. Next year, there will be a 3.2, with 
support continuing for 3.1. With each release, there will be minor changes with which you 
will need to keep up. For those that are making the upgrade from 3.0 to 3.1, you will find a 
few upgrades about which you will need to know.
Request and response classes
The Request class no longer directly houses the response, and the response has been given 
its own class. This has impacted several of the core features of the old Request class, and 
changes to your applications written in 3.0 will need some attention.
Specifically, $this->response is used in place of $this->request->response and it 
has been given its own set of properties and methods. You are encouraged to look at the 
new user guide and API Browser to familiarize yourself with the Response class.
As the Controller class consumes a request object in its constructor, it makes sense that 
there are changes there also. Now, the base controller's constructor method takes both 
a request object and a response object. If you are upgrading between releases and have 
overridden the core constructor, you may need to make some changes to ensure operability.
The Request::instance() method no longer exists, and has been replaced 
with two methods that offer more flexibility. To get the initial request object, 
you use Request::initial(), and to get the current request, you would use 
Request::current(). This makes much more sense in an HMVC pattern, and will 
give you more power when using the Request object.
The object properties in the Request object that have been used to get the controller, action, 
directory, and URI have also changed. These properties are now accessed via methods on the 
object, so Request::$controller is now accessed via Request::controller(). This 
allows you more options:
Request::initial()->controller() // Returns initial request controller
Request::initial()->action() // Returns initial request action
Request::initial()->directory() // Returns initial request directory
Request::initial()->uri() // Returns initial request URI
Request::current()->controller() // Returns current request controller
Request::current()->action() // Returns current request action
Request::current()->directory() // Returns current request directory
Request::current()->uri() // Returns current request URI

Appendix
[ 313 ]
Although you will most likely be using Request::current() for most of your needs, it 
could be useful to know about the initial request in some cases.
The new Request and Routing classes take another step in improving the functionality of the 
HMVC pattern, and allow developers to use the request stack more fully in their applications. 
Security enhancements
This release takes on security and validation enhancements as one of the main 
improvements. Kohana has always encouraged good security and promoted best practices, 
often giving you the ability to use or overlook tools available to you.
In version 3.1, the Security::xss_clean() has been removed in favor of using 
third-party libraries like HTMLPurifier (http://htmlpurifier.org/). This method is 
not covered in this book due to the vunerablities associated with it, and the removal in 
future versions of Kohana.
One of the most overlooked security abilities for Kohana is the ease in which you can salt 
cookies, which greatly increases the security of your applications. If you are going to use 
the Cookie class in the framework for your cookie handling, you are no longer able to forego 
salting your cookies.
As described earlier in this book, salting cookies is easy, and one line in the bootstrap can 
greatly decrease your vulnerability to attack or unwanted results. If you do not salt your 
cookies in 3.1, the framework will throw an application-level error, and you will be forced to 
correct your mistake. To add salt to your cookies, all you need to do is add the following line 
to your bootstrap:
Cookie::$salt = 'Some unique string goes here';
While we are on the subject of bootstraps, this release introduces the ability to have more 
than one.
Bootstrapping and the front controller
The request execution has been moved from the bootstrap to the front controller (index.
php file). This is a minor change, but has significant implications, as it more specifically 
defines the domains for the front controller and bootstrap for the framework.
It is very common to have a different bootstrap for different needs. You may have one that 
is built for running tests, and one for setting up your application. The line of thought in this 
change is that it is the job of the front controller to execute the request, and the job of the 
bootstrap to set up the application environment.

Upgrading from CodeIgniter and Kohana 2
[ 314 ]
If you look at the code in the index.php file included with the 3.1 release, you will see the 
file ending with the following code:
// Bootstrap the application
require APPPATH.'bootstrap'.EXT;
/**
 * Execute the main request. A source of the URI can be passed, eg: 
$_SERVER['PATH_INFO'].
 * If no source is specified, the URI will be automatically detected.
 */
echo Request::factory()
   ->execute()
   ->send_headers()
   ->body();
This sums up the change, and shows that after the bootstrapping has completed, the 
Request is executed. This change will probably not affect most upgrades, but is a nice 
addition that is worth knowing about as you continue to develop in the new release.
Validation library
This library underwent a major overhaul, adding a lot of functionality while deferring some 
other legacy functionality away from the library. First of all, filters have been completely 
removed, and there is nothing to take their place. The ORM has added some similar 
functionality in its new release, but the validation library does not have an offering that can 
adequately replace validation filters.
Also gone are callbacks, but not in the same sense. Now what was referred to as callbacks 
in the previous release are now an integrated part of the rules() method. The new library 
introduces a new concept the docs refer to as "context" support.
By using these context variables in your rule definitions, you can validate against a validation 
object, a field being compared, or a value of a field. This works in the same manner that 
callbacks did, and updating your code to reflect the changes should not be very difficult.
For a complete look at the 3.1 validation library, refer to the userguide and API browser.
Other changes
Other additions include better exception handling options, module upgrades, and small 
changes to functionality. Most modules, including all official modules, are supporting 
branches for both the 3.0 and 3.1 release, and have updated readme files in to point out 
significant changes and API differences.

Appendix
[ 315 ]
Another major change has been better documentation. As the framework gains more 
popularity and community support with the success of 3.0, we are seeing dramatic 
improvements in the documentation and tutorials provided with the userguide module and 
on the official Kohana website.


Index
Symbols
$id variable  85
$messages variable  82
404 redirects
custom 404 page, adding  274-276
handling  273, 274
__toString() method  151
A
abstract controller
creating  58, 59
action_about() method  56
action_edit() method  200
action_get_messages() method  84
action_index() method  36, 84
action_why_egotist() method  57
additional segments
allowing, in route  89
adjust() method  97
advanced installation, Kohana  17, 18
after() method  49
ampm() method  97
anchor() method  100
and_having() method  175
and_where_close() method  172
and_where() method  170
and_where_open() method  172
Apache
configuring  27, 28
Application Controller  75
application environment
configuring  292-294
setting up  24, 25
app_name variable  26
APPPATH constant  72
Arr class
about  104
extract() method  105
flatten() method  108
get() method  105
is_array() method  110
map() method  109
merge() method  106, 107
overwrite() method  107, 108
pluck() method  105
range() method  110
unshift() method  109
as_array() method  175
as_object() method  168, 175
Auth module
about  151, 215, 241
actions, securing  258
Auth functionality, adding to case study site  
244-258
configuring  241
controllers, securing  258
implementing  243
new messages page, adding using query builder  
261
secure actions, adding to case study  258-260
using  241
Auth module configuration
about  241
users, adding to case study site  241-243

[ 318 ]
auto_load() method  96
B
background() method, image module  137
base controller
abstract controller, creating  58, 59
creating  58
base() method  103, 104
before() function  49
Bench_Validurl class  152
bind() method
about  149
using, for passing data to view  42
bootstrap  73
bootstrap.php file  23, 73
bundled modules
about  133
Auth module  151
Cache module  153
Code Bench module  152, 153
Database module  139
image module  135
oAuth module  138
pagination module  145
unit test module  153
user guide module  134
C
Cache module  153
cascading filesystem, Kohana
about  70, 71
classes folder  72
config files  72
internationalization files  72
messages folder  72
view files  72
case study, Kohana  12
chars() method  99
checkbox() method  124, 125
chmod command  19
classes
autoloading  96
classes folder  72
close() method  119
Code Bench module  152
CodeIgniter
about  19
autoloading classes  304
modules  305
ORM  304
PHP 5 codebase  304
CodeIgniter-Kohana
differences  302, 303
config files  72
configuration, Kohana
testing  28-30
Controller::after() method  74
Controller::before() method  74
Controller class  36
controllers
anatomy  35, 36
Controller_Template class  48
Controller_Welcome class
anatomy  35
Cookie class
about  111
delete() method  112
get() method  112
set() method  111
cookies
about  289
securing  289-291
count_all() method  184, 210
COUNT() function  210
create() method  115, 116
crop() method, image module  136
cURL  12
custom modules
creating  159
custom routes
creating  86, 88
friendly URLs, creating with  86
D
data
passing to view  38
passing to view, as view variables  40
passing to view, via bind() method  42, 43
passing to view, via factory() method  39, 40
passing to view, via multiple methods  44, 45
passing to view, via set() method  41, 42
Database::$default property  165

[ 319 ]
Database::escape() method  289
Database module
about  139, 161
application, configuring for using database
  139-141
configuring  163-165
database sessions, configuring  211
database sessions, using  212
database table, creating using query builder  
141-145
queries, creating  165-168
queries, running  165-168
Query Builder, using  169
using  163
using with sessions  211
Database_Query class  165
database sessions
configuring  211
session handling, adding with database adapter  
211, 212
susing  212
Date class
about  97, 98
adjust() method  97
ampm() method  97
fuzzy date text, customizing  98
fuzzy_span() method  98
hours() method  97
minutes() method  97
months() method  97
seconds() method  97
years() method  97
DB::expr() method  209
DB::query() static method  166
DB::select() method  169
debugging, Kohana
404 redirects, handling  273, 274
about  263
error handler, disabling  272
error handling  268
error logs, viewing  273
error messages, adding to login form  272
error messages, adding to signup form  269-271
exception handler, illustrating  269-271
exception handling  268
Kohana::debug() method  264-268
decamelize() method  102
default config file
creating  26, 27
delete() method  112, 201
development environment
Kohana, configuring for  22
die() function  263
Distributed Version Control System (DVCS)  14
Don’t Repeat Yourself. See  DRY principle
downloading
Kohana, from web  13, 14
DRY principle  79
E
echo statement  82
edit() method  200
Egotist application
encryption configuration, adding to  113, 114
email() method  99, 100
Encrypt class  112
encryption configuration
adding, to Egotist application  113, 114
environment
testing  20, 21
error handler
disabling  272, 273
error handling  268
error logs
viewing  273
error messages
adding, to login form  272
adding, to signup form  269-271
exception handling  268
execute() method  166
exit() function  263
extract() method  105
F
factory() method
about  38
using, for passing data to view  39, 40
Feed class
about  115
create() method  115, 116
parse() method  117, 118
file() method  125
file system, Kohana  19, 20

[ 320 ]
first controller
creating  54, 55
expanding  55, 57
flatten() method  108
flip() method, image module  137
foreach loop  82
Form class
about  118
checkbox() method  124, 125
close() method  119
file() method  125
label() method  119
open() method  118, 119
radio() method  125
select() method  125
textarea() method  126
Form helper class
login form, creating with  119-121
friendly URLs
creating, custom routes used  86
from() method  169
fuzzy_span() function  98
G
GD  12
get_all() method  178
get_all() model method  145
get_message() method  200
get() method  105, 112
Git
about  14
features  14
Kohana, downloading with  15-17
Git clone  17
GitHub
about  14
Kohana, installing from  14
URL  14, 303
group_by() method  175
H
having() method  175
helpers
about  96, 97
Arr class  104
Cookie class  111
creating  130
Date class  97, 98
Encrypt class  112
extending  127
Feed class  115
Form class  118
HTML class  98
inflector class  101, 102
URL class  103
hierarchical aspect, Kohana  70
HMVC  69, 74
hours() method  97
HTML class
about  98
anchor() method  100
chars() method  99
mail() method  99, 100
image() method  101
mailto() method  101
obfuscate() method  99
script() method  101
style() method  101
HTML helper method
extending  127
htmlspecialchars() function  99
humanize() method  102
I
ID
used, for displaying messages  84, 85
image() method  101
image module, bundled modules
about  135
background() method  136, 137
crop() method  136
factory() method  136
flip() method  136, 137
reflection() method  136, 137
resize() method  136
rotate() method  136
save() method  138
sharpen() method  136, 137
watermark() method  136, 137
index.php file  18, 72, 74
inflector class
about  101

[ 321 ]
camelize() method  101
decamelize() method  102
humanize() method  102
plural() method  102
singular() method  102
uncountable() method  102
underscore() method  102
insert() method  185
install.php file  72
instance() method  114
instance() static method  165
internationalization files  72
is_array() method  110
is_assoc() method  110
J
join() method  175
K
Kohana
advanced installation, with Git  17, 18
Apache configuration  27, 28
application environment, setting up  24, 25
applications, profiling  277
base controller, creating  58
cascading filesystem  70-72
case study  12
classes, autoloading  96
code, debugging  263, 264
configuration, testing  28-30
configuring, for development environment  22
controllers  34
default config file, creating  26, 27
downloading, from web  13, 14
downloading, Git used  15-17
environment, testing  20, 21
error handling  263
file system  19, 20
first controller, creating  54, 55
first controller, expanding  55-57
helper classes  95
helpers  96, 97
hierarchical aspect  70
installing, from GitHub  14
model  161
module  131
modules, enabling  25
moving from CodeIgniter  304
new controllers, creating  54
nginx configuration  28
profiling, adding to case study project  278, 280
request flow  72-74
Request object, using  74-76
requisites  12
routing  83-85
server configuration  27
system requisites  12
Template Controller  46
timezone, setting up  22, 23
troubleshooting  263
upgrading  301
URL, for repository  14
URL, for website  12
URL settings, configuring  23, 24
user guide module, enabling  25
views  34
Welcome Controller, updating  37
working, with MySQL  161
Kohana::$environment property
about  24
setting  24
Kohana 2.x
about  305, 306
directory structure  306, 307
GET method  306
naming conventions  307, 308
POST method  306
requests  310, 311
routing  310, 311
updated ORM  308-310
views  308
Kohana 3.0
upgrading  312
Kohana application, for production
configuration settings, updating  298
directory structure considerations  295, 296
multiple application configuration  297
structure case study site  296
unnecessary files, removing  295
Kohana applications
application environment, configuring  292-294
cookies and sessions  289
cookies, securing  289-291

[ 322 ]
preparing, for production  294
securing  283
sessions, securing  291, 292
SQL injection  288, 289
XSS attacks  284, 285
XSS risks, securing against  285-288
Kohana-CodeIgniter
differences  302, 303
Kohana community  13
Kohana::config() method  72
Kohana_Controller_Template class  75
Kohana::debug() method  264
Kohana::find_file() method  70
kohana.git repository  17
Kohana::init() method  23, 73
Kohana::modules() method  25
Kohana repository  14
Kohana_Request object  75
Kohana upgrade from 3.0 to 3.1
about  312
bootstrapping  313
exception handling options  314
front controller  313
module upgrades  314
request class  312, 313
response class  312, 313
security enhancements  313
validation library  314
L
label() method  119
limit() method  173
login form
creating, Form helper class used  119-121
lost password reset form
creating  126
M
mailto() method  101
map() method  109
MCRYPT  12, 113
merge() method  106, 107
Message model
updating  179
messages
displaying, ID used  84, 85
profile page, creating with  77, 78
rendering  76
Messages Controller  83
messages folder  72
minutes() method  97
model
anatomy  161
creating  162, 163
MODPATH constant  72
modules
about  73, 131
anatomy  131, 132
bundled modules  133
configuring  132, 133
installing  153
installing, from archive  154-156
installing, from source files  153
installing, via Git  156-159
loading  132, 133
months() method  97
multiple methods
using, for passing data to view  44, 45
MVC design pattern  69
N
new request
calling, inside request  79-82
new users
ssign up form, creating for  122-124
nginx
configuring  28
O
oAuth module, bundled modules  138
obfuscate() method  99
object oriented programming  79
offset() method  174
open() method  118, 119
order_by() method  149, 173
or_having() method  175
ORM  215
ORM module
about  145, 215
convention, over configuration  216, 217
Message Model, updating  224-230
ORM API overview  217-223

[ 323 ]
setting up  216
using  215, 216
validation, adding to Message Model  234-238
Validation class  230, 231
or_where_close() method  172
or_where() method  170
or_where_open() method  172
overwrite() method  107, 108
P
Pagination module
about  145
exploring  151
pagination, adding to database results  146-150
param() method  85, 166
parse() method  117, 118
PDO  12
PHP5  12
pluck() method  105
plural() method  102
print_r() function  263
Profile controller  83
profile page
creating, for rendering messages  76
creating, with messages  77, 78
profile route  88
Q
Query Builder
about  169
database functions  209, 210
expressions  209, 210
messages, adding via web interface  185-191
messages, deleting via web interface  202-209
messages, editing via web interface  193-200
Model_Message, refactoring  179-184
new messages page, adding  184
results, using  175-178
statements, deleting  201
statements, inserting  185
statements, selecting  169-174
statements, updating  192, 193
using  169
query() method  104
R
radio() method  125
range() method  110
regex
adding, to route  88
request
creating, within request  79-82
Request::action() method  76
Request::controller() method  76
request flow, Kohana  72-74
Request::instance() method  73
Request object
using  74-76
resize() method, image module  136
rotate() method, image module  136
route
about  86
additional segments, allowing in  89
regex, adding to  88
subdirectories, using with  90-92
Route::set() method  73, 88
routing  83-85
S
save() method, image module  138
seconds() method  97
select_array() method  170
select() method  125
Session::instance() method  212
sessions
about  289
securing  291, 292
setcookie() function  111
set() method 
 about 111, 212
using, for passing data to view  41
sharpen() method, image module  137
sign up form
creating, for new users  122-124
singular() method  102
site structure
footer view files, adding  65-67
header view files, adding  65-67
Source Code Management (SCM)  14
SQL injection  288, 289
structure
adding, to view files  65

[ 324 ]
stylesheets
adding, to template  61-65
subdirectories
using, with routes  90-92
SYSPATH constant  72
T
Template Controller
about  46, 75
examining  48, 49
exploring  50
extending  46-48
global view variables, binding  52
global view variables, setting  50-52
using  46
textarea() method  126
title() method  103
U
uncountable() method  102
underscore() method  102
unit test module  153
unshift() method  109
URI
additional data, allowing in  89
URL class
about  103
base() method  103, 104
query() method  104
title() method  103
URL settings
configuring  23, 24
user guide module
enabling  25
user guide module, bundled modules  134
User_Messages controller  180
V
values() method  185
var_dump() function  263
var_export() function  263
view
about  34
anatomy  34
data, passing to  38
View class  38
view files
about  72
structure, adding  65
view variables
creating  40
W
watermark() method, image module  137
web
Kohana, downloading from  13, 14
Welcome Controller
manipulating  37, 38
updating  37
Welcome_Controlleraction_index() method  36
where_close() method  172
where() method  170
where_open() method  172
Y
years() method  97




Thank you for buying 
Kohana 3.0 Beginner’s Guide
About Packt Publishing
Packt, pronounced 'packed', published its first book "Mastering phpMyAdmin for Effective 
MySQL Management" in April 2004 and subsequently continued to specialize in publishing 
highly focused books on specific technologies and solutions.
Our books and publications share the experiences of your fellow IT professionals in adapting 
and customizing today's systems, applications, and frameworks. Our solution based books 
give you the knowledge and power to customize the software and technologies you're 
using to get the job done. Packt books are more specific and less general than the IT books 
you have seen in the past. Our unique business model allows us to bring you more focused 
information, giving you more of what you need to know, and less of what you don't.
Packt is a modern, yet unique publishing company, which focuses on producing quality, 
cutting-edge books for communities of developers, administrators, and newbies alike. For 
more information, please visit our website: www.packtpub.com.
About Packt Open Source
In 2010, Packt launched two new brands, Packt Open Source and Packt Enterprise, in order 
to continue its focus on specialization. This book is part of the Packt Open Source brand, 
home to books published on software built around Open Source licences, and offering 
information to anybody from advanced developers to budding web designers. The Open 
Source brand also runs Packt's Open Source Royalty Scheme, by which Packt gives a royalty 
to each Open Source project about whose software a book is sold.
Writing for Packt
We welcome all inquiries from people who are interested in authoring. Book proposals 
should be sent to author@packtpub.com. If your book idea is still at an early stage and you 
would like to discuss it first before writing a formal book proposal, contact us; one of our 
commissioning editors will get in touch with you. 
We're not just looking for published authors; if you have strong technical skills but no writing 
experience, our experienced editors can help you develop a writing career, or simply get 
some additional reward for your expertise.

Play Framework Cookbook
ISBN: 978-1-84951-552-8           Paperback: 292 pages
Over 60 incredibly effective recipes to take you under 
the hood and leverage advanced concepts of the Play 
framework 
1.	
Make your application more modular, by 
introducing you to the world of modules.
2.	
Keep your application up and running in production 
mode, from setup to monitoring it appropriately.
3.	
Integrate play applications into your CI environment
Drupal 7
ISBN: 978-1-84951-286-2           Paperback: 416 pages
Create and operate any type of Drupal 7 website 
quickly and efficiently
1.	
Set up, configure, and deploy a Drupal 7 website
2.	
Easily add exciting and powerful features
3.	
Design and implement your website's look and feel
4.	
Promote, manage, and maintain your live website
Please check www.PacktPub.com for information on our titles

Joomla! 1.6 First Look
ISBN: 978-1-84951-342-5           Paperback: 236 pages
A concise guide to everything that's new in Joomla! 
1.6.
1.	
A short and concise first look into Joomla! 1.6. 
2.	
Covers changes in all aspects of Joomla! including 
interface, menus, templates, and extensions
3.	
Ample screenshots and clear explanations of all the 
new features and their usage
SilverStripe 2.4 Module Extension, Themes, and 
Widgets: Beginner's Guide
ISBN: 978-1-84951-500-9          Paperback: 368 pages
Create smashing SilverStripe applications by 
extending modules, creating themes, and adding 
widgets
1.	
The first and only book that focuses on extending 
SilverStripe sites
2.	
Step-by-step instructions covering everything you 
need to know for getting started with making the 
most of the core functionality, developing modules, 
creating themes, and adding widgets
3.	
Build a fun, real-world example application without 
breaking a sweat
Please check www.PacktPub.com for information on our titles

