
Digital Signal Processing

This page intentionally left blank

Digital Signal Processing
Fundamentals and Applications
Second edition
Li Tan
Purdue University North Central
Jean Jiang
Purdue University North Central
AMSTERDAM • BOSTON • HEIDELBERG • LONDON
NEW YORK • OXFORD • PARIS • SAN DIEGO
SAN FRANCISCO • SINGAPORE • SYDNEY • TOKYO
Academic Press is an Imprint of Elsevier

Academic Press is an imprint of Elsevier
225 Wyman Street, Waltham, MA 02451, USA
The Boulevard, Langford Lane, Kidlington, Oxford, OX5 1GB, UK
First edition 2007
Second edition 2013
Copyright  2013 Elsevier Inc. All rights reserved
No part of this publication may be reproduced or transmitted in any form or by any means, electronic or
mechanical, including photocopying, recording, or any information storage and retrieval system, without
permission in writing from the publisher. Details on how to seek permission, further information about the
Publisher’s permissions policies and our arrangement with organizations such as the Copyright Clearance Center
and the Copyright Licensing Agency, can be found at our website: www.elsevier.com/permissions
This book and the individual contributions contained in it are protected under copyright by the Publisher (other
than as may be noted herein).
Notices
Knowledge and best practice in this ﬁeld are constantly changing. As new research and experience broaden our
understanding, changes in research methods, professional practices, or medical treatment may become necessary.
Practitioners and researchers must always rely on their own experience and knowledge in evaluating and using any
information, methods, compounds, or experiments described herein. In using such information or methods they
should be mindful of their own safety and the safety of others, including parties for whom they have a professional
responsibility.
To the fullest extent of the law, neither the Publisher nor the authors, contributors, or editors, assume any liability
for any injury and/or damage to persons or property as a matter of products liability, negligence or otherwise, or
from any use or operation of any methods, products, instructions, or ideas contained in the material herein.
Library of Congress Cataloging-in-Publication Data
A catalog record for this book is available from the Library of Congress
British Library Cataloguing in Publication Data
A catalogue record for this book is available from the British Library
ISBN: 978 0 12 415893 1
For information on all Academic Press publications
visit our website at elsevier.com
Printed and bound in the United States of America
13 10 9 8 7 6 5 4 3 2 1

Contents
Preface ................................................................................................................................................xiii
CHAPTER 1
Introduction to Digital Signal Processing ......................................1
1.1. Basic Concepts of Digital Signal Processing........................................................... 1
1.2. Basic Digital Signal Processing Examples in Block Diagrams .............................. 3
1.2.1. Digital Filtering ............................................................................................. 3
1.2.2. Signal Frequency (Spectrum) Analysis......................................................... 3
1.3. Overview of Typical Digital Signal Processing in Real-World
Applications.............................................................................................................. 5
1.3.1. Digital Crossover Audio System................................................................... 5
1.3.2. Interference Cancellation in Electrocardiography ........................................ 5
1.3.3. Speech Coding and Compression.................................................................. 7
1.3.4. Compact-Disc Recording System ................................................................. 7
1.3.5. Vibration Signature Analysis for Defective Gear Teeth............................... 9
1.3.6. Digital Photo Image Enhancement ............................................................... 9
1.4. Digital Signal Processing Applications.................................................................. 12
1.5. Summary................................................................................................................. 13
CHAPTER 2
Signal Sampling and Quantization .............................................. 15
2.1. Sampling of Continuous Signal.............................................................................. 15
2.2. Signal Reconstruction............................................................................................. 21
2.2.1. Practical Considerations for Signal Sampling: Anti-Aliasing Filtering..... 25
2.2.2. Practical Considerations for Signal Reconstruction: Anti-Image
Filter and Equalizer ..................................................................................... 30
2.3. Analog-to-Digital Conversion, Digital-to-Analog Conversion,
and Quantization..................................................................................................... 35
2.4. Summary................................................................................................................. 47
2.5. MATLAB Programs................................................................................................ 48
2.6. Problems ................................................................................................................. 49
CHAPTER 3
Digital Signals and Systems....................................................... 57
3.1. Digital Signals ........................................................................................................ 57
3.1.1. Common Digital Sequences........................................................................ 58
3.1.2. Generation of Digital Signals...................................................................... 61
3.2. Linear Time-Invariant, Causal Systems ................................................................. 63
3.2.1. Linearity....................................................................................................... 63
3.2.2. Time Invariance ........................................................................................... 65
3.2.3. Causality ...................................................................................................... 66
3.3. Difference Equations and Impulse Responses....................................................... 67
3.3.1. Format of the Difference Equation ............................................................. 67
3.3.2. System Representation Using Its Impulse Response.................................. 68
v

3.4. Bounded-In and Bounded-Out Stability................................................................. 71
3.5. Digital Convolution ................................................................................................ 72
3.6. Summary................................................................................................................. 79
3.7. Problem................................................................................................................... 80
CHAPTER 4
Discrete Fourier Transform and Signal Spectrum ......................... 87
4.1. Discrete Fourier Transform .................................................................................... 87
4.1.1. Fourier Series Coefﬁcients of Periodic Digital Signals.............................. 88
4.1.2. Discrete Fourier Transform Formulas......................................................... 91
4.2. Amplitude Spectrum and Power Spectrum............................................................ 97
4.3. Spectral Estimation Using Window Functions .................................................... 107
4.4. Application to Signal Spectral Estimation........................................................... 116
4.5. Fast Fourier Transform......................................................................................... 123
4.5.1. Decimation-in-Frequency Method ............................................................ 123
4.5.2. Decimation-in-Time Method..................................................................... 128
4.6. Summary............................................................................................................... 132
4.7. Problem................................................................................................................. 132
CHAPTER 5
The z-Transform ...................................................................... 137
5.1. Deﬁnition .............................................................................................................. 137
5.2. Properties of the z-Transform............................................................................... 140
5.3. Inverse z-Transform.............................................................................................. 144
5.3.1. Partial Fraction Expansion Using MATLAB............................................ 150
5.4. Solution of Difference Equations Using the z-Transform................................... 152
5.5. Summary............................................................................................................... 156
5.6. Problems ............................................................................................................... 156
CHAPTER 6
Digital Signal Processing Systems, Basic Filtering Types,
and Digital Filter Realizations .................................................. 161
6.1. The Difference Equation and Digital Filtering.................................................... 161
6.2. Difference Equation and Transfer Function......................................................... 166
6.2.1. Impulse Response, Step Response, and System Response....................... 169
6.3. The z-Plane Pole-Zero Plot and Stability ............................................................ 172
6.4. Digital Filter Frequency Response....................................................................... 178
6.5. Basic Types of Filtering ....................................................................................... 186
6.6. Realization of Digital Filters................................................................................ 192
6.6.1. Direct-Form I Realization ......................................................................... 193
6.6.2. Direct-Form II Realization........................................................................ 193
6.6.3. Cascade (Series) Realization..................................................................... 195
6.6.4. Parallel Realization.................................................................................... 196
6.7. Application: Signal Enhancement and Filtering.................................................. 199
6.7.1. Pre-Emphasis of Speech............................................................................ 200
6.7.2. Bandpass Filtering of Speech.................................................................... 203
6.7.3. Enhancement of ECG Signal Using Notch Filtering................................ 205
vi
Contents

6.8. Summary............................................................................................................... 206
6.9. Problem................................................................................................................. 208
CHAPTER 7
Finite Impulse Response Filter Design....................................... 217
7.1. Finite Impulse Response Filter Format............................................................... 217
7.2. Fourier Transform Design ................................................................................... 219
7.3. Window Method .................................................................................................. 230
7.4. Applications: Noise Reduction and Two-Band Digital Crossover..................... 253
7.4.1. Noise Reduction ....................................................................................... 253
7.4.2. Speech Noise Reduction........................................................................... 256
7.4.3. Noise Reduction in Vibration Signals...................................................... 257
7.4.4. Two-Band Digital Crossover.................................................................... 258
7.5. Frequency Sampling Design Method.................................................................. 262
7.6. Optimal Design Method ...................................................................................... 269
7.7. Realization Structures of Finite Impulse Response Filters................................. 280
7.7.1. Transversal Form...................................................................................... 280
7.7.2. Linear Phase Form.................................................................................... 281
7.8. Coefﬁcient Accuracy Effects on Finite Impulse Response Filters..................... 282
7.9. Summary of FIR Design Procedures and Selection of FIR Filter Design
Methods in Practice............................................................................................. 285
7.10. Summary............................................................................................................. 288
7.11. MATLAB Programs ........................................................................................... 288
7.12. Problems ............................................................................................................. 290
CHAPTER 8
Inﬁnite Impulse Response Filter Design..................................... 301
8.1. Inﬁnite Impulse Response Filter Format............................................................. 302
8.2. Bilinear Transformation Design Method ............................................................ 303
8.2.1. Analog Filters Using Lowpass Prototype Transformation ...................... 304
8.2.2. Bilinear Transformation and Frequency Warping ................................... 308
8.2.3. Bilinear Transformation Design Procedure ............................................. 314
8.3. Digital Butterworth and Chebyshev Filter Designs............................................ 318
8.3.1. Lowpass Prototype Function and Its Order ............................................. 318
8.3.2. Lowpass and Highpass Filter Design Examples...................................... 322
8.3.3. Bandpass and Bandstop Filter Design Examples .................................... 331
8.4. Higher-Order Inﬁnite Impulse Response Filter Design Using the
Cascade Method................................................................................................... 338
8.5. Application: Digital Audio Equalizer ................................................................. 341
8.6. Impulse-Invariant Design Method....................................................................... 345
8.7. Pole-Zero Placement Method for Simple Inﬁnite Impulse Response
Filters ................................................................................................................... 351
8.7.1. Second-Order Bandpass Filter Design..................................................... 352
8.7.2. Second-Order Bandstop (Notch) Filter Design........................................ 354
8.7.3. First-Order Lowpass Filter Design........................................................... 355
8.7.4. First-Order Highpass Filter Design.......................................................... 357
Contents
vii

8.8. Realization Structures of Inﬁnite Impulse Response Filters .............................. 358
8.8.1. Realization of Inﬁnite Impulse Response Filters in Direct-Form I
and Direct-Form II.................................................................................... 358
8.8.2. Realization of Higher-Order Inﬁnite Impulse Response Filters
via the Cascade Form............................................................................... 361
8.9. Application: 60-Hz Hum Eliminator and Heart Rate Detection
Using Electrocardiography.................................................................................. 362
8.10. Coefﬁcient Accuracy Effects on Inﬁnite Impulse Response
Filters.................................................................................................................. 369
8.11. Application: Generation and Detection of DTMF Tones Using the Goertzel
Algorithm............................................................................................................ 373
8.11.1. Single-Tone Generator .......................................................................... 374
8.11.2. Dual-Tone Multifrequency Tone Generator.......................................... 375
8.11.3. Goertzel Algorithm ............................................................................... 377
8.11.4. Dual-Tone Multifrequency Tone Detection Using the Modiﬁed
Goertzel Algorithm ............................................................................... 383
8.12. Summary of Inﬁnite Impulse Response (IIR) Design Procedures
and Selection of the IIR Filter Design Methods in Practice ............................. 388
8.13. Summary............................................................................................................. 391
8.14. Problem............................................................................................................... 392
CHAPTER 9
Hardware and Software for Digital Signal Processors ................ 405
9.1. Digital Signal Processor Architecture.................................................................. 406
9.2. Digital Signal Processor Hardware Units ............................................................ 408
9.2.1. Multiplier and Accumulator...................................................................... 408
9.2.2. Shifters....................................................................................................... 409
9.2.3. Address Generators.................................................................................... 409
9.3. Digital Signal Processors and Manufacturers ...................................................... 411
9.4. Fixed-Point and Floating-Point Formats.............................................................. 411
9.4.1. Fixed-Point Format.................................................................................... 412
9.4.2. Floating-Point Format................................................................................ 419
9.4.3. IEEE Floating-Point Formats.................................................................... 423
9.4.5. Fixed-Point Digital Signal Processors ...................................................... 426
9.4.6. Floating-Point Processors.......................................................................... 427
9.5. Finite Impulse Response and Inﬁnite Impulse Response Filter
Implementations in Fixed-Point Systems............................................................. 429
9.6. Digital Signal Processing Programming Examples ............................................. 434
9.6.1. Overview of TMS320C67x DSK.............................................................. 434
9.6.2. Concept of Real-Time Processing............................................................. 438
9.6.3. Linear Buffering ........................................................................................ 440
9.6.4. Sample C Programs................................................................................... 445
9.7. Summary............................................................................................................... 448
9.8. Problems ............................................................................................................... 449
viii
Contents

CHAPTER 10
Adaptive Filters and Applications ........................................... 453
10.1. Introduction to Least Mean Square Adaptive Finite Impulse Response
Filters ............................................................................................................... 453
10.2. Basic Wiener Filter Theory and Least Mean Square Algorithm.................... 457
10.3. Applications: Noise Cancellation, System Modeling, and Line
Enhancement.................................................................................................... 462
10.3.1. Noise Cancellation.............................................................................. 462
10.3.2. System Modeling................................................................................ 468
10.3.3. Line Enhancement Using Linear Prediction...................................... 473
10.4. Other Application Examples ........................................................................... 476
10.4.1. Canceling Periodic Interferences Using Linear
Prediction............................................................................................ 476
10.4.2. Electrocardiography Interference Cancellation.................................. 476
10.4.3. Echo Cancellation in Long-Distance Telephone Circuits.................. 479
10.5. Laboratory Examples Using the TMS320C6713 DSK................................... 480
10.6. Summary .......................................................................................................... 485
10.7. Problems........................................................................................................... 486
CHAPTER 11
Waveform Quantization and Compression................................ 497
11.1. Linear Midtread Quantization ......................................................................... 497
11.2. m-law Companding .......................................................................................... 501
11.2.1. Analog m-Law Companding............................................................... 501
11.2.2. Digital m-Law Companding................................................................ 504
11.3. Examples of Differential Pulse Code Modulation (DPCM), Delta
Modulation, and Adaptive DPCM G.721........................................................ 509
11.3.1. Examples of Differential Pulse Code Modulation and Delta
Modulation.......................................................................................... 509
11.3.2. Adaptive Differential Pulse Code Modulation G.721........................ 512
11.4. Discrete Cosine Transform, Modiﬁed Discrete Cosine Transform,
and Transform Coding in MPEG Audio ......................................................... 519
11.4.1. Discrete Cosine Transform................................................................. 519
11.4.2. Modiﬁed Discrete Cosine Transform................................................. 522
11.4.3. Transform Coding in MPEG Audio................................................... 525
11.5. Laboratory Examples of Signal Quantization Using the TMS320C6713
DSK.................................................................................................................. 528
11.6. Summary .......................................................................................................... 533
11.7. MATLAB Programs......................................................................................... 533
11.8. Problems........................................................................................................... 548
CHAPTER 12
Multirate Digital Signal Processing, Oversampling
of Analog-to-Digital Conversion, and Undersampling
of Bandpass Signals .............................................................. 555
12.1. Multirate Digital Signal Processing Basics..................................................... 555
12.1.1. Sampling Rate Reduction by an Integer Factor................................. 556
Contents
ix

12.1.2. Sampling Rate Increase by an Integer Factor.................................... 562
12.1.3. Changing the Sampling Rate by a Noninteger Factor L/M............... 567
12.1.4. Application: CD Audio Player ........................................................... 571
12.1.5. Multistage Decimation ....................................................................... 574
12.2. Polyphase Filter Structure and Implementation.............................................. 578
12.3. Oversampling of Analog-to-Digital Conversion............................................. 585
12.3.1. Oversampling and Analog-to-Digital Conversion Resolution........... 586
12.3.2. Sigma-Delta Modulation Analog-to-Digital Conversion................... 592
12.4. Application Example: CD Player.................................................................... 601
12.5. Undersampling of Bandpass Signals............................................................... 603
12.6. Sampling Rate Conversion Using the TMS320C6713 DSK .......................... 608
12.7. Summary .......................................................................................................... 613
12.8. Problems........................................................................................................... 613
CHAPTER 13
Subband- and Wavelet-Based Coding...................................... 621
13.1. Subband Coding Basics................................................................................... 621
13.2. Subband Decomposition and Two-Channel Perfect Reconstruction
Quadrature Mirror Filter Bank ........................................................................ 626
13.3. Subband Coding of Signals ............................................................................. 635
13.4. Wavelet Basics and Families of Wavelets....................................................... 638
13.5. Multiresolution Equations ............................................................................... 650
13.6. Discrete Wavelet Transform............................................................................ 655
13.7. Wavelet Transform Coding of Signals ............................................................ 664
13.8. MATLAB Programs......................................................................................... 668
13.9. Summary .......................................................................................................... 672
13.10. Problems ........................................................................................................ 673
CHAPTER 14
Image Processing Basics....................................................... 683
14.1. Image Processing Notation and Data Formats................................................ 684
14.1.1. 8-Bit Gray Level Images .................................................................... 684
14.1.2. 24-bit Color Images............................................................................ 686
14.1.3. 8-Bit Color Images ............................................................................. 687
14.1.4. Intensity Images.................................................................................. 688
14.1.5. Red, Green, and Blue Components and Grayscale Conversion ........ 688
14.1.6. MATLAB Functions for Format Conversion..................................... 690
14.2. Image Histogram and Equalization................................................................. 692
14.2.1. Grayscale Histogram and Equalization.............................................. 692
14.2.2. 24-Bit Color Image Equalization ....................................................... 695
14.2.3. 8-Bit Indexed Color Image Equalization ........................................... 700
14.2.4. MATLAB Functions for Equalization................................................ 702
14.3. Image Level Adjustment and Contrast............................................................ 704
14.3.1. Linear Level Adjustment.................................................................... 704
14.3.2. Adjusting the Level for Display......................................................... 707
14.3.3. MATLAB Functions for Image Level Adjustment............................ 707
x
Contents

14.4. Image Filtering Enhancement.......................................................................... 707
14.4.1. Lowpass Noise Filtering..................................................................... 709
14.4.2. Median Filtering ................................................................................. 712
14.4.3. Edge Detection.................................................................................... 715
14.4.4. MATLAB Functions for Image Filtering........................................... 718
14.5. Image Pseudo-Color Generation and Detection.............................................. 722
14.6. Image Spectra .................................................................................................. 725
14.7. Image Compression by Discrete Cosine Transform ....................................... 728
14.7.1. Two-Dimensional Discrete Cosine Transform................................... 729
14.7.2. Two-Dimensional JPEG Grayscale Image Compression Example ... 731
14.7.3. JPEG Color Image Compression........................................................ 735
14.7.4. Image Compression Using Wavelet Transform Coding .................... 738
14.8. Creating a Video Sequence by Mixing Two Images ...................................... 745
14.9. Video Signal Basics......................................................................................... 746
14.9.1. Analog Video...................................................................................... 747
14.9.2. Digital Video....................................................................................... 753
14.10. Motion Estimation in Video.......................................................................... 755
14.11. Summary........................................................................................................ 757
14.12. Problems ........................................................................................................ 758
Appendix A: Introduction to the MATLAB Environment ............................................................... 767
Appendix B: Review of Analog Signal Processing Basics .............................................................. 775
Appendix C: Normalized Butterworth and Chebyshev Functions ................................................... 805
Appendix D: Sinusoidal Steady-State Response of Digital Filters.................................................. 813
Appendix E: Finite Impulse Response Filter Design Equations by the Frequency Sampling
Design Method................................................................................................................................... 817
Appendix F: Wavelet Analysis and Synthesis Equations................................................................. 821
Appendix G: Some Useful Mathematical Formulas......................................................................... 825
Answers to Selected Problems.......................................................................................................... 831
References.......................................................................................................................................... 857
Index .................................................................................................................................................. 861
Contents
xi

This page intentionally left blank

Preface
Technology such as microprocessors, microcontrollers, and digital signal processors have become so
advanced that they have had a dramatic impact on the disciplines of electronics engineering, computer
engineering, and biomedical engineering. Engineers and technologists need to become familiar with
digital signals and systems and basic digital signal processing (DSP) techniques. The objective of this
book is to introduce students to the fundamental principles of these subjects and to provide a working
knowledge such that they can apply DSP in their engineering careers.
The book is suitable for a two-semester course sequence at the senior level in undergraduate
electronics, computer, and biomedical engineering technology programs. Chapters 1 to 8 provide the
topics for a one-semester course, and a second course can complete the rest of the chapters. This
textbook can also be used in an introductory DSP course in an undergraduate electrical engineering
program at traditional colleges. Additionally, the book should be useful as a reference for under-
graduate engineering students, science students, and practicing engineers.
The material has been tested for two consecutive courses in a signal processing sequence at Purdue
University North Central in Indiana. With the background established from this book, students will be
well prepared to move forward to take other upper-level courses that deal with digital signals and
systems for communications and control.
The textbook consists of 14 chapters, organized as follows:
•
Chapter 1 introduces concepts of DSP and presents a general DSP block diagram. Application
examples are included.
•
Chapter 2 covers the sampling theorem described in the time domain and frequency domain and
also covers signal reconstruction. Some practical considerations for designing analog anti-
aliasing lowpass ﬁlters and anti-image lowpass ﬁlters are included. The chapter ends with
a section dealing with analog-to-digital conversion (ADC) and digital-to-analog conversion
(DAC), as well as signal quantization and encoding.
•
Chapter 3 introduces digital signals, linear time-invariant system concepts, difference equations,
and digital convolutions.
•
Chapter 4 introduces the discrete Fourier transform (DFT) and digital signal spectral calculations
using the DFT. Methods for applying the DFT to estimate the spectra of various signals,
including
speech,
seismic
signals,
electrocardiography
data,
and
vibration
signals,
are
demonstrated. The chapter ends with a section dedicated to illustrating fast Fourier transform
(FFT) algorithms.
•
Chapter 5 is devoted to the z-transform and difference equations.
•
Chapter 6 covers digital ﬁltering using difference equations, transfer functions, system stability,
digital ﬁlter frequency responses, and implementation methods such as direct-form I and direct-
form II.
•
Chapter 7 deals with various methods of ﬁnite impulse response (FIR) ﬁlter design, including the
Fourier transform method for calculating FIR ﬁlter coefﬁcients, window method, frequency
sampling design, and optimal design. Chapter 7 also includes applications that use FIR ﬁlters for
noise reduction and digital crossover system design.
xiii

• Chapter 8 covers various methods of inﬁnite impulse response (IIR) ﬁlter design, including the
bilinear transformation (BLT) design, impulse-invariant design, and pole-zero placement design.
Applications using IIR ﬁlters include audio equalizer design, biomedical signal enhancement,
dual-tone multifrequency (DTMF) tone generation, and detection with the Goertzel algorithm.
• Chapter 9 introduces DSP architectures, software and hardware, and ﬁxed-point and ﬂoating-point
implementations of digital ﬁlters.
• Chapter 10 covers adaptive ﬁlters with applications such as noise cancellation, system modeling,
line enhancement, cancellation of periodic interferences,
echo cancellation, and 60-Hz
interference cancellation in biomedical signals.
• Chapter 11 is devoted to speech quantization and compression, including pulse code modulation
(PCM) coding, mu-law compression, adaptive differential pulse code modulation (ADPCM)
coding, windowed modiﬁed discrete cosine transform (W-MDCT) coding, and MPEG audio
format, speciﬁcally MP3 (MPEG-1, layer 3).
• Chapter 12 covers topics pertaining to multirate DSP and applications, as well as principles of
oversampling ADC, such as sigma-delta modulation. Undersampling for bandpass signals is also
examined.
• Chapter 13 introduces a subband coding system and its implementation. Perfect reconstruction
conditions for a two-band system are derived. Subband coding with an application of data
compression is demonstrated. Furthermore, the chapter covers the discrete wavelet transform
(DWT) with applications to signal coding and denoising.
• Finally, Chapter 14 covers image enhancement using histogram equalization and ﬁltering methods,
including edge detection. The chapter also explores pseudo-color image generation and detection,
two-dimensional spectra, JPEG compression using DCT, image coding using the DWT, and the
mixing of two images to create a video sequence. Finally, motion compensation of the video
sequence is explored, which is a key element of video compression used in MPEG.
MATLAB programs are listed whenever they are possible. Therefore, a MATLAB tutorial should be
given to students who are new to the MATLAB environment.
• Appendix A serves as a MATLAB tutorial.
• Appendix B reviews key fundamentals of analog signal processing. Topics include Fourier series,
Fourier transform, Laplace transform, and analog system basics.
• Appendixes C, D, and E review Butterworth and Chebyshev ﬁlters, sinusoidal steady-state
responses in digital ﬁlters, and derivation of the FIR ﬁlter design equation via the frequency
sampling method, respectively.
• Appendix F details the derivations of wavelet analysis and synthesis equations.
• Appendix G offers general useful mathematical formulas.
In this new edition, MATLAB projects dealing with practical applications are included in Chapters 2,
4, 6, 7, 8, 10, 12, and 13.
Instructor support, including solutions, can be found at http://textbooks.elsevier.com. MATLAB
programs and exercises for students, plus Real-time C programs can be found at booksite.elsevier.com/
9780124158931.
Thanks to all the faculty and staff at Purdue University North Central in Westville, Indiana, for their
encouragement. In particular, the authors wish to thank Professors Thomas F. Brady, Larryl Matthews,
xiv
Preface

Christopher J. Smith, Alain Togbe, Edward Vavrek, Nuri Zeytinoglu, and Shengyong Zhang for their
support and suggestions. We are also indebted to all former students in our DSP classes at Purdue
University North Central for their feedback over the years, which helped reﬁne this edition.
Special thanks go to Joseph P. Hayton (Publisher), Chelsea Johnston (Editorial Project Manager),
and Renata Corbani (Project Manager) at Elsevier for their encouragement and guidance in developing
the second edition.
The book has beneﬁted from many constructive comments and suggestions from the following
reviewers and anonymous reviewers. The authors take this opportunity to thank them for their
signiﬁcant contributions. We would like to thank the following reviewers for the second edition:
Professor Oktay Alkin, Southern Illinois University Edwardsville
Professor Rabah Aouﬁ, DeVry University-Irving, TX
Dr. Janko Calic, University of Surrey, UK
Professor Erik Cheever, Swarthmore College
Professor Samir Chettri, University of Maryland Baltimore County
Professor Nurgun Erdol, Florida Atlantic University
Professor Richard L Henderson, DeVry University, Kansas City, MO
Professor JeongHee Kim, San Jose State University
Professor Sudarshan R. Nelatury, Penn State University, Erie, PA
Professor Javad Shakib, DeVry University in Pomona, California
Dr.ir. Herbert Wormeester, University of Twente, The Netherlands
Professor Yongpeng Zhang, Prairie View A&M University
In addition we would like to repeat our thanks to the reviewers for the ﬁrst edition: Professor Mateo
Aboy, Oregon Institute of Technology; Professor Jean Andrian, Florida International University;
Professor Rabah Aouﬁ, DeVry University; Professor Larry Bland, John Brown University; Professor
Phillip L. De Leon, New Mexico State University; Professor Mohammed Feknous, New Jersey
Institute of Technology; Professor Richard L. Henderson, DeVry University; Professor Ling Hou, St.
Cloud State University; Professor Robert C. (Rob) Maher, Montana State University; Professor
Abdulmagid Omar, DeVry University; Professor Ravi P. Ramachandran, Rowan University; Professor
William (Bill) Routt, Wake Technical Community College; Professor Samuel D. Stearns, University of
New Mexico; Professor Les Thede, Ohio Northern University; Professor Igor Tsukerman, University
of Akron; Professor Vijay Vaidyanathan, University of North Texas; and Professor David Waldo,
Oklahoma Christian University.
Li Tan
Jean Jiang
Preface
xv

This page intentionally left blank

Introduction to Digital Signal
Processing
1
CHAPTER OUTLINE
1.1 Basic Concepts of Digital Signal Processing .......................................................................................1
1.2 Basic Digital Signal Processing Examples in Block Diagrams...............................................................3
1.2.1 Digital Filtering .............................................................................................................3
1.2.2 Signal Frequency (Spectrum) Analysis.............................................................................3
1.3 Overview of Typical Digital Signal Processing in Real-World Applications ............................................5
1.3.1 Digital Crossover Audio System.......................................................................................5
1.3.2 Interference Cancellation in Electrocardiography..............................................................5
1.3.3 Speech Coding and Compression ....................................................................................7
1.3.4 Compact-Disc Recording System ....................................................................................7
1.3.5 Vibration Signature Analysis for Defective Gear Teeth .......................................................9
1.3.6 Digital Photo Image Enhancement ..................................................................................9
1.4 Digital Signal Processing Applications ............................................................................................ 12
1.5 Summary ....................................................................................................................................... 13
OBJECTIVES:
This chapter introduces concepts of digital signal processing (DSP) and reviews an overall picture of its
applications. Illustrative application examples include digital noise ﬁltering, signal frequency analysis,
speech and audio compression, biomedical signal processing such as interference cancellation in elec-
trocardiography, compact-disc recording, and image enhancement.
1.1 BASIC CONCEPTS OF DIGITAL SIGNAL PROCESSING
Digital signal processing (DSP) technology and its advancements have dramatically impacted our
modern society everywhere. Without DSP, we would not have digital/Internet audio and video; digital
recording; CD, DVD, and MP3 players; iPhone and iPad; digital cameras; digital and cellular tele-
phones; digital satellite and TV; or wired and wireless networks. Medical instruments would be less
efﬁcient or unable to provide useful information for precise diagnoses if there were no digital elec-
trocardiography (ECG) analyzers, digital X-rays, and medical image systems. We would also live in
many less efﬁcient ways, since we would not be equipped with voice recognition systems, speech
synthesis systems, and image and video editing systems. Without DSP, scientists, engineers, and
technologists would have no powerful tools to analyze and visualize the data necessary for their
designs, and so on.
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00001-9
Copyright  2013 Elsevier Inc. All rights reserved.
1

The basic concept of DSP is illustrated by the simpliﬁed block diagram in Figure 1.1, which
consists of an analog ﬁlter, an analog-to-digital conversion (ADC) unit, a digital signal (DS) processor,
a digital-to-analog conversion (DAC) unit, and a reconstruction (anti-image) ﬁlter.
As shown in the diagram, the analog input signal, which is continuous in time and amplitude, is
generally encountered in the world around us. Examples of such analog signals include current,
voltage, temperature, pressure, and light intensity. Usually a transducer (sensor) is used to convert the
nonelectrical signal to the analog electrical signal (voltage). This analog signal is fed to an analog
ﬁlter, which is applied to limit the frequency range of analog signals prior to the sampling process. The
purpose of ﬁltering is to signiﬁcantly attenuate aliasing distortion, which will be explained in the next
chapter. The band-limited signal at the output of the analog ﬁlter is then sampled and converted via the
ADC unit into the digital signal, which is discrete both in time and in amplitude. The DS processor
then accepts the digital signal and processes the digital data according to DSP rules such as lowpass,
highpass, and bandpass digital ﬁltering, or other algorithms for different applications. Notice that the
DS processor unit is a special type of digital computer and can be a general-purpose digital computer,
a microprocessor, or an advanced microcontroller; furthermore, DSP rules can be implemented using
software in general.
With the DS processor and corresponding software, a processed digital output signal is gener-
ated. This signal behaves in a manner according to the speciﬁc algorithm used. The next block in
Figure 1.1, the DAC unit, converts the processed digital signal to an analog output signal. As shown,
the signal is continuous in time and discrete in amplitude (usually a sample-and-hold signal, to be
discussed in Chapter 2). The ﬁnal block in Figure 1.1 is designated as a function to smooth the DAC
output voltage levels back to the analog signal via a reconstruction (anti-image) ﬁlter for real-world
applications.
In general, the analog signal process does not require software, an algorithm, ADC, and DAC. The
processing relies wholly on the electrical and electronic devices such as resistors, capacitors, tran-
sistors, operational ampliﬁers, and integrated circuits (ICs).
DSP systems, on the other hand, use software, digital processing, and algorithms; thus they have
a great deal of ﬂexibility, less noise interference, and no signal distortion in various applications.
However, as shown in Figure 1.1, DSP systems still require minimum analog processing such as the
anti-aliasing and reconstruction ﬁlters, which are musts for converting real-world information into
digital form and digital signals back into real-world information.
Note that there are many real-world DSP applications that do not require DAC, such as data
acquisition and digital information display, speech recognition, data encoding, and so on. Similarly,
DSP applications that need no ADC include CD players, text-to-speech synthesis, and digital tone
generators, among others. We will review some of them in the following sections.
Analog
filter
ADC
DSP
DAC
Reconstruction
filter
Analog
input
Analog
output
Band limited
signal
Digital
signal
Processed
digital signal
Output
signal
FIGURE 1.1
A digital signal processing scheme.
2
CHAPTER 1 Introduction to Digital Signal Processing

1.2 BASIC DIGITAL SIGNAL PROCESSING EXAMPLES IN BLOCK DIAGRAMS
We ﬁrst look at digital noise ﬁltering and signal frequency analysis, using block diagrams.
1.2.1 Digital Filtering
Let us consider the situation shown in Figure 1.2, depicting a digitized noisy signal obtained from
digitizing analog voltages (sensor output) containing a useful low-frequency signal and noise that
occupies all of the frequency range. After ADC, the digitized noisy signal xðnÞ, where n is the sample
number, can be enhanced using digital ﬁltering.
Since our useful signal contains the low-frequency component, the high-frequency components
above that of our useful signal are considered noise, which can be removed by using a digital lowpass
ﬁlter. We set up the DSP block in Figure 1.2 to operate as a simple digital lowpass ﬁlter. After pro-
cessing the digitized noisy signal xðnÞ, the digital lowpass ﬁlter produces a clean digital signal yðnÞ.
We can apply the cleaned signal yðnÞ to another DSP algorithm for a different application or convert it
to the analog signal via DAC and the reconstruction ﬁlter.
The digitized noisy signal and clean digital signal, respectively, are plotted in Figure 1.3, where the
top plot shows the digitized noisy signal, while the bottom plot demonstrates the clean digital signal
obtained by applying the digital lowpass ﬁlter. Typical applications of noise ﬁltering include acqui-
sition of clean digital audio and biomedical signals and enhancement of speech recording, among
others (Embree, 1995; Rabinar and Schafer, 1978; Webster, 1998).
1.2.2 Signal Frequency (Spectrum) Analysis
As shown in Figure 1.4, certain DSP applications often require that time domain information and
the frequency content of the signal be analyzed. Figure 1.5 shows a digitized audio signal and its
calculated signal spectrum (frequency content), that is, the signal amplitude versus its corre-
sponding frequency for the time being, obtained from a DSP algorithm, called the fast Fourier
transform (FFT), which will be studied in Chapter 4. The plot in Figure 1.5(a) is a time domain
display of the recorded audio signal with a frequency of 1,000 Hz sampled at 16,000 samples per
second, while the frequency content display of plot (b) displays the calculated signal spectrum
versus frequency, in which the peak amplitude is clearly located at 1,000 Hz. Plot (c) shows a time
domain display of an audio signal consisting of one signal of 1,000 Hz and another of 3,000 Hz
sampled at 16,000 samples per second. The frequency content display shown in plot (d) gives two
locations (1,000 Hz and 3,000 Hz) where the peak amplitudes reside, hence the frequency content
display presents clear frequency information of the recorded audio signal.
DSP
Digital filtering
( )
x n
( )
y n
Digitized noisy input
Clean digital signal
FIGURE 1.2
The simple digital ﬁltering block.
1.2 Basic Digital Signal Processing Examples in Block Diagrams
3

As another practical example, we often perform spectral estimation of a digitally recorded speech
or audio (music) waveform using the FFTalgorithm in order to investigate spectral frequency details of
speech information. Figure 1.6 shows a speech signal produced by a human in the time domain and
frequency content displays. The top plot shows the digital speech waveform versus its digitized sample
number, while the bottom plot shows the frequency content information of speech for a range from 0 to
4,000 Hz. We can observe that there are about ten spectral peaks, called speech formants, in the range
between 0 and 1,500 Hz. Those identiﬁed speech formants can be used for applications such as speech
modeling, speech coding, speech feature extraction for speech synthesis and recognition, and so on
(Deller et al., 1993).
Analog
filter
ADC
DSP
Algorithms
Time domain display
x(n)
Analog
input
Frequency content display
FIGURE 1.4
Signal spectral analysis.
0
0.005
0.01
0.015
0.02
0.025
0.03
2
1
0
1
2
Noisy signal
Ampl tude
0
0.005
0.01
0.015
0.02
0.025
0.03
2
1
0
1
2
Ampl tude
Time (sec.)
FIGURE 1.3
(Top) Digitized noisy signal. (Bottom) Clean digital signal using the digital lowpass ﬁlter.
4
CHAPTER 1 Introduction to Digital Signal Processing

1.3 OVERVIEW OF TYPICAL DIGITAL SIGNAL PROCESSING IN REAL-WORLD
APPLICATIONS
1.3.1 Digital Crossover Audio System
An audio system is required to operate in an entire audible range of frequencies, which may be beyond
the capability of any single speaker driver. Several drivers, such as the speaker cones and horns, each
covering a different frequency range, are used to cover the full audio frequency range.
Figure 1.7 shows a typical two-band digital crossover system consisting of two speaker drivers:
a woofer and a tweeter. The woofer responds to low frequencies, while the tweeter responds to high
frequencies. The incoming digital audio signal is split into two bands by using a digital lowpass ﬁlter
and a digital highpass ﬁlter in parallel. Then the separated audio signals are ampliﬁed. Finally, they are
sent to their corresponding speaker drivers. Although the traditional crossover systems are designed
using the analog circuits, the digital crossover system offers a cost-effective solution with program-
mability, ﬂexibility, and high quality. This topic is taken up in Chapter 7.
1.3.2 Interference Cancellation in Electrocardiography
In ECG recording, there often is unwanted 60-Hz interference in the recorded data (Webster, 1998).
The analysis shows that the interference comes from the power line and includes magnetic induction,
0
0.005
0.01
5
0
5
Time (sec.)
(a) S gnal ampl tude
0
0.005
0.01
10
5
0
5
10
Time (sec.)
(c) S gnal ampl tude
0
2000
4000
6000
8000
0
2
4
6
Frequency (Hz)
(b) S gnal spectrum
0
2000
4000
6000
8000
0
2
4
6
Frequency (Hz)
(d) S gnal spectrum
1000 Hz
1000 Hz
3000 Hz
FIGURE 1.5
Audio signals and their spectrums.
1.3 Overview of Typical Digital Signal Processing in Real World Applications
5

displacement currents in leads or in the body of the patient, effects from equipment interconnections,
and other imperfections. Although using proper grounding or twisted pairs minimizes such 60-Hz
effects, another effective choice can be use of a digital notch ﬁlter, which eliminates the 60-Hz
interference while keeping all the other useful information. Figure 1.8 illustrates a 60-Hz interference
eliminator using a digital notch ﬁlter. With such enhanced ECG recording, doctors in clinics could give
accurate diagnoses for patients.
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
x 10
4
2
1
0
1
2
x 10
4
Sample number
Speech amp tude
Speech data: "We lost the golden chain."
0
500
1000
1500
2000
2500
3000
3500
4000
0
50
100
150
200
Frequency (Hz)
Amp tude spectrum
FIGURE 1.6
Speech samples and speech spectrum.
Digital
audio x(  )
n
Digital
highpass filter
Digital
lowpass filter
Gain
Gain
Tweeter:
The crossover passes
high frequencies
Woofer:
The crossover passes
low frequencies
FIGURE 1.7
Two-band digital crossover.
6
CHAPTER 1 Introduction to Digital Signal Processing

This technique can also be applied to remove 60-Hz interference in audio systems. This topic is
explored in depth in Chapter 8.
1.3.3 Speech Coding and Compression
One of the speech coding methods, called waveform coding, is depicted in Figure 1.9A, describing the
encoding process, while Figure 1.9B shows the decoding processing. As shown in Figure 1.9A, the
analog signal is ﬁrst sent through an analog lowpass ﬁlter to remove high frequency noise components
and is then passed through the ADC unit, where the digital values at sampling instants are captured by
the DS processor. Next, the captured data are compressed using data compression rules to reduce the
storage requirements. Finally, the compressed digital information is sent to storage media.
The compressed digital information can also be transmitted efﬁciently, since compression reduces the
original data rate. Digital voice recorders, digital audio recorders, and MP3 players are products that
use compression techniques (Deller et al., 1993; Li and Drew, 2004; Pan 1985).
To retrieve the information, the reverse process is applied. As shown in Figure 1.9B, the DS
processor decompresses the data from the storage media and sends the recovered digital data to DAC.
The analog output is acquired by ﬁltering the DAC output via the reconstruction ﬁlter.
1.3.4 Compact-Disc Recording System
A compact-disc (CD) recording system is described in Figure 1.10A. The analog audio signal is sensed
from each microphone and then fed to the anti-aliasing lowpass ﬁlter. Each ﬁltered audio signal is
sampled at the industry standard rate of 44.1 kilo-samples per second, quantized, and coded to 16 bits for
each digital sample in each channel. The two channels are further multiplexed and encoded, and extra
bits are added to provide information such as playing time and track number for the listener. The encoded
ECG recorder with
the removed 60 Hz
interference
ECG
preamplifier
60 Hz
interference
Digital notch filter for
eliminating 60 Hz
interference
ECG signal
with 60 Hz
interference
FIGURE 1.8
Elimination of 60-Hz interference in electrocardiography (ECG).
1.3 Overview of Typical Digital Signal Processing in Real World Applications
7

Analog
filter
ADC
DSP
compressor
Analog
input
Storage
media
FIGURE 1.9A
Simpliﬁed data compressor.
DSP
decompressor
DAC
Reconstruction
filter
Analog
output
Storage
media
FIGURE 1.9B
Simpliﬁed data expander (decompressor).
Left mic
Right mic
Anti aliasing
LP filter
Anti aliasing
LP filter
16 bit
ADC
16 bit
ADC
Multiplex
Encoding
Modulation
Synchronization
Optics and
Recording
FIGURE 1.10A
Simpliﬁed encoder of the CD recording system.
CD
Optical pickup
Demodulation
Error correction
4x
Over
sampling
14 bit
DAC
14 bit
DAC
Anti image
LP filter
Anti image
LP filter
Amplified
left speaker
Amplified
right speaker
FIGURE 1.10B
Simpliﬁed decoder of the CD recording system.
8
CHAPTER 1 Introduction to Digital Signal Processing

data bits are modulated for storage, and more synchronized bits are added for subsequent recovery of
sampling frequency. The modulated signal is then applied to control a laser beam that illuminates the
photosensitive layer of a rotating glass disc. When the laser turns on and off, the digital information is
etched on the photosensitive layer as a pattern of pits and lands in a spiral track. This master disc forms
the basis for mass production of the commercial CD from the thermoplastic material.
During playback, as illustrated in Figure 1.10B, a laser optically scans the tracks on a CD to
produce a digital signal. The digital signal is then demodulated. The demodulated signal is further
oversampled by a factor of 4 to acquire a sampling rate of 176.4 kHz for each channel and is then
passed to the 14-bit DAC unit. For the time being, we can consider the oversampling process as
interpolation, that is, adding three samples between every two original samples in this case, as we shall
see in Chapter 12. After DAC, the analog signal is sent to the anti-image analog ﬁlter, which is
a lowpass ﬁlter to smooth the voltage steps from the DAC unit. The output from each anti-image ﬁlter
is fed to its ampliﬁer and loudspeaker. The purpose of the oversampling is to relieve the higher-ﬁlter-
order requirement for the anti-image lowpass ﬁlter, making the circuit design much easier and
economical (Ambardar, 1999).
Software audio players installed on computer systems that play music from CDs, such as Windows
Media Player and RealPlayer, are examples of DSP applications. These audio players often have many
advanced features, such as graphical equalizers, which allow users to change audio through techniques
such as boosting low-frequency content or emphasizing high-frequency content (Ambardar, 1999;
Embree, 1995; Ifeachor and Jervis, 2002).
1.3.5 Vibration Signature Analysis for Defective Gear Teeth
Gearboxes are widely used in industry and vehicles. During their extended service lifetimes, the gear
teeth will inevitably be worn, chipped, or go missing. Hence, with DSP techniques, effective diag-
nostic methods can be developed to detect and monitor the defective gear teeth in order to enhance the
reliability of the entire machine before any unexpected catastrophic events occur. Figure 1.11(a)
shows the gearbox; two straight bevel gears with a transmission ratio of 1.5:1 inside the gearbox are
shown in Figure 1.11(b). The number of teeth on the pinion is 18. The gearbox input shaft is connected
a sheave and driven by a “V” belt drive. The vibration data can be collected by a triaxial accelerometer
installed on the top of the gearbox, as shown in Figure 1.11(c). The data acquisition system uses a
sampling rate of 12.8 kHz. Figure 1.11(d) shows that a pinion has a missing tooth. During the test,
the motor speed is set to 1,000 RPM (revolutions per minute) so the meshing frequency is determined as
fm ¼ 1000ðRPMÞ  18=60 ¼ 300 Hz and input shaft frequency is fi ¼ 1000ðRPMÞ=60 ¼ 16:17 Hz.
The baseline signal and spectrum (excellent condition) from the x-direction of the accelerometer
are displayed in Figure 1.12, where we can see that the spectrum contains the meshing frequency
component of 300 Hz and a sideband frequency component of 283.33 (300  16.67) Hz.
Figure 1.13 shows the vibration signature for the damaged pinion in Figure 1.11(d). For the
damaged pinion, the sidebands (fm  fi, fm  2fi . ) become dominant. Hence, the vibration failure
signature is identiﬁed. More details can be found in Randall (2011).
1.3.6 Digital Photo Image Enhancement
Digital image enhancement is another example of signal processing in two dimensions. Figure 1.14(a)
shows a picture of an outdoor scene taken by a digital camera on a cloudy day. Due to the weather
1.3 Overview of Typical Digital Signal Processing in Real World Applications
9

FIGURE 1.11
Vibration signature analysis of the gearbox.
(Courtesy of SpectaQuest, Inc.)
10
CHAPTER 1 Introduction to Digital Signal Processing

0
2
4
6
8
10
12
14
0.5
0
0.5
Time (sec.)
Amp tude (V)
0
1000
2000
3000
4000
5000
6000
7000
0
0.01
0.02
Frequency (Hz)
Amp tude (VRMS)
250
260
270
280
290
300
310
320
330
340
350
0
0.01
0.02
Zoomed Frequency (Hz)
Amp tude (VRMS)
Meshing frequency
Meshing frequency
Sideband frequency fm fi
FIGURE 1.12
Vibration signal and spectrum from the gearbox in good condition.
(Data provided by SpectaQuest, Inc.)
0
2
4
6
8
10
12
14
2
0
2
Time (sec.)
Amp tude (V)
0
1000
2000
3000
4000
5000
6000
7000
0
0.02
0.04
Frequency (Hz)
Amp tude (VRMS)
250
260
270
280
290
300
310
320
330
340
350
0
0.01
0.02
Zoomed Frequency (Hz)
Amp tude (VRMS)
Meshing frequency
Meshing frequency
Sidebands
Sidebands
FIGURE 1.13
Vibration signal and spectrum from the damaged gearbox.
(Data provided by SpectaQuest, Inc.)
1.3 Overview of Typical Digital Signal Processing in Real World Applications
11

conditions, the image was improperly exposed in natural light and came out dark. The image pro-
cessing technique called histogram equalization (Gozalez and Wintz, 1987) can stretch the light
intensity of an image using the digital information (pixels) to increase image contrast so that detailed
information in the image can easily be seen, as we can see in Figure 1.14(b). We will study this
technique in Chapter 14.
1.4 DIGITAL SIGNAL PROCESSING APPLICATIONS
Applications of DSP are increasing in many areas where analog electronics are being replaced by DSP
chips, and new applications are depending on DSP techniques. With the cost of DS processors
decreasing and their performance increasing, DSP will continue to affect engineering design in our
modern daily life. Some application examples using DSP are listed in Table 1.1.
FIGURE 1.14
Image enhancement.
Table 1.1 Applications of Digital Signal Processing
Digital audio and speech
Digital audio coding such as CD players and MP3 players, digital crossover,
digital audio equalizers, digital stereo and surround sound, noise reduction
systems, speech coding, data compression and encryption, speech synthesis
and speech recognition
Digital telephone
Speech recognition, high-speed modems, echo cancellation, speech
synthesizers, DTMF (dual-tone multifrequency) generation and detection,
answering machines
Automobile industry
Active noise control systems, active suspension systems, digital audio and radio,
digital controls, vibration signal analysis
Electronic
communications
Cellular phones, digital telecommunications, wireless LAN (local area
networking), satellite communications
Medical imaging
equipment
ECG analyzers, cardiac monitoring, medical imaging and image recognition,
digital X-rays and image processing
Multimedia
Internet phones, audio and video, hard disk drive electronics, iPhone, iPad,
digital pictures, digital cameras, text-to-voice and voice-to-text technologies
12
CHAPTER 1 Introduction to Digital Signal Processing

However, the list in the table by no means covers all DSP applications. Engineers and scientists are
exploring many new potential applications. DSP techniques will continue to have a profound impact
and improve our lives.
1.5 SUMMARY
1. An analog signal is continuous in both time and amplitude. Analog signals in the real world include
current, voltage, temperature, pressure, light intensity, and so on. The digital signal contains the
digital values converted from the analog signal at the speciﬁed time instants.
2. Analog-to-digital signal conversion requires an ADC unit (hardware) and a lowpass ﬁlter attached
ahead of the ADC unit to block the high-frequency components that ADC cannot handle.
3. The digital signal can be manipulated using arithmetic. The manipulations may include digital
ﬁltering, calculation of signal frequency content, and so on.
4. The digital signal can be converted back to an analog signal by sending the digital values to DAC to
produce the corresponding voltage levels and applying a smooth ﬁlter (reconstruction ﬁlter) to the
DAC voltage steps.
5. Digital signal processing ﬁnds many applications in the areas of digital speech and audio, digital
and cellular telephones, automobile controls, vibration signal analysis, communications,
biomedical imaging, image/video processing, and multimedia.
1.5 Summary
13

This page intentionally left blank

Signal Sampling and Quantization 2
CHAPTER OUTLINE
2.1 Sampling of Continuous Signal........................................................................................................ 15
2.2 Signal Reconstruction .................................................................................................................... 21
2.2.1 Practical Considerations for Signal Sampling: Anti-Aliasing Filtering................................25
2.2.2 Practical Considerations for Signal Reconstruction: Anti-Image Filter and Equalizer..........30
2.3 Analog-to-Digital Conversion, Digital-to-Analog Conversion, and Quantization.................................... 35
2.4 Summary ....................................................................................................................................... 47
2.5 MATLAB Programs .......................................................................................................................... 48
OBJECTIVES:
This chapter investigates the sampling process, sampling theory, and the signal reconstruction
process. It also includes practical considerations for anti-aliasing and anti-image ﬁlters and signal
quantization.
2.1 SAMPLING OF CONTINUOUS SIGNAL
As discussed in Chapter 1, Figure 2.1 describes a simpliﬁed block diagram of a digital signal
processing (DSP) system. The analog ﬁlter processes the analog input to obtain the band-limited
signal, which is sent to the analog-to-digital conversion (ADC) unit. The ADC unit samples the
analog signal, quantizes the sampled signal, and encodes the quantized signal level to the digital
signal.
Here we ﬁrst develop concepts of sampling processing in the time domain. Figure 2.2 shows an
analog (continuous-time) signal (solid line) deﬁned at every point over the time axis (horizontal line)
and amplitude axis (vertical line). Hence, the analog signal contains an inﬁnite number of points.
It is impossible to digitize an inﬁnite number of points. The inﬁnite points cannot be processed by
the digital signal (DS) processor or computer, since they require an inﬁnite amount of memory and
inﬁnite amount of processing power for computations. Sampling can solve such a problem by taking
samples at a ﬁxed time interval as shown in Figure 2.2 and Figure 2.3, where the time T represents the
sampling interval or sampling period in seconds.
As shown in Figure 2.3, each sample maintains its voltage level during the sampling interval T to
give the ADC enough time to convert it. This process is called sample and hold. Since there exits one
amplitude level for each sampling interval, we can sketch each sample amplitude level at its corre-
sponding sampling time instant shown in Figure 2.2, where 14 samples at their sampling time instants
are plotted, each using a vertical bar with a solid circle at its top.
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00002-0
Copyright  2013 Elsevier Inc. All rights reserved.
15

For a given sampling interval T, which is deﬁned as the time span between two sample points, the
sampling rate is therefore given by
fs ¼ 1
T
samples per second ðHzÞ
For example, if a sampling period is T ¼ 125 microseconds, the sampling rate is fs ¼ 1=125ms ¼
8; 000 samples per second (Hz).
0
2T
4T
5
nT
6T
8T
10T
12T
Analog signal/continuous-time signal
Signal samples
x t( )
Sampling interval T
5
0
FIGURE 2.2
Display of the analog (continuous) signal and the digital samples versus the sampling time instants.
x t( )
0
2T
4T
5
5
nT
6T
8T
10T
12T
Analog signal
0
Voltage for ADC
FIGURE 2.3
Sample-and-hold analog voltage for ADC.
Analog
filter
ADC
DSP
DAC
Reconstruction
filter
Analog
input
Analog
output
Band limited
signal
Digital
signal
Processed
digital signal
Output
signal
FIGURE 2.1
A digital signal processing scheme.
16
CHAPTER 2 Signal Sampling and Quantization

After obtaining the sampled signal whose amplitude values are taken at the sampling instants, the
processor is able to process the sample points. Next, we have to ensure that samples are collected at
a rate high enough that the original analog signal can be reconstructed or recovered later. In other
words, we are looking for a minimum sampling rate to acquire a complete reconstruction of the analog
signal from its sampled version. If an analog signal is not appropriately sampled, aliasing will occur,
which causes unwanted signals in the desired frequency band.
The sampling theorem guarantees that an analog signal can be in theory perfectly recovered as long
as the sampling rate is at least twice as large as the highest-frequency component of the analog signal
to be sampled. The condition is described as
fs  2fmax
where fmax is the maximum-frequency component of the analog signal to be sampled. For example, to
sample a speech signal containing frequencies up to 4 kHz, the minimum sampling rate is chosen to be
at least 8 kHz, or 8,000 samples per second; to sample an audio signal possessing frequencies up to
20 kHz, at least 40,000 samples per second, or 40 kHz, of the audio signal are required.
Figure 2.4 illustrates sampling of two sinusoids, where the sampling interval between sample points
is T ¼ 0:01 second, and the sampling rate is thus fs ¼ 100 Hz. The ﬁrst plot in the ﬁgure displays
a sine wave with a frequency of 40 Hz and its sampled amplitudes. The sampling theorem condition is
satisﬁed since 2fmax ¼ 80 < fs. The sampled amplitudes are labeled using the circles shown in the ﬁrst
0
0.01
0.02
0.03
0.04
0.05
0.06
0.07
0.08
0.09
0.1
1
0
1
Time (sec.)
Vo tage
Sampling condition is satisfied
0
0.01
0.02
0.03
0.04
0.05
0.06
0.07
0.08
0.09
0.1
1
0
1
Time (sec.)
Vo tage
Sampling condition is not satisfied
40 Hz
90 Hz
10 Hz
FIGURE 2.4
Plots of the appropriately sampled signals and nonappropriately sampled (aliased) signals.
2.1 Sampling of Continuous Signal
17

plot. We notice that the 40-Hz signal is adequately sampled, since the sampled values clearly come from
the analog version of the 40-Hz sine wave. However, as shown in the second plot, the sine wave with
a frequency of 90 Hz is sampled at 100 Hz. Since the sampling rate of 100 Hz is relatively low compared
with the 90-Hz sine wave, the signal is undersampled due to 2fmax ¼ 180 > fs. Hence, the condition of
the sampling theorem is not satisﬁed. Based on the sample amplitudes labeled with the circles in the
second plot, we cannot tell whether the sampled signal comes from sampling a 90-Hz sine wave (plotted
using the solid line) or from sampling a 10-Hz sine wave (plotted using the dot-dash line). They are not
distinguishable. Thus they are aliases of each other. We call the 10-Hz sine wave the aliasing noise in
this case, since the sampled amplitudes actually come from sampling the 90-Hz sine wave.
Now let us develop the sampling theorem in frequency domain, that is, the minimum sampling rate
requirement for sampling an analog signal. As we shall see, in practice this can help us design the anti-
aliasing ﬁlter (a lowpass ﬁlter that will reject high frequencies that cause aliasing) that will be applied
before sampling, and the anti-image ﬁlter (a reconstruction lowpass ﬁlter that will smooth the
recovered sample-and-hold voltage levels to an analog signal) that will be applied after the digital-to-
analog conversion (DAC).
Figure 2.5 depicts the sampled signal xsðtÞ obtained by sampling the continuous signal xðtÞ at
a sampling rate of fs samples per second.
Mathematically, this process can be written as the product of the continuous signal and the
sampling pulses (pulse train):
xsðtÞ ¼ xðtÞpðtÞ
(2.1)
where pðtÞ is the pulse train with a period T ¼ 1=fs. From spectral analysis, the original spectrum
(frequency components) XðfÞ and the sampled signal spectrum XsðfÞ in terms of Hz are related as
XsðfÞ ¼ 1
T
X
N
n ¼
N
Xðf  nfsÞ
(2.2)
x t( )
x t( )
t
t
t
p t( )
x t
x t p t
s( )
( ) ( )
=
T
T
1
x T
s( )
xs( )
0
x
T
s(
)
2
ADC
encoding
FIGURE 2.5
The simpliﬁed sampling process.
18
CHAPTER 2 Signal Sampling and Quantization

where XðfÞ is assumed to be the original baseband spectrum while XsðfÞ is its sampled signal spec-
trum, consisting of the original baseband spectrum XðfÞ and its replicas Xðf  nfsÞ. Since Equation
(2.2) is a well-known formula, the derivation is omitted here and can be found in well-known texts
(Ahmed and Nataranjan, 1983; Ambardar, 1999; Alkin, 1993; Oppenheim and Schafer, 1975; Proakis
and Manolakis, 1996).
Expanding Equation (2.2) leads to the sampled signal spectrum in Equation (2.3):
XsðfÞ ¼ / þ 1
TXðf þ fsÞ þ 1
TXðfÞ þ 1
TXðf  fsÞ þ /
(2.3)
Equation (2.3) indicates that the sampled signal spectrum is the sum of the scaled original spectrum and
copies of its shifted versions, called replicas. Three possible sketches based on Equation (2.3) can be
obtained. Given the original signal spectrum XðfÞ plotted in Figure 2.6(a), the sampled signal
spectrum according to Equation (2.3) is plotted in Figure 2.6(b), where the replicas 1
TXðfÞ, 1
TXðf  fsÞ,
1
TXðf þ fsÞ, ., have separations between them. Figure 2.6(c) shows that the baseband spectrum and its
replicas, 1
TXðfÞ, 1
TXðf  fsÞ, 1
TXðf þ fsÞ, ., are just connected, and ﬁnally, in Figure 2.6(d), the original
B
X f
( )
0
f
f
f
f
0
0
0
X
f
s( )
X
f
s( )
X
f
s( )
B
B
B
−B
−B
−B
−B
f s
−f s
f s
f s
−f s
−f s
f
B
s −
f
B
s −
f
B
s +
f
B
s +
f
B
s +
−
+
f
B
s
−
+
f
B
s
−
−
f
B
s
−
−
f
B
s
−
−
f
B
s
10.
1
T
1
T
1
T
f s
2
B
f
=
max
Lowpass filter
Folding frequency/Nyquist limit
(a)
(b)
(c)
(d)
FIGURE 2.6
Plots of the sampled signal spectrum.
2.1 Sampling of Continuous Signal
19

spectrum 1
TXðfÞ and its replicas 1
TXðf  fsÞ, 1
TXðf þ fsÞ, ., are overlapped; that is, there are many
overlapping portions in the sampled signal spectrum.
From Figure 2.6, it is clear that the sampled signal spectrum consists of the scaled baseband
spectrum centered at the origin, and its replicas centered at the frequencies of nfs (multiples of the
sampling rate) for each of n ¼ 1; 2; 3; ..
If applying a lowpass reconstruction ﬁlter to obtain exact reconstruction of the original signal
spectrum, the following condition must be satisﬁed:
fs  fmax  fmax
(2.4)
Solving Equation (2.4) gives
fs  2fmax
(2.5)
In terms of frequency in radians per second, Equation (2.5) is equivalent to
us  2umax
(2.6)
This fundamental conclusion is well known as the Shannon sampling theorem, which is formally
described below:
We summarize two key points here.
1. The sampling theorem establishes a minimum sampling rate for a given band-limited analog signal
with highest-frequency component fmax. If the sampling rate satisﬁes Equation (2.5), then the
analog signal can be recovered via its sampled values using the lowpass ﬁlter, as described in
Figure 2.6(b).
2. Half of the sampling frequency fs=2 is usually called the Nyquist frequency (Nyquist limit) or
folding frequency. The sampling theorem indicates that a DSP system with a sampling rate of fs
can ideally sample an analog signal with a maximum frequency that is up to half of the
sampling rate without introducing spectral overlap (aliasing). Hence, the analog signal can be
perfectly recovered from its sampled version.
Let us study the following example.
EXAMPLE 2.1
Suppose that an analog signal is given as
xðtÞ
5cosð2p$1; 000tÞ; for t  0
and is sampled at the rate 8,000 Hz.
a. Sketch the spectrum for the original signal.
b. Sketch the spectrum for the sampled signal from 0 to 20 kHz.
For a uniformly sampled DSP system, an analog signal can be perfectly recovered as long as the sampling rate is at
least twice as large as the highest frequency component of the analog signal to be sampled.
20
CHAPTER 2 Signal Sampling and Quantization

Solution:
a. Since the analog signal is sinusoid with a peak value of 5 and frequency of 1,000 Hz, we can write the sine wave
using Euler’s identity:
5cosð2p  1; 000tÞ
5$ðej2p1;000t þ ej2p1;000t
2
Þ
2:5ej2p1;000t þ 2:5ej2p1;000t
whichis aFourierseries expansion for a continuous periodicsignalin terms of theexponentialform(seeAppendix B).We
can identify the Fourier series coefﬁcients as
c1
2:5 and c1
2:5
Using the magnitudes of the coefﬁcients, we then plot the two side spectrum as shown in Figure 2.7A.
b. After the analog signal is sampled at the rate of 8,000 Hz, the sampled signal spectrum and its replicas centered
at the frequencies nfs, each with a scaled amplitude of 2:5=T, are as shown in Figure 2.7B:
Notice that the spectrum of the sampled signal shown in Figure 2.7B contains the images of the original
spectrum shown in Figure 2.7A; that the images repeat at multiples of the sampling frequency fs (for our example,
8 kHz, 16kHz, 24kHz, .); and that all images must be removed, since they convey no additional information.
2.2 SIGNAL RECONSTRUCTION
In this section, we investigate the recovery of analog signal from its sampled signal version. Two
simpliﬁed steps are involved, as described in Figure 2.8. First, the digitally processed data yðnÞ are
converted to the ideal impulse train ysðtÞ, in which each impulse has amplitude proportional to digital
output yðnÞ, and two consecutive impulses are separated by a sampling period of T; second, the analog
f
kHz
1
−1
X f
( )
2 5.
FIGURE 2.7A
Spectrum of the analog signal in Example 2.1.
f
kHz
X
f
s( )
−8
8
16
1
−1
7
9
15
17
−9
−7
2.5/T
FIGURE 2.7B
Spectrum of the sampled signal in Example 2.1.
2.2 Signal Reconstruction
21

reconstruction ﬁlter is applied to the ideally recovered sampled signal ysðtÞ to obtain the recovered
analog signal.
To study the signal reconstruction, we let yðnÞ ¼ xðnÞ for the case of no DSP, so that the recon-
structed sampled signal and the input sampled signal are ensured to be the same; that is, ysðtÞ ¼ xsðtÞ.
Hence, the spectrum of the sampled signal ysðtÞ contains the same spectral content of the original
spectrum XðfÞ, that is, YðfÞ ¼ XðfÞ, with a bandwidth of fmax ¼ B Hz (described in Figure 2.8d)
and the images of the original spectrum (scaled and shifted versions). The following three cases are
discussed for recovery of the original signal spectrum XðfÞ.
Case 1: fs ¼ 2fmax
As shown in Figure 2.9, where the Nyquist frequency is equal to the maximum frequency of the
analog signal xðtÞ, an ideal lowpass reconstruction ﬁlter is required to recover the analog signal
spectrum. This is an impractical case.
y t( )
t
t
y t
s( )
T
y T
s( )
ys( )
0
y
T
s(
)
2
Digital signal
y n
( )
Lowpass
reconstruction
filter
n
y n
( )
y( )1
y( )
0
y( )
2
y t
s( )
y t( )
DAC
a.Digital signal processed
b.Sampled signal recovered       c.Analog signal recovered. 
B
Y f
( )
0
f
−B
10.
f
B
max =
d.Recovered signal spectrum 
FIGURE 2.8
Signal notations at the reconstruction stage.
f
0
X
f
s( )
B
−B
f s
−f s
f
B
s +
−
−
f
B
s
1
T
Ideal lowpass filter
FIGURE 2.9
Spectrum of the sampled signal when fs ¼ 2fmax.
22
CHAPTER 2 Signal Sampling and Quantization

Case 2: fs > 2fmax
In this case, as shown in Figure 2.10, there is a separation between the highest-frequency edge of
the baseband spectrum and the lower edge of the ﬁrst replica. Therefore, a practical lowpass recon-
struction (anti-image) ﬁlter can be designed to reject all the images and achieve the original signal
spectrum.
Case 3: fs < 2fmax
Case 3 violates the condition of the Shannon sampling theorem. As we can see, Figure 2.11 depicts
the spectral overlapping between the original baseband spectrum and the spectrum of the ﬁrst replica
and so on. Even when we apply an ideal lowpass ﬁlter to remove these images, in the baseband there
are still some foldover frequency components from the adjacent replica. This is aliasing, where the
recovered baseband spectrum suffers spectral distortion, that is, it contains an aliasing noise spectrum;
in the time domain, the recovered analog signal may consist of the aliasing noise frequency or
frequencies. Hence, the recovered analog signal is incurably distorted.
Note that if an analog signal with a frequency f is undersampled, the aliasing frequency component
falias in the baseband is simply given by the following expression:
falias ¼ fs  f
The following examples give a spectrum analysis of the signal recovery.
EXAMPLE 2.2
Assume that an analog signal is given by
xðtÞ
5cosð2p$2; 000tÞ þ 3cosð2p$3; 000tÞ; for t  0
f
0
X
f
s( )
B
−B
f s
−f s
f
B
s −
f
B
s +
−
+
f
B
s
−
−
f
B
s
1
T
Practical lowpass filter
FIGURE 2.10
Spectrum of the sampled signal when fs > 2fmax.
f
0
X
f
s( )
B
−B
f s
−f s
f
B
s −
f
B
s +
−
+
f
B
s
−
−
f
B
s
1
T
Ideal lowpass filter
FIGURE 2.11
Spectrum of the sampled signal when fs < 2fmax.
2.2 Signal Reconstruction
23

and is sampled at the rate of 8,000 Hz.
a. Sketch the spectrum of the sampled signal up to 20 kHz.
b. Sketch the recovered analog signal spectrum if an ideal lowpass ﬁlter with a cutoff frequency of 4 kHz is used to
ﬁlter the sampled signal (yðnÞ
xðnÞ in this case) to recover the original signal.
Solution:
a. Using Euler’s identity, we get
xðtÞ
3
2ej2p$3;000t þ 5
2ej2p$2;000t þ 5
2ej2p$2;000t þ 3
2ej2p$3;000t
The two sided amplitude spectrum for the sinusoid is displayed in Figure 2.12:
b. Based on the spectrum in (a), the sampling theorem condition is satisﬁed; hence, we can recover the original
spectrum using a reconstruction lowpass ﬁlter. The recovered spectrum is shown in Figure 2.13.
EXAMPLE 2.3
Assume an analog signal is given by
xðtÞ
5cosð2p  2; 000tÞ þ 1cosð2p  5; 000tÞ; for t  0
and is sampled at a rate of 8,000 Hz.
a. Sketch the spectrum of the sampled signal up to 20 kHz.
b. Sketch the recovered analog signal spectrum if an ideal lowpass ﬁlter with a cutoff frequency of 4 kHz is used to
recover the original signal (yðnÞ
xðnÞ in this case).
f
kHz
X
f
s( )
8
16
−2
6
10
14
18
−10
−6
2.5/T
2
−11
−5 −3
3
5
11 13
19
FIGURE 2.12
Spectrum of the sampled signal in Example 2.2.
f
kHz
2
−2
Y f
( )
3
−3
FIGURE 2.13
Spectrum of the recovered signal in Example 2.2.
24
CHAPTER 2 Signal Sampling and Quantization

Solution:
a. The spectrum for the sampled signal is sketched in Figure 2.14.
b. Since the maximum frequency of the analog signal is larger than that of the Nyquist frequencydthat is, twice
the maximum frequency of the analog signal is larger than the sampling ratedthe sampling theorem condition is
violated. The recovered spectrum is shown in Figure 2.15, where we see that aliasing noise occurs at 3 kHz.
2.2.1 Practical Considerations for Signal Sampling: Anti-Aliasing Filtering
In practice, the analog signal to be digitized may contain other frequency components in addition to the
folding frequency, such as high-frequency noise. To satisfy the sampling theorem condition, we apply
an anti-aliasing ﬁlter to limit the input analog signal, so that all the frequency components are less than
the folding frequency (half of the sampling rate). Considering the worst case, where the analog signal
to be sampled has a ﬂat frequency spectrum, the band limited spectrum XðfÞ and sampled spectrum
XsðfÞ are depicted in Figure 2.16, where the shape of each replica in the sampled signal spectrum is the
same as that of the anti-aliasing ﬁlter magnitude frequency response.
Due to nonzero attenuation of the magnitude frequency response of the anti-aliasing lowpass ﬁlter,
the aliasing noise from the adjacent replica still appears in the baseband. However, the amount of
aliasing noise is greatly reduced. We can also control the aliasing noise by either using a higher-order
lowpass ﬁlter or increasing the sampling rate. For illustrative purpose, we use a Butterworth ﬁlter. The
method can also be extended to other ﬁlter types such as the Chebyshev ﬁlter. The Butterworth
magnitude frequency response with an order of n is given by
jHðfÞj ¼
1
1 þ
f
fc
2n
s
(2.7)
f
kHz
X
f
s( )
8
16
−2
6
10
14
18
−10
−6
2 5. / T
2
−11
−5 −3
3
5
11 13
19
Aliasing noise
FIGURE 2.14
Spectrum of the sampled signal in Example 2.3.
f
kHz
2
−2
Y f
( )
3
−3
Aliasing noise
FIGURE 2.15
Spectrum of the recovered signal in Example 2.3.
2.2 Signal Reconstruction
25

For a second-order Butterworth lowpass ﬁlter with unit gain, the transfer function (which will be
discussed in Chapter 8) and its magnitude frequency response are given by
HðsÞ ¼
ð2pfcÞ2
s2 þ 1:4141  ð2pfcÞs þ ð2pfcÞ2
(2.8)
jHðfÞj ¼
1
1 þ
f
fc
4
s
(2.9)
A unit gain second-order lowpass ﬁlter using a Sallen-Key topology is shown in Figure 2.17. Matching
the coefﬁcients of the circuit transfer function to that of the second-order Butterworth lowpass transfer
function in Equation (2.10) gives the design formulas shown in Figure 2.17, where for a given cutoff
Anti aliasing
LP filter
Sample and
hold
ADC
coding
Digital value
fc
f s
f
f
s
a
−
f
fc
X f
( )
X
f
s( )
f
f
fa
Xa
Aliasing level  Xa
at fa (image from fs − fa )
f s
2
Analog signal spectrum
(worst case)
FIGURE 2.16
Spectrum of the sampled analog signal with a practical anti-aliasing ﬁlter.
−
+
Vin
Vo
R1
C2
R2
C1
R
R
C
fc)
1
2
2 
14142
(2
=
=
.
π
C
R R C
 fc)
1
1
2
2
2
1
(2
=
π
C2
Choose
FIGURE 2.17
Second-order unit gain Sallen-Key lowpass ﬁlter.
26
CHAPTER 2 Signal Sampling and Quantization

frequency of fc in Hz, and a capacitor value of C2, we can determine the other elements using the
formulas listed in the ﬁgure.
1
R1R2C1C2
s2 þ

1
R1C2
þ
1
R2C2

s þ
1
R1R2C1C2
¼
ð2pfcÞ2
s2 þ 1:4141  ð2pfcÞs þ ð2pfcÞ2
(2.10)
As an example, for a cutoff frequency of 3,400 Hz, and by selecting C2 ¼ 0:01 microfarad (mF),
we get
R1 ¼ R2 ¼ 6; 620 U; and C1 ¼ 0:005 mF
Figure 2.18 shows the magnitude frequency response, where the absolute gain of the ﬁlter is
plotted. As we can see, the absolute attenuation begins at the level of 0.7 at 3,400 Hz and reduces
to 0.3 at 6,000 Hz. Ideally, we want the gain attenuation to be zero after 4,000 Hz if our sampling
rate is 8,000 Hz. Practically speaking, aliasing will occur anyway with some degree. We will study
achieving the higher-order analog ﬁlter via Butterworth and Chebyshev prototype function tables
in Chapter 8. More details of the circuit realization for the analog ﬁlter can be found in Chen
(1986).
0
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
1.1
Frequency (Hz)
Magn tude response
fc=3400 Hz
FIGURE 2.18
Magnitude frequency response of the second-order Butterworth lowpass ﬁlter.
2.2 Signal Reconstruction
27

According to Figure 2.16, we can derive the aliasing level percentage using the symmetry of the
Butterworth magnitude function and its ﬁrst replica. It follows that
aliasing level % ¼
Xa
XðfÞjf¼fa
¼
jHðfÞjf ¼fs
fa
jHðfÞjf ¼fa
¼
1 þ
fa
fc
2n
s
1 þ
fs  fa
fc
2n
s
for
0  f  fc
(2.11)
With Equation (2.11), we can estimate the aliasing noise percentage, or choose a higher-order anti-
aliasing ﬁlter to satisfy the requirement for the aliasing level percentage.
EXAMPLE 2.4
Given the DSP system shown in Figures 2.16 to 2.18, where a sampling rate of 8,000 Hz is used and the anti
aliasing ﬁlter is a second order Butterworth lowpass ﬁlter with a cutoff frequency of 3.4 kHz, determine
a. the percentage of aliasing level at the cutoff frequency;
b. the percentage of aliasing level at a frequency of 1,000 Hz.
Solution:
fs
8; 000; fc
3; 400;
and
n
2
a. Since fa
fc
3; 400 Hz, we compute
aliasing level %
1 þ
3:4
3:4
22
s
1 þ
8
3:4
3:4
22
s
1:4142
2:0858
67:8%
b. With fa
1; 000 Hz, we have
aliasing level %
1 þ
 1
3:4
22
s
1 þ
8
1
3:4
22
s
1:03007
4:3551
23:05%
Let us examine another example with an increased sampling rate.
EXAMPLE 2.5
Given the DSP system shown in Figures 2.16 to 2.18, where a sampling rate of 16,000 Hz is used and the anti
aliasing ﬁlter is a second order Butterworth lowpass ﬁlter with a cutoff frequency of 3.4 kHz, determine the
percentage of aliasing level at the cutoff frequency.
28
CHAPTER 2 Signal Sampling and Quantization

Solution:
fs
16; 000; fc
3; 400;
and
n
2
Since fa
fc
3; 400 Hz, we have
aliasing level %
1 þ
3:4
3:4
22
s
1 þ
16
3:4
3:4
22
s
1:4142
13:7699
10:26%
In comparison with the result in Example 2.4, increasing the sampling rate can reduce the aliasing level.
The following example shows how to choose the order of the anti-aliasing ﬁlter.
EXAMPLE 2.6
Given the DSP system shown in Figure 2.16, where a sampling rate of 40,000 Hz is used, the anti aliasing ﬁlter is
the Butterworth lowpass ﬁlter with a cutoff frequency 8 kHz, and the percentage of aliasing level at the cutoff
frequency is required to be less than 1%, determine the order of the anti aliasing lowpass ﬁlter.
Solution:
Using fs
40; 000, fc
8; 000, and fa
8; 000 Hz, we start at order 1 and increase the ﬁlter order until the
requirement is met.
n
1;
aliasing level %
1 þ
8
8
21
s
1 þ
40
8
8
21
s
1:4142
1 þ ð4Þ2
q
34:30%
n
2;
aliasing level %
1:4142
1 þ ð4Þ4
q
8:82%
n
3;
aliasing level %
1:4142
1 þ ð4Þ6
q
2:21%
n
4;
aliasing level %
1:4142
1 þ ð4Þ8
q
0:55% < 1%
To satisfy the 1% aliasing level requirement, we choose n
4.
2.2 Signal Reconstruction
29

2.2.2 Practical Considerations for Signal Reconstruction: Anti-Image Filter
and Equalizer
The analog signal recovery for a practical DSP system is illustrated in Figure 2.19.
As shown in Figure 2.19, the DAC unit converts the processed digital signal yðnÞ to a sampled
signal ysðtÞ, and then the hold circuit produces the sample-and-hold voltage yHðtÞ. The transfer
function of the hold circuit can be derived as
HhðsÞ ¼ 1  e sT
sT
(2.12)
We can obtain the frequency response of the DAC with the hold circuit by substituting s ¼ ju in
Equation (2.12). It follows that
HhðuÞ ¼ e juT=2sinðuT=2Þ
uT=2
(2.13)
The magnitude and phase responses are given by
jHhðuÞj ¼

sinðuT=2Þ
uT=2
 ¼

sinðxÞ
x

(2.14)
:HhðuÞ ¼ uT=2
(2.15)
where x ¼ uT=2. In terms of Hz, we have
jHhðfÞj ¼

sinðpfTÞ
pfT

(2.16)
t
t
ys (t) 
T
Digital Signal
y n
( )
Anti
image
filter
n
y n( )
y t
s( )
y t( )
Hold
Circuit
Equalizer
t
y(t)
yH (t)
T
y
t
H ( )
1
( )
sT
h
e
H
s
sT
−
−
=
DAC
(a)
(b)
(c)
(d)
FIGURE 2.19
Signal notations at the practical reconstruction stage. (a) Processed digital signal. (b) Recovered ideal sampled
signal. (c) Recovered sample-and-hold voltage. (d) Recovered analog signal.
30
CHAPTER 2 Signal Sampling and Quantization

:HhðfÞ ¼ pfT
(2.17)
The plot of the magnitude effect is shown in Figure 2.20.
The magnitude frequency response acts like lowpass ﬁltering and shapes the sampled signal
spectrum of YsðfÞ. This shaping effect distorts the sampled signal spectrum YsðfÞ in the desired
frequency band, as illustrated in Figure 2.21. On the other hand, the spectral images are attenuated
20
15
10
5
0
5
10
15
20
0.5
0
0.5
1
x
s n(x)/x
0
0.5
1
1.5
2
2.5
3
0
0.2
0.4
0.6
0.8
1
Radians
Hh(w)
FIGURE 2.20
Sample-and-hold lowpass ﬁltering effect.
f
Y f
s( )
Y f
( )
Y f
f s
(
)
−
Y f
f s
(
)
−2
f s
2 f s
Spectral images
sin( )
x
x
Sample and hold effect
0
FIGURE 2.21
Sample-and-hold effect and distortion.
2.2 Signal Reconstruction
31

due to the lowpass effect of sinðxÞ=x. This sample-and-hold effect can help us design the anti-image
ﬁlter.
As shown in Figure 2.21, the percentage of distortion in the desired frequency band is given by
distortion % ¼ ð1  jHhðfÞjÞ  100%
¼

1 

sinðpfTÞ
pfT


 100%
(2.18)
EXAMPLE 2.7
Given a DSP system with a sampling rate of 8,000 Hz and a hold circuit used after DAC, determine
a. the percentage of distortion at a frequency of 3,400 Hz;
b. the percentage of distortion at a frequency of 1,000 Hz.
Solution:
a. Since fT
3; 400  1=8; 000
0:425;
distortion %

1

sinð0:425pÞ
0:425p


 100%
27:17%
b. Since fT
1; 000  1=8; 000
0:125;
distortion %

1

sinð0:125pÞ
0:125p


 100%
2:55%
To overcome the sample-and-hold effect, the following methods can be applied.
1. We can compensate the sample-and-hold shaping effect using an equalizer whose magnitude
response is opposite to the shape of the hold circuit magnitude frequency response, which is
shown as the solid line in Figure 2.22.
2. We can increase the sampling rate using oversampling and interpolation methods when a higher
sampling rate is available at the DAC. Using the interpolation will increase the sampling rate
without affecting the signal bandwidth, so that the baseband spectrum and its images are
separated further apart and a lower-order anti-aliasing ﬁlter can be used. This subject will be
discussed in Chapter 12.
3. We can change the DAC conﬁguration and perform digital pre-equalization using a ﬂexible digital
ﬁlter whose magnitude frequency response is against the spectral shape effect due to the hold
circuit. Figure 2.23 shows a possible implementation. In this way, the spectral shape effect can
be balanced before the sampled signal passes through the hold circuit. Finally, the anti-image
ﬁlter will remove the rest of images and recover the desired analog signal.
The following practical example will illustrate the design of an anti-image ﬁlter using a higher
sampling rate while making use of the sample-and-hold effect.
32
CHAPTER 2 Signal Sampling and Quantization

EXAMPLE 2.8
Determine the cutoff frequency and the order for the anti image ﬁlter given a DSP system with a sampling rate of
16,000 Hz and speciﬁcations for the anti image ﬁlter as shown in Figure 2.24.
Design requirements:
•
Maximum allowable gain variation from 0 to 3,000 Hz
2 dB
•
33 dB rejection at a frequency of 13,000 Hz
•
Butterworth ﬁlter is assumed for the anti image ﬁlter.
Solution:
We ﬁrst determine the spectral shaping effects at f
3; 000 Hz and f
13; 000 Hz; that is,
Digital signal
y n( )
Anti
image
filter
y t
s ( )
y t( )
Hold
Digital equalizer
y
t
H ( )
y
n
eq( )
DAC
FIGURE 2.23
Possible implementation using a digital equalizer.
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
0.7
0.8
0.9
1
1.1
1.2
1.3
1.4
1.5
1.6
Equa zer ga n
Radians
FIGURE 2.22
Ideal equalizer magnitude frequency response to overcome the distortion introduced by the sample-and-hold
process.
2.2 Signal Reconstruction
33

f
3; 000 Hz; fT
3; 000  1=16; 000
0:1785
gain

sinð0:1875pÞ
0:1875p

0:9484
0:46 dB
and
f
13; 000 Hz; fT
13; 000  1=16; 000
0:8125
gain

sinð0:8125pÞ
0:8125p

0:2177 z
13 dB
This gain would help the attenuation requirement.
Hence, the design requirements for the anti image ﬁlter are
•
Butterworth lowpass ﬁlter
•
Maximum allowable gain variation from 0 to 3,000 Hz
2 0.46
1.54 dB
•
33 13
20 dB rejection at frequency 13,000 Hz.
We set up equations using log operations of the Butterworth magnitude function as
20 logð1 þ ð3; 000=fcÞ2nÞ1=2  1:54
20 logð1 þ ð13; 000=fcÞ2nÞ1=2  20
Digital signal
y n
( )
Anti
image
filter
y t
s( )
y t( )
Hold
y
t
H ( )
DAC
FIGURE 2.24
DSP recover system for Example 2.8.
f
13.
32.
3
16.
kHz
0 9484
.
0 2177
.
Y f
s( )
0
FIGURE 2.25
Spectral shaping by the sample-and-hold effect in Example 2.8.
34
CHAPTER 2 Signal Sampling and Quantization

From these two equations, we have to satisfy
ð3; 000=fcÞ2n
100:154
1
ð13; 000=fcÞ2n
102
1
Taking the ratio of these two equations yields
13; 000
3; 000
2n
102
1
100:154
1
Then
n
1
2 logðð102
1Þ=ð100:154
1ÞÞ=logð13; 000=3; 000Þ
1:86 z 2
Finally, the cutoff frequency can be computed as
fc
13; 000
ð102
1Þ1=ð2nÞ
13; 000
ð102
1Þ1=4
4; 121:30 Hz
fc
3; 000
ð100:154
1Þ1=ð2nÞ
3; 000
ð100:154
1Þ1=4
3; 714:23 Hz
We choose the smaller one, that is,
fc
3; 714:23 Hz
With the ﬁlter order and cutoff frequency, we can realize the anti image (reconstruction) ﬁlter using the second
order unit gain Sallen Key lowpass ﬁlter described in Figure 2.17.
Note that the speciﬁcations for anti-aliasing ﬁlter designs are similar to anti-image (reconstruction)
ﬁlters, except for their stopband edges. The anti-aliasing ﬁlter is designed to block the frequency
components beyond the folding frequency before the ADC operation, while the reconstruction ﬁlter
is designed to block the frequency components beginning at the lower edge of the ﬁrst image after
the DAC.
2.3 ANALOG-TO-DIGITAL CONVERSION, DIGITAL-TO-ANALOG CONVERSION,
AND QUANTIZATION
During the ADC process, amplitudes of the analog signal to be converted have inﬁnite precision. The
continuous amplitude must be converted to digital data with ﬁnite precision, which is called quanti-
zation. Figure 2.26 shows quantization as a part of ADC.
There are several ways to implement ADC. The most common ones are
•
Flash ADC
•
Successive approximation ADC
•
Sigma-delta ADC.
2.3 Analog Conversion and Quantization
35

In this chapter, we will focus on a simple 2-bit ﬂash ADC unit, described in Figure 2.27, for illustrative
purposes. Sigma-delta ADC will be studied in Chapter 12.
As shown in Figure 2.27, the 2-bit ﬂash ADC unit consists of a serial reference voltage created by
the equal value resistors, a set of comparators, and logic units. As an example, the reference voltages in
the ﬁgure are 1.25 volts, 2.5 volts, 3.75 volts, and 5 volts, respectively. If an analog sample-and-hold
voltage is Vin ¼ 3 volts, then the lower two comparators will each output logic 1. Through the logic
units, only the line labeled 10 is actively high, and the rest of lines are actively low. Hence, the
encoding logic circuit outputs a 2-bit binary code of 10.
Flash ADC offers the advantage of high conversion speed, since all bits are acquired at the same
time. Figure 2.28 illustrates a simple 2-bit DAC unit using an R-2R ladder. The DAC contains the R-2R
ladder circuit, a set of single-throw switches, an adder, and a phase shifter. If a bit is logic 0, the switch
connects a 2R resistor to ground. If a bit is logic 1, the corresponding 2R resistor is connected to the
branch to the input of the operational ampliﬁer (adder). When the operational ampliﬁer operates in
a linear range, the negative input is virtually equal to the positive input. The adder adds all the currents
+
−
+
−
+
−
R
R
R
R
VR = 5
Vin
00
01
10
11
Encoding
logic
VR
4
125
= .
VR
2
2 5
= .
3
4
375
VR = .
Comparators
10
logic 0
logic 0
logic 0
logic 1
logic 0
logic 1
logic 1
logic 1
logic 0
FIGURE 2.27
An example of a 2-bit ﬂash ADC.
x t( )
y t( )
ADC
Anti
aliasing
filter
Sample
and hold
Quantization
binary
encoder
DAC
Digital
signal
 processor
Zeroth
order
hold
Anti
image
filter
FIGURE 2.26
A block diagram for a DSP system.
36
CHAPTER 2 Signal Sampling and Quantization

from all branches. The feedback resistor R in the adder provides overall ampliﬁcation. The ladder
network is equivalent to two 2R resistors in parallel. The entire network has a total current of
I ¼ VR
R
using Ohm’s law, where VR is the reference voltage, chosen to be 5 volts for our example.
Hence, half of the total current ﬂows into the b1 branch, while the other half ﬂows into the rest of the
network. The halving process repeats for each branch successively to the lower bit branches to get lower
bit weights. The second operational ampliﬁer acts like a phase shifter to cancel the negative sign of the
adder output. Using the basic electric circuit principle, we can determine the DAC output voltage as
V0 ¼ VR
 1
21 b1 þ 1
22 b0

where b1 and b0 are bits in the 2-bit binary code, with b0 as the least signiﬁcant bit (LSB).
In Figure 2.28, where we set VR ¼ 5 and b1b0 ¼ 10, the ADC output is expected to be
V0 ¼ 5 
 1
21  1 þ 1
22  0

¼ 2:5 volts
As we can see, the recovered voltage of V0 ¼ 2:5 volts introduces voltage error as compared with
Vin ¼ 3 volts, discussed in the ADC stage. This is due to the fact that in the ﬂash ADC unit, we use
only four (i.e., ﬁnite) voltage levels to represent continuous (inﬁnitely possible) analog voltage values.
This is called quantization error, obtained by subtracting the original analog voltage from the
recovered analog voltage. For our example, the quantization error is
V0  Vin ¼ 2:5  3 ¼ 0:5 volts
Next, we focus on quantization development. The process of converting analog voltage with inﬁnite
precision to ﬁnite precision is called the quantization process. For example, if the digital processor has
only a 3-bit word, the amplitudes can be converted into eight different levels.
+−
R
2R
2R
2R
R
VR = 5
I
V
R
R
=
I / 2
0
0
1
1
V0
I / 4
I / 4
R
+−
R
R
Phase shfter
V
V
b
b
R
0
1
1
2
0
1
2
1
2
=
+
b0
0
=
b1
1
=
Adder
FIGURE 2.28
R-2R ladder DAC.
2.3 Analog Conversion and Quantization
37

A unipolar quantizer deals with analog signals ranging from 0 volt to a positive reference voltage,
and a bipolar quantizer deals with analog signals ranging from a negative reference to a positive
reference. The notations and general rules for quantization are as follows:
D ¼ ðxmax  xminÞ
L
(2.19)
L ¼ 2m
(2.20)
i ¼ round
x  xmin
D

(2.21)
xq ¼ xmin þ iD
i ¼ 0; 1; /; L  1
(2.22)
where xmax and xmin are the maximum value and minimum values, respectively, of the analog input
signal x. The symbol L denotes the number of quantization levels, which is determined by Equation
(2.20), where m is the number of bits used in ADC. The symbol D is the step size of the quantizer or the
ADC resolution. Finally, xq indicates the quantization level, and i is an index corresponding to the
binary code.
Figure 2.29 depicts a 3-bit unipolar quantizer and corresponding binary codes. From Figure 2.29,
we see that xmin ¼ 0, xmax ¼ 8D, and m ¼ 3. Applying Equation (2.22) gives each quantization
level as follows: xq ¼ 0 þ iD, i ¼ 0; 1; /; L  1, where L ¼ 23 ¼ 8 and i is the integer corre-
sponding to the 3-bit binary code. Table 2.1 details quantization for each input signal subrange.
Similarly, a 3-bit bipolar quantizer and binary codes are shown in Figure 2.30, where we have
xmin ¼ 4D, xmax ¼ 4D, and m ¼ 3. The corresponding quantization table is given in Table 2.2.
001
011
101
110
111
010
000
eq
x
Δ / 2
−Δ / 2
x
100
0
Δ
2Δ
3Δ
4Δ
5Δ
6Δ
7Δ
8Δ
Δ
7Δ
6Δ
5Δ
4Δ
3Δ
2Δ
xq
Binary code
FIGURE 2.29
Characteristics of the unipolar quantizer.
38
CHAPTER 2 Signal Sampling and Quantization

EXAMPLE 2.9
Assuming that a 3 bit ADC channel accepts analog input ranging from 0 to 5 volts, determine
a. the number of quantization levels;
b. the step size of the quantizer or resolution;
c. the quantization level when the analog voltage is 3.2 volts;
d. the binary code produced by the ADC.
Solution:
Since the range is from 0 to 5 volts and a 3 bit ADC is used, we have
xmin
0 volt; xmax
5 volts;
and
m
3 bits
Table 2.1 Quantization Table for the 3-Bit Unipolar Quantizer (step size ¼ D ¼ ðxmax
xminÞ=23, xmax ¼ maximum voltage, and xmin ¼ 0)
Binary Code
Quantization Level xq (V)
Input Signal Subrange (V)
0 0 0
0
0  x < 0:5D
0 0 1
D
0:5D  x < 1:5D
0 1 0
2D
1:5D  x < 2:5D
0 1 1
3D
2:5D  x < 3:5D
1 0 0
4D
3:5D  x < 4:5D
1 0 1
5D
4:5D  x < 5:5D
1 1 0
6D
5:5D  x < 6:5D
1 1 1
7D
6:5D  x < 7:5D
000
001
011
100
101
110
111
010
eq
Δ / 2
−Δ / 2
x
x
xq
Δ
3Δ
2Δ
0
Δ
2Δ
3Δ
4Δ
−Δ
−2Δ
−3Δ
−4Δ
−Δ
−2Δ
−3Δ
−4Δ
Binary code
FIGURE 2.30
Characteristics for the bipolar quantizer.
2.3 Analog Conversion and Quantization
39

a. Using Equation (2.20), we get the number of quantization levels as
L
2m
23
8
b. Applying Equation (2.19) yields
D
5
0
8
0:625 volt
c. When x
3:2
D
0:625
5:12D, from Equation (2.21) we get
i
round
x
xmin
D

roundð5:12Þ
5
From Equation (2.22), we determine the quantization level as
xq
0 þ 5D
5  0:625
3:125 volts
d. The binary code is determined as 101, either from Figure 2.29 or Table 2.1.
After quantizing the input signal x, the ADC produces binary codes, as illustrated in Figure 2.31.
The DAC process is shown in Figure 2.32. As shown in the ﬁgure, the DAC unit takes the binary
codes from the DS processor. Then it converts the binary code using the zero-order hold circuit to
reproduce the sample-and-hold signal. Assuming that the spectrum distortion due to sample-and-hold
effect can be ignored for our illustration, the recovered sample-and-hold signal is further processed
using the anti-image ﬁlter. Finally, the analog signal is produced.
When the DAC outputs the analog amplitude xq with ﬁnite precision, it introduces quantization
error deﬁned as
eq ¼ xq  x
(2.23)
Table 2.2 Quantization Table for the 3-Bit Bipolar Quantizer (step size ¼ D ¼ ðxmax xminÞ=23,
xmax ¼ maximum voltage, and xmin ¼ xmax)
Binary Code
Quantization Level xq (V)
Input Signal Subrange (V)
0 0 0
4D
4D  x <
3:5D
0 0 1
3D
3:5D  x <
2:5D
0 1 0
2D
2:5D  x <
1:5D
0 1 1
D
1:5  x <
0:5D
1 0 0
0
0:5D  x < 0:5D
1 0 1
D
0:5D  x < 1:5D
1 1 0
2D
1:5D  x < 2:5D
1 1 1
3D
2:5D  x < 3:5D
40
CHAPTER 2 Signal Sampling and Quantization

The quantization error as shown in Figure 2.29 is bounded by half of the step size, that is,
 D
2  eq  D
2
(2.24)
where D is the quantization step size, or the ADC resolution. We also refer to D as Vmin (minimum
detectable voltage) or the LSB value of the ADC.
x t( )
00001101
00001001
01001011
11010010
Binary code
Anti
aliasing
filter
Sample
and hold
ADC conversion
 Quantization
and coding
...
FIGURE 2.31
Typical ADC process.
00001101
00001001
01001011
11010010
DAC conversion
Anti
image
filter
Analog signal
Digital signal
Zero order
hold
Quantization
and coding
Binary code
...
FIGURE 2.32
Typical DAC process.
2.3 Analog Conversion and Quantization
41

EXAMPLE 2.10
Using Example 2.9, determine the quantization error when the analog input is 3.2 volts.
Solution:
Using Equation (2.23), we obtain
eq
xq
x
3:125
3:2
0:075 volt
Note that the quantization error is less than the half of the step size, that is,
eq

0:075 < D=2
0:3125 volt
In practice, we can empirically conﬁrm that the quantization error appears in uniform distribution
when the step size is much smaller than the dynamic range of the signal samples and we have
a sufﬁciently large number of samples. Based on the theory of probability and random variables, the
power of quantization noise is related to the quantization step and given by
Eðe2
qÞ ¼ D2
12
(2.25)
where EðÞ is the expectation operator, which actually averages the squared values of the quantization
error (the reader can get more information from the texts by Roddy and Coolen (1997); Tomasi (2004);
and Stearns and Hush (1990)). The ratio of signal power to quantization noise power (SNR) can be
expressed as
SNR ¼ Eðx2Þ
Eðe2qÞ
(2.26)
If we express the SNR in terms of decibels (dB), we have
SNRdB ¼ 10$log10ðSNRÞ dB
(2.27)
Substituting Equation (2.25) and Eðx2Þ ¼ x2rms into Equation (2.27), we achieve
SNRdB ¼ 10:79 þ 20$log10
xrms
D

(2.28)
where xrms is the RMS (root mean squared) value of the signal to be quantized x.
Practically, the SNR can be calculated using the following formula:
SNR ¼
1
N
XN
1
n¼0 x2ðnÞ
1
N
XN
1
n¼0 e2
qðnÞ
¼
PN
1
n ¼ 0 x2ðnÞ
PN
1
n ¼ 0 e2qðnÞ
(2.29)
where xðnÞ is the nth sample amplitude and eqðnÞ the quantization error from quantizing xðnÞ.
42
CHAPTER 2 Signal Sampling and Quantization

EXAMPLE 2.11
If the analog signal to be quantized is a sinusoidal waveform, that is,
xðtÞ
Asinð2p  1; 000tÞ
and if the bipolar quantizer uses m bits, determine the SNR in terms of m bits.
Solution:
Since xrms
0:707A and D
2A=2m, substituting xrms and D into Equation (2.28) leads to
SNRdB
10:79 þ 20$log10
0:707A
2A=2m

10:79 þ 20$log10 ð0:707=2Þ þ 20m$log102
After simplifying the numerical values, we get
SNRdB
1:76 þ 6:02m dB
(2.30)
EXAMPLE 2.12
For a speech signal, if a ratio of the RMS value over the absolute maximum value of the analog signal (Roddy and
Coolen, 1997) is given, that is,
 xrms
jxjmax

, and the ADC quantizer uses m bits, determine the SNR in terms of m
bits.
Solution:
Since
D
xmax
xmin
L
2jxjmax
2m
substituting D in Equation (2.28) achieves
SNRdB
10:79 þ 20$log10

xrms
2jxjmax=2m

10:79 þ 20$log10
 xrms
jxjmax

þ 20mlog102
20log102
Thus, after numerical simpliﬁcation, we have
SNRdB
4:77 þ 20$log10
 xrms
jxjmax

þ 6:02m
(2.31)
From Examples 2.11 and 2.12, we observed that increasing 1 bit of the ADC quantizer can improve
SNR due to quantization by 6 dB.
2.3 Analog Conversion and Quantization
43

EXAMPLE 2.13
Given a sinusoidal waveform with a frequency of 100 Hz,
xðtÞ
4:5$sinð2p  100tÞ
sampled at 8,000 Hz,
a. write a MATLAB program to quantize xðtÞ using 4 bits to obtain and plot the quantized signal xq, assuming the
signal range is between
5 and 5 volts;
b. calculate the SNR due to quantization.
Solution:
a. Program 2.1. MATLAB program for Example 2.13.
%Example 2.13
clear all; close all
disp(’Generate 0.02 second sine wave of 100 Hz and Vp 5’);
fs 8000;
% Sampling rate
T 1/fs;
% Sampling interval
t 0:T:0.02;
% Duration of 0.02 second
sig
4.5*sin(2*pi*100*t);
% Generate sinusoids
bits
input(’input number of bits
>’);
lg
length(sig);
% Length of signal vector sig
for x 1:lg
[Index(x) pq]
biquant(bits,
5,5, sig(x));
% Output quantized index
0
0.002
0.004
0.006
0.008
0.01
0.012
0.014
0.016
0.018
0.02
-5
-4
-3
-2
-1
0
1
2
3
4
5
Time (sec.)
Quantized x(n)
FIGURE 2.33
Comparison of the quantized signal and the original signal.
44
CHAPTER 2 Signal Sampling and Quantization

end
% transmitted
% received
for x 1:lg
qsig(x)
biqtdec(bits,
5,5, Index(x));
% Recover the quantized value
end
qerr
qsig sig;
% Calculate quantized error
stairs(t,qsig); hold
% Plot signal in staircase style
plot(t,sig); grid;
% Plot signal
xlabel(’Time (sec.)’); ylabel(’Quantized x(n)’)
disp(’Signal to noise ratio due to quantization noise’)
snr(sig,qsig);
b. Theoretically, applying Equation (2.30) gives
SNRdB
1:76 þ 6:02$4
25:84 dB
Practically, using Equation (2.29), the simulated result is obtained as
SNRdB
25:78 dB
It is clear from this example that the ratios of signal power to noise power due to quantization achieved
from theory and from simulation are very close. Next, we look at an example for quantizing a speech
signal.
EXAMPLE 2.14
Given the speech signal sampled at 8,000 Hz in the ﬁle we.dat,
a. write a MATLAB program to quantize xðtÞ using 4 bit quantizers to obtain the quantized signal xq, assuming
the signal range is from 5 to 5 volts;
b. plot the original speech, quantized speech, and quantization error, respectively;
c. calculate the SNR due to quantization using the MATLAB program.
Solution:
a. Program 2.2 MATLAB program for Example 2.14.
%Example 2.14
clear all; close all
disp(’load speech: We’);
load we.dat
% Load speech data at the current folder
sig
we;
% Provided by the instructor
fs 8000;
% Sampling rate
lg length(sig);
% Length of signal vector
T 1/fs;
% Sampling period
t [0:1:lg 1]*T;
% Time instants in seconds
sig 4.5*sig/max(abs(sig)); % Normalizes speech in the range from
4.5 to 4.5
Xmax
max(abs(sig));
% Maximum amplitude
Xrms
sqrt( sum(sig .*
sig) / length(sig))
% RMS value
disp(’Xrms/Xmax’)
k Xrms/Xmax
2.3 Analog Conversion and Quantization
45

disp(’20*log10(k) >’);
k
20*log10(k)
bits
input(’input number of bits
>’);
lg
length(sig);
for x 1:lg
[Index(x) pq]
biquant(bits,
5,5, sig(x)); % Output quantized index
end
% transmitted
% received
for x 1:lg
qsig(x)
biqtdec(bits,
5,5, Index(x));
% Recover the quantized value
end
qerr
sig qsig;
% Calculate the quantized error
subplot(3,1,1);plot(t,sig);
ylabel(’Original speech’);title(’we.dat: we’);
subplot(3,1,2);stairs(t, qsig);grid
ylabel(’Quantized speech’)
subplot(3,1,3);stairs(t, qerr);grid
ylabel(’Quantized error’)
xlabel(’Time (sec.)’);axis([0 0.25
1 1]);
disp(’signal to noise ratio due to quantization noise’)
snr(sig,qsig);
% Signal to ratio in dB:
sig
original signal vector,
% qsig
quantized signal vector
0
0.05
0.1
0.15
0.2
0.25
5
0
5
Or g na  speech
we.dat: we
0
0.05
0.1
0.15
0.2
0.25
5
0
5
Quant zed speech
0
0.05
0.1
0.15
0.2
0.25
1
0
1
Quant zed error
Time (sec.)
FIGURE 2.34
Original speech, quantized speech using the 4-bit bipolar quantizer, and quantization error.
46
CHAPTER 2 Signal Sampling and Quantization

b. In Figure 2.34, the top plot shows the speech wave to be quantized, while the middle plot displays the quantized
speech signal using 4 bits. The bottom plot shows the quantization error. It also shows that the absolute value of
quantization error is uniformly distributed in a range between
0.3125 and 0.3125.
c. From the MATLAB program, we have xrms
jxjmax
0:203. Theoretically, from Equation (2.31), it follows that
SNRdB
4:77 þ 20log10
 xrms
jxjmax

þ 6:02$4
4:77 þ 20log10ð0:203Þ þ 6:02$4
15dB
On the other hand, the simulated result using Equation (2.29) gives
SNRdB
15:01 dB
Results for SNRs from Equations (2.31) and (2.29) are very close in this example.
2.4 SUMMARY
1. Analog signal is sampled at a ﬁxed time interval so the ADC will convert the sampled voltage level
to the digital value; this is called the sampling process.
2. Theﬁxedtimeintervalbetweentwosamplesisthesamplingperiod,andthereciprocalofthesampling
period is the sampling rate. Half of the sampling rate is the folding frequency (Nyquist limit).
3. The sampling theorem condition that the sampling rate must be larger than twice the highest
frequency of the sampled analog signal must be met in order for the analog signal to be
recovered.
4. The sampled spectrum is explained using the following well-known formula:
XsðfÞ ¼ / þ 1
T Xðf þ fsÞ þ 1
T XðfÞ þ 1
T Xðf  fsÞ þ /
That is, the sampled signal spectrum is a scaled and shifted version of its analog signal spectrum
and its replicas centered at the frequencies that are multiples of the sampling rate.
5. The analog anti-aliasing lowpass ﬁlter is used before ADC to remove frequency components higher
than the folding frequency to avoid aliasing.
6. The reconstruction (analog lowpass) ﬁlter is adopted after DAC to remove the spectral images that
exist in the sample-and-hold signal and obtain the smoothed analog signal. The sample-and-hold
DAC effect may distort the baseband spectrum, but it also reduces image spectrum.
7. Quantization occurs when the ADC unit converts the analog signal amplitude with inﬁnite
precision to digital data with ﬁnite precision (a ﬁnite number of codes).
8. When the DAC unit converts a digital code to a voltage level, quantization error occurs. The
quantization error is bounded by half of the quantization step size (ADC resolution), which is
a ratio of the full range of the signal over the number of quantization levels (number of codes).
9. The performance of the quantizer in terms of the signal to quantization noise ratio (SNR), in dB, is
related to the number of bits in ADC. Increasing each ADC code by 1 bit will improve SNR by 6 dB
due to quantization.
2.4 Summary
47

2.5 MATLAB PROGRAMS
Program 2.3. MATLAB function for uniform quantization encoding.
function [ I, pq]
biquant(NoBits,Xmin,Xmax,value)
% function pq
biquant(NoBits, Xmin, Xmax, value)
% This routine is created for simulation of the uniform quantizer.
%
% NoBits: number of bits used in quantization
% Xmax: overload value
% Xmin: minimum value
% value: input to be quantized
% pq: output of quantized value
% I: coded integer index
L 2^NoBits;
delta (Xmax Xmin)/L;
I round((value Xmin)/delta);
if ( I
L)
I I 1;
end
if I<0
I 0;
end
pq XminþI*delta;
Program 2.4. MATLAB function for uniform quantization decoding.
function pq
biqtdec(NoBits,Xmin,Xmax,I)
% function pq
biqtdec(NoBits,Xmin, Xmax, I)
% This routine recovers the quantized value.
%
% NoBits: number of bits used in quantization
% Xmax: overload value
% Xmin: minimum value
% pq: output of quantized value
% I: coded integer index
L 2^NoBits;
delta (Xmax Xmin)/L;
pq XminþI*delta;
Program 2.5. MATLAB function for calculation of signal to quantization noise ratio.
function snr
calcsnr(speech, qspeech)
% function snr
calcsnr(speech, qspeech)
% This routine was created to calculate SNR.
%
% speech: original speech waveform
% qspeech: quantized speech
% snr: output SNR in dB
%
qerr
speech qspeech;
snr
10*log10(sum(speech.*speech)/sum(qerr.*qerr))
48
CHAPTER 2 Signal Sampling and Quantization

2.6 PROBLEMS
2.1. Given an analog signal
xðtÞ ¼ 5cosð2p$1; 500tÞ; for t  0
sampled at a rate of 8,000 Hz,
a. sketch the spectrum of the original signal;
b. sketch the spectrum of the sampled signal from 0 kHz up to 20 kHz.
2.2. Given an analog signal
xðtÞ ¼ 5cosð2p$2; 500tÞ þ 2cosð2p$3; 200tÞ; for t  0
sampled at a rate of 8,000 Hz,
a. sketch the spectrum of the sampled signal up to 20 kHz;
b. sketch the recovered analog signal spectrum if an ideal lowpass ﬁlter with a cutoff
frequency of 4 kHz is used to ﬁlter the sampled signal in order to recover the original signal.
2.3. Given an analog signal
xðtÞ ¼ 3cosð2p$1; 500tÞ þ 2cosð2p$2; 200tÞ; for t  0
sampled at a rate of 8,000 Hz,
a. sketch the spectrum of the sampled signal up to 20 kHz;
b. sketch the recovered analog signal spectrum if an ideal lowpass ﬁlter with a cutoff
frequency of 4 kHz is used to ﬁlter the sampled signal in order to recover the original signal.
2.4. Given an analog signal
xðtÞ ¼ 3cosð2p$1; 500tÞ þ 2cosð2p$4; 200tÞ; for t  0
sampled at a rate of 8,000 Hz,
a. sketch the spectrum of the sampled signal up to 20 kHz;
b. sketch the recovered analog signal spectrum if an ideal lowpass ﬁlter with a cutoff
frequency of 4 kHz is used to ﬁlter the sampled signal in order to recover the original signal.
2.5. Given an analog signal
xðtÞ ¼ 5cosð2p$2; 500tÞ þ 2cosð2p$4; 500tÞ; for t  0
sampled at a rate of 8,000 Hz,
a. sketch the spectrum of the sampled signal up to 20 kHz;
b. sketch the recovered analog signal spectrum if an ideal lowpass ﬁlter with a cutoff
frequency of 4 kHz is used to ﬁlter the sampled signal in order to recover the original signal;
c. determine the frequency/frequencies of aliasing noise.
2.5 MATLAB Programs
49

2.6. Assuming a continuous signal is given as
xðtÞ ¼ 10cosð2p$5; 500tÞ þ 5sinð2p$7; 500tÞ; for t  0
sampled at a rate of 8,000 Hz,
a. sketch the spectrum of the sampled signal up to 20 kHz;
b. sketch the recovered analog signal spectrum if an ideal lowpass ﬁlter with a cutoff
frequency of 4 kHz is used to ﬁlter the sampled signal in order to recover the original signal;
c. determine the frequency/frequencies of aliasing noise.
2.7. Assuming a continuous signal is given as
xðtÞ ¼ 8cosð2p$5; 000tÞ þ 5sinð2p$7; 000tÞ; for t  0
sampled at a rate of 8,000 Hz,
a. sketch the spectrum of the sampled signal up to 20 kHz;
b. sketch the recovered analog signal spectrum if an ideal lowpass ﬁlter with a cutoff
frequency of 4 kHz is used to ﬁlter the sampled signal in order to recover the original signal;
c. determine the frequency/frequencies of aliasing noise.
2.8. Assuming a continuous signal is given as
xðtÞ ¼ 10cosð2p$5; 000tÞ þ 5sinð2p$7; 500tÞ; for t  0
sampled at a rate of 8,000 Hz,
a. sketch the spectrum of the sampled signal up to 20 kHz;
b. sketch the recovered analog signal spectrum if an ideal lowpass ﬁlter with a cutoff
frequency of 4 kHz is used to ﬁlter the sampled signal in order to recover the original signal;
c. determine the frequency/frequencies of aliasing noise.
2.9. Given a Butterworth type second-order anti-aliasing lowpass ﬁlter (Figure 2.35), determine
the values of circuit elements if we want the ﬁlter to have a cutoff frequency of 1,000 Hz.
−
+
Vin
Vo
R1
C2
R2
C1
R
R
C
 fc)
1
2
2
14142
(2
=
=
.
π
C
R R C
 fc)
1
1
2
2
2
1
(2
=
C2
Choose
π
FIGURE 2.35
Filter circuit in Problem 2.9.
50
CHAPTER 2 Signal Sampling and Quantization

2.10. From Problem 2.9, determine the percentage of aliasing level at the frequency of 500 Hz,
assuming that the sampling rate is 4,000 Hz.
2.11. Given a Butterworth type second-order anti-aliasing lowpass ﬁlter (Figure 2.36), determine
the values of circuit elements if we want the ﬁlter to have a cutoff frequency of 800 Hz.
2.12. From Problem 2.11, determine the percentage of aliasing level at the frequency of 400 Hz,
assuming that the sampling rate is 4,000 Hz.
2.13. Given a DSP system in which a sampling rate of 8,000 Hz is used and the anti-aliasing
ﬁlter is a second-order Butterworth lowpass ﬁlter with a cutoff frequency of 3.2 kHz,
determine
a. the percentage of aliasing level at the cutoff frequency;
b. the percentage of aliasing level at the frequency of 1,000 Hz.
2.14. Given a DSP system in which a sampling rate of 8,000 Hz is used and the anti-aliasing ﬁlter
is a Butterworth lowpass ﬁlter with a cutoff frequency 3.2 kHz, determine the order of the
Butterworth lowpass ﬁlter required to make the percentage of aliasing level at the cutoff
frequency less than 10%.
2.15. Given a DSP system in which a sampling rate of 8,000 Hz is used and the anti-aliasing ﬁlter
is a second-order Butterworth lowpass ﬁlter with a cutoff frequency of 3.1 kHz, determine
a. the percentage of aliasing level at the cutoff frequency;
b. the percentage of aliasing level at a frequency of 900 Hz.
2.16. Given a DSP system in which a sampling rate of 8,000 Hz is used and the anti-aliasing ﬁlter
is a Butterworth lowpass ﬁlter with a cutoff frequency 3.1 kHz, determine the order of the
Butterworth lowpass ﬁlter required to make the percentage of aliasing level at the cutoff
frequency less than 10%.
−
+
Vin
Vo
R1
C2
R2
C1
R
R
C
  fc)
1
2
2
14142
(2
=
=
.
π
C
R R C
  fc )
1
1
2
2
2
1
(2
=
π
C2
Choose
FIGURE 2.36
Filter circuit in Problem 2.11.
2.5 MATLAB Programs
51

2.17. Given a DSP system with a sampling rate of 8,000 Hz and assuming that the hold circuit is
used after DAC, determine
a. the percentage of distortion at a frequency of 3,200 Hz;
b. the percentage of distortion at a frequency of 1,500 Hz.
2.18. A DSP system (Figure 2.37) is given with the following speciﬁcations:
Design requirements:
• Sampling rate 20,000 Hz
• Maximum allowable gain variation from 0 to 4,000 Hz ¼ 2 dB
• 40 dB rejection at a frequency of 16,000 Hz
• Butterworth ﬁlter.
Determine the cutoff frequency and order for the anti-image ﬁlter.
2.19. Given a DSP system with a sampling rate of 8,000 Hz and assuming that the hold circuit is
used after DAC, determine
a. the percentage of distortion at a frequency of 3,000 Hz;
b. the percentage of distortion at a frequency of 1,600 Hz.
2.20. A DSP system (Figure 2.38) is given with the following speciﬁcations:
Design requirements:
•
Sampling rate 22,000 Hz
•
Maximum allowable gain variation from 0 to 4,000 Hz ¼ 2 dB
DAC
Digital signal
y n
( )
Anti
image
filter
y t
s ( )
y t( )
Hold
y
 t
H ( )
FIGURE 2.37
Analog signal reconstruction in Problem 2.18.
DAC
Digital signal
y n( )
Anti
image
filter
y t
s( )
y t( )
Hold
y
t
H ( )
FIGURE 2.38
Analog signal reconstruction in Problem 2.20.
52
CHAPTER 2 Signal Sampling and Quantization

• 40 dB rejection at the frequency of 18,000 Hz
• Butterworth ﬁlter.
Determine the cutoff frequency and order for the anti-image ﬁlter.
2.21. Given the 2-bit ﬂash ADC unit with an analog sample-and-hold voltage of 2 volts shown in
Figure 2.39, determine the output bits.
2.22. Given the R-2R DAC unit with a 2-bit value deﬁned as b1b0 ¼ 01 shown in Figure 2.40,
determine the converted voltage.
+
−
+
−
+
−
R
R
R
R
VR = 5
V
volts
in = 2
00
01
10
11
Encoding
logic
VR
4
125
= .
VR
2
2 5
= .
3
4
375
VR = .
Comparators
b1b0
FIGURE 2.39
2-bit ﬂash ADC in Problem 2.21.
+−
R
2R
2R
2R
R
VR = 5
I
V
R
R
=
I / 2
0
0
1
1
V0
I / 4
I / 4
R
+−
R
R
Phase shfter
V
V
b
b
R
0
1
1
2
0
1
2
1
2
=
+
b0
1
=
b1
0
=
Adder
FIGURE 2.40
2-bit R-2R DAC in Problem 2.22.
2.5 MATLAB Programs
53

2.23. Given the 2-bit ﬂash ADC unit with an analog sample-and-hold voltage of 3.5 volts shown in
Figure 2.39, determine the output bits.
2.24. Given the R-2R DAC unit with 2-bit values deﬁned as b1b0 ¼ 11 and b1b0 ¼ 10 and shown in
Figure 2.40, determine the converted voltages.
2.25. Assuming that a 4-bit ADC channel accepts analog input ranging from 0 to 5 volts, determine
the following:
a. number of quantization levels;
b. step size of the quantizer or resolution;
c. quantization level when the analog voltage is 3.2 volts;
d. binary code produced by the ADC;
e. quantization error.
2.26. Assuming that a 5-bit ADC channel accepts analog input ranging from 0 to 4 volts, determine
the following:
a. number of quantization levels;
b. step size of the quantizer or resolution;
c. quantization level when the analog voltage is 1.2 volts;
d. binary code produced by the ADC;
e. quantization error.
2.27. Assuming that a 3-bit ADC channel accepts analog input ranging from 2.5 to 2.5 volts,
determine the following:
a. number of quantization levels;
b. step size of the quantizer or resolution;
c. quantization level when the analog voltage is 1.2 volts;
d. binary code produced by the ADC;
e. quantization error.
2.28. Assuming that a 8-bit ADC channel accepts analog input ranging from 2.5 to 2.5 volts,
determine the following:
a. number of quantization levels;
b. step size of the quantizer or resolution;
c. quantization level when the analog voltage is 1.5 volts;
d. binary code produced by the ADC;
e. quantization error.
2.29. If the analog signal to be quantized is a sinusoidal waveform, that is,
xðtÞ ¼ 9:5sinð2; 000  ptÞ
54
CHAPTER 2 Signal Sampling and Quantization

and if the bipolar quantizer uses 6 bits, determine
a. the number of quantization levels;
b. the quantization step size or resolution, D, assuming the signal range is from 10 to
10 volts;
c. the signal power to quantization noise power ratio.
2.30. For a speech signal, if the ratio of the RMS value over the absolute maximum value of the
signal is given, that is,
 xrms
jxjmax

¼ 0:25, and the ADC bipolar quantizer uses 6 bits,
determine
a. the number of quantization levels;
b. the quantization step size or resolution, D, if the signal range is 5 volts;
c. the signal power to quantization noise power ratio.
2.6.1 Computer Problems with MATLAB
Use the MATLAB programs in Section 2.5 to solve the following problems.
2.31. Given a sinusoidal waveform of 100 Hz,
xðtÞ ¼ 4:5sinð2p  100tÞ
sample it at 8,000 samples per second and
a. write a MATLAB program to quantize xðtÞ using a 6-bit bipolar quantizer to obtain the
quantized signal xq, assuming that the signal range is from 5 to 5 volts;
b. plot the original signal and quantized signal;
c. calculate the SNR due to quantization using the MATLAB program.
2.32. Given a signal waveform,
xðtÞ ¼ 3:25sinð2p  50tÞ þ 1:25cosð2p  100t þ p=4Þ
sample it at 8,000 samples per second and
a. write a MATLAB program to quantize xðtÞ using a 6-bit bipolar quantizer to obtain the
quantized signal xq, assuming that the signal range is from 5 to 5 volts;
b. plot the original signal and quantized signal;
c. calculate the SNR due to quantization using the MATLAB program.
2.33. Given a speech signal sampled at 8,000 Hz, as shown in Example 2.14,
a. write a MATLAB program to quantize xðtÞ using a 6-bit bipolar quantizer to obtain the
quantized signal xq, assuming that the signal range is from 5 to 5 volts;
b. plot the original speech waveform, quantized speech, and quantization error;
c. calculate the SNR due to quantization using the MATLAB program.
2.5 MATLAB Programs
55

2.6.2 MATLAB Projects
2.34. Performance evaluation of speech quantization:
Given an original speech segment “speech.dat” sampled at 8,000 Hz with each sample encoded
in 16 bits, use Programs 2.3 to 2.5 and modify Program 2.2 to quantize the speech segment using
3 to 15 bits, respectively. The SNR in dB must be measured for each quantization. The MATLAB
function: “sound(x/max(abs(x)),fs)” can be used to evaluate sound quality, where “x” is the
speech segment while “fs” is the sampling rate of 8,000 Hz. In this project, create a plot of the
measured SNR (dB) versus the number of bits and discuss the effect on the sound quality. For
comparisons, plot the original speech and the quantized one using 3 bits, 8 bits, and 15 bits.
2.35. Performance evaluation of seismic data quantization:
The seismic signal, a measurement of the acceleration of ground motion, is required for
applications in the study of geophysics. The seismic signal (“seismic.dat” provided by the US
Geological Survey, Albuquerque Seismological Laboratory) has a sampling rate of 15 Hz with
6,700 data samples, and each sample is encoded using 32 bits. Quantizing each 32-bit sample
down to the lower number of bits per sample can reduce the memory storage requirement with
the trade-off of reduced signal quality. Use Programs 2.3 to 2.5 and modify Program 2.2 to
quantize the seismic data using 13, 15, 17, ., 31 bits. The SNR in dB must be measured for each
quantization. Create a plot of the measured SNR (dB) versus the number of bits. For comparison,
plot the seismic data and the quantized one using 13 bits, 18 bits, 25 bits, and 31 bits.
56
CHAPTER 2 Signal Sampling and Quantization

Digital Signals and Systems
3
CHAPTER OUTLINE
3.1 Digital Signals ............................................................................................................................... 57
3.1.1 Common Digital Sequences..........................................................................................58
3.1.2 Generation of Digital Signals ........................................................................................61
3.2 Linear Time-Invariant, Causal Systems............................................................................................. 63
3.2.1 Linearity.....................................................................................................................63
3.2.2 Time Invariance ..........................................................................................................65
3.2.3 Causality ....................................................................................................................66
3.3 Difference Equations and Impulse Responses................................................................................... 67
3.3.1 Format of the Difference Equation ................................................................................67
3.3.2 System Representation Using Its Impulse Response.......................................................68
3.4 Bounded-In and Bounded-Out Stability............................................................................................. 71
3.5 Digital Convolution......................................................................................................................... 72
3.6 Summary ....................................................................................................................................... 79
OBJECTIVES:
This chapter introduces notations for digital signals and special digital sequences that are widely used in
this book. The chapter continues to study some properties of linear systems such as time invariance, BIBO
(bounded-in and bounded-out) stability, causality, impulse response, difference equations, and digital
convolution.
3.1 DIGITAL SIGNALS
In our daily lives, analog signals appear in forms such as speech, audio, seismic, biomedical, and
communications signals. To process an analog signal using a digital signal processor, the analog signal
must be converted in to a digital signal, that is, analog-to-digital conversion (ADC) must take place, as
discussed in Chapter 2. Then the digital signal is processed via digital signal processing (DSP)
algorithm(s).
A typical digital signal xðnÞ is shown in Figure 3.1, where both the time and the amplitude of the
digital signal are discrete. Notice that the amplitudes of the digital signal samples are given and
sketched only at their corresponding time indices, where xðnÞ represents the amplitude of the nth
sample and n is the time index or sample number. From Figure 3.1, we learn that
xð0Þ: zeroth sample amplitude at sample number n ¼ 0,
xð1Þ: ﬁrst sample amplitude at sample number n ¼ 1,
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00003-2
Copyright  2013 Elsevier Inc. All rights reserved.
57

xð2Þ: second sample amplitude at sample number n ¼ 2,
xð3Þ: third sample amplitude at sample number n ¼ 3, and so on.
Furthermore, Figure 3.2 illustrates the digital samples whose amplitudes are the discrete encoded
values represented in the digital signal (DS) processor. Precision of the data is based on the number of
bits used in the DSP system. The encoded data format can be either an integer if a ﬁxed-point DS
processor is used or a ﬂoating-point number if a ﬂoating-point DP processor is used. As shown in
Figure 3.2 for the ﬂoating-point DS processor, we can identify the ﬁrst ﬁve sample amplitudes at their
time indices as follows:
xð0Þ ¼ 2:25
xð1Þ ¼ 2:0
xð2Þ ¼ 1:0
xð3Þ ¼ 1:0
xð4Þ ¼ 0:0
..
Again, note that each sample amplitude is plotted using a vertical bar with a solid dot. This notation is
well accepted in DSP literature.
3.1.1 Common Digital Sequences
Let us study some special digital sequences that are widely used. We deﬁne and plot each of them as
follows:
Unit-impulse sequence (digital unit-impulse function):
dðnÞ ¼
(
1
n ¼ 0
0
ns0
(3.1)
n
x(n)
0
1
2
3
4
x(0) x(1)
x(2)
x(3)
......
–1
–2
FIGURE 3.1
Digital signal notation.
n
x(n)
0
1
2
3
4
2.25 2.0
1.0
......
0.0
–1
–2
FIGURE 3.2
Plot of the digital signal samples.
58
CHAPTER 3 Digital Signals and Systems

The plot of the unit-impulse function is given in Figure 3.3. The unit-impulse function has unit
amplitude at only n ¼ 0 and zero amplitude at other time indices.
Unit-step sequence (digital unit-step function):
uðnÞ ¼
(
1
n  0
0
n < 0
(3.2)
The plot is given in Figure 3.4. The unit-step function has unit amplitude at n ¼ 0 and at all the
positive time indices, and zero amplitude at all negative time indices.
The shifted unit-impulse and unit-step sequences are displayed in Figure 3.5. As shown in the
ﬁgure, the shifted unit-impulse function dðn  2Þ is obtained by shifting the unit-impulse function dðnÞ
to the right by two samples, and the shifted unit-step function uðn  2Þ is achieved by shifting the unit-
step function uðnÞ to the right by two samples; similarly, dðn þ 2Þ and uðn þ 2Þ are acquired by
shifting dðnÞ and uðnÞ two samples to the left, respectively.
n
0
1
–1
–2
2
4
3
δ(n)
1
FIGURE 3.3
Unit-impulse sequence.
n
0
1
2
4
3
u n
( )
1
–1
–2
FIGURE 3.4
Unit-step sequence.
n
n
1
1
n
n
1
1
δ(n – 2)
u(n – 2)
u(n + 2)
δ(n + 2)
FIGURE 3.5
Shifted unit-impulse and unit-step sequences.
3.1 Digital Signals
59

Sinusoidal and exponential sequences are depicted in Figures 3.6 and 3.7, respectively. For the
sinusoidal sequence xðnÞ ¼ Acosð0:125pnÞuðnÞ, and A ¼ 10, we can calculate the digital values for
the ﬁrst eight samples and list their values in Table 3.1.
For the exponential sequence xðnÞ ¼ Að0:75ÞnuðnÞ, the calculated digital values for the ﬁrst eight
samples with A ¼ 10 are listed in Table 3.2.
n
x n
( )
A
FIGURE 3.6
Plot of samples of the sinusoidal function.
n
x(n)
FIGURE 3.7
Plot of samples of the exponential function.
Table 3.1 Sample Values Calculated from the
Sinusoidal Function
n
xðnÞ [ 10cosð0:125pnÞuðnÞ
0
10:0000
1
9:2388
2
7:0711
3
3:8628
4
0:0000
5
3:8628
6
7:0711
7
9:2388
60
CHAPTER 3 Digital Signals and Systems

EXAMPLE 3.1
Sketch the following sequence
xðnÞ
dðn þ 1Þ þ 0:5dðn
1Þ þ 2dðn
2Þ
Solution:
According to the shift operation, dðn þ 1Þ is obtained by shifting dðnÞ to the left by one sample, while dðn
1Þ and
dðn
2Þ are yielded by shifting dðnÞ to right by one sample and two samples, respectively. Using the amplitude of
each impulse function, we obtain the sketch in Figure 3.8.
3.1.2 Generation of Digital Signals
Given the sampling rate of a DSP system to sample the analytical function of an analog signal, the
corresponding digital function or digital sequence (assuming its sampled amplitudes are encoded to
have ﬁnite precision) can be found. The digital sequence is often used to
1. Calculate the encoded sample amplitude for a given sample number n.
2. Generate the sampled sequence for simulation.
Table 3.2 Sample Values Calculated from the
Exponential Function
n
10ð0:75ÞnuðnÞ
0
10:0000
1
7:5000
2
5:6250
3
4:2188
4
3:1641
5
2:3730
6
1:7798
7
1:3348
x(n)
0
1
2
3
1
2
3
1
2
n
2
1
05.
FIGURE 3.8
Plot of digital sequence in Example 3.1.
3.1 Digital Signals
61

The procedure to develop the digital sequence from its analog signal function is as follows. Assuming
that an analog signal xðtÞ is uniformly sampled at the time interval of Dt ¼ T, where T is the sampling
period, the corresponding digital function (sequence) xðnÞ gives the instant encoded values of
the analog signal xðtÞ at all the time instants t ¼ nDt ¼ nT and can be achieved by substituting time
t ¼ nT into the analog signal xðtÞ, that is,
xðnÞ ¼ xðtÞjt¼nT ¼ xðnTÞ
(3.3)
Also notice that for sampling the unit-step function uðtÞ, we have
uðtÞjt¼nT ¼ uðnTÞ ¼ uðnÞ
(3.4)
The following example will demonstrate the use of Equations (3.3) and (3.4).
EXAMPLE 3.2
Assume we have a DSP system with a sampling time interval of 125 microseconds.
a. Convert each of following analog signals xðtÞ to a digital signal xðnÞ :
1. xðtÞ
10e5;000tuðtÞ
2. xðtÞ
10 sinð2;000ptÞuðtÞ
b. Determine and plot the sample values from each obtained digital function.
Solution:
a. Since T
0:000125 seconds in Equation (3.3), substituting t
nT
n  0:000125
0:000125 n into
the analog signal xðtÞ expressed in (1) leads to the digital sequence
1:
xðnÞ
xðnTÞ
10e5;0000:000125nuðnTÞ
10e0:625nuðnÞ
Similarly, the digital sequence for (2) is achieved as follows:
2:
xðnÞ
xðnTÞ
10 sinð2;000p  0:000125nÞuðnTÞ
10 sinð0:25pnÞuðnÞ
b. The ﬁrst ﬁve sample values for (1) are calculated and plotted in Figure 3.9.
xð0Þ
10e0:6250uð0Þ
10:0
xð1Þ
10e0:6251uð1Þ
5:3526
0
1
2
3
4
5
n
5
10
x(n)
10
5.3526
2.86501.5335 0.8208
Sample index
t
Microseconds (μsec.)
0
125
250
375
500
625
125
T
t
nT
FIGURE 3.9
Plot of the digital sequence for (1) in Example 3.2.
62
CHAPTER 3 Digital Signals and Systems

xð2Þ
10e0:6252uð2Þ
2:8650
xð3Þ
10e0:6253uð3Þ
1:5335
xð4Þ
10e0:6254uð4Þ
0:8208
The ﬁrst eight amplitudes for (2) are computed and sketched in Figure 3.10.
xð0Þ
10 sinð0:25p  0Þuð0Þ
0
xð1Þ
10 sinð0:25p  1Þuð1Þ
7:0711
xð2Þ
10 sinð0:25p  2Þuð2Þ
10:0
xð3Þ
10 sinð0:25p  3Þuð3Þ
7:0711
xð4Þ
10 sinð0:25p  4Þuð4Þ
0:0
xð5Þ
10 sinð0:25p  5Þuð5Þ
7:0711
xð6Þ
10 sinð0:25p  6Þuð6Þ
10:0
xð7Þ
10 sinð0:25p  7Þuð7Þ
7:0711
3.2 LINEAR TIME-INVARIANT, CAUSAL SYSTEMS
In this section, we study linear time-invariant causal systems and focus on properties such as linearity,
time-invariance, and causality.
3.2.1 Linearity
A linear system is illustrated in Figure 3.11, where y1ðnÞ is the system output using an input x1ðnÞ, and
y2ðnÞ the system output with an input x2ðnÞ.
Figure 3.11 illustratesthat the system output dueto theweighted sum inputs ax1ðnÞ þ bx2ðnÞ is equal
to the same weighted sum of the individual outputs obtained from their corresponding inputs, that is,
yðnÞ ¼ ay1ðnÞ þ by2ðnÞ
(3.5)
where a and b are constants.
0
4
1
3
n
2
10
x(n)
5
6
7
5
10
0.0
0.0
7.0711
10.0
7.0711
7 0711
.
10 0.
7 0711
.
t
Microseconds (μsec.)
0
125
250
375
500
625
Sample index
750
875
125
T
t
nT
FIGURE 3.10
Plot of the digital sequence for (2) in Example 3.2.
3.2 Linear Time Invariant, Causal Systems
63

For example, assuming a digital ampliﬁer is represented by yðnÞ ¼ 10xðnÞ, the input is
multiplied by 10 to generate the output. The inputs x1ðnÞ ¼ uðnÞ and x2ðnÞ ¼ dðnÞ generate the
outputs
y1ðnÞ ¼ 10uðnÞ, and y2ðnÞ ¼ 10dðnÞ, respectively
If, as described in Figure 3.11, we apply the combined input xðnÞ to the system, where the ﬁrst input
multiplied by a constant 2 while the second input multiplied by a constant 4,
xðnÞ ¼ 2x1ðnÞ þ 4x2ðnÞ ¼ 2uðnÞ þ 4dðnÞ
then the system output due to the combined input is obtained as
yðnÞ ¼ 10xðnÞ ¼ 10ð2uðnÞ þ 4dðnÞÞ ¼ 20uðnÞ þ 40dðnÞ
(3.6)
If we verify the weighted sum of the individual outputs, we see that
2y1ðnÞ þ 4y2ðnÞ ¼ 20uðnÞ þ 40dðnÞ
(3.7)
Comparing Equations (3.6) and (3.7) veriﬁes that
yðnÞ ¼ 2y1ðnÞ þ 4y2ðnÞ
(3.8)
Hence, the system yðnÞ ¼ 10xðnÞ is a linear system. The linearity means that the system obeys the
superposition principle, as shown in Equation (3.8). Let us verify a system whose output is a square of
its input,
yðnÞ ¼ x2ðnÞ
Applying the inputs x1ðnÞ ¼ uðnÞ and x2ðnÞ ¼ dðnÞ to the system leads to
y1ðnÞ ¼ u2ðnÞ ¼ uðnÞ; and y2ðnÞ ¼ d2ðnÞ ¼ dðnÞ
It is very easy to verify that u2ðnÞ ¼ uðnÞ and d2ðnÞ ¼ dðnÞ.
System
x n
1( )
y n
1( )
System
x n
2( )
y n
2( )
System
x n
x n
1
2
( )
( )
y n
y n
1
2
( )
( )
FIGURE 3.11
Digital linear system.
64
CHAPTER 3 Digital Signals and Systems

We can determine the system output using a combined input, which is the weighed sum of the
individual inputs with constants 2 and 4, respectively. Using algebra, we see that
yðnÞ ¼ x2ðnÞ ¼ ð4x1ðnÞ þ 2x2ðnÞÞ2
¼ ð4uðnÞ þ 2dðnÞÞ2 ¼ 16u2ðnÞ þ 16uðnÞdðnÞ þ 4d2ðnÞ
¼ 16uðnÞ þ 20dðnÞ
(3.9)
Note that we use the fact that uðnÞdðnÞ ¼ dðnÞ, which can be easily veriﬁed.
Again, we express the weighted sum of the two individual outputs with the same constants 2
and 4 as
4y1ðnÞ þ 2y2ðnÞ ¼ 4uðnÞ þ 2dðnÞ
(3.10)
It is obvious that
yðnÞs4y1ðnÞ þ 2y2ðnÞ
(3.11)
Hence, the system is a nonlinear system, since the linear property, superposition, does not hold, as
shown in Equation (3.11).
3.2.2 Time Invariance
A time-invariant system is illustrated in Figure 3.12, where y1ðnÞ is the system output for the input
x1ðnÞ. Let x2ðnÞ ¼ x1ðn  n0Þ be the shifted version of x1ðnÞ by n0 samples. The output y2ðnÞ
obtained with the shifted input x2ðnÞ ¼ x1ðn  n0Þ is equivalent to the output y2ðnÞ acquired by
shifting y1ðnÞ by n0 samples, y2ðnÞ ¼ y1ðn  n0Þ.
This can simply be viewed as the following:
System
x (n)
1
1( )
y n
x n
x n
n
2
1
0
( )
(
)
y n
y n
n
2
1
0
( )
(
)
0n
0n
shifted by n samples
0
shifted by n samples
0
n
n
n
n
FIGURE 3.12
Illustration of the linear time-invariant digital system.
If the system is time invariant and y1ðnÞ is the system output due to the input x1ðnÞ, then the shifted system input
x1ðn
n0Þ will produce a shifted system output y1ðn
n0Þ by the same amount of time n0.
3.2 Linear Time Invariant, Causal Systems
65

EXAMPLE 3.3
Determine whether the linear systems
a. yðnÞ
2xðn
5Þ
b. yðnÞ
2xð3nÞ
are time invariant.
Solution:
a. Let the input and output be x1ðnÞ and y1ðnÞ, respectively; then the system output is y1ðnÞ
2x1ðn
5Þ. Again,
let x2ðnÞ
x1ðn
n0Þ be the shifted input and y2ðnÞ be the output due to the shifted input. We determine the
system output using the shifted input as
y2ðnÞ
2x2ðn
5Þ
2x1ðn
n0
5Þ
Meanwhile, shifting y1ðnÞ
2x1ðn
5Þ by n0 samples leads to
y1ðn
n0Þ
2x1ðn
5
n0Þ
We can verify that y2ðnÞ
y1ðn
n0Þ. Thus the shifted input of n0 samples causes the system output to be
shifted by the same n0 samples. The system is thus time invariant.
b. Let the input and output be x1ðnÞ and y1ðnÞ, respectively; then the system output is y1ðnÞ
2x1ð3nÞ. Again, let
the input and output be x2ðnÞ and y2ðnÞ, where x2ðnÞ
x1ðn
n0Þ, a shifted version, and the corresponding output
is y2ðnÞ. We get the output due to the shifted input x2ðnÞ
x1ðn
n0Þ and note that x2ð3nÞ
x1ð3n
n0Þ:
y2ðnÞ
2x2ð3nÞ
2x1ð3n
n0Þ
On the other hand, if we shift y1ðnÞ by n0 samples, and replace n in y1ðnÞ
2x1ð3nÞ by n
n0, we obtain
y1ðn
n0Þ
2x1ð3ðn
n0ÞÞ
2x1ð3n
3n0Þ
Clearly, we know that y2ðnÞsy1ðn
n0Þ. Since the system output y2ðnÞ using the input shifted by n0 samples is
not equal to the system output y1ðnÞ shifted by the same n0 samples, the system is not time invariant.
3.2.3 Causality
A causal system is the one in which the output yðnÞ at time n depends only on the current input xðnÞ at
time n, and its past input sample values such as xðn  1Þ, xðn  2Þ,.. Otherwise, if a system output
depends on future input values such as xðn þ 1Þ, xðn þ 2Þ, ., the system is noncausal. The noncausal
system cannot be realized in real time.
EXAMPLE 3.4
Determine whether the systems
a. yðnÞ
0:5xðnÞ þ 2:5xðn
2Þ, for n  0
b. yðnÞ
0:25xðn
1Þ þ 0:5xðn þ 1Þ
0:4yðn
1Þ, for n  0
are causal.
Solution:
a. Since for n  0, the output yðnÞ depends on the current input xðnÞ and its past value xðn
2Þ, the system is
causal.
b. Since for n  0, the output yðnÞ depends on the current input xðnÞ and its future value xðn þ 1Þ, the system is
noncausal.
66
CHAPTER 3 Digital Signals and Systems

3.3 DIFFERENCE EQUATIONS AND IMPULSE RESPONSES
Now we study the difference equation and its impulse response.
3.3.1 Format of the Difference Equation
A causal, linear, time-invariant system can be described by a difference equation having the following
general form:
yðnÞ þ a1yðn  1Þ þ / þ aNyðn  NÞ ¼ b0xðnÞ þ b1xðn  1Þ þ / þ bMxðn  MÞ
(3.12)
where a1,., aN, and b0, b1,., bM are the coefﬁcients of the difference equation. Equation (3.12) can
also be written as
yðnÞ ¼ a1yðn  1Þ  /  aNyðn  NÞ þ b0xðnÞ þ b1xðn  1Þ þ / þ bMxðn  MÞ
(3.13)
or
yðnÞ ¼ 
X
N
i ¼ 1
aiyðn  iÞ þ
X
M
j ¼ 0
bjxðn  jÞ
(3.14)
Notice that yðnÞ is the current output, which depends on the past output samples yðn  1Þ,., yðn  NÞ,
the current input sample xðnÞ, and the past input samples, xðn  1Þ,., xðn  NÞ.
We will examine the speciﬁc difference equations in the following examples.
EXAMPLE 3.5
Given the difference equation
yðnÞ
0:25yðn
1Þ þ xðnÞ
identify the nonzero system coefﬁcients.
Solution:
Comparison with Equation (3.13) leads to
b0
1
a1
0:25;
that is;
a1
0:25
EXAMPLE 3.6
Given a linear system described by the difference equation
yðnÞ
xðnÞ þ 0:5xðn
1Þ
determine the nonzero system coefﬁcients.
Solution:
By comparing Equation (3.13), we have
b0
1
and
b1
0:5
3.3 Difference Equations and Impulse Responses
67

3.3.2 System Representation Using Its Impulse Response
A linear time-invariant system can be completely described by its unit-impulse response, which is
deﬁned as the system response due to the impulse input dðnÞ with zero initial conditions, depicted in
Figure 3.13.
With the obtained unit-impulse response hðnÞ, we can represent the linear time-invariant system as
shown in Figure 3.14.
EXAMPLE 3.7
Assume we have a linear time invariant system
yðnÞ
0:5xðnÞ þ 0:25xðn
1Þ
with an initial condition xð 1Þ
0.
a. Determine the unit impulse response hðnÞ.
b. Draw the system block diagram.
c. Write the output using the obtained impulse response.
Solution:
a. According to Figure 3.13, let xðnÞ
dðnÞ, then
hðnÞ
yðnÞ
0:5xðnÞ þ 0:25xðn
1Þ
0:5dðnÞ þ 0:25dðn
1Þ
Thus, for this particular linear system, we have
hðnÞ
8
>
<
>
:
0:5
n
0
0:25
n
1
0
elsewhere
Linear time invariant system
h n
( )
( )
n
FIGURE 3.13
Unit-impulse response of a linear time-invariant system.
y(n)
x(n)
h(n)
FIGURE 3.14
Representation of a linear time-invariant system using the impulse response.
68
CHAPTER 3 Digital Signals and Systems

b. The block diagram of the linear time invariant system is shown in Figure 3.15.
c. The system output can be rewritten as
yðnÞ
hð0ÞxðnÞ þ hð1Þxðn
1Þ
From the result Example 3.7, it is noted that the difference equation does not have the past output
terms, yðn  1Þ, ., yðn  NÞ, that is, the corresponding coefﬁcients a1,.,aN, are zeros, and the impulse
response hðnÞ has a ﬁnite number of terms. We call this system a ﬁnite impulse response (FIR) system. In
general, Equation (3.12) contains the past output terms and the resulting impulse response h(n) has an
inﬁnite number of terms. We can express the output sequence of a linear time-invariant system using its
impulse response and inputs as
yðnÞ ¼ / þ hð1Þxðn þ 1Þ þ hð0ÞxðnÞ þ hð1Þxðn  1Þ þ hð2Þxðn  2Þ þ /
(3.15)
Equation (3.15) is called the digital convolution sum, which will be explored in a later section. We can
verify Equation (3.15) by substituting the impulse sequence xðnÞ ¼ dðnÞ to get the impulse response
hðnÞ ¼ / þ hð1Þdðn þ 1Þ þ hð0ÞdðnÞ þ hð1Þdðn  1Þ þ hð2Þdðn  2Þ þ /
where . hð1Þ, hð0Þ , hð1Þ, hð2Þ . are the amplitudes of the impulse response at the corresponding
time indices. Now let us look at another example.
EXAMPLE 3.8
Consider the difference equation
yðnÞ
0:25yðn
1Þ þ xðnÞ
for
n  0
and
yð 1Þ
0
a. Determine the unit impulse response hðnÞ.
b. Draw the system block diagram.
c. Write the output using the obtained impulse response.
d. For a step input xðnÞ
uðnÞ, verify and compare the output responses for the ﬁrst three output samples using
the difference equation and digital convolution sum (Equation (3.15)).
Solution:
a. Let xðnÞ
dðnÞ, then
hðnÞ
0:25hðn
1Þ þ dðnÞ
To solve for hðnÞ, we evaluate
hð0Þ
0:25hð 1Þ þ dð0Þ
0:25  0 þ 1
1
hð1Þ
0:25hð0Þ þ dð1Þ
0:25  1 þ 0
0:25
( )
y n
( )
x n
( )
0.5 ( )
0.25 (
1)
h n
n
n
FIGURE 3.15
The system block diagram for Example 3.7.
3.3 Difference Equations and Impulse Responses
69

hð2Þ
0:25hð1Þ þ dð2Þ
0:25  0:5 þ 0
0:0625
..
With the calculated results, we can predict the impulse response as
hðnÞ
ð0:25ÞnuðnÞ
dðnÞ þ 0:25dðn
1Þ þ 0:0625dðn
2Þ þ /
b. The system block diagram is given in Figure 3.16.
c. The output sequence is a sum of inﬁnite terms expressed as
yðnÞ
hð0ÞxðnÞ þ hð1Þxðn
1Þ þ hð2Þxðn
2Þ þ /
xðnÞ þ 0:25xðn
1Þ þ 0:0625xðn
2Þ þ /
d. From the difference equation and using the zero initial condition, we have
yðnÞ
0:25yðn
1Þ þ xðnÞ for n  0 and yð 1Þ
0
n
0, yð0Þ
0:25yð 1Þ þ xð0Þ
uð0Þ
1
n
1, yð1Þ
0:25yð0Þ þ xð1Þ
0:25  uð0Þ þ uð1Þ
1:25
n
2, yð2Þ
0:25yð1Þ þ xð2Þ
0:25  1:25 þ uð2Þ
1:3125
..
Applying the convolution sum in Equation (3.15) yields
yðnÞ
xðnÞ þ 0:25xðn
1Þ þ 0:0625xðn
2Þ þ /
n
0;
yð0Þ
xð0Þ þ 0:25xð 1Þ þ 0:0625xð 2Þ þ /
uð0Þ þ 0:25  uð 1Þ þ 0:125  uð 2Þ þ /
1
n
1;
yð1Þ
xð1Þ þ 0:25xð0Þ þ 0:0625xð 1Þ þ /
uð1Þ þ 0:25  uð0Þ þ 0:125  uð 1Þ þ /
1:25
n
2;
yð2Þ
xð2Þ þ 0:25xð1Þ þ 0:0625xð0Þ þ /
uð2Þ þ 0:25  uð1Þ þ 0:0625  uð0Þ þ /
1:3125
.
Comparing the results, we verify that a linear time invariant system can be represented by the convolution sum
using its impulse response and input sequence. Note that we verify only the causal system for simplicity, and
the principle works for both causal and noncausal systems.
( )
y n
( )
x n
( )
( )
0.25 (
1)
h n
n
n
...
FIGURE 3.16
The system block diagram for Example 3.8.
70
CHAPTER 3 Digital Signals and Systems

Notice that this impulse response hðnÞ contains an inﬁnite number of terms in its duration due to the
past output term yðn  1Þ. Such a system as described in the preceding example is called an inﬁnite
impulse response (IIR) system, which will be studied in later chapters.
3.4 BOUNDED-IN AND BOUNDED-OUT STABILITY
We are interested in designing and implementing stable linear systems. A stable system is one for
which every bounded input produces a bounded output (BIBO). There are many other stability deﬁ-
nitions. To ﬁnd the stability criterion, consider the linear time-invariant representation with all the
inputs reaching the maximum value M for the worst case. Equation (3.15) becomes
yðnÞ ¼ Mð/ þ hð1Þ þ hð0Þ þ hð1Þ þ hð2Þ þ /Þ
(3.16)
Using the absolute values of the impulse response leads to
yðnÞ < Mð/ þ jhð1Þj þ jhð0Þj þ jhð1Þj þ jhð2Þj þ /Þ
(3.17)
If the absolute sum in Equation (3.17) is a ﬁnite number, the product of the absolute sum and the
maximum input value is therefore a ﬁnite number. Hence, we have a bounded input and bounded
output. In terms of the impulse response, a linear system is stable if the sum of its absolute impulse
response coefﬁcients is a ﬁnite number. We can apply Equation (3.18) to determine whether a linear
time-invariant system is stable or not stable, that is,
S ¼
X
N
k ¼
N
jhðkÞj ¼ / þ jhð1Þj þ jhð0Þj þ jhð1Þj þ / < N
(3.18)
Figure 3.17 describes a linear stable system, where the impulse response decreases to zero in a ﬁnite
amount of time so that the summation of its absolute impulse response coefﬁcients is guaranteed to be
ﬁnite.
EXAMPLE 3.9
Given the linear system in Example 3.8,
yðnÞ
0:25yðn
1Þ þ xðnÞ
for
n  0
and
yð 1Þ
0
h n
( )
(n)
linear stable
system
n
n
FIGURE 3.17
Illustration of stability of the digital linear system.
3.4 Bounded In and Bounded Out Stability
71

which is described by the unit impulse response
hðnÞ
ð0:25ÞnuðnÞ
determine whether this system is stable.
Solution:
Using Equation (3.18), we have
S
X
N
k
N
jhðkÞj
X
N
k
N
ð0:25ÞkuðkÞ

Applying the deﬁnition of the unit step function uðkÞ
1 for k  0, we have
S
X
N
k
0
ð0:25Þk
1 þ 0:25 þ 0:252 þ /
Using the formula for a sum of the geometric series (see Appendix F),
X
N
k
0
ak
1
1
a;
where a
0:25 < 1, we conclude
S
1 þ 0:25 þ 0:252 þ /
1
1
0:25
4
3 < N
Since the summation is a ﬁnite number, the linear system is stable.
3.5 DIGITAL CONVOLUTION
Digital convolution plays an important role in digital ﬁltering. As we veriﬁed in the last section,
a linear time-invariant system can be represented using a digital convolution sum. Given a linear time-
invariant system, we can determine its unit-impulse response hðnÞ, which relates the system input and
output. To ﬁnd the output sequence yðnÞ for any input sequence xðnÞ, we write the digital convolution
shown in Equation (3.15) as
yðnÞ ¼
P
N
k ¼
N
hðkÞxðn  kÞ
¼ / þ hð1Þxðn þ 1Þ þ hð0ÞxðnÞ þ hð1Þxðn  1Þ þ hð2Þxðn  2Þ þ /
(3.19)
The sequences hðkÞ and xðkÞ in Equation (3.19) are interchangeable. Hence, we have an alternative
form:
yðnÞ ¼
P
N
k ¼
N
xðkÞhðn  kÞ
¼ / þ xð1Þhðn þ 1Þ þ xð0ÞhðnÞ þ xð1Þhðn  1Þ þ xð2Þhðn  2Þ þ /
(3.20)
72
CHAPTER 3 Digital Signals and Systems

Using conventional notation, we express the digital convolution as
yðnÞ ¼ hðnÞ  xðnÞ
(3.21)
Note that for a causal system, which implies an impulse response of
hðnÞ ¼ 0
for
n < 0
(3.16)
the lower limit of the convolution sum begins at 0 instead of N, that is
yðnÞ ¼
X
N
k ¼ 0
hðkÞxðn  kÞ ¼
X
N
k ¼ 0
xðkÞhðn  kÞ
(3.22)
We will focus on evaluating the convolution sum based on Equation (3.20). Let us examine ﬁrst a few
outputs from Equation (3.20):
yð0Þ ¼ PN
k ¼
N xðkÞhðkÞ ¼ / þ xð1Þhð1Þ þ xð0Þhð0Þ þ xð1Þhð1Þ þ xð2Þhð2Þ þ /
yð1Þ ¼ PN
k ¼
N xðkÞhð1  kÞ ¼ / þ xð1Þhð2Þ þ xð0Þhð1Þ þ xð1Þhð0Þ þ xð2Þhð1Þ þ /
yð2Þ ¼ PN
k ¼
N xðkÞhð2  kÞ ¼ / þ xð1Þhð3Þ þ xð0Þhð2Þ þ xð1Þhð1Þ þ xð2Þhð0Þ þ /
...
We see that the convolution sum requires the sequence hðnÞ to be reversed and shifted. The graphical,
formula, and table methods for evaluating the digital convolution will be discussed via several examples.
To evaluate the convolution sum graphically, we need to apply the reversed sequence and shifted
sequence. The reversed sequence is deﬁned as follows: if hðnÞ is the given sequence, hðnÞ is the reversed
sequence. The reversed sequence is a mirror image of the original sequence, assuming the vertical axis as
the mirror. Let us study the reversed sequence and shifted sequence via the following example.
EXAMPLE 3.10
Consider a sequence
hðkÞ
8
>
<
>
:
3;
k
0; 1
1;
k
2; 3
0
elsewhere
where k is the time index or sample number.
a. Sketch the sequence hðkÞ and reversed sequence hð kÞ.
b. Sketch the shifted sequences hð k þ 3Þ and hð k
2Þ.
Solution:
a. Since hðkÞ is deﬁned, we plot it in Figure 3.18. Next, we need to ﬁnd the reversed sequence hð kÞ. We examine
the following:
k > 0, hð kÞ
0
k
0, hð 0Þ
hð0Þ
3
k
1, hð kÞ
hð ð 1ÞÞ
hð1Þ
3
k
2, hð kÞ
hð ð 2ÞÞ
hð2Þ
1
k
3, hð kÞ
hð ð 3ÞÞ
hð3Þ
1
One can verify that k 
4, hð kÞ
0. Then the reversed sequence hð kÞ is shown as the second plot in
Figure 3.18.
3.5 Digital Convolution
73

As shown in the sketches, hð kÞ is just a mirror image of the original sequence hðkÞ.
b. Based on the deﬁnition of the original sequence, we know that hð0Þ
hð1Þ
3, hð2Þ
hð3Þ
1, and the
others are zeros. The time indices correspond to the following:
k þ 3
0, k
3
k þ 3
1, k
2
k þ 3
2, k
1
k þ 3
3, k
0
Thus we can sketch hð k þ 3Þ as shown in Figure 3.19.
Similarly, hð k
2Þ is shown in Figure 3.20.
0
1
2
3
4
5
k
1
1
2
3
( )
h k
0
1
2
3
4
5
k
1
1
2
3
(
)
h
k
FIGURE 3.18
Plots of the digital sequence and its reversed sequence in Example 3.10.
0
4
1
3
1
2
k
2
1
2
3
(
3)
h
k
FIGURE 3.19
Plot of the sequence hð k þ 3Þ in Example 3.10.
0
2
3
4
5
k
1
1
2
3
(
2)
h
k
6
FIGURE 3.20
Plot of the sequence hð k
2Þ in Example 3.10.
74
CHAPTER 3 Digital Signals and Systems

We can get hð k þ 3Þ by shifting hð kÞ to the right by three samples, and we can obtain hð k
2Þ by shifting
hð kÞ to the left by two samples.
In summary, given hð kÞ, we can obtain hðn
kÞ by shifting hð kÞn samples to the right or the left,
depending on whether n is positive or negative.
Once we understand the shifted sequence and reversed sequence, we can perform digital convolution of the
two sequences hðkÞ and xðkÞ, deﬁned in Equation (3.20) graphically. From that equation, we see that each
convolution value yðnÞ is the sum of the products of two sequences xðkÞ and hðn
kÞ, the latter of which is the
shifted version of the reversed sequence hð kÞ by jnj samples. Hence, we can summarize the graphical convo
lution procedure in Table 3.3.
We illustrate the digital convolution sum in the following example.
EXAMPLE 3.11
Using the sequences deﬁned in Figure 3.21, evaluate the digital convolution
yðnÞ
X
N
k
N
xðkÞhðn
kÞ
a. By the graphical method.
b. By applying the formula directly.
Solution:
a. To obtain yð0Þ, we need the reversed sequence hð kÞ; and to obtain yð1Þ, we need the reversed sequence
hð1
kÞ, and so on. Using the technique we have discussed, sequences hð kÞ, hð k þ 1Þ, hð k þ 2Þ,
hð k þ 3Þ, and hð k þ 4Þ are obtained and plotted in Figure 3.22.
Again, using the information in Figures 3.21 and 3.22, we can compute the convolution sum as
Table 3.3 Digital Convolution Using the Graphical Method
Step 1. Obtain the reversed sequence hð kÞ.
Step 2. Shift hð kÞ by jnj samples to get hðn
kÞ. If n  0, hð kÞ will be shifted to right by n samples; but if
n < 0, hð kÞ will be shifted to the left by jnj samples.
Step 3. Perform the convolution sum, which is the sum of the products of two sequences xðkÞ and hðn
kÞ, to
get yðnÞ.
Step 4. Repeat Steps 1 to 3 for the next convolution value yðnÞ.
0
1
2
3
k
1
1
2
3
h(k)
0
1
2
3
k
1
1
2
3
x(k)
FIGURE 3.21
Plots of digital input sequence and impulse sequence in Example 3.11.
3.5 Digital Convolution
75

0
1
2
3
k
1
1
2
3
(
)
h
k
0
1
2
3
k
1
1
2
3
(
1)
h
k
0
2
1
2
k
1
1
2
3
(
2)
h
k
1
3
0
1
k
2
1
2
3
(
3)
h
k
2
4
1
0
k
3
1
2
3
(
4)
h
k
FIGURE 3.22
Illustration of convolution of two sequences xðkÞ and hðkÞ in Example 3.11.
76
CHAPTER 3 Digital Signals and Systems

sum of product of xðkÞ and hð kÞ: yð0Þ
3  3
9
sum of product of xðkÞ and hð1
kÞ: yð1Þ
1  3 þ 3  2
9
sum of product of xðkÞ and hð2
kÞ: yð2Þ
2  3 þ 1  2 þ 3  1
11
sum of product of xðkÞ and hð3
kÞ: yð3Þ
2  2 þ 1  1
5
sum of product of xðkÞ and hð4
kÞ: yð4Þ
2  1
2
sum of product of xðkÞ and hð5
kÞ: yðnÞ
0 for n > 4, since sequences xðkÞ and hðn
kÞ do not overlap.
Finally, we sketch the output sequence yðnÞ in Figure 3.23.
b. Applying Equation (3.20) with zero initial conditions leads to
yðnÞ
xð0ÞhðnÞ þ xð1Þhðn
1Þ þ xð2Þhðn
2Þ
n
0, yð0Þ
xð0Þhð0Þ þ xð1Þhð 1Þ þ xð2Þhð 2Þ
3  3 þ 1  0 þ 2  0
9
n
1, yð1Þ
xð0Þhð1Þ þ xð1Þhð0Þ þ xð2Þhð 1Þ
3  2 þ 1  3 þ 2  0
9
n
2, yð2Þ
xð0Þhð2Þ þ xð1Þhð1Þ þ xð2Þhð0Þ
3  1 þ 1  2 þ 2  3
11
n
3, yð3Þ
xð0Þhð3Þ þ xð1Þhð2Þ þ xð2Þhð1Þ
3  0 þ 1  1 þ 2  2
5
n
4, yð4Þ
xð0Þhð4Þ þ xð1Þhð3Þ þ xð2Þhð2Þ
3  0 þ 1  0 þ 2  1
2
n  5, yðnÞ
xð0ÞhðnÞ þ xð1Þhðn
1Þ þ xð2Þhðn
2Þ
3  0 þ 1  0 þ 2  0
0
In simple cases such as this example, it is not necessary to use the graphical or formula methods. We can compute
the convolution by treating the input sequence and impulse response as number sequences and sliding the
reversed impulse response past the input sequence, cross multiplying, and summing the nonzero overlap terms at
each step. The procedure and calculated results are listed in Table 3.4.
0
1
2
3
n
5
10
y n
( )
4
5
FIGURE 3.23
Plot of the convolution sum in Example 3.11.
Table 3.4 Convolution Sum Using the Table Method
k :
L2
L1
0
1
2
3
4
5
xðkÞ :
3
1
2
hð kÞ :
1
2
3
yð0Þ
3  3
9
hð1
kÞ
1
2
3
yð1Þ
3  2 þ 1  3
9
hð2
kÞ
1
2
3
yð2Þ
3  1 þ 1  2 þ 2  3
11
hð3
kÞ
1
2
3
yð3Þ
1  1 þ 2  2
5
hð4
kÞ
1
2
3
yð4Þ
2  1
2
hð5
kÞ
1
2
3
yð5Þ
0 (no overlap)
3.5 Digital Convolution
77

We can see that the calculated results using all the methods are consistent. The steps using the table method
are summarized in Table 3.5.
EXAMPLE 3.12
Convolve the following two rectangular sequences using the table method:
xðnÞ
( 1
n
0; 1; 2
0
otherwise
and
hðnÞ
8
>
>
>
<
>
>
>
:
0
n
0
1
n
1; 2
0
otherwise
Solution:
Using Table 3.5 as a guide, we list the operations and calculations in Table 3.6. Note that the output should show
the trapezoidal shape.
Table 3.6 Convolution Sum in Example 3.12
k :
L2
L1
0
1
2
3
4
5
xðkÞ :
1
1
1
hð kÞ :
1
1
0
yð0Þ
0 (no overlap)
hð1
kÞ
1
1
0
yð1Þ
1  1
1
hð2
kÞ
1
1
0
yð2Þ
1  1 þ 1  1
2
hð3
kÞ
1
1
0
yð3Þ
1  1 þ 1  1
2
hð4
kÞ
1
1
0
yð4Þ
1  1
1
hðn
kÞ
1
1
0
yðnÞ
0, n  5 (no overlap)
Stop
Table 3.5 Digital Convolution Steps via the Table Method
Step 1. List the index k covering a sufﬁcient range.
Step 2. List the input xðkÞ.
Step 3. Obtain the reversed sequence hð kÞ, and align the rightmost element of hðn
kÞ to the leftmost
element of xðkÞ.
Step 4. Cross-multiply and sum the nonzero overlap terms to produce yðnÞ.
Step 5. Slide hðn
kÞ to the right by one position.
Step 6. Repeat Step 4; stop if all the output values are zero or if required.
78
CHAPTER 3 Digital Signals and Systems

Let us examine convolving a ﬁnite long sequence with an inﬁnite long sequence.
EXAMPLE 3.13
A system representation using the unit impulse response for the linear system
yðnÞ
0:25yðn
1Þ þ xðnÞ
for
n  0
and
yð 1Þ
0
was determined in Example 3:8 as
yðnÞ
X
N
k
N
xðkÞhðn
kÞ
where hðnÞ
ð0:25ÞnuðnÞ. For a step input xðnÞ
uðnÞ, determine the output response for the ﬁrst three output
samples using the table method.
Solution:
Using Table 3.5 as a guide, we list the operations and calculations in Table 3.7. As expected, the output values are
the same as those obtained in Example 3.8.
3.6 SUMMARY
1. Digital signal samples are sketched using their encoded amplitude versus sample numbers with
vertical bars topped by solid circles located at their sampling instants, respectively. The impulse
sequence, unit-step sequence, and their shifted versions are sketched in this notation.
2. The analog signal function can be sampled to its digital (discrete-time) version by substituting time
t ¼ nT into the analog function, that is,
xðnÞ ¼ xðtÞjt¼nT ¼ xðnTÞ
The digital function values can be calculated for the given time index (sample number).
3. The DSP system we wish to design must be a linear, time-invariant, causal system. Linearity means
that the superposition principle exists. Time invariance requires that the shifted input generate the
corresponding shifted output in the same amount of time. Causality indicates that the system output
depends on only its current input sample and past input sample(s).
4. The difference equation describing a linear, time-invariant system has a format such that the current
output depends on the current input, past input(s), and past output(s) in general.
Table 3.7 Convolution Sum in Example 3.13.
k :
L2
L1
0
1
2
3
.
xðkÞ :
1
1
1
1
.
hð kÞ :
0.0625
0.25
1
yð0Þ
1  1
1
hð1
kÞ
0.0625
0.25
1
yð1Þ
1  0:25 þ 1  1
1:25
hð2
kÞ
0.0625
0.25
1
yð2Þ
1  0:0625 þ 1  0:25þ
1  1
1:3125
Stop as required
3.6 Summary
79

5. The unit-impulse response can be used to fully describe a linear, time-invariant system. Given the
impulse response, the system output is the sum of the products of the impulse response coefﬁcients
and corresponding input samples, called the digital convolution sum.
6. BIBO is a type of stability in which a bounded input will produce a bounded output. A BIBO
system requires that the sum of the absolute impulse response coefﬁcients be a ﬁnite number.
7. The digital convolution sum, which represents a DSP system, is evaluated in three ways: the
graphical method, evaluation of the formula, and the table method. The table method is found to
be most effective.
3.7 PROBLEMS
3.1. Sketch each of the following special digital sequences:
a. 5dðnÞ
b. 2dðn  5Þ
c. 5uðnÞ
d. 5uðn  2Þ
3.2. Calculate the ﬁrst eight sample values and sketch each of the following sequences:
a. xðnÞ ¼ 0:5nuðnÞ
b. xðnÞ ¼ 5sinð0:2pnÞuðnÞ
c. xðnÞ ¼ 5cosð0:1pn þ 300ÞuðnÞ
d. xðnÞ ¼ 5ð0:75Þnsinð0:1pnÞuðnÞ
3.3. Sketch each of the following special digital sequences:
a. 8dðnÞ
b. 3:5dðn  4Þ
c. 4:5uðnÞ
d. 6uðn  3Þ
3.4. Calculate the ﬁrst eight sample values and sketch each of the following sequences:
a. xðnÞ ¼ 0:25nuðnÞ
b. xðnÞ ¼ 3sinð0:4pnÞuðnÞ
c. xðnÞ ¼ 6cosð0:2pn þ 300ÞuðnÞ
d. xðnÞ ¼ 4ð0:5Þnsinð0:1pnÞuðnÞ
3.5. Sketch the following sequences:
a. xðnÞ ¼ 3dðn þ 2Þ  0:5dðnÞ þ 5dðn  1Þ  4dðn  5Þ
b. xðnÞ ¼ dðn þ 1Þ  2dðn  1Þ þ 5uðn  4Þ
80
CHAPTER 3 Digital Signals and Systems

3.6. Given the digital signals xðnÞ in Figures 3.24 and 3.25, write an expression for each digital
signal using the unit-impulse sequence and its shifted sequences.
3.7. Sketch the following sequences:
a. xðnÞ ¼ 2dðn þ 3Þ  0:5dðn þ 1Þ  5dðn  2Þ  4dðn  5Þ
b. xðnÞ ¼ 2dðn þ 2Þ  2dðn þ 1Þ þ 5uðn  3Þ
3.8. Given the digital signals xðnÞ in Figures 3.26 and 3.27, write an expression for each digital
signal using the unit-impulse sequence and its shifted sequences.
x n
( )
0
1
2
3
1
1
n
4
5
1
FIGURE 3.25
The second digital signal in Problem 3.6.
x n
( )
0
1
2
3
1
1
2
n
2
1
4
5
3
4
1
1
FIGURE 3.24
The ﬁrst digital signal in Problem 3.6.
x n
( )
0
1
2
3
1
1
2
n
4
5
3
4
FIGURE 3.26
The ﬁrst digital signal in Problem 3.8.
3.6 Summary
81

x(n)
0
1
2
3
1
1
n
4
5
1
FIGURE 3.27
The second digital signal in Problem 3.8.
3.9. Assume that a DS processor with a sampling time interval of 0.01 second converts the
following analog signals xðtÞ to a digital signal xðnÞ; determine the digital sequence for each
of the analog signals.
a. xðtÞ ¼ e 50tuðtÞ
b. xðtÞ ¼ 5sinð20ptÞuðtÞ
c. xðtÞ ¼ 10cosð40pt þ 300ÞuðtÞ
d. xðtÞ ¼ 10e 100tsinð15ptÞuðtÞ
3.10. Determine which of the following systems is a linear system.
a. yðnÞ ¼ 5xðnÞ þ 2x2ðnÞ
b. yðnÞ ¼ xðn  1Þ þ 4xðnÞ
c. yðnÞ ¼ 4x3ðn  1Þ  2xðnÞ
3.11. Assume that a DS processor with a sampling time interval of 0.005 second converts each of
the following analog signals xðtÞ to a digital signal xðnÞ; determine the digital sequence for
each of the analog signals.
a. xðtÞ ¼ e 100tuðtÞ
b. xðtÞ ¼ 4sinð60ptÞuðtÞ
c. xðtÞ ¼ 7:5cosð20pt þ 600ÞuðtÞ
d. xðtÞ ¼ 20e 200tsinð60ptÞuðtÞ
3.12. Determine which of the following systems is a linear system.
a. yðnÞ ¼ 4xðnÞ þ 8x3ðnÞ
b. yðnÞ ¼ xðn  3Þ þ 3xðnÞ
c. yðnÞ ¼ 5x2ðn  1Þ  3xðnÞ
3.13. Determine which of the following linear systems is time invariant.
a. yðnÞ ¼ 5xðn  10Þ
b. yðnÞ ¼ 4xðn2Þ
82
CHAPTER 3 Digital Signals and Systems

3.14. Determine which of the following linear systems is causal.
a. yðnÞ ¼ 0:5xðnÞ þ 100xðn  2Þ  20xðn  10Þ
b. yðnÞ ¼ xðn þ 4Þ þ 0:5xðnÞ  2xðn  2Þ
3.15. Determine the causality for each of the following linear systems.
a. yðnÞ ¼ 0:5xðnÞ þ 20xðn  2Þ  0:1yðn  1Þ
b. yðnÞ ¼ xðn þ 2Þ  0:4yðn  1Þ
c. yðnÞ ¼ xðn  1Þ þ 0:5yðn þ 2Þ
3.16. Find the unit-impulse response for each of the following linear systems.
a. yðnÞ ¼ 0:5xðnÞ  0:5xðn  2Þ ; for n  0, xð2Þ ¼ 0, xð1Þ ¼ 0
b. yðnÞ ¼ 0:75yðn  1Þ þ xðnÞ ; for n  0, yð1Þ ¼ 0
c. yðnÞ ¼ 0:8yðn  1Þ þ xðn  1Þ ; for n  0, xð1Þ ¼ 0, yð1Þ ¼ 0
3.17. Determine the causality for each of the following linear systems.
a. yðnÞ ¼ 5xðnÞ þ 10xðn  4Þ  0:1yðn  5Þ
b. yðnÞ ¼ 2xðn þ 2Þ  0:2yðn  2Þ
c. yðnÞ ¼ 0:1xðn þ 1Þ þ 0:5yðn þ 2Þ
3.18. Find the unit-impulse response for each of the following linear systems.
a. yðnÞ ¼ 0:2xðnÞ  0:3xðn  2Þ ; for n  0, xð2Þ ¼ 0, xð1Þ ¼ 0
b. yðnÞ ¼ 0:5yðn  1Þ þ 0:5xðnÞ ; for n  0, yð1Þ ¼ 0
c. yðnÞ ¼ 0:6yðn  1Þ  xðn  1Þ ; for n  0, xð1Þ ¼ 0, yð1Þ ¼ 0
3.19. For each of the following linear systems, ﬁnd the unit-impulse response, and draw the block
diagram.
a. yðnÞ ¼ 5xðn  10Þ
b. yðnÞ ¼ xðnÞ þ 0:5xðn  1Þ
3.20. Determine the stability of the following linear system.
yðnÞ ¼ 0:5xðnÞ þ 100xðn  2Þ  20xðn  10Þ
3.21. For each of the following linear systems, ﬁnd the unit-impulse response, and draw the block
diagram.
a. yðnÞ ¼ 2:5xðn  5Þ
b. yðnÞ ¼ 2xðnÞ þ 1:2xðn  1Þ
3.22. Determine the stability for the following linear system.
yðnÞ ¼ 5xðnÞ þ 30xðn  3Þ  10xðn  20Þ
3.23. Determine the stability for each of the following linear systems.
a. yðnÞ ¼ PN
k ¼ 0 0:75kxðn  kÞ
b. yðnÞ ¼ PN
k ¼ 0 2kxðn  kÞ
3.6 Summary
83

3.24. Determine the stability for each of the following linear systems.
a. yðnÞ ¼ PN
k ¼ 0ð1:5Þkxðn  kÞ
b. yðnÞ ¼ PN
k ¼ 0ð0:5Þkxðn  kÞ
3.25. Given the sequence
hðkÞ ¼
8
>
<
>
:
2;
k ¼ 0; 1; 2
1;
k ¼ 3; 4
0
elsewhere;
where k is the time index or sample number,
a. sketch the sequence hðkÞ and the reverse sequence hðkÞ ;
b. sketch the shifted sequences hðk þ 2Þ and hðk  3Þ.
3.26. Given the sequence
hðkÞ ¼
8
>
>
>
>
<
>
>
>
>
:
1
k ¼ 0; 1
2
k ¼ 2; 3
2
k ¼ 4
0
elsewhere
where k is the time index or sample number,
a. sketch the sequence hðkÞ and the reverse sequence hðkÞ ;
b. sketch the shifted sequences hðk þ 1Þ and hðk  2Þ.
3.27. Using the sequence deﬁnitions
hðkÞ ¼
8
>
<
>
:
2;
k ¼ 0; 1; 2
1;
k ¼ 3; 4
0
elsewhere
and xðkÞ ¼
8
>
<
>
:
2;
k ¼ 0
1;
k ¼ 1; 2
0
elsewhere
evaluate the digital convolution
yðnÞ ¼
X
N
k ¼
N
xðkÞhðn  kÞ
a. using the graphical method;
b. using the table method;
c. applying the convolution formula directly.
3.28. Using the sequence deﬁnitions
xðkÞ ¼
8
>
<
>
:
2;
k ¼ 0; 1; 2
1;
k ¼ 3; 4
0
elsewhere
and hðkÞ ¼
8
>
<
>
:
2;
k ¼ 0
1;
k ¼ 1; 2
0
elsewhere
84
CHAPTER 3 Digital Signals and Systems

evaluate the digital convolution
yðnÞ ¼
X
N
k ¼
N
xðkÞhðn  kÞ
a. using the graphical method;
b. using the table method;
c. applying the convolution formula directly.
3.29. Convolve the two rectangular sequences
xðnÞ ¼
(
1
n ¼ 0; 1
0
otherwise and hðnÞ ¼
8
>
<
>
:
0
n ¼ 0
1
n ¼ 1; 2
0
otherwise
using the table method.
3.6 Summary
85

This page intentionally left blank

Discrete Fourier Transform and
Signal Spectrum
4
CHAPTER OUTLINE
4.1 Discrete Fourier Transform.............................................................................................................. 87
4.1.1 Fourier Series Coefﬁcients of Periodic Digital Signals .....................................................88
4.1.2 Discrete Fourier Transform Formulas.............................................................................91
4.2 Amplitude Spectrum and Power Spectrum........................................................................................ 97
4.3 Spectral Estimation Using Window Functions................................................................................. 107
4.4 Application to Signal Spectral Estimation ...................................................................................... 116
4.5 Fast Fourier Transform.................................................................................................................. 123
4.5.1 Decimation-in-Frequency Method ...............................................................................123
4.5.2 Decimation-in-Time Method .......................................................................................128
4.6 Summary ..................................................................................................................................... 132
OBJECTIVES:
This chapter investigates discrete Fourier transform (DFT) and fast Fourier transform (FFT) and their
properties; introduces the DFT/FFT algorithms that compute the signal amplitude spectrum and power
spectrum; and uses the window function to reduce spectral leakage. Finally, the chapter describes the FFT
algorithm and shows how to apply FFT to estimate a speech spectrum.
4.1 DISCRETE FOURIER TRANSFORM
In the time domain, representation of digital signals describes the signal amplitude versus the sampling
time instant or the sample number. However, in some applications, signal frequency content is very
useful in ways other than as digital signal samples. The representation of the digital signal in terms of
its frequency component in a frequency domain, that is, the signal spectrum, needs to be developed. As
an example, Figure 4.1 illustrates the time domain representation of a 1,000-Hz sinusoid with 32
samples at a sampling rate of 8,000 Hz; the bottom plot shows the signal spectrum (frequency domain
representation), where we can clearly observe that the amplitude peak is located at the frequency of
1,000 Hz in the calculated spectrum. Hence, the spectral plot better displays the frequency information
of a digital signal.
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00004-4
Copyright  2013 Elsevier Inc. All rights reserved.
87

The algorithm transforming the time domain signal samples to the frequency domain components
is known as the discrete Fourier transform, or DFT. The DFT also establishes a relationship between
the time domain representation and the frequency domain representation. Therefore, we can apply the
DFT to perform frequency analysis of a time domain sequence. In addition, the DFT is widely used in
many other areas, including spectral analysis, acoustics, imaging/video, audio, instrumentation, and
communications systems.
To be able to develop the DFT and understand how to use it, we ﬁrst study the spectrum of periodic
digital signals using the Fourier series. (There is a detailed discussion of the Fourier series in
Appendix B.)
4.1.1 Fourier Series Coefﬁcients of Periodic Digital Signals
Let us look at a process in which we want to estimate the spectrum of a periodic digital signal xðnÞ
sampled at a rate of fs Hz with the fundamental period T0 ¼ NT, as shown in Figure 4.2, where there
are N samples within the duration of the fundamental period and T ¼ 1=fs is the sampling period. For
the time being, we assume that the periodic digital signal is band limited such that all harmonic
frequencies are less than the folding frequency fs=2 so that aliasing does not occur.
According to Fourier series analysis (Appendix B), the coefﬁcients of the Fourier series expansion
of the periodic signal xðtÞ in a complex form are
0
5
10
15
20
25
30
5
0
5
Sample number n
x(n)
0
500
1000
1500
2000
2500
3000
3500
4000
0
2
4
6
Frequency (Hz)
S gna  spectrum
FIGURE 4.1
Example of the digital signal and its amplitude spectrum.
88
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

ck ¼ 1
T0
Z
T0
xðtÞe jku0tdt
 N < k < N
(4.1)
where k is the number of harmonics corresponding to the harmonic frequency of kf0 and u0 ¼ 2p=T0
and f0 ¼ 1=T0 are the fundamental frequency in radians per second and the fundamental frequency in
Hz, respectively. To apply Equation (4.1), we substitute T0 ¼ NT, u0 ¼ 2p=T0 and approximate the
integration over one period using a summation by substituting dt ¼ T and t ¼ nT. We obtain
ck ¼ 1
N
X
N
1
n ¼ 0
xðnÞe j 2pkn
N ;
 N < k < N
(4.2)
Since the coefﬁcients ck are obtained from the Fourier series expansion in the complex form, the
resultant spectrum ck will have two sides. There is an important feature of Equation (4.2) in which the
Fourier series coefﬁcient ck is periodic of N. We can verify this as follows:
ckþN ¼ 1
N
X
N
1
n ¼ 0
xðnÞe j2pðkþNÞn
N
¼ 1
N
X
N
1
n ¼ 0
xðnÞe j2pkn
N e j2pn
(4.3)
Since e j2pn ¼ cosð2pnÞ  jsinð2pnÞ ¼ 1, it follows that
ckþN ¼ ck
(4.4)
Therefore, the two-side line amplitude spectrum jckj is periodic, as shown in Figure 4.3.
( )
x n
n
0T
NT
0
x( )
0
x( )1
(
)
(0)
x N
x
(
1)
(1)
x N
x
N
FIGURE 4.2
Periodic digital signal.
f
kc
DC component kfo = 0xfo = 0 Hz
= 2xfo = 2fo Hz
Other harmonics ...
Other harmonics ...
Hz
f 0
fs – f0
fs = Nf0
fs fs + f0
 f0
 –fs / 2
 fs / 2
 –f0
2nd harmonic kfo
1st harmonic kfo = 1xfo = fo Hz
FIGURE 4.3
Amplitude spectrum of the periodic digital signal.
4.1 Discrete Fourier Transform
89

We note the following points:
a. As displayed in Figure 4.3, only the line spectral portion between the frequency fs=2 and
frequency fs=2 (folding frequency) represents frequency information of the periodic signal.
b. Notice that the spectral portion from fs=2 to fs is a copy of the spectrum in the negative frequency
range from fs=2 to 0 Hz due to the spectrum being periodic for every Nf0 Hz. Again, the amplitude
spectral components indexed from fs=2 to fs can be folded at the folding frequency fs=2 to match the
amplitude spectral components indexed from 0 to fs=2 in terms of fs  f Hz, where f is in the range
from fs=2 to fs. For convenience, we compute the spectrum over the range from 0 to fs Hz with
nonnegative indices, that is,
ck ¼ 1
N
X
N
1
n ¼ 0
xðnÞe j2pkn
N ;
k ¼ 0; 1; /; N  1
(4.5)
We can apply Equation (4.4) to ﬁnd the negative indexed spectral values if they are required.
c. For the kth harmonic, the frequency is
f ¼ kf0 Hz
(4.6)
Thefrequencyspacingbetweentheconsecutivespectrallines,calledthefrequencyresolution,isf0 Hz.
EXAMPLE 4.1
The periodic signal
xðtÞ
sinð2ptÞ
is sampled using the sampling rate fs
4 Hz.
a. Compute the spectrum ck using the samples in one period.
b. Plot the two sided amplitude spectrum jckj over the range from
2 to 2 Hz.
Solution:
a. From the analog signal, we can determine the fundamental frequency u0
2p radians per second and
f0
u0
2p
2p
2p
1 Hz, and the fundamental period T0
1 second.
Since using the sampling interval T
1=fs
0:25 second, we get the sampled signal as
xðnÞ
xðnTÞ
sinð2pnTÞ
sinð0:5pnÞ
and plot the ﬁrst eight samples as shown in Figure 4.4.
x n
( )
n
4
N
0
1
x( )
0
x( )1
x( )
2
x( )3
FIGURE 4.4
Periodic digital signal.
90
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

Choosing the duration of one period, N
4, we have the following sample values:
xð0Þ
0; xð1Þ
1; xð2Þ
0; and xð3Þ
1
Using Equation (4.5),
c0
1
4
X
3
n
0
xðnÞ
1
4

xð0Þ þ xð1Þ þ xð2Þ þ xð3Þ

1
4 ð0 þ 1 þ 0
1Þ
0
c1
1
4
X
3
n
0
xðnÞej2p1n=4
1
4

xð0Þ þ xð1Þejp=2 þ xð2Þejp þ xð3Þej3p=2
1
4

xð0Þ
jxð1Þ
xð2Þ þ jxð3Þ
0
jð1Þ
0 þ jð 1Þ

j0:5
Similarly, we get
c2
1
4
X
3
k
0
xðnÞej2p2n=4
0; and c3
1
4
X
3
n
0
xðkÞej2p3n=4
j0:5
Using periodicity, it follows that
c1
c3
j0:5; and c2
c2
0
b. The amplitude spectrum for the digital signal is sketched in Figure 4.5.
As we know, the spectrum in the range of
2 to 2 Hz presents the information of the sinusoid with a frequency
of 1 Hz and a peak value of 2j:c1j:
1, which is obtained from converting two sides to one side by doubling the
two sided spectral value. Note that we do not double the direct current (DC) component, that is, c0.
4.1.2 Discrete Fourier Transform Formulas
Now let us concentrate on development of the DFT. Figure 4.6 shows one way to obtain the DFT
formula.
f
1
1
/ 2
2
sf
4
sf
kc
3
4
5
Hz
2
3
4
5
2
0
05.
05.
05.
05.
05.
05.
FIGURE 4.5
Two-sided spectrum for the periodic digital signal in Example 4.1.
4.1 Discrete Fourier Transform
91

First, we assume that the process acquires data samples from digitizing the relevant continuous
signal for T0 seconds. Next, we assume that a periodic signal xðnÞ is obtained by cascading the
acquired N data samples with the duration of T0 repetitively. Note that we assume continuity between
the N data sample frames. This is not true in practice. We will tackle this problem in Section 4.3.
Finally, we determine the Fourier series coefﬁcients using one-period N data samples and Equation
(4.5). Then we multiply the Fourier series coefﬁcients by a factor of N to obtain
XðkÞ ¼ Nck ¼
X
N
1
n ¼ 0
xðnÞe j2pkn
N ;
k ¼ 0; 1; /; N  1
where XðkÞ constitutes the DFT coefﬁcients. Notice that the factor of N is a constant and does not
affect the relative magnitudes of the DFT coefﬁcients XðkÞ. As shown in the last plot, applying DFT
with N data samples of xðnÞ sampled at a sampling rate of fs (sampling period is T ¼ 1=fs) produces
N complex DFT coefﬁcients XðkÞ. The index n is the time index representing the sample number of
the digital sequence, whereas k is the frequency index indicating each calculated DFT coefﬁcient,
and can be further mapped to the corresponding signal frequency in terms of Hz.
Now let us conclude the DFT deﬁnition. Given a sequence xðnÞ,0  n  N  1, its DFT is deﬁned as
XðkÞ ¼
X
N
1
n ¼ 0
xðnÞe j2pkn=N ¼
X
N
1
n ¼ 0
xðnÞWkn
N ;
for k ¼ 0; 1; /; N  1
(4.7)
FIGURE 4.6
Development of DFT formula.
92
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

Equation (4.7) can be expanded as
XðkÞ ¼ xð0ÞWk0
N þ xð1ÞWk1
N þ xð2ÞWk2
N þ / þ xðN  1ÞWkðN
1Þ
N
;
for k ¼ 0; 1; /; N  1 (4.8)
where the factor WN (called the twiddle factor in some textbooks) is deﬁned as
WN ¼ e j2p=N ¼ cos
2p
N

 jsin
2p
N

(4.9)
The inverse of the DFT is given by
xðnÞ ¼ 1
N
X
N
1
k ¼ 0
XðkÞej2pkn=N ¼ 1
N
X
N
1
k ¼ 0
XðkÞW
kn
N
;
for n ¼ 0; 1; /; N  1
(4.10)
Proof can be found in Ahmed and Nataranjan (1983); Proakis and Manolakis (1996); Oppenheim,
Schafer, and Buck (1997); and Stearns and Hush (1990).
Similar to Equation (4.7), the expansion of Equation (4.10) leads to
xðnÞ ¼ 1
N

Xð0ÞW
0n
N
þ Xð1ÞW
1n
N
þ Xð2ÞW
2n
N
þ / þ XðN  1ÞW
ðN
1Þn
N

;
for n ¼ 0; 1; /; N  1
(4.11)
As shown in Figure 4.6, in time domain we use the sample number or time index n for indexing the digital
sample sequence xðnÞ. However, in the frequency domain, we use index k for indexing N calculated DFT
coefﬁcients XðkÞ. We also refer to k as the frequency bin number in Equations (4.7) and (4.8).
We can use MATLAB functions fft() and ifft() to compute the DFT coefﬁcients and the inverse DFT
with the syntax listed in Table 4.1.
The following examples serve to illustrate the application of DFT and the inverse DFT.
EXAMPLE 4.2
Given a sequence xðnÞ for 0  n  3, where xð0Þ
1, xð1Þ
2, xð2Þ
3, and xð3Þ
4, evaluate its DFT XðkÞ.
Solution:
Since N
4 and W4
ejp
2, using Equation (4.7) we have a simpliﬁed formula,
XðkÞ
X
3
n
0
xðnÞW kn
4
X
3
n
0
xðnÞejpkn
2
Table 4.1 MATLAB FFT Functions
X
fft(x)
% Calculate DFT coefﬁcients
x
ifft(X)
% Inverse of DFT
x
input vector
X
DFT coefﬁcient vector
4.1 Discrete Fourier Transform
93

Thus, for k
0
Xð0Þ
X
3
n
0
xðnÞej0
xð0Þej0 þ xð1Þej0 þ xð2Þej0 þ xð3Þej0
xð0Þ þ xð1Þ þ xð2Þ þ xð3Þ
1 þ 2 þ 3 þ 4
10
for k
1
Xð1Þ
X
3
n
0
xðnÞejpn
2
xð0Þej0 þ xð1Þejp
2 þ xð2Þejp þ xð3Þej3p
2
xð0Þ
jxð1Þ
xð2Þ þ jxð3Þ
1
j2
3 þ j4
2 þ j2
for k
2
Xð2Þ
X
3
n
0
xðnÞejpn
xð0Þej0 þ xð1Þejp þ xð2Þej2p þ xð3Þej3p
xð0Þ
xð1Þ þ xð2Þ
xð3Þ
1
2 þ 3
4
2
and for k
3
Xð3Þ
X
3
n
0
xðnÞej3pn
2
xð0Þej0 þ xð1Þej3p
2 þ xð2Þej3p þ xð3Þej9p
2
xð0Þ þ jxð1Þ
xð2Þ
jxð3Þ
1 þ j2
3
j4
2
j2
Let us verify the result using the MATLAB function fft():
>> X
fft([1 2 3 4 ])
X
10.0000
2.0000 þ 2.0000i
2.0000
2.0000
2.0000i
EXAMPLE 4.3
Using the DFT coefﬁcients XðkÞ for 0  k  3 computed in Example 4.2, evaluate the inverse DFT to determine the
time domain sequence xðnÞ.
Solution:
Since N
4 and W 1
4
ejp
2, using Equation (4.10) we achieve a simpliﬁed formula,
xðnÞ
1
4
X
3
k
0
XðkÞW nk
4
1
4
X
3
k
0
XðkÞejpkn
2
Then for n
0
xð0Þ
1
4
X
3
k
0
XðkÞej0
1
4

Xð0Þej0 þ Xð1Þej0 þ Xð2Þej0 þ Xð3Þej0
1
4 ð10 þ ð 2 þ j2Þ
2 þ ð 2
j2ÞÞ
1
94
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

for n
1
xð1Þ
1
4
X
3
k
0
XðkÞejkp
2
1
4

Xð0Þej0 þ Xð1Þejp
2 þ Xð2Þejp þ Xð3Þej3p
2

1
4 ðXð0Þ þ jXð1Þ
Xð2Þ
jXð3ÞÞ
1
4 ð10 þ jð 2 þ j2Þ
ð 2Þ
jð 2
j2ÞÞ
2
for n
2
xð2Þ
1
4
X
3
k
0
XðkÞejkp
1
4

Xð0Þej0 þ Xð1Þejp þ Xð2Þej2p þ Xð3Þej3p
1
4 ðXð0Þ
Xð1Þ þ Xð2Þ
Xð3ÞÞ
1
4 ð10
ð 2 þ j2Þ þ ð 2Þ
ð 2
j2ÞÞ
3
and for n
3
xð3Þ
1
4
X
3
k
0
XðkÞejkp3
2
1
4

Xð0Þej0 þ Xð1Þej3p
2 þ Xð2Þej3p þ Xð3Þej9p
2

1
4 ðXð0Þ
jXð1Þ
Xð2Þ þ jXð3ÞÞ
1
4 ð10
jð 2 þ j2Þ
ð 2Þ þ jð 2
j2ÞÞ
4
This example actually veriﬁes the inverse DFT. Applying the MATLAB function ifft() we obtain
>> x
ifft([10
2þ2j
2
2
2j])
x
1 2 3 4
Now we explore the relationship between the frequency bin k and its associated frequency.
Omitting the proof, the calculated N DFT coefﬁcients XðkÞ represent the frequency components
ranging from 0 Hz (or radians/second) to fs Hz (or us radians/second), hence we can map the frequency
bin k to its corresponding frequency as follows:
u ¼ kus
N
ðradians per secondÞ
(4.12)
or in terms of Hz,
f ¼ kfs
N ðHzÞ
(4.13)
where us ¼ 2pfs.
4.1 Discrete Fourier Transform
95

We can deﬁne the frequency resolution as the frequency step between two consecutive DFT
coefﬁcients to measure how ﬁne the frequency domain presentation is and obtain
Du ¼ us
N ðradians per secondÞ
(4.14)
or in terms of Hz, it follows that
Df ¼ fs
N ðHzÞ
(4.15)
Let us study the following example.
EXAMPLE 4.4
In Example 4.2, given a sequence xðnÞ for 0  n  3, where xð0Þ
1, xð1Þ
2, xð2Þ
3, and xð3Þ
4, we
computed 4 DFT coefﬁcients XðkÞ for 0  k  3 as Xð0Þ
10, Xð1Þ
2 þ j2, Xð2Þ
2, and
Xð3Þ
2
j2. If the sampling rate is 10 Hz,
a. determine the sampling period, time index, and sampling time instant for a digital sample xð3Þ in the time
domain;
b. determine the frequency resolution, frequency bin, and mapped frequencies for the DFT coefﬁcients Xð1Þ and
Xð3Þ in the frequency domain.
Solution:
a. In the time domain, the sampling period is calculated as
T
1=fs
1=10
0:1 second
For xð3Þ, the time index is n
3 and the sampling time instant is determined by
t
nT
3$0:1
0:3 second
b. In the frequency domain, since the total number of DFT coefﬁcients is four, the frequency resolution is
determined by
Df
fs
N
10
4
2:5 Hz
The frequency bin for Xð1Þ should be k
1 and its corresponding frequency is determined by
f
kfs
N
1  10
4
2:5 Hz
Similarly, for Xð3Þ and k
3,
f
kfs
N
3  10
4
7:5 Hz
Note that from Equation (4.4), k
3 is equivalent to k
N
3
4
1; and f
7.5 Hz is also equivalent to
the frequency f
ð 1  10Þ=4
2:5 Hz, which corresponds to the negative side spectrum. The amplitude
spectrum at 7.5 Hz after folding should match the one at fs
f
10:0
7:5
2:5 Hz. We will apply these
developed notations in the next section for amplitude and power spectral estimation.
96
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

4.2 AMPLITUDE SPECTRUM AND POWER SPECTRUM
One DFT application is transformation of a ﬁnite-length digital signal xðnÞ into the spectrum in
the frequency domain. Figure 4.7 demonstrates such an application, where Ak and Pk are
the computed amplitude spectrum and the power spectrum, respectively, using the DFT coefﬁ-
cients XðkÞ.
First, we obtain the digital sequence xðnÞ by sampling the analog signal xðtÞ and truncating the
sampled signal with a data window of length T0 ¼ NT, where T is the sampling period and N the
number of data points. The time for the data window is
T0 ¼ NT
(4.16)
For the truncated sequence xðnÞ with a range of n ¼ 0; 1; 2; /; N  1, we get
xð0Þ; xð1Þ; xð2Þ; .; xðN  1Þ
(4.17)
Next, we apply the DFT to the obtained sequence, xðnÞ, to get the N DFT coefﬁcients
XðkÞ ¼
X
N
1
n ¼ 0
xðnÞWnk
N ;
for k ¼ 0; 1; 2; /; N  1
(4.18)
Since each calculated DFT coefﬁcient is a complex number, it is not convenient to plot it versus
its frequency index. Hence, after evaluating Equation (4.18), the magnitude and phase of
each DFT coefﬁcient (we refer to them as the amplitude spectrum and phase spectrum,
respectively) can be determined and plotted versus its frequency index. We deﬁne the amplitude
spectrum as
Ak ¼ 1
N jXðkÞj ¼ 1
N
ðReal½XðkÞÞ2 þ ðImag½XðkÞÞ2
q
;
k ¼ 0; 1; 2; /; N  1
(4.19)
DSP
processing
DFT or FFT
Power
spectrum or
amplitude
spectrum
x n
( )
X k
( )
x n
( )
n
T
T
NT
0
N
1
k
N f
N
1
A
P
k
k
 or 
0
0
T
f s
1/
f
f
N
s /
N / 2
f
kf
N
s /
FIGURE 4.7
Applications of DFT/FFT.
4.2 Amplitude Spectrum and Power Spectrum
97

We can modify the amplitude spectrum to a one-side amplitude spectrum by doubling the amplitudes
in Equation (4.19), keeping the original DC term at k ¼ 0. Thus we have
Ak ¼
8
>
>
>
<
>
>
>
:
1
N jXð0Þj;
k ¼ 0
2
N jXðkÞj;
k ¼ 1; /; N=2
(4.20)
We can also map the frequency bin k to its corresponding frequency as
f ¼ kfs
N
(4.21)
Correspondingly, the phase spectrum is given by
fk ¼ tan 1
Imag½XðkÞ
Real½XðkÞ

;
k ¼ 0; 1; 2; /; N  1
(4.22)
Besides the amplitude spectrum, the power spectrum is also used. The DFT power spectrum is
deﬁned as
Pk ¼ 1
N2jXðkÞj2 ¼ 1
N2
n
ðReal½XðkÞÞ2þðImag½XðkÞÞ2o
;
k ¼ 0; 1; 2; /; N  1
(4.23)
Similarly, for a one-sided power spectrum, we get
Pk ¼
8
>
>
>
<
>
>
>
:
1
N2jXð0Þj2
k ¼ 0
2
N2jXðkÞj2
k ¼ 0; 1; /; N=2
(4.24)
and
f ¼ kfs
N
(4.25)
Again, notice that the frequency resolution, which denotes the frequency spacing between DFT
coefﬁcients in the frequency domain, is deﬁned as
Df ¼ fs
N ðHzÞ
(4.26)
It follows that better frequency resolution can be achieved by using a longer data sequence.
98
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

EXAMPLE 4.5
Consider the sequence in Figure 4.8. Assuming that fs
100 Hz, compute the amplitude spectrum, phase
spectrum, and power spectrum.
Solution:
Since N
4, and using the DFT shown in Example 4.1, we ﬁnd the DFT coefﬁcients to be
Xð0Þ
10
Xð1Þ
2 þ j2
Xð2Þ
2
Xð3Þ
2
j2
The amplitude spectrum, phase spectrum, and power density spectrum are computed as follows:
for k
0, f
k$fs=N
0  100=4
0 Hz,
A0
1
4 jXð0Þj
2:5; f0
tan1
Imag½Xð0Þ
Realð½Xð0Þ

00;
P0
1
42jXð0Þj2
6:25
for k
1, f
1  100=4
25 Hz,
A1
1
4 jXð1Þj
0:7071; f1
tan1
Imag½Xð1Þ
Real½Xð1Þ

1350;
P1
1
42jXð1Þj2
0:5000
for k
2, f
2  100=4
50 Hz,
A2
1
4 jXð2Þj
0:5; f2
tan1
Imag½Xð2Þ
Real½Xð2Þ

1800;
P2
1
42jXð2Þj2
0:2500
Similarly,
for k
3, f
3  100=4
75 Hz,
A3
1
4 jXð3Þj
0:7071; f3
tan1
Imag½Xð3Þ
Real½Xð3Þ

1350;
P3
1
42jXð3Þj2
0:5000:
Thus, the sketches for the amplitude spectrum, phase spectrum, and power spectrum are given in Figures 4.9A
and B.
x n
( )
0
1
2
3
1
2
n
2
1
4
5
3
4
4
3
2
T
NT
0
FIGURE 4.8
Sampled values in Example 4.5.
4.2 Amplitude Spectrum and Power Spectrum
99

Note that the folding frequency in this example is 50 Hz and the amplitude and power spectrum values at
75 Hz are each image counterparts (corresponding negative indexed frequency components), respectively. Thus
values at 0, 25, 50 Hz correspond to the positive indexed frequency components.
We can easily ﬁnd the one sided amplitude spectrum and one sided power spectrum as
A0
2:5; A1
1:4141; A2
1 and
P0
6:25; P1
2; P2
1
FIGURE 4.9A
Amplitude spectrum and phase spectrum in Example 4.5.
FIGURE 4.9B
Power density spectrum in Example 4.5.
100
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

We plot the one sided amplitude spectrum for comparison in Figure 4.10.
Note that in the one sided amplitude spectrum, the negative indexed frequency components are added back
to the corresponding positive indexed frequency components; thus each amplitude value other than the DC term is
doubled. It represents the frequency components up to the folding frequency.
EXAMPLE 4.6
Consider a digital sequence sampled at the rate of 10 kHz. If we use 1,024 data points and apply the 1,024 point
DFT to compute the spectrum,
a. determine the frequency resolution;
b. determine the highest frequency in the spectrum.
Solution:
a. Df
fs
N
10000
1024
9:776 Hz
b. The highest frequency is the folding frequency, given by
fmax
N
2Df
fs
2
512$9:776
5000 Hz:
As shown in Figure 4.7, the DFT coefﬁcients may be computed via a fast Fourier transform (FFT)
algorithm. The FFT is a very efﬁcient algorithm for computing DFT coefﬁcients. The FFT algorithm
requires a time domain sequence xðnÞ where the number of data points is equal to a power of 2; that is,
2m samples, where m is a positive integer. For example, the number of samples in xðnÞ can be
N ¼ 2; 4; 8; 16; etc.
When using the FFT algorithm to compute DFT coefﬁcients, where the length of the available data
is not equal to a power of 2 (as required by the FFT), we can pad the data sequence with zeros to create
Ak
k
0
1
2
2
4
f Hz
(
)
2 5.
14141
.
1
0
25
50
FIGURE 4.10
One-sided amplitude spectrum in Example 4.5.
4.2 Amplitude Spectrum and Power Spectrum
101

a new sequence with a larger number of samples, N ¼ 2m > N. The modiﬁed data sequence for
applying FFT, therefore, is
xðnÞ ¼
(
xðnÞ
0  n  N  1
0
N  n  N  1
(4.27)
It is very important to note that the signal spectra obtained via zero-padding the data sequence in
Equation (4.27) do not add any new information and do not contain more accurate signal spectral
presentation. In this situation, the frequency spacing is reduced due to more DFT points, and the
achieved spectrum is an interpolated version with “better display.” We illustrate the zero-padding
effect via the following example instead of theoretical analysis. A theoretical discussion of zero
padding in FFT can be found in Proakis and Manolakis (1996).
Figure 4.11(a) shows the 12 data samples from an analog signal containing frequencies of 10 Hz
and 25 Hz at a sampling rate of 100 Hz, and the amplitude spectrum obtained by applying the DFT.
Figure 4.11(b) displays the signal samples with padding of four zeros to the original data to make up
a data sequence of 16 samples, along with the amplitude spectrum calculated by FFT. The data
sequence padded with 20 zeros and its calculated amplitude spectrum using FFT are shown in
Figure 4.11(c). It is evident that increasing the data length via zero padding to compute the signal
spectrum does not add basic information and does not change the spectral shape but gives the
0
5
10
2
0
2
Number of samples
 Or g na  data
0
50
100
0
0.5
Frequency (Hz)
Amp tude spectrum
0
5
10
15
2
0
2
Number of samples
 Padd ng 4 zeros
0
50
100
0
0.5
Frequency (Hz)
Amp tude spectrum
0
10
20
30
2
0
2
Number of samples
 Padd ng 20 zeros
0
50
100
0
0.5
Frequency (Hz)
Amp tude spectrum
zero padding
zero padding
(a)
(b)
(c)
FIGURE 4.11
Zero-padding effect by using FFT.
102
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

“interpolated spectrum” with reduced frequency spacing. We can get a better view of the two spectral
peaks described in this case.
The only way to obtain the detailed signal spectrum with a ﬁne frequency resolution is to apply
more available data samples, that is, a longer sequence of data. Here, we choose to pad the least
number of zeros to satisfy the minimum FFT computational requirement. Let us look at another
example.
EXAMPLE 4.7
We use the DFT to compute the amplitude spectrum of a sampled data sequence with a sampling rate
fs
10 kHz. Given a requirement that the frequency resolution be less than 0.5 Hz, determine the number of data
points by using the FFT algorithm, assuming that the data samples are available.
Solution:
Df
0:5 Hz
N
fs
Df
10; 000
0:5
20; 000
Since we use the FFT to compute the spectrum, the number of data points must be a power of 2, that is,
N
215
32; 768
The resulting frequency resolution can be recalculated as
Df
fs
N
10; 000
32; 768
0:31 Hz:
Next, we study a MATLAB example.
EXAMPLE 4.8
Consider the sinusoid
xðnÞ
2$sin

2; 000p
n
8; 000

obtained by sampling the analog signal
xðtÞ
2$sinð2; 000ptÞ
with a sampling rate of fs
8,000 Hz,
a. Use the MATLAB DFT to compute the signal spectrum where the frequency resolution is equal to or less
than 8 Hz.
b. Use the MATALB FFT and zero padding to compute the signal spectrum, assuming that the data samples in
(a) are available.
4.2 Amplitude Spectrum and Power Spectrum
103

Solution:
a. The number of data points is
N
fs
Df
8; 000
8
1; 000
There is no zero padding needed if we use the DFT formula. The detailed implementation is given in Program 4.1.
The ﬁrst and second plots in Figure 4.12 show the two sided amplitude and power spectra, respectively, using the
DFT, where each frequency counterpart at 7,000 Hz appears. The third and fourth plots are the one sided
amplitude and power spectra, where the true frequency contents are displayed from 0 Hz to the Nyquist frequency
of 4 kHz (folding frequency).
b. If the FFT is used, the number of data points must be a power of 2. Hence we choose
N
210
1; 024
Assuming there are only 1,000 data samples available in (a), we need to pad 24 zeros to the original 1,000
data samples before applying the FFT algorithm, as required. Thus the calculated frequency resolution is
Df
fs=N
8; 000=1; 024
7:8125 Hz. Note that this is an interpolated frequency resolution by using zero
padding. The zero padding actually interpolates a signal spectrum and carries no additional frequency information.
Figure 4.13 shows the spectral plots using FFT. The detailed implementation is given in Program 4.1.
Program 4.1. MATLAB program for Example 4.8.
% Example 4.8
close all;clear all
% Generate the sine wave sequence
fs 8000;
% Sampling rate
N 1000;
% Number of data points
x 2*sin(2000*pi*[0:1:N 1]/fs);
% Apply the DFT algorithm
figure(1)
xf abs(fft(x))/N;
% Compute the amplitude spectrum
P xf.*xf;
% Compute power spectrum
f [0:1:N 1]*fs/N;
% Map the frequency bin to frequency (Hz)
subplot(2,1,1); plot(f,xf);grid
xlabel(’Frequency (Hz)’); ylabel(’Amplitude spectrum (DFT)’);
subplot(2,1,2);plot(f,P);grid
xlabel(’Frequency (Hz)’); ylabel(’Power spectrum (DFT)’);
figure(2)
% Convert it to one side spectrum
xf(2:N) 2*xf(2:N);
% Get the single side spectrum
P xf.*xf;
% Calculate the power spectrum
f [0:1:N/2]*fs/N
% Frequencies up to the folding frequency
subplot(2,1,1); plot(f,xf(1:N/2þ1));grid
xlabel(’Frequency (Hz)’); ylabel(’Amplitude spectrum (DFT)’);
subplot(2,1,2);plot(f,P(1:N/2þ1));grid
xlabel(’Frequency (Hz)’); ylabel(’Power spectrum (DFT)’);
figure (3)
% Zero padding to the length of 1024
x [x,zeros(1,23)];
N length(x);
xf abs(fft(x))/N;
% Compute amplitude spectrum with zero padding
P xf.*xf;
% Compute power spectrum
f [0:1:N 1]*fs/N;
% Map frequency bin to frequency (Hz)
subplot(2,1,1); plot(f,xf);grid
104
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

0
1000
2000
3000
4000
5000
6000
7000
8000
0
0.5
1
Frequency (Hz)
Amp tude spectrum (DFT)
0
1000
2000
3000
4000
5000
6000
7000
8000
0
0.2
0.4
0.6
0.8
1
Frequency (Hz)
Power spectrum (DFT)
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.5
1
1.5
2
Frequency (Hz)
Amp tude spectrum (DFT)
0
500
1000
1500
2000
2500
3000
3500
4000
0
1
2
3
4
Frequency (Hz)
Power spectrum (DFT)
FIGURE 4.12
Amplitude spectrum and power spectrum using DFT for Example 4.8.
4.2 Amplitude Spectrum and Power Spectrum
105

0
1000
2000
3000
4000
5000
6000
7000
8000
0
0.5
1
Frequency (Hz)
Amp tude spectrum (FFT)
0
1000
2000
3000
4000
5000
6000
7000
8000
0
0.2
0.4
0.6
0.8
1
Frequency (Hz)
Power spectrum (FFT)
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.5
1
1.5
2
Frequency (Hz)
Amp tude spectrum (FFT)
0
500
1000
1500
2000
2500
3000
3500
4000
0
1
2
3
4
Frequency (Hz)
Power spectrum (FFT)
FIGURE 4.13
Amplitude spectrum and power spectrum using FFT for Example 4.8.
106
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

xlabel(’Frequency (Hz)’); ylabel(’Amplitude spectrum (FFT)’);
subplot(2,1,2);plot(f,P);grid
xlabel(’Frequency (Hz)’); ylabel(’Power spectrum (FFT)’);
figure(4)
% Convert it to one side spectrum
xf(2:N) 2*xf(2:N);
P xf.*xf;
f [0:1:N/2]*fs/N;
subplot(2,1,1); plot(f,xf(1:N/2þ1));grid
xlabel(’Frequency (Hz)’); ylabel(’Amplitude spectrum (FFT)’);
subplot(2,1,2);plot(f,P(1:N/2þ1));grid
xlabel(’Frequency (Hz)’); ylabel(’Power spectrum (FFT)’);
4.3 SPECTRAL ESTIMATION USING WINDOW FUNCTIONS
When we apply DFT to the sampled data in the previous section, we theoretically imply the following
assumptions: ﬁrst, that the sampled data are periodic (repeat themselves), and second, that the sampled
data are continuous and band limited to the folding frequency. The second assumption is often
violated, and the discontinuity produces undesired harmonic frequencies. Consider a pure 1-Hz sine
wave with 32 samples shown in Figure 4.14.
As shown in the ﬁgure, if we use a window size of N ¼ 16 samples, which is a multiple of the two
waveform cycles, the second window has continuity with the ﬁrst. However, when the window size is
0
5
10
15
20
25
30
35
1
0.5
0
0.5
1
x(n)
Window size: N=16 (multiple of waveform cycles)
0
5
10
15
20
25
30
35
40
1
0.5
0
0.5
1
Window size: N=18 (not multiple of waveform cycles)
x(n)
FIGURE 4.14
Sampling a 1-Hz sine wave using (top) 16 samples per cycle and (bottom) 18 samples per cycle.
4.3 Spectral Estimation Using Window Functions
107

chosen to be 18 samples, which is not multiple of the waveform cycles (2.25 cycles), there is
a discontinuity in the second window. It is this discontinuity that produces harmonic frequencies
that are not present in the original signal. Figure 4.15 shows the spectral plots for both cases using the
DFT/FFT directly.
The ﬁrst spectral plot contains a single frequency, as we expected, while the second spectrum has
the expected frequency component plus many harmonics, which do not exist in the original signal.
We called such an effect spectral leakage. The amount of spectral leakage shown in the second plot
is due to amplitude discontinuity in time domain. The bigger the discontinuity, the more the leakage.
To reduce the effect of spectral leakage, a window function can be used whose amplitude tapers
smoothly and gradually toward zero at both ends. Applying the window function wðnÞ to a data
sequence xðnÞ to obtain the windowed sequence xwðnÞ is illustrated in Figure 4.16 using
Equation (4.28):
xwðnÞ ¼ xðnÞwðnÞ;
for n ¼ 0; 1; /; N  1
(4.28)
The top plot is the data sequence xðnÞ, and the middle plot is the window function wðnÞ. The bottom
plot in Figure 4.16 shows that the windowed sequence xwðnÞ is tapped down by a window function to
zero at both ends such that the discontinuity is dramatically reduced.
0
5
10
15
1
0.5
0
0.5
1
x(n)
Window size: N=16
0
5
10
15
0
0.2
0.4
0.6
0.8
Ak
Window size: N=16
0
5
10
15
1
0.5
0
0.5
1
x(n)
 Window size:N=18
0
5
10
15
0
0.2
0.4
Ak
Window size: N=18
FIGURE 4.15
Signal samples and spectra without spectral leakage and with spectral leakage.
108
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

EXAMPLE 4.9
In Figure 4.16, given
•
xð2Þ
1 and wð2Þ
0:2265
•
xð5Þ
0:7071 and wð5Þ
0:7008
calculate the windowed sequence data points xwð2Þ and xwð5Þ.
Solution:
Applying the window function operation leads to
xwð2Þ
xð2Þ  wð2Þ
1  0:2265
0:2265 and
xwð5Þ
xð5Þ  wð5Þ
0:7071  0:7008
0:4956
which agree with the values shown in the bottom plot in Figure 4.16.
Using the window function shown in Example 4.9, the spectral plot is reproduced. As a result, the
spectral leakage is greatly reduced, as shown in Figure 4.17.
The common window functions are listed as follows.
The rectangular window (no window function):
wRðnÞ ¼ 1; 0  n  N  1
(4.29)
0
2
4
6
8
10
12
14
16
-1
0
1
x(n)
0
2
4
6
8
10
12
14
16
0
0.5
1
Window w(n)
0
2
4
6
8
10
12
14
16
-1
0
1
Windowed xw(n)
Time index n
FIGURE 4.16
Illustration of the window operation.
4.3 Spectral Estimation Using Window Functions
109

The triangular window:
wtriðnÞ ¼ 1  j2n  N þ 1j
N  1
;
0  n  N  1
(4.30)
The Hamming window:
whmðnÞ ¼ 0:54  0:46cos
 2pn
N  1

;
0  n  N  1
(4.31)
The Hanning window:
whnðnÞ ¼ 0:5  0:5cos
 2pn
N  1

;
0  n  N  1
(4.32)
Plots for each window function for a size of 20 samples are shown in Figure 4.18.
The following example details each step for computing the spectral information using the window
functions.
0
5
10
15
1
0.5
0
0.5
1
x(n) (or g na  s gna )
 Time index n
0
5
10
15
0
0.2
0.4
Ak
Frequency index
0
5
10
15
1
0.5
0
0.5
1
W ndowed x(n)
Time index n
0
5
10
15
0
0.2
0.4
W ndowed Ak
Frequency index
FIGURE 4.17
Comparison of spectra calculated without using a window function and using a window function to reduce
spectral leakage.
110
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

EXAMPLE 4.10
Considering
the
sequence
xð0Þ
1,
xð1Þ
2,
xð2Þ
3,
xð3Þ
4,
and
given
fs
100
Hz,
T
0:01 seconds; compute the amplitude spectrum, phase spectrum, and power spectrum
a. using the triangle window function;
b. using the Hamming window function.
Solution:
a. Since N
4, from the triangular window function, we have
wtrið0Þ
1
j2  0
4 þ 1j
4
1
0
wtrið1Þ
1
j2  1
4 þ 1j
4
1
0:6667
Similarly, wtrið2Þ
0:6667, wtrið3Þ
0. Next, the windowed sequence is computed as
xwð0Þ
xð0Þ  wtrið0Þ
1  0
0
xwð1Þ
xð1Þ  wtrið1Þ
2  0:6667
1:3334
xwð2Þ
xð2Þ  wtrið2Þ
3  0:6667
2
xwð3Þ
xð3Þ  wtrið3Þ
4  0
0
0
5
10
15
20
0
0.2
0.4
0.6
0.8
1
Rectangu ar w ndow
0
5
10
15
20
0
0.2
0.4
0.6
0.8
1
Tr angu ar w ndow
0
5
10
15
20
0
0.2
0.4
0.6
0.8
1
Hamm ng w ndow
0
5
10
15
20
0
0.2
0.4
0.6
0.8
1
Hann ng w ndow
FIGURE 4.18
Plots of window sequences.
4.3 Spectral Estimation Using Window Functions
111

Applying DFT Equation (4.8) to xwðnÞ for k
0; 1; 2; 3, respectively,
XðkÞ
xwð0ÞW k0
4
þ xð1ÞW k1
4
þ xð2ÞW k2
4
þ xð3ÞW k3
4
We obtain the following results:
Xð0Þ
3:3334
Xð1Þ
2
j1:3334
Xð2Þ
0:6666
Xð3Þ
2 þ j1:3334
Df
1
NT
1
4$0:01
25 Hz
Applying Equations (4.19), (4.22), and (4.23) leads to
A0
1
4 jXð0Þj
0:8334; f0
tan1

0
3:3334

00;
P0
1
42jXð0Þj2
0:6954
A1
1
4 jXð1Þj
0:6009; f1
tan1
 1:3334
2

146:310;
P1
1
42jXð1Þj2
0:3611
A2
1
4 jXð2Þj
0:1667; f2
tan1

0
0:6666

00;
P1
1
42jXð2Þj2
0:0278
Similarly,
A3
1
4 jXð3Þj
0:6009; f3
tan1
1:3334
2

146:310;
P3
1
42jXð3Þj2
0:3611
b. Since N
4, from the Hamming window function, we have
whmð0Þ
0:54
0:46 cos
2p  0
4
1

0:08
whmðnÞ
0:54
0:46 cos
2p  1
4
1

0:77
Similarly,whmð2Þ
0:77, whmð3Þ
0:08. Next, the windowed sequence is computed as
xwð0Þ
xð0Þ  whmð0Þ
1  0:08
0:08
xwð1Þ
xð1Þ  whmð1Þ
2  0:77
1:54
xwð2Þ
xð2Þ  whmð2Þ
3  0:77
2:31
xwð0Þ
xð3Þ  whmð3Þ
4  0:08
0:32
Applying DFT Equation (4.8) to xwðnÞ for k
0; 1; 2; 3, respectively,
XðkÞ
xwð0ÞW k0
4
þ xð1ÞW k1
4
þ xð2ÞW k2
4
þ xð3ÞW k3
4
112
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

We obtain the following:
Xð0Þ
4:25
Xð1Þ
2:23
j1:22
Xð2Þ
0:53
Xð3Þ
2:23 þ j1:22
Df
1
NT
1
4$0:01
25 Hz
Applying Equations (4.19), (4.22), and (4.23), we achieve
A0
1
4 jXð0Þj
1:0625; f0
tan1
 0
4:25

00;
P0
1
42jXð0Þj2
1:1289
A1
1
4 jXð1Þj
0:6355; f1
tan1
 1:22
2:23

151:320;
P1
1
42jXð1Þj2
0:4308
A2
1
4 jXð2Þj
0:1325; f2
tan1
 0
0:53

00 ;
P2
1
42jXð2Þj2
0:0176
Similarly,
A3
1
4 jXð3Þj
0:6355; f3
tan1
 1:22
2:23

151:320;
P3
1
42jXð3Þj2
0:4308
EXAMPLE 4.11
Given the sinusoid
xðnÞ
2$sin

2; 000p
n
8; 000

obtained using a sampling rate of fs
8; 000 Hz, use the DFT to compute the spectrum with the following
speciﬁcations:
a. Compute the spectrum of a triangular window function with window size
50.
b. Compute the spectrum of a Hamming window function with window size
100.
c. Compute the spectrum of a Hanning window function with window size
150 and a one sided spectrum.
Solution:
The MATLAB program is listed in Program 4.2, and results are plotted in Figures 4.19 to 4.21. As compared with
the no window (rectangular window) case, all three windows are able to effectively reduce the spectral leakage, as
shown in the ﬁgures.
Program 4.2. MATLAB program for Example 4.11.
%Example 4.11
close all;clear all
% Generate the sine wave sequence
fs 8000; T 1/fs;
% Sampling rate and sampling period
x 2*sin(2000*pi*[0:1:50]*T);
% Generate 51 2000 Hz samples.
% Apply the FFT algorithm
N length(x);
4.3 Spectral Estimation Using Window Functions
113

index t [0:1:N 1];
f [0:1:N 1]*8000/N;
% Map frequency bin to frequency (Hz)
xf abs(fft(x))/N;
% Calculate amplitude spectrum
figure(1)
%Using Bartlett window
x b x.*bartlett(N)’;
% Apply triangular window function
xf b abs(fft(x b))/N;
% Calculate amplitude spectrum
subplot(2,2,1);plot(index t,x);grid
xlabel(’Time index n’); ylabel(’x(n)’);
subplot(2,2,3); plot(index t,x b);grid
xlabel(’Time index n’); ylabel(’Triangular windowed x(n)’);
subplot(2,2,2);plot(f,xf);grid;axis([0 8000 0 1]);
xlabel(’Frequency (Hz)’); ylabel(’Ak (no window)’);
subplot(2,2,4); plot(f,xf b);grid; axis([0 8000 0 1]);
xlabel(’Frequency (Hz)’); ylabel(’Triangular windowed Ak’);
figure(2)
% Generate the sine wave sequence
x 2*sin(2000*pi*[0:1:100]*T);
% Generate 101 2000 Hz samples.
% Apply the FFT algorithm
N length(x);
index t [0:1:N 1];
f [0:1:N 1]*fs/N;
xf abs(fft(x))/N;
% Using Hamming window
x hm x.*hamming(N)’;
% Apply Hamming window function
xf hm abs(fft(x hm))/N;
% Calculate amplitude spectrum
subplot(2,2,1);plot(index t,x);grid
xlabel(’Time index n’); ylabel(’x(n)’);
subplot(2,2,3); plot(index t,x hm);grid
xlabel(’Time index n’); ylabel(’Hamming windowed x(n)’);
subplot(2,2,2);plot(f,xf);grid;axis([0 fs 0 1]);
xlabel(’Frequency (Hz)’); ylabel(’Ak (no window)’);
subplot(2,2,4); plot(f,xf hm);grid;axis([0 fs 0 1]);
xlabel(’Frequency (Hz)’); ylabel(’Hamming windowed Ak’);
figure(3)
% Generate the sine wave sequence
x 2*sin(2000*pi*[0:1:150]*T);
% Generate 151 2 kHz samples
% Apply the FFT algorithm
N length(x);
index t [0:1:N 1];
f [0:1:N 1]*fs/N;
xf 2*abs(fft(x))/N;xf(1) xf(1)/2;
% Single sided spectrum
%Using Hanning window
x hn x.*hanning(N)’;
xf hn 2*abs(fft(x hn))/N;xf hn(1) xf hn(1)/2;
% Single sided spectrum
subplot(2,2,1);plot(index t,x);grid
xlabel(’Time index n’); ylabel(’x(n)’);
subplot(2,2,3); plot(index t,x hn);grid
xlabel(’Time index n’); ylabel(’Hanning windowed x(n)’);
subplot(2,2,2);plot(f(1:(N 1)/2),xf(1:(N 1)/2));grid;axis([0 fs/2 0 1]);
xlabel(’Frequency (Hz)’); ylabel(’Ak (no window)’);
subplot(2,2,4); plot(f(1:(N 1)/2),xf hn(1:(N 1)/2));grid;axis([0 fs/2 0 1]);
xlabel(’Frequency (Hz)’); ylabel(’Hanning windowed Ak’);
114
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

0
20
40
60
2
1
0
1
2
Time index n
x(n)
0
20
40
60
2
1
0
1
2
Time index n
Triangular windowed x(n)
0
2000
4000
6000
8000
0
0.5
1
Frequency (Hz)
Ak (no window)
0
2000
4000
6000
8000
0
0.2
0.4
0.6
0.8
1
Frequency (Hz)
Triangular windowed Ak
FIGURE 4.19
Comparison of a spectrum without using a window function and a spectrum using a triangular window with
50 samples in Example 4.11.
0
50
100
2
1
0
1
2
Time index n
x(n)
0
50
100
2
1
0
1
2
Time index n
Hamming windowed x(n)
0
2000
4000
6000
8000
0
0.5
1
Frequency (Hz)
Ak (no window)
0
2000
4000
6000
8000
0
0.2
0.4
0.6
0.8
1
Frequency (Hz)
Hamming windowed Ak
FIGURE 4.20
Comparison of a spectrum without using a window function and a spectrum using a Hamming window with
100 samples in Example 4.11.
4.3 Spectral Estimation Using Window Functions
115

4.4 APPLICATION TO SIGNAL SPECTRAL ESTIMATION
The following plots compare amplitude spectra for speech data (we.dat) with 2,001 samples and
a sampling rate of 8,000 Hz using the rectangular window (no window) function and the
Hamming window function. As demonstrated in Figure 4.22 (two-sided spectrum) and Figure 4.23
(one-sided spectrum), there is little difference between the amplitude spectrum using the
Hamming window function and the spectrum without using the window function. This is due to
the fact that when the data length of the sequence (e.g., 2,001 samples) increases, the frequency
resolution will be improved and the spectral leakage will become less signiﬁcant. However, when
data length is short, the reduction in spectral leakage using a window function will be more
prominent.
Next, we compute the one-sided spectrum for 32-bit seismic data sampled at 15 Hz (provided by
the US Geological Survey, Albuquerque Seismological Laboratory) with 6,700 data samples. The
computed spectral plots without using a window function and using the Hamming window are
displayed in Figure 4.24. We can see that most of seismic signal components are below 3 Hz.
0
50
100
150
2
1
0
1
2
Time index n
x(n)
0
50
100
150
2
1
0
1
2
Time index n
Hann ng w ndowed x(n)
0
1000
2000
3000
4000
0
0.5
1
1.5
2
Frequency (Hz)
Ak (no w ndow)
0
1000
2000
3000
4000
0
0.5
1
1.5
2
Frequency (Hz)
Hann ng w ndowed Ak
FIGURE 4.21
Comparison of a one-sided spectrum without using the window function and a one-sided spectrum using
a Hanning window with 150 samples in Example 4.11.
116
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

0
500
1000
1500
2000
-1
-0.5
0
0.5
1
x 10
4
Time index n
x(n)
0
500
1000
1500
2000
-5000
0
5000
10000
Time index n
Hamming windowed x(n)
0
2000
4000
6000
8000
0
100
200
300
400
Frequency (Hz)
Amplitude spectrum Ak
0
2000
4000
6000
8000
0
100
200
300
400
Frequency (Hz)
Hamming windowed Ak
FIGURE 4.22
Comparison of a spectrum without using a window function and a spectrum using the Hamming window for
speech data.
0
500
1000
1500
2000
-1
-0.5
0
0.5
1
x 10
4
Time index n
x(n)
0
500
1000
1500
2000
-5000
0
5000
10000
Time index n
Hamming windowed x(n)
0
1000
2000
3000
0
200
400
600
800
Frequency (Hz)
Amplitude spectrum Ak
0
1000
2000
3000
0
200
400
600
800
Frequency (Hz)
Hamming windowed Ak
FIGURE 4.23
Comparison of a one-sided spectrum without using a window function and a one-sided spectrum using the
Hamming window for speech data.
4.4 Application to Signal Spectral Estimation
117

0
2000
4000
6000
8000
-5
0
5
x 10
5
Time index n
x(n)
0
2000
4000
6000
8000
-4
-2
0
2
4
x 10
5
Time index n
Hamming windowed x(n)
0
2
4
6
0
2000
4000
6000
Frequency (Hz)
Amplitude spectrum Ak
0
2
4
6
0
2000
4000
6000
Frequency (Hz)
Hamming windowed Ak
FIGURE 4.24
Comparison of a one-sided spectrum without using a window function and a one-sided spectrum using the
Hamming window for seismic data.
0
2000
4000
6000
-5000
0
5000
10000
Time index n
x(n)
0
2000
4000
6000
-5000
0
5000
10000
Time index n
Hamming windowed x(n)
0
100
200
0
200
400
600
Frequency (Hz)
Amplitude spectrum Ak
0
100
200
0
200
400
600
Frequency (Hz)
Hamming windowed Ak
60-Hz interference
60-Hz interference
FIGURE 4.25
Comparison of a one-sided spectrum without using a window function and a one-sided spectrum using the
Hamming window for electrocardiogram data.
118
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

We also compute the one-sided spectrum for a standard electrocardiogram (ECG) signal from the
MIT BIH (Massachusetts Institute of Technology Beth Israel Hospital) Database. The ECG signal
contains frequency components ranging from 0.05 to 100 Hz sampled at 500 Hz. As shown in
Figure 4.25, there is a spike located at 60 Hz. This is due to the 60-Hz power line interference when the
ECG is acquired via the ADC acquisition process. This 60-Hz interference can be removed by using
a digital notch ﬁlter, which will be studied in Chapter 8.
Figure 4.26 shows a vibration signal and its spectrum. The vibration signal is captured using an
accelerometer sensor attached to a simple supported beam while an impulse force is applied to
a location that is close to the middle of the beam. The sampling rate is 1 kHz. As shown in Figure 4.26,
four dominant modes (natural frequencies corresponding to locations of spectral peaks) can be easily
identiﬁed from the displayed spectrum.
We now present another practical example for vibration signature analysis of a defective gear
tooth, described in Section 1.3.5. Figure 4.27 shows a gearbox containing two straight bevel gears
with a transmission ratio of 1.5:1 and the number of teeth on the pinion and gear are 18 and 27.
The vibration data is collected by an accelerometer installed on the top of the gearbox. The
data acquisition system uses a sampling rate of 12.8 kHz. The meshing frequency is determined as
fm ¼ fiðRPMÞ  18=60 ¼ 300 Hz, where the input shaft frequency is fi ¼ 1000 RPM ¼ 16:67Hz.
Figures 4.28 4.31 show the baseline vibration signal and spectrum for a gearbox in good condition,
0
500
1000
1500
2000
1
0.5
0
0.5
1
Time index n
x(n)
0
500
1000
1500
2000
1
0.5
0
0.5
1
Time index n
Hamm ng w ndowed x(n)
0
100
200
300
400
500
0
0.01
0.02
0.03
0.04
Frequency (Hz)
Amp tude spectrum Ak
0
100
200
300
400
500
0
0.01
0.02
0.03
0.04
Frequency (Hz)
Hamm ng w ndowed Ak
Components corresponding
 to natural frequencies
Components corresponding
to natural frequencies
FIGURE 4.26
Comparison of a one-sided spectrum without using a window function and a one-sided spectrum using the
Hamming window for vibration signal.
4.4 Application to Signal Spectral Estimation
119

along with the vibration signals and spectra for three different damage severity levels (there are ﬁve
levels classiﬁed by SpectraQuest, Inc; the spectrums shown are for severity level 1 [lightly chipped];
severity level 4 [heavily chipped]; and severity level 5 [missing tooth]). As we can see, the baseline
spectrum contains the meshing frequency component of 300 Hz and a sideband frequency compo-
nent of 283.33 Hz (300 16.67). We can observe that the sidebands (fm  fi, fm  2fi .) become
more dominant when the severity level increases. Hence, the spectral information is very useful for
monitoring the health condition of the gearbox.
(a) Gearbox 
 
 
 
 
(b) Pinion and gear 
 
        (c) Damaged pinion 
missing tooth
FIGURE 4.27
Vibration signature analysis of a gearbox.
(Courtesy of SpectaQuest, Inc.)
120
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

0
2
4
6
8
10
12
14
0.5
0
0.5
Time (sec.)
Amplitude (V)
0
1000
2000
3000
4000
5000
6000
7000
0
0.01
0.02
Frequency (Hz)
Amplitude (VRMS)
250
260
270
280
290
300
310
320
330
340
350
0
0.01
0.02
Zoomed Frequency (Hz)
Amplitude (VRMS)
Meshing frequency
Meshing frequency
Sideband frequency fm fi
FIGURE 4.28
Vibration signal and spectrum from the good condition gearbox.
(Data provided by SpectaQuest, Inc.)
0
2
4
6
8
10
12
14
1
0
1
Time (sec.)
Amplitude (V)
0
1000
2000
3000
4000
5000
6000
7000
0
0.01
0.02
Frequency (Hz)
Amplitude (VRMS)
250
260
270
280
290
300
310
320
330
340
350
0
0.01
0.02
Zoomed Frequency (Hz)
Amplitude (VRMS)
Meshing frequency
Meshing frequency
Sidebands
Sidebands
FIGURE 4.29
Vibration signal and spectrum for damage severity level 1.
(Data provided by SpectaQuest, Inc.)
4.4 Application to Signal Spectral Estimation
121

0
2
4
6
8
10
12
14
1
0
1
Time (sec.)
Amplitude (V)
0
1000
2000
3000
4000
5000
6000
7000
0
0.005
0.01
Frequency (Hz)
Amplitude (VRMS)
250
260
270
280
290
300
310
320
330
340
350
0
0.01
0.02
Zoomed Frequency (Hz)
Amplitude (VRMS)
Meshing frequency
Meshing frequency
Sidebands
Sidebands
FIGURE 4.30
Vibration signal and spectrum for damage severity level 4.
(Data provided by SpectaQuest, Inc.)
0
2
4
6
8
10
12
14
2
0
2
Time (sec.)
Amplitude (V)
0
1000
2000
3000
4000
5000
6000
7000
0
0.02
0.04
Frequency (Hz)
Amplitude (VRMS)
250
260
270
280
290
300
310
320
330
340
350
0
0.01
0.02
Zoomed Frequency (Hz)
Amplitude (VRMS)
Meshing frequency
Meshing frequency
Sidebands
Sidebands
FIGURE 4.31
Vibration signal and spectrum for damage severity level 5.
(Data provided by SpectaQuest, Inc.)
122
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

4.5 FAST FOURIER TRANSFORM
Now we study FFT in detail. FFT is a very efﬁcient algorithm in computing DFT coefﬁcients and can
reduce a very large amount of computational complexity (multiplications). Without loss of generality,
we consider the digital sequence xðnÞ consisting of 2m samples, where m is a positive integer, that is,
the number of samples of the digital sequence xðnÞ is a power of 2, N ¼ 2; 4; 8; 16; etc. If xðnÞ does
not contain 2m samples, then we simply append it with zeros until the number of the appended
sequence is a power of 2.
In this section, we focus on two formats. One is called the decimation-in-frequency algorithm,
while the other is the decimation-in-time algorithm. They are referred to as the radix-2 FFTalgorithms.
Other types of FFT algorithms are the radix-4 and the split radix and their advantages can be explored
in more detail in other texts (see Proakis and Manolakis, 1996).
4.5.1 Decimation-in-Frequency Method
We begin with the deﬁnition of DFT studied in the opening section in this chapter:
XðkÞ ¼
X
N
1
n ¼ 0
xðnÞWkn
N
for
k ¼ 0; 1; /; N  1
(4.33)
where WN ¼ e j2p
N is the twiddle factor, and N ¼ 2; 4; 8; 16; /. Equation (4.33) can be expanded as
XðkÞ ¼ xð0Þ þ xð1ÞWk
N þ / þ xðN  1ÞWkðN
1Þ
N
(4.34)
Again, if we split Equation (4.34) into
XðkÞ ¼ xð0Þ þ xð1ÞWk
N þ / þ x
N
2  1

WkðN=2 1Þ
N
þx
N
2

WkN=2 þ / þ xðN  1ÞWkðN
1Þ
N
(4.35)
then we can rewrite it as a sum of the following two parts:
XðkÞ ¼
X
ðN=2Þ 1
n ¼ 0
xðnÞWkn
N þ
X
N
1
n ¼ N=2
xðnÞWkn
N
(4.36)
Modifying the second term in Equation (4.36) yields
XðkÞ ¼
X
ðN=2Þ 1
n ¼ 0
xðnÞWkn
N þ WðN=2Þk
N
X
ðN=2Þ 1
n ¼ 0
x

n þ N
2

Wkn
N
(4.37)
4.5 Fast Fourier Transform
123

Recall WN=2
N
¼ e j2pðN=2Þ
N
¼ e jp ¼ 1 ; then we have
XðkÞ ¼
X
ðN=2Þ 1
n ¼ 0

xðnÞ þ ð1Þkx

n þ N
2

Wkn
N
(4.38)
Now letting k ¼ 2m be an even number we obtain
Xð2mÞ ¼
X
ðN=2Þ 1
n ¼ 0

xðnÞ þ x

n þ N
2

W2mn
N
(4.39)
while substituting k ¼ 2m þ 1 (an odd number) yields
Xð2m þ 1Þ ¼
X
ðN=2Þ 1
n ¼ 0

xðnÞ  x

n þ N
2

Wn
NW2mn
N
(4.40)
Using the fact that W2
N ¼ e j2p2
N
¼ e j 2p
ðN=2Þ ¼ WN=2, it follows that
Xð2mÞ ¼
X
ðN=2Þ 1
n ¼ 0
aðnÞWmn
N=2 ¼ DFTfaðnÞwithðN=2Þpointsg
(4.41)
Xð2m þ 1Þ ¼
X
ðN=2Þ 1
n ¼ 0
bðnÞWn
NWmn
N=2 ¼ DFT

bðnÞWn
N with ðN=2Þpoints

(4.42)
where aðnÞ and bðnÞ are introduced and expressed as
aðnÞ ¼ xðnÞ þ x

n þ N
2

;
for n ¼ 0; 1/; N
2  1
(4.43a)
bðnÞ ¼ xðnÞ  x

n þ N
2

;
for n ¼ 0; 1; /; N
2  1
(4.43b)
Equations (4.33), (4.41), and (4.42) can be summarized as
DFTfxðnÞ with N pointsg ¼
(
DFTfaðnÞ with ðN=2Þ pointsg
DFT

bðnÞ Wn
N with ðN=2Þ points

(4.44)
The computation process is illustrated in Figure 4.32. As shown in this ﬁgure, there are three graphical
operations, which are illustrated Figure 4.33.
If we continue the process described by Figure 4.32, we obtain the block diagrams shown in Figures
4.34 and 4.35.
Figure 4.35 illustrates the FFT computation for the eight-point DFT, where there are 12 complex
multiplications. This is a big saving as compared with the eight-point DFT with 64 complex
124
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

x( )
0
x( )1
x( )3
x( )
4
x( )5
x( )
6
x( )
7
x( )
2
a( )
0
a( )1
a( )
2
a( )3
b( )
0
b( )1
b( )
2
b( )3
WN
0
WN
1
WN
2
WN
3
N
2 - point
N
2 - point
DFT
DFT
1
1
1
1
X ( )
0
X ( )
2
X ( )
4
X ( )
6
X ( )1
X ( )3
X ( )5
X ( )
7
FIGURE 4.32
The ﬁrst iteration of the eight-point FFT.
x
y
z
x
y
1
x
y
z
x
y
x
w
z
wx
FIGURE 4.33
Deﬁnitions of the graphical operations.
x( )
0
x( )1
x( )3
x( )
4
x( )5
x( )
6
x( )
7
x( )
2
WN
0
WN
1
WN
2
WN
3
N
4 - point
DFT
1
1
1
1
X ( )
0
X ( )
4
X ( )
2
X ( )
6
X ( )1
X ( )5
X ( )3
X ( )
7
N
4 - point
DFT
N
4 - point
DFT
N
4 - point
DFT
WN
0
WN
0
WN
2
WN
2
1
1
1
1
FIGURE 4.34
The second iteration of the eight-point FFT.
X ( )
0
X ( )
4
X ( )
2
X ( )
6
X ( )1
X ( )5
X ( )3
X ( )
7
WN
0
WN
0
WN
0
WN
0
1
1
1
1
x( )
0
x( )1
x( )3
x( )
4
x( )5
x( )
6
x( )
7
x( )
2
WN
0
WN
1
WN
2
WN
3
1
1
1
1
WN
0
WN
0
WN
2
WN
2
1
1
1
1
FIGURE 4.35
Block diagram for the eight-point FFT (total 12 multiplications).
4.5 Fast Fourier Transform
125

multiplications. For a data length of N, the number of complex multiplications for DFT and FFT,
respectively, are determined by
Complex multiplications of DFT ¼ N2; and
Complex multiplications of FFT ¼ N
2 log2ðNÞ
To see the effectiveness of FFT, let us consider a sequence with 1,024 data points. Applying DFT
will require 1; 024  1; 024 ¼ 1; 048; 576 complex multiplications; however, applying FFT will
require only ð1024=2Þlog2ð1; 024Þ ¼ 5; 120 complex multiplications. Next, the index (bin
number) of the eight-point DFT coefﬁcient XðkÞ becomes 0, 4, 2, 6, 1, 5, 3, and 7, respectively,
which is not the natural order. This can be ﬁxed by index matching. The index matching between
the input sequence and output frequency bin number by applying reversal bits is described in
Table 4.2.
Figure 4.36 explains the bit reversal process. First, the input data with indices 0, 1, 2, 3, 4, 5, 6, 7 are
split into two parts. The ﬁrst half contains even indices
0, 2, 4, 6
while the second half contains odd
indices. The ﬁrst half with indices 0, 2, 4, 6 at the ﬁrst iteration continues to be split into even indices 0,
4 and odd indices 2, 6 as shown in the second iteration. The second half with indices 1, 3, 5, 7 at the
ﬁrst iteration is split to even indices 1, 5 and odd indices 3, 7 in the second iteration. The splitting
process continues to the end at the third iteration. The bit patterns of the output data indices are just the
respective reversed bit patterns of the input data indices.
Although Figure 4.36 illustrates the case of an eight-point FFT, this bit reversal process works as
long as N is a power of 2.
The inverse FFT is deﬁned as
xðnÞ ¼ 1
N
X
N
1
k ¼ 0
XðkÞW
kn
N
¼ 1
N
X
N
1
k ¼ 0
XðkÞ ~
Wkn
N ;
for k ¼ 0; 1; /; N  1
(4.45)
Table 4.2 Index Mapping for Fast Fourier Transform
Input Data
Index Bits
Reversal Bits
Output Data
xð0Þ
000
000
Xð0Þ
xð1Þ
001
100
Xð4Þ
xð2Þ
010
010
Xð2Þ
xð3Þ
011
110
Xð6Þ
xð4Þ
100
001
Xð1Þ
xð5Þ
101
101
Xð5Þ
xð6Þ
110
011
Xð3Þ
xð7Þ
111
111
Xð7Þ
126
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

Comparing Equation (4.45) with Equation (4.33), we notice the difference as follows: the twiddle
factor WN is changed to ~
WN ¼ W
1
N , and the sum is multiplied by a factor of 1=N. Hence, by
modifying the FFT block diagram as shown in Figure 4.35, we achieve the inverse FFT block diagram
shown in Figure 4.37.
EXAMPLE 4.12
Given a sequence xðnÞ for 0  n  3, where xð0Þ
1, xð1Þ
2, xð2Þ
3, and xð3Þ
4,
a. evaluate its DFT XðkÞ using the decimation in frequency FFT method;
b. determine the number of complex multiplications.
Solution:
a. Using the FFT block diagram in Figure 4.35, the result is shown in Figure 4.38.
b. From Figure 4.38, the number of complex multiplications is four, which can also be determined by
N
2 log2ðNÞ
4
2 log2ð4Þ
4
2
4
6
0
4
2
6
0
5
3
7
1
4
0
6
2
5
1
7
3
3
5
7
1
1
2
3
0
5
6
7
4
Binary
001
010
011
000
101
110
111
100
Bit reversal
100
010
011
000
101
011
111
001
1st split 2nd split
3rd split
index
FIGURE 4.36
Bit reversal process in FFT.
x( )
0
x( )
4
x( )
2
x( )
6
x( )1
x( )5
x( )3
x( )
7
~
WN
0
~
WN
0
~
WN
0
~
WN
0
1
1
1
1
X ( )
0
X ( )1
X ( )3
X ( )
4
X ( )5
X ( )
6
X ( )
7
X ( )
2
~
WN
0
~
WN
1
~
WN
2
~
WN
3
1
1
1
1
~
WN
0
~
WN
0
~
WN
2
~
WN
2
1
1
1
1
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
FIGURE 4.37
Block diagram for the inverse of eight-point FFT.
4.5 Fast Fourier Transform
127

EXAMPLE 4.13
Given the DFT sequence XðkÞ for 0  k  3 computed in Example 4.12, evaluate its inverse DFT xðnÞ using the
decimation in frequency FFT method.
Solution:
Using the inverse FFT block diagram in Figure 4.37, we have the result shown in Figure 4.39.
4.5.2 Decimation-in-Time Method
In this method, we split the input sequence xðnÞ into the even indexed xð2mÞ and xð2m þ 1Þ, each with
N data points. Then Equation (4.33) becomes
XðkÞ ¼
X
ðN=2Þ 1
m ¼ 0
xð2mÞW2mk
N
þ
X
ðN=2Þ 1
m ¼ 0
xð2m þ 1ÞWk
NW2mk
N
;
for k ¼ 0; 1; /; N  1
(4.46)
X ( )
0
X ( )1
X( )
2
X ( )3
W4
0
1
1
1
x( )
0
1
x( )1
2
x( )3
4
x( )
2
3
W4
0
1
W
j
4
1
1
1
4
6
2
2
W4
0
1
10
2
2
2
j
2
2
j
Bit index
00
01
10
11
Bit reversal
00
10
01
11
FIGURE 4.38
Four-point FFT block diagram in Example 4.12.
x( )
0
1
x( )
2
3
x( )1
2
x( )
4
4
W4
0
1
~
W4
0
1
1
1
X ( )
0
10
X
j
( )1
2
2
X
j
( )3
2
2
X ( )
2
2
~
W4
0
1
~
W
j
4
1
1
1
1
4
Bit reversal
00
10
01
11
Bit index
00
01
10
11
8
4
12
j4
4
12
8
16
1
4
1
4
1
4
FIGURE 4.39
Four-point inverse FFT block diagram in Example 4.13.
128
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

Using the relation W2
N ¼ WN=2, it follows that
XðkÞ ¼
X
ðN=2Þ 1
m ¼ 0
xð2mÞWmk
N=2 þ Wk
N
X
ðN=2Þ 1
m ¼ 0
xð2m þ 1ÞWmk
N=2 ;
for k ¼ 0; 1; /; N  1
(4.47)
Deﬁne new functions as
GðkÞ ¼
X
ðN=2Þ 1
m ¼ 0
xð2mÞWmk
N=2 ¼ DFTfxð2mÞ with ðN=2Þ pointsg
(4.48)
HðkÞ ¼
X
ðN=2Þ 1
m ¼ 0
xð2m þ 1ÞWmk
N=2 ¼ DFTfxð2m þ 1Þ with ðN=2Þ pointsg
(4.49)
Note that
GðkÞ ¼ G

k þ N
2

;
for k ¼ 0; 1; /; N
2  1
(4.50)
HðkÞ ¼ H

k þ N
2

;
for k ¼ 0; 1; /; N
2  1
(4.51)
Substituting Equations (4.50) and (4.51) into Equation (4.47) yields the ﬁrst half frequency bins
XðkÞ ¼ GðkÞ þ Wk
NHðkÞ;
for k ¼ 0; 1; /; N
2  1
(4.52)
Considering Equations (4.50) and (4.51) and the fact that
WðN=2þkÞ
N
¼ Wk
N
(4.53)
the second half of frequency bins can be computed as follows:
X
N
2 þ k

¼ GðkÞ  Wk
NHðkÞ;
for k ¼ 0; 1; /; N
2  1
(4.54)
If we perform backward iterations, we can obtain the FFT algorithm. The procedure using Equations
(4.52) and (4.54) is illustrated in Figure 4.40, the block diagram for the eight-point FFT algorithm.
From a further computation, we obtain Figure 4.41. Finally, after three recursions, we end up with the
block diagram in Figure 4.42.
The index for each input sequence element can be achieved by bit reversal of the frequency index in
sequential order. Similar to the decimation-in-frequency method, after we change WN to ~
WN in
Figure 4.42 and multiply the output sequence by a factor of 1=N, we derive the inverse FFT block
diagram for the eight-point inverse FFT in Figure 4.43.
4.5 Fast Fourier Transform
129

x( )
0
x( )1
x( )3
x( )
4
x( )5
x( )
6
x( )
7
x( )
2
1
1
X ( )
0
X ( )
4
X ( )
2
X ( )
6
X ( )1
X ( )5
X ( )3
X ( )
7
WN
0
WN
2
WN
0
WN
1
WN
2
WN
3
WN
0
WN
2
2 point
DFT
2 point
DFT
2 point
DFT
2 point
DFT
1
1
1
1
1
1
FIGURE 4.41
The second iteration.
W8
0
W8
0
W8
1
W8
2
W8
3
W8
0
W8
2
1
x( )
0
x( )1
x( )3
x( )
4
x( )5
x( )
6
x( )
7
x( )
2
W8
0
W8
2
W8
0
X ( )
0
X ( )
2
X ( )
4
X ( )
6
X ( )1
X ( )3
X ( )5
X ( )
7
W8
0
W8
0
1
1
1
1
1
1
1
1
1
1
1
FIGURE 4.42
The eight-point FFT algorithm using decimation-in-time (12 complex multiplications).
x( )
0
x( )1
x( )3
x( )
4
x( )5
x( )
6
x( )
7
x( )
2
G( )
0
G( )1
G( )
2
G( )3
H( )
0
H( )1
H( )
2
H( )3
WN
0
WN
1
WN
2
WN
3
4 - point
4 - point
DFT
DFT
X ( )
0
X ( )
2
X ( )
4
X ( )
6
X ( )1
X ( )3
X ( )5
X ( )
7
1
1
1
1
FIGURE 4.40
The ﬁrst iteration.
130
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

EXAMPLE 4.14
Given a sequence xðnÞ for 0  n  3, where xð0Þ
1, xð1Þ
2, xð2Þ
3, and xð3Þ
4, evaluate its DFT XðkÞ
using the decimation in time FFT method.
Solution:
Using the block diagram in Figure 4.42 leads to the result shown in Figure 4.44.
EXAMPLE 4.15
Given the DFT sequence XðkÞ for 0  k  3 computed in Example 4.14, evaluate its inverse DFT xðnÞ using the
decimation in time FFT method.
Solution:
Using the block diagram in Figure 4.43 yields Figure 4.45.
~
W8
0
~
W8
0
~
W8
0
~
W8
0
~
W8
1
~
W8
2
~
W8
3
~
W8
0
~
W8
2
1
x( )
0
x( )1
x( )3
x( )
4
x( )5
x( )
6
x( )
7
x( )
2
~
W8
0
~
W8
2
~
W8
0
X ( )
0
X ( )
2
X ( )
4
X ( )
6
X ( )1
X ( )3
X ( )5
X ( )
7
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
1
1
1
1
1
1
1
1
1
1
FIGURE 4.43
The eight-point IFFT using decimation-in-time.
W4
0
1
W4
0
1
W4
0
1
W
j
4
1
1
x( )
0
1
x( )1
2
x( )3
4
x( )
2
3
X ( )
0
X ( )
2
X ( )1
X ( )3
4
2
6
2
10
2
2
j
2
2
2
j
1
1
1
FIGURE 4.44
The four-point FFT using decimation-in-time.
~
W4
0
1
~
W4
0
1
~
W4
0
1
~
W
j
4
1
1
X ( )
0
10
X
j
( )1
2
2
X
j
( )3
2
2
X ( )
2
2
x( )
0
1
x( )
2
3
x( )1
2
x( )3
4
8
12
4
j4
4
8
12
16
1
4
1
4
1
4
1
4
1
1
1
FIGURE 4.45
The four-point IFFT using decimation-in-time.
4.5 Fast Fourier Transform
131

4.6 SUMMARY
1. The Fourier series coefﬁcients for a periodic digital signal can be used to develop the DFT.
2. The DFT transforms a time sequence to the complex DFT coefﬁcients, while the inverse DFT
transforms DFT coefﬁcients back to the time sequence.
3. The frequency bin number is the same as the frequency index. Frequency resolution is the
frequency spacing between two consecutive frequency indices (two consecutive spectrum
components).
4. The DFT coefﬁcients for a given digital signal are applied to compute the amplitude spectrum,
power spectrum, or phase spectrum.
5. The spectrum calculated from all the DFT coefﬁcients represents the signal frequency range from 0
Hz to the sampling rate. The spectrum beyond the folding frequency is equivalent to the negative-
indexed spectrum from the negative folding frequency to 0 Hz. This two-sided spectrum can be
converted into a single-sided spectrum by doubling alternation-current (AC) components from 0
Hz to the folding frequency and retaining the DC component as is.
6. To reduce the burden of computing DFT coefﬁcients, the FFT algorithm is used, which requires the
data length to be a power of 2. Sometimes zero padding is employed to make up the data length.
The zero padding actually interpolates the spectrum and does not carry any new information about
the signal; even the calculated frequency resolution is smaller due to the zero-padded longer length.
7. Applying a window function to the data sequence before DFT reduces the spectral leakage due to
abrupt truncation of the data sequence when performing spectral calculation for a short sequence.
8. Two radix-2 FFT algorithms
decimation-in-frequency and decimation-in-time
are developed
via graphical illustrations.
4.7 PROBLEMS
4.1. Given a sequence xðnÞ for 0  n  3, where xð0Þ ¼ 1, xð1Þ ¼ 1, xð2Þ ¼ 1, and xð3Þ ¼ 0,
compute its DFT XðkÞ.
4.2. Given a sequence xðnÞ for 0  n  3, where xð0Þ ¼ 4, xð1Þ ¼ 3, xð2Þ ¼ 2, and xð3Þ ¼ 1,
evaluate its DFT XðkÞ.
4.3. Given a sequence xðnÞ for 0  n  3, where xð0Þ ¼ 0:2, xð1Þ ¼ 0:2, xð2Þ ¼ 0:2, and
xð3Þ ¼ 0, compute its DFT XðkÞ.
4.4. Given a sequence xðnÞ for 0  n  3, where xð0Þ ¼ 0:8, xð1Þ ¼ 0:6, xð2Þ ¼ 0:4, and
xð3Þ ¼ 0:2, evaluate its DFT XðkÞ.
4.5. Given the DFT sequence XðkÞ for 0  k  3 obtained in Problem 4.2, evaluate its inverse
DFT xðnÞ.
4.6. Given a sequence xðnÞ, where xð0Þ ¼ 4,xð1Þ ¼ 3, xð2Þ ¼ 2, and xð3Þ ¼ 1 with two
additional zero-padded data points xð4Þ ¼ 0 and xð5Þ ¼ 0, evaluate its DFT XðkÞ.
4.7. Given the DFT sequence XðkÞ for 0  k  3 obtained in Problem 4.4, evaluate its inverse
DFT xðnÞ.
132
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

4.8. Given a sequence xðnÞ, where xð0Þ ¼ 0:8, xð1Þ ¼ 0:6, xð2Þ ¼ 0:4, and xð3Þ ¼ 0:2 with
two additional zero-padded data points xð4Þ ¼ 0 and xð5Þ ¼ 0, evaluate its DFT XðkÞ.
4.9. Using the DFT sequence XðkÞ for 0  k  5 computed in Problem 4.6, evaluate the inverse
DFT for xð0Þ and xð4Þ.
4.10. Consider a digital sequence sampled at the rate of 20,000 Hz. If we use the 8,000-point DFT
to compute the spectrum, determine
a. the frequency resolution;
b. the folding frequency in the spectrum.
4.11. Using the DFT sequence XðkÞ for 0  k  5 computed in Problem 4.8, evaluate the inverse
DFT for xð0Þ and xð4Þ.
4.12. Consider a digital sequence sampled at the rate of 16,000 Hz. If we use the 4,000-point DFT
to compute the spectrum, determine
a. the frequency resolution;
b. the folding frequency in the spectrum.
4.13. We use the DFT to compute the amplitude spectrum of a sampled data sequence with
a sampling rate fs ¼ 2; 000 Hz. It requires the frequency resolution to be less than 0.5 Hz.
Determine the number of data points used by the FFT algorithm and actual frequency reso-
lution in Hz, assuming that the data samples are available for selecting the number of data
points.
4.14. Given the sequence in Figure 4.46 and assuming fs ¼ 100 Hz, compute the amplitude
spectrum, phase spectrum, and power spectrum.
4.15. Compute the following window functions for a size of eight:
a. Hamming window function;
b. Hanning window function.
x n
( )
0
1
2
3
1
2
n
2
4
4
5
3
4
4
1
1
T
NT
0
1
FIGURE 4.46
Data sequence for Problem 4.14.
4.6 Summary
133

4.16. Consider the following data sequence of length six:
xð0Þ ¼ 0; xð1Þ ¼ 1; xð2Þ ¼ 0; xð3Þ ¼ 1; xð4Þ ¼ 0; xð5Þ ¼ 1
Compute the windowed sequence xwðnÞ using the
a. triangular window function;
b. Hamming window function;
c. Hanning window function.
4.17. Compute the following window functions for a size of 10:
a. Hamming window function;
b. Hanning window function.
4.18. Consider the following data sequence of length six:
xð0Þ ¼ 0; xð1Þ ¼ 0:2; xð2Þ ¼ 0; xð3Þ ¼ 0:2; xð4Þ ¼ 0; xð5Þ ¼ 0:2
Compute the windowed sequence xwðnÞ using the
a. triangular window function;
b. Hamming window function;
c. Hanning window function.
4.19. Given the sequence in Figure 4.47 where fs ¼ 100 Hz and T ¼ 0:01 sec:, compute the
amplitude spectrum, phase spectrum, and power spectrum using the
a. triangular window;
b. Hamming window;
c. Hanning window.
4.20. Given the sinusoid
xðnÞ ¼ 2$sin

2; 000$2p$
n
8; 000

x n
( )
0
1
2
3
1
2
n
2
4
4
5
3
4
4
1
1
T
NT
0
1
FIGURE 4.47
Data sequence for Problem 4.19.
134
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

obtained using a sampling rate of fs ¼ 8; 000 Hz, we apply the DFT to compute the
amplitude spectrum.
a. Determine the frequency resolution when the data length is 100 samples. Without using
the window function, is there any spectral leakage in the computed spectrum?
Explain.
b. Determine the frequency resolution when the data length is 73 samples. Without using the
window function, is there any spectral leakage in the computed spectrum?
Explain.
4.21. Given a sequence xðnÞ for 0  n  3, where xð0Þ ¼ 4, xð1Þ ¼ 3, xð2Þ ¼ 2, and xð3Þ ¼ 1,
evaluate its DFT XðkÞ using the decimation-in-frequency FFT method, and determine the
number of complex multiplications.
4.22. Given the DFT sequence XðkÞ for 0  k  3 obtained in Problem 4.21, evaluate its inverse
DFT xðnÞ using the decimation-in-frequency FFT method.
4.23. Given a sequence xðnÞ for 0  n  3, where xð0Þ ¼ 0:8, xð1Þ ¼ 0:6, xð2Þ ¼ 0:4, and
xð3Þ ¼ 0:2, evaluate its DFT XðkÞ using the decimation-in-frequency FFT method, and
determine the number of complex multiplications.
4.24. Given the DFT sequence XðkÞ for 0  k  3 obtained in Problem 4.23, evaluate its inverse
DFT xðnÞ using the decimation-in-frequency FFT method.
4.25. Given a sequence xðnÞ for 0  n  3, where xð0Þ ¼ 4, xð1Þ ¼ 3, xð2Þ ¼ 2, and xð3Þ ¼ 1,
evaluate its DFT XðkÞ using the decimation-in-time FFT method, and determine the number
of complex multiplications.
4.26. Given the DFT sequence XðkÞ for 0  k  3 computed in Problem 4.25, evaluate its inverse
DFT xðnÞ using the decimation-in-time FFT method.
4.27. Given a sequence xðnÞ for 0  n  3, where xð0Þ ¼ 0:8, xð1Þ ¼ 0:4, xð2Þ ¼ 0:4, and
xð3Þ ¼ 0:2, evaluate its DFT XðkÞ using the decimation-in-time FFT method, and
determine the number of complex multiplications.
4.28. Given the DFT sequence XðkÞ for 0  k  3 computed in Problem 4.27, evaluate its inverse
DFT xðnÞ using the decimation-in-time FFT method.
4.7.1 Computer Problems with MATLAB
Use MATLAB to solve Problems 4.29 and 4.30.
4.29. Consider three sinusoids with the following amplitudes and phases:
x1ðtÞ ¼ 5cosð2pð500ÞtÞ
x2ðtÞ ¼ 5cosð2pð1200Þt þ 0:25pÞ
x3ðtÞ ¼ 5cosð2pð1800Þt þ 0:5pÞ
a. Create a MATLAB program to sample each sinusoid and generate a sum of three sinu-
soids, that is, xðnÞ ¼ x1ðnÞ þ x2ðnÞ þ x3ðnÞ, using a sampling rate of 8,000 Hz. Plot xðnÞ
over a range of 0.1 seconds.
b. Use the MATLAB function fft() to compute DFT coefﬁcients, and plot and examine the
spectrum of the signal xðnÞ.
4.6 Summary
135

4.30. Consider the sum of sinusoids in Problem 4.29.
a. Generate the sum of sinusoids for 240 samples using a sampling rate of 8,000 Hz.
b. Write a MATLAB program to compute and plot the amplitude spectrum of the signal xðnÞ
with the FFT using each of the following window functions:
(1) Rectangular window (no window);
(2) Triangular window;
(3) Hamming window.
c. Examine the effect of spectral leakage for each window use in (b).
4.7.2 MATLAB Projects
4.31. Signal spectral analysis:
Given the four practical signals below, compute their one-sided spectra and create their time-
domain plots and spectral plots, respectively:
a. Speech signal (“speech.dat”), sampling rate ¼ 8,000 Hz. From the spectral plot, identify
the ﬁrst 5 formants.
b. ECG signal (“ecg.dat”), sampling rate ¼ 500 Hz. From the spectral plot, identify the
60 Hz-interference component.
c. Seismic data (“seismic.dat”), sampling rate ¼15 Hz. From the spectral plot, determine the
dominant frequency component.
d. Vibration signal of the acceleration response from a simple supported beam (“vbrdata.dat”),
sampling rate ¼1,000 Hz. From the spectral plot, determine four dominant frequencies
(modes).
4.32. Vibration signature analysis:
The acceleration signals measured from a gearbox can be used to monitor the condition of
the gears inside the gearbox. The early diagnosis of any gear issues can prevent the future
catastrophic failure of the system. Assume the following measurements and speciﬁcations
(courtesy of SpectraQuest, Inc.):
a. The input shaft has a speed of 1,000 RPM and meshing frequency is approximately 300 Hz.
b. Data speciﬁcations:
Sampling rate ¼ 12.8 kHz
v0.dat: healthy condition
v1.dat: damage severity level 1 (lightly chipped gear)
v2.dat: damage severity level 2 (moderately chipped gear)
v3.dat: damage severity level 3 (chipped gear)
v4.dat: damage severity level 4 (heavily chipped gear)
v5.dat: damage severity level 5 (missing tooth)
Investigate the spectrum for each measurement and identify sidebands. For each measure-
ment, determine the ratio of the largest sideband amplitude over the amplitude of meshing
frequency. Investigate the relation between the computed ratio values and the damage
severity.
136
CHAPTER 4 Discrete Fourier Transform and Signal Spectrum

The z-Transform
5
CHAPTER OUTLINE
5.1 Deﬁnition..................................................................................................................................... 137
5.2 Properties of the z-Transform........................................................................................................ 140
5.3 Inverse z-Transform...................................................................................................................... 144
5.3.1 Partial Fraction Expansion Using MATLAB...................................................................150
5.4 Solution of Difference Equations Using the z-Transform .................................................................. 152
5.5 Summary ..................................................................................................................................... 156
OBJECTIVES
This chapter introduces the z-transform and its properties; illustrates how to determine the inverse
z-transform using partial fraction expansion; and applies the z-transform to solve linear difference
equations.
5.1 DEFINITION
The z-transform is a very important tool in describing and analyzing digital systems. It also supports
the techniques for digital ﬁlter design and frequency analysis of digital signals. We begin with the
deﬁnition of the z-transform.
The z-transform of a causal sequence xðnÞ, designated by XðzÞ or ZðxðnÞÞ, is deﬁned as
XðzÞ ¼ ZðxðnÞÞ ¼ P
N
n ¼ 0
x

n

z n
¼ xð0Þz 0 þ xð1Þz 1 þ xð2Þz 2 þ /
(5.1)
where z is the complex variable. Here, the summation taken from n ¼ 0 to n ¼ N is according to the
fact that for most situations, the digital signal xðnÞ is the causal sequence, that is, xðnÞ ¼ 0 for n < 0.
Thus, the deﬁnition in Equation (5.1) is referred to as a one-sided z-transform or a unilateral transform.
In Equation (5.1), all the values of z that make the summation exist form a region of convergence in the
z-transform domain, while all other values of z outside the region of convergence will cause the
summation to diverge. The region of convergence is deﬁned based on the particular sequence xðnÞ
being applied. Note that we deal with the unilateral z-transform in this book, and hence when
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00005-6
Copyright  2013 Elsevier Inc. All rights reserved.
137

performing inverse z-transform (which we shall study later), we are restricted to the causal sequence.
Now let us study the following typical examples.
EXAMPLE 5.1
Given the sequence
xðnÞ
uðnÞ
ﬁnd the z transform of xðnÞ.
Solution:
From the deﬁnition of Equation (5.1), the z transform is given by
XðzÞ
X
N
n
0
uðnÞzn
X
N
n
0

z1n
1 þ

z1
þ

z12
þ/
This is an inﬁnite geometric series that converges to
XðzÞ
z
z
1
with a condition jz1j<1. Note that for an inﬁnite geometric series, we have 1 þ r þ r2 þ /
1
1
r when jrj<1.
The region of convergence for all values ofz is given as jzj > 1.
EXAMPLE 5.2
Consider the exponential sequence
xðnÞ
anuðnÞ
and ﬁnd the z transform of the sequence xðnÞ.
Solution:
From the deﬁnition of the z transform in Equation (5.1), it follows that
XðzÞ
X
N
n
0
anuðnÞzn
X
N
n
0

az1n
1 þ

az1
þ

az12
þ/
Since this is a geometric series that will converge for jaz1j<1, it is further expressed as
XðzÞ
z
z
a; for jzj > jaj
The z-transforms for common sequences are summarized in Table 5.1. Example 5.3 illustrates how
to ﬁnd the z-transform using Table 5.1.
138
CHAPTER 5 The z Transform

EXAMPLE 5.3
Find the z transform for each of the following sequences:
a. xðnÞ
10uðnÞ
b. xðnÞ
10sinð0:25pnÞuðnÞ
Table 5.1 Table of z-Transform Pairs
Line No.
xðnÞ; n ‡ 0
z-Transform XðzÞ
Region of
Convergence
1
xðnÞ
PN
n
0 xðnÞzn
2
dðnÞ
1
jzj > 0
3
auðnÞ
az
z
1
jzj > 1
4
nuðnÞ
z
ðz
1Þ2
jzj > 1
5
n2 uðnÞ
zðz þ 1Þ
ðz
1Þ3
jzj > 1
6
an uðnÞ
z
z
a
jzj > jaj
7
ena uðnÞ
z
ðz
eaÞ
jzj > ea
8
nan uðnÞ
az
ðz
aÞ2
jzj > jaj
9
sinðanÞuðnÞ
z sinðaÞ
z2
2z cosðaÞ þ 1
jzj > 1
10
cosðanÞuðnÞ
z½z
cosðaÞ
z2
2z cosðaÞ þ 1
jzj > 1
11
an sinðbnÞuðnÞ
½a sinðbÞz
z2
½2a cosðbÞz þ a2
jzj > jaj
12
an cosðbnÞuðnÞ
z½z
a cosðbÞ
z2
½2a cosðbÞz þ a2
jzj > jaj
13
ean sinðbnÞuðnÞ
½ea sinðbÞz
z2
½2ea cosðbÞz þ e2a
jzj > ea
14
ean cosðbnÞuðnÞ
z½z
ea cosðbÞ
z2
½2ea cosðbÞz þ e2a
jzj > ea
15
2jAjjPjncosðnq þ 4ÞuðnÞ
where P and A are complex
constants deﬁned by
P
jPj:q; A
jAj:4
Az
z
P þ
Az
z
P
5.1 Deﬁnition
139

c. xðnÞ
ð0:5ÞnuðnÞ
d. xðnÞ
ð0:5Þnsinð0:25pnÞuðnÞ
e. xðnÞ
e0:1ncosð0:25pnÞuðnÞ
Solution:
a. From Line 3 in Table 5.1, we get
XðzÞ
Zð10uðnÞÞ
10z
z
1
b. Line 9 in Table 5.1 leads to
XðzÞ
10Zðsinð0:2pnÞuðnÞÞ
10sinð0:25pÞz
z2
2zcos

0:25p

þ 1
7:07z
z2
1:414z þ 1
c. From Line 6 in Table 5.1, we obtain
XðzÞ
Z

ð0:5Þnu

n

z
z
0:5
d. From Line 11 in Table 5.1, it follows that
XðzÞ
Z

ð0:5Þnsin

0:25pn

u

n

0:5  sinð0:25pÞz
z2
2  0:5 cos

0:25p

z þ 0:52
0:3536z
z2
1:4142z þ 0:25
e. From Line 14 in Table 5.1, it follows that
XðzÞ
Z

e0:1ncos

0:25pn

uðnÞ

z

z
e0:1cos

0:25p

z2
2e0:1 cos

0:25p

z þ e0:2
zðz
0:6397Þ
z2
1:2794z þ 0:8187
5.2 PROPERTIES OF THE Z-TRANSFORM
In this section, we study some important properties of the z-transform. These properties are widely
used in deriving the z-transfer functions of difference equations and solving the system output
responses of linear digital systems with constant system coefﬁcients, which will be discussed in the
next chapter.
Linearity: The z-transform is a linear transformation, which implies
Zðax1ðnÞ þ bx2ðnÞÞ ¼ aZðx1ðnÞÞ þ bZðx2ðnÞÞ
(5.2)
where x1ðnÞ and x2ðnÞ denote the sampled sequences, while a and b are the arbitrary constants.
140
CHAPTER 5 The z Transform

EXAMPLE 5.4
Find the z transform of the sequence deﬁned by
x

n

u

n

ð0:5Þnu

n

Solution:
Applying the linearity of the z transform discussed above, we have
XðzÞ
ZðxðnÞÞ
ZðuðnÞÞ
Zð0:5nðnÞÞ
Using Table 5.1 yields
ZðuðnÞÞ
z
z
1
and
Zð0:5nuðnÞÞ
z
z
0:5
Substituting these results in XðzÞ leads to the ﬁnal solution,
XðzÞ
z
z
1
z
z
0:5
Shift theorem: Given XðzÞ, the z-transform of a sequence xðnÞ, the z-transform of xðn  mÞ, the
time-shifted sequence, is given by
Zðxðn  mÞÞ ¼ z mX

z

(5.3)
Note that if m  0, then xðn  mÞ is obtained by right shifting xðnÞ by m samples. Since the shift
theorem plays a very important role in developing the transfer function from a difference equation, we
verify the shift theorem for the causal sequence. Note that the shift theorem also works for the
noncausal sequence.
Veriﬁcation: Applying the z-transform to the shifted causal signal xðn  mÞ leads to
Zðxðn  mÞÞ ¼ P
N
n ¼ 0
x

n  m

z n
¼ xðmÞz 0 þ / þ xð1Þz ðm 1Þ þ xð0Þz m þ x

1

z m 1 þ .
Since xðnÞ is assumed to be a causal sequence, this means that
xð mÞ ¼ xð m þ 1Þ ¼ / ¼ xð 1Þ ¼ 0
Then we achieve
Zðxðn  mÞÞ ¼ xð0Þz m þ xð1Þz m 1 þ xð2Þz m 2 þ .
(5.4)
5.2 Properties of the z Transform
141

Factoring z m from Equation (5.4) and applying the deﬁnition of z-transform of XðzÞ, we get
Zðxðn  mÞÞ ¼ z m
xð0Þ þ xð1Þz 1 þ xð2Þz 2 þ .

¼ z mXðzÞ
EXAMPLE 5.5
Determine the z transform of the following sequence:
yðnÞ
ð0:5Þðn5Þ,uðn
5Þ
where uðn
5Þ
1 for n  5 and uðn
5Þ
0 for n<5.
Solution:
We ﬁrst use the shift theorem to obtain
Y ðzÞ
Z
h
ð0:5Þn5uðn
5Þ
i
z5Z

ð0:5Þnu

n

Using Table 5.1 leads to
Y ðzÞ
z5,
z
z
0:5
z4
z
0:5
Convolution: Given two sequences x1ðnÞ and x2ðnÞ, their convolution can be determined as
follows:
xðnÞ ¼ x1ðnÞ  x2ðnÞ ¼
X
N
k ¼ 0
x1ðn  kÞx2ðkÞ
(5.5)
where * designates the linear convolution. In the z-transform domain, we have
XðzÞ ¼ X1ðzÞX2ðzÞ
(5.6)
Here, XðzÞ ¼ ZðxðnÞÞ, X1ðzÞ ¼ Zðx1ðnÞÞ, and X2ðzÞ ¼ Zðx2ðnÞÞ.
EXAMPLE 5.6
Verify Equation (5.6) using causal sequences x1ðnÞ and x2ðnÞ.
Solution:
Taking the z transform of Equation (5.5) leads to
XðzÞ
X
N
n
0
xðnÞzn
X
N
n
0
X
N
k
0
x1ðn
kÞx2ðkÞzn
This expression can be further modiﬁed to
XðzÞ
X
N
n
0
X
N
k
0
x2ðkÞzkx1ðn
kÞzðnkÞ
142
CHAPTER 5 The z Transform

Now interchanging the order of the previous summation gives
XðzÞ
X
N
k
0
x2ðkÞzk X
N
n
0
x1ðn
kÞzðnkÞ
Now, let m
n
k :
XðzÞ
X
N
k
0
x2ðkÞzk X
N
m
0
x1ðmÞzm
By the deﬁnition of Equation (5.1), it follows that
XðzÞ
X2ðzÞX1ðzÞ
X1ðzÞX2ðzÞ
EXAMPLE 5.7
Consider two sequences,
x1ðnÞ
3dðnÞ þ 2dðn
1Þ
x2ðnÞ
2dðnÞ
dðn
1Þ
a. Find the z transform of the convolution:
XðzÞ
Zðx1ðnÞ  x2ðnÞÞ
b. Determine the convolution sum using the z transform:
xðnÞ
x1ðnÞ  x2ðnÞ
X
N
k
0
x1ðkÞx2ðn
kÞ
Solution:
a. Applying the z transform for x1ðnÞ and x2ðnÞ, respectively, it follows that
X1ðzÞ
3 þ 2z1
X2ðzÞ
2
z1
Using the convolution property, we have
XðzÞ
X1ðzÞX2ðzÞ

3 þ 2z1
2
z1
6 þ z1
2z2
b. Applying the inverse z transform and using the shift theorem and Line 1 of Table 5.1 leads to
xðnÞ
Z 1ð6 þ z1
2z2Þ
6dðnÞ þ dðn
1Þ
2dðn
2Þ
5.2 Properties of the z Transform
143

The properties of the z-transform discussed in this section are listed in Table 5.2.
5.3 INVERSE Z-TRANSFORM
The z-transform of the sequence xðnÞ and the inverse z-transform for the function XðzÞ are deﬁned as,
respectively
XðzÞ ¼ ZðxðnÞÞ
(5.7)
and
xðnÞ ¼ Z
1ðXðzÞÞ
(5.8)
where Zð Þ is the z-transform operator, and Z
1ð Þ is the inverse z-transform operator.
The inverse of the z-transform may be obtained by at least three methods:
1. partial fraction expansion and lookup table;
2. power series expansion;
3. residue method.
The ﬁrst method is widely utilized, and it is assumed that the reader is well familiar with the partial
fraction expansion method in learning Laplace transform. Therefore, we concentrate on the ﬁrst
method in this book. As for the power series expansion and residue methods, the interested reader is
referred to the textbook by Oppenheim and Schafer (1975). The key idea of the partial fraction
expansion is that if XðzÞ is a proper rational function of z, we can expand it to a sum of the ﬁrst-order
factors or higher-order factors using the partial fraction expansion that can be inverted by inspecting
the z-transform table. The partial fraction expansion method is illustrated via the following examples.
(For simple z-transform functions, we can directly ﬁnd the inverse z-transform using Table 5.1.)
EXAMPLE 5.8
Find the inverse z transform for each of the following functions:
a. XðzÞ
2 þ
4z
z
1
z
z
0:5
b. XðzÞ
5z
ðz
1Þ2
2z
ðz
0:5Þ2
Table 5.2 z-Transform Properties
Property
Time Domain
z-Transform
Linearity
ax1ðnÞ þ bx2ðnÞ
aZðx1ðnÞÞ þ bZðx2ðnÞÞ
Shift theorem
xðn
mÞ
zmXðzÞ
Linear convolution
x1ðnÞ  x2ðnÞ
PN
k
0 x1ðn
kÞx2ðkÞ
X1ðzÞX2ðzÞ
144
CHAPTER 5 The z Transform

c. XðzÞ
10z
z2
z þ 1
d. XðzÞ
z4
z
1 þ z6 þ
z3
z þ 0:5
Solution:
a. xðnÞ
2Z 1ð1Þ þ 4Z 1
z
z
1

Z 1
z
z
0:5

From Table 5.1, we have
x

n

2d

n

þ 4u

n

ð0:5Þnu

n

b. xðnÞ
Z 1
 
5z
ðz
1Þ2
!
Z 1
 
2z
ðz
0:5Þ2
!
5Z 1
 
z
ðz
1Þ2
!
2
0:5Z 1
 
0:5z
ðz
0:5Þ2
!
Then
xðnÞ
5nu

n

4nð0:5Þnu

n

c. XðzÞ
10z
z2
z þ 1
 10
sinðaÞ
	
sinðaÞz
z2
2zcosðaÞ þ 1
By coefﬁcient matching, we have
2cosðaÞ
1
Hence, cosðaÞ
0:5, and a
600. Substituting a
600 into the sine function leads to
sin

a

sin

600
0:866
Finally, we have
xðnÞ
10
sinðaÞZ 1

sinðaÞz
z2
2zcos

a

þ 1
	
10
0:866 sinðn,600Þ
11:547sinðn,600Þ
d.
xðnÞ
Z 1
z5
z
z
1

þ Z 1
z6,1

þ Z 1
z4
z
z þ 0:5

Using Table 5.1 and the shift property, we get
xðnÞ
uðn
5Þ þ dðn
6Þ þ ð
0:5Þn4uðn
4Þ
Now, we are ready to deal with the inverse z-transform using the partial fraction expansion and
lookup table. The general procedure is as follows:
1. Eliminate the negative powers of z for the z-transform function XðzÞ.
2. Determine the rational function XðzÞ=z (assuming it is proper), and apply the partial fraction
expansion to the determined rational function XðzÞ=z using the formula in Table 5.3.
3. Multiply the expanded function XðzÞ=z by z on both sides of the equation to obtain XðzÞ.
4. Apply the inverse z-transform using Table 5.1.
5.3 Inverse z Transform
145

The partial fraction format and the formulas for calculating the constants are listed in Table 5.3.
Example 5.9 considers the situation of the z-transform function having ﬁrst-order poles.
EXAMPLE 5.9
Find the inverse of the following z transform:
XðzÞ
1

1
z1
1
0:5z1
Solution:
Eliminating the negative power of z by multiplying the numerator and denominator by z2 yields
XðzÞ
z2
z2
1
z1
1
0:5z1
z2
ðz
1Þðz
0:5Þ
Dividing both sides by z leads to
XðzÞ
z
z
ðz
1Þðz
0:5Þ
Again, we write
XðzÞ
z
A
ðz
1Þ þ
B
ðz
0:5Þ
where A and B are constants found using the formula in Table 5.3, that is,
Table 5.3 Partial Fraction(s) and Formulas for Constant(s)
Partial fraction with the ﬁrst-order real pole:
R
z
p
R
ðz
pÞXðzÞ
z




z p
Partial fraction with the ﬁrst-order complex poles:
Az
ðz
PÞ þ
Az
ðz
P Þ
A
ðz
PÞXðzÞ
z




z
P
P 
complex conjugate of P A
complex conjugate of A
Partial fraction with mth-order real poles:
Rm
ðz
pÞ þ
Rm1
ðz
pÞ2 þ / þ
R1
ðz
pÞm
Rk
1
ðk
1Þ!
dk1
dzk1

ðz
pÞmXðzÞ
z
	



z p
A
ðz
1ÞXðzÞ
z




z
1
z
ðz
0:5Þ




z
1
2
146
CHAPTER 5 The z Transform

B
ðz
0:5ÞXðzÞ
z




z
0:5
z
ðz
1Þ




z
0:5
1
Thus
XðzÞ
z
2
ðz
1Þ þ
1
ðz
0:5Þ
Multiplying z on both sides gives
XðzÞ
2z
ðz
1Þ þ
z
ðz
0:5Þ
Using Table 5.1 with the z transform pairs, it follows that
x

n

2u

n

ð0:5Þnu

n

Tabulating this solution in terms of integer values of n, we obtain the results in Table 5.4.
The following example considers the case where XðzÞ has ﬁrst-order complex poles.
EXAMPLE 5.10
Find yðnÞ if
Y ðzÞ
z2
z þ 1


z
1

z2
z þ 0:5

Solution:
Dividing Y ðzÞ by z, we have
Y ðzÞ
z
zðz þ 1Þ

z
1

z2
z þ 0:5

Applying the partial fraction expansion leads to
Y ðzÞ
z
B
z
1 þ
A
ðz
0:5
j0:5Þ þ
A
ðz
0:5 þ j0:5Þ
Table 5.4 Determined Sequence in Example 5.9
n
0
1
2
3
4
.
N
xðnÞ
1.0
1.5
1.75
1.875
1.9375
.
2.0
5.3 Inverse z Transform
147

We ﬁrst ﬁnd B :
B
ðz
1ÞY ðzÞ
z




z
1
zðz þ 1Þ

z2
z þ 0:5





z
1
1  ð1 þ 1Þ

12
1 þ 0:5

4
Notice that A and A are a complex conjugate pair. We determine A as follows:
A
ðz
0:5
j0:5ÞY ðzÞ
z




z
0:5þj0:5
zðz þ 1Þ
ðz
1Þðz
0:5 þ j0:5Þ




z
0:5þj0:5
ð0:5 þ j0:5Þð0:5 þ j0:5 þ 1Þ
ð0:5 þ j0:5
1Þð0:5 þ j0:5
0:5 þ j0:5Þ
ð0:5 þ j0:5Þð1:5 þ j0:5Þ
ð
0:5 þ j0:5Þj
Using the polar form, we get
A

0:707:450
1:58114:18:430

0:707:1350
1:900
1:58114:
161:570
A
A
1:58114:161:570
Assume that a ﬁrst order complex pole takes the form
P
0:5 þ 0:5j
jPj:q
0:707:450 and P
jPj:
q
0:707:
450
We have
Y ðzÞ
4z
z
1 þ
Az
ðz
PÞ þ
Az
ðz
PÞ
Applying the inverse z transform from Line 15 in Table 5.1 leads to
yðnÞ
4Z 1
z
z
1

þ Z 1

Az
ðz
PÞ þ
Az
ðz
PÞ
	
Using the previous formula, the inversion and subsequent simpliﬁcation yield
y

n

4u

n

þ 2jAjðjPjÞncos

nq þ 4

u

n

4u

n

þ 3:1623ð0:7071Þncos

450n
161:570
u

n

The situation dealing with real repeated poles is presented next.
EXAMPLE 5.11
Find xðnÞ if
XðzÞ
z2

z
1

z
0:5
2
148
CHAPTER 5 The z Transform

Solution:
Dividing both sides of the previous z transform by z yields
XðzÞ
z
z
ðz
1Þðz
0:5Þ2
A
z
1 þ
B
z
0:5 þ
C
ðz
0:5Þ2
where
A
ðz
1ÞXðzÞ
z




z
1
z
ðz
0:5Þ2





z
1
4
Using the formulas for mth order real poles in Table 5.3, where m
2 and p
0:5, to determine B and C yields
B
R2
1
ð2
1Þ!
d
dz

ðz
0:5Þ2XðzÞ
z

z
0:5
d
dz

z
z
1
	



z
0:5
1
ðz
1Þ2





z
0:5
4
C
R1
1
ð1
1Þ!
d0
dz0

ðz
0:5Þ2XðzÞ
z

z
0:5
z
z
1



z
0:5
1
Then
XðzÞ
4z
z
1 þ
4z
z
0:5 þ
1z
ðz
0:5Þ2
(5.9)
The inverse z transform for each term on the right hand side of Equation (5.9) can be obtained using the result
listed in Table 5.1, that is,
Z 1n
z
z
1
o
u

n

Z 1n
z
z
0:5
o
ð0:5Þnu

n

Z 1
(
z
ðz
0:5Þ2
)
2nð0:5ÞnuðnÞ
From these results, it follows that
x

n

4u

n

4ð0:5Þnu

n

2nð0:5Þnu

n

5.3 Inverse z Transform
149

5.3.1 Partial Fraction Expansion Using MATLAB
The MATLAB function residue() can be applied to perform the partial fraction expansion of a
z-transform function XðzÞ=z. The syntax is given as
½R; P; K ¼ residueðB; AÞ
Here, B and A are the vectors consisting of coefﬁcients for the numerator and denominator
polynomials, BðzÞ and AðzÞ, respectively. Notice that BðzÞ and AðzÞ are the polynomials with
increasing positive powers of z.
BðzÞ
AðzÞ ¼ b0zM þ b1zM
1 þ b2zM
2 þ / þ bM
zN þ a1zN
1 þ a2z 2 þ / þ aN
The function returns the residues in vector R, corresponding poles in vector P, and polynomial
coefﬁcients (if any) in vector K. The expansion format is shown as
BðzÞ
AðzÞ ¼
r1
z  p1
þ
r2
z  p2
þ / þ k0 þ k1z 1 þ /
For a pole pj of multiplicity m, the partial fraction includes the following terms:
BðzÞ
AðzÞ ¼ / þ
rj
z  pj
þ
rjþ1
ðz  pjÞ2 þ / þ
rjþm
ðz  pjÞm þ / þ k0 þ k1z 1 þ /
EXAMPLE 5.12
Find the partial expansion for each of the following z transform functions:
a. XðzÞ
1
ð1
z1Þð1
0:5z1Þ
b. Y ðzÞ
z2ðz þ 1Þ
ðz
1Þðz2
z þ 0:5Þ
c. XðzÞ
z2
ðz
1Þðz
0:5Þ2
Solution:
a. From MATLAB, we can show the denominator polynomial as
» conv([1 L1],[1 L0.5])
D [
1.0000 L1.5000 0.5000
This leads to
XðzÞ
1

1
z1
1
0:5z1
1
1
1:5z1 þ 0:52
z2
z2
1:5z þ 0:5
and
XðzÞ
z
z
z2
1:5z þ 0:5
150
CHAPTER 5 The z Transform

From MATLAB, we have
» [R,P,K][residue([1 0],[1 L1.5 0.5])
R [
2
L1
P [
1.0000
0.5000
K [
[]
»
Then the expansion is written as
XðzÞ
2z
z
1
z
z
0:5
b. From the MATLAB entry
» N[conv([1 0 0],[1 1])
N [
1 1 0 0
» D[conv([1 L1], [1 L1 0.5])
D [
1.0000 L2.0000 1.5000 L0.5000
we get
Y ðzÞ
z2
z þ 1


z
1

z2
z þ 0:5

z3 þ z2
z3
2z2 þ 1:5z
0:5
and
Y ðzÞ
z
z2 þ z
z3
2z2 þ 1:5z
0:5
Using the MATLAB residue function yields
» [R,P,K][residue([1 1 0],[1 L2 1.5 L0.5])
R [
4.0000
L1.5000 L 0.5000i
L1.5000 D 0.5000i
P [
1.0000
0.5000 D 0.5000i
0.5000 L 0.5000i
K [
[]
»
Then the expansion is shown below
XðzÞ
Bz
z
p1
þ
Az
z
p þ
Az
z
p
5.3 Inverse z Transform
151

where B
4; p1
1;
A
1:5
0:5j;
p
0:5 þ 0:5j;
A
1:5 þ 0:5j;
and p
0:5
0:5j
c. Similarly, if we use
» D[conv(conv([1 L1], [1 L0.5]),[1 L0.5])
D [
1.0000 L2.0000 1.2500 L0.2500
then
XðzÞ
z2
ðz
1Þðz
0:5Þ2
z2
z3
2z2 þ 1:25z
0:25
and we yield
XðzÞ
z
z
z3
2z2 þ 1:25z
0:25
From MATLAB, we obtain
» [R,P,K][residue([1 0],[1 L2 1.25 L0.25])
R [
4.0000
L4.0000
L1.0000
P [
1.0000
0.5000
0.5000
K [
[]
»
Using the previous results leads to
XðzÞ
4z
z
1
4z
z
0:5
z
ðz
0:5Þ2
5.4 SOLUTION OF DIFFERENCE EQUATIONS USING THE Z-TRANSFORM
To solve a difference equation with initial conditions, we have to deal with time-shifted sequences such
as yðn  1Þ, yðn  2Þ,., yðn  mÞ, and so on. Let us examine the z-transform of these terms. Using the
deﬁnition of the z-transform, we have
152
CHAPTER 5 The z Transform

Zðyðn  1ÞÞ ¼ P
N
n ¼ 0
y

n  1

z n
¼ y

 1

þ y

0

z 1 þ y

1

z 2 þ /
¼ y

 1

þ z 1
y

0

þ y

1

z 1 þ y

2

z 2 þ /

It holds that
Zðyðn  1ÞÞ ¼ y

 1

þ z 1Y

z

(5.10)
Similarly, we have
Zðyðn  2ÞÞ ¼ P
N
n ¼ 0
y

n  2

z n
¼ y

 2

þ y

 1

z 1 þ y

0

z 2 þ y

1

z 3 þ /
¼ y

 2

þ y

 1

z 1 þ z 2
y

0

þ y

1

z 1 þ y

2

z 2 þ /

Zðyðn  2ÞÞ ¼ y

 2

þ y

 1

z 1 þ z 2Y

z

(5.11)
Zðyðn  mÞÞ ¼ yðmÞ þ yðm þ 1Þz 1 þ / þ yð1Þz ðm 1Þ þ z mYðzÞ
(5.12)
where yðmÞ, yðm þ 1Þ, ., yð1Þ are the initial conditions. If all initial conditions are considered to
be zero, that is,
yð  mÞ ¼ yð  m þ 1Þ ¼ /yð  1Þ ¼ 0
(5.13)
then Equation (5.12) becomes
Zðyðn  mÞÞ ¼ z mY

z

(5.14)
which is the same as the shift theorem in Equation (5.3).
The following two examples serve as illustrations of applying the z-transform to ﬁnd the solutions of
difference equations. The procedure is as follows:
1. Apply the z-transform to the difference equation.
2. Substitute the initial conditions.
3. Solve for the difference equation in the z-transform domain.
4. Find the solution in the time domain by applying the inverse z-transform.
EXAMPLE 5.13
A digital signal processing (DSP) system is described by the difference equation
y

n

0:5y

n
1

5ð0:2Þnu

n

Determine the solution when the initial condition is given by yð 1Þ
1.
5.4 Solution of Difference Equations Using the z Transform
153

Solution:
Applying the z transform on both sides of the difference equation and using Equation (5.12), we have
Y ðzÞ
0:5ðyð 1Þ þ z1Y ðzÞÞ
5Zð0:2nuðnÞÞ
Substituting the initial condition and Zð0:2nuðnÞÞ
Zð0:2nuðnÞÞ
z=ðz
0:2Þ, we achieve
Y ðzÞ
0:5ð1 þ z1Y ðzÞÞ
5z=ðz
0:2Þ
Simpliﬁcation leads to
Y ðzÞ
0:5z1Y ðzÞ
0:5 þ 5z=ðz
0:2Þ
Factoring out Y ðzÞ and combining the right hand side of the equation, it follows that
Y ðzÞð1
0:5z1Þ
ð5:5z
0:1Þ=ðz
0:2Þ
Then we obtain
Y ðzÞ
ð5:5z
0:1Þ

1
0:5z1
z
0:2

zð5:5z
0:1Þ
ðz
0:5Þðz
0:2Þ
Using the partial fraction expansion method leads to
Y ðzÞ
z
5:5z
0:1
ðz
0:5Þðz
0:2Þ
A
z
0:5 þ
B
z
0:2
where
A
ðz
0:5ÞY ðzÞ
z




z
0:5
5:5z
0:1
z
0:2




z
0:5
5:5  0:5
0:1
0:5
0:2
8:8333
B
ðz
0:2ÞY ðzÞ
z




z
0:2
5:5z
0:1
z
0:5




z
0:2
5:5  0:2
0:1
0:2
0:5
3:3333
Thus
Y ðzÞ
8:8333z
ðz
0:5Þ þ
3:3333z
ðz
0:2Þ
which gives the solution as
y

n

8:3333ð0:5Þnu

n

3:3333ð0:2Þnu

n

EXAMPLE 5.14
A relaxed (zero initial conditions) DSP system is described by a difference equation
yðnÞ þ 0:1yðn
1Þ
0:2yðn
2Þ
xðnÞ þ xðn
1Þ
a. Determine the impulse response yðnÞ due to the impulse sequence xðnÞ
dðnÞ.
b. Determine the system response yðnÞ due to the unit step function excitation, where uðnÞ
1 for n  0.
154
CHAPTER 5 The z Transform

Solution:
a. Applying the z transform on both sides of the difference equation and using Equation (5.3) or Equation (5.14),
we obtain
Y ðzÞ þ 0:1Y ðzÞz1
0:2Y ðzÞz2
XðzÞ þ XðzÞz1
(5.15)
Factoring out YðzÞ on the left side and substituting XðzÞ
ZðdðnÞÞ
1 to the right side in the Equation (5.15)
we get
Y ðzÞð1 þ 0:1z1
0:2z2Þ
1ð1 þ z1Þ
Then YðzÞ can be expressed as
Y ðzÞ
1 þ z1
1 þ 0:1z1
0:2z2
To obtain the impulse response, which is the inverse z transform of the transfer function, we multiply the
numerator and denominator by z2.
Thus
Y ðzÞ
z2 þ z
z2 þ 0:1z
0:2
zðz þ 1Þ
ðz
0:4Þðz þ 0:5Þ
Using the partial fraction expansion method leads to
Y ðzÞ
z
z þ 1
ðz
0:4Þðz þ 0:5Þ
A
z
0:4 þ
B
z þ 0:5
where
A
ðz
0:4ÞY ðzÞ
z




z
0:4
z þ 1
z þ 0:5




z
0:4
0:4 þ 1
0:4 þ 0:5
1:5556
B
ðz þ 0:5ÞY ðzÞ
z




z
0:5
z þ 1
z
0:4




z
0:5
0:5 þ 1
0:5
0:4
0:5556
Thus
Y ðzÞ
1:5556z
ðz
0:4Þ þ
0:5556z
ðz þ 0:5Þ
which gives the impulse response
y

n

1:5556ð0:4Þnu

n

0:5556ð
0:5Þnu

n

b. To obtain the response due to a unit step function, the input sequence is set to be
xðnÞ
uðnÞ
and the corresponding z transform is given by
XðzÞ
z
z
1
5.4 Solution of Difference Equations Using the z Transform
155

Notice that
Y ðzÞ þ 0:1Y ðzÞz1
0:2Y ðzÞz2
XðzÞ þ XðzÞz1
Then the z transform of the output sequence yðnÞ can be obtained as
Y ðzÞ

z
z
1

1 þ z1
1 þ 0:1z1
0:2z2
	
z2ðz þ 1Þ
ðz
1Þðz
0:4Þðz þ 0:5Þ
Using the partial fraction expansion method as before gives
Y ðzÞ
2:2222z
z
1
þ
1:0370z
z
0:4
þ
0:1852z
z þ 0:5
and the system response is found by using Table 5.1:
y

n

2:2222u

n

1:0370ð0:4Þnu

n

0:1852ð
0:5Þnu

n

5.5 SUMMARY
1. The one-sided (unilateral) z-transform, which can be used to transform the causal sequence to the
z-transform domain, was deﬁned.
2. The lookup table of the z-transform determines the z-transform for a simple causal sequence, or the
causal sequence from a simple z-transform function.
3. The important properties of the z-transform, such as linearity, the shift theorem, and
convolution were introduced. The shift theorem can be used to solve a difference equation.
The z-transform of a digital convolution of two digital sequences is equal to the product of
their z-transforms.
4. Methods to determine the inverse of the z-transform, such as partial fraction expansion, invert the
complicated z-transform function, which can have ﬁrst-order real poles, multiple-order real poles,
and ﬁrst-order complex poles assuming that the z-transform function is proper. The MATLAB
techniques to determine the inverse were introduced.
5. The z-transform can be applied to solve linear difference equations with nonzero initial conditions
and zero initial conditions.
5.6 PROBLEMS
5.1. Find the z-transform for each of the following sequences:
a. xðnÞ ¼ 4uðnÞ
b. xðnÞ ¼ ð0:7ÞnuðnÞ
c. xðnÞ ¼ 4e 2nuðnÞ
d. xðnÞ ¼ 4ð0:8Þncosð0:1pnÞuðnÞ
e. xðnÞ ¼ 4e 3nsinð0:1pnÞuðnÞ
156
CHAPTER 5 The z Transform

5.2. Using the properties of the z-transform, ﬁnd the z-transform for each of the following
a. xðnÞ ¼ uðnÞ þ ð0:5ÞnuðnÞ
b. xðnÞ ¼ e 3ðn 4Þcosð0:1pðn  4ÞÞuðn  4Þ, where uðn  4Þ ¼ 1 for n  4 while
uðn  4Þ ¼ 0 for n<4
5.3. Find the z-transform for each of the following sequences:
a. xðnÞ ¼ 3uðn  4Þ
b. xðnÞ ¼ 2ð0:2ÞnuðnÞ
c. xðnÞ ¼ 5e 2ðn 3Þuðn  3Þ
d. xðnÞ ¼ 6ð0:6Þncosð0:2pnÞuðnÞ
e. xðnÞ ¼ 4e 3ðn 1Þsinð0:2pðn  1ÞÞuðn  1Þ.
5.4. Using the properties of the z-transform, ﬁnd the z-transform for each of the following
sequences:
a. xðnÞ ¼ 2uðnÞ  ð0:75ÞnuðnÞ
b. xðnÞ ¼ e 2ðn 3Þsinð0:2pðn  3ÞÞuðn  3Þ, where uðn  3Þ ¼ 1 for n  3 while
uðn  3Þ ¼ 0 for n < 3
5.5. Given two sequences
x1ðnÞ ¼ 5dðnÞ  2dðn  2Þ and x2ðnÞ ¼ 3dðn  3Þ
a. determine the z-transform of the convolution of the two sequences using the convolution
property of z-transform
XðzÞ ¼ X1ðzÞX2ðzÞ
b. determine the convolution by the inverse z-transform
x

n

¼ Z
1ðX1ðzÞX2ðzÞÞ
from the result in (a).
5.6. Using Table 5.1 and the z-transform properties, ﬁnd the inverse z-transform for each of the
following functions:
a. XðzÞ ¼ 4  10z
z  1 
z
z þ 0:5
b. XðzÞ ¼
5z
ðz  1Þ þ
10z
ðz  1Þ2 þ
2z
ðz  0:8Þ2
c. XðzÞ ¼
z
z2 þ 1:2z þ 1
d. XðzÞ ¼ 4z 4
z  1 þ
z 1
ðz  1Þ2 þ z 8 þ
z 5
z  0:5
5.5 Summary
157

5.7. Given two sequences
x1ðnÞ ¼ 2dðnÞ þ 5dðn  2Þ and x2ðnÞ ¼ 4dðn  4Þ
a. determine the z-transform of convolution of the two sequences using the convolution
property of z-transform
XðzÞ ¼ X1ðzÞX2ðzÞ
b. determine the convolution by the inverse z-transform
x

n

¼ Z
1ðX1ðzÞX2ðzÞÞ
from the result in (a).
5.8. Using Table 5.1 and z-transform properties, ﬁnd the inverse z-transform for each of the
following functions:
a. XðzÞ ¼ 5 
7z
z þ 1 
3z
z  0:5
b. XðzÞ ¼
3z
ðz  0:5Þ þ
8z
ðz  0:8Þ þ
2z
ðz  0:8Þ2
c. XðzÞ ¼
3z
z2 þ 1:414z þ 1
d. XðzÞ ¼ 5z 5
z  1 
z 2
ðz  1Þ2 þ z 10 þ
z 3
z  0:75
5.9. Using the partial fraction expansion method, ﬁnd the inverse of the following z-transforms:
a. XðzÞ ¼
1
z2  0:3z  0:24
b. XðzÞ ¼
z
ðz  0:2Þðz þ 0:4Þ
c. XðzÞ ¼
z
ðz þ 0:2Þðz2  z þ 0:5Þ
d. XðzÞ ¼
zðz þ 0:5Þ
ðz  0:1Þ2ðz  0:6Þ
5.10. A system is described by the difference equation
yðnÞ þ 0:5yðn  1Þ ¼ 2ð0:8ÞnuðnÞ
Determine the solution when the initial condition is yð1Þ ¼ 2.
5.11. Using the partial fraction expansion method, ﬁnd the inverse of the following z-transforms:
a. XðzÞ ¼
1
z2 þ 0:2z þ 0:2
158
CHAPTER 5 The z Transform

b. XðzÞ ¼
z
ðz þ 0:3Þðz  0:5Þ
c. XðzÞ ¼
5z
ðz  0:75Þðz2  z þ 0:5Þ
d. XðzÞ ¼
2zðz  0:4Þ
ðz  0:2Þ2ðz þ 0:8Þ
5.12. A system is described by the difference equation
yðnÞ þ 0:2yðn  1Þ ¼ 4ð0:3ÞnuðnÞ
Determine the solution when the initial condition is yð1Þ ¼ 1.
5.13. A system is described by the difference equation
yðnÞ  0:5yðn  1Þ þ 0:06yðn  2Þ ¼ ð0:4Þn 1uðn  1Þ
Determine the solution when the initial conditions are yð1Þ ¼ 1, and yð2Þ ¼ 2.
5.14. Given the following difference equation with the input output relationship of a certain
initially relaxed system (all initial conditions are zero),
yðnÞ  0:7yðn  1Þ þ 0:1yðn  2Þ ¼ xðnÞ þ xðn  1Þ
a. ﬁnd the impulse response sequence yðnÞ due to the impulse sequence dðnÞ;
b. ﬁnd the output response of the system when the unit step function uðnÞ is applied.
5.15. A system is described by the difference equation
yðnÞ  0:6yðn  1Þ þ 0:08yðn  2Þ ¼ ð0:5Þn 1uðn  1Þ
Determine the solution when the initial conditions are yð1Þ ¼ 2, and yð2Þ ¼ 1.
5.16. Given the following difference equation with the input output relationship of a certain
initially relaxed system (all initial conditions are zero),
yðnÞ  0:6yðn  1Þ þ 0:25yðn  2Þ ¼ xðnÞ þ xðn  1Þ
a. ﬁnd the impulse response sequence yðnÞ due to the impulse sequence dðnÞ;
b. ﬁnd the output response of the system when the unit step function uðnÞ is applied.
5.17. Given the following difference equation with the input output relationship of a certain
initially relaxed DSP system (all initial conditions are zero),
yðnÞ  0:4yðn  1Þ þ 0:29yðn  2Þ ¼ xðnÞ þ 0:5xðn  1Þ
a. ﬁnd the impulse response sequence yðnÞ due to the impulse sequence dðnÞ;
b. ﬁnd the output response of the system when the unit step function uðnÞ is applied.
5.5 Summary
159

5.18. Given the following difference equation with the input output relationship of a certain
initially relaxed DSP system (all initial conditions are zero),
yðnÞ  0:2yðn  1Þ þ 0:17yðn  2Þ ¼ xðnÞ þ 0:3xðn  1Þ
a. ﬁnd the impulse response sequence yðnÞ due to the impulse sequence dðnÞ;
b. ﬁnd the output response of the system when the unit step function uðnÞ is applied.
160
CHAPTER 5 The z Transform

Digital Signal Processing Systems,
Basic Filtering Types, and Digital
Filter Realizations
6
CHAPTER OUTLINE
6.1 The Difference Equation and Digital Filtering ................................................................................. 161
6.2 Difference Equation and Transfer Function ..................................................................................... 166
6.2.1 Impulse Response, Step Response, and System Response ............................................169
6.3 The z-Plane Pole-Zero Plot and Stability........................................................................................ 172
6.4 Digital Filter Frequency Response ................................................................................................. 178
6.5 Basic Types of Filtering ................................................................................................................ 186
6.6 Realization of Digital Filters.......................................................................................................... 192
6.6.1 Direct-Form I Realization ...........................................................................................193
6.6.2 Direct-Form II Realization ..........................................................................................193
6.6.3 Cascade (Series) Realization ......................................................................................195
6.6.4 Parallel Realization....................................................................................................196
6.7 Application: Signal Enhancement and Filtering............................................................................... 199
6.7.1 Pre-Emphasis of Speech ............................................................................................200
6.7.2 Bandpass Filtering of Speech .....................................................................................203
6.7.3 Enhancement of ECG Signal Using Notch Filtering.......................................................205
6.8 Summary ..................................................................................................................................... 206
OBJECTIVES:
This chapter illustrates digital ﬁltering operations for a given input sequence; derives transfer functions
from the difference equations; analyzes the stability of the linear systems using the z-plane pole-zero plot;
and calculates the frequency responses of digital ﬁlters. Then the chapter further investigates realizations
of the digital ﬁlters, and examines spectral effects by ﬁltering speech data using the digital ﬁlters.
6.1 THE DIFFERENCE EQUATION AND DIGITAL FILTERING
In this chapter, we begin with developing the ﬁltering concept of digital signal processing (DSP)
systems. With the knowledge acquired in Chapter 5, dealing with the z-transform, we will learn how to
describe and analyze linear time-invariant systems. We also will become familiar with digital ﬁltering
types and their realization structures.
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00006-8
Copyright  2013 Elsevier Inc. All rights reserved.
161

A DSP system (digital ﬁlter) is described in Figure 6.1.
Let xðnÞ and yðnÞ be a DSP system’s input and output, respectively. We can express the relationship
between the input and the output of a DSP system by the following difference equation:
yðnÞ ¼ b0xðnÞ þ b1xðn  1Þ þ / þ bMxðn  MÞ
 a1yðn  1Þ  /  aNyðn  NÞ
(6.1)
where bi, 0  i  M and aj, 1  j  N, represent the coefﬁcients of the system and n is the time index.
Equation (6.1) can also be written as
yðnÞ ¼
X
M
i ¼ 0
bixðn  iÞ 
X
N
j ¼ 1
ajyðn  jÞ
(6.2)
From Equations (6.1) and (6.2), we observe that the DSP system output is the weighted summation of
the current input value xðnÞ, past values xðn  1Þ, . , xðn  MÞ, and the past output sequence
yðn  1Þ, . , yðn  NÞ. The system can be veriﬁed as linear, time-invariant, and causal. If the initial
conditions are speciﬁed, we can compute system output (time response) yðnÞ recursively. This process
is referred to as digital ﬁltering. We will illustrate ﬁltering operations in Examples 6.1 and 6.2.
EXAMPLE 6.1
Compute the system output
yðnÞ
0:5yðn
2Þ þ xðn
1Þ
for the ﬁrst four samples using the following initial conditions:
a. initial conditions yð
2Þ
1, yð
1Þ
0, xð
1Þ
1, and input xðnÞ
ð0:5ÞnuðnÞ
b. zero initial conditions yð 2Þ
0, yð
1Þ
0, xð
1Þ
0, and input xðnÞ
ð0:5ÞnuðnÞ
Solution:
According to Equation (6.1), we identify the system coefﬁcients as
N
2; M
1; a1
0; a2
0:5; b0
0;
and
b1
1
a. Setting n
0, and using initial conditions, we obtain the input and output as
xð0Þ
ð0:5Þ0uð0Þ
1
yð0Þ
0:5yð
2Þ þ xð
1Þ
0:5$1 þ ð
1Þ
0:5
Setting n
1, and using the initial condition yð
1Þ
0, we achieve
xð1Þ
ð0:5Þ1uð1Þ
0:5
yð1Þ
0:5yð
1Þ þ xð0Þ
0:5$0 þ 1
1:0
Digital filter
(digital filtering)
x(n)
y(n)
Digital output
Digital input
FIGURE 6.1
DSP system with input and output.
162
CHAPTER 6 Digital Signal Processing Systems

Similarly, using the past output yð0Þ
0:5, we get
xð2Þ
ð0:5Þ2uð2Þ
0:25
yð2Þ
0:5yð0Þ þ xð1Þ
0:5,ð
0:5Þ þ 0:5
0:25
and with yð1Þ
1:0, we yield
xð3Þ
ð0:5Þ3uð3Þ
0:125
yð3Þ
0:5yð1Þ þ xð2Þ
0:5,1 þ 0:25
0:75
.........
Clearly, yðnÞ could be recursively computed for n > 3.
b. Setting n
0, we obtain
xð0Þ
ð0:5Þ0uð0Þ
1
yð0Þ
0:5yð
2Þ þ xð
1Þ
0,1 þ 0
0
Setting n
1, we achieve
xð1Þ
ð0:5Þ1uð1Þ
0:5
yð1Þ
0:5yð
1Þ þ xð0Þ
0,0 þ 1
1
Similarly, with the past output yð0Þ
0, we determine
xð2Þ
ð0:5Þ2uð2Þ
0:25
yð2Þ
0:5yð0Þ þ xð1Þ
0:5,0 þ 0:5
0:5
and with yð1Þ
1, we obtain
xð3Þ
ð0:5Þ3uð3Þ
0:125
yð3Þ
0:5yð1Þ þ xð2Þ
0:5,1 þ 0:25
0:75
.........
Clearly, yðnÞ could be recursively computed for n > 3
EXAMPLE 6.2
Given the DSP system
yðnÞ
2xðnÞ
4xðn
1Þ
0:5yðn
1Þ
yðn
2Þ
with initial conditions yð
2Þ
1, yð
1Þ
0, xð
1Þ
1, and the input xðnÞ
ð0:8ÞnuðnÞ, compute the
system response yðnÞ for 20 samples using MATLAB.
Solution:
Program 6.1 lists the MATLAB program for computing the system response yðnÞ. The top plot in Figure 6.2 shows
the input sequence. The middle plot displays the ﬁltered output using the initial conditions, and the bottom plot
shows the ﬁltered output for zero initial conditions. As we can see, the system outputs are different at the
beginning, but they approach the same value later.
Program 6.1. MATLAB program for Example 6.2.
% Example 6.2
% Compute y(n) 2x(n) 4x(n 1) 0.5y(n 1) 0.5y(n 2)
% Nonzero initial conditions:
% y( 2) 1, y( 1) 0, x( 1)
1, and x(n) (0.8)^n*u(n)
%
y
zeros(1,20);
% Set up a vector to store y(n)
y
[ 1 0 y];
% Add initial condition of y( 2) and y( 1)
n 0:1:19;
% Compute time indexes
x (0.8).^n;
% Compute 20 input samples of x(n)
6.1 The Difference Equation and Digital Filtering
163

0
2
4
6
8
10
12
14
16
18
20
0
0.5
1
Input x(n)
Sample number
0
2
4
6
8
10
12
14
16
18
20
10
0
10
Number of samples, n; part (a)
Output y(n)
0
2
4
6
8
10
12
14
16
18
20
4
2
0
2
Number of samples, n; part (b)
Output y(n)
FIGURE 6.2
Plots of the input and system outputs yðnÞ for Example 6.2.
x
[ 0
1 x];
% Add initial condition of
x( 2) 0 and x( 1) 1
for n 1:20
y(nþ2)
2*x(nþ2) 4*x(nþ1) 0.5*y(nþ1) 0.5*y(n); % Compute 20 outputs of y(n)
end
n 0:1:19;
subplot(3,1,1);stem(n,x(3:22));grid;ylabel(’Input x(n)’);xlabel(’Sample number’);
Subplot(3,1,2); stem(n,y(3:22)),grid;
xlabel(’Number of samples, n; part (a)’); ylabel(’Output y(n)’);
y(3:22)
%Output y(n)
% Zero initial conditions:
% y( 2) 0, y( 1) 0, x( 1)
0, and x(n) 1/(nþ1)
%
y
zeros(1,20);
% Set up a vector to store y(n)
y
[ 0 0 y];
% Add zero initial conditions for y( 2) and y( 1)
n 0:1:19;
% Compute time indexes
x (0.8).^n;
% Compute 20 input samples of x(n)
x
[ 0 0 x];
% Add zero initial conditions for x( 2) and x( 1)
for n 1:20
y(nþ2)
2*x(nþ2) 4*x(nþ1) 0.5*y(nþ1) 0.5*y(n); % Compute 20 outputs of y(n)
end
n 0:1:19
subplot(3,1,3); stem(n,y(3:22)),grid;
xlabel(’Number of samples, n; part (b)’); ylabel(’Output y(n)’);
y(3:22)
%Output y(n)
164
CHAPTER 6 Digital Signal Processing Systems

The MATLAB function ﬁlter(), developed using a direct-form II realization (which will be discussed
in a later section), can be used to operate digital ﬁltering, and the syntax is
Zi
ﬁltic(B, A, Yi, Xi)
y
ﬁlter(B, A, x, Zi)
where B and A are vectors for the coefﬁcients bj and aj whose formats are
A ¼ ½ 1
a1
a2
/
aN
and
B ¼ ½ b0
b1
b2
/
bM
and x and y are the input data vector and output data vector, respectively.
Note that the ﬁlter function ﬁltic() is a MATLAB function which is used to obtain initial states from
initial conditions in the difference equation. The initial states are required by the MATLAB ﬁlter
function ﬁlter() since it is implemented in a direct-form II. Hence, Zi contains initial states required for
operating MATLAB function ﬁlter(), that is,
Zi ¼ ½wð1Þ wð2Þ
/ 
which can be recovered by another MATLAB function ﬁltic(). Xi and Yi are initial conditions with the
length of the greater of M or N, given by
Xi ¼ ½xð1Þ xð2Þ /

and
Yi ¼ ½yð1Þ yð2Þ /

For zero initial conditions in particular, the syntax is reduced to
y
ﬁlter(B, A, x)
Let us verify the ﬁlter operation results in Example 6.1 using the MATLAB functions. The MATLAB
codes and results for Example 6.1(a) with the nonzero initial conditions are listed as
» B ¼ [0 1]; A ¼ [1 0 0.5];
» x ¼ [1 0.5 0.25 0.125];
» Xi ¼ [1 0];Yi¼[0 1];
» Zi ¼ ﬁltic(B, A, Yi, Xi);
» y ¼ ﬁlter(B, A, x, Zi)
y ¼
 0.5000 1.0000 0.2500 0.7500
»
For the case of zero initial conditions in Example 6.1(b), the MATLAB codes and results are
» B ¼ [0 1]; A ¼ [1 0 0.5];
» x ¼ [1 0.5 0.25 0.125];
» y ¼ ﬁlter(B, A, x)
y ¼
0 1.0000 0.5000 0.7500
»
As we expected, the ﬁlter outputs match the ones in Example 6.1.
6.1 The Difference Equation and Digital Filtering
165

6.2 DIFFERENCE EQUATION AND TRANSFER FUNCTION
To proceed in this section, Equation (6.1) is rewritten as
yðnÞ ¼ b0xðnÞ þ b1xðn  1Þ þ / þ bMxðn  MÞ
 a1yðn  1Þ  /  aNyðn  NÞ
With an assumption that all initial conditions of this system are zero, and with XðzÞ and YðzÞ denoting
the z-transforms of xðnÞ and yðnÞ, respectively, taking the z-transform of Equation (6.1) yields
YðzÞ ¼ b0XðzÞ þ b1XðzÞz 1 þ / þ bMXðzÞz M
 a1YðzÞz 1  /  aNYðzÞz N
(6.3)
Rearranging Equation (6.3), we obtain
HðzÞ ¼ YðzÞ
XðzÞ ¼ b0 þ b1z 1 þ / þ bMz M
1 þ a1z 1 þ / þ aNz N
¼ BðzÞ
AðzÞ
(6.4)
where HðzÞ is deﬁned as the transfer function with its numerator and denominator polynomials deﬁned
below:
BðzÞ ¼ b0 þ b1z 1 þ / þ bMz M
(6.5)
AðzÞ ¼ 1 þ a1z 1 þ / þ aNz N
(6.6)
Clearly the z-transfer function is deﬁned as
ratio ¼
z-transform of the output
z-transform of the input
In DSP applications, given the difference equation, we can develop the z-transfer function and
represent the digital ﬁlter in the z-domain as shown in Figure 6.3. Then the stability and frequency
response can be examined based on the developed transfer function.
EXAMPLE 6.3
A DSP system is described by the following difference equation:
yðnÞ
xðnÞ
xðn
2Þ
1:3yðn
1Þ
0:36yðn
2Þ
( )
( )
z transform input
z transform output
Digital filter transfer function
FIGURE 6.3
Digital ﬁlter transfer function.
166
CHAPTER 6 Digital Signal Processing Systems

Find the transfer function HðzÞ, the denominator polynomial AðzÞ, and the numerator polynomial BðzÞ.
Solution:
Taking the z transform on both sides of the previous difference equation, we obtain
Y ðzÞ
XðzÞ
XðzÞz2
1:3Y ðzÞz1
0:36Y ðzÞz2
Moving the last two terms to the left side of the difference equation and factoring Y ðzÞ on the left side and XðzÞ on
the right side, we obtain
Y ðzÞð1 þ 1:3z1 þ 0:36z2Þ
ð1
z2ÞXðzÞ
Therefore, the transfer function, which is the ratio of Y ðzÞ over XðzÞ, can be found to be
HðzÞ
Y ðzÞ
XðzÞ
1
z2
1 þ 1:3z1 þ 0:36z2
From the derived transfer function HðzÞ, we can obtain the denominator polynomial and numerator polynomial as
AðzÞ
1 þ 1:3z1 þ 0:36z2
and
BðzÞ
1
z2
The difference equation and its transfer function, as well as the stability issue of the linear time invariant system,
will be discussed in the following sections
EXAMPLE 6.4
A digital system is described by the following difference equation:
yðnÞ
xðnÞ
0:5xðn
1Þ þ 0:36xðn
2Þ
Find the transfer function HðzÞ, the denominator polynomial AðzÞ, and the numerator polynomial BðzÞ.
Solution:
Taking the z transform on both sides of the previous difference equation, we obtain
Y ðzÞ
XðzÞ
0:5XðzÞz2 þ 0:36XðzÞz2
Therefore, the transfer function, that is the ratio of Y ðzÞ to XðzÞ, can be found as
HðzÞ
Y ðzÞ
XðzÞ
1
0:5z1 þ 0:36z2
From the derived transfer function HðzÞ, it follows that
AðzÞ
1
BðzÞ
1
0:5z1 þ 0:36z2
6.2 Difference Equation and Transfer Function
167

In DSP applications, the given transfer function of a digital system can converted into a difference
equation for DSP implementation. The following example illustrates the procedure.
EXAMPLE 6.5
Convert each of the following transfer functions into its difference equation.
a. HðzÞ
z2
1
z2 þ 1:3z þ 0:36
b. HðzÞ
z2
0:5z þ 0:36
z2
Solution:
a. Dividing the numerator and denominator by z2 to obtain the transfer function whose numerator and denominator
polynomials have the negative power of z, it follows that
HðzÞ
ðz2
1Þ=z2
ðz2 þ 1:3z þ 0:36Þ=z2
1
z2
1 þ 1:3z1 þ 0:36z2
We write the transfer function using the ratio of Y ðzÞ to XðzÞ :
Y ðzÞ
XðzÞ
1
z2
1 þ 1:3z1 þ 0:36z2
Then we have
Y ðzÞð1 þ 1:3z1 þ 0:36z2Þ
XðzÞð1
z2Þ
By distributing Y ðzÞ and XðzÞ, we yield
Y ðzÞ þ 1:3z1Y ðzÞ þ 0:36z2Y ðzÞ
XðzÞ
z2XðzÞ
Applying the inverse z transform and using the shift property in Equation (5.3) of Chapter 5, we get
yðnÞ þ 1:3yðn
1Þ þ 0:36yðn
2Þ
xðnÞ
xðn
2Þ
Writing the output yðnÞ in terms of inputs and past outputs leads to
yðnÞ
xðnÞ
xðn
2Þ
1:3yðn
1Þ
0:36yðn
2Þ
b. Similarly, dividing the numerator and denominator by z2, we obtain
HðzÞ
Y ðzÞ
XðzÞ
ðz2
0:5z þ 0:36Þ=z2
z2=z2
1
0:5z1 þ 0:36z2
Thus
Y ðzÞ
XðzÞð1
0:5z1 þ 0:36z2Þ
By distributing XðzÞ, we yield
Y ðzÞ
XðzÞ
0:5z1XðzÞ þ 0:36z2XðzÞ
Applying the inverse z transform with using the shift property in Equation (5.3), we obtain
yðnÞ
xðnÞ
0:5xðn
1Þ þ 0:36xðn
2Þ
168
CHAPTER 6 Digital Signal Processing Systems

The transfer function HðzÞ can be factored into the pole zero form:
HðzÞ
b0ðz
z1Þðz
z2Þ/ðz
zMÞ
ðz
p1Þðz
p2Þ/ðz
pNÞ
(6.7)
where the zeros zi can be found by solving roots of the numerator polynomial, while the poles pi can be solved for
the roots of the denominator polynomial.
EXAMPLE 6.6
Consider the following transfer functions:
HðzÞ
1
z2
1 þ 1:3z1 þ 0:36z2
Convert it into the pole zero form.
Solution:
We ﬁrst multiply the numerator and denominator polynomials by z2 to achieve the advanced form in which both
numerator and denominator polynomials have positive powers of z, that is,
HðzÞ
ð1
z2Þz2
ð1 þ 1:3z1 þ 0:36z2Þz2
z2
1
z2 þ 1:3z þ 0:36
Letting z2
1
0, we get z
1 and z
1. Setting z2 þ 1:3z þ 0:36
0 leads to z
0:4 and z
0:9.
We then can write numerator and denominator polynomials in the factored form to obtain the pole zero form:
HðzÞ
ðz
1Þðz þ 1Þ
ðz þ 0:4Þðz þ 0:9Þ
6.2.1 Impulse Response, Step Response, and System Response
The impulse response hðnÞ of the DSP system HðzÞ can be obtained by solving its difference equation
using a unit impulse input dðnÞ. With the help of the z-transform and noticing that XðzÞ ¼ ZfdðnÞg1,
we yield
hðnÞ ¼ Z
1fHðzÞXðzÞg ¼ Z
1fHðzÞg
(6.8)
Similarly, for a step input, we can determine step response assuming zero initial conditions. Letting
XðzÞ ¼ Z½uðnÞ ¼
z
z  1
the step response can be found as
yðnÞ ¼ Z
1

HðzÞ
z
z  1

(6.9)
Furthermore, the z-transform of the general system response is given by
YðzÞ ¼ HðzÞXðzÞ
(6.10)
6.2 Difference Equation and Transfer Function
169

If we know the transfer function HðzÞ and z-transform of the input XðzÞ, we are able to determine the
system response yðnÞ by ﬁnding the inverse z-transform of the output YðzÞ :
yðnÞ ¼ Z
1fYðzÞg
(6.11)
EXAMPLE 6.7
Given a transfer function depicting a DSP system
HðzÞ
z þ 1
z
0:5
determine
a. the impulse response hðnÞ,
b. step response yðnÞ, and
c. system response yðnÞ if the input is given as xðnÞ
ð0:25ÞnuðnÞ.
Solution:
a. The transfer function can be rewritten as
HðzÞ
z
z þ 1
zðz
0:5Þ
A
z þ
B
z
0:5
where
A
z þ 1
ðz
0:5Þ

z
0
2 and B
z þ 1
z

z
0:5
3
Thus we have
HðzÞ
z
2
z þ
3
z
0:5
and
HðzÞ

2
z þ
3
z
0:5

z
2 þ
3z
z
0:5
By taking the inverse z transform as shown in Equation (6.8), we yield the impulse response
hðnÞ
2dðnÞ þ 3ð0:5ÞnuðnÞ
b. For the step input xðnÞ
uðnÞ and its z transform XðzÞ
z
z
1, we can determine the z transform of the step
response as
Y ðzÞ
HðzÞXðzÞ
z þ 1
z
0:5
z
z
1
Applying the partial fraction expansion leads to
Y ðzÞ
z
z þ 1
ðz
0:5Þðz
1Þ
A
z
0:5 þ
B
z
1
170
CHAPTER 6 Digital Signal Processing Systems

where
A
z þ 1
z
1

z
0:5
3
and
B
z þ 1
z
0:5

z
1
4
The z transform step response is therefore
Y ðzÞ
3z
z
0:5 þ
4z
z
1
Applying the inverse z transform table yields the step response as
yðnÞ
3ð0:5ÞnuðnÞ þ 4uðnÞ
c. To determine the system output response, we ﬁrst ﬁnd the z transform of the input xðnÞ,
XðzÞ
Zfð0:25ÞnuðnÞg
z
z
0:25
Then Y ðzÞ can be obtained via Equation (6.10), that is,
Y ðzÞ
HðzÞXðzÞ
z þ 1
z
0:5$
z
z
0:25
zðz þ 1Þ
ðz
0:5Þðz
0:25Þ
Using the partial fraction expansion, we have
Y ðzÞ
z
ðz þ 1Þ
ðz
0:5Þðz
0:25Þ

A
z
0:5 þ
B
z
0:25

0
1
2
3
4
5
6
7
8
9
10
0
1
2
Sample number
(a)Impu se response
0
1
2
3
4
5
6
7
8
9
10
0
2
4
Sample number
(b)Step response
0
1
2
3
4
5
6
7
8
9
10
0
1
2
Sample number
(c)System response
FIGURE 6.4
Impulse, step, and system response in Example 6.7.
6.2 Difference Equation and Transfer Function
171

Y ðzÞ

6z
z
0:5 þ
5z
z
0:25

Using Equation (6.11) and Table 5.1 in Chapter 5, we ﬁnally yield
yðnÞ
Z 1fY ðzÞg
6ð0:5ÞnuðnÞ
5ð0:25ÞnuðnÞ
The impulse response for (a), step response for (b), and system response for (c) are each plotted in Figure 6.4.
6.3 THE Z-PLANE POLE-ZERO PLOT AND STABILITY
A very useful tool to analyze digital systems is the z-plane pole-zero plot. This graphical technique
allows us to investigate characteristics of the digital system shown in Figure 6.1, including the system
stability. In general, a digital transfer function can be written in the pole-zero form as shown in
Equation (6.7), and we can plot the poles and zeros on the z-plane. The z-plane is depicted in
Figure 6.5 and has the following features:
1. The horizontal axis is the real part of the variable z, and the vertical axis represents the imaginary
part of the variable z.
2. The z-plane is divided into two parts by a unit circle.
3. Each pole is marked on z-plane using the cross symbol x, while each zero is plotted using the small
circle symbol o.
Let’s investigate the z-plane pole-zero plot of a digital ﬁlter system via the following example.
FIGURE 6.5
z-plane and pole-zero plot.
172
CHAPTER 6 Digital Signal Processing Systems

EXAMPLE 6.8
Given the digital transfer function
HðzÞ
z1
0:5z2
1 þ 1:2z1 þ 0:45z2
plot poles and zeros.
Solution:
Converting the transfer function to its advanced form by multiplying the numerator and denominator by z2, it
follows that
HðzÞ
ðz1
0:5z2Þz2
ð1 þ 1:2z1 þ 0:45z2Þz2
z
0:5
z2 þ 1:2z þ 0:45
By setting z2 þ 1:2z þ 0:45
0 and z
0:5
0, we obtain two poles
p1
0:6 þ j0:3
p2
p
1
0:6
j0:3
and a zero z1
0:5, which are plotted on the z plane shown in Figure 6.6. According to the form of Equation
(6.7), we also yield the pole zero form as
HðzÞ
z1
0:5z2
1 þ 1:2z1 þ 0:45z2
ðz
0:5Þ
ðz þ 0:6
j0:3Þðz þ 0:6 þ j0:3Þ
With zeros and poles plotted on the z-plane, we are able to study system stability. We ﬁrst establish
the relationship between the s-plane in the Laplace domain and the z-plane in the z-transform domain,
as illustrated in Figure 6.7.
FIGURE 6.6
The z-plane pole-zero plot of Example 6.8.
6.3 The z Plane Pole Zero Plot and Stability
173

As shown in Figure 6.7, the sampled signal, which is not quantized, with a sampling period of T is
written as
xsðtÞ ¼
X
N
n ¼ 0
xðnTÞdðt  nTÞ ¼ xð0ÞdðtÞ þ xðTÞdðt  TÞ þ xð2TÞdðt  2TÞ þ /
(6.12)
Taking the Laplace transform and using the Laplace shift property as
Lðdðt  nTÞÞ ¼ e nTs
(6.13)
leads to
XsðsÞ ¼
X
N
n ¼ 0
xðnTÞe nTs ¼ xð0Þe 0Ts þ xðTÞe Ts þ xð2TÞe 2Ts þ /
(6.14)
Compare Equation (6.14) with the deﬁnition of a one-sided z-transform of the data sequence xðnÞ from
analog-to-digital conversion (ADC):
XðzÞ ¼ ZðxðnÞÞ ¼
X
N
n ¼ 0
xðnÞz n ¼ xð0Þz 0 þ xð1Þz 1 þ xð2Þz 2 þ /
(6.15)
Clearly, we see the relationship of the sampled system in the Laplace domain and its digital system in
the z-transform domain by the following mapping:
z ¼ esT
(6.16)
Substituting s ¼ a  ju into Equation (6.16), it follows that z ¼ e aTjuT. In the polar form, we
have
z ¼ e aT:  uT
(6.17)
Equations (6.16) and (6.17) give the following important conclusions.
FIGURE 6.7
Relationship between Laplace transform and z-transform.
174
CHAPTER 6 Digital Signal Processing Systems

If a > 0, this means jzj ¼ e aT < 1. Then the left-hand side half plane (LHHP) of the s-plane
is mapped to the inside of the unit circle of the z-plane. When a ¼ 0, this causes jzj ¼ e aT ¼ 1.
Thus the ju axis of the s-plane is mapped on the unit circle of the z-plane, as shown in Figure 6.8.
Obviously, the right-hand half plane (RHHP) of the s-plane is mapped to the outside of the unit
cycle in the z-plane. A stable system means that for a given bounded input, the system output must
be bounded. Similar to the analog system, the digital system requires that all poles plotted on the
z-plane must be inside the unit circle. We summarize the rules for determining the stability of
a DSP system as follows:
1. If the outmost pole(s) of the z-transfer function HðzÞ describing the DSP system is (are) inside the
unit circle on the z-plane pole-zero plot, then the system is stable.
2. If the outmost pole(s) of the z-transfer function HðzÞ is (are) outside the unit circle on the z-plane
pole-zero plot, the system is unstable.
3. If the outmost pole(s) is (are) ﬁrst-order pole(s) of the z-transfer function HðzÞ and on the unit circle
on the z-plane pole-zero plot, then the system is marginally stable.
4. If the outmost pole(s) is (are) multiple-order pole(s) of the z-transfer function HðzÞ and on the unit
circle on the z-plane pole-zero plot, then the system is unstable.
5. The zeros do not affect the system stability.
Notice that the following facts apply to a stable system (bounded-in/bounded-out [BIBO] stability
discussed in Chapter 3):
1. If the input to the system is bounded, then the output of the system will also be bounded, or the
impulse response of the system will go to zero in a ﬁnite number of steps.
2. An unstable system is one where the output of the system will grow without bound due to any
bounded input, initial condition, or noise, or the impulse response will grow without bound.
3. The impulse response of a marginally stable system stays at a constant level or oscillates between
two ﬁnite values.
Examples illustrating these rules are shown in Figure 6.9.
FIGURE 6.8
Mapping between s-plane and z-plane.
6.3 The z Plane Pole Zero Plot and Stability
175

EXAMPLE 6.9
The following transfer functions describe digital systems.
a. HðzÞ
z þ 0:5
ðz
0:5Þðz2 þ z þ 0:5Þ
b. HðzÞ
z2 þ 0:25
ðz
0:5Þðz2 þ 3z þ 2:5Þ
FIGURE 6.9
Stability illustrations.
176
CHAPTER 6 Digital Signal Processing Systems

c. HðzÞ
z þ 0:5
ðz
0:5Þðz2 þ 1:4141z þ 1Þ
d. HðzÞ
z2 þ z þ 0:5
ðz
1Þ2ðz þ 1Þðz
0:6Þ
For each, sketch the z plane pole zero plot and determine the stability status for the digital system.
Solution:
a. A zero is located at z
0:5.
Poles: z
0:5, jzj
0:5 < 1; z
0:5  j0:5,
jzj
ð 0:5Þ2 þ ð0:5Þ2
q
0:707 < 1.
The plot of poles and a zero is shown in Figure 6.10. Since the outmost poles are inside the unit circle, the system
is stable.
b. Zeros are z
 j0:5.
Poles: z
0:5, jzj
0:5 < 1; z
1:5  j0:5
jzj
ð1:5Þ2 þ ð0:5Þ2
q
1:5811 > 1.
The plot of poles and zeros is shown in Figure 6.10. Since we have two poles at z
1:5  j 0:5 that are outside
the unit circle, the system is unstable.
c. A zero is located at z
0:5.
(a)
(c)
(d)
(b)
FIGURE 6.10
Pole-zero plots for Example 6.9.
6.3 The z Plane Pole Zero Plot and Stability
177

Poles: z
0:5, jzj
0:5 < 1; z
0:707  j0:707,
jzj
ð0:707Þ2 þ ð 0:707Þ2
q
1.
The zero and poles are plotted in Figure 6.10. Since the outmost poles are ﬁrst order at z
0:707  j 0:707
and are on the unit circle, the system is marginally stable.
d. Zeros are z
0:5  j 0:5.
Poles: z
1, jzj
1; z
1, jzj
1; z
1, jzj
1;, z
0:6
jzj
0:6 < 1.
The zeros and poles are plotted in Figure 6.10. Since the outmost pole is a multiple order (second order) pole at
z
1 and is on the unit circle, the system is unstable.
6.4 DIGITAL FILTER FREQUENCY RESPONSE
From the Laplace transfer function, we can achieve the analog ﬁlter steady-state frequency response
HðjuÞ by substituting s ¼ ju into the transfer function HðsÞ. That is,
HðsÞjs¼ju ¼ HðjuÞ
Then we can study the magnitude frequency response jHðjuÞj and phase response:HðjuÞ. Similarly,
in a DSP system, using the mapping in Equation (6.16), we substitute z ¼ esT
s¼ju ¼ ejuT into the
z-transfer function HðzÞ to acquire the digital frequency response, which is converted into the
magnitude frequency response
HðejuTÞ
 and phase response:jHðejuTÞj. That is,
HðzÞjz¼ejuT ¼ HðejuTÞ ¼
HðejuTÞ
:HðejuTÞ
(6.18)
Let us introduce a normalized digital frequency in radians in the digital domain:
U ¼ uT
(6.19)
Then the digital frequency response in Equation (6.18) becomes
HðejUÞ ¼ HðzÞ

z¼ejU ¼
HðejUÞ
:HðejUÞ
(6.20)
The formal derivation for Equation (6.20) can be found in Appendix D.
Now we verify the frequency response via the following simple digital ﬁlter. Consider a digital
ﬁlter with a sinusoidal input of amplitude K (Figure 6.11).
We can determine the system output yðnÞ, which consists of the transient response ytrðnÞ and the
steady-state response yssðnÞ. We ﬁnd the z-transform output as
FIGURE 6.11
System transient and steady-state frequency responses.
178
CHAPTER 6 Digital Signal Processing Systems

YðzÞ ¼
0:5z þ 0:5
z

Kz sin U
z2  2z cos U þ 1
(6.21)
To perform the inverse z-transform to ﬁnd the system output, we further rewrite Equation (6.21) as
YðzÞ
z
¼
0:5z þ 0:5
z

K sin U
ðz  ejUÞðz  e jUÞ ¼ A
z þ
B
z  ejU þ
B
z  e jU
where A, B and the complex conjugate B are the constants for the partial fractions. Applying the
partial fraction expansion leads to
A ¼ 0:5K sin U
B ¼ 0:5z þ 0:5
z

z¼ejU
K
2j ¼
HðejUÞ
ej:HðejUÞK
2j
Notice that the ﬁrst part of constant B is a complex function, which is obtained by substituting z ¼
ejU into the ﬁlter z-transfer function. We can also express the complex function in terms of the polar
form:
0:5z þ 0:5
z

z¼ejU ¼ 0:5 þ 0:5z 1
z¼ejU ¼ HðzÞjz¼ejU ¼ HðejUÞ ¼
HðejUÞ
ej:HðejUÞ
where HðejUÞ ¼ 0:5 þ 0:5e jU. We call this complex function the steady-state frequency response.
Based on the complex conjugate property, we get another residue as
B ¼
HðejUÞ
e j:HðejUÞ K
j2
The z-transform system output is then given by
YðzÞ ¼ A þ
Bz
z  ejU þ
Bz
z  e jU
Taking the inverse z-transform, we achieve the following system transient and steady-state responses:
yðnÞ ¼ 0:5K sin UdðnÞ
|ﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄ{zﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄ}
ytrðnÞ
þ
HðejUÞ
ej:HðejUÞK
j2ejnUuðnÞ þ
HðejUÞ
e j:HðejUÞ K
j2e jnUuðnÞ
|ﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄ{zﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄ}
yssðnÞ
Simplifying the response yields the form
yðnÞ ¼ 0:5K sin UdðnÞ þ
HðejUÞ
K ejnUþj:HðejUÞuðnÞ  e jnU j:HðejUÞuðnÞ
j2
We can further combine the last term using Euler’s formula to express the system response as
yðnÞ ¼
0:5K sin UdðnÞ
|ﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄ{zﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄ}
ytrðnÞwill decay to zero after the first sample
þ
HðejUÞ
K sin ðnU þ :HðejUÞÞuðnÞ
|ﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄ{zﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄ}
yssðnÞ
6.4 Digital Filter Frequency Response
179

Finally, the steady-state response is identiﬁed as
yssðnÞ ¼ K
HðejUÞ
 sin ðnU þ :HðejUÞÞuðnÞ
For this particular ﬁlter, the transient response exists for only the ﬁrst sample in the system response.
By substituting n ¼ 0 into yðnÞ and after simplifying algebra, we achieve the response for the ﬁrst
output sample:
yð0Þ ¼ ytrð0Þ þ yssð0Þ ¼ 0:5K sin ðUÞ  0:5K sin ðUÞ ¼ 0
Note that the ﬁrst output sample of the transient response cancels the ﬁrst output sample of the steady-
state response, so the combined ﬁrst output sample has a value of zero for this particular ﬁlter. The
system response reaches the steady-state response after the ﬁrst output sample. At this point, we can
conclude that
Steady-state magnitude frequency response ¼ Peak amplitude of steady state response at U
Peak amplitude of sinusoidal input at U
¼
HðejUÞ
K
K
¼
HðejUÞ

Steady-state phase frequency response ¼ Phase difference ¼ :HðejUÞ
Figure 6.12 shows the system response with sinusoidal inputs at U ¼ 0:25p, U ¼ 0:5p, and
U ¼ 0:75p, respectively.
Next, we examine the properties of the ﬁlter frequency response HðejUÞ. From Euler’s identity and
the trigonometric identity, we know that
ejðUþk2pÞ ¼ cos ðU þ k2pÞ þ j sin ðU þ k2pÞ
¼ cos U þ j sin U ¼ ejU
where k is an integer taking values of k ¼ 0; 1; 2; /. Then the frequency response has the
following property (assuming all input sequences are real):
1. Periodicity
a. Frequency response: HðejUÞ ¼ HðejðUþk2pÞÞ
b. Magnitude frequency response:
HðejUÞ
 ¼ jHðejðUþk2pÞÞj
c. Phase response: :HðejUÞ ¼ :HðejUþk2pÞ
The second property is given without proof (see proof in Appendix D):
2. Symmetry
a. Magnitude frequency response:
Hðe jUÞ
 ¼ jHðejUÞj
b. Phase response: :Hðe jUÞ ¼ :HðejUÞ
Since the maximum frequency in a DSP system is the folding frequency, fs=2, where fs ¼ 1=T,
and T designates the sampling period, the corresponding maximum normalized frequency of the
system frequency can be calculated as
180
CHAPTER 6 Digital Signal Processing Systems

U ¼ uT ¼ 2p fs
2  T ¼ p radians
(6.22)
The frequency response HðejUÞ for jUjip consists of the image replicas of HðejUÞ for jUj  p and will
be removed via the reconstruction ﬁlter later. Hence, we need to evaluate HðejUÞ for only the positive
normalized frequency range from U ¼ 0 to U ¼ p radians. The frequency, in Hz, can be determined
by
f ¼ U
2p fs
(6.23)
The magnitude frequency response is often expressed in decibels, deﬁned as
HðejUÞ

dB ¼ 20 log10ð
HðejUÞ
	
(6.24)
The DSP system stability, magnitude response, and phase response are investigated via the following
examples.
EXAMPLE 6.10
Given the digital system
yðnÞ
0:5xðnÞ þ 0:5xðn
1Þ
with a sampling rate of 8,000 Hz, determine the frequency response.
0
5
10
15
20
25
30
35
40
45
50
2
0
2
Omega=0.25*p
0
5
10
15
20
25
30
35
40
45
50
2
0
2
Omega=0.5*p
0
5
10
15
20
25
30
35
40
45
50
2
0
2
Omega=0.75*p
Sample number
Steady state response
Steady state response
Steady state response
FIGURE 6.12
The digital ﬁlter responses to different input sinusoids.
6.4 Digital Filter Frequency Response
181

Solution:
Taking the z transform on both sides on the difference equation leads to
Y ðzÞ
0:5XðzÞ þ 0:5z1XðzÞ
Then the transfer function describing the system is easily found to be
HðzÞ
Y ðzÞ
XðzÞ
0:5 þ 0:5z1
Substituting z
ejU, we obtain the frequency response as
HðejUÞ
0:5 þ 0:5ejU
0:5 þ 0:5 cos ðUÞ
j0:5 sin ðUÞ:
Therefore, the magnitude frequency response and phase response are given by
HðejUÞ

ð0:5 þ 0:5 cos ðUÞÞ2 þ ð0:5 sin ðUÞÞ2
q
and
:HðejUÞ
tan1

0:5 sin ðUÞ
0:5 þ 0:5 cos ðUÞ

Several points for the magnitude response and phase response are calculated and shown in Table 6.1. According to
the data, we plot the frequency response and phase response of the DSP system in Figure 6.13.
0
0.5
1
1.5
2
2.5
3
100
50
0
Frequency (radians)
Phase response (degrees)
0
0.5
1
1.5
2
2.5
3
40
30
20
10
0
Frequency (radians)
Magn tude response (dB)
FIGURE 6.13
Frequency responses of the digital ﬁlter in Example 6.10.
182
CHAPTER 6 Digital Signal Processing Systems

It is observed that when the frequency increases, the magnitude response decreases. The DSP system
acts like a digital lowpass ﬁlter, and its phase response is linear.
We can also verify the periodicity for
HðejUÞ
 and :HðejUÞ when U ¼ 0:25p þ 2p:
Hðejð0:25pþ2pÞÞ
 ¼
ð0:5 þ 0:5 cos ð0:25p þ 2pÞÞ2 þ ð0:5 sin ð0:25p þ 2pÞÞ2
q
¼ 0:924 ¼
Hðej0:25pÞ

:Hðejð0:25pþ2pÞÞ ¼ tan 1

0:5 sin ð0:25p þ 2pÞ
0:5 þ 0:5 cos ð0:25p þ 2pÞ

¼ 22:50 ¼ :Hðej0:25pÞ:
For U ¼ 0:25p, we can verify the symmetry property as
Hðe j0:25pÞ
 ¼
ð0:5 þ 0:5 cos ð0:25pÞÞ2 þ ð0:5 sin ð0:25pÞÞ2
q
¼ 0:924 ¼
Hðej0:25pÞ

:Hðe j0:25pÞ ¼ tan 1

0:5 sin ð0:25pÞ
0:5 þ 0:5 cos ð0:25pÞ

¼ 22:50 ¼ :Hðej0:25pÞ
The properties can be observed in Figure 6.14, where the frequency range is chosen from U ¼ 2p to
U ¼ 4p radians. As shown in the ﬁgure, the magnitude and phase responses are periodic with a period
of 2p. For a period between U ¼ p to U ¼ p, the magnitude responses for the portion U ¼ p to
U ¼ 0 and the portion U ¼ 0 to U ¼ p are the same, while the phase responses are opposite. Since the
magnitude and phase responses calculated for the range from U ¼ 0 to U ¼ p are sufﬁcient to present
frequency response information, this range is only required for generating the frequency response plots.
Again, note that the phase plot shows a sawtooth shape instead of a linear straight line for this
particular ﬁlter. This is due to the phase wrapping at U ¼ 2p radians since ejðUþk2pÞ ¼ ejU is used
in the calculation. However, the phase plot shows that the phase is linear in the range from U ¼ 0
to U ¼ p radians.
Table 6.1 Frequency Response Calculations for Example 6.10
U (radians)
f [ U
2p fs (Hz)
HðejUÞ

HðejUÞ

dB
:HðejUÞ
0
0
1.000
0 dB
00
0:25p
1,000
0.924
0.687 dB
22:50
0:50p
2,000
0.707
3.012 dB
45:000
0:75p
3,000
0.383
8.336 dB
67:500
1:00p
4,000
0.000
N
900
6.4 Digital Filter Frequency Response
183

EXAMPLE 6.11
Given a digital system
yðnÞ
xðnÞ
0:5yðn
1Þ
with a sampling rate of 8,000 Hz, determine the frequency response.
Solution:
Taking the z transform on both sides of the difference equation leads to
Y ðzÞ
XðzÞ
0:5z1Y ðzÞ
Then the transfer function describing the system is easily found to be
HðzÞ
Y ðzÞ
XðzÞ
1
1 þ 0:5z1
z
z þ 0:5
Substituting z
ejU, we have the frequency response as
HðejUÞ
1
1 þ 0:5ejU
1
1 þ 0:5 cos ðUÞ
j0:5 sin ðUÞ
6
4
2
0
2
4
6
8
10
12
0
0.5
1
Frequency (radians)
Magn tude response
6
4
2
0
2
4
6
8
10
12
100
50
0
50
100
Frequency (radians)
Phase response (degrees)
FIGURE 6.14
Periodicity of the magnitude response and phase response in Example 6.10.
184
CHAPTER 6 Digital Signal Processing Systems

Therefore, the magnitude frequency response and phase response are given by
H

ejU
1
ð1 þ 0:5 cos ðUÞÞ2þð0:5 sin ðUÞÞ2
q
and
:HðejUÞ
tan1

0:5 sin ðUÞ
1 þ 0:5 cos ðUÞ

Several points for the magnitude response and phase response are calculated and shown in Table 6.2. The
magnitude response and phase response of the DSP system are roughly plotted in Figure 6.15 in accordance with
the obtained data.
0
0.5
1
1.5
2
2.5
3
10
0
10
20
30
40
Frequency (radians)
Phase response (degrees)
0
0.5
1
1.5
2
2.5
3
10
5
0
5
10
Frequency (radians)
Magn tude response (dB)
FIGURE 6.15
Frequency responses of the digital ﬁlter in Example 6.11.
Table 6.2 Frequency Response Calculations in Example 6.11
U (radians)
f [ U
2p fs (Hz)
HðejUÞ

HðejUÞ

dB
:HðejUÞ
0
0
0.670
3.479 dB
00
0:25p
1,000
0.715
2.914 dB
14:640
0:50p
2,000
0.894
0.973 dB
26:570
0:75p
3,000
1.357
2.652 dB
28:680
1:00p
4,000
2.000
6.021 dB
00
6.4 Digital Filter Frequency Response
185

From Table 6.2 and Figure 6.15, we can see that when the frequency increases, the magnitude
response increases. The DSP system actually performs digital highpass ﬁltering.
Notice that if all the coefﬁcients ai for i ¼ 0; 1; /; M in Equation (6.1) are zeros, Equation (6.2) is
reduced to
yðnÞ ¼ P
M
i ¼ 0
bixðn  iÞ
¼ b0xðnÞ þ b1xðn  1Þ þ / þ bKxðn  MÞ
(6.25)
Notice that bi is the ith impulse response coefﬁcient. Also, since M is a ﬁnite positive integer, bi in this
particular case is a ﬁnite set, HðzÞ ¼ BðzÞ; note that the denominator AðzÞ ¼ 1. Such systems are
called ﬁnite impulse response (FIR) systems. If not all ai in Equation (6.1) are zeros, the impulse
response hðiÞ would consist of an inﬁnite number of coefﬁcients. Such systems are called inﬁnite
impulse response (IIR) systems. The z-transform of the IIR hðiÞ, in general, is given by
HðzÞ ¼ BðzÞ
AðzÞ
where AðzÞs1.
6.5 BASIC TYPES OF FILTERING
The basic ﬁlter types can be classiﬁed into four categories: lowpass, highpass, . bandpass, and
bandstop. Each of them ﬁnds a speciﬁc application in digital signal processing. One of the objectives in
applications may involve the design of digital ﬁlters. In general, the ﬁlter is designed based on the
speciﬁcations primarily for the passband, stopband, and transition band of the ﬁlter frequency
response. The ﬁlter passband is the frequency range with the amplitude gain of the ﬁlter response being
approximately unity. The ﬁlter stopband is deﬁned as the frequency range over which the ﬁlter
magnitude response is attenuated to eliminate the input signal whose frequency components are within
that range. The transition band denotes the frequency range between the passband and stopband.
1
p
1-
p
s
1.0
0
p
s
Passband
Transition
Stopband
FIGURE 6.16
Magnitude response of the normalized lowpass ﬁlter.
186
CHAPTER 6 Digital Signal Processing Systems

The design speciﬁcations of the lowpass ﬁlter are illustrated in Figure 6.16, where the low-
frequency components are passed through the ﬁlter while the high-frequency components are atten-
uated. As shown in Figure 6.16, Up and Us are the passband cutoff frequency and the stopband cutoff
frequency, respectively; dp is the design parameter to specify the ripple (ﬂuctuation) of the frequency
response in the passband; and ds speciﬁes the ripple of the frequency response in the stopband.
The highpass ﬁlter keeps high-frequency components and rejects low-frequency components. The
magnitude frequency response for the highpass ﬁlter is demonstrated in Figure 6.17.
The bandpass ﬁlter attenuates both low- and high-frequency components while keeping the middle-
frequency components, as shown in Figure 6.18.
As illustrated in Figure 6.18, UpL and UsL are the lower passband cutoff frequency and lower
stopband cutoff frequency, respectively. UpH and UsH are the upper passband cutoff frequency and
upper stopband cutoff frequency, respectively. dp is the design parameter to specify the ripple of the
frequency response in the passband, while ds speciﬁes the ripple of the frequency response in the
stopband.
1
p
1-
p
s
1.0
0
p
s
Passband
Transition
Stopband
0
FIGURE 6.17
Magnitude response of the normalized highpass ﬁlter.
1
p
1-
p
s
1.0
0
Passband
Transition
Stopband
0
Stopband
Transition
sL
pL
pH
sH
FIGURE 6.18
Magnitude response of the normalized bandpass ﬁlter.
6.5 Basic Types of Filtering
187

Finally, the bandstop (band reject or notch) ﬁlter shown in Figure 6.19 rejects the middle-frequency
components and accepts both the low- and the high-frequency components.
As a matter of fact, all kinds of digital ﬁlters are implemented using FIR or IIR systems.
Furthermore, the FIR and IIR systems can each be realized by various ﬁlter conﬁgurations, such as
direct forms, cascade forms, and parallel forms. Such topics will be included in the next section.
Given a transfer function, the MATLAB function freqz() can be used to determine the frequency
response. The syntax is given by
[h, w]
freqz(B, A, N)
where the parameters are deﬁned as follows:
h ¼ an output vector containing frequency response
w ¼ an output vector containing normalized frequency values distributed in the range from 0 to
p radians
B ¼ an input vector for numerator coefﬁcients
A ¼ an input vector for denominator coefﬁcients
N ¼ the number of normalized frequency points used for calculating the frequency response
Let’s consider Example 6.12.
EXAMPLE 6.12
Consider the following digital transfer function:
a. HðzÞ
z
z
0:5
b. HðzÞ
1
0:5z1
c. HðzÞ
0:5z2
0:32
z2
0:5z þ 0:25
d. HðzÞ
1
0:9z1 þ 0:81z2
1
0:6z1 þ 0:36z2
1
p
1-
p
s
1.0
0
0
sL
pL
pH
sH
Passband
Transition
Stopband
Transition
Passband
FIGURE 6.19
Magnitude of the normalized bandstop ﬁlter.
188
CHAPTER 6 Digital Signal Processing Systems

1. Plot the poles and zeros on the z plane.
2. Use the MATLAB function freqz() to plot the magnitude frequency response and phase response for each
transfer function.
3. Identify the corresponding ﬁlter type (e.g., lowpass, highpass, bandpass, or bandstop).
Solution:
1. The pole zero plot for each transfer function is demonstrated in Figure 6.20. The transfer functions of (a) and (c)
need to be converted into the standard form (delay form) required by the MATLAB function freqz(), in which both
numerator and denominator polynomials have negative powers of z. Hence, we obtain
HðzÞ
z
z
0:5
1
1
0:5z1
HðzÞ
0:5z2
0:32
z2
0:5z þ 0:25
0:5
0:32z2
1
0:5z1 þ 0:25z2
while the transfer functions of (b) and (d) are already in their standard forms (delay forms).
2. The MATLAB program for plotting the magnitude frequency response and the phase response for each case is
listed in Program 6.2.
3. From the plots in Figures 6.21Ae6.21D of magnitude frequency responses for all cases, we can conclude that
case (a) is a low pass ﬁlter, (b) is a high pass ﬁlter, (c) is a bandpass ﬁlter, and (d) is a bandstop (band reject) ﬁlter.
(a)
(b)
(c)
(d)
FIGURE 6.20
Pole-zero plots of Example 6.12.
6.5 Basic Types of Filtering
189

0
0.5
1
1.5
2
2.5
3
3.5
0.5
1
1.5
2
Frequency (radians)
Magn tude
0
0.5
1
1.5
2
2.5
3
3.5
30
20
10
0
Frequency (radians)
Phase (degrees)
(a)
FIGURE 6.21A
Plots of frequency responses for Example 6.12 for (a).
0
0.5
1
1.5
2
2.5
3
3.5
0.5
1
1.5
Frequency (radians)
Magn tude
0
0.5
1
1.5
2
2.5
3
3.5
0
10
20
30
Frequency (radians)
Phase (degrees)
(b)
FIGURE 6.21B
Plots of frequency responses for Example 6.12 for (b).
190
CHAPTER 6 Digital Signal Processing Systems

0
0.5
1
1.5
2
2.5
3
3.5
0
0.5
1
1.5
Frequency (radians)
Magn tude
0
0.5
1
1.5
2
2.5
3
3.5
60
40
20
0
20
40
Frequency (radians)
Phase (degrees)
(c)
FIGURE 6.21C
Plots of frequency responses for Example 6.12 for (c).
0
0.5
1
1.5
2
2.5
3
3.5
0
0.5
1
1.5
Frequency (radians)
Magn tude
0
0.5
1
1.5
2
2.5
3
3.5
40
20
0
20
40
60
Frequency (radians)
Phase (degrees)
(d)
FIGURE 6.21D
Plots of frequency responses for Example 6.12 for (d).
6.5 Basic Types of Filtering
191

Program 6.2. MATLAB program for Example 6.12.
% Example 6.12
% Plot the frequency response and phase response
% Case a
ﬁgure (1)
[h w]
freqz([1],[1
0.5],1024);
% Calculate frequency response
phi 180*unwrap(angle(h))/pi;
subplot(2,1,1), plot(w,abs(h)),grid; xlabel(’Frequency (radians)’),
ylabel(’Magnitude’)
subplot(2,1,2), plot(w,phi),grid; xlabel(’Frequency (radians)’), ylabel(’Phase
(degrees)’)
% Case b
ﬁgure (2)
[h w]
freqz([1
0.5],[1],1024);
% Calculate frequency response
phi 180*unwrap(angle(h))/pi;
subplot(2,1,1), plot(w,abs(h)),grid;xlabel(’Frequency (radians)’),
ylabel(’Magnitude’)
subplot(2,1,2), plot(w,phi),grid; xlabel(’Frequency (radians)’), ylabel(’Phase
(degrees)’)
% Case c
ﬁgure (3)
[h w]
freqz([0.5 0
0.32],[1
0.5 0.25],1024); % Calculate frequency response
phi 180*unwrap(angle(h))/pi;
subplot(2,1,1), plot(w,abs(h)),grid;
xlabel(’Frequency (radians)’),ylabel(’Magnitude’)
subplot(2,1,2), plot(w,phi),grid;
xlabel(’Frequency (radians)’), ylabel(’Phase (degrees)’)
% Case d
ﬁgure (4)
[h w]
freqz([1
0.9 0.81], [1
0.6 0.36],1024); % Calculate frequency response
phi 180*unwrap(angle(h))/pi;
subplot(2,1,1), plot(w,abs(h)),grid; xlabel(’Frequency (radians)’),
ylabel(’Magnitude’)
subplot(2,1,2), plot(w,phi),grid; xlabel(’Frequency (radians)’), ylabel(’Phase
(degrees)’)
%
6.6 REALIZATION OF DIGITAL FILTERS
In this section, basic realization methods for digital ﬁlters are discussed. Digital ﬁlters described by the
transfer function HðzÞ may be generally realized into the following forms:
• Direct-form I
• Direct-form II
• Cascade
• Parallel
(The reader can explore various lattice realizations in the textbook by Stearns and Hush [1990].)
192
CHAPTER 6 Digital Signal Processing Systems

6.6.1 Direct-Form I Realization
As we know, a digital ﬁlter transfer function, HðzÞ, is given by
HðzÞ ¼ BðzÞ
AðzÞ ¼ b0 þ b1z 1 þ / þ bMz M
1 þ a1z 1 þ / þ aNz N
(6.26)
Let xðnÞ and yðnÞ be the digital ﬁlter input and output, respectively. We can express the relationship in
z-transform domain as
YðzÞ ¼ HðzÞXðzÞ
(6.27)
where XðzÞ and YðzÞ are the z-transforms of xðnÞ and yðnÞ, respectively. If we substitute Equation
(6.26) into HðzÞ in Equation (6.27), we have
YðzÞ ¼
b0 þ b1z 1 þ / þ bMz M
1 þ a1z 1 þ / þ aNz N

XðzÞ
(6.28)
Taking the inverse of the z-transform of Equation (6.28), we yield the relationship between input xðnÞ
and output yðnÞ in the time domain, as follows:
yðnÞ ¼ b0xðnÞ þ b1xðn  1Þ þ / þ bMxðn  MÞ
a1yðn  1Þ  a2yðn  2Þ  /  aNyðn  NÞ
(6.29)
This difference equation thus can be implemented by the direct-form I realization shown in
Figure 6.22(a). Figure 6.22(b) illustrates the realization of the second-order IIR ﬁlter (M ¼ N ¼ 2).
Note that the notation used in Figures 6.22(a) and (b) are deﬁned in Figure 22(c) and will be applied for
discussion of other realizations.
Notice that any of the aj and bi can be zero, thus not all the paths need to exist for realization.
6.6.2 Direct-Form II Realization
Considering Equations (6.26) and (6.27) with N ¼ M, we can express
YðzÞ ¼ HðzÞXðzÞ ¼ BðzÞ
AðzÞXðzÞ ¼ BðzÞ
XðzÞ
AðzÞ

¼ ðb0 þ b1z 1 þ / þ bMz MÞ

XðzÞ
1 þ a1z 1 þ / þ aMz M

|ﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄ{zﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄ}
WðzÞ
(6.30)
6.6 Realization of Digital Filters
193

Also, if we deﬁne a new z-transform function as
WðzÞ ¼
XðzÞ
1 þ a1z 1 þ / þ aMz M
(6.31)
we have
YðzÞ ¼ ðb0 þ b1z 1 þ / þ bMz MÞWðzÞ
(6.32)
The corresponding difference equations for Equations (6.31) and (6.32), respectively, become
wðnÞ ¼ xðnÞ  a1wðn  1Þ  a2wðn  2Þ  /  aMwðn  MÞ
(6.33)
(a)
(b)
(c)
FIGURE 6.22
(a) Direct-form I realization; (b) direct-form I realization with M ¼ 2; (c) notation.
194
CHAPTER 6 Digital Signal Processing Systems

and
yðnÞ ¼ b0wðnÞ þ b1wðn  1Þ þ . þ bMwðn  MÞ
(6.34)
Realization of Equations (6.33) and (6.34) produces another direct-form II realization, which is
demonstrated in Figure 6.23(a). Again, the corresponding realization of the second-order IIR ﬁlter is
described in Figure 6.23(b). Note that in Figure 6.23(a), the variables wðnÞ, wðn  1Þ, wðn  2Þ,.,
wðn  MÞ are different from the ﬁlter inputs xðn  1Þ, xðn  2Þ , ., xðn  MÞ.
6.6.3 Cascade (Series) Realization
An alternate way to ﬁlter realization is to cascade the factorized HðzÞ in the following form:
HðzÞ ¼ H1ðzÞ$H2ðzÞ/HkðzÞ
(6.35)
where HkðzÞ is chosen to be the ﬁrst- or second-order transfer function (section), which is deﬁned by
HkðzÞ ¼ bk0 þ bk1z 1
1 þ ak1z 1
(6.36)
or
HkðzÞ ¼ bk0 þ bk1z 1 þ bk2z 2
1 þ ak1z 1 þ ak2z 2
(6.37)
respectively. The block diagram of the cascade, or series, realization is depicted in Figure 6.24.
(a)
(b)
FIGURE 6.23
(a) Direct-form II realization; (b) direct-form II realization with M ¼ 2.
6.6 Realization of Digital Filters
195

6.6.4 Parallel Realization
Now we convert HðzÞ into the form
HðzÞ ¼ H1ðzÞ þ H2ðzÞ þ / þ HkðzÞ
(6.38)
where HkðzÞ is deﬁned as the ﬁrst- or second-order transfer function (section) given by
HkðzÞ ¼
bk0
1 þ ak1z 1
(6.39)
or
HkðzÞ ¼
bk0 þ bk1z 1
1 þ ak1z 1 þ ak2z 2
(6.40)
respectively. The resulting parallel realization is illustrated in the block diagram in Figure 6.25.
EXAMPLE 6.13
Given a second order transfer function
HðzÞ
0:5ð1
z2Þ
1 þ 1:3z1 þ 0:36z2
perform the ﬁlter realizations and write difference equations using the following realizations:
a. direct form I and direct form II;
b. cascade form via ﬁrst order sections;
c. parallel form via ﬁrst order sections.
FIGURE 6.24
Cascade realization.
FIGURE 6.25
Parallel realization.
196
CHAPTER 6 Digital Signal Processing Systems

Solution:
a. To perform the ﬁlter realizations using direct form I and direct form II, we rewrite the given second order transfer
function as
HðzÞ
0:5
0:5z2
1 þ 1:3z1 þ 0:36z2
and identify that
a1
1:3; a2
0:36; b0
0:5; b1
0;
and
b2
0:5
Based on the realizations in Figure 6.22, we sketch the direct form I realization in Figure 6.26.
The difference equation for the direct form I realization is given by
yðnÞ
0:5xðnÞ
0:5xðn
2Þ
1:3yðn
1Þ
0:36yðn
2Þ
Using the direct form II realization shown in Figure 6.23, we present the realization in Figure 6.27. The difference
equations for the direct form II realization are expressed as
wðnÞ
xðnÞ
1:3wðn
1Þ
0:36wðn
2Þ
yðnÞ
0:5wðnÞ
0:5wðn
2Þ
b. To achieve the cascade (series) form realization, we factor HðzÞ into two ﬁrst order sections to yield
HðzÞ
0:5ð1
z2Þ
1 þ 1:3z1 þ 0:36z2
0:5
0:5z1
1 þ 0:4z1
1 þ z1
1 þ 0:9z1
FIGURE 6.26
Direct-form I realization for Example 6.13.
FIGURE 6.27
Direct-form II realization for Example 6.13.
6.6 Realization of Digital Filters
197

where H1ðzÞ and H2ðzÞ are chosen to be
H1ðzÞ
0:5
0:5z1
1 þ 0:4z1
H2ðzÞ
1 þ z1
1 þ 0:9z1
Notice that the obtained H1ðzÞ and H2ðzÞ are not the unique selections for realization. For example, there is another
way of choosing H1ðzÞ
0:5
0:5z1
1 þ 0:9z1
and H2ðzÞ
1 þ z1
1 þ 0:4z1 to yield the same HðzÞ. Using the H1ðzÞ and
H2ðzÞ we have obtained, and with the direct form II realization, we achieve the cascade form depicted in Figure 6.28.
The difference equations for the direct form II realization have two cascaded sections, expressed as
Section 1:
w1ðnÞ
xðnÞ
0:4wðn
1Þ
y1ðnÞ
0:5w1ðnÞ
0:5w1ðn
1Þ
Section 2:
w2ðnÞ
y1ðnÞ
0:9w2ðn
1Þ
yðnÞ
w2ðnÞ þ w2ðn
1Þ
c. In order to yield the parallel form of realization, we need to make use of the partial fraction expansion, and we
ﬁrst let
HðzÞ
z
0:5ðz2
1Þ
zðz þ 0:4Þðz þ 0:9Þ
A
z þ
B
z þ 0:4 þ
C
z þ 0:9
where
A
z

0:5ðz2
1Þ
zðz þ 0:4Þðz þ 0:9Þ

z
0
0:5ðz2
1Þ
ðz þ 0:4Þðz þ 0:9Þ

z
0
1:39
B
ðz þ 0:4Þ

0:5ðz2
1Þ
zðz þ 0:4Þðz þ 0:9Þ

z
0:4
0:5ðz2
1Þ
zðz þ 0:9Þ

z
0:4
2:1
C

z þ 0:9

0:5

z2
1
	
zðz þ 0:4Þðz þ 0:9Þ

z
0:9
0:5

z2
1
	
zðz þ 0:4Þ

z
0:9
0:21
FIGURE 6.28
Cascade realization for Example 6.13.
198
CHAPTER 6 Digital Signal Processing Systems

Therefore
HðzÞ
1:39 þ
2:1z
z þ 0:4 þ
0:21z
z þ 0:9
1:39 þ
2:1
1 þ 0:4z1 þ
0:21
1 þ 0:9z1
Again, using the direct form II realization for each section, we obtain the parallel realization in Figure 6.29.
The difference equations for the direct form II realization have three parallel sections, expressed as
y1ðnÞ
1:39xðnÞ
w2ðnÞ
xðnÞ
0:4w2ðn
1Þ
y2ðnÞ
2:1w2ðnÞ
w3ðnÞ
xðnÞ
0:9w3ðn
1Þ
y3ðnÞ
0:21w3ðnÞ
yðnÞ
y1ðnÞ þ y2ðnÞ þ y3ðnÞ
In practice, the second-order ﬁlter module with the direct-form I or direct-form II realization is
used. The high-order ﬁlter can be factored in the cascade form with the ﬁrst- or second-order sections.
In cases where the ﬁrst order-ﬁlter is required, we can still modify the second-order ﬁlter module by
setting the corresponding ﬁlter coefﬁcients to be zero.
6.7 APPLICATION: SIGNAL ENHANCEMENT AND FILTERING
This section investigates applications of signal enhancement using a pre-emphasis ﬁlter and
speech ﬁltering using a bandpass ﬁlter. Enhancement also includes biomedical signals such as
electrocardiogram (ECG) signals.
FIGURE 6.29
Parallel realization for Example 6.13.
6.7 Application: Signal Enhancement and Filtering
199

6.7.1 Pre-Emphasis of Speech
A speech signal may have frequency components that fall off at high frequencies. In some applications
such as speech coding, to avoid overlooking the high frequencies, the high frequency components
are compensated using pre-emphasis ﬁltering. A simple digital ﬁlter used for such compensation is
given as
yðnÞ ¼ xðnÞ  axðn  1Þ
(6.41)
where a is the positive parameter to control the degree of pre-emphasis ﬁltering and usually is chosen
to be less than 1. The ﬁlter described in Equation (6.41) is essentially a highpass ﬁlter. Applying
z-transform on both sides of Equation (6.41) and solving for the transfer function, we have
HðzÞ ¼ 1  az 1
(6.42)
The magnitude and phase responses adopting the pre-emphasis parameter a ¼ 0:9 and the sampling
rate fs ¼ 8;000 Hz are plotted in Figure 6.30A using MATLAB.
Figure 6.30B compares the original speech waveform and the pre-emphasized speech using the
ﬁlter in Equation (6.42). Again, we apply the fast Fourier transform (FFT) to estimate the spectrum of
0
500
1000
1500
2000
2500
3000
3500
4000
0
20
40
60
80
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
20
10
0
10
Frequency (Hertz)
Magn tude response (dB)
FIGURE 6.30A
Frequency responses of the pre-emphasis ﬁlter.
200
CHAPTER 6 Digital Signal Processing Systems

the original speech and the spectrum of the pre-emphasized speech. The plots are displayed in
Figure 6.31.
From Figure 6.31, we can conclude that the ﬁlter does its job to boost the high-frequency
components and attenuate the low-frequency components. We can also try this ﬁlter with different
values of a to examine the degree of the pre-emphasis ﬁltering of the digitally recorded speech. The
MATLAB list is in Program 6.3.
Program 6.3. MATLAB program for pre-emphasis of speech.
% MATLAB program for Figures 6.30 and 6.31
close all;clear all
fs 8000;
% Sampling rate
alpha
0.9;
% Degree of pre emphasis
figure(1);
freqz([1
alpha],1,512,fs);
% Calculate and display frequency response
load speech.dat
figure(2);
y filter([1
alpha],1,speech);
% Filtering speech
subplot(2,1,1),plot(speech);grid;
ylabel(’Speech samples’)
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
x 10
4
2
1
0
1
2
x 10
4
Speech samp es
Speech: We lost the golden chain
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
x 10
4
1
0.5
0
0.5
1
x 10
4
F tered samp es
Number of samples
Pre emphasized speech
FIGURE 6.30B
Original speech and pre-emphasized speech waveforms.
6.7 Application: Signal Enhancement and Filtering
201

title(’Speech: We lost the golden chain.’)
subplot(2,1,2),plot(y);grid
ylabel(’Filtered samples’)
xlabel(’Number of samples’);
title(’Preemphasized speech.’)
figure(3);
N length(speech);
% Length of speech
Axk abs(fft(speech.*hamming(N)’))/N;
% Two sided spectrum of speech
Ayk abs(fft(y.*hamming(N)’))/N;
% Two sided spectrum of pre emphasized speech
f [0:N/2]*fs/N;
Axk(2:N) 2*Axk(2:N);
% Get one sided spectrum of speech
Ayk(2:N) 2*Ayk(2:N);
% Get one sided spectrum of filtered speech
subplot(2,1,1),plot(f,Axk(1:N/2þ1));grid
ylabel(’Amplitude spectrum Ak’)
title(’Original speech’);
subplot(2,1,2),plot(f,Ayk(1:N/2þ1));grid
ylabel(’Amplitude spectrum Ak’)
xlabel(’Frequency (Hz)’);
title(’Preemphasized speech’);
%
0
500
1000
1500
2000
2500
3000
3500
4000
0
50
100
150
200
Amp tude spectrum Ak
Original speech
0
500
1000
1500
2000
2500
3000
3500
4000
0
20
40
60
Amp tude spectrum Ak
Frequency (Hz)
Pre emphasized speech
FIGURE 6.31
Amplitude spectral plots for the original speech and pre-emphasized speech.
202
CHAPTER 6 Digital Signal Processing Systems

6.7.2 Bandpass Filtering of Speech
Bandpass ﬁltering plays an important role in DSP applications. It can be used to pass the signals
according to the speciﬁed frequency passband and reject the frequency other than the passband
speciﬁcation. Then the ﬁltered signal can be further used for the signal feature extraction. Filtering can
also be applied to perform applications such as noise reduction, frequency boosting, digital audio
equalizing, and digital crossover, among others.
Let us consider the following digital fourth-order bandpass Butterworth ﬁlter with a lower cutoff
frequency of 1,000 Hz, an upper cutoff frequency of 1,400 Hz (that is, the bandwidth is 400 Hz), and
a sampling rate of 8,000 Hz:
HðzÞ ¼
0:0201  0:0402z 2 þ 0:0201z 4
1  2:1192z 1 þ 2:6952z 2  1:6924z 3 þ 0:6414z 4
(6.43)
Converting the z-transfer function into the DSP difference equation yields
yðnÞ ¼ 0:0201xðnÞ  0:0402xðn  2Þ þ 0:0201xðn  4Þ
þ2:1192yðn  1Þ  2:6952yðn  2Þ þ 1:6924yðn  3Þ  0:6414yðn  4Þ
(6.44)
The ﬁlter frequency responses are computed and plotted in Figure 6.32Awith MATLAB. Figure 6.32B
shows the original speech and ﬁltered speech, while Figure 6.32C displays the spectral plots for the
original speech and ﬁltered speech.
0
500
1000
1500
2000
2500
3000
3500
4000
200
100
0
100
200
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
40
30
20
10
0
Frequency (Hertz)
Magn tude response (dB)
FIGURE 6.32A
Frequency responses of the designed bandpass ﬁlter.
6.7 Application: Signal Enhancement and Filtering
203

As shown in Figure 6.32C, the designed bandpass ﬁlter signiﬁcantly reduces low-frequency
components, which are less than 1,000 Hz, and the high-frequency components above 1,400 Hz, while
letting the signals with the frequencies ranging from 1,000 Hz to 1,400 Hz pass through the ﬁlter.
Similarly, we can design and implement other types of ﬁlters, such as lowpass, highpass, bandpass, and
band reject (bandstop) to ﬁlter the signals and examine the performance of their designs. MATLAB
implementation details are given in Program 6.4.
Program 6.4. MATLAB program for bandpass ﬁltering of speech.
fs 8000;
% Sampling rate
freqz([0.0201 0.00
0.0402 0 0.0201],[1
2.1192 2.6952
1.6924 0.6414],512,fs);
axis([0 fs/2
40 1]);
% Frequency response of bandpass filter
figure
load speech.dat
y filter([0.0201 0.00
0.0402 0.0201],[1
2.1192 2.6952
1.6924 0.6414],speech);
subplot(2,1,1),plot(speech); grid;
% Filtering speech
ylabel(’Origibal Samples’)
title(’Speech: We lost the golden chain.’)
subplot(2,1,2),plot(y);grid
xlabel(’Number of Samples’);ylabel(’Filtered Samples’)
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
x 10
4
2
1
0
1
2
x 10
4
Or g na  samp es
Speech: We lost the golden chain
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
x 10
4
4000
2000
0
2000
4000
Number of samples
F tered samp es
Bandpass filtered speech
FIGURE 6.32B
Plots of the original speech and ﬁltered speech.
204
CHAPTER 6 Digital Signal Processing Systems

title(’Bandpass ﬁltered speech.’)
figure
N length(speech);
Axk abs(fft(speech.*hamming(N)’))/N;
% One sided spectrum of speech
Ayk abs(fft(y.*hamming(N)’))/N;
% One sided spectrum of filtered speech
f [0:N/2]*fs/N;
Axk(2:N) 2*Axk(2:N);Ayk(2:N) 2*Ayk(2:N);
% One sided spectra
subplot(2,1,1),plot(f,Axk(1:N/2þ1));grid
ylabel(’Amplitude spectrum Ak’)
title(’Original speech’);
subplot(2,1,2),plot(f,Ayk(1:N/2þ1));grid
ylabel(’Amplitude spectrum Ak’);xlabel(’Frequency (Hz)’);
title(’Bandpass ﬁltered speech’);
6.7.3 Enhancement of ECG Signal Using Notch Filtering
A notch ﬁlter is a bandstop ﬁlter with a very narrow bandwidth. It can be applied to enhance an ECG
signal that is corrupted during the data acquisition stage, where the signal is exposed to 60-Hz
interference induced from the power line. Let us consider the following digital second-order notch
0
500
1000
1500
2000
2500
3000
3500
4000
0
50
100
150
200
Amp tude spectrum Ak
Original speech
0
500
1000
1500
2000
2500
3000
3500
4000
0
10
20
30
Amp tude spectrum Ak
Frequency (Hz)
Bandpass filtered speech
FIGURE 6.32C
Amplitude spectra of the original speech and bandpass ﬁltered speech.
6.7 Application: Signal Enhancement and Filtering
205

ﬁlter with a notch frequency of 60 Hz where the digital system has a sampling frequency of 500 Hz. We
obtain a notch ﬁlter (details can be found in Chapter 8) as follows:
HðzÞ ¼
1  1:4579z 1 þ z 2
1  1:3850z 1 þ 0:9025z 2
(6.45)
The DSP difference equation is expressed as
yðnÞ ¼ xðnÞ  1:4579xðn  1Þ þ 1:3850yðn  1Þ  0:9025yðn  2Þ
(6.46)
The frequency responses are computed and plotted in Figure 6.33. Comparisons of the raw ECG signal
corrupted by 60-Hz interference with the enhanced ECG signal for both the time domain and
frequency domain are displayed in Figures 6.34 and 6.35, respectively. As we can see, the notch ﬁlter
completely removes the 60-Hz interference.
6.8 SUMMARY
1. The digital ﬁlter (DSP system) is represented by a difference equation, which is linear and time
invariant.
2. The ﬁlter output depends on the ﬁlter current input, past input(s), and past output(s) in general.
Given arbitrary inputs and nonzero or zero initial conditions, operating the difference equation
can generate the ﬁlter output recursively.
0
50
100
150
200
250
100
50
0
50
100
Frequency (Hz)
Phase (degrees)
0
50
100
150
200
250
60
40
20
0
Frequency (Hz)
Magn tude (dB)
FIGURE 6.33
Notch ﬁlter frequency responses.
206
CHAPTER 6 Digital Signal Processing Systems

3. System responses such as the impulse response and step response can be determined analytically
using the z-transform.
4. The transfer function can be obtained by applying z-transform to the difference equation to
determine the ratio of the output z-transform over the input z-transform. A digital ﬁlter (DSP
system) can be represented by its transfer function.
5. System stability can be studied using a very useful tool, a z-plane pole-zero plot.
6. The frequency response of the DSP system was developed and illustrated to investigate the
magnitude and phase responses. In addition, the FIR (ﬁnite impulse response) and IIR (inﬁnite
impulse response) systems were deﬁned.
7. Digital ﬁlters and their speciﬁcations, such as lowpass, highpass, bandpass, and bandstop, were
reviewed.
8. A digital ﬁlter can be realized using standard realization methods such as direct-form I; direct-form
II; cascade, or series form; and parallel form.
9. Digital processing of speech using the pre-emphasis ﬁlter and bandpass ﬁlter was investigated to
study spectral effects of the processed digital speech. The pre-emphasis ﬁlter boosts the high-
frequency components, while bandpass ﬁltering keeps the midband frequency components and
rejects other lower- and upper-band frequency components.
0
500
1000
1500
2000
2500
3000
3500
4000
4500
5000
5000
0
5000
10000
Or g na  samp es
Raw ECG corrupted by 60 Hz interference
0
500
1000
1500
2000
2500
3000
3500
4000
4500
5000
5000
0
5000
10000
Number of samples
F tered samp es
Enhanced ECG signal
FIGURE 6.34
The corrupted ECG signal and the enhanced ECG signal.
6.8 Summary
207

6.9 PROBLEMS
6.1. Given the difference equation
yðnÞ ¼ xðnÞ  0:5yðn  1Þ
a. calculate the system response yðnÞ for n ¼ 0; 1; .; 4 with the input xðnÞ ¼ ð0:5ÞnuðnÞ
and initial condition yð  1Þ ¼ 1;
b. calculate the system response yðnÞ for n ¼ 0; 1; .; 4 with the input xðnÞ ¼ ð0:5ÞnuðnÞ and
zero initial condition yð  1Þ ¼ 0
6.2. Given the difference equation
yðnÞ ¼ 0:5xðn  1Þ þ 0:6yðn  1Þ
a. calculate the system response yðnÞ for n ¼ 0; 1; .; 4 with the input xðnÞ ¼ ð0:5ÞnuðnÞ
and initial conditions xð  1Þ ¼ 1, and yð  1Þ ¼ 1;
b. calculate the system response yðnÞ for n ¼ 0; 1; .; 4 with the input xðnÞ ¼ ð0:5ÞnuðnÞ and
zero initial conditions xð  1Þ ¼ 0, and yð  1Þ ¼ 0.
0
50
100
150
200
250
0
200
400
600
800
Amp tude spectrum Ak
Raw ECG corrupted by 60 Hz interference
0
50
100
150
200
250
0
100
200
300
400
Amp tude spectrum Ak
Frequency (Hz)
Enhanced ECG signal
60 Hz interference
FIGURE 6.35
The corrupted ECG signal spectrum and the enhanced ECG signal spectrum.
208
CHAPTER 6 Digital Signal Processing Systems

6.3. Given the difference equation
yðnÞ ¼ xðn  1Þ  0:75yðn  1Þ  0:125yðn  2Þ
a. calculate the system response yðnÞ for n ¼ 0; 1; .; 4 with the input xðnÞ ¼ ð0:5ÞnuðnÞ
and initial conditions: xð  1Þ ¼ 1, yð  2Þ ¼ 2, and yð  1Þ ¼ 1;
b. calculate the system response yðnÞ for n ¼ 0; 1; .; 4 with the input xðnÞ ¼ ð0:5ÞnuðnÞ and
zero initial conditions: xð  1Þ ¼ 0, yð2Þ ¼ 0, and yð  1Þ ¼ 0.
6.4. Given the difference equation
yðnÞ ¼ 0:5xðnÞ þ 0:5xðn  1Þ
a. ﬁnd the HðzÞ;
b. determine the impulse response yðnÞ if the input xðnÞ ¼ 4dðnÞ;
c. determine the step response yðnÞ if the input xðnÞ ¼ 10uðnÞ.
6.5. Given the difference equation,
yðnÞ ¼ xðnÞ  0:5yðn  1Þ
a. ﬁnd the HðzÞ;
b. determine the impulse response yðnÞ if the input xðnÞ ¼ dðnÞ;
c. determine the step response yðnÞ if the input xðnÞ ¼ uðnÞ.
6.6. A digital system is described by the following difference equation:
yðnÞ ¼ xðnÞ  0:25xðn  2Þ  1:1yðn  1Þ  0:28yðn  2Þ
Find the transfer function HðzÞ, the denominator polynomial AðzÞ, and the numerator poly-
nomial BðzÞ.
6.7. A digital system is described by the following difference equation:
yðnÞ ¼ 0:5xðnÞ þ 0:5xðn  1Þ  0:6yðn  2Þ
Find the transfer function HðzÞ, the denominator polynomial AðzÞ, and the numerator poly-
nomial BðzÞ.
6.8. A digital system is described by the following difference equation:
yðnÞ ¼ 0:25xðn  2Þ þ 0:5yðn  1Þ  0:2yðn  2Þ
Find the transfer function HðzÞ, the denominator polynomial AðzÞ, and the numerator poly-
nomial BðzÞ.
6.9. A digital system is described by the following difference equation:
yðnÞ ¼ xðnÞ  0:3xðn  1Þ þ 0:28xðn  2Þ
Find the transfer function HðzÞ, the denominator polynomial AðzÞ, and the numerator
polynomial BðzÞ.
6.8 Summary
209

6.10. Convert each of the following transfer functions into difference equations:
a. HðzÞ ¼ 0:5 þ 0:5z 1
b. HðzÞ ¼
1
1  0:3z 1
6.11. Convert each of the following transfer functions into difference equations:
a. HðzÞ ¼ 0:1 þ 0:2z 1 þ 0:3z 2
b. HðzÞ ¼
0:5  0:5z 2
1  0:3z 1 þ 0:8z 2
6.12. Convert each of the following transfer functions into difference equations:
a. HðzÞ ¼
z2  0:25
z2 þ 1:1z þ 0:18
b. HðzÞ ¼ z2  0:1z þ 0:3
z3
6.13. Convert each of the following transfer functions into pole-zero form:
a. HðzÞ ¼ z2 þ 2z þ 1
z2 þ 5z þ 6
b HðzÞ ¼
1  0:16z 2
1 þ 0:7z 1 þ 0:1z 2
c HðzÞ ¼
z2 þ 4z þ 5
z3 þ 2z2 þ 6z
6.14. A transfer function depicting a discrete-time system is given by
HðzÞ ¼ 10ðz þ 1Þ
ðz þ 0:75Þ
a. Determine the impulse response hðnÞ and step response.
b. Determine the system response yðnÞ if the input is xðnÞ ¼ ð0:25ÞnuðnÞ.
6.15. Given each of the following transfer functions that describe digital systems, sketch the z-
plane pole-zero plot and determine the stability for each digital system.
a. HðzÞ ¼
z  0:5
ðz þ 0:25Þðz2 þ z þ 0:8Þ
b. HðzÞ ¼
z2 þ 0:25
ðz  0:5Þðz2 þ 4z þ 7Þ
c. HðzÞ ¼
z þ 0:95
ðz þ 0:2Þðz2 þ 1:414z þ 1Þ
d. HðzÞ ¼
z2 þ z þ 0:25
ðz  1Þðz þ 1Þ2ðz  0:36Þ
210
CHAPTER 6 Digital Signal Processing Systems

6.16. Given the digital system
yðnÞ ¼ 0:5xðnÞ þ 0:5xðn  2Þ
with a sampling rate of 8,000 Hz,
a. determine the frequency response;
b. calculate and plot the magnitude and phase frequency responses;
c. determine the ﬁlter type based the magnitude frequency response.
6.17. Given the digital system,
yðnÞ ¼ 0:5xðn  1Þ þ 0:5xðn  2Þ
with a sampling rate of 8,000 Hz,
a. determine the frequency response;
b. calculate and plot the magnitude and phase frequency responses;
c. determine the ﬁlter type based the magnitude frequency response.
6.18. For the digital system
yðnÞ ¼ 0:5xðnÞ þ 0:5yðn  1Þ
with a sampling rate of 8,000 Hz,
a. determine the frequency response;
b. calculate and plot the magnitude and phase frequency responses;
c. determine the ﬁlter type based the magnitude frequency response.
6.19. For the digital system
yðnÞ ¼ xðnÞ  0:5yðn  2Þ
with a sampling rate of 8,000 Hz,
a. determine the frequency response;
b. calculate and plot the magnitude and phase frequency responses;
c. determine the ﬁlter type based the magnitude frequency response.
6.20. Given the difference equation
yðnÞ ¼ xðnÞ  2$ cos ðaÞxðn  1Þ þ xðn  2Þ þ 2g$ cos ðaÞ  g2
where g ¼ 0:8 and a ¼ 600,
a. ﬁnd the transfer function HðzÞ;
b. plot the poles and zeros on the z-plan with the unit circle;
c. determine the stability of the system from the pole-zero plot;
d. calculate the amplitude (magnitude) response of HðzÞ;
e. calculate the phase response of HðzÞ.
6.8 Summary
211

6.21. For the difference equations
a. yðnÞ ¼ 0:5xðnÞ þ 0:5xðn  1Þ
b yðnÞ ¼ 0:5xðnÞ  0:5xðn  1Þ
c. yðnÞ ¼ 0:5xðnÞ þ 0:5xðn  2Þ
d. yðnÞ ¼ 0:5xðnÞ  0:5xðn  2Þ
1. ﬁnd HðzÞ;
2. calculate the magnitude response;
3. specify the ﬁltering type based on the calculated magnitude response.
6.22. Given an IIR system expressed as
yðnÞ ¼ 0:5xðnÞ þ 0:2yðn  1Þ; yð  1Þ ¼ 0
a. ﬁnd HðzÞ;
b. ﬁnd the system response yðnÞ due to the input xðnÞ ¼ ð0:5ÞnuðnÞ.
6.23. Given the IIR system
yðnÞ ¼ 0:5xðnÞ  0:7yðn  1Þ  0:1yðn  2Þ
with zero initial conditions,
a. ﬁnd HðzÞ;
b. ﬁnd the unit step response.
6.24. Given the ﬁrst-order IIR system
HðzÞ ¼
1 þ 2z 1
1  0:5z 1
realize HðzÞ and develop the difference equations using the following forms:
a. direct-form I;
b. direct-form II.
6.25. Given the ﬁlter
HðzÞ ¼ 1  0:9z 1  0:1z 2
1 þ 0:3z 1  0:04z 2
realize HðzÞ and develop difference equations using the following forms:
a. direct-form I;
b. direct-form II;
212
CHAPTER 6 Digital Signal Processing Systems

c. cascade (series) form via the ﬁrst-order sections;
d. parallel form via the ﬁrst-order sections.
6.26. Given the pre-emphasis ﬁlters:
HðzÞ ¼ 1  0:5z 1
HðzÞ ¼ 1  0:7z 1
HðzÞ ¼ 1  0:9z 1
a. write the difference equation for each;
b. determine which emphasizes high frequency components most.
6.9.1 MATLAB Problems
6.27. Given a ﬁlter
H

z
	
¼
1 þ 2z 1 þ z 2
1  0:5z 1 þ 0:25z 2
use MATLAB to plot
a. its magnitude frequency response;
b. its phase response.
6.28. Given a difference equation
yðnÞ ¼ xðn  1Þ  0:75yðn  1Þ  0:125yðn  2Þ
a. use the MATLAB functions ﬁlter() and ﬁltic() to calculate the system response yðnÞ for
n ¼ 0; 1; .; 4 with the input of xðnÞ ¼ ð0:5ÞnuðnÞ and initial conditions xð  1Þ ¼ 1,
yð  2Þ ¼ 2, and yð  1Þ ¼ 1;
b. use the MATLAB function ﬁlter() to calculate the system response yðnÞ for
n ¼ 0; 1; .; 4 with the input of xðnÞ ¼ ð0:5ÞnuðnÞ and zero initial conditions
xð  1Þ ¼ 0, yð2Þ ¼ 0, and yð  1Þ ¼ 0.
6.29. Given a ﬁlter
HðzÞ ¼
1  z 1 þ z 2
1  0:9z 1 þ 0:81z 2
a. plot the magnitude frequency response and phase response using MATLAB;
b. specify the type of ﬁltering;
c. ﬁnd the difference equation;
6.8 Summary
213

d. perform ﬁltering, that is, calculate yðnÞ for the ﬁrst 1,000 samples for each of the
following inputs and plot the ﬁlter outputs using MATLAB, assuming that all initial
conditions are zeros and the sampling rate is 8,000 Hz:
xðnÞ ¼ cos

p,103
n
8;000

xðnÞ ¼ cos
8
3p,103
n
8;000

xðnÞ ¼ cos

6p,103
n
8; 000

e. repeat (d) using the MATLAB function ﬁlter().
6.30. Repeat (d) in Problem 6.29 using direct-form II structure.
6.9.2 MATLAB Projects
6.31. Sound effects of pre-emphasis ﬁltering:
A pre-emphasis ﬁlter is shown in Figure 6.36 with a selective parameter 0  a < 1, which
controls the degree of pre-emphasis ﬁltering. Assuming the system has a sampling rate of
8,000 Hz, plot the frequency responses for a ¼ 0, a ¼ 0:4, a ¼ 0:8, a ¼ 0:95, a ¼ 0:99,
respectively. For each case, apply the pre-emphasis ﬁlter to the given speech (“speech.dat”)
and discuss the sound effects.
6.32. Echo generation (sound regeneration):
Echo is the repetition of sound due to sound wave reﬂection from the objects. It can easily be
generated using an FIR ﬁlter such as that in Figure 6.37, where jaj < 1 is an attenuation
FIGURE 6.37
A single echo generator using an FIR ﬁlter.
FIGURE 6.36
A pre-emphasis ﬁlter.
214
CHAPTER 6 Digital Signal Processing Systems

factor and R the delay of the echo. The echo signal is generated by the sum of a delayed
version of sound with the attenuation of a and the nondelayed version.
However, a single echo generator may not be useful, so a multiple-echo generator using an
IIR ﬁlter is usually applied, as shown in Figure 6.38.
a. Assuming the system has a sampling rate of 8,000 Hz, plot the IIR ﬁlter frequency
responses for the following cases: a ¼ 0:5 and R ¼ 1; a ¼ 0:6 and R ¼ 4; a ¼ 0:7 and
R ¼ 10, and characterize the frequency responses.
b. Implement the multiple-echo generator using the following code:
y ﬁlter([1], [1 zeros(1, R 1) alpha], x)
Following that, evaluate the sound effects of the speech ﬁle (“speech.dat”) for the following
cases: a ¼ 0:5 and R ¼ 500 (62.5 ms); a ¼ 0:7 and R ¼ 1000 (125 ms); a ¼ 0:5,
R ¼ 2000 (250 ms); and a ¼ 0:5, R ¼ 4000 (500 ms).
FIGURE 6.38
A multiple-echo generator using an IIR ﬁlter.
6.8 Summary
215

This page intentionally left blank

Finite Impulse Response
Filter Design
7
CHAPTER OUTLINE
7.1 Finite Impulse Response Filter Format ........................................................................................... 217
7.2 Fourier Transform Design.............................................................................................................. 219
7.3 Window Method ........................................................................................................................... 230
7.4 Applications: Noise Reduction and Two-Band Digital Crossover....................................................... 253
7.4.1 Noise Reduction........................................................................................................253
7.4.2 Speech Noise Reduction ............................................................................................256
7.4.3 Noise Reduction in Vibration Signals...........................................................................257
7.4.4 Two-Band Digital Crossover ........................................................................................258
7.5 Frequency Sampling Design Method .............................................................................................. 262
7.6 Optimal Design Method................................................................................................................. 269
7.7 Realization Structures of Finite Impulse Response Filters ............................................................... 280
7.7.1 Transversal Form.......................................................................................................280
7.7.2 Linear Phase Form.....................................................................................................281
7.8 Coefﬁcient Accuracy Effects on Finite Impulse Response Filters...................................................... 282
7.9 Summary of FIR Design Procedures and Selection of FIR Filter Design Methods in Practice .............. 285
7.10 Summary ................................................................................................................................... 288
7.11 MATLAB Programs ...................................................................................................................... 288
OBJECTIVES:
This chapter introduces principles of the ﬁnite impulse response (FIR) ﬁlter design and investigates design
methods such as the Fourier transform method, window method, frequency sampling method, and optimal
design method. Then the chapter illustrates how to apply the designed FIR ﬁlters to solve real-world
problems such as noise reduction and digital crossover for audio applications.
7.1 FINITE IMPULSE RESPONSE FILTER FORMAT
In this chapter, we describe techniques for designing ﬁnite impulse response (FIR) ﬁlters. An FIR ﬁlter
is completely speciﬁed by the following input output relationship:
yðnÞ ¼ P
K
i ¼ 0
bixðn  iÞ
¼ b0 xðnÞ þ b1xðn  1Þ þ b2xðn  2Þ þ / þ bKxðn  KÞ
(7.1)
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00007-X
Copyright  2013 Elsevier Inc. All rights reserved.
217

where bi represents FIR ﬁlter coefﬁcients and K þ 1 denotes the FIR ﬁlter length. Applying the
z-transform on both sides on Equation (7.1) leads to
YðzÞ ¼ b0XðzÞ þ b1z 1XðzÞ þ / þ bKz KXðzÞ
(7.2)
Factoring out XðzÞ on the right-hand side of Equation (7.2) and then dividing XðzÞ on both sides, we
have the transfer function, which depicts the FIR ﬁlter, as
HðzÞ ¼ YðzÞ
XðzÞ ¼ b0 þ b1z 1 þ / þ bKz K
(7.3)
The following example serves to illustrate the notations used in Equations (7.1) and (7.3) numerically.
EXAMPLE 7.1
Given the FIR ﬁlter
yðnÞ
0:1xðnÞ þ 0:25xðn
1Þ þ 0:2xðn
2Þ
determine the transfer function, ﬁlter length, nonzero coefﬁcients, and impulse response.
Solution:
Applying the z transform on both sides of the difference equation yields
Y ðzÞ
0:1XðzÞ þ 0:25XðzÞz1 þ 0:2XðzÞz2
Then the transfer function is found to be
HðzÞ
Y ðzÞ
XðzÞ
0:1 þ 0:25z1 þ 0:2z2
The ﬁlter length is K þ 1
3, and the identiﬁed coefﬁcients are
b0
0:1; b1
0:25
and
b2
0:2
Taking the inverse z transform of the transfer function, we have
hðnÞ
0:1dðnÞ þ 0:25dðn
1Þ þ 0:2dðn
2Þ
This FIR ﬁlter impulse response has only three terms.
The foregoing example is to help us understand the FIR ﬁlter format. We can conclude the
following:
1. The transfer function in Equation (7.3) has a constant term, all the other terms have negative
powers of z, and all the poles are at the origin on the z-plane. Hence, the stability of the ﬁlter is
guaranteed. Its impulse response has only a ﬁnite number of terms.
2. The FIR ﬁlter operations involve only multiplying theﬁlter inputs by their corresponding coefﬁcients
and accumulating them; the implementation of this ﬁlter type in real time is straightforward.
From the FIR ﬁlter format, the design objective is to obtain bi coefﬁcients for the FIR ﬁlter such that
the magnitude frequency response of the FIR ﬁlter HðzÞ will approximate the desired magnitude
218
CHAPTER 7 Finite Impulse Response Filter Design

frequency response, such as that of a lowpass, highpass, bandpass, or bandstop ﬁlter. The following
sections will introduce design methods to calculate the FIR ﬁlter coefﬁcients.
7.2 FOURIER TRANSFORM DESIGN
We begin with an ideal lowpass ﬁlter with a normalized cutoff frequency Uc, whose magnitude
frequency response in terms of the normalized digital frequency U is plotted in Figure 7.1 and is
characterized by
HðejUÞ ¼
(
1;
0  jUj  Uc
0;
Uc  jUj  p
(7.4)
Since the frequency response is periodic with a period of U ¼ 2p radians, as we discussed in Chapter 6,
we can extend the frequency response of the ideal ﬁlter HðejUÞ, as shown in Figure 7.2.
The periodic frequency response can be approximated using a complex Fourier series expansion
(see Appendix B) in terms of the normalized digital frequency U, that is,
HðejUÞ ¼
X
N
n ¼
N
cne ju0nU
(7.5)
and the Fourier coefﬁcients are given by
cn ¼ 1
2p
Zp
p
HðejUÞeju0nUdU
for
 N < n < N
(7.6)
FIGURE 7.1
Frequency response of an ideal lowpass ﬁlter.
FIGURE 7.2
Periodicity of the ideal lowpass frequency response.
7.2 Fourier Transform Design
219

Notice that we obtain Equations (7.5) and (7.6) simply by treating the Fourier series expansion in the
time domain with the time variable t replaced by the normalized digital frequency variable U. The
fundamental frequency is easily found to be
u0 ¼ 2p=ðperiod of waveformÞ ¼ 2p=2p ¼ 1
(7.7)
Substituting u0 ¼ 1 into Equation (7.6) and introducing hðnÞ ¼ cn, called the desired impulse
response of the ideal ﬁlter, we obtain the Fourier transform design as
hðnÞ ¼ 1
2p
Zp
-p
HðejUÞejUndU
for
 N < n < N
(7.8)
Now, let us look at the possible z-transfer function. If we substitute ejU ¼ z and u0 ¼ 1 back to
Equation (7.5), we yield a z-transfer function in the following format:
HðzÞ ¼
P
N
n ¼
N
hðnÞz n
/ þ hð2Þz2 þ hð1Þz1 þ hð0Þ þ hð1Þz 1 þ hð2Þz 2 þ /
(7.9)
This is a noncausal FIR ﬁlter. We will deal with this later in this section. Using the Fourier transform
design shown in Equation (7.8), the desired impulse response approximation of the ideal lowpass ﬁlter
is solved as
For n ¼ 0 hðnÞ ¼ 1
2p
Zp
-p
HðejUÞejU0dU
¼ 1
2p
ZUc
Uc
1dU ¼ Uc
p
For ns0 hðnÞ ¼ 1
2p
Zp
-p
HðejUÞejUndU ¼ 1
2p
ZUc
Uc
ejUndU
¼ ejnU
2pjn

Uc
Uc
¼ 1
pn
ejnUc  e jnUc
2j
¼ sinðUcnÞ
pn
(7.10)
The desired impulse response hðnÞ is plotted versus the sample number n in Figure 7.3.
Theoretically, hðnÞ in Equation (7.10) exists for N < n < N and is symmetrical about n ¼ 0; that
is, hðnÞ ¼ hð  nÞ. The amplitude of the impulse response sequence hðnÞ becomes smaller when n
increases in both directions. The FIR ﬁlter design must ﬁrst be completed by truncating the inﬁnite-length
sequence hðnÞ to achieve the 2M þ 1 dominant coefﬁcients using the coefﬁcient symmetry, that is,
HðzÞ ¼ hðMÞzM þ / þ hð1Þz1 þ hð0Þ þ hð1Þz 1 þ / þ hðMÞz M
220
CHAPTER 7 Finite Impulse Response Filter Design

The obtained ﬁlter is a noncausal z-transfer function of the FIR ﬁlter, since the ﬁlter transfer function
contains terms with the positive powers of z, which in turn means that the ﬁlter output depends on the
future ﬁlter inputs. To remedy the noncausal z-transfer function, we delay the truncated impulse
response hðnÞ by M samples to yield the following causal FIR ﬁlter:
HðzÞ ¼ b0 þ b1z 1 þ / þ b2Mð2MÞz 2M
(7.11)
n
h(n)
0
FIGURE 7.3
Impulse response of an ideal digital lowpass ﬁlter.
Table 7.1 Summary of Ideal Impulse Responses for Standard FIR Filters
Filter
Type Ideal Impulse Response hðnÞ (noncausal FIR coefﬁcients)
Lowpass:
hðnÞ
8
>
>
<
>
>
:
Uc
p
for
n
0
sinðUcnÞ
np
for
ns0
M  n  M
Highpass:
hðnÞ
8
>
>
<
>
>
:
p
Uc
p
for
n
0
sinðUcnÞ
np
for
ns0
M  n  M
Bandpass:
hðnÞ
8
>
>
<
>
>
:
UH
UL
p
for
n
0
sinðUHnÞ
np
sinðULnÞ
np
for
ns0
M  n  M
Bandstop:
hðnÞ
8
>
>
<
>
>
:
p
UH þ UL
p
for
n
0
sinðUHnÞ
np
þ sinðULnÞ
np
for
ns0
M  n  M
Causal FIR ﬁlter coefﬁcients: shifting hðnÞ to the right by M samples.
Transfer function:
HðzÞ ¼ b0 þ b1z
1 þ b2z
2 þ /b2Mz
2M
where bn ¼ hðn
MÞ,n ¼ 0; 1; /; 2M.
7.2 Fourier Transform Design
221

where the delay operation is given by
bn ¼ hðn  MÞ
for
n ¼ 0; 1; /; 2M
(7.12)
Similarly, we can obtain the design equations for other types of FIR ﬁlters, such as highpass, bandpass,
and bandstop, using their ideal frequency responses and Equation (7.8). The derivations are omitted
here. Table 7.1 gives a summary of all the formulas for FIR ﬁlter coefﬁcient calculations.
The following example illustrates the coefﬁcient calculation for the lowpass FIR ﬁlter.
EXAMPLE 7.2
a. Calculate the ﬁlter coefﬁcients for a 3 tap FIR lowpass ﬁlter with a cutoff frequency of 800 Hz and a sampling
rate of 8,000 Hz using the Fourier transform method.
b. Determine the transfer function and difference equation of the designed FIR system.
c. Compute and plot the magnitude frequency response for U
0; p=4; p=2; 3p=4; and p radians.
Solution:
a. Calculating the normalized cutoff frequency leads to
Uc
2pfcTs
2p  800=8; 000
0:2p radians
Since 2M þ 1
3 in this case, using the equation in Table 7.1 results in
hð0Þ
Uc
p
for
n
0
hðnÞ
sinðUcnÞ
np
sinð0:2pnÞ
np
for ns1
The computed ﬁlter coefﬁcients via the previous expression are listed as:
hð0Þ
0:2p
p
0:2
hð1Þ
sin½0:2p  1
1  p
0:1871
Using the symmetry leads to
hð 1Þ
hð1Þ
0:1871
Thus delaying hðnÞ by M
1 sample using Equation (7.12) gives
b0
hð0
1Þ
hð 1Þ
0:1871
b1
hð1
1Þ
hð0Þ
0:2
b2
hð2
1Þ
hð1Þ
0:1871
b. The transfer function is achieved as
HðzÞ
0:1871 þ 0:2z1 þ 0:1871z2
Using the technique described in Chapter 6, we have
Y ðzÞ
XðzÞ
HðzÞ
0:1871 þ 0:2z1 þ 0:1871z2
222
CHAPTER 7 Finite Impulse Response Filter Design

Multiplying X(z) leads to
Y ðzÞ
0:1871XðzÞ þ 0:2z1XðzÞ þ 0:1871z2XðzÞ
Applying the inverse z transform on both sides, the difference equation is yielded as
yðnÞ
0:1871xðnÞ þ 0:2xðn
1Þ þ 0:1871xðn
2Þ
c. The magnitude frequency response and phase response can be obtained using the technique introduced in
Chapter 6. Substituting z
ejU into HðzÞ, it follows that
HðejUÞ
0:1871 þ 0:2ejU þ 0:1871ej2U
Factoring term ejU and using the Euler formula ejx þ ejx
2 cos ðxÞ, we achieve
HðejUÞ
ejUð0:1871ejU þ 0:2 þ 0:1871ejUÞ
ejUð0:2 þ 0:3742 cos ðUÞÞ
Then the magnitude frequency response and phase response are found to be
HðejUÞ

j0:2 þ 0:3472 cos Uj
and
:HðejUÞ
(
U
if
0:2 þ 0:3472 cos U > 0
U þ p
if
0:2 þ 0:3472 cos U < 0
Details of the magnitude calculations for several typical normalized frequencies are listed in Table 7.2.
Due to the symmetry of the coefﬁcients, the obtained FIR ﬁlter has a linear phase response as
shown in Figure 7.4. The sawtooth shape is produced by the contribution of the negative sign of the real
magnitude term 0:2 þ 0:3742 cos U in the 3-tap ﬁlter frequency response, that is,
HðejUÞ ¼ e jUð0:2 þ 0:3742 cos UÞ
In general, the FIR ﬁlter with symmetric coefﬁcients has a linear phase response (linear function of U)
as follows:
:HðejUÞ ¼ MU þ possible phase of 180
(7.13)
Table 7.2 Frequency Response Calculation in Example 7.2
U radians
f [ U fs / (2p) Hz
0.2 D 0.3742 cos U
HðejUÞ

HðejUÞjdB
:HðejUÞ
degree
0
0
0.5742
0.5742
4.82
0
p=4
1000
0.4646
0.4646
6.66
45
p=2
2000
0.2
0.2
14.0
90
3p=4
3000
0.0646
0.0646
23.8
45
p
4000
0.1742
0.1742
15.2
0
7.2 Fourier Transform Design
223

Next, we see that the 3-tap FIR ﬁlter does not give an acceptable magnitude frequency response.
To explore this response further, Figure 7.5 displays the magnitude and phase responses of 3-tap
(M ¼ 1) and 17-tap (M ¼ 8) FIR lowpass ﬁlters with a normalized cutoff frequency Uc ¼ 0:2p
radians. The calculated coefﬁcients for the 17-tap FIR lowpass ﬁlter are listed in Table 7.3.
We can make the following observations at this point:
1. The oscillations (ripples) exhibited in the passband (main lobe) and stopband (side lobes) of the
magnitude frequency response constitute the Gibbs effect. The Gibbs oscillatory behavior
originates from the abrupt truncation of the inﬁnite impulse response in Equation (7.11). To
remedy this problem, window functions will be used and will be discussed in the next section.
2. Using a larger number of the ﬁlter coefﬁcients will produce the sharp roll-off characteristic of the
transition band but may cause increased time delay and increase computational complexity for
implementing the designed FIR ﬁlter.
3. The phase response is linear in the passband. This is consistent with Equation (7.13), which means
that all frequency components of the ﬁlter input within the passband are subjected to the same time
delay at the ﬁlter output. This is a requirement for applications in audio and speech ﬁltering, where
phase distortion needs to be avoided. Note that we impose a linear phase requirement, that is, the
FIR coefﬁcients are symmetric about the middle coefﬁcient, and the FIR ﬁlter order is an odd
number. If the design methods cannot produce the symmetric coefﬁcients or generate anti-
symmetric coefﬁcients (Proakis and Manolakis, 1996), the resultant FIR ﬁlter does not have the
0
500
1000
1500
2000
2500
3000
3500
4000
80
60
40
20
0
Frequency (Hz)
Magn tude response (dB)
0
500
1000
1500
2000
2500
3000
3500
4000
200
100
0
100
Frequency (Hz)
Phase response (degrees)
FIGURE 7.4
Magnitude frequency response in Example 7.2.
224
CHAPTER 7 Finite Impulse Response Filter Design

linear phase property. (Linear phase even-order FIR ﬁlters and FIR ﬁlters using the anti-symmetry
of coefﬁcients are discussed in Proakis and Manolakis [1996].)
To further probe the linear phase property, we consider a sinusoidal sequence xðnÞ ¼ A sin ðnUÞ as the
FIR ﬁlter input, with the output expected to be
yðnÞ ¼ AjHjsinðnU þ fÞ
where f ¼ MU. Substituting f ¼ MU into y(n) leads to
yðnÞ ¼ AjHjsin½Uðn  MÞ
0
0.5
1
1.5
2
2.5
3
3.5
80
60
40
20
0
20
Magn tude response
Frequency (radians)
0
0.5
1
1.5
2
2.5
3
3.5
600
400
200
0
200
Frequency (radians)
Phase (degrees)
Linear phase responses
Ripples on passband
Ripples on stopband
      (side lobes)
Main lobe
FIGURE 7.5
Magnitude and phase frequency responses of the lowpass FIR ﬁlters with 3 coefﬁcients (dash-dotted line) and 17
coefﬁcients (solid line).
Table 7.3 17-Tap FIR Lowpass Filter Coefﬁcients in Example 7.2 ( M ¼ 8)
b0
b16
0.0378
b1
b15
0.0432
b2
b14
0.0312
b3
b13
0.0000
b4
b12
0.0468
b5
b11
0.1009
b6
b10
0.1514
b7
b9
0.1871b8
0.2000
7.2 Fourier Transform Design
225

This clearly indicates that within the passband, all frequency components passing through the FIR
ﬁlter will have the same constant delay at the output, which equals M samples. Hence, phase distortion
is avoided.
Figure 7.6 veriﬁes the linear phase property using an FIR ﬁlter with 17 taps. Two sinusoids of the
normalized digital frequencies 0:05p and 0:15p radians, respectively, are used as inputs. These two
input signals are within the passband, so their magnitudes are not changed. As shown in Figure 7.6,
beginning at the ninth sample the output matches the input, which is delayed by eight samples for
each case.
What would happen if the ﬁlter phase were nonlinear? This can be illustrated using the following
combined sinusoids as the ﬁlter input:
xðnÞ ¼ x1ðnÞ þ x2ðnÞ ¼ sinð0:05pnÞuðnÞ  1
3 sin ð0:15pnÞuðnÞ
The original xðnÞ is the top plot shown in Figure 7.7. If the linear phase response of a ﬁlter is
considered, such as f ¼ MU0, where M ¼ 8 in our illustration, we have the ﬁltered output as
y1ðnÞ ¼ sin ½0:05pðn  8Þ  1
3 sin ½0:15pðn  8Þ
0
5
10
15
20
25
30
35
40
45
50
2
0
2
x1(n)=s n(0.05*p *n)
0
5
10
15
20
25
30
35
40
45
50
2
0
2
y1(n)
0
5
10
15
20
25
30
35
40
45
50
2
0
2
x2(n)=s n(0.15*p *n)
0
5
10
15
20
25
30
35
40
45
50
2
0
2
n
y2(n)
M=8
Matching x1(n)
M=8
Matching x2(n)
FIGURE 7.6
Illustration of FIR ﬁlter linear phase property (constant delay of eight samples).
226
CHAPTER 7 Finite Impulse Response Filter Design

The linear phase effect is shown in the middle plot of Figure 7.7. We see that y1ðnÞ is the eight-sample
delayed version of xðnÞ. However, considering a unit gain ﬁlter with a phase delay of 90 degrees for all
the frequency components, we obtain the ﬁltered output as
y2ðnÞ ¼ sinð0:05pn  p=2Þ  1
3 sinð0:15pn  p=2Þ
where the ﬁrst term has a phase shift of 10 samples (see sin½0:05pðn  10Þ), while the second term
has a phase shift of 10=3 samples

see 1
3 sin

0:15p

n  10
3

. Certainly, we do not have the
linear phase feature. The signal y2ðnÞ plotted in Figure 7.7 shows that the waveform shape is
different from that of the original signal xðnÞ, and hence has signiﬁcant phase distortion. This phase
distortion is audible for audio applications and can be avoided by using an FIR ﬁlter, which has the
linear phase feature.
We now have ﬁnished discussing the coefﬁcient calculation for the FIR lowpass ﬁlter, which has
a good linear phase property. To explain the calculation of ﬁlter coefﬁcients for the other types of ﬁlters
and examine the Gibbs effect, we look at another simple example.
0
5
10
15
20
25
30
35
40
45
50
-2
0
2
x(n)=x1(n)+x2(n)
0
5
10
15
20
25
30
35
40
45
50
-2
0
2
y1(n)
0
5
10
15
20
25
30
35
40
45
50
-2
0
2
n
y2(n)
M 8
Matching x(n)
Linear phase filter output
90 degree phase shift
for x1(n) and x2(n)
Output waveform shape is
different from the one of x(n)
Combined two
sinusoidal input
FIGURE 7.7
Comparison of linear and nonlinear phase responses.
7.2 Fourier Transform Design
227

EXAMPLE 7.3
a. Calculate the ﬁlter coefﬁcients for a 5 tap FIR bandpass ﬁlter with a lower cutoff frequency of 2,000 Hz and an
upper cutoff frequency of 2,400 Hz and a sampling rate of 8,000 Hz.
b. Determine the transfer function and plot the frequency responses with MATLAB.
Solution:
a. Calculating the normalized cutoff frequencies leads to
UL
2pfL=fs
2p  2; 000=8; 000
0:5p radians
UH
2pfH=fs
2p  2; 400=8; 000
0:6p radians
Since 2M þ 1
5 in this case, using the equation in Table 7.1 yields
hðnÞ
8
>
>
>
<
>
>
>
:
UH
UL
p
n
0
sinðUHnÞ
np
sinðULnÞ
np
ns0
2  n  2
(7.14)
Calculations for noncausal FIR coefﬁcients are listed as
hð0Þ
UH
UL
p
0:6p
0:5p
p
0:1
The other computed ﬁlter coefﬁcients via Equation (7.14) are
hð1Þ
sin½0:6p  1
1  p
sin½0:5p  1
1  p
0:01558
hð2Þ
sin½0:6p  2
2  p
sin½0:5p  2
2  p
0:09355
Using symmetry leads to
hð 1Þ
hð1Þ
0:01558
hð 2Þ
hð2Þ
0:09355
Thus, delaying hðnÞ by M
2 samples gives
b0
b4
0:09355
b1
b3
0:01558;
and
b2
0:1
b. The transfer function is achieved as
HðzÞ
0:09355
0:01558z1 þ 0:1z2
0:01558z3
0:09355z4
To complete Example 7.3, the magnitude frequency response plotted in terms of
HðejUÞ

dB
20log10jHðejUÞj
using MATLAB Program 7.1 is displayed in Figure 7.8.
228
CHAPTER 7 Finite Impulse Response Filter Design

Program 7.1. MATLAB program for Example 7.3.
% Example 7.3
% MATLAB program to plot frequency response
%
[hz,w] freqz([ 0.09355
0.01558 0.1
0.01558
0.09355], [1], 512);
phi 180*unwrap(angle(hz))/pi;
subplot(2,1,1), plot(w,20*log10(abs(hz))),grid;
xlabel(’Frequency (radians)’);
ylabel(’Magnitude Response (dB)’)
subplot(2,1,2), plot(w, phi); grid;
xlabel(’Frequency (radians)’);
ylabel(’Phase (degrees)’);
To summarize Example 7.3, the magnitude frequency response demonstrates the Gibbs oscillatory
behavior existing in the passband and stopband. The peak of the main lobe in the passband is dropped
from 0 dB to approximately 10 dB, while for the stopband, the lower side lobe in the magnitude
response plot swings approximately between
18 dB and
70 dB, and the upper side lobe swings
between 25 dB and 68 dB. As we have pointed out, this is due to the abrupt truncation of the inﬁnite
impulse sequence hðnÞ. The oscillations can be reduced by increasing the number of coefﬁcients and
using a window function, which will be studied next.
0
0.5
1
1.5
2
2.5
3
3.5
0
100
200
300
Frequency (radians)
Phase (degrees)
0
0.5
1
1.5
2
2.5
3
3.5
80
60
40
20
0
Frequency (radians)
Magn tude response (dB)
Side obe
Side lobe
Main lobe
FIGURE 7.8
Frequency responses for Example 7.3.
7.2 Fourier Transform Design
229

7.3 WINDOW METHOD
In this section, the window method (Fourier transform design with window functions) is developed to
remedy the undesirable Gibbs oscillations in the passband and stopband of the designed FIR ﬁlter.
Recall that the Gibbs oscillations originate from the abrupt truncation of the inﬁnite-length coefﬁ-
cient sequence. Then it is natural to seek a window function, which is symmetrical and can gradually
weight the designed FIR coefﬁcients down to zeros at both ends for the range M  n  M.
Applying the window sequence to the ﬁlter coefﬁcients gives
hwðnÞ ¼ hðnÞ$wðnÞ
where wðnÞ designates the window function. Common window functions used in the FIR ﬁlter design
are as follows:
1. Rectangular window:
wrecðnÞ ¼ 1; M  n  M
(7.15)
2. Triangular (Bartlett) window:
wtriðnÞ ¼ 1  jnj
M; M  n  M
(7.16)
3. Hanning window:
whanðnÞ ¼ 0:5 þ 0:5 cos
np
M

; M  n  M
(7.17)
4. Hamming window:
whamðnÞ ¼ 0:54 þ 0:46 cos
np
M

; M  n  M
(7.18)
5. Blackman window:
wblackðnÞ ¼ 0:42 þ 0:5 cos
np
M

þ 0:08 cos
2np
M

; M  n  M
(7.19)
In addition, there is another popular window function, called the Kaiser window (detailed
information can be found in Oppenheim, Shaffer, and Buck [1999]). As we expected, the rect-
angular window function has a constant value of 1 within the window, and hence only does
truncation. For comparison, shapes of the other window functions from Equations (7.16) to (7.19)
are plotted in Figure 7.9 for the case of 2M þ 1 ¼ 81.
We apply the Hamming window function in Example 7.4.
230
CHAPTER 7 Finite Impulse Response Filter Design

EXAMPLE 7.4
Given the calculated ﬁlter coefﬁcients
hð0Þ
0:25; hð
1Þ
hð1Þ
0:22508; hð
2Þ
hð2Þ
0:15915; hð
3Þ
hð3Þ
0:07503
a. apply the hamming window function to obtain windowed coefﬁcients hwðnÞ;
b. plot the impulse response hðnÞ and windowed impulse response hwðnÞ.
Solution:
a. Since M
3, applying Equation (7.18) leads to the window sequence
whamð
3Þ
0:54 þ 0:46 cos
 3  p
3

0:08
whamð
2Þ
0:54 þ 0:46 cos
 2  p
3

0:31
whamð
1Þ
0:54 þ 0:46 cos
 1  p
3

0:77
whamð0Þ
0:54 þ 0:46 cos
0  p
3

1
40
30
20
10
0
10
20
30
40
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Number of samples
Magn tude
FIGURE 7.9
Shapes of window functions for the case of 2M þ 1 ¼ 81. “o” line, triangular window; “þ” line, Hanning
window; solid line, Hamming window; dashed line, Blackman window.
7.3 Window Method
231

whamð1Þ
0:54 þ 0:46 cos
1  p
3

0:77
whamð2Þ
0:54 þ 0:46 cos
2  p
3

0:31
whamð3Þ
0:54 þ 0:46 cos
3  p
3

0:08
Applying the Hamming window function and its symmetric property to the ﬁlter coefﬁcients, we get
hwð0Þ
hð0Þ$whamð0Þ
0:25  1
0:25
hwð1Þ
hð1Þ$whamð1Þ
0:22508  0:77
0:17331
hwð 1Þ
hwð2Þ
hð2Þ$whamð2Þ
0:15915  0:31
0:04934
hwð
2Þ
hwð3Þ
hð3Þ$whamð3Þ
0:07503  0:08
0:00600
hwð 3Þ
b. Noncausal impulse responses hðnÞ and hwðnÞ are plotted in Figure 7.10.
We observe that the Hamming window does its job and weights the FIR ﬁlter coefﬁcients to zero gradually at
both ends. Hence, we can expect a reduced Gibbs effect in the magnitude frequency response.
4
3
2
1
0
1
2
3
4
0
0.1
0.2
Sample number n
h(n)
4
3
2
1
0
1
2
3
4
0
0.1
0.2
Sample number n
hw(n)
FIGURE 7.10
Plots of FIR noncausal coefﬁcients and windowed FIR coefﬁcients in Example 7.4.
232
CHAPTER 7 Finite Impulse Response Filter Design

Now lowpass FIR ﬁlter design via the window method can be achieved. The design procedure
includes three steps. The ﬁrst step is to obtain the truncated impulse response hðnÞ, where M  n  M;
then we multiply the obtained sequence hðnÞ by the selected window data sequence to yield the
windowed noncausal FIR ﬁlter coefﬁcients hwðnÞ; the ﬁnal step is to delay the windowed noncausal
sequence hwðnÞ by M samples to obtain the causal FIR ﬁlter coefﬁcients, bn ¼ hwðn  MÞ. The design
procedure of the FIR ﬁlter via windowing is summarized as follows:
1. Obtain the FIR ﬁlter coefﬁcients hðnÞ via the Fourier transform method (Table 7.1).
2. Multiply the generated FIR ﬁlter coefﬁcients by the selected window sequence
hwðnÞ ¼ hðnÞwðnÞ; n ¼ M; /0; 1; /; M
(7.20)
where wðnÞ is chosen to be one of the window functions listed in Equations (7.15) to (7.19).
3. Delay the windowed impulse sequence hwðnÞ by M samples to get the windowed FIR ﬁlter
coefﬁcients
bn ¼ hwðn  MÞ;
for
n ¼ 0; 1; /; 2M
(7.21)
Let us study the following design examples.
EXAMPLE 7.5
a. Design a 3 tap FIR lowpass ﬁlter with a cutoff frequency of 800 Hz and a sampling rate of 8,000 Hz using the
Hamming window function.
b. Determine the transfer function and difference equation of the designed FIR system.
c. Compute and plot the magnitude frequency response for U
0; p=4; p=2; 3p=4; and p radians.
Solution:
a. The normalized cutoff frequency is calculated as
Uc
2pfcTs
2p  800=8; 000
0:2p radians
Since 2M þ 1
3 in this case, FIR coefﬁcients obtained by using the equation in Table 7.1 are listed as
hð0Þ
0:2
and
hð 1Þ
hð1Þ
0:1871
(see Example 7.2). Applying the Hamming window function deﬁned in Equation (7.18), we have
whamð0Þ
0:54 þ 0:46 cos
0p
1

1
whamð1Þ
0:54 þ 0:46 cos
1  p
1

0:08
Using the symmetry of the window function gives
whamð 1Þ
whamð1Þ
0:08
The windowed impulse response is calculated as
hwð0Þ
hð0Þwhamð0Þ
0:2  1
0:2
7.3 Window Method
233

hwð1Þ
hð1Þwhamð1Þ
0:1871  0:08
0:01497
hwð 1Þ
hð 1Þwhamð 1Þ
0:1871  0:08
0:01497
Thus delaying hwðnÞ by M
1 sample gives
b0
b2
0:01496
and
b1
0:2
b. The transfer function is
HðzÞ
0:01497 þ 0:2z1 þ 0:01497z2
Using the technique described in Chapter 6, we have
Y ðzÞ
XðzÞ
HðzÞ
0:01497 þ 0:2z1 þ 0:01497z2
Multiplying X(z) leads to
Y ðzÞ
0:01497XðzÞ þ 0:2z1XðzÞ þ 0:01497z2XðzÞ
Applying the inverse z transform on both sides, the difference equation is obtained as
yðnÞ
0:01497xðnÞ þ 0:2xðn
1Þ þ 0:01497xðn
2Þ
c. The magnitude frequency response and phase response can be obtained using the technique introduced in
Chapter 6. Substituting z
ejU into HðzÞ, it follows that
HðejUÞ
0:01497 þ 0:2ejU þ 0:01497ej2U
ejUð0:01497ejU þ 0:2 þ 0:01497ejUÞ
Using Euler’s formula leads to
HðejUÞ
ejUð0:2 þ 0:02994 cos UÞ
Then the magnitude frequency response and phase response are found to be
HðejUÞ

j0:2 þ 0:2994 cos Uj
Table 7.4 Frequency Response Calculation in Example 7.5
U radians
f [ Ufs=ð2pÞ
Hz
0:2D0:02994 cos U
HðejUÞ

HðejUÞ

dB dB
:HðejUÞ
degrees
0
0
0.2299
0.2299
12.77
0
p=4
1,000
0.1564
0.2212
13.11
45
p=2
2,000
0.2000
0.2000
13.98
90
3p=4
3,000
0.1788
0.1788
14.95
135
p
4,000
0.1701
0.1701
15.39
180
234
CHAPTER 7 Finite Impulse Response Filter Design

and
:HðejUÞ
(
U
if
0:2 þ 0:02994 cos U > 0
U þ p
if
0:2 þ 0:02994 cos U < 0
The calculation details of the magnitude response for several normalized values are listed in Table 7.4.
Figure 7.11 shows the plots of the frequency responses.
EXAMPLE 7.6
a. Design a 5 tap FIR band reject (bandstop) ﬁlter with a lower cutoff frequency of 2,000 Hz, an upper cutoff
frequency of 2,400 Hz, and a sampling rate of 8,000 Hz using the Hamming window method.
b. Determine the transfer function.
Solution:
a. Calculating the normalized cutoff frequencies leads to
UL
2pfLT
2p  2; 000=8; 000
0:5p radians
0
500
1000
1500
2000
2500
3000
3500
4000
30
20
10
0
Frequency (Hz)
Magn tude response (dB)
0
500
1000
1500
2000
2500
3000
3500
4000
200
150
100
50
0
50
Frequency (Hz)
Phase response (degrees)
FIGURE 7.11
The frequency responses in Example 7.5.
7.3 Window Method
235

UH
2pfHT
2p  2; 400=8; 000
0:6p radians
Since 2M þ 1
5 in this case, using the equation in Table 7.1 yields
hðnÞ
8
>
>
>
<
>
>
>
:
p
UH þ UL
p
n
0
sinðUHnÞ
np
þ sinðULnÞ
np
ns0
2  n  2
When n
0, we have
hð0Þ
p
UH þ UL
p
p
0:6p þ 0:5p
p
0:9
The other computed ﬁlter coefﬁcients for the previous expression are listed below:
hð1Þ
sin½0:5p  1
1  p
sin½0:6p  1
1  p
0:01558
hð2Þ
sin½0:5p  2
2  p
sin½0:6p  2
2  p
0:09355
Using symmetry leads to
hð 1Þ
hð1Þ
0:01558
hð 2Þ
hð2Þ
0:09355
Applying the Hamming window function in Equation (7.18), we have
whamð0Þ
0:54 þ 0:46 cos
0  p
2

1:0
whamð1Þ
0:54 þ 0:46 cos
1  p
2

0:54
whamð2Þ
0:54 þ 0:46 cos
2  p
2

0:08
Using the symmetry of the window function gives
whamð 1Þ
whamð1Þ
0:54
whamð 2Þ
whamð2Þ
0:08
The windowed impulse response is calculated as
hwð0Þ
hð0Þwhamð0Þ
0:9  1
0:9
236
CHAPTER 7 Finite Impulse Response Filter Design

hwð1Þ
hð1Þwhamð1Þ
0:01558  0:54
0:00841
hwð2Þ
hð2Þwhamð2Þ
0:09355  0:08
0:00748
hwð 1Þ
hð 1Þwhamð 1Þ
0:00841
hwð 2Þ
hð 2Þwhamð 2Þ
0:00748
Thus, delaying hwðnÞ by M
2 samples gives
b0
b4
0:00748; b1
b3
0:00841;
and
b2
0:9
b. The transfer function is
HðzÞ
0:00748 þ 0:00841z1 þ 0:9z2 þ 0:00841z3 þ 0:00748z4
The following design examples are demonstrated using MATLAB programs. The MATLAB
function ﬁrwd(N, Ftype, WnL, WnH, Wtype) is listed in the “MATLAB Programs” section at the
end of this chapter. Table 7.5 lists comments to show how the function is used.
Table 7.5 Illustration of the MATLAB Function for FIR Filter Design Using Window Methods
function B ﬁrwd(N,Ftype,WnL,WnH,Wtype)
% B
ﬁrwd(N,Ftype,WnL,WnH,Wtype)
% FIR ﬁlter design using the window function method.
% Input parameters:
% N: the number of the FIR ﬁlter taps.
% Note: It must be odd number.
% Ftype: the ﬁlter type
%
1. Lowpass ﬁlter
%
2. Highpass ﬁlter
%
3. Bandpass ﬁlter
%
4. Band reject (Bandstop) ﬁlter
% WnL: lower cutoff frequency in radians. Set WnL 0 for the highpass ﬁlter.
% WnH: upper cutoff frequency in radians. Set WnH 0 for the lowpass ﬁlter.
% Wtypw: window function type
%
1. Rectangular window
%
2. Triangular window
%
3. Hanning window
%
4. Hamming window
%
5. Blackman window
7.3 Window Method
237

EXAMPLE 7.7
a. Design a lowpass FIR ﬁlter with 25 taps using the MATLAB program listed in the “MATLAB Programs” section
at the end of this chapter. The cutoff frequency of the ﬁlter is 2,000 Hz, assuming a sampling frequency of
8,000 Hz. The rectangular window and Hamming window functions are used for each design.
b. Plot the frequency responses along with those obtained using the rectangular window and Hamming window for
comparison.
c. List the FIR ﬁlter coefﬁcients for each window design method.
Solution:
a. With a given sampling rate of 8,000 Hz, the normalized cutoff frequency can be found as
Uc
2; 000  2p
8; 000
0:5p radians
Now we are ready to design FIR ﬁlters via the MATLAB program. The function ﬁrwd(N, Ftype, WnL, WnH, Wtype)
listed in the “MATLAB Programs” section at the end of this chapter, has ﬁve input parameters, which are described
as follows:
•
“N” is the number of speciﬁed ﬁlter coefﬁcients (the number of ﬁlter taps).
•
“Ftype” denotes the ﬁlter type, that is, input “1” for the lowpass ﬁlter design, input “2” for the highpass ﬁlter
design, input “3” for the bandpass ﬁlter design, and input “4” for the band reject ﬁlter design.
0
500
1000
1500
2000
2500
3000
3500
4000
100
50
0
Frequency (Hz)
Magn tude response (dB)
0
500
1000
1500
2000
2500
3000
3500
4000
2000
1500
1000
500
0
Frequency (Hz)
Phase (degrees)
FIGURE 7.12
Frequency responses using the rectangular and Hamming windows.
238
CHAPTER 7 Finite Impulse Response Filter Design

•
“WnL” and “WnH” are the lower and upper cutoff frequency inputs, respectively. Note that WnH
0 when
specifying WnL for the lowpass ﬁlter design, while WnL
0 when specifying WnH for the highpass ﬁlter design.
•
“Wtype” speciﬁes the window data sequence to be used in the design, that is, input “1” for the rectangular
window, input “2” for the triangular window, input “3” for the Hanning window, input “4” for the Hamming
window, and input “5” for the Blackman window.
b. The following program (Program 7.2) is used to generate FIR ﬁlter coefﬁcients using the rectangular window. Its
frequency responses will be plotted together with the results of the FIR ﬁlter design obtained using the Hamming
window, as shown in Program 7.3.
Program 7.2. MATLAB program for Example 7.7.
% Example 7.7
% MATLAB program to generate FIR coefficients
% using the rectangular window.
%
N 25; Ftype 1; WnL 0.5*pi; WnH 0; Wtype 1;
B firwd(N,Ftype,WnL,WnH,Wtype);
Program 7.3. MATLAB program for Example 7.7.
%Figure 7.12
% MATLAB program to create Figure 7.12
%
N 25; Ftype 1; WnL 0.5*pi; WnH 0; Wtype 1;fs 8000;
%design using the rectangular window;
Brec firwd(N,Ftype,WnL,WnH,Wtype);
N 25; Ftype 1; WnL 0.5*pi; WnH 0; Wtype 4;
%design using the Hamming window;
Bham firwd(N,Ftype,WnL,WnH,Wtype);
[hrec,f] freqz(Brec,1,512,fs);
[hham,f] freqz(Bham,1,512,fs);
prec 180*unwrap(angle(hrec))/pi;
pham 180*unwrap(angle(hham))/pi;
subplot(2,1,1);
Table 7.6 FIR Filter Coefﬁcients in Example 7.7 (rectangular and Hamming windows)
B: FIR Filter Coefﬁcients (Rectangular
Window)
Bham: FIR Filter Coefﬁcients (Hamming
Window)
b0
b24
0.000000
b1
b23
0.028937
b2
b22
0.000000
b3
b21
0.035368
b4
b20
0.000000
b5
b19
0.045473
b6
b18
0.000000
b7
b17
0.063662
b8
b16
0.000000
b9
b15
-0.106103
b10
b14
0.000000
b11
b13
0.318310
b12
0.500000
b0
b24
0.000000
b1
b23
0.002769
b2
b22
0.000000
b3
b21
0.007595
b4
b20
0.000000
b5
b19
0.019142
b6
b18
0.000000
b7
b17
0.041957
b8
b16
0.000000
b9
b15
0.091808
b10
b14
0.000000
b11
b13
0.313321
b12
0.500000
7.3 Window Method
239

plot(f,20*log10(abs(hrec)),’ .’,f,20*log10(abs(hham)));grid
axis([0 4000
100 10]);
xlabel(’Frequency (Hz)’); ylabel(’Magnitude Response (dB)’);
subplot(2,1,2);
plot(f,prec,’ .’,f,pham);grid
xlabel(’Frequency (Hz)’); ylabel(’Phase (degrees)’);
For comparison, the frequency responses achieved from the rectangular window and the Hamming window are
plotted in Figure 7.12, where the dash dotted line indicates the frequency response via the rectangular window,
and the solid line indicates the frequency response via the Hamming window.
c. The FIR ﬁlter coefﬁcients for both methods are listed in Table 7.6.
For comparison with other window functions, Figure 7.13 shows the magnitude frequency responses
using the Hanning, Hamming, and Blackman windows, with 25 taps and a cutoff frequency of 2,000 Hz.
The Blackman window offers the lowest side lobe, but with an increased width of the main lobe. The
Hamming window and Hanning have a similar narrow width of the main lobe, but the Hamming window
accommodates a lower side lobe than the Hanning window. Next, we will study how to choose a window in
practice.
Applying the window to remedy the Gibbs effect will change the characteristics of the magnitude
frequency response of the FIR ﬁlter, as the width of the main lobe becomes wider and more attenuation
of the side lobes occurs.
0
500
1000
1500
2000
2500
3000
3500
4000
140
120
100
80
60
40
20
0
20
Magn tude frequency responses
Frequency (Hz)
Hanning window
Peak of 1st side lobe
Hamming window
Peak of 1st side lobe
Blackman window
Peak of 1st side lobe
FIGURE 7.13
Comparisons of magnitude frequency responses for the Hanning, Hamming, and Blackman windows.
240
CHAPTER 7 Finite Impulse Response Filter Design

Next, we illustrate the design for customer speciﬁcations in practice. Given the required stopband
attenuation and passband ripple speciﬁcations shown in Figure 7.14, where the lowpass ﬁlter speci-
ﬁcations are given for illustrative purposes, the appropriate window can be selected based on the
performance of the window functions listed in Table 7.7. For example, the Hamming window offers
a passband ripple of 0.0194 dB and stopband attenuation of 53 dB. With the selected Hamming
window and the normalized transition band deﬁned in Table 7.7,
Df ¼
fstop  fpass

.
fs
(7.22)
FIGURE 7.14
Lowpass ﬁlter frequency domain speciﬁcations.
TABLE 7.7 FIR Filter Length Estimation Using Window Functions
(normalized transition width Df ¼ jfstop  fpassj=fs)
Window Type
Window Function
wðnÞ,LM £ n £ M
Window Length N
Passband
Ripple (dB)
Stopband
Attenuation (dB)
Rectangular
1
N
0:9=Df
0.7416
21
Hanning
0:5 þ 0:5 cos
pn
M

N
3:1=Df
0.0546
44
Hamming
0:54 þ 0:46 cos
pn
M

N
3:3=Df
0.0194
53
Blackman
0:42 þ 0:5 cos
np
M

þ0:08 cos
2np
M

N
5:5=Df
0.0017
74
7.3 Window Method
241

the ﬁlter length using the Hamming window can be determined by
N ¼ 3:3
Df
(7.23)
Note that the passband ripple is deﬁned as
dpdB ¼ 20$log10ð1 þ dpÞ
(7.24)
while the stopband attenuation is deﬁned as
dsdB ¼ 20 log 10ðdsÞ
(7.25)
The cutoff frequency used for the design will be chosen at the middle of the transition band, as
illustrated for the lowpass ﬁlter case shown in Figure 7.14.
As a rule of thumb, the cutoff frequency used for design is determined by
fc ¼ ð fpass þ fstopÞ=2
(7.26)
Note that Equation (7.23) and formulas for other window lengths in Table 7.7 are empirically derived
based on the normalized spectral transition width of each window function. The spectrum of each
window function appears to be shaped like the lowpass ﬁlter magnitude frequency response with
ripples in the passband and side lobes in the stopband. The passband frequency edge of the spectrum
is the frequency where the magnitude just begins to drop below the passband ripple and where the
stop frequency edge is at the peak of the ﬁrst side lobe in the spectrum. With the passband ripple and
stopband attenuation speciﬁed for a particular window, the normalized transition width of the
window is in inverse proportion to the window length N multiplied by a constant. For example, the
normalized spectral transition Df for the Hamming window is 3:3=N. Hence, matching the FIR ﬁlter
transition width with the transition width of the window spectrum gives the ﬁlter length estimation
listed in Table 7.7.
The following examples illustrate the determination of each ﬁlter length and cutoff frequency/
frequencies for the design of lowpass, highpass, bandpass, and bandstop ﬁlters. Application of each
designed ﬁlter to the processing of speech data is included, along with an illustration of ﬁltering effects
in both the time domain and frequency domain.
EXAMPLE 7.8
A lowpass FIR ﬁlter has the following speciﬁcations:
Passband 0e1,850 Hz
Stopband 2,150e4,000 Hz
Stopband attenuation 20 dB
Passband ripple 1 dB
Sampling rate 8,000 Hz
Determine the FIR ﬁlter length and the cutoff frequency to be used in the design equation.
242
CHAPTER 7 Finite Impulse Response Filter Design

Solution:
The normalized transition band as deﬁned in Equation (7.22) and Table 7.7 is given by
Df
j2; 150
1; 850j=8; 000
0:0375
Again, based on Table 7.7, selecting the rectangular window will result in a passband ripple of 0.74 dB and
stopband attenuation of 21 dB. Thus, this window selection would satisfy the design requirement for a passband
ripple of 1 dB and stopband attenuation of 20 dB. Next, we determine the length of the ﬁlter as
N
0:9=Df
0:9=0:0375
24
We choose the odd number N
25. The cutoff frequency is determined by (1,850 þ 2,150)/2
2,000 Hz. Such
a ﬁlter has been designed in Example 7.7, its ﬁlter coefﬁcients are listed in Table 7.6, and its frequency responses
can be found in Figure 7.12 (dashed lines).
Now we look at the time domain and frequency domain results from ﬁltering a speech signal by using the
lowpass ﬁlter we have just designed. Figure 7.15A shows the original speech and lowpass ﬁltered speech. The
spectral comparison is given in Figure 7.15B, where, as we can see, the frequency components beyond 2 kHz are
ﬁltered. The lowpass ﬁltered speech would sound mufﬂed.
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0.5
0
0.5
1
x 10
4
Speech
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0.5
0
0.5
1
x 10
4
Lowpassed speech
Sample number
FIGURE 7.15A
Original speech and processed speech using the lowpass ﬁlter.
7.3 Window Method
243

We will continue to illustrate the determination of the ﬁlter length and cutoff frequency for other
types of ﬁlters via the following examples.
EXAMPLE 7.9
Design a highpass FIR ﬁlter with the following speciﬁcations:
Stopband 0e1,500 Hz
Passband 2,500e4,000 Hz
Stopband attenuation 40 dB
Passband ripple 0.1 dB
Sampling rate 8,000 Hz
Solution:
Based on the speciﬁcation, the Hanning window will do the job since it has a passband ripple of 0.0546 dB and
stopband attenuation of 44 dB.
Then
Df
j1; 500
2; 500j=8; 000
0:125
0
500
1000
1500
2000
2500
3000
3500
4000
0
200
400
600
800
Frequency (Hz)
Amp tude X(f)  
0
500
1000
1500
2000
2500
3000
3500
4000
0
200
400
600
800
Frequency (Hz)
Amp tude Y(f)  
FIGURE 7.15B
Spectral plots of the original speech and processed speech by the lowpass ﬁlter.
244
CHAPTER 7 Finite Impulse Response Filter Design

Table 7.8 FIR Filter Coefﬁcients in Example 7.9 (Hanning window)
Bhan: FIR Filter Coefﬁcients (Hanning Window)
b0
b24
0.000000
b1
b23
0.000493
b2
b22
0.000000
b3
b21
0.005179
b4
b20
0.000000
b5
b19
0.016852
b6
b18
0.000000
b7
b17
0.040069
b8
b16
0.0000000
b9
b15
0.090565
b10
b14
0.000000
b11
b13
0.312887
b12
0.500000
0
500
1000
1500
2000
2500
3000
3500
4000
-1500
-1000
-500
0
500
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
-100
-50
0
Frequency (Hertz)
Magn tude response (dB)
FIGURE 7.16
Frequency responses of the designed highpass ﬁlter using the Hanning window.
7.3 Window Method
245

N
3:1=Df
24:2 ðchoose N
25Þ
Hence, we choose 25 ﬁlter coefﬁcients using the Hanning window method. The cutoff frequency is
(1,500 þ 2,500)/2
2,000 Hz. The normalized cutoff frequency can be easily found as
Uc
2; 000  2p
8; 000
0:5p radians
Notice that 2M þ 1
25. The application program and design results are listed in Program 7.4 and
Table 7.8.
Program 7.4. MATLAB program for Example 7.9
%Figure 7.16(Example 7.9)
% MATLAB program to create Figure 7.16
%
N 25; Ftype 2; WnL 0; WnH 0.5*pi; Wtype 3;fs 8000;
Bhan firwd(N,Ftype,WnL,WnH,Wtype);
freqz(Bhan,1,512,fs);
axis([0 fs/2
120 10]);
The corresponding frequency responses of the designed highpass FIR ﬁlter are displayed in Figure 7.16.
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0.5
0
0.5
1
x 10
4
Speech
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0.5
0
0.5
1
x 10
4
H ghpassed speech
Sample number
FIGURE 7.17A
Original speech and processed speech using the highpass ﬁlter.
246
CHAPTER 7 Finite Impulse Response Filter Design

Comparisons are given in Figure 7.17A, where the original speech and processed speech using the highpass
ﬁlter are plotted, respectively. The high frequency components of speech generally contain a small amount of
energy. Figure 7.17B displays the spectral plots, where clearly the frequency components lower than 1.5 kHz are
ﬁltered. The processed speech would sound crisp.
EXAMPLE 7.10
Design a bandpass FIR ﬁlter with the following speciﬁcations:
Lower stopband 0e500 Hz
Passband 1,600e2,300 Hz
Upper stopband 3,500e4,000 Hz
Stopband attenuation 50 dB
Passband ripple 0.05 dB
Sampling rate 8,000 Hz
Solution:
Df1
j1; 600
500j=8; 000
0:1375
and
Df2
j3; 500
2; 300j=8; 000
0:15
N1
3:3=0:1375
24
and
N2
3:3=0:15
22
0
500
1000
1500
2000
2500
3000
3500
4000
0
200
400
600
800
Frequency (Hz)
Amp tude X(f)  
0
500
1000
1500
2000
2500
3000
3500
4000
0
10
20
30
Frequency (Hz)
Amp tude Y(f)  
FIGURE 7.17B
Spectral comparison of the original speech and processed speech using the highpass ﬁlter.
7.3 Window Method
247

We select N
25 for the number of ﬁlter coefﬁcients and using the Hamming window method, we next obtain
f1
ð1; 600 þ 500Þ=2
1; 050 Hz
and f2
ð3; 500 þ 2; 300Þ=2
2; 900 Hz
The normalized lower and upper cutoff frequencies are calculated as
UL
1; 050  2p
8; 000
0:2625p radians
UH
2; 900  2p
8; 000
0:725p radians
and N
2M þ 1
25. The design results are shown using the MATLAB program in Program 7.5.
Program 7.5. MATLAB program for Example 7.10.
%Figure 7.18(Example 7.10)
% MATLAB program to create Figure 7.18
%
N 25; Ftype 3; WnL 0.2625*pi; WnH 0.725*pi; Wtype 4;fs 8000;
Bham firwd(N,Ftype,WnL,WnH,Wtype);
freqz(Bham,1,512,fs);
axis([0 fs/2
130 10]);
Figure 7.18 depicts the frequency responses of the designed bandpass FIR ﬁlter. Table 7.9 lists the designed FIR
ﬁlter coefﬁcients.
0
500
1000
1500
2000
2500
3000
3500
4000
2000
1500
1000
500
0
500
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
100
50
0
Frequency (Hertz)
Magn tude response (dB)
FIGURE 7.18
Frequency responses of the designed bandpass ﬁlter using the Hamming window.
248
CHAPTER 7 Finite Impulse Response Filter Design

For comparison, the original speech and bandpass ﬁltered speech are plotted in Figure 7.19A, where the
bandpass frequency components contain a small portion of speech energy. Figure 7.19B shows a comparison
indicating that low and high frequencies are removed by the bandpass ﬁlter.
Table 7.9 FIR Filter Coefﬁcients in Example 7.10 (Hamming Window)
Bham: FIR Filter Coefﬁcients (Hamming Window)
b0
b24
0.002680
b1
b23
0.001175
b2
b22
0.007353
b3
b21
0.000674
b4
b20
0.011063
b5
b19
0.004884
b6
b18
0.053382
b7
b17
0.003877
b8
b16
0.028520
b9
b15
0.008868
b10
b14
0.296394
b11
b13
0.008172
b12
0.462500
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0.5
0
0.5
1
x 10
4
Speech
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0.5
0
0.5
1
x 10
4
Bandpassed speech
Sample number
FIGURE 7.19A
Original speech and processed speech using the bandpass ﬁlter.
7.3 Window Method
249

EXAMPLE 7.11
Design a bandstop FIR ﬁlter with the following speciﬁcations:
Lower cutoff frequency 1,250 Hz
Lower transition width 1,500 Hz
Upper cutoff frequency 2,850 Hz
Upper transition width 1,300 Hz
Stopband attenuation 60 dB
Passband ripple 0.02 dB
Sampling rate 8,000 Hz
Solution:
We can directly compute the normalized transition width:
Df1
1;500=8;000
0:1875
and
Df2
1;300=8;000
0:1625
The ﬁlter lengths are determined using the Blackman windows as
N1
5:5=0:1875
29:33;
and
N2
5:5=0:1625
33:8
0
500
1000
1500
2000
2500
3000
3500
4000
0
200
400
600
800
Frequency (Hz)
Amp tude X(f)  
0
500
1000
1500
2000
2500
3000
3500
4000
0
10
20
30
40
50
Frequency (Hz)
Amp tude Y(f)  
FIGURE 7.19B
Spectral comparison of the original speech and processed speech using the bandpass ﬁlter.
250
CHAPTER 7 Finite Impulse Response Filter Design

We choose N
35, an odd number. The normalized lower and upper cutoff frequencies are calculated as
UL
2p  1; 250
8; 000
0:3125p radians
UH
2p  2; 850
8; 000
0:7125p radians
and N
2M þ 1
35. Using MATLAB, the design results are demonstrated in Program 7.6.
Program 7.6. MATLAB program for Example 7.11.
%Figure 7.20 (Example 7.11)
% MATLAB program to create Figure 7.20
%
N 35; Ftype 4; WnL 0.3125*pi; WnH 0.7125*pi; Wtype 5;fs 8000;
Bblack firwd(N,Ftype,WnL,WnH,Wtype);
freqz(Bblack,1,512,fs);
axis([0 fs/2
120 10]);
Figure 7.20 shows the plot of the frequency responses of the designed bandstop ﬁlter. The designed ﬁlter
coefﬁcients are listed in Table 7.10.
Comparisons of ﬁltering effects are illustrated in Figures 7.21A and 7.21B. In Figure 7.21A, the original
speech and speech processed by the bandstop ﬁlter are plotted. The processed speech contains most of the energy
of the original speech because most of the energy of the speech signal exists in the low frequency band.
Figure 7.21B veriﬁes the ﬁltering frequency effects. The requency components ranging from 2,000 Hz to 2,200
Hz have been completely removed.
0
500
1000
1500
2000
2500
3000
3500
4000
2500
2000
1500
1000
500
0
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
100
50
0
Frequency (Hertz)
Magn tude response (dB)
FIGURE 7.20
Frequency responses of the designed bandstop ﬁlter using the Blackman window.
7.3 Window Method
251

Table 7.10 FIR Filter Coefﬁcients in Example 7.11 (Blackman Window)
Black: FIR Filter Coefﬁcients (Blackman Window)
b0
b34
0.000000
b1
b33
0.000059
b2
b32
0.000000
b3
b31
0.000696
b4
b30
0.001317
b5
b29
0.004351
b6
b28
0.002121
b7
b27
0.000000
b8
b26
0.004249
b9
b25
0.027891
b10
b24
0.011476
b11
b23
0.036062
b12
b22
0.000000
b13
b21
0.073630
b14
b20
0.020893
b15
b19
0.285306
b16
b18
0.014486
b17
0.600000
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0.5
0
0.5
1
x 10
4
Bandstopped speech
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0.5
0
0.5
1
x 10
4
Band rejected speech
Sample number
FIGURE 7.21A
Original speech and processed speech using the bandstop ﬁlter.
252
CHAPTER 7 Finite Impulse Response Filter Design

7.4 APPLICATIONS: NOISE REDUCTION AND TWO-BAND
DIGITAL CROSSOVER
In this section, we will investigate noise reduction and digital crossover design using FIR ﬁlters.
7.4.1 Noise Reduction
One of the key digital signal processing (DSP) applications is noise reduction. In this application,
a digital FIR ﬁlter removes noise in a signal that is contaminated by noise existing in a broad
frequency range. For example, such noise often appears during the data acquisition process.
In real-world applications, the desired signal usually occupies a certain frequency range. We
can design a digital ﬁlter to remove frequency components other than the desired frequency
range.
In a data acquisition system, we record a 500 Hz sine wave at a sampling rate of 8,000 samples per
second. The signal is corrupted by broadband noise vðnÞ:
xðnÞ ¼ 1:4141$sinð2p$500n=8; 000Þ þ vðnÞ
0
500
1000
1500
2000
2500
3000
3500
4000
0
200
400
600
800
Frequency (Hz)
Amp tude X(f)  
0
500
1000
1500
2000
2500
3000
3500
4000
0
200
400
600
Frequency (Hz)
Amp tude Y(f)  
FIGURE 7.21B
Spectral comparison of the original speech and processed speech using the bandstop ﬁlter.
7.4 Applications: Noise Reduction and Two Band Digital Crossover
253

The 500 Hz signal with noise and its spectrum are plotted in Figure 7.22, from which it is obvious that
the digital sine wave contains noise. The spectrum is also displayed to give a better understanding of
the noise frequency level. We can see that noise is broadband, existing from 0 Hz to the folding
frequency of 4,000 Hz. Assuming that the desired signal has a frequency range of only 0 to 800 Hz, we
can ﬁlter noise from 800 Hz and beyond. A lowpass ﬁlter would complete such a task. Then we
develop the ﬁlter speciﬁcations:
Passband frequency range: 0 Hz to 800 Hz with the passband ripple less than 0.02 dB
Stopband frequency range: 1 kHz to 4 kHz with 50 dB attenuation
As we will see, lowpass ﬁltering will remove noise in the range 1,000 Hz to 4,000 Hz , and hence the
signal to noise power ratio will be improved.
Based on the speciﬁcations, we design an FIR ﬁlter with the Hamming window, a cutoff frequency
of 900 Hz, and an estimated ﬁlter length of 133 taps. The enhanced signal is depicted in Figure 7.23,
where the clean signal can be observed. The amplitude spectrum for the enhanced signal is also
plotted. As shown in the spectral plot, the noise level is negligible between 1 and 4 kHz. Notice that
since we use the higher-order FIR ﬁlter, the signal experiences a linear phase delay of 66 samples, as is
expected. We also see some transient response effects. However, the transient response effects will end
after the ﬁrst 132 samples due to the length of the FIR ﬁlter. MATLAB implementation is given in
Program 7.7.
0
50
100
150
200
250
4
2
0
2
4
Number of samples
Samp e va ue
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.5
1
1.5
Frequency (Hz)
Amp tude X(f)  
FIGURE 7.22
Signal with noise and its spectrum.
254
CHAPTER 7 Finite Impulse Response Filter Design

Program 7.7. MATLAB program for the application of noise ﬁltering.
close all; clear all
fs 8000;
% Sampling rate
T 1/fs;
% Sampling period
v sqrt(0.1)*randn(1,250);
% Generate Gaussian random noise
n 0:1:249;
% Indexes
x sqrt(2)*sin(2*pi*500*n*T)þv;
% Generate 500 Hz plus noise
subplot(2,1,1);plot(n,x);
xlabel(’Number of samples’);ylabel(’Sample value’);grid;
N length(x);
f [0:N/2]*fs/N;
Axk 2*abs(fft(x))/N;Axk(1) Axk(1)/2;
% Calculate single side spectrum for x(n)
subplot(2,1,2); plot(f,Axk(1:N/2þ1));
xlabel(’Frequency (Hz)’); ylabel(’Amplitude jX(f)j ’);grid;
figure
Wnc 2*pi*900/fs;
% Determine the normalized digital cutoff
frequency
B firwd(133,1,Wnc,0,4);
% Design FIR filter
y filter(B,1,x);
% Perform digital filtering
Ayk 2*abs(fft(y))/N;Ayk(1) Ayk(1)/2;
% Single side spectrum of the filtered data
subplot(2,1,1); plot(n,y);
0
50
100
150
200
250
4
2
0
2
4
Number of samples
Samp e va ue
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.5
1
1.5
Frequency (Hz)
Amp tude Y(f)  
M=66
FIGURE 7.23
The clean signal and spectrum with noise removed.
7.4 Applications: Noise Reduction and Two Band Digital Crossover
255

xlabel(’Number of samples’);ylabel(’Sample value’);grid;
subplot(2,1,2);plot(f,Ayk(1:N/2þ1)); axis([0 fs/2 0 1.5]);
xlabel(’Frequency (Hz)’); ylabel(’Amplitude jY(f)j ’);grid;
7.4.2 Speech Noise Reduction
In a speech recording system, we digitally record speech in a noisy environment at a sampling rate of
8,000 Hz. Assuming the recorded speech contains information within 1,800 Hz, we can design
a lowpass ﬁlter to remove the noise between 1,800 Hz and the Nyquist limit (the folding frequency of
4,000 Hz). The ﬁlter speciﬁcations are listed below:
Filter type: lowpass FIR ﬁlter
Passband frequency range: 0 1,800 Hz
Passband ripple: 0.02 dB
Stopband frequency range: 2,000 4,000 Hz
Stopband attenuation: 50 dB
According to these speciﬁcations, we can determine the following parameters for ﬁlter design:
Window type ¼ Hamming window
Number of ﬁlter taps ¼ 133
Lowpass cutoff frequency ¼ 1,900 Hz
0
0.05
0.1
0.15
0.2
0.25
1
0.5
0
0.5
1
x 10
4
Number of samples
Samp e va ue
0
500
1000
1500
2000
2500
3000
3500
4000
0
200
400
600
800
Frequency (Hz)
Amp tude X(f)  
FIGURE 7.24A
Noisy speech and its spectrum.
256
CHAPTER 7 Finite Impulse Response Filter Design

Figure 7.24A shows the plots of the recorded noisy speech and its spectrum. As we can see in the
noisy spectrum, the noise level is high and broadband. After applying the designed lowpass ﬁlter, we
plot the ﬁltered speech and its spectrum shown in Figure 7.24B, where the clean speech is clearly
identiﬁed, while the spectrum shows that the noise components above 2 kHz have been completely
removed.
7.4.3 Noise Reduction in Vibration Signals
In a data acquisition system for vibration analysis, we captured a vibration signal using an acceler-
ometer sensor in the noisy environment. The sampling rate is 1,000 Hz. The captured signal is
signiﬁcantly corrupted by a broadband noise. Vibration analysis requires the ﬁrst dominant frequency
component in the range 35 to 50 Hz to be retrieved. We list the ﬁlter speciﬁcations below:
Filter type ¼ bandpass FIR ﬁlter
Passband frequency range ¼ 35 50 Hz
Passband ripple ¼ 0.02 dB
Stopband frequency ranges ¼ 0 15 and 70 500 Hz
Stopband attenuation: 50 dB
0
0.05
0.1
0.15
0.2
0.25
1
0.5
0
0.5
1
x 10
4
Number of samples
Samp e va ue
0
500
1000
1500
2000
2500
3000
3500
4000
0
200
400
600
800
Frequency (Hz)
Amp tude Y(f)  
FIGURE 7.24B
Enhanced speech and its spectrum.
7.4 Applications: Noise Reduction and Two Band Digital Crossover
257

According to these speciﬁcations, we can determine the following parameters for the ﬁlter design:
Window type ¼ Hamming window
Number of ﬁlter taps ¼ 167
Low cutoff frequency ¼ 25 Hz
High cutoff frequency ¼ 65 Hz
Figure 7.25 displays the plots of the recorded noisy vibration signal and its spectrum. Figure 7.26
shows the retrieved vibration signal with noise reduction by a bandpass ﬁlter.
7.4.4 Two-Band Digital Crossover
In audio systems, there is often a situation where the application requires the entire audible range of
frequencies, but this is beyond the capability of any single speaker driver. So, we combine several
drivers, such as the speaker cone and horns, each covering a different frequency range, to reproduce the
full audio frequency range.
A typical two-band digital crossover can be designed as shown in Figure 7.27. There are two
speaker drivers. The woofer responds to low frequencies, and the tweeter responds to high frequencies.
The incoming digital audio signal is split into two bands by using a lowpass ﬁlter and a highpass ﬁlter
in parallel. We then amplify the separated audio signals and send them to their respective corre-
sponding speaker drivers. Hence, the objective is to design the lowpass ﬁlter and the highpass ﬁlter so
0
200
400
600
800
1000
1200
1400
1600
1800
2000
2
1
0
1
Number of samples
Samp e va ue
0
50
100
150
200
250
300
350
400
450
500
0
0.01
0.02
0.03
0.04
Frequency (Hz)
Amp tude X(f)  
FIGURE 7.25
Noisy vibration signal and its spectrum.
258
CHAPTER 7 Finite Impulse Response Filter Design

that their combined frequency response is ﬂat, while keeping transitions as sharp as possible to prevent
audio signal distortion in the transition frequency range. Although traditional crossover systems are
designed using active circuits (analog systems) or passive circuits, the digital crossover system
provides a cost-effective solution with programmability, ﬂexibility, and high quality.
A crossover system has the following speciﬁcations:
0
200
400
600
800
1000
1200
1400
1600
1800
2000
0.5
0
0.5
Number of samples
Samp e va ue
0
50
100
150
200
250
300
350
400
450
500
0
0.01
0.02
0.03
0.04
Frequency (Hz)
Amp tude Y(f)  
FIGURE 7.26
Retrieved vibration signal and its spectrum.
Digital
audio x(n)
Highpass filter
Lowpass filter
Gain_L
Gain_H
Tweeter:
The crossover passes
high frequencies
Woofer:
The crossover passes
low frequencies
yH(n)
yL(n)
FIGURE 7.27
Two-band digital crossover.
7.4 Applications: Noise Reduction and Two Band Digital Crossover
259

Sampling rate ¼ 44,100 Hz
Crossover frequency ¼ 1,000 Hz (cutoff frequency)
Transition band ¼ 600 Hz to 1,400 Hz
Lowpass ﬁlter ¼ passband frequency range from 0 to 600 Hz with a ripple of 0.02 dB and stopband
edge at 1,400 Hz with an attenuation of 50 dB
Highpass ﬁlter ¼ passband frequency range from 1.4 to 44.1 kHz with ripple of 0.02 dB and
stopband edge at 600 Hz with an attenuation of 50 dB
In the design of this crossover system, one possibility is to use an FIR ﬁlter, since it provides a linear
phase for the audio system. However, an inﬁnite impulse response (IIR) ﬁlter (which will be dis-
cussed in the next chapter) is a possible alternative. Based on the transition band of 800 Hz and the
passband ripple and stopband attenuation requirements, the Hamming window is chosen for both
lowpass and highpass ﬁlters. We can determine the number of ﬁlter taps as 183, each with a cutoff
frequency of 1,000 Hz.
The frequency responses for the designed lowpass and highpass ﬁlters are given in Figure 7.28A;
the lowpass ﬁlter, highpass ﬁlter, and combined responses appear in Figure 7.28B. As we can see, the
crossover frequency for both ﬁlters is at 1,000 Hz, and the combined frequency response is perfectly
ﬂat. The impulse responses (ﬁlter coefﬁcients) for the lowpass and highpass ﬁlters are plotted in
Figure 7.28C.
10
0
10
1
10
2
10
3
10
4
200
150
100
50
0
Frequency (Hz)
Magn tude response (dB)
10
0
10
1
10
2
10
3
10
4
200
150
100
50
0
Frequency (Hz)
Magn tude response (dB)
FIGURE 7.28A
Magnitude frequency responses for lowpass ﬁlter and highpass ﬁlter.
260
CHAPTER 7 Finite Impulse Response Filter Design

10
0
10
1
10
2
10
3
10
4
200
180
160
140
120
100
80
60
40
20
0
20
Frequency (Hz)
Magnitude response (dB)
Combined
LPF
HPF
FIGURE 7.28B
Magnitude frequency responses for both the lowpass and highpass ﬁlters, and the combined magnitude
frequency response for the digital audio crossover system.
0
20
40
60
80
100
120
140
160
180
200
0.02
0
0.02
0.04
0.06
n
mpulse response of LPF
0
20
40
60
80
100
120
140
160
180
200
0.5
0
0.5
1
n
mpulse response of HPF
FIGURE 7.28C
Impulse responses of both the FIR lowpass ﬁlter and the FIR highpass ﬁlter for the digital audio crossover system.
7.4 Applications: Noise Reduction and Two Band Digital Crossover
261

7.5 FREQUENCY SAMPLING DESIGN METHOD
In addition to methods of Fourier transform design and Fourier transform with windowing discussed
in the previous section, frequency sampling is another alternative. The key feature of frequency
sampling is that the ﬁlter coefﬁcients can be calculated based on the speciﬁed magnitudes of the
desired ﬁlter frequency response uniformly in the frequency domain. Hence, it has design ﬂexibility.
To begin development, we let hðnÞ, for n ¼ 0; 1; /; N  1, be the causal impulse response (FIR
ﬁlter coefﬁcients) that approximates the FIR ﬁlter, and we let HðkÞ, for k ¼ 0; 1; /; N  1, represent
the corresponding discrete Fourier transform (DFT) coefﬁcients. We obtain HðkÞ by sampling the
desired frequency ﬁlter response HðkÞ ¼ HðejUkÞ at equally spaced instants in frequency domain, as
shown in Figure 7.29.
Then, according to the deﬁnition of the inverse DFT (IDFT), we can calculate the FIR coefﬁcients:
hðnÞ ¼ 1
N
X
N
1
k ¼ 0
HðkÞW
kn
N
;
for
n ¼ 0; 1; /; N  1
(7.27)
where
WN ¼ e j2p
N ¼ cos
2p
N

 j sin
2p
N

We assume that the FIR ﬁlter has linear phase and the number of taps is N ¼ 2M þ 1. Equation (7.27)
can be signiﬁcantly simpliﬁed as
FIGURE 7.29
Desired ﬁlter frequency response and sampled frequency response.
262
CHAPTER 7 Finite Impulse Response Filter Design

hðnÞ ¼
1
2M þ 1
(
H0 þ 2
X
M
k ¼ 1
Hkcos
2pkðn  MÞ
2M þ 1
	
;
for
n ¼ 0; 1; /; 2M
(7.28)
where Hk, for k ¼ 0; 1; /; 2M, represents the magnitude values specifying the desired ﬁlter frequency
response sampled at Uk ¼
2pk
ð2M þ 1Þ. The derivation is detailed in Appendix E. The design procedure
is therefore simply summarized as follows:
1. Given the ﬁlter length of 2M þ 1, specify the magnitude frequency response for the normalized
frequency range from 0 to p:
Hk at Uk ¼
2pk
ð2M þ 1Þ
for
k ¼ 0; 1; /; M
(7.29)
2. Calculate the FIR ﬁlter coefﬁcients:
bn ¼ hðnÞ ¼
1
2M þ 1
(
H0 þ 2
X
M
k ¼ 1
Hkcos
2pkðn  MÞ
2M þ 1
)
for
n ¼ 0; 1; /; M
(7.30)
3. Use symmetry (linear phase requirement) to determine the rest of coefﬁcients:
hðnÞ ¼ hð2M  nÞ
for
n ¼ M þ 1; /; 2M
(7.31)
Example 7.12 illustrates the design procedure.
EXAMPLE 7.12
Design a linear phase lowpass FIR ﬁlter with 7 taps and a cutoff frequency of Uc
0:3p radians using the
frequency sampling method.
Solution:
Since N
2M þ 1
7 and M
3, the sampled frequencies are given by
Uk
2p
7 k radians; k
0; 1; 2; 3
Next we specify the magnitude values Hk at the speciﬁed frequencies as follows:
for U0
0 radians; H0
1:0
for U1
2
7p radians; H1
1:0
for U2
4
7p radians; H2
0:0
for U3
6
7p radians; H3
0:0
7.5 Frequency Sampling Design Method
263

Figure 7.30 shows the speciﬁcations.
Using Equation (7.30), we achieve
hðnÞ
1
7
(
1 þ 2
X
3
k
1
Hk cos ½2pkðn
3Þ=7
)
; n
0; 1; /; 3:
1
7 f1 þ 2 cos ½2pðn
3Þ=7g
Thus, computing the FIR ﬁlter coefﬁcients yields
hð0Þ
1
7 f1 þ 2 cos ð
6p=7Þg
0:11456
hð1Þ
1
7 f1 þ 2 cos ð
4p=7Þg
0:07928
hð2Þ
1
7 f1 þ 2 cos ð
2p=7Þg
0:32100
hð3Þ
1
7 f1 þ 2 cos ð
0  p=7Þg
0:42857
By symmetry, we obtain the rest of the coefﬁcients as follows:
hð4Þ
hð2Þ
0:32100
hð5Þ
hð1Þ
0:07928
hð6Þ
hð0Þ
0:11456
The following two examples are devoted to illustrating the FIR ﬁlter design using the frequency sampling method. A
MATLAB program, ﬁrfs(N, Hk), is provided in the “MATLAB Programs” section at the end of this chapter (see its
usage in Table 7.11) to implement the design in Equation (7.30) with the input parameters of N
2M þ 1
FIGURE 7.30
Sampled values of the frequency response in Example 7.12.
264
CHAPTER 7 Finite Impulse Response Filter Design

(number of taps) and a vector Hk containing the speciﬁed magnitude values Hk, k
0; 1; /; M. Finally, the
MATLAB function will return the calculated FIR ﬁlter coefﬁcients.
EXAMPLE 7.13
a. Design a linear phase lowpass FIR ﬁlter with 25 coefﬁcients using the frequency sampling method. Let the
cutoff frequency be 2,000 Hz and assume a sampling frequency of 8,000 Hz.
b. Plot the frequency responses.
c. List the FIR ﬁlter coefﬁcients.
Solution:
a. The normalized cutoff frequency for the lowpass ﬁlter is Uc
uT
2p2000=8000
0:5p radi
ans, N
2M þ 1
25, and the speciﬁed values of the sampled frequency response are chosen to be
Hk
½1 1 1 1 1 1 1 0 0 0 0 0 0
MATLAB Program 7.8 produces the design results.
Program 7.8. MATLAB program for Example 7.13.
%Figure 7.31(Example 7.13)
% MATLAB program to create Figure 7.31
fs 8000;
% Sampling frequency
H1 [1 1 1 1 1 1 1 0 0 0 0 0 0];
% Magnitude specifications
B1 firfs(25,H1);
% Design filter
[h1,f] freqz(B1,1,512,fs);
% Calculate magnitude frequency response
H2 [1 1 1 1 1 1 1 0.5 0 0 0 0 0]; % Magnitude specifications
B2 firfs(25,H2);
% Frequency response
[h2,f] freqz(B2,1,512,fs);
% Calculate magnitude frequency response
p1 180*unwrap(angle(h1))/pi;
p2 180*unwrap(angle(h2))/pi
subplot(2,1,1); plot(f,20*log10(abs(h1)),’ .’,f,20*log10(abs(h2)));grid
axis([0 fs/2
80 10]);
xlabel(’Frequency (Hz)’); ylabel(’Magnitude Response (dB)’);
subplot(2,1,2); plot(f,p1,’ .’,f,p2);grid
xlabel(’Frequency (Hz)’); ylabel(’Phase (degrees)’);
Table 7.11 Illustrative Usage for MATLAB Function ﬁrfs(N, Hk)
function B ﬁrfs(N,Hk)
% B ﬁrls(N,Hk)
% FIR ﬁlter design using the frequency sampling method.
% Input parameters:
% N: the number of ﬁlter coefﬁcients.
%
note: N must be odd number.
% Hk: sampled frequency response for k 0,1,2,.,M (N-1)/2.
% Output:
% B: FIR ﬁlter coefﬁcients.
7.5 Frequency Sampling Design Method
265

0
500
1000
1500
2000
2500
3000
3500
4000
80
60
40
20
0
Frequency (Hz)
Magn tude response (dB)
0
500
1000
1500
2000
2500
3000
3500
4000
1500
1000
500
0
Frequency (Hz)
Phase (degrees)
FIGURE 7.31
Frequency responses using the frequency sampling method in Example 7.13.
Table 7.12 FIR Filter Coefﬁcients in Example 7.13
(frequency sampling method)
B1: FIR Filter Coefﬁcients
B2: FIR Filter
Coefﬁcients
b0
b24
0.027436
b0
b24
0.001939
b1
b23
0.031376
b1
b23
0.003676
b2
b22
0.024721
b2
b22
0.012361
b3
b21
0.037326
b3
b21
0.002359
b4
b20
0.022823
b4
b20
0.025335
b5
b19
0.046973
b5
b19
0.008229
b6
b18
0.021511
b6
b18
0.038542
b7
b17
0.064721
b7
b17
0.032361
b8
b16
0.020649
b8
b16
0.049808
b9
b15
0.106734
b9
b15
0.085301
b10
b14
0.020159
b10
b14
0.057350
b11
b13
0.318519
b11
b13
0.311024
b12
0.520000
b12
0.560000
266
CHAPTER 7 Finite Impulse Response Filter Design

b. The magnitude frequency response plotted using the dash dotted line is displayed in Figure 7.31, where it
is observed that oscillations occur in the passband and stopband of the designed FIR ﬁlter. This is due to the
abrupt change of the speciﬁcation in the transition band (between the passband and the stopband). To
reduce this ripple effect, the modiﬁed speciﬁcation with a smooth transition band, Hk, k
0; 1; /; 13, is
used:
Hk
½1 1 1 1 1 1 1 0:5 0 0 0 0 0
The improved magnitude frequency response is shown in Figure 7.31 via the solid line.
c. The calculated FIR coefﬁcients for both ﬁlters are listed in Table 7.12.
EXAMPLE 7.14
a. Design a linear phase bandpass FIR ﬁlter with 25 coefﬁcients using the frequency sampling method. Let the
lower and upper cutoff frequencies be 1,000 Hz and 3,000 Hz, respectively, and assume a sampling frequency
of 8,000 Hz.
b. List the FIR ﬁlter coefﬁcients.
c. Plot the frequency responses.
Solution:
a. First we calculate the normalized lower and upper cutoff frequencies for the bandpass ﬁlter; that is, UL
2p 
1; 000=8; 000
0:25p radians and UH
2p  3; 000=8; 000
0:75p radians, respectively. The sampled
values of the bandpass frequency response are speciﬁed by the following vector:
Hk
½0 0 0 0 1 1 1 1 1 0 0 0 0
For comparison, a second speciﬁcation of Hk with a smooth transition band is used:
Hk
½0 0 0 0:5 1 1 1 1 1 0:5 0 0 0
b. The MATLAB list is shown in Program 7.9. The generated FIR coefﬁcients are listed in Table 7.13.
Program 7.9 MATLAB program for Example 7.14.
% Figure 7.32 (Example 7.14)
% MATLAB program to create Figure 7.32
%
fs 8000;
H1 [0 0 0 0 1 1 1 1 1 0 0 0 0];
% Magnitude specifications
B1 firfs(25,H1);
% Design filter
[h1,w] freqz(B1,1,512);
% Calculate magnitude frequency response
H2 [0 0 0 0.5 1 1 1 1 1 0.5 0 0 0]; % Magnitude spectrum
B2 firfs(25,H2);
% Design filter
[h2,w] freqz(B2,1,512);
% Calculate magnitude frequency response
p1 180*unwrap(angle(h1)’)/pi;
p2 180*unwrap(angle(h2)’)/pi
subplot(2,1,1); plot(f,20*log10(abs(h1)),’ .’,f,20*log10(abs(h2)));grid
axis([0 fs/2
100 10]);
xlabel(’Frequency (Hz)’); ylabel(’Magnitude Response (dB)’);
subplot(2,1,2); plot(f,p1,’ .’,f,p2);grid
xlabel(’Frequency (Hz)’); ylabel(’Phase (degrees)’);
7.5 Frequency Sampling Design Method
267

Table 7.13 FIR Filter Coefﬁcients in Example 7.14 (frequency sampling method)
B1: FIR Filter Coefﬁcients
B2: FIR Filter Coefﬁcients
b0
b24
0.055573
b0
b24
0.001351
b1
b23
0.030514
b1
b23
0.008802
b2
b22
0.000000
b2
b22
0.020000
b3
b21
0.027846
b3
b21
0.009718
b4
b20
0.078966
b4
b20
0.011064
b5
b19
0.042044
b5
b19
0.023792
b6
b18
0.063868
b6
b18
0.077806
b7
b17
0.000000
b7
b17
0.020000
b8
b16
0.094541
b8
b16
0.017665
b9
b15
0.038728
b9
b15
0.029173
b10
b14
0.303529
b10
b14
0.308513
b11
b13
0.023558
b11
b13
0.027220
b12
0.400000
b12
0.480000
0
500
1000
1500
2000
2500
3000
3500
4000
100
50
0
Frequency (Hz)
Magn tude response (dB)
0
500
1000
1500
2000
2500
3000
3500
4000
1500
1000
500
0
500
Frequency (Hz)
Phase (degrees)
FIGURE 7.32
Frequency responses using the frequency sampling method in Example 7.14.
268
CHAPTER 7 Finite Impulse Response Filter Design

c. Similar to the preceding example, Figure 7.32 shows the frequency responses. Focusing on the magnitude
frequency responses depicted in Figure 7.32, the dash dotted line indicates the magnitude frequency
response obtained without specifying the smooth transition band, while the solid line indicates the magnitude
frequency response achieved with the speciﬁcation of the smooth transition band, resulting in the reduced
ripple effect.
Observations can be made from examining Examples 7.13 and 7.14. First, the oscillations (Gibbs
behavior) in the passband and stopband can be reduced at the expense of increasing the width of the
main lobe. Second, we can modify the speciﬁcation of the magnitude frequency response with
a smooth transition band to reduce the oscillations and thus improve the performance of the FIR ﬁlter.
Third, the magnitude values Hk, k ¼ 0; 1; /; M in general can be arbitrarily speciﬁed. This indicates
that the frequency sampling method is more ﬂexible and can be used to design the FIR ﬁlter with an
arbitrary speciﬁcation of the magnitude frequency response.
7.6 OPTIMAL DESIGN METHOD
This section introduces the Parks McClellan algorithm, which is one of the most popular optimal
design method used in the industry due to its efﬁciency and ﬂexibility. The FIR ﬁlter design using the
Parks McClellan algorithm is developed based on the idea of minimizing the maximum approxi-
mation error between a Chebyshev polynomial and the desired ﬁlter magnitude frequency response.
The details of this design development are beyond the scope of this text and can be found in Ambardar
(1999) and Porat (1997). We will outline the design criteria and notation and then focus on the design
procedure.
Given an ideal magnitude response HdðejuTÞ, the approximation error EðuÞ is deﬁned as
EðuÞ ¼ WðuÞ½HðejuTÞ  HdðejuTÞ
(7.32)
where HðejuTÞ is the frequency response of the linear phase FIR ﬁlter to be designed, and WðuÞ is the
weight function for emphasizing certain frequency bands over others during the optimization process.
The goal is to minimize the error over the set of FIR coefﬁcients:
minðmaxjEðuÞjÞ
(7.33)
With the help of the Remez exchange algorithm, which is also beyond the scope of this book, we can
obtain the best FIR ﬁlter whose magnitude response has an equiripple approximation to the ideal
magnitude response. The achieved ﬁlters are optimal in the sense that the algorithms minimize the
maximum error between the desired frequency response and actual frequency response. These are
often called minimax ﬁlters.
Next, we establish the notation that will be used in the design procedure. Figure 7.33 shows the
characteristics of the FIR ﬁlter designed by the Parks McClellan and Remez exchange algorithms. As
illustrated in the top graph of Figure 7.33, the passband frequency response and stopband frequency
response have equiripples. dp is used to specify the magnitude ripple in the passband, while ds
7.6 Optimal Design Method
269

speciﬁes the stopband magnitude attenuation. In terms of dB value speciﬁcation, we have
dpdB ¼ 20  log10ð1 þ dpÞ and dsdB ¼ 20  log10ds.
The middle graph in Figure 7.33 describes the error between the ideal frequency response and the
actual frequency response. In general, the error magnitudes in the passband and stopband are
different. This makes optimization unbalanced, since the optimization process involves an entire
band. When the error magnitude in a band dominates the other(s), the optimization process may
deemphasize the contribution due to a small magnitude error. To make the error magnitudes
balanced, a weight function can be introduced. The idea is to weight a band with a bigger magnitude
error with a small weight factor and to weight a band with a smaller magnitude error with a big
weight factor. We use a weight factor Wp for weighting the passband error and Ws for weighting the
stopband error. The bottom graph in Figure 7.33 shows the weighted error, and clearly, the error
magnitudes on both bands are at the same level. Selection of the weighting factors is further
illustrated in the following design procedure.
Optimal FIR Filter Design Procedure for the Parks McClellan Algorithm
1. Specify the band edge frequencies such as passband and stopband frequencies, passband ripple,
stopband attenuation, ﬁlter order, and sampling frequency of the DSP system.
2. Normalize band edge frequencies to the Nyquist limit (folding frequency ¼ fs=2) and specify the
ideal magnitudes.
FIGURE 7.33
(Top) Magnitude frequency response of an ideal lowpass ﬁlter and a typical lowpass ﬁlter designed using the
Parks McClellan algorithm. (Middle) Error between the ideal and practical responses. (Bottom) Weighted error
between the ideal and practical responses.
270
CHAPTER 7 Finite Impulse Response Filter Design

3. Calculate the absolute values of the passband ripple and stopband attenuation if they are given in
terms if dB values:
dp ¼ 10
dpdB
20

 1
(7.34)
ds ¼ 10
dsdB
20

(7.35)
Then calculate the ratio and put it into fraction form:
dp
ds
¼ fraction form ¼
numerator
denominator ¼ Ws
Wp
(7.36)
Next, set the error weight factors for passband and stopband, respectively:
Ws ¼ numerator
Wp ¼ denominator
(7.37)
4. Apply the Remez algorithm to calculate ﬁlter coefﬁcients.
5. If the speciﬁcations are not met, then increase the ﬁlter order and repeat steps 1 to 4.
The following two examples are given to illustrate the design procedure.
EXAMPLE 7.15
Design a lowpass ﬁlter with the following speciﬁcations:
DSP system sampling rate
8,000 Hz
Passband
0e800 Hz
Stopband
1,000e4,000 Hz
Passband ripple
1 dB
Stopband attenuation
40 dB
Filter order
53
Solution:
From the speciﬁcations, we have two bands: a lowpass band and a stopband. We perform normalization and specify
ideal magnitudes as follows:
Folding frequency:
fs=2
8; 000=2
4; 000 Hz
For 0 Hz:
0=4; 000
0
magnitude: 1
For 800 Hz:
800=4; 000
0:2
magnitude: 1
For 1,000 Hz:
1; 000=4; 000
0:25
magnitude: 0
For 4,000 Hz:
4; 000=4; 000
1
magnitude: 0
Next, let us determine the weights:
7.6 Optimal Design Method
271

dp
10
 1
20

1
0:1220
ds
10
 40
20

0:01
Then, applying Equation (7.36) gives
dp
ds
12:2 z 12
1
Ws
Wp
Hence, we have
Ws
12 and Wp
1
We apply the remez() routine provided by MATLAB in Program 7.10. The ﬁlter coefﬁcients are listed in Table 7.14.
Figure 7.34 shows the frequency responses.
Program 7.10. MATLAB program for Example 7.15.
%Figure 7.34 (Example 7.15)
% MATLAB program to create Figure 7.34
%
fs 8000;
f [ 0 0.2 0.25 1]; % Edge frequencies
m [ 1 1 0 0] ; % Ideal magnitudes
w [ 1 12 ]; % Error weight factors
b remez(53,f,m,w); % (53þ1)Parks McClellan algorithm and Remez exchange
format long
freqz(b,1,512,fs) % Plot the frequency response
axis([0 fs/2
80 10]);
Clearly, the stopband attenuation is satisﬁed. We plot the details for the ﬁlter passband in Figure 7.35.
Table 7.14 FIR Filter Coefﬁcients in Example 7.15
B: FIR Filter Coefﬁcients (optimal design method)
b0
b53
0.006075
b1
b52
0.00197
b2
b51
0.001277
b3
b50
0.006937
b4
b49
0.013488
b5
b48
0.018457
b6
b47
0.019347
b7
b46
0.014812
b8
b45
0.005568
b9
b44
0.005438
b10
b43
0.013893
b11
b42
0.015887
b12
b41
0.009723
b13
b40
0.002789
b14
b39
0.016564
b15
b38
0.024947
b16
b37
0.022523
b17
b36
0.007886
b18
b35
0.014825
b19
b34
0.036522
b20
b33
0.045964
b21
b32
0.033866
b22
b31
0.003120
b23
b30
0.060244
b24
b29
0.125252
b25
b28
0.181826
b26
b27
0.214670
272
CHAPTER 7 Finite Impulse Response Filter Design

0
500
1000
1500
2000
2500
3000
3500
4000
1500
1000
500
0
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
2
1
0
1
2
Frequency (Hertz)
Magnitude response (dB)
FIGURE 7.35
Frequency response details for passband in Example 7.15.
0
500
1000
1500
2000
2500
3000
3500
4000
1500
1000
500
0
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
80
60
40
20
0
Frequency (Hertz)
Magnitude response (dB)
FIGURE 7.34
Frequency and phase responses for Example 7.15.
7.6 Optimal Design Method
273

As shown in Figure 7.35, the ripples in the passband are between
1 and 1 dB. Hence, all the speciﬁcations
are met. Note that if the speciﬁcation is not satisﬁed, we will increase the order until the stopband attenuation and
passband ripple are met.
The next example illustrates bandpass ﬁlter design.
EXAMPLE 7.16
Design a bandpass ﬁlter with the following speciﬁcations:
DSP system sampling rate
8,000 Hz
Passband
1,000e1,600 Hz
Stopband
0e600 Hz and 2,000e4,000 Hz
Passband ripple
1 dB
Stopband attenuation
30 dB
Filter order
25
Solution:
From the speciﬁcations, we have three bands: a passband, a lower stopband, and an upper stopband. We perform
normalization and specify ideal magnitudes as follows:
Folding frequency:
fs=2
8;000=2
4; 000 Hz
For 0 Hz:
0=4; 000
0
magnitude: 0
For 600 Hz:
600=4; 000
0:15
magnitude: 0
For 1,000 Hz:
1; 000=4; 000
0:25
magnitude: 1
For 1,600 Hz:
1; 600=4; 000
0:4
magnitude: 1
For 2,000 Hz:
2; 000=4; 000
0:5
magnitude: 0
For 4,000 Hz:
4; 000=4; 000
1
magnitude: 0
Next, let us determine the weights:
dp
10

 1
20

1
0:1220
ds
10

30
20

0:0316
Then applying Equation (7.36), we get
dp
ds
3:86 z 39
10
Ws
Wp
Hence, we have
Ws
39 and Wp
10
We apply the Remez() routine provided by MATLAB and check performance in Program 7.11. Table 7.15 lists the
ﬁlter coefﬁcients. The frequency responses are depicted in Figure 7.36.
Program 7.11. MATLAB program for Example 7.16.
%Figure 7.36(Example 7.16)
% MATLAB program to create Figure 7.36
274
CHAPTER 7 Finite Impulse Response Filter Design

%
fs 8000;
f [ 0 0.15 0.25 0.4 0.5 1];
% Edge frequencies
m [ 0 0 1 1 0 0];
% Ideal magnitudes
w [ 39 10 39 ];
% Error weight factors
format long
0
500
1000
1500
2000
2500
3000
3500
4000
600
400
200
0
200
400
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
80
60
40
20
0
Frequency (Hertz)
Magn tude response (dB)
FIGURE 7.36
Frequency and phase responses for Example 7.16.
Table 7.15 FIR Filter Coefﬁcients in Example 7.16
B: FIR Filter Coefﬁcients (optimal design method)
b0
b25
0.022715
b1
b24
0.012753
b2
b23
0.005310
b3
b22
0.009627
b4
b21
0.004246
b5
b20
0.006211
b6
b19
0.057515
b7
b18
0.076593
b8
b17
0.015655
b9
b16
0.156828
b10
b15
0.170369
b11
b14
0.009447
b12
b13
0.211453
7.6 Optimal Design Method
275

b remez(25,f,m,w) % (25þ1) taps Parks McClellan algorithm and Remez exchange
freqz(b,1,512,fs); % Plot the frequency response
axis([0 fs/2
80 10])
Clearly, the stopband attenuation is satisﬁed. We also check the details for the passband as shown in
Figure 7.37.
As shown in Figure 7.37, the ripples in the passband between 1,000 Hz and 1,600 Hz are between
1 and
1 dB. Hence, all speciﬁcations are satisﬁed.
EXAMPLE 7.17
Now we show how the Remez exchange algorithm in Equation (7.32) is processed using a linear phase 3 tap FIR
ﬁlter represented as follows:
HðzÞ
b0 þ b1z1 þ b0z2
The ideal frequency response speciﬁcations are shown in Figure 7.38(a), where the ﬁlter gain increases linearly
from a gain of 0.5 at U
0 radians to a gain of 1 at U
p=4 radians. The band between U
p=4 radians and
U
p=2 radians is a transition band. Finally, the ﬁlter gain decreases linearly from the gain 0.75 at U
p=2
radians to the gain of 0 at U
p radians.
0
500
1000
1500
2000
2500
3000
3500
4000
600
400
200
0
200
400
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
2
1
0
1
2
Frequency (Hertz)
Magn tude response (dB)
FIGURE 7.37
Frequency response details for passband in Example 7.16.
276
CHAPTER 7 Finite Impulse Response Filter Design

For simplicity, we set all the weight factors to 1, that is, WðUÞ
1. Equation (7.32) is simpliﬁed to
EðUÞ
HðejUÞ
HdðejUÞ
Substituting z
ejU into the transfer function HðzÞ gives
HðejUÞ
b0 þ b1ejU þ b0ej2U
After simpliﬁcation using Euler’s identity ejU þ ejU
2 cos U, the ﬁlter frequency response is given by
HðejUÞ
ejUðb1 þ 2b0 cos UÞ
Disregarding the linear phase shift term ejU for the time being, we have a Chebyshev real magnitude function
(there are a few other types as well):
HðejUÞ
b1 þ 2b0 cos U
The alternation theorem (Ambardar, 1999; Porat, 1997) must be used. The alternation theorem states that given
a Chebyshev polynomial HðejUÞ to approximate the ideal magnitude response HdðejUÞ, we can ﬁnd at least M þ 2
(where M
1 for our case) frequencies U0,U1, .UMþ1, called the extremal frequencies, so that signs of the error
at the extremal frequencies alternate and the absolute error value at each extremal point reaches the maximum
absolute error, that is,
0
1
2
3
4
0
0.5
1
Normalized frequency
 Se ected po nts on Hd
0
1
2
3
4
0.4
0.2
0
0.2
0.4
Normalized frequency
 Emax at extrema  po nts
0
1
2
3
4
0
0.2
0.4
0.6
0.8
1
Normalized frequency
 Se ected po nts on Hd
0
1
2
3
4
0.4
0.2
0
0.2
0.4
Normalized frequency
 Emax at extrema  po nts
will be selected
as an extremal
 point
equiripples
(a) 
(b)
(c)
(d)
FIGURE 7.38
Determining the 3-tap FIR ﬁlter coefﬁcients using the Remez algorithm in Example 7.17.
7.6 Optimal Design Method
277

EðUkÞ
EðUkþ1Þ
for
U0; U1; . UMþ1
and
jEðUkÞj
Emax
But the alternation theorem does not tell us how to execute the algorithm. The Remez exchange algorithm actually
is employed to solve this problem. The equations and steps (Ambardar, 1999; Porat, 1997) are brieﬂy summarized
for our illustrative example:
1. Given an order of N
2Mþ1, choose the initial extremal frequencies:
U0; U1; .; UMþ1 ðcan be uniformly distributed firstÞ
2. Solve the following equation to satisfy the alternate theorem:
ð 1ÞkE
WðUkÞðHdðejUk Þ
HðejUk ÞÞ
for
U0; U1; .; UMþ1
Note that since HðejUÞ
b1 þ 2b0 cos U, for example, the solution will include solving for three unknowns:
b0,b1, and Emax.
3. Determine the extremal points including band edges (can be more than M þ 2 points), and retain M þ 2
extremal points with the largest error values Emax.
4. Output the coefﬁcients, if the extremal frequencies are not changed; otherwise, go to step 2 using the new set
of extremal frequencies.
Now let us apply the Remez exchange algorithm.
First Iteration
1. We use uniformly distributed extremal points U0
0, U1
p=2, U2
p whose ideal magnitudes are
marked by the symbol “o” in Figure 7.38(a).
2. The alternation theorem requires
ð 1ÞkE
HdðejUÞ
ðb1 þ 2b0 cos UÞ.
Applying extremal points yields the following three simultaneous equations with three unknowns: b0,b1,
and E:
E
0:5
b1
2b0
E
0:75
b1
E
0
b1 þ 2b0
8
>
>
<
>
>
:
We solve these three equations to get
b0
0:125; b1
0:5; E
0:25; HðejUÞ
0:5 þ 0:25 cos U
3. We then determine the extremal points, including at the band edge, with their error values from Figure 7.38(b)
using the following error function:
EðUÞ
HdðejUÞ
0:5
0:25 cos U
These extremal points are marked by symbol “o” and their error values are listed in Table 7.16.
4. Since the band edge U
p=4 has an larger error than the others, it must be chosen as the extremal frequency.
After deleting the extremal point at U
p=2, a new set of extremal points are found according the largest error
values as
U0
0
U1
p=4
278
CHAPTER 7 Finite Impulse Response Filter Design

U2
p
The ideal magnitudes at these three extremal points are given in Figure 7.38(c), that is, 0.5, 1, 0. Now let us
examine the second iteration.
Second Iteration
Applying the alternation theorem at the new set of extremal points, we have
8
>
<
>
:
E
0:5
b1
2b0
E
1
b1
1:4142b0
E
0
b1 þ 2b0
Solving these three simultaneous equations leads to
b0
0:125; b1
0:537; E
0:287; and HðejUÞ
0:537 þ 0:25 cos U
The error values at the extremal points and band edge are listed in Table 7.17 and shown in Figure 7.38(d), where
the determined extremal points are marked by the symbol “o”.
Since the extremal points have the same maximum error value of 0.287, they are U0
0,U1
p=4, and
U2
p, which is unchanged. We stop the iteration and output the ﬁlter transfer function as
HðzÞ
0:125 þ 0:537z1 þ 0:125z2
As shown in Figure 7.37(d), we obtain the equiripples of error at the extemal points U0
0, U1
p=4, and
U2
p; their signs are alternating, and the maximum absolute error of 0.287 is obtained at each point. It takes
two iterations to determine the coefﬁcients for this simpliﬁed example.
As we mentioned, the Parks McClellan algorithm is one of the most popular ﬁlter design methods
in industry due to its ﬂexibility and performance. However, there are two disadvantages. The ﬁlter
length has to be estimated by the empirical method. Once the frequency edges, magnitudes, and
weighting factors are speciﬁed, the Remez exchange algorithm cannot control the actual ripple
obtained from the design. We may often need to try a longer length of ﬁlter or different weight factors
to remedy situations where the ripple is unacceptable.
Table 7.16 Extremal Points and Band Edges with Their Error Values for the
First Iteration.
U
0
p=4
p=2
p
Emax
0.25
0.323
0.25
0.25
Table 7.17 Error Values at Extremal Frequencies and Band Edge
U
0
p=4
p=2
p
Emax
0.287
0.287
0.213
0.287
7.6 Optimal Design Method
279

7.7 REALIZATION STRUCTURES OF FINITE IMPULSE RESPONSE FILTERS
Using the direct-form I realization (discussed in Chapter 6), we will obtain a special realization form,
called the transversal form. Using the linear phase property will produce a linear phase realization
structure.
7.7.1 Transversal Form
Given the transfer function of the FIR ﬁlter in Equation (7.38),
HðzÞ ¼ b0 þ b1z 1 þ / þ bKz K
(7.38)
we obtain the difference equation as
yðnÞ ¼ b0xðnÞ þ b1xðn  1Þ þ b2xðn  2Þ þ / þ bKxðn  KÞ
Realization of such a transfer function is the transversal form, displayed in Figure 7.39.
EXAMPLE 7.18
Given an FIR ﬁlter transfer function
HðzÞ
1 þ 1:2z1 þ 0:36z2
perform the FIR ﬁlter realization.
Solution:
From the transfer function, we can identify that
b0
1; b1
1:2; and b2
0:36
Using Figure 7.39, we ﬁnd the FIR realization to be as displayed in Figure 7.40.
We determine the DSP equation for implementation to be
yðnÞ
xðnÞ þ 1:2xðn
1Þ þ 0:36xðn
2Þ
Program 7.12 shows the MATLAB implementation.
1
1
1
y(n)
b0
b1
bK
+
x n
( )
x n
(
)1
x n
K
(
)
+
FIGURE 7.39
FIR ﬁlter realization (transversal form).
280
CHAPTER 7 Finite Impulse Response Filter Design

Program 7.12. MATLAB program for Example 7.18.
% Sample MATLAB code
sample
1:1:10;
% Input test array
x [ 0 0 0];
% Input buffer [x(n) x(n 1) .]
y [0];
%output buffer [y(n) y(n 1) . ]
b [1.0 1.2 0.36];
% FIR filter coefficients [b0 b1 .]
KK length(b);
for n 1:1:length(sample)
% Loop processing
for k KK: 1:2
% Shift input by one sample
x(k) x(k 1);
end
x(1) sample(n);
% Get new sample
y(1) 0;
% Perform FIR filtering
for k 1:1:KK
y(1) y(1)þb(k)*x(k);
end
out(n) y(1); %send filtered sample to the output array
end
out
7.7.2 Linear Phase Form
We illustrate the linear phase structure using the following simple example.
Consider the following transfer function with 5 taps obtained from the design:
HðzÞ ¼ b0 þ b1z 1 þ b2z 2 þ b1z 3 þ b0z 4
(7.39)
We can see that the coefﬁcients are symmetrical and the difference equation is
yðnÞ ¼ b0xðnÞ þ b1xðn  1Þ þ b2xðn  2Þ þ b1xðn  3Þ þ b0xðn  4Þ
This DSP equation can further be combined to yield
yðnÞ ¼ b0ðxðnÞ þ xðn  4ÞÞ þ b1ðxðn  1Þ þ xðn  3ÞÞ þ b2xðn  2Þ
Then we obtain the realization structure in a linear phase form as shown in Figure 7.41.
1
1
y(n)
1
12.
0 36
.
+
x n
( )
x n
(
)1
x n
(
)
2
+
FIGURE 7.40
FIR ﬁlter realization for Example 7.18.
7.7 Realization Structures of Finite Impulse Response Filters
281

1
1
1
y(n)
b0
b1
+
x n
( )
x n
(
)1
x n
(
)
4
+
1
x n
(
)
2
x n
(
)3
b2
+
+
FIGURE 7.41
Linear phase FIR ﬁlter realization.
7.8 COEFFICIENT ACCURACY EFFECTS ON FINITE IMPULSE RESPONSE
FILTERS
In practical applications, the ﬁlter coefﬁcients achieved through high-level software such as MATLAB
must be quantized using ﬁnite word length. This may have two effects. First, the locations of zeros are
changed; second, due to the location change of zeros, the ﬁlter frequency response will change
correspondingly. In practice, there are two types of digital signal (DS) processors: ﬁxed-point
processors and ﬂoating-point processors. The ﬁxed-point DS processor uses integer arithmetic, and the
ﬂoating-point processor employs ﬂoating-point arithmetic. Such effects of ﬁlter coefﬁcient quanti-
zation will be covered in Chapter 9.
In this section, we will study the effects of FIR ﬁlter coefﬁcient quantization in general, since
during practical ﬁlter realization, obtaining ﬁlter coefﬁcients with inﬁnite precision is impossible.
Filter coefﬁcients are usually truncated or rounded off for the application. Assume that the FIR ﬁlter
transfer function with inﬁnite precision is given by
HðzÞ ¼
X
K
n ¼ 0
bnz n ¼ b0 þ b1z 1 þ / þ b2Mz K
(7.40)
where each ﬁlter coefﬁcient bn has inﬁnite precision. Now let the quantized FIR ﬁlter transfer
function be
HqðzÞ ¼
X
K
n ¼ 0
bq
nz n ¼ bq
0 þ bq
1z 1 þ / þ bq
Kz K
(7.41)
where each ﬁlter coefﬁcient bq
n is quantized (rounded off) using the speciﬁed number of bits. Then the
error of the magnitude frequency response can be bounded as
HðejUÞ  HqðejUÞ
 ¼ P
K
n ¼ 0

bn  bq
nÞejU
< P
K
n ¼ 0
bn  bq
n

ðK þ 1Þ$2 B
(7.42)
where B is the number of bits used to encode each magnitude of the ﬁlter coefﬁcient.
282
CHAPTER 7 Finite Impulse Response Filter Design

EXAMPLE 7.19
In Example 7.7, a lowpass FIR ﬁlter with 25 taps using a Hamming window was designed, and FIR ﬁlter coefﬁ
cients are listed below for comparison in Table 7.18. One sign bit is used, and 7 bits are used for fractional parts,
since all FIR ﬁlter coefﬁcients are less than 1. We will multiply each ﬁlter coefﬁcient by a scale factor of 27 and
round off each scaled magnitude to an integer whose magnitude can be encoded using 7 bits. When the coefﬁcient
integer is scaled back, the coefﬁcient with ﬁnite precision (quantized ﬁlter coefﬁcient) using 8 bits, including the
sign bit, will be achieved.
To
understand
quantization,
we
take
a
look
at
one
of
the
inﬁnite
precision
coefﬁcients
Bhamð3Þ
0:00759455135346, for illustration. The quantization using 7 magnitude bits is
0:00759455135346  27
0:9721
1
Then the quantized ﬁlter coefﬁcient is obtained as
BhamQð3Þ
1=27
0:0078125
Since the poles for both FIR ﬁlters always reside at the origin, we need to examine only their zeros. The z plane zero
plots for both FIR ﬁlters are shown in Figure 7.42A, where the circles are zeros from the FIR ﬁlter with inﬁnite
precision, while the crosses are zeros from the FIR ﬁlter with the quantized coefﬁcients.
Most importantly, Figure 7.42B shows the difference of the frequency responses for both ﬁlters obtained using
Program 7.13. In the ﬁgure, the solid line represents the frequency response with inﬁnite ﬁlter coefﬁcient
precision, and the dot dashed line indicates the frequency response with ﬁnite ﬁlter coefﬁcients. It is observed that
the stopband performance is degraded due to the ﬁlter coefﬁcient quantization. The degradation in the passband is
not severe.
TABLE 7.18 FIR Filter Coefﬁcients and Their Quantized Filter Coefﬁcients in Example
7.19 (Hamming window)
Bham: FIR Filter Coefﬁcients
BhamQ: FIR Filter Coefﬁcients
b0
b24
0.00000000000000
b0
b24
0.0000000
b1
b23
0.00276854711076
b1
b23
0.0000000
b2
b22
0.00000000000000
b2
b22
0.0000000
b3
b21
0.00759455135346
b3
b21
0.0078125
b4
b20
0.00000000000000
b4
b20
0.0000000
b5
b19
0.01914148493949
b5
b19
0.0156250
b6
b18
0.00000000000000
b6
b18
0.0000000
b7
b17
0.04195685650042
b7
b17
0.0390625
b8
b16
0.00000000000000
b8
b16
0.0000000
b9
b15
0.09180790496577
b9
b15
0.0859375
b10
b14
0.00000000000000
b10
b14
0.0000000
b11
b13
0.31332065886015
b11
b13
0.3125000
b12
0.50000000000000
b12
0.5000000
7.8 Coefﬁcient Accuracy Effects on Finite Impulse Response Filters
283

Program 7.13. MATLAB program for Example 7.19.
fs 8000;
[hham,f] freqz(Bham,1,512,fs);
[hhamQ,f] freqz(BhamQ,1,512,fs);
p 180*unwrap(angle(hham))/pi;
pQ 180*unwrap(angle(hhamQ))/pi
subplot(2,1,1); plot(f,20*log10(abs(hham)),f,20*log10(abs(hhamQ)),’:’);grid
axis([0 4000
100 10]);
xlabel(’Frequency (Hz)’); ylabel(’Magnitude Response (dB)’);
subplot(2,1,2); plot(f,p,f,pQ,’:’);grid
Using Equation (7.42), the error of the magnitude frequency response due to quantization is bounded by
HðejUÞ
HqðejUÞ

D
25=256
0:0977
This can be easily veriﬁed at the stopband of the magnitude frequency response for the worst condition as follows:
HðejUÞ
HqðejUÞ

10100=20
1030=20
0:032 < 0:0977
1
0.5
0
0.5
1
1.5
2
1.5
1
0.5
0
0.5
1
1.5
FIGURE 7.42A
The z-plane zero plots for both FIR ﬁlters. The circles are zeros for inﬁnite precision; the crosses are zeros
for round-off coefﬁcients.
284
CHAPTER 7 Finite Impulse Response Filter Design

In practical situations, a similar procedure can be used to analyze the effects of ﬁlter coefﬁcient
quantization to make sure that the designed ﬁlter meets the requirements.
7.9 SUMMARY OF FIR DESIGN PROCEDURES AND SELECTION OF FIR
FILTER DESIGN METHODS IN PRACTICE
In this section, we ﬁrst summarize the design procedures of the window design, frequency sampling
design, and optimal design methods, and then discuss the selection of the particular ﬁlter for typical
applications.
The window method (Fourier transform design using windows):
1. Given the ﬁlter frequency speciﬁcations, determine the ﬁlter order (odd number used in this book)
and the cutoff frequency/frequencies using Table 7.7 and Equation (7.26).
2. Compute the impulse sequence hðnÞ via the Fourier transform method using the appropriate
equations (in Table 7.1).
3. Multiply the generated FIR ﬁlter coefﬁcients hðnÞ in step 2 by the selected window sequence using
Equation (7.20) to obtain the windowed impulse sequence hwðnÞ.
0
500
1000
1500
2000
2500
3000
3500
4000
100
50
0
Frequency (Hz)
Magn tude response (dB)
0
500
1000
1500
2000
2500
3000
3500
4000
2000
1500
1000
500
0
Frequency (Hz)
Phase (degrees)
FIGURE 7.42B
Frequency responses. The solid line indicates the FIR ﬁlter with inﬁnite precision; the dashed line indicates the
FIR ﬁlter with the round-off coefﬁcients.
7.9 Fir Design Procedures and Selection of Fir Filter Design Methods
285

4. Delay the windowed impulse sequence hwðnÞ by M samples to get the causal windowed FIR ﬁlter
coefﬁcients bn ¼ hwðn  MÞ using Equation (7.21).
5. Output the transfer function and plot the frequency responses.
6. If the frequency speciﬁcations are satisﬁed, output the difference equation. If the frequency
speciﬁcations are not satisﬁed, increase the ﬁlter order and repeat beginning with step 2.
The frequency sampling method:
1. Given the ﬁlter frequency speciﬁcations, choose the ﬁlter order (odd number used in the book), and
specify the equally spaced magnitudes of the frequency response for the normalized frequency
range from 0 to p using Equation (7.29).
2. Calculate FIR ﬁlter coefﬁcients using Equation (7.30).
3. Use the symmetry in Equation (7.31) and the linear phase requirement to determine the rest of the
coefﬁcients.
4. Output the transfer function and plot the frequency responses.
5. If the frequency speciﬁcations are satisﬁed, output the difference equation. If the frequency
speciﬁcations are not satisﬁed, increase the ﬁlter order and repeat beginning with step 2.
The optimal design method (Parks McClellan algorithm):
1. Given the band edge frequencies, choose the ﬁlter order , normalize each band edge frequency to
the Nyquist limit (folding frequency ¼ fs=2), and specify the ideal magnitudes.
2. Calculate the absolute values of the passband ripple and stopband attenuation, if they are given in
terms of dB values, using Equations (7.34) and (7.35).
3. Determine the error weight factors for the passband and stopband, respectively, using Equations
(7.36) and (7.37).
4. Apply the Remez algorithm to calculate ﬁlter coefﬁcients.
Table 7.19 Comparisons of Three Design Methods
Design Method
Window
Frequency Sampling
Optimal
Filter type
1. Lowpass, highpass,
bandpass, bandstop.
2. Formulas are not valid
for arbitrary frequency
selectivity.
1. Any type of ﬁlter
2. The formula is valid
for arbitrary frequency
selectivity.
1. Any type of ﬁlter
2. Valid for arbitrary
frequency selectivity
Linear phase
Yes
Yes
Yes
Ripple and stopband
speciﬁcations
Used for determining
the ﬁlter order and cutoff
frequency/-cies
Need to be checked
after each design trial
Used in the algorithm;
need to be checked
after each design trial
Algorithm complexity for
coefﬁcients
Moderate:
1. Impulse sequence
calculation
2. Window function
weighting
Simple:
Single equation
Complicated:
1. ParkseMcClellan
algorithm
2. Remez exchange
algorithm
Minimal design tool
Calculator
Calculator
Software
286
CHAPTER 7 Finite Impulse Response Filter Design

5. Output the transfer function and check the frequency responses.
6. If the frequency speciﬁcations are satisﬁed, output the difference equation. If the frequency
speciﬁcations are not satisﬁed, increase the ﬁlter order and repeat beginning with step 4.
Table 7.19 shows the comparisons for the window, frequency sampling, and optimal methods. The
table can be used as a selection guide for each design method in this book.
Example 7.20 describes the possible selection of the design method by a DSP engineer to solve
a real-world problem.
EXAMPLE 7.20
Determine the appropriate FIR ﬁlter design method for each of the following DSP applications.
a. A DSP engineer implements a digital two band crossover system as described in Section 7.4.4 in this book. He
selects the FIR ﬁlters to satisfy the following speciﬁcations:
Sampling rate
44,100 Hz
Crossover frequency
1,000 Hz (cutoff frequency)
Transition band
600 Hz to 1,400 Hz
Lowpass ﬁlter
passband frequency range from 0 to 600 Hz with a ripple of 0.02 dB and stopband edge at 1,400
Hz with an attenuation of 50 dB.
Highpass ﬁlter
passband frequency range from 1.4 to 44.1 kHz with a ripple of 0.02 dB and stopband edge at
600 Hz with an attenuation of 50 dB.
The engineer does not have the software routine for the Remez algorithm.
b. An audio engineer tries to equalize a speech signal sampled at 8,000 Hz using a linear phase FIR ﬁlter based on the
magnitude speciﬁcations in Figure 7.43. The engineer does not have the software routine for the Remez algorithm.
Solution:
a. The window design method is the ﬁrst choice, since this formula is expressed in terms of the cutoff frequency
(crossover frequency), the ﬁlter order is based on the transient band, and the ﬁlter types are standard lowpass and
highpass. The ripple and stopband speciﬁcations can be satisﬁed by selecting the Hamming window. The optimal
design method will also do the job if the remez() algorithm is available. But there exists a challenge to satisfy the
combined unity gains at the crossover frequency of 1,000 Hz.
b. Since the magnitude frequency response is not a standard ﬁlter type such as lowpass, highpass, bandpass, or
bandstop, and the remez() algorithm is not available, the ﬁrst choice should be the frequency sampling method.
fs/2=4000 Hz
2.0
1.0
0
0.0
Magnitude
FIGURE 7.43
Magnitude frequency response in Example 7.20(b).
7.9 Fir Design Procedures and Selection of Fir Filter Design Methods
287

7.10 SUMMARY
1. The Fourier transform method is used to compute noncausal FIR ﬁlter coefﬁcients, including
those of lowpass, highpass, bandpass, and bandstop ﬁlters.
2. Converting noncausal FIR ﬁlter coefﬁcients to causal FIR ﬁlter coefﬁcients only introduces
linear phase, which is a good property for audio applications. The linear phase ﬁlter output
has the same amount of delay for all the input signals whose frequency components are
within the passband.
3. The causal FIR ﬁlter using the Fourier transform method generates ripple oscillations (Gibbs
effect) in the passband and stopband in its ﬁlter magnitude frequency response due to abrupt
truncation of the FIR ﬁlter coefﬁcient sequence.
4. To reduce the oscillation effect, the window method is introduced to tap down the coefﬁcient values
towards both ends. A substantial improvement of the magnitude frequency response is achieved.
5. Real-life DSP applications such as noise reduction systems and two-band digital audio crossover
systems were investigated.
6. Frequency sampling design is feasible for an FIR ﬁlter with an arbitrary magnitude response
speciﬁcation.
7. An optimal design method, the Parks McClellan algorithm using the Remez exchange algorithm,
offers ﬂexibility for ﬁlter speciﬁcations. The Remez exchange algorithm was explained using
a simpliﬁed example.
8. Realization structures of FIR ﬁlters have special forms, such as the transversal form and the linear
phase form.
9. The effect of quantizing FIR ﬁlter coefﬁcients for implementation changes the zero locations
of the FIR ﬁlter. More effects on the stopband in the magnitude and phase responses are
observed.
10. Guidelines for selecting an appropriate design method in practice were summarized with
consideration of the ﬁlter type, linear phase, ripple and stopband speciﬁcations, algorithm
complexity, and design tools.
7.11 MATLAB PROGRAMS
Program 7.14 enables one to design FIR ﬁlters via the window method using window functions
such as the rectangular window, triangular window, Hanning window, Hamming window, and
Blackman window. Filter types of the design include lowpass, highpass, bandpass, and
bandstop.
Program 7.14. MATLAB function for FIR ﬁlter design using the window method.
function B firwd(N,Ftype,WnL,WnH,Wtype)
% B
firwd(N,Ftype,WnL,WnH,Wtype)
% FIR filter design using the window function method.
% Input parameters:
% N: the number of the FIR filter taps.
%
Note: It must be odd number.
288
CHAPTER 7 Finite Impulse Response Filter Design

% Ftype: the filter type
%
1. Lowpass filter
%
2. Highpass filter
%
3. Bandpass filter
%
4. Bandstop filter
% WnL: lower cutoff frequency in radians. Set WnL 0 for the highpass filter.
% WnH: upper cutoff frequency in radians. Set WnL 0 for the lowpass filter.
% Wtypw: window function type
%
1. Rectangular window
%
2. Triangular window
%
3. Hanning window
%
4. Hamming window
%
5. Balckman window
% Output:
% B: FIR filter coefficients.
M (N 1)/2;
hH sin(WnH*[ M:1: 1])./([ M:1: 1]*pi);
hH(Mþ1) WnH/pi;
hH(Mþ2:1:N) hH(M: 1:1);
hL sin(WnL*[ M:1: 1])./([ M:1: 1]*pi);
hL(Mþ1) WnL/pi;
hL(Mþ2:1:N) hL(M: 1:1);
if Ftype
1
h(1:N) hL(1:N);
end
if Ftype
2
h(1:N)
hH(1:N);
h(Mþ1) 1þh(Mþ1);
end
if Ftype
3
h(1:N) hH(1:N) hL(1:N);
end
if Ftype
4
h(1:N) hL(1:N) hH(1:N);
h(Mþ1) 1þh(Mþ1);
end
% Window functions
if Wtype
1
w(1:N) ones(1,N);
end
if Wtype
2
w 1 abs([ M:1:M])/M;
end
if Wtype
3
w
0.5þ0.5*cos([ M:1:M]*pi/M);
end
if Wtype
4
w 0.54þ0.46*cos([ M:1:M]*pi/M);
7.11 MATLAB Programs
289

end
if Wtype
5
w 0.42þ0.5*cos([ M:1:M]*pi/M)þ0.08*cos(2*[ M:1:M]*pi/M);
end
B h .* w
Program 7.15 enables one to design FIR ﬁlters using the frequency sampling method. Note that
values of the frequency response, which correspond to the equally spaced DFT frequency components,
must be speciﬁed for design. Besides the lowpass, highpass, bandpass and bandstop ﬁlter designs, the
method can be used to design FIR ﬁlters with an arbitrarily speciﬁed magnitude frequency response.
Program 7.15. MATLAB function for FIR ﬁlter design using the frequency sampling method.
function B firfs(N,Hk)
% B firls(N,Hk)
% FIR filter design using the frequency sampling method.
% Input parameters:
% N: the number of filter coefficients.
%
note: N must be odd number.
% Hk: sampled frequency reponse for k 0,1,2,.,M (N 1)/2.
% Output:
% B: FIR filter coefficients.
M (N 1)/2;
for n 1:1:N
B(n) (1/N)*(Hk(1)þ.
2*sum(Hk(2:1:Mþ1).
.*cos(2*pi*([1:1:M])*(n 1 M)/N)));
end
7.12 PROBLEMS
7.1. Design a 3-tap FIR lowpass ﬁlter with a cutoff frequency of 1,500 Hz and a sampling rate of
8,000 Hz using a
a. rectangular window function
b. Hamming window function
Determine the transfer function and difference equation of the designed FIR system, and
compute and plot the magnitude frequency response for U ¼ 0; p=4; p=2; 3p=4; and p radians.
7.2. Design a 3-tap FIR highpass ﬁlter with a cutoff frequency of 1,600 Hz and a sampling rate of
8,000 Hz using a
a. rectangular window function
b. Hamming window function
Determine the transfer function and difference equation of the designed FIR system, and
compute and plot the magnitude frequency response for U ¼ 0; p=4; p=2; 3p=4; and p
radians.
290
CHAPTER 7 Finite Impulse Response Filter Design

7.3. Design a 5-tap FIR lowpass ﬁlter with a cutoff frequency of 100 Hz and a sampling rate of
1,000 Hz using a
a. rectangular window function
b. Hamming window function
Determine the transfer function and difference equation of the designed FIR system, and
compute and plot the magnitude frequency response for U ¼ 0; p=4; p=2; 3p=4; and p radians.
7.4. Design a 5-tap FIR highpass ﬁlter with a cutoff frequency of 250 Hz and a sampling rate of
1,000 Hz using a
a. rectangular window function
b. Hamming window function
Determine the transfer function and difference equation of the designed FIR system, and
compute and plot the magnitude frequency response for U ¼ 0; p=4; p=2; 3p=4; and p radians.
7.5. Design a 5-tap FIR bandpass ﬁlter with a lower cutoff frequency of 1,600 Hz, an upper cut-off
frequency of 1,800 Hz and a sampling rate of 8,000 Hz using a
a. rectangular window function
b. Hamming window function
Determine the transfer function and difference equation of the designed FIR system, and
compute and plot the magnitude frequency response for U ¼ 0; p=4; p=2; 3p=4; and p radians.
7.6. Design a 5-tap FIR band reject ﬁlter with a lower cutoff frequency of 1,600 Hz, an upper
cutoff frequency of 1,800 Hz, and a sampling rate of 8,000 Hz using a
a. rectangular window function
b. Hamming window function
Determine the transfer function and difference equation of the designed FIR system, and
compute and plot the magnitude frequency response for U ¼ 0; p=4; p=2; 3p=4; and p radians.
7.7. Consider an FIR lowpass ﬁlter design with the following speciﬁcations:
Passband ¼ 0 800 Hz
Stopband ¼ 1,200 4,000 Hz
Passband ripple ¼ 0.1 dB
Stopband attenuation ¼ 40 dB
Sampling rate ¼ 8,000 Hz
Determine the following:
a. window method
b. length of the FIR ﬁlter
c. cutoff frequency for the design equation
7.11 MATLAB Programs
291

7.8. Consider an FIR highpass ﬁlter design with the following speciﬁcations:
Stopband ¼ 0 1,500 Hz
Passband ¼ 2,000 4,000 Hz
Passband ripple ¼ 0.02 dB
Stopband attenuation ¼ 60 dB
Sampling rate ¼ 8,000 Hz
Determine the following:
a. window method
b. length of the FIR ﬁlter
c. cutoff frequency for the design equation
7.9. Consider an FIR bandpass ﬁlter design with the following speciﬁcations:
Lower cutoff frequency ¼ 1,500 Hz
Lower transition width ¼ 600 Hz
Upper cutoff frequency ¼ 2,300 Hz
Upper transition width ¼ 600 Hz
Passband ripple ¼ 0.1 dB
Stopband attenuation ¼ 50 dB
Sampling rate: 8,000 Hz
Determine the following:
a. window method
b. length of the FIR ﬁlter
c. cutoff frequencies for the design equation
7.10. Consider an FIR bandstop ﬁlter design with the following speciﬁcations:
Lower passband ¼ 0 1,200 Hz
Stopband ¼ 1,600 2,000 Hz
Upper passband ¼ 2,400 4,000 Hz
Passband ripple ¼ 0.05 dB
Stopband attenuation ¼ 60 dB
Sampling rate ¼ 8,000 Hz
292
CHAPTER 7 Finite Impulse Response Filter Design

Determine the following:
a. window method
b. length of the FIR ﬁlter
c. cutoff frequencies for the design equation
7.11. Given an FIR system
HðzÞ ¼ 0:25  0:5z 1 þ 0:25z 2
realize HðzÞ using each of the following speciﬁed methods:
a. transversal form (write the difference equation for implementation)
b. linear phase form (write the difference equation for implementation)
7.12. Given an FIR ﬁlter transfer function
HðzÞ ¼ 0:2 þ 0:5z 1  0:3z 2 þ 0:5z 3 þ 0:2z 4
perform the linear phase FIR ﬁlter realization, and write the difference equation for
implementation.
7.13. Determine the transfer function for a 3-tap FIR lowpass ﬁlter with a cutoff frequency of 150
Hz and a sampling rate of 1,000 Hz using the frequency sampling method.
7.14. Determine the transfer function for a 3-tap FIR highpass ﬁlter with a cutoff frequency of 250
Hz and a sampling rate of 1,000 Hz using the frequency sampling method.
7.15. Determine the transfer function for a 5-tap FIR lowpass ﬁlter with a cutoff frequency of 2,000
Hz and a sampling rate of 8,000 Hz using the frequency sampling method.
7.16. Determine the transfer function for a 5-tap FIR highpass ﬁlter with a cutoff frequency of
3,000 Hz and a sampling rate of 8,000 Hz using the frequency sampling method.
7.17. Given the following speciﬁcations, determine the transfer function:
• 7-tap FIR bandpass ﬁlter
• lower cutoff frequency of 1,500 Hz and upper cutoff frequency of 3,000 Hz
• sampling rate of 8,000 Hz
• frequency sampling design method
7.18. Given the following speciﬁcations, determine the transfer function:
• 7-tap FIR bandstop ﬁlter
• lower cutoff frequency of 1,500 Hz and upper cutoff frequency of 3,000 Hz
• sampling rate of 8,000 Hz
• frequency sampling design method
7.11 MATLAB Programs
293

7.19. A lowpass FIR ﬁlter to be designed has the following speciﬁcations:
Design method: Parks McClellan algorithm
Sampling rate ¼ 1,000 Hz
Passband ¼ 0 200 Hz
Stopband ¼ 300 500 Hz
Passband ripple ¼ 1 dB
Stopband attenuation ¼ 40 dB
Determine the error weights Wp and Ws for the passband and stopband in the Parks McClellan
algorithm.
7.20. A bandpass FIR ﬁlter to be designed has the following speciﬁcations:
Design method: Parks McClellan algorithm
Sampling rate ¼ 1,000 Hz
Passband ¼ 200 250 Hz
Lower stopband ¼ 0 150 Hz
Upper stopband ¼ 300 500 Hz
Passband ripple ¼ 1 dB
Stopband attenuation ¼ 30 dB
Determine the error weights Wp and Ws for the passband and stopband in the Parks McClellan
algorithm.
7.21. A highpass FIR ﬁlter to be designed has the following speciﬁcations:
Design method: Parks McClellan algorithm
Sampling rate ¼ 1,000 Hz
Passband ¼ 350 500 Hz
Stopband ¼ 0 250 Hz
Passband ripple ¼ 1 dB
Stopband attenuation ¼ 60 dB
Determine the error weights Wp and Ws for the passband and stopband in the Parks McClellan
algorithm.
7.22. A bandstop FIR ﬁlter to be designed has the following speciﬁcations:
Design method: Parks McClellan algorithm
Sampling rate ¼ 1,000 Hz
294
CHAPTER 7 Finite Impulse Response Filter Design

Stopband ¼ 250 350 Hz
Lower passband ¼ 0 200 Hz
Upper passband ¼ 400 500 Hz
Passband ripple ¼ 1 dB
Stopband attenuation ¼ 25 dB
Determine the error weights Wp and Ws for the passband and stopband in the Parks McClellan
algorithm.
7.23. In a speech recording system with a sampling rate of 10,000 Hz, the speech is corrupted by
broadband random noise. To remove the random noise while preserve speech information,
the following speciﬁcations are given:
Speech frequency range ¼ 0 3,000 Hz
Stopband range ¼ 4,000 5,000 Hz
Passband ripple ¼ 0.1 dB
Stopband attenuation ¼ 45 dB
FIR ﬁlter with Hamming window
Determine the FIR ﬁlter length (number of taps) and the cutoff frequency; use MATLAB to
design the ﬁlter; and plot the frequency response.
7.24. Consider the speech equalizer shown in Figure 7.44 to compensate for midrange frequency
loss of hearing that has the following speciﬁcations:
Sampling rate ¼ 8,000 Hz
Bandpass FIR ﬁlter with Hamming window
Frequency range to be emphasized ¼ 1,500 2,000 Hz
Lower stopband ¼ 0 1,000 Hz
Upper stopband ¼ 2,500 4,000 Hz
Passband ripple ¼ 0.1 dB
Stopband attenuation ¼ 45 dB
Determine the ﬁlter length and the lower and upper cutoff frequencies.
Digital
input x(n)
Digital
output y(n)
+
Bandpass
filter
5
Gain
FIGURE 7.44
Speech equalizer in Problem 7.24.
7.11 MATLAB Programs
295

7.25. A digital crossover can be designed as shown in Figure 7.45.
Consider the following audio speciﬁcations:
Sampling rate ¼ 44,100 Hz
Crossover frequency ¼ 2,000 Hz
Transition band range ¼ 1,600 Hz
Passband ripple ¼ 0.1 dB
Stopband attenuation ¼ 50 dB
Filter type ¼ FIR
Determine the following for each ﬁlter in Figure 7.45:
a. window function
b. ﬁlter length
c. cutoff frequency
Use MALAB to design both ﬁlters and plot frequency responses for both ﬁlters.
7.12.1 Computer Problems with MATLAB
Use the MATLAB programs provided in Section 7.11 to design the following FIR ﬁlters.
7.26. Design a 41-tap lowpass FIR ﬁlter whose cutoff frequency is 1,600 Hz using the following
window functions. Assume that the sampling frequency is 8,000 Hz.
a. rectangular window function
b. triangular window function
c. Hanning window function
d. Hamming window function
e. Blackman window function
List the FIR ﬁlter coefﬁcients and plot the frequency responses for each case.
Digital
audio x(n)
Highpass filter
Lowpass filter
Gain_L
Gain_H
Tweeter:
The crossover passes
high frequencies
Woofer:
The crossover passes
low frequencies
yH(n)
yL(n)
FIGURE 7.45
Two-band crossover in Problem 7.25.
296
CHAPTER 7 Finite Impulse Response Filter Design

7.27. Design a lowpass FIR ﬁlter whose cutoff frequency is 1,000 Hz using the Hamming window
function for the following speciﬁed ﬁlter length. Assume that the sampling frequency is
8,000 Hz.
a. 21 ﬁlter coefﬁcients
b. 31 ﬁlter coefﬁcients
c. 41 ﬁlter coefﬁcients
List the FIR ﬁlter coefﬁcients for each design and compare the magnitude frequency
responses.
7.28. Design a 31-tap highpass FIR ﬁlter whose cutoff frequency is 2,500 Hz using the following
window functions. Assume that the sampling frequency is 8,000 Hz.
a. Hanning window function
b. Hamming window function
c. Blackman window function
List the FIR ﬁlter coefﬁcients and plot the frequency responses for each design.
7.29. Design a 41-tap bandpass FIR ﬁlter with lower and upper cutoff frequencies of 2,500 Hz and
3,000 Hz, respectively, using the following window functions. Assume a sampling frequency
of 8,000 Hz.
a. Hanning window function
b. Blackman window function.
List the FIR ﬁlter coefﬁcients and plot the frequency responses for each design.
7.30. Design a 41-tap band reject FIR ﬁlter with cutoff frequencies of 2,500 Hz and 3,000 Hz,
respectively, using the Hamming window function. Assume a sampling frequency of 8,000
Hz. List the FIR ﬁlter coefﬁcients and plot the frequency responses.
7.31. Use the frequency sampling method to design a linear phase lowpass FIR ﬁlter with 17
coefﬁcients. Let the cutoff frequency be 2,000 Hz and assume a sampling frequency of 8,000
Hz. List the FIR ﬁlter coefﬁcients and plot the frequency responses.
7.32. Use the frequency sampling method to design a linear phase bandpass FIR ﬁlter with 21
coefﬁcients. Let the lower and upper cutoff frequencies be 2,000 Hz and 2,500 Hz,
respectively, and assume a sampling frequency of 8,000 Hz. List the FIR ﬁlter coefﬁcients
and plot the frequency responses.
7.33. Given an input data sequence
xðnÞ ¼ 1:2$sinð2pð1; 000Þn=8; 000Þ  1:5$cosð2pð2; 800Þn=8; 000Þ
with a sampling frequency of 8,000 Hz, use the designed FIR ﬁlter with a Hamming window
in Problem 7.26 to ﬁlter 400 data points of xðnÞ, and plot the 400 samples of the input and
output data.
7.11 MATLAB Programs
297

7.34. Design a lowpass FIR ﬁlter with the following speciﬁcations:
Design method: Parks McClellan algorithm
Sampling rate ¼ 8,000 Hz
Passband ¼ 0 1,200 Hz
Stopband ¼ 1,500 4,000 Hz
Passband ripple ¼ 1 dB
Stopband attenuation ¼ 40 dB
List the ﬁlter coefﬁcients and plot the frequency responses.
7.35. Design a bandpass FIR ﬁlter with the following speciﬁcations:
Design method: Parks McClellan algorithm
Sampling rate ¼ 8,000 Hz
Passband ¼ 1,200 1,600 Hz
Lower stopband ¼ 0 800 Hz
Upper stopband ¼ 2,000 4,000 Hz
Passband ripple ¼ 1 dB
Stopband attenuation ¼ 40 dB
List the ﬁlter coefﬁcients and plot the frequency responses.
7.12.2 MATLAB Projects
7.36. Speech enhancement:
Digitally recorded speech in a noisy environment can be enhanced using a lowpass ﬁlter if
the recorded speech with a sampling rate of 8,000 Hz contains the desired frequency
components lower than 1,600 Hz. Design a lowpass ﬁlter to remove the high frequency noise
above 1,600 Hz with the following ﬁlter speciﬁcations: passband frequency range: 0
1,600
Hz; passband ripple: 0.02 dB; stopband frequency range: 1,800 4,000 Hz; stopband
attenuation: 50 dB.
Use the designed lowpass ﬁlter to ﬁlter the noisy speech and adopt the following code to simulate
the noisy speech:
load speech.dat
t [0:length(speech) 1]*T;
th mean(speech.*speech)/4; %Noise power
(1/4) speech power
noise sqrt(th)*randn([1,length(speech)]); %Generate Gaussian noise
nspeech speech+noise; % Generate noisy speech
In this project, plot the speech samples and spectra for both noisy speech and the enhanced
speech and use the MATLAB sound() function to evaluate the sound quality. For example, to
hear the noisy speech, use the following:
soundðnspeech=maxðabsðnspeechÞÞ; 8000Þ;
298
CHAPTER 7 Finite Impulse Response Filter Design

7.37. Digital crossover system:
Design a two-band digital crossover system with the following speciﬁcations:
Sampling rate ¼ 44,100 Hz
Crossover frequency ¼ 1,200 Hz (cutoff frequency)
Transition band ¼ 800 1,600 Hz
Lowpass ﬁlter: passband frequency range from 0 to 800 Hz with a ripple of 0.02 dB and
stopband edge at 1,400 Hz with the attenuation of 50 dB
Highpass ﬁlter: passband frequency range from 1.6 to 44.1 kHz with a ripple of 0.02 dB and
stopband edge at 1,600 Hz with the attenuation of 50 dB
In this project, plot the magnitude frequency responses for both lowpass and highpass ﬁlters.
Use the following MATLAB code to read stereo audio data (“No9seg.wav”):
½x fs Nbits ¼ wavreadð0No9seg:wav0Þ;
Process the given stereo audio segment. Listen to and describe the sound effects of the processed
audio in the following sequences:
Channel 1: original, lowband, and highband
Channel 2: original, lowband, and highband
Stereo (both channels): original, lowband, and highband
7.11 MATLAB Programs
299

This page intentionally left blank

Inﬁnite Impulse Response
Filter Design
8
CHAPTER OUTLINE
8.1 Inﬁnite Impulse Response Filter Format ......................................................................................... 302
8.2 Bilinear Transformation Design Method.......................................................................................... 303
8.2.1 Analog Filters Using Lowpass Prototype Transformation ................................................304
8.2.2 Bilinear Transformation and Frequency Warping...........................................................308
8.2.3 Bilinear Transformation Design Procedure ...................................................................314
8.3 Digital Butterworth and Chebyshev Filter Designs ........................................................................... 318
8.3.1 Lowpass Prototype Function and Its Order ...................................................................318
8.3.2 Lowpass and Highpass Filter Design Examples.............................................................322
8.3.3 Bandpass and Bandstop Filter Design Examples...........................................................331
8.4 Higher-Order Inﬁnite Impulse Response Filter Design Using the Cascade Method ............................. 338
8.5 Application: Digital Audio Equalizer .............................................................................................. 341
8.6 Impulse-Invariant Design Method .................................................................................................. 345
8.7 Pole-Zero Placement Method for Simple Inﬁnite Impulse Response Filters....................................... 351
8.7.1 Second-Order Bandpass Filter Design..........................................................................352
8.7.2 Second-Order Bandstop (Notch) Filter Design ..............................................................354
8.7.3 First-Order Lowpass Filter Design................................................................................355
8.7.4 First-Order Highpass Filter Design...............................................................................357
8.8 Realization Structures of Inﬁnite Impulse Response Filters ............................................................. 358
8.8.1 Realization of Inﬁnite Impulse Response Filters in Direct-Form I and Direct-Form II .......358
8.8.2 Realization of Higher-Order Inﬁnite Impulse Response Filters via the Cascade Form........361
8.9 Application: 60-Hz Hum Eliminator and Heart Rate Detection Using Electrocardiography.................. 362
8.10 Coefﬁcient Accuracy Effects on Inﬁnite Impulse Response Filters.................................................. 369
8.11 Application: Generation and Detection of DTMF Tones Using the Goertzel Algorithm ....................... 373
8.11.1 Single-Tone Generator............................................................................................374
8.11.2 Dual-Tone Multifrequency Tone Generator ...............................................................375
8.11.3 Goertzel Algorithm.................................................................................................377
8.11.4 Dual-Tone Multifrequency Tone Detection Using the Modiﬁed Goertzel Algorithm .......383
8.12 Summary of Inﬁnite Impulse Response (IIR) Design Procedures and Selection of the IIR Filter
Design Methods in Practice................................................................................................................. 388
8.13 Summary ................................................................................................................................... 391
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00008-1
Copyright  2013 Elsevier Inc. All rights reserved.
301

OBJECTIVES:
This chapter investigates a bilinear transformation method for inﬁnite impulse response (IIR) ﬁlter design
and develops a procedure to design digital Butterworth and Chebyshev ﬁlters. The chapter also investigates
other IIR ﬁlter design methods, such as impulse-invariant design and pole-zero placement design. Finally,
the chapter illustrates how to apply the designed IIR ﬁlters to solve real-world problems such as digital audio
equalization, 60-Hz interference cancellation in audio and electrocardiography signals, dual-tone multifre-
quency tone generation, and detection using the Goertzel algorithm.
8.1 INFINITE IMPULSE RESPONSE FILTER FORMAT
In this chapter, we will study several methods for inﬁnite impulse response (IIR) ﬁlter design. An IIR
ﬁlter is described using the difference equation, as discussed in Chapter 6:
yðnÞ ¼ b0xðnÞ þ b1xðn  1Þ þ / þ bMxðn  MÞ
 a1yðn  1Þ  /  aNyðn  NÞ
Chapter 6 also gives the IIR ﬁlter transfer function as
HðzÞ ¼ YðzÞ
XðzÞ ¼ b0 þ b1z 1 þ / þ bMz M
1 þ a1z 1 þ / þ aNz N
where bi and ai are the ðM þ 1Þ numerator and N denominator coefﬁcients, respectively. YðzÞ and XðzÞ
are the z-transform functions of the ﬁlter input xðnÞ and ﬁlter output yðnÞ. To become familiar with the
form of the IIR ﬁlter, let us look at the following example.
EXAMPLE 8.1
Given the IIR ﬁlter
yðnÞ
0:2xðnÞ þ 0:4xðn
1Þ þ 0:5yðn
1Þ
determine the transfer function, nonzero coefﬁcients, and impulse response.
Solution:
Applying the z transform and solving for a ratio of the z transform output over input, we have
HðzÞ
Y ðzÞ
XðzÞ
0:2 þ 0:4z1
1
0:5z1
We also identify the nonzero numerator coefﬁcients and denominator coefﬁcient as
b0
0:2; b1
0:4;
and
a1
0:5
To determine the impulse response, we rewrite the transfer function as
HðzÞ
0:2
1
0:5z1 þ
0:4z1
1
0:5z1
302
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Using the inverse z transform and shift theorem, we obtain the impulse response as
h

n

0:2ð0:5Þnu

n

þ 0:4ð0:5Þn1u

n
1

The obtained impulse response has an inﬁnite number of terms, where the ﬁrst several terms are calculated as
hð0Þ
0:2; hð1Þ
0:7; hð2Þ
0:25; .:
At this point, we can make following remarks:
1. The IIR ﬁlter output yðnÞ depends not only on the current input xðnÞ and past inputs xðn  1Þ, .,
but also on the past output(s) yðn  1Þ, ., (recursive terms). Its transfer function is a ratio of the
numerator polynomial over the denominator polynomial, and its impulse response has an inﬁnite
number of terms.
2. Since the transfer function has the denominator polynomial, the pole(s) of a designed IIR ﬁlter
must be inside the unit circle on the z-plane to ensure its stability.
3. Compared with the ﬁnite impulse response (FIR) ﬁlter (see Chapter 7), the IIR ﬁlter offers a much
smaller ﬁlter size. Hence, the ﬁlter operation requires a fewer number of computations, but the
linear phase is not easily obtained. The IIR ﬁlter is preferred when a small ﬁlter size is called
for but the application does not require a linear phase.
The objective of IIR ﬁlter design is to determine the ﬁlter numerator and denominator coefﬁcients to
satisfy ﬁlter speciﬁcations such as passband gain and stopband attenuation, as well as cutoff frequency/
frequencies for the lowpass, highpass, bandpass, and bandstop ﬁlters.
We ﬁrst focus on the bilinear transformation (BLT) design method. Then we introduce other design
methods such as the impulse invariant design and the pole-zero placement design.
8.2 BILINEAR TRANSFORMATION DESIGN METHOD
Figure 8.1 illustrates a ﬂow chart of the BLT design used in this book. The design procedure includes
the following steps: (1) transforming digital ﬁlter speciﬁcations into analog ﬁlter speciﬁcations,
Digital filter
specifications
 Analog filter specifications
Analog filter transfer function
Digital filter transfer function
 and frequency response verification
1. Transformation with frequency warping
2. Transformation by lowpass prototype filter
3. Bilinear transformation
FIGURE 8.1
General procedure for IIR ﬁlter design using bilinear transformation.
8.2 Bilinear Transformation Design Method
303

(2) performing analog ﬁlter design, and (3) applying bilinear transformation (which will be introduced
in the next section) and verifying the frequency response.
8.2.1 Analog Filters Using Lowpass Prototype Transformation
Before we begin to develop the BLT design, let us review analog ﬁlter design using lowpass prototype
transformation. This method converts an analog lowpass ﬁlter with a cutoff frequency of 1 radians per
second, called the lowpass prototype, into practical analog lowpass, highpass, banspass, and bandstop
ﬁlters with speciﬁed frequencies.
Letting HPðsÞ be a transfer function of the lowpass prototype, the transformation of the lowpass
prototype into a lowpass ﬁlter is given in Figure 8.2.
As shown in Figure 8.2, HLPðsÞ designates the analog lowpass ﬁlter with a cutoff frequency uc
radians/second. The lowpass prototype to lowpass ﬁlter transformation substitutes s in the lowpass
prototype function HPðsÞ with s=uc, where v is the normalized frequency of the lowpass prototype and uc
is the cutoff frequency of the lowpass ﬁlter. Let us consider the following ﬁrst-order lowpass prototype:
HPðsÞ ¼
1
s þ 1
(8.1)
Its frequency response is obtained by substituting s ¼ jv into Equation (8.1), that is,
HPðjnÞ ¼
1
jv þ 1
and the magnitude gain is
jHPðjvÞj ¼
1
1 þ v2
p
(8.2)
We compute the gains at v ¼ 0, v ¼ 1, v ¼ 100, v ¼ 10; 000 to obtain 1; 1=
2
p
, 0:0995, and 0.01,
respectively. The cutoff frequency gain at v ¼ 1 equals 1=
2
p
, which is equivalent to 3 dB, and
the direct-current (DC) gain is 1. The gain approaches zero when the frequency goes to v ¼ þN.
This veriﬁes that the lowpass prototype is a normalized lowpass ﬁlter with a normalized cutoff
frequency of 1. Applying the prototype transformation s ¼ s=uc in Figure 8.2, we get an analog
lowpass ﬁlter with a cutoff frequency of uc:
HðsÞ ¼
1
s=uc þ 1 ¼
uc
s þ uc
(8.3)
1
c
v
H
jv
P(
)
H
j
LP (
)
s
s
c
H
s
H
s
LP
P
s s
c
( )
( )
/
0
0
FIGURE 8.2
Analog lowpass prototype transformation into a lowpass ﬁlter.
304
CHAPTER 8 Inﬁnite Impulse Response Filter Design

We can obtain the analog frequency response by substituting s ¼ ju into Equation (8.3), that is,
HðjuÞ ¼
1
ju=uc þ 1
The magnitude response is determined by
jHðjuÞj ¼
1
1 þ
 u
uc
2
s
(8.4)
Similarly, we verify the gains at u ¼ 0, u ¼ uc, u ¼ 100uc, u ¼ 10; 000uc to be 1;1=
2
p
, 0:0995,
and 0.01, respectively. The ﬁlter gain at the cutoff frequency uc equals 1=
2
p
, and the DC gain is 1. The
gain approaches zero when u ¼ þN. We notice that ﬁlter gains do not change but that the ﬁlter
frequency is scaled up by a factor of uc. This veriﬁes that the prototype transformation converts the
lowpass prototype to the analog lowpass ﬁlter with the speciﬁed cut-off frequency of uc without an
effect on the ﬁlter gain.
This ﬁrst-order prototype function is used here for illustrative purposes. We will obtain general
functions for Butterworth and Chebyshev lowpass prototypes in Section 8.3.
The highpass, bandpass, and bandstop ﬁlters using the speciﬁed lowpass prototype transformation
can be easily veriﬁed. We review them in Figures 8.3, 8.4 and 8.5, respectively.
The transformation from the lowpass prototype to the highpass ﬁlter HHPðsÞ with a cutoff
frequency uc radians/second is given in Figure 8.3, where s ¼ uc=s in the lowpass prototype
transformation.
The transformation of the lowpass prototype function to a bandpass ﬁlter with a center frequency
u0, a lower cutoff frequency ul, and an upper cutoff frequency uh in the passband is depicted in
Figure 8.4, where s ¼ ðs2 þ u2
0Þ=ðsWÞ is substituted into the lowpass prototype.
As shown in Figure 8.4, u0 is the geometric center frequency, which is deﬁned as u0 ¼
uluh
p
while the passband bandwidth is given by W ¼ uh  ul. Similarly, the transformation from the
lowpass prototype to a bandstop (band reject) ﬁlter is illustrated in Figure 8.5 with s ¼ sW=ðs2 þ u2
0Þ
substituted into the lowpass prototype.
Finally, the lowpass prototype transformations are summarized in Table 8.1.
1
c
v
H
jv
P(
)
H
j
HP (
)
s
s
c
H
s
H
s
HP
P
s
s
c
( )
( )
/
0
0
FIGURE 8.3
Analog lowpass prototype transformation to the highpass ﬁlter.
8.2 Bilinear Transformation Design Method
305

1
v
H
jv
P(
)
H
j
BP (
)
s
s
sW
2
0
2
H
s
H
s
BP
P
s s
sW
( )
( )
2
02
0
0
l
h
0
W
0
l
h
W
h
l
FIGURE 8.4
Analog lowpass prototype transformation to the bandpass ﬁlter.
1
v
H
jv
P(
)
H
j
BS (
)
s
sW
s2
0
2
H
s
H
s
BS
P
s
sW
s
( )
( )
2
0
2
0
0
l
h
0
W
0
l
h
W
h
l
FIGURE 8.5
Analog lowpass prototype transformation to a bandstop ﬁlter.
Table 8.1 Analog Lowpass Prototype Transformations
Filter Type
Prototype Transformation
Lowpass
s
uc
, uc is the cutoff frequency
Highpass
uc
s , uc is the cutoff frequency
Bandpass
s2 þ u2
0
sW
, u0
uluh
p
, W
uh
ul
Bandstop
sW
s2 þ u2
0
, u0
uluh
p
, W
uh
ul
306
CHAPTER 8 Inﬁnite Impulse Response Filter Design

The MATLAB function freqs() can be used to plot analog ﬁlter frequency responses for veriﬁ-
cation with the following syntax:
H
freqs(B, A, W)
B ¼ the vector containing the numerator coefﬁcients
A ¼ the vector containing the denominator coefﬁcients
W¼ the vector containing the speciﬁed analog frequency points (radians per second)
H ¼ the vector containing the frequency response
The following example veriﬁes the lowpass prototype transformation.
EXAMPLE 8.2
Given a lowpass prototype
HPðsÞ
1
s þ 1
determine each of the following analog ﬁlters and plot their magnitude responses from 0 to 200 radians per
second.
a. A highpass ﬁlter with a cutoff frequency of 40 radians per second.
b. A bandpass ﬁlter with a center frequency of 100 radians per second and bandwidth of 20 radians per second.
Solution:
a. Applying the lowpass prototype transformation by substituting s
40/s into the lowpass prototype, we obtain
an analog highpass ﬁlter:
HHPðsÞ
1
40
s þ 1
s
s þ 40
b. Similarly, substituting the lowpass to bandpass transformation s
ðs2 þ 100Þ=ð20sÞ into the lowpass
prototype leads to
HBPðsÞ
1
s2 þ 100
20s
þ 1
20s
s2 þ 20s þ 100
The program for plotting the magnitude responses for the highpass ﬁlter and bandpass ﬁlter is shown in
Program 8.1, and Figure 8.6 displays the magnitude responses for the highpass ﬁlter and bandpass ﬁlter,
respectively.
Program 8.1 MATLAB program in Example 8.2.
W 0:1:200;
% Analog frequency points for computing the
%filter gains
Ha freqs([1 0],[1 40],W);
% Frequency response for the highpass filter
Hb freqs([20 0],[1 20 100],W);
%Frequency response for the bandpass filter
subplot(2,1,1);plot(W, abs(Ha),’k’); grid
% The filter gain plot for highpass filter
xlabel(’(a) Frequency (radians per second)’)
ylabel(’Absolute ﬁlter gain’);
subplot(2,1,2);plot(W,abs(Hb),’k’);grid
% The filter gain plot for bandpass filter
xlabel(’(b) Frequency (radians per second)’)
ylabel(’Absolute ﬁlter gain’);
8.2 Bilinear Transformation Design Method
307

Figure 8.6 conﬁrms the transformation of the lowpass prototype into a highpass ﬁlter and a bandpass
ﬁlter, respectively. To obtain the transfer function of an analog ﬁlter, we always begin with the lowpass
prototype and apply the corresponding lowpass prototype transformation. To transfer from a lowpass prototype
to a bandpass or bandstop ﬁlter, the resultant order of the analog ﬁlter is twice that of the lowpass prototype
order.
8.2.2 Bilinear Transformation and Frequency Warping
In this subsection, we develop the BLT, which converts an analog ﬁlter to a digital ﬁlter. We begin by
ﬁnding the area under a curve using the integration of calculus and the numerical recursive method.
The area under the curve is a common problem in early calculus courses. As shown in Figure 8.7, the
area under the curve can be determined using the following integration:
yðtÞ ¼
Zt
0
xðtÞdt
(8.5)
where yðtÞ (area under the curve) and xðtÞ (curve function) are the output and input of the analog
integrator, respectively, and t is the upper limit of the integration.
0
20
40
60
80
100
120
140
160
180
200
0
0.5
1
(b) Frequency (radians per second)
Abso ute f ter ga n
0
20
40
60
80
100
120
140
160
180
200
0
0.5
1
(a) Frequency (radians per second)
Abso ute f ter ga n
FIGURE 8.6
Magnitude responses for the analog highpass ﬁlter and bandpass ﬁlter in Example 8.2.
308
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Applying the Laplace transform on Equation (8.5), we have
YðsÞ ¼ XðsÞ
s
(8.6)
and ﬁnd that the Laplace transfer function is
GðsÞ ¼ YðsÞ
XðsÞ ¼ 1
s
(8.7)
Now we examine the numerical integration method shown in Figure 8.7 to approximate the integration
of Equation (8.5) using the following difference equation:
yðnÞ ¼ yðn  1Þ þ xðnÞ þ xðn  1Þ
2
T
(8.8)
where T denotes the sampling period. yðnÞ ¼ yðnTÞ is the output sample that represents the whole area
under the curve,while yðn  1Þ ¼ yðnT  TÞ isthepreviousoutputsamplefromtheintegratorindicating
the previously computed area under the curve (the shaded area in Figure 8.7). Notice that xðnÞ ¼ xðnTÞ
and xðn  1Þ ¼ xðnT  TÞ, sample amplitudes from the curve, are the current input sample and the
previous input sample in Equation (8.8). Applying the z-transform on both sides of Equation (8.8) leads to
Y

z

¼ z 1Y

z

þ T
2

X

z

þ z 1X

z

Solving for the ratio of YðzÞ=XðzÞ, we obtain the z-transfer function as
HðzÞ ¼ YðzÞ
XðzÞ ¼ T
2
1 þ z 1
1  z 1
(8.9)
Next, comparing Equation (8.9) with Equation (8.7), it follows that
1
s ¼ T
2
1 þ z 1
1  z 1 ¼ T
2
z þ 1
z  1
(8.10)
Solving for s in Equation (8.10) gives the bilinear transformation
s ¼ 2
T
z  1
z þ 1
(8.11)
t
x n
(
)
1
x n
( )
nT
(
)
n
T
1
T
0
x t( )
y n
( )
y n
(
)1
FIGURE 8.7
Digital integration method to calculate the area under the curve.
8.2 Bilinear Transformation Design Method
309

The BLT method is a mapping or transformation of points on the s-plane to the z-plane. Equation
(8.11) can be alternatively written as
z ¼ 1 þ sT=2
1  sT=2
(8.12)
The general mapping properties are summarized as following:
1. The left-half s-plane is mapped onto the inside of the unit circle of the z-plane.
2. The right-half s-plane is mapped into the outside of the unit circle of the z-plane.
3. The positive ju axis portion in the s-plane is mapped onto the positive half circle (the dashed line
arrow in Figure 8.8) on the unit circle, while the negative ju axis is mapped onto the negative half
circle (the dotted line arrow in Figure 8.8) on the unit circle.
To verify these features, let us look at the following illustrative example.
EXAMPLE 8.3
Assume that T
2 seconds in Equation (8.12), and that the following points are given:
1. s
1 þ j, on the left half of the s plane
2. s
1
j, on the right half of the s plane
3. s
j, on the positive ju on the s plane
4. s
j, on the negative ju on the s plane
Convert each of the points in the s plane to the z plane, and verify mapping properties (1) to (3).
Solution:
Substituting T
2 into Equation (8.12) leads to
z
1 þ s
1
s
We can carry out mapping for each point as follows:
1.
z
1 þ ð 1 þ jÞ
1
ð 1 þ jÞ
j
2
j
1:90

5
p
:
26:57

0:4472:116:57
,
j
Re( )z
Im( )z
Stable Region
Stable Region
1
0
0
FIGURE 8.8
Mapping between the s-plane and the z-plane by the bilinear transformation.
310
CHAPTER 8 Inﬁnite Impulse Response Filter Design

since jzj
0:4472 < 1, which is inside the unit circle on the z plane.
2. z
1 þ ð1
jÞ
1
ð1
jÞ
2
j
j
5
p
:
26:57
1:90
2:2361:
116:57,
since jzj
2:2361 > 1, which is outside the unit circle on the z plane.
3. z
1 þ j
1
j
2
p
:45
2
p
:
45
1:90,
since jzj
1 and q
90, which is on the positive half circle on the unit circle on the z plane.
4. z
1
j
1
ð jÞ
1
j
1 þ j
2
p
:
45
2
p
:45
1:
90,
since jzj
1 and q
90
, which is on the negative half circle on the unit circle on the z plane.
As shown in Example (8.3), the BLT offers convertion of an analog transfer function to a digital
transfer function. Example (8.4) shows how to perform the BLT.
EXAMPLE 8.4
Given an analog ﬁlter whose transfer function is
HðsÞ
10
s þ 10
convert it to the digital ﬁlter transfer function and difference equation, respectively, when the sampling period is
given as T
0:01 second.
Solution:
Applying the BLT, we have
HðzÞ
HðsÞjs
2
T
z
1
zþ1
10
s þ 10

s
2
T
z
1
zþ1
Substituting T
0:01, it follows that
HðzÞ
10
200ðz
1Þ
z þ 1
þ 10
0:05
z
1
z þ 1 þ 0:05
0:05ðz þ 1Þ
z
1 þ 0:05ðz þ 1Þ
0:05z þ 0:05
1:05z
0:95:
Finally, we get
HðzÞ
ð0:05z þ 0:05Þ=ð1:05zÞ
ð1:05z
0:95Þ=ð1:05zÞ
0:0476 þ 0:0476z1
1
0:9048z1
:
Applying the technique from Chapter 6, we obtain the difference equation as
yðnÞ
0:0476xðnÞ þ 0:0476xðn
1Þ þ 0:9048yðn
1Þ:
8.2 Bilinear Transformation Design Method
311

Next, we examine frequency mapping between the s-plane and the z-plane. As illustrated in
Figure 8.9, the analog frequency ua is marked on the ju -axis on the s-plane, whereas ud is the digital
frequency labeled on the unit circle in the z-plane.
We substitute s ¼ jwa and z ¼ ejuT into the bilinear transformation in Equation (8.11) to get
jua ¼ 2
T
ejudT  1
ejudT þ 1
(8.13)
Simplifying Equation (8.13) leads to
ua ¼ 2
T tan
udT
2

(8.14)
Equation (8.14) explores the relation between the analog frequency on the ju axis and the corre-
sponding digital frequency ud on the unit circle. We can also write its inverse as
ud ¼ 2
T tan 1
uaT
2

(8.15)
The range of the digital frequency ud is from 0 radians per second to the folding frequency us=2
radians per second, where us is the sampling frequency in terms of radians per second. We present
a plot of Equation (8.14) in Figure 8.10.
From Figure 8.10, when the digital frequency range 0  ud  0:25us is mapped to the analog
frequency range 0  ua  0:32us, the transformation appears to be linear; however, when the
digital frequency range 0:25us  ud  0:5us is mapped to the analog frequency range for
ua > 0:32us, the transformation is nonlinear. The analog frequency range for ua > 0:32us is
compressed into the digital frequency range 0:25us  ud  0:5us. This nonlinear frequency
mapping effect is called frequency warping. We must incorporate frequency warping into IIR ﬁlter
design.
The following example will illustrate the frequency warping effect in the BLT.
j
Re( )z
Im( )z
1
0
a
dT
1
z
0
FIGURE 8.9
Frequency mapping from the analog domain to the digital domain.
312
CHAPTER 8 Inﬁnite Impulse Response Filter Design

EXAMPLE 8.5
Assume the following analog frequencies:
ua
10 radians per second
ua
us=4
50p
157 radians per second
ua
us=2
100p
314 radians per second.
Find their digital frequencies using the BLT with a sampling period of 0.01 second, given the analog ﬁlter in
Example 8.4 and the developed digital ﬁlter.
Solution:
From Equation (8.15), we can calculate digital frequency ud as follows:
When ua
10 radians per second and T
0:01 second
ud
2
T tan1
uaT
2

2
0:01 tan1
10  0:01
2

9:99 rad=sec
which is close to the analog frequency of 10 radians per second. When ua
157 rad/sec and T
0:01 second
ud
2
0:01 tan1
157  0:01
2

133:11 rad=sec
which is somewhat off as compared with the desired value 157. When ua
314 rad/sec and T
0:01 second,
ud
2
0:01 tan1
314  0:01
2

252:5 rad=sec
which is signiﬁcantly different than the digital folding frequency of 314 radians per second.
Figure 8.11 shows how to correct the frequency warping error. First, given the digital frequency
speciﬁcation, we prewarp the digital frequency speciﬁcation to the analog frequency speciﬁcation by
Equation (8.14).
Second, we obtain the analog lowpass ﬁlter HðsÞ using the prewarped analog frequency ua and the
lowpass prototype. For the lowpass analog ﬁlter, we have
0
a
d
0 25
.
s
0 32
.
s
0 4.
s
s
05.
s
( / )
r s
( / )
r
s
FIGURE 8.10
Frequency warping from bilinear transformation.
8.2 Bilinear Transformation Design Method
313

HðsÞ ¼ HPðsÞjs¼ s
ua ¼ HP
 s
ua

(8.16)
Finally, substituting the BLT Equation (8.11) into Equation (8.16) yields the digital ﬁlter:
H

z

¼ HðsÞjs¼ 2
T
z 1
zþ1
(8.17)
This approach can be similarly extended to other types of ﬁlter design.
8.2.3 Bilinear Transformation Design Procedure
Now we can summarize the BLT design procedure.
1. Given the digital ﬁlter frequency speciﬁcations, prewarp the digital frequency speciﬁcations to the
analog frequency speciﬁcations.
For the lowpass ﬁlter and highpass ﬁlter:
ua ¼ 2
T tan
udT
2

(8.18)
0
a
d
05.
s
( / )
r s
( / )
r
s
Digtal lowpass filter
specification
d
a
Analog lowpass filter specification
a
d
T
T
2
2
tan
Frequency prewarping
v
1
H
s
P( )
H s( )
H z( )
s
s
a
/
s
T
z
z
2
1
1
Analog lowpass prototype
Step 1
Step 2
Step 3
Bilinear transformation
FIGURE 8.11
Graphical representation of IIR ﬁlter design using the bilinear transformation.
314
CHAPTER 8 Inﬁnite Impulse Response Filter Design

For the bandpass ﬁlter and bandstop ﬁlter :
ual ¼ 2
T tan
ulT
2

; uah ¼ 2
T tan
uhT
2

(8.19)
and u0 ¼
ualuah
p
, W ¼ uah  ual
2. Perform the prototype transformation using the lowpass prototype HPðsÞ.
From lowpass to lowpass: HðsÞ ¼ HPðsÞjs ¼ s
ua
(8.20)
From lowpass to highpass: HðsÞ ¼ HPðsÞjs ¼ ua
s
(8.21)
From lowpass to bandpass: HðsÞ ¼ HPðsÞj
s ¼
s2þu2
0
sW
(8.22)
From lowpass to bandstop: HðsÞ ¼ HPðsÞj
s ¼
sW
s2þu2
0
(8.23)
3. Substitute the BLT to obtain the digital ﬁlter
HðzÞ ¼ HðsÞjs ¼ 2
T
z 1
zþ1
(8.24)
Table 8.2 lists MATLAB functions for the BLT design.
We illustrate the lowpass ﬁlter design procedure in Example (8.6). Other types of ﬁlters, such as
highpass, bandpass, and bandstop, will be illustrated in the next section.
EXAMPLE 8.6
The normalized lowpass ﬁlter with a cutoff frequency of 1 rad/sec is given as
HPðsÞ
1
s þ 1
a. Use the given HPðsÞ and the BLT to design a corresponding digital IIR lowpass ﬁlter with a cutoff frequency of
15 Hz and a sampling rate of 90 Hz.
b. Use MATLAB to plot the magnitude response and phase response of HðzÞ.
Solution:
a. First, we obtain the digital frequency as
ud
2pf
2pð15Þ
30p radians=second;
and
T
1=fs
1=90 sec
We then follow the design procedure:
1. First calculate the prewarped analog frequency as
8.2 Bilinear Transformation Design Method
315

ua
2
T tan
udT
2

2
1=90 tan
30p=90
2

that is, ua
180  tanðp=6Þ
180  tanð30Þ
103:92 rad/sec.
2. Then perform the prototype transformation (lowpass to lowpass) as follows:
HðsÞ
HPðsÞjs
s
ua
1
s
ua
þ 1
ua
s þ ua
This yields an analog ﬁlter:
HðsÞ
103:92
s þ 103:92
3. Apply the BLT, which yields
HðzÞ
103:92
s þ 103:92

s
2
T
z
1
zþ1
Table 8.2 MATLAB Functions for Bilinear Transformation Design
Lowpass to lowpass: HðsÞ
HPðsÞj
s
s
ua
>>[B, A][lp2lp(Bp, Ap, wa)
Lowpass to highpass: HðsÞ
HPðsÞj
s
ua
s
>>[B, A][lp2hp(Bp, Ap, wa)
Lowpass to bandpass: HðsÞ
HPðsÞj
s
s2þu2
0
sW
>>[B, A][lp2bp(Bp, Ap, w0, W)
Lowpass to bandstop: HðsÞ
HPðsÞj
s
sW
s2þu2
0
>>[B, A][lp2bs(Bp, Ap, w0, W)
Bilinear transformation to achieve the digital ﬁlter:
>>[b, a][bilinear(B, A, fs)
Plot of the magnitude and phase frequency responses of the digital ﬁlter:
>>freqz(b, a, 512, fs)
Deﬁnitions of design parameters:
Bp
vector containing the numerator coefﬁcients of the lowpass prototype
Ap
vector containing the denominator coefﬁcients of the lowpass prototype
wa
cutoff frequency for the lowpass or highpass analog ﬁlter (rad/sec)
w0
center frequency for the bandpass or bandstop analog ﬁlter (rad/sec)
W
bandwidth for the bandpass or bandstop analog ﬁlter (rad/sec)
B
vector containing the numerator coefﬁcients of the analog ﬁlter
A
vector containing the denominator coefﬁcients of the analog ﬁlter
b
vector containing the numerator coefﬁcients of the digital ﬁlter
a
vector containing the denominator coefﬁcients of the digital ﬁlter
fs
sampling rate (samples/sec)
316
CHAPTER 8 Inﬁnite Impulse Response Filter Design

We simplify the algebra by dividing both the numerator and the denominator by 180:
HðzÞ
103:92
180  z
1
z þ 1 þ 103:92
103:92=180
z
1
z þ 1 þ 103:92=180
0:5773
z
1
z þ 1 þ 0:5773
Then we multiply both numerator and denominator by ðz þ 1Þ to obtain
HðzÞ
0:5773ðz þ 1Þ
z
1
z þ 1 þ 0:5773

z þ 1

0:5773z þ 0:5773
ðz
1Þ þ 0:5773ðz þ 1Þ
0:5773z þ 0:5773
1:5773z
0:4227
Finally, we divide both numerator and denominator by 1:5773z to get the transfer function in the standard
format:
HðzÞ
ð0:5773z þ 0:5773Þ=ð1:5773zÞ
ð1:5773z
0:4227Þ=ð1:5773zÞ
0:3660 þ 0:3660z1
1
0:2679z1
b. The corresponding MATLAB design is listed in Program 8.2. Figure 8.12 shows the magnitude and phase
frequency responses.
Program 8.2. MATLAB program for Example 8.6.
%Example 8.6
% Plot the magnitude and phase responses
fs 90;
% Sampling rate (Hz)
0
5
10
15
20
25
30
35
40
45
0
0.5
1
Frequency (Hz)
Magn tude response
0
5
10
15
20
25
30
35
40
45
100
80
60
40
20
0
Frequency (Hz)
Phase (degrees)
FIGURE 8.12
Frequency responses of the designed digital ﬁlter for Example 8.6.
8.2 Bilinear Transformation Design Method
317

[B, A][lp2lp([1],[1 1],103.92);
[b,a][bilinear(B,A,fs)
% b
[0.3660 0.3660] numerator coefficients of the digital filter from MATLAB
% a
[1
0.2679]
denominator coefficients of the digital filter from MATLAB
[hz, f]
freqz([0.3660 0.3660],[1
0.2679],512,fs); % Frequency response
phi
180*unwrap(angle(hz))/pi;
subplot(2,1,1), plot(f, abs(hz)),grid;
axis([0 fs/2 0 1]);
xlabel(’Frequency (Hz)’); ylabel(’Magnitude Response’)
subplot(2,1,2), plot(f, phi); grid;
axis([0 fs/2
100 0]);
xlabel(’Frequency (Hz)’); ylabel(’Phase (degrees)’)
8.3 DIGITAL BUTTERWORTH AND CHEBYSHEV FILTER DESIGNS
In this section, we design various types of digital Butterworth and Chebyshev ﬁlters using the BLT
design method developed in the previous section.
8.3.1 Lowpass Prototype Function and Its Order
As described in Section 8.2, BLT design requires obtaining the analog ﬁlter with prewarped frequency
speciﬁcations. These analog ﬁlter design requirements include the ripple speciﬁcation at the passband
frequency edge, the attenuation speciﬁcation at the stopband frequency edge, and the type of lowpass
prototype (which we shall discuss) and its order.
Table 8.3 lists the Butterworth prototype functions with 3 dB passband ripple speciﬁcation. Tables
8.4 and 8.5 contain the Chebyshev prototype functions (type I) with 1 dB and 0.5 dB passband ripple
speciﬁcations, respectively. Other lowpass prototypes with different ripple speciﬁcations and orders
can be computed using the methods described in Appendix C.
In this section, we will focus on the Chebyshev type I ﬁlter. The Chebyshev type II ﬁlter design can
be found in Proakis and Manolakis (1996) and Porat (1997).
The magnitude response function of the Butterworth lowpass prototype with order n is
shown in Figure 8.13, where the magnitude response jHPðvÞj versus the normalized frequency v is
given by
jHPðvÞj ¼
1
1 þ ε2v2n
p
(8.25)
With the given passband ripple AP dB at the normalized passband frequency edge vp ¼ 1, and the
stopband attenuation As dB at the normalized stopband frequency edge vs, the following two equations
must be satisﬁed to determine the prototype ﬁlter order:
AP dB ¼ 20$log10

1
1 þ ε2
p

(8.26)
318
CHAPTER 8 Inﬁnite Impulse Response Filter Design

As dB ¼ 20$log10
 
1
1 þ ε2v2n
s
p
!
(8.27)
Solving Equations (8.26) and (8.27), we determine the lowpass prototype order as
ε2 ¼ 100:1Ap  1
(8.28)
Table 8.4 Chebyshev Lowpass Prototype Transfer Functions with 0.5 dB Ripple ( ε ¼ 0:3493)
n
HPðsÞ
1
2:8628
s þ 2:8628
2
1:4314
s2 þ 1:4256s þ 1:5162
3
0:7157
s3 þ 1:2529s2 þ 1:5349s þ 0:7157
4
0:3579
s4 þ 1:1974s3 þ 1:7169s2 þ 1:0255s þ 0:3791
5
0:1789
s5 þ 1:1725s4 þ 1:9374s3 þ 1:3096s2 þ 0:7525s þ 0:1789
6
0:0895
s6 þ 1:1592s5 þ 2:1718s4 þ 1:5898s3 þ 1:1719s2 þ 0:4324s þ 0:0948
Table 8.3 3-dB Butterworth Lowpass Prototype Transfer Functions ( ε ¼ 1)
n
HPðsÞ
1
1
s þ 1
2
1
s2 þ 1:4142s þ 1
3
1
s3 þ 2s2 þ 2s þ 1
4
1
s4 þ 2:6131s3 þ 3:4142s2 þ 2:6131s þ 1
5
1
s5 þ 3:2361s4 þ 5:2361s3 þ 5:2361s2 þ 3:2361s þ 1
6
1
s6 þ 3:8637s5 þ 7:4641s4 þ 9:1416s3 þ 7:4641s2 þ 3:8637s þ 1
8.3 Digital Butterworth and Chebyshev Filter Designs
319

n 
log10
100:1As  1
ε2

½2$log10ðvsÞ
(8.29)
where ε is the absolute ripple speciﬁcation.
The magnitude response function of a Chebyshev lowpass prototype with order n is shown in
Figure 8.14, where the magnitude response jHPðvÞj versus the normalized frequency v is given by
jHPðvÞj ¼
1
1 þ ε2C2n

v

q
(8.30)
where
Cn

vs

¼ cosh

ncosh 1
vs
	
(8.31)
Table 8.5 Chebyshev Lowpass Prototype Transfer Functions with 1 dB Ripple ( ε ¼ 0:5088Þ
n
HPðsÞ
1
1:9652
s þ 1:9652
2
0:9826
s2 þ 1:0977s þ 1:1025
3
0:4913
s3 þ 0:9883s2 þ 1:2384s þ 0:4913
4
0:2456
s4 þ 0:9528s3 þ 1:4539s2 þ 0:7426s þ 0:2756
5
0:1228
s5 þ 0:9368s4 þ 1:6888s3 þ 0:9744s2 þ 0:5805s þ 0:1228
6
0:0614
s6 þ 0:9283s5 þ 1:9308s4 þ 1:20121s3 þ 0:9393s2 þ 0:3071s þ 0:0689
v
H
v
P( )
vp
1
1
n
1
n
2
n
3
0
1
1
2
vs
As
H
v
v
P
n
( )
1
1
2
2
FIGURE 8.13
Normalized Butterworth magnitude response function.
320
CHAPTER 8 Inﬁnite Impulse Response Filter Design

cosh 1
vs

¼ ln

vs þ
v2s  1
q

(8.32)
As shown in Figure 8.14, the magnitude response for the Chebyshev lowpass prototype with an odd-
numbered order begins with a ﬁlter DC gain of 1. In the case of a Chebyshev lowpass prototype with an
even-numbered order, the magnitude starts at a ﬁlter DC gain of 1=
1 þ ε2
p
. For both cases, the ﬁlter
gain at the normalized cutoff frequency vp ¼ 1 is 1=
1 þ ε2
p
.
Similarly, Equations (8.33) and (8.34) must be satisﬁed:
AP dB ¼ 20$log10

1
1 þ ε2
p

(8.33)
As dB ¼ 20$log10
0
B
@
1
1 þ ε2C2n

vs

q
1
C
A
(8.34)
The lowpass prototype order can be solved in Equation (8.35):
ε2 ¼ 100:1Ap  1
(8.35a)
n 
cosh 1

100:1As  1
ε2
0:5
cosh 1ðvsÞ
(8.35b)
where cosh 1ðxÞ ¼ lnðx þ
x2  1
p
Þ, ε is the absolute ripple parameter.
The normalized stopband frequency vs can be determined from the frequency speciﬁcations of
the analog ﬁlter in Table 8.6. Then the order of the lowpass prototype can be determined by
Equation (8.29) for the Butterworth function and Equation (8.35b) for the Chebyshev function.
Figure 8.15 gives frequency edge notations for analog lowpass and bandpass ﬁlters. The notations for
analog highpass and bandstop ﬁlters can be deﬁned correspondingly.
1
0
vp
1
v
n (odd)
1
1
2
H
v
P( )
vs
As
n (even)
H
v
C
v
P
n
( )
( )
1
1
2
2
Cn v
n
v
v
n
v
v
( )
cos
cos
( )
cosh
cosh
( )
1
1
1
1
FIGURE 8.14
Normalized Chebyshev magnitude response function.
8.3 Digital Butterworth and Chebyshev Filter Designs
321

8.3.2 Lowpass and Highpass Filter Design Examples
The following examples illustrate various designs for the Butterworth and Chebyshev lowpass and
highpass ﬁlters.
EXAMPLE 8.7
a. Design a digital lowpasss Butterworth ﬁlter with the following speciﬁcations:
1. 3 dB attenuation at the passband frequency of 1.5 kHz
2. 10 dB stopband attenuation at the frequency of 3 kHz
3. Sampling frequency at 8,000 Hz
b. Use MATLAB to plot the magnitude and phase responses.
Solution:
a. First, we obtain the digital frequencies in radians per second:
udp
2pf
2pð1500Þ
3; 000p rad/sec
Table 8.6 Conversion from Analog Filter Speciﬁcations to Lowpass Prototype Speciﬁcations
Analog Filter Speciﬁcations
Lowpass Prototype Speciﬁcations
Lowpass: uap, uas
vp
1, vs
uas=uap
Highpass: uap, uas
vp
1, vs
uap=uas
Bandpass: uapl, uaph, uasl, uash, u0
uapluaph
p
,
u0
uasluash
p
vp
1, vs
uash
uasl
uaph
uapl
Bandstop: uapl, uaph, uasl, uash, u0
uapluaph
p
,
u0
uasluash
p
vp
1, vs
uaph
uapl
uash
uasl
uap, passband frequency edge; uas, stopband frequency edge;
uapl, lower cutoff frequency in passband; uaph, upper cutoff frequency in passband;
uasl, lower cutoff frequency in stopband; uash, upper cutoff frequency in stopband;
u0, geometric center frequency.
ap
asl
H
j
LP(
)
H
j
BP (
)
0
0
apl
aph
0
ash
W
0
apl
aph
W
aph
apl
AP
AP
as
As
As
r
e
tlif s
s
a
p
d
n
a
B
r
e
tlif s
s
a
p
w
o
L
FIGURE 8.15
Speciﬁcations for analog lowpass and bandpass ﬁlters.
322
CHAPTER 8 Inﬁnite Impulse Response Filter Design

uds
2pf
2pð3; 000Þ
6; 000p rad/sec
T
1=fs
1=8; 000 sec
We then follow the design procedure steps
1. We apply the warping equation as follows:
uap
2
T tan
udT
2

16; 000  tan
3; 000p=8; 000
2

1:0691  104 rad=sec:
uas
2
T tan
udT
2

16; 000  tan
6; 000p=8; 000
2

3:8627  104 rad=sec:
We then ﬁnd the lowpass prototype speciﬁcations using Table 8.6 as follows:
vs
uas=uap
3:8627  104=

1:0691  104
3:6130 rad=s and As
10 dB
The ﬁlter order is computed as
ε2
100:13
1
1
n
log10

100:110
1

2$log10ð3:6130Þ
0:8553
2. Rounding n up, we choose n
1 for the lowpass prototype. From Table 8.3, we have
HP

s

1
s þ 1
Applying the prototype transformation (lowpass to lowpass) yields the analog ﬁlter
HðsÞ
HPðsÞ

s
uap
1
s
uap
þ 1
uap
s þ uap
1:0691  104
s þ 1:0691  104
3. Finally, using the BLT, we have
HðzÞ
1:0691  104
s þ 1:0691  104

s
16;000ðz1Þ=ðzþ1Þ
Substituting the BLT leads to
HðzÞ
1:0691  104

16; 000 z
1
z þ 1

þ 1:0691  104
To simply the algebra, we both numerator and denominator by 16,000 to get
HðzÞ
0:6682
z
1
z þ 1

þ 0:6682
8.3 Digital Butterworth and Chebyshev Filter Designs
323

Then multiplying ðz þ 1Þ on both numerator and denominator leads to
HðzÞ
0:6682ðz þ 1Þ
ðz
1Þ þ 0:6682ðz þ 1Þ
0:6682z þ 0:6682
1:6682z
0:3318
Dividing both numerator and denominator by ð1:6682$zÞ leads to
HðzÞ
0:4006 þ 0:4006z1
1
0:1989z1
b. Steps 2 and 3 can be carried out using MATLAB Program 8.3, as shown in the ﬁrst three lines of the MATLAB
code. Figure 8.16 describes the ﬁlter frequency responses.
Program 8.3. MATLAB program for Example 8.7.
% Example 8.7
% Design of the digital lowpass Butterworth filter
format long
fs 8000;
% Sampling rate
[B A] lp2lp([1],[1 1], 1.0691*10^4)
% Complete step 2
[b a] bilinear(B,A,fs)
% Complete step 3
% Plot the magnitude and phase responses jH(z)j
% b [0.4005 0.4005]; numerator coefficients from MATLAB
% a [1
0.1989]; denominator coefficients from MATLAB
freqz(b,a,512,fs);
axis([0 fs/2
20 1])
0
500
1000
1500
2000
2500
3000
3500
4000
100
80
60
40
20
0
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
20
15
10
5
0
Frequency (Hertz)
Magn tude response (dB)
FIGURE 8.16
Frequency responses of the designed digital ﬁlter for Example 8.7.
324
CHAPTER 8 Inﬁnite Impulse Response Filter Design

EXAMPLE 8.8
a. Design a ﬁrst order highpass digital Chebyshev ﬁlter with a cutoff frequency of 3 kHz and 1 dB ripple on the
passband using a sampling frequency of 8,000 Hz.
b. Use MATLAB to plot the magnitude and phase responses.
Solution:
a. First, we obtain the digital frequency in radians per second:
ud
2pf
2pð3; 000Þ
6; 000p rad=sec;
and
T
1=fs
1=8; 000 sec
Following the steps of the design procedure, we have
1.
ua
2
T tan
udT
2

16; 000  tan
6; 000p=8; 000
2

3:8627  104 rad=sec
2. Since the ﬁlter order is given as 1, we select the ﬁrst order lowpass prototype from Table 8.5:
HPðsÞ
1:9625
s þ 1:9625
Applying the prototype transformation (lowpass to highpass), we obtain
HðsÞ
HPðsÞjua
s
1:9625
ua
s þ 1:9625
1:9625s
1:9625s þ 3:8627  104
Dividing both numerator and denominator by 1.9625 gives
HðsÞ
s
s þ 1:9683  104
3. Using the BLT, we have
HðzÞ
s
s þ 1:9683  104

s
16;000ðz1Þ=ðzþ1Þ
The algebra work proceeds as follows:
HðzÞ
16; 000 z
1
z þ 1
16; 000 z
1
z þ 1 þ 1:9683  104
Simplifying the transfer function yields
HðzÞ
0:4484
0:4484z1
1 þ 0:1032z1
b. Steps 2 and 3 and frequency response plots shown in Figure 8.17 can be carried out using MATLAB Program 8.4.
Program 8.4. MATLAB program for Example 8.8.
% Example 8.8
% Design of the digital highpass Butterworth filter
8.3 Digital Butterworth and Chebyshev Filter Designs
325

format long
fs 8000;
% Sampling rate
[B A] lp2hp([1.9625],[1 1.9625], 3.8627*10^4)
% Complete step 2
[b a] bilinear(B,A,fs)
% Complete step 3
% Plot the magnitude and phase responses jH(z)j
% b [0.4484
0.4484 ]; numerator coefficients from MATLAB
% a [1 0.1032]; denominator coefficients from MATLAB
freqz(b,a,512,fs);
axis([0 fs/2
40 2])
EXAMPLE 8.9
a. Design a second order lowpass digital Butterworth ﬁlter with a cutoff frequency of 3.4 kHz at a sampling
frequency of 8,000 Hz.
b. Use MATLAB to plot the magnitude and phase responses.
Solution:
a. First, we obtain the digital frequency in radians per second:
ud
2pf
2pð3; 400Þ
6; 800p rad=sec;
and
T
1=fs
1=8; 000 sec
0
500
1000
1500
2000
2500
3000
3500
4000
0
50
100
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
40
30
20
10
0
Frequency (Hertz)
Magn tude response (dB)
FIGURE 8.17
Frequency responses of the designed digital ﬁlter for Example 8.8.
326
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Following the steps of the design procedure, we compute the prewarped analog frequencies as
1.
ua
2
T tan
udT
2

16; 000  tan
6; 800p=8; 000
2

6:6645  104 rad=sec
2. Since the order of 2 is given in the speciﬁcation, we directly pick the second order lowpass prototype from
Table 8.3:
HPðsÞ
1
s2 þ 1:4142s þ 1
After applying the prototype transformation (lowpass to lowpass), we have
HðsÞ
HPðsÞj s
ua
4:4416  109
s2 þ 9:4249  104s þ 4:4416  109
3. Carrying out the BLT yields
HðzÞ
4:4416  109
s2 þ 9:4249  104s þ 4:4416  109

s
16;000ðz1Þ=ðzþ1Þ
Algebra work yields the following:
HðzÞ
4:4416  109

16; 000 z
1
z þ 1
2
þ9:4249  104

16; 000 z
1
z þ 1

þ 4:4416  109
To simplify, we divide both numerator and denominator by ð16; 000Þ2 to get
HðzÞ
17:35
z
1
z þ 1
2
þ5:8906
z
1
z þ 1

þ 17:35
Then multiplying both numerator and denominator by ðz þ 1Þ2 leads to
HðzÞ
17:35ðz þ 1Þ2
ðz
1Þ2þ5:8906ðz
1Þðz þ 1Þ þ 17:35ðz þ 1Þ2
Using identities, we have
HðzÞ
17:35

z2 þ 2z þ 1


z2
2z þ 1

þ 5:8906

z2
1

þ 17:35

z2 þ 2z þ 1

17:35z2 þ 34:7z þ 17:35
24:2406z2 þ 32:7z þ 12:4594
Dividing both numerator and denominator by ð24:2406z2Þ leads to
HðzÞ
0:7157 þ 1:4314z1 þ 0:7151z2
1 þ 1:3490z1 þ 0:5140z2
b. Steps 2 and 3 require a certain amount of algebra work and can be veriﬁed using MATLAB Program 8.5, as
shown in the ﬁrst three lines of the code. Figure 8.18 plots the ﬁlter magnitude and phase frequency
responses.
8.3 Digital Butterworth and Chebyshev Filter Designs
327

Program 8.5. MATLAB program for Example 8.9.
% Example 8.9
% Design of the digital lowpass Butterworth filter
format long
fs 8000;
% Sampling rate
[B A] lp2lp([1],[1 1.4142 1], 6.6645*10^4)
% Complete step 2
[b a] bilinear(B,A,fs)
% Complete step 3
% Plot the magnitude and phase responses jH(z)j
% b [0.7157 1.4315 0.7157]; numerator coefficients from MATLAB
%a [1 1.3490 0.5140]; denominator coefficients from MATLAB
freqz(b,a,512,fs);
axis([0 fs/2
40 10])
EXAMPLE 8.10
a. Design a highpass digital Chebyshev ﬁlter with the following speciﬁcations:
1. 0.5 dB ripple on the passband at a frequency of 3,000 Hz
2. 25 dB attenuation at a frequency of 1,000 Hz
3. Sampling frequency at 8,000 Hz.
b. Use MATLAB to plot the magnitude and phase responses.
0
500
1000
1500
2000
2500
3000
3500
4000
200
150
100
50
0
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
40
30
20
10
0
10
Frequency (Hertz)
Magn tude Response (dB)
FIGURE 8.18
Frequency responses of the designed digital ﬁlter for Example 8.9.
328
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Solution:
a. From the speciﬁcations, the digital frequencies are
udp
2pf
2pð3; 000Þ
6; 000p rad/sec
uds
2pf
2pð1; 000Þ
2; 000p rad/sec
and T
1=fs
1=8; 000 sec
Using the design procedure, it follows that
uap
2
T tan
udpT
2

16; 000  tan
6; 000p=8; 000
2

3:8627  104 rad=sec
uas
16; 000  tan
udsT
2

16; 000  tan
2; 000p=8; 000
2

6:6274  103 rad=sec
We ﬁnd the lowpass prototype speciﬁcation as follows:
vs
ups=usp
3:8627  104=6:6274  103
5:8284 rad=s and As
25 dB
Then the ﬁlter order is computed as
ε2
100:10:5
1
0:1220

100:125
1
.
0:1220
2; 583:8341
n
cosh1h
ð2; 583:8341Þ0:5i
cosh1
5:8284

ln

50:8314 þ
50:83142
1
p

ln

5:8284 þ
5:82842
1
p

1:8875
We select n
2 for the lowpass prototype function. Following the steps of the design procedure, it follows that
1.
up
3:8627  104 rad=sec
2. Performing the prototype transformation (lowpass to lowpass) using the prototype ﬁlter in Table 8.4, we have
HPðsÞ
1:4314
s2 þ 1:4256s þ 1:5162 and
HðsÞ
HPðsÞj s
ua
1:4314
up
s
2
þ1:4256
up
s

þ 1:5162
0:9441s2
s2 þ 3:6319  104s þ 9:8407  108
3. Applying the BLT, we convert the analog ﬁlter to the digital ﬁlter as follows:
HðzÞ
0:9441s2
s2 þ 3:6319  104s þ 9:8407  108

s
16;000ðz1Þ=ðzþ1Þ
8.3 Digital Butterworth and Chebyshev Filter Designs
329

After algebra simpliﬁcation, it follows that
HðzÞ
0:1327
0:2654z1 þ 0:1327z2
1 þ 0:7996z1 þ 0:3618z2
b. MATLAB Program 8.6 is listed for this example, and frequency responses are given in Figure 8.19.
Program 8.6. MATLAB program for Example 8.10.
% Example 8.10
% Design of the digital lowpass Chebyshev filter
format long
fs 8000;
% Sampling rate
% BLT design
[B A] lp2hp([1.4314],[1 1.4256 1.5162], 3.8627*10^4) % Complete step 2
[b a] bilinear(B,A,fs)
% Complete step 3
% Plot the magnitude and phase responses jH(z)j
% b [0.1327
0.2654 0.1327]; numerator coefficients from MATLAB
% a [1 0.7996 0.3618]; denominator coefficients from MATLAB
freqz(b,a,512,fs);
axis([0 fs/2
40 10])
0
500
1000
1500
2000
2500
3000
3500
4000
0
50
100
150
200
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
40
30
20
10
0
10
Frequency (Hertz)
Magn tude response (dB)
FIGURE 8.19
Frequency responses of the designed digital ﬁlter for Example 8.10.
330
CHAPTER 8 Inﬁnite Impulse Response Filter Design

8.3.3 Bandpass and Bandstop Filter Design Examples
EXAMPLE 8.11
a. Design a second order digital bandpass Butterworth ﬁlter with the following speciﬁcations:
• upper cutoff frequency of 2.6 kHz
• lower cutoff frequency of 2.4 kHz
• sampling frequency of 8,000 Hz
b. Use MATLAB to plot the magnitude and phase responses.
Solution:
a. Let us ﬁnd the digital frequencies in radians per second:
uh
2pfh
2pð2600Þ
5; 200p rad/sec
ul
2pfl
2pð2400Þ
4; 800p rad/sec, and T
1=fs
1=8; 000 sec
Following the steps of the design procedure, we have the following:
1.
uah
2
T tan
uhT
2

16; 000  tan
5; 200p=8; 000
2

2:6110  104 rad=sec
ual
16; 000  tan
ulT
2

16; 000  tan

0:3p

2:2022  104 rad=sec
W
uah
ual
26; 110
22; 022
4; 088 rad=sec
u2
0
uah  ual
5:7499  108
2. We perform the prototype transformation (lowpass to bandpass) to obtain HðsÞ. From Table 8.3, we pick the
lowpass prototype with order 1 to produce the bandpass ﬁlter with order 2:
HP

s

1
s þ 1
Applying the lowpass to bandpass transformation, it follows that
HðsÞ
HPðsÞjs2þu2
0
sW
Ws
s2 þ Ws þ u2
0
4; 088s
s2 þ 4; 088s þ 5:7499  108
3. Hence we apply the BLT to yield
HðzÞ
4; 088s
s2 þ 4; 088s þ 5:7499  108

s
16;000ðz1Þ=ðzþ1Þ
Via algebra work, we obtain the digital ﬁlter as
HðzÞ
0:0730
0:0730z2
1 þ 0:7117z1 þ 0:8541z2
8.3 Digital Butterworth and Chebyshev Filter Designs
331

b. MATLAB Program 8.7 is given for this example, and the corresponding frequency response plots are illustrated
in Figure 8.20.
Program 8.7. MATLAB program for Example 8.11.
% Example 8.11
% Design of the digital bandpass Butterworth filter
format long
fs 8000;
[B A] lp2bp([1],[1 1],sqrt(5.7499*10^8),4088)
% Complete step 2
[b a] bilinear(B,A,fs)
% Complete step 3
% Plot the magnitude and phase responses jH(z)j
% b [0.0730 0
0.0730]; numerator coefficients from MATLAB
% a [1 0.7117 0.8541]; denominator coefficients form MATLAB
freqz(b, a,512,fs);
axis([0 fs/2
40 10])
EXAMPLE 8.12
Now let us examine the bandstop Butterworth ﬁlter design.
a. Design a digital bandstop Butterworth ﬁlter with the following speciﬁcations:
• Center frequency of 2.5 kHz
• Passband width of 200 Hz and ripple of 3dB
0
500
1000
1500
2000
2500
3000
3500
4000
100
50
0
50
100
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
40
30
20
10
0
10
Frequency (Hertz)
Magn tude response (dB)
FIGURE 8.20
Frequency responses of the designed digital ﬁlter for Example 8.11.
332
CHAPTER 8 Inﬁnite Impulse Response Filter Design

• Stopband width of 50 Hz and attenuation of 10 dB
• Sampling frequency of 8,000 Hz
b. Use MATLAB to plot the magnitude and phase responses.
Solution:
a. The digital frequencies of the digital ﬁlter are
uh
2pfh
2pð2; 600Þ
5; 200p rad/sec
ul
2pfl
2pð2; 400Þ
4; 800p rad/sec
ud0
2pf0
2pð2; 500Þ
5; 000p rad/sec, and T
1=fs
1=8; 000 sec
Applying the three steps of the IIR ﬁlter design approach, it follows that
1.
uah
2
T tan
uhT
2

16; 000  tan
5; 200p=8; 000
2

2:6110  104 rad=sec
ual
16; 000  tan
ulT
2

16; 000  tan

0:3p

2:2022  104 rad=sec
u0
16; 000  tan
ud0T
2

16; 000  tan

0:3125p

2:3946  104 rad=sec
ush
2
T tan
2; 525  2p=8; 000
2

16; 000  tan

56:81250
2:4462  104 rad=sec
usl
16; 000  tan
2; 475  2p=8; 000
2

16; 000  tan

55:68750
2:3444  104 rad=sec
To adjust the unit passband gain at the center frequency of 2,500 Hz, we perform the following:
Fixing ual
2:2022  104, we compute uah
u2
0=ual
ð2:3946  104Þ2
2:2022  104
2:6037  104
and the passband bandwidth: W
uah
ual
4; 015
Fixing usl
2:3444  104, ush
u2
0=usl
ð2:3946  104Þ2
2:3444  104
2:4459  104
and the stopband bandwidth: Ws
ush
usl
1; 015
Again, Fixing uah
2:6110  104, we got ual
u2
0=uah
ð2:3946  104Þ2
2:6110  104
2:1961  104
and the passband bandwidth: W
uah
ual
4; 149
Fixing ush
2:4462  104, usl
u2
0=ush
ð2:3946  104Þ2
2:4462  104
2:3441  104
and the stopband bandwidth: Ws
ush
usl
1; 021
For an aggressive bandstop design, we choose ual
2:6110  104, uah
2:1961  104, usl
2:3441  104,
ush
2:4462  104 and u0
2:3946  104 to satisfy a larger bandwidth.
Thus we develop the prototype speciﬁcation:
vs
ð26; 110
21; 916Þ=ð24; 462
23; 441Þ
4:0177
n
log10

100:110
1

2$log10ð4:0177Þ

0:7899; choose n
1
W
uah
ual
26; 110
21; 961
4; 149 rad=sec; u2
0
5:7341  108:
8.3 Digital Butterworth and Chebyshev Filter Designs
333

2. Then, carrying out the prototype transformation (lowpass to bandstop) using the ﬁrst order lowpass prototype
ﬁlter given by
HP

s

1
s þ 1
it follows that
HðsÞ
HPðsÞ

sW
s2þu2
0

s2 þ u2
0

s2 þ Ws þ u2
0
Substituting the values of u2
0 and W yields
HðsÞ
s2 þ 5:7341  108
s2 þ 4; 149s þ 5:7341  108
3. Hence, applying the BLT leads to
HðzÞ
s2 þ 5:7341  108
s2 þ 4; 149s þ 5:73411  108

s
16;000ðz1Þ=ðzþ1Þ
After algebra, we get
HðzÞ
0:9259 þ 0:7078z1 þ 0:9249z2
1 þ 0:7078z1 þ 0:8518z2
0
500
1000
1500
2000
2500
3000
3500
4000
100
50
0
50
100
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
40
30
20
10
0
10
Frequency (Hertz)
Magn tude response (dB)
FIGURE 8.21
Frequency responses of the designed digital ﬁlter for Example 8.12.
334
CHAPTER 8 Inﬁnite Impulse Response Filter Design

b. MATLAB Program 8.8 includes the design steps. Figure 8.21 shows the ﬁlter frequency responses.
Program 8.8. MATLAB program for Example 8.12.
% Example 8.12
% Design of the digital bandstop Butterworth filter
format long
fs 8000;
% Sampling rate
[B A] lp2bs([1],[1 1],sqrt(5.7341*10^8),4149) % Complete step 2
[b a] bilinear(B,A,fs)
% Complete step 3
% Plot the magnitude and phase responses jH(z)j
% b [0.9259 0.7078 0.9259]; numerator coefficients from MATLAB
% a [1 0.7078 0.8518]; denominator coefficients from MATLAB
freqz(b,a,512,fs);
axis([0 fs/2
40 10])
EXAMPLE 8.13
a. Design a digital bandpass Chebyshev ﬁlter with the following speciﬁcations:
• Center frequency of 2.5 kHz
• Passband bandwidth of 200 Hz, 0.5 dB ripple on passband
• Lower stop frequency of 1.5 kHz, upper stop frequency of 3.5 kHz
• Stopband attenuation of 10 dB
• Sampling frequency of 8,000 Hz
b. Use MATLAB to plot the magnitude and phase responses.
Solution:
a. The digital frequencies are given as
udph
2pfdph
2pð2; 600Þ
5; 200p rad/sec
udpl
2pfdpl
2pð2; 400Þ
4; 800p rad/sec
ud0
2pf0
2pð2; 500Þ
5; 000p rad/sec, and T
1=fs
1=8; 000 sec
Applying the frequency prewarping equation, it follows that
uaph
2
T tan
udT
2

16; 000  tan
5; 200p=8; 000
2

2:6110  104 rad=sec
uapl
16; 000  tan
udplT
2

16; 000  tan

0:3p

2:2022  104 rad=sec
u0
16; 000  tan
ud0T
2

16; 000  tan

0:3125p

2:3946  104 rad=sec
uash
16; 000  tan
3; 500  2p=8; 000
2

16; 000  tan

78:750
8:0437  104 rad=sec
8.3 Digital Butterworth and Chebyshev Filter Designs
335

uasl
16; 000  tan
1; 500  2p=8; 000
2

1:0691  104 rad=sec
Now, adjusting the unit gain for the center frequency of 2,500 Hz leads to the following:
Fixing uapl
2:2022  104, we have uaph
u2
0
uapl
ð2:3946  104Þ2
2:2022  104
2:6038  104
and the passband bandwidth: W
uaph
uapl
4; 016
Fixing uasl
1:0691  104, uash
u2
0
uasl
ð2:3946  104Þ2
2:10691  104
5:3635  104
and the stopband bandwidth: Ws
uash
uasl
42; 944
Again, ﬁxing uaph
2:6110  104, we have uapl
u2
0
uaph
ð2:3946  104Þ2
2:6110  104
2:1961  104
and the passband bandwidth: W
uaph
uapl
4; 149
Fixing uash
8:0437  104, uasl
u2
0
uash
ð2:3946  104Þ2
8:0437  104
0:7137  104
and the stopband bandwidth: Ws
uash
uasl
73; 300
For
an
aggressive
bandpass
design,
we
select
uapl
2:2022  104,
uaph
2:6038  104,
uasl
1:0691  104,
uash
5:3635  104 and for a smaller bandwidth for passband.
Thus, we obtain the prototype speciﬁcations:
vs
ð53; 635
10; 691Þ=ð26; 110
21; 961Þ
10:6932
ε2
100:10:5
1
0:1220

100:110
1
.
0:1220
73:7705
n
cosh1h
ð73:7705Þ0:5i
cosh1
10:6932

ln

8:5890 þ
8:58902
1
p

ln

10:6932 þ
10:69322
1
p

0:9280
Rounding up n leads to n
1.
Next, we apply the design steps:
1.
uaph
2:6038  104 rad=sec; uapl
2:2022  104 rad=sec
W
4; 016 rad=sec; u2
0
5:7341  108
2. Performing the prototype transformation (lowpass to bandpass), we obtain
HPðsÞ
2:8628
s þ 2:8628
and
HðsÞ
HPðsÞ

s
s2þu2
0
sW
2:8628Ws
s2 þ 2:8628Ws þ u2
0
1:1878  104s
s2 þ 1:1878  104s þ 5:7341  108
336
CHAPTER 8 Inﬁnite Impulse Response Filter Design

3. Applying the BLT, the analog ﬁlter is converted into a digital ﬁlter as follows:
HðzÞ
1:1878  104s
s2 þ 1:1878  104s þ 5:7341  108

s
16;000ðz1Þ=ðzþ1Þ
This is simpliﬁed and arranged as follows:
HðzÞ
0:1864
0:1864z2
1 þ 0:6227z1 þ 0:6272z2
b. Program 8.9 lists the MATLAB details. Figure 8.22 displays the frequency responses.
Program 8.9. MATLAB program for Example 8.13.
% Example 8.13
% Design of the digital bandpass Chebyshev filter
format long
fs 8000;
[B A] lp2bp([2.8628],[1 2.8628],sqrt(5.7341*10^8),4149) % Complete step 2
[b a] bilinear(B,A,fs)
% Complete step 3
% Plot the magnitude and phase responses jH(z)j
% b [0.1864 0.0
0.1864]; numerator coefficients from MATLAB
% a [1 0.6227 0.6272]; denominator coefficients from MATLAB
freqz(b,a,512,fs);
axis([0 fs/2
40 10])
0
500
1000
1500
2000
2500
3000
3500
4000
100
50
0
50
100
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
40
30
20
10
0
10
Frequency (Hertz)
Magn tude response (dB)
FIGURE 8.22
Frequency responses of the designed digital ﬁlter for Example 8.13.
8.3 Digital Butterworth and Chebyshev Filter Designs
337

8.4 HIGHER-ORDER INFINITE IMPULSE RESPONSE FILTER DESIGN USING
THE CASCADE METHOD
For higher order IIR ﬁlter design, use of a cascade transfer function is preferred. The factored forms for
the lowpass prototype transfer functions for Butterworth and Chebyshev ﬁlters are given in Tables 8.7,
8.8 and 8.9. A Butterworth ﬁlter design example will be provided and a similar procedure can be
adopted for the Chebyshev ﬁlters.
EXAMPLE 8.14
a. Design a fourth order digital lowpass Butterworth ﬁlter with a cutoff frequency of 2.5 kHz at a sampling
frequency of 8,000 Hz.
b. Use MATLAB to plot the magnitude and phase responses.
Table 8.7 3-dB Butterworth Prototype Functions in Cascade Form
n
HPðsÞ
3
1
ðs þ 1Þðs2 þ s þ 1Þ
4
1
ðs2 þ 0:7654s þ 1Þðs2 þ 1:8478s þ 1Þ
5
1
ðs þ 1Þðs2 þ 0:6180s þ 1Þðs2 þ 1:6180s þ 1Þ
6
1
ðs2 þ 0:5176s þ 1Þðs2 þ 1:4142s þ 1Þðs2 þ 1:9319s þ 1Þ
Table 8.8 Chebyshev Prototype Functions in Cascade Form with 0.5-dB Ripple ( ε ¼ 0:3493)
n
HPðsÞ 0.5-dB Ripple ( ε [ 0:3493)
3
0:7157
ðs þ 0:6265Þðs2 þ 0:6265s þ 1:1425Þ
4
0:3579
ðs2 þ 0:3507s þ 1:0635Þðs2 þ 0:8467s þ 0:3564Þ
5
0:1789
ðs þ 0:3623Þðs2 þ 0:2239s þ 1:0358Þðs2 þ 0:5862s þ 0:4768Þ
6
0:0895
ðs2 þ 0:1553s þ 1:0230Þðs2 þ 0:4243s þ 0:5900Þðs2 þ 0:5796s þ 0:1570Þ
338
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Solution:
a. First, we obtain the digital frequency in radians per second:
ud
2pf
2pð2; 500Þ
5; 000p rad=sec; and T
1=fs
1=8; 000 sec
Following the design steps, we compute the speciﬁcations for the analog ﬁlter.
1.
ua
2
T tan
udT
2

16; 000  tan
5; 000p=8; 000
2

2:3946  104 rad=sec
2. From Table 8.7, we obtain the fourth order factored prototype transfer function:
HPðsÞ
1

s2 þ 0:7654s þ 1

s2 þ 1:8478s þ 1

Applying the prototype transformation, we yield
HðsÞ
HPðsÞj s
ua
u2
a  u2
a

s2 þ 0:7654uas þ u2a

s2 þ 1:8478uas þ u2a

Substituting ua
2:3946  104 rad/sec yields
HðsÞ

5:7340  108


5:7340  108

s2 þ 1:8328s þ 5:7340  108
s2 þ 4:4247  104s þ 5:7340  108
3. Hence, after applying BLT, we have
HðzÞ

5:7340  108


5:7340  108

s2 þ 1:8328s þ 5:7340  108
s2 þ 4:4247  104s þ 5:7340  108

s
16;000ðz1Þ=ðzþ1Þ
After simplifying with algebra, we obtain the digital ﬁlter as
HðzÞ
0:5108 þ 1:0215z1 þ 0:5108z2
1 þ 0:5654z1 þ 0:4776z2
 0:3730 þ 0:7460z1 þ 0:3730z2
1 þ 0:4129z1 þ 0:0790z2
Table 8.9 Chebyshev Prototype Functions in Cascade Form with 1-dB Ripple ðε ¼ 0:5088Þ
n
HPðsÞ 1-dB Ripple ðε [ 0:5088Þ
3
0:4913
ðs þ 0:4942Þðs2 þ 0:4942s þ 0:9942Þ
4
0:2456
ðs2 þ 0:2791s þ 0:9865Þðs2 þ 0:6737s þ 0:2794Þ
5
0:1228
ðs þ 0:2895Þðs2 þ 0:1789s þ 0:9883Þðs2 þ 0:4684s þ 0:4293Þ
6
0:0614
ðs2 þ 0:1244s þ 0:9907Þðs2 þ 0:3398s þ 0:5577Þðs2 þ 0:4641s þ 0:1247Þ
8.4 Higher Order Inﬁnite Impulse Response Filter Design
339

b. A MATLAB program is preferable to carry out the algebra and is listed in Program 8.10. Figure 8.23 shows the
ﬁlter magnitude and phase frequency responses.
Program 8.10. MATLAB program for Example 8.14.
% Example 8.14
% Design of the fourth order digital lowpass Butterworth filter
% in the cascade form
format long
fs 8000;
% Sampling rate
[B1 A1] lp2lp([1],[1 0.7654 1], 2.3946*10^4) % Complete step 2
[b1 a1] bilinear(B1,A1,fs) % complete step 3
[B2 A2] lp2lp([1],[1 1.8478 1], 2.3946*10^4) % Complete step 2
[b2 a2] bilinear(B2,A2,fs) % complete step 3
% Plot the magnitude and phase responses jH(z)j
% b1 [0.5108 1.0215 0.5108]; a1 [1 0.5654 0.4776]; coefficients from MATLAB
% b2 [0.3730 0.7460 0.3730]; a2 [1 0.4129 0.0790]; coefficients from MATLAB
freqz(conv(b1,b2),conv(a1,a2),512,fs); % Combined filter responses
axis([0 fs/2
40 10]);
The higher-order bandpass, highpass and bandstop ﬁlters using the cascade form can be designed
similarly.
0
500
1000
1500
2000
2500
3000
3500
4000
400
300
200
100
0
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
40
30
20
10
0
10
Frequency (Hertz)
Magn tude response (dB)
FIGURE 8.23
Frequency responses of the designed digital ﬁlter for Example 8.14.
340
CHAPTER 8 Inﬁnite Impulse Response Filter Design

8.5 APPLICATION: DIGITAL AUDIO EQUALIZER
In this section, the design of a digital audio equalizer is introduced. For an audio application such as the
CD player, the digital audio equalizer is used to adjust the sound as one desires by changing ﬁlter gains
for different audio frequency bands. Other applications include adjusting the sound source to take
room acoustics into account, removing undesired noise, and boosting the desired signal in the speciﬁed
passband. The simulation is based on the consumer digital audio processor
such as a CD player
handling the 16-bit digital samples with a sampling rate of 44.1 kHz and an audio signal bandwidth at
22.05 kHz. A block diagram of the digital audio equalizer is depicted in Figure 8.24.
A seven-band audio equalizer is adopted for discussion. The center frequencies are listed in
Table 8.10. The 3-dB bandwidth for each bandpass ﬁlter is chosen to be 50% of the center frequency.
As shown in Figure 8.24, g0 through g6 are the digital gains for each banspass ﬁlter output and can be
adjusted to make sound effects, while y0ðnÞ through y6ðnÞ are the digital ampliﬁed bandpass ﬁlter
outputs. Finally, the equalized signal is the sum of the ampliﬁed bandpass ﬁlter outputs and itself. By
changing the digital gains of the equalizer, many sound effects can be produced.
x n
( )
y n
( )
g0
g1
g6
bandpass filter
bandpass filter
bandpass filter
x n
( )
y
n
0( )
y n
1( )
y
n
6( )
FIGURE 8.24
Simpliﬁed block diagram of the audio equalizer.
Table 8.10 Speciﬁcations for an Audio Equalizer
Center frequency (Hz)
100
200
400
1000
2500
6000
15000
Bandwidth (Hz)
50
100
200
500
1250
3000
7500
8.5 Application: Digital Audio Equalizer
341

To complete the design and simulation, second-order IIR bandpass Butterworth ﬁlters are chosen
for the audio equalizer; the coefﬁcients are determined using the BLT method, and are given in
Table 8.11.
The magnitude response for each ﬁlter bank is plotted in Figure 8.25 for design veriﬁcation. As
shown in Figure 8.25, after careful examination, the magnitude response of each ﬁlter band meets the
design speciﬁcation. We will perform simulation next.
Table 8.11 Designed Filter Banks
Filter Banks
Coefﬁcients for the Numerator
Coefﬁcients for the Denominator
Bandpass ﬁlter 0
0.0031954934, 0,
0.0031954934
1, 1.9934066716 , 0.9936090132
Bandpass ﬁlter 1
0.0063708102, 0,
0.0063708102
1,
1.9864516324, 0.9872583796
Bandpass ﬁlter 2
0.0126623878, 0,
0.0126623878
1,
1.9714693192, 0.9746752244
Bandpass ﬁlter 3
0.0310900413, 0,
0.0310900413
1,
1.9181849043, 0.9378199174
Bandpass ﬁlter 4
0.0746111954, 0,
0.0746111954
1,
1.7346085867, 0.8507776092
Bandpass ﬁlter 5
0.1663862883, 0,
0.1663862884
1,
1.0942477187, 0.6672274233
Bandpass ﬁlter 6
0.3354404899, 0,
0.3354404899
1, 0.7131366534, 0.3291190202
10
1
10
2
10
3
10
4
10
5
10
-6
10
-5
10
-4
10
-3
10
-2
10
-1
10
0
Frequency (Hz)
F ter ga n
FIGURE 8.25
Magnitude frequency responses for the audio equalizer.
342
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Simulation in the MATLAB environment is based on the following settings. The audio test signal
with frequency components of 100 Hz, 200 Hz, 400 Hz, 1,000 Hz, 2,500 Hz, 6,000 Hz, and 15,000 Hz
is generated from Equation (8.36):
xðnÞ ¼ sinð200pn=44;100Þ þ sinð400pn=44;100 þ p=14Þ
þ sinð800pn=44;100 þ p=7Þ þ sinð2; 000pn=44;100 þ 3p=14Þ
þ sinð5; 000pn=44;100 þ 2p=7Þ þ sinð12; 000pn=44;100 þ 5p=14Þ
þ sinð30; 000pn=44;100 þ 3p=7Þ
(8.36)
The gains set for the ﬁlter banks are
g0 ¼ 10; g1 ¼ 10; g2 ¼ 0; g3 ¼ 0; g4 ¼ 0; g5 ¼ 10; g6 ¼ 10
After simulation, we notice that the frequency components at 100 Hz, 200 Hz, 6,000 Hz, and
15,000 Hz will be boosted by 20$log1010 ¼ 20 dB. The top plot in Figure 8.26 shows the spectrum for
the audio test signal, while the bottom plot depicts the spectrum for the equalized audio test signal. As
shown in the plots, before audio digital equalization, the spectral peaks at all bands are at the same
level; after audio digital equalization, the frequency components at bank 0, bank 1, bank 5, and bank 6
are ampliﬁed. Therefore, as we expected, the operation of the digital equalizer boosts the low
10
1
10
2
10
3
10
4
10
5
10
0
Audio spectrum
10
1
10
2
10
3
10
4
10
5
10
0
Frequency (Hz)
Equalized audio spectrum
FIGURE 8.26
Audio spectrum and equalized audio spectrum.
8.5 Application: Digital Audio Equalizer
343

frequency components and the high frequency components. The MATLAB list for the simulation is
shown in Program 8.11.
Program 8.11. MATLAB program for the digital audio equalizer.
close all; clear all
% Filter Coefficients (Butterworth type designed using the BLT)
B0 [0.0031954934 0
0.0031954934]; A0 [1.0000000000
1.9934066716 0.9936090132];
B1 [0.0063708102 0
0.0063708102]; A1 [1.0000000000
1.9864516324 0.9872583796];
B2 [0.0126623878 0
0.0126623878]; A2 [1.0000000000
1.9714693192 0.9746752244];
B3 [0.0310900413 0
0.0310900413]; A3 [ 1.0000000000
1.9181849043 0.9378199174];
B4 [0.0746111954 0.000000000
0.0746111954];
A4 [1.0000000000
1.7346085867 0.8507776092];
B5 [0.1663862883 0.0000000000
0.1663862884];
A5 [1.0000000000
1.0942477187 0.6672274233];
B6 [0.3354404899 0.0000000000
0.3354404899];
A6 [1.0000000000 0.7131366534
0.3291190202];
[h0,f] freqz(B0,A0,2048,44100);
[h1,f] freqz(B1,A1,2048,44100);
[h2,f] freqz(B2,A2,2048,44100);
[h3,f] freqz(B3,A3,2048,44100);
[h4,f] freqz(B4,A4,2048,44100);
[h5,f] freqz(B5,A5,2048,44100);
[h6,f] freqz(B6,A6,2048,44100);
loglog(f,abs(h0),f,abs(h1), f,abs(h2), .
f,abs(h3),f,abs(h4),f,abs(h5),f,abs(h6));
xlabel(’Frequency (Hz)’);
ylabel(’Filter Gain’);grid
axis([10 10^5 10^( 6) 1]);
figure(2)
g0 10;g1 10;g2 0;g3 0;g4 0;g5 10;g6 10;
p0 0;p1 pi/14;p2 2*p1;p3 3*p1;p4 4*p1;p5 5*p1;p6 6*p1;
n 0:1:20480;
% Indices of samples
fs 44100;
% Sampling rate
x sin(2*pi*100*n/fs)þsin(2*pi*200*n/fsþp1)þ.
sin(2*pi*400*n/fsþp2)þsin(2*pi*1000*n/fsþp3)þ.
sin(2*pi*2500*n/fsþp4)þsin(2*pi*6000*n/fsþp5)þ.
sin(2*pi*15000*n/fsþp6);
% Generate test audio signals
y0 filter(B0,A0,x);
% Bandpass filter 0
y1 filter(B1,A1,x);
% Bandpass filter 1
y2 filter(B2,A2,x);
% Bandpass filter 2
y3 filter(B3,A3,x);
% Bandpass filter 3
y4 filter(B4,A4,x);
% Bandpass filter 4
y5 filter(B5,A5,x);
% Bandpass filter 5
y6 filter(B6,A6,x);
% Bandpass filter 6
y g0.*y0þg1.*y1þg2.*y2þg3.*y3þg4.*y4þg5.*y5þg6.*y6þx; % Equalizer output
N length(x);
Axk 2*abs(fft(x))/N;Axk(1) Axk(1)/2; % One sided amplitude spectrum of the input
f [0:N/2]*fs/N;
344
CHAPTER 8 Inﬁnite Impulse Response Filter Design

subplot(2,1,1);loglog(f,Axk(1:N/2þ1));
title(’Audio spectrum’);
axis([10 100000 0.00001 100]);grid;
Ayk 2*abs(fft(y))/N; Ayk(1) Ayk(1)/2; % One sided amplitude
% spectrum of the output
subplot(2,1,2);loglog(f,Ayk(1:N/2þ1));
xlabel(’Frequency (Hz)’);
title(’Equalized audio spectrum’);
axis([10 100000 0.00001 100]);grid;
8.6 IMPULSE-INVARIANT DESIGN METHOD
We illustrate the concept of the impulse-invariant design in Figure 8.27. Given the transfer function of
a designed analog ﬁlter, an analog impulse response can be easily found by the inverse Laplace
transform of the transfer function. To replace the analog ﬁlter by the equivalent digital ﬁlter, we apply
an approximation in the time domain in which the digital ﬁlter impulse response must be equivalent to
the analog impulse response. Therefore, we can sample the analog impulse response to get the digital
impulse response, and take the z-transform of the sampled analog impulse response to obtain the
transfer function of the digital ﬁlter.
The analog impulse response can be achieved by taking the inverse Laplace transform of the analog
ﬁlter HðsÞ, that is,
h

t

¼ L 1ðHðsÞÞ
(8.37)
Now, if we sample the analog impulse response with a sampling interval of T and use T as a scale
factor, it follows that
T$h

n

¼ T$hðtÞjt¼nT; n  0
(8.38)
H z( )
H s( )
ADC
n
( )
n
t
( )t
t
n
h t( )
h n
( )
X z( )
1
X s( )
1
h t
L
H s
( )
( )
1
( )
( ) t nT
T h n
T h t
H z
Z Th n
FIGURE 8.27
Impulse-invariant design method.
8.6 Impulse Invariant Design Method
345

Taking the z-transform on both sides of Equation (8.38) yields the digital ﬁlter as
HðzÞ ¼ Z½T$hðnÞ
(8.39)
The effect of the scale factor T in Equation (8.38) can be explained as follows. We approximate the
area under the curve speciﬁed by the analog impulse function hðtÞ using a digital sum given by
area ¼
ZN
0
hðtÞdt z T$hð0Þ þ T$hð1Þ þ T$hð2Þ þ /
(8.40)
Note that the area under the curve indicates the DC gain of the analog ﬁlter while the digital sum in
Equation (8.40) is the DC gain of the digital ﬁlter.
The rectangular approximation is used, since each sample amplitude is multiplied by the sampling
interval T. Due to the interval size for approximation in practice, we cannot guarantee that the digital
sum has exactly the same value as the one from the integration unless the sampling interval T in
Equation (8.40) approaches zero. This means that the higher the sampling rate
that is, the smaller the
sampling interval
the more accurately the digital ﬁlter gain matches the analog ﬁlter gain. Hence, in
practice, we need to further apply gain scaling for adjustment if it is a requirement.
EXAMPLE 8.15
Consider the following Laplace transfer function:
HðsÞ
2
s þ 2
a. Determine HðzÞ using the impulse invariant method if the sampling rate fs
10 Hz.
b. Use MATLAB to plot the following:
1. The magnitude response jHðfÞj and phase response 4ðfÞ with respect to HðsÞ for the
frequency range from 0 to fs=2 Hz;
2. The magnitude response
HðejUÞ

jHðej2pfT Þj and phase response 4ðfÞ with respect to HðzÞ for the
frequency range from 0 to fs=2 Hz.
Solution:
a. Taking the inverse Laplace transform of the analog transfer function, the impulse response is found to be
hðtÞ
L1

2
s þ 2

2e2tuðtÞ
Sampling the impulse response hðtÞ with T
1=fs
0:1 second, we have
Th

n

T2e2nT u

n

0:2e0:2nu

n

Using the z transform table in Chapter 5, we yield
Z
h
eanu

n
i
z
z
ea
And noting that ea
e0:2
0:8187, the digital ﬁlter transfer function HðzÞ is ﬁnally given by
H

z

0:2z
z
0:8187
0:2
1
0:8187z1
346
CHAPTER 8 Inﬁnite Impulse Response Filter Design

b. The MATLAB code is listed in Program 8.12. The ﬁrst and third plots in Figure 8.28 show comparisons of the
magnitude and phase frequency responses. The shape of the magnitude response (ﬁrst plot) closely matches
that of the analog ﬁlter, while the phase response (third plot) differs from the analog phase response in this
example.
Program 8.12. MATLAB program for Example 8.15.
% Example 8.15.
% Plot the magnitude responses jH(s)j and jH(z)j
% For the Laplace transfer function H(s)
f 0:0.1:5;T 0.1;
% Frequency range and sampling interval
w 2*pi*f;
% Frequency range in rad/sec
hs freqs([2], [1 2],w);
% Analog frequency response
phis 180*angle(hs)/pi;
% For the z transfer function H(z)
hz freqz([0.2],[1
0.8187],length(w)); % Digital frequency resoonse
hz scale freqz([0.1813],[1
0.8187],length(w)); % Scaled digital mag. response
phiz 180*angle(hz)/pi;
% Plot magnitude and phase responses.
subplot(3,1,1), plot(f,abs(hs),’kx’,f, abs(hz),’k ’),grid; axis([0 5 0 1.2]);
xlabel(’Frequency (Hz)’); ylabel(’Mag. Responses’)
subplot(3,1,2),
plot(f,abs(hs),’kx’,f,
abs(hz scale),’k ’),grid;
axis([0
5
0 1.2]);
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
0
0.5
1
Frequency (Hz)
Mag. responses
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
0
0.5
1
Frequency (Hz)
Sca ed mag. responses
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
-100
-50
0
Frequency (Hz)
Phases (deg.)
FIGURE 8.28
Frequency responses. The line of “x”s represent the frequency responses of the analog ﬁlter; the solid line
represents the frequency responses of the designed digital ﬁlter.
8.6 Impulse Invariant Design Method
347

xlabel(’Frequency (Hz)’); ylabel(’Scaled Mag. Responses’)
subplot(3,1,3), plot(f,phis,’kx’,f, phiz,’k ’); grid;
xlabel(’Frequency (Hz)’); ylabel(’Phases (deg.)’);
The ﬁlter DC gain is given by
H

ejU
U¼0 ¼ Hð1Þ ¼ 1:1031
We can further scale the ﬁlter to have a unit gain of
HðzÞ ¼
1
1:1031
0:2
1  0:8187z 1 ¼
0:1813
1  0:8187z 1
The scaled magnitude frequency response is shown in the middle plot along with that of analog ﬁlter in
Figure 8.28, where the magnitudes are matched very well below 1.8 Hz.
Example 8.15 demonstrates the procedure for using the impulse-invariant design. The ﬁlter
performance depends on the sampling interval (Lynn and Fuerst,1999). As shown in Figure 8.27, the
analog impulse response hðtÞ is not a band-limited signal whose frequency extends to inﬁnity, which is
certainly larger than the Nyquist limit (folding frequency); hence, sampling hðtÞ could cause aliasing.
Figure 8.29(a) shows the analog impulse response ThðtÞ in Example 8.15 and its sampled version
ThðnTÞ, where the sampling interval is 0.125 second. The analog ﬁlter and digital ﬁlter magnitude
responses are plotted in Figure 8.29(b). The aliasing occurs because the impulse response contains
frequency components beyond the Nyquist limit, that is, 4 Hz in this case. Furthermore, using the
lower sampling rate of 8 Hz causes less accuracy in the digital ﬁlter magnitude response, so more
aliasing develops.
Figure 8.29(c) shows the analog impulse response and its sampled version using a higher
sampling rate of 16 Hz. Figure 8.29(d) displays the more accurate magnitude response of the digital
ﬁlter. Hence, we can obtain a reduced aliasing level. Note that the aliasing cannot be avoided, due to
sampling of the analog impulse response. The only way to reduce the aliasing is to use a higher
sampling frequency or design a ﬁlter with a very low cutoff frequency to reduce the aliasing to
a minimum level.
Investigation of the sampling interval effect leads us to the following conclusions. Note that the
analog impulse response for an analog highpass ﬁlter or bandstop ﬁlter contains frequency up to
inﬁnity, which is larger than the Nyquist limit (folding frequency), even assuming that the sampling
rate is much higher than the cutoff frequency of a highpass ﬁlter or the upper cutoff frequency of
a bandstop ﬁlter. Hence, sampling the analog impulse response always produces aliasing. Without
using an additional anti-aliasing ﬁlter, the impulse invariant method alone cannot be used for designing
the highpass ﬁlter or bandstop ﬁlter.
Instead, in practice, we should apply the BLT design method. The impulse-invariant design
method is only appropriate for designing a lowpass ﬁlter or bandpass ﬁlter with a sampling rate much
larger than the lower cutoff frequency of the lowpass ﬁlter or the upper cutoff frequency of the
bandpass ﬁlter.
Next, let us focus on second-order ﬁlter design via Example 8.16.
348
CHAPTER 8 Inﬁnite Impulse Response Filter Design

EXAMPLE 8.16
Consider the following Laplace transfer function:
HðsÞ
s
s2 þ 2s þ 5
a. Determine HðzÞ using the impulse invariant method if the sampling rate fs
10 Hz.
b. Use MATLAB to plot the following:
1. the magnitude response jHðfÞj and phase response fðfÞ with respect to HðsÞ for the frequency range from
0 to fs=2 Hz;
2. the magnitude response
HðejUÞ

jHðej2pfT Þj and phase response fðfÞ with respect to HðzÞ for the
frequency range from 0 to fs=2 Hz.
Solution:
a. Since HðsÞ has complex poles located at s
1  2j, we can write it in a quadratic form as
HðsÞ
s
s2 þ 2s þ 5
s
ðs þ 1Þ2þ22
0
5
10
15
20
0
0.1
0.2
0.3
0.4
Time (sec.)
h(t) and h(nT)
 Sample rate fs=8 Hz
0
2
4
6
8
0
0.5
1
1.5
Frequency (Hz)
 Mag. responses:H(s) and H(z)
0
10
20
30
40
0
0.05
0.1
0.15
0.2
Time (sec.)
 h(t) and h(nT)
 Sample rate fs=16 Hz
0
5
10
15
0
0.5
1
1.5
Frequency (Hz)
 Mag. responses:H(s) and H(z)
Dig tal
filter
Analog
filter
Aliasing
Digital
filter
Analog
f lter
Aliasing
(a) 
(b)
(d)
(c)
FIGURE 8.29
Sampling interval effect in the impulse invariant IIR ﬁlter design.
8.6 Impulse Invariant Design Method
349

We can further write the transfer function as
HðsÞ
ðs þ 1Þ
1
ðs þ 1Þ2þ22
ðs þ 1Þ
ðs þ 1Þ2þ22
0:5 
2
ðs þ 1Þ2þ22
From the Laplace transform table (Appendix B), the analog impulse response can easily be found as
h

t

etcos

2t

u

t

0:5etsin

2t

u

t

Sampling the impulse response hðtÞ using a sampling interval T
0:1 and using the scale factor of T
0:1,
we have
Th

n

ThðtÞjt
nT
0:1e0:1ncos

0:2n

u

n

0:05e0:1nsin

0:2n

u

n

Applying the z transform (Chapter 5) leads to
H

z

Z

0:1e0:1ncos

0:2n

u

n

0:05e0:1nsin

0:2n

u

n
	
0:1z

z
e0:1cos

0:2

z2
2e0:1cos

0:2

z þ e0:2
0:05e0:1sin

0:2

z
z2
2e0:1cos

0:2

z þ e0:2
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
0
0.2
0.4
0.6
0.8
Frequency (Hz)
Magn tude responses
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
100
50
0
50
100
Frequency (Hz)
Phases (degrees)
FIGURE 8.30
Frequency responses. The line of “x”s represents frequency responses of the analog ﬁlter; the solid line
represents frequency responses of the designed digital ﬁlter.
350
CHAPTER 8 Inﬁnite Impulse Response Filter Design

After algebra simpliﬁcation, we obtain the second order digital ﬁlter as
HðzÞ
0:1
0:09767z1
1
1:7735z1 þ 0:8187z2
b. The magnitude and phase frequency responses are shown in Figure 8.30 and MATLAB Program 8.13 is
given. The passband gain of the digital ﬁlter is higher than that of the analog ﬁlter, but their shapes are
same.
Program 8.13. MATLAB program for Example 8.16.
% Example 8.16
% Plot the magnitude responses jH(s)j and jH(z)j
% For the Laplace transfer function H(s)
f 0:0.1:5;T 0.1; % Initialize analog frequency range in Hz and sampling interval
w 2*pi*f;
% Convert the frequency range to radians/second
hs freqs([1 0], [1 2 5],w); % Calculate analog filter frequency responses
phis 180*angle(hs)/pi;
% For the z transfer function H(z)
% Calculate digital filter frequency responses
hz freqz([0.1
0.09766],[1
1.7735 0.8187],length(w));
phiz 180*angle(hz)/pi;
% Plot magnitude and phase responses
subplot(2,1,1), plot(f,abs(hs),’x’,f, abs(hz),’ ’),grid;
xlabel(’Frequency (Hz)’); ylabel(’Magnitude Responses’)
subplot(2,1,2), plot(f,phis,’x’,f, phiz,’ ’); grid;
xlabel(’Frequency (Hz)’); ylabel(’Phases (degrees)’)
8.7 POLE-ZERO PLACEMENT METHOD FOR SIMPLE INFINITE IMPULSE
RESPONSE FILTERS
This section introduces a pole-zero placement method for a simple IIR ﬁlter design. Let us ﬁrst
examine the effects of the pole-zero placement on the magnitude response in the z-plane (Figure 8.31).
In the z-plane, when we place apair of complex conjugate zeros at a givenpoint on the unit circlewith
an angle q (usually we do), wewill have a numerator factor of ðz  ejqÞðz  e jqÞin the transfer function.
Its magnitude contribution to the frequency response at z ¼ ejU is ðejU  ejqÞðejU  e jqÞ. When
U ¼ q, the magnitude will reach zero, since the ﬁrst factor ðejq  ejqÞ ¼ 0 contributes zero magnitude.
When a pair of complex conjugate poles are placed at a given point within the unit cycle, we have
a denominator factor of ðz  rejqÞðz  re jqÞ, where r is the radius chosen to be less than and close to 1 to
place the poles inside the unit circle. The magnitude contribution to the frequency response at U ¼ q
will rise to a large magnitude, since the ﬁrst factor ðejq  rejqÞ ¼ ð1  rÞejq gives a small magnitude
of 1  r in the denominator. This small magnitude (1r) is the length between the pole location and the
unit circle at the angle U ¼ q as shown in Figure 8.31. Note that the magnitude of ejq is 1.
Therefore, we can reduce the magnitude response using zero placement, while we increase the
magnitude response using pole placement. Placing a combination of poles and zeros will result in
8.7 Pole Zero Placement Method for Simple Inﬁnite Impulse Response Filters
351

different frequency responses, such as lowpass, highpass, bandpass, and bandstop. The method is
intuitive and approximate. Furthermore, it is easy to compute ﬁlter coefﬁcients for simple IIR ﬁlters.
Here, we describe the design procedures for second-order bandpass and bandstop ﬁlters, as well ﬁrst-
order lowpass and highpass ﬁlters. (For details of derivations, readers are referred to Lynn and Fuerst
[1999]). Practically, the pole-zero placement method delivers good performance when the bandpass
and bandstop ﬁlters have very narrow bandwidth requirements and the lowpass and highpass ﬁlters
have either very low cutoff frequency close to DC or very high cutoff frequency close to the folding
frequency (Nyquist limit).
8.7.1 Second-Order Bandpass Filter Design
Typical pairs of poles and zeros for a bandpass ﬁlter are placed in Figure 8.32. Poles are complex
conjugate, with the magnitude r controlling the bandwidth and the angle q controlling the center
frequency. The zeros are placed at z ¼ 1 corresponding to DC, and z ¼ 1, corresponding to the
folding frequency.
The poles will increase the magnitude response at the center frequency while the zeros will cause
zero gains at DC (zero frequency) and at the folding frequency.
The following equations give the bandpass ﬁlter design formulas using pole-zero placement:
r z 1  ðBW3dB=fsÞ  p; good for 0:9  r < 1
(8.41)
q ¼
f0
fs

 360

(8.42)
0
f s / 2
r
0
f s / 2
r
j
z
e
Factor in denominator 
j
j
z
re
z
re
Magnitude response in denominator at
1
j
j
j
j
j
j
j
z
e
e
re
e
re
r
e
re
Factor in numerator 
j
j
z
e
z
e
Magnitude response in numerator at 
0
j
j
j
j
j
z
e
e
e
e
e
j
z
e
FIGURE 8.31
Effects of the pole-zero placement on the magnitude response.
352
CHAPTER 8 Inﬁnite Impulse Response Filter Design

HðzÞ ¼
Kðz  1Þðz þ 1Þ
ðz  rejqÞðz  re jqÞ ¼
K

z2  1

ðz2  2rz cos q þ r2Þ
(8.43)
where K is a scale factor to adjust the bandpass ﬁlter so it has a unit passband gain given by
K ¼ ð1  rÞ
1  2r cos 2q þ r2
p
2jsin qj
(8.44)
EXAMPLE 8.17
A second order bandpass ﬁlter is required to satisfy the following speciﬁcations:
•
Sampling rate
8,000 Hz
•
3 dB bandwidth: BW
200 Hz
•
Narrow passband centered at f0
1; 000 Hz
•
Zero gain at 0 Hz and 4,000 Hz
Find the transfer function using the pole zero placement method.
Solution:
First, we calculate the required magnitude of the poles
r
1
ð200=8; 000Þp
0:9215;
which is a good approximation. Use the center frequency to obtain the angle of the pole location:
q
1; 000
8; 000

 360
45
0
f0
f s / 2
0
f s / 2
f
r
0°
180°
H e j
(
)
f
f s
0
°
360
Re( )z
Im( )z
FIGURE 8.32
Pole-zero placement for a second-order narrow bandpass ﬁlter.
8.7 Pole Zero Placement Method for Simple Inﬁnite Impulse Response Filters
353

Compute the unit gain scale factor as
K
ð1
0:9215Þ
1
2  0:9215  cos2  45
 þ 0:92152
p
2jsin 45j
0:0755
Finally, the transfer function is given by
HðzÞ
0:0755

z2
1


z2
2  0:9215zcos 45 þ 0:92152
0:0755
0:0755z2
1
1:3031z1 þ 0:8491z2
8.7.2 Second-Order Bandstop (Notch) Filter Design
For this type of ﬁlter, the pole placement is the same as the bandpass ﬁlter (Figure 8.33). The zeros are
placed on the unit circle with the same angles with respect to poles. This will improve passband
performance. The magnitude and the angle of the complex conjugate poles determine the 3 dB
bandwidth and center frequency, respectively.
Design formulas for bandstop ﬁlters are given in the following equations:
r z 1  ðBW3dB=fsÞ  p; good for 0:9  r < 1
(8.45)
q ¼
f0
fs

 360
(8.46)
HðzÞ ¼ K

z  ejq
z þ e jq
ðz  rejqÞðz  re jqÞ ¼ K

z2  2z cos q þ 1

ðz2  2rz cos q þ r2Þ
(8.47)
The scale factor to adjust the bandstop ﬁlter so it has a unit passband gain is given by
K ¼

1  2r cos q þ r2
ð2  2 cos qÞ
(8.48)
0
f0
f s / 2
0
f s / 2
f
r
FIGURE 8.33
Pole-zero placement for a second-order notch ﬁlter.
354
CHAPTER 8 Inﬁnite Impulse Response Filter Design

EXAMPLE 8.18
A second order notch ﬁlter is required to satisfy the following speciﬁcations:
•
Sampling rate
8,000 Hz
•
3 dB bandwidth: BW
100 Hz
•
Narrow passband centered at f0
1; 500 Hz
Find the transfer function using the pole zero placement approach.
Solution:
We ﬁrst calculate the required magnitude of the poles
r z 1
ð100=8; 000Þ  p
0:9607
which is a good approximation. We use the center frequency to obtain the angle of the pole location:
q
1; 500
8; 000

 360
67:5
The unit gain scale factor is calculated as
K

1
2  0:9607 cos 67:5 þ 0:96072
ð2
2 cos 67:5Þ
0:9620
Finally, we obtain the transfer function:
HðzÞ
0:9620

z2
2z cos 67:5 þ 1


z2
2  0:9607z cos 67:5 þ 0:96072
0:9620
0:7363z1 þ 0:9620z2
1
0:7353z1 þ 0:9229
8.7.3 First-Order Lowpass Filter Design
The ﬁrst-order pole-zero placement can be utilized in two cases. The ﬁrst situation is when the cutoff
frequency is less than fs=4. Then the pole-zero placement is shown in Figure 8.34.
As shown in Figure 8.34, the pole z ¼ a is placed in the real axis. The zero is placed at z ¼ 1 to
ensure zero gain at the folding frequency (Nyquist limit). When the cutoff frequency is above fs=4, the
pole-zero placement is adopted as shown in Figure 8.35.
Design formulas for lowpass ﬁlters using the pole-zero placement are given in the following
equations.
0
fc
f s / 2
0
f s / 2
f
FIGURE 8.34
Pole-zero placement for the ﬁrst-order lowpass ﬁlter with fc < fs=4.
8.7 Pole Zero Placement Method for Simple Inﬁnite Impulse Response Filters
355

When fc < fs=4,
a z 1  2  ðfc=fsÞ  p;
good for
0:9  r < 1
(8.49)
When fc > fs=4,
a z  ð1  p þ 2  ðfc=fsÞ  pÞ;
good for
 1 < r  0:9
(8.50)
The transfer function is
HðzÞ ¼ Kðz þ 1Þ
ðz  aÞ
(8.51)
and the unit passband gain scale factor is given by
K ¼ ð1  aÞ
2
(8.52)
EXAMPLE 8.19
A ﬁrst order lowpass ﬁlter is required to satisfy the following speciﬁcations:
•
Sampling rate
8,000 Hz
•
3 dB cutoff frequency: fc
100 Hz
•
Zero gain at 4,000 Hz
Find the transfer function using the pole zero placement method.
Solution:
Since the cutoff frequency of 100 Hz is much less than fs=4
2; 000 Hz, we determine the pole as
a z 1
2  ð100=8; 000Þ  p
0:9215
which is above 0.9. Hence, we have a good approximation. The unit gain scale factor is calculated by
K
ð1
0:9215Þ
2
0:03925
Last, we can develop the transfer function as
HðzÞ
0:03925ðz þ 1Þ
ðz
0:9215Þ
0:03925 þ 0:03925z1
1
0:9215z1
0
fc
f s / 2
0
f s / 2
f
FIGURE 8.35
Pole-zero placement for the ﬁrst-order lowpass ﬁlter with fc > fs=4.
356
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Note that we can also determine the unit gain factor K by substituting z
ej0
1 in the transfer function
HðzÞ
ðz þ 1Þ
ðz
aÞ, then ﬁnding the DC gain. Set the scale factor to be a reciprocal of the DC gain. This can be easily
done as follows:
DC gain
z þ 1
z
0:9215

z
1
1 þ 1
1
0:9215
25:4777
Hence, K
1=25:4777
0:03925.
8.7.4 First-Order Highpass Filter Design
Similar to the lowpass ﬁlter design, the pole-zero placements for the ﬁrst-order highpass ﬁlters in two
cases are shown in Figure 8.36(a) and 8.36(b).
Formulas for designing highpass ﬁlters using the pole-zero placement are listed in the following
equations:
When fc < fs=4,
a z 1  2  ðfc=fsÞ  p;
good for
0:9  r < 1
(8.53)
When fc > fs=4,
a z  ð1  p þ 2  ðfc=fsÞ  pÞ;
good for
 1 < r  0:9
(8.54)
HðzÞ ¼ Kðz  1Þ
ðz  aÞ
(8.55)
K ¼ ð1 þ aÞ
2
(8.56)
0
fc
f s / 2
0
f s / 2
f
0
fc
f s / 2
0
f s / 2
f
(a)
(b)
FIGURE 8.36
(a) Pole-zero placement for the ﬁrst-order highpass ﬁlter with fc < fs=4. (b) Pole-zero placement for the ﬁrst-
order highpass ﬁlter with fc > fs=4.
8.7 Pole Zero Placement Method for Simple Inﬁnite Impulse Response Filters
357

EXAMPLE 8.20
A ﬁrst order highpass ﬁlter is required to satisfy the following speciﬁcations:
•
Sampling rate
8,000 Hz
•
3 dB cutoff frequency: fc
3; 800 Hz
•
Zero gain at 0 Hz
Find the transfer function using the pole zero placement method.
Solution:
Since the cutoff frequency of 3,800 Hz is much larger than fs=4
2; 000 Hz, we determine the pole as
a z
ð1
p þ 2  ð3; 800=8; 000Þ  pÞ
0:8429
The unit gain scale factor and transfer function are obtained as
K
ð1
0:8429Þ
2
0:07854
HðzÞ
0:07854ðz
1Þ
ðz þ 0:8429Þ
0:07854
0:07854z1
1 þ 0:8429z1
Note that we can also determine the unit gain scale factor K by substituting z
ej1800
1 to the transfer
function H

z

ðz
1Þ
ðz
aÞ, ﬁnding a passband gain at the Nyquist limit fs=2
4; 000 Hz. We then set the scale
factor to be a reciprocal of the passband gain. That is,
Passbandgain
z
1
z þ 0:8429

z
1
1
1
1 þ 0:8429
12:7307
Hence, K
1=12:7307
0:07854:
8.8 REALIZATION STRUCTURES OF INFINITE IMPULSE RESPONSE FILTERS
In this section, we will realize the designed IIR ﬁlter using direct-form I as well as direct-form II. We
will then realize a higher-order IIR ﬁlter using a cascade form.
8.8.1 Realization of Inﬁnite Impulse Response Filters in
Direct-Form I and Direct-Form II
EXAMPLE 8.21
Realize the ﬁrst order digital highpass Butterworth ﬁlter
HðzÞ
0:1936
0:1936z1
1 þ 0:6128z1
using a direct form I realization.
358
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Solution:
From the transfer function, we can identify
b0
0:1936; b1
0:1936;
and
a1
0:6128
Applying the direct form I developed in Chapter 6 results in the diagram in Figure 8.37.
The digital signal processing (DSP) equation for implementation is then given by
yðnÞ
0:6128yðn
1Þ þ 0:1936xðnÞ
0:1936xðn
1Þ
Program 8.14 lists the MATLAB implementation.
Program 8.14. MATLAB program for Example 8.21.
% Sample MATLAB code
sample
2:2:20; % Input test array
x [ 0 0 ]; % Input buffer [x(n) x(n 1) .]
y [ 0 0]; % Output buffer [y(n) y(n 1) . ]
b [0.1936
0.1936]; % Numerator coefficients [b0 b1 . ]
a [1 0.6128]; % Denominator coefficients [1 a0 a1 .]
for n 1:1:length(sample) % Processing loop
for k 2: 1:2
x(k) x(k 1); % Shift input by one sample
y(k) y(k 1); % Shift output by one sample
end
x(1) sample(n);
% Get new sample
y(1) 0;
% Digital filtering
for k 1:1:2
y(1) y(1)þx(k)*b(k);
end
for k 2:2
y(1) y(1) a(k)*y(k);
end
out(n) y(1); % Output the filtered sample to output array
end
out
EXAMPLE 8.22
Realize the following digital ﬁlter using direct form II:
HðzÞ
0:7157 þ 1:4314z1 þ 0:7151z2
1 þ 1:3490z1 þ 0:5140z2
z 1
z 1
y(n)
01936
.
01936
.
0 6128
.
+
x n
( )
x n
(
)1
y n
(
)1
FIGURE 8.37
Realization of IIR ﬁlter in Example 8.21 in direct-form I.
8.8 Realization Structures of Inﬁnite Impulse Response Filters
359

Solution:
First, we can identify
b0
0:7157; b1
1:4314; b2
0:7151
and
a1
1:3490; a2
0:5140
Applying the direct form II realization developed in Chapter 6 leads to Figure 8.38.
There are two difference equations required for implementation:
wðnÞ
xðnÞ
1:3490wðn
1Þ
0:5140wðn
2Þ
yðnÞ
0:7157wðnÞ þ 1:4314wðn
1Þ þ 0:7157wðn
2Þ
The MATLAB implementation is listed in Program 8.15.
Program 8.15. MATLAB code for Example 8.22.
% Sample MATLAB code
sample
2:2:20;
% Input test array
x [0];
% Input buffer [x(n) ]
y [0];
% Output buffer [y(n)]
w [0 0 0]; % Buffer for w(n) [w(n) w(n 1) .]
b [0.7157 1.4314 0.7157];
% Numerator coefficients [b0 b1 .]
a [1 1.3490 0.5140];
% Denominator coefficients [1 a1 a2 .]
for n 1:1:length(sample)
% Processing loop
for k 3: 1:2
w(k) w(k 1);
% Shift w(n) by one sample
end
x(1) sample(n);
% Get new sample
w(1) x(1);
% Perform IIR filtering
for k 2:1:3
w(1) w(1) a(k)*w(k);
end
y(1) 0;
% Perform FIR filtering
for k 1:1:3
y(1) y(1)þb(k)*w(k);
end
out(n) y(1);
% Send the filtered sample to output array
end
out
z 1
y n
( )
0 7157
.
14314
.
1349
.
x n
( )
0514
.
w n
(
)
2
w n
( )
z 1
w n
(
)1
0 7157
.
FIGURE 8.38
Realization of IIR ﬁlter in Example 8.22 in direct-form II.
360
CHAPTER 8 Inﬁnite Impulse Response Filter Design

8.8.2 Realization of Higher-Order Inﬁnite Impulse Response Filters via the
Cascade Form
EXAMPLE 8.23
Given a fourth order ﬁlter transfer function designed as
HðzÞ
0:5108z2 þ 1:0215z þ 0:5108
z2 þ 0:5654z þ 0:4776
 0:3730z2 þ 0:7460z þ 0:3730
z2 þ 0:4129z þ 0:0790
realize the digital ﬁlter using the cascade (series) form via second order sections.
Solution:
Since the ﬁlter is designed using the cascade form, we have two sections of the second order ﬁlters, whose transfer
functions are
H1ðzÞ
0:5108z2 þ 1:0215z þ 0:5108
z2 þ 0:5654z þ 0:4776
0:5180 þ 1:0215z1 þ 0:5108z2
1 þ 0:5654z1 þ 0:4776z2
and
H2ðzÞ
0:3730z2 þ 0:7460z þ 0:3730
z2 þ 0:4129z þ 0:0790
0:3730 þ 0:7460z1 þ 0:3730z2
1 þ 0:4129z1 þ 0:0790z2
Each ﬁlter section is developed using the direct form I realization, shown in Figure 8.39.
There are two sets of DSP equations for implementation of the ﬁrst and second sections, respectively.
First section:
y1ðnÞ
0:5654y1ðn
1Þ
0:4776y1ðn
2Þ
þ0:5108xðnÞ þ 1:0215xðn
1Þ þ 0:5108xðn
2Þ
Second section:
yðnÞ
0:4129yðn
1Þ
0:0790yðn
2Þ
þ0:3730y1ðnÞ þ 0:7460y1ðn
1Þ þ 0:3730y1ðn
2Þ
Again, after we use the direct form II for realizing each second order ﬁlter, the realization shown in Figure 8.40 is
developed.
z 1
z 1
z 1
z 1
05654
.
+
x n
( )
0 4776
.
z 1
z 1
z 1
z 1
y(n)
05108
.
0 4129
.
+
0 3730
.
10215
.
05108
.
0 0790
.
0 3730
.
0 7460
.
y n
1( )
FIGURE 8.39
Cascade realization of IIR ﬁlter in Example 8.23 in direct-form I.
8.8 Realization Structures of Inﬁnite Impulse Response Filters
361

The difference equations for the implementation of the ﬁrst section are
w1ðnÞ
xðnÞ
0:5654w1ðn
1Þ
0:4776w1ðn
2Þ
y1ðnÞ
0:5108w1ðnÞ þ 1:0215w1ðn
1Þ þ 0:5108w1ðn
2Þ
The difference equations for the implementation of the second section are
w2ðnÞ
y1ðnÞ
0:4129w2ðn
1Þ
0:0790w2ðn
2Þ
yðnÞ
0:3730w2ðnÞ þ 0:7460w2ðn
1Þ þ 0:3730w2ðn
2Þ
Note that for both direct form I and direct form II, the output from the ﬁrst ﬁlter section becomes the input for the
second ﬁlter section.
8.9 APPLICATION: 60-HZ HUM ELIMINATOR AND HEART RATE DETECTION
USING ELECTROCARDIOGRAPHY
Hum noise created by poor power suppliers, transformers, or electromagnetic interference sourced by
a main power supply is characterized by a frequency of 60 Hz and its harmonics. If this noise interferes
with a desired audio or biomedical signal (e.g., in electrocardiography [ECG]), the desired signal could
be corrupted. The corrupted signal is useless without signal processing. It is sufﬁcient to eliminate the
60-Hz hum frequency with its second and third harmonics in most practical applications. We can
complete this by cascading with notch ﬁlters having notch frequencies of 60 Hz, 120 Hz, and 180 Hz,
respectively. Figure 8.41 depicts the functional block diagram.
Now let us apply the 60-Hz hum eliminator to an ECG recording system. ECG is a small electrical
signal captured from an ECG sensor. The ECG signal is produced by the activity of the human heart, thus
it can be used for heart rate detection, fetal monitoring, and diagnostic purposes. The single pulse of the
ECG is depicted in Figure 8.42, which shows that the ECG signal is characterized by ﬁve peaks and
valleys, labeled P, Q, R, S, and T. The highest positive wave is the R wave. Shortly before and after the R
wave are negative waves called the Q wave and S wave. The P wave comes before the Q wave, while the
T wave comes after the S wave. The Q, R, and S waves together are called the QRS complex.
The properties of the QRS complex, with its rate of occurrence and times, heights, and widths,
provide information to cardiologists concerning various pathological conditions of the heart. The
z 1
05108
.
10215
.
05654
.
x n
( )
05108
.
0 4776
.
z 1
z 1
y n
( )
0 3730
.
0 7460
.
0 4129
.
0 3730
.
0 0790
.
z 1
y n
1( )
w n
1( )
w n
2( )
FIGURE 8.40
Cascade realization of IIR ﬁlter in Example 8.23 in direct-form II.
362
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Notch filter
60 Hz
Notch filter
120Hz
Notch filter
180 Hz
Digital signal
input
Digital signal
output
60
120
180
0
30
60
Gain (dB)
f Hz
60
120
180
f Hz
60 Hz Hum
120 Hz Harmonic
180 Hz Harmonic
Input signal
spectrum
FIGURE 8.41
(Top) 60-Hz hum eliminator; (middle) the ﬁlter frequency response of the eliminator; (bottom) the input signal
spectrum corrupted by the 60-Hz hum and its second and third harmonics.
0
50
100
150
200
250
300
350
400
450
500
0.6
0.4
0.2
0
0.2
0.4
0.6
0.8
ECG s gna  amp tude
n
P
Q
R
S
T
FIGURE 8.42
The characteristics of the ECG pulse.
8.9 Application: 60 Hz Hum Eliminator and Heart Rate Detection Using ECG
363

reciprocal of the time period between R wave peaks (in milliseconds) multiplied by 60,000 gives
instantaneous heart rate in beats per minute. On a modern ECG monitor, the acquired ECG signal is
displayed for diagnostic purposes.
However, a major source of frequent interference is the electric-power system. Such interference
appears on the recorded ECG data due to electrical-ﬁeld coupling between the power lines and the
electrocardiograph or patient, which is the cause of the electrical ﬁeld surrounding power lines
(mains). Another cause is magnetic induction in the power line, whereby current in the power line
generates a magnetic ﬁeld around the line. Sometimes, the harmonics of 60-Hz hum exist due to the
nonlinear sensor and signal ampliﬁer effects. If such interference is severe, the recorded ECG data
becomes useless.
In this application, we focus on ECG enhancement for heart rate detection. To signiﬁcantly reduce
60-Hz interference, we apply signal enhancement to the ECG recording system, as shown in Figure 8.43.
The 60-Hz eliminator removes the 60-Hz interference and has the capability to reduce its second
harmonic of 120 Hz and third harmonic of 180 Hz.
The next objective is to detect the heart rate using the enhanced ECG signal. We need to remove
DC drift and to ﬁlter muscle noise, which may occur at approximately 40 Hz or more. If we consider
the lowest heart rate as 30 beats per minute, the corresponding frequency is 30/60 ¼ 0.5 Hz. Choosing
a lower cutoff frequency of 0.25 Hz should be reasonable.
Thus, a bandpass ﬁlter with a passband from 0.25 Hz to 40 Hz (range from 0.67 Hz to 40 Hz, dis-
cussed in Webster [1998]), either FIR or IIR type, can be designed to reduce such effects. The resultant
ECG signalis valid only for the detection of heart rate. Noticethat the ECG signal after bandpass ﬁltering
with a passband from 0.25 Hz to 40 Hz is no longer valid for general ECG applications, since the original
ECG signal occupies the frequency range from 0.01 Hz to 250 Hz (diagnostic-quality ECG), as dis-
cussed in Carr and Brown (2001) and Webster (1998). The enhanced ECG signal from the 60-Hz hum
eliminator can serve for general ECG signal analysis (which is beyond the scope of this book). We
summarize the design speciﬁcations for the heart rate detection application as follows:
System outputs:
Enhanced ECG signal with 60-Hz elimination
Processed ECG signal for heart rate detection
60-Hz eliminator speciﬁcations:
Harmonics to be removed:
60 Hz (fundamental)
120 Hz (second harmonic)
180 Hz (third harmonic)
3-dB bandwidth for each ﬁlter: 4 Hz
Sampling rate:
600 Hz
Notch ﬁlter type:
Second-order IIR
60 Hz eliminator
Bandpass filtering
Passband:
0.25 Hz to 40 Hz
Input ECG
signal
Enhanced ECG signal
Signal for
heart rate
detection
FIGURE 8.43
ECG signal enhancement system.
364
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Design method:
Pole-zero placement
Bandpass ﬁlter speciﬁcations:
Passband frequency range:
0.25 40 Hz
Passband ripple:
0.5 dB
Filter type:
Chebyshev fourth order
Design method:
Bilinear transformation method
DSP sampling rate:
600 Hz
Let us carry out the 60-Hz eliminator design and determine the transfer function and difference
equation for each notch ﬁlter and bandpass ﬁlter. For the ﬁrst section with the notch frequency of 60
Hz, applying Equations (8.45) to (8.48) leads to
r ¼ 1  ð4=600Þ  p ¼ 0:9791
q ¼
 60
600

 360 ¼ 36
We calculate 2 cos ð36Þ ¼ 1:6180, 2r cos ð36Þ ¼ 1:5842, and
K ¼

1  2r cos q þ r2
ð2  2 cos qÞ
¼ 0:9803
Hence it follows that
H1ðzÞ ¼ 0:9803  1:5862z 1 þ 0:9803z 2
1  1:5842z 1 þ 0:9586z 2
y1ðnÞ ¼ 0:9803xðnÞ  1:5862xðn  1Þ þ 0:9802xðn  2Þ þ 1:5842y1ðn  1Þ  0:9586y1ðn  2Þ
Similarly, we obtain the transfer functions and difference equations for the second section and third
section as follows:
Second section:
H2ðzÞ ¼ 0:9794  0:6053z 1 þ 0:9794z 2
1  0:6051z 1 þ 0:9586z 2
y2ðnÞ ¼ 0:9794y1ðnÞ  0:6053y1ðn  1Þ þ 0:9794y1ðn  2Þ þ 0:6051y2ðn  1Þ  0:9586y2ðn  2Þ
Third section:
H3ðzÞ ¼ 0:9793 þ 0:6052z 1 þ 0:9793z 2
1 þ 0:6051z 1 þ 0:9586z 2
y3ðnÞ ¼ 0:9793y2ðnÞ þ 0:6052y2ðn  1Þ þ 0:9793y2ðn  2Þ  0:6051y3ðn  1Þ  0:9586y3ðn  2Þ
The cascaded frequency responses are plotted in Figure 8.44. As we can see, the rejection for each
notch frequency is below 50 dB.
8.9 Application: 60 Hz Hum Eliminator and Heart Rate Detection Using ECG
365

The second-stage design using the BLT gives the bandpass ﬁlter transfer function and difference
equation:
H4ðzÞ ¼
0:0464  0:0927z 2 þ 0:0464z 4
1  3:3523z 1 þ 4:2557z 2  2:4540z 3 þ 0:5506z 4
y4ðnÞ ¼ 0:046361y3ðnÞ  0:092722y3ðn  2Þ þ 0:046361y3ðn  4Þ
þ03:352292y4ðn  1Þ  4:255671y4ðn  2Þ þ 2:453965y4ðn  3Þ  0:550587y4ðn  4Þ
Figure 8.45 depicts the processed results at each stage. In Figure 8.45, plot (a) shows the initial corrupted
ECG data, which includes 60-Hz interference and its 120 and 180 Hz harmonics, along with muscle
noise. Plot (b) shows that the 60-Hz interference and its harmonics of 120 and 180 Hz have been removed.
Finally, plot (c) displays the result after the bandpass ﬁlter. As we expected, the muscle noise has been
removed; and the enhanced ECG signal is observed. A MATLAB simulation is provided in Program 8.16.
With the procssed ECG signal, a simple zero-cross algorithm can be designed to detect the heart
rate. Based on plot (c) in Figure 8.45, we use a threshold value of 0.5 and continuously compare each
of two consecutive samples with the threshold. If both results are opposite, then a zero crossing is
detected. Each zero-crossing measure is given by
zero crossing ¼ jcur sign  pre signj
2
0
50
100
150
200
250
300
100
50
0
50
100
Frequency (Hertz)
Phase (degrees)
0
50
100
150
200
250
300
100
50
0
50
Frequency (Hertz)
Magn tude response (dB)
FIGURE 8.44
Frequency responses of three cascaded notch ﬁlters.
366
CHAPTER 8 Inﬁnite Impulse Response Filter Design

where cur sign and pre sign are determined based on the current input xðnÞ, the past input xðn  1Þ,
and the threshold value, given as
if
xðnÞ  threshold cur sign ¼ 1 else cur sign ¼ 1
if
xðn  1Þ  threshold pre sign ¼ 1 else pre sign ¼ 1
Figure 8.46 summarizes the algorithm.
After detecting the total number of zero crossings, the number of peaks will be half the number of
zero crossings. The heart rate in terms of pulses per minute can be determined by
Heart rate ¼
60
Number of enhanced ECG data
fs
 
zero  crossing number
2

In our simulation, we have detected 6 zero-crossing points using 1,500 captured data points at
a sampling rate of 600 samples per second. Hence,
0
0.5
1
1.5
2
2.5
1
0
1
(a)
0
0.5
1
1.5
2
2.5
1
0
1
(b)
0
0.5
1
1.5
2
2.5
1
0
1
(c)
Time (sec.)
FIGURE 8.45
Results of ECG signal processing. (a) Initial corrupted ECG data; (b) ECG data enhanced by removing 60-Hz
interference; (c) ECG data with DC blocking and noise removal for heart rate detection.
8.9 Application: 60 Hz Hum Eliminator and Heart Rate Detection Using ECG
367

Heart rate ¼
60
1; 500
600
 
6
2

¼ 72 pulses per minute
The MATLAB implementation of the zero-crossing detection can be found in the last part in
Program 8.16.
Program 8.16. MATLAB program for heart rate detection using an ECG signal.
load ecgbn.dat; % Load noisy ECG recording
b1 [0.9803
1.5862 0.9803]; %Notch filter with a notch frequency of 60 Hz
a1 [1
1.5842 0.9586];
b2 [0.9794
0.6053 0.9794]; % Notch filter with a notch frequency 120 Hz
a2 [1
0.6051 0.9586];
b3 [0.9793 0.6052 0.9793]; % Notch filter with a notch frequency of 180 Hz
a3 [1 0.6051 0.9586];
y1 filter(b1,a1,ecgbn); % First section filtering
y2 filter(b2,a2,y1);
% Second section filtering
y3 filter(b3,a3,y2);
% Third section filtering
%Bandpass filter
fs 600;
% Sampling rate
T 1/600;
% Sampling interval
% BLT design
wd1 2*pi*0.25;
threshold=0.5
zerocrossing=0
pre_sign= 1 and cur_sign= 1
get x(n) and x(n 1)
Get enhanced ECG data array x(n)
with N data
if x(n 1))>threshold then pre_sign=1
if x(n)>threshold then cur_sign=1
 zerocrossing=zerocrossing+
abs(cur_sign pre_sign)/2
n=n+1
is n=N ?
No
Yes
Start
Stop
FIGURE 8.46
A simple zero-crossing algorithm.
368
CHAPTER 8 Inﬁnite Impulse Response Filter Design

wd2 2*pi*40;
wa1 (2/T)*tan(wd1*T/2);
wa2 (2/T)*tan(wd2*T/2);
[B,A] lp2bp([1.4314], [1 1.4652 1.5162],sqrt(wa1*wa2),wa2 wa1);
[b,a] bilinear(B,A,fs);
b
[ 0.046361 0
0.092722 0 0.046361]
a
[1
3.352292 4.255671
2.453965 0.550587]
y4 filter(b,a,y3);
%Bandpass filtering
t 0:T:1499*T;
% Recover time
subplot(3,1,1);plot(t,ecgbn);grid;ylabel(’(a)’);
subplot(3,1,2);plot(t,y3);grid;ylabel(’(b)’);
subplot(3,1,3);plot(t,y4);grid;ylabel(’(c)’);
xlabel(’Time (sec.)’);
%Zero cross algorithm
zcross 0.0;threshold 0.5
for n 2:length(y4)
pre sign
1;cur sign
1;
if y4(n 1)>threshold
pre sign 1;
end
if y4(n)>threshold
cur sign 1;
end
zcross zcrossþabs(cur sign pre sign)/2;
end
zcross
% Output the number of zero crossings
rate 60*zcross/(2*length(y4)/600)
% Output the heart rate
8.10 COEFFICIENT ACCURACY EFFECTS ON INFINITE IMPULSE
RESPONSE FILTERS
In practical applications, the IIR ﬁlter coefﬁcients with inﬁnite precision may be quantized due
to the ﬁnite word length. Quantization of inﬁnite precision ﬁlter coefﬁcients changes the
locations of the zeros and poles of the designed ﬁlter transfer function, and thus changes the
ﬁlter frequency responses. Since analysis of ﬁlter coefﬁcient quantization for the IIR ﬁlter is
very complicated and beyond the scope of this textbook, we pick only a couple of simple cases
for discussion. Filter coefﬁcient quantization for speciﬁc processors such as the ﬁxed-point DSP
processor and ﬂoating-point processor will be included in Chapter 9. To illustrate this effect, we
look at the following ﬁrst-order IIR ﬁlter transfer function with ﬁlter coefﬁcients with inﬁnite
precision:
HðzÞ ¼ b0 þ b1z 1
1 þ a1z 1
(8.57)
8.10 Coefﬁcient Accuracy Effects on Inﬁnite Impulse Response Filters
369

After ﬁlter coefﬁcient quantization, we have the quantized digital IIR ﬁlter transfer function:
HqðzÞ ¼ bq
0 þ bq
1z 1
1 þ aq
1z 1
(8.58)
Solving for the pole and zero, we get
z1 ¼ bq
1
bq
0
(8.59)
p1 ¼ aq
1
(8.60)
Now considering a second-order IIR ﬁlter transfer function as
HðzÞ ¼ b0 þ b1z 1 þ b2z 2
1 þ a1z 1 þ a2z 2
(8.61)
and its quantized IIR ﬁlter transfer function
HqðzÞ ¼ bq
0 þ bq
1z 1 þ bq
2z 2
1 þ aq
1z 1 þ aq
2z 2
(8.62)
solving for poles and zeros yields
z1;2 ¼ 0:5$bq
1
bq
0
 j
bq
2
bq
0
 0:25$
bq
1
bq
0
21
2
(8.63)
p1;2 ¼ 0:5$aq
1  j

aq
2  0:25$

aq
1
21
2
(8.64)
With Equations (8.59) and (8.60) for the ﬁrst-order IIR ﬁlter, and Equations (8.63) and (8.64) for the
second-order IIR ﬁlter, we can study the effects of location changes of the poles and zeros, and the
frequency responses due to ﬁlter coefﬁcient quantization.
EXAMPLE 8.24
Given the ﬁrst order IIR ﬁlter
HðzÞ
1:2341 þ 0:2126z1
1
0:5126z1
and assuming that we use 1 sign bit and 6 bits for encoding the magnitude of the ﬁlter coefﬁcients, ﬁnd the
quantized transfer function and pole zero locations.
Solution:
Let us ﬁnd the pole and zero for inﬁnite precision ﬁlter coefﬁcients. Solving 1:2341z þ 0:2126
0 leads to
a zero location z1
0:17227. Solving z
0:5126
0 gives a pole location p1
0:5126.
Now let us quantize the ﬁlter coefﬁcients. Quantizing 1.2341 can be illustrated as
1:2341  25
39:4912
39 ðrounded to integerÞ
370
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Since the maximum magnitude of the ﬁlter coefﬁcients is 1.2341, which is between 1 and 2, we scale all
coefﬁcient magnitudes by a factor of 25 and round off each value to an integer whose magnitude is encoded using
6 bits. As shown in the quantization, 6 bits are required to encode the integer 39. When the coefﬁcient integer is
scaled back by the same scale factor, the corresponding quantized coefﬁcient with ﬁnite precision (7 bits,
including the sign bit) is found to be
bq
0
39=25
1:21875
Following the same procedure, we can obtain
bq
1
0:1875
and
aq
1
0:5
Thus we achieve the quantized transfer function
HqðzÞ
1:21875 þ 0:1875z1
1
0:5z1
Solving for the pole and zero leads to
p1
0:5
and
z1
0:1538
It is clear that the pole and zero locations change after the ﬁlter coefﬁcients are quantized. This
effect can change the frequency response of the designed ﬁlter as well. In Example 8.25, we study
quantization of the ﬁlter coefﬁcients for the second-order IIR ﬁlter and examine the pole/zero location
changes and magnitude/phase frequency responses.
EXAMPLE 8.25
A second order digital lowpass Chebyshev ﬁlter with a cutoff frequency of 3.4 kHz and 0.5 dB ripple on passband
at a sampling frequency of 8,000 Hz is designed. Assume that we use 1 sign bit and 7 bits for encoding the
magnitude of each ﬁlter coefﬁcient. The z transfer function is given by
HðzÞ
0:7434 þ 1:4865z1 þ 0:7434z2
1 þ 1:5149z1 þ 0:6346z2
a. Find the quantized transfer function and pole and zero locations.
b. Plot the magnitude and phase responses, respectively.
Solution:
a. Since the maximum magnitude of the ﬁlter coefﬁcients is between 1 and 2, the scale factor for quantization is
chosen to be 26, so that the coefﬁcient integer can be encoded using 7 bits.
8.10 Coefﬁcient Accuracy Effects on Inﬁnite Impulse Response Filters
371

After performing ﬁlter coefﬁcient encoding, we have
HqðzÞ
0:7500 þ 1:484375z1 þ 0:7500z2
1 þ 1:515625z1 þ 0:640625z2
For comparison, the uncoded zeros and encoded zeros of the transfer function HðzÞ are
Uncoded zeros:
1,
1
Coded zeros:
0.9896 þ 0.1440i,
0.9896
0.1440i
Similarly, the uncoded poles and coded poles of the transfer function HqðzÞ are
Uncoded poles:
0.7574 þ 0.2467i,
0.7574
0.2467i
Coded poles:
0.7578 þ 0.2569i,
0.7578
0.2569i
b. The comparisons for the magnitude responses and phase responses are listed in Program 8.17 and plotted in
Figure 8.47.
Program 8.17. MATLAB m ﬁle for Example 8.25.
% Example 8.25
% Plot the magnitude and phase responses
fs 8000;
% Sampling rate
B [0.7434 1.4868 0.7434];
A [1 1.5149 0.6346];
[hz,f] freqz(B,A,512,fs);
% Calculate reponses without coefficient quantization
phi 180*unwrap(angle(hz))/pi;
Bq [0.750 1.4834375 0.75000];
0
500
1000
1500
2000
2500
3000
3500
4000
10
5
0
Frequency (Hz)
Magn tude response (dB)
0
500
1000
1500
2000
2500
3000
3500
4000
200
150
100
50
0
50
Frequency (Hz)
Phase (degrees)
FIGURE 8.47
Frequency responses (dash-dotted line, quantized coefﬁcients; solid line, unquantized coefﬁcients).
372
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Aq [1 1.515625 0.640625];
[hzq,f] freqz(Bq,Aq,512,fs); % Calculate responses with coefficient quantization
phiq 180*unwrap(angle(hzq))/pi;
subplot(2,1,1), plot(f,20*log10(abs(hz)),f,20*log10(abs(hzq)), ’ .’);grid;
axis([0 4000
10 2])
xlabel(’Frequency (Hz)’);
ylabel(’Magnitude Response (dB)’);
subplot(2,1,2), plot(f, phi, f, phiq,’ .’); grid;
xlabel(’Frequency (Hz)’);
ylabel(’Phase (degrees)’);
From Figure 8.47, we observe that the quantization of IIR ﬁlter coefﬁcients has more effect on
magnitude response and less effect on phase response in the passband. In practice, one needs to verify
this effect to make sure that the magnitude frequency response meets the ﬁlter speciﬁcations.
8.11 APPLICATION: GENERATION AND DETECTION OF DTMF TONES USING
THE GOERTZEL ALGORITHM
In this section, we study an application of the digital ﬁlters to the generation and detection of dual-tone
multifrequency (DTMF) signals used for telephone touch keypads. In our daily life, DTMF touch tones
produced by telephone keypads on handsets are applied to dial telephone numbers routed to telephone
companies, where the DTMF tones are digitized and processed and the detected dialed telephone digits
are used for the telephone switching system to ring the party to be called. A telephone touch keypad is
shown in Figure 8.48, where each key is represented by two tones with their speciﬁed frequencies. For
example, if the key “7” is pressed, the DTMF signal with the designated frequencies of 852 Hz and
1,209 Hz is generated, which is sent to the central ofﬁce at the telephone company for processing.
1
2
3
4
5
6
7
8
9
*
0
#
1209 Hz 1336 Hz 1477 Hz
697 Hz
770 Hz
852 Hz
941 Hz
FIGURE 8.48
DTMF tone speciﬁcations.
8.11 Application: Generation and Detection of DTMF Tones
373

At the central ofﬁce, the received DTMF tones are detected through the digital ﬁlters and some logic
operations are used to decode the dialed signal consisting of 852 Hz and 1,209 Hz as key “7”. The
frequencies deﬁned for each key are in Figure 8.48.
8.11.1 Single-Tone Generator
Now, let us look at a digital tone generator whose transfer function is obtained from the z-transform
function of a sinusoidal sequence sinðnU0Þ as
HðzÞ ¼
z sin U0
z2  2z cos U0 þ 1 ¼
z 1 sin U0
1  2z 1 cos U0 þ z 2
(8.65)
where U0 is the normalized digital frequency. Given the sampling rate of the DSP system and the
frequency of the tone to be generated, we have the relationship
U0 ¼ 2pf0=fs
(8.66)
Applying the inverse z-transform to the transfer function leads to the difference equation
yðnÞ ¼ sin U0xðn  1Þ þ 2 cos U0yðn  1Þ  yðn  2Þ
(8.67)
since
Z
1ðHðzÞÞ ¼ Z
1

z sin U0
z2  2z cos U0 þ 1

¼ sinðU0nÞ ¼ sinð2pf0n=fsÞ
which is the impulse response. Hence, to generate a pure tone with an amplitude of A, an impulse
function xðnÞ ¼ AdðnÞ must be used as the input to the digital ﬁlter, as illustrated in Figure 8.49.
Now, we illustrate implementation. Assuming that the sampling rate of the DSP system is 8,000
Hz, we need to generate a digital tone of 1 kHz. Then we compute
U0 ¼ 2p  1; 000=8; 000 ¼ p=4; sin U0 ¼ 0:707107;
and
2 cos U0 ¼ 1:414214
The required ﬁlter transfer function is determined as
HðzÞ ¼
0:707107z 1
1  1:414214z 1 þ z 2
The MATLAB simulation using the input xðnÞ ¼ dðnÞ is displayed in Figure 8.50, where the top plot
is the generated tone of 1 kHz, and the bottom plot shows its spectrum. The corresponding MATLAB
code is in Program 8.18.
H z
z
z
z
( )
sin
cos
1
0
1
0
2
1 2
x n
A
n
( )
( )
Tone
y n
A
f n
f
u n
s
( )
sin(
/
) ( )
2
0
FIGURE 8.49
Single-tone generator.
374
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Note that if we replace the ﬁlter H(z) with the z-transform of other sequences such as a cosine function
and use the impulse sequence as the ﬁlter input, the ﬁlter will generate the corresponding digital wave
such as the digital cosine wave.
Program 8.18. MATLAB program for generating a sinusoid.
fs 8000;
% Sampling rate
t 0:1/fs:1;
% Time vector for 1 second
x zeros(1,length(t));
% Initialize input to be zero
x(1) 1;
% Set up impulse function
y filter([0 0.707107],[1
1.414214 1],x);
% Perform filtering
subplot(2,1,1);plot(t(1:400),y(1:400));grid
ylabel(’y(n) 1 kHz tone’); xlabel(’time (second)’)
Ak 2*abs(fft(y))/length(y);Ak(1) Ak(1)/2;
% One sided amplitude spectrum
f [0:1:(length(y) 1)/2]*fs/length(y);
% Indices to frequencies (Hz) for plot
subplot(2,1,2);plot(f,Ak(1:(length(y)þ1)/2));grid
ylabel(’Spectrum for y(n)’); xlabel(’frequency (Hz)’)
8.11.2 Dual-Tone Multifrequency Tone Generator
Now that the principle of a single-tone generator is illustrated, we can extend it to develop the DTMF
tone generator using two digital ﬁlters in parallel. The DTMF tone generator for key “7” is depicted in
Figure 8.51.
0
0.005
0.01
0.015
0.02
0.025
0.03
0.035
0.04
0.045
0.05
2
1
0
1
2
y(n) 1 KHz tone
Time (second)
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.2
0.4
0.6
0.8
1
Spectrum for y(n)
Frequency (Hz)
FIGURE 8.50
Plots of a generated single tone of 1,000 Hz and its spectrum.
8.11 Application: Generation and Detection of DTMF Tones
375

Here we generate the DTMF tone for key “7” for a duration of one second, assuming a sampling
rate of 8,000 Hz. The generated tone and its spectrum are plotted in Figure 8.52 for veriﬁcation, while
the MATLAB implementation is given in Program 8.19.
H
z
z
z
z
L
L
L
( )
sin
cos
1
1
2
1
2
H
z
z
z
z
H
H
H
sin
cos
1
1
2
1
2
A
n
( )
DTMF Tones
7
L
sf
2
852
s
H
f
2
1209
y n
7
FIGURE 8.51
Digital DTMF tone generator for the keypad digit “7”.
0
0.005
0.01
0.015
0.02
0.025
0.03
0.035
0.04
0.045
0.05
-2
-1
0
1
2
y(n) DTMF: number 7
Time (second)
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.2
0.4
0.6
0.8
1
Spectrum for y7(n)
Frequency (Hz)
FIGURE 8.52
Plots of the generate DTMF tone of “7” and its spectrum.
376
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Program 8.19. MATLAB program for DTMF tone generation.
close all; clear all
fs 8000;
% Sampling rate
t 0:1/fs:1;
% 1 second time vector
x zeros(1,length(t));
% Initialize input to be zero
x(1) 1;
% Set up impulse function
% Generate 852 Hz tone
y852 filter([0 sin(2*pi*852/fs)],[1
2*cos(2*pi*852/fs) 1],x);
% Generate 1209 Hz tone
y1209 filter([0 sin(2*pi*1209/fs) ],[1
2*cos(2*pi*1209/fs) 1],x); % Filtering
y7 y852þy1209;
% Generate DTMF tone
subplot(2,1,1);plot(t(1:400),y7(1:400));grid
ylabel(’y(n) DTMF: number 7’);
xlabel(’time (second)’)
Ak 2*abs(fft(y7))/length(y7);Ak(1) Ak(1)/2;
% One sided amplitude spectrum
f [0:1:(length(y7) 1)/2]*fs/length(y7);
% Map indices to frequencies (Hz) for plot
subplot(2,1,2);plot(f,Ak(1:(length(y7)þ1)/2));grid
ylabel(’Spectrum for y7(n)’);
xlabel(’frequency (Hz)’);
8.11.3 Goertzel Algorithm
In practice, the DTMF tone detector is designed using the Goertzel algorithm. This is a special and
powerful algorithm used for computing discrete Fourier tansform (DFT) coefﬁcients and signal spectra
using a digital ﬁltering method. The modiﬁed Goertzel algorithm can be used for computing signal
spectra without involving complex algebra like the DFT algorithm.
Speciﬁcally, the Goertzel algorithm is a ﬁltering method for computing the DFT coefﬁcient XðkÞ at
the speciﬁed frequency bin k with the given N digital data xð0Þ; xð1Þ; /; xðN  1Þ. We can begin to
illustrate the Goertzel algorithm using the second-order IIR digital Goertzel ﬁlter, whose transfer
function is given by
HkðzÞ ¼ YkðzÞ
XðzÞ ¼
1  Wk
Nz 1
1  2cos
2pk
N

z 1 þ z 2
(8.68)
with the input data xðnÞ for n ¼ 0; 1; /; N  1, and the last element set to be xðNÞ ¼ 0. Notice that
Wk
N ¼ e
2pk
N . We will process the data sequence N þ 1 times to achieve the ﬁlter output as ykðnÞ for
n ¼ 0; 1; /; N, where k is the frequency index (bin number) of interest. The DFT coefﬁcient XðkÞ is
the last datum from the Goertzel ﬁlter, that is,
XðkÞ ¼ ykðNÞ
(8.69)
The implementation of the Goertzel ﬁlter is presented by direct-form II realization in Figure 8.53.
According to the direct-form II realization, we can write the Goertzel algorithm as follows:
xðNÞ ¼ 0
(8.70)
For n ¼ 0; 1; /; N
8.11 Application: Generation and Detection of DTMF Tones
377

vkðnÞ ¼ 2 cos
2pk
N

vkðn  1Þ  vkðn  2Þ þ xðnÞ
(8.71)
yk

n

¼ vk

n

 Wk
Nvk

n  1

(8.72)
with initial conditions vkð2Þ ¼ 0, vkð1Þ ¼ 0
Then the DFT coefﬁcient XðkÞ is given as
XðkÞ ¼ ykðNÞ
(8.73)
The squared magnitude x(k) is computed as
jXðkÞj2 ¼ v2
kðNÞ þ v2
kðN  1Þ  2 cos
2pk
N

vkðNÞvkðN  1Þ
(8.74)
We show the derivation of Equation (8.74) as follows. Note that Equation (8.72) involves complex
algebra, since the equation contains only one complex number, a factor
Wk
N ¼ e j2pk
N ¼ cos
2pk
N

 j sin
2pk
N

discussed in Chapter 4. If our objective is to compute the spectrum value, we can substitute n ¼ N into
Equation (8.72) to obtain XðkÞ and multiply XðkÞ by its conjugate X	ðkÞ to achieve the squared
magnitude the DFT coefﬁcient. It follows (Ifeachor and Jervis, 2002) that
jXðkÞj2 ¼ XðkÞX	ðkÞ
Since
X

k

¼ yk

N

 Wk
Nvk

N  1

X	
k

¼ yk

N

 W
k
N vk

N  1

z 1
y n
k( )
1
WN
k
2
2
cos
k
N
x n
( )
1
v
n
k (
)
2
v
n
k ( )
z 1
v
n
k (
)1
FIGURE 8.53
Second-order Goertzel IIR ﬁlter.
378
CHAPTER 8 Inﬁnite Impulse Response Filter Design

then
jXðkÞj2 ¼

yk

N

 Wk
Nyk

N  1

yk

N

 W
k
N yk

N  1

¼ y2
k

N

þ y2
k

N  1



Wk
N þ W
k
N

yk

N

yk

N  1

(8.75)
Using Euler’s identity yields
Wk
N þ W
k
N
¼ e j2p
N k þ ej2p
N k ¼ 2 cos
2pk
N

(8.76)
Substituting Equation (8.76) into Equation (8.75) leads to Equation (8.74).
We can see that the DSP equation for vkðkÞ and computation of the squared magnitude of the DFT
coefﬁcient jXðkÞj2 do not involve any complex algebra. Hence, we will use this advantage for later
development. To illustrate the algorithm, let us consider Example 8.26.
EXAMPLE 8.26
Given a digital data sequence of length 4 as xð0Þ
1, xð1Þ
2, xð2Þ
3, and xð3Þ
4, use the Goertzel
algorithm to compute DFT coefﬁcient Xð1Þ and the corresponding spectral amplitude at the frequency bin
k
1.
Solution:
We have k
1, N
4, xð0Þ
1, xð1Þ
2, xð2Þ
3, and xð3Þ
4. Note that
2 cos
2p
4

0
and
W 1
4
ej2p1
4
cos
p
2

jsin
p
2

j
We ﬁrst write the simpliﬁed difference equations:
xð4Þ
0
For n
0; 1; /; 4
v1ðnÞ
v1ðn
2Þ þ xðnÞ
y1ðnÞ
v1ðnÞ þ jv1ðn
1Þ
Then
Xð1Þ
y1ð4Þ
jXð1Þj2
v2
1

4

þ v2
1

3

The digital ﬁlter process is demonstrated in the following:
v1ð0Þ
v1ð
2Þ þ xð0Þ
0 þ 1
1
y1ð0Þ
v1ð0Þ þ jv1ð
1Þ
1 þ j  0
1
v1ð1Þ
v1ð
1Þ þ xð1Þ
0 þ 2
2
8.11 Application: Generation and Detection of DTMF Tones
379

y1ð1Þ
v1ð1Þ þ jv1ð0Þ
2 þ j  1
2 þ j
v1ð2Þ
v1ð0Þ þ xð2Þ
1 þ 3
2
y1ð2Þ
v1ð2Þ þ jv1ð1Þ
2 þ j  2
2 þ j2
v1ð3Þ
v1ð1Þ þ xð3Þ
2 þ 4
2
y1ð3Þ
v1ð3Þ þ jv1ð2Þ
2 þ j  2
2 þ j2
v1ð4Þ
v1ð2Þ þ xð4Þ
2 þ 0
2
y1ð4Þ
v1ð4Þ þ jv1ð3Þ
2 þ j  2
2 þ j2
Then the DFT coefﬁcient and its squared magnitude are determined as
Xð1Þ
y1ð4Þ
2 þ j2
jXð1Þj2
v2
1

4

þ v2
1

3

ð
2Þ2þð2Þ2
8
Thus, the two sided amplitude spectrum is computed as
A1
1
4

jXð1Þj2
r
0:7071
and the corresponding single sided amplitude spectrum is A1
2  0:707
1:4141.
From this simple illustrative example, we see that the Goertzel algorithm has the following
advantages:
1. We can apply the algorithm for computing the DFT coefﬁcient XðkÞ for a speciﬁed frequency
bin k; unlike the fast Fourier transform (FFT) algorithm, all the DFT coefﬁcients are computed
once it is applied.
2. If we want to compute the spectrum at frequency bin k, that is, jXðkÞj, Equation (8.71) shows that
we need to process vkðnÞN þ 1 times and then compute jXðkÞj2. The operations avoid complex
algebra.
If we use the modiﬁed Goertzel ﬁlter in Figure 8.54, then the corresponding transfer function is
given by
GkðzÞ ¼ VkðzÞ
XðzÞ ¼
1
1  2 cos
2pk
N

z 1 þ z 2
(8.77)
380
CHAPTER 8 Inﬁnite Impulse Response Filter Design

The modiﬁed Goertzel algorithm becomes the following:
xðNÞ ¼ 0
For n ¼ 0; 1; /; N
vkðnÞ ¼ 2 cos
2pk
N

vkðn  1Þ  vkðn  2Þ þ xðnÞ
with initial conditions vkð2Þ ¼ 0 and vkð1Þ ¼ 0
Then the squared magnitude of the DFT coefﬁcient is given by
jXðkÞj2 ¼ v2
kðNÞ þ v2
kðN  1Þ  2 cos
2pk
N

vkðNÞvkðN  1Þ
EXAMPLE 8.27
Given a digital data sequence of length 4 as xð0Þ
1, xð1Þ
2, xð2Þ
3, and xð3Þ
4, use the Goertzel
algorithm to compute the spectral amplitude at the frequency bin k
0.
Solution:
k
0; N
4; xð0Þ
1; xð1Þ
2; xð2Þ
3;
and
xð3Þ
4
Using the modiﬁed Goertzel algorithm and noting that 2$cos
2p
4  0

2, we obtain the simpliﬁed difference
equations as follows:
xð4Þ
0
For n
0; 1; /; 4
v0ðnÞ
2v0ðn
1Þ
v0ðn
2Þ þ xðnÞ
Then
jXð0Þj2
v2
0

4

þ v2
0

3

2v0

4

v0

3

z 1
+
2 cos
k
2
N
x n
( )
1
v
n
k (
)
2
v
n
k ( )
z 1
v
n
k (
)1
FIGURE 8.54
Modiﬁed second-order Goertzel IIR ﬁlter.
8.11 Application: Generation and Detection of DTMF Tones
381

The digital ﬁltering is performed as
v0ð0Þ
2v0ð
1Þ
v0ð
2Þ þ xð0Þ
0 þ 0 þ 1
1
v0ð1Þ
2v0ð0Þ
v0ð
1Þ þ xð1Þ
2  1 þ 0 þ 2
4
v0ð2Þ
2v0ð1Þ
v0ð0Þ þ xð2Þ
2  4
1 þ 3
10
v0ð3Þ
2v0ð2Þ
v0ð1Þ þ xð3Þ
2  10
4 þ 4
20
v0ð4Þ
2v0ð3Þ
v0ð2Þ þ xð4Þ
2  20
10 þ 0
30
Then the squared magnitude is determined by
jXð0Þj2
v2
0

4

þ v2
0

3

2v0

4

v0

3

ð30Þ2þð20Þ2
2  30  20
100
Thus, the amplitude spectrum is computed as
A0
1
4

jXð0Þj2
r
2:5
A MATLAB function for the Geortzel algorithm is shown in Program 8.20.
Program 8.20. MATLAB function for Geortzel Algorithm.
function [ Xk, Ak]
galg(x,k)
% Geortzel Algorithm
% [ Xk, Ak]
galg(x,k)
% x input vetcor; k frequency index
% Xk
kth DFT coeficient; Ak magnitude of the kth DFT coefficient
N length(x); x [x 0];
vk zeros(1,Nþ3);
for n 1:Nþ1
vk(nþ2) 2*cos(2*pi*k/N)*vk(nþ1) vk(n)þx(n);
end
Xk vk(Nþ3) exp( 2*pi*j*k/N)*vk(Nþ2);
Ak vk(Nþ3)*vk(Nþ3)þvk(Nþ2)*vk(Nþ2) 2*cos(2*pi*k/N)*vk(Nþ3)*vk(Nþ2);
Ak sqrt(Ak)/N;
end
EXAMPLE 8.28
Use Program 8.20 to verify the results in Examples 8.26 and 8.27.
Solution:
a. For Example 8.26, we obtain
>> x [1 2 3 4]
382
CHAPTER 8 Inﬁnite Impulse Response Filter Design

x
1 2 3 4
>> [X1, A1] galg(x,1)
X1
2.0000 þ 2.0000i
A1
0.7071
b. For Example 8.27, we obtain
>> x [1 2 3 4]
x
1 2 3 4
>> [X0, A0] galg(x,1)
X0
10
A0
2.5000
8.11.4 Dual-Tone Multifrequency Tone Detection Using
the Modiﬁed Goertzel Algorithm
Based on the speciﬁed frequencies of each DTMF tone shown in Figure 8.48 and the modiﬁed Goertzel
algorithm, we can develop the following design principles for DTMF tone detection.
1. When the digitized DTMF tone xðnÞ is received, it has two nonzero frequency components from the
following seven: 697, 770, 852, 941, 1,209, 1,336, and 1,477 Hz.
2. We can apply the modiﬁed Goertzel algorithm to compute seven spectral values, which
correspond
to
the
seven
frequencies
in
(1).
The
single-sided
amplitude
spectrum
is
computed as
Ak ¼ 2
N
jXðkÞj2
q
(8.78)
3. Since the modiﬁed Goertzel algorithm is used, there is no complex algebra involved. Ideally, there
are two nonzero spectral components. We will use these two nonzero spectral
components to determine which key is pressed.
4. The frequency bin number (frequency index) can be determined based on the sampling rate
fs, and the data size of N via the following relation:
k ¼ f
fs
 N ðround off to an integerÞ
(8.79)
Given the key frequency speciﬁcation in Table 8.12, we can determine the frequency bin k for each
DTMF frequency with fs ¼ 8;000 Hz and N ¼ 205.
The DTMF detector block diagram is shown in Figure 8.55.
5. The threshold value can be the sum of all seven spectral values divided by a factor of 4. Note
that there are only two nonzero spectral values, hence the threshold value should ideally be half
of the individual nonzero spectral value. If the spectrum value is larger than the threshold
value, then the logic operation outputs logic 1; otherwise, it outputs logic 0. Finally, the
logic operation at the last stage is to decode the key information based on the 7-bit binary
pattern.
8.11 Application: Generation and Detection of DTMF Tones
383

EXAMPLE 8.29
Given a DSP system with fs
8;000 Hz and data size N
205, seven Goertzel IIR ﬁlters are implemented for
DTMF tone detection. Determine the following for the frequencies corresponding to key 7.
a. Frequency bin numbers
b. The Goertzel ﬁlter transfer functions and DSP equations
c. Equations for calculating amplitude spectral values
Table 8.12 DTMF Frequencies and Their Frequency
Bins
DTMF Frequency (Hz)
Frequency Bin: k [ f
fs
3N
697
18
770
20
852
22
941
24
1209
31
1336
34
1477
38
H
z
18( )
H
z
20( )
H
z
22( )
H
z
24( )
H
z
31( )
H
z
34( )
H
z
38( )
x n
y n
( )
( )
7
DTMF Tone
A18
A20
/
)
( A
A
A
A
A
A
A
18
20
22
24
31
34
38
4
Threshold
logic
logic
logic
logic
logic
logic
logic
logic
7
1
0
0
0
1
0
0
A22
A24
A31
A34
A38
v
n
18( )
v
n
20( )
v
n
22( )
v
n
24( )
v
n
31( )
v
n
34( )
v
n
38( )
FIGURE 8.55
DTMF detector using the Goertzel algorithm.
384
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Solution:
For key 7, we have fL
852 Hz and fH
1;209 Hz.
a. Using Equation (8.79), we get
kL
852
8; 000  205 z 22
and
kH
1; 209
8; 000  205 z 31
b. Since 2cos
2p  22
205

1:5623,
and
2cos
2p  31
205

1:1631, it follows that
H22ðzÞ
1
1
1:5623z1 þ z2
and
H31ðzÞ
1
1
1:1631z1 þ z2
The DSP equations are therefore given by
v22ðnÞ
1:5623v22ðn
1Þ
v22ðn
2Þ þ xðnÞ with xð205Þ
0; for n
0; 1; /; 205
v31ðnÞ
1:1631v31ðn
1Þ
v31ðn
2Þ þ xðnÞ with xð205Þ
0; for n
0; 1; /; 205
c. The amplitude spectral values are determined by
jXð22Þj2
ðv22ð205ÞÞ2þðv22ð204ÞÞ2
1:5623ðv22ð205ÞÞ  ðv22ð204ÞÞ
A22
2
jXð22Þj2
q
205
and
jXð31Þj2
ðv31ð205ÞÞ2þðv31ð204ÞÞ2
1:1631ðv31ð205ÞÞ  ðv31ð204ÞÞ
A31
2
jXð31Þj2
q
205
The MATLAB simulation for decoding key 7 is shown in Program 8.21. Figure 8.56(a) shows the
frequency responses of the second-order Goertzel bandpass ﬁlters. The input is generated as shown in
Figure 8.52. After ﬁltering, the calculated spectral values and threshold value for decoding key 7 are
displayed in Figure 8.56(b), where only two spectral values corresponding to the frequencies of 770 Hz
and 1,209 Hz are above the threshold, and are encoded as logic 1. According to the key information in
the Figure 8.55, the ﬁnal logic operation decodes the key as 7.
The principle can easily be extended to transmit the ASCII (American Standard Code for Infor-
mation Interchange) code or other types of code using the parallel Goertzel ﬁlter bank. If the calculated
spectral value is larger than the threshold value, then the logic operation outputs logic 1; otherwise,
8.11 Application: Generation and Detection of DTMF Tones
385

it outputs logic 0. Finally, the logic operation at the last stage decodes the key information based on the
7-bit binary pattern.
Program 8.21. DTMF detection using the Goertzel algorithm.
close all;clear all;
% DTMF tone generator
N 205;
fs 8000; t [0:1:N 1]/fs;
% Sampling rate and time vector
x zeros(1,length(t));x(1) 1;
% Generate the impulse function
%Generation of tones
y697 filter([0 sin(2*pi*697/fs)],[1
2*cos(2*pi*697/fs) 1],x);
y770 filter([0 sin(2*pi*770/fs)],[1
2*cos(2*pi*770/fs) 1],x);
y852 filter([0 sin(2*pi*852/fs)],[1
2*cos(2*pi*852/fs) 1],x);
y941 filter([0 sin(2*pi*941/fs)],[1
2*cos(2*pi*941/fs) 1],x);
y1209 filter([0 sin(2*pi*1209/fs) ],[1
2*cos(2*pi*1209/fs) 1],x);
y1336 filter([0 sin(2*pi*1336/fs)],[1
2*cos(2*pi*1336/fs) 1],x);
y1477 filter([0 sin(2*pi*1477/fs)],[1
2*cos(2*pi*1477/fs) 1],x);
key input(’input of the following keys: 1,2,3,4,5,6,7,8,9,*,0,#
>’,’s’);
yDTMF [];
if key
’1’ yDTMF y697þy1209; end
if key
’2’ yDTMF y697þy1336; end
if key
’3’ yDTMF y697þy1477; end
if key
’4’ yDTMF y770þy1209; end
0
500
1000
1500
2000
2500
3000
3500
4000
0
500
1000
1500
2000
Frequency (Hz)
 F lter bank freq  responses
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.5
1
1.5
Frequency (Hz)
Spectral values
 (b) 
(a)
FIGURE 8.56
(a) Goertzel ﬁlter bank frequency responses; (b) display of spectral values and threshold for key 7.
386
CHAPTER 8 Inﬁnite Impulse Response Filter Design

if key
’5’ yDTMF y770þy1336; end
if key
’6’ yDTMF y770þy1477; end
if key
’7’ yDTMF y852þy1209; end
if key
’8’ yDTMF y852þy1336; end
if key
’9’ yDTMF y852þy1477; end
if key
’*’ yDTMF y941þy1209; end
if key
’0’ yDTMF y941þy1336; end
if key
’#’ yDTMF y941þy1477; end
if size(yDTMF)
0 disp(’Invalid input key’); return; end
yDTMF [yDTMF 0];
% DTMF signal appended with a zero
% DTMF detector (use Goertzel algorithm)
a697 [1
2*cos(2*pi*18/N) 1];
a770 [1
2*cos(2*pi*20/N) 1];
a852 [1
2*cos(2*pi*22/N) 1];
a941 [1
2*cos(2*pi*24/N) 1];
a1209 [1
2*cos(2*pi*31/N) 1];
a1336 [1
2*cos(2*pi*34/N) 1];
a1477 [1
2*cos(2*pi*38/N) 1];
% Filter bank frequency responses
[w1, f] freqz(1,a697,512,fs);
[w2, f] freqz(1,a770,512,fs);
[w3, f] freqz(1,a852,512,fs);
[w4, f] freqz(1,a941,512,fs);
[w5, f] freqz(1,a1209,512,fs);
[w6, f] freqz(1,a1336,512,fs);
[w7, f] freqz(1,a1477,512,fs);
subplot(2,1,1);plot(f,abs(w1),f,abs(w2),f,abs(w3), .
f,abs(w4),f,abs(w5),f,abs(w6),f,abs(w7));grid
xlabel(’Frequency (Hz)’); ylabel(’(a) Filter bank freq. responses’);
% Filter bank bandpass filtering
y697 filter(1,a697,yDTMF);
y770 filter(1,a770,yDTMF);
y852 filter(1,a852,yDTMF);
y941 filter(1,a941,yDTMF);
y1209 filter(1,a1209,yDTMF);
y1336 filter(1,a1336,yDTMF);
y1477 filter(1,a1477,yDTMF);
% Determine the absolute magnitude of DFT coefficents
m(1) sqrt(y697(206)^2þy697(205)^2
.
2*cos(2*pi*18/205)*y697(206)*y697(205));
m(2) sqrt(y770(206)^2þy770(205)^2
.
2*cos(2*pi*20/205)*y770(206)*y770(205));
m(3) sqrt(y852(206)^2þy852(205)^2
.
2*cos(2*pi*22/205)*y852(206)*y852(205));
m(4) sqrt(y941(206)^2þy941(205)^2
.
2*cos(2*pi*24/205)*y941(206)*y941(205));
m(5) sqrt(y1209(206)^2þy1209(205)^2
.
2*cos(2*pi*31/205)*y1209(206)*y1209(205));
8.11 Application: Generation and Detection of DTMF Tones
387

m(6) sqrt(y1336(206)^2þy1336(205)^2
.
2*cos(2*pi*34/205)*y1336(206)*y1336(205));
m(7) sqrt(y1477(206)^2þy1477(205)^2
.
2*cos(2*pi*38/205)*y1477(206)*y1477(205));
% Convert the magnitude of DFT coefficients to the single side spectrum
m 2*m/205;
% Determine the threshold
th sum(m)/4;
% Plot the DTMF spectrum with the threshold
f [ 697 770 852 941 1209 1336 1477];
f1 [0 fs/2];
th [ th th];
subplot(2,1,2);stem(f,m);grid;hold; plot(f1,th);
xlabel(’Frequency (Hz)’); ylabel(’ (b) Spectral values’);
m round(m); % Round to the binary pattern
if m
[ 1 0 0 0 1 0 0] disp(’Detected Key 1’); end
if m
[ 1 0 0 0 0 1 0] disp(’Detected Key 2’); end
if m
[ 1 0 0 0 0 0 1] disp(’Detected Key 3’); end
if m
[ 0 1 0 0 1 0 0] disp(’Detected Key 4’); end
if m
[ 0 1 0 0 0 1 0] disp(’Detected Key 5’); end
if m
[ 0 1 0 0 0 0 1] disp(’Detected Key 6’); end
if m
[ 0 0 1 0 1 0 0] disp(’Detected Key 7’); end
if m
[ 0 0 1 0 0 1 0] disp(’Detected Key 8’); end
if m
[ 0 0 1 0 0 0 1] disp(’Detected Key 9’); end
if m
[ 0 0 0 1 1 0 0] disp(’Detected Key *’); end
if m
[ 0 0 0 1 0 1 0] disp(’Detected Key 0’); end
if m
[ 0 0 0 1 0 0 1] disp(’Detected Key #’); end
8.12 SUMMARY OF INFINITE IMPULSE RESPONSE (IIR) DESIGN
PROCEDURES AND SELECTION OF THE IIR FILTER DESIGN METHODS IN
PRACTICE
In this section, we ﬁrst summarize the design procedures of the BLT design, impulse-invariant design,
and pole-zero placement design methods, and then discuss the selection of the particular ﬁlter for
typical applications.
The BLT design method:
1. Given the digital ﬁlter frequency speciﬁcations, prewarp each digital frequency edge to the analog
frequency edge using Equations (8.18) and (8.19).
2. Determine the prototype ﬁlter order using Equation (8.29) for the Butterworth ﬁlter or Equation
(8.35b) for the Chebyshev ﬁlter, and perform lowpass prototype transformation using the
lowpass prototype in Table 8.3 (Butterworth function) or Tables 8.4 and 8.5 (Chebyshev
function) using Equations (8.20) to (8.23).
3. Apply the BLT to the analog ﬁlter using Equation (8.24) and output the transfer function.
4. Verify the frequency responses, and output the difference equation.
388
CHAPTER 8 Inﬁnite Impulse Response Filter Design

The impulse-invariant design method:
1. Given the lowpass or bandpass ﬁlter frequency speciﬁcations, perform analog ﬁlter design. For the
highpass or bandstop ﬁlter design, quit this method and use the BLT.
a. Determine the prototype ﬁlter order using Equation (8.29) for the Butterworth ﬁlter or Equation
(8.35b) for the Chebyshev ﬁlter.
b. Perform lowpass prototype transformation using the lowpass prototype in Table 8.3
(Butterworth function) or Tables 8.4 and 8.5 (Chebyshev functions) using Equations (8.20)
to (8.23).
c. Skip step 1 if the analog ﬁlter transfer function is given to begin with.
2. Determine the impulse response by applying the partial fraction expansion technique to the analog
transfer function and inverse Laplace transform using Equation (8.37).
3. Sample the analog impulse response using Equation (8.38) and apply the z-transform to the digital
impulse function to obtain the digital ﬁlter transfer function.
4. Verify the frequency response, and output the difference equation. If the frequency speciﬁcations
are not net, quit the design method and use the BLT.
The pole-zero placement method:
1. Given the ﬁlter cutoff frequency speciﬁcations, determine the pole-zero locations using the
corresponding equations:
a. Second-order bandpass ﬁlter: Equations (8.41) and (8.42).
b. Second-order notch ﬁlter: Equations (8.45) and (8.46).
c. First-order lowpass ﬁlter: Equations (8.49) or (8.50).
d. First-order highpass ﬁlter: Equations (8.53) or (8.54).
2. Apply the corresponding equation and scale factor to obtain the digital ﬁlter transfer function:
a. Second-order bandpass ﬁlter: Equations (8.43) and (8.44).
b. Second-order notch ﬁlter: Equations (8.47) and (8.48).
c. First-order lowpass ﬁlter: Equations (8.51) and (8.52).
d. First-order highpass ﬁlter: Equations (8.55) and (8.56).
3. Verify the frequency response, and output the difference equation. If the frequency speciﬁcations
are not net, quit the design method and use BLT.
Table 8.13 compares the design parameters of the three design methods.
Performance comparisons using three methods are given in Figure 8.57, where the bandpass ﬁlter is
designed using the following speciﬁcations:
Passband ripple ¼ 3 dB
Center frequency ¼ 400 Hz
Bandwidth ¼ 200 Hz
Sampling rate ¼ 2,000 Hz
Butterworth IIR ﬁlter ¼ second-order
As we expected, the BLT method satisﬁes the design requirement, and the pole-zero placement method
has little performance degradation because r ¼ 1  ðf0=fsÞp ¼ 0:6858 < 0:9, and this effect will
also cause the center frequency to be shifted. For the bandpass ﬁlter designed using the impulse-
invariant method, the gain at the center frequency is scaled to 1 for a frequency response shape
8.12 Summary of Inﬁnite Impulse Response (IIR)
389

comparison. The performance of the impulse-invariant method is satisfactory in the passband.
However, it has signiﬁcant performance degradation in the stopband when compared with the other
two methods. This is due to aliasing when sampling the analog impulse response in time domain.
Improvement in using the pole-zero placement and impulse-invariant methods can be achieved by
using a very high sampling rate. Example 8.30 describes the possible selection of the design method by
a DSP engineer to solve a real-world problem.
EXAMPLE 8.30
Determine an appropriate IIR ﬁlter design method for each of the following DSP applications. As described in
a previous section, we apply a notch ﬁlter to remove the 60 Hz interference and cascade a bandpass ﬁlter to
remove noise in an ECG signal for heart rate detection. The following speciﬁcations are required:
Notch ﬁlter:
Harmonics to be removed
60 Hz
3dB bandwidth for the notch ﬁlter
4 Hz
Bandpass ﬁlter:
Passband frequency range
0.25 to 40 Hz
Passband ripple
0.5 dB
Sampling rate
600 Hz
Table 8.13 Comparisons of Three IIR Design Methods
Design Method
BLT
Impulse Invariant
Pole-Zero Placement
Filter type
Lowpass, highpass,
bandpass, bandstop
Appropriate for lowpass
and bandpass
Second-order for
bandpass and band
stop; ﬁrst-order for
lowpass and highpass
Linear phase
No
No
No
Ripple and stopband
speciﬁcations
Used for determining
the ﬁlter order
Used for determining
the ﬁlter order
Not required;
3 dB on passband
offered
Special requirement
None
Very high sampling
relative to the cutoff
frequency (LPF) or to
upper cutoff frequency
(BPF)
Narrow band for BPF or
notch ﬁlter;
lower cutoff frequency
or higher cutoff
frequency for LPF or
HPF.
Algorithm complexity
High: Frequency
prewarping,
analog ﬁlter design,
BLT
Moderate: Analog ﬁlter
design
determining digital
impulse response;
apply z-transform
Low: Design
equations
Minimum design tool
Calculator, algebra
Calculator, algebra
Calculator
BLT ¼ blinear transformation; LPF ¼ lowpass ﬁlter; BPF ¼ bandpass ﬁlter; HPF ¼ highpass ﬁlter.
390
CHAPTER 8 Inﬁnite Impulse Response Filter Design

The pole zero placement method is the best choice, since the notch ﬁlter to be designed has a very narrow 3 dB
bandwidth of 4 Hz. This simple design gives a quick solution. Since the bandpass ﬁlter requires a passband ripple
of 0.5 dB from 0.25 to 40 Hz, the BLT can also be an appropriate choice. Even though the impulse invariant
method could work for this case, since the sampling rate of 600 Hz is much larger than 40 Hz, aliasing cannot be
prevented completely. Hence, the BLT is a preferred design method for the bandpass ﬁlter.
8.13 SUMMARY
1. The BLT method is able to transform the transfer function of an anolog ﬁlter to the transfer
function of the corresponding digital ﬁlter in general.
2. The BLT maps the left half of an s-plane to the inside unit circle of the z-plane. Stability of
mapping is guaranteed.
3. The BLT causes analog frequency warping. The analog frequency range from 0 Hz to inﬁnite is
warped to a digital frequency range from 0 Hz to the folding frequency.
4. Given the digital frequency speciﬁcations, analog ﬁlter frequency speciﬁcations must be
developed using the frequency warping equation before designing the corresponding analog
ﬁlter and applying the BLT.
0
100
200
300
400
500
600
700
800
900
1000
-20
-18
-16
-14
-12
-10
-8
-6
-4
-2
0
2
Frequency (Hz)
Magn tude responses (dB)
Bilinear
transformation
method
Pole-zero
placement
method
Impulse invariant
method
FIGURE 8.57
Performance comparisons for the BLT, pole-zero placement, and impulse-invariant methods.
8.13 Summary
391

5. An analog ﬁlter transfer function can be obtained by using a lowpass prototype, which can be
selected from the Butterworth and Chebyshev functions.
6. Higher-order IIR ﬁlters can be designed using a cascade form.
7. The impulse-invariant design method maps the analog impulse response to the digital equivalent
impulse response. The method works for lowpass and bandpass ﬁlter design with a very high
sampling rate. It is not appropriate for the highpass and bandstop ﬁlter design.
8. The pole-zero placement method can be applied for simple IIR ﬁlter designs such as second-order
bandpass and bandstop ﬁlters with narrow band speciﬁcations, and ﬁrst-order lowpass and
highpass ﬁlters with the cutoff frequency close to either DC or the folding frequency.
9. Quantization of IIR ﬁlter coefﬁcients has more effect on the magnitude frequency response than
on the phase frequency response. It may cause the quantized IIR ﬁlter to be unstable.
10. A simple audio equalizer uses bandpass IIR ﬁlter banks to create sound effects.
11. The 60-Hz interference eliminator is designed to enhance biomedical ECG signals for heart rate
detection. It can also be adapted for audio humming noise elimination.
12. A single tone or a DTMF tone can be generated using the IIR ﬁlter with the impulse sequence as
the ﬁlter input.
13. The Goertzel algorithm is applied for DTMF tone detection. This is an important application in
the telecommunication industry.
14. The procedures for the BLT, impulse-invariant, and pole-zero placement design methods
were summarized, and their design feasibilities were compared, including the ﬁlter type, linear
phase, ripple and stopband speciﬁcations, special requirements, algorithm comlexity, and design
tool(s).
8.14 PROBLEMS
8.1. Given an analog ﬁlter with the transfer function
HðsÞ ¼
1; 000
s þ 1; 000
convert it to the digital ﬁlter transfer function and difference equation using the BLT if the
DSP system has a sampling period of T ¼ 0:001 second.
8.2. The lowpass ﬁlter with a cutoff frequency of 1 rad/sec is given as
HPðsÞ ¼
1
s þ 1
a. Use HPðsÞ and the BLT to obtain a corresponding IIR digital lowpass ﬁlter with a cutoff
frequency of 30 Hz, assuming a sampling rate of 200 Hz.
b. Use MATLAB to plot the magnitude and phase frequency responses of HðzÞ.
8.3. The normalized lowpass ﬁlter with a cutoff frequency of 1 rad/sec is given as
HPðsÞ ¼
1
s þ 1
392
CHAPTER 8 Inﬁnite Impulse Response Filter Design

a. Use HPðsÞ and the BLT to obtain a corresponding IIR digital highpass ﬁlter with a cutoff
frequency of 30 Hz, assuming a sampling rate of 200 Hz.
b. Use MATLAB to plot the magnitude and phase frequency responses of HðzÞ.
8.4. Consider the normalized lowpass ﬁlter with a cutoff frequency of 1 rad/sec:
HPðsÞ ¼
1
s þ 1
a. Use HPðsÞ and the BLT to design a corresponding IIR digital notch (bandstop) ﬁlter with
a lower cutoff frequency of 20 Hz, an upper cutoff frequency of 40 Hz, and a sampling rate
of 120 Hz.
b. Use MATLAB to plot the magnitude and phase frequency responses of HðzÞ.
8.5. Consider the following normalized lowpass ﬁlter with a cutoff frequency of 1 rad/sec:
HPðsÞ ¼
1
s þ 1
a. Use HPðsÞ and the BLT to design a corresponding IIR digital bandpass ﬁlter with a low-
er cutoff frequency of 15 Hz, an upper cutoff frequency of 25 Hz, and a sampling rate of
120 Hz.
b. Use MATLAB to plot the magnitude and phase frequency responses of HðzÞ.
8.6. Design a ﬁrst-order digital lowpass Butterworth ﬁlter with a cutoff frequency of 1.5 kHz and a
passband ripple of 3 dB at a sampling frequency of 8,000 Hz.
a. Determine the transfer function and difference equation.
b. Use MATLAB to plot the magnitude and phase frequency responses.
8.7. Design a second-order digital lowpass Butterworth ﬁlter with a cutoff frequency of 1.5 kHz
and a passband ripple of 3 dB at a sampling frequency of 8,000 Hz.
a. Determine the transfer function and difference equation.
b. Use MATLAB to plot the magnitude and phase frequency responses.
8.8. Design a third-order digital highpass Butterworth ﬁlter with a cutoff frequency of 2 kHz and
a passband ripple of 3dB at a sampling frequency of 8,000 Hz.
a. Determine the transfer function and difference equation.
b. Use MATLAB to plot the magnitude and phase frequency responses.
8.9. Design a second-order digital bandpass Butterworth ﬁlter with a lower cutoff frequency of
1.9 kHz, an upper cutoff frequency 2.1 kHz, and a passband ripple of 3dB at a sampling
frequency of 8,000 Hz.
a. Determine the transfer function and difference equation.
b. Use MATLAB to plot the magnitude and phase frequency responses.
8.13 Summary
393

8.10. Design a second-order digital bandstop Butterworth ﬁlter with a center frequency of 1.8 kHz,
a bandwidth of 200 Hz, and a passband ripple of 3dB at a sampling frequency of 8,000 Hz.
a. Determine the transfer function and difference equation.
b. Use MATLAB to plot the magnitude and phase frequency responses.
8.11. Design a ﬁrst-order digital lowpass Chebyshev ﬁlter with a cutoff frequency of 1.5 kHz and
a passband ripple of 1 dB at a sampling frequency of 8,000 Hz.
a. Determine the transfer function and difference equation.
b. Use MATLAB to plot the magnitude and phase frequency responses.
8.12. Design a second-order digital lowpass Chebyshev ﬁlter with a cutoff frequency of 1.5 kHz
and a passband ripple of 0.5 dB at a sampling frequency of 8,000 Hz. Use MATLAB to plot
the magnitude and phase frequency responses.
8.13. Design a third-order digital highpass Chebyshev ﬁlter with a cutoff frequency of 2 kHz and
a passband ripple fo 1 dB at a sampling frequency of 8,000 Hz.
a. Determine the transfer function and difference equation.
b. Use MATLAB to plot the magnitude and phase frequency responses.
8.14. Design a second-order digital bandpass Chebyshev ﬁlter with the following speciﬁcations:
Center frequency of 1.5 kHz
Bandwidth of 200 Hz
0.5 dB passband ripple
Sampling frequency of 8,000 Hz
a. Determine the transfer function and difference equation.
b. Use MATLAB to plot the magnitude and phase frequency responses.
8.15. Design a second-order bandstop digital Chebyshev ﬁlter with the following speciﬁcations:
Center frequency of 2.5 kHz
Bandwidth of 200 Hz
1 dB stopband ripple
Sampling frequency of 8,000 Hz.
a. Determine the transfer function and difference equation.
b. Use MATLAB to plot the magnitude and phase frequency responses.
8.16. Design a fourth-order low pass digital Butterworth ﬁlter with a cutoff frequency of 2 kHz,
and a passband ripple of 3 dB at a sampling frequency at 8,000 Hz.
a. Determine transfer function and difference equation;
b. Use MATLAB to plot the magnitude and phase frequency responses.
394
CHAPTER 8 Inﬁnite Impulse Response Filter Design

8.17. Design a fourth-order digital lowpass Chebyshev ﬁlter with a cutoff frequency of 1.5 kHz and
a 0.5 dB passband ripple at a sampling frequency of 8,000 Hz.
a. Determine the transfer function and difference equation.
b. Use MATLAB to plot the magnitude and phase frequency responses.
8.18. Design a fourth-order digital bandpass Chebyshev ﬁlter with a center frequency of 1.5 kHz,
a bandwidth of 200 Hz, and a 0.5 dB passband ripple at a sampling frequency of 8,000 Hz.
a. Determine the transfer function and difference equation.
b. Use MATLAB to plot the magnitude and phase frequency responses.
8.19. Consider the following Laplace transfer function:
HðsÞ ¼
10
s þ 10
a. Determine HðzÞ and the difference equation using the impulse-invariant method if the
sampling rate fs ¼ 10 Hz.
b. Use MATLAB to plot the magnitude frequency response jHðfÞj and the phase frequency
response fðf Þ with respect to HðsÞ for the frequency range from 0 to fs=2 Hz.
c. Use MATLAB to plot the magnitude frequency response
HðejUÞ
 ¼ jHðej2pfTÞj and the
phase frequency response fðfÞ with respect to HðzÞ for the frequency range from 0 to
fs=2 Hz.
8.20. Consider the following Laplace transfer function:
HðsÞ ¼
1
s2 þ 3s þ 2
a. Determine HðzÞ and the difference equation using the impulse-invariant method if the
sampling rate fs ¼ 10 Hz.
b. Use MATLAB to plot the magnitude frequency response jHðfÞj and the phase frequency
response fðf Þ with respect to HðsÞ for the frequency range from 0 to fs=2 Hz.
c. Use MATLAB to plot the magnitude frequency response
HðejUÞ
 ¼ jHðej2pfTÞj and the
phase frequency response 4ðfÞ with respect to HðzÞ for the frequency range from 0 to
fs=2 Hz.
8.21. Consider the following Laplace transfer function:
HðsÞ ¼
s
s2 þ 4s þ 5
a. Determine HðzÞ and the difference equation using the impulse-invariant method if the
sampling rate fs ¼ 10 Hz.
8.13 Summary
395

b. Use MATLAB to plot the magnitude frequency response jHðfÞj and the phase frequency
response fðfÞ with respect to HðsÞ for the frequency range from 0 to fs=2 Hz;
c. Use MATLAB to plot the magnitude frequency response
HðejUÞ
 ¼ jHðej2pfTÞj and the
phase frequency response fðfÞ with respect to HðzÞ for the frequency range from 0 to
fs=2 Hz.
8.22. A second-order bandpass ﬁlter is required to satisfy the following speciﬁcations:
Sampling rate ¼ 8,000 Hz
3 dB bandwidth: BW ¼ 100 Hz
Narrow passband centered at f0 ¼ 2;000 Hz
Zero gain at 0 Hz and 4,000 Hz
Find the transfer function and difference equation by the pole-zero placement method.
8.23. A second-order notch ﬁlter is required to satisfy the following speciﬁcations:
Sampling rate ¼ 8,000 Hz
3 dB bandwidth: BW ¼ 200 Hz
Narrow passband centered at f0 ¼ 1;000 Hz.
Find the transfer function and difference equation by the pole-zero placement method.
8.24. A ﬁrst-order lowpass ﬁlter is required to satisfy the following speciﬁcations:
Sampling rate ¼ 8,000 Hz
3 dB cutoff frequency: fc ¼ 200 Hz
Zero gain at 4,000 Hz
Find the transfer function and difference equation using the pole-zero placement method.
8.25. A ﬁrst-order lowpass ﬁlter is required to satisfy the following speciﬁcations:
Sampling rate ¼ 8,000 Hz
3 dB cutoff frequency: fc ¼ 3;800 Hz
Zero gain at 4,000 Hz
Find the transfer function and difference equation by the pole-zero placement method.
8.26. A ﬁrst-order highpass ﬁlter is required to satisfy the following speciﬁcations:
Sampling rate ¼ 8,000 Hz
3 dB cutoff frequency: fc ¼ 3;850 Hz
Zero gain at 0 Hz
Find the transfer function and difference equation by the pole-zero placement method.
396
CHAPTER 8 Inﬁnite Impulse Response Filter Design

8.27. A ﬁrst-order highpass ﬁlter is required to satisfy the following speciﬁcations:
Sampling rate ¼ 8,000 Hz
3 dB cutoff frequency: fc ¼ 100 Hz
Zero gain at 0 Hz
Find the transfer function and difference equation by the pole-zero placement method.
8.28. Given a ﬁlter transfer function
HðzÞ ¼ 0:3430z2 þ 0:6859z þ 0:3430
z2 þ 0:7075z þ 0:7313
a. realize the digital ﬁlter using direct-form I and using direct-form II;
b. determine the difference equations for each implementation.
8.29. Given a fourth-order ﬁlter transfer function,
HðzÞ ¼ 0:3430z2 þ 0:6859z þ 0:3430
z2 þ 0:7075z þ 0:7313
 0:4371z2 þ 0:8742z þ 0:4371
z2  0:1316z þ 0:1733
a. realize the digital ﬁlter using the cascade (series) form via second-order sections using
direct-form II;
b. determine the difference equations for implementation.
8.30. Given a DSP system with a sampling rate of 1,000 Hz, develop a 200 Hz single tone
generator using the digital IIR ﬁlter by completing the following steps:
a. Determine the digital IIR ﬁlter transfer function.
b. Determine the DSP equation (difference equation).
8.31. Given a DSP system with a sampling rate of 8,000 Hz, develop a 250 Hz single tone
generator using the digital IIR ﬁlter by completing the following steps:
a. Determine the digital IIR ﬁlter transfer function.
b. Determine the DSP equation (difference equation).
8.32. Given a DSP system with a sampling rate of 8,000 Hz, develop a DTMF tone generator for
key 9 using the digital IIR ﬁlters by completing the following steps:
a. Determine the digital IIR ﬁlter transfer functions.
b. Determine the DSP equations (difference equation).
8.33. Given a DSP system with a sampling rate 8,000 Hz, develop a DTMF tone generator for key
3 using the digital IIR ﬁlters by completing the following steps:
a. Determine the digital IIR ﬁlter transfer functions.
b. Determine the DSP equations (difference equation).
8.13 Summary
397

8.34. Given xð0Þ ¼ 1, xð1Þ ¼ 2, xð2Þ ¼ 0, xð3Þ ¼ 1, use the Goertzel algorithm to compute
the following DFT coefﬁcients and their amplitude spectrum:
a. Xð0Þ
b. jXð0Þj2
c. A0 (single side)
d. Xð1Þ
e. jXð1Þj2
f. A1 (single side)
8.35. Repeat Problem 8.34 for Xð2Þ and Xð3Þ.
8.36. Given a digital data sequence of length 4 as xð0Þ ¼ 4, xð1Þ ¼ 3, xð2Þ ¼ 2, and xð3Þ ¼ 1,
use the modiﬁed Goertzel algorithm to compute the spectral amplitude at the frequency bin
k ¼ 0 and k ¼ 2.
8.37. Repeat Problem 8.36 for Xð1Þ and Xð3Þ.
Use MATLAB to solve Problems 8.38 to 8.50.
8.38. A speech sampled at 8,000 Hz is corrupted by a sine wave of 360 Hz. Design a notch ﬁlter to
remove the noise with the following speciﬁcations:
Chebyshev notch ﬁlter
Center frequency: 360 Hz
Bandwidth: 60 Hz
Passband ripple: 0.5 dB
Stopband attenuation: 5 dB at 355 Hz and 365 Hz, respectively.
Determine the transfer function and difference equation.
8.39. In Problem 8.38, if the speech is corrupted by a sine wave of 360 Hz and its third harmonic,
cascading two notch ﬁlters can be applied to remove noise signals. The possible speciﬁca-
tions are given as
Chebyshev notch ﬁlter 1
Center frequency: 360 Hz
Bandwidth: 60 Hz
Passband ripple: 0.5 dB
Stopband attenuation: 5 dB at 355 Hz and 365 Hz, respectively
Chebyshev notch ﬁlter 2
Center frequency: 1,080 Hz
398
CHAPTER 8 Inﬁnite Impulse Response Filter Design

Bandwidth: 60 Hz
Passband ripple: 0.5 dB
Stopband attenuation: 5 dB at 1,075 Hz 1,085 Hz, respectively
Determine the transfer function and difference equation for each ﬁlter (Fig. 8.58).
8.40. In a speech recording system with a sampling frequency of 10,000 Hz, the speech is cor-
rupted by random noise. To remove the random noise while preserving speech information,
the following speciﬁcations are given:
Speech frequency range: 0 3,000 Hz
Stopband range: 4,000 5,000 Hz
Passband ripple: 3 dB
Stopband attenuation 25 dB
Butterworth IIR ﬁlter
Determine the ﬁlter order and transfer function.
8.41. In Problem 8.40, assume we instead use a Chebyshev IIR ﬁlter with the following
speciﬁcations:
Speech frequency range: 0 3,000 Hz
Stopband range: 4,000 5,000 Hz
Passband ripple: 1 dB
Stopband attenuation: 35 dB
Chebyshev IIR ﬁlter
Determine the ﬁlter order and transfer function.
8.42. Consider a speech equalizer to compensate for midrange frequency loss of hearing
(Figure 8.59).
The equalizer has the following speciﬁcations:
Sampling rate: 8,000 Hz
Notch filter
at 360 Hz
Notch filter
at 1080 Hz
Digital
input x(n)
Digital
output y(n)
FIGURE 8.58
Cascaded notch ﬁlter in Problem 8.39.
8.13 Summary
399

Second-order bandpass IIR ﬁlter
Frequency range to be emphasized: 1,500 2,000 Hz
Passband ripple: 3 dB
Pole-zero placement design method
Determine the transfer function.
8.43. In Problem 8.42, assume we use an IIR ﬁlter with following speciﬁcations:
Sampling rate: 8,000 Hz
Butterworth IIR ﬁlter
Frequency range to be emphasized: 1,500 2,000 Hz
Lower stopband: 0 1,000 Hz
Upper stopband: 2,500 4,000 Hz
Passband ripple: 3 dB
Stopband attenuation: 20 dB
Determine the ﬁlter order and ﬁlter transfer function.
8.44. A digital crossover can be designed as shown in Figure 8.60.
Assume the following audio speciﬁcations:
Sampling rate: 44,100 Hz
Crossover frequency: 1,000 Hz
Highpass ﬁlter: third-order Butterworth type at a cutoff frequency of 1,000 Hz
Lowpass ﬁlter: third-order Butterworth type at a cutoff frequency of 1,000 Hz
Use the MATLAB BLT design method to determine
a. the transfer functions and difference equations for the highpass and lowpass ﬁlters;
b. frequency responses for the highpass ﬁlter and the lowpass ﬁlter;
c. combined frequency response for both ﬁlters.
Digital
input x(n)
Digital
output y(n)
+
Bandpass
filter
5
Gain
FIGURE 8.59
Speech equalizer in Problem 8.42.
400
CHAPTER 8 Inﬁnite Impulse Response Filter Design

8.45. Given a DSP system with a sampling rate of 8,000 Hz, develop an 800 Hz single-tone
generator using a digital IIR ﬁlter by completing the following steps:
a. Determine the digital IIR ﬁlter transfer function.
b. Determine the DSP equation (difference equation).
c. Write a MATLAB program using the MATLAB function ﬁlter() to generate and plot the
800-Hz tone for a duration of 0.01 second.
8.46. Given a DSP system with a sampling rate of 8,000 Hz, develop a DTMF tone generator for
key “5” using digital IIR ﬁlters by completing the following steps:
a. Determine the digital IIR ﬁlter transfer functions.
b. Determine the DSP equations (difference equation).
c. Write a MATLAB program using the MATLAB function ﬁlter() to generate and plot the
DTMF tone for key 5 for 205 samples.
8.47. Given xð0Þ ¼ 1, xð1Þ ¼ 1, xð2Þ ¼ 0, xð3Þ ¼ 1, use the Goertzel algorithm to compute
the following DFT coefﬁcients and their amplitude spectra:
a. Xð0Þ
b. jXð0Þj2
c. A0 (single sided)
d. Xð1Þ
e. jXð1Þj2
f. A1 (single sided)
8.48. Repeat Problem 8.47 for spectra: A2, and A3.
8.49. Given a DSP system with a sampling rate of 8,000 Hz and data size of 205 ( N ¼ 205), seven
Goertzel IIR ﬁlters are implemented for DTMF tone detection. For the frequencies corre-
sponding to key 5, determine
a. the modiﬁed Goertzel ﬁlter transfer functions;
Digital
audio x(n)
Highpass filter
Lowpass filter
Gain_L
Gain_H
Tweeter:
The crossover passes
high frequencies
Woofer:
The crossover passes
low frequencies
yH(n)
yL(n)
FIGURE 8.60
Two-band digital crossover system in Problem 8.44.
8.13 Summary
401

b. the ﬁlter DSP equations for vkðnÞ; and
c. the DSP equations for the squared magnitudes
jXðkÞj2 ¼ jykð205Þj2
d. Using the data generated in Problem 8.46 (c), write a program using the MATLAB
function ﬁlter() and Goertzel algorithm to detect the spectral values of the DTMF tone for
key 5.
8.50. Given an input data sequence
xðnÞ ¼ 1:2$sinð2pð1; 000Þn=10; 000ÞÞ  1:5$cosð2pð4; 000Þn=10; 000Þ
assuming a sampling frequency of 10 kHz, implement the designed IIR ﬁlter in Problem
8.41 to ﬁlter 500 data points of xðnÞ with the following speciﬁed method, and plot the 500
samples of the input and output data.
a. Direct-form I implementation
b. Direct-form II implementation
8.14.1 MATLAB Projects
8.51. The 60-Hz hum eliminator with harmonics and heart rate detection:
Given the recorded ECG data (ecgbn.dat) that is corrupted by 60-Hz interference with its
harmonics and assuming a sampling rate of 600 Hz, plot the signal’s spectrum and determine the
harmonics. With the harmonic frequency information, design a notch ﬁlter to ehance the ECG
signal. Then use the designed notch ﬁlter to process the given ECG signal and apply the zero-
cross algorithm to determine the heart rate.
8.52. Digital speech and audio equalizer:
Design a seven-band audio equalizer using fourth-order bandpass ﬁlters. The center frequencies
are listed below:
Center frequency (Hz)
160
320
640
1,280
2,560
5,120
10,240
Bandwidth (Hz)
80
160
320
640
1,280
2,560
5,120
In this project, use the designed equalizer to process stereo audio (“No9seg.wav”). Plot the
magnitude response for each ﬁlter bank. Listen to and evaluate the processed audio with the
following gain settings:
a. each ﬁlter bank gain ¼ 0 (no equalization)
b. lowpass ﬁltered
c. bandpass ﬁltered
d. highpass ﬁltered
402
CHAPTER 8 Inﬁnite Impulse Response Filter Design

8.53. DTMF tone generation and detection:
Implement the DTMF tone generation and detection according to Section 8.11 with the
following speciﬁcations:
a. Input keys: 1, 2, 3, 4, 5, 6, 7, 8, 9, *, 0, #, A, B, C, D (key frequencies are given in
Figure 8.61).
b. Sampling frequency is 8,000 Hz.
c. Program will respond to each input key with its DTMF tone and display the detected key.
1
2
3
4
5
6
7
8
9
*
0
#
1209 Hz 1336 Hz 1477 Hz
697 Hz
770 Hz
852 Hz
941 Hz
1633 Hz
A
B
C
D
FIGURE 8.61
DTMF key frequencies.
8.13 Summary
403

This page intentionally left blank

Hardware and Software for Digital
Signal Processors
9
CHAPTER OUTLINE
9.1 Digital Signal Processor Architecture ............................................................................................ 406
9.2 Digital Signal Processor Hardware Units ....................................................................................... 408
9.2.1 Multiplier and Accumulator........................................................................................408
9.2.2 Shifters ....................................................................................................................409
9.2.3 Address Generators....................................................................................................409
9.3 Digital Signal Processors and Manufacturers................................................................................. 411
9.4 Fixed-Point and Floating-Point Formats.......................................................................................... 411
9.4.1 Fixed-Point Format ....................................................................................................412
9.4.2 Floating-Point Format ................................................................................................419
Overﬂow.......................................................................................................................... 422
Underﬂow ....................................................................................................................... 423
9.4.3 IEEE Floating-Point Formats ......................................................................................423
Single Precision Format................................................................................................... 423
Double Precision Format ................................................................................................. 425
9.4.5 Fixed-Point Digital Signal Processors ..........................................................................426
9.4.6 Floating-Point Processors...........................................................................................427
9.5 Finite Impulse Response and Inﬁnite Impulse Response Filter Implementations in Fixed-Point
Systems ............................................................................................................................................. 429
9.6 Digital Signal Processing Programming Examples .......................................................................... 434
9.6.1 Overview of TMS320C67x DSK ..................................................................................434
9.6.2 Concept of Real-Time Processing................................................................................438
9.6.3 Linear Buffering ........................................................................................................440
Finite Impulse Response Filtering .................................................................................... 441
Inﬁnite Impulse Response Filtering .................................................................................. 442
Digital Oscillation with Inﬁnite Impulse Response Filtering ................................................ 442
9.6.4 Sample C Programs ...................................................................................................445
Floating-Point Implementation Example ........................................................................... 445
Fixed-Point Implementation Example ............................................................................... 445
9.7 Summary ..................................................................................................................................... 448
OBJECTIVES:
This chapter introduces the basics of digital signal processors such as processor architectures and
hardware units, investigates ﬁxed-point and ﬂoating-point formats, and illustrates the implementation
of digital ﬁlters in real time.
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00009-3
Copyright  2013 Elsevier Inc. All rights reserved.
405

9.1 DIGITAL SIGNAL PROCESSOR ARCHITECTURE
Unlike microprocessors and microcontrollers, digital signal (DS) processors have special features that
require operations such as fast Fourier transform (FFT), ﬁltering, convolution and correlation, and real-
time sample-based and block-based processing. Therefore, DS processors use a different dedicated
hardware architecture.
We ﬁrst compare the architecture of the general microprocessor with that of the DS processors. The
design of general microprocessors and microcontrollers is based on the Von Neumann architecture,
which was developed from a research paper written by John Von Neumann and others in 1946. Von
Neumann suggested that computer instructions, as we shall discuss, be numerical codes instead of
special wiring. Figure 9.1 shows the Von Neumann architecture.
As shown in Figure 9.1, a Von Neumann processor contains a single, shared memory for programs
and data, a single bus for memory access, an arithmetic unit, and a program control unit. The processor
proceeds in a serial fashion in terms of fetching and execution cycles. This means that the central
processing unit (CPU) fetches an instruction from memory and decodes it to ﬁgure out what operation
to do, then executes the instruction. The instruction (in machine code) has two parts: the opcode and
the operand. The opcode speciﬁes what the operation is, that is, tells the CPU what to do. The operand
informs the CPU what data to operate on. These instructions will modify memory, or input and output
(I/O). After an instruction is completed, the cycles will resume for the next instruction. One instruction
or piece of data can be retrieved at a time. Since the processor proceeds in a serial fashion, it causes
most units to stay in a wait state.
As noted, the Von Neumann architecture operates the cycles of fetching and execution by fetching
an instruction from memory, decoding it via the program control unit, and ﬁnally executing instruction.
When execution requires data movement
that is, data to be read from or written to memory
the next
instruction will be fetched after the current instruction is completed. The Von Neumann-based
processor has this bottleneck mainly due to the use of a single, shared memory for both program
instructions and data. Increasing the speed of the bus, memory, and computational units can improve
speed, but not signiﬁcantly.
Program and
data memory
Address bus
Data bus
Input/Output
devices
Address
generator
Program
control unit
Arithmetic
unit
FIGURE 9.1
General microprocessor based on Von Neumann architecture.
406
CHAPTER 9 Hardware and Software for Digital Signal Processors

To accelerate the execution speed of digital signal processing, DS processors are designed based on
the Harvard architecture, which originated from the Mark 1 relay-based computers builtby IBM in 1944
at Harvard University. This computer stored its instructions on punched tape and data using relay latches.
Figure 9.2 shows today’s Harvard architecture. As depicted, the DS processor has two separate memory
spaces. One is dedicated for the program code, while the other is employed for data. Hence, to
accommodate two memory spaces, two corresponding address buses and two data buses are used. In this
way, the program memory and data memory have their own connections to the program memory bus and
data memory bus, respectively. This means that the Harvard processor can fetch the program instruction
and data in parallel at the same time, the former via the program memory bus and the latter via the data
memory bus. There is an additional unit called a multiplier and accumulator (MAC), which is the
dedicated hardware used for the digital ﬁltering operation. The last additional unit, the shift unit, is used
for the scaling operation for ﬁxed-point implementation when the processor performs digital ﬁltering.
Let us compare the executions of the two architectures. The Von Neumann architecture generally
has the execution cycles described in Figure 9.3. The fetch cycle obtains the opcode from the memory,
and the control unit will decode the instruction to determine the operation. Next is the execute cycle.
Based the decoded information, execution will modify the content of the register or the memory. Once
this is completed, the process will fetch the next instruction and continue. The processor operates one
instruction at a time in a serial fashion.
To improve the speed of the processor operation, the Harvard architecture takes advantage of
a common DS processor, in which one register holds the ﬁlter coefﬁcient while the other register holds
the data to be processed, as depicted in Figure 9.4.
Program
memory
Program memory data bus
Input/Output
devices
Address
generator
Program
control unit
Arithmetic
logic unit
Program memory address bus
Data memory address bus
Data memory data bus
Data
memory
Multiplier/
acummulator
Shift unit
FIGURE 9.2
Digital signal processors based on the Harvard architecture.
9.1 Digital Signal Processor Architecture
407

As shown in Figure 9.4, the execute and fetch cycles are overlapped. We call this the pipelining
operation. The DS processor performs one execution cycle while also fetching the next instruction to
be executed. Hence, the processing speed is dramatically increased.
The Harvard architecture is preferred for all DS processors due to the requirements of most digital
signal processing (DSP) algorithms, such as ﬁltering, convolution, and FFT, which need repetitive
arithmetic operations, including multiplications, additions, memory access, and heavy data ﬂow
through the CPU.
For the other applications, such as those dependent on simple microcontrollers with less of a timing
requirement, the Von Neumann architecture may be a better choice, since it offers much less silica area
and is thus less expensive.
9.2 DIGITAL SIGNAL PROCESSOR HARDWARE UNITS
In this section, we will brieﬂy discuss special DS processor hardware units.
9.2.1 Multiplier and Accumulator
As compared with the general microprocessors based on the Von Newmann architecture, the DS
processor uses the MAC, a special hardware unit for enhancing the speed of digital ﬁltering. This is
Fetch
Execute
Fetch
Fetch
Execute
Execute
FIGURE 9.3
Execution cycle based on the Von Neumann architecture.
Execute
Execute
Execute
Fetch
Fetch
Fetch
FIGURE 9.4
Execution cycle based on Harvard architecture.
408
CHAPTER 9 Hardware and Software for Digital Signal Processors

dedicated hardware, and the corresponding instruction is generally referred to as a MAC operation.
The basic structure of the MAC is shown in Figure 9.5.
As shown in Figure 9.5, in a typical hardware MAC, the multiplier has a pair of input registers, each
holding the 16-bit input to the multiplier. The result of the multiplication is accumulated in the 32-bit
accumulator unit. The result register holds the double precision data from the accumulator.
9.2.2 Shifters
In digital ﬁltering, to prevent overﬂow, a scaling operation is required. A simple scaling-down oper-
ation shifts data to the right, while a scaling-up operation shifts data to the left. Shifting data to the right
is the same as dividing the data by 2 and truncating the fraction part; shifting data to the left is
equivalent to multiplying the data by 2. As an example for a 3-bit data word 0112 ¼ 310, shifting 011
to the right gives 0012 ¼ 1, that is, 3/2¼1.5, and truncating 1.5 results in 1. Shifting the same number
to the left, we have 1102 ¼ 610, that is, 3  2 ¼ 6. The DS processor often shifts data by several bits
for each data word. To speed up such operation, the special hardware shift unit is designed to
accommodate the scaling operation, as depicted in Figure 9.2.
9.2.3 Address Generators
The DS processor generates the addresses for each datum on the data buffer to be processed. A special
hardware unit for circular buffering is used (see the address generator in Figure 9.2). Figure 9.6
describes the basic mechanism of circular buffering for a buffer having eight data samples.
In circular buffering, a pointer is used and always points to the newest data sample, as shown in
Figure 9.6. After the next sample is obtained from analog-to-digital conversion (ADC), the data will be
X Register
Y Register
Multiplier
Accumulator
Result
Register
Operand
Operand
16
16
32
32
FIGURE 9.5
The multiplier and accumulator (MAC) dedicated to DSP.
9.2 Digital Signal Processor Hardware Units
409

x n
( )
x n
(
)
-1
x n
(
)
- 2
x n
(
)
- 3
x n
(
)
- 4
x n
(
)
-5
x n
(
)
- 6
x n
(
)
- 7
Data point
FIGURE 9.6
Illustration of circular buffering.
d
Data flow: a, b, c, d, e, f, g, ...
c
b
a
Pointer
Past data
a
b
c
d
Current data
FIFO
d
c
b
e
Pointer
Past data
b
c
d
e
Current data
d
c
f
e
Pointer
Past data
c
d
e
f
Current data
FIFO
FIFO
equivalent to
equivalent to
equivalent to
Data
Data
FIGURE 9.7
Circular buffer and equivalent FIFO.
410
CHAPTER 9 Hardware and Software for Digital Signal Processors

placed at the location of xðn  7Þ and the oldest sample is pushed out. Thus, the location for xðn  7Þ
becomes the location for the current sample. The original location for xðnÞ becomes a location for the
past sample of xðn  1Þ. The process continues according to the mechanism just described. For each
new data sample, only one location on the circular buffer needs to be updated.
The circular buffer acts like a ﬁrst-in/ﬁrst-out (FIFO) buffer, but each datum on the buffer does not
have to be moved. Figure 9.7 gives a simple illustration of the 2-bit circular buffer. In the ﬁgure, there
is data ﬂow to the ADC (a, b, c, d, e, f, g, .) and a circular buffer initially containing a, b, c, and d. The
pointer speciﬁes the current data of d, and the equivalent FIFO buffer is shown on the right side with
the current data of d at the top of the memory. When e comes in, as shown in the middle drawing in
Figure 9.7, the circular buffer will change the pointer to the next position and update old a with a new
datum e. It costs the pointer only one movement to update one datum in one step. However, on the right
side, the FIFO has to move each of the other data down to let in the new datum e at the top. For this
FIFO, it takes four data movements. In the bottom drawing in Figure 9.7, the incoming datum f for both
the circular buffer and the FIFO buffer continues to conﬁrm our observations.
Like ﬁnite impulse response (FIR) ﬁltering, the data buffer size can reach several hundreds. Hence,
using the circular buffer will signiﬁcantly enhance the processing speed.
9.3 DIGITAL SIGNAL PROCESSORS AND MANUFACTURERS
DS processors are classiﬁed for general DSP and special DSP. The general-DSP processor is designed
and optimized for applications such as digital ﬁltering, correlation, convolution, and FFT. In addition
to these applications, the special-DSP processor has features that are optimized for unique applications
such as audio processing, compression, echo cancellation, and adaptive ﬁltering. Here, we will focus
on the general-DSP processor.
The major manufacturers in the DSP industry are Texas Instruments (TI), Analog Devices, and
Motorola. TI and Analog Devices offer both ﬁxed-point DSP families and ﬂoating-point DSP families,
while Motorola offers ﬁxed-point DSP families. We will concentrate on TI families, review their
architectures, and study real-time implementation using the ﬁxed- and ﬂoating-point formats.
9.4 FIXED-POINT AND FLOATING-POINT FORMATS
In order to process real-world data, we need to select an appropriate DS processor, as well as a DSP
algorithm or algorithms for a certain application. Whether a DS processor uses a ﬁxed- or ﬂoating-point
method depends on how the processor’s CPU performs arithmetic. A ﬁxed-point DS processor represents
data in2’s complementinteger formatand manipulatesdatausinginteger arithmetic,while aﬂoating-point
processor represents number using a mantissa (fractional part) and an exponent in addition to the integer
format and operates data using ﬂoating-point arithmetic (discussed in Section 9.4.2).
Since the ﬁxed-point DS processor operates using the integer format, which represents only a very
narrow dynamic range of the integer number, a problem such as overﬂow of data manipulation may
occur. Hence, we need to spend much more coding effort to deal with such a problem. As we shall see,
we may use ﬂoating-point DS processors, which offer a wider dynamic range of data, so that coding
becomes much easier. However, the ﬂoating-point DS processor contains more hardware units to
9.4 Fixed Point and Floating Point Formats
411

handle the integer arithmetic and the ﬂoating-point arithmetic; hence it is more expensive and slower
than ﬁxed-point processors in terms of instruction cycles. It is usually a choice for prototyping or
proof-of-concept development.
When it is time to make the DSP an application-speciﬁc integrated circuit (ASIC), a chip designed
for a particular application, a dedicated hand-coded ﬁxed-point implementation is likely the best
choice in terms of performance and small silica area.
The formats used by DSP implementation can be classiﬁed as ﬁxed or ﬂoating point.
9.4.1 Fixed-Point Format
We begin with 2’s complement representation. Considering a 3-bit 2’s complement, we can represent
all the decimal numbers shown in Table 9.1.
Let us review the 2’s complement number system using Table 9.1. Converting a decimal number to
its 2’s complement form requires following steps:
1. Convert the magnitude in the decimal to its binary number using the required number of bits.
2. If the decimal number is positive, its binary number is its 2’s complement representation; if the
decimal number is negative, perform the 2’s complement operation, where we negate the binary
number by changing the logic 1s to logic 0s and logic 0s to logic 1s and then add a logic 1 to
the data. For example, a decimal number of 3 is converted to its 3-bit 2’s complement
representation as 011; however, for converting a decimal number of 3, we ﬁrst get a 3-bit
binary number for the magnitude in decimal, that is, 011. Next, negating the binary number 011
yields the binary number 100. Finally, adding a binary logic 1 achieves the 3-bit 2’s
complement representation of 3, that is, 100 þ1¼101, as shown in Table 9.1.
As we see, a 3-bit 2’s complement number system has a dynamic range from 4 to 3, which is very
narrow. Since the basic DSP operations include multiplications and additions, results of operation can
cause overﬂow problems. Let us examine multiplication in Example 9.1.
Table 9.1 A 3-Bit 2’s Complement Number Representation
Decimal Number
Two’s Complement
3
011
2
010
1
001
0
000
1
111
2
110
3
101
4
100
412
CHAPTER 9 Hardware and Software for Digital Signal Processors

EXAMPLE 9.1
Given
a. 2  ð 1Þ
b. 2  ð 3Þ
operate each expression using 2’s complement.
Solution:
a.
0 1 0
 0 0 1
0 1 0
0 0 0
þ 0 0 0
0 0 0 1 0
The 2’s complement of 00010
11110. Removing two extended sign bits 1 gives 110. The answer is 110 ( 2),
which is within the system.
b.
0 1 0
 0 1 1
0 1 0
0 1 0
þ 1 0 0
0 0 1 1 0
The 2’s complement of 00110
11010. Removing two extended sign bits leaves 010. Since the binary number
010 is 2, which is not ( 6) as what we expect, overﬂow occurs; that is, the result of the multiplication ( 6) is out of
our dynamic range ( 4 to 3).
Let us design a system treating all the decimal values as fractional numbers, so that we obtain the
fractional binary 2’s complement system shown in Table 9.2.
To become familiar with the fractional binary 2’s complement system, let us convert a positive
fraction number 3
4 and a negative fraction number 1
4 in decimals to their 2’s complements. Since
3
4 ¼ 0  20 þ 1  2 1 þ 1  2 2
Table 9.2 A 3-Bit 2’s Complement System Using Fractional Representation
Decimal Number
Decimal Fraction
Two’s Complement
3
3/4
0.11
2
2/4
0.10
1
1/4
0.01
0
0
0.00
1
1/4
1.11
2
2/4
1.10
3
3/4
1.01
4
4/4
1
1.00
9.4 Fixed Point and Floating Point Formats
413

its 2’s complement is 011. Note that we did not mark the binary point for clarity. Again, since
1
4 ¼ 0  20 þ 0  2 1 þ 1  2 2
its positive-number 2’s complement is 001. For the negative number, applying the 2’s complement to
the binary number 001 leads to 110 þ 1 ¼ 111, as we see in Table 9.2. By adding the binary points, we
obtain 0.01 and 1.11, respectively.
Now let us focus on the fractional binary 2’s complement system. The data are normalized to the
fractional range from 1 to 1  2 2 ¼ 3
4. When we carry out multiplications with two fractions, the result
should be a fraction, so that multiplication overﬂow can be prevented. Let us verify the multiplication
(0.10) (1.01), which is the overﬂow case in Example 9.1. We ﬁrst multiply two positive numbers:
0:1 0
 0:1 1
0 1 0
0 1 0
þ 1 0 0
0:0 1 1 0
The 2’s complement of 0.0110 ¼ 1.1010.
The answer in decimal form should be
1:1010 ¼ ð1Þ  ð0:0110Þ2 ¼ ð0  ð2Þ 1 þ 1  ð2Þ 2 þ 1  ð2Þ 3 þ 0  ð2Þ 4Þ ¼  3
8
This number is correct, as we can verify from Table 9.2, that is,
2
4 

3
4

¼  3
8.
If we truncate the last two least signiﬁcant bits to keep the 3-bit binary number, we have an
approximate answer:
1:10 ¼ ð1Þ  ð0:01Þ2 ¼ 

0  ð2Þ 1 þ 1  ð2Þ 2
¼ 1
2
Truncation error occurs. The error should be bounded by 2 2 ¼ 1
4. We can verify that
j  1=2  ð3=8Þj ¼ 1=8 < 1=4
With such a scheme, we can avoid overﬂow due to multiplication but cannot prevent overﬂow due to
addition. Consider the addition example
0:1 1
þ 0:0 1
1:0 0
where the result 1.00 is a negative number. Adding two positive fractional numbers yields a negative
number. Hence, overﬂow occurs.
414
CHAPTER 9 Hardware and Software for Digital Signal Processors

We see that this signed fractional number scheme partially solves the overﬂow in multiplications.
This fractional number format is called the signed Q-2 format, where there are 2 magnitude bits plus
one sign bit. The overﬂow from addition will be tackled using a scaling method discussed in a later
section.
Q-format number representation is the most common one used in ﬁxed-point DSP implementation.
It is deﬁned in Figure 9.8.
As indicated in Figure 9.8, Q-15 means that the data are in a sign magnitude form in which there are
15 bits for magnitude and one bit for sign. Note that after the sign bit, the dot shown in Figure 9.8
implies the binary point. The number is normalized to the fractional range from 1 to 1. The range is
divided in to 216 intervals, each with a size of 2 15. The most negative number is 1, while the most
positive number is 1  2 15. Any result from multiplication is within the fractional range of 1 to 1.
Let us study the following examples to become familiar with Q-format number representation.
EXAMPLE 9.2
Find the signed Q 15 representation for the decimal number 0.560123.
Q 15

−20 2 1
−
2 2
−
2 3
−
2 4
−
2 5
−
2 6
−
2 7
−
2 8
−
2 14
−
2 9
−
2 10
−
2 11
−
2 12
−
2 13
−
2 15
−
Implied binary point
FIGURE 9.8
Q-15 (ﬁxed-point) format.
Table 9.3 Conversion Process of Q-15 Representation
Number
Product
Carry
0.560123 x 2
1.120246
1 (MSB)
0.120246 x 2
0.240492
0
0.240492 x 2
0.480984
0
0.480984 x 2
0.961968
0
0.961968 x 2
1.923936
1
0.923936 x 2
1.847872
1
0.847872 x 2
1.695744
1
0.695744 x 2
1.391488
1
0.391488 x 2
0.782976
0
0.782976 x 2
1.565952
1
0.565952 x 2
1.131904
1
0.131904 x 2
0.263808
0
0.263808 x 2
0.527616
0
0.527616 x 2
1.055232
1
0.055232 x 2
0.110464
0 (LSB)
MSB, most signiﬁcant bit; LSB, least signiﬁcant bit.
9.4 Fixed Point and Floating Point Formats
415

Solution:
The conversion process is illustrated using Table 9.3. For a positive fractional number, we multiply the number by
2 if the product is larger than 1, carry bit 1 as a most signiﬁcant bit (MSB), and copy the fractional part to the next
line for the next multiplication by 2; if the product is less than 1, we carry bit 0 to MSB. The procedure continues to
collect all 15 magnitude bits.
We yield the Q 15 format representation as
0:100011110110010
Since we only use 16 bits to represent the number, we may lose accuracy after conversion. Like quantization,
truncation error is introduced. However, this error should be less than the interval size, in this case,
215
0:0000305017. We shall verify this in Example 9.5. An alternative method of conversion is to convert
a fraction, let’s say 3
4 to Q 2 format, multiply it by 22, and then convert the truncated integer to its binary, that is,
ð3=4Þ  22
3
0112
In this way, it follows that
ð0:560123Þ  215
18; 354
Converting 18,354 to its binary representation will achieve the same answer. The next example illustrates the
signed Q 15 representation for a negative number.
EXAMPLE 9.3
Find the signed Q 15 representation for the decimal number
0.160123.
Solution:
Converting the Q 15 format for the corresponding positive number with the same magnitude using the procedure
described in Example 9.2, we have
0:160123
0:001010001111110
Then after applying 2’s complement, the Q 15 format becomes
0:160123
1:110101110000010
Alternative method: Since ð 0:160123Þ  215
5; 246:9, converting the truncated number
5,246 to its
16 bit 2’s complement yields 1110101110000010.
EXAMPLE 9.4
Convert the Q 15 signed number 1.110101110000010 to the decimal number.
Solution:
Since the number is negative, applying the 2’s complement yields
0:001010001111110
Then the decimal number is
ð23 þ 25 þ 29 þ 210 þ 211 þ 212 þ 213 þ 214Þ
0:160095
416
CHAPTER 9 Hardware and Software for Digital Signal Processors

EXAMPLE 9.5
Convert the Q 15 signed number 0.100011110110010 to the decimal number.
Solution:
The decimal number is
21 þ 25 þ 26 þ 27 þ 28 þ 210 þ 211 þ 214
0:560120
As we know, the truncation error in Example 9.2 is less than 215
0:000030517. We verify that the truncation
error is bounded by
j0:560120
0:560123j
0:000003 < 0:000030517
Note that the larger the number of bits used, the smaller the truncation error that may accompany it.
Examples 9.6 and 9.7 are devoted to illustrating data manipulations in the Q 15 format.
EXAMPLE 9.6
Add the two numbers in Examples 9.4 and 9.5 in Q 15 format.
Solution:
Binary addition is carried out as follows:
1: 1 1 0 1 0 1 1 1 0 0 0 0 0 1 0
þ 0: 1 0 0 0 1 1 1 1 0 1 1 0 0 1 0
1 0: 0 1 1 0 0 1 1 0 0 1 1 0 1 0 0
Then the result is
0: 0 1 1 0 0 1 1 0 0 1 1 0 1 0 0
This number in decimal form is
22 þ 23 þ 26 þ 27 þ 210 þ 211 þ 213
0:400024
EXAMPLE 9.7
This is a simple illustration of ﬁxed point multiplication.
Determine the ﬁxed point multiplication of 0.25 and 0.5 in Q 3 ﬁxed point 2’s complement format.
Solution:
Since 0.25
0.010 and 0.5
0.100, we carry out binary multiplication as follows:
0 : 0 1 0
 0 : 1 0 0
0 0 0 0
0 0 0 0
0 0 1 0
þ 0 0 0 0
0:0 0 1 0 0 0
9.4 Fixed Point and Floating Point Formats
417

Truncating the least signiﬁcant bits to convert the result to Q 3 format, we have
0:010  0:100
0:001
Note that 0:001
23
0:125. We can also verify that 0.25  0.5
0.125.
The Q-format number representation is a better choice than the 2’s complement integer repre-
sentation, it can prevent multiplication overﬂow. But we need to be concerned with the following
problems.
1. When converting a decimal number to its Q-N format, where N denotes the number of magnitude
bits, we may lose accuracy due to the truncation error, which is bounded by the size of the interval,
that is, 2 N.
2. Addition and subtraction may cause overﬂow, where adding two positive numbers leads to
a negative number, or adding two negative number yields a positive number; similarly,
subtracting a positive number from a negative number gives a positive number, while
subtracting a negative number from a positive number results in a negative number.
3. Multiplying two numbers in Q-15 format will lead to a Q-30 format, which has 31 bits in total.
As in Example 9.7, the multiplication of Q-3 yields a Q-6 format, that is, 6 magnitude bits and
a sign bit. In practice, it is common for a DS processor to hold the multiplication result using
a double word size such as MAC operation, as shown in Figure 9.9 for multiplying two
numbers in Q-15 format. In Q-30 format, there is one sign-extended bit. We may get rid of
it by shifting left by one bit to obtain Q-31 format and maintaining the Q-31 format for
each MAC operation.
Sometimes, the number in Q-31 format needs to be converted to Q-15; for example, the 32-bit data
in the accumulator needs to be sent for 16-bit digital-to-analog conversion (DAC), where the upper
most-signiﬁcant 16 bits in the Q-30 format must be used to maintain accuracy. We can shift the
number in Q-30 to the right by 15 bits or shift the Q-31 number to the right by 16 bits. The
useful result is stored in the lower 16-bit memory location. Note that after truncation,
the maximum error is bounded by the interval size of 2 15, which satisﬁes most applications. In
using the Q-format in the ﬁxed-point DS processor, it is costly to maintain the accuracy of data
manipulation.
4. Underﬂow can happen when the result of multiplication is too small to be represented in the
Q-format. As an example, in a Q-2 system shown in Table 9.2, multiplying 0.01 0.01 leads to
0.0001. To keep the result in Q-2, we truncate the last two bits of 0.0001 to achieve 0.00, which
is zero. Hence, underﬂow occurs.
Q 30
15 magnitude bits
30 magnitude bits
S
S
15 magnitude bits
S
S
5
1
Q
5
1
Q
x
FIGURE 9.9
Sign bit extended Q-30 format.
418
CHAPTER 9 Hardware and Software for Digital Signal Processors

9.4.2 Floating-Point Format
To increase the dynamic range of number representation, a ﬂoating-point format, which is similar to
scientiﬁc notation, is used. The general format for ﬂoating-point number representation is given by
x ¼ M$2E
(9.1)
where M is the mantissa, or fractional part in Q format, and E is the exponent. The mantissa and
exponent are signed numbers. If we assign 12 bits for the mantissa and 4 bits for the exponent, the
format looks like Figure 9.10.
Since the 12-bit mantissa is limited to between 1 to þ1, the number of bits assigned to the
exponent controls the dynamic range. The bigger the number of bits designated to the exponent, the
larger the dynamic range. The number of bits for the mantissa deﬁnes the interval in the normalized
range; as shown in Figure 9.10, the interval size is 2 11 in the normalized range, which is smaller than
the Q-15 format. However, when more mantissa bits are used, there will be a smaller interval size.
Using the format in Figure 9.10, we can determine the most negative and most positive numbers as
most negative number ¼ ð1:00000000000Þ2$201112 ¼ ð1Þ  27 ¼ 128:0
most positive number ¼ ð0:11111111111Þ2$201112 ¼ ð1  2 11Þ  27 ¼ 127:9375
The smallest positive number is given by
smallest positive number ¼ ð0:00000000001Þ2$21;0002 ¼ ð2 11Þ  2 8 ¼ 2 19
As we can see, the exponent acts like a scale factor to increase the dynamic range of the number
representation. We study the ﬂoating-point format in the following example.
EXAMPLE 9.8
Convert each of the following decimal numbers to a ﬂoating point number using the format speciﬁed in Figure 9.10.
a. 0.1601230
b.
20.430527
Solution:
a. We ﬁrst scale the number 0.1601230 to 0:160123=22
0:640492 with an exponent of
2 (other choices
could be 0 or
1) to get 0:160123
0:640492  22. Using 2’s complement, we have
2
1110. Now we
convert the value 0:640492 using the Q 11 format to get 010100011111. Cascading the exponent bits and the
mantissa bits yields
1110010100011111
20
2 1 2 2 2 3 2 4 2 5 2 6 2 7 2 8 2 9
2 10 2 11
20
21
22
23
12 bit mantissa
4 bit exponent
FIGURE 9.10
Floating-point format.
9.4 Fixed Point and Floating Point Formats
419

b. Since
20:430527=25
0:638454, we can convert it into the fractional part and exponent part
as
20:430527
0:638454  25. Note that this conversion is not particularly unique; the forms
20:430527
0:319227  26 and
20:430527
0:1596135  27 are still valid choices. Let us keep
what we have now. Therefore, the exponent bits should be 0101.
Converting the number 0.638454 using the Q 11 format gives
010100011011
Using 2’s complement, we obtain the representation for the decimal number
0.6438454 as
101011100101
Cascading the exponent bits and mantissa bits, we achieve
0101101011100100
Floating-point arithmetic is more complicated. We must obey the rules for manipulating two
ﬂoating-point numbers. For arithmetic addition, with two ﬂoating point numbers given as
x1 ¼ M12E1
x2 ¼ M22E2
the ﬂoating-point sum is performed as follows:
x1 þ x2 ¼
( ðM1 þ M2  2 ðE1
E2ÞÞ  2E1;
if E1  E2
ðM1  2 ðE2
E1Þ þ M2Þ  2E2
if E1 < E2
For multiplication, given two properly normalized ﬂoating-point numbers
x1 ¼ M12E1
x2 ¼ M22E2
where 0:5  j:M1j: < 1 and 0:5  j:M2j: < 1, the calculation can be performed as follows:
x1  x2 ¼ ðM1  M2Þ  2E1þE2 ¼ M  2E
That is, the mantissas are multiplied while the exponents are added:
M ¼ M1  M2
E ¼ E1 þ E2
Examples 9.9 and 9.10 serve to illustrate manipulators.
420
CHAPTER 9 Hardware and Software for Digital Signal Processors

EXAMPLE 9.9
Add the two ﬂoating point numbers obtained in Example 9.8:
1110 010100011111
:640136718  22
0101 101011100101
0:638183593  25
Solution:
Before addition, we change the ﬁrst number so it has the same exponent as the second number, that is,
0101 000000001010
0:00500168  25
Then we add the two mantissa numbers:
0: 0 0 0 0 0 0 0 1 0 1 0
þ 1: 0 1 0 1 1 1 0 0 1 0 1
1: 0 1 0 1 1 1 0 1 1 1 1
The ﬂoating number is
0101 101011101111
We can verify the result by the following:
0101 101011101111
ð21 þ 23 þ 27 þ 211Þ  25
0:633300781  25
20:265625
EXAMPLE 9.10
Multiply the two ﬂoating point numbers obtained in Example 9.8:
1110 010100011111
:640136718  22
0101 101011100101
0:638183593  25
Solution:
From the results in Example 9.8, we have the bit patterns for these two numbers as
E1
1110; E2
0101; M1
010100011111; M2
101011100101
Adding two exponents in 2’s complement form leads to
E
E1 þ E2
1110 þ 0101
0011
which is þ3, as we expected, since in the decimal domain ( 2) þ 5
3. As previously shown when introducing
the multiplication rule, when multiplying two mantissas, we need to apply their corresponding positive values. If
the sign for the ﬁnal value is negative, then we convert it to its 2’s complement form. In our example,
M1
010100011111 is a positive mantissa. However, M2
101011100101 is a negative mantissa, since
9.4 Fixed Point and Floating Point Formats
421

the MSB is 1. To perform multiplication, we use 2’s complement to convert M2 to its positive value,
010100011011, and note that the multiplication result is negative. We multiply two positive mantissas and
truncate the result to 12 bits to give
010100011111  010100011011
001101010100
Now we need to add a negative sign to the multiplication result with the 2’s complement operation. Taking the 2’s
complement, we have
M
110010101100
Hence, the product is achieved by cascading the 4 bit exponent and 12 bit mantissa as
0011110010111100
Converting this number back to the decimal number, we verify the result to be
0:408203125  23
3:265625:
Next, we examine overﬂow and underﬂow in the ﬂoating-point number system.
Overﬂow
During an operation, overﬂow will occur when a number is too large to be represented in the ﬂoating-
point number system. Adding two mantissa numbers may lead to a number larger than 1 or
less than 1; and multiplying two numbers causes the addition of their two exponents so that the sum
of the two exponents could overﬂow. Consider the following overﬂow cases.
Case 1. Add the following two ﬂoating-point numbers:
0111 011000000000 þ 011101000000000
Note that the two exponents are the same and they are the biggest positive number in 4-bit 2’s
complement representation. We add two positive mantissa numbers as
0: 1 1 0 0 0 0 0 0 0 0 0
þ
0: 1 0 0 0 0 0 0 0 0 0 0
1: 0 1 0 0 0 0 0 0 0 0 0
The result for adding mantissa numbers is negative. Hence the overﬂow occurs.
Case 2: Multiply the following two numbers:
0111 011000000000  0111 01100000000
Adding the two positive exponents gives
0111 þ 0111 ¼ 1000 ðnegative; the overflow occursÞ
Multiplying the two mantissa numbers gives
0:11000000000  0:1100000000 ¼ 0:10010000000 ðOK!Þ
422
CHAPTER 9 Hardware and Software for Digital Signal Processors

Underﬂow
As we discussed before, underﬂow will occur when a number is too small to be represented in the
number system. Let us divide the following two ﬂoating-point numbers:
1001 001000000000 O 0111 01000000000
First, subtracting the two exponents leads to
1001ðnegativeÞ  0111ðpositiveÞ ¼ 1001 þ 1001 ¼ 0010 ðpositive; the underflow occursÞ
Then, dividing two mantissa numbers, it follows that
0:01000000000 O 0:1000000000 ¼ 0:10000000000 ðOK!Þ
However, in this case, the expected resulting exponent is 14 in decimal, which is too small to be
presented in the 4-bit 2’s complement system. Hence the underﬂow occurs.
Now that we understand the basic principles of the ﬂoating-point formats, we can next examine two
ﬂoating-point formats of the Institute of Electrical and Electronics Engineers (IEEE).
9.4.3 IEEE Floating-Point Formats
Single Precision Format
IEEE ﬂoating-point formats are widely used in many modern DS processors. There are two types
of IEEE ﬂoating-point formats (IEEE 754 standard). One is the IEEE single precision format, and
the other is the IEEE double precision format. The single precision format is described in
Figure 9.11.
The format of IEEE single precision ﬂoating-point standard representation requires 23 fraction
bits F, 8 exponent bits E, and 1 sign bit S, with a total of 32 bits for each word. F is the mantissa in 2’s
complement positive binary fraction represented from bit 0 to bit 22. The mantissa is within the
normalized range limits between þ1 and þ2. The sign bit S is employed to indicate the sign of
the number, where when S ¼ 1 the number is negative, and when S ¼ 0 the number is positive. The
exponent E is in excess 127 form. The value of 127 is the offset from the 8-bit exponent range from 0 to
255, so that E-127 will have a range from 127 to þ128. The formula shown in Figure 9.11 can be
applied to convert the IEEE 754 standard (single precision) to the decimal number. The following
simple examples also illustrate this conversion:
0 10000000 00000000000000000000000 ¼ ð1Þ0  ð1:02Þ  2128 127 ¼ 2:0
fraction
exponent
s
0
31 30
23 22
x
F
s
E
(
)
( .
)
1
1
2
127
FIGURE 9.11
IEEE single precision ﬂoating-point format.
9.4 Fixed Point and Floating Point Formats
423

0 10000001 10100000000000000000000 ¼ ð1Þ0  ð1:1012Þ  2129 127 ¼ 6:5
1 10000001 10100000000000000000000 ¼ ð1Þ1  ð1:1012Þ  2129 127 ¼ 6:5
Let us look at Example 9.11 for more explanation.
EXAMPLE 9.11
Convert the following number in IEEE single precision format to decimal format:
110000000:010.0000
Solution:
From the bit pattern in Figure 9.11, we can identify the sign bit, exponent, and fractional as
s
1; E
27
128
1:F
1:012
ð2Þ0 þ ð2Þ2
1:25
Then, applying the conversion formula leads to
x
ð 1Þ1ð1:25Þ  2128127
1:25  21
2:5
In conclusion, the value x represented by the word can be determined based on the following rules,
including all the exceptional cases:
• If E ¼ 255 and F is nonzero, then x ¼ NaN ("Not a number").
• If E ¼ 255, F is zero, and S is 1, then x ¼ Infinity.
• If E ¼ 255, F is zero, and S is 0, then x ¼ þInfinity.
• If 0 < E < 255, then x ¼ ð1Þs  ð1:FÞ  2E 127, where 1:F represents the binary number created
by preﬁxing F with an implicit leading 1 and a binary point.
• If E ¼ 0 and F is nonzero, then x ¼ ð1Þs  ð0:FÞ  2 126. This is an "unnormalized" value.
• If E ¼ 0, F is zero, and S is 1, then x ¼ 0.
• If E ¼ 0, F is zero, and S is 0, then x ¼ 0.
Typical and exceptional examples are shown as follows:
000000000 00000000000000000000000 ¼ 0
100000000 00000000000000000000000 ¼ 0
011111111 00000000000000000000000 ¼ Inﬁnity
111111111 00000000000000000000000 ¼ Inﬁnity
011111111 00000100000000000000000 ¼ NaN
111111111 00100010001001010101010 ¼ NaN
000000001 00000000000000000000000 ¼ ð1Þ0  ð1:02Þ  21 127 ¼ 2 126
000000000 10000000000000000000000 ¼ ð1Þ0  ð0:12Þ  20 126 ¼ 2 127
424
CHAPTER 9 Hardware and Software for Digital Signal Processors

000000000 00000000000000000000001 ¼
ð1Þ0  ð0:000000000000000000000012Þ  20 126 ¼ 2 149 ðsmallest positive valueÞ
Double Precision Format
The IEEE double precision format is described in Figure 9.12.
The IEEE double precision ﬂoating-point standard representation requires a 64-bit word, which
may be numbered from 0 to 63, left to right. The ﬁrst bit is the sign bit S, the next eleven bits are the
exponent bits E, and the ﬁnal 52 bits are the fraction bits F. The IEEE ﬂoating-point format in double
precision signiﬁcantly increases the dynamic range of number representation since there are eleven
exponent bits; the double-precision format also reduces the interval size in the mantissa normalized
range of þ1 to þ2, since there are 52 mantissa bits as compare with the single precision case of 23 bits.
Applying the conversion formula shown in Figure 9.12 is similar to the single precision case.
EXAMPLE 9.12
Convert the following number in IEEE double precision format to the decimal format:
001000.0:110.000
Solution:
Using the bit pattern in Figure 9.12, we have
s
0; E
29
512 and
1:F
1:112
ð2Þ0 þ ð2Þ1 þ ð2Þ2
1:75
Then, applying the double precision formula yields
x
ð 1Þ0ð1:75Þ  25121023
1:75  2511
2:6104  10154
For the purpose of completeness, rules for determining the value x represented by the double-
precision word are listed as follows:
•
If E ¼ 2;047 and F is nonzero, then x ¼ NaN ("Not a number").
•
If E ¼ 2;047, F is zero, and S is 1, then x ¼ Inifinity.
•
If E ¼ 2;047, F is zero, and S is 0, then x ¼ þInifinity.
•
If 0 < E < 2;047, then x ¼ ð1Þs  ð1:FÞ  2E 1;023, where "1:F " is intended to represent the
binary number created by preﬁxing F with an implicit leading 1 and a binary point.
s
exponent
fraction
fraction
0
0
31
31
30
19
20
x
F
s
E
(
)
( .
)
1
1
2
1023
r
e
tsig
e
r 
n
e
v
e
r
e
tsig
e
r 
d
d
o
FIGURE 9.12
IEEE double precision ﬂoating-point format.
9.4 Fixed Point and Floating Point Formats
425

• If E ¼ 0 and F is nonzero, then x ¼ ð1Þs  ð0:FÞ  2 1022. This is an "unnormalized" value.
• If E ¼ 0, F is zero, and S is 1, then x ¼ 0.
• If E ¼ 0, F is zero, and S is 0, then x ¼ 0.
9.4.5 Fixed-Point Digital Signal Processors
Analog Devices, Texas Instruments, and Motorola all manufacture ﬁxed-point DS processors. Analog
Devices offers a ﬁxed-point DSP family such as the ADSP21xx. Texas Instruments provides various
generations of ﬁxed-point DS processors based on historical development, architecture features, and
computational performance. Some of the most common ones are the TMS320C1x (ﬁrst generation),
TMS320C2x, TMS320C5x, and TMS320C62x. Motorola manufactures a variety of ﬁxed-point
processors, such as the DSP5600x family. The new families of ﬁxed-point DS processors are expected
Program
memory
Program memory data bus
Input/Output
devices
Arithmetic
logic unit
D data memory address bus
E data memory address bus
C data memory data bus
Data
memory
Multiplier/
acummulator
Shift unit
Program memory address bus
C data memory address bus
D data memory data bus
E data memory data bus
Data address
generator
Program
address
generator
Program
control unit
FIGURE 9.13
Basic architecture of the TMSC320C54x family.
426
CHAPTER 9 Hardware and Software for Digital Signal Processors

to continue to grow. Since they share some basic common features such as program memory and data
memory with associated address buses, arithmetic logic units (ALUs), program control units, MACs,
shift units, and address generators, here we focus on an overview of the TMS320C54x processor. The
typical TMS320C54x ﬁxed-point DSP architecture appears in Figure 9.13.
The ﬁxed-point TMS320C50 families supporting 16-bit data have on-chip program memory and
data memory in various sizes and conﬁgurations. They include data RAM (random access memory)
and program ROM (read-only memory) used for program code, instruction, and data. Four data buses
and four address buses are accommodated to work with the data memory and program memory. The
program memory address bus and program memory data bus are responsible for fetching program
instructions. As shown in Figure 9.13, the C and D data memory address buses and the C and D data
memory data buses deal with fetching data from the data memory while the E data memory address bus
and E data memory data bus are dedicated to moving data into data memory. In addition, the E memory
data bus can access the I/O devices.
Computational units consist of an ALU, a MAC, and a shift unit. For the TMS320C54x family, the
ALU can fetch data from the C, D, and program memory data buses and access the E memory data bus.
It has two independent 40-bit accumulators, which are able to operate 40-bit addition. The multiplier,
which can fetch data from the C and D memory data buses and write data via the E data memory data
bus, is capable of operating 17-bit  17-bit multiplications. The 40-bit shifter has the same capability
of bus access as the MAC, allowing all possible shifts for scaling and fractional arithmetic such as
those we have discussed for the Q-format.
The program control unit fetches instructions via the program memory data bus. Again, in order to
speed up memory access, there are two address generators available: one responsible for program
addresses and one for data addresses.
Advanced Harvard architecture is employed, where several instructions operate at the same time
for given a given single instruction cycle. Processing performance offers 40 MIPS (million instruction
sets per second). To further explore this subject, the reader is referred to Dahnoun (2000), Embree
(1995), Ifeachor and Jervis (2002), and Van der Vegte (2002), as well as the TI website (www.ti.com).
9.4.6 Floating-Point Processors
Floating-point DS processors perform DSP operations using ﬂoating-point arithmetic, as we discussed
before. The advantages of using the ﬂoating-point processor include getting rid of ﬁnite word length
effects such as overﬂows, round-off errors, truncation errors, and coefﬁcient quantization error. Hence,
in terms of coding, we do not need to scale input samples to avoid overﬂow, shift the accumulator
result to ﬁt the DAC word size, scale the ﬁlter coefﬁcients, or apply Q-format arithmetic. A ﬂoating-
point DS processor with high speed and calculation precision facilitates a friendly environment to
develop and implement DSP algorithms.
Analog Devices provides ﬂoating-point DSP families such as ADSP210xx and TigerSHARC.
Texas Instruments offers a wide range of the ﬂoating-point DSP families, in which the TMS320C3x is
the ﬁrst generation, followed by the TMSC320C4x and TMS320C67x families. Since the ﬁrst
generation of a ﬂoating-point DS processor is less complicated than later generations but still has the
common basic features, we review the ﬁrst-generation architecture ﬁrst.
Figure 9.14 shows the typical architecture of Texas Instruments’ TMS320C3x family of processors.
We discuss some key features brieﬂy. Further detail can be found in the TMS320C3x User’s Guide
9.4 Fixed Point and Floating Point Formats
427

(Texas Instruments 1991), the TMS320C6x CPU and Instruction Set Reference Guide (Texas
Instruments, 1998), and other studies (Dahnoun, 2000; Embree, 1995; Ifeachor and Jervis, 2002;
Kehtaranavaz and Simsek, 2000; Sorensen and Chen, 1997; Van der Vegte, 2002). The TMS320C3x
family consists of 32-bit single chip ﬂoating-point processors that support both integer and ﬂoating-
point operations.
The processor has a large memory space and is equipped with dual-access on-chip memories. A
program cache is employed to enhance the execution of commonly used codes. Similar to the ﬁxed-
point processor, it uses the Harvard architecture, where there are separate buses used for program and
data so that instructions can be fetched at the same time that data are being accessed. There also exist
memory buses and data buses for direct-memory access (DMA) for concurrent I/O and CPU opera-
tions, and peripheral access such as serial ports, I/O ports, memory expansion, and an external clock.
The C3x CPU contains the ﬂoating-point/integer multiplier; an ALU, which is capable of operating
both integer and ﬂoating-point arithmetic; a 32-bit barrel shifter; internal buses; a CPU register ﬁle;
and dedicated auxiliary register arithmetic units (ARAUs). The multiplier operates single-cycle
multiplications on 24-bit integers and on 32-bit ﬂoating-point values. Using parallel instructions to
perform a multiplication, an ALU will cost a single cycle, which means that a multiplication and an
addition are equally fast. The ARAUs support addressing modes, in which some of them are speciﬁc to
DSP such as circular buffering and bit-reversal addressing (digital ﬁltering and FFT operations). The
CPU register ﬁle offers 28 registers, which can be operated on by the multiplier and ALU. The special
functions of the registers include eight-extended 40-bit precision registers for maintaining accuracy of
RAM
block 1
(1Kx32)
Program
cache
(64x32
RAM
block 0
(1Kx32)
ROM
block 0
(4Kx32)
DMA
Address generators
Control registers
CPU
Integer/
Floating-point
Multiplier
Integer/
Floating-point
ALU
8 Extended-precision
registers
Address
generator 0
Address
generator 1
8 Auxilliary registers
12 Control registers
Data bus
Contro er
Per phera  bus
Serial
port 0
Serial
port 1
Timer 0
Timer 1
XR W
/
XD31− 0
A12− 0
X
MSTRB
IOSTRB
XRDY
XR W
/
XD31− 0
XA12− 0
MSTRB
IOSTRB
XRDY
IACK
XF1
0
−
MCBL MP
/
X1
INT3
0
−
RDY
SHZ
VSS
VDD
X
CLKIN
2 /
FIGURE 9.14
The typical TMS320C3x ﬂoating-point DS processor.
428
CHAPTER 9 Hardware and Software for Digital Signal Processors

the ﬂoating-point results. Eight auxiliary registers can be used for addressing and for integer arith-
metic. These registers provide internal temporary storage of internal variables instead of external
memory storage, to allow performance of arithmetic between registers. In this way, program efﬁciency
is greatly increased.
The prominent feature of C3x is its ﬂoating-point capability, allowing operation of numbers with
a very large dynamic range. It offers implementation of the DSP algorithm without worrying about
problems such as overﬂows and coefﬁcient quantization. Three ﬂoating-point formats are supported. A
short 16-bit ﬂoating-point format has 4 exponent bits, 1 sign bit, and 11 mantissa bits. A 32-bit single
precision format has 8 exponent bits, 1 sign bit, and 23 fraction bits. A 40-bit extended precision
format contains 8 exponent bits, 1 sign bit, and 31 fraction bits. Although the formats are slightly
different from the IEEE 754 standard, conversions are available between these formats.
The TMS320C30 offers high-speed performance with 60-nanosecond single-cycle instruction
execution time, which is equivalent to 16.7 MIPS. For speech quality applications with an 8 kHz
sampling rate, it can handle over 2,000 single-cycle instructions between two samples (125 micro-
seconds). With instruction enhancements such as pipelines executing each instruction in a single cycle
(four cycles required from fetch to execution by the instruction itself) and a multiple interrupt
structure, this high-speed processor validates implementation of real-time applications in ﬂoating-
point arithmetic.
9.5 FINITE IMPULSE RESPONSE AND INFINITE IMPULSE RESPONSE
FILTER IMPLEMENTATIONS IN FIXED-POINT SYSTEMS
With knowledge of the IEEE format and of ﬁlter realization structures such as direct-form I, direct-
form II, and parallel and cascade forms (Chapter 6), we can study digital ﬁlter implementation in
the ﬁxed-point processor. In the ﬁxed-point system, where only integer arithmetic is used, we
prefer input data, ﬁlter coefﬁcients, and processed output data to be in the Q-format. In this way,
we avoid overﬂow due to multiplication and can prevent overﬂow due to addition by scaling input
data. When the ﬁlter coefﬁcients are out of the Q-format range, coefﬁcient scaling must be taken
into account to maintain the Q-format. We develop FIR ﬁlter implementation in Q-format ﬁrst, and
then inﬁnite impulse response (IIR) ﬁlter implementation next. In addition, we assume that with
a given input range in Q-format, the ﬁlter output is always in Q-format even if the ﬁlter passband
gain is larger than 1.
First, to avoid the overﬂow for an adder, we can scale the input down by a scale factor S, which can
be safely determined by the following equation
S ¼ Imax,
X
N
k ¼ 0
jhðkÞj ¼ Imax,ðjhð0Þj þ jhð1Þj þ jhð2Þj þ /Þ
(9.2)
where hðkÞ is the impulse response of the adder output and Imax the maximum amplitude of the input in
Q-format. Note that this is not an optimal factor in terms of reduced signal-to-noise ratio. However, it
shall prevent the overﬂow. Equation (9.2) means that the adder output can actually be expressed as
a convolution output:
adder output ¼ hð0ÞxðnÞ þ hð1Þxðn  1Þ þ hð2Þxðn  2Þ þ /
9.5 Finite Impulse Response and Inﬁnite Impulse Response
429

Assuming the worst conditions, that is, that all the inputs xðnÞ reach a maximum value of Imax and all
the impulse coefﬁcients are positive, the sum of the adder gives the most conservative scale factor, as
shown in Equation (9.2). Hence, scaling down the input by a factor of S will guarantee that the output
of the adder is in Q-format.
When some of the FIR coefﬁcients are larger than 1, which is beyond the range of Q-format
representation, coefﬁcient scaling is required. The idea is that scaling down the coefﬁcients will make
them less than 1, and later the ﬁltered output will be scaled up by the same amount before it is sent to
DAC. Figure 9.15 describes the modiﬁed implementation.
1
1
1
y(n)
b
B
0 /
b
B
1 /
b
B
K /
+
x n
( )
+
B
1/ S
S
( )
sx n
( )
sy n
FIGURE 9.15
Direct-form I implementation of the FIR ﬁlter.
In the ﬁgure, the scale factor B makes the coefﬁcients bk=B convertible to the Q-format. The scale
factors S and B are usually chosen to be a power of 2, so the simple shift operation can be used in the
coding process. Let us implement an FIR ﬁlter containing ﬁlter coefﬁcients larger than 1 in the ﬁxed-
point implementation.
EXAMPLE 9.13
Given the FIR ﬁlter
yðnÞ
0:9xðnÞ þ 3xðn
1Þ þ 0:9xðn
2Þ
with a passband gain of 4, and assuming that the input range only occupies one quarter of the full range for
a particular application, develop the DSP implementation equations in the Q 15 ﬁxed point system.
Solution:
The adder may cause overﬂow if the input data exist for one quarter of the full dynamic range. The scale factor is
determined using the impulse response, which consists of the FIR ﬁlter coefﬁcients, as discussed in Chapter 3.
S
1
4 ðjhð0Þj þ jhð1Þj þ jhð2ÞjÞ
1
4 ð0:9 þ 3 þ 0:9Þ
1:2
Overﬂow may occur. Hence, we select S
2 (a power of 2). We choose B
4 to scale all the coefﬁcients to be
less than 1, so the Q 15 format can be used. According to Figure 9.15, the developed difference equations are
given by
xsðnÞ
xðnÞ
2
ysðnÞ
0:225xsðnÞ þ 0:75xsðn
1Þ þ 0:225xsðn
2Þ
yðnÞ
8ysðnÞ
430
CHAPTER 9 Hardware and Software for Digital Signal Processors

Next, the direct form I implementation of the IIR ﬁlter is illustrated in Figure 9.16. As shown in the ﬁgure, the
purpose of the scale factor C is to scale down the original ﬁlter coefﬁcients to the Q format. The factor C is usually
chosen to be a power of 2 for using a simple shift operation in DSP.
EXAMPLE 9.14
The IIR ﬁlter
yðnÞ
2xðnÞ þ 0:5yðn
1Þ
uses
the
direct form
I
realization,
and
for
a
particular
application,
the
maximum
input
is
Imax
0:010.:02
0:25. Develop the DSP implementation equations in the Q 15 ﬁxed point system.
Solution:
This is an IIR ﬁlter whose transfer function is
HðzÞ
2
1
0:5z1
2z
z
0:5
Applying the inverse z transform, we obtain the impulse response
hðnÞ
2  ð0:5ÞnuðnÞ
To prevent overﬂow in the adder, we can compute the S factor with the help of the Maclaurin series or approximate
Equation (9.2) numerically. We get
S
0:25 

2ð0:5Þ0 þ 2ð0:5Þ1 þ 2ð0:5Þ2 þ /

0:25  2  1
1
0:5
1
The MATLAB function impz() can also be applied to ﬁnd the impulse response and the S factor:
>> h impz(2,[1
0.5]); % Find the impulse response
>> sf 0.25*sum(abs(h)) % Determine the sum of absolute values of h(k)
sf
1
Hence, we do not need to perform input scaling. However, we need scale down all the coefﬁcients to use the
Q 15 format. A factor of C
4 is selected. From Figure 9.16, we get the difference equations as
xsðnÞ
xðnÞ
ysðnÞ
0:5sxðnÞ þ 0:125yf ðn
1Þ
1
1
1
1
1
( )
y n
b
C
0 /
b
C
1 /
b
C
M /
a
C
1 /
+
x n
( )
1
a
C
2 /
a
C
N /
+
C
1/ S
S
( )
sy n
( )
fy
n
( )
sx n
FIGURE 9.16
Direct-form I implementation of the IIR ﬁlter.
9.5 Finite Impulse Response and Inﬁnite Impulse Response
431

yf ðnÞ
4ysðnÞ
yðnÞ
yf ðnÞ
We can develop these equations directly. First, we divide the original difference equation by a factor of 4 to scale
down all the coefﬁcients to be less than 1, that is,
1
4 yf ðnÞ
1
4  2xsðnÞ þ 1
4  0:5yf ðn
1Þ
and deﬁne a scaled output
ysðnÞ
1
4 yf ðnÞ
Finally, substituting ysðnÞ on the left side of the scaled equation and rescaling up the ﬁlter output as
yf ðnÞ
4ysðnÞ, we have the same results as before.
The ﬁxed-point implementation for direct-form II is more complicated. The developed direct-form
II implementation of the IIR ﬁlter is illustrated in Figure 9.17.
As shown in the ﬁgure, two scale factors A and B are designated to scale denominator coefﬁcients
and numerator coefﬁcients to their Q-format representations, respectively. Here S is a special factor to
scale down the input sample so that the numerical overﬂow in the ﬁrst sum in Figure 9.17 can be
prevented. The difference equations are given in Chapter 6 and listed here:
wðnÞ ¼ xðnÞ  a1wðn  1Þ  a2wðn  2Þ  /  aMwðn  MÞ
yðnÞ ¼ b0wðnÞ þ b1wðn  1Þ þ / þ bMwðn  MÞ
The ﬁrst equation is scaled down by the factor A to ensure that all the denominator coefﬁcients are less
than 1, that is,
1
+
+
y n
( )
b
B
0 /
b
B
1 /
b
B
M /
a
A
1 /
a
A
M /
x n
( )
b
B
2 /
a
A
2 /
w n
(
)
2
w n
M
(
)
w n
( )
1
1
w n
(
)1
1/ S 1/ A
A
B
S
( )
s
w n
( )
sy n
FIGURE 9.17
Direct-form II implementation of the IIR ﬁlter.
432
CHAPTER 9 Hardware and Software for Digital Signal Processors

wsðnÞ ¼ 1
AwðnÞ ¼ 1
AxðnÞ  1
A a1wðn  1Þ  1
A a2wðn  2Þ  /  1
A aMwðn  MÞ
wðnÞ ¼ A  wsðnÞ
Similarly, scaling the second equation yields
ysðnÞ ¼ 1
ByðnÞ ¼ 1
B b0wðnÞ þ 1
B b1wðn  1Þ þ / þ 1
B bMwðn  MÞ
and
yðnÞ ¼ B  ysðnÞ
To avoid the ﬁrst adder overﬂow (ﬁrst equation), the scale factor S can be safely determined by
Equation (9.3):
S ¼ Imaxðjhð0Þj þ jhð1Þj þ jhð2Þj þ /Þ
(9.3)
where hðkÞ is the impulse response due to the denominator polynomial of the IIR ﬁlter, where the poles
can cause a larger value to the ﬁrst sum. Hence, h(k) is given by
hðnÞ ¼ Z
1

1
1 þ a1z 1 þ / þ az M

(9.4)
All the scale factors A, B, and S are usually chosen to be a power of 2, respectively, so that the shift
operations can be used in the coding process. Example 9.15 serves as illustration.
EXAMPLE 9.15
Given the IIR ﬁlter
yðnÞ
0:75xðnÞ þ 1:49xðn
1Þ þ 0:75xðn
2Þ
1:52yðn
1Þ
0:64yðn
2Þ
with a passband gain of 1 and a full range of input, use the direct form II implementation to develop the DSP
implementation equations in the Q 15 ﬁxed point system.
Solution:
The difference equations without scaling in the direct form II implementation are given by
wðnÞ
xðnÞ
1:52wðn
1Þ
0:64wðn
2Þ
yðnÞ
0:75wðnÞ þ 1:49wðn
1Þ þ 0:75wðn
2Þ
To prevent overﬂow in the ﬁrst adder, we obtain the reciprocal of the denominator polynomial as
AðzÞ
1
1 þ 1:52z1 þ 0:64z2
Using the MATLAB function impz() leads to:
>> h impz(1,[1 1.52 0.64]);
>> sf sum(abs(h))
sf
10.4093
9.5 Finite Impulse Response and Inﬁnite Impulse Response
433

We choose the S factor as S
16 and we choose A
2 to scale down the denominator coefﬁcients by half.
Since the second adder output after scaling is
ysðnÞ
0:75
B wðnÞ þ 1:49
B wðn
1Þ þ 0:75
B wðn
2Þ
to avoid second adder overﬂow we have to ensure that each coefﬁcient is less than 1, along with the sum of the
absolute values:
0:75
B
þ 1:49
B
þ 0:75
B
< 1
Hence B
4 is selected. We develop the DSP equations as
xsðnÞ
xðnÞ=16
wsðnÞ
0:5xsðnÞ
0:76wðn
1Þ
0:32wðn
2Þ
wðnÞ
2wsðnÞ
ysðnÞ
0:1875wðnÞ þ 0:3725wðn
1Þ þ 0:1875wðn
2Þ
yðnÞ
ðB  SÞysðnÞ
64ysðnÞ
The implementation for cascading the second-order section ﬁlters can be found in Ifeachor and
Jervis (2002).
A practical example will be presented in the next section. Note that if a ﬂoating-point DS processor
is used, all the scaling concerns should be ignored, since the ﬂoating-point format offers a large
dynamic range, so that overﬂow hardly ever happens.
9.6 DIGITAL SIGNAL PROCESSING PROGRAMMING EXAMPLES
In this section, we ﬁrst review the TMS320C67x DSK (DSP Starter Kit), which offers ﬂoating-point
and ﬁxed-point arithmetic. We will then investigate real-time implementation of digital ﬁlters.
9.6.1 Overview of TMS320C67x DSK
In this section, a Texas Instruments TMS320C6713 DSK (DSP Starter Kit) shown in Figure 9.18 is
chosen for demonstration. This DSK board has an approximate size of 5 x 8 inches, a clock rate of 225
MHz, and a 16-bit stereo codec TLV320AIC23 (AIC23), which deals with analog inputs and outputs.
The onboard codec AIC23 applies sigma-delta technology for analog-to-digital conversion (ADC) and
digital-to-analog conversion (DAC) functions. The codec runs using a 12 MHz system clock and the
sampling rate can be selected from a range of 8 to 96 kHz for speech and audio processing. Other
boards such as a Texas Instruments TMS320C6711 DSK can also be found in the references
(Kehtaranavaz and Simsek, 2001; TMS320C6x CPU and Instruction Set Reference Guide, 1999). The
434
CHAPTER 9 Hardware and Software for Digital Signal Processors

FIGURE 9.18
(a) C6713 DSK board and (b) block diagram (courtesy of Texas Instruments).
9.6 Digital Signal Processing Programming Examples
435

on-board daughter card connections facilitate the external units for advanced applications such as
external peripheral and external memory interfaces. The TMS320C6713 DSK board consists of 16 MB
(megabytes) of synchronous dynamic RAM (SDRAM) and 512 kB (kilobytes) of ﬂash memory. There
are four onboard connections: MIC IN for microphone input; LINE IN for line input; LINE OUT for
line output; and HEADPHONE for a headphone output (multiplexed with LINE OUT). The board
components are tied by a CPLD (programmable logic device), which has a register based user
interface. A user can conﬁgure the board by reading and writing to the CPLD registers. The DSK
includes the four user DIP switches and four LEDs (light-emitting diodes) which provide a user
a simple form of inputs and outputs. Both can be accessed by the CPLD registers. The onboard voltage
regulators provide 1.26 V for the DSP core and 3.3 V for the memory and peripherals. The USB port
provides the connection between the DSK board and the host computer, where the user program is
developed, compiled, and downloaded to the DSK for real-time applications using the user-friendly
software called Code Composer Studio, which we shall discuss later.
In general, the TMS320C67x operates at a high clock rate of 300 MHz. Combining this high speed
and multiple units operating at the same time has pushed its performance up to 2,400 MIPS at 300
MHz. Using this number, the C67x can handle 0.3 MIPS between two speech samples at a sampling
rate of 8 kHz, and can handle over 54,000 instructions between two audio samples with a sampling rate
of 44.1 kHz. Hence, the C67x offers great ﬂexibility for real-time applications with a high-level
C language.
Data
RAM
Program
RAM
.D1
Control registers
Internal buses
Serial
port
Host
port
Boot
load
Timers
Data
EMIF
DMA
Power
down
CPU
Reg sters (B0-B15)
Reg sters (A0-A15)
.D2
.M1
.M2
.L1
.L2
.S1
.S2
FIGURE 9.19
Block diagram of TMS320C67x ﬂoating-point DSP.
436
CHAPTER 9 Hardware and Software for Digital Signal Processors

Figure 9.19 shows a C67x architecture overview, while Figure 9.20 displays a more detailed block
diagram. The C67x contains three main parts, which are the CPU, the memory, and the peripherals. As
shown in Figure 9.19, these three main parts are joined by an external memory interface (EMIF)
interconnected by internal buses to facilitate interface with common memory devices, DMA, a serial
port, and a host port interface (HPI).
Since this section is devoted to showing DSP coding examples, C67x key features and references
are brieﬂy listed here:
1. Architecture: The system uses Texas Instruments VelociTM architecture, which is an enhancement
of the VLIW (very long instruction word architecture) (Dahnoun, 2000; Ifeachor and Jervis, 2002;
Kehtaranavaz and Simsek, 2000).
2. CPU: As shown in Figure 9.20, the CPU has eight functional units divided into two sides A and B,
each consisting of units .D, .M, .L, and .S. For each side, an .M unit is used for multiplication
operation, an .L unit is used for logical and arithmetic operations, and a .D unit is used for
loading/storing and arithmetic operations. Each side of the C67x CPU has sixteen 32-bit registers
that the CPU must go through for interface. More detail can be found in Appendix D (Texas
Instruments, 1991) as well as in Kehtaranavaz and Simsek (2000) and Texas Instruments (1998).
Additional
peripherals:
Timers,
Serial ports
etc.
DMA
EMIF
Program cache/program memory
32-bit address
256-bit data
Program fetch
Instruction dispatch
Instruction decode
Data cache/data memory
32 bit address
6-,16-,32-bit data
Control
registers
Data path A
Data path B
Register file A
Register file B
Control
logic
Test
Emulation
Interrupts
.L1
.D2
.D1
.M1
.S1
.M2 .S2 .L2
FIGURE 9.20
Registers of TMS320C67x ﬂoating-point DSP.
9.6 Digital Signal Processing Programming Examples
437

3. Memory and internal buses: Memory space is divided into internal program memory, internal
data memory, and internal peripheral and external memory space. The internal buses include
a 32-bit program address bus, a 256-bit program data bus to carry out eight 32-bit instructions
(VLIW), two 32-bit data address buses, two 64-bit load data buses, two 64-bit store data
buses, two 32-bit DMA buses, and two 32-bit DMA address buses responsible for reading and
writing. There also is a 22-bit address bus and a 32-bit data bus for accessing off-chip or
external memory.
4. Peripherals:
a. EMIF, which provides the required timing for accessing external memory;
b. DMA, which moves data from one memory location to another without interfering with CPU
operations;
c. Multichannel
buffered
serial
port
(McBSP)
with
a
high-speed
multichannel
serial
communication link;
d. HPI, which lets a host access internal memory;
e. Boot loader for loading code from off-chip memory or the HPI to internal memory;
f. Timers (two 32-bit counters);
g. Power-down units for saving power for periods when the CPU is inactive.
The software tool for the C67x is the Code Composer Studio (CCS) provided by TI. It allows the user
to build and debug programs from a user-friendly graphical user interface (GUI) and extends the
capabilities of code development tools to include real-time analysis. Installation, tutorial, coding, and
debugging information can be found in the CCS Getting Started Guide (Texas Instruments, 2001) and
in Kehtaranavaz and Simsek (2000).
Of particular note is the TMS320C6713 DSK with a clock rate of 225 MHz, which has the
capability to fetch eight 32-bit instructions every 4.4 nanoseconds (1/225 MHz). The functional block
diagram is shown in Figure 9.21. A detailed description can be found in Chassaing and Reay (2008).
9.6.2 Concept of Real-Time Processing
We illustrate real-time implementation in Figure 9.22, where the sampling rate is 8,000 samples per
second; that is, the sampling period is T ¼ 1=fs ¼ 125 microseconds, which is the time between two
samples.
As shown in Figure 9.22, the required timing includes an input sample clock and an output sample
clock. The input sample clock maintains the accuracy of the sampling time for each ADC operation,
while the output sample clock keeps the accuracy of the time instant for each DAC operation. The time
between the input sample clock n and output sample clock n consists of the ADC operation, algorithm
processing, and the wait for the next ADC operation. The numbers of instructions for ADC and the
DSP algorithm must be estimated and veriﬁed to ensure that all instructions have been completed
before DAC begins. Similarly, the number of instructions for DAC must be veriﬁed so that DAC
instructions will be ﬁnished between the output sample clock n and the next input sample clock n þ 1.
Timing usually is set up using the DSP interrupts (we will not pursue the interrupt setup here).
Next, we focus on the implementation of the DSP algorithm in a ﬂoating-point system for
simplicity. A DSK setup example (Tan and Jiang, 2010) is depicted in Figure 9.23, while a skeleton
code for veriﬁcation of the input and output is depicted in Figure 9.24.
438
CHAPTER 9 Hardware and Software for Digital Signal Processors

T
s
125
T
s
125
T
s
125
T
s
125
T
s
125
ADC  x(n)
Process ng DSP
a gor thm y(n)
Wa t ng t me
DAC  y(n)
ADC  x(n)
Process ng DSP
a gor thm y(n)
Wa t ng t me
DAC  y(n)
Input sample n
Input sample n+1
Input sample n+2
Output sample n
Output sample n+1
FIGURE 9.22
Concept of real-time processing.
FIGURE 9.21
Functional block diagram and registers of TMS320C6713 (courtesy of Texas Instruments).
9.6 Digital Signal Processing Programming Examples
439

TI TMS320C6713
DSP Board
Computer
Left Line In
Right Line In
Left Line Out
Right Line Out
Mic Input
Signal
Generator
Oscilloscope
Speaker
FIGURE 9.23
TMS320C6713 DSK setup example.
float x[1]={0.0};
float y[1]={0.0};
interrupt void c_int11()
{
float lc; /*left channel input */
float rc; /*right channel input */
float lcnew; /*left channel output */
float rcnew; /*right channel output */
int i;
//Left channel and right channel inputs
AIC23_data.combo=input_sample();
lc=(float) (AIC23_data.channel[LEFT]);
rc= (float) (AIC23_data.channel[RIGHT]);
// Insert DSP algorithm below 
x[0]=lc; /  Input from the left channel /
y[0]=x[0];  /  simplest DSP equation /
// End of the DSP algorithm
rcnew=y[0];
rcnew=y[0];
AIC23_data.channel[LEFT]=(short) lcnew;
AIC23_data.channel[RIGHT]=(short) rcnew;
output_sample(AIC23_data.combo);
}
FIGURE 9.24
Program segment for verifying input and output.
9.6.3 Linear Buffering
During DSP such as digital ﬁltering, past inputs and past outputs are required to be buffered
and
updated
for
processing
the
next
input
sample.
Let
us
ﬁrst
study
the
FIR
ﬁlter
implementation.
440
CHAPTER 9 Hardware and Software for Digital Signal Processors

Finite Impulse Response Filtering
Consider implementation for the following 3-tap FIR ﬁlter:
yðnÞ ¼ 0:5xðnÞ þ 0:2xðn  1Þ þ 0:5xðn  2Þ
The buffer requirements are shown in Figure 9.25. The coefﬁcient buffer b[3] contains 3 FIR coef-
ﬁcients, and the coefﬁcient buffer is ﬁxed during the process. The input buffer x[3], which holds the
Coefficient buffer b[3]
Update of input
buffer x[3]
(FIFO)
b[0]
b[1]
b[2]
0.5
0.5
0.2
x[0]
x[1]
x[2]
x(n)
x(n-1)
x(n-2)
New input x(n)
kicked out
First step
Free for new sample
float x[3]={0.0, 0.0, 0.0};
float b[3]={0.5, 0.2, 0.5};
float y[1]={0.0};
interrupt void c_int11()
{
float lc; /*left channel input */
float rc; /*right channel input */
float lcnew; /*left channel output */
float rcnew; /*right channel output */
int i;
//Left channel and right channel inputs
AIC23_data.combo=input_sample();
lc=(float) (AIC23_data.channel[LEFT]);
rc= (float) (AIC23_data.channel[RIGHT]);
// Insert DSP algorithm below 
for(i=2; i>0; i--)    /
/
 Update the input buffer x[3] /
{   x[i]=x[i-1]; }
x[0]= (float) lc;  Input from the left channel /
y[0]=0;
for(i=0; i<3; i++)
{  y[0]=y[0]+b[i] x[i]; } /  FIR filtering /
// End of the DSP algorithm
rcnew=y[0]; 
rcnew=y[0];
AIC23_data.channel[LEFT]=(short) lcnew;
AIC23_data.channel[RIGHT]=(short) rcnew;
output_sample(AIC23_data.combo);
}
FIGURE 9.25
Example of FIR ﬁltering with linear buffer update.
9.6 Digital Signal Processing Programming Examples
441

current and past inputs, must be updated. The FIFO update process is adopted here with the segment of
code shown in Figure 9.25. For each input sample, we update the input buffer using FIFO, which
begins at the end of the data buffer; the oldest sample is kicked out ﬁrst from the buffer and updated
with the value from the upper location. When the FIFO process is completed, the ﬁrst memory location
x[0] will be free to be used to store the current input sample. The segment of code in Figure 9.25
explains the implementation.
Note that in the code segment, x½0 holds the current input sample xðnÞ, while b½0 is the corre-
sponding coefﬁcient; x½1 and x½2 hold the past input samples xðn  1Þ and xðn  2Þ, respectively;
similarly, b½1 and b½2 are the corresponding coefﬁcients.
Again, note that using the array and loop structures in the code segment is for simplicity in notation
and the assumption is that the reader is not familiar with C pointers in the C language. The concern for
simplicity has to do mainly with the DSP algorithm. More coding efﬁciency can be achieved using C
pointers and a circular buffer. The DSP-oriented coding implementation can be found in Kehtarnavaz
and Simsek (2000) and Chassaing and Reay (2008).
Inﬁnite Impulse Response Filtering
Similarly, we can implement an IIR ﬁlter. It requires an input buffer, which holds the current and past
inputs; an output buffer, which holds the past outputs; a numerator coefﬁcient buffer; and a denomi-
nator coefﬁcient buffer. Consider the following IIR ﬁlter for implementation:
yðnÞ ¼ 0:5xðnÞ þ 0:7xðn  1Þ  0:5xðn  2Þ  0:4yðn  1Þ þ 0:6yðn  2Þ
We accommodate the numerator coefﬁcient buffer b[3], the denominator coefﬁcient buffer a[3], the
input buffer x[3], and the output buffer y[3] shown in Figure 9.26. The buffer updates for input x[3] and
output y[3] are FIFO. The implementation is illustrated in the segment of code listed in Figure 9.26.
Again, note that in the code segment, x½0 holds the current input sample, while y½0 holds the
current processed output, which will be sent to the DAC unit for conversion. The coefﬁcient a½0 is
never modiﬁed in the code. We keep that for a purpose of notation simplicity and consistency during
the programming process.
Digital Oscillation with Inﬁnite Impulse Response Filtering
The principle for generating digital oscillation is described in Chapter 8, where the input to the digital
ﬁlter is the impulse sequence, and the transfer function is obtained by applying the z-transform of the
digital sinusoid function. Applications can be found in dual-tone multifrequency (DTMF) tone genera-
tion, digital carrier generation for communications, and so on. Hence, we can modify the implementation
of IIR ﬁltering for tone generation with the input generated internally instead of using the ADC channel.
Let us generate an 800 Hz tone with a digital amplitude of 5,000. According to Section 8.11
“Application: Generation and Detection of DTMF Tones Using the Goertzel Algorithm” in Chapter 8,
the transfer function, difference equation, and the impulse input sequence are found to be, respectively,
HðzÞ ¼
0:587785z 1
1  1:618034z 1 þ z 2
yðnÞ ¼ 0:587785xðn  1Þ þ 1:618034yðn  1Þ  yðn  2Þ
xðnÞ ¼ 5000dðnÞ
442
CHAPTER 9 Hardware and Software for Digital Signal Processors

Coefficients b[3]
Coefficents a[3]
Update of input
buffer x[3]
(FIFO)
b[0]
b[1]
b[2]
0.5
0.5
0.7
a[0]
a[1]
a[2]
x[0]
x[1]
x[2]
1
0.4
0.6
x(n)
x(n 1)
x(n 2)
New input x(n)
Kicked out
First step
Free for new sample
Update of output
buffer y[3]
(FIFO)
y[0]
y[1]
y[2]
y(n)
y(n 1)
y(n 2)
Kicked out
First step
Free for output sample
float x[3]={0.0, 0.0, 0.0};
float b[3]={0.5, 0.7, -0.5};
float a[3]={1, 0.4, -0.6};
float y[3]={0.0, 0.0, 0.0};
interrupt void c_int11()
{
float lc; /*left channel input */
float rc; /*right channel input */
float lcnew; /*left channel output */
float rcnew; /*right channel output */
int i;
//Left channel and right channel inputs
AIC23_data.combo=input_sample();
lc=(float) (AIC23_data.channel[LEFT]);
rc= (float) (AIC23_data.channel[RIGHT]);
// Insert DSP algorithm below 
for(i=2; i>0; i--)
/ Update the input buffer /
{   x[i]=x[i-1];   }
x[0]= lc; / Input from the left channel /
for (i=2;i>0;i--)
/ Update the output buffer /
{    y[i]=y[i-1];  }
y[0]=b[0] x[0]+b[1] x[1]+b[2] x[2]-a[1] y[1]-a[2] y[2];
// End of the DSP algorithm
rcnew=y[0]; 
rcnew=y[0];
AIC23_data.channel[LEFT]=(short) lcnew;
AIC23_data.channel[RIGHT]=(short) rcnew;
output_sample(AIC23_data.combo);
}
FIGURE 9.26
Example of IIR ﬁltering using linear buffer update.
9.6 Digital Signal Processing Programming Examples
443

We deﬁne the numerator coefﬁcient buffer b[2], the denominator coefﬁcient buffer a[3], the input
buffer x[2], and the output buffer y[3] in Figure 9.27, which also shows the modiﬁed implementation
for tone generation.
Coefficients b[2]
Coefficents a[3]
Update of input
buffer x[2]
(FIFO)
b[0]
b[1]
0.0
0.587785
a[0]
a[1]
a[2]
x[0]
x[1]
1.0
-1.618034
1.0
5000
x(n-1)
New input x(n)=0
Kicked out
First step
Free for new sample
Update of output
buffer y[3]
(FIFO)
y[0]
y[1]
y[2]
y(n)
y(n-1)
y(n-2)
Kicked out
First step
Free for output sample
float x[2]={5000, 0.0}; / initialize the impulse input /
float b[2]={0.0, 0.587785};
float a[3]={1.0, -1.618034,  1.0};
float y[3]={0.0};
interrupt void c_int11()
{    float lc; /*left channel input */
float rc; /*right channel input */
float lcnew; /*left channel output */
float rcnew; /*right channel output */
int i;
//Left channel and right channel inputs
AIC23_data.combo=input_sample();
lc=(float) (AIC23_data.channel[LEFT]);
rc= (float) (AIC23_data.channel[RIGHT]);
// Insert DSP algorithm below 
y[0]=b[0] x[0]+b[1] x[1]+b[2] x[2]-a[1] y[1]-a[2] y[2];
for(i=2; i>0; i--)     /  Update the input buffer with zero input /
{   x[i]=x[i-1];   }
x[0]= 0; 
for (i=2;i>0;i--)     /  Update the output buffer /
{    y[i]=y[i-1];  }
// End of the DSP algorithm
rcnew=y[0]; 
rcnew=y[0];
AIC23_data.channel[LEFT]=(short) lcnew;
AIC23_data.channel[RIGHT]=(short) rcnew;
output_sample(AIC23_data.combo);
}
FIGURE 9.27
Example of IIR ﬁltering using linear buffer update and the impulse sequence input.
444
CHAPTER 9 Hardware and Software for Digital Signal Processors

Initially, we set x½0 ¼ 5;000. Then it will be updated with x½0 ¼ 0 for each current processed
output sample y½0.
9.6.4 Sample C Programs
Floating-Point Implementation Example
Real-time DSP implementation using a ﬂoating-point processor is easy to program. The overﬂow
problem hardly ever occurs. Therefore, we do not need to consider scaling factors, as described in the
last section. The code segment shown in Figure 9.28 demonstrates the simplicity of coding the
ﬂoating-point IIR ﬁlter using the direct-form I structure.
Fixed-Point Implementation Example
When the execution time is critical, ﬁxed-point implementation is preferred in a ﬂoating-point
processor. We implement the following IIR ﬁlter with a unit passband gain in direct-form II:
float a[5]={1.00, -2.1192, 2.6952, -1.6924, 0.6414};
float b[5]={0.0201, 0.00, -0.0402, 0.00, 0.0201};
float x[5]={0.0, 0.0, 0.0, 0.0, 0.0};
float y[5]={0.0, 0.0, 0.0, 0.0, 0.0};
interrupt void c_int11()
{
float lc; /*left channel input */
float rc; /*right channel input */
float lcnew; /*left channel output */
float rcnew; /*right channel output */
int i;
//Left channel and right channel inputs
AIC23_data.combo=input_sample();
lc=(float) (AIC23_data.channel[LEFT]);
rc= (float) (AIC23_data.channel[RIGHT]);
// Insert DSP algorithm below 
for(i=4; i>0; i--)
/  Update the input buffer /
{   
x[i]=x[i-1];   
}
x[0]= lc; /  Input from the left channel /
for (i=2;i>0;i--)      /  Update the output buffer /
{   
y[i]=y[i-1];  
}
y[0]=b[0] x[0]+b[1] x[1]+b[2] x[2]+b[3] x[3]+b[4] x[4]-a[1] y[1]-a[2] y[2]-a[3] y[3]-a[4] y[4];
// End of the DSP algorithm
rcnew=y[0]; 
rcnew=y[0];
AIC23_data.channel[LEFT]=(short) lcnew;
AIC23_data.channel[RIGHT]=(short) rcnew;
output_sample(AIC23_data.combo);
}
FIGURE 9.28
Sample C code for IIR ﬁltering (ﬂoating-point implementation).
9.6 Digital Signal Processing Programming Examples
445

HðzÞ ¼
0:0201  0:0402z 2 þ 0:0201z 4
1  2:1192z 1 þ 2:6952z 2  1:6924z 3 þ 0:6414z 4
wðnÞ ¼ xðnÞ þ 2:1192wðn  1Þ  2:6952wðn  2Þ þ 1:6924wðn  3Þ  0:6414wðn  4Þ
yðnÞ ¼ 0:0201wðnÞ  0:0402wðn  2Þ þ 0:0201wðn  4Þ
Using MATLAB to calculate the scale factor S, it follows that
» h¼impz([1],[1 2.1192 2.6952 1.6924 0.6414]);
» sf¼sum(abs(h))
sf¼28.2196
Hence we choose S ¼ 32. To scale the ﬁlter coefﬁcients in the Q-15 format, we use the factors A ¼ 4
and B ¼ 1. Then the developed DSP equations are
xsðnÞ ¼ xðnÞ=32
wsðnÞ ¼ 0:25xsðnÞ þ 0:5298wsðn  1Þ  0:6738wsðn  2Þ þ 0:4231wsðn  3Þ  0:16035wsðn  4Þ
wðnÞ ¼ 4wsðnÞ
ysðnÞ ¼ 0:0201wðnÞ  0:0402wðn  2Þ þ 0:0201wðn  4Þ
yðnÞ ¼ 32ysðnÞ
Using the method described in Section 9.5, we can convert ﬁlter coefﬁcients into the Q-15 format; each
coefﬁcient is listed in Table 9.4.
Table 9.4 Filter Coefﬁcients in Q-15 Format
IIR Filter
Filter Coefﬁcients
Q-15 Format (Hex)
a1
0.5298
0  43D0
a2
0.6738
0  A9C1
a3
0.4230
0  3628
a4
0.16035
0  EB7A
b0
0.0201
0  0293
b1
0.0000
0  0000
b2
0.0402
0  FADB
b3
0.0000
0  000
b4
0.0201
0  0293
446
CHAPTER 9 Hardware and Software for Digital Signal Processors

/*float a[5]={1.00, -2.1192, 2.6952, -1.6924, 0.6414}; float b[5]={0.0201, 0.00, -0.0402, 0.00, 0.0201};*/
short a[5]={0x2000, 0x43D0, 0xA9C1, 0x3628, 0xEB7A}; /* coefficients in Q-15 format */
short b[5]={0x0293, 0x0000, 0xFADB, 0x0000, 0x0293};
int w[5]={0, 0, 0, 0, 0};
int sample;
interrupt void c_int11()
{
float lc; /*left channel input */
float rc; /*right channel input */
float lcnew; /*left channel output */
float rcnew; /*right channel output */
int i, sum=0;
//Left channel and right channel inputs
AIC23_data.combo=input_sample();
lc= (float) (AIC23_data.channel[LEFT]);
rc= (float) (AIC23_data.channel[RIGHT]);
// Insert DSP algorithm below 
sample = (int) lc; /*input sample from the left channel*/
sample = (sample << 16);  /  move to high 16 bits /
sample = (sample>>5); /  scaled down by 32 to avoid overflow /
for (i=4;i>0;i--)
{
w[i]=w[i-1];
}
sum= (sample >> 2); /  scaled down by 4 to use Q-15 /
for (i=1;i<5;i++)
{
sum += (_mpyhl(w[i],a[i])) <<1;
}
sum = (sum <<2); /  scaled up by 4 /
w[0]=sum;
sum =0;
for(i=0;i<5;i++)
{ 
sum += (_mpyhl(w[i],b[i]))<<1;
}
sum = (sum << 5);  /  scaled up by 32 to get y(n) /
sample= (sum>>16); /  move to low 16 bits /
// End of the DSP algorithm
rcnew=sample; 
rcnew=sample;
AIC23_data.channel[LEFT]=(short) lcnew;
AIC23_data.channel[RIGHT]=(short) rcnew;
output_sample(AIC23_data.combo);
}
FIGURE 9.29
Sample C code for IIR ﬁltering (ﬁxed point implementation).
9.6 Digital Signal Processing Programming Examples
447

The code for the ﬁxed-point implementation is displayed in Figure 9.29, and some coding notations
are given in Figure 9.30.
Note that this chapter has provided only basic concepts and an introduction to real-time DSP
implementation. The coding detail and real-time DSP applications will be treated in a separate DSP
course, which deals with real-time implementations.
9.7 SUMMARY
1. The Von Neumann architecture consists of a single, shared memory for programs and data, a single
bus for memory access, an arithmetic unit, and a program control unit. The Von Neumann
processor operates fetching and execution cycles seriously.
2. The Harvard architecture has two separate memory spaces dedicated to program code and to data,
respectively, two corresponding address buses, and two data buses for accessing two memory
spaces. The Harvard processor offers fetching and executions in parallel.
3. The DSP special hardware units include a MAC dedicated to DSP ﬁltering operations, a shifter unit
for scaling, and address generators for circular buffering.
4. The ﬁxed-point DS processor uses integer arithmetic. The data format Q-15 for the ﬁxed-point
system is preferred to avoid the overﬂows.
5. The ﬂoating-point processor uses ﬂoating-point arithmetic. The standard ﬂoating-point formats
include the IEEE single precision and double precision formats.
6. The architectures and features of ﬁxed-point processors and ﬂoating-point processors were brieﬂy
reviewed.
7. Implementing digital ﬁlters in the ﬁxed-point DSP system requires scaling ﬁlter coefﬁcients so that
the ﬁlters are in Q-15 format, and input scaling for the adder so that overﬂow during MAC
operations can be avoided.
8. The ﬂoating-point processor is easy to code using ﬂoating-point arithmetic and develops the
prototype quickly. However, it is not efﬁcient in terms of the number of instructions it has to
complete compared with the ﬁxed-point processor.
9. The ﬁxed-point processor using ﬁxed-point arithmetic takes much effort to code. But it offers the
least number of the instructions for the CPU to execute.
short coefficient;
declaration of 16 bit signed integer
int sample, result;
declaration of 32 bit signed integer
MPYHL assembly instruction (signed multiply high low 16 MSB x 16 LSB)
result = (_mpyhl(sample,coefficient) ) <<1;
sample must be shifted left by 16 bits to be stored in the high 16 MSB.
coefficient is the 16 bit data to be stored in the low 16 LSB.
result is shifted left by one bit to get rid of the extended sign bit, and high 16 
MSB’s are designated for the processed data.
Final result will be shifted down to right by 16 bits before DAC conversion.
sample = (result>>16);
FIGURE 9.30
Some coding notations for the Q-15 ﬁxed-point implementation.
448
CHAPTER 9 Hardware and Software for Digital Signal Processors

9.8 PROBLEMS
9.1. Find the signed Q-15 representation for the decimal number 0.2560123.
9.2. Find the signed Q-15 representation for the decimal number 0.2160123.
9.3. Find the signed Q-15 representation for the decimal number 0.3567921.
9.4. Find the signed Q-15 representation for the decimal number 0.4798762.
9.5. Convert the Q-15 signed number ¼ 1.010101110100010 to a decimal number.
9.6. Convert the Q-15 signed number ¼ 0.001000111101110 to a decimal number.
9.7. Convert the Q-15 signed number ¼ 0.110101000100010 to a decimal number.
9.8. Convert the Q-15 signed number ¼ 1.101000100101111 to a decimal number.
9.9. Add the following two Q-15 numbers:
1: 1 0 1 0 1 0 1 1 1 0 0 0 0 0 1 þ 0: 0 1 0 0 0 1 1 1 1 0 1 1 0 1 0
9.10. Add the following two Q-15 numbers:
0: 0 0 1 0 1 0 1 0 1 0 0 0 0 0 1 þ 0: 0 1 0 1 0 1 1 1 1 0 1 0 0 1 0
9.11. Add the following two Q-15 numbers:
1: 0 0 1 0 1 0 1 0 1 0 0 0 0 0 1 þ 1: 0 1 0 1 0 1 1 1 1 0 1 0 0 1 0
9.12. Add the following two Q-15 numbers:
0: 0 0 1 0 1 0 1 0 1 0 0 0 0 0 1 þ 1: 0 1 0 1 0 1 1 1 1 0 1 0 0 1 0
9.13. Convert each of the following decimal numbers to a ﬂoating-point number using the format
speciﬁed in Figure 9.10.
a. 0.1101235
b. 10.430527
9.14. Convert each of the following decimal numbers to a ﬂoating-point number using the format
speciﬁed in Figure 9.10.
a. 2.5568921
b. 0.678903
c. 0.0000000
d. 1.0000000
9.7 Summary
449

9.15. Add the following ﬂoating-point numbers whose formats are deﬁned in Figure 9.10, and
determine the sum in decimal format:
1101 011100011011 þ 0100 101111100101
9.16. Add the following ﬂoating-point numbers whose formats are deﬁned in Figure 9.10, and
determine the sum in decimal format:
0111 110100011011 þ 0101 001000100101
9.17. Add the following ﬂoating-point numbers whose formats are deﬁned in Figure 9.10, and
determine the sum in decimal format:
0001 000000010011 þ 0100 001000000101
9.18. Convert the following number in IEEE single precision format to the decimal format:
110100000.010. 0000
9.19. Convert the following number in IEEE single precision format to the decimal format:
010100100.101. 0000
9.20. Convert the following number in IEEE double precision format to the decimal format:
011000.0:1010.000
9.21. Convert the following number in IEEE double precision format to the decimal format:
011000.0:0110.0000
9.22. Given the FIR ﬁlter
yðnÞ ¼ 0:2xðnÞ þ 0:6xðn  1Þ þ 0:2xðn  2Þ
with a passband gain of 1 and the input being a full range, develop the DSP implementation
equations in the Q-15 ﬁxed-point system.
9.23. Given the IIR ﬁlter
yðnÞ ¼ 0:6xðnÞ þ 0:3yðn  1Þ
with a passband gain of 1 and the input being a full range, use the direct-form I method to
develop the DSP implementation equations in the Q-15 ﬁxed-point system.
9.24. Repeat Problem 9.23 using the direct-form II method.
9.25. Given the FIR ﬁlter
yðnÞ ¼ 0:36xðnÞ þ 1:6xðn  1Þ þ 0:36xðn  2Þ
with a passband gain of 2 and the input being half of the range, develop the DSP imple-
mentation equations in the Q-15 ﬁxed-point system.
9.26. Given the IIR ﬁlter
yðnÞ ¼ 1:35xðnÞ þ 0:3yðn  1Þ
450
CHAPTER 9 Hardware and Software for Digital Signal Processors

with a passband gain of 2, and the input being half of the range, use the direct-form I method
to develop the DSP implementation equations in the Q-15 ﬁxed-point system.
9.27. Repeat Problem 9.26 using the direct-form II method.
9.28. Given the IIR ﬁlter
yðnÞ ¼ 0:72xðnÞ þ 1:42xðn  2Þ þ 0:72xðn  2Þ  1:35yðn  1Þ  0:5yðn  2Þ
with a passband gain of 1 and a full range of input, use the direct-form I to develop the DSP
implementation equations in the Q-15 ﬁxed-point system.
9.29. Repeat Problem 9.28 using the direct-form II method.
9.7 Summary
451

This page intentionally left blank

Adaptive Filters and Applications 10
CHAPTER OUTLINE
10.1 Introduction to Least Mean Square Adaptive Finite Impulse Response Filters ................................. 453
10.2 Basic Wiener Filter Theory and Least Mean Square Algorithm....................................................... 457
10.3 Applications: Noise Cancellation, System Modeling, and Line Enhancement .................................. 462
10.3.1 Noise Cancellation.................................................................................................462
10.3.2 System Modeling...................................................................................................468
10.3.3 Line Enhancement Using Linear Prediction..............................................................473
10.4 Other Application Examples......................................................................................................... 476
10.4.1 Canceling Periodic Interferences Using Linear Prediction..........................................476
10.4.2 Electrocardiography Interference Cancellation..........................................................476
10.4.3 Echo Cancellation in Long-Distance Telephone Circuits ............................................479
10.5 Laboratory Examples Using the TMS320C6713 DSK ..................................................................... 480
10.6 Summary ................................................................................................................................... 485
OBJECTIVES
This chapter introduces principles of adaptive ﬁlters and the adaptive least mean square algorithm and
illustrates how to apply the adaptive ﬁlters to solve the real-world application problems such as adaptive
noise cancellation, system modeling, adaptive line enhancement, and telephone echo cancellation.
10.1 INTRODUCTION TO LEAST MEAN SQUARE ADAPTIVE
FINITE IMPULSE RESPONSE FILTERS
An adaptive ﬁlter is a digital ﬁlter that has self-adjusting characteristics. It is capable of adjusting its
ﬁlter coefﬁcients automatically to adapt the input signal via an adaptive algorithm. Adaptive ﬁlters
play an important role in modern digital signal processing (DSP) products in areas such as telephone
echo cancellation, noise cancellation, equalization of communications channels, biomedical signal
enhancement, active noise control, and adaptive control systems. Adaptive ﬁlters work generally for
adaptation of signal-changing environments, spectral overlap between noise and signal, and
unknown or time-varying noise. For example, when the interference noise is strong and its spectrum
overlaps that of the desired signal, removing the interference using a traditional ﬁlter such as a notch
ﬁlter with ﬁxed ﬁlter coefﬁcients will fail to preserve the desired signal spectrum, as shown in
Figure 10.1.
However, an adaptive ﬁlter will do the job. Note that adaptive ﬁltering, with its applications, has
existed for more than two decades in the research community and is still active there. This chapter can
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00010-X
Copyright  2013 Elsevier Inc. All rights reserved.
453

only introduce some fundaments of the subject, that is, adaptive ﬁnite impulse response (FIR) ﬁlters
with a simple and popular least mean square (LMS) algorithm. Further exploration into adaptive
inﬁnite impulse response (IIR) ﬁlters, adaptive lattice ﬁlters, their associated algorithms and appli-
cations, and so on, can be found in comprehensive texts by Haykin (1991), Stearns (2003), and Widrow
and Stearns (1985).
To understand the concept of adaptive ﬁltering, we will ﬁrst look at an illustrative example of the
simplest noise canceller to see how it works before diving into detail. The block diagram for such
a noise canceller is shown in Figure 10.2.
As shown in Figure 10.2, ﬁrst, the DSP system consists of two analog-to-digital conversion (ADC)
channels. The ﬁrst microphone with ADC is used to capture the desired speech sðnÞ. However, due to
a noisy environment, the signal is contaminated and the ADC channel produces a signal with the noise;
that is, dðnÞ ¼ sðnÞ þ nðnÞ. The second microphone is placed where only noise is picked up and the
second ADC channel captured noise xðnÞ, which is fed to the adaptive ﬁlter.
Note that the corrupting noise nðnÞ in the ﬁrst channel is uncorrelated to the desired signal sðnÞ, so
that separation between them is possible. The noise signal xðnÞ from the second channel is correlated
f
Spectrum
Noise spectum
Desired signal spectrum
FIGURE 10.1
Spectrum illustration for using adaptive ﬁlters.
y n
w x n
n
( )
( )
y n
( )
d n
s n
n n
( )
( )
( )
x n
( )
e n
d n
y n
s n
( )
( )
( )
~( )
w
w
e n x n
n
n
1
0 01
.
( ) ( )
ADC
ADC
DAC
Adaptive filter
LMS algorithm
Noise
la
n
gis
r
o
rr
E
e
sio
n
d
n
a
la
n
gi
S
FIGURE 10.2
Simplest noise canceller using a one-tap adaptive ﬁlter.
454
CHAPTER 10 Adaptive Filters and Applications

to the corrupting noise nðnÞ in the ﬁrst channel, since both come from the same noise source. Similarly,
the noise signal xðnÞ is not correlated to the desired speech signal sðnÞ.
We assume that the corrupting noise in the ﬁrst channel is a linear ﬁltered version of the second-
channel noise, since it has a different physical path from the second-channel noise, and the noise source
is time varying, so that we can estimate the corrupting noise nðnÞ using an adaptive ﬁlter. The adaptive
ﬁlter contains a digital ﬁlter with adjustable coefﬁcient(s) and the LMS algorithm to modify the value(s)
of coefﬁcient(s) for ﬁltering each sample. The adaptive ﬁlter then produces an estimate of noise yðnÞ,
which will be subtracted from the corrupted signal dðnÞ ¼ sðnÞ þ nðnÞ. When the noise estimate yðnÞ
equals or approximates the noise nðnÞ in the corrupted signal, that is, yðnÞznðnÞ, the error signal eðnÞ ¼
sðnÞ þ nðnÞ  yðnÞz~sðnÞ will approximate the clean speech signal sðnÞ. Hence, the noise is cancelled.
In our illustrative numerical example, the adaptive ﬁlter is set to be one-tap FIR ﬁlter to simplify
numerical algebra. The ﬁlter adjustable coefﬁcient wn is adjusted based on the LMS algorithm (dis-
cussed later in detail) in the following:
wnþ1 ¼ wn þ 0:01$eðnÞ$xðnÞ
where wn is the coefﬁcient used currently, while wnþ1 is the coefﬁcient obtained from the LMS
algorithm and will be used for the next coming input sample. The value of 0.01 controls the speed of
the coefﬁcient change. To illustrate the concept of the adaptive ﬁlter in Figure 10.2, the LMS algorithm
has the initial coefﬁcient set to w0 ¼ 0:3 and leads to
yðnÞ ¼ wnxðnÞ
eðnÞ ¼ dðnÞ  yðnÞ
wnþ1 ¼ wn þ 0:01eðnÞxðnÞ
The corrupted signal is generated by adding noise to a sine wave. The corrupted signal and noise
reference are shown in Figure 10.3, and their ﬁrst 16 values are listed in Table 10.1.
Let us perform adaptive ﬁltering for several samples using the values for the corrupted signal and
reference noise in Table 10.1. We see that
n ¼ 0;
yð0Þ ¼ w0xð0Þ ¼ 0:3  ð 0:5893Þ ¼ 0:1768
eð0Þ ¼ dð0Þ  yð0Þ ¼ 0:2947  ð0:1768Þ ¼ 0:1179 ¼ ~sð0Þ
w1 ¼ w0 þ 0:01eð0Þxð0Þ ¼ 0:3 þ 0:01  ð0:1179Þ  ð0:5893Þ ¼ 0:3007
n ¼ 1;
yð1Þ ¼ w1xð1Þ ¼ 0:3007  0:5893 ¼ 0:1772
eð1Þ ¼ dð1Þ  yð1Þ ¼ 1:0017  0:1772 ¼ 0:8245 ¼ ~sð1Þ
w2 ¼ w1 þ 0:01eð1Þxð1Þ ¼ 0:3007 þ 0:01  0:8245  0:5893 ¼ 0:3056
n ¼ 2;
yð2Þ ¼ w2xð2Þ ¼ 0:3056  3:1654 ¼ 0:9673
eð2Þ ¼ dð2Þ  yð2Þ ¼ 2:5827  0:9673 ¼ 1:6155 ¼ ~sð2Þ
w3 ¼ w2 þ 0:01eð2Þxð2Þ ¼ 0:3056 þ 0:01  1:6155  3:1654 ¼ 0:3567
n ¼ 3; /
10.1 Least Mean Square Adaptive Finite Impulse Response Filters
455

0
5
10
15
20
25
30
5
0
5
d(n)
0
5
10
15
20
25
30
5
0
5
x(n)
0
5
10
15
20
25
30
2
0
2
 e(n)
0
5
10
15
20
25
30
2
0
2
s(n)
0
5
10
15
20
25
30
0
0.5
1
wn
Sample number n
converges
FIGURE 10.3
Original signal, reference noise, corrupted signal, enhanced signal, and adaptive coefﬁcient in the noise
cancellation.
TABLE 10.1 Adaptive Filtering Results for the Simplest Noise Canceller Example
n
dðnÞ
xðnÞ
~sðnÞ [ eðnÞ
Original sðnÞ
wnD1
0
0.2947
0.5893
0.1179
0
0.3000
1
1.0017
0.5893
0.8245
0.7071
0.3007
2
2.5827
3.1654
1.6155
1.0000
0.3056
3
1.6019
4.6179
0.0453
0.7071
0.3567
4
0.5622
1.1244
0.1635
0.0000
0.3546
5
0.4456
2.3054
0.3761
0.7071
0.3564
6
4.2674
6.5348
1.9948
1.0000
0.3478
7
0.8418
0.2694
0.7130
0.7071
0.4781
8
0.3862
0.7724
0.0154
0.0000
0.4800
9
1.2274
1.0406
0.7278
0.7071
0.4802
10
0.6021
0.7958
0.9902
1.0000
0.4877
11
1.1647
0.9152
0.7255
0.7071
0.4799
12
0.9630
1.9260
0.0260
0.0000
0.4865
13
1.5065
1.5988
0.7279
0.7071
0.4870
14
0.1329
1.7342
0.9976
1.0000
0.4986
15
0.8146
3.0434
0.6503
0.7071
0.4813
456
CHAPTER 10 Adaptive Filters and Applications

For comparison, results of the ﬁrst 16 processed output samples, original samples, and ﬁlter coefﬁcient
values are also included in Table 10.1. Figure 10.3 also shows the original signal samples, reference
noise samples, corrupted signal samples, enhanced signal samples, and ﬁlter coefﬁcient values for each
incoming sample, respectively.
As shown in Figure 10.3, after seven adaptations, the adaptive ﬁlter learns noise characteristics
and cancels the noise in the corrupted signal. The adaptive coefﬁcient is close to the optimal value of
0.5. The processed output is close to the original signal. The ﬁrst 16 processed values for corrupted
signal, reference noise, clean signal, original signal, and adaptive ﬁlter coefﬁcient used at each step are
listed in Table 10.1.
Clearly, the enhanced signal samples look much like the sinusoid input samples. Now our simplest
one-tap adaptive ﬁlter works for this particular case. In general, an FIR ﬁlter with multiple taps is used
and has the following format:
yðnÞ ¼
X
N
1
i ¼ 0
wnðiÞxðn  iÞ ¼ wnð0ÞxðnÞ þ wnð1Þxðn  1Þ þ / þ wnðN  1Þxðn  N þ 1Þ
(10.1)
The LMS algorithm for the adaptive FIR ﬁlter will be developed next.
10.2 BASIC WIENER FILTER THEORY AND LEAST MEAN
SQUARE ALGORITHM
Many adaptive algorithms can be viewed as approximations of the discrete Wiener ﬁlter shown in
Figure 10.4, where the Wiener ﬁlter output yðnÞ is a sum of its N weighted inputs, that is,
yðnÞ ¼ wð0ÞxðnÞ þ wð1Þxðn  1Þ þ . þ wðN  1Þxðn  N þ 1Þ:
The Wiener ﬁlter adjusts its weight(s) to produce a desired ﬁlter output yðnÞ which is close to the
noise nðnÞ contained in the corrupted signal dðnÞ. At the subtracted output, the noise nðnÞ is cancelled
or attenuated. Hence, the output eðnÞ contains a clean signal.
Consider a single-weight case of yðnÞ ¼ wxðnÞ, and note that the error signal eðnÞ is given by
eðnÞ ¼ dðnÞ  wxðnÞ
(10.2)
Now let us determine the best weight w. Taking the square or enhanced the output error leads to
e2ðnÞ ¼ ðdðnÞ  wxðnÞÞ2 ¼ d2ðnÞ  2dðnÞwxðnÞ þ w2x2ðnÞ
(10.3)
e n
( )
x n
( )
d n
s n
n n
( )
( )
( )
y n
( )
Wiener filter
Output
Noise
Signal and noise
FIGURE 10.4
Wiener ﬁlter for noise cancellation.
10.2 Basic Wiener Filter Theory and Least Mean Square Algorithm
457

Taking the statistical expectation of Equation (10.3), we have
E

e2
n

¼ E

d2
n

 2wEðdðnÞxðnÞÞ þ w2E

x2
n

(10.4)
Using the notations in statistics, we deﬁne
J ¼ E

e2
n

¼ MSE ¼ mean squared error
s2 ¼ E

d2
n

¼ power of corrupted signal
P ¼ EðdðnÞxðnÞÞ ¼ cross-correlation between dðnÞ and xðnÞ
R ¼ E

x2
n

¼ autocorrelation
We can view the statistical expectation as an average of the N signal terms, each being a product of two
individual samples
E

e2
n

¼ e2
0

þ e2
1

þ / þ e2
N  1

N
or
EðdðnÞxðnÞÞ ¼ dð0Þxð0Þ þ dð1Þxð1Þ þ / þ dðN  1ÞxðN  1Þ
N
for a sufﬁciently large sample number of N. We can write Equation (10.4) as
J ¼ s2  2wP þ w2R
(10.5)
Since s2, P, and R are constants, J is a quadratic function of w that may be plotted as shown in
Figure 10.5.
The best weight (optimal) w is at the location where the minimum MSE Jmin is achieved. To
obtain w, taking a derivative of J and setting it to zero leads to
dJ
dw ¼ 2P þ 2wR ¼ 0
(10.6)
Solving Equation (10.6), we get the best weight solution as
w ¼ R 1P
(10.7)
J
w
w*
Jmin
FIGURE 10.5
Mean square error quadratic function.
458
CHAPTER 10 Adaptive Filters and Applications

EXAMPLE 10.1
Consider the following quadratic MSE function for the Wiener ﬁlter:
J
40
20w þ 10w2
Find the optimal solution for w to achieve the minimum MSE Jmin and determine Jmin.
Solution:
Taking a derivative of the MSE function and setting it to zero, we have
dJ
dw
20 þ 10  2w
0
Solving the equation leads to
w
1
Finally, substituting w
1 into the MSE function, we get the minimum Jmin as
Jmin
J

w
w 
40
20w þ 10w2
w
1
40
20  1 þ 10  12
30
Notice that a few points need to be clariﬁed for Equation (10.7):
1. Optimal coefﬁcient (s) can be different for every block of data, since the corrupted signal and
reference signal are unknown. The autocorrelation and cross-correlation may vary.
2. If a larger number of coefﬁcients (weights) are used, the inverse matrix of R 1 may require a
larger number of computations and may become ill-conditioned. This will make real-time
implementation impossible.
3. The optimal solution is based on the statistics, assuming that the size of the data block, N, is
sufﬁcient long. This will cause a long processing delay that will make real-time implementation
impossible.
As we pointed out, solving the Wiener solution, Equation (10.7), requires a lot of computations,
including matrix inversion for a general multiple-tap FIR ﬁlter. The well-known textbook authored by
Widrow and Stearns (1985) described a powerful LMS algorithm by using the steepest descent
algorithm to minimize the MSE sample by sample to locate the ﬁlter coefﬁcient(s). We ﬁrst study the
steepest descent algorithm illustrated in the following:
wnþ1 ¼ wn  m dJ
dw
(10.8)
where m ¼ constant controlling speed of convergence.
The illustration of the steepest decent algorithm for solving the optimal coefﬁcient(s) is described
in Figure 10.6.
As shown in the ﬁrst plot in Figure 10.6, if dJ
dw < 0, notice that m dJ
dw > 0. The new coefﬁcient
wnþ1 will be increased to approach the optimal value w by Equation (10.8). On the other
hand, if dJ
dw > 0, as shown in the second plot in Figure 10.6, we see that m dJ
dw < 0. The new
10.2 Basic Wiener Filter Theory and Least Mean Square Algorithm
459

coefﬁcient wnþ1 will be decreased to approach the optimal value w. When dJ
dw ¼ 0, the best coef-
ﬁcient wnþ1 is reached.
EXAMPLE 10.2
Consider the following quadratic MSE function for the Wiener ﬁlter:
J
40
20w þ 10w2
Use the steepest decent method with an initial guess of w0
0 and m
0:04 to ﬁnd the optimal solution for w
and determine Jmin by iterating three times.
Solution:
Taking a derivative of the MSE function, we have
dJ
dw
20 þ 10  2wn
When n
0, we calculate
m dJ
dw
0:04  ð 20 þ 10  2w0Þ

w0
0
0:8
Applying the steepest decent algorithm, it follows that
w1
w0
m dJ
dw
0
ð 0:8Þ
0:8
Similarly for n
1, we get
m dJ
dw
0:04  ð 20 þ 10  2w1Þ

w1
0:8
0:16
w2
w1
m dJ
dw
0:8
ð 0:16Þ
0:96
and for n
2, it follows that
m dJ
dw
0:04  ð 20 þ 10  2w2Þ

w2
0:96
0:032
w*
w
wn 1
wn
Jmin
Jn
Jn 1
J
w*
w
wn 1 wn
Jmin
Jn
Jn 1
J
Case dJ
dw
and
dJ
dw
0
0
Case dJ
dw
and
dJ
dw
0
0
FIGURE 10.6
Illustration of the steepest descent algorithm.
460
CHAPTER 10 Adaptive Filters and Applications

w3
w2
m dJ
dw
0:96
ð 0:032Þ
0:992
Finally, substituting wzw3
0:992 into the MSE function, we get the minimum Jmin as
Jmin z 40
20w þ 10w2
w
0:992
40
20  0:992 þ 10  0:9922
30:0006
As we can see, after three iterations, the ﬁlter coefﬁcient and minimum MSE values are very close to the theoretical
values obtained in Example 10.1.
Application of the steepest descent algorithm still needs an estimation of the derivative of the MSE
function that could include statistical calculation of a block of data. To change the algorithm to do
sample-based processing, an LMS algorithm must be used. To develop the LMS algorithm in terms of
sample-based processing, we take the statistical expectation out of J and then take the derivative to
obtain an approximation of dJ
dw, that is,
J ¼ e2ðnÞ ¼ ðdðnÞ  wxðnÞÞ2
(10.9)
dJ
dw ¼ 2ðdðnÞ  wxðnÞÞ dðdðnÞ  wxðnÞÞ
dw
¼ 2eðnÞxðnÞ
(10.10)
Substituting dJ
dw into the steepest descent algorithm in Equation (10.8), we achieve the LMS algorithm
for updating a single-weight case as
wnþ1 ¼ wn þ 2meðnÞxðnÞ
(10.11)
where m is the convergence parameter controlling speed of convergence. For example, let us choose
2m ¼ 0:01. In general, with an adaptive FIR ﬁlter of length N, we extend the single-tap LMS algo-
rithm without going through derivation, as shown in the following equations:
yðnÞ ¼ wnð0ÞxðnÞ þ wnð1Þxðn  1Þ þ / þ wnðN  1Þxðn  N þ 1Þ
(10.12)
for i ¼ 0; /; N  1
wnþ1ðiÞ ¼ wnðiÞ þ 2meðnÞxðn  iÞ
(10.13)
The convergence factor is chosen to be
0 < m <
1
NPx
(10.14)
where Px is the input signal power. In practice, if the ADC has 16-bit data, the maximum signal
amplitude should be A ¼ 215. Then the maximum input power must be less than
Px <

2152 ¼ 230
10.2 Basic Wiener Filter Theory and Least Mean Square Algorithm
461

Hence, we may make a selection of the convergence parameter as
m ¼
1
N  230 z 9:3  10 10
N
(10.15)
We further neglect time index for wnðiÞ and use the notation wðiÞ ¼ wnðiÞ, since only the current
updated coefﬁcients are needed for next sample adaptation. We conclude the implementation of the
LMS algorithm with the following steps:
1. Initialize wð0Þ, wð1Þ, . wðN  1Þ to arbitrary values.
2. Read dðnÞ, xðnÞ, and perform digital ﬁltering:
yðnÞ ¼ wð0ÞxðnÞ þ wð1Þxðn  1Þ þ / þ wðN  1Þxðn  N þ 1Þ
3. Compute the output error:
eðnÞ ¼ dðnÞ  yðnÞ
4. Update each ﬁlter coefﬁcient using the LMS algorithm:
for i ¼ 0; /; N  1
wðiÞ ¼ wðiÞ þ 2meðnÞxðn  iÞ
We will apply the adaptive ﬁlter to solve real-world problems in the next section.
10.3 APPLICATIONS: NOISE CANCELLATION, SYSTEM MODELING, AND
LINE ENHANCEMENT
We now examine several applications of the LMS algorithm, such as noise cancellation, system
modeling, and line enhancement via application examples. First, we begin with the noise cancellation
problem to illustrate operations of the LMS adaptive FIR ﬁlter.
10.3.1 Noise Cancellation
The concept of noise cancellation was introduced in the previous section. Figure 10.7 shows the main
concept.
The DSP system consists of two ADC channels. The ﬁrst microphone with ADC captures the noisy
speech, dðnÞ ¼ sðnÞ þ nðnÞ, which contains the clean speech sðnÞ and noise nðnÞ due to a noisy
environment, while the second microphone with ADC resides where it picks up only the correlated
noise and feeds the noise reference xðnÞ to the adaptive ﬁlter. The adaptive ﬁlter uses the LMS
algorithm to adjust its coefﬁcients to produce the best estimate of noise yðnÞznðnÞ, which will be
subtracted from the corrupted signal dðnÞ ¼ sðnÞ þ nðnÞ. The output of the error signal
eðnÞ ¼ sðnÞ þ nðnÞ  yðnÞz~sðnÞ is expected to be the best estimate of the clean speech signal.
Through digital-to-analog conversion (DAC), the cleaned digital speech becomes analog voltage,
which drives the speaker.
462
CHAPTER 10 Adaptive Filters and Applications

We ﬁrst study the noise cancellation problem using a simple two-tap adaptive ﬁlter via Example
10.3 and assumed data. The purpose of doing so is to become familiar with the setup and operations of
the adaptive ﬁlter and LMS algorithm. The simulation for real adaptive noise cancellation follows.
EXAMPLE 10.3
Consider the DSP system for the noise cancellation application using an adaptive ﬁlter with two coefﬁcients shown
in Figure 10.8.
a. Set up the LMS algorithm for the adaptive ﬁlter.
b. Perform adaptive ﬁltering to obtain outputs eðnÞ for n
0; 1; 2 given the following inputs and outputs:
xð0Þ
1; xð1Þ
1; xð2Þ
1; dð0Þ
2; dð1Þ
1; dð2Þ
2
The initial weights are wð0Þ
wð1Þ
0, and the convergence factor is set to be m
0:1.
Solution:
a. The adaptive LMS algorithm is set up as:
Initialization: wð0Þ
0, wð1Þ
0
Digital ﬁltering: yðnÞ
wð0ÞxðnÞ þ wð1Þxðn
1Þ
e n
( )
y n
w
x n
w
x n
( )
( ) ( )
( ) (
)
0
1
1
x n
( )
d n
s n
n n
( )
( )
( )
y n
( )
Adaptive filter
Output
Noise
Signal and noise
FIGURE 10.8
Noise cancellation in Example 10.3.
y n
( )
d n
s n
n n
( )
( )
( )
x n
( )
e n
d n
y n
s n
( )
( )
( )
~( )
ADC
ADC
DAC
Adaptive filter
LMS algorithm
Noise
la
n
gis
r
o
rr
E
e
sio
n
d
n
a
la
n
gi
S
FIGURE 10.7
Simplest noise canceller using a one-tap adaptive ﬁlter.
10.3 Noise Cancellation, System Modeling, and Line Enhancement
463

Computing the output: eðnÞ
dðnÞ
yðnÞ
Updating each weight to be used for the next coming sample:
wðiÞ
wðiÞ þ 2meðnÞxðn
iÞ;
for
i
0; 1
or
wð0Þ
wð0Þ þ 2meðnÞxðnÞ
wð1Þ
wð1Þ þ 2meðnÞxðn
1Þ
b.
We can see the adaptive ﬁltering operations as follows:
For n
0
Digital ﬁltering:
yð0Þ
wð0Þxð0Þ þ wð1Þxð 1Þ
0  1 þ 0  0
0
Computing the output:
eð0Þ
dð0Þ
yð0Þ
2
0
2
Updating coefﬁcients:
wð0Þ
wð0Þ þ 2  0:1  eð0Þxð0Þ
0 þ 2  0:1  2  1
0:4
wð1Þ
wð1Þ þ 2  0:1  eð0Þxð 1Þ
0 þ 2  0:1  2  0
0:0
For n
1
Digital ﬁltering:
yð1Þ
wð0Þxð1Þ þ wð1Þxð0Þ
0:4  1 þ 0  1
0:4
Computing the output:
eð1Þ
dð1Þ
yð1Þ
1
0:4
0:6
Updating coefﬁcients:
wð0Þ
wð0Þ þ 2  0:1  eð1Þxð1Þ
0:4 þ 2  0:1  0:6  1
0:52
wð1Þ
wð1Þ þ 2  0:1  eð1Þxð0Þ
0 þ 2  0:1  0:6  1
0:12
For n
2
Digital ﬁltering:
yð2Þ
wð0Þxð2Þ þ wð1Þxð1Þ
0:52  ð
1Þ þ 0:12  1
0:4
Computing the output:
eð2Þ
dð2Þ
yð2Þ
2
ð
0:4Þ
1:6
Updating coefﬁcients:
wð0Þ
wð0Þ þ 2  0:1  eð2Þxð2Þ
0:52 þ 2  0:1  ð
1:6Þ  ð
1Þ
0:84
wð1Þ
wð1Þ þ 2  0:1  eð2Þxð1Þ
0:12 þ 2  0:1  ð
1:6Þ  1
0:2
Hence, the adaptive ﬁlter outputs for the ﬁrst three samples are listed as
eð0Þ
2; eð1Þ
0:6; eð2Þ
1:6
464
CHAPTER 10 Adaptive Filters and Applications

Next we examine the MSE function assuming the following statistical data for the two-tap adaptive
ﬁlter yðnÞ ¼ wð0ÞxðnÞ þ wð1Þxðn  1Þ :
s2 ¼ E

d2
n

¼ 4; E

x2
n

¼ E

x2
n  1

¼ 1; E½xðnÞxðn  1Þ ¼ 0
E½dðnÞxðnÞ ¼ 1; and E½dðnÞxðn  1Þ ¼ 1
We follow Equations (10.2) to (10.5) to achieve the minimum MSE function in two dimensions as
J ¼ 4 þ w2
0

þ w2
1

 2w

0

þ 2w

1

Figure 10.9 shows the MSE function versus the weights, where the optimal weights and the
minimum MSE are wð0Þ ¼ 1, wð1Þ ¼ 1, and Jmin ¼ 2. If the adaptive ﬁlter continues to
process the data, it will converge to the optimal weights, which locate the minimum MSE. The plot
also indicates that the function is quadratic and that there exists only one minimum of the MSE
surface.
FIGURE 10.9
Plot of the MSE function versus two weights.
10.3 Noise Cancellation, System Modeling, and Line Enhancement
465

Next, a simulation example is given to illustrate this idea and its results. The noise cancellation
system is assumed to have the following speciﬁcations:
• Sample rate ¼ 8,000 Hz
• Original speech data: wen.dat
• Speech corrupted by Gaussian noise with a power of 1 delayed by 5 samples from the noise
reference
• Noise reference containing Gaussian noise with a power of 1
• Adaptive FIR ﬁlter used to remove the noise
• Number of FIR ﬁlter taps ¼ 21
• Convergence factor for the LMS algorithm is chosen to be 0.01 (<1/21).
The speech waveforms and spectral plots for the original, corrupted, and reference noise and for the
cleaned speech are plotted in Figures 10.10A and Figure 10.10B. From the ﬁgures, it is observed that
the enhanced speech waveform and spectrum are very close to the original ones. The LMS algorithm
converges after approximately 400 iterations. The method is a very effective approach for noise
canceling. The MATLAB implementation is detailed in Program 10.1.
Program 10.1. MATLAB program for adaptive noise cancellation.
close all; clear all
load wen.dat
% Given by the instructor
fs 8000;
% Sampling rate
t 0:1:length(wen) 1;
% Create index array
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0
1
Or g. speech
0
200
400
600
800
1000
1200
1400
1600
1800
2000
5
0
5
Corrupt. speech
0
200
400
600
800
1000
1200
1400
1600
1800
2000
5
0
5
Ref. no se
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0
1
C ean speech
Number of samples
FIGURE 10.10A
Waveforms for original speech, corrupted speech, reference noise, and clean speech.
466
CHAPTER 10 Adaptive Filters and Applications

t t/fs;
% Convert indices to time instant
x randn(1,length(wen));
% Generate random noise
n filter([ 0 0 0 0 0 0.5 ],1,x);
% Generate the corruption noise
d wenþn;
% Generate signal plus noise
mu 0.01;
% Initialize step size
w zeros(1,21);
% Initialize adaptive filter coefficients
y zeros(1,length(t));
% Initialize the adaptive filter output array
e y;
% Initialize the output array
% Adaptive filtering using LMS algorithm
for m 22:1:length(t) 1
sum 0;
for i 1:1:21
sum sumþw(i)*x(m i);
end
y(m) sum;
e(m) d(m) y(m);
for i 1:1:21
w(i) w(i)þ2*mu*e(m)*x(m i);
end
end
% Calculate the single sided amplitude spectrum for the original signal
WEN 2*abs(fft(wen))/length(wen);WEN(1) WEN(1)/2;
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.05
0.1
Or g. spectrum
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.05
0.1
0.15
Corrupt. spectrum
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.05
0.1
0.15
C ean spectrum
Frequency (Hz)
FIGURE 10.10B
Spectrum for original speech, corrupted speech, and clean speech.
10.3 Noise Cancellation, System Modeling, and Line Enhancement
467

% Calculate the single sided amplitude spectrum for the corrupted signal
D 2*abs(fft(d))/length(d);D(1) D(1)/2;
f [0:1:length(wen)/2]*8000/length(wen);
% Calculate the single sided amplitude spectrum for the noise cancelled signal
E 2*abs(fft(e))/length(e);E(1) E(1)/2;
% Plot signals and spectrums
subplot(4,1,1), plot(wen);grid; ylabel(’Orig. speech’);
subplot(4,1,2),plot(d);grid; ylabel(’Corrupt. speech’)
subplot(4,1,3),plot(x);grid;ylabel(’Ref. noise’);
subplot(4,1,4),plot(e);grid; ylabel(’Clean speech’);
xlabel(’Number of samples’);
figure
subplot(3,1,1),plot(f,WEN(1:length(f)));grid
ylabel(’Orig. spectrum’)
subplot(3,1,2),plot(f,D(1:length(f)));grid; ylabel(’Corrupt. spectrum’)
subplot(3,1,3),plot(f,E(1:length(f)));grid
ylabel(’Clean spectrum’); xlabel(’Frequency (Hz)’);
Other interference cancellations include that of 60-Hz interference cancellation in electrocardi-
ography (ECG) (Chapter 8) and echo cancellation in long-distance telephone circuits, which will be
described in Section 10.4.
10.3.2 System Modeling
Another application of the adaptive ﬁlter is system modeling. The adaptive ﬁlter can keep tracking the
behaviorofanunknownsystembyusingtheunknownsysteminputandoutput,asdepictedinFigure10.11.
As shown in the ﬁgure, after the adaptive ﬁlter converges, the adaptive ﬁlter output yðnÞ will
approach to the unknown system’s output. Since both the unknown system and the adaptive ﬁlter
respond to the same input, the transfer function of the adaptive ﬁlter approximates the transfer function
of the unknown system.
EXAMPLE 10.4
Given the system modeling described in this section and using a single weight adaptive ﬁlter yðnÞ
wxðnÞ to
perform the system modeling task,
x n
( )
d n
( )
y n
( )
e n
( )
Unknown system
Adaptive
FIR filter
Input
Output
FIGURE 10.11
Adaptive ﬁlter for system modeling.
468
CHAPTER 10 Adaptive Filters and Applications

a. set up the LMS algorithm to implement the adaptive ﬁlter assuming that initially w
0 and m
0:5;
b. perform adaptive ﬁltering to obtain yð0Þ, yð1Þ, yð2Þ, and yð3Þ, given
dð0Þ
1; dð1Þ
2; dð2Þ
2; dð3Þ
2;
xð0Þ
0:5; xð1Þ
1; xð2Þ
1; xð3Þ
1
Solution:
a. Adaptive ﬁltering equations are set up as
w
0
and
2m
2  0:5
1
yðnÞ
wxðnÞ
eðnÞ
dðnÞ
yðnÞ
w
w þ eðnÞxðnÞ
b. Adaptive ﬁltering:
n
0;
yð0Þ
wxð0Þ
0  0:5
0
eð0Þ
dð0Þ
yð0Þ
1
0
1
w
w þ eð0Þxð0Þ
0 þ 1  0:5
0:5
n
1;
yð1Þ
wxð1Þ
0:5  1
0:5
eð1Þ
dð1Þ
yð1Þ
2
0:5
1:5
w
w þ eð1Þxð1Þ
0:5 þ 1:5  1
2:0
n
2;
yð2Þ
wxð2Þ
2  ð
1Þ
2
eð2Þ
dð2Þ
yð2Þ
2
ð
2Þ
0
w
w þ eð2Þxð2Þ
2 þ 0  ð
1Þ
2
n
3;
yð3Þ
wxð3Þ
2  1
2
eð3Þ
dð3Þ
yð3Þ
2
2
0
w
w þ eð3Þxð3Þ
2 þ 0  1
2
For this particular case, the system is actually a digital ampliﬁer with a gain of 2.
Next, we assume the unknown system is a fourth-order bandpass IIR ﬁlter whose 3-dB lower and
upper cutoff frequencies are 1,400 Hz and 1,600 Hz operating at 8,000 Hz. We use an input consisting
10.3 Noise Cancellation, System Modeling, and Line Enhancement
469

of tones of 500, 1,500, and 2,500 Hz. The unknown system’s frequency responses are shown in
Figure 10.12.
The input waveform xðnÞ with three tones is shown as the ﬁrst plot in Figure 10.13. We can
predict that the output of the unknown system will contain a 1,500 Hz tone only, since the other two
tones are rejected by the unknown system. Now, let us look at adaptive ﬁlter results. We use an FIR
adaptive ﬁlter with the number of taps being 21, and a convergence factor set to 0.01. In the time
domain, the output waveforms of the unknown system dðnÞ and adaptive ﬁlter output yðnÞ are almost
identical after 70 samples when the LMS algorithm converges. The error signal eðnÞ is also plotted
to show the adaptive ﬁlter keeps tracking the unknown system’s output with no difference after the
ﬁrst 50 samples.
Figure 10.14 depicts the frequency domain comparisons. The ﬁrst plot displays the frequency
components of the input signal, which clearly shows 500 Hz, 1,500 Hz, and 2,500 Hz. The second plot
shows the unknown system’s output spectrum, which contains only a 1,500 Hz tone, while the third
plot displays the spectrum of the adaptive ﬁlter output. As we can see, in the frequency domain, the
adaptive ﬁlter tracks the characteristics of the unknown system. The MATLAB implementation is
given in Program 10.2.
Program 10.2. MATLAB program for adaptive system identiﬁcation.
close all; clear all
%Design unknown system
fs 8000; T 1/fs;
% Sampling rate and sampling period
0
500
1000
1500
2000
2500
3000
3500
4000
200
100
0
100
200
Frequency (Hertz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
80
60
40
20
0
Frequency (Hertz)
Magnitude response (dB)
FIGURE 10.12
The unknown system’s frequency responses.
470
CHAPTER 10 Adaptive Filters and Applications

% Bandpass filter design
% for the assumed unknown system using the bilinear transformation
%(BLT) method (see Chapter 8)
wd1 1400*2*pi; wd2 1600*2*pi;
wa1 (2/T)*tan(wd1*T/2); wa2 (2/T)*tan(wd2*T/2);
BW wa2 wa1;
w0 sqrt(wa2*wa1);
[B,A] lp2bp([1],[1 1.4141 1],w0,BW);
[b,a] bilinear(B,A,fs);
freqz(b,a,512,fs); axis([0 fs/2
80 1]); % Frequency response plots
figure
t 0:T:0.1;
% Generate the time vector
x cos(2*pi*500*t)þsin(2*pi*1500*t)þcos(2*pi*2500*tþpi/4);
d filter(b,a,x);
% Produce unknown system output
mu 0.01;
% Convergence factor
w zeros(1,21); y zeros(1,length(t)); % Initialize the coefficients and output
e y;
% Initialize the error vector
% Perform adaptive filtering using LMS algorithm
for m 22:1:length(t) 1
sum 0;
for i 1:1:21
0
100
200
300
400
500
600
700
800
-2
0
2
System nput
0
100
200
300
400
500
600
700
800
-1
0
1
System output
0
100
200
300
400
500
600
700
800
-1
0
1
ADF output
0
100
200
300
400
500
600
700
800
-1
0
1
Error
Number of samples
FIGURE 10.13
The waveforms for the unknown system’s output, adaptive ﬁlter output, and error output.
10.3 Noise Cancellation, System Modeling, and Line Enhancement
471

sum sumþw(i)*x(m i);
end
y(m) sum;
e(m) d(m) y(m);
for i 1:1:21
w(i) w(i)þ2*mu*e(m)*x(m i);
end
end
% Calculate the single sided amplitude spectrum for the input
X 2*abs(fft(x))/length(x);X(1) X(1)/2;
% Calculate the single sided amplitude spectrum for the unknown system output
D 2*abs(fft(d))/length(d);D(1) D(1)/2;
% Calculate the single sided amplitude spectrum for the adaptive filter output
Y 2*abs(fft(y))/length(y);Y(1) Y(1)/2;
% Map the frequency index to its frequency in Hz
f [0:1:length(x)/2]*fs/length(x);
% Plot signals and spectra
subplot(4,1,1), plot(x);grid; axis([0 length(x)
3 3]);
ylabel(’System input’);
subplot(4,1,2), plot(d);grid; axis([0 length(x)
1.5 1.5]);
ylabel(’System output’);
subplot(4,1,3),plot(y);grid; axis([0 length(y)
1.5 1.5]);
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.5
1
Syst. nput spect.
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.5
1
Syst. output spect.
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.5
1
ADF output spect.
Frequency (Hz)
FIGURE 10.14
Spectrum for the input signal, unknown system output, and the adaptive ﬁlter output.
472
CHAPTER 10 Adaptive Filters and Applications

ylabel(’ADF output’)
subplot(4,1,4),plot(e);grid; axis([0 length(e)
1.5 1.5]);
ylabel(’Error’); xlabel(’Number of samples’)
figure
subplot(3,1,1),plot(f,X(1:length(f)));grid; ylabel(’Syst. input spect.’)
subplot(3,1,2),plot(f,D(1:length(f)));grid; ylabel(’Syst. output spect.’)
subplot(3,1,3),plot(f,Y(1:length(f)));grid
ylabel(’ADF output spect.’); xlabel(’Frequency (Hz)’);
10.3.3 Line Enhancement Using Linear Prediction
We study adaptive ﬁltering via another application example: line enhancement. If the signal frequency
content is very narrow compared with the bandwidth and changes with time, then the signal can
efﬁciently be enhanced by the adaptive ﬁlter, which is line enhancement. Figure 10.15 shows line
enhancement using the adaptive ﬁlter where the LMS algorithm is used. As illustrated in the ﬁgure,
the signal dðnÞ is the sine wave signal corrupted by the white Gaussian noise nðnÞ. The enhanced line
consists of the delay element to delay the corrupted signal by D samples to produce an input to
the adaptive ﬁlter. The adaptive ﬁlter is actually a linear predictor of the desired narrow band signal.
A two-tap FIR adaptive ﬁlter can predict one sinusoid (proof is beyond the scope of this text). The
value of D is usually determined by experiments or experience in practice to achieve the best enhanced
signal.
Our simulation example has the following speciﬁcations:
•
Sampling rate ¼ 8,000 Hz
•
Corrupted signal ¼ 500 Hz tone with white Gaussian noise added to the unit amplitude
•
Adaptive ﬁlter ¼ FIR type, 21 taps
•
Convergence factor ¼ 0.001
•
Delay value D ¼ 7
•
LMS algorithm is applied
Figure 10.16 shows the time domain results. The ﬁrst plot is the noisy signal, while the second plot
clearly demonstrates the enhanced signal. Figure 10.17 describes the frequency domain point of view.
The spectrum of the noisy signal is shown in the top plot, where we can see the white noise is populated
s
( )
cos(
/
)
( )
2
y n
( )
e n
( )
z
x n
( )
Adaptive
FIR filter
Enhanced
output
FIGURE 10.15
Line enhancement using an adaptive ﬁlter.
10.3 Noise Cancellation, System Modeling, and Line Enhancement
473

over the entire bandwidth. The bottom plot is the enhanced signal spectrum. Since the method is
adaptive, it is especially effective when the enhanced signal frequency is changing with time. Program
10.3 lists the MATLAB program for this simulation.
Program 10.3. MATLAB program for adaptive line enhancement.
close all; clear all
fs 8000; T 1/fs;
% Sampling rate and sampling period
t 0:T:0.1;
% 1 second time instant
n randn(1,length(t));
% Generate Gaussian random noise
d cos(2*pi*500*t)þn;
% Generate 500 Hz tone plus noise
x filter([ 0 0 0 0 0 0 0 1 ],1,d);
% Delay filter
mu 0.001;
% Initialize the step size for LMS algorithms
w zeros(1,21);
% Initialize the adaptive filter coefficients
y zeros(1,length(t));
% Initialize the adaptive filter output
e y;
% Initialize the error vector
% Perform adaptive filtering using the LMS algorithm
for m 22:1:length(t) 1
sum 0;
for i 1:1:21
sum sumþw(i)*x(m i);
0
100
200
300
400
500
600
700
800
-2
-1
0
1
2
No sy s gna
0
100
200
300
400
500
600
700
800
-2
-1
0
1
2
ADF output (enhanced s gna )
Number of samples
FIGURE 10.16
Noisy signal and enhanced signal.
474
CHAPTER 10 Adaptive Filters and Applications

end
y(m) sum;
e(m) d(m) y(m);
for i 1:1:21
w(i) w(i)þ2*mu*e(m)*x(m i);
end
end
% Calculate the single sided amplitude spectrum for corrupted signal
D 2*abs(fft(d))/length(d);D(1) D(1)/2;
% Calculate the single sided amplitude spectrum for enhanced signal
Y 2*abs(fft(y))/length(y);Y(1) Y(1)/2;
% Map the frequency index to its frequency in Hz
f [0:1:length(x)/2]*8000/length(x);
% Plot the signals and spectra
subplot(2,1,1), plot(d);grid; axis([0 length(x)
2.5 2.5]); ylabel(’Noisy signal’);
subplot(2,1,2),plot(y);grid; axis([0 length(y)
2.5 2.5]);
ylabel(’ADF output (enhanced signal)’); xlabel(’Number of samples’)
figure
subplot(2,1,1),plot(f,D(1:length(f)));grid; axis([0 fs/2 0 1.5]);
ylabel(’Noisy signal spectrum’)
subplot(2,1,2),plot(f,Y(1:length(f)));grid; axis([0 fs/2 0 1.5]);
ylabel(’ADF output spectrum’); xlabel(’Frequency (Hz)’);
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.5
1
1.5
No sy s gna  spectrum
0
500
1000
1500
2000
2500
3000
3500
4000
0
0.5
1
1.5
ADF output spectrum
Frequency (Hz)
FIGURE 10.17
Spectrum plots for the noisy signal and enhanced signal.
10.3 Noise Cancellation, System Modeling, and Line Enhancement
475

10.4 OTHER APPLICATION EXAMPLES
This section continues to explore other adaptive ﬁlter applications brieﬂy, without showing
computer simulations. The topics include periodic interference cancellation, ECG interference
cancellation, and echo cancellation in long-distance telephone circuits. Detailed information can
also be explored in Haykin (1991), Ifeachor and Jervis (2002), Stearns (2003), and Widrow and
Stearns (1985).
10.4.1 Canceling Periodic Interferences Using Linear Prediction
An audio signal may be corrupted by periodic interference with no noise reference available. Such
examples include the playback of speech or music with tape hum interference, turntable rumble, or
vehicle engine or power line interference. We can use the modiﬁed line enhancement structure as
shown in Figure 10.18.
The adaptive ﬁlter uses the delayed version of the corrupted signal xðnÞ to predict the periodic
interference. The number of delayed samples is selected through experiments that determine the
performance of the adaptive ﬁlter. Note that a two-tap FIR adaptive ﬁlter can predict one sinusoid, as
noted earlier. After convergence, the adaptive ﬁlter would predict the interference as
yðnÞ ¼
X
N
1
i ¼ 0
wðiÞxðn  iÞ z Acosð2pfn=fsÞ
(10.16)
Therefore, the error signal contains only the desired audio signal
eðnÞ z sðnÞ
(10.17)
10.4.2 Electrocardiography Interference Cancellation
As we discussed in Chapters 1 and 8, in recording of electrocardiograms (ECG), there often exists
unwanted 60-Hz interference, along with its harmonics, in the recorded data. This interference comes
s
( )
( )
cos(
/
)
2
y n
( )
e n
s n
( )
( )
z
x n
( )
Adaptive
FIR filter
Enhanced
audio
Audio and periodic interference
FIGURE 10.18
Canceling periodic interference using the adaptive ﬁlter.
476
CHAPTER 10 Adaptive Filters and Applications

from the power line, including effects from magnetic induction, displacement currents in leads or in
the body of the patient, and equipment interconnections and imperfections.
Figure 10.19 illustrates the application of adaptive noise canceling in ECG. The primary input
is taken from the ECG preampliﬁer, while a 60-Hz reference input is taken from a wall outlet
with proper attenuation. After proper signal conditioning, the digital interference xðnÞ is acquired
by the digital signal (DS) processor. The digital adaptive ﬁlter uses this reference input signal to
produce an estimate, which approximates the 60-Hz interference nðnÞ sensed from the ECG
ampliﬁer:
yðnÞ z nðnÞ
(10.18)
Here, an FIR adaptive ﬁlter with N taps and the LMS algorithm can be used for this application:
yðnÞ ¼ wð0ÞxðnÞ þ wð1Þxðn  1Þ þ / þ wðN  1Þxðn  N þ 1Þ
(10.19)
Then after convergence of the adaptive ﬁlter, the estimated interference is subtracted from the primary
signal of the ECG preampliﬁer to produce the output signal eðnÞ, in which the 60-Hz interference is
cancelled:
eðnÞ ¼ dðnÞ  yðnÞ ¼ sðnÞ þ nðnÞ  xðnÞ z sðnÞ
(10.20)
With enhanced ECG recording, doctors in clinics can give more accurate diagnoses for patients.
Canceling the maternal ECG in fetal monitoring is another important application. The block
diagram is shown in Figure 10.20(a). Fetal ECG plays an important role in monitoring the
condition of the baby before or during birth. However, the ECG acquired from the mother’s
abdomen is contaminated by noise such as muscle activity and fetal motion, as well as the
mother’s own ECG. In order to reduce the effect of the mother’s ECG, four (or more) chest leads
ECG recorder with
the removed 60 Hz
interference
ECG
preamplifier
and ADC
60 Hz
interference
To 60 Hz
wall outlet
Reference
input and
ADC
Adaptive
FIR filter
Primary signal
with the
inteference
x n
( )
d n
s n
n n
( )
( )
( )
y n
( )
FIGURE 10.19
Illustration of canceling 60-Hz interference in ECG.
10.4 Other Application Examples
477

(electrodes) are used to acquire the reference inputs: x0ðnÞ, x1ðnÞ, x2ðnÞ, and x3ðnÞ, with the
assumption that these channels only contain the mother’s ECG (see Figure 10.20(b)). One lead
(electrode) placed on the mother’s abdomen is used to capture the fetal information dðnÞ, which
may be corrupted by the mother’s ECG as shown in Figure 10.20(c). An adaptive ﬁlter uses its
references to predict the mother ECG, which will be subtracted from the corrupted fetus signal.
Then the fetal ECG with the reduced mother’s ECG is obtained, as depicted in Figure 10.20(d).
One possible LMS algorithm is listed below:
For k ¼ 0;1;2;3
ykðnÞ ¼ wkð0ÞxkðnÞ þ wkð1Þxkðn  1Þ þ / þ wkðN  1Þxkðn  N þ 1Þ
yðnÞ ¼ y0ðnÞ þ y1ðnÞ þ y2ðnÞ þ y3ðnÞ
sðnÞ ¼ eðnÞ ¼ dðnÞ  yðnÞ
For k ¼ 0;1;2;3
wkðn  iÞ ¼ wkðn  iÞ þ 2meðnÞxkðn  iÞ; for i ¼ 0; 1; /N  1
Adaptive
Algorithm
0( )
x n
1( )
x n
2( )
x n
3( )
x n
( )
y n
( )
d n
( )
( )
s n
e n
Mother
Fetus
Fetus
Chest leads
Abdominal
lead
Reduced
Mother's
ECG
Mother
Chest leads
Abdominal
lead
(a)
(b)
(c)
(d)
FIGURE 10.20
Canceling the maternal ECG in fetal monitoring.
478
CHAPTER 10 Adaptive Filters and Applications

10.4.3 Echo Cancellation in Long-Distance Telephone Circuits
Long-distance telephone transmission often suffers from impedance mismatches. This occurs
primarily at the hybrid circuit interface. Balancing electric networks within the hybrid can never
perfectly match the hybrid to the subscriber loop due to temperature variations, degradation of
transmission lines, and so on. As a result, a small portion of the received signal is leaked for trans-
mission. For example, in Figure 10.21A, if speaker B talks, the speech indicated as xBðnÞ will pass the
transmission line to reach user A, and a portion of xBðnÞ at site A is leaked and transmitted back to the
user B, forcing caller B to hear his or her own voice. This is known as an echo for speaker B. A similar
echo illustration can be conducted for speaker A. When the telephone call is made over a long distance
(more than 1,000 miles, such as geostationary satellites), the echo can be delayed by as much as
540 milliseconds. The echo impairment can be annoying to the customer and increases with distance.
To circumvent the problem of echo in long-distance communications, an adaptive ﬁlter is applied
at each end of the communication system, as shown in Figure 10.21B. Let us examine the adaptive
ﬁlter installed at the speaker A site. The incoming signal is xBðnÞ from speaker B, while the out-
going signal contains the speech from the speaker A and a portion of leakage from the hybrid circuit
Central
office
x
n
A( )
x
n
B( )
Central
office
Repeaters
Local 2 wire
customer loop
Local 2 wire
customer loop
4 wire trunck
FIGURE 10.21A
Simpliﬁed long-distance circuit.
Hybrid
Hybrid
F
D
A
F
D
A
Channel
Channel
y
n
A( )
d
n
x
n
x
n
A
A
B
( )
( )
( )
e
n
x
n
A
A
( )
( )
x
n
A( )
x
n
B( )
d
n
x
n
x
n
B
A
B
( )
( )
( )
e
n
x
n
B
B
( )
( )
y
n
B( )
Echo of speaker B
Echo of speaker A
x
n
B( )
x
n
A( )
Local 2 wire
customer loop
Local 2 wire
customer loop
4 wire trunck
Receiving site
Transmitting site
Receiving site
Transmitting site
FIGURE 10.21B
Adaptive echo cancellers.
10.4 Other Application Examples
479

dAðnÞ ¼ xAðnÞ þ xBðnÞ. If the leakage xBðnÞ returns back to speaker B, it becomes an annoying echo.
To prevent the echo, the adaptive ﬁlter at the speaker A site uses the incoming signal from speaker B as
an input and makes its output approximate to the leaked speaker B signal by adjusting its ﬁlter
coefﬁcients; that is,
yAðnÞ ¼
X
N
1
i ¼ 0
wðiÞxBðn  iÞ z xBðnÞ
(10.21)
As shown in Figure 10.21B, the estimated echo yAðnÞzxBðnÞ is subtracted from the outgoing signal,
thus producing the signal that contains only speech A; that is, eAðnÞzxAðnÞ. As a result, the echo of
speaker B is removed. We can illustrate similar operations for the adaptive ﬁlter used at the speaker B
site. In practice, an FIR adaptive ﬁlter with several hundred coefﬁcients or more is commonly used to
effectively cancel the echo. If nonlinearities are concerned in the echo path, a corresponding nonlinear
adaptive canceller can be used to improve the performance of the echo cancellation.
Other forms of adaptive ﬁlters and other applications are beyond the scope of this book. The reader
is referred to the references for further development.
10.5 LABORATORY EXAMPLES USING THE TMS320C6713 DSK
The implementation for system modeling in Section 10.4.3 is shown in Figure 10.22, where the input is
fed from a function generator. The unknown system is a bandpass ﬁlter with a lower cutoff frequency
of 1,400 Hz and upper cutoff frequency of 1,600 Hz. As shown in Figure 10.22, the left input channel
(Left Line In [LCI]) is used for the input while the left output channel (Left Line Out [LCO]) and the
right output channel (Right Line Out [RCO]) are designated as the system output and error output,
x n
( )
d n
( )
y n
( )
e n
( )
Unknown system
Adaptive
FIR filter
Input
Output
TI TMS320C6713
DSP Board
Left Line In
(LCI)
Right Line In
(RCI)
Left Line Out
(LCO)
Right Line Out
(RCO)
Signal
Generator
Oscilloscope
( )
x n
( )
y n
( )
e n
FIGURE 10.22
Setup for system modeling using the LMS adaptive ﬁlter.
480
CHAPTER 10 Adaptive Filters and Applications

respectively. Note that the right input channel (Right Line In [RCI]) is not used. When the input
frequency is swept from 200 Hz to 3,000 Hz, the output shows a maximum peak when the input
frequency is dialed to around 1,500 Hz. Hence, the adaptive ﬁlter acts like the unknown system.
Program 10.4 gives the sample program segment.
Program 10.4. Program segment for system modeling.
/*Numerator coefficients */
/*for the bandpass filter (unknown system) with fL 1.4 kHz, fH 1.6 kHz*/
float b[5] { 0.005542761540433, 0.000000000000002,
0.011085523080870,
0.000000000000003 0.005542761540431};
/*Denominator coefficients */
/*for the bandpass filter (unknown system) with fL 1.4 kHz, fH 1.6 kHz*/
float a[5] { 1.000000000000000,
1.450496619180500. 2.306093105231476,
1.297577189144526 0.800817049322883};
float x[40] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; /*Reference input buffer*/
float w[40] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; /*Adaptive filter coefficients*/
float d[1] {0.0}; /*Unknown system output */
float y[1] {0,0}; /*Adaptive filter output */
float e[1] {0.0}; /*Error signal */
float mu 0.000000000002; /*Adaptive filter convergence factor*/
interrupt void c int11()
{
float lc; /*left channel input */
float rc; /*right channel input */
float lcnew; /*left channel output */
float rcnew; /*right channel output */
int i;
//Left channel and right channel inputs
AIC23 data.combo input sample();
lc (float) (AIC23 data.channel[LEFT]);
rc
(float) (AIC23 data.channel[RIGHT]);
// Insert DSP algorithm below
for(i 39;i>0;i
) /*Update the input buffer*/
{ x[i] x[i 1]; }
x[0] lc;
d[0] b[0]*x[0]þ b[1]*x[1]þ b[2]*x[2]þ b[3]*x[3]þ b[4]*x[4]
a[1]*d[1] a[2]*d[2]
a[3]*d[3]
a[4]*d[4]; /*Unknown system output*/
// Adaptive filter
y[0] 0;
for(i 0;i<40; iþþ)
{ y[0] y[0]þw[i]*x[i];}
e[0] d[0] y[0]; /* Error output */
for(i 0;i<40; iþþ)
{ w[i] w[i]þ2*mu*e[0]*x[i];} /* LMS algorithm */
// End of the DSP algorithm
lcnew y[0]; /* Send the tracked output */
10.5 Laboratory Examples Using the TMS320C6713 DSK
481

rcnew e[0]; /* Send the error signal*/
AIC23 data.channel[LEFT] (short) lcnew;
AIC23 data.channel[RIGHT] (short) rcnew;
output sample(AIC23 data.combo);
}
With the advantage of the stereo input and output channels, we can conduct system modeling for an
unknown analog system illustrated in Figure 10.23, where RCI is used to feed the unknown analog
system output to the DSK. The program segment is listed in Program 10.5.
Program 10.5. Program segment for modeling an analog system.
float x[40] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; /*Reference input buffer*/
float w[40] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; /*Adaptive filter coefficients*/
float d[1] {0.0}; /*Unknown system output */
float y[1] {0,0}; /*Adaptive filter output */
float e[1] {0.0}; /*Error signal */
float mu 0.000000000002; /*Adaptive filter convergence factor*/
interrupt void c int11()
{
float lc; /*left channel input */
float rc; /*right channel input */
float lcnew; /*left channel output */
float rcnew; /*right channel output */
int i;
//Left channel and right channel inputs
AIC23 data.combo input sample();
lc (float) (AIC23 data.channel[LEFT]);
rc
(float) (AIC23 data.channel[RIGHT]);
// Insert DSP algorithm below
for(i 39;i>0;i
) /*Update the input buffer*/
{ x[i] x[i 1]; }
TI TMS320C6713
DSP Board
Left Line In
(LCI)
Right Line In
(RCI)
Left Line Out
(LCO)
Right Line Out
(RCO)
Signal
Generator
Oscilloscope
( )
x n
( )
y n
( )
e n
Unknown
Analog system
( )
d n
( )
d t
FIGURE 10.23
System modeling using an LMS adaptive ﬁlter.
482
CHAPTER 10 Adaptive Filters and Applications

x[0] lc;
d[0] rc; /*Unknown system output*/
// Adaptive filter
y[0] 0;
for(i 0;i<40; iþþ)
{ y[0] y[0]þw[i]*x[i];}
e[0] d[0] y[0]; /* Error output */
for(i 0;i<40; iþþ)
{ w[i] w[i]þ2*mu*e[0]*x[i];} /* LMS algorithm */
// End of the DSP algorithm
lcnew y[0]; /* Send the tracked output */
rcnew e[0]; /* Send the error signal*/
AIC23 data.channel[LEFT] (short) lcnew;
AIC23 data.channel[RIGHT] (short) rcnew;
output sample(AIC23 data.combo);
}
Figure 10.24A shows an example of a tonal noise reduction system, and Figure 10.24B shows the
details of the adaptive noise cancellation. The ﬁrst DSP board is used to create the real-time corrupted
signal, which is obtained by mixing the mono audio source (Left Line In [LCI1]) from any audio
device and the tonal noise (Right Line In [RCI1]) generated from a function generator. The output
(Left line Out [LCO1]) is the corrupted signal, which is fed to the second DSP board for noise
cancellation application. The adaptive FIR ﬁlter in the second DSP board uses the reference input
(Right Line In [RCI2]) to generate the output, which is used to cancel the tonal noise embedded in the
corrupted signal (Left Line In [LCI2]). The output (Left Line Out [LCO2]) produces the clean mono
audio signal (Jiang and Tan, 2012). Program 10.6 details the implementation.
Program 10.6. Program segments for noise cancellation.
(a) Program segment for DSK 1 (generation of the corrupted signal).
float x[1] {0.0}; /* Tonal reference noise */
Float s[1] {0,0}; /* Audio signal */
float d[1] {0.0}; /* Corrupted signal*/
y n
( )
d n
s n
n n
( )
( )
( )
x n
( )
e n
d n
y n
s n
( )
( )
( )
~( )
ADC
ADC
DAC
Adaptive filter
LMS algorithm
Noise
la
n
gis
r
o
rr
E
e
sio
n
d
n
a
la
n
gi
S
FIGURE 10.24A
Block diagram for tonal noise cancellation.
10.5 Laboratory Examples Using the TMS320C6713 DSK
483

interrupt void c int11()
{
float lc; /*left channel input */
float rc; /*right channel input */
float lcnew; /*left channel output */
float rcnew; /*right channel output */
int i;
//Left channel and right channel inputs
AIC23 data.combo input sample();
lc (float) (AIC23 data.channel[LEFT]);
rc
(float) (AIC23 data.channel[RIGHT]);
// Insert DSP algorithm below
s[0] lc;
x[0] rc;
D[0] s[0]þx[0];
// End of the DSP algorithm
lcnew d[0]; /* Send to DAC */
rcnew rc; /* keep the original data */
AIC23 data.channel[LEFT] (short) lcnew;
AIC23 data.channel[RIGHT] (short) rcnew;
output sample(AIC23 data.combo);
}
(b) Program segment for DSK 2 (LMS adaptive ﬁlter).
float x[20] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; /*Reference input buffer*/
float w[20] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; /*Adaptive filter
coefficients*/
float d[1] {0.0}; /* Corrupted signal*/
float y[1] {0,0}; /* Adaptive filter output */
TI TMS320C6713
DSP Board 2
Left Line In
LCI2
Right Line In
RCI2
Left Line Out
Right Line Out
Mono Audio
Source
TI TMS320C6713
DSP Board 1
Left Line In
LCI1
Right Line In
RCI1
Left Line Out
LCO1
Right Line Out
RCO1
Tonal
Reference
Noise
Corrupted
Audio
Mixing audio
and tonal noise
FIR adaptive filtering
Enhanced
Audio
( )
s n
( )
x n
( )
d n
( )
x n
( )
( )
s n
e n
( )
d n
FIGURE 10.24B
Tonal noise cancellation with the adaptive ﬁlter.
484
CHAPTER 10 Adaptive Filters and Applications

float e[1] {0.0}; /* Enhanced signal */
float mu 0.000000000004; /*Adaptive filter convergence factor*/
interrupt void c int11()
{
float lc; /*left channel input */
float rc; /*right channel input */
float lcnew; /*left channel output */
float rcnew; /*right channel output */
int i;
//Left channel and right channel inputs
AIC23 data.combo input sample();
lc (float) (AIC23 data.channel[LEFT]);
rc
(float) (AIC23 data.channel[RIGHT]);
// Insert DSP algorithm below
d[0] lc; /*Corrupted signal*/
for(i 19;i>0;i
) /*Update the reference noise buffer input buffer*/
{ x[i] xn[i 1]; }
x[0] lc;
// Adaptive filter
y[0] 0;
for(i 0;i<20; iþþ)
{ y[0] y[0]þw[i]*x[i];}
e[0] d[0] y[0]; /* Enhanced output */
for(i 0;i<20; iþþ)
{ w[i] w[i]þ2*mu*e[0]*x[i]; }/* LMS algorithm */
// End of the DSP algorithm
lcnew e[0]; /* Send to DAC */
rcnew rc; /* keep the original data */
AIC23 data.channel[LEFT] (short) lcnew;
AIC23 data.channel[RIGHT] (short) rcnew;
output sample(AIC23 data.combo);
}
Many other practical conﬁgurations can be implemented similarly.
10.6 SUMMARY
1. Adaptive ﬁlters can be applied to signal-changing environments, spectral overlap between noise
and signal, and unknown, or time-varying, noise.
2. Wiener ﬁlter theory provides optimal weight solutions based on statistics. It involves collection of
a large block of data, calculation of an autocorrelation matrix and a cross-correlation matrix, and
inversion of a large autocorrelation matrix.
3. The steepest decent algorithm can ﬁnd the optimal weight solution using an iterative method, so
a large matrix inversion is not needed. But it still requires calculating an autocorrelation matrix
and cross-correlation matrix.
4. The LMS is a sample-based algorithm, which does not need collection of data or computation of
statistics and does not involve matrix inversion.
10.6 Summary
485

5. The convergence factor for the LMS algorithm is bounded by the reciprocal of the product of the
number of ﬁlter coefﬁcients and input signal power.
6. The LMS adaptive FIR ﬁlter can be effectively applied for noise cancellation, system modeling,
and line enhancement.
7. Further exploration includes other applications such as cancellation of periodic interference,
biomedical ECG signal enhancement, and adaptive telephone echo cancellation.
10.7 PROBLEMS
10.1. Given a quadratic MSE function for the Wiener ﬁlter
J ¼ 50  40w þ 10w2
ﬁnd the optimal solution for w to achieve the minimum MSE Jmin and determine Jmin.
10.2. Given a quadratic MSE function for the Wiener ﬁlter
J ¼ 15 þ 20w þ 10w2
ﬁnd the optimal solution for w to achieve the minimum MSE Jmin and determine Jmin.
10.3. Given a quadratic MSE function for the Wiener ﬁlter
J ¼ 100 þ 20w þ 2w2
ﬁnd the optimal solution for w to achieve the minimum MSE Jmin and determine Jmin.
10.4. Given a quadratic MSE function for the Wiener ﬁlter
J ¼ 10  30w þ 15w2
ﬁnd the optimal solution for w to achieve the minimum MSE Jmin and determine Jmin.
10.5. Given a quadratic MSE function for the Wiener ﬁlter
J ¼ 50  40w þ 10w2
use the steepest descent method with an initial guess of w0 ¼ 0 and a convergence factor
m ¼ 0:04 to ﬁnd the optimal solution for w and determine Jmin by iterating three times.
10.6. Given a quadratic MSE function for the Wiener ﬁlter
J ¼ 15 þ 20w þ 10w2
use the steepest descent method with an initial guess of w0 ¼ 0 and a convergence factor
m ¼ 0:04 to ﬁnd the optimal solution for w and determine Jmin by iterating three times.
10.7. Given a quadratic MSE function for the Wiener ﬁlter
J ¼ 100 þ 20w þ 2w2
use the steepest descent method with an initial guess of w0 ¼ 4 and a convergence factor
m ¼ 0:2 to ﬁnd the optimal solution for w and determine Jmin by iterating three times.
486
CHAPTER 10 Adaptive Filters and Applications

10.8. Given a quadratic MSE function for the Wiener ﬁlter
J ¼ 10  30w þ 15w2
use the steepest descent method with an initial guess of w0 ¼ 2 and a convergence factor
m ¼ 0:02 to ﬁnd the optimal solution for w and determine Jmin by iterating three times.
10.9. Consider the following DSP system used for noise cancellation applications (Figure 10.25),
in which dð0Þ ¼ 3, dð1Þ ¼ 2, dð2Þ ¼ 1, xð0Þ ¼ 3, xð1Þ ¼ 1, xð2Þ ¼ 2, and there is
an adaptive ﬁlter with two taps yðnÞ ¼ wð0ÞxðnÞ þ wð1Þxðn  1Þ with initial values
wð0Þ ¼ 0, wð1Þ ¼ 1, and m ¼ 0:1,
a. Determine the LMS algorithm equations
yðnÞ ¼
eðnÞ ¼
wð0Þ ¼
wð1Þ ¼
b. Perform adaptive ﬁltering for each n ¼ 0; 1; 2.
10.10. Given a DSP system with a sampling rate of 8,000 samples per second, implement an
adaptive ﬁlter with ﬁve taps for system modeling.
As shown in Figure 10.26, assume the unknown system transfer function is
HðzÞ ¼ 0:25 þ 0:25z 1
1  0:5z 1
Determine the DSP equations
yðnÞ ¼
eðnÞ ¼
wðiÞ ¼
x n
( )
d n
( )
y n
( )
e n
( )
Adaptive
FIR filter
Input
Output
FIGURE 10.25
Noise cancellation in Problem 10.9.
10.6 Summary
487

using the LMS algorithm for i ¼ 0; 1; 2; 3; 4; that is, write the equations for all adaptive
coefﬁcients:
wð0Þ ¼
wð1Þ ¼
wð2Þ ¼
wð3Þ ¼
wð4Þ ¼
10.11. Consider the adaptive ﬁlter used for the noise cancellation application in Problem 10.9, in
which dð0Þ ¼ 3, dð1Þ ¼ 2, dð2Þ ¼ 1, xð0Þ ¼ 3, xð1Þ ¼ 1, xð2Þ ¼ 2, and an adap-
tive ﬁlter with three taps yðnÞ ¼ wð0ÞxðnÞ þ wð1Þxðn  1Þ þ wð2Þxðn  2Þ with initial
values wð0Þ ¼ 0, wð1Þ ¼ 0, wð2Þ ¼ 0 and m ¼ 0:2.
a. Determine the LMS algorithm equations
yðnÞ ¼
eðnÞ ¼
wð0Þ ¼
wð1Þ ¼
wð2Þ ¼
b. Perform adaptive ﬁltering for each of n ¼ 0; 1; 2.
10.12. Consider the DSP system with a sampling rate of 8,000 samples per second in Problem
10.10. Implement an adaptive ﬁlter with ﬁve taps for system modeling, assuming the
unknown system transfer function is
H

z

¼ 0:2 þ 0:3z 1 þ 0:2z 2
Determine the DSP equations
yðnÞ ¼
eðnÞ ¼
wðiÞ ¼
x n
( )
H z
z
z
( )
.
02.
.
5 025
1 05
1
1
d n
( )
y n
( )
e n
( )
Input
Output
Adaptive
FIR filter
Unknown system
FIGURE 10.26
System modeling in Problem 10.10.
488
CHAPTER 10 Adaptive Filters and Applications

using the LMS algorithm for i ¼ 0; 1; 2; 3; 4; that is, write the equations for all adaptive
coefﬁcients:
wð0Þ ¼
wð1Þ ¼
wð2Þ ¼
wð3Þ ¼
wð4Þ ¼
10.13. Consider the DSP system set up for noise cancellation applications with a sampling rate of
8,000 Hz shown in Figure 10.27. The desired 1,000 Hz tone is generated internally via
a tone generator, and the generated tone is corrupted by the noise captured from a micro-
phone. An FIR adaptive ﬁlter with 25 taps is applied to reduce the noise in the corrupted
tone.
a. Determine the DSP equation for the channel noise nðnÞ.
b. Determine the DSP equation for signal tone yyðnÞ.
c. Determine the DSP equation for the corrupted tone dðnÞ.
d. Set up the LMS algorithm for the adaptive FIR ﬁlter.
10.14. Consider the DSP system for noise cancellation applications with two taps in Figure 10.28.
a. Set up the LMS algorithm for the adaptive ﬁlter.
x n
( )
xx n
n
( )
( )
5000
d n
( )
05.
yy n
( )
n n
( )
Noise channel
Gain
Delay for 5 samples
Sine wave generator
1000 Hz
Noise from line in
e n
( )
Adaptive
filter
y n
( )
Clean
signal
FIGURE 10.27
Noise cancellation in Problem 10.13.
e n
( )
( )
(0) ( )
(1) (
1)
y n
w
x n
w
x n
x n
( )
( )
d n
y n
( )
Adaptive filter
Output
Noise
Signal and noise
FIGURE 10.28
Noise cancellation in Problem 10.14.
10.6 Summary
489

b. Assume the inputs and outputs xð0Þ ¼ 1, xð1Þ ¼ 1, xð2Þ ¼ 1, xð3Þ ¼ 2, dð0Þ ¼ 0,
dð1Þ ¼ 2, dð2Þ ¼ 1, and dð3Þ ¼ 1; initial weights wð0Þ ¼ wð1Þ ¼ 0; and
convergence factor m ¼ 0:1. Perform adaptive ﬁltering to obtain outputs eðnÞ for
n ¼ 0; 1; 2.
10.15. Again consider the DSP system for noise cancellation applications with three taps in
Figure 10.28.
a. Set up the LMS algorithm for the adaptive ﬁlter.
b. Assume the inputs and outputs xð0Þ ¼ 1, xð1Þ ¼ 1, xð2Þ ¼ 1, xð3Þ ¼ 2, dð0Þ ¼ 0,
dð1Þ ¼ 2, dð2Þ ¼ 1, and dð3Þ ¼ 1; initial weights wð0Þ ¼ wð1Þ ¼ wð2Þ ¼ 0, and
convergence factor m ¼ 0:1. Perform adaptive ﬁltering to obtain outputs eðnÞ for
n ¼ 0; 1; 2.
10.16. For a line enhancement application using the FIR adaptive ﬁlter depicted in Figure 10.29.
a. Set up the LMS algorithm for the adaptive ﬁlter using two ﬁlter coefﬁcients and delay
D ¼ 2.
b. Assume the inputs and outputs dð0Þ ¼ 1, dð1Þ ¼ 1, dð2Þ ¼ 1, dð3Þ ¼ 1,
dð4Þ ¼ 1, dð5Þ ¼ 1 and dð6Þ ¼ 1; initial weights wð0Þ ¼ wð1Þ ¼ 0; and
convergence factor m ¼ 0:1. Perform adaptive ﬁltering to obtain outputs yðnÞ for
n ¼ 0; 1; 2; 3; 4.
10.17. Repeat Problem 10.16 using a three-tap FIR ﬁlter and D ¼ 3.
10.18. An audio playback application is described in Figure 10.30.
Due to the interference environment, the audio is corrupted by 15 different periodic interfer-
ences. The DSP engineer uses an FIR adaptive ﬁlter to remove such interferences as shown in
Figure 10.30.
a. What is the minimum number of ﬁlter coefﬁcients?
b. Set up the LMS algorithm for the adaptive ﬁlter using the number of taps obtained in (a).
10.19. Repeat Problem 10.18 for corrupted audio that contains ﬁve different periodic
interferences.
( )
d n
y n
( )
e n
( )
z
x n
( )
Adaptive
FIR filter
Enhanced
output
FIGURE 10.29
Line enhancement in Problem 10.16.
490
CHAPTER 10 Adaptive Filters and Applications

10.20. In a noisy ECG acquisition environment, the DSP engineer uses an adaptive FIR ﬁlter with
20 coefﬁcients to remove 60-Hz interference. The system is set up as shown in Figure 10.19,
where the corrupted ECG and enhanced ECG are represented as dðnÞ and eðnÞ, respectively;
xðnÞ is the captured reference signal from the 60-Hz interference; and yðnÞ is the adaptive
ﬁlter output. Determine all difference equations to implement the adaptive ﬁlter.
10.21. Given an application of the echo cancellation shown in Figure 10.21B, determine all
difference equations to implement the adaptive ﬁlter with four adaptive coefﬁcients at the
speaker A site.
10.22. Given an application of the echo cancellation shown in Figure 10.21B,
a. explain the concepts and beneﬁts using the echo canceller;
b. explain the operations of the adaptive ﬁlter at the speaker B site;
c. determine all difference equations to implement the adaptive ﬁlter at the speaker A site.
10.7.1 Computer Problems with MATLAB
Use MATLAB to solve Problems 10.23 to 10.26.
10.23. Write a MATLAB program for minimizing the two-weight MSE (mean squared error)
function
J ¼ 100 þ 100w2
1 þ 4w2
2  100w1  8w2 þ 10w1w2
z
Adaptive
FIR filter
 
Enhanced
audio
Audio and periodic interferences
( )
d n
( )
y n
( )
e n
 
FIGURE 10.30
Interference cancellation in Problem 10.18.
2
y n
( )
e n
( )
z
x n
( )
Adaptive
FIR filter
Enhanced
output
d n
A
fn
f
n n
s
( )
cos(
/
)
( )
FIGURE 10.31
A line enhancement system in Problem 10.26
10.6 Summary
491

by applying the steepest descent algorithm for 500 iterations. The derivatives are
dJ
dw1
¼ 200w1  100 þ 10w2
and
dJ
dw2
¼ 8w2  8 þ 10w1
and the initial weights are assumed as w1ð0Þ ¼ 0, w2ð0Þ ¼ 0, m ¼ 0:001. Plot w1ðkÞ, w2ðkÞ,
and JðkÞ versus the number of iterations, respectively. Summarize your results.
10.24. In Problem 10.10, the unknown system is assumed to be a fourth-order Butterworth
bandpass ﬁlter with a lower cutoff frequency of 700 Hz and an upper cutoff frequency of
900 Hz. Design a bandpass ﬁlter by the bilinear transformation method for simulating the
unknown system with a sampling rate of 8,000 Hz.
a. Generate the input signal for 0.1 second using a sum of three sinusoids with 100 Hz, 800
Hz, and 1,500 Hz and a sampling rate of 8,000 Hz.
b. Use the generated input as the unknown system input to produce the system output.
The adaptive FIR ﬁlter is then applied to model the designed bandpass ﬁlter. The following
parameters are assumed:
Adaptive FIR ﬁlter
Number of taps: 15 coefﬁcients
Algorithm: LMS algorithm
Convergence factor: 0.01
c. Implement the adaptive FIR ﬁlter, and plot the system input, system output, adaptive
ﬁlter output, and error signal, respectively.
d. Plot the input spectrum, system output spectrum, and adaptive ﬁlter output spectrum,
respectively.
10.25. Use the following MATLAB code to generate reference noise and a signal of 300 Hz
corrupted by the noise with a sampling rate of 8,000 Hz.
fs 8000; T 1/fs;
% Sampling rate and sampling period
t 0:T:1;
% Create time instants
x randn(1,length(t));
% Generate reference noise
n filter([ 0 0 0 0 0 0 0 0 0 0.8 ],1,x); % Generate the corruption noise
d sin(2*pi*300*t)+n;
% Generate the corrupted signal
a. Implement an adaptive FIR ﬁlter to remove the noise. The adaptive ﬁlter speciﬁcations
are as follows:
Sample rate ¼ 8,000 Hz
Signal corrupted by Gaussian noise delayed by nine samples from the reference noise
Reference noise: Gaussian noise with a power of 1
Number of FIR ﬁlter taps: 16
Convergence factor for the LMS algorithm: 0.01
492
CHAPTER 10 Adaptive Filters and Applications

b. Plot the corrupted signal, reference noise, and enhanced signal, respectively.
c. Compare the spectral plots between the corrupted signal and the enhanced signal.
10.26. A line enhancement system (Figure 10.31) has following speciﬁcations:
Sampling rate ¼ 1,000 Hz
Corrupted signal: 100 Hz tone with the unit amplitude added with the unit power Gaussian
noise
Adaptive ﬁlter: FIR type, 16 taps
Convergence factor: 0.001
Delay value D: to be decided according to the experiment
LMS algorithm
a. Write a MATLAB program to perform the line enhancement for a one-second corrupted
signal. Run the developed program with a trail of delay value D and plot the noisy signal,
the enhanced signals, and their spectra.
b. Run your simulation to ﬁnd the delay value D that achieves the largest noise reduction.
10.7.2 MATLAB Projects
10.27. Active noise control:
The ANC (active noise control) system is based on the principle of superposition of the primary
noise source and secondary source with its acoustic output being the same amplitude but the
opposite phase of the primary noise source, as shown in Figure 10.32. The primary noise is
captured using the reference microphone, which is located close to the noise source. The ANC
system uses the sensed reference signal xðnÞ to generate a canceling signal yðnÞ, which drives
the secondary speaker to destructively attenuate the primary noise. An error microphone is
used to detect the residue noise eðnÞ, which is fed back to the ANC system to monitor the
system performance. The residue noise eðnÞ together with the reference signal xðnÞ are used
by the linear adaptive controller whose coefﬁcients are adjusted via an adaptive algorithm to
minimize the measured error signal eðnÞ, or the residue acoustic noise. PðzÞ designates the
physical primary path between the reference sensor and the error sensor, and SðzÞ designates
the physical secondary path between the ANC adaptive ﬁlter output and the error sensor. To
control the noise at the cancelling point, the instantaneous power e2ðnÞ must be minimized.
Note that
EðzÞ ¼ DðzÞ  YðzÞSðzÞ ¼ DðzÞ  ½WðzÞXðzÞSðzÞ
where WðzÞ denotes the adaptive control ﬁlter. Exchange of the ﬁlter order (since the ﬁlters are
linear ﬁlters) gives
EðzÞ ¼ DðzÞ  WðzÞ½SðzÞXðzÞ ¼ DðzÞ  YðzÞ
Assuming that SðzÞ is the secondary path estimate and noticing that UðzÞ ¼ SðzÞXðzÞ and
YðzÞ ¼ WðzÞXðzÞ are the ﬁltered reference signal and adaptive ﬁlter output, applying the
LMS algorithm gives the ﬁltered-x LMS algorithm
wðiÞ ¼ wðiÞ þ 2meðnÞuðn  iÞ
10.6 Summary
493

Note that eðnÞ is measured from the error microphone.
The completed ﬁltered-x LMS algorithm is summarized below:
1. Initialize wð0Þ, wð1Þ, . wðN  1Þ to arbitrary values.
2. Read xðnÞ and perform digital ﬁltering:
yðnÞ ¼ wð0ÞxðnÞ þ wð1Þxðn  1Þ þ / þ wðN  1Þxðn  N þ 1Þ
3. Compute the ﬁltered inputs:
uðnÞ ¼ sð0ÞxðnÞ þ sð1Þxðn  1Þ þ / þ sðM  1Þxðn  M þ 1Þ
4. Read eðnÞ and update each ﬁlter coefﬁcient:
for i ¼ 0; /; N  1; wðiÞ ¼ wðiÞ þ 2meðnÞuðn  iÞ;
Assuming the following:
Sampling rate ¼ 8,000 Hz and simulation duration ¼ 10 seconds
Primary noise: xðnÞ ¼ 500-Hz sine wave
Primary path: PðzÞ ¼ 0:2 þ 0:25z 1 þ 0:2z 2
Secondary path: SðzÞ ¼ 0:25 þ 0:2z 1
Secondary path estimate: SðzÞ ¼ SðzÞ ¼ 0:2 þ 0:2z 1 (can have slight error as compared
to SðzÞ)
( )
x n
( )
y n
( )
e n
ANC
Reference 
e
n
o
h
p
o
r
ci
m
e
n
o
h
p
o
r
ci
m
Secondary
speaker
Error
Primary noise
Noise source
(a) 
(b) 
 Physical model 
 Adaptive
Algorithm
-
( )
( )
y n
( )
( )
x n
( )
d n
( )
( )
e n
( )
x n
( )
u n
( )
P z
S z
S z
W z
 Simulation model 
FIGURE 10.32
An active noise control system.
494
CHAPTER 10 Adaptive Filters and Applications

Residue error signal: eðnÞ ¼ dðnÞ  filtering yðnÞ using coefficients sðnÞ ¼ dðnÞ  yðnÞ
sðnÞ, where the symbol “*” denotes the ﬁlter convolution.
Implement the ANC system and plot the residue sensor signal to verify the effectiveness. The
primary noise at cancelling point dðnÞ, and ﬁltered reference signal uðnÞ can be generated in
MATLAB as follows:
d
filter([0.2 0.25 0.2],1,x); % Simulate physical media
u filter([0.2 0.2],1,x);
The residue error signal eðnÞ should be generated sample by sample and embedded into the
adaptive algorithm, that is,
e(n) d(n) (s(1)*y(n)+s(2)*y(n 1)); % Simulate the residue error
where s(1) ¼ 0.2 and s(2) ¼ 0.2. Details of active control systems can be found in the textbook
by Kuo and Morgan (1996).
10.28. Frequency tracking:
An adaptive ﬁlter can be applied for real-time frequency tracking (estimation). In this appli-
cation, a special second notch IIR ﬁlter structure, as shown in Figure 10.33, is preferred for
simplicity.
The notch ﬁlter transfer function
HðzÞ ¼
1  2cos

q

z 1 þ z 2
1  2rcosðqÞz 1 þ r2z 2
has only one adaptive parameter q. It has two zeros on the unit circle resulting in an inﬁnite-
depth notch. The parameter r controls the notch bandwidth. It requires 0 << r < 1 for
achieving a narrowband notch. When r is close to 1, the 3-dB notch ﬁlter bandwidth can be
approximated as BWz2ð1  rÞ (see Chapter 8). The input sinusoid whose frequency f
needs to be estimated and tracked is given below:
xðnÞ ¼ Acosð2pfn=fs þ aÞ
where A and a are the amplitude and phase angle. The ﬁlter output is expressed as
y

n

¼ x

n

 2cos

q

n

x

n  1

þ x

n  2

þ 2rcos

q

n

y

n  1

 r2y

n  2

Second-order adaptive IIR
notch filter
( )
y n
( )
x n
FIGURE 10.33
A frequency tracking system.
10.6 Summary
495

The objective is to minimize the ﬁlter instantaneous output power y2ðnÞ. Once the output power
is minimized, the ﬁlter parameter q ¼ 2pf=fs will converge to its corresponding frequency
f Hz. The LMS algorithm to minimize the instantaneous output power y2ðnÞ is given as
qðn þ 1Þ ¼ qðnÞ  2myðnÞbðnÞ;
where the gradient function bðnÞ ¼ vyðnÞ=vqðnÞ can be derived as follows:
b

n

¼ 2sin

q

n

x

n  1

 2rsin

q

n

y

n  1

þ 2rcos

q

n

b

n  1

 r2b

n  2

m is the convergence factor which controls speed of algorithm convergence.
In this project, plot and verify the notch frequency response by setting fs ¼ 8,000 Hz,
f ¼ 1,000 Hz, and r ¼ 0:95. Then generate the sinusoid with a duration of 10 seconds,
frequency of 1,000 Hz, and amplitude of 1. Implement the adaptive algorithm using an initial
guess qð0Þ ¼ 2p  2000=fs ¼ 0:5p and plot the tracked frequency fðnÞ ¼ qðnÞfs=2p for
tracking veriﬁcation.
Notice that this particular notch ﬁlter only works for a single frequency tracking, since the
mean squares error function E½y2ðnÞ has one global minimum (one best solution when the
LMS algorithm converges). Details of the adaptive notch ﬁlter can be found in Tan and Jiang
(2012). Notice that the general IIR adaptive ﬁlter suffers from local minima, that is, the LMS
algorithm converges to local minimum and the nonoptimal solution results.
496
CHAPTER 10 Adaptive Filters and Applications

Waveform Quantization and
Compression
11
CHAPTER OUTLINE
11.1 Linear Midtread Quantization ...................................................................................................... 497
11.2 m-law Companding ..................................................................................................................... 501
11.2.1 Analog m-Law Companding .....................................................................................501
11.2.2 Digital m-Law Companding......................................................................................504
11.3 Examples of Differential Pulse Code Modulation (DPCM), Delta Modulation,
and Adaptive DPCM G.721 .......................................................................................................... 509
11.3.1 Examples of Differential Pulse Code Modulation and Delta Modulation.......................509
11.3.2 Adaptive Differential Pulse Code Modulation G.721 .................................................512
Simulation Example..................................................................................................... 517
11.4 Discrete Cosine Transform, Modiﬁed Discrete Cosine Transform,
and Transform Coding in MPEG Audio .......................................................................................... 519
11.4.1 Discrete Cosine Transform......................................................................................519
11.4.2 Modiﬁed Discrete Cosine Transform ........................................................................522
11.4.3 Transform Coding in MPEG Audio ...........................................................................525
11.5 Laboratory Examples of Signal Quantization Using the TMS320C6713 DSK.................................... 528
11.6 Summary ................................................................................................................................... 533
11.7 MATLAB Programs ...................................................................................................................... 533
OBJECTIVES:
This chapter studies speech quantization and compression techniques such as signal companding,
differential pulse code modulation, and adaptive differential pulse code modulation. The chapter
continues to explore the discrete-cosine transform (DCT) and the modiﬁed DCT and shows how to apply the
developed concepts to understand the MP3 audio format. The chapter also introduces industry standards
that are widely used in the digital signal processing ﬁeld.
11.1 LINEAR MIDTREAD QUANTIZATION
As we discussed in Chapter 2, in the digital signal processing (DSP) system, the ﬁrst step is to sample and
quantize the continuous signal. Quantization is the process of rounding off the sampled signal voltage to
the predetermined levels that will be encoded by analog-to-digital conversion (ADC). We described the
quantization process in Chapter 2, in which we studied unipolar and bipolar linear quantizers in detail. In
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00011-1
Copyright  2013 Elsevier Inc. All rights reserved.
497

this section, we focus on a linear midtread quantizer, which is used in digital communications (Rod-
dy and Coolen, 1997; Tomasi, 2004), and its use to quantize speech waveforms. The linear midtread
quantizer is similar to the bipolar linear quantizer discussed in Chapter 2 except that the midtread
quantizer offers the same decoded magnitude range for both positive and negative voltages.
Let us look at a midtread quantizer. The characteristics and binary codes for a 3-bit midtread
quantizer are depicted in Figure 11.1, where the code is in a sign magnitude format. Positive voltage is
coded using a sign bit of logic 1, while negative voltage is coded by a sign bit of logic 0; the next two
bits are the magnitude bits. The key feature of the linear midtread quantizer is noted as follows: when
0  x < D=2, the binary code of 100 is produced; when D=2  x < 0, the binary code of 000 is
generated, where D is the quantization step size. However, the quantized values for both codes 100 and
000 are the same and equal to xq ¼ 0. We can also see details in Table 11.1. For the 3-bit midtread
001
011
100 000
/
101
110
111
010
eq
/ 2
/ 2
x
x
xq
3
2
0
2
3
4
2
4
2
3
Binary code
FIGURE 11.1
Characteristics of a 3-bit midtread quantizer.
Table 11.1 Quantization Table for the 3-bit Midtread Quantizer
Binary Code
Quantization Level xq (V)
Input Signal Subrange (V)
0 1 1
0 1 0
0 0 1
0 0 0
1 0 0
1 0 1
1 1 0
1 1 1
3D
2D
D
0
0
D
2D
3D
3:5D  x <
2:5D
2:5D  x <
1:5D
1:5D  x <
0:5D
0:5  x < 0
0  x < 0:5D
0:5D  x < 1:5D
1:5D  x < 2:5D
2:5D  x < 3:5D
Note: Step size ¼ D ¼ ðxmax
xminÞ=ð23
1Þ; xmax ¼ maximum voltage; and xmin ¼
xmax. Coding format: a. sign bit:
1¼ plus, 0 ¼ minus; b. 2 magnitude bits.
498
CHAPTER 11 Waveform Quantization and Compression

qunatizer, we expect seven quantized values instead of eight; that is; there are 2n  1 quantization
levels for the n-bit midtread quantizer. Notice that quantization signal range is ð2n  1ÞD and the
magnitudes of the quantized values are symmetric, as shown in Table 11.1. We apply the midtread
quantizer particularly for speech waveform coding.
The following example serves to illustrate the coding principles of the 3-bit midtread quantizer.
EXAMPLE 11.1
For the 3 bit midtread quantizer described in Figure 11.1 and the analog signal with a range from
5 volts to 5
volts,
a. determine the quantization step size;
b. determine the binary codes, recovered voltages, and quantization errors when the input is
3.6 volts and
0.5 volt, respectively.
Solution:
a. The quantization step size is calculated as
D
5
ð
5Þ
23
1
1:43 volts
b. For x
3:6 volts, we have x
3:6
1:43
2:52D. From quantization characteristics, it follows that the
binary code
011 and the recovered voltage is xq
3D
4:29 volts. Thus the quantization error is
computed as
eq
xq
x
4:29

3:6

0:69 volt
For x
0:5
0:5
1:43D
0:35D, we get binary code
100. Based on Figure 11.1, the recovered voltage and
quantization error are found to be
xq
0
and
eq
0
0:5
0:5 volt
As discussed in Chapter 2, the linear midtread quantizer introduces quantization noise, as shown in
Figure 11.1; the signal-to-noise power ratio (SNR) is given by
SNR ¼ 10:79 þ 20$log10
xrms
D

dB
(11.1)
where xrms designates the root mean squared value of the speech data to be quantized. The practical
equation for estimating the SNR for the speech data sequence xðnÞ of N data points is written as
SNR ¼
 
PN
1
n ¼ 0 x2
n

PN
1
n ¼ 0

xq

n

 x

n
2
!
(11.2)
SNR dB ¼ 10$log10ðSNRÞ dB
(11.3)
11.1 Linear Midtread Quantization
499

Notice that xðnÞ and xqðnÞ are the speech data to be quantized and the quantized speech data, respectively.
Equation (11.2) gives the absolute SNR, and Equation (11.3) produces the SNR in terms of decibels (dB).
Quantization error is the difference between the quantized speech data (or quantized voltage level)
and speech data (or analog voltage), that is, xqðnÞ  xðnÞ. Also note that from Equation (11.1), adding 1
bit to the linear quantizer would improve SNR by approximately 6 dB. Let us examine performance of
the 5-bit linear midtread quantizer.
In the following simulation, we use a 5-bit midtread quantizer to quantize the speech data. After
quantization, the original speech, quantized speech, and quantized error after quantization are plotted in
Figure 11.2. Since the program calculates xrms=xmax ¼ 0:203, we yield xrms as xrms ¼ 0:203  xmax ¼
0:0203  5 ¼ 1:015 and D ¼ 10=ð25  1Þ ¼ 0:3226. Applying Equation (11.1) gives SNR ¼ 21:02
dB. The SNR using Equations (11.2) and (11.3) is approximately 21.6 dB.
The ﬁrst plot in Figure 11.2 is the original speech, and the second plot shows the quantized speech.
Quantization error is displayed in the third plot, where the error amplitude interval is uniformly
distributed between
0.1613 and 0.1613, indicating the bounds of the quantized error (D=2). The
details of the MATLAB implementation are given in Program 11.1 in Section 11.7.
To improve the SNR, the number of bits must be increased. However, increasing the number of
encoding bits will cost an expansive ADC device, larger storage media for storing the speech data, and
more bandwidth for transmitting the digital data. To gain a more efﬁcient quantization approach, we
will study m-law companding in the next section.
0
200
400
600
800
1000
1200
1400
1600
1800
2000
5
0
5
Speech
0
200
400
600
800
1000
1200
1400
1600
1800
2000
5
0
5
Quantized speech
0
200
400
600
800
1000
1200
1400
1600
1800
2000
0.5
0
0.5
Qunatized error
Sample number
FIGURE 11.2
Plots of original speech, quantized speech, and quantization error.
500
CHAPTER 11 Waveform Quantization and Compression

11.2 m-LAW COMPANDING
In this section, we will study analog m-law companding, which takes an analog input signal; and digital
m-law companding, which deals with linear pulse code modulation (PCM) codes.
11.2.1 Analog m-Law Companding
To reduce the number of bits required to encode each speech datum, m-law companding, called log-
PCM coding, is applied. m-law companding (Roddy and Coolen, 1997; Tomasi, 2004) was ﬁrst used in
the United States and Japan in the telephone industry (G.711 standard). m-law companding is
a compression process. It explores the principle that the higher amplitudes of analog signals are
compressed before ADC and expanded after digital-to-analog conversion (DAC). As studied in the
linear quantizer, the quantization error is uniformly distributed. This means that the maximum
quantization error stays the same no matter how big or small the speech samples are. m-law com-
panding can be employed to make the quantization error smaller when the sample amplitude is smaller
and to make the quantization error bigger when the sample amplitude is bigger, using the same number
of bits per sample. It is described in Figure 11.3.
As shown in Figure 11.3, x is the original speech sample, which is the input to the compressor,
while y is the output from the m-law compressor; then the output y is uniformly quantized. Assuming
that the quantized sample yq is encoded and sent to the m-law expander, the expander will perform the
reverse process to obtain the quantized speech sample xq. The compression and decompression
processes cause the maximum quantization error jxq  xjmax to be small for the smaller sample
amplitudes and large for the larger sample amplitudes.
The equation for the m-law compressor is given by
y ¼ signðxÞ
ln

1 þ m
jxj
jxjmax

lnð1 þ mÞ
(11.4)
where jxjmax is the maximum amplitude of the inputs, while m is a positive parameter to control the
degree of the compression. m ¼ 0 corresponds to no compression, while m ¼ 255 is adopted in the
industry. The compression curve with m ¼ 255 is plotted in Figure 11.4. Note that the sign function
signðxÞ shown in Equation (11.4) is deﬁned as
signðxÞ ¼
(
1
x  0
1
x < 0
(11.5)
µ-law
compressor
Uniform
quantizer
µ-law
expander
x
y
yq
xq
FIGURE 11.3
Block diagram for m-law compressor and m-law expander.
11.2 m law Companding
501

Solving Equation (11.4) by substituting the quantized value, that is, y ¼ yq we achieve the expander
equation as
xq ¼ jxjmaxsignðyqÞð1 þ mÞjyqj1
m
(11.6)
For the case m ¼ 255, the expander curve is plotted in Figure 11.5.
Let’s look at Example 11.2 on m-law compression.
EXAMPLE 11.2
For the m law compression and expansion process shown in Figure 11.3, with m
255, the 3 bit midtread
quantizer described in Figure 11.1, and an analog signal ranging from
5 to 5 volts, determine the binary codes,
recovered voltages, and quantization errors when the input is
a.
3.6 volts
b. 0.5 volt
Solution:
a. For m law compression and x
3:6 volts, we can determine the quantization input as
1
0.8
0.6
0.4
0.2
0
0.2
0.4
0.6
0.8
1
1
0.8
0.6
0.4
0.2
0
0.2
0.4
0.6
0.8
1
x/|x|max
µ law compressor
y
FIGURE 11.4
Characteristics for the m-law compander.
502
CHAPTER 11 Waveform Quantization and Compression

y
signð 3:6Þ
ln

1 þ 255 j 3:6j
j5jmax

lnð1 þ 255Þ
0:94
As shown in Figure 11.4, the range of y is 2, thus the quantization step size is calculated as
D
2
23
1
0:286
and
y
0:94
0:286
3:28D
From quantization characteristics, it follows that the binary code is 011 and the recovered signal is
yq
3D
0:858.
Applying the m law expander leads to
xq
j5jmaxsignð 0:858Þð1 þ 255Þj0:858j
1
255
2:264
Thus the quantization error is computed as
eq
xq
x
2:264

3:6

1:336 volts
b. Similarly, for x
0:5, we get
y
signð0:5Þ
ln

1 þ 255 j0:5j
j5jmax

lnð1 þ 255Þ
0:591
-1
-0.8
-0.6
-0.4
-0.2
0
0.2
0.4
0.6
0.8
1
-1
-0.8
-0.6
-0.4
-0.2
0
0.2
0.4
0.6
0.8
1
yq
xq/|x|max
µ-law expander
FIGURE 11.5
Characteristics for the m-law expander.
11.2 m law Companding
503

In terms of the quantization step, we get
y
0:519
0:286 D
2:1D
and binary code
110
Based on Figure 11.1, the recovered signal is
yq
2D
0:572
and the expander gives
xq
j5jmaxsignð0:572Þð1 þ 255Þj0:572j
1
255
0:448 volt
Finally, the quantization error is given by
eq
0:448
0:5
0:052 volt
As we can see, with 3 bits per sample, the stronger signal is encoded with more quantization error, while the weak
signal is encoded with less quantization error.
In the following simulation, we apply a 5-bit m-law compander with m ¼ 255 in order to quantize
and encode the speech data used in the last section. Figure 11.6 is a block diagram of compression and
decompression.
Figure 11.7 shows the original speech data, the quantized speech data using m-law compression,
and the quantization error for comparisons. The quantized speech wave is very close to the original
speech wave. From the plots in Figure 11.7, we can observe that the amplitude of the quantization error
changes according to the amplitude of the speech being quantized. More quantization error is intro-
duced when the amplitude of speech data is larger; on the other hand, a smaller quantization error is
produced when the amplitude of speech data is smaller.
Compared with the quantized speech using the linear quantizer shown in Figure 11.2, the
decompressed signal using the m-law compander looks and sounds much better, since the quantized
signal can better track the original large amplitude signal and original small amplitude signal as well.
The MATLAB implementation is shown in Program 11.2 in Section 11.7.
11.2.2 Digital m-Law Companding
In many multimedia applications, the analog signal is ﬁrst sampled and then it is digitized into a linear
PCM code with a larger number of bits per sample. Digital m-law companding further compresses the
linear PCM code using the compressed PCM code with a smaller number of bits per sample without
losing sound quality. The block diagram of a digital m-law compressor and expander is shown in
Figure 11.8.
µ law
compressor
µ=255
5 bit code
midtread
 quantizer
µ law
expander
µ=255
x
y
yq
xq
FIGURE 11.6
The 5-bit midtread uniform quantizer with m ¼ 255 used for simulation.
504
CHAPTER 11 Waveform Quantization and Compression

The typical digital m-law companding system compresses a 12-bit linear PCM code to an 8-bit
compressed code. This companding characteristic is depicted in Figure 11.9, where it closely
resembles an analog compression curve with m ¼ 255 by approximating the curve using a set of eight
straight-line segments. The slope of each successive segment is exactly one-half that of the previous
segment. Figure 11.9 shows the 12-bit to 8-bit digital companding curve for the positive portion only.
There are 16 segments, accounting for both positive and negative portions.
However, like the midtread quantizer discussed in the ﬁrst section of this chapter, only 13 segments
are used, since segments þ0, 0, þ1, and 1 form a straight line with a constant slope and are
considered one segment. As shown in Figure 11.9, when the relative input is very small, such as in
segment 0 or segment 1, there is no compression, while when the relative input is larger such as in
segment 3 or segment 4, the compression occurs with compression ratios of 2:1 and 4:1, respectively.
0
200
400
600
800
1000
1200
1400
1600
1800
2000
5
0
5
Speech
0
200
400
600
800
1000
1200
1400
1600
1800
2000
5
0
5
Recovered speech
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0
1
Quant zed error
Sample number
FIGURE 11.7
Plots of the original speech, quantized speech, and quantization error with the m-law compressor and expander.
Linear PCM
Decoded
linear PCM
Digital µ-law
compressor
Digital µ-law
expander
Compressed
PCM
FIGURE 11.8
The block diagram for a m-law compressor and expander.
11.2 m law Companding
505

The format of the 12-bit linear PCM code is in the sign-magnitude form with the most signiﬁcant bit
(MSB) as the sign bit (1 ¼ positive value and 0 ¼ negative value) plus 11 magnitude bits. The
compressed 8-bit code has the format shown in Table 11.2, where it consists of a sign bit, a 3-bit
segment identiﬁer, and a 4-bit quantization interval within the speciﬁed segment. Encoding and
decoding procedures are very simple, as illustrated in Tables 11.3 and 11.4, respectively.
As shown in those two tables, the preﬁx “S” is used to indicate the sign bit, which could be either
1 or 0; A, B, C, and D, are transmitted bits; and the bit position with an “X” is the truncated bit during
the compression and hence would be lost during decompression. For the 8-bit compressed PCM code
in Table 11.3, the 3 bits between “S” and “ABCD” indicate the segment number that is obtained by
subtracting the number of consecutive zeros (less than or equal to 7) after the “S” bit in the original
12-bit PCM code from 7. Similarly, to recover the 12-bit linear code in Table 11.4, the number of
consecutive zeros after the “S” bit can be determined by subtracting the segment number in the 8-bit
compressed code from 7. We will illustrate the encoding and decoding processes in Examples 11.3
and 11.4.
10.
10.
00.
Segment +0  1:1 no compression
Segment +1  1:1 no compression
Segment +2  2:1 compression ratio
Segment +3  4:1 compression ratio
Segment +4  8:1 compression ratio
Segment +5  16:1 compression ratio
Segment +7  64:1 compression ratio
Relative input amplitude
Relat ve output ampl tude
Segment +6  32:1 compression ratio
FIGURE 11.9
m
255 compression characteristics (for positive portion only).
Table 11.2 The Format of 8-Bit Compressed PCM Code
Sign bit:
1
þ
0
3-bit segment
identiﬁer: 000 to 111
4-bit
quantization
interval:
A B C D
0000 to 1111
506
CHAPTER 11 Waveform Quantization and Compression

EXAMPLE 11.3
In a digital companding system, encode each of the following 12 bit linear PCM codes into an 8 bit compressed
PCM code.
a. 1 0 0 0 0 0 0 0 0 1 0 1
b. 0 0 0 0 1 1 1 0 1 0 1 0
Solution:
a. Based on Table 11.3, we identify the 12 bit PCM code as S
1, A
0, B
1, C
0, and D
1, which is in
segment 0. From the fourth column in Table 11.3, we get the 8 bit compressed code as
1 0 0 0 0 1 0 1
b. For the second 12 bit PCM code, we note that S
0, A
1, B
1, C
0, D
1, and XXX
010, and the code
belongs to segment 4. Thus, from the fourth column in Table 11.3, we have
0 1 0 0 1 1 0 1
Table 11.3 m  255 Encoding Table
Segment
12-Bit Linear Code
12-Bit Amplitude Range
in Decimal
8-Bit Compressed
Code
0
1
2
3
4
5
6
7
S0000000ABCD
S0000001ABCD
S000001ABCDX
S00001ABCDXX
S0001ABCDXXX
S001ABCDXXXX
S01ABCDXXXXX
S1ABCDXXXXXX
0 to 15
16 to 31
32 to 63
64 to 127
128 to 255
256 to 511
512 to 1023
1023 to 2047
S000ABCD
S001ABCD
S010ABCD
S011ABCD
S100ABCD
S101ABCD
S110ABCD
S111ABCD
Table 11.4 m  255 Decoding Table
8-Bit Compressed Code
8-Bit Amplitude Range
in Decimal
Segment
12-Bit Linear Code
S000ABCD
S001ABCD
S010ABCD
S011ABCD
S100ABCD
S101ABCD
S110ABCD
S111ABCD
0 to 15
16 to 31
32 to 47
48 to 63
64 to 79
80 to 95
96 to 111
112 to 127
0
1
2
3
4
5
6
7
S0000000ABCD
S0000001ABCD
S000001ABCD1
S00001ABCD10
S0001ABCD100
S001ABCD1000
S01ABCD10000
S1ABCD100000
11.2 m law Companding
507

EXAMPLE 11.4
In a digital companding system, decode each of the following 8 bit compressed PCM codes into a 12 bit linear
PCM code.
a. 1 0 0 0 0 1 0 1
b. 0 1 0 0 1 1 0 1
Solution:
a. Using Table 11.4, we notice that S
1, A
0, B
1, C
0, and D
1, and the code is in segment 0. Decoding
leads to 1 0 0 0 0 0 0 0 0 1 0 1, which is identical to the 12 bit PCM code in (a) in Example 11.3. We expect
this result, since there is no compression for segment 0 and segment 1.
b. Applying Table 11.4, it follows that S
0, A
1, B
1, C
0, and D
1, and the code resides in segment 4.
Decoding achieves 0 0 0 0 1 1 1 0 1 1 0 0. As expected, this code is the approximation of the code in (b) in
Example 11.3. Since segment 4 has compression, the last 3 bits in the original 12 bit linear code, that is,
XXX
010
2 in decimal, are discarded during transmission or storage. When we recover these three bits,
the best guess should be the middle value: XXX
100
4 in decimal for the 3 bit coding range from 0 to 7.
Now we apply the m  255 compander to compress 12-bit speech data as shown in Figure 11.10(a).
The 8-bit compressed code is plotted in Figure 11.10(b). Plots (c) and (d) in the ﬁgure show the 12-bit
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1000
0
1000
0
200
400
600
800
1000
1200
1400
1600
1800
2000
100
0
100
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1000
0
1000
0
200
400
600
800
1000
1200
1400
1600
1800
2000
40
20
0
20
40
Sample number
(a)
(b)
(c)
(d)
FIGURE 11.10
The m
255 compressor and expander: (a) 12-bit speech data; (b) 8-bit compressed data; (c) 12-bit decoded
speech; (d) quantization error.
508
CHAPTER 11 Waveform Quantization and Compression

speech after decoding and quantization error, respectively. We can see that the quantization error
follows the amplitude of speech data relatively. The decoded speech sounds no different when
compared with the original speech. Programs 11.8 to 11.10 in Section 11.7 show the details of the
MATLAB implementation.
11.3 EXAMPLES OF DIFFERENTIAL PULSE CODE MODULATION (DPCM),
DELTA MODULATION, AND ADAPTIVE DPCM G.721
Data compression can be further achieved using differential pulse code modulation (DPCM). The
general idea is to use past recovered values as the basis to predict the current input data and then
encode the difference between the current input and the predicted input. Since the difference has
a signiﬁcantly reduced signal dynamic range, it can be encoded with fewer bits per sample. Therefore,
we obtain data compression. First, we study the principles of the DPCM concept that will help us
understand adaptive DPCM in the next subsection.
11.3.1 Examples of Differential Pulse Code Modulation and Delta Modulation
Figure 11.11 shows a schematic diagram for the DPCM encoder and decoder. We denote the original
signal xðnÞ; the predicted signal ~xðnÞ; the quantized or recovered signal ^xðnÞ; the difference signal to be
quantized dðnÞ; and the quantized difference signal dqðnÞ. The quantizer can be chosen as a uniform
quantizer, a midtread quantizer (e.g., see Table 11.5), or any others available. The encoding block
produces a binary bit stream in the DPCM encoding. The predictor uses the past predicted signal and
quantized difference signal to predict the current input value xðnÞ as close as possible. The digital ﬁlter
or adaptive ﬁlter can serve as the predictor. On the other hand, the decoder recovers the quantized
difference signal, which can be added to the predictor output signal to produce the quantized and
recovered signal, as shown in Figure 11.11(b).
(a)
(b)
FIGURE 11.11
DPCM block diagram: (a) encoder; (b) decoder.
11.3 Examples of Differential Pulse Code Modulation (DPCM)
509

Table 11.5 Quantization Table for the 3-bit Quantizer in Example 11.5
Binary Code
Quantization Value dqðnÞ
Subrange in dðnÞ
0 1 1
0 1 0
0 0 1
0 0 0
1 0 0
1 0 1
1 1 0
1 1 1
11
5
2
0
0
2
5
11
15  dðnÞ <
7
7  dðnÞ <
3
3  dðnÞ <
1
1  dðnÞ < 0
0  dðnÞ  1
1 < dðnÞ  3
3 < dðnÞ  7
7 < dðnÞ  15
In Example 11.5, we examine a simple DPCM coding system via the process of encoding and decoding
numerical actual data.
EXAMPLE 11.5
A DPCM system has the following speciﬁcations:
Encoder scheme: xðnÞ
^xðn
1Þ; predictor
dðnÞ
xðnÞ
xðnÞ
dq

n

Q½dðnÞ
quantizer in Table 11:5
^x

n

x

n

þ dq

n

Decoding scheme: xðnÞ
^xðn
1Þ; predictor
dq

n

quantizer in Table 11:5
^x

n

x

n

þ dq

n

5 bit input data: xð0Þ
6, xð1Þ
8, xð2Þ
13.
a. Perform DPCM encoding to produce the binary code for each input datum.
b. Perform DCPM decoding to recover the data using the binary code in (a).
Solution:
a. Let us perform encoding according to the encoding scheme.
For n
0, we have
xð0Þ
^xð 1Þ
0
dð0Þ
xð0Þ
xð0Þ
6
0
6
dqð0Þ
Q½dð0Þ
5
^xð0Þ
xð0Þ þ dqð0Þ
0 þ 5
5
Binary code
110
For n
1, it follows that
xð1Þ
^xð0Þ
5
dð1Þ
xð1Þ
xð1Þ
8
5
3
dqð1Þ
Q½dð1Þ
2
^xð1Þ
xð1Þ þ dqð1Þ
5 þ 2
7
Binary code
101
For n
2, the results are
xð2Þ
^xð1Þ
7
dð2Þ
xð2Þ
xð2Þ
13
7
6
510
CHAPTER 11 Waveform Quantization and Compression

dqð2Þ
Q½dð2Þ
5
^xð2Þ
xð2Þ þ dqð2Þ
7 þ 5
12
Binary code
110
b. We conduct the decoding scheme as follows.
For n
0, we get
Binary code
110
dqð0Þ
5; from Table 11.5
xð0Þ
^xð 1Þ
0
^xð0Þ
xð0Þ þ dqð0Þ
0 þ 5
5 (recovered)
For n
1, decoding shows:
Binary code
101
dqð1Þ
2; from Table 11.5
xð1Þ
^xð0Þ
5
^xð1Þ
xð1Þ þ dqð1Þ
5 þ 2
7 (recovered)
For n
2, we have:
Binary code
110
dqð2Þ
5; from Table 11.5
xð2Þ
^xð1Þ
7
^xð2Þ
xð2Þ þ dqð2Þ
7 þ 5
12 (recovered)
From this example, we can verify that the 5 bit code is compressed to the 3 bit code. However, we can see that
each piece of recovered data has a quantization error. Hence, DPCM is a lossy data compression scheme.
DPCM for which a single bit is used in the quantization table becomes delta modulation (DM). The quanti
zation table contains two quantized values, A and
A, where A is the quantization step size. Delta modulation
quantizes the difference of the current input sample and the previous input sample using a 1 bit code word. To
conclude the idea, we list the equations for encoding and decoding as follows:
Encoder scheme: xðnÞ
^xðn
1Þ; predictor
dðnÞ
xðnÞ
xðnÞ
dq

n

(
þA
dq

n

 0; output bit: 1
A
dq

n

0; output bit: 0
^x

n

x

n

þ dq

n

Decoding scheme : xðnÞ
^xðn
1Þ; predictor
dq

n

(
þA
input bit: 1
A
input bit: 0
^x

n

x

n

þ dq

n

Note that the predictor has a sample delay.
EXAMPLE 11.6
Consider a DM system with 5 bit input data
xð0Þ
6; xð1Þ
8; xð2Þ
13
and a quantized constant of A
7.
a. Perform DM encoding to produce the binary code for each input datum.
b. Perform DM decoding to recover the data using the binary code in (a).
11.3 Examples of Differential Pulse Code Modulation (DPCM)
511

Solution:
a. Applying encoding accordingly, we have
For n
0,
xð0Þ
^xð 1Þ
0, dð0Þ
xð0Þ
xð0Þ
6
0
6
dqð0Þ
7, ^xð0Þ
xð0Þ þ dqð0Þ
0 þ 7
7
Binary code
1
For n
1,
xð1Þ
^xð0Þ
7, dð1Þ
xð1Þ
xð1Þ
8
7
1
dqð1Þ
7, ^xð1Þ
xð1Þ þ dqð1Þ
7 þ 7
14
Binary code
1.
For n
2,
xð2Þ
^xð1Þ
14, dð2Þ
xð2Þ
xð2Þ
13
14
1
dqð2Þ
7, ^xð2Þ
xð2Þ þ dqð2Þ
14
7
7
Binary code
0
b. Applying the decoding scheme leads to
For n
0,
Binary code
1
dqð0Þ
7, xð0Þ
^xð 1Þ
0
^xð0Þ
xð0Þ þ dqð0Þ
0 þ 7
7 (recovered)
For n
1,
Binary code 1
dqð1Þ
7, xð1Þ
^xð0Þ
7
^xð1Þ
xð1Þ þ dqð1Þ
7 þ 7
14 (recovered)
For n
2,
Binary code 0
dqð2Þ
7, xð2Þ
^xð1Þ
14
^xð2Þ
xð2Þ þ dqð2Þ
14
7
7 (recovered)
We can see that coding causes a larger quantization error for each recovered sample. In practice,
this can be solved by using a very high sampling rate (much larger than the Nyquist rate), and by
making the quantization step size A adaptive. The quantization step size increases by a factor when
the slope magnitude of the input sample curve becomes bigger, that is, the condition in which the
encoder produces continuous logic 1s or continuous logic 0s in the coded bit stream. Similarly, the
quantization step decreases by a factor when the encoder generates logic 1 and logic 0 alternatively.
Hence, the resultant DM is called adaptive DM. In practice, the DM chip replaces the predictor,
feedback path, and summer (see Figure 11.11) with an integrator for both the encoder and the
decoder. Detailed information can be found in Li and Drew (2004), Roddy and Coolen (1997), and
Tomasi (2004).
11.3.2 Adaptive Differential Pulse Code Modulation G.721
In this subsection, an efﬁcient compression technique for speech waveform is described, that is,
adaptive DPCM (ADPCM), per recommendation G.721 of the CCITT (the Comite´ Consultatif
512
CHAPTER 11 Waveform Quantization and Compression

International Te´le´phonique et Te´le´graphique). General discussion can be found in Li and Drew (2004),
Roddy and Coolen (1997), and Tomasi (2004). The simpliﬁed block diagrams of the ADPCM encoder
and decoder are shown in Figures 11.12A and 11.12B.
As shown in Figure 11.12A for the ADPCM encoder, ﬁrst a difference signal dðnÞ is obtained, by
subtracting an estimate of the input signal ~xðnÞ from the input signal xðnÞ. An adaptive 16-level
quantizer is used to assign four binary digits IðnÞ to the value of the difference signal for transmission
to the decoder. At the same time, the inverse quantizer produces a quantized difference signal dqðnÞ
from the same four binary digits IðnÞ. The adaptive quantizer and inverse quantizer operate based on
the quantization table and the scale factor obtained from the quantizer adaptation to keep tracking
the energy change of the difference signal to be quantized. The input signal estimate from the
16-level adaptive
quantizer
 Encoder
Adaptive
predictor
B(z)/A(z)
+
+
x n
( )
~( )
x n
d n
( )
d
n
q ( )
Quantizer
adaptation
16-level inverse
adaptive
quantizer
+
+
+
I n
( )
FIGURE 11.12A
ADPCM encoder.
16-level inverse
adaptive
quantizer
Adaptive
predictor
B(z)/A(z)
+
I n
( )
ˆ( )
x n
Quantizer
adaptation
+
+
d
n
q ( )
~( )
x n
FIGURE 11.12B
ADPCM decoder.
11.3 Examples of Differential Pulse Code Modulation (DPCM)
513

adaptive predictor is then added to this quantized difference signal to produce the reconstructed
version of the input ^xðnÞ. Both the reconstructed signal and the quantized difference signal are
operated on by an adaptive predictor, which generates the estimate of the input signal, thereby
completing the feedback loop.
The decoder shown in Figure 11.12B includes a structure identical to the feedback part of the
encoder as depicted in Figure 11.12A. It ﬁrst converts the received 4-bit data IðnÞ to the quantized
difference signal dqðnÞ using the adaptive quantizer. Then, at the second stage, the adaptive predictor
uses the recovered quantized difference signal dqðnÞ and recovered current output ~xðnÞ to generate the
next output. Notice that the adaptive predictors of both the encoder and the decoder change corre-
spondingly based on the signal to be quantized. The details of the adaptive predictor will be discussed.
Now, let us examine the ADPCM encoder principles. As shown in Figure 11.12A, the difference
signal is computed as
dðnÞ ¼ xðnÞ  ~xðnÞ
(11.7)
A 16-level nonuniform adaptive quantizer is used to quantize the difference signal dðnÞ. Before
quantization, dðnÞ is converted to a base-2 logarithmic representation and scaled by yðnÞ, which is
computed by the scale factor algorithm. Four binary codes IðnÞ are used to specify the quantized signal
level representing dqðnÞ, and the quantized difference dqðnÞ is also fed to the inverse adaptive
quantizer. Table 11.6 shows the quantizer normalized input and output characteristics.
The scaling factor for the quantizer and the inverse quantizer yðnÞ is computed according to the
4-bit quantizer output IðnÞ and the adaptation speed control parameter alðnÞ, the fast (unlocked) scale
factor yuðnÞ, the slow (locked) scale factor ylðnÞ, and the discrete function WðIÞ, deﬁned in Table 11.7:
yu

n

¼

1  2 5
y

n

þ 2 5W

I

n

(11.8)
where 1:06  yuðnÞ  10:00.
The slow scale factor ylðnÞ is derived from the fast scale factor yuðnÞ using a lowpass ﬁlter as follows:
yl

n

¼

1  2 6
yl

n  1

þ 2 6yu

n

(11.9)
Table 11.6 Quantizer Normalized Input and Output Characteristics
Normalized Quantizer
Input Range:
log2jdðnÞjLyðnÞ
Magnitude:
jIðnÞj
Normalized Quantizer
Output:
log2jdqðnÞjLyðnÞ
[3.12, þN)
7
3.32
[2.72, 3.12)
6
2.91
[2.34, 2.72)
5
2.52
[1.91, 2.34)
4
2.13
[1.38, 1.91)
3
1.66
[0.62, 1.38)
2
1.05
[ 0.98, 0.62)
1
0.031
( N,
0.98)
0
N
514
CHAPTER 11 Waveform Quantization and Compression

The fast and slow scale factors are then combined to compute the scale factor:
yðnÞ ¼ alðnÞyuðn  1Þ þ ð1  alðnÞÞylðn  1Þ
(11.10)
Next the controlling parameter 0  alðnÞ  1 tends toward unity for speech signals and toward zero for
voice band data signals and tones. It is updated based on the following parameters: dmsðnÞ, which is the
relatively short-term average of FðIðnÞÞ; dmlðnÞ, which is the relatively long-term average of FðIðnÞÞ;
and the variable apðnÞ, where FðIðnÞÞ is deﬁned as in Table 11.8.
Hence, we have
dms

n

¼

1  2 5
dms

n  1

þ 2 5F

I

n

(11.11)
and
dml

n

¼

1  2 7
dml

n  1

þ 2 7F

I

n

(11.12)
while the variable apðnÞ is given by
apðnÞ ¼
8
>
>
>
>
>
>
>
<
>
>
>
>
>
>
>
:

1  2 4
ap

n  1

þ 2 3
if
jdmsðnÞ  dmlðnÞj  2 3dml

n


1  2 4
ap

n  1

þ 2 3
if
yðnÞh3

1  2 4
ap

n

þ 2 3
if
tdðnÞ ¼ 1
1
if
trðnÞ ¼ 1

1  2 4
ap

n

otherwise
(11.13)
apðnÞ approaches 2 when the difference between dmsðnÞ and dmlðnÞ is large and approaches 0 when the
difference is small. Also apðnÞ approaches 2 for an idle channel (indicated by y(n) <3) or partial band
signals (indicated by tdðnÞ ¼ 1). Finally, apðnÞ is set to 1 when a partial band signal transition is
detected (trðnÞ ¼ 1).
alðnÞ, which is used in Equation (11.10), is deﬁned as
TABLE 11.7 Discrete Function WðIÞ
jIðnÞj
7
6
5
4
3
2
1
0
WðIÞ
70.13
22.19
12.38
7.00
4.0
2.56
1.13
0.75
TABLE 11.8 Discrete Function FðIðnÞÞ
jIðnÞj
7
6
5
4
3
2
1
0
FðIðnÞÞ
7
3
1
1
1
0
0
0
11.3 Examples of Differential Pulse Code Modulation (DPCM)
515

alðnÞ ¼
(
1
ap

n  1
	
1
ap

n  1

ap

n  1

 1
(11.14)
The partial band signal tdðnÞ and the partial band signal transition trðnÞ that appear in Equation (11.13)
will be discussed later.
The predictor computes the signal estimate ~xðnÞ from the quantized difference signal dqðnÞ. The
predictor z-transfer function, which is suitable for a variety of input signals, is given by
BðzÞ
AðzÞ ¼ b0 þ b1z 1 þ b2z 2 þ b3z 3 þ b4z 4 þ b5z 5
1  a1z 1  a2z 2
(11.15)
It consists of a ﬁfth-order portion that models the zeros and a second-order portion that models the
poles of the input signals. The input signal estimate is expressed in terms of the processed signal ^xðnÞ
and the signal xzðnÞ processed by the ﬁnite impulse response (FIR) ﬁlter as follows:
~xðnÞ ¼ a1ðnÞ^xðn  1Þ þ a2ðnÞ^xðn  2Þ þ xzðnÞ
(11.16)
where
^x

n  i

¼ ~x

n  i

þ dq

n  i

(11.17)
xzðnÞ ¼
X
5
i ¼ 0
bi

n

dq

n  i

(11.18)
Both sets of predictor coefﬁcients are updated using a simpliﬁed gradient algorithm:
a1

n

¼

1  2 8
a1

n  1

þ 3$2 8signn

p

n

sign

p

n  1

(11.19)
a2

n

¼

1  2 7
a2

n  1

þ 2 7fsignnðpðnÞÞsignðpðn  2ÞÞ
 fða1ðn  1ÞÞsignnðpðnÞÞsignðpðn  1ÞÞg
(11.20)
where pðnÞ ¼ dqðnÞ þ xzðnÞ and
fða1ðnÞÞ ¼
(
4a1ðnÞ
ja1ðnÞj  2 1
2 signða1ðnÞÞ
ja1ðnÞj > 2 1
(11.21)
Note that the function sign(x) is deﬁned in Equation (11.5), while the function signn(x) equals 1 when
x > 0, equals 0 when x ¼ 0; and equals ¼ 1 when x < 0 with stability constrains
ja2ðnÞj  0:75 and ja1ðnÞj  1  2 4  a2

n

(11.22)
a1ðnÞ ¼ a2ðnÞ ¼ 0
if
trðnÞ ¼ 1
(11.23)
Also, the equations for updating the coefﬁcients for the zero-order portion are given by
bi

n

¼

1  2 8
bi

n  1

þ 2 7signn

dq

n

sign

dq

n  i

for i ¼ 0; 1; 2; /; 5
(11.24)
516
CHAPTER 11 Waveform Quantization and Compression

with the following constrains:
b0ðnÞ ¼ b1ðnÞ ¼ b2ðnÞ ¼ b3ðnÞ ¼ b4ðnÞ ¼ b5ðnÞ ¼ 0
if
trðnÞ ¼ 1
(11.25)
tdðnÞ ¼
(
1
a2ðnÞh  0:71875
0
otherwise
(11.26)
trðnÞ ¼
(
1
a2ðnÞh  0:71875
and


dq

n


 > 24,2yl
0
otherwise
(11.27)
tdðnÞ is the indicator that detects a partial band signal (tone). If a tone is detected (tdðnÞ ¼ 1), Equation
(11.13) is invoked to drive the quantizer into the fast mode of adaptation. trðnÞ is the indicator for
a transition from a partial band signal. If it is detected (trðnÞ ¼ 1), setting the predictor coefﬁcients to be
zero as shown in Equations (11.23) and (11.25) will force the quantizer into the fast mode of adaptation.
Simulation Example
To illustrate performance, we apply the ADPCM encoder to the speech data used in Section 11.1 and
then operate the ADPCM decoder to recover the speech signal. As described, the ADPCM uses 4 bits
to encode each speech sample. The MATLAB implementations for the encoder and decoder are listed
in Programs 11.11 to 11.13 in Section 11.7. Figure 11.13 plots the original speech samples, decoded
0
200
400
600
800
1000
1200
1400
1600
1800
2000
5000
0
5000
Speech
0
200
400
600
800
1000
1200
1400
1600
1800
2000
5000
0
5000
Quant zed speech
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1000
0
1000
Quant zed error
Sample number
FIGURE 11.13
Original speech, quantized speech, and quantization error using ADPCM.
11.3 Examples of Differential Pulse Code Modulation (DPCM)
517

speech samples, and the quantization errors. From the ﬁgure, we see that the decoded speech data are
very close to the original speech data; the quantization error is very small as compared with the speech
sample, and its amplitude follows the change in amplitude of the speech data. In practice, we cannot
tell the difference between the original speech and the decoded speech by listening to them. However,
ADPCM encodes each speech sample using 4 bits per sample, while the original data are presented
using 16 bits; thus the compression ratio (CR) of 4:1 is achieved.
In practical applications, data compression can reduce the storage media and bit rate for efﬁcient
digital transmission. To measure performance of data compression, we use
• the data CR, which is the ratio of original data ﬁle size to the compressed data ﬁle size, or ratio of
the original code size in bits to the compressed code size in bits for ﬁxed-length coding, and
• the bit rate, which is in terms of bits per second (bps) and can be calculated by
bit rate ¼ m  fs ðbpsÞ
(11.28)
where m ¼ number of bits per sample (bits) and fs ¼ sampling rate (samples per second).
Now, let us look at an application example.
EXAMPLE 11.7
Speech is sampled at 8 kHz and each sample is encoded at 12 bits per sample. Using (1) no compression,
(2) standard m law compression, and (3) standard ADPCM encoding,
a. determine the CR and the bit rate for each of the encoders and decoders;
b. determine the number of channels that the phone company can carry if a telephone system can transport the
digital voice channel over a digital link with a capacity of 1.536 Mbps.
Solution:
a(1). For no compression:
CR
1 : 1
Bit rate
12
bits
sample  8;000 sample
second
96 ðkbpsÞ
b(1).
Number of channels
1:536
96
MBPS
KBPS
16
a(2). For standard m law compression, each sample is encoded using 8 bits per sample. Hence, we have
CR
12
8
bits=sample
bits=sample
1:5 : 1
Bit rate
8
bits
sample  8;000 sample
second
64 ðkbpsÞ
b(2).
Number of channels
1:536
64
MBPS
KBPS
24
a(3). For standard ADPCM with 4 bits per sample, it follows that
518
CHAPTER 11 Waveform Quantization and Compression

CR
12
4
bits=sample
bits=sample
3 : 1
Bit rate
4
bits
sample  8;000 sample
second
32 ðkbpsÞ
b(3).
Number of channels
1:536
32
MBPS
KBPS
48:
11.4 DISCRETE COSINE TRANSFORM, MODIFIED DISCRETE COSINE
TRANSFORM, AND TRANSFORM CODING IN MPEG AUDIO
This section introduces discrete cosine transform (DCT) and explains how to apply it in transform
coding. This section will also show how to remove the block effects in transform coding using a modiﬁed
DCT (MDCT). Finally, we will examine how MDCT coding is used in the MPEG (Motion Picture
Experts Group) audio format, which is used as a part of MPEG audio, such as MP3 (MPEG-1 layer 3).
11.4.1 Discrete Cosine Transform
Given N data samples, we deﬁne the one-dimensional (1D) DCT pair as follows:
Forward transform:
XDCTðkÞ ¼
2
N
r
CðkÞ
X
N
1
n ¼ 0
xðnÞcos
ð2n þ 1Þkp
2N

; k ¼ 0; 1; /; N  1
(11.29)
Inverse transform:
xðnÞ ¼
2
N
r
X
N
1
k ¼ 0
CðkÞXDCTðkÞcos
ð2n þ 1Þkp
2N

; n ¼ 0; 1; /; N  1
(11.30)
CðkÞ ¼
8
>
<
>
:
2
p
2
k ¼ 0
1
otherwise
(11.31)
where xðnÞ is the input data sample and XDCTðkÞ is the DCT coefﬁcient. The DCT transforms the time
domain signal to frequency domain coefﬁcients. However, unlike the discrete Fourier transform
(DFT), there are no complex number operations for both the forward and inverse transforms. Both the
forward and inverse transforms use the same scale factor:
2
N
r
CðkÞ
In terms of transform coding, the DCT decomposes a block of data into a direct-current (DC) coef-
ﬁcient that corresponds to the average of the data samples and alternating-current (AC) coefﬁcients
that correspond to the frequency component (ﬂuctuation). The terms “DC” and “AC” come from basic
11.4 Discrete Cosine Transform, Modiﬁed Discrete Cosine Transform
519

electrical engineering. In transform coding, we can quantize the DCT coefﬁcients and encode them
into binary information. The inverse DCT can transform the DCT coefﬁcients back to the input data.
Let us proceed to Examples 11.8 and 11.9.
EXAMPLE 11.8
Assume that the following input data can each be encoded by 5 bits, including a sign bit:
xð0Þ
10; xð1Þ
8; xð2Þ
10 and xð3Þ
12
a. Determine the DCT coefﬁcients.
b. Use the MATLAB function dct() to verify all the DCT coefﬁcients.
Solution:
a. Using Equation (11.29) leads to
XDCT ðkÞ
1
2
r
CðkÞ

xð0Þ cos
pk
8

þ xð1Þ cos
3pk
8

þ xð2Þ cos
5pk
8

þ xð3Þ cos
7pk
8

When k
0, we see that the DC component is calculated as
XDCT ð0Þ
1
2
r
Cð0Þ

xð0Þ cos
p  0
8

þ xð1Þ cos
3p  0
8

þ xð2Þ cos
5p  0
8

þ xð3Þ cos
7p  0
8

1
2
r

2
p
2 ½xð0Þ þ xð1Þ þ xð2Þ þ xð3Þ
1
2 ð10 þ 8 þ 10 þ 12Þ
20
We clearly see that the ﬁrst DCT coefﬁcient is a scaled average value.
For k
1,
XDCT ð1Þ
1
2
r
Cð1Þ

xð0Þ cos
p  1
8

þ xð1Þ cos
3p  1
8

þ xð2Þ cos
5p  1
8

þ xð3Þ cos
7p  1
8

1
2
r
 1

10  cos
p
8

þ 8  cos
3p
8

þ 10  cos
5p
8

þ 12  cos
7p
8

1:8478
Similarly, we have
XDCT ð2Þ
2 and XDCT ð3Þ
0:7654
b. Using the MATLAB 1D DCT function dct(), we can verify the DCT coeffcients:
>> dct([10 8 10 12])
ans
20.0000
1.8478 2.0000 0.7654
EXAMPLE 11.9
Assume the following DCT coefﬁcients:
XDCT ð0Þ
20; XDCT ð1Þ
1:8478; XDCT ð0Þ
2;
and
XDCT ð0Þ
0:7654
a. Determine xð0Þ.
b. Use the MATLAB function idct() to verify all the recovered data samples.
Solution:
a. Applying Equations (11.30) and (11.31), we have
520
CHAPTER 11 Waveform Quantization and Compression

xð0Þ
1
2
r 
Cð0ÞXDCT ð0Þ cos
p
8

þ Cð1ÞXDCT ð1Þ cos
3p
8

þ Cð2ÞXDCT ð2Þ cos
5p
8

þ Cð3ÞXDCT ð3Þ cos
7p
8

1
2
r "
2
p
2  20  cos
p
8

þ 1  ð 1:8478Þ  cos
3p
8

þ 1  2  cos
5p
8

þ 1  0:7654  cos
7p
8

10
b. With the MATLAB 1D inverse DCT function idct(), we obtain
>> idct([20
1.8478 2 0.7654])
ans
10.0000 8.0000 10.0000 12.0000
We verify that the input data samples are the same as those in Example 11.8.
In Example 11.9, we obtained an exact recovery of the input data from the DCT coefﬁcients,
since inﬁnite precision of each DCT coefﬁcient is preserved. However, in transform coding,
each DCT coefﬁcient is quantized using the number of bits per sample assigned by a bit alloca-
tion scheme. Usually the DC coefﬁcient requires a larger number of bits to encode, since it carries
more energy of the signal, while each AC coefﬁcient requires a smaller number of bits to enco-
de. Hence, the quantized DCT coefﬁcients approximate the DCT coefﬁcients in inﬁnite precision,
and the recovered input data with the quantized DCT coefﬁcients will certainly have quantization
errors.
EXAMPLE 11.10
Assuming the DCT coefﬁcients
XDCT ð0Þ
20; XDCT ð1Þ
1:8478; XDCT ð2Þ
2;
and
XDCT ð3Þ
0:7654
in inﬁnite precision, we recovered the exact data 10, 8, 10, and 12; this was veriﬁed in Example 11.9. If a bit
allocation scheme quantizes the DCT coefﬁcients using a scale factor of 4 in the form
XDCT ð0Þ
4  5
20; XDCT ð1Þ
4  ð
0Þ
0; XDCT ð2Þ
4  1
4;
and
XDCT ð3Þ
4  0
0
we can code the scale factor of 4 with 3 bits (magnitude bits only), the scaled DC coefﬁcient of 5 with 4 bits
(including a sign bit), and the scaled AC coefﬁcients of 0, 1, and 0 using 2 bits each. 13 bits in total are required.
Use the MATLAB function idct() to recover the input data samples.
Solution:
Using the MATLAB function idct() and the quantized DCT coefﬁcients, we obtain
>> idct([20 0 4 0])
ans
12 8 8 12
As we see, the original sample requires 5 bits (4 magnitude bits and 1 sign bit) to encode each of 10, 8, 10, and 12
for a total of 20 bits. Hence, 7 bits are saved for coding this data block using the DCT. We expect many more bits to
be saved in practice, in which a longer frame of the correlated data samples is used. However, quantization errors
are introduced.
11.4 Discrete Cosine Transform, Modiﬁed Discrete Cosine Transform
521

For comprehensive coverage of the topics on DCT, see Li and Drew (2004), Nelson (1992),
Saywood (2000), and Stearns (2003).
11.4.2 Modiﬁed Discrete Cosine Transform
In the previous section, we observed how a 1D-DCT is adopted for coding a block of data. When we
apply the 1D-DCT to audio coding, we ﬁrst divide the audio samples into blocks and then transform
each block of data with DCT. The DCT coefﬁcients for each block are quantized according to the bit
allocation scheme. However, when we decode DCT blocks, we encounter edge artifacts at boundaries
of the recovered DCT blocks, since DCT coding is block based. This effect of edge artifacts produces
periodic noise and is annoying in the decoded audio. To solve for such a problem, the windowed
MDCT has been developed (described in Pan, 1995; Princen and Bradley, 1986). The principles are
illustrated in Figure 11.14. As we shall see, the windowed MDCT is used in MPEG-1 MP3 audio
coding.
We describe and discuss only the main steps for coding data blocks using the windowed MDCT
(W-MDCT) based on Figure 11.14.
N
N
/ 2
N
/ 2
N
/ 2
N
A
B
C
A
B
A
B
50% overlap
with window h(n)
C
W MDCT
W MDCT
W MDCT
A_MDCT
B_MDCT
C_MDCT
A
A
B
B
C
W IMDCT
W IMDCT
W IMDCT
50% overlap
with window f(n)
50%
overlap
add
50%
overlap
add
50%
overlap
add
Recovered A Recovered BRecovered C
Encoding
stage
Decoding
stage
FIGURE 11.14
Modiﬁed discrete cosine transform (MDCT).
522
CHAPTER 11 Waveform Quantization and Compression

Encoding stage:
1. Divide the data samples into blocks that each have N (must be an even number) samples,
and further divide each block into two subblocks, each with N=2 samples for data overlap purposes.
2. Apply the window function for the overlapped blocks. As shown in Figure 11.14, if one block
contains the subblocks A and B, the next one would consist of subblocks B and C. The
subblock B is the overlapped block. This procedure continues. A window function hðnÞ is
applied to each block with N samples to reduce possible edge effects. Next, the W-MDCT is
applied. The W-MDCT is given by
XMDCTðkÞ ¼ 2
X
N
1
n ¼ 0
xðnÞhðnÞ cos
2p
N ðn þ 0:5 þ N=4Þðk þ 0:5Þ

for
k ¼ 0; 1; /; N=2  1
(11.32)
Note that we need to compute and encode only half of the MDCT coefﬁcients (since the other half
can be reconstructed based on the ﬁrst half of the MDCT coefﬁcients).
3. Quantize and encode the MDCT coefﬁcients.
Decoding stage:
1. Receive the N=2 MDCT coefﬁcients, and use Equation (11.33) to recover the second half of the
coefﬁcients:
XMDCTðkÞ ¼ ð  1Þ
N
2þ1XMDCTðN  1  kÞ;
for
k ¼ N=2; N=2 þ 1; /; N  1
(11.33)
2. Apply the windowed inverse MDCT (W-IMDCT) to each N MDCT coefﬁcient block using
Equation (11.34) and then apply a decoding window function fðnÞ to reduce the artifacts at the
block edges:
xðnÞ ¼ 1
N fðnÞ
X
N
1
k ¼ 0
XMDCTðkÞ cos
2p
N ðn þ 0:5 þ N=4Þðk þ 0:5Þ

for
n ¼ 0; 1; /; N  1
(11.34)
Note that the recovered sequence contains the overlap portion. As shown in Figure 11.14, if
a decoded block has the decoded subblocks A and B, the next one would have subblocks B and C,
where the subblock B is an overlapped block. The procedure continues.
3. Reconstruct the subblock B using the overlap and add operation, as shown in Figure 11.14, where
two subblocks labeled B are overlapped and added to generate the recovered subblock B. Note that
the ﬁrst subblock B comes from the recovered block with N samples containing A and B, while the
second subblock B belongs to the next recovered block with N samples consisting of B and C.
In order to obtain the perfect reconstruction, that is, the full cancellation of all aliasing introduced by
the MDCT, the following two conditions must be met for selecting the window functions, in which one
is used for encoding while the other is used for decoding (Princen and Bradley, 1986):
f

n þ N
2

h

n þ N
2

þ fðnÞhðnÞ ¼ 1
(11.35)
11.4 Discrete Cosine Transform, Modiﬁed Discrete Cosine Transform
523

f

n þ N
2

hðN  n  1Þ  fðnÞh
N
2  n  1

¼ 0
(11.36)
Here, we choose the following simple function for the W-MDCT:
fðnÞ ¼ hðnÞ ¼ sin
p
N ðn þ 0:5Þ

(11.37)
Equation (11.37) must satisfy the conditions described in Equations (11.35) and (11.36). This will be
left for an exercise in the Problems section at the end of this chapter. The MATLAB functions
wmdcth() and wimdctf() relate to this topic and are listed in Programs 11.14-11.5 in section (11.7).
Now, let us examine the W-MDCT in Example 11.11.
EXAMPLE 11.11
Given the data 1, 2,
3, 4, 5,
6, 4, 5 .,
a. determine the W MDCT coefﬁcients for the ﬁrst three blocks using a block size of 4;
b. determine the ﬁrst two overlapped subblocks, and compare the results with the original data sequence using
the W MDCT coefﬁcients in (a).
Solution:
a. We divided the ﬁrst two data blocks using the overlapping of 2 samples:
First data block: 1 2
3 4
Second data block
3 4 5
6
Third data block: 5
6 4 5
We apply the W MDCT to get
>> wmdct([1 2
3 4])
ans
1.1716 3.6569
>> wmdct([ 3 4 5
6])
ans
8.0000 7.1716
>> wmdct([5
6 4 5])
ans
4.6569
18.0711
b. The results from W IWDCT are as follows:
>> x1 wimdct([1.1716 3.6569])
x1
0.5607 1.3536
1.1465
0.4749
>> x2 wimdct([ 8.0000 7.1716])
x2
1.8536 4.4749 2.1464 0.8891
>> x3 wimdct([ 4.6569 18.0711])
x3
2.8536
6.8891 5.1820 2.1465
Applying the overlap and add, we have
>> [x1 0 0 0 0]þ [0 0 x2 0 0 ]þ [ 0 0 0 0 x3]
ans
0.5607 1.3536 3.0000 4.0000 5.0000
6.0000 5.1820 2.1465
The ﬁrst two recovered subblocks contain the values
3, 4, 5
6, which are consistent with the input data.
Figure 11.15 shows coding of speech data we.dat using the DCT transform and W-MDCT trans-
form. To be able to see the block edge artifacts, the following parameters are used for both DCT and
W-MDCT transform coding:
524
CHAPTER 11 Waveform Quantization and Compression

Speech data: 16-bits per sample, 8,000 samples per second
Block size: 16 samples
Scale factor: 2-bit nonlinear quantizer
Coefﬁcients: 3-bit linear quantizer
Note that we assume a lossless scheme will further compress the quantized scale factors and coefﬁ-
cients. This stage does not affect the simulation results.
We use a 2-bit nonlinear quantizer with four levels to select the scale factor so that the block
artifacts can be clearly displayed in Figure 11.15. We also apply a 3-bit linear quantizer to the scaled
coefﬁcients for both DCT and W-MDCT coding. As shown in Figure 11.15, the W-MDCT demon-
strates signiﬁcant improvement in smoothing out the block edge artifacts. The MATLAB simulation
code is given in Programs 11.14 to 11.16 in Section 11.7, where Program 11.6 is the main program.
11.4.3 Transform Coding in MPEG Audio
With the DCTand MDCT concepts developed, we now explore the MPEG audio data format, where the
DCT plays a key role. MPEG was established in 1988 to develop a standard for delivery of digital video
and audio. Since MPEG audio compression contains so many topics, we focus here on examining its
data format brieﬂy, using the basic concepts developed in this book. Readers can further explore this
subject by reading Pan’s (1995) tutorial on MPEG audio compression, as well as Li and Drew (2004).
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0
1
x 10
4
Or g na  s gna
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0
1
x 10
4
DCT cod ng
0
200
400
600
800
1000
1200
1400
1600
1800
2000
1
0
1
x 10
4
W-MDCT cod ng
Sample number
Block edge artifacts
FIGURE 11.15
Waveform coding using DCT and W-MDCT.
11.4 Discrete Cosine Transform, Modiﬁed Discrete Cosine Transform
525

Figure 11.16 shows the MPEG audio frame. First, the input PCM samples
with possible sampling
rates of 32 kHz, 44.1 kHz, and 48 kHz
are divided into 32 frequency subbands. All the subbands have
equal bandwidths. The sum of their bandwidths covers up to the folding frequency, that is, fs=2, which
is the Nyquist limit in the DSP system. The subband ﬁlters are designed to minimize aliasing in the
frequency domain. Each subband ﬁlter outputs one sample for every 32 input PCM samples contin-
uously, and forms a data segment for every 12 output samples. The purpose of the ﬁlter banks is to
separate the data into different frequency bands so that the psycho-acoustic model of the human
auditory system (Yost, 1994) can be applied to activate the bit allocation scheme for a particular
subband. The data frames are formed before quantization.
There are three types of data frames, as shown in Figure 11.16. Layer 1 contains 32 data segments,
each coming from one subband with 12 samples, so the total frame has 384 data samples. As we see,
layer 2 and layer 3 have the same size data frame, consisting of 96 data segments, where each ﬁlter
outputs 3 data segments of 12 samples. Hence, layer 2 and layer 3 each have 1,152 data samples.
Next, let us examine brieﬂy the content of each data frame, as show in Figure 11.17. Layer 1
contains 384 audio samples from 32 subbands, each having 12 samples. It begins with a header fol-
lowed by a cyclic redundancy check (CRC) code. The numbers within parentheses indicate the
possible number of bits to encode each ﬁeld. The bit allocation informs the decoder of the number of
bits used for each encoded sample in the speciﬁc band. Bit allocation can also be set to zero bits for
a particular subband if analysis of the psycho-acoustic model ﬁnds that the data in the band can be
discarded without affecting the audio quality. In this way, the encoder can achieve more data
compression. Each scale factor is encoded with 6 bits. The decoder will multiply the scale factor by the
decoded quantizer output to get the quantized subband value. Use of the scale factor allows for
utilization of the full range of the quantizer. The ﬁeld “ancillary data” is reserved for “extra”
information.
The layer 2 encoder takes 1,152 samples per frame, with each subband channel having 3 data
segments of 12 samples. These 3 data segments may have a bit allocation and up to to 3 scale factors.
PCM
samples
Subband filter 0
Subband filter 1
Subband filter 31
12
samples
12
samples
12
samples
12
samples
12
samples
12
samples
12
samples
12
samples
12
samples
Layer 1
frame
Layer 2 frame, layer 3 frame
FIGURE 11.16
MPEG audio frame.
526
CHAPTER 11 Waveform Quantization and Compression

Using one scale factor for 3 data segments would be called for when values of the scale factors per
subband are sufﬁciently close and the encoder applies temporal noise masking (a type of noise
masking by the human auditory system) to hide any distortion. In Figure 11.17, the ﬁeld “SCFSI”
(scale-factor selection information) contains the information to inform the decoder. A different scale
factor is used for each subband channel when avoidance of audible distortion is required. The bit
allocation can also provide a possible single compact code word to represent three consecutive
quantized values.
The layer 3 frame contains side information and main data that come from Huffman encoding
(lossless coding with an exact recovery) of the W-MDCT coefﬁcients to gain improvement over layer 1
and layer 2.
Figure 11.18 shows the MPEG-1 layer 1 and 2 encoder, and the layer 3 encoder. For MPEG-1 layer
1 and layer 2, the encoder examines the audio input samples using a 1,024-point fast Fourier transform
(FFT). The psycho-acoustic model is analyzed based on the FFT coefﬁcients. This includes possible
frequency masking (hiding noise in frequency domain) and noise temporal masking (hiding noise in
time domain). The result of the analysis of the psycho-acoustic model instructs the bit allocation
scheme.
The major difference in layer 3, called MP3 (the most popular format in the multimedia industry),
is that it adopts the MDCT. First, the encoder can gain further data compression by transforming the
data segments from each subband channel using DCT and then quantizing the DCT coefﬁcients,
which, again, are losslessly compressed using Huffman encoding. As shown in Examples 11.8 to
11.11, since the DCT uses block-based processing, it produces block edge effects, where the beginning
samples and ending samples show discontinuity and cause audible periodic noise. This periodic edge
noise can be alleviated, as discussed in the previous section, by using the W-MDCT, in which there is
50% overlap between successive transform windows.
There are two sizes of windows. One has 36 samples and other 12 samples used in MPEG-1 layer
3 (MP3) audio. The larger block length offers better frequency resolution for low-frequency tonelike
signals, hence it is used for the lowest two subbands. For the rest of the subbands, the shorter block is
used, since it allows better time resolution for noiselike transient signals. Other improvements of MP3
Header
(32)
CRC
(0,16)
Bit allocation
(128 256)
Scale factors
(0 384)
Samples
Ancillary
data
Header
(32)
CRC
(0,16)
Bit allocation
(26 256)
Scale factors
(0 1080)
Samples
Ancillary
data
SCFSI
(0 60)
Header
(32)
CRC
(0,16)
Side information
(136 256)
Main data; not necessary
linked to this frame.
Layer 1
Layer 2
Layer 3
(a)
(b)
(c)
FIGURE 11.17
MPEG audio frame formats.
11.4 Discrete Cosine Transform, Modiﬁed Discrete Cosine Transform
527

over layers 1 and 2 include use of the scale-factor band, where the W-MDCT coefﬁcients are
regrouped from the original 32 uniformly divided subbands into 25 actual critical bands based on
the human auditory system. Then the corresponding scale factors are assigned, and a nonlinear
quantizer is used.
Finally, Huffman coding is applied to the quantizer outputs to obtain more compression. Partic-
ularly in CD-quality audio, MP3 (MPEG-1 layer 3) can achieve CRs varying from 12:1 to 8:1, cor-
responding to bit rates from 128 kbps to 192 kbps. Besides the use of DCT in MP3, MPEG-2 audio
coding methods such as AC-2, AC-3, ATRAC, and PAC/MPAC also use W-MDCT coding. Readers
can further explore these subjects in Brandenburg (1997) and Li and Drew (2004).
11.5 LABORATORY EXAMPLES OF SIGNAL QUANTIZATION USING THE
TMS320C6713 DSK
Linear quantization can be implemented as shown in C Program 11.1. The program only demonstrates
left channel coding; right channel coding can be easily extended from the program. The program
consists of both an encoder and decoder. First, it converts the 16-bit 2’s complement data to the sign-
magnitude format with truncated magnitude bits as required. Then the decoder converts the
compressed PCM code back to the 16-bit data. The encoding and decoding are explained in
Example 11.12.
Layer 1, or layer 2
frame formatting
PCM
samples
Filter banks:
32 subbands
1024 point
FFT
Linear
quantizer
Psycho acoustic
model
Side information
coding
Bit stream
Non uniform
quantizer
PCM
samples
Filter banks:
32 subbands
1024 point
FFT
M DCT
Psychoaccoustic
model
Side information
coding
Bit stream
Huffman coding
Layer 3
frame formatting
Layer 1 and Layer 2
Layer 3
(a)
(b)
FIGURE 11.18
Encoder block diagrams for layers 1 and 2 and for layer 3.
528
CHAPTER 11 Waveform Quantization and Compression

EXAMPLE 11.12
Givena16 bitdatumlc
2050(decimal),convertittoa5 bitlinearPCMcodeusingtheinformationinProgram11.1.
Solution:
a. Encoding:
tmp
2050 (decimal)
0x0802 (hex)
0000 1000 0000 0010 (binary)
After shifting 11 bits, tmp
0x0001 (hex)
PCMcode
tmp&mask[5 1] 0x0001&0x000f 0x0001 (hex) // Get magnitude bits
if lc >0 {
PCMcode
PCMcode j sign[5 1] // Add positive sign bit
} // This line is not executed since lc < 0
PCMcode
00001 (binary)
b. Decoding:
dec
PCMcode & mask[4]
0x0001&0x000f 0x0001 (hex)
tmp
PCMcode&sign[4]
0x0001&0x0010 0x0000 (hex) (the number is negative)
dec
dec<<11 0x0800
dec
dec j rec[4] 0x0800j 0x0400 0x0C00 (hex) 3072 (decimal)
lc
3072 (recovered decimal)
As expected, the recovered PCM code is different from the original code, since a PCM is the lossy coding scheme.
The same procedure can be followed for coding a positive decimal number.
C Program 11.1. Encoding and decoding using the TMS320C6713 DSK.
int PCMcode;
/* Sign magnitude format: s magnitude bits, see Section 11.1, in Chapter 11 */
/* converta16 bitPCMcodea5 bitPCMcode,andrecoverthe5 bitPCMcodetothe16 bitPCMcode*/
// See the following example:
/* Convert a 16 bit sign magnitude code 5 bit PCM code 16 bit recovered sign magnitude code */
/* sADCDEFGHIJKLMNO
sABCDE
sABCD10000000000 */
/* Note that audio input/output data are in 2’s complement form */
/* For encoder, convert the 2’s complement input to the sign magnitude form before
quantization
*/
/* For decoder, convert the sign magnitude form to the 2’s complement output before DAC
*/
int nofbits 5; // specify the number of quantization bits
int sign[16] {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
0x100,0x200,0x400,0x800,0x1000,0x2000,0x4000,0x8000}; // add sign bit (MSB)
int mask[16] {0x0,0x01,0x03,0x07,0x0f,0x1f,0x3f,0x7f,
0xff,0x1ff,0x3ff,0x7ff,0xfff,0x1fff,0x3fff,0x7fff}; // mask for obtaining
magnitude bits
int rec[16] {0x4000,0x2000,0x1000,0x0800,
0x0400,0x0200,0x0100,0x0080,
0x0040,0x0020,0x0010,0x0008,
0x0004,0x0002,0x0001,0x0000};// the midpoint of the quantization interval
interrupt void c int11()
{
int lc; /*left channel input */
int rc; /*right channel input */
int lcnew; /*left channel output */
11.5 Laboratory Examples of Signal Quantization Using the Tms320C6713 DSK
529

int rcnew; /*right channel output */
int temp, dec;
//Left channel and right channel inputs
AIC23 data.combo input sample();
lc (int) (AIC23 data.channel[LEFT]);
rc
(int) (AIC23 data.channel[RIGHT]);
// Insert DSP algorithm below
/* Encoder :*/
tmp
lc; // for the Left Line In channel
if (tmp <0 )
{
tmp
tmp; // Get magnitude bits to work with
}
tmp
(tmp>>(16 nofbits));
PCMcode tmp&mask[nofbits 1]; // Get magnitude bits
if (lc> 0)
{
PCMcode
PCMcode j sign[nofbits 1]; // Add sign bit
}
/* PCM code (stored in the lower portion) */
/* Decoder: */
dec
PCMcode&mask[nofbits 1]; // Obtain magnitude bits
tmp
PCMcode&sign[nofbits 1]; // Obtain the sign bit
dec
(dec<<(16 nofbits)); // Scale to 15 bit magnitude
dec
dec j rec[nofbits 1]; // Recover the midpoint of the quantization interval
lc
dec;
if (tmp
0x00)
{
lc
dec; // Back to 2’s complement form (change the sign)
}
// End of the DSP algorithm
lcnew lc; /* Send to DAC */
rcnew lc; /* Keep the original data */
AIC23 data.channel[LEFT] (short) lcnew;
AIC23 data.channel[RIGHT] (short) rcnew;
output sample(AIC23 data.combo);
}
C Program 11.2 demonstrates digital m-law encoding and decoding. It converts a 12-bit linear PCM
code to an 8-bit compressed PCM code using the principles discussed in Section 11.2. Note that the
program only performs left-channel coding.
C Program 11.2. Digital m-law encoding and decoding.
int ulawcode;
/* Digital mu law definition*/
// Sign magnitude format: s segment quantization
// s
1 for the positive value, s
0 for the negative value
// Segment defines compression
// quantization with 16 levels
530
CHAPTER 11 Waveform Quantization and Compression

// See Section 11.2, Chapter 11
/* Segment
12 bit PCM
4 bit quantization interval */
/* 0
s0000000ABCD
s000ABCD
*/
/* 1
s0000001ABCD
s001ABCD
*/
/* 2
s000001ABCDX
s010ABCD
*/
/* 3
s00001ABCDXX
s011ABCD
*/
/* 4
s0001ABCDXXX
s100ABCD
*/
/* 5
s001ABCDXXXX
s101ABCD
*/
/* 6
s01ABCDXXXXX
s110ABCD
*/
/* 7
s1ABCDXXXXXX
s111ABCD
*/
//
/* Segment Recovered 12 bit PCM
*/
/* 0
s0000000ABCD
*/
/* 1
s0000001ABCD
*/
/* 2
s000001ABCD1
*/
/* 3
s00001ABCD10
*/
/* 4
s0001ABCD100
*/
/* 5
s001ABCD1000
*/
/* 6
s01ABCDq0000
*/
/* 7
s1ABCD100000
*/
/* Note that audio input/output data are in 2's complement form */
/* For encoder, convert the 2's complement form to the sign magnitude form before
quantization
*/
/* For decoder, convert the sign magnitude form to the 2's complement output before DAC
*/
interrupt void c int11()
{
int lc; /*left channel input */
int rc; /*right channel input */
int lcnew; /*left channel output */
int rcnew; /*right channel output */
int tmp,ulawcode, dec;
//Left channel and right channel inputs
AIC23 data.combo input sample();
lc (int) (AIC23 data.channel[LEFT]);
rc
(int) (AIC23 data.channel[RIGHT]);
// Insert DSP algorithm below
/* Encoder :*/
tmp
lc;
if (tmp <0 )
{ tmp
tmp; // Get magnitude bits to work with
}
tmp
(tmp>>4); // Linear scale down to 12 bits to use the u 255 law table
if( (tmp&0x07f0)
0x0) // Segment 0
{ ulawcode
(tmp&0x000f); }
if( (tmp&0x07f0)
0x0010) // Segment 1
{ ulawcode
(tmp&0x00f);
ulawcode
ulawcode j 0x10; }
if( (tmp&0x07E0)
0x0020) // Segment 2
11.5 Laboratory Examples of Signal Quantization Using the Tms320C6713 DSK
531

{ ulawcode
(tmp&0x001f)>>1;
ulawcode
ulawcode j0x20; }
if( (tmp&0x07c0)
0x0040) // Segment 3
{ ulawcode
(tmp&0x003f)>>2;
ulawcode
ulawcode j 0x30; }
if( (tmp&0x0780)
0x0080) // Segment 4
{ ulawcode
(tmp&0x007f)>>3;
ulawcode
ulawcode j 0x40;}
if( (tmp&0x0700)
0x0100) // Segment 5
{ ulawcode
(tmp&0x00ff)>>4;
ulawcode
ulawcode j 0x50;}
if( (tmp&0x0600)
0x0200) // Segment 6
{ ulawcode
(tmp&0x01ff)>>5;
ulawcode
ulawcode j 0x60; }
if( (tmp&0x0400)
0x0400) // Segment 7
{ ulawcode
(tmp&0x03ff)>>6;
ulawcode ulawcode j 0x70; }
if (lc> 0)
{
ulawcode
ulawcodej0x80;
}
/* u law code (8 bit compressed PCM code) for transmission and storage */
/* Decoder: */
tmp
ulawcode&0x7f;
tmp
(tmp>>4);
if ( tmp
0x0) // Segment 0
{ dec
ulawcode&0xf; }
if ( tmp
0x1) // Segment 1
{ dec
ulawcode&0xf j 0x10; }
if ( tmp
0x2) // Segment 2
{ dec
((ulawcode&0xf)<<1) j 0x20;
dec
dec j0x01; }
if ( tmp
0x3) // Segment 3
{ dec
((ulawcode&0xf)<<2) j 0x40;
dec
decj0x02; }
if ( tmp
0x4) // Segment 4
{ dec
((ulawcode&0xf)<<3) j 0x80;
dec
decj0x04; }
if ( tmp
0x5) // Segment 5
{ dec
((ulawcode&0xf)<<4) j 0x0100;
dec
decj0x08; }
if ( tmp
0x6) // Segment 6
{ dec
((ulawcode&0xf)<<5) j 0x0200;
dec
decj0x10; }
if ( tmp
0x7) // Segment 7
{ dec
((ulawcode&0xf)<<6) j 0x0400;
dec
dec j0x20; }
tmp
ulawcode & 0x80;
532
CHAPTER 11 Waveform Quantization and Compression

lc
dec;
if (tmp
0x00)
{ lc
dec; // Back to 2’s complement form
}
lc
(lc<<4); // Linear scale up to 16 bits
// End of the DSP algorithm
lcnew lc; /* Send to DAC */
rcnew lc; /* Keep the original data */
AIC23 data.channel[LEFT] (short) lcnew;
AIC23 data.channel[RIGHT] (short) rcnew;
output sample(AIC23 data.combo);
}
11.6 SUMMARY
1. The linear midtread quantizer used in PCM coding has an odd number of quantization levels, that
is, 2n  1. It accommodates the same decoded magnitude range for quantizing the positive and
negative voltages.
2. Analog and digital m-law compression improve coding efﬁciency. 8-bit m-law compression
of speech is equivalent to 12-bit linear PCM coding, with no difference in sound quality.
These methods are widely used in the telecommunications industry and in multimedia system
applications.
3. DPCM encodes the difference between the input sample and predicted sample using a predictor to
achieve coding efﬁciency.
4. DM coding is essentially a 1-bit DPCM.
5. ADPCM is similar to DPCM except that the predictor transfer function has six zeros and two poles
and is an adaptive ﬁlter. ADPCM is superior to 8-bit m-law compression, since it provides the same
sound quality with only 4 bits per code.
6. Data compression performance is measured in terms of the data compression ratio and the
bit rate.
7. The DCT decomposes a block of data to the DC coefﬁcient (average) and AC coefﬁcients
(ﬂuctuation) so that different numbers of bits are assigned to encode DC coefﬁcients and AC
coefﬁcients to achieve data compression.
8. W-MDCT alleviates the block effects introduced by the DCT.
9. MPEG-1 audio formats such as MP3 (MPEG-1, layer 3) include W-MDCT, ﬁlter banks, a psycho-
acoustic model, bit allocation, a nonlinear quantizer, and Huffman lossless coding.
11.7 MATLAB PROGRAMS
Program 11.1 MATLAB program for the linear midtread quantizer.
clear all;close all
disp(’load speech: We’);
load we.dat;
% Provided by your instructor
sig
we;
11.7 MATLAB Programs
533

lg length(sig);
% Length of the speech data
t [0:1:lg 1];
% Time index
sig 5*sig/max(abs(sig));
% Normalized signal to the range between
5 to 5
Emax
max(abs(sig));
Erms
sqrt( sum(sig .* sig) / length(sig))
k Erms/Emax
disp(’20*log10(k) >’);
k
20*log10(k)
bits
input(’input number of bits
>’);
lg
length(sig);
% Encoding
for x 1:lg
[indx(x) qy]
mtrdenc(bits, 5, sig(x));
end
disp(’Finished and transmitted’);
% Decoding
for x 1:lg
qsig(x)
mtrddec(bits, 5, indx(x));
end
disp(’decoding ﬁnished’);
qerr
sig qsig;
% Calculate quantization errors
subplot(3,1,1);plot(t, sig);grid
ylabel(’Speech’);axis([0 length(we)
5 5]);
subplot(3,1,2);plot(t, qsig);grid
ylabel(’Quantized speech’);axis([0 length(we)
5 5]);
subplot(3,1,3);plot(qerr);grid
axis([0 length(we)
0.5 0.5]);
ylabel(’Qunatized error’);xlabel(’Sample number’);
disp(’signal to noise ratio due to quantization noise’)
snr(sig,qsig);
% Calculate signal to noise ratio due to quantization
Program 11.2. MATLAB program for m-law encoding and decoding.
close all; clear all
disp(’load speech ﬁle’);
load we.dat;
% Provided by your instructor
lg length(we);
% Length of the speech data
we 5*we/max(abs(we));
% Normalize the speech data
we nor we/max(abs(we));
% Normalization
t [0:1:lg 1];
% Time index
disp(’mulaw companding’)
mu input(’input mu
>’);
for x 1:lg
ymu(x)
mulaw(we nor(x),1,mu);
end
disp(’ﬁnished mu law companding’);
disp(’start to quantization’)
bits
input(’input bits >’);
% Midtread quantization and encoding
534
CHAPTER 11 Waveform Quantization and Compression

for x 1:lg
[indx(x) qy]
mtrdenc(bits, 1, ymu(x));
end
disp(’ﬁnished and transmitted’);
%
% Midtread decoding
for x 1:lg
qymu(x)
mtrddec(bits, 1, indx(x));
end
disp(’expander’);
for x 1:lg
dymu(x)
muexpand(qymu(x),1,mu)*5;
end
disp(’ﬁnished’)
qerr
dymu we; % Quantization error
subplot(3,1,1);plot(we);grid
ylabel(’Speech’);axis([0 length(we)
5 5]);
subplot(3,1,2);plot(dymu);grid
ylabel(’recovered speech’);axis([0 length(we)
5 5]);
subplot(3,1,3);plot(qerr);grid
ylabel(’Quantized error’);xlabel(’Sample number’);
axis([0 length(we)
1 1]);
snr(we,dymu);
% Calculate signal to noise ratio due to quantization
Program 11.3. MATLAB function for m-law companding.
Function qvalue
mulaw(vin, vmax, mu)
% This function performs mu law companding
% Usage:
% function qvalue
mulaw(vin, vmax, mu)
% vin
input value
% vmax
input value
% mu
parameter for controlling the degree of compression which must be the same
% qvalue
output value from the mu law compander
% as the mu law expander
%
vin
vin/vmax;
% Normalization
% mu law companding formula
qvalue
vmax*sign(vin)*log(1þmu*abs(vin))/log(1þmu);
Program 11.4. MATLAB program for m-law expanding.
function rvalue
muexpand(y,vmax, mu)
% This function performs mu law exoanding
% Usage:
% function rvalue
muexpand(y,vmax, mu)
% y
input signal
% vmax
maximum amplitude
% mu
parameter for controlling the degree of compression, which must be the same
% as the mu law compander
11.7 MATLAB Programs
535

% rvalue
output value from the mu law expander
%
y y/vmax;
% Normalization
% mu law expanding
rvalue sign(y)*(vmax/mu)*((1þmu)^abs(y)
1);
Program 11.5. MATLAB function for midread quantizer encoding.
function [indx, pq ]
mtrdenc(NoBits,Xmax,value)
% function pq
mtrdenc(NoBits, Xmax, value)
% This routine is created for simulation of midtread uniform quantizer.
%
% NoBits: number of bits used in quantization.
% Xmax: overload value.
% value: input to be quantized.
% pq: output of quantized value
% indx: integer index
%
% Note: the midtread method is used in this quantizer.
%
if NoBits
0
pq
0;
indx 0;
else
delta
2*abs(Xmax)/(2^NoBits 1);
Xrmax delta*(2^NoBits/2 1);
if abs(value) >
Xrmax
tmp
Xrmax;
else
tmp
abs(value);
end
indx round(tmp/delta);
pq
indx*delta;
if value < 0
pq
pq;
indx
indx;
end
end
Program 11.6. MATLAB function for midtread quantizer decoding.
function pq
mtrddec(NoBits,Xmax,indx)
% function pq
mtrddec(NoBits, Xmax, value)
% This routine is the dequantizer.
%
% NoBits: number of bits used in quantization.
% Xmax: overload value.
% pq: output of quantized value
% indx: integer index
%
536
CHAPTER 11 Waveform Quantization and Compression

% Note: the midtread method is used in this quantizer.
%
delta
2*abs(Xmax)/(2^NoBits 1);
pq
indx*delta;
Program 11.7. MATLAB function for calculation of signal to quantization noise ratio (SNR).
function snr
calcsnr(speech, qspeech)
% function snr
calcsnr(speech, qspeech)
% This routine was created for calculation of SNR.
%
% speech: original speech waveform.
% qspeech: quantized speech.
% snr: output SNR in dB.
%
% Note: the midrise method is used in this quantizer.
%
qerr
speech qspeech;
snr
10*log10(sum(speech.*speech)/sum(qerr.*qerr))
Program 11.8. Main program for digital m-law encoding and decoding.
load we12b.dat
for i 1:1:length(we12b)
code8b(i) dmuenc(12, we12b(i));
% Encoding
qwe12b(i) dmudec(code8b(i));
% Decoding
end
subplot(4,1,1),plot(we12b);grid
ylabel(’a’);axis([0 length(we12b)
1024 1024]);
subplot(4,1,2),plot(code8b);grid
ylabel(’b’);axis([0 length(we12b)
128 128]);
subplot(4,1,3),plot(qwe12b);grid
ylabel(’c’);axis([0 length(we12b)
1024 1024]);
subplot(4,1,4),plot(qwe12b we12b);grid
ylabel(’d’);xlabel(’Sample number’);axis([0 length(we12b)
40 40]);
Program 11.9. The digital m-law compressor.
function [cmp code ]
dmuenc(NoBits, value)
% This routine is created for simulation of 12 bit mu law compression.
% function [cmp code ]
dmuenc(NoBits, value)
% NoBits
number of bits for the data
% value
input value
% cmp code
output code
%
scale
NoBits 12;
value value*2^( scale); % Scale to 12 bit
if (abs(value) > 0) & (abs(value)<16)
cmp code value;
end
if (abs(value) > 16) & (abs(value)<32)
11.7 MATLAB Programs
537

cmp code sgn(value)*(16þfix(abs(value) 16));
end
if (abs(value) > 32) & (abs(value)<64)
cmp code sgn(value)*(32þfix((abs(value)
32)/2));
end
if (abs(value) > 64) & (abs(value)<128)
cmp code sgn(value)*(48þfix((abs(value)
64)/4));
end
if (abs(value) > 128) & (abs(value)<256)
cmp code sgn(value)*(64þfix((abs(value)
128)/8));
end
if (abs(value) > 256) & (abs(value)<512)
cmp code sgn(value)*(80þfix((abs(value)
256)/16));
end
if (abs(value) > 512) & (abs(value)<1024)
cmp code sgn(value)*(96þfix((abs(value)
512)/32));
end
if (abs(value) > 1024) & (abs(value)<2048)
cmp code sgn(value)*(112þfix((abs(value)
1024)/64));
end
Program 11.10. The digital m-law expander.
function [value ]
dmudec(cmp code)
% This routine is created for simulation of 12 bit mu law decoding.
% Usage:
% unction [value ]
dmudec(cmp code)
% cmp code
input mu law encoded code
% value
recovered output value
%
if (abs(cmp code) > 0) & (abs(cmp code)<16)
value cmp code;
end
if (abs(cmp code) > 16) & (abs(cmp code)<32)
value sgn(cmp code)*(16þ(abs(cmp code) 16));
end
if (abs(cmp code) > 32) & (abs(cmp code)<48)
value sgn(cmp code)*(32þ(abs(cmp code) 32)*2þ1);
end
if (abs(cmp code) > 48) & (abs(cmp code)<64)
value sgn(cmp code)*(64þ(abs(cmp code) 48)*4þ2);
end
if (abs(cmp code) > 64) & (abs(cmp code)<80)
value sgn(cmp code)*(128þ(abs(cmp code) 64)*8þ4);
end
if (abs(cmp code) > 80) & (abs(cmp code)<96)
value sgn(cmp code)*(256þ(abs(cmp code) 80)*16þ8);
end
if (abs(cmp code) > 96) & (abs(cmp code)<112)
538
CHAPTER 11 Waveform Quantization and Compression

value sgn(cmp code)*(512þ(abs(cmp code) 96)*32þ16);
end
if (abs(cmp code) > 112) & (abs(cmp code)<128)
value sgn(cmp code)*(1024þ(abs(cmp code) 112)*64þ32);
end
Program 11.11. Main program for ADPCM coding.
% This program is written for offline simulation.
% file: adpcm.m
clear all; close all
load we.dat
% Provided by the instructor
speech we;
desig
speech;
lg length(desig);
% Length of speech data
enc
adpcmenc(desig);
% ADPCM encoding
%ADPCM finished
dec
adpcmdec(enc);
% ADPCM decoding
snrvalue
snr(desig,dec)
% Calculate signal to noise ratio due to quantization
subplot(3,1,1);plot(desig);grid;
ylabel(’Speech’);axis([0 length(we)
8000 8000]);
subplot(3,1,2);plot(dec);grid;
ylabel(’Quantized speech’);axis([0 length(we)
8000 8000]);
subplot(3,1,3);plot(desig dec);grid
ylabel(’Quantized error’);xlabel(’Sample number’);
axis([0 length(we)
1200 1200]);
Program 11.12. MATLAB function for ADPCM encoding.
function iiout
adpcmenc(input)
% This function performs ADPCM encoding.
% function iiout
adpcmenc(input)
% Usage:
% input
input value
% iiout
output index
%
% Quantization tables
fitable
[0 0 0 1 1 1 1 3 7];
witable
[ 0.75 1.13 2.56 4.00 7.00 12.38 22.19 70.13 ];
qtable
[
0.98 0.62 1.38 1.91 2.34 2.72 3.12 ];
invqtable
[0.031 1.05 1.66 2.13 2.52 2.91 3.32 ];
lgth
length(input);
sr
zeros(1,2); pk
zeros(1,2);
a
zeros(1,2); b
zeros(1,6);
dq
zeros(1,6); ii
zeros(1,lgth);
y 0; ap
0; al
0; yu 0; yl
0; dms
0; dml
0; tr
0; td
0;
for k
1:lgth
sl
input(k);
%
% predict zeros
11.7 MATLAB Programs
539

%
sez
b(1)*dq(1);
for i 2:6
sez
sez þ b(i)*dq(i);
end
se
a(1)*sr(1)þa(2)*sr(2)þ sez;
d
sl
se;
%
% Perform quantization
%
dqq
log10(abs(d))/log10(2.0) y;
ik
0;
for i 1:7
if dqq > qtable(i)
ik
i;
end
end
if d < 0
ik
ik;
end
ii(k)
ik;
yu
(31.0/32.0)*y þ witable(abs(ik)þ1)/32.0;
if yu > 10.0
yu
10.0;
end
if yu < 1.06
yu
1.06;
end
yl
(63.0/64.0)*ylþyu/64.0;
%
%Inverse quantization
%
if ik
0
dqq
2^( y);
else
dqq
2^(invqtable(abs(ik))þy);
end
if ik < 0
dqq
dqq;
end
srr
se þ dqq;
dqsez
srrþsez se;
%
% Update state
%
pk1
dqsez;
%
% Obtain adaptive predictor coefficients
540
CHAPTER 11 Waveform Quantization and Compression

%
if tr
1
a
zeros(1,2); b
zeros(1,6);
tr
0;
td
0; % Set for the time being
else
% Update predictor poles
% Update a2 first
a2p
(127.0/128.0)*a(2);
if abs(a(1)) <
0.5
fa1
4.0*a(1);
else
fa1
2.0*sgn(a(1));
end
a2p a2pþ(sign(pk1)*sgn(pk(1)) fa1*sign(pk1)*sgn(pk(2)))/128.0;
if abs(a2p) > 0.75
a2p
0.75*sgn(a2p);
end
a(2)
a2p;
%
% Update a1
a1p
(255.0/256.0)*a(1);
a1p
a1p þ 3.0*sign(pk1)*sgn(pk(2))/256.0;
if abs(a1p) > 15.0/16.0 a2p
a1p
15.0/16.0
a2p;
end
a(1)
a1p;
%
% Update b coefficients
%
for i
1:6
b(i)
(255.0/256.0)*b(i)þsign(dqq)*sgn(dq(i))/128.0; % see Program 11.17 for sgn().
end
if a2p <
0.7185
td
1;
else
td
0;
end
if a2p <
0.7185 & abs(dq(6)) > 24.0*2^(yl)
tr
1;
else
tr
0;
end
for i 6: 1:2
dq(i)
dq(i 1);
end
dq(1)
dqq; pk(2)
pk(1); pk(1)
pk1; sr(2)
sr(1); sr(1)
srr;
%
11.7 MATLAB Programs
541

% Adaptive speed control
%
dms
(31.0/32.0)*dms; dms
dms þ fitable(abs(ik)þ1)/32.0;
dml
(127.0/128.0)*dml; dml
dml þ fitable(abs(ik)þ1)/128.0;
if ap > 1.0
al
1.0;
else
al
ap;
end
ap
(15.0/16.0)*ap;
if abs(dms dml) >
dml/8.0
ap
ap þ 1/8.0;
end
if y < 3
ap
ap þ1/8.0;
end
if td
1
ap
ap þ 1/8.0;
end
if tr
1
ap
1.0;
end
y
al*yu þ (1.0 al)*yl;
end
end
iiout
ii;v
Program 11.13. MATLAB function for ADPCM decoding.
function iiout
adpcmdec(ii)
% This function performs ADPCM decoding.
% function iiout
adpcmdec(ii)
% Usage:
% ii
input ADPCM index
% iiout
decoded output value
%
% Quantization tables:
fitable
[0 0 0 1 1 1 1 3 7];
witable
[ 0.75 1.13 2.56 4.00 7.00 12.38 22.19 70.13 ];
qtable
[
0.98 0.62 1.38 1.91 2.34 2.72 3.12 ];
invqtable
[0.031 1.05 1.66 2.13 2.52 2.91 3.32 ];
lgth
length(ii);
sr
zeros(1,2); pk
zeros(1,2);
a
zeros(1,2); b
zeros(1,6);
dq
zeros(1,6); out
zeros(1,lgth);
y 0; ap
0; al
0; yu 0; yl
0; dms
0; dml
0; tr
0; td
0;
for k
1:lgth
%
sez
b(1)*dq(1);
542
CHAPTER 11 Waveform Quantization and Compression

for i 2:6
sez
sez þ b(i)*dq(i);
end
se
a(1)*sr(1)þa(2)*sr(2)þ sez;
%
% Inverse quantization
%
ik
ii(k);
yu
(31.0/32.0)*y þ witable(abs(ik)þ1)/32.0;
if yu > 10.0
yu
10.0;
end
if yu < 1.06
yu
1.06;
end
yl
(63.0/64.0)*ylþyu/64.0;
if ik
0
dqq
2^( y);
else
dqq
2^(invqtable(abs(ik))þy);
end
if ik < 0
dqq
dqq;
end
srr
se þ dqq;
dqsez
srrþsez se;
out(k)
srr;
%
% Update state
%
pk1
dqsez;
%
% Obtain adaptive predictor coefficients
%
if tr
1
a
zeros(1,2);
b
zeros(1,6);
tr
0;
td
0; % Set for the time being
else
% Update predictor poles
% Update a2 first
a2p
(127.0/128.0)*a(2);
if abs(a(1)) <
0.5
fa1
4.0*a(1);
else
fa1
2.0*sgn(a(1));
end
11.7 MATLAB Programs
543

a2p a2pþ(sign(pk1)*sgn(pk(1)) fa1*sign(pk1)*sgn(pk(2)))/128.0;
if abs(a2p) > 0.75
a2p
0.75*sgn(a2p);
end
a(2)
a2p;
%
% Update a1
a1p
(255.0/256.0)*a(1);
a1p
a1p þ 3.0*sign(pk1)*sgn(pk(2))/256.0;
if abs(a1p) > 15.0/16.0 a2p
a1p
15.0/16.0 a2p;
end
a(1)
a1p;
%
% Update b coefficients
%
for i
1: 6
b(i)
(255.0/256.0)*b(i)þsign(dqq)*sgn(dq(i))/128.0;
end
if a2p <
0.7185
td
1;
else
td
0;
end
if a2p <
0.7185 & abs(dq(6)) > 24.0*2^(yl)
tr
1;
else
tr
0;
end
for i 6: 1:2
dq(i)
dq(i 1);
end
dq(1)
dqq; pk(2)
pk(1); pk(1)
pk1; sr(2)
sr(1); sr(1)
srr;
%
% Adaptive speed control
%
dms
(31.0/32.0)*dms;
dms
dms þ fitable(abs(ik)þ1)/32.0;
dml
(127.0/128.0)*dml;
dml
dml þ fitable(abs(ik)þ1)/128.0;
if ap > 1.0
al
1.0;
else
al
ap;
end
ap
(15.0/16.0)*ap;
if abs(dms dml) >
dml/8.0
ap
ap þ 1/8.0;
544
CHAPTER 11 Waveform Quantization and Compression

end
if y < 3
ap
ap þ1/8.0;
end
if td
1
ap
ap þ 1/8.0;
end
if tr
1
ap
1.0;
end
y
al*yu þ (1.0 al)*yl;
end
end
iiout
out;
Program 11.14. W-MDCT function.
function [ tdac coef ]
wmdct(ipsig)
%
% This function transforms the signal vector using the W MDCT.
% Usage:
% ipsig: input signal block of N samples (N even number)
% tdac coe: W MDCT coefficents (N/2 coefficients)
%
N
length(ipsig);
NN
N;
for i 1:NN
h(i)
sin((pi/NN)*(i 1þ0.5));
end
for k 1:N/2
tdac coef(k)
0.0;
for n 1:N
tdac coef(k)
tdac coef(k) þ .
h(n)*ipsig(n)*cos((2*pi/N)*(k 1þ0.5)*(n 1þ0.5þN/4));
end
end
tdac coef 2*tdac coef;
Program 11.15. Inverse W-IMDCT function.
function [ opsig ]
wimdct(tdac coef)
%
% This function transforms the W MDCT coefficients back to the signal.
% Usage:
% tdac coeff: N/2 W MDCT coeffcients
% opsig: output signal black with N samples
%
N
length(tdac coef);
tmp coef
(( 1)^(Nþ1))*tdac coef(N: 1:1);
tdac coef
[ tdac coef tmp coef];
11.7 MATLAB Programs
545

N
length(tdac coef);
NN
N;
for i 1:NN
f(i)
sin((pi/NN)*(i 1þ0.5));
end
for n 1:N
opsig(n)
0.0;
for k 1:N
opsig(n)
opsig(n) þ .
tdac coef(k)*cos((2*pi/N)*(k 1þ0.5)*(n 1þ0.5þN/4));
end
opsig(n)
opsig(n)*f(n)/N;
end
Program 11.16. Waveform coding using DCT and W-MDCT.
% Waveform coding using DCT and MDCT for a block size of 16 samples.
% Main program
close all; clear all
load we.dat
% Provided by the instructor
% Create a simple 3 bit scale fcator
scalef4bits [1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768];
scalef3bits [256 512 1024 2048 4096 8192 16384 32768];
scalef2bits [4096 8192 16384 32768];
scalef1bit [16384 32768];
scalef scalef1bit;
nbits
3;
% Ensure the block size to be 16 samples.
x [we zeros(1,16 mod(length(we),16))];
Nblock length(x)/16;
DCT code []; scale code [];
% DCT transform coding
% Encoder
for i 1:Nblock
xblock DCT dct(x((i 1)*16þ1:i*16));
diff abs(scalef (max(abs(xblock DCT))));
iscale(i) min(find(diff< min(diff))); % find a scale factor
xblock DCT xblock DCT/scalef(iscale(i)); % scale the input vector
for j 1:16
[DCT coeff(j) pp] biquant(nbits, 1,1,xblock DCT(j));
end
DCT code [DCT code DCT coeff ];
end
% Decoder
Nblock length(DCT code)/16;
xx [];
for i 1:Nblock
DCT coefR DCT code((i 1)*16þ1:i*16);
for j 1:16
546
CHAPTER 11 Waveform Quantization and Compression

xrblock DCT(j) biqtdec(nbits, 1,1,DCT coefR(j));
end
xrblock idct(xrblock DCT.*scalef(iscale(i)));
xx [xx xrblock];
end
% Transform coding using MDCT
xm [zeros(1,8) we zeros(1,8 mod(length(we),8)), zeros(1,8)];
Nsubblock length(x)/8;
MDCT code [];
% Encoder
for i 1:Nsubblock
xsubblock DCT wmdct(xm((i 1)*8þ1:(iþ1)*8));
diff abs(scalef max(abs(xsubblock DCT)));
iscale(i) min(find(diff< min(diff))); % find a scale factor
xsubblock DCT xsubblock DCT/scalef(iscale(i)); % scale the input vector
for j 1:8
[MDCT coeff(j) pp] biquant(nbits, 1,1,xsubblock DCT(j));
end
MDCT code [MDCT code MDCT coeff];
end
% Decoder
% Recover the first subblock
Nsubblock length(MDCT code)/8;
xxm [];
MDCT coeffR MDCT code(1:8);
for j 1:8
xmrblock DCT(j) biqtdec(nbits, 1,1,MDCT coeffR(j));
end
xmrblock wimdct(xmrblock DCT*scalef(iscale(1)));
xxr pre xmrblock(9:16) % recovered first block for overlap and add
for i 2:Nsubblock
MDCT coeffR MDCT code((i 1)*8þ1:i*8);
for j 1:8
xmrblock DCT(j) biqtdec(nbits, 1,1,MDCT coeffR(j));
end
xmrblock wimdct(xmrblock DCT*scalef(iscale(i)));
xxr cur xxr preþxmrblock(1:8); % overlap and add
xxm [xxm xxr cur];
xxr pre xmrblock(9:16);
% set for the next overlap
end
subplot(3,1,1);plot(x,’k’);grid; axis([0 length(x)
10000 10000])
ylabel(’Original signal’);
subplot(3,1,2);plot(xx,’k’);grid;axis([0 length(xx)
10000 10000]);
ylabel(’DCT coding’)
subplot(3,1,3);plot(xxm,’k’);grid;axis([0 length(xxm)
10000 10000]);
ylabel(’W MDCT coding’);
xlabel(’Sample number’);
11.7 MATLAB Programs
547

Program 11.17. Sign function.
function sgn
sgn(sgninp)
%
% Sign function
% if signp > 0 then sign 1
% else sign
1
%
if sgninp >
0
opt
1;
else
opt
1;
end
sgn
opt;
11.8 PROBLEMS
11.1. For the 3-bit midtread quantizer described in Figure 11.1, and an analog signal range
from 2.5 to 2.5 volts, determine
a. the quantization step size;
b. the binary codes, recovered voltages, and quantization errors when each input is 1.6 volts
and 0.2 volt.
11.2. For the 3-bit midtread quantizer described in Figure 11.1, and an analog signal range
from 4 to 4 volts, determine
a. the quantization step size;
b. the binary codes, recovered voltages, and quantization errors when each input
is 2.6 volts and 0.1 volt.
11.3. For the 3-bit midtread quantizer described in Figure 11.1, and an analog signal range
from 5 to 5 volts, determine
a. the quantization step size;
b. the binary codes, recovered voltages, and quantization errors when each input is 2.6
volts and 3.5 volts.
11.4. For the 3-bit midtread quantizer described in Figure 11.1, and an analog signal range
from 10 to 10 volts, determine
a. the quantization step size;
b. the binary codes, recovered voltages, and quantization errors when each input is 5
volts, 0 volts, and 7.2 volts.
11.5. For the m-law compression and expanding process shown in Figure 11.3 with m ¼ 255,
a 3-bit midtread quantizer described in Figure 11.1, and an analog signal range from 2.5
to 2.5 volts, determine the binary codes, recovered voltages, and quantization errors when
each input is 1.6 volts and 0.2 volt.
548
CHAPTER 11 Waveform Quantization and Compression

11.6. For the m-law compression and expanding process shown in Figure 11.3 with m ¼ 255,
a 3-bit midtread quantizer described in Figure 11.1, and an analog signal range from 4 to
4 volts, determine the binary codes, recovered voltages, and quantization errors when each
input is 2.6 volts and 0.1 volt.
11.7. For the m-law compression and expanding process shown in Figure 11.3 with m ¼ 255,
a 3-bit midtread quantizer described in Figure 11.1, and an analog signal range from 5 to
5 volts, determine the binary codes, recovered voltages, and quantization errors when each
input is 2.6 volts and 3.5 volts.
11.8. For the m-law compression and expanding process shown in Figure 11.3 with m ¼ 255, a
3-bit midtread quantizer described in Figure 11.1, and an analog signal range from 10 to
10 volts, determine the binary codes, recovered voltages, and quantization errors when each
input is 5, 0, and 7.2 volts.
11.9. In a digital companding system, encode each of the following 12-bit linear PCM codes into
8-bit compressed PCM code:
a. 0 0 0 0 0 0 0 1 0 1 0 1
b. 1 0 1 0 1 1 1 0 1 0 1 0
11.10. In a digital companding system, decode each of the following 8-bit compressed PCM codes
into 12-bit linear PCM code:
a. 0 0 0 0 0 1 1 1
b. 1 1 1 0 1 0 0 1
11.11. In a digital companding system, encode each of the following 12-linear PCM codes into the
8-bit compressed PCM code:
a. 0 0 1 0 1 0 1 0 1 0 1 0
b. 1 0 0 0 0 0 0 0 1 1 0 1
11.12. In a digital companding system, decode each of the following 8-bit compressed PCM codes
into the 12-bit linear PCM code:
a. 0 0 1 0 1 1 0 1
b. 1 0 0 0 0 1 0 1
11.13. Consider a 3-bit DPCM encoding system with the following speciﬁcations (Figure 11.19):
Encoder scheme : ~xðnÞ ¼ ^xðn  1Þ ðpredictorÞ
dðnÞ ¼ xðnÞ  ~xðnÞ
dq

n

¼ Q½dðnÞ ¼ quantizer in Table 11:9
^x

n

¼ ~x

n

þ dq

n

5-bit input data: xð0Þ ¼ 6, xð1Þ ¼ 8,
and
xð2Þ ¼ 13
Perform DPCM encoding to produce the binary code for each input data.
11.7 MATLAB Programs
549

11.14. Consider a 3-bit DPCM decoding system with the following speciﬁcations (Figure 11.20):
Decoding scheme : ~xðnÞ ¼ ^xðn  1Þ ðpredictorÞ
dq

n

¼ quantizer in Table 11:9
^x

n

¼ ~x

n

þ dq

n

Three received binary codes: 110, 100, 101
Perform DCPM decoding to recover each digital value using its binary code.
Table 11.9
FIGURE 11.19
DPCM encoding in Problem 11.13.
Table 11.9 Quantization Table for the 3-bit Quantizer in Problem 11.13
Binary Code
Quantization Value dqðnÞ
Subrange in dðnÞ
0 1 1
0 1 0
0 0 1
0 0 0
1 0 0
1 0 1
1 1 0
1 1 1
11
5
2
0
0
2
5
11
15  dðnÞ <
7
7  dðnÞ <
3
3  dðnÞ <
1
1  dðnÞ < 0
0  dðnÞ  1
1 < dðnÞ  3
3 < dðnÞ  7
7 < dðnÞ  15
Table 11.9
FIGURE 11.20
DPCM decoding in Problem 11.14.
550
CHAPTER 11 Waveform Quantization and Compression

11.15. For a 3-bit DPCM encoding system shown in Problem 11.13 and the given 5-bit input data
xð0Þ ¼ 6, xð1Þ ¼ 8, and xð2Þ ¼ 13, perform DPCM encoding to produce the binary code
for each of input data.
11.16. For the 3-bit DPCM decoding system shown in Problem 11.14 and the received data 010,
000, 001, perform DCPM decoding to recover each digital value using its binary code.
11.17. Assuming that a speech waveform is sampled at 8 kHz and each sample is encoded by
16 bits, determine the compression ratio for each of the following encoding methods:
a. no compression
b. standard m-law compression (8 bits per sample)
c. standard ADPCM encoding (4 bits per sample)
11.18. Assuming that a speech waveform is sampled at 8 kHz and each sample is encoded by
16 bits, determine the bit rate for each of the following encoding methods:
a. no compression
b. standard m-law companding (8 bits per sample)
c. standard ADPCM encoding (4 bits per sample)
11.19. Assuming that an audio waveform is sampled at 44.1 kHz and each sample is encoded by
16 bits, determine the compression ratio for each of the following encoding methods:
a. no compression
b. standard m-law compression (8 bits per sample)
c. standard ADPCM encoding (4 bits per sample)
11.20. Assuming that an audio waveform is sampled at 44.1 kHz and each sample is encoded by
12 bits, determine the bit rate for each of the encoding methods.
a. no compression
b. standard m-law companding (8 bits per sample)
c. standard ADPCM encoding (4 bits per sample)
11.21. Speech is sampled at 8 kHz and each sample is encoded by 16 bits. A telephone system can
transport the digital voice channel over a digital link with a capacity of 1.536 MBPS.
Determine the number of channels that the phone company can carry for each of the
following encoding methods:
a. no compression
b. standard 8-bit m-law companding (8 bits per sample)
c. standard ADPCM encoding (4 bits per sample)
11.22. Given the input data
xð0Þ ¼ 25; xð1Þ ¼ 30; xð2Þ ¼ 28;
and
xð3Þ ¼ 25
determine the DCT coefﬁcients.
11.7 MATLAB Programs
551

11.23. Given the input data
xð0Þ ¼ 25
and
xð1Þ ¼ 30
determine the DCT coefﬁcients.
11.24. Given the input data
xð0Þ ¼ 25; xð1Þ ¼ 30; xð2Þ ¼ 28; xð3Þ ¼ 25;
xð4Þ ¼ 10; xð5Þ ¼ 0; xð6Þ ¼ 0; and xð7Þ ¼ 0
determine the DCT coefﬁcients XDCTð0Þ, XDCTð2Þ, XDCTð4Þ, and XDCTð6Þ.
11.25. Given the input data
xð0Þ ¼ 25; xð1Þ ¼ 30; xð2Þ ¼ 28; xð3Þ ¼ 25;
xð4Þ ¼ 10; xð5Þ ¼ 0; xð6Þ ¼ 0; and xð7Þ ¼ 0
determine the DCT coefﬁcients XDCTð1Þ, XDCTð3Þ, XDCTð5Þ, and XDCTð7Þ.
11.26. Assume the following DCT coefﬁcients with inﬁnite precision:
XDCTð0Þ ¼ 14; XDCTð1Þ ¼ 6; XDCTð2Þ ¼ 6; and XDCTð3Þ ¼ 8
a. Determine the input data using the MATLAB function idct().
b. Recover the input data samples using the MATLAB function idct() if a bit allocation
scheme quantizes the DCT coefﬁcients as follows: 2 magnitude bits plus 1 sign bit (3
bits) for the DC coefﬁcient, 1 magnitude bit plus 1 sign bit (2 bits) for each AC coef-
ﬁcient and a scale factor of 8, that is,
XDCTð0Þ ¼ 8  2 ¼ 16; XDCTð1Þ ¼ 8  1 ¼ 8; XDCTð2Þ ¼ 8  ð  1Þ
¼ 8; and XDCTð3Þ ¼ 8  1 ¼ 8
c. Compute the quantized error in part (b) of this problem.
11.27. Assume the following DCT coefﬁcients with inﬁnite precision:
XDCTð0Þ ¼ 11; XDCTð1Þ ¼ 5; XDCTð2Þ ¼ 7; and XDCTð3Þ ¼ 3
a. Determine the input data using the MATLAB function idct().
b. Recover the input data samples using the MATLAB function idct() if a bit allocation
scheme quantizes the DCT coefﬁcients as follows: 2 magnitude bits plus 1 sign bit
(3 bits) for the DC coefﬁcient, 1 magnitude bit plus 1 sign bit (2 bits) for each AC
coefﬁcient and a scale factor of 8, that is,
XDCTð0Þ ¼ 8  1 ¼ 8; XDCTð1Þ ¼ 8  1 ¼ 8; XDCTð2Þ ¼ 8  1 ¼ 8;
and
XDCTð3Þ ¼ 8  0 ¼ 0
c. Compute the quantized error in part (b) of this problem.
552
CHAPTER 11 Waveform Quantization and Compression

11.28. a. Verify that the window function
fðnÞ ¼ hðnÞ ¼ sin
p
N ðn þ 0:5Þ

used in MDCT is satisﬁed with Equations (11.35) and (11.36).
b. Verify the relation for W-MDCT coefﬁcients
XMDCTðkÞ ¼ ð  1Þ
N
2þ1XMDCTðN  1  kÞ
for
k ¼ N=2; N=2 þ 1; /; N  1
11.29. Given data 1, 2, 3, 4, 5, 4, 3, 2, .,
a. determine the W-MDCT coefﬁcients for the ﬁrst three blocks using a block size of 4;
b. determine the ﬁrst two overlapped subblocks and compare the results with the original
data sequence using the W-MDCT coefﬁcients in part (a).
11.30. Given data 1, 2, 3, 4, 5, 4, 3, 2, 1, 2, 3, 4, 5,.,
a. determine the W-MDCT coefﬁcients for the ﬁrst three blocks using a block size of 6;
b. determine the ﬁrst two overlapped subblocks and compare the results with the original
data sequence using the W-MDCT coefﬁcients in part (a).
11.8.1 Computer Problems with MATLAB
Use the MATLAB programs in Section 11.7 for Problems 11.31 to 11.33.
11.31. Consider the data ﬁle “speech.dat” with 16 bits per sample and a sampling rate of 8 kHz.
a. Use PCM coding (midtread quantizer) to perform compression and decompression and
apply the MATLAB function sound() to evaluate the sound quality in terms of
“excellent”, “good”, “intelligent”, and “unacceptable” for the following bit rates:
1. 4 bits/sample (32 kbits per second)
2. 6 bits/sample (48 kbits per second)
3. 8 bits/sample (64 kbits per second)
b. Use m-law PCM coding to perform compression and decompression and apply the
MATLAB function sound() to evaluate the sound quality for the following bit rates:
1. 4 bits/sample (32 kbits per second)
2. 6 bits/sample (48 kbits per second)
3. 8 bits/sample (64 kbits per second)
11.32. Given the data ﬁle “speech.dat” with 16 bits per sample, a sampling rate of 8 kHz, and
ADCPM coding, perform compression and decompression and apply the MATLAB
function sound() to evaluate the sound quality.
11.33. Given the data ﬁle “speech.dat” with 16 bits per sample, a sampling rate of 8 kHz, and DCT
and M-DCT coding as described in the programs in Section 11.7, perform compression and
11.7 MATLAB Programs
553

decompression using the following speciﬁed parameters in Program 11.16 to compare the
sound quality:
a. nbits¼3, scalef¼scalef2bits
b. nbits¼3, scalef¼scalef3bits
c. nbits¼4, scalef¼scalef2bits
d. nbits¼4, scalef¼scalef3bits
554
CHAPTER 11 Waveform Quantization and Compression

Multirate Digital Signal Processing,
Oversampling of Analog-to-Digital
Conversion, and Undersampling
of Bandpass Signals
12
CHAPTER OUTLINE
12.1 Multirate Digital Signal Processing Basics................................................................................... 555
12.1.1 Sampling Rate Reduction by an Integer Factor.........................................................556
12.1.2 Sampling Rate Increase by an Integer Factor ...........................................................562
12.1.3 Changing the Sampling Rate by a Noninteger Factor L/M ..........................................567
12.1.4 Application: CD Audio Player..................................................................................571
12.1.5 Multistage Decimation ...........................................................................................574
12.2 Polyphase Filter Structure and Implementation............................................................................. 578
12.3 Oversampling of Analog-to-Digital Conversion .............................................................................. 585
12.3.1 Oversampling and Analog-to-Digital Conversion Resolution........................................586
12.3.2 Sigma-Delta Modulation Analog-to-Digital Conversion...............................................592
12.4 Application Example: CD Player................................................................................................... 601
12.5 Undersampling of Bandpass Signals............................................................................................ 603
Simulation Example ................................................................................................................... 608
12.6 Sampling Rate Conversion Using the TMS320C6713 DSK ............................................................. 608
12.7 Summary ................................................................................................................................... 613
OBJECTIVES:
This chapter investigates basics of multirate digital signal processing, illustrates how to change a sampling
rate for speech and audio signals, and describes the polyphase implementation for the decimation ﬁlter
and interpolation ﬁlter. Next, the chapter introduces the advanced analog-to-digital conversion system with
the oversampling technique and sigma-delta modulation. Finally, the chapter explores the principles of
undersampling of bandpass signals.
12.1 MULTIRATE DIGITAL SIGNAL PROCESSING BASICS
In many areas of digital signal processing (DSP) applications
such as communications, speech, and
audio processing
rising or lowering of a sampling rate is required. The principles relating to
changing the sampling rate belong essentially within the topic of multirate signal processing (Ifeachor
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00012-3
Copyright  2013 Elsevier Inc. All rights reserved.
555

and Jervis, 2002; Proakis and Manolakis,1996; Porat, 1997; Sorensen and Chen,1997). As an intro-
duction, we will focus on the sampling rate conversion; that is, sampling rate reduction or increase.
12.1.1 Sampling Rate Reduction by an Integer Factor
The process of reducing the sampling rate by an integer factor is referred to as downsampling of a data
sequence. We also refer downsampling as “decimation” (not taking one of ten). The term “decimation”
has been accepted and used in many textbooks and ﬁelds. To downsample a data sequence xðnÞ by an
integer factor of M, we use the following notation:
yðmÞ ¼ xðmMÞ
(12.1)
where yðmÞ is the downsampled sequence, obtained by taking a sample from the data sequence xðnÞ
for every M samples (discarding M-1 samples for every M samples). As an example, if the original
sequence with a sampling period T ¼ 0:1 second (sampling rate ¼ 10 samples per second) is
given by
xðnÞ : 8
7
4
8
9
6
4
2
 2
 5
 7
 7
 6
 4 .
and we downsample the data sequence by a factor of 3, we obtain the downsampled sequence as
yðmÞ : 8 8 4  5  6 .
with the resultant sampling period T ¼ 3  0:1 ¼ 0:3 second (the sampling rate now is 3.33 samples
per second). Although the example is straightforward, there is a requirement to avoid aliasing noise.
We will illustrate this next.
From the Nyquist sampling theorem, it is known that aliasing can occur in the downsampled signal
due to the reduced sampling rate. After downsampling by a factor of M, the new sampling period
becomes MT, and therefore the new sampling frequency is
fsM ¼
1
MT ¼ fs
M
(12.2)
where fs is the original sampling rate.
Hence, the folding frequency after downsampling becomes
fsM=2 ¼
fs
2M
(12.3)
This tells us that after downsampling by a factor of M, the new folding frequency will be decreased
M times. If the signal to be downsampled has frequency components larger than the new folding
frequency, f > fs=ð2MÞ, aliasing noise will be introduced into the downsampled data.
To overcome this problem, it is required that the original signal xðnÞ be processed by a lowpass
ﬁlter HðzÞ before downsampling, which should have a stop frequency edge at fs=ð2MÞ (Hz). The
corresponding normalized stop frequency edge is then converted to
Ustop ¼ 2p fs
2M T ¼ p
M radians
(12.4)
556
CHAPTER 12 Multirate Digital Signal Processing

In this way, before downsampling, we can guarantee the maximum frequency of the ﬁltered signal
satisﬁes
fmax < fs
2M
(12.5)
such that no aliasing noise is introduced after downsampling. A general block diagram of decimation is
given in Figure 12.1, where the ﬁltered output in terms of the z-transform can be written as
WðzÞ ¼ HðzÞXðzÞ
(12.6)
where XðzÞ is the z-transform of the sequence to be decimated, xðnÞ, and HðzÞ is the lowpass ﬁlter
transfer function. After anti-aliasing ﬁltering, the downsampled signal yðmÞ takes its value from the
ﬁlter output as
yðmÞ ¼ wðmMÞ
(12.7)
The process of reducing the sampling rate by a factor of 3 is shown in Figure 12.1. The corresponding
spectral plots for xðnÞ, wðnÞ, and yðmÞ in general are shown in Figure 12.2.
Anti aliasing
filter H(z)
x n
( )
w n
( )
M
y m
( )
n
n
m
x n
( )
0
0
2
4
6
8
10
12
14
16
0
2
4
6
8
10
12
14
16
1
2
3
4
w n
( )
y m
( )
5
f s
f s
f
M
s
FIGURE 12.1
Block diagram of the downsampling process with M ¼ 3.
12.1 Multirate Digital Signal Processing Basics
557

To verify this principle, let us consider a signal xðnÞ generated by the following:
x

n

¼ 5 sin
2p  1;000n
8;000

þ cos
2p  2;500
8;000

¼ 5 sin
np
4

þ cos
5np
8

(12.8)
With a sampling rate of fs ¼ 8;000 Hz, the spectrum of xðnÞ is plotted in the ﬁrst graph in
Figure 12.3A, where we observe that the signal has components at frequencies of 1,000 Hz and
2,500 Hz. Now we downsample xðnÞ by a factor of 2, that is, M ¼ 2. According to Equation (12.3), we
know that the new folding frequency is 4,000/2 ¼ 2,000 Hz. Hence, without using the anti-aliasing
lowpass ﬁlter, the spectrum would contain an aliasing frequency of 4 kHz
2.5 kHz ¼ 1.5 kHz
introduced by 2.5 kHz, plotted in the second graph in Figure 12.3A.
Now we apply a ﬁnite impulse response (FIR) lowpass ﬁlter designed with a ﬁlter length of N ¼
27 and a cutoff frequency of 1.5 kHz to remove the 2.5 kHz signal before downsampling to avoid
X f
( )
f s / 2
0
f s / 2
f s
f s
f
Hz
(
)
f
Hz
(
)
f s / 2
f s
0
f s
f s / 2
1
W f
( )
f s / 2
0
f s / 2
f s
f s
f
Hz
(
)
H f
( )
f sM
2
f sM
2
0
f sM
2
f
Hz
(
)
2 f sM
f sM
2 f sM
f sM
2
Y f
( )
f sM
2
f sM
2
f sM
Anti-aliasing
filter H(z)
x n
( )
w n
( )
M
y m
( )
f s
f s
f
f
M
sM
s
f
f
M
sM
s /
FIGURE 12.2
Spectrum after downsampling.
558
CHAPTER 12 Multirate Digital Signal Processing

aliasing. How to obtain such speciﬁcations will be discussed in the later example. The normalized
cutoff frequency used for design is given by
Uc ¼ 2p  1;500  ð1=8;000Þ ¼ 0:375p
Thus, the aliasing noise is avoided. The spectral plots are given in Figure 12.3B, where the ﬁrst
plot shows the spectrum of wðnÞ after anti-aliasing ﬁltering, while the second plot describes the
spectrum of yðmÞ after downsampling. Clearly, we prevent aliasing noise in the downsampled
data by sacriﬁcing the original 2.5-kHz signal. Program 12.1 gives the details of the MATLAB
implementation.
Program 12.1. MATLAB program for decimation.
close all; clear all;
% Downsampling filter (see Chapter 7 for FIR filter design)
B
[0.00074961181416 0.00247663033476 0.00146938649416
0.00440446121505 .
0.00910635730662 0.00000000000000 0.02035676831506 0.02233710562885.
0.01712963672810
0.06376620649567
0.03590670035210 0.10660980550088.
0.29014909103794 0.37500000000000 0.29014909103794 0.10660980550088.
0.03590670035210
0.06376620649567
0.01712963672810 0.02233710562885.
0.02035676831506 0.00000000000000
0.00910635730662
0.00440446121505.
0.00146938649416 0.00247663033476 0.00074961181416];
0
500
1000
1500
2000
2500
3000
3500
4000
0
2
4
6
Frequency (Hz)
0
200
400
600
800
1000
1200
1400
1600
1800
2000
0
2
4
6
Frequency (Hz)
FIGURE 12.3A
Spectrum before downsampling and spectrum after downsampling without using the anti-aliasing ﬁlter.
12.1 Multirate Digital Signal Processing Basics
559

% Generate 2048 samples
fs 8000;
% Sampling rate
N 2048;
% Number of samples
M 2;
% Downsample factor
n 0:1:N 1;
x 5*sin(n*pi/4)þcos(5*n*pi/8);
% Compute single sided amplitude spectrum
% AC component will be doubled, and DC component will be kept at the same value
X 2*abs(fft(x,N))/N;X(1) X(1)/2;
% Map the frequency index up to the folding frequency in Hz
f [0:1:N/2 1]*fs/N;
% Downsampling
y x(1:M:N);
NM length(y);
% Length of the downsampled data
% Compute the single sided amplitude spectrum for the downsampled signal
Y 2*abs(fft(y,NM))/length(y);Y(1) Y(1)/2;
% Map the frequency index to the frequency in Hz
fsM [0:1:NM/2 1]*(fs/M)/NM;
subplot(2,1,1);plot(f,X(1:1:N/2));grid; xlabel(’Frequency (Hz)’);
subplot(2,1,2);plot(fsM,Y(1:1:NM/2));grid; xlabel(’Frequency (Hz)’);
figure
0
500
1000
1500
2000
2500
3000
3500
4000
0
2
4
6
Frequency (Hz)
0
200
400
600
800
1000
1200
1400
1600
1800
2000
0
2
4
6
Frequency (Hz)
FIGURE 12.3B
Spectrum before downsampling and spectrum after downsampling using the anti-aliasing ﬁlter.
560
CHAPTER 12 Multirate Digital Signal Processing

w filter(B,1,x);
% Anti aliasing filtering
% Compute the single sided amplitude spectrum for the filtered signal
W 2*abs(fft(w,N))/N;W(1) W(1)/2;
% Downsampling
y w(1:M:N);
NM length(y);
% Compute the single sided amplitude spectrum for the downsampled signal
Y 2*abs(fft(y,NM))/NM;Y(1) Y(1)/2;
% Plot spectra
subplot(2,1,1);plot(f,W(1:1:N/2));grid; xlabel(’Frequency (Hz)’);
subplot(2,1,2);plot(fsM,Y(1:1:NM/2));grid; xlabel(’Frequency (Hz)’);
Now we focus on how to design an anti-aliasing FIR ﬁlter, or decimation ﬁlter. We will discuss this
topic via the following example.
EXAMPLE 12.1
Consider a DSP downsampling system with the following speciﬁcations:
Sampling rate
6,000 Hz
Input audio frequency range
0e800 Hz
Passband ripple
0.02 dB
Stopband attenuation
50 dB
Downsample factor M
3
Determine the FIR ﬁlter length, cutoff frequency, and window type if the window method is used.
Solution:
The speciﬁcations are reorganized as
Anti aliasing ﬁlter operating at the sampling rate
6,000 Hz
Passband frequency range
0e800 Hz
Stopband frequency range
1e3 kHz
Passband ripple
0.02 dB
Stopband attenuation
50 dB
Filter type
FIR
The block diagram and speciﬁcations are depicted in Figure 12.4.
Anti-aliasing
filter H(z)
x n
( )
w n
( )
y m
( )
6
6
2
3
f
2
1
08.
0
3
FIGURE 12.4
Filter speciﬁcations for Example 12.1.
12.1 Multirate Digital Signal Processing Basics
561

The Hamming window is selected, since it provides 0.019 dB ripple and 53 dB stopband attenuation. The
normalized transition band is given by
Df
fstop
fpass
fs
1;000
800
6;000
0:033
The length of the ﬁlter and the cutoff frequency can be determined by
N
3:3
Df
3:3
0:033
100
We choose an odd number; that is, N
101, and
fc
fpass þ fstop
2
800 þ 1;000
2
900 Hz
12.1.2 Sampling Rate Increase by an Integer Factor
Increasing a sampling rate is a process of upsampling by an integer factor of L. This process is
described as follows:
y

m

¼
8
<
:
x
m
L

m ¼ nL
0
otherwise
(12.9)
where n ¼ 0; 1; 2; /; xðnÞ is the sequence to be upsampled by a factor of L, and yðmÞ is the upsampled
sequence. As an example, suppose that the data sequence is given as follows:
xðnÞ : 8 8 4
 5
 6 .
After upsampling the data sequence xðnÞ by a factor of 3 (adding L - 1 zeros for each sample), we have
the upsampled data sequence wðmÞ as
wðmÞ : 8 0 0 8 0 0 4 0 0  5 0 0  6 0 0 .
The next step is to smooth the upsampled data sequence via an interpolation ﬁlter. The process is
illustrated in Figure 12.5A.
Similar to the downsampling case, assuming that the data sequence has the current sampling period
of T, the Nyquist frequency is given by fmax ¼ fs=2. After usampling by a factor of L, the new
sampling period becomes T=L, thus the new sampling frequency is changed to be
fsL ¼ Lfs
(12.10)
This indicates that after upsampling, the spectral replicas originally centered at fs, 2fs, . are
included in the frequency range from 0 Hz to the new Nyquist limit Lfs=2 Hz, as shown in
Figure 12.5B. To remove those included spectral replicas, an interpolation ﬁlter with a stop frequency
edge of fs=2 in Hz must be attached, and the normalized stop frequency edge is given by
Ustop ¼ 2p
fs
2


T
L

¼ p
L radians
(12.11)
562
CHAPTER 12 Multirate Digital Signal Processing

After ﬁltering via the interpolation ﬁlter, we will achieve the desired spectrum for yðnÞ, as shown in
Figure 12.5B. Note that since the interpolation is to remove the high-frequency images that are aliased
by the upsampling operation, it is essentially an anti-aliasing lowpass ﬁlter.
To verify the upsampling principle, we generate the signal xðnÞ with 1 kHz and 2.5 kHz as follows:
x

n

¼ 5 sin
2p  1;000n
8;000

þ cos
2p  2;500n
8;000

with a sampling rate of fs ¼ 8;000 Hz. The spectrum of xðnÞ is plotted in Figure 12.6. Now we
upsample xðnÞ by a factor of 3, that is, L ¼ 3. We know that the sampling rate is increased to be
3  8,000 ¼ 24,000 Hz. Hence, without using the interpolation ﬁlter, the spectrum would contain the
image frequencies originally centered at the multiple frequencies of 8 kHz. The top plot in Figure 12.6
shows the spectrum for the sequence after upsampling and before applying the interpolation ﬁlter.
Now we apply an FIR lowpass ﬁlter designed with a length of 53, a cutoff frequency of 3,250 Hz,
and a new sampling rate of 24,000 Hz as the interpolation ﬁlter, whose normalized frequency should be
Uc ¼ 2p  3;250 

1
24;000

¼ 0:2708p
m
m
n
w m
( )
0
2
4
6
8
10
12
14
16
0
2
4
6
8
10
12
14
16
0
1
2
3
4
y m
( )
x n
( )
Interpolation
filter H(z)
x n
( )
y m
( )
( )
w m
5
f s
Lf s
Lf s
L
FIGURE 12.5A
Block diagram for the upsampling process with L ¼ 3.
12.1 Multirate Digital Signal Processing Basics
563

The bottom plot in Figure 12.6 shows the spectrum for yðmÞ after applying the interpolation ﬁlter,
where only the original signals with frequencies of 1 kHz and 2.5 kHz are presented. Program 12.2
shows the implementation details in MATLAB.
Program 12.2. MATLAB program for interpolation.
close all; clear all
% Upsampling filter (see Chapter 7 for FIR filter design)
B
[ 0.00012783931504 0.00069976044649 0.00123831516738 0.00100277549136.
0.00025059018468
0.00203448515158
0.00300830295487
0.00174101657599.
0.00188598835011 0.00578414933758 0.00649330625041 0.00177982369523.
X f
( )
f s / 2
0
f s / 2
f s
f s
f s
f sL
0
f sL
f s
1
W f
( )
f s
0
f s
f
Lf
sL
s
Lf s
H f
( )
f s / 2
f s / 2
0
f sL
f sL
Y f
( )
f sL / 2
f sL / 2
f s / 2
f s / 2
f s / 2
f s / 2
Interpolation
filter H(z)
x n
( )
y m
( )
w m
( )
f s
Lf s
f
Lf
sL
s
L
FIGURE 12.5B
Spectra before and after upsampling
564
CHAPTER 12 Multirate Digital Signal Processing

0.00670672686935
0.01319379342716
0.01116855281442 0.00123034314117.
0.01775600060894 0.02614700427364 0.01594155162392
0.01235169936557.
0.04334322148505
0.05244745563466
0.01951094855292 0.05718573279009.
0.15568416401644 0.23851539047347 0.27083333333333 0.23851539047347.
0.15568416401644 0.05718573279009
0.01951094855292
0.05244745563466.
0.04334322148505
0.01235169936557 0.01594155162392 0.02614700427364.
0.01775600060894 0.00123034314117
0.01116855281442
0.01319379342716.
0.00670672686935 0.00177982369523 0.00649330625041 0.00578414933758.
0.00188598835011
0.00174101657599
0.00300830295487
0.00203448515158.
0.00025059018468 0.00100277549136 0.00123831516738 0.00069976044649.
0.00012783931504];
% Generate the 2048 samples with fs
8000 Hz
fs 8000;
% Sampling rate
N 2048;
% Number of samples
L
3;
% Upsampling factor
n 0:1:N 1;
x 5*sin(n*pi/4)þcos(5*n*pi/8);
% Upsampling by a factor of L
w zeros(1,L*N);
0
2000
4000
6000
8000
10000
12000
0
0.5
1
1.5
2
Frequency (Hz)
0
2000
4000
6000
8000
10000
12000
0
0.5
1
1.5
2
Frequency (Hz)
FIGURE 12.6
(Top) The spectrum after upsampling and before applying the interpolation ﬁlter; (bottom) spectrum after
applying the interpolation ﬁlter.
12.1 Multirate Digital Signal Processing Basics
565

for n 0:1:N 1
w(L*nþ1) x(nþ1);
end
NL
length(w);
% Length of the upsampled data
W 2*abs(fft(w,NL))/NL;W(1) W(1)/2; % Compute one sided amplitude spectrum
f [0:1:NL/2 1]*fs*L/NL; % Map the frequency index to the frequency (Hz)
% Interpolation
y filter(B,1,w);
% Apply interpolation filter
Y 2*abs(fft(y,NL))/NL;Y(1) Y(1)/2; % Compute the one sided amplitude spectrum
fsL [0:1:NL/2 1]*fs*L/NL; % Map the frequency index to the frequency (Hz)
subplot(2,1,1);plot(f,W(1:1:NL/2));grid; xlabel(’Frequency (Hz)’);
subplot(2,1,2);plot(fsL,Y(1:1:NL/2));grid; xlabel(’Frequency (Hz)’);
Now let us study how to design an interpolation ﬁlter via Example 12.2.
EXAMPLE 12.2
Consider a DSP upsampling system with the following speciﬁcations:
Sampling rate
6,000 Hz
Input audio frequency range
0e800 Hz
Passband ripple
0.02 dB
Stopband attenuation
50 dB
Upsample factor L
3
Determine the FIR ﬁlter length, cutoff frequency, and window type if the window design method is used.
Solution:
The speciﬁcations are reorganized as follows:
Interpolation ﬁlter operating at the sampling rate
18,000 Hz
Passband frequency range
0e800 Hz
Stopband frequency range
3e9 kHz
Passband ripple
0.02 dB
Stopband attenuation
50 dB
Filter type: FIR ﬁlter
The block diagram and ﬁlter frequency speciﬁcations are given in Figure 12.7.
Anti-image filter
H(z)
x n
( )
( )
w m
y m
( )
6
18
18
9
6
3
08.
0
3
FIGURE 12.7
Filter frequency speciﬁcations for Example 12.2.
566
CHAPTER 12 Multirate Digital Signal Processing

We choose the Hamming window for this application. The normalized transition band is
Df
fstop
fpass
fsL
3;000
800
18;000
0:1222
The length of the ﬁlter and the cutoff frequency can be determined by
N
3:3
Df
3:3
0:1222
27
and the cutoff frequency is given by
fc
fpass þ fstop
2
3;000 þ 800
2
1;900 Hz:
12.1.3 Changing the Sampling Rate by a Noninteger Factor L/M
With an understanding of the downsampling and upsampling processes, we now study sampling rate
conversion by a noninteger L=M. This can be viewed as two sampling conversion processes. In step 1,
we perform the upsampling process by a factor of integer L following application of an interpolation
ﬁlter H1ðzÞ; in step 2, we continue ﬁltering the output from the interpolation ﬁlter via an anti-aliasing
ﬁlter H2ðzÞ, and ﬁnally execute downsampling. The entire process is illustrated in Figure 12.8.
Since the interpolation and anti-aliasing ﬁlters are in a cascaded form and operate at the same rate,
we can select one of them. We choose the one with the lower stop frequency edge and choose the most
demanding requirements for passband gain and stopband attenuation for the ﬁlter design. A lot of
computational savings can be achieved by using one lowpass ﬁlter. We illustrate the procedure via the
following simulation. Let us generate the signal xðnÞ by
x

n

¼ 5 sin
2p  1;000n
8;000

þ cos
2p  2;500n
8;000

with a sampling rate of fs ¼ 8;000 Hz and frequencies of 1 kHz and 2.5 kHz. Now we resample xðnÞ to
3,000 Hz by a noninteger factor of 0.375, that is,
 L
M

¼ 0:375 ¼ 3
8
Upsampling is at a factor of L ¼ 3 and the upsampled sequence is ﬁltered by an FIR lowpass ﬁlter
designed with a ﬁlter length N ¼ 53 and a cutoff frequency of 3,250 Hz at a sampling rate of 3  8,000
¼ 24,000 Hz. The spectrum for the upsampled sequence and the spectrum after application of the
interpolation ﬁlter are plotted in Figure 12.9A.
Interpolation
filter H1(z)
x n
( )
Anti aliasing
filter H2(z)
( )
y m
M
 H(z)
L
FIGURE 12.8
Block diagram for sampling rate conversion.
12.1 Multirate Digital Signal Processing Basics
567

The sequence from step 1 can be ﬁltered via another FIR lowpass ﬁlter with ﬁlter length N ¼ 159 and
a cutoff frequency of 1,250 Hz, followed by downsampling by a factor of M ¼ 8. The spectrum after
the anti-aliasing ﬁlter and the spectrum for the ﬁnal output yðmÞ are plotted in Figure 12.9B. Note that
the anti-aliasing ﬁlter removes the frequency component of 2.5 kHz to avoid aliasing. This is because
after downsampling, the Nyquist limit is 1.5 kHz. As we discussed previously, we can select one ﬁlter
for implementation. We choose a FIR lowpass ﬁlter with N ¼ 159 and a cutoff frequency of 1,250 Hz
because its bandwidth is smaller than that of the interpolation ﬁlter. The MATLAB implementation is
listed in Program 12.3.
Program 12.3 MATLAB program for changing sampling rate with a noninteger factor.
close all; clear all;clc;
% Downsampling filter
Bdown firwd(159,1,2*pi*1250/24000,0,4);
% Generate 2048 samples with fs 8000 Hz
fs 8000;
% Original sampling rate
N
2048;
% The number of samples
L 3;
% Upsampling factor
M 8;
% Downsampling factor
n 0:1:N 1;
% Generate the time index
x 5*sin(n*pi/4)þcos(5*n*pi/8);
% Generate the test signal
% Upsampling by a factor of L
w1 zeros(1,L*N);
0
2000
4000
6000
8000
10000
12000
0
0.5
1
1.5
2
Frequency (Hz)
0
2000
4000
6000
8000
10000
12000
0
0.5
1
1.5
2
Frequency (Hz)
FIGURE 12.9A
(Top) Spectrum after upsampling, and (bottom) spectrum after interpolation ﬁltering.
568
CHAPTER 12 Multirate Digital Signal Processing

for n 0:1:N 1
w1(L*nþ1) x(nþ1);
end
NL
length(w1);
% Length of upsampled data
W1 2*abs(fft(w1,NL))/NL;W1(1) W1(1)/2; % Compute the one sided
% amplitude spectrum
f [0:1:NL/2 1]*fs*L/NL;
% Map frequency index to its frequency in Hz
subplot(3,1,1);plot(f,W1(1:1:NL/2));grid
xlabel(’Frequency (Hz)’);
w2 filter(Bdown,1,w1);
% Perform the combined anti aliasing filter
W2 2*abs(fft(w2,NL))/NL;W2(1) W2(1)/2; % Compute the one sided
% amplitude spectrum
y2 w2(1:M:NL);
NM length(y2);
% Length of the downsampled data
Y2 2*abs(fft(y2,NM))/NM;Y2(1) Y2(1)/2;% Compute the one sided
%amplitude spectrum
% Map frequency index to its frequency in Hz before downsampling
fbar [0:1:NL/2 1]*24000/NL;
% Map frequency index to its frequency in Hz
fsM [0:1:NM/2 1]*(fs*L/M)/NM;
subplot(3,1,2);plot(f,W2(1:1:NL/2));grid; xlabel(’Frequency (Hz)’);
subplot(3,1,3);plot(fsM,Y2(1:1:NM/2));grid; xlabel(’Frequency (Hz)’);
0
2000
4000
6000
8000
10000
12000
0
0.5
1
1.5
2
Frequency (Hz)
0
500
1000
1500
0
0.5
1
1.5
2
Frequency (Hz)
FIGURE 12.9B
(Top) Spectrum after anti-aliasing ﬁltering, and (bottom) spectrum after downsampling.
12.1 Multirate Digital Signal Processing Basics
569

Therefore, three steps are required to accomplish the process:
1. Upsampling by a factor of L ¼ 3;
2. Filtering the upsampled sequence by an FIR lowpass ﬁlter designed with ﬁlter length N ¼ 159 and
a cutoff frequency of 1,250 Hz at a sampling rate of 3 8,000 ¼ 24,000 Hz;
3. Downsampling by a factor of M ¼ 8.
EXAMPLE 12.3
Consider a sampling conversion DSP system (Figure 12.10A) with the following speciﬁcations:
Audio input xðnÞ is sampled at the rate of 6,000 Hz.
Audio output yðmÞ is operated at the rate of 9,000 Hz.
Determine the ﬁlter length and cutoff frequency for the combined anti aliasing ﬁlter HðzÞ, and the window types,
respectively, if the window design method is used.
Solution:
The ﬁlter frequency speciﬁcations and corresponding block diagram are developed in Figure 12.10B.
Speciﬁcations for the interpolation ﬁlter H1ðzÞ:
Passband frequency range
0e2,500 Hz
Passband ripples for H1ðzÞ
0.04 dB
Stopband frequency range
3,000e9,000 Hz
Stopband attenuation
42 dB
Speciﬁcations for the anti aliasing ﬁlter H2ðzÞ:
Passband frequency range
0e2,500 Hz
Interpolation
filter H1(z)
x n
( )
3
Anti aliasing
filter H2(z)
y m
( )
2
FIGURE 12.10A
Sampling conversion in Example 12.3.
Interpolation
filter H1(z)
x n
( )
3
Anti aliasing
filter H2(z)
y m
( )
2
9
6
3
2 5.
0
4 5.
2 5.
0
9
6
FIGURE 12.10B
Filter frequency speciﬁcations for Example 12.3.
570
CHAPTER 12 Multirate Digital Signal Processing

Passband ripples for H2ðzÞ
0.02 dB
Stopband frequency range
4,500e9,000 Hz
Stopband attenuation
46 dB
Combined speciﬁcations HðzÞ:
Passband frequency range
0e2,500 Hz
Passband ripples for HðzÞ
0.02 dB
Stopband frequency range
3,000e9,000 Hz
Stopband attenuation
46 dB
We use an FIR ﬁlter with a Hamming window. Since
Df
fstop
fpass
fsL
3;000
2;500
18;000
0:0278
the length of the ﬁlter and the cutoff frequency can be determined by
N
3:3
Df
3:3
0:0278
118:8
We choose N
119, and
fc
fpass þ fstop
2
3;000 þ 2;500
2
2;750 Hz
12.1.4 Application: CD Audio Player
In this application example, we will discuss principles of the upsampling and interpolation-ﬁlter
processes used in CD audio systems to help with reconstruction ﬁlter design.
Each raw digital sample recorded on a CD audio system contains 16 bits and is sampled at the rate
of 44.1 kHz. Figure 12.11 describes a portion of one channel of the CD player in terms of a simpliﬁed
block diagram.
Let us consider the situation without upsampling and application of a digital interpolation ﬁlter. We
know that the audio signal has a bandwidth of 22.05 kHz, that is, the Nyquist frequency, and digital-to-
analog conversion (DAC) produces the sample-and-hold signals that contain the desired audio band
and images thereof. To achieve the audio band signal, we need to apply a reconstruction ﬁlter (also
called a smooth ﬁlter or anti-image ﬁlter) to remove all image frequencies beyond the Nyquist
frequency of 22.05 kHz. Due to the requirement of the sharp transition band, a higher-order analog
ﬁlter design becomes a requirement.
The design of the higher-order analog ﬁlter is complex and expensive to implement. As shown
in Figure 12.11, in order to relieve such design constraints, we can add the upsampling process
Interpolation
filter H(z)
x n
( )
L
y m
( )
w m
( )
CD
Player
Analog
reconstruction
filter H(s)
DAC
y t( )
f s
Lf s
Lf s
FIGURE 12.11
Sample rate conversion in the CD audio player system.
12.1 Multirate Digital Signal Processing Basics
571

before DAC, followed by application of the digital interpolation ﬁlter (assume L ¼ 4). Certainly,
the interpolation ﬁlter design must satisfy the speciﬁcations studied in the previous section on
increasing the sampling rate by an integer factor. Again, after digital interpolation, the audio band
is kept the same, while the sampling frequency is increased by fourfold (L ¼ 4), that is, 44.1 4 ¼
176.4 kHz.
Since the audio band of 22.05 kHz is now relatively low compared with the new folding frequency
(176.4/2 ¼ 88.2 kHz), the use of a simple ﬁrst-order or second-order analog anti-image ﬁlter may be
sufﬁcient. Let us look the following simulation.
A test audio signal with a frequency of 16 kHz and a sampling rate of 44.1 kHz is generated using
the formula
x

n

¼ sin
2p  16;000n
441;000

If we use an upsampling factor of 4, then the bandwidth would increase to 88.2 kHz. Based on the
audio frequency of 16 kHz, the original Nyquist frequency of 22.05 kHz, and the new sampling rate of
176.4 kHz, we can determine the ﬁlter length as
Df ¼ 22:05  16
176:4
¼ 0:0343
Using the Hamming window for FIR ﬁlter design leads to
N ¼ 3:3
Df ¼ 96:2
We choose N ¼ 97. The cutoff frequency therefore is
fc ¼ 16 þ 22:05
2
¼ 19:025 kHz
The spectrum of the interpolated audio test signal is shown in Figure 12.12, where the top plot
illustrates that after the upsampling, the audio test signal has a frequency of 16 kHz, along with image
frequencies coming from 44.1
16 ¼ 28.1 kHz, 44.1 þ 16 ¼ 60.1 kHz, 88.2
16 ¼ 72.2 kHz, and so
on. The bottom graph describes the spectrum after the interpolation ﬁlter. From lowpass FIR ﬁltering,
an interpolated audio signal with a frequency of 16 kHz is observed.
Let us examine the corresponding process in the time domain, as shown in Figure 12.13. The upper
left plot shows the original samples. The upper right plot describes the upsampled signals. The lower
left plot shows the signals after the upsampling process and digital interpolation ﬁlter. Finally, the lower
right plot shows the sample-and-hold signals after DAC. Clearly, we can easily design a reconstruction
ﬁlter to smooth the sample-and-hold signals and obtain the original audio test signal. The advantage of
reducing hardware is illustrated. The MATLAB implementation can be seen in Program 12.4.
Program 12.4. MATLAB program for CD player example.
close all; clear all; clc
% Generate the 2048 samples with fs
44100 Hz
fs
44100;
% Original sampling rate
T 1/fs;
% Sampling period
572
CHAPTER 12 Multirate Digital Signal Processing

N 2048;
% Number of samples
L 4;
fsL fs*L;
% Upsampling rate
%Upsampling filter (see Chapter 7 for FIR filter design)
Bup firwd(97,1,2*19025*pi/fsL,0,4);
n 0:1:N 1;
% Generate the time indices
x 5*sin(2*pi*16000*n*T);
% Generate the test signal
% Upsampling by a factor of L
w zeros(1,L*N);
for n 0:1:N 1
w(L*nþ1) x(nþ1);
end
NL length(w);
% Number of the upsampled data
W 2*abs(fft(w,NL))/NL;W(1) W(1)/2; % Compute the one sided
% amplitude spectrum
f [0:1:NL/2 1]*fs*L/NL;
% Map the frequency index to its frequency in Hz
f f/1000;
% Convert to kHz
% Interpolation
y filter(Bup,1,w);
% Perform the interpolation filter
Y 2*abs(fft(y,NL))/NL;Y(1) Y(1)/2; % Compute the one sided
% amplitude spectrum
0
10
20
30
40
50
60
70
80
0
0.5
1
1.5
2
Frequency (KHz)
0
10
20
30
40
50
60
70
80
0
0.5
1
1.5
2
Frequency (KHz)
FIGURE 12.12
(Top) The spectrum after upsampling, and (bottom) the spectrum after applying the interpolation ﬁlter.
12.1 Multirate Digital Signal Processing Basics
573

subplot(2,1,1);plot(f,W(1:1:NL/2));grid;
xlabel(’Frequency (kHz)’); axis([0 f(length(f)) 0 2]);
subplot(2,1,2);plot(f,Y(1:1:NL/2));grid;
xlabel(’Frequency (kHz)’);axis([0 f(length(f)) 0 2]);
figure
subplot(2,2,1);stem(x(21:30));grid
xlabel(’Number of Samples’);ylabel(’x(n)’);
subplot(2,2,2);stem(w(81:120));grid
xlabel(’Number of Samples’); ylabel(’w(n)’);
subplot(2,2,3);stem(y(81:120));grid
xlabel(’Number of Samples’); ylabel(’y(n)’)
subplot(2,2,4);stairs([80:1:119]*1000*T,y(81:120));grid
xlabel(’Time (ms)’); ylabel(’y(t)’)
12.1.5 Multistage Decimation
The multistage approach for downsampling rate conversion can be used to dramatically reduce the
anti-aliasing ﬁlter length. Figure 12.14 describes a two-stage decimator.
As shown in Figure 12.14, a total decimation factor is M ¼ M1  M2. Here, even though we
develop a procedure for a two-stage case, a similar principle can be applied to general multistage cases.
0
5
10
-5
0
5
Number of Samples
x(n)
0
10
20
30
40
-5
0
5
Number of Samples
w(n)
0
10
20
30
40
-2
-1
0
1
2
Number of Samples
y(n)
0.4
0.5
0.6
-2
-1
0
1
2
Time (ms)
y(t)
FIGURE 12.13
Plots of signals at each stage according to the block diagram in Figure 12.11.
574
CHAPTER 12 Multirate Digital Signal Processing

Using the two-stage decimation in Figure 12.15, the ﬁnal Nyquist limit is fs
2M after ﬁnal down-
sampling. So our useful information bandwidth should stop at the frequency edge of fs
2M. Next, we
need to determine the stop frequency edge for the anti-aliasing lowpass ﬁlter at stage 1 before the ﬁrst
decimation process begins. This stop frequency edge is actually the lower frequency edge of the ﬁrst
image replica centered at the sampling frequency of fs
M1
after the stage 1 decimation. This lower
frequency edge of the ﬁrst image replica is then determined by
fs
M1
 fs
2M
After downsampling, we expect that some frequency components from
fs
2M1
to fs
M1
 fs
2M to be folded
over to the frequency band between fs
2M and fs
2M1
. However, these aliased frequency components do not
affect the ﬁnal useful band between 0 Hz to fs
2M and will be removed by the anti-aliasing ﬁlter(s) in the
future stage(s). As illustrated in Figure 12.15, any frequency components beyond the edge fs
M1
 fs
2M
x n
( )
Anti aliasing
filter H2(z)
y m
( )
M2
M1
Anti aliasing
filter H1(z)
f s
f
M1
f
M M
f
M
s
s
s
1
2
Stage2
Stage1
FIGURE 12.14
Multistage decimation.
f
M
s
2
f
M
s
1
f
M
f
M
s
s
1
2
Final stop band
frequency edge
Image after
decimation at
stage 1
f s
Anti aliasing filter at
stage 1 operating at
the sampling rate of fs
Image before
decimation at
stage 1
Stop band frequency
edge at stage 1
f s / 2
Removed by H1(z)
Prevented
by H1(z)
Removed in
future stage(s)
FIGURE 12.15
Stopband frequency edge for the anti-aliasing ﬁlter at stage 1 for two-stage decimation.
12.1 Multirate Digital Signal Processing Basics
575

can fold over into the ﬁnal useful information band to create aliasing distortion. Therefore, we can use
this frequency as the lower stop frequency edge of the anti-aliasing ﬁlter to prevent the aliasing
distortion at the ﬁnal stage. The upper stopband edge (Nyquist limit) for the anti-image ﬁlter at stage 1
is clearly fs
2, since the ﬁlter operates at fs samples per second. So the stopband frequency range at
stage 1 is therefore from fs
M1
 fs
2M to fs
2. The aliasing distortion, introduced into the frequency band
from fs
2M to
fs
2M1
, will be ﬁltered out after future decimation stage(s).
Similarly, for stage 2, the lower frequency edge of the ﬁrst image developed after stage 2 down-
sampling is
fs
M1M2
 fs
2M ¼
fs
2M
As is evident in our two-stage scheme, the stopband frequency range for the second anti-aliasing
ﬁlter at stage 2 should be from fs
2M to
fs
2M1
.
We summarize the speciﬁcations for the two-stage decimation as follows:
Filter requirements for stage 1:
• Passband frequency range ¼ 0 to fp
• Stopband frequency range ¼ fs
M1
 fs
2M to fs
2
• Passband ripple ¼ dp=2, where dp is the combined absolute ripple on the passband
• Stopband attenuation ¼ ds
Filter requirements for stage 2:
• Passband frequency range ¼ 0 to fp
• Stopband frequency range ¼
fs
M1  M2
 fs
2M to
fs
2M1
• Passband ripple ¼ dp=2, where dp is the combined absolute ripple on the passband
• Stopband attenuation ¼ ds
Example 12.4 illustrates the two-stage decimator design.
EXAMPLE 12.4
Determine the anti aliasing FIR ﬁlter lengths and cutoff frequencies for the two stage decimator with the following
speciﬁcations and the block diagram in Figure 12.16A:
Original sampling rate: fs
240 kHz
Audio frequency range: 0e3,400 Hz
Passband ripple: dp
0:05 (absolute)
Stopband attenuation: ds
0:005 (absolute)
FIR ﬁlter design using the window method
New sampling rate: fsM
8 kHz
576
CHAPTER 12 Multirate Digital Signal Processing

Solution:
M
240 kHz
8 kHz
30
10  3
We choose M1
10 and M2
3; there could be other choices. Figure 12.16B shows the block diagram and ﬁlter
frequency speciﬁcations.
Filter speciﬁcations for H1ðzÞ:
Passband frequency range: 0e3,400 Hz
Passband ripples: 0.05/2
0.025 (dp dB
20 log10ð1 þ dpÞ
0.212 dB)
Stopband frequency range: 20,000e120,000 Hz
Stopband attenuation: 0.005, ds dB
20  log10ðdsÞ
46 dB
Filter type: FIR, Hamming window
Note that the lower stopband edge can be determined as
fstop
fs
M1
fs
2  M
240;000
10
240;000
2  30
20;000 Hz
Df
fstop
fpass
fs
20;000
3;400
240;000
0:06917
The length of the ﬁlter and the cutoff frequency can be determined by
N
3:3
Df
47:7
We choose N
49, and
fc
fpass þ fstop
2
20;000 þ 3;400
2
11;700 Hz
x n
( )
Anti aliasing
filter H2(z)
y m
( )
M2
M1
Anti aliasing
filter H1(z)
240
24
8
2
e
g
a
t
S
1
e
g
a
t
S
FIGURE 12.16A
Multistage decimation in Example 12.4.
x n
( )
Anti aliasing
filter H2(z)
y m
( )
3
120
f
80
40
20
0
f
4
0
12
8
Anti aliasing
filter H1(z)
10
FIGURE 12.16B
Filter frequency speciﬁcations for Example 12.4.
12.1 Multirate Digital Signal Processing Basics
577

Filter speciﬁcations for H2ðzÞ:
Passband frequency range: 0e3,400 Hz
Passband ripples: 0.05/2
0.025 (0.212 dB)
Stopband frequency range: 4,000e12,000 Hz
Stopband attenuation: 0.005, dsdB
46 dB
Filter type: FIR, Hamming window
Note that
Df
fstop
fpass
fsM1
4;000
3;400
24;000
0:025:
The length of the ﬁlter and the cutoff frequency can be determined by
N
3:3
Df
132
We choose N
133, and
fc
fpass þ fstop
2
4;000 þ 3;400
2
3;700 Hz
The reader can verify this case by using only one stage with a decimation factor of M
30. Using the Hamming
window for the FIR ﬁlter, the resulting number of taps is 1,321, and the cutoff frequency is 3,700 Hz. Thus, such
a ﬁlter requires a huge number of computations and causes a large delay during implementation compared with the
two stage case.
The multistage scheme is very helpful for sampling rate conversion between audio systems. For
example, to convert CD audio at a sampling rate of 44.1 kHz to MP3 or Digital Audio Tape (DAT), in
which the sampling rate of 48 kHz is used, the conversion factor L=M ¼ 48=44:1 ¼ 160=147 is
required. Using the single stage scheme may cause impractical FIR ﬁlter sizes for interpolation and
downsampling. However, since L=M ¼ 160=147 ¼ ð4=3Þð8=7Þð5=7Þ, we may design an efﬁcient
three-stage system, in which stages 1, 2, and 3 use the conversion factors L=M ¼ 8=7, L=M ¼ 5=7,
and L=M ¼ 4=3, respectively.
12.2 POLYPHASE FILTER STRUCTURE AND IMPLEMENTATION
Due to the nature of the decimation and interpolation processes, polyphase ﬁlter structures can be
developed to efﬁciently implement the decimation and interpolation ﬁlters (using fewer multiplica-
tions and additions). As we will explain, these ﬁlters are all-pass ﬁlters with different phase shifts
(Proakis and Manolakis, 1996), thus we call them polyphase ﬁlters.
Here, we skip their derivations and illustrate implementations of decimation and interpolation
using simple examples. Consider the interpolation process shown in Figure 12.17, where L ¼ 2.
x n
( )
2
w m
( )
y m
( )
FIGURE 12.17
Upsampling by a factor of 2 and a four-tap interpolation ﬁlter.
578
CHAPTER 12 Multirate Digital Signal Processing

We assume that the FIR interpolation ﬁlter has four taps, shown as
H

z

¼ h

0

þ h

1

z 1 þ h

2

z 2 þ h

3

z 3
and the ﬁlter output is
yðmÞ ¼ hð0ÞwðmÞ þ hð1Þwðm  1Þ þ hð2Þwðm  2Þ þ hð3Þwðm  3Þ
For the purpose of comparison, the direct interpolation process shown in Figure 12.17 is summarized
in Table 12.1, where wðmÞ is the upsampled signal and yðmÞ the interpolated output. Processing each
input sample xðnÞ requires applying the difference equation twice to obtain yð0Þ and yð1Þ. Hence, for
this example, we need eight multiplications and six additions.
The output results in Table 12.1 can be easily obtained by using the polyphase ﬁlters shown in
Figure 12.18.
In general, there are L polyphase ﬁlters. With a designed interpolation ﬁlter HðzÞ of N taps, we can
determine each bank of ﬁlter coefﬁcients as follows:
rk

n

¼ h

k þ nL

for
k ¼ 0; 1; /; L  1
and
n ¼ 0; 1; /; N
L  1
(12.12)
2
2
x n
( )
y m
0( )
y m
1( )
1
y m
( )
f s
L f s
w n
0( )
w n
1( )
FIGURE 12.18
Polyphase ﬁlter implementation for the interpolation in Figure 12.17 (4 multiplications and 3 additions for
processing each input sample x(n)).
Table 12.1 Results of the Direct Interpolation Process in Figure 12.17 (8 multiplications and 6
additions for processing each input sample x(n))
n
xðnÞ
m
wðmÞ
yðmÞ
n
0
xð0Þ
m
0
wð0Þ
xð0Þ
yð0Þ
hð0Þxð0Þ
m
1
wð1Þ
0
yð1Þ
hð1Þxð0Þ
n
1
xð1Þ
m
2
wð2Þ
xð1Þ
yð2Þ
hð0Þxð1Þ þ hð2Þxð0Þ
m
3
wð3Þ
0
yð3Þ
hð1Þxð1Þ þ hð3Þxð0Þ
n
2
xð2Þ
m
4
wð4Þ
xð2Þ
yð4Þ
hð0Þxð2Þ þ hð2Þxð1Þ
m
5
wð5Þ
0
yð5Þ
hð1Þxð2Þ þ hð3Þxð1Þ
.
.
.
.
.
12.2 Polyphase Filter Structure and Implementation
579

For our example, L ¼ 2 and N ¼ 4, we have L  1 ¼ 1, and N=L  1 ¼ 1, respectively. Hence,
there are two ﬁlter banks, r0ðzÞ and r1ðzÞ, each having a length of 2, as illustrated in Figure 12.18.
When
k ¼ 0
and
n ¼ 1,
the
upper
limit
of
time
index
required
for
hðk þ nLÞ
is
k þ nL ¼ 0 þ 1  2 ¼ 2. When k ¼ 1 and n ¼ 1, the upper limit of the time index for h(kþnL) is 3.
Hence, the ﬁrst ﬁlter r0ðzÞ has the coefﬁcients hð0Þ and hð2Þ. Similarly, the second ﬁlter r1ðzÞ has
coefﬁcients hð1Þ and hð3Þ. In fact, the ﬁlter coefﬁcients of r0ðzÞ are a decimated version of h(n)
starting at k ¼ 0, while the ﬁlter coefﬁcients of r1ðzÞ are a decimated version of h(n) starting at k ¼ 1,
and so on.
As shown in Figure 12.18, we can reduce the computational complexity from eight multiplications
and six additions down to four multiplications and three additions for processing each input sample
xðnÞ. Generally, the computation can be reduced by a factor of L as compared with the direct process.
The commutative model for the polyphase interpolation ﬁlter is given in Figure 12.19.
EXAMPLE 12.5
Verify y(1) in Table 12.1 using the polyphase ﬁlter implementation in Figures 12.18 and 12.19, respectively.
Solution:
Applying the ployphase interpolation ﬁlter as shown in Figure 12.18 leads to
w0ðnÞ
hð0ÞxðnÞ þ hð2Þxðn
1Þ
w1ðnÞ
hð1ÞxðnÞ þ hð3Þxðn
1Þ
When n
0,
w0ð0Þ
hð0Þxð0Þ
w1ð0Þ
hð1Þxð0Þ
After interpolation, we have
y0ðmÞ : w0ð0Þ
0
/
and
y1ðmÞ : 0
w1ð0Þ
0
/
Note: there is a unit delay for the second ﬁlter bank. Hence
m
0; y0ð0Þ
hð0Þxð0Þ; y1ð0Þ
0
m
1; y0ð1Þ
0; y1ð1Þ
hð1Þxð0Þ
x n
( )
y n
0( )
y n
1( )
y m
( )
f s
L f s
Switch
FIGURE 12.19
Commutative model for the polyphase interpolation ﬁlter.
580
CHAPTER 12 Multirate Digital Signal Processing

Combining two channels, we ﬁnally get
m
0; yð0Þ
y0ð0Þ þ y1ð0Þ
hð0Þxð0Þ
m
1; yð1Þ
y0ð1Þ þ y1ð1Þ
hð1Þxð0Þ
Therefore, yð1Þ matches that in the direct interpolation process given in Table 12.1.
Applying the polyphase interpolation ﬁlter using the commutative model in Figure 12.19, we have
y0ðnÞ
hð0ÞxðnÞ þ hð2Þxðn
1Þ
y1ðnÞ
hð1ÞxðnÞ þ hð3Þxðn
1Þ
When n
0,
m
0; yð0Þ
y0ð0Þ
hð0Þxð0Þ þ hð2Þxð
1Þ
hð0Þxð0Þ
m
1; yð1Þ
y1ð0Þ
hð1Þxð0Þ þ hð3Þxð
1Þ
hð1Þxð0Þ
Clearly, yð1Þ
hð1Þxð0Þ matches the yð1Þ result in Table 12.1.
Next, we will brieﬂy explain the properties of polyphase ﬁlters (that is, they have all-pass gain and
possible different phases). Each polyphase ﬁlter rkðnÞ operating at the original sampling rate fs
(assuming 8 kHz) is a downsampled version of the interpolation ﬁlter hðnÞ operating at the upsampling
rate Lfs (32 kHz assuming an interpolation factor of L ¼ 4). Considering that the designed interpolation
FIR ﬁlter coefﬁcients hðnÞ are the impulse response sequence with a ﬂat frequency spectrum up to
a bandwidth of fs=2 (assuming a bandwidth of 4 kHz with a perfect ﬂat frequency magnitude response,
theoretically) at a sampling rate of Lfs (32 kHz), we then downsample hðnÞ to obtain polyphase ﬁlters
by a factor of L ¼ 4 and operate them at a sampling rate of fs (8 kHz).
The Nyquist frequency after downsampling should be ðLfs=2Þ=L ¼ fs=2 (4 kHz); at the same time,
each downsampled sequence rkðnÞ operating at fs (8 kHz) has a ﬂat spectrum up to fs=2 (4 kHz) due to
the fs=2 (4 kHz) bandlimited sequence of hðnÞ at the sampling rate of Lfs (32 kHz). Hence, all of the
ployphase ﬁlters are all-pass ﬁlters. Since each polyphase rkðnÞ ﬁlter has different coefﬁcients, each
may have a different phase. Therefore, these polyphase ﬁlters are the all-pass ﬁlters with possible
different phases, theoretically.
Next, consider the decimation process in Figure 12.20. Assuming a three-tap decimation ﬁlter,
we have
H

z

¼ h

0

þ h

1

z 1 þ h

2

z 2
wðnÞ ¼ hð0ÞxðnÞ þ hð1Þxðn  1Þ þ hð2Þxðn  2Þ
The direct decimation process is shown in Table 12.2 for the purpose of comparison. Obtaining each
output yðmÞ requires processing ﬁlter difference equations twice, resulting in six multiplications and
four additions for this particular example.
x n
( )
2
w n
( )
y m
( )
FIGURE 12.20
Decimation by a factor of 2 and a three-tap anti-aliasing ﬁlter.
12.2 Polyphase Filter Structure and Implementation
581

The efﬁcient way to implement a polyphase ﬁlter is given in Figure 12.21.
Similarly, there are M polyphase ﬁlters. With the designed decimation ﬁlter HðzÞ of N taps, we can
obtain ﬁlter bank coefﬁcients by
rk

n

¼ h

k þ nM

for
k ¼ 0; 1; /; M  1
and
n ¼ 0; 1; /; N
M  1
(12.13)
For our example, we see that M  1 ¼ 1 and N=M  1 ¼ 1ðrounded upÞ. Thus, we have two
ﬁlter banks. Since k ¼ 0 and n ¼ 1, k þ nM ¼ 0 þ 1  2 ¼ 2. The time index upper limit
required for hðk þ nMÞ is 2 for the ﬁrst ﬁlter bank r0ðzÞ. Hence r0ðzÞ has ﬁlter coefﬁcients hð0Þ
and hð2Þ.
However, when k ¼ 1 and n ¼ 1, k þ nM ¼ 1 þ 1  2 ¼ 3, the time index upper limit required
for hðk þ nMÞ is 3 for the second ﬁlter bank, and the corresponding ﬁlter coefﬁcients are required to be
hð1Þ and hð3Þ. Since our direct interpolation ﬁlter hðnÞ does not contain the coefﬁcient hð3Þ, we set
hð3Þ ¼ 0 to get the second ﬁlter bank with one tap only, as shown in Figure 12.21. Also as shown in
that ﬁgure, achieving each yðmÞ requires three multiplications and one addition. In general, the number
of multiplications can be reduced by a factor of M.
The commutative model for the polyphase decimator is shown in Figure 12.22.
Table 12.2 Results of the Direct Decimation Process in Figure 12.20 (6 multiplications and 4
additions for obtaining each output yðmÞ)
n
xðnÞ
wðnÞ
m
yðmÞ
n
0
xð0Þ
wð0Þ
hð0Þxð0Þ
m
0
yð0Þ
hð0Þxð0Þ
n
1
xð1Þ
wð1Þ
hð0Þxð1Þ þ hð1Þxð0Þ discard
n
2
xð2Þ
wð2Þ
hð0Þxð2Þ þ hð1Þxð1Þ þ hð2Þxð0Þ
m
1
yð1Þ
hð0Þxð2Þþ
hð1Þxð1Þ þ hð2Þxð0Þ
n
3
xð3Þ
wð3Þ
hð0Þxð3Þ þ hð1Þxð2Þ þ hð2Þxð1Þ discard
n
4
xð5Þ
wð4Þ
hð0Þxð4Þ þ hð1Þxð3Þ þ hð2Þxð2Þ
m
2
yð2Þ
hð0Þxð4Þþ
hð1Þxð3Þ þ hð2Þxð2Þ
n
5
xð6Þ
wð5Þ
hð0Þxð5Þ þ hð1Þxð4Þ þ hð2Þxð3Þ discard
.
.
.
.
.
2
2
x n
( )
y m
0( )
y m
1( )
y m
( )
f s
f
M
s
w m
0( )
w m
1( )
FIGURE 12.21
Polyphase ﬁlter implementation for the decimation in Figure 12.20. (3 multiplications and 1 addition for obtaining
each output y(m)).
582
CHAPTER 12 Multirate Digital Signal Processing

EXAMPLE 12.6
Verify y(1) in Table 12.2 using the polyphase decimation ﬁlter implementation in Figure 12.21.
Solution:
Using Figure 12.21, we write the difference equations as
y0ðmÞ
hð0Þw0ðmÞ þ hð2Þw0ðm
1Þ
y1ðmÞ
hð1Þw1ðmÞ
Assuming n
0, n
1, n
2, and n
3, we have the inputs as xð0Þ, xð1Þ, xð2Þ and xð3Þ, and
w0ðmÞ : xð0Þ
xð2Þ
/
Delaying xðnÞ by one sample and decimating it by a factor or 2 leads to
w1ðmÞ :
0
xð1Þ
xð3Þ
/
Hence, applying the ﬁlter banks yields the following: For m
0, we have inputs for each ﬁlter as
w0ð0Þ
xð0Þ and w1ð0Þ
0
Then
y0ð0Þ
hð0Þw0ð0Þ þ hð2Þw0ð
1Þ
hð0Þxð0Þ
y1ð0Þ
hð1Þw1ð0Þ
hð1Þ  0
0
Combining two channels, we obtain
yð1Þ
y0ð1Þ þ y1ð1Þ
hð0Þxð0Þ þ 0
hð0Þxð0Þ
For m
1, we get inputs for each ﬁlter as
w0ð1Þ
xð2Þ
and
w1ð1Þ
xð1Þ
Then
y0ð1Þ
hð0Þw0ð1Þ þ hð2Þw0ð0Þ
hð0Þxð2Þ þ hð2Þxð0Þ
y1ð1Þ
hð1Þw1ð1Þ
hð1Þxð1Þ
Combining two channels leads to
yð1Þ
y0ð1Þ þ y1ð1Þ
hð0Þxð2Þ þ hð2Þxð0Þ þ hð1Þxð1Þ
We note that yð1Þ is the same as that shown in Table 12.2. Similar analysis can be done for the commutative
model shown in Figure 12.22.
x n
( )
y m
0( )
y m
1( )
y m
( )
f s
Switch
f
M
s
bank 0
bank 1
w m
0( )
w m
1( )
FIGURE 12.22
Commutative model for the polyphase decimation ﬁlter.
12.2 Polyphase Filter Structure and Implementation
583

Program 12.5 demonstrates the polyphase implementation of decimation. The program is modiﬁed
based on Program 12.1.
Program 12.5. Decimation using polyphase implementation.
close all; clear all;
% Downsampling filter (see Chapter 7 for FIR filter design)
B
[0.00074961181416 0.00247663033476
0.00146938649416
0.00440446121505.
0.00910635730662
0.00000000000000
0.02035676831506
0.02233710562885.
0.01712963672810
0.06376620649567
0.03590670035210 0.10660980550088.
0.29014909103794
0.37500000000000
0.29014909103794
0.10660980550088.
0.03590670035210
0.06376620649567
0.01712963672810 0.02233710562885.
0.02035676831506
0.00000000000000
0.00910635730662
0.00440446121505.
0.00146938649416
0.00247663033476
0.00074961181416];
% Generate 2048 samples
fs 8000;
% Sampling rate
N 2048;
% Number of samples
M 2;
% Downsample factor
n 0:1:N 1;
x 5*sin(n*pi/4)þcos(5*n*pi/8);
% Compute the single sided amplitude spectrum
% AC component will be doubled, and DC component will be kept the
% same value
X 2*abs(fft(x,N))/N;X(1) X(1)/2;
% Map the frequency index up to the folding frequency in Hz
f [0:1:N/2 1]*fs/N;
% Decimation
w0 x(1:M:N); p0 B(1:2:length(B)); % Downsampling
w1 filter([0 1],1,x); % Delay one sample
w1 w1(1:M:N); p1 B(2:M:length(B)) % Downsampling
y filter(p0,1,w0)þfilter(p1,1,w1);
NM length(y);
% Length of the downsampled data
% Compute the single sided amplitude spectrum for the downsampled
% signal
Y 2*abs(fft(y,NM))/NM;Y(1) Y(1)/2;
% Map the frequency index to the frequency in Hz
fsM [0:1:NM/2 1]*(fs/M)/NM;
% Plot spectra
subplot(2,1,1);plot(f,X(1:1:N/2));grid; xlabel(’Frequency (Hz)’);
subplot(2,1,2);plot(fsM,Y(1:1:NM/2));grid; xlabel(’Frequency (Hz)’);
Program 12.6 demonstrates polyphase implementation of interpolation using the information in
Program 12.2.
Program 12.6. Interpolation using polyphase implementation.
close all; clear all
% Upsampling filter (see Chapter 7 for FIR filter design)
B
[
0.00012783931504 0.00069976044649 0.00123831516738 0.00100277549136.
0.00025059018468
0.00203448515158
0.00300830295487
0.00174101657599.
584
CHAPTER 12 Multirate Digital Signal Processing

0.00188598835011 0.00578414933758 0.00649330625041 0.00177982369523.
0.00670672686935
0.01319379342716
0.01116855281442 0.00123034314117.
0.01775600060894 0.02614700427364 0.01594155162392
0.01235169936557.
0.04334322148505
0.05244745563466
0.01951094855292 0.05718573279009.
0.15568416401644 0.23851539047347 0.27083333333333 0.23851539047347.
0.15568416401644 0.05718573279009
0.01951094855292
0.05244745563466.
0.04334322148505
0.01235169936557 0.01594155162392 0.02614700427364.
0.01775600060894 0.00123034314117
0.01116855281442
0.01319379342716.
0.00670672686935 0.00177982369523 0.00649330625041 0.00578414933758.
0.00188598835011
0.00174101657599
0.00300830295487
0.00203448515158.
0.00025059018468 0.00100277549136 0.00123831516738 0.00069976044649.
0.00012783931504];
% Generate 2048 samples with fs 8000 Hz
fs 8000;
% Sampling rate
N 2048;
% Number of samples
L
3;
% Upsampling factor
n 0:1:N 1;
x 5*sin(n*pi/4)þcos(5*n*pi/8);
p0 B(1:L:length(B)); p1 B(2:L:length(B)); p2 B(3:L:length(B));
% Interpolation
w0 filter(p0,1,x);
w1 filter(p1,1,x);
w2 filter(p2,1,x);
y0 zeros(1,L*N);y0(1:L:length(y0)) w0;
y1 zeros(1,L*N);y1(1:L:length(y1)) w1;
y1 filter([0 1],1,y1);
y2 zeros(1,L*N);y2(1:L:length(y2)) w2;
y2 filter([0 0 1],1,y2);
y y0þy1þy2;
% Interpolated signal
NL
length(y);
% Length of the upsampled data
X 2*abs(fft(x,N))/N;X(1) X(1)/2; % Compute the one sided amplitude
% spectrum
f [0:1:N/2 1]*fs/N; % Map the frequency index to the frequency (Hz)
Y 2*abs(fft(y,NL))/NL;Y(1) Y(1)/2; % Compute the one sided amplitude
% spectrum
fsL [0:1:NL/2 1]*fs*L/NL;
% Map the frequency index to the frequency (Hz)
subplot(2,1,1);plot(f,X(1:1:N/2));grid; xlabel(’Frequency (Hz)’);
subplot(2,1,2);plot(fsL,Y(1:1:NL/2));grid; xlabel(’Frequency (Hz)’);
Note that wavelet transform and subband coding are also topics in the area of multirate signal
processing. We will pursue these subjects in Chapter 13.
12.3 OVERSAMPLING OF ANALOG-TO-DIGITAL CONVERSION
Oversampling of the analog signal has become more popular in the DSP industry to improve the
resolution of analog-to-digital conversion (ADC). Oversampling uses a sampling rate that is much
higher than the Nyquist rate. We can deﬁne an oversampling ratio as
12.3 Oversampling of Analog to Digital Conversion
585

fs
2fmax
>> 1
(12.14)
The beneﬁts of an oversampling ADC include
1. helping to design a simple analog anti-aliasing ﬁlter before ADC, and
2. reducing the ADC noise ﬂoor with possible noise shaping so that a low-resolution
ADC can be used.
12.3.1 Oversampling and Analog-to-Digital Conversion Resolution
To begin developing the relation between oversampling and ADC resolution, we ﬁrst summarize the
regular ADC and some useful deﬁnitions discussed in Chapter 2:
Quantization noise power ¼ s2
q ¼ D2
12
(12.15)
Quantization step ¼ D ¼ A
2n
(12.16)
where A ¼ full range of the analog signal to be digitized and n ¼ number of bits per sample (ADC
resolution).
Substituting Equation (12.16) into Equation (12.15), we have
Quantization noise power ¼ s2
q ¼ A2
12  2 2n
(12.17)
The power spectral density of the quantization noise with an assumption of uniform probability
distribution is shown in Figure 12.23. Note that this assumption is true for quantizing a uniformly
q
sf
2
f s
2
f s
2
q
q
s
s
P f df
area
f
f
2
2
(
)
f s
n bit ADC
FIGURE 12.23
Regular ADC system.
586
CHAPTER 12 Multirate Digital Signal Processing

distributed signal in a full range with a sufﬁciently long duration. It is not generally true in practice.
See research papers authored by Lipshitz et al. (1992) and Maher (1992). However, using the
assumption will guide us to some useful results for oversampling systems.
The quantization noise power is the area obtained from integrating the power spectral density
function in the range of fs=2 to fs=2. Now let us examine the oversampling ADC, where the
sampling rate is much larger than that of the regular ADC; that is fs >> 2fmax. The scheme is shown in
Figure 12.24.
As we can see, oversampling can reduce the level of noise power spectral density. After the
decimation process with the decimation ﬁlter, only a portion of quantization noise power in the range
from fmax and fmax is kept in the DSP system. We call this an in-band frequency range.
In Figure 12.24, the shaded area, which is the quantization noise power, is given by
Quantization noise power ¼
ZN
N
P

f

df ¼ 2fmax
fs
 s2
q ¼ 2fmax
fs
$A2
12  2 2m
(12.18)
Assuming that the regular ADC shown in Figure 12.23 and the oversampling ADC shown in
Figure 12.24 are equivalent, we set their quantization noise powers to be the same to obtain
A2
12$2 2n ¼ 2fmax
fs
$A2
12  2 2m
(12.19)
Equation (12.19) leads to two useful equations for applications:
n ¼ m þ 0:5  log2
 fs
2fmax

and
(12.20)
fs ¼ 2fmax  22ðn mÞ
(12.21)
P f
( )
q
sf
2
f max
f s
2
f s
f
f
s
'
max
2
f s
2
f max
m bit ADC
oversampling
Decimator
Oversampling rate
Minimum sampling rate
In band noise
M
Anti-aliasing LPF
FIGURE 12.24
Oversampling ADC system.
12.3 Oversampling of Analog to Digital Conversion
587

where
fs ¼ sampling rate in the oversampling DSP system
fmax ¼ maximum frequency of the analog signal
m ¼ number of bits per sample in the oversampling DSP system
n ¼ number of bits per sample in the regular DSP system using the minimum sampling rate
From Equation (12.20) and given the number of bits (m) used in the oversampling scheme, we can
determine the number of bits per sample equivalent to the regular ADC. On the other hand, given the
number of bits in the oversampling ADC, we can determine the required oversampling rate so that the
oversampling ADC is equivalent to the regular ADC with the larger number of bits per sample (n). Let
us look at the following examples.
EXAMPLE 12.7
Given an oversampling audio DSP system with maximum audio input frequency of 20 kHz and ADC resolution of
14 bits, determine the oversampling rate to improve the ADC resolution to 16 bit resolution.
Solution:
Based on the speciﬁcations, we have
fmax
20 kHz; m
14 bits
and
n
16 bits
Using Equation (12.21) leads to
fs
2fmax  22ðnmÞ
2  20  22ð1614Þ
640 kHz
Since fs=ð2fmaxÞ
24, we see that each doubling of the minimum sampling rate (2fmax
40 kHz) will increase
the resolution by a half bit.
EXAMPLE 12.8
Given an oversampling audio DSP system with a maximum audio input frequency of 4 kHz, and ADC resolution of 8
bits, an a sampling rate of 80 MHz, determine the equivalent ADC resolution.
Solution:
Since fmax
4 kHz, fs
80 kHz, and m
8 bits, appyling Equation (12.20) yields
n
m þ 0:5  log2
 fs
2fmax

8 þ 0:5  log2
80;000 kHz
2  4 kHz

z 15 bits
The MATLAB program shown in Program 12.7 validates the oversampling technique. We consider
the following signal,
xðtÞ ¼ 1:5 sin ð2p  150tÞ þ 0:9 sin ð2p  175t þ p=6Þ þ 0:6 sin ð2p  200t þ p=4Þ
(12.22)
with a regular sampling rate of 1 kHz. The oversampling rate is 4 kHz and each sample is quantized
using a 3-bit code. The anti-aliasing lowpass ﬁlter is designed with a cutoff frequency of
U ¼ 2pfmaxT ¼ 2p  500=4;000 ¼ 0:25p radians. Figure 12.25 shows the frequency responses of
588
CHAPTER 12 Multirate Digital Signal Processing

the designed ﬁlter while Figure 12.26 compares the signals in the time and frequency domains,
respectively, where xðtÞ denotes the continuous version, xqðnÞ is the quantized version using a regular
sampling rate of 1 kHz, and yqðnÞ is the enhanced version using the oversampling system with L ¼ 4.
The detailed amplitude comparisons are given in Figure 12.27. The measured signal-to-noise ratios
(SNRs) are 14.3 dB using the regular sampling system and 21.0 dB using the oversampling system.
Since L ¼ 4, the achieved signal is expected to have 4-bit quality (0:5  log2 4 ¼ 1 bit improvement).
From simulation, we achieve an SNR improvement of approximately 6dB. The improvement will stop
when L increases due to the fact that when the sampling increases the quantization error may have
correlation with the sinusoidal signal. The degradation performance can be cured using the dithering
technique (Tan and Wang, 2011), which is beyond our scope.
Program 12.7. Oversampling implementation.
clear all; close all,clc
ntotal 512;
n 0:ntotal; % Number of samples
L 4; % Oversampling factor
nL 0:ntotal*L; % Number of samples for oversampling
numb 3; % Number of bits
A 2^(numb 1) 1; % Peak value
f1 150;C1 0.5*A;f2 175;C2 A*0.3;f3 200;C3 A*0.2; % Frequencies and amplitudes
0
200
400
600
800
1000
1200
1400
1600
1800
2000
8000
6000
4000
2000
0
Frequency (Hz)
Phase (degrees)
0
200
400
600
800
1000
1200
1400
1600
1800
2000
150
100
50
0
50
Frequency (Hz)
Magn tude (dB)
FIGURE 12.25
Frequency responses of the designed ﬁlter.
12.3 Oversampling of Analog to Digital Conversion
589

fmax 500;fs 1000;T 1/fs; % Maximum frequency, sampling rate, sampling period
fsL L*fs;TL 1/fsL;% Oversampling rate and oversampling period
% Sampling at fs 1000 Hz
x C1*sin(2*pi*f1*n*T)þC2*sin(2*pi*f2*T*nþpi/6)þC3*sin(2*pi*f3*T*nþpi/4);
xq round(x); % Quantized signal at the minimum sampling rate
NN length(n);
f [0:ntotal 1]*fs/NN;
M 32*L;nd M/L; % Delay in terms of samples due to anti aliasing filtering
B firwd(2*Mþ1,1,2*pi*fmax/fsL,0,4); % Anti aliasing filter design (5% transition
% bandwidth)
figure(1);
freqz(B,1,1000,fsL)
% Oversampling
xx C1*sin(2*pi*f1*nL*TL)þC2*sin(2*pi*f2*nL*TLþpi/6)þC3*sin(2*pi*f3*nL*TLþpi/4);
xxq round(xx); % Quantized signal
% Down sampling
y filter(B,1,xxq);% Anti aliasing filtering
yd y(1:L:length(y));% Downsample
figure (2)
subplot(3,2,1);plot(n,x,’k’);grid;axis([0 500
5 5]);ylabel(’x(t)’)
Ak 2*abs(fft(x))/NN; Ak(1) Ak(1)/2;
0
100
200
300
400
500
5
0
5
x(t)
0
100
200
300
400
500
4
2
0
2
X(f)
0
100
200
300
400
500
5
0
5
xq(n)
0
100
200
300
400
500
4
2
0
2
Xq(f)
0
100
200
300
400
500
5
0
5
yq(n)
Sample number
0
100
200
300
400
500
4
2
0
2
Yq(f)
Frequency (Hz)
FIGURE 12.26
Signal comparisons in both the time and frequency domains.
590
CHAPTER 12 Multirate Digital Signal Processing

subplot(3,2,2);plot(f(1:NN/2),log10(Ak(1:NN/2)),’k’);grid;ylabel(’X(f)’); axis([0 500
4 2])
subplot(3,2,3);plot(n,xq,’k’);grid;axis([0 500
5 5]);ylabel(’xq(n)’);
Ak 2*abs(fft(xq))/NN; Ak(1) Ak(1)/2;
subplot(3,2,4);plot(f(1:NN/2),log10(Ak(1:NN/2)),’k’);grid;ylabel(’Xq(f)’); axis([0 500
4 2])
subplot(3,2,5);plot(n,yd,’k’);grid;axis([0 500
5 5]);ylabel(’yq(n)’);
xlabel(’Sample number’);
Ak 2*abs(fft(yd))/NN; Ak(1) Ak(1)/2;
subplot(3,2,6);plot(f(1:NN/2),log10(Ak(1:NN/2)),’k’);grid;ylabel(’Yq(f)’); axis([0 500
4 2])
xlabel(’Frequency (Hz)’);
figure (3)
plot(n(1:50),x(1:50),’k’,’LineWidth’,2); hold % Plot of ﬁrst 50 samples
stairs(n(1:50),xq(1:50),’b’);
stairs(n(1:50),yd(1þnd:50þnd),’r’,’LineWidth’,2);grid
axis([0 50
5 5]);xlabel(’Sample number’);ylabel(’Amplitudes’)
snr(x,xq);
snr(x(1:ntotal nd),yd(1þnd:ntotal));
0
5
10
15
20
25
30
35
40
45
50
5
4
3
2
1
0
1
2
3
4
5
Sample number
Amp tudes
x(t)
yq(n)
xq(n)
FIGURE 12.27
Comparisons of continuous, regular sampled, and oversampled signal amplitudes.
12.3 Oversampling of Analog to Digital Conversion
591

12.3.2 Sigma-Delta Modulation Analog-to-Digital Conversion
To further improve ADC resolution, sigma-delta modulation (SDM) ADC is used. The principles of
the ﬁrst-order SDM are described in Figure 12.28.
First, the analog signal is sampled to obtain the discrete-time signal xðnÞ. This discrete-time signal
is subtracted by the analog output from the m-bit DAC, converting the m-bit oversampled digital signal
yðnÞ. Then the difference is sent to the discrete-time analog integrator, which is implemented by the
switched-capacitor technique, for example. The output from the discrete-time analog integrator is
converted using an m-bit ADC to produce the oversampled digital signal. Finally, the decimation ﬁlter
removes outband quantization noise. Further decimation processes can change the oversampling rate
back to the desired sampling rate for the output digital signal w(m).
To examine the SDM, we need to develop a DSP model for the discrete-time analog ﬁlter described
in Figure 12.29.
As shown in Figure 12.29, the input signal cðnÞ designates the amplitude at time instant n, while the
output dðnÞ is the area under the curve at time instant n, which can be expressed as a sum of the area
under the curve at time instant n  1 and an area increment:
dðnÞ ¼ dðn  1Þ þ area incremetal
Using the extrapolation method, we have
dðnÞ ¼ dðn  1Þ þ 1  cðnÞ
(12.23)
Applying the z-transform to Equation (12.23) leads to a transfer function of the discrete-time analog
ﬁlter as
H

z

¼ DðzÞ
CðzÞ ¼
1
1  z 1
(12.24)
Again, considering that the m-bit quantization requires one sample delay, we get the DSP model for the
ﬁrst-order SDM depicted in Figure 12.30, where yðnÞ is the oversampling data encoded by m bits each,
and eðnÞ represents quantization error.
The SDM DSP model represents a feedback control system. Appling the z-transform leads to
Y

z

¼
1
1  z 1

X

z

 z 1Y

z

þ E

z

(12.25)
x t( )
x n
( )
Discrete-time
analog
integrator
m-bit
ADC
m-bit
DAC
S/H
y n
( )
w m
( )
Analog
signal
Decimator
M
Anti-aliasing LPF
FIGURE 12.28
Block diagram of SDM ADC.
592
CHAPTER 12 Multirate Digital Signal Processing

After simple algebra, we have
Y

z

¼
XðzÞ
|ﬄ{zﬄ}
Original
digital signal
transform
þ

1  z 1
|ﬄﬄﬄﬄﬄﬄ{zﬄﬄﬄﬄﬄﬄ}
Highpass
filter
$
EðzÞ
|ﬄ{zﬄ}
Quantization
error
transform
(12.26)
In Equation (12.26), the indicated highpass ﬁlter pushes quantization noise to the high-frequency
range, where later the quantization noise can be removed by the decimation ﬁlter. Thus we call this
highpass ﬁlter ð1  z 1Þ the noise shaping ﬁlter (illustrated in Figure 12.31).
Shaped-in-band noise power after use of decimation ﬁlter can be estimated by the solid area under
the curve. We have
Shaped-in-band noise power ¼
ZUmax
Umax
s2
q
2p
		1  e jU		2dU
(12.27)
Discrete-time
analog
integrator
c n
( )
d n
( )
n
c n
( )
d n
area under the curve at n
( )
d n
area under the curve at n
(
)
1
1
n
n
1
0
1
2
c( )
0
c( )1 c( )
2
c n
(
)1
c n
( )
area increment
c n
1
( )
FIGURE 12.29
Illustration of discrete-time analog integrator.
x n
( )
y n
( )
w n
( )
H z
z
( )
1
1
1
z 1
e n
( )
Quantization error
Decimator
M
Anti-aliasing LPF
encoded by m bits
FIGURE 12.30
DSP model for ﬁrst-order SDM ADC.
12.3 Oversampling of Analog to Digital Conversion
593

Using the Maclaurin series expansion and neglecting the higher-order terms due to the small value of
Umax, we yield
1  e jU ¼ 1 
 
1 þ ðjUÞ
1!
þ ðjUÞ2
2!
þ /
!
z jU
Applying this approximation to Equation (12.27) leads to
Shaped-in-band noise power z
ZUmax
Umax
s2
q
2pjjUj2dU ¼
s2
q
3p U3
max
(12.28)
After simple algebra, we have
Shaped-in-band noise power z
p2s2
q
3
2fmax
fs
3
¼ p2
3 $A22 2m
12
2fmax
fs
3
(12.29)
If we let the shaped-in-band noise power equal the quantization noise power from the regular ADC
using a minimum sampling rate, we have
p2
3 $A22 2m
12
2fmax
fs
3
¼ A2
12$2 2n
(12.30)
P f
( )
f
Hz
(
)
f max
f s
2
f s
f s
2
f max
In-band
quantization
 noise
In-band
quantization
 noise without
SDM
 Quantization
 noise to be
shaped and
filtered with
SDM
Noise shaping
filter frequency
response
1
e
j
q
sf
2
x n
( )
y n
( )
w m
( )
m-bit SDM ADC
oversampling
Oversampling rate
Decimator
M
f
f
s
'
max
2
Anti-aliasing LPF
FIGURE 12.31
Noise shaping of quantization noise for SDM ADC.
594
CHAPTER 12 Multirate Digital Signal Processing

We modify Equation (12.30) into the following useful formats for applications:
n ¼ m þ 1:5  log2
 fs
2fmax

 0:86
(12.31)
 fs
2fmax
3
¼ p2
3  22ðn mÞ
(12.32)
EXAMPLE 12.9
Given the following DSP system speciﬁcations, determine the equivalent ADC resolution.
Oversampling rate system
First order SDM with 2 bit ADC
Sampling rate
4 MHz
Maximum audio input frequency
4 kHz
Solution:
Since m
2 bits, and
fs
2fmax
4;000 kHz
2  4 kHz
500
we calculate
n
m þ 1:5  log2
 fs
2fmax

0:86
2 þ 1:5  log2 ð500Þ
0:86 z 15 bits
We can also extend the ﬁrst-order SDM DSP model to the second-order SDM DSP model by
cascading one section of the ﬁrst-order discrete-time analog ﬁlter as depicted in Figure 12.32.
Similarly to the ﬁrst-order SDM DSP model, applying the z-transform leads to the following
relationship:
Y

z

¼
XðzÞ
|ﬄ{zﬄ}
Original
digital signal
transform
þ

1  z 1
|ﬄﬄﬄﬄﬄﬄ{zﬄﬄﬄﬄﬄﬄ}
Highpass
noise shaping
filter
2
$
EðzÞ
|ﬄ{zﬄ}
Quantization
error
transform
(12.33)
Notice that the noise shape ﬁlter becomes a second-order highpass ﬁlter; hence, the more quantization
noise is pushed to the high frequency range, the better ADC resolution is expected to be. In a similar
analysis to the ﬁrst-order SDM, we get the following useful formulas:
n ¼ m þ 2:5  log2
 fs
2fmax

 2:14
(12.34)
12.3 Oversampling of Analog to Digital Conversion
595

x n
( )
y n
( )
w n
( )
H z
z
( )
1
1
1
z 1
e n
( ) Quantization error
H z
z
( )
1
1
1
Decimator
M
Anti-aliasing LPF
encoded by m bits
FIGURE 12.32
DSP model for the second-order SDM ADC.
 fs
2fmax
5
¼ p4
5  22ðn mÞ
(12.35)
In general, the Kth-order SDM DSP model and ADC resolution formulas are given as
Y

z

¼
XðzÞ
|ﬄ{zﬄ}
Original
digital signal
transform
þ

1  z 1K
|ﬄﬄﬄﬄﬄﬄﬄ{zﬄﬄﬄﬄﬄﬄﬄﬄ}
Highpass
noise shaping
filter

EðzÞ
|ﬄ{zﬄ}
Quantization
error
transform
(12.36)
n ¼ m þ 0:5$ð2K þ 1Þ  log2
 fs
2fmax

 0:5  log2
 p2K
2K þ 1

(12.37)
 fs
2fmax
2Kþ1
¼
p2K
2K þ 1  22ðn mÞ
(12.38)
EXAMPLE 12.10
Given an oversampling rate DSP system with the following speciﬁcations, determine the effective ADC resolution:
Second order SDM
1 bit ADC
Sampling rate
1 MHz
Maximum audio input frequency
4 kHz
Solution:
n
1 þ 2:5  log2
1;000 kHz
2  4 kHz

2:14 z 16 bits
596
CHAPTER 12 Multirate Digital Signal Processing

We implement the ﬁrst-order SDM system using the same continuous signal in Equation (12.22). The
continuoussignalisoriginallysampledat1kHzandeachsampleisencodedusing3bits.TheSDMsystem
uses an oversampling rate of 8 kHz (L ¼ 8) and each sample is quantized using a 3-bit code. The anti-
aliasing lowpass ﬁlter is designed with a cutofffrequency of U ¼ 2pfmaxT ¼ 2p  500=8;000 ¼ p=8
radians. Figure 12.33 shows the frequency responses of the designed ﬁlter while Figure 12.34
compares the time and frequency domain signals, where xðtÞ designates the continuous version, xqðnÞ
denotes the quantized version using a regular sampling rate (L ¼ 1), and yqðnÞ is the enhanced version
using L ¼ 8. The detailed amplitude comparisons are given in Figure 12.35. The measured SNRs are
14.3 dB in the regular sampling system and 33.83 dB in the oversampling SDM system. We observe
a signiﬁcant SNR improvement of 19.5 dB. The detailed implementation using MATLAB is given in
Program 12.8.
Program 12.8. First-order SDM oversampling implementation.
clear all; close all;clc
ntotal 512; % Number of samples
n 0:ntotal;
L 8; % Oversampling factor
nL 0:ntotal*L;numb 3;A 2^(numb 1) 1; % Peak value
f1 150;C1 0.5*A;f2 175;C2 A*0.3;f3 200;C3 A*0.2;% Frequencies and amplitudes
fmax 500;fs 1000; T 1/fs; % Sampling rate and sampling period
fsL L*fs;TL 1/fsL; % Oversampling rate and oversampling period
0
500
1000
1500
2000
2500
3000
3500
4000
8000
6000
4000
2000
0
Frequency (Hz)
Phase (degrees)
0
500
1000
1500
2000
2500
3000
3500
4000
150
100
50
0
50
Frequency (Hz)
Magn tude (dB)
FIGURE 12.33
Frequency responses of the designed ﬁlter.
12.3 Oversampling of Analog to Digital Conversion
597

% Sampling at fs
1000 Hz
x C1*sin(2*pi*f1*n*T)þC2*sin(2*pi*f2*T*nþpi/6)þC3*sin(2*pi*f3*T*nþpi/4);
xq round(x); % Quantization
NN length(n);
M 32*L;nd M/L; % Delay in terms of samples for anti aliasing filtering
B firwd(2*Mþ1,1,2*pi*fmax/fsL,0,4); % Design of an anti aliasing filter
figure(1)
freqz(B,1,1000,fsL);
% Oversampling
xx C1*sin(2*pi*f1*nL*TL)þC2*sin(2*pi*f2*nL*TLþpi/6)þC3*sin(2*pi*f3*nL*TLþpi/4);
% The first order SDM processing
yq zeros(1,ntotal*Lþ1þ1); % Initializing the buffer
y yq;
for i 1:ntotal*L
y(iþ1) (xx(iþ1) yq(i))þy(i);
yq(iþ1) round(y(iþ1));
end
xxq yq(1:ntotal*Lþ1); % Signal quantization
% Downsampling
y filter(B,1,xxq);
yd y(1:L:length(y));
f [0:ntotal 1]*fs/NN;
0
100
200
300
400
500
5
0
5
x(t)
0
100
200
300
400
500
2
0
2
X(f)
0
100
200
300
400
500
5
0
5
xq(n)
0
100
200
300
400
500
2
0
2
Xq(f)
0
100
200
300
400
500
5
0
5
yq(n)
Sample number
0
100
200
300
400
500
2
0
2
Yq(f)
Frequency (Hz)
FIGURE 12.34
Signal comparisons in both the time and frequency domains.
598
CHAPTER 12 Multirate Digital Signal Processing

figure (2)
subplot(3,2,1);plot(n,x,’k’);grid;axis([0 500
5 5]);ylabel(’x(t)’);
Ak 2*abs(fft(x))/NN; Ak(1) Ak(1)/2;
subplot(3,2,2);plot(f(1:NN/2),log10(Ak(1:NN/2)),’k’);grid;
axis([0 500
3 2]);ylabel(’X(f)’);
subplot(3,2,3);plot(n,xq,’k’);grid;axis([0 500
5 5]);ylabel(’xq(n)’);
Ak 2*abs(fft(xq))/NN; Ak(1) Ak(1)/2;
subplot(3,2,4);plot(f(1:NN/2),log10(Ak(1:NN/2)),’k’);grid
axis([0 500
3 2]);ylabel(’Xq(f)’);
subplot(3,2,5);plot(n,yd,’k’);grid;axis([0 500
5 5]);ylabel(’yq(n)’);
xlabel(’Sample number’);
Ak 2*abs(fft(yd))/NN; Ak(1) Ak(1)/2;
subplot(3,2,6);plot(f(1:NN/2),log10(Ak(1:NN/2)),’k’);grid
axis([0 500
3 2]);ylabel(’Yq(f)’);xlabel(’Frequency (Hz)’);
figure (3)
plot(n(1:50),x(1:50),’k’,’LineWidth’,2); hold
stairs(n(1:50),xq(1:50),’b’);
stairs(n(1:50),yd(1þnd:50þnd),’r’,’LineWidth’,2);
axis([0 50
5 5]);grid;xlabel(’Sample number’);ylabel(’Amplitudes’);
snr(x,xq);
snr(x(1:ntotal nd),yd(1þnd:ntotal));
0
5
10
15
20
25
30
35
40
45
50
5
4
3
2
1
0
1
2
3
4
5
Sample number
Amp tudes
xq(n)
yq(n)
x(t)
FIGURE 12.35
Comparison of continuous, regular sampled, and oversampled signal amplitudes.
12.3 Oversampling of Analog to Digital Conversion
599

Next, we review application of oversampling ADC in industry. Figure 12.36 illustrates a function
diagram for the MAX1402 low-power, multichannel oversampling sigma-delta analog-to-digital
converter used in industry. It applies a sigma-delta modulator with a digital decimation ﬁlter to achieve
16-bit accuracy. The device offers three fully differential input channels, which can be independently
programmed. It can also be conﬁgured as ﬁve pseudo-differential input channels. It comprises two
chopper buffer ampliﬁers and a programmable gain ampliﬁer, a DAC unit with predicted input sub-
tracted from the analog input to acquire the differential signal, and a second-order switched-capacitor
sigma-delta modulator.
The chip produces a 1-bit data stream, which will be ﬁltered by the integrated digital ﬁlter to
complete ADC. The digital ﬁlter’s user-selectable decimation factor offers ﬂexibility as conversion
resolution can be reduced in exchange for a higher data rate or vice versa. The integrated digital
lowpass ﬁlter is a ﬁrst-order or third-order Sinc inﬁnite impulse response ﬁlter. Such a ﬁlter offers
notches corresponding to its output data rate and its frequency harmonics, so it can effectively reduce
the developed image noises in the frequency domain (the Sinc ﬁlter is beyond the scope of our
discussion). The MAX1402 can provide 16-bit accuracy at 480 samples per second and 12-bit
accuracy at 4,800 samples per second. The chip ﬁnds wide application in sensors and instrumentation.
The MAX1402 data sheet contains detailed ﬁgure information (Maxim Integrated Products, 2007).
FIGURE 12.36
Functional diagram for the sigma-delta ADC.
600
CHAPTER 12 Multirate Digital Signal Processing

12.4 APPLICATION EXAMPLE: CD PLAYER
Figure 12.37 illustrates a CD playback system, also described earlier in this chapter. A laser
optically scans the tracks on a CD to produce a digital signal. The digital signal is then
demodulated, and parity bits are used to detect bit errors due to manufacturing defects, dust, and so
on, and to correct them. The demodulated signal is again oversampled by a factor of 4 and hence
the sampling rate is increased to 176.4 kHz for each channel. Each digital sample then passes
through a 14-bit DAC, which produces the sample-and-hold voltage signals that pass the anti-image
lowpass ﬁlter. The output from each analog ﬁlter is fed to its corresponding loudspeaker. Over-
sampling relaxes the design requirements of the analog anti-image lowpass ﬁlter, which is used to
smooth out the voltage steps.
The earliest system used a third-order Bessel ﬁlter with a 3-dB gain attenuation at 30 kHz. Notice
that ﬁrst-order sigma delta modulation (ﬁrst-order SDM) is added to the 14-bit DAC unit to further
improve the 14-bit DAC to 16-bit DAC.
Let us examine the single-channel DSP portion as shown in Figure 12.38.
The spectral plots for the oversampled and interpolated signal xðnÞ, the 14-bit SDM output yðnÞ,
and the ﬁnal analog output audio signal are given in Figure 12.39. As we can see in plot (a) in the
ﬁgure, the quantization noise is uniformly distributed, and only in-band quantization noise (0 to 22.05
kHz) is expected. Again, 14 bits for each sample are kept after oversampling. Without using the ﬁrst-
order SDM, we expect the effective ADC resolution due to oversampling to be
n ¼ 14 þ 0:5  log2
176:4
44:1

¼ 15 bits
which is fewer than 16 bits. To improve quality further, the ﬁrst-order SDM is used. The in-band
quantization noise is then shaped. The ﬁrst-order SDM pushes quantization noise to the high-
frequency range, as illustrated in plot (b) in Figure 12.39. The effective ADC resolution now becomes
n ¼ 14 þ 1:5  log2
176:4
44:1

 0:86 z 16 bits
CD
Optical pickup
Demodulation
Error correction
4x
Over-
sampling
14-bit
DAC
1st-order
SDM
14-bit
DAC
1st-order
SDM
Anti-image
LP filter
Anti-image
LP filter
Amplified
left speaker
Amplified
right speaker
FIGURE 12.37
Simpliﬁed decoder of a CD recording system.
12.4 Application Example: CD Player
601

Hence, 16-bit ADC audio quality is preserved. On the other hand, from plot (c) in Figure 12.39, the
audio occupies a frequency range up to 22.05 kHz, while the DSP Nyquist limit is 88.2 kHz, so the
low-order analog anti-image ﬁlter can satisfy the design requirement.
Analog
LPF
y m
( )
K
z
1
1
z 1
e m
( ) Quantization
error
Oversampling by 4
1st order SDM
m=14 bits
44.1
sf
kHz
n
bits
16
4 44.1
176.4
sf
kHz
m
( )
x n
( )
4
Anti-image LPF
FIGURE 12.38
Illustration of oversampling and SDM ADC used in the decoder of a CD recording system.
(
)
f kHz
X f
( )
441.
2
8
8
0
.
132 3.
22 05
.
176 4.
14 bit in band
quantization
noise
(
)
f kHz
Y f
( )
441.
2
8
8
0
.
132 3.
22 05
.
176 4.
14 bit in band
shaped noise
with the SDM
(
)
f kHz
441.
2
8
8
0
.
132 3.
22 05
.
176 4.
14 bit in band
shaped noise
with the SDM
Analog LPF
Best audio
(b)
(c)
(d)
FIGURE 12.39
Spectral illustrations for oversampling and SDM ADC used in the decoder of a CD recording system.
602
CHAPTER 12 Multirate Digital Signal Processing

12.5 UNDERSAMPLING OF BANDPASS SIGNALS
As we discussed in Chapter 2, the sampling theorem requires that the sampling rate be twice as large as
the highest frequency of the analog signal to be sampled. The sampling theorem ensures the complete
reconstruction of the analog signal without aliasing distortion. In some applications, such as the
modulated signals in communications systems, the signal exists in only a small portion of the band-
width. Figure 12.40 shows an amplitude modulated (AM) signal in both the time domain and
frequency domain. Assuming that the message signal has a bandwidth of 4 kHz and a carrier frequency
of 96 kHz, the upper frequency edge of the AM signal is therefore 100 kHz (fcþB). Then the tradi-
tional sampling process requires that the sampling rate be larger than 200 kHz 2(fcþB), resulting in at
a high processing cost. Note that sampling the baseband signal of 4 kHz only requires a sampling rate
of 8 kHz (2B).
If a certain condition is satisﬁed at the undersampling stage, we are able to make use of the aliasing
signal to recover the message signal, since the aliasing signal contains the folded original message
information (which we used to consider distortion). The reader is referred to the undersampling
technique discussed in Ifeachor and Jervis (2002) and Porat (1997). Let the message to be recovered
have a bandwidth of B, the theoretical minimum sampling rate be fs ¼ 2B, and the carrier frequency
of the modulated signal be fc. We discuss the following cases.
Case 1
If fc ¼ even integer  B and fc ¼ 2B, the sampled spectrum with all the replicas will be as shown
in Figure 12.41(a).
As an illustrative example in the time domain for Case 1, suppose we have a bandpass signal with
a carrier frequency of 20 Hz; that is,
xðtÞ ¼ cos ð2p  20tÞmðtÞ
(12.39)
t
Message signal with a
bandwidth of B Hz
Carrier signal with a
frequency of fc Hz
Modulated signal x(t)
f
( )
X f
cf
cf
U
L
L
U
B
cf
B
f
B
Message signal
spectrum with a
bandwidth of B Hz
FIGURE 12.40
Message signal, modulated signal, and their spectra.
12.5 Undersampling of Bandpass Signals
603

where mðtÞ is the message signal with a bandwidth of 2 Hz. Using a sampling rate of 4 Hz by
substituting t ¼ nT, where T ¼ 1=fs into Equation (12.39), we get the sampled signal as
xðnTÞ ¼ cos ð2p  20tÞmðtÞ
		
t¼nT ¼ cos ð2p  20n=4ÞmðnTÞ
(12.40)
Since 10np ¼ 5nð2pÞ is a multiple of 2p,
cos ð2p  20n=4Þ ¼ cos ð10pnÞ ¼ 1
(12.41)
we obtain the undersampled signal as
xðnTÞ ¼ cos ð2p  20n=4ÞmðnTÞ ¼ mðnTÞ
(12.42)
which is a perfect digital message signal. Figure 12.42 shows the bandpass signal and its sampled
signals when the message signal is 1 Hz, given as
mðtÞ ¼ cos ð2ptÞ
(12.43)
Case 2
If fc ¼ odd integer  B and fc ¼ 2B, the sampled spectrum with all the replicas will be as
shown in Figure 12.41(b), where the spectral portions L and U are reversed. Hence, frequency
reversal will occur. Then a further digital modulation in which the signal is multiplied by the
digital oscillator with a frequency of B Hz can be used to adjust the spectrum to be the same as
that in Case 1.
As another illustrative example for Case 2, let us sample the following the bandpass signal with
a carrier frequency of 22 Hz, given by
xðtÞ ¼ cos ð2p  22tÞmðtÞ
(12.44)
Bandpass filter
ADC
( )
x t
sf
U
L
( )
x n
U
L
U
L
U
L
U
L
f
U
L
U
L
U
L
U
L
U
L
f
Spectrum for x(n) for
fs  even integer x B Hz
Spectrum for x(n) for
fs  odd integer x B Hz
(a)
(b)
FIGURE 12.41
Spectrum of the undersampled signal.
604
CHAPTER 12 Multirate Digital Signal Processing

Applying undersampling using a sampling rate of 4 Hz, it follows that
xðnTÞ ¼ cos ð2p  22n=4ÞmðnTÞ ¼ cos ð11npÞmðnTÞ
(12.45)
Since 11np can be either an odd or an even integer multiple of p, we have
cos

11pn

¼
(
1
n ¼ odd
1
n ¼ even
(12.46)
We see that Equation (12.46) causes the message samples to change sign alternatively with a carrier
frequency of 22 Hz, which is the odd integer multiple of the message bandwidth of 2 Hz. This in fact
will reverse the baseband message spectrum. To correct the spectrum reversal, we multiply an
oscillator with a frequency of B ¼ 2 Hz by the bandpass signal, that is
xðtÞcos ð2p  2tÞ ¼ cos ð2p  22tÞmðtÞcos ð2p  2tÞ
(12.47)
Then the undersampled signal is given by
xðnTÞcos ð2p  2n=4Þ ¼ cos ð2p  22n=4ÞmðnTÞcos ð2p  2n=4Þ
¼ cos ð11npÞmðnTÞcos ðnpÞ
(12.48)
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
-1
-0.8
-0.6
-0.4
-0.2
0
0.2
0.4
0.6
0.8
1
x(t) and x(nT)
Case 1 fc even number x 2 Hz 20 Hz, fs 4 Hz
Time (sec.)
Bandpass
signal
Sampled
signal
FIGURE 12.42
Plots of the bandpass signal and sampled signal for Case 1.
12.5 Undersampling of Bandpass Signals
605

0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
-1
-0.5
0
0.5
1
Time (sec.)
x(t) and x(nT)
Case 2: fc  odd number x B 22 Hz, fs 2B 4 Hz
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
-1
-0.5
0
0.5
1
Time (sec.)
Case 2: fc  odd number x B 22 Hz, fs 2B 4 Hz, with B 2 Hz oscillator
x(t)*cos(2*p *2*t) and m(nT)
Phase
distortion
Message
signals
FIGURE 12.43
Plots of the bandpass signals and sampled signals for Case 2.
Since
cos ð11pnÞcos ðpnÞ ¼ 1
(12.49)
it follows that
xðnTÞcos ð2p  2n=4Þ ¼ cos ðp  11nÞmðnTÞcos ðp  nÞ ¼ mðnTÞ
(12.50)
which is the recovered message signal. Figure 12.43 shows the sampled bandpass signals with the
reversed message spectrum and the corrected message spectrum, respectively, for a message signal
having a frequency of 0.5 Hz; that is,
mðtÞ ¼ cos ð2p  0:5tÞ
(12.51)
Case 3
If fc ¼ noninterger  B, we can extend the bandwidth B to B such that
fc ¼ integer  B
and
fs ¼ 2B
(12.52)
Then we can apply Case 1 or Case 2. An illustration of Case 3 is included in the following
example.
606
CHAPTER 12 Multirate Digital Signal Processing

EXAMPLE 12.11
Given a bandpass signal with the spectrum and carry frequency fc shown in Figures 12.44A, 12.44B, and
12.44C, respectively, and assuming the baseband bandwidth B
4 kHz, select the sampling rate and sketch the
sampled spectrum ranging from 0 Hz to the carrier frequency for each of the following carrier frequencies:
f
0
0
2
0
1
kHz
16
f kHz
20
10
0
Bandpass signal with
baseband bandwidth
B=4 kHz
Bandpass signal
sampled at fs=8 kHz
15
17
7
9
15
17
1
FIGURE 12.44A
Sampled signal spectrum for fc ¼ 16 kHz.
f
0
0
2
0
1
kHz
12
f
kHz
20
10
0
Bandpass signal with
baseband bandwidth
B=4 kHz
Bandpass signal
sampled at fs=8 kHz
3
5
13
11
11
13
19
FIGURE 12.44B
Sampled signal spectrum for fc ¼ 12 kHz.
f
0
0
2
0
1
kHz
19
f
kHz
20
10
0
Bandpass signal with
baseband bandwidth
B=6 kHz
Bandpass signal
sampled at fs=9 kHz
1
18
17
17
19
8
FIGURE 12.44C
Sampled signal spectrum for fc ¼ 18 kHz.
12.5 Undersampling of Bandpass Signals
607

a. fc
16 kHz
b. fc
12 kHz
c. fc
18 kHz
Solution:
a. Since fc=B
4 is an even number, which is Case 1, we select fs
8 kHz and sketch the sampled spectrum
shown in Figure 12.44A.
b. Since fc=B
3 is an odd number, we select fs
8 kHz and sketch the sampled spectrum shown in
Figure 12.44B.
c. Now, fc=B
4:5, which is a noninteger. We extend the bandwidth B
4:5 kHz, so fc=B
4 and
fs
2B
9 kHz. The sketched spectrum is shown in Figure 12.44C.
Simulation Example
An AM with a 1-kHz message signal is given as
xðtÞ ¼ ½1 þ 0:8  sinð2p  1; 000tÞcos ð2p  fctÞ
(12.53)
Assuming a message bandwidth of 4 kHz, determine the sampling rate, use MATLAB to sample the
AM signal, and sketch the sampled spectrum up to the sampling frequency for each of the following
carrier frequencies:
a. fc ¼ 96 kHz
b. fc ¼ 100 kHz
c. fc ¼ 99 kHz
a. For this case, fc=B ¼ 24 is an even number. We select fs ¼ 8 kHz. Figure 12.45A describes the
simulation, where the upper left plot is the AM signal, the upper right plot is the spectrum of
the AM signal, the lower left plot is the undersampled signal, and the lower right plot is
the spectrum of the undersampled signal displayed from 0 to 8 kHz.
b. fc=B ¼ 25 is an odd number, so we choose fs ¼ 8 kHz, and a further process is needed. We
can multiply the undersampled signal by a digital oscillator with a frequency of B ¼ 4 kHz
to achieve the 1-kHz baseband signal. The plots of the AM signal spectrum, undersampled
signal
spectrum,
and
the
oscillator
mixed
signal
and
its
spectrum
are
shown
in
Figure 12.45B.
c. For fc ¼ 99 kHz, fc=B ¼ 24:75. We extend the bandwidth to B ¼ 4:125 so that fc=B ¼ 24.
Hence, fs ¼ 8:25 kHz is used as the undersampling rate. Figure 12.45C shows the plots for the
AM signal, the AM signal spectrum, the undersampled signal based on the extended baseband
width, and the sampled signal spectrum ranging from 0 to 8.25 kHz, respectively.
This example veriﬁes the principles of undersampling of bandpass signals.
12.6 SAMPLING RATE CONVERSION USING THE TMS320C6713 DSK
Downsampling by an integer factor of M using the TMS320C6713 is depicted in Figure 12.46. The
idea is that we set up the DSK running at the original sampling rate and update the DAC channel once
for M samples. The program (Tan and Jiang, 2008) is shown in Program 12.9.
608
CHAPTER 12 Multirate Digital Signal Processing

Program 12.9. Downsampling implementation (anti-aliasing ﬁlter has 67 coefﬁcients that are stored in
an array b[67]).
int M 2;
float x[67];
float y[1] {0.0};
interrupt void c int11()
{
float lc; /*Left channel input */
float rc; /*Right channel input */
float lcnew; /*Left channel output */
float rcnew; /*Right channel output */
int i,j;
float sum;
// Left channel and right channel inputs
AIC23 data.combo input sample();
lc (float) (AIC23 data.channel[LEFT]);
rc
(float) (AIC23 data.channel[RIGHT]);
// Insert DSP algorithm below
0
0.005
0.01
-2
-1
0
1
2
Time (sec.)
AM s gna
0.9
0.95
1
1.05
1.1
x 10
5
0
0.5
1
Frequency (Hz)
Spectrum of x(t)
0
0.005
0.01
0
0.5
1
1.5
2
m(n)
Time (sec.)
0
2000
4000
6000
8000
0
0.5
1
Frequency (Hz)
Spectrum of x(n)
FIGURE 12.45A
Sampled AM signal and spectrum for fc ¼ 96 kHz.
12.6 Sampling Rate Conversion Using the TMS320C6713 DSK
609

for (j 0;j<M;jþþ)
{
for(i 66; i>0; i
) // Update input buffer
{ x[i] x[i 1]; }
x[0] lc; // Load new sample
sum 0.0;
for(i 0;i<67;iþþ)
// FIR filtering
{ sum sumþx[i]*b[i]; }
if (j
0)
{ y[0] sum; } // Update DAC with processed sample (decimation)
}
// End of the DSP algorithm
lcnew y[0]; /* Send to DAC */
rcnew y[0];
AIC23 data.channel[LEFT] (short) lcnew;
AIC23 data.channel[RIGHT] (short) rcnew;
output sample(AIC23 data.combo);
}
0.9
0.95
1
1.05
1.1
x 10
5
0
0.5
1
Frequency (Hz)
Spectrum of x(t)
0
2000
4000
6000
8000
0
0.5
1
Frequency (Hz)
Spectrum for x(n)*cos(2*p *B*n/fs)
0
0.005
0.01
0
0.5
1
1.5
2
Time (sec.)
x(n)*cos(2*p *B*n/fs)
0
2000
4000
6000
8000
0
0.2
0.4
0.6
0.8
Frequency (Hz)
Spectrum of x(n)
FIGURE 12.45B
Sampled AM signal and spectrum for fc ¼ 100 kHz.
610
CHAPTER 12 Multirate Digital Signal Processing

Upsampling by an integer factor of L using the TMS320C6713 is depicted in Figure 12.47. Again,
we set up the DSK to run at the upsampling rate fsL and acquire a sample from the ADC channel
once for L samples. The program (Tan and Jiang, 2008) is shown in Program 12.10.
Program 12.10. Upsampling implementation (anti-image ﬁlter has 67 coefﬁcients that are stored in an
array b[67]).
int L 2;
int Lcount 0;
float x[67];
float y[1] {0.0};
interrupt void c int11()
{
float lc; /*Left channel input */
float rc; /*Right channel input */
float lcnew; /*Left channel output */
float rcnew; /*Right channel output */
int i,j;
// Left channel and right channel inputs
AIC23 data.combo input sample();
0
0.005
0.01
-2
-1
0
1
2
Time (sec.)
AM s gna
0.9
0.95
1
1.05
1.1
x 10
5
0
0.5
1
Frequency (Hz)
Spectrum of x(t)
0
0.005
0.01
0
0.5
1
1.5
2
m(n)
Time (sec.)
0
5000
10000
0
0.5
1
Frequency (Hz)
Spectrum of x(n)
FIGURE 12.45C
Sampled AM signal and spectrum for fc ¼ 99 kHz.
12.6 Sampling Rate Conversion Using the TMS320C6713 DSK
611

lc (float) (AIC23 data.channel[LEFT]);
rc
(float) (AIC23 data.channel[RIGHT]);
// Insert DSP algorithm below
Lcountþþ;
for(i 66; i>0; i
) // Update input buffer with zeros
{ x[i] x[i 1]; }
x[0] 0;
if (Lcount
L)
{
x[0] lc; // Load new sample for every L samples
Lcount
0;
}
y[0] 0.0;
for(i 0;i<67;iþþ)
// FIR filtering
{ y[0] y[0]þx[i]*b[i]; }
y[0] (float) L*y[0]
TI TMS320C6713
DSP Board
Left Line In
LCI
Right Line In
RCI
Left Line Out
Right Line Out
Signal
source
( )
y m
( )
x n
( )
y m
Sampling rate at fs
Update DAC channel
once for M samples to
obatin the sampling
rate at fs/M
( )
x n
FIGURE 12.46
Downsampling using the TMS320C6713.
TI TMS320C6713
DSP Board 2
Left Line In
LCI
Right Line In
RCI
Left Line Out
Right Line Out
Signal
source
( )
y m
( )
x n
( )
y m
Sampling rate set as fsL
Acquiring x(n) once
for L samples
( )
x n
FIGURE 12.47
Upsampling using the TMS320C6713.
612
CHAPTER 12 Multirate Digital Signal Processing

// End of the DSP algorithm
lcnew y[0]; /* Send to DAC */
rcnew y[0];
AIC23 data.channel[LEFT] (short) lcnew;
AIC23 data.channel[RIGHT] (short) rcnew;
output sample(AIC23 data.combo);
}
12.7 SUMMARY
1. Downsampling (decimation) by an integer factor of M means taking one sample from the data
sequence xðnÞ for every M samples and discarding the last M  1 samples.
2. Upsampling (interpolation) by an integer factor of L means inserting L  1 zeros for every sample
in the data sequence xðnÞ.
3. Downsampling requires a decimation (anti-aliasing) ﬁlter to avoid frequency aliasing before
downsampling.
4. Upsampling requires an interpolation (anti-image) ﬁlter to remove the images after interpolation.
5. Changing the sampling rate by a noninteger factor of L=M requires two stages: an interpolation
stage and a downsampling stage.
6. Two-stage decimation can dramatically reduce the anti-aliasing ﬁlter length.
7. Polyphase implementations of the decimation ﬁlter and interpolation ﬁlter can reduce the
complexity of the ﬁlter operations, that is, fewer multiplications and additions.
8. Using oversampling can improve the regular ADC resolution. Sigma-delta modulation ADC can
achieve even higher ADC resolution, using the noise shaping effect for further reduction of
quantization noise.
9. The audio CD player uses multirate signal processing and oversampling.
10. Undersampling can be used to sample the bandpass signal, leading to applications in
communications.
12.8 PROBLEMS
12.1. Consider a single-stage decimator with the following speciﬁcations:
Original sampling rate ¼ 1 kHz
Decimation factor M ¼ 2
Frequency of interest ¼ 0 100 Hz
Passband ripple ¼ 0.015 dB
Stopband attenuation ¼ 40 dB
a. Draw the block diagram for the decimator.
b. Determine the window type, ﬁlter length, and cutoff frequency if the window method is
used for the anti-aliasing FIR ﬁlter design.
12.2. Consider a single-stage interpolator with the following speciﬁcations:
Original sampling rate ¼ 1 kHz
12.7 Summary
613

Interpolation factor L ¼ 2
Frequency of interest ¼ 0 150 Hz
Passband ripple ¼ 0.02 dB
Stopband attenuation ¼ 45 dB
a. Draw the block diagram for the interpolator.
b. Determine the window type, ﬁlter length, and cutoff frequency if the window method is
used for the anti-image FIR ﬁlter design.
12.3. Consider a single stage decimator with the following speciﬁcations:
Original sampling rate ¼ 8 kHz
Decimation factor M ¼ 4
Frequency of interest ¼ 0 800 Hz
Passband ripple ¼ 0.02 dB
Stopband attenuation ¼ 46 dB,
a. Draw the block diagram for the decimator.
b. Determine the window type, ﬁlter length, and cutoff frequency if the window method is
used for the anti-aliasing FIR ﬁlter design.
12.4. Consider a single-stage interpolator with the following speciﬁcations:
Original sampling rate ¼ 8 kHz
Interpolation factor L ¼ 3
Frequency of interest ¼ 0 3,400 Hz
Passband ripple ¼ 0.02 dB
Stopband attenuation ¼ 46 dB
a. Draw the block diagram for the interpolator.
b. Determine the window type, ﬁlter length, and cutoff frequency if the window method is
used for the anti-image FIR ﬁlter design.
12.5. Consider the sampling conversion from 4 kHz to 3 kHz with the following speciﬁcations:
Original sampling rate ¼ 4 kHz
Interpolation factor L ¼ 3
Decimation factor M ¼ 2
Frequency of interest ¼ 0 400 Hz
Passband ripple ¼ 0.02 dB
Stopband attenuation ¼ 46 dB
a. Draw the block diagram for the interpolator.
b. Determine the window type, ﬁlter length, and cutoff frequency if the window method is
used for the combined FIR ﬁlter H(z).
12.6. Consider the design of a two-stage decimator with the following speciﬁcations:
Original sampling rate ¼ 32 kHz
Frequency of interest ¼ 0 250 Hz
Passband ripple ¼ 0.05 (absolute)
614
CHAPTER 12 Multirate Digital Signal Processing

Stopband attenuation ¼ 0.005 (absolute)
Final sampling rate ¼ 1,000 Hz
a. Draw the decimation block diagram.
b. Specify the sampling rate for each stage.
c. Determine the window type, ﬁlter length, and cutoff frequency for the ﬁrst stage if the
window method is used for anti-aliasing FIR ﬁlter design (H1ðzÞ).
d. Determine the window type, ﬁlter length, and cutoff frequency for the second stage if the
window method is used for the anti-aliasing FIR ﬁlter design (H2ðzÞ).
12.7. Consider the sampling conversion from 6 kHz to 8 kHz with the following speciﬁcations:
Original sampling rate ¼ 6 kHz
Interpolation factor L ¼ 4
Decimation factor M ¼ 3
Frequency of interest ¼ 0 2,400 Hz
Passband ripple ¼ 0.02 dB
Stopband attenuation ¼ 46 dB
a. Draw the block diagram for the processor.
b. Determine the window type, ﬁlter length, and cutoff frequency if the window method is
used for the combined FIR ﬁlter HðzÞ.
12.8. Consider the design of a two-stage decimator with the following speciﬁcations:
Original sampling rate ¼ 320 kHz
Frequency of interest ¼ 03,400 Hz
Passband ripple ¼ 0.05 (absolute)
Stopband attenuation ¼ 0.005 (absolute)
Final sampling rate ¼ 8,000 Hz
a. Draw the decimation block diagram.
b. Specify the sampling rate for each stage.
c. Determine the window type, ﬁlter length, and cutoff frequency for the ﬁrst stage if the
window method is used for anti-aliasing FIR ﬁlter design (H1ðzÞ).
d. Determine the window type, ﬁlter length, and cutoff frequency for the second stage if the
window method is used for anti-aliasing FIR ﬁlter design (H2ðzÞ).
12.9. a. Given an interpolator ﬁlter
H

z

¼ 0:25 þ 0:4z 1 þ 0:5z 2
draw the block diagram for interpolation polyphase ﬁlter implementation for
the case of L ¼ 2.
b. Given a decimation ﬁlter
H

z

¼ 0:25 þ 0:4z 1 þ 0:5z 2 þ 0:6z 3
draw the block diagram for decimationpolyphase ﬁlter implementationfor thecaseof M ¼ 2.
12.7 Summary
615

12.10. Using the commutative models for the polyphase interpolation and decimation ﬁlters,
a. draw the block diagram for interpolation polyphase ﬁlter implementation for the case of
L ¼ 2, and HðzÞ ¼ 0:25 þ 0:4z 1 þ 0:5z 2 ;
b. draw the block diagram for decimation polyphase ﬁlter implementation for the case of
M ¼ 2, and HðzÞ ¼ 0:25 þ 0:4z 1 þ 0:5z 2 þ 0:6z 3.
12.11. a. Given an interpolator ﬁlter
H

z

¼ 0:25 þ 0:4z 1 þ 0:5z 2 þ 0:6z 3 þ 0:7z 4 þ 0:6z 5;
draw the block diagram for interpolation polyphase ﬁlter implementation for the case of
L ¼ 4.
b. Given a decimation ﬁlter
H

z

¼ 0:25 þ 0:4z 1 þ 0:5z 2 þ 0:6z 3 þ 0:5z 3 þ 0:4z 4
draw the block diagram for decimation polyphase ﬁlter implementation for the case of
M ¼ 4.
12.12. Using the commutative models for the polyphase interpolation and decimation ﬁlters,
a. draw the block diagram for interpolation polyphase ﬁlter implementation for the case
of L ¼ 4, and HðzÞ ¼ 0:25 þ 0:4z 1 þ 0:5z 2 þ 0:6z 3 þ 0:7z 4 þ 0:6z 5;
b. draw the block diagram for decimation polyphase ﬁlter implementation for the case of
M ¼ 4, and HðzÞ ¼ 0:25 þ 0:4z 1 þ 0:5z 2 þ 0:6z 3 þ 0:5z 3 þ 0:4z 4.
12.13. Consider a speech system with the following speciﬁcations:
Speech input frequency range: 0 4 kHz
ADC resolution ¼ 16 bits
Current sampling rate ¼ 8 kHz
a. Determine the oversampling rate if a 12-bit ADC chip is used to replace the speech
system.
b. Draw the block diagram.
12.14. Consider a speech system with the following speciﬁcations:
Speech input frequency range: 0 4 kHz
ADC resolution ¼ 6 bits
Oversampling rate ¼ 4 MHz
a. Draw the block diagram.
b. Determine the actual effective ADC resolution (number of bits per sample).
12.15. Consider an audio system with the following speciﬁcations:
Audio input frequency range: 0 15 kHz
ADC resolution ¼ 16 bits
Current sampling rate ¼ 30 kHz
616
CHAPTER 12 Multirate Digital Signal Processing

a. Determine the oversampling rate if a 12-bit ADC chip is used to replace the audio system.
b. Draw the block diagram.
12.16. Consider an audio system with the following speciﬁcations:
Audio input frequency range: 0 15 kHz
ADC resolution ¼ 6 bits
Oversampling rate ¼ 45 MHz
a. Draw the block diagram.
b. Determine the actual effective ADC resolution (number of bits per sample).
12.17. Consider the following speciﬁcations of an oversampling DSP system:
Audio input frequency range: 0 4 kHz
First-order SDM with a sampling rate of 128 kHz
ADC resolution in SDM ¼ 1 bit
a. Draw the block diagram using the DSP model.
b. Determine the equivalent (effective) ADC resolution.
12.18. Consider the following speciﬁcations of an oversampling DSP system:
Audio input frequency range: 0 20 kHz
Second-order SDM with a sampling rate of 160 kHz
ADC resolution in SDM ¼ 10 bits
a. Draw the block diagram using the DSP model.
b. Determine the equivalent (effective) ADC resolution.
12.19. Consider the following speciﬁcations of an oversampling DSP system:
Signal input frequency range: 0 500 Hz
First-order SDM with a sampling rate of 128 kHz
ADC resolution in SDM ¼ 1 bit
a. Draw the block diagram using the DSP model.
b. Determine the equivalent (effective) ADC resolution.
12.20. Consider the following speciﬁcations of an oversampling DSP system:
Signal input frequency range: 0 500 Hz
Second-order SDM with a sampling rate of 16 kHz
ADC resolution in SDM ¼ 8 bits
a. Draw the block diagram using the DSP model.
b. Determine the equivalent (effective) ADC resolution.
12.21. Given a bandpass signal with a spectrum shown in Figure 12.48, and assuming the
bandwidth B ¼ 5 kHz, select the sampling rate and sketch the sampled spectrum
ranging from 0 Hz to the carrier frequency for each of the following carrier
frequencies:
a. fc ¼ 30 kHz
12.7 Summary
617

b. fc ¼ 25 kHz
c. fc ¼ 33 kHz
12.22. Given a bandpass signal with a spectrum shown in Figure 12.48, and assuming fs ¼ 10
kHz, select the sampling rate and sketch the sampled spectrum ranging from 0 Hz to the
carrier frequency for each of the following carrier frequencies:
a. fc ¼ 15 kHz
b. fc ¼ 20 kHz
12.23. Given a bandpass signal with a spectrum shown in Figure 12.48, and assuming B ¼ 5 kHz,
select the sampling rate and sketch the sampled spectrum ranging from 0 Hz to the carrier
frequency for each of the following carrier frequencies:
a. fc ¼ 35 kHz
b. fc ¼ 40 kHz
c. fc ¼ 22 kHz
12.8.1 MATLAB Problems
Use MATLAB to solve Problems 12.24 to 12.30.
12.24. Generate a sinusoid with a frequency of 1,000 Hz for 0.05 second using a sampling rate of
8 kHz.
a. Design a decimator to change the sampling rate to 4 kHz with the speciﬁcations below:
Signal frequency range: 0 1,800 Hz
Hamming window required for FIR ﬁlter design
b. Write a MATLAB program to implement the downsampling scheme, and plot the
original signal and the downsampled signal versus the sample number, respectively.
12.25. Generate a sinusoid with a frequency of 1,000 Hz for 0.05 second using a sampling rate of
8 kHz.
a. Design an interpolator to change the sampling rate to 16 kHz with the following spec-
iﬁcations:
Signal frequency range: 0 3,600 Hz
Hamming window required for FIR ﬁlter design
f
0
kHz
cf
Bandpass signal with
baseband bandwidth
B=5 kHz
5
cf
5
cf
2
cf
2
cf
FIGURE 12.48
Spectrum of the bandpass signal in Problem 12.21.
618
CHAPTER 12 Multirate Digital Signal Processing

b. Write a MATLAB program to implement the upsampling scheme, and plot the original
signal and the upsampled signal versus the sample number, respectively.
12.26. Generate a sinusoid with a frequency of 500 Hz for 0.1 second using a sampling rate of
8 kHz.
a. Design an interpolation and decimation processing algorithm with the following spec-
iﬁcations to change the sampling rate to 22 kHz:
Signal frequency range: 0 3,400 Hz
Hamming window required for FIR ﬁlter design
b. Write a MATLAB program to implement the scheme, and plot the original signal and the
sampled signal at the rate of 22 kHz versus the sample number, respectively.
12.27. Repeat Problem 12.24 using the polyphase form for the decimator.
12.28. Repeat Problem 12.25 using the polyphase form for the interpolator.
12.29. a. Use MATLAB to create a 1-second sinusoidal signal using a sampling rate of 1 kHz,
xðtÞ ¼ 1:8 cos ð2p  100tÞ þ 1:0 sin ð2p  150t þ p=4Þ
where each sample xðtÞ can be rounded off using a 3-bit signed integer (directly round off
the calculated xðtÞ). Evaluate the signal-to-quantization-noise ratio (SQNR).
b. Use MATLAB to design an oversampling system including an anti-aliasing ﬁlter with
a selectable integer factor L using the same equation for the input x(t).
c. Recover the signal using the quantized 3-bit signal and measure the SQNRs for the
following integer factors: L ¼ 2, L ¼ 4, L ¼ 8, L ¼ 16, and L ¼ 32. From the
results, explain which one offers better quality for the recovered signals.
12.30. a. Use MATLAB to create a 1-second sinusoidal signal using a sampling rate of 1 kHz,
xðtÞ ¼ 1:8 cos ð2p  100tÞ þ 1:0 sin ð2p  150t þ p=4Þ
where each sample x(t) can be rounded off using a 3-bit signed integer (directly round off
the calculated x(t)). Evaluate the signal-to-quantization-noise ratio (SQNR).
b. Use MATLAB to implement the ﬁrst-order SDM system including an anti-aliasing ﬁlter
with an oversampling factor of 16. Measure the SQNR (signal to noise ratio due to
quantization).
c. Use MATLAB to implement the second-order SDM system including an anti-aliasing
ﬁlter with an oversampling factor of 16. Measure the SQNR. Compare the SQNR with
the one obtained in (b).
12.8.2 MATLAB Project
12.31. Audio rate conversion system:
Given a 16-bit stereo audio ﬁle (“No9seg.wav”) with a sampling rate of 44.1 kHz, design
a multistage conversion system and implement the designed system to convert the audio ﬁle
from 44.1 to 48 kHz. Listen and compare the quality of the original audio with the converted
audio.
12.7 Summary
619

This page intentionally left blank

Subband- and Wavelet-Based
Coding
13
CHAPTER OUTLINE
13.1 Subband Coding Basics .............................................................................................................. 621
13.2 Subband Decomposition and Two-Channel Perfect Reconstruction Quadrature Mirror Filter Bank..... 626
13.3 Subband Coding of Signals ......................................................................................................... 635
13.4 Wavelet Basics and Families of Wavelets .................................................................................... 638
13.5 Multiresolution Equations ........................................................................................................... 650
13.6 Discrete Wavelet Transform ........................................................................................................ 655
13.7 Wavelet Transform Coding of Signals........................................................................................... 664
13.8 MATLAB Programs ...................................................................................................................... 668
13.9 Summary ................................................................................................................................... 672
OBJECTIVES
This chapter is a continuation of Chapter 12 and further studies basic principles of multirate digital signal
processing, speciﬁcally for subband and wavelet transform coding. First, the chapter explains digital ﬁlter
bank theory and develops subband coding techniques for compressing various signals, including speech
and seismic data. Then the chapter focuses on wavelet basics with applications of waveform coding and
signal denoising.
13.1 SUBBAND CODING BASICS
In many applications such as speech and audio analysis, synthesis, and compression, digital ﬁlter
banks are often used. The ﬁlter bank system consists of two stages. The ﬁrst stage, called the
analysis stage, is in the form of ﬁlter bank decomposition, in which the signal is ﬁltered into
subbands along with a sampling rate decimation; the second stage interpolates the decimated sub-
band signals to reconstruct the original signal. For the purpose of data compression, spectral
information from each subband channel can be used to quantize the subband signal efﬁciently to
achieve efﬁcient coding.
Figure 13.1 illustrates the basic framework for a four-channel ﬁlter bank analyzer and synthe-
sizer. At the analysis stage, the input signal xðnÞ at the original sampling rate fs is divided via the
analysis ﬁlter bank into four channels, x0ðmÞ, x1ðmÞ, x2ðmÞ, and x3ðmÞ, each at the decimated
sampling rate fs=M, where M ¼ 4. For the synthesizer, these four decimated signals are interpolated
via a synthesis ﬁlter bank. The outputs from all four channels (x0ðnÞ, x1ðnÞ, x2ðnÞ, and x3ðnÞ) of the
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00013-5
Copyright  2013 Elsevier Inc. All rights reserved.
621

synthesis ﬁlter bank are then combined to reconstruct the original signal xðnÞ at the original sampling
rate fs. Each channel essentially generates a bandpass signal. The decimated signal spectrum for
channel 0 can be achieved via a standard downsampling process, while the decimated spectra of
other channels can be obtained using the principle of undersampling of bandpass signals with an
integer band (discussed in Section 12.5), where the inherent frequency aliasing or image properties
of decimation and interpolation are involved. The theoretical development will follow next. With
a proper design of analysis and synthesis ﬁlter banks, we are able to achieve perfect reconstruction of
the original signal.
Let us examine the spectral details of each band (subband). Figure 13.2 depicts the spectral
information of the analysis and synthesis stages, as shown in Figure 13.2(a) and (b). H0ðzÞ and G0ðzÞ
are the analysis and synthesis ﬁlters of channel 0, respectively. At the analyzer (Figure 13.2(c) to (e)),
xðnÞ is bandlimited by a lowpass ﬁlter H0ðzÞ to get w0ðnÞ and decimated by M ¼ 4 to obtain x0ðmÞ. At
the synthesizer (Figure 13.2(f) to (h)), x0ðmÞ is upsampled by a factor of 4 to obtain w0ðnÞ and then
goes through the anti-aliasing (synthesis) ﬁlter G0ðzÞ to achieve the lowpass signal x0ðnÞ.
Figure 13.3 depicts the analysis and synthesis stages for channel 1 (see Figure 13.3(a) and (b)).
H1ðzÞ and G1ðzÞ are the bandpass analysis and synthesis ﬁlters, respectively. Similarly, at the analyzer
(Figure 13.3(c) to (e)), xðnÞ is ﬁltered by a bandpass ﬁlter H1ðzÞ to get w1ðnÞ and decimated by M ¼ 4
to obtain x1ðmÞ. Since the lower frequency edge of W1ðzÞ is fc=B ¼ 1 ¼ odd number, where
fc ¼ fs=ð2MÞ ¼ B, fc corresponds to the carrier frequency, and B is the baseband bandwidth as
depicted in Section 12.5, the reversed spectrum in the baseband results in Figure 13.3(e). However, this
is not a problem, since at the synthesizer as shown in Figures 13.3(f) and (g), the spectral reversal occurs
again so that W1ðzÞ will have the same spectral components as W1ðzÞ at the analyzer. After w1ðnÞ goes
through the anti-aliasing (synthesis) ﬁlter G1ðzÞ, we achieve the reconstructed bandpass signal x1ðnÞ.
Figure 13.4 describes the analysis and synthesis stages for channel 2. At the analyzer
(Figure 13.4(c) to (e)), xðnÞ is ﬁltered by a bandpass ﬁlter H2ðzÞ to get w2ðnÞ and decimated by M ¼ 4
to obtain x2ðmÞ. Similarly, considering the lower frequency edge of W2ðzÞ as fc ¼ 2ðfs=ð2MÞÞ ¼ 2B,
fc=B ¼ 2 ¼ even. Therefore, we obtain the nonreversed spectrum in the baseband as shown in
Figure 13.4(f). At the synthesizer shown in Figure 13.4(g), the spectrum W2ðzÞ has the same spectral
Analysis Filter Bank
Synthesis Filter Bank
Aanalysis stage                                     Synthesis stage
( )
x n
( )
x n
0( )
x m
1( )
x m
2( )
x m
3( )
x m
0
Channel
Channel
0
1
1
2
3
2
3
0( )
x m
1( )
x m
2( )
x m
3( )
x m
+
0( )
x n
1( )
x n
2( )
x n
3( )
x n
sf
/
sM
s
f
f
M
=
sf
(a)
(b)
FIGURE 13.1
Filter bank framework with an analyzer and synthesizer.
622
CHAPTER 13 Subband and Wavelet Based Coding

1( )
H
1( )
G
M
↓
M
↑
( )
x n
1( )
x m
1( )
x m
1( )
x n
1( )
w n
1( )
w n
( )
X f
1( )
W f
1( )
X
f
1( )
X
f
1( )
W
f
1( )
X
f
f
f
f
f
f
f
/ 2
sf
/ 2
sf
/(2
)
sM
s
f
f
M
sf
sf
/
sM
s
f
f
M
/
sM
s
f
f
M
sf
sf
/(2
)
sM
s
f
f
M
/ 2
sf
/ 2
sf
(a)
(c)
(d)
(e)
(b)
(h)
(g)
(f)
FIGURE 13.3
Analysis and synthesis stages for channel 1.
0( )
H
0( )
G
M
↓
M
↑
( )
x n
0( )
x m
0( )
x m
0( )
x n
0( )
w n
0( )
w n
( )
X f
0( )
W
f
0( )
X
f
0( )
X
f
0( )
W
f
0( )
X
f
f
f
f
f
f
f
/ 2
sf
/ 2
sf
/(2
)
sM
s
f
f
M
sf
sf
/
sM
s
f
f
M
/
sM
s
f
f
M
sf
sf
/(2
)
sM
s
f
f
M
/ 2
sf
/ 2
sf
(a)
(c)
(d)
(e)
(b)
(h)
(g)
(f)
FIGURE 13.2
Analysis and synthesis stages for channel 0.
13.1 Subband Coding Basics
623

components as W2ðzÞ at the analyzer. After w2ðnÞ is ﬁltered by the synthesis bandpass ﬁlter, G2ðzÞ, we
get the reconstructed bandpass signal x2ðnÞ.
The process in channel 3 is similar to that in channel 1 with the spectral reversal effect and is
illustrated in Figure 13.5.
Now let us examine the theory. Without quantization of subband channels, perfect reconstruction of
the ﬁlter banks (see Figure 13.1) depends on the analysis and syntheses ﬁlter effects. To develop the
perfect reconstruction required of the analysis and synthesis ﬁlters, consider a signal in a single
channel ﬂowing up to the synthesis ﬁlter in general as depicted in Figure 13.6.
As shown in Figure 13.6, wðnÞ is the output signal from the analysis ﬁlter H(z) at the original
sampling rate, that is,
WðzÞ ¼ HðzÞXðzÞ
(13.1)
xdðmÞ is the downsampled version of wðnÞ while wðnÞ is the interpolated version of wðnÞ prior to the
synthesis ﬁlter and can be expressed as
wðnÞ ¼
(
wðnÞ
n ¼ 0; M; 2M; .
0
otherwise
(13.2)
Using a delta function dðnÞ, that is, dð0Þ ¼ 1 for n ¼ 0 and dðnÞ ¼ 0 for ns0, we can write wðnÞ as
wðnÞ ¼
" X
N
k ¼ 0
dðn  kMÞ
#
wðnÞ ¼ iðnÞwðnÞ
(13.3)
2( )
H
2( )
G
M
↓
M
↑
( )
x n
2( )
x m
2( )
x m
2( )
x n
2( )
w n
2( )
w n
( )
X f
2( )
W
f
2( )
X
f
2( )
X
f
2( )
W
f
2( )
X
f
f
f
f
f
f
f
/ 2
sf
/ 2
sf
/(2
)
sM
s
f
f
M
sf
sf
/
sM
s
f
f
M
/
sM
s
f
f
M
sf
sf
/(2
)
sM
s
f
f
M
/ 2
sf
/ 2
sf
(a)
(c)
(d)
(e)
(b)
(h)
(g)
(f)
FIGURE 13.4
Analysis and synthesis stages for channel 2.
624
CHAPTER 13 Subband and Wavelet Based Coding

where iðnÞ is deﬁned as iðnÞ ¼ PN
k ¼ 0 dðn  kMÞ ¼ dðnÞ þ dðn  MÞ þ dðn  2MÞ þ /
Clearly, iðnÞ is a periodic function (impulse train with a period of M samples) as shown in
Figure 13.7 where M ¼ 4.
We can determine the discrete Fourier transform of the impulse train with a period of M samples as
IðkÞ ¼
X
M
1
n ¼ 0
iðnÞe j2pkn
M
¼
X
M
1
n ¼ 0
dðnÞe j2pkn
M
¼ 1
(13.4)
( )
H
M
↓
M
↑
( )
x n
( )
w n
( )
w n
sf
sf
/
sM
s
f
f
M
sf
( )
dx
m
( )
w n
( )
dx
m
( )
w n
n
m
n
FIGURE 13.6
Signal ﬂow in one channel.
3( )
H
2( )
G
M
↓
M
↑
( )
x n
3( )
x m
3( )
x m
3( )
x n
3( )
w n
3( )
w n
( )
X f
3( )
W
f
3( )
X
f
3( )
X
f
3( )
W
f
3( )
X
f
f
f
f
f
f
f
/ 2
sf
/ 2
sf
/(2
)
sM
s
f
f
M
sf
sf
/
sM
s
f
f
M
/
sM
s
f
f
M
sf
sf
/(2
)
sM
s
f
f
M
/ 2
sf
/ 2
sf
(a)
(c)
(d)
(e)
(b)
(h)
(g)
(f)
FIGURE 13.5
Analysis and synthesis stages for channel 3.
13.1 Subband Coding Basics
625

Hence, using the inverse of discrete Fourier transform, iðnÞ can be expressed as
iðnÞ ¼ 1
M
X
M
1
k ¼ 0
IðkÞej2pkn
M
¼ 1
M
X
M
1
k ¼ 0
ej2pkn
M
(13.5)
Substituting Equation (13.5) into Equation (13.3) leads to
wðnÞ ¼ 1
M
X
M
1
k ¼ 0
wðnÞej2pkn
M
(13.6)
Applying the z-transform in Equation (13.6), we achieve the fundamental relationship between WðzÞ
and WðzÞ :
WðzÞ ¼ 1
M
X
M
1
k ¼ 0
X
N
n ¼ 0
wðnÞej2pkn
M z n ¼ 1
M
X
M
1
k ¼ 0
X
N
n ¼ 0
wðnÞ

e j2pk
M z
 n
¼ 1
M
X
M
1
k ¼ 0
W

e j2pk
M z

¼ 1
M
h
W

e j2p0
M z

þ W

e j2p1
M z

þ / þ W

e j2pðM
1Þ
M
z
i
(13.7)
Equation (13.7) indicates that the signal spectrum WðzÞ before the synthesis ﬁlter is an average of the
various modulated spectrum WðzÞ. Notice that both WðzÞ and WðzÞ are at the original sampling rate fs.
We will use this result for further development in the next section.
13.2 SUBBAND DECOMPOSITION AND TWO-CHANNEL PERFECT
RECONSTRUCTION QUADRATURE MIRROR FILTER BANK
To explore Equation (13.7), let us begin with a two-band case as illustrated in Figure 13.8.
Substituting M ¼ 2 in Equation (13.7), it follows that
WðzÞ ¼ 1
2
X
1
k ¼ 0
Wðe j2pk
2 zÞ ¼ 1
2 ½WðzÞ þ WðzÞ
(13.8)
( )
i n
n
1.0
FIGURE 13.7
Impulse train with a period 4 samples.
626
CHAPTER 13 Subband and Wavelet Based Coding

Applying for each band in Figure 13.8 by substituting Equation (13.1) in Equation (13.8), we have
Y0ðzÞ ¼ 1
2 G0ðzÞðH0ðzÞXðzÞ þ H0ðzÞXðzÞÞ
(13.9)
Y1ðzÞ ¼ 1
2 G1ðzÞðH1ðzÞXðzÞ þ H1ðzÞXðzÞÞ
(13.10)
Since the synthesized signal XðzÞ is the sum of Y0ðzÞ and Y1ðzÞ, it can be expressed as
XðzÞ ¼ 1
2 ðG0ðzÞH0ðzÞ þ G1ðzÞH1ðzÞÞXðzÞ
þ 1
2 ðG0ðzÞH0ðzÞ þ G1ðzÞH1ðzÞÞXðzÞ
¼ AðzÞXðzÞ þ SðzÞXðzÞ
(13.11)
For perfect reconstruction, the recovered signal xðnÞ should be a scaled and delayed version of the
original signal xðnÞ, that is, xðnÞ ¼ cxðn  n0Þ. Hence, to achieve a perfect reconstruction, it is
required that
SðzÞ ¼ 1
2 ðG0ðzÞH0ðzÞ þ G1ðzÞH1ðzÞÞ ¼ 0
(13.12)
AðzÞ ¼ 1
2 ðG0ðzÞH0ðzÞ þ G1ðzÞH1ðzÞÞ ¼ cz n0
(13.13)
where c is the constant while n0 is the delay introduced by the analysis and synthesis ﬁlters.
Forcing SðzÞ ¼ 0 leads to the following relationship:
G0ðzÞ
G1ðzÞ ¼ H1ðzÞ
H0ðzÞ
(13.14)
It follows that
G0ðzÞ ¼ H1ðzÞ
(13.15)
0( )
H
0( )
G
2
↓
2
↑
( )
x n
( )
x n
1( )
H
2
↓
2
↑
1( )
G
Analysis stage                                              Synthesis stage
0( )
w n
1( )
w n
0( )
w n
1( )
w n
0( )
x m
1( )
x m
0( )
y n
1( )
y n
FIGURE 13.8
Two-band ﬁlter bank system.
13.2 Subband Decomposition and Two Channel Perfect Reconstruction
627

G1ðzÞ ¼ H0ðzÞ
(13.16)
Substituting G0ðzÞ and G1ðzÞ in Equation (13.13) gives
AðzÞ ¼ 1
2 ðH0ðzÞH1ðzÞ  H0ðzÞH1ðzÞÞ
(13.17)
Assume H0ðzÞ and H1ðzÞ are N-tap FIR ﬁlters, where N is even, and let
H1ðzÞ ¼ z ðN
1ÞH0ðz 1Þ
(13.18)
Notice that
H1ðzÞ ¼ z ðN
1ÞH0ðz 1Þ
(13.19)
Substituting Equations (13.18) and (13.19), we can simplify Equation (13.17) as
AðzÞ ¼ 1
2z ðN
1ÞðH0ðzÞH0ðz 1Þ þ H0ðzÞH0ðz 1ÞÞ
(13.20)
Finally, for perfect reconstruction, we require that
H0ðzÞH0ðz 1Þ þ H0ðzÞH0ðz 1Þ ¼ RðzÞ þ RðzÞ ¼ constant
(13.21)
where
RðzÞ ¼ H0ðzÞH0ðz 1Þ ¼ aN
1zN
1 þ aN
2zN
2 þ / þ a0z0 þ / þ aN
1z ðN
1Þ
(13.22)
RðzÞ ¼ H0ðzÞH0ðz 1Þ ¼ aN
1zN
1 þ aN
2zN
2 þ / þ a0z0 þ /  aN
1z ðN
1Þ (13.23)
It is important to note that the sum of RðzÞ þ RðzÞ only consists of even order of powers of z, since the
terms with odd powers of z cancel each other. Using algebraic simpliﬁcation, we conclude that the
coefﬁcients of RðzÞ ¼ HðzÞHðz 1Þ are essentially samples of the autocorrelation function given by
rðnÞ ¼
X
N
1
k ¼ 0
h0ðkÞh0ðk þ nÞ ¼ rðnÞ ¼ h0ðnÞ1h0ðnÞ
(13.24)
where 1 denotes the correlation operation. Hence, we require rðnÞ ¼ 0 for n ¼ even and ns0, that is,
rð2nÞ ¼
X
N
1
k ¼ 0
h0ðkÞh0ðk þ 2nÞ ¼ 0
(13.25)
For the normalization for n ¼ 0, we require
X
N
1
k ¼ 0
jh0ðkÞj2 ¼ 0:5
(13.26)
We then obtain the ﬁlter design constraint as
rð2nÞ ¼
X
N
1
k ¼ 0
h0ðkÞh0ðk þ 2nÞ ¼ dðnÞ
(13.27)
628
CHAPTER 13 Subband and Wavelet Based Coding

For a two-band ﬁlter bank, h0ðkÞ and h1ðkÞ are designed as lowpass and highpass ﬁlters, respectively,
which are essentially the quadrature mirror ﬁlters. Their expected frequency responses must satisfy
Equation (13.28) and are shown in Figure 13.9:
H0ðejUÞ
2þ
H1ðejUÞ
2 ¼ 1
(13.28)
Equation (13.28) implies that
RðzÞ þ RðzÞ ¼ 1
(13.29)
To verify Equation (13.29), we use
HðejUÞ
2 ¼ HðejUÞHðe jUÞ ¼ HðzÞHðz 1Þ

z¼ejU
Equation (13.28) becomes
H0ðzÞH0ðz 1Þ þ H1ðzÞH1ðz 1Þ

z¼ejU ¼ 1
which is equivalent to
H0ðzÞH0ðz 1Þ þ H1ðzÞH1ðz 1Þ ¼ 1
From Equation (13.18), we can verify that
H1ðzÞH1ðz 1Þ ¼ H0ðzÞH0ðz 1Þ
Finally, we see that
H0ðzÞH0ðz 1Þ þ H1ðzÞH1ðz 1Þ
¼ H0ðzÞH0ðz 1Þ þ H0ðzÞH0ðz 1Þ ¼ RðzÞ þ RðzÞ ¼ 1
Once the lowpass analysis ﬁlter H0ðzÞ is designed, the highpass ﬁlter can be obtained using the
developed relationship in Equation (13.18). The key equations are summarized as follows:
0
1
/ 2
Lowpass
Highpass
0( )
H
1( )
H
0
FIGURE 13.9
Frequency responses for quadrature mirror ﬁlters.
13.2 Subband Decomposition and Two Channel Perfect Reconstruction
629

Filter design constraint equations for the lowpass ﬁlter H0ðzÞ:
RðzÞ ¼ H0ðzÞH0ðz 1Þ
RðzÞ þ RðzÞ ¼ 1
rð2nÞ ¼ 0:5dðnÞ
Equations for the other ﬁlters:
H1ðzÞ ¼ z ðN
1ÞH0ðz 1Þ
G0ðzÞ ¼ H1ðzÞ
G1ðzÞ ¼ H0ðzÞ
Design of the analysis and synthesis ﬁlters to satisfy the above conditions is very challenging. Smith
and Barnwell (1984) were the ﬁrst to show that perfect reconstruction in a two-band ﬁlter bank is
possible when the linear phase of the FIR ﬁlter requirement is relaxed. The Smith Barnwell ﬁlters are
called the conjugate quadrature ﬁlters (PR-CQF). Eight- and 16-tap PR-CQF coefﬁcients are listed in
Table 13.1. As shown in Table 13.1, the ﬁlter coefﬁcients are not symmetric; hence, the obtained
analysis ﬁlter does not have a linear phase. The detailed design of Smith Barnwell ﬁlters can be found
in their research paper (Smith and Barnwell, 1984) and the design of other types of analysis and
synthesis ﬁlters can be found in Akansu and Haddad (1992).
Now let us verify the ﬁlter constraint in the following example.
Table 13.1 Smith Barnwell PR-CQF Filters
8 Taps
16 Taps
0.0348975582178515
0.02193598203004352
0.01098301946252854
0.001578616497663704
0.06286453934951963
0.06025449102875281
0.223907720892568
0.0118906596205391
0.556856993531445
0.137537915636625
0.357976304997285
0.05745450056390939
0.02390027056113145
0.321670296165893
0.07594096379188282
0.528720271545339
0.295779674500919
0.0002043110845170894
0.0290669978946796
0.03533486088708146
0.006821045322743358
0.02606678468264118
0.001033363491944126
0.01435930957477529
630
CHAPTER 13 Subband and Wavelet Based Coding

EXAMPLE 13.1
Use the 8 tap PR CQF coefﬁcients (Table 13.1) and MATLAB to verify the following conditions:
rð2nÞ
X
N1
k
0
h0ðkÞh0ðk þ 2nÞ
0:5dðnÞ
RðzÞ þ Rð zÞ
1
Also, plot the magnitude frequency responses of the analysis and synthesis ﬁlters.
Solution:
Since rðnÞ
PN1
k
0 h0ðkÞh0ðk þ nÞ, we obtain the following:
For n
0,
rð0Þ
X
81
k
0
h0ðkÞh0ðkÞ
h2
0ð0Þ þ h2
0ð1Þ þ / þ h2
0ð7Þ
0:5
For n
1,
rð1Þ
X
81
k
0
h0ðkÞh0ðk þ 1Þ
h0ð0Þh0ð1Þ þ h0ð1Þh0ð2Þ þ / þ h0ð6Þh0ð7Þ
0:3035
For n
1,
rð 1Þ
X
81
k
0
h0ðkÞh0ðk
1Þ
h0ð1Þh0ð0Þ þ h0ð2Þh0ð1Þ þ / þ h0ð7Þh0ð6Þ
0:3035
For n
2,
rð2Þ
X
81
k
0
h0ðkÞh0ðk þ 2Þ
h0ð0Þh0ð2Þ þ h0ð1Þh0ð3Þ þ / þ h0ð5Þh0ð7Þ
0:0
For n
2,
rð 2Þ
X
81
k
0
h0ðkÞh0ðk
2Þ
h0ð2Þh0ð0Þ þ h0ð3Þh0ð1Þ þ / þ h0ð7Þh0ð5Þ
0:0
We can easily verify that rðnÞ
0 for ns0 and n
even number.
Next, we use the MATLAB built in function xcorr() to compute the autocorrelation coefﬁcients. The results are
listed as
>>h0 [0.0348975582178515
0.01098301946252854
0.06286453934951963 .
0.223907720892568 0.556856993531445 0.357976304997285 .
0.02390027056113145
0.07594096379188282];
>>p xcorr(h0,h0)
p
0.0027
0.0000 0.0175 0.0000
0.0684
0.0000 0.3035 0.50000
0.3035
0.0000
0.0684 0.0000 0.0175
0.0000
0.0027
We observe that there are 15 coefﬁcients. The middle one is rð0Þ
0:5 and we also have rð2Þ
rð4Þ
rð6Þ
0 as well as rð1Þ
0:3035, rð3Þ
0:0684, rð5Þ
0:0175, and rð7Þ
0:0027.
13.2 Subband Decomposition and Two Channel Perfect Reconstruction
631

Next, we write
RðzÞ
0:0027z7
0:0000z6 þ 0:0175z5 þ 0:0000z4
0:0684z3
0:0000z2 þ 0:3035z1 þ 0:5000z0
þ 0:3035z1
0:0000z2
0:0684z3 þ 0:0000z4 þ 0:0175z5
0:0000z6
0:0027z7
Substituting z
z in RðzÞ yields
Rð zÞ
0:0027z7
0:0000z6
0:0175z5 þ 0:0000z4 þ 0:0684z3
0:0000z2
0:3035z1 þ 0:5000z0
0:3035z1
0:0000z2 þ 0:0684z3 þ 0:0000z4
0:0175z5
0:0000z6 þ 0:0027z7
Clearly, by adding the expressions RðzÞ and Rð zÞ, we can verify that
RðzÞ þ Rð zÞ
1
Using MATLAB, the PR CQF frequency responses are plotted and shown in Figure 13.10.
Figure 13.11 shows the perfect reconstruction of the two-band system in Figure 13.8 using two-
band CQF ﬁlters for speech data. The MATLAB program is listed in Program 13.1, in which the
quantization is deactivated. Since the obtained signal-to-noise ratio (SNR) ¼ 135.5803 dB, a perfect
reconstruction is achieved. Notice that both x0ðmÞ and x1ðmÞ have half of the data samples, where
x0ðmÞ contains low-frequency components with more signal energy while x1ðmÞ possesses high-
frequency components with less signal energy.
0
0.5
1
1.5
2
2.5
3
0
0.2
0.4
0.6
0.8
1
Frequency in radians
Magn tude
FIGURE 13.10
Magnitude frequency responses of the analysis and synthesis ﬁlters in Example 13.1.
632
CHAPTER 13 Subband and Wavelet Based Coding

Program 13.1. Two-band subband system MATLAB implementation.
% This program is for implementing analysis and synthesis using two subbands.
close all; clear all;clc
% Smith Barnwell PR CQF 8 taps
h0 [0.0348975582178515
0.01098301946252854
0.06286453934951963 .
0.223907720892568 0.556856993531445 0.357976304997285 .
0.02390027056113145
0.07594096379188282];
% Read data file "orig.dat" with sampling rate of 8 kHz
load orig.dat; % Load speech data
M 2; % Downsample factor
N length(h0); PNones ones(1,N); PNones(2:2:N)
1;
h1 h0.*PNones; h1 h1(N: 1:1);
g0
h1.*PNones; g1 h0.*PNones;
disp(’check R(z)þR( z)
>’);
xcorr(h0,h0)
sum(h0.*h0)
w 0:pi/1000:pi;
fh0 freqz(h0,1,w); fh1 freqz(h1,1,w);
plot(w,abs(fh0),’k’,w,abs(fh1),’k’);grid; axis([0 pi 0 1.2]);
xlabel(’Frequency in radians’);ylabel(’Magnitude)’)
figure
speech orig;
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
x 10
4
2
0
2
x 10
4
x(n)
0
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
2
0
2
x 10
4
x0(m)
0
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
2000
0
2000
x1(m)
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
x 10
4
2
0
2
x 10
4
xbar(n)
Sample number
FIGURE 13.11
Two-band analysis and synthesis for speech data.
13.2 Subband Decomposition and Two Channel Perfect Reconstruction
633

% Analysis
sb low filter(h0,1,speech); sb high filter(h1,1,speech);
% Downsampling
sb low sb low(1:M:length(sb low)); sb high sb high(1:M:length(sb high));
% Quantization
%sb low round((sb low/2^15)*2^9)*2^(15 9); %Quantization with 10 bits
%sb high round((sb high/2^15)*2^5)*2^(15 5); % Quantization with 6 bits
% Synthesis
low sp zeros(1,M*length(sb low)); % Upsampling
low sp(1:M:length(low sp)) sb low;
high sp zeros(1,M*length(sb high)); high sp(1:M:length(high sp)) sb high;
low sp filter(g0,1,low sp); high sp filter(g1,1,high sp);
rec sig 2*(low spþhigh sp);
% Signal alignment for SNR calculations
speech [zeros(1,N 1) speech]; % Align the signal
0
H
0
G
2
↓
( )
x n
( )
x n
1
H
2
↓
1
G
Analysis stage
Synthesis stage
0
H
0
H
1
H
1
H
2
↓
2
↓
2
↓
2
↓
2
↑
2
↑
2
↑
2
↑
1
G
0
G
0
G
2
↑
2
↑
1
G
LL
LH
HL
HH
(a)
0
/ 2
3 / 4
/ 4
LL
LH
HL
HH
(b)
FIGURE 13.12
Four-band implementation based on a binary tree structure.
634
CHAPTER 13 Subband and Wavelet Based Coding

subplot(4,1,1);plot(speech);grid,ylabel(’x(n)’);axis([0 20000
20000 20000]);
subplot(4,1,2);plot(sb low);grid,ylabel(’x0(m)’); axis([0 10000
20000 20000]);
subplot(4,1,3);plot(sb high);grid, ylabel(’x1(m)’); axis([0 10000
2000 2000]);
subplot(4,1,4);plot(rec sig);grid, ylabel(’xbar(n)’),xlabel(’Sample number’);
axis([0 20000
20000 20000]);
NN min(length(speech),length(rec sig));
err rec sig(1:NN) speech(1:NN);
SNR sum(speech.*speech)/sum(err.*err);
disp(’PR reconstruction SNR dB >’);
SNR 10*log10(SNR)
This two-band composition method can easily be extended to a multiband ﬁlter bank using a binary
tree structure. Figure 13.12 describes a four-band implementation. As shown in Figure 13.12, the ﬁlter
banks divide an input signal into two equal subbands, resulting the low (L) and high (H) bands using
PR-QMF. This two-band PR-QMF again splits L and H into half bands to produce quarter bands: LL,
LH, HL, and HH. The four-band spectrum is labeled in Figure 13.12(b). Note that the HH band is
actually centered in ½p=2;3p=4 instead of ½3p=4;p.
In signal coding applications, a dyadic subband tree structure is often used, as shown in Figure 13.13,
where the PR-QMF bank splits only the lower half of the spectrum into two equal bands at any level.
Through continuation of splitting, we can achieve a coarser-and-coarser version of the original signal.
13.3 SUBBAND CODING OF SIGNALS
Subband analysis and synthesis can be successfully applied to signal coding. Figure 13.14 presents an
example of a two-band case. The analytical signals from each channel are ﬁltered by the analysis ﬁlter,
downsampled by a factor of 2, and quantized using quantizers Q0 and Q1 each with a assigned number
0
H
0
G
2
↓
( )
x n
( )
x n
1
H
2
↓
1
G
Analysis stage
Synthesis stage
0
H
1
H
2
↓
2
↓
2
↑
2
↑
0
G
2
↑
2
↑
1
G
FIGURE 13.13
Four-band implementation based on a dyadic tree structure.
13.3 Subband Coding of Signals
635

of bits. The quantized codes are multiplexed for transmission or storage. At the synthesis stage, the
received or recovered quantized signals are demultiplexed, upsampled by a factor of 2, and processed
by the synthesis ﬁlters. Then the output signals from all the channels are added to reconstruct the
original signal. Since the signal from each analytical channel is quantized, the resultant scheme is
a lossy compression one. The coding quality can be measured using the SNR.
Figure 13.15 shows speech coding results using a subband coding system (two-band) with the
following speciﬁcations:
0( )
H
0( )
G
2
↓
( )
x n
( )
x n
1( )
H
1( )
G
e
g
a
ts
sis
e
h
t
n
y
S
e
g
a
ts
sis
yla
n
A
2
↓
2
↑
2
↑
0
Q
1
Q
MUX
DEMUX
FIGURE 13.14
Two-band ﬁlter bank system used for signal compression.
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
x 10
4
2
0
2
x 10
4
x(n)
0
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
2
0
2
x 10
4
x0(m)
0
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
2000
0
2000
x1(m)
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
x 10
4
2
0
2
x 10
4
xbar(n)
Sample number
FIGURE 13.15
Two-subband compression for speech data.
636
CHAPTER 13 Subband and Wavelet Based Coding

Sampling rate ¼ 8 ksps (kilosamples per second)
Sample size ¼ 16 bits/sample
Original data rate ¼ 8 kHz  16 bits ¼128 kbps (kilobits per second)
We assign ten bits for Q0 (since the low-band signal contains more energy) and six bits for Q1.
We obtain a new data rate of (10 þ 6) bits  8 ksps/2 ¼ 64 kbps. The MATLAB
implementation is shown in Program 13.1 with the activated quantizers. Notice that x0ðmÞ and
x1ðmÞ in Figure 13.15 are the quantized versions using Q0 and Q1. The measured SNR is
24.51 dB.
Figure 13.16 shows the results using a four-band system. We designate both Q0 and Q1 as 11 bits,
Q3 as 10 bits, and Q2 as 0 bits (discarded). Note that the HL band contains the highest frequency
components with the lowest signal energy level (see Figure 13.12(b)). Hence, we discard HL band
information to increase the coding efﬁciency. Therefore, we obtain the data rate as (11þ11þ10þ0)
bits  8 ksps/4 ¼ 64 kbps. The measured SNR is 27.06 dB. A four-band system offers a possibility of
signal quality improvement over the two-band system. Plots for the original speech, reconstructed
speech, and quantized signal version for each subband are displayed in Figure 13.17.
Figure 13.18 shows the results using a four-band system (Figure 13.16) for encoding seismic data.
The seismic signal (provided by the US Geological Survey (USGS)) Albuquerque Seismological
Laboratory) has a sampling rate of 15 Hz with 6,700 data samples, and each sample is encoded
in 32 bits. For the four-band system, the bit allocations for all bands are as follows: Q0 (LL) ¼21 bits,
Q1 (LH) ¼ 21 bits, Q3 (HL) ¼ 0 (discarded), and Q4 (HH) ¼19 bits. We achieve a compression ratio
of 4:1 with SNR ¼ 36.00 dB.
0
H
0
G
2
↓
( )
x n
( )
x n
1
H
2
↓
1
G
Analysis stage
Synthesis stage
0
H
0
H
1
H
1
H
2
↓
2
↓
2
↓
2
↓
2
↑
2
↑
2
↑
2
↑
1
G
0
G
0
G
2
↑
2
↑
1
G
0
Q
1
Q
2
Q
3
Q
FIGURE 13.16
Four-subband compression for speech data.
13.3 Subband Coding of Signals
637

13.4 WAVELET BASICS AND FAMILIES OF WAVELETS
Wavelet transform has become a powerful tool for signal processing. It offers time frequency analysis
to decompose the signal in terms of a family of wavelets or a set of basic functions, which have a ﬁxed
shape but can be shifted and dilated in time. The wavelet transform can present a signal with a good
time resolution or a good frequency resolution. There are two types of wavelet transforms: the
continuous wavelet transform (CWT) and the discrete wavelet transform (DWT). Speciﬁcally, the
DWT provides an efﬁcient tool for signal coding. It operates on discrete samples of the signal and has
a relation with the dyadic subband coding described in Section 13.2. The DWT resembles other
discrete transforms, such as the discrete Fourier transform (DFT) or the discrete cosine transform
(DCT). In this section, without getting too detailed with mathematics, we review the basics of the
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
x 10
4
-2
0
2
x 10
4
x(n)
0
500
1000
1500
2000
2500
3000
3500
4000
4500
5000
-2
0
2
x 10
4
x0(m)
0
500
1000
1500
2000
2500
3000
3500
4000
4500
5000
-2
0
2
x 10
4
x1(m)
0
500
1000
1500
2000
2500
3000
3500
4000
4500
5000
-2000
0
2000
x2(m
0
500
1000
1500
2000
2500
3000
3500
4000
4500
5000
-2000
0
2000
x3(m)
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
x 10
4
-2
0
2
x 10
4
Sample number
xbar(n)
FIGURE 13.17
Four-subband compression for 16-bit speech data and SNR ¼ 27.5 dB.
638
CHAPTER 13 Subband and Wavelet Based Coding

CWT, which will lay out the foundation. Next, we emphasize the DWT for applications of signal
coding.
Let us examine a signal sampled at 1 kHz with 1024  32 (32,678) samples given by
xðtÞ ¼ 0:5cosð2p  80tÞ½uðtÞ  uðt  8Þ þ sinð2p  180tÞ½uðt  8Þ  uðt  16Þ
þsinð2p  250tÞ½uðt  16Þ  uðt  32Þ þ 0:1sinð2p  0:8tÞ½uðt  8Þ  uðt  24Þ
(13.30)
The signal contains four sinusoids: 80 Hz for 0  t < 8 seconds, 180 Hz for 8  t < 16 seconds,
350 Hz for 16  t  32 seconds, and ﬁnally 0.8 Hz for 8  t  24 seconds. All the signals are plotted
separately in Figure 13.19 while Figure 13.20 shows the combined signal and its DFT spectrum.
Based on the traditional spectral analysis shown in Figure 13.20, we can identify the frequency
components of 80, 180, and 350 Hz. However, the 0.8-Hz component and transient behaviors such as
the start and stop time instants of the sinusoids (discontinuity) cannot be observed from the spectrum.
Figure 13.21 depicts the wavelet transform of the same signal. The horizontal axis is time in seconds
0
1000
2000
3000
4000
5000
6000
5
0
5
x 10
5
x(n)
0
200
400
600
800
1000
1200
1400
1600
5
0
5
x 10
5
x0(m)
0
200
400
600
800
1000
1200
1400
1600
5
0
5
x 10
5
x1(m)
0
200
400
600
800
1000
1200
1400
1600
5
0
5
x 10
4
x2(m
0
200
400
600
800
1000
1200
1400
1600
5
0
5
x 10
4
x3(m)
0
1000
2000
3000
4000
5000
6000
5
0
5
x 10
5
Sample number
xbar(n)
FIGURE 13.18
Four-subband compression for 32-bit seismic data and SNR ¼ 36 dB.
13.4 Wavelet Basics and Families of Wavelets
639

0
5
10
15
20
25
30
35
0.5
0
0.5
Time (sec.)
80 Hz
0
5
10
15
20
25
30
35
0.5
0
0.5
Time (sec.)
180 Hz
0
5
10
15
20
25
30
35
0.5
0
0.5
Time (sec.)
Time (sec.)
350 Hz
0.8 Hz
0
5
10
15
20
25
30
35
0.1
0
0.1
FIGURE 13.19
Individual signal components.
0
5
10
15
20
25
30
35
1
0.5
0
0.5
1
Comb ned
Time (sec.)
0
50
100
150
200
250
300
350
400
450
500
0
0.1
0.2
0.3
0.4
Frequency (Hz)
Amp tude spectrum
FIGURE 13.20
Combined signal and its spectrum.
640
CHAPTER 13 Subband and Wavelet Based Coding

while the vertical axis is index j, which is inversely proportional to the scale factor (a ¼ 2 j). As will
be discussed, the larger the scale factor (the smaller the index j), the smaller the frequency value. The
amplitudes of the wavelet transform are displayed according to the intensity. The brighter the intensity,
the larger the amplitude. The areas with brighter intensities indicate the strongest resonances between
the signal and the wavelets of various frequency scales and time shifts. In Figure 13.21, the four
different frequency components and the discontinuities of the sinusoids are displayed as well. We can
further observe the fact that the ﬁner the frequency resolution, the coarser the time resolution. For
example, we can clearly identify the start and stop times for 80-, 180-, and 350-Hz frequency
components, but frequency resolution is coarse, since index j has larger frequency spacing. However,
for the 0.8-Hz sinusoid, we have ﬁne frequency resolution (small frequency spacing so we can see the
0.8-Hz sinusoid) and coarse time resolution as evidenced by the way in which the start and stop times
are blurred.
The CWT is deﬁned as
Wða; bÞ ¼
ZN
N
fðtÞjabðtÞdt
(13.31)
where Wða; bÞ is the wavelet transform and jabðtÞ is called the mother wavelet, which is deﬁned as
jabðtÞ ¼
1
a
p j
t  b
a

(13.32)
The wavelet function consists of two important parameters: scaling a and translation b. A scaled
version of the function jðtÞ with a scale factor of a is deﬁned as jðt=aÞ. Consider a base function
jðtÞ ¼ cosðutÞ when a ¼ 1. When a > 1, jðtÞ ¼ cosðut=aÞ is a scaled function with a frequency
less than u rad/s. When a < 1, jðtÞ ¼ cosðut=aÞ has a frequency larger than u. Figure 13.22 shows
the scaled wavelet functions.
FIGURE 13.21
Wavelet transform amplitudes.
13.4 Wavelet Basics and Families of Wavelets
641

A translated version of the function jðtÞ with a shifted time constant b is deﬁned as jðt  bÞ.
Figure 13.23 shows several translated versions of the wavelet. A scaled and translated function jðtÞ is
given by jððt  bÞ=aÞ. This means that jððt  bÞ=aÞ changes frequency and time shift. Several
combined scaling and translated wavelets are displayed in Figure 13.24.
Besides these two properties, a wavelet function must satisfy admissibility and regularity
conditions (vanishing moment up to a certain order). Admissibility requires that the wavelet
(mother wavelet) have a bandpass-limited spectrum and a zero average in the time domain,
which means that wavelets must be oscillatory. Regularity requires that wavelets have some
smoothness and concentration in both time and frequency domains. This topic is beyond the
scope of this book and the details can be found in Akansu and Haddad (1992). There exists
a pair of wavelet functions: the father wavelet (also called the scaling function) and mother
wavelet. Figure 13.25 shows a simplest pair of wavelets: the Haar father wavelet and mother
wavelet.
To devise an efﬁcient wavelet transform algorithm, we let the scale factor be a power of two,
that is,
a ¼ 2 j
(13.33)
Note that the larger the index j, the smaller the scale factor a ¼ 2 j. The time shift becomes
b ¼ k2 j ¼ ka
(13.34)
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
1
0
1
a=2
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
1
0
1
a=1
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
1
0
1
a=0.5
Time (sec.)
FIGURE 13.22
Scaled wavelet functions.
642
CHAPTER 13 Subband and Wavelet Based Coding

0
0.5
1
1.5
2
2.5
1
0
1
a=1,b=0
0
0.5
1
1.5
2
2.5
1
0
1
a=1,b=0.5
0
0.5
1
1.5
2
2.5
1
0
1
a=1,b=1.5
Time (sec.)
FIGURE 13.23
Translated wavelet functions.
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
1
0
1
a=2,b=0
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
1
0
1
a=1,b=0.5
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
1
0
1
a=0.5,b=1.5
Time (sec.)
FIGURE 13.24
Scaled and translated wavelet functions.
13.4 Wavelet Basics and Families of Wavelets
643

Substituting Equations (13.33) and (13.34) into the base function gives
j
t  b
a

¼ j
t  kb
a

¼ jða 1t  kÞ ¼ jð2jt  kÞ
(13.35)
We can deﬁne a mother wavelet at scale j and translation k as
jjkðtÞ ¼ 2j=2jð2jt  kÞ
(13.36)
Similarly, a father wavelet (scaling function) at scale j and translation k is deﬁned as
fjkðtÞ ¼ 2j=2fð2jt  kÞ
(13.37)
0
0.5
1
0
0.2
0.4
0.6
0.8
1
t
Haar father wave et
0
0.5
1
1
0.8
0.6
0.4
0.2
0
0.2
0.4
0.6
0.8
1
t
Haar mother wave et
( )t
Mother wavelet 
( )t
(a) Father wavelet
(b)
FIGURE 13.25
Haar (a) father and (b) mother wavelets.
EXAMPLE 13.2
Sketch the Haar father wavelet families for four different scales, j
0; 1; 2; 3, for a period of one second.
644
CHAPTER 13 Subband and Wavelet Based Coding

Solution:
Based on Equation (13.37), we can determine the wavelet at each required scale as follows:
For j
0, f0kðtÞ
fðt
kÞ, only k
0 is required to cover a 1 second duration.
For j
1, f1kðtÞ
2
p
fð2t
kÞ, k
0 and k
1 are required.
For j
2, f2kðtÞ
2fð4t
kÞ, we need k
0; 1; 2; 3.
For j
3, f3kðtÞ
2
2
p
fð8t
kÞ, we need k
0; 1; 2; /; 7.
Using Figure 13.25(a), we obtain the plots shown in Figure 13.26.
EXAMPLE 13.3
Sketch the Haar mother wavelet families for four different scales, j
0; 1; 2; 3, for a period of 1 second.
Solution:
Based on Equation (13.36), we have
For j
0, j0k
jðt
kÞ, k
0 and k
1 are required.
For j
1, j1k
2
p
jð2t
kÞ, k
0 and k
1 are required.
For j
2, j2k
2jð4t
kÞ, we need k
0; 1; 2; 3.
For j
3, j3kðtÞ
2
2
p
jð8t
kÞ, we need k
0; 1; 2; /; 7.
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.5
1
j=0
t (sec.)
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
1
2
j=1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
1
2
j=2
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
2
j=3
FIGURE 13.26
Haar father wavelets at different scales and translations.
13.4 Wavelet Basics and Families of Wavelets
645

Using Figure 13.25(b), we obtain the plots shown in Figure 13.27.
A signal can be expanded by the father wavelets (scaling function and its translations) at level j.
More accuracy can be achieved by using the larger j. The expanded function is approximated by
fðtÞ z fjðtÞ ¼
X
N
k ¼
N
cjðkÞ2j=2fð2jt  kÞ
(13.38)
where the wavelet coefﬁcients cjðkÞ can be determined by an inner product:
cjðkÞ ¼

fðtÞfjkðtÞ
	
¼
Z
fðtÞ2j=2fð2jt  kÞdt:
(13.39)
EXAMPLE 13.4
Approximate the following function using the Haar scaling function at level j
1:
fðtÞ
(
2
0  t < 0:5
1
0:5  t  1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
1
0
1
j=0
t (sec.)
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
2
0
2
j=1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
2
0
2
j=2
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
2
0
2
j=3
FIGURE 13.27
Haar mother wavelet at different scales and translations.
646
CHAPTER 13 Subband and Wavelet Based Coding

Solution:
Substituting j
1 in Equation (13.38) leads to
fðtÞ z f1ðtÞ
X
N
k
N
c1ðkÞ21=2fð2t
kÞ
We only need k
0 and k
1 to cover the range 0  t  1, that is,
fðtÞ
c1ð0Þ21=2fð2tÞ þ c1ð1Þ21=2fð2t
1Þ
Notice that
fð2tÞ
(
1
for
0  t  0:5
0
elsewhere
and
fð2t
1Þ
(
1
for
0:5  t  1
0
elsewhere
Applying Equation (13.39) yields
c1ð0Þ
Z1=2
0
fðtÞ21=2fð2tÞdt
Z1=2
0
2  21=2  1dt
21=2
Similarly,
c1ð1Þ
Z1
1=2
fðtÞ21=2fð2t
1Þdt
Z1
1=2
1  21=2  1dt
0:5  21=2
Then substituting the coefﬁcients c1ð0Þ and c1ð1Þ leads to
f1ðtÞ
21=2  21=2fð2tÞ þ 0:5  21=221=2fð2t
1Þ
2fð2tÞ þ fð2t
1Þ
fðtÞ
Equation (13.39) can also be approximated numerically:
cjðkÞ z
X
M
1
m ¼ 0
fðtmÞ2j=2fð2jtm  kÞDt
where tm ¼ mDt is the time instant, Dt denotes the time step, and M is the number of intervals. In
this example, if we choose Dt ¼ 0:2, then M ¼ 5 and tm ¼ mDt. The numerical calculations for
Example 13.4 are done as follows:
c1ð0Þ z P
4
m ¼ 0
fðtmÞ21=2fð2tmÞDt ¼ 21=2½fð0Þ  fð0Þ þ fð0:2Þ  fð0:4Þ
þfð0:4Þ  fð0:8Þ þ fð0:6Þ  fð1:2Þ þ fð0:8Þ  fð1:6ÞDt
¼ 21=2ð2  1 þ 2  1 þ 2  1 þ 1  0 þ 1  0Þ  0:2 ¼ 1:2  21=2
c1ð1Þ z P
4
m ¼ 0
fðtmÞ21=2fð2tm  1ÞDt ¼ 21=2½fð0Þ  fð1Þ þ fð0:2Þ  fð0:6Þ
þf ð0:4Þ  fð0:2Þ þ fð0:6Þ  fð0:2Þ þ fð0:8Þ  fð0:6ÞDt
¼ 21=2ð2  0 þ 2  0 þ 2  0 þ 1  1 þ 1  1Þ  0:2 ¼ 0:4  21=2
13.4 Wavelet Basics and Families of Wavelets
647

Finally, we have
f1ðtÞ ¼ 1:2  21=2  21=2fð2tÞ þ 0:4  21=221=2fð2t  1Þ ¼ 2:4fð2tÞ þ 0:8fð2t  1Þ z fðtÞ
It is clear that there is a numerical error. The error can be reduced when a smaller time interval Dt is
adopted.
Figure 13.28 demonstrates the approximation of a sinusoidal delaying function using the scaling
functions (Haar father wavelets) at different scales, i.e., j ¼ 0; 1; 2; 4; 5.
Now, let us examine the function approximation at resolution j ¼ 1:
f1ðtÞ z
X
N
k ¼
N
c1ðkÞ
2
p
fð2t  kÞ ¼ c1ð0Þ
2
p
fð2tÞ þ c1ð1Þ
2
p
fð2t  1Þ
We also look at another possibility at a coarser scale with both the scaling functions (father wavelets)
and mother wavelets, that is, j ¼ 0:
f1ðtÞ z
P
N
k ¼
N
c0ðkÞf0kðtÞ þ
P
N
k ¼
N
d0ðkÞj0kðtÞ
¼ c0ð0Þf00ðtÞ þ d0ð0Þj00ðtÞ ¼ c0ð0ÞfðtÞ þ d0ð0ÞjðtÞ
0
0.5
1
-100
0
100
j=0
0
0.5
1
-100
0
100
j=1
0
0.5
1
-100
0
100
j=2
0
0.5
1
-100
0
100
j=3
0
0.5
1
-100
0
100
j=4
Time (sec.)
0
0.5
1
-100
0
100
j=5
Time (sec.)
FIGURE 13.28
Signal expanded by Haar father wavelets.
648
CHAPTER 13 Subband and Wavelet Based Coding

Furthermore, we see that
f1ðtÞ z c0ð0ÞfðtÞ þ d0ð0ÞjðtÞ
¼ c0ð0Þ
 1
2
p fð2tÞ þ 1
2
p fð2t  1Þ

þ d0ð0Þ
 1
2
p fð2tÞ  1
2
p fð2t  1Þ

¼
1
2
p ðc0ð0Þ þ d0ð0ÞÞfð2tÞ þ 1
2
p ðc0ð0Þ  d0ð0ÞÞfð2t  1Þ
We observe that
c1ð0Þ ¼ 1
2 ðc0ð0Þ þ d0ð0ÞÞ
c1ð1Þ ¼ 1
2 ðc0ð0Þ  d0ð0ÞÞ
This means that
S1 ¼ S0WW0
where S1 contains functions in terms of basis scaling functions at f1kðtÞ, and the function can also be
expanded using the scaling functions f0kðtÞ and wavelet functions j0kðtÞ at a coarser level j  1. In
general, the following statement is true:
Sj ¼ Sj 1WWj 1 ¼ ½Sj 2WWj 2WWj 1
¼ f½Sj 3WWj 3WWj 2gWWj 1
/ ¼ S0WW0WW1W/WWj 1:
(13.40)
Hence, the approximation of fjðtÞ can be expressed as
fðtÞ z fjðtÞ ¼
P
N
k ¼
N
cjðkÞfjkðtÞ
¼
P
N
k ¼
N
cj 1ðkÞfðj 1ÞkðtÞ þ
P
N
k ¼
N
dj 1ðkÞjðj 1ÞkðtÞ
¼
P
N
k ¼
N
cðj 1ÞðkÞ2ðj 1Þ=2fð2ðj 1Þt  kÞ þ
P
N
k ¼
N
dðj 1ÞðkÞ2ðj 1Þ=2jð2ðj 1Þt  kÞ
Repeating the expansion of the ﬁrst sum leads to
fðtÞ z fJðtÞ ¼
P
N
k ¼
N
c0ðkÞf0kðtÞ þ P
J
1
j ¼ 0
P
N
k ¼
N
djðkÞjjkðtÞ
¼
P
N
k ¼
N
c0ðkÞfðt  kÞ þ P
J
1
j ¼ 0
P
N
k ¼
N
djðkÞ2j=2jð2jt  kÞ
(13.41)
13.4 Wavelet Basics and Families of Wavelets
649

where the mother wavelet coefﬁcients djðkÞ can also be determined by the inner product:
djðkÞ ¼

fðtÞjjkðtÞ
	
¼
Z
fðtÞ2j=2jð2jt  kÞdt
(13.42)
Figure 13.29 demonstrates the function approximation (Figure 13.28) with the base scaling function at
resolution j ¼ 0, and mother wavelets at scales j ¼ 0; 1; 2; 3; 4. The combined approximation
(J ¼ 5) using Equation (13.41) is shown in Figure 13.30.
13.5 MULTIRESOLUTION EQUATIONS
There are two very important equations for multiresolution analysis. Each scaling function can be
constructed by a linear combination of translations with the doubled frequency of a base scaling
function fð2tÞ, that is,
fðtÞ ¼
X
N
k ¼
N
2
p
h0ðkÞfð2t  kÞ
(13.43)
0
0.5
1
2
3
4
5
ph , j=0
0
0.5
1
-5
0
5
ps , j=0
0
0.5
1
-10
0
10
ps , j=1
0
0.5
1
-50
0
50
ps , j=2
0
0.5
1
-50
0
50
ps , j=3
Time (sec.)
0
0.5
1
-50
0
50
ps , j=4
Time (sec.)
FIGURE 13.29
Approximations using Haar scaling functions and mother wavelets.
650
CHAPTER 13 Subband and Wavelet Based Coding

where h0ðkÞ is a set of scaling function coefﬁcients (wavelet ﬁlter coefﬁcients). The mother wavelet
function can also be built by a sum of translations with the double frequency of the base scaling
function fð2tÞ, that is,
jðtÞ ¼
X
N
k ¼
N
2
p
h1ðkÞfð2t  kÞ
(13.44)
where h1ðkÞ is another set of wavelet ﬁlter coefﬁcients. Let us verify these two relationships via
Example 13.5 below.
EXAMPLE 13.5
Determine h0ðkÞ for the Haar father wavelet.
Solution:
From Equation (13.43), we can express
fðtÞ
2
p
h0ð0Þfð2tÞ þ
2
p
h0ð1Þfð2t
1Þ
Then we deduce that
h0ð0Þ
h0ð1Þ
1=
2
p
Figure 13.31 shows that the Haar father wavelet is the sum of two scaling functions at scale j
1.
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
60
40
20
0
20
40
60
80
Time (sec.)
Amp tudes
FIGURE 13.30
Signal coded using the wavelets at resolution J ¼ 5.
13.5 Multiresolution Equations
651

EXAMPLE 13.6
Determine h1ðkÞ for the Haar mother wavelet.
Solution:
From Equation (13.44), we can write
jðtÞ
2
p
h1ð0Þfð2tÞ þ
2
p
h1ð1Þfð2t
1Þ
Hence, we deduce that
h1ð0Þ
1=
2
p
and
h1ð1Þ
1=
2
p
Figure 13.32 shows that the Haar mother wavelet is the difference of two scaling functions at scale j
1.
Notice that the relation between H0ðzÞ and H1ðzÞ exists and is given by
h1ðkÞ ¼ ð1Þkh0ðN  1  kÞ
(13.45)
We can verify Equation (13.45) for the Haar wavelet:
h1ðkÞ ¼ ð1Þkh0ð1  kÞ
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.5
1
1.5
sqrt(2)*h0(0)*ph (2t)
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.5
1
1.5
sqrt(2)*h0(1)*ph (2t-1)
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.5
1
1.5
Time (sec.)
ph (t)
FIGURE 13.31
Haar wavelets in Example 13.5.
652
CHAPTER 13 Subband and Wavelet Based Coding

h1ð0Þ ¼ ð1Þ0h0ð1  0Þ ¼ h0ð1Þ ¼ 1=
2
p
h1ð1Þ ¼ ð1Þ1h0ð1  1Þ ¼ h0ð0Þ ¼ 1=
2
p
This means that once we obtain the coefﬁcients of h0ðkÞ, the coefﬁcients h1ðkÞ can be determined via
Equation (13.45). We do not aim to obtain wavelet ﬁlter coefﬁcients here. The topic is beyond the
scope of this book and the details are given in Akansu and Haddad (1992). Instead, some typical ﬁlter
coefﬁcients for Haar and Daubechies are given in Table 13.2.
We can apply the Daubechies-4 ﬁlter coefﬁcients to examine multiresolution Equations (13.43) and
(13.44). From Table 13.2, we have
h0ð0Þ ¼ 0:4830; h0ð1Þ ¼ 0:8365; h0ð2Þ ¼ 0:2241; h0ð3Þ ¼ 0:1294
We then expand Equation (13.43) as
fðtÞ ¼
2
p
h0ð0Þfð2tÞ þ
2
p
h0ð1Þfð2t  1Þ þ
2
p
h0ð2Þfð2t  2Þ þ
2
p
h0ð3Þfð2t  3Þ
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
-1
0
1
sqrt(2)*h1(0)*ph (2t)
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
-1
0
1
sqrt(2)*h1(1)*ph (2t-1)
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
-1
0
1
Time (sec.)
ps (t)
FIGURE 13.32
Haar wavelets in Example 13.6.
13.5 Multiresolution Equations
653

Figure 13.33 shows each component at resolution j ¼ 1 and the constructed scaling function fðtÞ.
The original scaling function fðtÞ is also included as shown in the last plot for comparison.
With the given coefﬁcients h0ðkÞ and applying Equation (13.45), we can obtain the wavelet
coefﬁcients h1ðkÞ as
h1ð0Þ ¼ 0:1294; h1ð1Þ ¼  0:2241; h1ð2Þ ¼ 0:8365;
and
h1ð2Þ ¼ 0:4830
Table 13.2 Typical Wavelet Filter Coefﬁcients h0ðkÞ
Haar
Daubechies 4
Daubechies 6
Daubechies 8
0.707106781186548
0.707106781186548
0.482962913144534
0.836516303737808
0.224143868042013
0.129409522551260
0.332670552950083
0.806891509311093
0.459877502118492
0.135011020010255
0.085441273882027
0.035226291885710
0.230377813308896
0.714846570552915
0.630880767929859
0.027983769416859
0.187034811719093
0.030841381835561
0.032883011666885
0.010597401785069
0
1
2
3
-0.5
0
0.5
1
sqrt(2)*h0(0)*ph (2t)
0
1
2
3
-1
0
1
2
sqrt(2)*h0(1)*ph (2t-0.5)
0
1
2
3
-0.5
0
0.5
sqrt(2)*h0(2)*ph (2t-1)
0
1
2
3
-0.5
0
0.5
sqrt(2)*h0(3)*ph (2t-1.5)
0
1
2
3
-1
0
1
2
ph (t)
Time (sec.)
0
1
2
3
-1
0
1
2
Org na  ph (t)
Time (sec.)
FIGURE 13.33
Constructed 4-tap Daubechies father wavelet.
654
CHAPTER 13 Subband and Wavelet Based Coding

Expanding Equation (13.44) leads to
jðtÞ ¼
2
p
h1ð0Þfð2tÞ þ
2
p
h1ð1Þfð2t  1Þ þ
2
p
h1ð2Þfð2t  2Þ þ
2
p
h1ð3Þfð2t  3Þ
Similarly, Figure 13.34 displays each component at resolution j ¼ 1 and the constructed mother
wavelet function jðtÞ. The last plot displays the original mother wavelet function jðtÞ for
comparison.
13.6 DISCRETE WAVELET TRANSFORM
Now let us examine the discrete wavelet transform (DWT). We begin with coding a signal using
a wavelet expansion as follows:
fðtÞ z fjþ1ðtÞ ¼
X
N
k ¼
N
cjðkÞ2j=2fð2jt  kÞ þ
X
N
k ¼
N
djðkÞ2j=2jð2jt  kÞ
(13.46)
0
1
2
3
-0.5
0
0.5
sqrt(2)*h1(0)*ph (2t)
0
1
2
3
-0.5
0
0.5
sqrt(2)*h1(1)*ph (2t-0.5)
0
1
2
3
-1
0
1
2
sqrt(2)*h1(2)*ph (2t-1)
0
1
2
3
-1
-0.5
0
0.5
sqrt(2)*h1(3)*ph (2t-1.5)
0
1
2
3
-2
0
2
ps (t)
Time (sec.)
0
1
2
3
-2
0
2
Or g na  ps (t)
Time (sec.)
FIGURE 13.34
Constructed 4-tap Daubechies mother wavelet.
13.6 Discrete Wavelet Transform
655

By applying and continuing to apply Equation (13.46), fðtÞ can be coded at any level we wish.
Furthermore, by recursively applying Equation (13.46) until j ¼ 0, we can obtain signal expansion
using all the mother wavelets plus one scaling function at scale j ¼ 0, that is,
fðtÞ z fJðtÞ ¼
X
N
k ¼
N
c0ðkÞfðt  kÞ þ
X
J
1
j ¼ 0
X
N
k ¼
N
djðkÞ2j=2jð2jt  kÞ
(13.47)
All cjðkÞ and all djðkÞ are called the wavelet coefﬁcients. They are essentially weights for the scaling
function(s) and wavelet functions (mother wavelets). The DWT computes these wavelet coefﬁcients.
On the other hand, given the wavelet coefﬁcients, we are able to reconstruct the original signal by
applying the inverse discrete wavelet transform (IDWT).
Based on the wavelet theory without proof (see Appendix F), we can perform the DWT using the
analysis equations as follows:
cjðkÞ ¼
X
N
m ¼
N
cjþ1ðmÞh0ðm  2kÞ
(13.48)
djðkÞ ¼
X
N
m ¼
N
cjþ1ðmÞh1ðm  2kÞ
(13.49)
where h0ðkÞ are the lowpass wavelet ﬁlter coefﬁcients listed in Table 13.2, while h1ðkÞ, the highpass
ﬁlter coefﬁcients, can be determined by
h1ðkÞ ¼ ð1Þkh0ðN  1  kÞ
(13.50)
These lowpass and highpass ﬁlters are called the quadrature mirror ﬁlters (QMF). As an example, the
frequency responses of the 4-tap Daubechies wavelet ﬁlters are plotted in Figure 13.35.
Next, we need to determine the ﬁlter inputs cjþ1ðkÞ in Equations (13.48) and (13.49). In practice,
since j is a large number, the function fð2jt  kÞ appears to be close to an impulse-like function, that
is, fð2jt  kÞz2 jdðt  k2 jÞ. For example, the Haar scaling function can be expressed as
fðtÞ ¼ uðtÞ  uðt  1Þ, where uðtÞ is the step function. We can easily get fð25t  kÞ ¼ uð25t  kÞ 
uð25t  1  kÞ ¼ uðt  k2 5Þ  uðt  ðk þ 1Þ2 5Þ for j ¼ 5, which is a narrow pulse with a
unit height and a width 2 5 located at t ¼ k2 5. The area of the pulse is therefore 2
5. When
j approaches a larger positive integer, fð2jt  kÞz2 jdðt  k2 jÞ. Therefore, fðtÞ approximated by the
scaling function at level j is rewritten as
fðtÞ z fjðtÞ ¼
P
N
k ¼
N
cjðkÞ2j=2fð2jt  kÞ
¼ / þ cjð0Þ2j=2fð2jtÞ þ cjð1Þ2j=2fð2jt  1Þ þ cjð2Þ2j=2fð2jt  2Þ þ /
z / þ cjð0Þ2 j=2dðtÞ þ cjð1Þ2 j=2dðt  1  2 jÞ þ cjð2Þ2 j=2dðt  2  2 jÞ þ /
(13.51)
On the other hand, if we sample fðtÞ using the same sample interval Ts ¼ 2 j (time resolution), the
discrete-time function can be expressed as
fðnÞ ¼ fðnTsÞ ¼ / þ fð0TsÞTsdðt  TsÞ þ fðTsÞTsdðt  TsÞ þ fð2TsÞTsdðn  2TsÞ þ /
(13.52)
656
CHAPTER 13 Subband and Wavelet Based Coding

Hence, comparing Equation (13.51) with the discrete-time version in Equation (13.52), it follows that
cjðkÞ2 j=2 ¼ fðkÞTs
(13.53)
Substituting Ts ¼ 2 j in Equation (13.53) leads to
cjðkÞ ¼ 2 j=2fðkÞ
(13.54)
With the obtained sequence cjðkÞ using sample values fðkÞ, we can perform the DWT using Equations
(13.48) and (13.49). Furthermore, Equations (13.48) and (13.49) can be implemented using a dyadic
tree structure similar to the subband coding case. Figure 13.36 depicts the case for j ¼ 2.
Note that the reversed sequences h0ðkÞ and h1ðkÞ are used in the analysis stage. Similarly, the
IDWT (synthesis equation) can be developed (see Appendix F) and expressed as
cjþ1ðkÞ ¼
X
N
m ¼
N
cjðmÞh0ðk  2mÞ þ
X
N
m ¼
N
djðmÞh1ðk  2mÞ
(13.55)
Finally, the signal amplitude can be rescaled by
fðkÞ ¼ 2j=2cjðkÞ
(13.56)
An implementation for j ¼ 2 using the dyadic subband coding structure is illustrated in Figure 13.37.
0
0.5
1
1.5
2
2.5
3
0
0.5
1
1.5
Frequency in radians
Magn tude
H0(z)
H1(z)
FIGURE 13.35
Frequency responses for 4-tap Daubechies ﬁlters.
13.6 Discrete Wavelet Transform
657

Now, let us study the DWT and IDWT in the following examples.
EXAMPLE 13.7
Given the sample values [4 2
1 0], use the Haar wavelets to determine the wavelet coefﬁcients.
Solution:
Form the ﬁlter inputs:
c2ðkÞ
22=2  ½ 4
2
1
0 

2
1
1
2
0

The acquired Haar wavelet ﬁlter coefﬁcients are listed as
h0ðkÞ

 1
2
p
1
2
p

and
h1ðkÞ

 1
2
p
1
2
p

The function is expanded by the scaling functions as
fðtÞ z f2ðtÞ
P
N
k
N
cjðkÞ2j=2fð2jt
kÞ
4  fð4tÞ þ 2  fð4t
1Þ
1  fð4t
2Þ þ 0  fð4t
3Þ:
0
H
2
2c
1
H
2
0
H
1
H
2
2
1d
1c
0c
0
d
0(
)
h
k
0(
)
h
k
1(
)
h
k
1(
)
h
k
FIGURE 13.36
Analysis using the dyadic subband coding structure.
0
H
2c
1
H
+
2
2
+
0
H
2
2
1
H
0c
0
d
1d
1c
FIGURE 13.37
Synthesis using the dyadic subband coding structure.
658
CHAPTER 13 Subband and Wavelet Based Coding

We will verify this expression later. Applying the wavelet analysis equations, we have
c1ðkÞ
X
N
m
N
c2ðmÞh0ðm
2kÞ
d1ðkÞ
X
N
m
N
c2ðmÞh1ðm
2kÞ
Speciﬁcally,
c1ð0Þ
X
N
m
N
c2ðmÞh0ðmÞ
c2ð0Þh0ð0Þ þ c2ð1Þh0ð1Þ
2  1
2
p
þ 1  1
2
p
3
2
p
2
c1ð1Þ
X
N
m
N
c2ðmÞh0ðm
2Þ
c2ð2Þh0ð0Þ þ c2ð3Þh0ð1Þ
 1
2

 1
2
p
þ 0  1
2
p
1
2
2
p
d1ð0Þ
X
N
m
N
c2ðmÞh1ðmÞ
c2ð0Þh1ð0Þ þ c2ð1Þh1ð1Þ
2  1
2
p
þ 1 

1
2
p

1
2
p
d1ð1Þ
X
N
m
N
c2ðmÞh1ðm
2Þ
c2ð2Þh1ð0Þ þ c2ð3Þh1ð1Þ
 1
2

 1
2
p
þ 0 

1
2
p

1
2
2
p
Using the subband coding method in Figure 13.36 yields
>> x0 rconv([1 1]/sqrt(2),[2 1
0.5 0])
x0
2.1213 0.3536
0.3536 1.4142
>> c1 x0(1:2:4)
c1
2.1213
0.3536
>> x1 rconv([1
1]/sqrt(2),[2 1
0.5 0])
x1
0.7071 1.0607
0.3536
1.4142
>> d1 x1(1:2:4)
d1
0.7071
0.3536
where the MATLAB function rconv() for ﬁlter operations with the reversed ﬁlter coefﬁcients is listed in Section
13.8. Repeating for the next level, we have
c0ðkÞ
X
N
m
N
c1ðmÞh0ðm
2kÞ
d0ðkÞ
X
N
m
N
c1ðmÞh1ðm
2kÞ
Thus
c0ð0Þ
X
N
m
N
c1ðmÞh0ðmÞ
c1ð0Þh0ð0Þ þ c1ð1Þh0ð1Þ
3
2
p
2
 1
2
p
þ ð
1
2
2
p Þ  1
2
p
5
4
d0ð0Þ
X
N
m
N
c1ðmÞh1ðmÞ
c1ð0Þh1ð0Þ þ c1ð1Þh1ð1Þ
3
2
p
2
 1
2
p
þ

1
2
2
p



1
2
p

7
4
13.6 Discrete Wavelet Transform
659

The MATLAB veriﬁcations follow:
>> xx0 rconv([1 1]/sqrt(2),c1)
xx0
1.2500 1.2500
>> c0 xx0(1:2:2)
c0
1.2500
>> xx1 rconv([1
1]/sqrt(2),c1)
xx1
1.7500
1.7500
>> d0 xx1(1:2:2)
d0
1.7500
Finally, we pack the wavelet coefﬁcients w2ðkÞ at j
2 together as
w2ðkÞ
½c0ð0Þd0ð0Þd1ð0Þd1ð1Þ

5
4
7
4
1
2
p
1
2
2
p

Then the function can be expanded using one scaling function and three mother wavelet functions:
fðtÞ z f2ðtÞ
P
N
k
N
c0ðkÞfðt
kÞ þ P
1
j
0
P
N
k
N
djðkÞ2j=2jð2jt
kÞ
5
4fðtÞ þ 7
4jðtÞ þ jð2tÞ
1
2jð2t
1Þ
Figure 13.38 shows the plots for each function and the combined function to verify that fðtÞ does have amplitudes
of 4, 2,
1, and 0.
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
-2
0
2
(5/4)*phi(t)
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
-2
0
2
(7/4)*psi(t)
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
-1
0
1
psi(2t)
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
-1
0
1
psi(2t-1)
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
-4
-2
0
2
4
6
Time (sec.)
f(t)
FIGURE 13.38
The signal reconstructed using the Haar wavelets in Example 13.7.
660
CHAPTER 13 Subband and Wavelet Based Coding

We can use the MATLAB function dwt() provided in Section 13.8 to compute the DWT coefﬁcients.
dwt.m
function w
dwt(h0,c,kLevel)
% h0
wavelet filter coefficients (lowpass filter)
% c
input vector
% kLevel
level
% w
wavelet coefficients
The results are veriﬁed as follows:
>> w dwt([1/sqrt(2) 1/sqrt(2)],[4 2
1 0]/2,2)’
w
1.2500 1.7500 0.7071
0.3536
From Example 13.7, we can create a time frequency plot of the DWT amplitudes in two dimen-
sions as shown in Figure 13.39. Assuming the sampling frequency is fs, we have the smallest frequency
resolution as fs=N ¼ fs=4, where N ¼ 4. When j (j ¼ 0) is small, we achieve a small frequency
resolution Df ¼ fs=4 and each wavelet presents four samples. In this case, we have a good fre-
quency resolution but a poor time resolution. Similarly, when j (j ¼ 1) is a large value, the frequency
resolution becomes Df ¼ 2fs=4 and each wavelet presents two samples (more details in the time
domain). Hence, we achieve a good time resolution but a poor frequency resolution. Note that
5 ( )
4
t
7
( )
4
t
0
n
Sample number
1 (2 )t
1
(2
1)
2
t
0
0
j
f
0
0
2 (
/ 4)
s
j
f
f
1
1
2 (
/ 4)
s
j
f
f
j
4
1
2
3
Good frequency resolution
Good time resolution
/ 4
s
f
f
2
/ 4
s
f
f
2 samples
4 samples
4 samples
0
1
(a)  Time–frequency plane
Time
Frequency
(b)  Time–frequency plot
FIGURE 13.39
Time frequency plot of the DWT amplitudes.
13.6 Discrete Wavelet Transform
661

the DWT cannot achieve good resolutions in both frequency and time at the same time. The time
frequency plot of the DWT amplitudes in terms of their intensity is shown in Figure 13.39(b), and the
time and frequency plane for the DWT is shown in Figure 13.40.
EXAMPLE 13.8
Given the wavelet coefﬁcients obtained using the Haar wavelet ﬁlters
½c0ð0Þd0ð0Þd1ð0Þd1ð1Þ

5
4
7
4
1
2
p
1
2
2
p

perform the IDWT.
Solution:
From Equation (13.55) we get
c1ðkÞ
X
N
m
N
c0ðmÞh0ðk
2mÞ þ
X
N
m
N
d0ðmÞh1ðk
2mÞ
Then we recover coefﬁcients c1ðkÞ as
c1ð0Þ
X
N
m
N
c0ðmÞh0ð 2mÞ þ
X
N
m
N
d0ðmÞh1ð 2mÞ
c0ð0Þh0ð0Þ þ d0ð0Þh1ð0Þ
5
4  1
2
p
þ 7
4  1
2
p
3
2
p
2
c1ð1Þ
X
N
m
N
c0ðmÞh0ð1
2mÞ þ
X
N
m
N
d0ðmÞh1ð1
2mÞ
c0ð0Þh0ð1Þ þ d0ð0Þh1ð1Þ
5
4  1
2
p
þ 7
4 

1
2
p

1
2
2
p
MATLAB veriﬁcation using Figure 13.37 is given as
>> c1 fconv([1 1]/sqrt(2),[5/4 0])þfconv([1
1]/sqrt(2),[7/4 0])
c1
2.1213
0.3536
High frequency 
(Large j, small scale=2 )
j
Low frequency 
(Small j, large scale=2
)
j
Time
FIGURE 13.40
Time frequency plane.
662
CHAPTER 13 Subband and Wavelet Based Coding

where the MATLAB function fconv() for ﬁlter operations with the forward ﬁlter coefﬁcients is listed in Section 13.8.
Again, from Equation (13.55), we obtain
c2ðkÞ
X
N
m
N
c1ðmÞh0ðk
2mÞ þ
X
N
m
N
d1ðmÞh1ðk
2mÞ
Substituting the achieved wavelet coefﬁcients c2ðkÞ, we yield
c2ð0Þ
X
N
m
N
c1ðmÞh0ð 2mÞ þ
X
N
m
N
d1ðmÞh1ð 2mÞ
c1ð0Þh0ð0Þ þ d1ð0Þh1ð0Þ
3
2
p
2

 1
2
p

þ 1
2
p
 1
2
p
2
c2ð1Þ
X
N
m
N
c1ðmÞh0ð1
2mÞ þ
X
N
m
N
d1ðmÞh1ð1
2mÞ
c1ð0Þh0ð1Þ þ d1ð0Þh1ð1Þ
3
2
p
2
 1
2
p
þ 1
2
p

1
2
p

1
c2ð2Þ
X
N
m
N
c1ðmÞh0ð2
2mÞ þ
X
N
m
N
d1ðmÞh1ð2
2mÞ
c1ð1Þh0ð0Þ þ d1ð1Þh1ð0Þ

1
2
2
p

 1
2
p
þ

1
2
2
p

 1
2
p
1
2
c2ð3Þ
X
N
m
N
c1ðmÞh0ð3
2mÞ þ
X
N
m
N
d1ðmÞh1ð3
2mÞ
c1ð1Þh0ð1Þ þ d1ð1Þh1ð1Þ

1
2
2
p

 1
2
p
þ

1
2
2
p



1
2
p

0
We can verify the results using the MATLAB program as follows:
>> c2 fconv([1 1]/sqrt(2),[3*sqrt(2)/2 0
1/(2*sqrt(2)) 0])þfconv([1
1]/sqrt(2),[1/sqrt(2) 0
1/(2*sqrt(2)) 0])
c2
2.0000 1.0000
0.5000 0
Scaling the wavelet coefﬁcients, we ﬁnally recover the original sample values as
fðkÞ
22=2½2 1
0:5 0
½4 2
1 0
Similarly, we can use the MATLAB function idwt() provided in Section 13.8 to perform the IDWT.
idwt.m
function c
idwt(h0,w,kLevel)
% h0
wavelet filter coefficients (lowpass filter)
% w
wavelet coefficients
% kLevel
level
% c
input vector
Appling the MATLAB function idwt() leads to
>> f 2*idwt([1/sqrt(2) 1/sqrt(2)],[5/4 7/4 1/sqrt(2)
1/(2*sqrt(2))],2)’
f
4.0000 2.0000
1.0000 0.0000
Since 2j=2 scales signal amplitudes down in the analysis stage and scales them back up in the synthesis stage, we
can omit 2j=2 by using cðkÞ
fðkÞ directly in practice.
13.6 Discrete Wavelet Transform
663

EXAMPLE 13.9
Given the sample values [4 2
1 0], use the provided MATLAB DWT (dwt.m) and IDWT (idwt.m) and speciﬁed
wavelet ﬁlter to perform the DWT and IWDT without using the scale factor 2j=2.
a. Haar wavelet ﬁlter
b. 4 tap Daubechies wavelet ﬁlter
Solution:
a. From Table 13.2, the Haar wavelet ﬁlter coefﬁcients are
h0
 1
2
p
1
2
p

Applying the MATLAB functions dwt() and idwt(), we have
>> w dwt([1/sqrt(2) 1/sqrt(2)],[4 2
1 0],2)’
w
2.5000 3.5000 1.4142
0.7071
>> f idwt([1/sqrt(2) 1/sqrt(2)],w,2)’
f
4.0000 2.0000
1.0000 0
b. From Table 13.2, the 4 Tap Duabechies wavelet ﬁlter coefﬁcients are
h0 [0.482962913144534 0.836516303737808 0.224143868042013
0.129409522551260]
MATLAB program veriﬁcation is demonstrated as follows:
>> w dwt([0.482962913144534 0.836516303737808 0.224143868042013
0.129409522551260],
[4 2
1 0],2)’
w
2.5000 2.2811
1.8024 2.5095
>> f idwt([0.482962913144534 0.836516303737808 0.224143868042013
0.129409522551260],
w,2)’
f
4.0000 2.0000
1.0000 0
13.7 WAVELET TRANSFORM CODING OF SIGNALS
We can apply the DWT and IWDT for data compression and decompression. The compression and
decompression involves two stages, that is, the analysis stage and the synthesis stage. At the analysis
stage, the wavelet coefﬁcients are quantized based on their signiﬁcance. Usually, we assign more bits
to the coefﬁcient in a coarser scale, since the corresponding subband has larger signal energy and low
frequency components. We assign a small number of bits to a coefﬁcient that resides in a ﬁner scale,
since the corresponding subband has lower signal energy and high frequency components. The
quantized coefﬁcients can be efﬁciently transmitted. The DWT coefﬁcients are laid out in a format
described in Figure 13.41. The coarse coefﬁcients are placed towards the left side. For example, in
Example 13.7, we organized the DWT coefﬁcient vector as
w2ðkÞ ¼ ½c0ð0Þd0ð0Þd1ð0Þd1ð1Þ ¼

5
4
7
4
1
2
p 
1
2
2
p

Let us look at the following simulation examples.
664
CHAPTER 13 Subband and Wavelet Based Coding

EXAMPLE 13.10
Consider a 40 Hz sinusoidal signal plus random noise sampled at 8,000 Hz with 1,024 samples:
xðnÞ
100 cos ð2p  40nTÞ þ 10  randn
where T
1=8;000 seconds and randn is a random noise generator with a unit power and Gaussian distribution.
Use a 16 bit code for each wavelet coefﬁcient and write a MATLAB program to perform data compression for each
of the following ratios: 2:1, 4:1, 8:1, and 16:1. Plot the reconstructed waveforms.
Solution:
We use the 8 tap Daubechies ﬁlter as listed in Table 13.2. We achieve the data compression by dropping the high
subband coefﬁcients for each level consecutively and coding each wavelet coefﬁcient in the lower subband using
16 bits. For example, we achieve the 2:1 compression ratio by omitting 512 high frequency coefﬁcients at the ﬁrst
level, 4:1 by omitting 512 high frequency coefﬁcients at the ﬁrst level, and 256 high frequency coefﬁcients at the
second level, and so on. The recovered signals are plotted in Figure 13.42. SNR
21 dB is achieved for the 2:1
compression ratio. As we can see, when more and more higher frequency coefﬁcients are dropped, the recon
structed signal contains less and less details. The recovered signal with 16:1 compression presents the least
details but shows the smoothest signal. On the other hand, omitting the high frequency wavelet coefﬁcients can be
very useful for a signal denoising application, in which the high frequency noise contaminating the clean signal is
removed. A complete MATLAB program is given in Program 13.2.
Program 13.2. Wavelet data compression.
close all; clear all;clc
t 0:1:1023;t t/8000;
x 100*cos(40*2*pi*t)þ10*randn(1,1024);
h0 [0.230377813308896 0.714846570552915 0.630880767929859 .
0.027983769416859
0.187034811719092 0.030841381835561 ..
0.032883011666885
0.010597401785069];
N 1024; nofseg 1
rec sig []; rec sig2t1 []; rec sig4t1 []; rec sig8t1 []; rec sig16t1 [];
for i 1:nofseg
1024
512
512
512
256
256
512
256
128
10
c
9c
9
d
9
d
8
d
8c
9
d
8
d
7
d
0c
0
d
Level-0
Level-1
Level-2
Level-10
FIGURE 13.41
DWT coefﬁcient layout.
13.7 Wavelet Transform Coding of Signals
665

0
0.02
0.04
0.06
0.08
0.1
0.12
100
0
100
x(n)
0
0.02
0.04
0.06
0.08
0.1
0.12
100
0
100
2:1
0
0.02
0.04
0.06
0.08
0.1
0.12
100
0
100
0
0.02
0.04
0.06
0.08
0.1
0.12
100
0
100
8:1
4:1
0
0.02
0.04
0.06
0.08
0.1
0.12
100
0
100
16:1
Time (sec.)
FIGURE 13.42
Reconstructed signal at various compression ratios.
sp x((i 1)*1024þ1:i*1024);
w dwt(h0,sp,10);
% Quantization
wmax round(max(abs(w)));
wcode round(2^15*w/wmax); % 16 bit code for storage
w wcode*wmax/2^15; % Recovered wavelet coefficients
w(513:1024) zeros(1,512); % 2:1 compression ratio
sig rec2t1 idwt(h0,w,10);
rec sig2t1 [rec sig2t1 sig rec2t1’];
w(257:1024) 0; % 4:1 compression ratio
sig rec4t1 idwt(h0,w,10);
rec sig4t1 [rec sig4t1 sig rec4t1’];
w(129:1024) 0; % 8:1 compression ratio
sig rec8t1 idwt(h0,w,10);
rec sig8t1 [rec sig8t1 sig rec8t1’];
w(65:1024) 0; % 16:1 compression ratio
sig rec16t1 idwt(h0,w,10);
rec sig16t1 [rec sig16t1 sig rec16t1’];
end
subplot(5,1,1),plot(t,x,’k’); axis([0 0.12
120 120]);ylabel(’x(n)’);
subplot(5,1,2),plot(t,rec sig2t1,’k’); axis([0 0.12
120 120]);ylabel(’2:1’);
subplot(5,1,3),plot(t,rec sig4t1,’k’); axis([0 0.12
120 120]);ylabel(4:1);
subplot(5,1,4),plot(t,rec sig8t1,’k’); axis([0 0.12
120 120]);ylabel(’8:1’);
666
CHAPTER 13 Subband and Wavelet Based Coding

subplot(5,1,5),plot(t,rec sig16t1,’k’); axis([0 0.12
120 120]);ylabel(’16:1’);
xlabel(’Time (sec.)’)
NN min(length(x),length(rec sig2t1)); axis([0 0.12
120 120]);
err rec sig2t1(1:NN) x(1:NN);
SNR sum(x.*x)/sum(err.*err);
disp(’PR reconstruction SNR dB >’);
SNR 10*log10(SNR)
Figure 13.43 shows the wavelet compression for 16-bit speech data sampled at 8 kHz. The original
speech data is divided into speech segments, each with 1,024 samples. After applying the DWT to each
segment, the coefﬁcients, which correspond to high frequency components indexed from 513 to 1,024,
are discarded in order to achieve coding efﬁciency. The reconstructed speech data has a compression
ratio 2:1 with SNR ¼ 22 dB. The MATLAB program is given in Program 13.3.
Program 13.3. Wavelet data compression for speech segments.
close all; clear all;clc
load orig.dat ; % Load speech data
h0 [0.230377813308896 0.714846570552915 0.630880767929859 .
0.027983769416859
0.187034811719092 0.030841381835561 ..
0.032883011666885
0.010597401785069];
N length(orig);
nofseg ceil(N/1024);
speech zeros(1,nofseg*1024);
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
x 10
4
2
1
0
1
2
x 10
4
Or g na  data x(n)
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
x 10
4
2
1
0
1
2
x 10
4
Sample number
Recovered x(n) CR=2:1
FIGURE13.43
Reconstructed speech signal with compression ratio of 2 and SNR ¼ 22 dB.
13.7 Wavelet Transform Coding of Signals
667

speech(1:N) orig(1:N); % Making the speech length a multiple of 1024 samples
rec sig [];
for i 1:nofseg
sp speech((i 1)*1024þ1:i*1024);
w dwt(h0,sp,10);
% Quantization
w (round(2^15*w/2^15))*2^(15 15);
w(513:1024) zeros(1,512); % Omitting the high frequency coefficients
sp rec idwt(h0,w,10);
rec sig [rec sig sp rec’];
end
subplot(2,1,1),plot([0:length(speech) 1],speech,’k’);axis([0 20000
20000 20000]);
ylabel(’Original data x(n)’);
subplot(2,1,2),plot([0:length(rec sig) 1],rec sig,’k’);axis([0 20000
20000 20000]);
xlabel(’Sample number’);ylabel(’Recovered x(n) CR 2:1’);
NN min(length(speech),length(rec sig));
err rec sig(1:NN) speech(1:NN);
SNR sum(speech.*speech)/sum(err.*err);
disp(’PR reconstruction SNR dB >’);
SNR 10*log10(SNR)
Figure 13.44 displays the wavelet compression for 16-bit ECG data using Program 13.3. The
reconstructed ECG data has a compression ratio of 2:1 with SNR ¼ 33.8 dB.
Figure 13.45 illustrates an application of signal denoising using the DWTwith a coefﬁcient threshold.
During the analysis stage, an obtained DWT coefﬁcient (quantization is not necessary) is set to zero if its
value is less than the predeﬁned threshold depicted in Figure 13.45. This simple technique is called the
hard threshold. Usually, the small wavelet coefﬁcients are related to the high frequency components in
signals. Therefore, setting high frequency components to zero is the same as lowpass ﬁltering.
An example is shown in Figure 13.46. The ﬁrst plot depicts a 40-Hz noisy sinusoidal signal (sine
wave plus noise with SNR ¼ 18 dB) and the clean signal with a sampling rate of 8,000 Hz. The second
plot shows that after zero threshold operations, 67% of coefﬁcients are set to zero and the recovered
signal has SNR ¼ 19 dB. Similarly, the third and fourth plots illustrate that 93% and 97% of coef-
ﬁcients are set to zero after threshold operations and the recovered signals have SNR ¼ 23 and 28 dB,
respectively. As an evidence that the signal is smoothed, that is, high frequency noise is attenuated, the
wavelet denoising technique is equivalent to lowpass ﬁltering.
13.8 MATLAB PROGRAMS
In this section, four key MATLAB programs are listed. rconv() and fconv() perform circular
convolutions with the reversed ﬁlter coefﬁcients and the forward ﬁlter coefﬁcients, respectively. dwt()
and idwt() are the programs to compute the DWT coefﬁcients and IDWT coefﬁcients. The resolution
level can be speciﬁed.
Program 13.4. Circular convolution with the reversed ﬁlter coefﬁcients (rconv.m).
function [y]
rconv(h,c)
% Circular convolution using the reversed filter coefficients h( k)
668
CHAPTER 13 Subband and Wavelet Based Coding

( )
w k
( )
w k
∼
Original coefficients
Hard threshold coefficients
Threshold
   value
Threshold
   value
FIGURE 13.45
Hard threshold for the DWT coefﬁcients.
0
500
1000
1500
2000
2500
3000
3500
4000
4500
5000
1
0.5
0
0.5
1
x 10
4
16-b t ECG data x(n)
0
500
1000
1500
2000
2500
3000
3500
4000
4500
5000
1
0.5
0
0.5
1
x 10
4
Sample number
Recovered x(n) CR=2:1
FIGURE 13.44
Reconstructed ECG signal with compression ratio of 2 and SNR ¼ 33.8 dB.
13.8 Matlab Programs
669

% h
filter coefficients
% c
input vector
% y
output vector
N length(c); M length(h);
xx zeros(1,MþN 1);
xx(1:N) c;
xx(Nþ1:NþM 1) c(1:M 1); % Use periodized input
for n 1:N;
y(n) 0;
for m 1:M
y(n) y(n)þh(m)*xx(nþm 1);
end
end
Program 13.5. Circular convolution with the forward ﬁlter coefﬁcients (fconv.m).
function [y]
fconv(h,c)
% Circular convolution using the forward filter coefficients h(k)
% h
filter coefficients
% c
input vector
% y
output vector
N length(c); M length(h);
0
0.02
0.04
0.06
0.08
0.1
0.12
100
0
100
SNR=18 dB
No sy s gna
0
0.02
0.04
0.06
0.08
0.1
0.12
100
0
100
SNR=19 dB
67% zero coef.
0
0.02
0.04
0.06
0.08
0.1
0.12
100
0
100
SNR=23 dB
93% zero coef.
0
0.02
0.04
0.06
0.08
0.1
0.12
100
0
100
Time (sec.)
SNR=28 dB
97% zero coef.
FIGURE 13.46
Signal denoising using wavelet transform coding.
670
CHAPTER 13 Subband and Wavelet Based Coding

x(1:NþM 1)
zeros(1,NþM 1);
for j
1:N
x(j:Mþ(j 1))
x(j:Mþ(j 1)) þ c(j)*h;
end
for i
NþM 1: 1:Nþ1
x(i N)
x(i N) þ x(i); % Circular convolution
end
y x(1:N);
Program 13.6. DWT coefﬁcients (dwt.m).
function w
dwt(h0,c,kLevel)
% w
dwt(h,c,k)
% Computes wavelet transform coefficients for a vector c using the
% orthonormal wavelets defined by the coefficients h.
% h
wavelet coefficients
% c
input vector
% kLelvel
level
% w
wavelet coefficients
n length(c); m
length(h0);
h1
h0(m: 1:1); h1(2:2:m)
h1(2:2:m);
h0
h0(:)’; h1
h1(:)’;
c
c(:); w
c;
x
zeros(nþm 2,1);
% Perform decomposition through k levels
% at each step, x
periodized version of x coefficients
for j
1:kLevel
x(1:n)
w(1:n);
for i
1:m 2
x(nþi)
x(i);
end
for i
1:n/2
w(i)
h0 * x(1 þ 2*(i 1):m þ 2*(i 1));
w(n/2 þ i)
h1* x(1 þ 2*(i 1):m þ 2*(i 1));
end
n
n/2;
end
Program 13.7. IDWT coefﬁcients (idwt.m).
function c
idwt(h0,w,kLevel)
% c
idwt(h0,w,kLevel)
% Computes the inverse fast wavelet transform from data W using the
% orthonormal wavelets defined by the coefficients.
% h0
wavelet filter coefficients
% w
wavelet coefficients
% kLevel
level
% c
IDWT coefficients
n length(w); m
length(h0);
h1
h0(m: 1:1); h1(2:2:m)
h1(2:2:m);
13.8 Matlab Programs
671

h0
h0(:); h1
h1(:);
w
w(:); c
w;
x
zeros(nþm 2,1);
% Perform the reconstruction through k levels
% x
periodized version of x coefficients
n
n/2^kLevel;
for i
1:kLevel
x(1:2*nþm 2)
zeros(2*nþm 2,1);
for j
1:n
x(1þ2*(j 1):mþ2*(j 1))
x(1þ2*(j 1):mþ2*(j 1)) þ c(j)*h0 þ w(nþj)*h1;
end
for i
2*nþm 2: 1:2*nþ1
x(i 2*n)
x(i 2*n) þ x(i);
end
c(1:2*n)
x(1:2*n);
n
2 * n;
end
13.9 SUMMARY
1. A signal can be decomposed using a ﬁlter bank system. The ﬁlter bank contains two stages: the
analysis stage and the synthesis stage. The analysis stage applies analysis ﬁlters to decompose the
signal into multiple channels. The signal from each channel is downsampled and coded. At
the synthesis stage, the recovered signal from each channel is upsampled and processed using
its synthesis ﬁlter. Then the outputs from all the synthesis ﬁlters are combined to produce the
recovered signal.
2. Perfect reconstruction conditions for the two-band case are derived to design the analysis and
synthesis ﬁlters. The conditions consist of a half-band ﬁlter requirement and normalization.
Once the lowpass analysis ﬁlter coefﬁcients are obtained, the coefﬁcients for other ﬁlters can
be achieved from the derived relationships.
3. In a binary tree structure, a ﬁlter bank divides an input signal into two equal subbands, resulting in
the low and high bands. Each band again splits into low and high bands to produce quarter bands.
The process continues in this form.
4. The dyadic structure implementation of the ﬁlter bank ﬁrst splits the input signal to low and high
bands and then continues to split the low band only each time.
5. By quantizing each subband channel using the assigned number bits based on the signal
signiﬁcance (more bits assigned to code the samples for channels with large signal energy
while less bits assigned to code the samples for channels with small signal energy), the
subband coding method demonstrates efﬁciency for data compression.
6. The wavelet transform can identify the frequencies in a signal and the times when the signal
elements occur and end.
7. The wavelet transform provides either good frequency resolution or good time resolution, but not
both.
672
CHAPTER 13 Subband and Wavelet Based Coding

8. The wavelet has two important properties: scaling and translation. The scaling process is related
to changes of wavelet frequency (oscillation) while translation is related to the time localization.
9. A family of wavelets contains a father wavelet and a mother wavelet, and their scaling and
translation versions. The father wavelet and its scaling and translation are called the scaling
function while the mother wavelet and its scaling and translation are called the wavelet
function. Each scaling function and wavelet function can be presented using the scaling
functions in the next ﬁner scale.
10. A signal can be approximated from a sum of weighted scaling functions and wavelet functions.
The weights are essentially the DWT coefﬁcients. A signal can also be coded at any desired level
using smaller-scale wavelets.
11. Implementation of DWT and IDWT consists of the analysis and synthesis stages, which are
similar to the subband coding scheme. The implementation uses the dyadic structure but with
analysis ﬁlter coefﬁcients in a reversed format.
12. The DWT and IDWT are very effective for data compression or signal denoising by eliminating
smaller DWT coefﬁcients, which correspond to higher frequency components.
13.10 PROBLEMS
13.1. Given the downsampling systems in Figure 13.47(a) and (b) and input spectrum WðfÞ,
sketch the downsampled spectrum XðfÞ.
13.2. Given the upsampling systems in Figure 13.48(a) and (b) and input spectrum XðfÞ, sketch
the upsampled spectrum WðfÞ. Note that the sampling rate for input xðmÞ fsM ¼ fs=4 and
the output sampling rate wðnÞ is fs.
13.3. Given the down- and upsampling systems in Figure 13.49(a) and (b) and the input spectrum
WðfÞ, sketch the output spectrum YðfÞ and express YðfÞ in terms of WðfÞ.
4
( )
w n
( )
x m
( )
W f
f
/ 2
sf
sf
/ 4
sM
s
f
f
/ 4
sf
4
( )
w n
( )
x m
( )
W f
f
/ 2
sf
sf
/ 4
sM
s
f
f
/ 4
sf
(a)
(b)
FIGURE 13.47
Downsampling systems in Problem 13.1.
13.9 Summary
673

13.4. Given the down- and upsampling systems in Figure 13.50(a) and (b) and the input spectrum
WðfÞ, sketch the output spectrum YðfÞ and express YðfÞ in terms of WðfÞ.
13.5. Given H0ðzÞ ¼
1
2
p þ 1
2
p z 1, determine H1ðzÞ, G0ðzÞ, and G1ðzÞ.
13.6. Given H0ðzÞ ¼
1
2
p þ 1
2
p z 1, verify the following conditions:
rð2nÞ ¼
X
N
1
k ¼ 0
h0ðkÞh0ðk þ 2nÞ ¼ dðnÞ
RðzÞ þ RðzÞ ¼ 2
Also, plot the magnitude frequency responses of the analysis and synthesis ﬁlters.
4
( )
x m
( )
w n
( )
X f
f
/ 4
sM
s
f
f
sf
/(8)
sM
s
f
f
/ 2
sf
4
( )
x m
( )
w n
( )
X f
f
/ 4
sM
s
f
f
sf
/(8)
sM
s
f
f
/ 2
sf
(a)
(b)
FIGURE 13.48
Upsampling systems in Problem 13.2.
2
2
( )
w n
( )
y n
sf
/ 2
sM
s
f
f
sf
( )
W f
f
/ 2
sf
/8
sf
2
2
( )
w n
( )
y n
sf
/ 2
sM
s
f
f
sf
( )
W f
f
/ 2
sf
3
/8
sf
(a)
(b)
FIGURE 13.49
Down- and upsampling systems in Problem 13.3.
674
CHAPTER 13 Subband and Wavelet Based Coding

13.7. Given
H0ðzÞ ¼ 0:483 þ 0:837z 1 þ 0:224z 2  0:129z 3
determine H1ðzÞ, G0ðzÞ, and G1ðzÞ.
13.8. Given
H0ðzÞ ¼ 0:483 þ 0:837z 1 þ 0:224z 2  0:129z 3
verify the following conditions:
rð2nÞ ¼
X
N
1
k ¼ 0
h0ðkÞh0ðk þ 2nÞ ¼ dðnÞ
RðzÞ þ RðzÞ ¼ 2
13.9. Draw a four-band dyadic tree structure of a subband system including the analyzer and
synthesizer.
13.10. Draw an eight-band dyadic tree structure of a subband system including the analyzer and
synthesizer.
13.11. Consider the function in Figure 13.51.
Sketch
a. fð4tÞ
b. fðt  2Þ
c. fð2t  3Þ
d. fðt=2Þ
4
4
( )
w n
( )
y n
sf
/ 4
sM
s
f
f
sf
( )
W f
f
/ 2
sf
/8
sf
4
4
( )
w n
( )
y n
sf
/ 4
sM
s
f
f
sf
( )
W f
f
/ 2
sf
3
/8
sf
(a)
(b)
FIGURE 13.50
Down- and upsampling systems in Problem 13.4.
13.9 Summary
675

e. fðt=4  0:5Þ
13.12. Given a father wavelet (base scaling function) in base scale plotted in Figure 13.52(a),
determine a and b for each of the wavelets plotted in Figure 13.52(b) and (c).
13.13. Consider the signal in Figure 13.53.
Sketch
a. fð4tÞ
b. fðt  2Þ
c. fð2t  3Þ
d. fðt=2Þ
e. fðt=4  0:5Þ
13.14. Consider the signal in Figure 13.54.
Sketch
a. fð4tÞ
b. fðt  2Þ
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
2
1.5
1
0.5
0
0.5
1
1.5
2
Time (sec.)
f(t)=2*s n(2*p *t)
FIGURE 13.51
A sine function in Problem 13.11.
676
CHAPTER 13 Subband and Wavelet Based Coding

c. fð2t  3Þ
d. fðt=2Þ
e. fðt=4  1Þ
13.15. Sketch the Haar father wavelet families for three different scales, j ¼ 0; 1; 2 for a period of
2 seconds.
1.0
0
(sec.)
t
( )
f t
FIGURE 13.53
The function in Problem 13.13.
0
0.5
1
1.5
2
2.5
3
3.5
4
1
0
1
(a)
 a=1 b=0
0
0.5
1
1.5
2
2.5
3
3.5
4
1
0
1
(b)
0
0.5
1
1.5
2
2.5
3
3.5
4
1
0
1
(c)
Time (sec.)
FIGURE 13.52
Wavelets in Problem 13.12.
13.9 Summary
677

13.16. Sketch the Haar mother wavelet families for three different scales, j ¼ 0; 1; 2 for a period
of 2 seconds.
13.17. Use the Haar wavelet family to expand the signal depicted in Figure 13.55.
a. Use only scaling functions fð2t  kÞ.
b. Use scaling functions and wavelets fðtÞ and jðt  kÞ
13.18. Use the Haar wavelet family to expand the signal depicted in Figure 13.56.
a. Use only scaling functions fð4t  kÞ.
1.0
0
(sec.)
t
( )
f t
FIGURE 13.54
A trapezoidal function in Problem 13.14.
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
5
4
3
2
1
0
1
2
3
4
5
f(t)
Time (sec.)
FIGURE 13.55
A gate function in Problem 13.17.
678
CHAPTER 13 Subband and Wavelet Based Coding

0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
5
4
3
2
1
0
1
2
3
4
5
f(t)
Time (sec.)
FIGURE 13.56
A piecewise function in Problem 13.18.
b. Use scaling functions and wavelets fð2t  kÞ and jð2t  kÞ.
c. Use scaling functions and wavelets fðtÞ, jð2t  kÞ, and jðt  kÞ.
13.19. Use the Haar wavelet family to expand the signal
xðtÞ ¼ sinð2ptÞ
for
0  t  1
a. Use only scaling functions fð2t  kÞ.
b. Use scaling functions and wavelets fðtÞ and jðt  kÞ.
13.20. Use the Haar wavelet family to expand the signal
x

t

¼ e 5t
for
0  t  1
a. Use only scaling functions fð2t  kÞ.
b. Use scaling functions and wavelets fðtÞ and jðt  kÞ.
13.21. Verify the following equations using the Haar wavelet families:
a. fð2tÞ ¼ PN
k ¼
N
2
p
h0ðkÞfð4t  kÞ
b. jð2tÞ ¼ PN
k ¼
N
2
p
h1ðkÞfð4t  kÞ
13.9 Summary
679

13.22. Given the 4-tap Daubechies wavelet coefﬁcients
h0(k) ¼ [0.483 0.837 0.224 0.129]
determine h1ðkÞ and plot magnitude frequency responses for both h0ðkÞ and h1ðkÞ.
13.23. Given the sample values [8 2 4 1], use the Haar wavelet to determine the level-2 wavelet
coefﬁcients.
13.24. Given the sample values [8 2 4 3 0 1 2 0], use the Haar wavelet to determine the level-
3 wavelet coefﬁcients.
13.25. Given the level-2 wavelet coefﬁcients [4 2 1 2], use the Haar wavelet to determine the
sampled signal vector fðkÞ.
13.26. Given the level-3 wavelet coefﬁcients [4 2 1 2 0 0 0 0], use the Haar wavelet to determine
the sampled signal vector fðkÞ.
13.27. Given the level-1 wavelet coefﬁcients [4 2 1 2], use the Haar wavelet to determine the
sampled signal vector fðkÞ.
13.28. The four-level DWT coefﬁcients are given as follows:
W ¼ [100 20 16 5 3 4 2 6 4 6 1 2 3 0 2 1]
List the wavelet coefﬁcients to achieve each of the following compression ratios:
a. 2:1
b. 4:1
c. 8:1
d. 16:1
13.10.1 MATLAB Problems
Use MATLAB to solve Problems 13.29 to 13.31.
13.29. Use the 16-tap PR-CQF coefﬁcients and MATLAB to verify the following conditions:
rð2nÞ ¼
X
N
1
k ¼ 0
h0ðkÞh0ðk þ 2nÞ ¼ dðnÞ
RðzÞ þ RðzÞ ¼ 2
Plot the frequency responses for h0ðkÞ and h1ðkÞ.
13.30. Use the MATLAB functions provided in Section 13.8 [dwt(), idwt()] to verify Problems
13.23 13.27.
13.31. Consider a 20-Hz sinusoidal signal plus random noise sampled at 8,000 Hz with 1,024 samples:
xðnÞ ¼ 100 cos ð2p  20nTÞ þ 50  randn
where T ¼ 1=8;000 seconds and randn is a random noise generator with a unit power and
Gaussian distribution.
680
CHAPTER 13 Subband and Wavelet Based Coding

a. Use a 16-bit code for each wavelet coefﬁcient and write a MATLAB program to perform
data compression with the following ratios: 2:1, 4:1, 8:1, 16:1, and 32:1.
b. Measure the SNR in dB for each case.
c. Plot the reconstructed waveform for each case.
13.10.2 MATLAB Projects
13.32. Data compression using subband coding:
Given 16-bit speech data (“speech.dat”) and using the four-band subband coding method,
write a MATLAB program to compress a speech signal with the following speciﬁcations:
a. 16 bits for each of the subband coefﬁcients, code the LL, LH, HL, HH subbands, and
measure the SNR in dB.
b. 16 bits for each of the subband coefﬁcients, code the LL band, discard the LH, HL, and HH
subbands.
c. 16 bits for each of the subband coefﬁcients, code the LL and LH bands, discard the HL and
HH subbands.
d. 16 bits for each of subband coefﬁcients, code the LL, LH, and HL bands, discard the HH
subband.
e. Measure SNR in dB for (a), (b), (c), and (d).
f. Determine the achieved compression ratios for (a), (b), (c), and (d).
g. Repeat (a) to (f) for seismic data (“seismic.dat”) in which each sample is encoded using 32
bits instead of 16 bits.
13.33. Wavelet-based data compression:
Given 16-bit speech data (“speech.dat”) and using the wavelet coding method with 16-tap
Daubechies wavelet ﬁlters, write a MATLAB program to compress a speech signal with
the following speciﬁcations:
a. 16 bits for each of the wavelet coefﬁcients, compression 2:1.
b. 16 bits for each of the wavelet coefﬁcients, compression 4:1.
c. 16 bits for each of the wavelet coefﬁcients, compression 8:1.
d. 16 bits for each of the wavelet coefﬁcients, compression 16:1.
e. 16 bits for each of the wavelet coefﬁcients, compression 32:1.
f. Measure SNR in dB for (a), (b), (c), (d) and (e).
g. Repeat (a) to (f) for seismic data (“seismic.dat”) in which each sample is encoded using 32
bits instead of 16 bits.
13.9 Summary
681

This page intentionally left blank

Image Processing Basics
14
CHAPTER OUTLINE
14.1 Image Processing Notation and Data Formats............................................................................... 684
14.1.1 8-Bit Gray Level Images.........................................................................................684
14.1.2 24-bit Color Images...............................................................................................686
14.1.3 8-Bit Color Images.................................................................................................687
14.1.4 Intensity Images....................................................................................................688
14.1.5 Red, Green, and Blue Components and Grayscale Conversion....................................688
14.1.6 MATLAB Functions for Format Conversion ...............................................................690
14.2 Image Histogram and Equalization............................................................................................... 692
14.2.1 Grayscale Histogram and Equalization.....................................................................692
14.2.2 24-Bit Color Image Equalization .............................................................................695
14.2.3 8-Bit Indexed Color Image Equalization...................................................................700
14.2.4 MATLAB Functions for Equalization ........................................................................702
14.3 Image Level Adjustment and Contrast .......................................................................................... 704
14.3.1 Linear Level Adjustment.........................................................................................704
14.3.2 Adjusting the Level for Display................................................................................707
14.3.3 MATLAB Functions for Image Level Adjustment .......................................................707
14.4 Image Filtering Enhancement ...................................................................................................... 707
14.4.1 Lowpass Noise Filtering .........................................................................................709
14.4.2 Median Filtering ....................................................................................................712
14.4.3 Edge Detection......................................................................................................715
14.4.4 MATLAB Functions for Image Filtering ....................................................................718
14.5 Image Pseudo-Color Generation and Detection ............................................................................. 722
14.6 Image Spectra............................................................................................................................ 725
14.7 Image Compression by Discrete Cosine Transform ........................................................................ 728
14.7.1 Two-Dimensional Discrete Cosine Transform ............................................................729
14.7.2 Two-Dimensional JPEG Grayscale Image Compression Example.................................731
14.7.3 JPEG Color Image Compression ..............................................................................735
RGB to YIQ Transformation ........................................................................................... 735
DCT on Image Blocks.................................................................................................... 735
Quantization.................................................................................................................. 735
Differential Pulse Code Modulation on Direct-Current Coefﬁcients................................... 736
Run-Length Coding on Alternating-Current Coefﬁcients .................................................. 736
Lossless Entropy Coding................................................................................................ 737
CHAPTER
Digital Signal Processing. http://dx.doi.org/10.1016/B978-0-12-415893-1.00014-7
Copyright  2013 Elsevier Inc. All rights reserved.
683

Coding DC Coefﬁcients.................................................................................................. 737
Coding AC Coefﬁcients .................................................................................................. 737
14.7.4 Image Compression Using Wavelet Transform Coding ...............................................738
14.8 Creating a Video Sequence by Mixing Two Images ....................................................................... 745
14.9 Video Signal Basics ................................................................................................................... 746
14.9.1 Analog Video.........................................................................................................747
PAL Video..................................................................................................................... 752
SECAM Video................................................................................................................ 752
14.9.2 Digital Video .........................................................................................................753
14.10 Motion Estimation in Video ....................................................................................................... 755
14.11 Summary ................................................................................................................................. 757
OBJECTIVES:
In today’s modern computers, media information such as audio, images, and video have become necessary
for daily business operations and entertainment. In this chapter, we will study the digital image and its
processing techniques. This chapter introduces the basics of image processing, including image
enhancement using histogram equalization and ﬁltering methods, and proceeds to study pseudo-color
generation for object detection and recognition. Finally, the chapter investigates image compression
techniques and the basics of video signals.
14.1 IMAGE PROCESSING NOTATION AND DATA FORMATS
The digital image is picture information in a digital form. The image can be ﬁltered to remove noise to
enhance it. It can also be transformed to extract features for pattern recognition. The image can be
compressed for storage and retrieval, as well as transmitted via a computer network or a communi-
cation system.
The digital image consists of pixels. The position of each pixel is speciﬁed in terms of an index
for the number of columns and another for the number of rows. Figure 14.1 shows that a pixel pð2; 8Þ
has a level of 86 and is located in the second row, eighth column. We express it in notation as
pð2; 8Þ ¼ 86
(14.1)
The number of pixels in the presentation of a digital image is its spatial resolution, which relates to the
image quality. The higher the spatial resolution, the better quality the image has. The resolution can be
fairly high, for instance, as high as 1,600  1,200 (1,920,000 pixels ¼ 1.92 megapixels), or as low as
320  200 (64,000 pixels ¼ 64 kilopixels). In notation, the number to the left of the multiplication
symbol represents the width, and that to the right of the symbol represents the height. Image quality
also depends on the numbers of bits used in encoding each pixel level, which will be discussed in next
section.
14.1.1 8-Bit Gray Level Images
If a pixel is encoded on a gray scale from 0 to 255, where 0 ¼ black and 255 ¼ white, the numbers
in between represent levels of gray forming a grayscale image. For a 640  480 8-bit image, 307.2
684
CHAPTER 14 Image Processing Basics

kilobytes are required for storage. Figure 14.2 shows a grayscale image format. As shown in the ﬁgure,
the pixel indicated in the box has an 8-bit value of 25.
The image of a cruise ship with a spatial resolution of 320  240 using an 8-bit grayscale format is
shown in Figure 14.3.
0
n
m
25
Pixel value
0
FIGURE 14.2
Grayscale image format.
m
n
p m n
( , )
( , )
m n
0
1
2
3
4
5
6
7
8
9 10 11
0
1
2
3
4
5
6
7
86
FIGURE 14.1
Image pixel notation.
FIGURE 14.3
Grayscale image (8-bit 320  240).
14.1 Image Processing Notation and Data Formats
685

14.1.2 24-bit Color Images
In a 24-bit color image representation, each pixel is recoded with red, green, and blue (RGB)
components. With each component value encoded in 8 bits, resulting in 24 bits in total, we achieve
a full color RGB image. With such an image, we can have 224 ¼ 16:777216  106 different colors. A
640  480 24-bit color image requires 921.6 kilobytes for storage. Figure 14.4 shows the format for the
24-bit color image where the indicated pixel has 8-bit RGB components.
Figure 14.5 shows a 24-bit color image of the Grand Canyon, along with grayscale displays for the
8-bit RGB component images. The full color picture at the upper left is included in the color insert.
0
0
n
m
R=66
G=132
B=34
Pixel value
FIGURE 14.4
The 24-bit color image format.
 RGB
(a)
(b)  Red
(c) Green
(d) Blue
FIGURE 14.5
The 24-bit color image and its respective RGB components.
686
CHAPTER 14 Image Processing Basics

14.1.3 8-Bit Color Images
The 8-bit color image is also a popular image format. Its pixel value is a color index that points to
a color lookup table containing RGB components. We call this a color indexed image, and its format
is shown in Figure 14.6. As an example in the ﬁgure, the color indexed image has a pixel index
value of 5, which is the index for the entry of the color table, called the color map. At location 5 in
the color table, there are three color components with RGB values of 66, 132, and 34, respectively.
Each color component is encoded in 8 bits. There are only 256 different colors in the image. A
640  480 8-bit color image requires 307.2 kilobytes for data storage and 3  256 ¼ 768 bytes for
color map storage. The 8-bit color image for the cruise ship shown in Figure 14.3 is displayed in
Figure 14.7.
0
0
n
m
0
m
0
n
R
G
B
01000010
5
Index value
0
5
255
10000100
00100010
R 66
G 132
B 34
Pixel value
Index
FIGURE 14.6
The 8-bit color indexed image format.
FIGURE 14.7
The 8-bit color indexed image.
14.1 Image Processing Notation and Data Formats
687

14.1.4 Intensity Images
As we noted in the ﬁrst section, the grayscale image uses a pixel value ranging from 0 to 255 to present
luminance, or the light intensity. A pixel value of 0 designates black, and a value of 255 represents white.
In some processing environments such as MATLAB (matrix laboratory), ﬂoating-point operations
are used. The grayscale image has an intensity value that is normalized to the range from 0 to 1.0,
where 0 represents black and 1 represents white. We often change the pixel value to the normalized
range to get the grayscale intensity image before processing it, then scale it back to the standard 8-bit
range after processing for display. With the intensity image in ﬂoating point format, the digital ﬁlter
implementation can be easily applied. Figure 14.8 shows the format of the grayscale intensity image,
where the indicated pixel shows the intensity value of 0.5988.
14.1.5 Red, Green, and Blue Components and Grayscale Conversion
In some applications, we need to convert a color image to a grayscale image so that storage space can be
saved. As an example, ﬁngerprint images are stored in grayscale format in a database system. As another
example, in color image compression, the transformation converts the RGB color space to the YIQ color
space (Li and Drew, 2004; Rabbani and Jones, 1991), where Yis the luminance (Y) channel representing
light intensity while the I (in-space) and Q (quadrature) chrominance channels represent color details.
The luminance Yðm; nÞ carries grayscale information with most of the signal energy (as much as
93%), and the chrominance channels Iðm; nÞ and Qðm; nÞ carry color information with much less
energy (as little as 7%). The transformation in terms of the standard matrix notion is given by
2
64
Yðm; nÞ
Iðm; nÞ
Qðm; nÞ
3
75 ¼
2
64
0:299
0:587
0:114
0:596
0:274
0:322
0:212
0:523
0:311
3
75
2
64
Rðm; nÞ
Gðm; nÞ
Bðm; nÞ
3
75
(14.2)
As an example of data compression, after transformation, we can encode Yðm; nÞ with a higher
resolution using a larger number of bits, since it contains most of the signal energy, while we encode
chrominance channels Iðm; nÞ and Qðm; nÞ with less resolution using a smaller number of bits. Inverse
transformation can be solved as
2
64
Rðm; nÞ
Gðm; nÞ
Bðm; nÞ
3
75 ¼
2
64
1:000
0:956
0:621
1:000
0:272
0:647
1:000
1:106
1:703
3
75
2
64
Yðm; nÞ
Iðm; nÞ
Qðm; nÞ
3
75
(14.3)
0
0
n
m
0.5988
Pixel value
Floating
point
operation
FIGURE 14.8
The grayscale intensity image format.
688
CHAPTER 14 Image Processing Basics

To obtain the grayscale image, we simply convert each RGB pixel to the YIQ pixel, and then keep its
luminance channel and discard IQ channel chrominance. The conversion formula is hence given by
Yðm; nÞ ¼ 0:299$Rðm; nÞ þ 0:587$Gðm; nÞ þ 0:114$Bðm; nÞ
(14.4)
Note that Yðm; nÞ, Iðm; nÞ, and Qðm; nÞ can be matrices that represent the luminance image and two
color component images, respectively. Similarly, Rðm; nÞ, Gðm; nÞ, and Bðm; nÞ can be matrices for the
RGB component images.
EXAMPLE 14.1
Given a pixel in an RGB image
R
200; G
10; B
100
convert the pixel values to the YIQ values.
Solution:
Applying Equation (14.2), it follows that
2
64
Y
I
Q
3
75
2
64
0:299
0:587
0:114
0:596
0:274
0:322
0:212
0:523
0:311
3
75
2
64
200
10
100
3
75
Carrying out the matrix operations leads to
2
64
Y
I
Q
3
75
2
64
0:299  200
0:587  10
0:114  100
0:596  200
0:274  10
0:322  100
0:212  200
0:523  10
0:311  100
3
75
2
64
77:07
84:26
68:27
3
75
Rounding the values to integers, we have
2
64
Y
I
Q
3
75
round
2
64
77:07
84:26
68:27
3
75
2
64
77
84
68
3
75
Now let us study the following example to convert the YIQ values back to the RGB values.
EXAMPLE 14.2
Given a pixel of an image in the YIQ color format
Y
77; I
84; Q
68
convert the pixel values back to the RGB values.
Solution:
Applying Equation (14.3) yields
2
64
R
G
B
3
75
2
64
1:000
0:956
0:621
1:000
0:272
0:647
1:000
1:106
1:703
3
75
2
64
77
84
68
3
75
2
64
199:53
10:16
99:90
3
75
14.1 Image Processing Notation and Data Formats
689

After rounding, it follows that
2
64
R
G
B
3
75
round
2
64
199:53
10:16
99:9
3
75
2
64
200
10
100
3
75
EXAMPLE 14.3
Given the 2  2 RGB image
R
"
100
50
200
150
#
G
"
10
25
20
50
#
B
"
10
5
20
15
#
convert the RGB color image into a grayscale image.
Solution:
Since only Y components are kept in the grayscale image, we apply Equation (14.4) to each pixel in the 2 x 2 image
and round the results to integers as follows:
Y
0:299 
"
100
50
200
150
#
þ 0:587 
"
10
25
20
50
#
þ 0:114 
"
10
5
20
15
#
"
37
30
74
76
#
Figure 14.9 shows the grayscale image converted from the 24-bit color image in Figure 14.5 using
the RGB-to-YIQ transformation, where only the luminance information is retained.
14.1.6 MATLAB Functions for Format Conversion
The following list summarizes MATLAB functions for image format conversion:
imread ¼ read image data ﬁle with the speciﬁed format
X ¼ 8-bit grayscale image, 8-bit indexed image, or 24-bit RGB color image
FIGURE 14.9
Grayscale image converted from the 24-bit color image in Figure 14.5 using RGB-to-YIQ transformation.
690
CHAPTER 14 Image Processing Basics

map ¼ color map table for the indexed image (256 entries)
imshow(X,map) ¼ 8-bit image display
imshow(X) ¼ 24-bit RGB color image display if image X is in a 24-bit RGB color format;
grayscale image display if image X is in an 8-bit grayscale format
ind2gray ¼ 8-bit indexed color image to 8-bit grayscale image conversion
ind2rgb ¼ 8-bit indexed color image to 24-bit RGB color image conversion
rgb2ind ¼ 24-bit RGB color image to 8-bit indexed color image conversion
rgb2gray ¼ 24-bit RGB color image to 8-bit grayscale image conversion
im2double ¼ 8-bit image to intensity image conversion
mat2gray ¼ image data to intensity image conversion
im2uint8 ¼ intensity image to 8-bit grayscale image conversion
Indexed color image
1) Pixel value is an index; there are
256 indices.
2) Each index points to a color map
entry with three values: Red, Green
and Blue.
R G
B
0
1
255
1
RGB color image
1) Each pixel has three values:
Red, Green, and Blue.
2) There are red image, blue
image, and green image
components.
B
G
R
Grayscale image
1) Each pixel has a value with
a range of 0 to 255.
Grayscale intensity image
1) Pixel value is normalized to
a range from 0 to 1.0.
2) The filter could be applied in
the float format.
[X, map]=imread('file name','format')
X=imread('file name','format');
X=ind2rgb(X,map)
[X,map]=rgb2ind(X,256)
X=ind2gray(X,map)
X=rgb2gray(X)
I=im2double(X)
X=mat2gray(I)
X=im2uint8(X)
Image format and conversion
imshow(X, map)
imshow(X)
imshow(X)
FIGURE 14.10
Outlines the applications of image format conversions.
14.1 Image Processing Notation and Data Formats
691

14.2 IMAGE HISTOGRAM AND EQUALIZATION
An image histogram is a graph to show how many pixels are at each scale level, or at each index for the
indexed color image. The histogram contains information needed for image equalization, where the
image pixels are stretched to give a reasonable contrast.
14.2.1 Grayscale Histogram and Equalization
We can obtain a histogram by plotting pixel value distribution over the full grayscale range.
EXAMPLE 14.4
Produce a histogram given the following image (a matrix ﬁlled with integers) with the grayscale value ranging from
0 to 7, that is, with each pixel encoded into 3 bits:
2
6666664
0
1
2
2
6
2
1
1
2
1
1
3
4
3
3
0
2
5
1
1
3
7777775
Solution:
Since the image is encoded using 3 bits for each pixel, the pixel value ranges from 0 to 7. The count for each
grayscale is listed in Table 14.1.
Table 14.1 Pixel Count Distribution
Pixel pðm; nÞ Level
Number of Pixels
0
2
1
7
2
5
3
3
4
1
5
1
6
1
7
0
692
CHAPTER 14 Image Processing Basics

0
1
2
3
4
5
6
7
0
1
2
3
4
5
6
7
Number of pixels
Scale level
FIGURE 14.11
Histogram in Example 14.4.
Based on the grayscale distribution counts, the histogram is created as shown in Figure 14.11.
As we can see, the image has pixels whose levels are more concentrated in the dark scale in this example.
With the histogram, the equalization technique can be developed. Equalization stretches the scale
range of the pixel levels to the full range to improve the contrast of the given image. To utilize this
technique, the equalized new pixel value is redeﬁned as
peq

m; n

¼ Number of pixels with scale level  pðm; nÞ
Total number of pixels
 ðmaximum scale levelÞ
(14.5)
The new pixel value is reassigned using the value obtained by multiplying the maximum scale level by
the scaled ratio of the accumulative counts up to the current image pixel value over the total number of
pixels. Clearly, since the accumulative counts can range from 0 up to the total number of pixels, the
equalized pixel value can vary from 0 to the maximum scale level. It is due to this accumulation
procedure that the pixel values are spread over the whole range from 0 to the maximum scale level
(255). Let us look at a simpliﬁed equalization example.
EXAMPLE 14.5
Consider the following image (matrix ﬁlled with integers) with a grayscale value ranging from 0 to 7, that is, with
each pixel encoded using 3 bits:
2
66664
0
1
2
2
6
2
1
1
2
1
1
3
4
3
3
0
2
5
1
1
3
77775
14.2 Image Histogram and Equalization
693

Perform equalization using the histogram in Example 14.4, and plot the histogram for the equalized image.
Solution:
Using the histogram result in Table 14.1, we can compute an accumulative count for each grayscale level as shown
in Table 14.2. The equalized pixel level using Equation (14.5) is given in the last column.
To see how the old pixel level pðm; nÞ
4 is equalized to the new pixel level peqðm; nÞ
6, we apply
Equation (14.5):
peq

m; n

round
18
20  7

6
The equalized image using Table 14.2 is ﬁnally obtained by replacing each old pixel value in the old image with its
corresponding equalized new pixel value:
2
66664
1
3
5
5
7
5
3
3
5
3
3
6
6
6
6
1
5
7
3
3
3
77775
To see how the histogram is changed, we compute the pixel level counts according to the equalized image. The
result is given in Table 14.3, and Figure 14.12 shows the new histogram for the equalized image.
Table 14.2 Image Equalization in Example 14.5.
Pixel pðm; nÞ
Level
Number of
Pixels
Number of Pixels
£pðm; nÞ
Equalized
Pixel Level
0
2
2
1
1
7
9
3
2
5
14
5
3
3
17
6
4
1
18
6
5
1
19
7
6
1
20
7
7
0
20
7
Table 14.3 Pixel Level Distribution Counts of the Equalized Image in Example 14.5
Pixel pðm; nÞ Level
Number of Pixels
0
0
1
2
2
0
3
6
4
0
5
5
6
4
7
2
694
CHAPTER 14 Image Processing Basics

As we can see, the pixel levels in the equalized image are stretched to the larger scale levels. This technique
works for underexposed images.
Next, we apply image histogram equalization to enhance a biomedical image of a human neck in
Figure 14.13A, while Figure 14.13B shows the original image histogram. (The purpose of the arrow
in Figure 14.13A will be explained later.) We see that there are many pixel counts residing at the lower
scales in the histogram. Hence, the image looks rather dark, and may be underexposed.
Figure 14.14A and Figure 14.14B show the equalized grayscale image using the histogram method
and its histogram, respectively. As shown in the histogram, the equalized pixels reside on a larger
scale, and hence the equalized image has improved contrast.
14.2.2 24-Bit Color Image Equalization
For equalizing the RGB image, we ﬁrst transform RGB values to YIQ values since the Y channel
contains most of the signal energy, about 93%. Then Y channel is equalized just like the grayscale
equalization to enhance the luminance. We leave the I and Q channels as they are, since these contain
color information only and we do not equalize them. Next, we can repack the equalized Y channel
back to the YIQ format. Finally, the YIQ values are transformed back to the RGB values for display.
Figure 14.15 shows the procedure.
0
1
2
3
4
5
6
7
0
1
2
3
4
5
6
7
8
Scale level
Number of pixels
FIGURE 14.12
Histogram for the equalized image in Example 14.5.
14.2 Image Histogram and Equalization
695

FIGURE 14.13A
Original grayscale image.
0
50
100
150
200
250
0
500
1000
1500
2000
FIGURE 14.13B
Histogram for the original grayscale image.
696
CHAPTER 14 Image Processing Basics

FIGURE 14.14A
Grayscale equalized image.
0
50
100
150
200
250
0
500
1000
1500
2000
2500
FIGURE 14.14B
Histogram for the grayscale equalized image.
14.2 Image Histogram and Equalization
697

Figure 14.16A shows an original RGB color outdoors scene that is underexposed. Figure 14.16B
shows the equalized RGB image using the method of equalizing the Y channel only. We can verify
signiﬁcant improvement with the equalized image showing much detailed information. The color print
of the image is included in the color insert.
We can also use the histogram equalization method to equalize each of the R, G , and B channels, or
their possible combinations. Figure 14.17 illustrates such a procedure.
Some color effects can be observed. Equalization of the R channel only would make the
image look redder since the red pixel values are stretched out to the full range. Similar
RGB
YIQ
Grayscale
equalization
Yeq
Pack YIQ
Equalized
RGB
FIGURE 14.15
Color image equalization.
FIGURE 14.16A
Original RGB color image. See color image on book’s companion site.
698
CHAPTER 14 Image Processing Basics

observations can be made for equalizing the G channel, or the B channel only. The equalized
images for the R, G, and B channels, respectively, are shown in Figure 14.18. The image from
equalizing the R, G, and B channels simultaneously is shown in the upper left corner, which
offers improved image contrast.
FIGURE 14.16B
Equalized RGB color image.
RGB
Equalizing R channel
Equalized
RGB
Equalizing G channel
Equalizing B channel
FIGURE 14.17
Equalizing RGB channels.
14.2 Image Histogram and Equalization
699

14.2.3 8-Bit Indexed Color Image Equalization
Equalization of the 8-bit color indexed image is more complicated. This is due to the fact that the pixel
value is the index for color map entries, and there are three RGB color components for each entry. We
expect that after equalization, the index for each pixel will not change from its location on the color
map table. Instead, the RGB components in the color map are equalized and changed. The procedure is
described in the following is shown in Figure 14.19.
Step 1. The RGB color map is converted to the YIQ color map. Note that there are only 256 color
table entries. Since the image contains the index values, which point to locations on the color
table containing RGB components, it is natural to convert the RGB color table to the YIQ
color table.
Step 2. The grayscale image is generated using the Y channel value, so that grayscale equalization
can be performed.
Step 3. Grayscale equalization is executed.
Step 4. The equalized 256 Y values are divided by their corresponding old Y values to obtain the
relative luminance scale factors.
FIGURE 14.18
Equalization effects for RGB channels.
700
CHAPTER 14 Image Processing Basics

Step 5. Finally, the R, G, B values are each scaled in the old RGB color table with the corresponding
relative luminance scale factor and are normalized as new RGB channels in the color table in the
correct range. Then the new RGB color map is the output.
Note that original index values are not changed; only the color map content is.
Using the previous outdoors picture for the condition of underexposure, Figure 14.20 shows the
equalized indexed color image. We see that the equalized image displays much more detail. Its color
version is reprinted in the color insert.
0
0
n
m
01000010
5
Index value
0
5
255
10000100
00010010
Index
Y
I
Q
00010000
0
5
255
10110100
00010110
Index
0
0
n
m
16
Grayscale
0
0
n
m
32
Grayscale
Grayscale equalization
Yeq
00100000
Index
0
5
255
Relative
luminance
scale factor
Yeq/Y
00000010
Multiply R, G, B by the scale
factor and rescale them to 
the correct range with their
maximum scale levels from
R's, G's, B's, respectively.
R
G
B
Req
Geq
Beq
Step 1
Step 2
Step 3
Step 4
Step 5
FIGURE 14.19
Equalization of 8-bit indexed color image.
14.2 Image Histogram and Equalization
701

14.2.4 MATLAB Functions for Equalization
Figure 14.21 lists MATLAB functions for performing equalization for the different image formats. The
MATLAB functions are explained as follows:
histeq ¼ grayscale histogram equalization, or 8-bit indexed color histogram equalization
imhist ¼ histogram display
rgb2ntsc ¼ 24-bit RGB color image to 24-bit YIQ color image conversion
ntsc2rgb ¼ 24-bit YIQ color image to 24-bit RGB color image conversion
Examples using the MATLAB functions for image format conversion and equalization are given in
Program 14.1.
Program 14.1. Examples of image format conversion and equalization.
disp(’Read the RGB image’);
XX imread(’trees’,’JPEG’);
% Provided by the instructor
figure, imshow(XX); title(’24 bit color’);
disp(’The grayscale image and histogram’);
Y rgb2gray(XX);
% RGB to grayscale conversion
figure, subplot(1,2,1);imshow(Y);
title(’original’);subplot(1,2,2);imhist(Y, 256);
disp(’Equalization in grayscale domain’);
Y histeq(Y);
figure, subplot(1,2,1); imshow(Y);
title(’EQ in grayscale domain’); subplot(1,2,2); imhist(Y, 256);
disp(’Equalization of Y channel for RGB color image’);
figure
subplot(1,2,1); imshow(XX);
title(’EQ in RGB color’);
subplot(1,2,2); imhist(rgb2gray(XX),256);
Z1 rgb2ntsc(XX);
% Conversion from RGB to YIQ
FIGURE 14.20
Equalized indexed 8-bit color image.
702
CHAPTER 14 Image Processing Basics

Indexed color image
1) Pixel value is an index; there are
256 indices.
2) Each index points to a color map
entry with three values: Red, Green
and Blue.
R G
B
0
1
255
1
RGB color image
1) Each pixel has three values:
Red, Green, and Blue.
2) There are red image, green
image, and blue image
components.
B
G
R
Grayscale image
1) Each pixel has a value with
a range of 0 to 255.
Equalization
1) In grayscale domain.
Y=histeq(X)
imhist(Y,256)
2) In 8-bit color domain, find new
colormap.
newmap=histeq(X,map)
imhist(ind2gray(X,newmap),256)
3) RGB color domain.
  (a) Transfrom RGB domain to
YIQ domain; equalize Y, and
transform YIQ domain back to
RGB domain.
           Z=rgb2ntsc(X);
           Z(:,:,1)=histeq(Z(:,:,1));
           X=ntsc2rgb(Z);
  (b) Equalize R, G, B, respectively.
          X(:,:,1)=histeq(X(:,:,1));
          X(:,:,2)=histeq(X(:,:,2));
          X(:,:,3)=histeq(X(:,:,3));
[X, map]=imread('file name','format');
X=imread('file name','format');
X=ind2rgb(X,map)
[X,map]=rgb2ind(X,256)
X=ind2gray(X,map)
X=rgb2gray(X)
Image Histogram
Equalization
FIGURE 14.21
MATLAB functions for image equalization.
14.2 Image Histogram and Equalization
703

Z1(:,:,1) histeq(Z1(:,:,1));
% Equalizing Y channel
ZZ ntsc2rgb(Z1);
% Conversion from YIQ to RGB
figure
subplot(1,2,1); imshow(ZZ);
title(’EQ for Y channel for RGB color image’);
subplot(1,2,2); imhist(im2uint8(rgb2gray(ZZ)),256);
ZZZ XX;
ZZZ(:,:,1) histeq(ZZZ(:,:,1));
%Equalizing R channel
ZZZ(:,:,2) histeq(ZZZ(:,:,2));
%Equalizing G channel
ZZZ(:,:,3) histeq(ZZZ(:,:,3));
%Equalizing B channel
figure
subplot(1,2,1); imshow(ZZZ);
title(’EQ for RGB channels’);
subplot(1,2,2); imhist(im2uint8(rgb2gray(ZZZ)),256);
disp(’Equalization in 8 bit indexed color’);
[Xind, map] rgb2ind(XX, 256);
% RGB to 8 bit index image conversion
newmap histeq(Xind,map);
figure
subplot(1,2,1); imshow(Xind,newmap);
title(’EQ in 8 bit indexed color’);
subplot(1,2,2); imhist(ind2gray(Xind,newmap),256);
14.3 IMAGE LEVEL ADJUSTMENT AND CONTRAST
Image level adjustment can be used to linearly stretch the pixel level in an image to increase contrast
and shift the pixel level to change viewing effects. Image level adjustment is also a requirement for
modifying results from image ﬁltering or other operations to an appropriate range for display. We will
study this technique in the following subsections.
14.3.1 Linear Level Adjustment
Sometimes, if the pixel range in an image is small, we can adjust the image pixel level to make use of
a full pixel range. Hence, contrast of the image is enhanced. Figure 14.22 illustrates linear level
adjustment.
The linear level adjustment is given by the following formula:
padjust

m; n

¼ Bottom þ pðm; nÞ  L
H  L
 ðTop-BottomÞ
(14.6)
where pðm; nÞ ¼ original image pixel
padjustðm; nÞ ¼ desired image pixel
H ¼ maximum pixel level in the original image
L ¼ minimum pixel level in the original image
Top ¼ maximum pixel level in the desired image
Bottom ¼ minimum pixel level in the desired image
704
CHAPTER 14 Image Processing Basics

Besides adjusting the image level to a full range, we can also apply the method to shift the image pixel
levels up or down.
EXAMPLE 14.6
Consider the following image (matrix ﬁlled with integers) with a grayscale value ranging from 0 to 7, that is, with
each pixel encoded in 3 bits:
2
66664
3
4
4
5
5
3
3
3
4
4
4
5
3
5
3
4
3
77775
a. Perform level adjustment to the full range.
b. Shift the level to the range from 3 to 7.
c. Shift the level to the range from 0 to 3.
Solution:
a. From the given image, we set the following for level adjustment to the full range:
H
5; L
3; Top
23
1
7; Bottom
0
Applying Equation (14.6) yields the second column in Table 14.4.
b. For the shift up operation, it follows that
H
5; L
3; Top
7; Bottom
3
L
H
Bottom
Top
p m n
( , )
p
m n
adjust ( , )
FIGURE 14.22
Linear level adjustment.
Table 14.4 Image Adjustment Results in Example 14.6.
Pixel pðm; nÞ Level
Full Range
Range [3e7]
Range [0e3]
3
0
3
0
4
4
5
2
5
7
7
3
14.3 Image Level Adjustment and Contrast
705

c. For the shift down operation, we set
H
5; L
3; Top
3; Bottom
0
The results for (b) and (c) are listed in the third and fourth column, respectively, of Table 14.4.
According to Table 14.4, we have three images:
2
66664
0
4
4
7
7
0
0
0
4
4
4
7
0
7
0
4
3
77775
2
66664
3
5
5
7
7
3
3
3
5
5
5
7
3
7
3
5
3
77775
2
66664
0
2
2
3
3
0
0
0
2
2
2
3
0
3
0
2
3
77775
Next, applying the level adjustment for the neck image of Figure 14.13A, we get the results
shown in Figure 14.23: the original image, the full range stretched image, the level shift-up
image, and the level shift-down image. As we can see, the stretching operation increases image
contrast while the shift-up operation lightens the image and the shift-down operation darkens the
image.
FIGURE 14.23
Image level adjustment.
706
CHAPTER 14 Image Processing Basics

14.3.2 Adjusting the Level for Display
When two 8-bit images are added together or undergo other mathematical operations, the sum of two
pixel values could be as low as 0 and as high as 510. We can apply the linear adjustment to scale the
range back to 0 to 255 for display. The following addition of two 8-bit images yields a sum that is out
of the 8-bit range:
2
66664
30
25
5
170
70
210
250
30
225
125
50
70
28
100
30
50
3
77775
þ
2
66664
30
255
50
70
70
3
30
30
50
200
50
70
30
70
30
50
3
77775
¼
2
66664
60
280
55
240
140
213
280
60
275
325
100
140
58
179
60
100
3
77775
To scale the combined image, modify Equation (14.6) as follows:
pscaled

m; n

¼
pðm; nÞ  Minimum
Maximum  Minimum  ðMaximum scale levelÞ
(14.7)
Note that in the image to be scaled,
Maximum ¼ 325
Minimum ¼ 55
Maximum scale level ¼ 255
After scaling we have
2
66664
5
213
0
175
80
149
213
5
208
255
43
80
3
109
5
43
3
77775
14.3.3 MATLAB Functions for Image Level Adjustment
Figure 14.24 lists applications of the MATLAB level adjustment function, which is deﬁned as
follows:
J
imajust(I, [bottom level, top level],[adjusted bottom, adjusted top], gamma)
I ¼ input intensity image
J ¼ output intensity image
gamma ¼ 1 (linear interpolation function as we discussed in Section 14.3.1)
0 < gamma < 1 lightens image; gamma > 1 darkens image
14.4 IMAGE FILTERING ENHANCEMENT
As with one-dimensional digital signal processing, we can design a digital image ﬁlter such as low-
pass, highpass, bandpass, and notch to process the image to obtain the desired effect. In this section, we
14.4 Image Filtering Enhancement
707

Indexed color image
1) Pixel value is an index; there are
256 indices.
2) Each index points to a color map
entry with three values: Red, Green
and Blue.
R G
B
0
1
255
1
RGB color image
1) Each pixel has three
values: Red, Green, and Blue.
2) There are red image, blue
image, and green image
components.
B
G
R
Grayscale image
1) Each pixel has a value with
a range of 0 to 255.
Level adjustment
1) Stretch the pixel range.
2) Shift and contract the pixel range.
3) Darken or lighten the pixel.
[X, map]=imread('file name','format');
X=imread('file name','format');
X=ind2rgb(X,map)
[X,map]=rgb2ind(X,256)
X=ind2gray(X,map)
X=rgb2gray(X)
I=im2double(X)
X=im2uint8(X)
to display
%J=imadjust(I,[low,high],[bot,top],gamma);
% gamma=1.5 darker, gamm=0.5 lighter
J1=imadjust(I,[0,.5],[0,1],1);
J2=imadjust(I,[0,1],[.5,1],1);
J3=imadjust(I,[0,1],[0,0.5],1);
 Image Level Adjustment
FIGURE 14.24
MATLAB functions for image level adjustment.
708
CHAPTER 14 Image Processing Basics

discuss the most common ones: lowpass ﬁlters to remove noise, median ﬁlters to remove impulse
noise, and edge detection ﬁlters to discover the boundaries of objects in images. More advanced
treatment of this subject can be explored in the well-known text by Gonzalez and Wintz (1987).
14.4.1 Lowpass Noise Filtering
One of the simplest lowpass ﬁlters is the average ﬁlter. The noisy image is ﬁltered using the average
convolution kernel with a size 3  3 block, 4  4 block, 8  8 block, and so on, in which the elements
in the block have the same ﬁlter coefﬁcients. The 3  3, 4  4, and 8  8 average kernels are as
follows:
3  3 average kernel:
1
9
2
664
1
1
1
1
1
1
1
1
1
3
775
(14.8)
4  4 average kernel:
1
16
2
666664
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
3
777775
(14.9)
8  8 average kernel:
1
64
2
666666666666666664
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
3
777777777777777775
(14.10)
Each of the elements in the average kernel is 1 and the scale factor is the reciprocal of the total number
of elements in the kernel. The convolution operates to modify each pixel in the image as follows. By
passing the center of a convolution kernel through each pixel in the noisy image, we can sum each
product of the kernel element and the corresponding image pixel value and multiply the sum by the
scale factor to get the processed pixel. To understand the ﬁlter operation with the convolution kernel,
let us study the following example.
14.4 Image Filtering Enhancement
709

EXAMPLE 14.7
Perform digital ﬁltering on the noisy image using a 2  2 convolutional average kernel, and compare the enhanced
image with the original one given the following 8 bit grayscale original and corrupted (noisy) images:
4  4 original image:
2
66664
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
3
77775
4  4 corrupted image:
2
66664
99
107
113
96
92
116
84
107
103
93
86
108
87
109
106
107
3
77775
2  2 average kernel: 1
4
"
1
1
1
1
#
Solution:
In the following diagram, we pad edges with zeros in the last row and column before processing at the point where
the ﬁrst kernel and the last kernel are shown in the dotted line boxes, respectively:
99
107
113
96
92
107
84
116
103
93
86
108
107
87
109
106
0
0
0
0
0
0
0
0
0
To process the ﬁrst element, we know that the ﬁrst kernel covers the image elements as

99
107
92
116

. Summing
each product of the kernel element and the corresponding image pixel value, multiplying by a scale factor of ¼,
and rounding the result, it follows that
1
4 ð99  1 þ 107  1 þ 92  1 þ 116  1Þ
103:5
roundð103:5Þ
104
In the processing of the second element, the kernel covers

107
113
116
84

. Similarly, we have
1
4 ð107  1 þ 113  1 þ 116  1 þ 84  1Þ
105
roundð105Þ
105
The process continues for the rest of image pixels. To process the last element of the ﬁrst row, 96, since the kernel
covers only

96
0
107
0

, we assume that the last two elements are zeros. Then
1
4 ð96  1 þ 107  1 þ 0  1 þ 0  1Þ
50:75
roundð50:75Þ
51
710
CHAPTER 14 Image Processing Basics

Finally, we yield the following ﬁltered image:
2
66664
104
105
100
51
101
95
96
54
98
98
102
54
49
54
53
27
3
77775
As we know, due to zero padding for boundaries, the last row and last column values are in error. However, for
a large image, these errors at the boundaries can be neglected without affecting image quality. The ﬁrst 3  3
elements in the processed image have values that are close to those of the original image. Hence, the image is
enhanced.
Figure 14.25 shows the noisy image and enhanced images using the 3  3, 4  4, 8  8 average
lowpass ﬁlter kernels, respectively. The average kernel removes noise. However, it also blurs the
image. When using a large-sized kernel, the quality of the processed image becomes unacceptable.
The sophisticated large-size kernels are used for noise ﬁltering. Although it is beyond the scope of
the text, the Gaussian ﬁlter kernel with a standard deviation s ¼ 0:9, for instance, is given by the
following:
FIGURE 14.25
Noise ﬁltering using the lowpass average kernels.
14.4 Image Filtering Enhancement
711

1
25
2
6666664
0
2
4
2
0
2
15
27
15
2
4
27
50
27
4
2
15
27
15
2
0
2
4
2
0
3
7777775
(14.11)
In this kernel the center pixel is weighted the most and the weights become lower and lower as we
move away from the center. In this way, the blurring effect can be reduced when ﬁltering the noise. The
plot of kernel values in the special domain looks like the bell shape. The steepness of shape is
controlled by the standard deviation of the Gaussian distribution function. The larger the standard
deviation, the ﬂatter the kernel; with a ﬂatter kernel, the blurring effect will be more pronounced.
Figure 14.26A shows the noisy image, while Figure 14.26B shows the enhanced image using a 5  5
Gaussian ﬁlter kernel. Clearly, the majority of the noise has been ﬁltered, while the blurring effect is
signiﬁcantly reduced.
14.4.2 Median Filtering
The median ﬁlter is one type of nonlinear ﬁlter. It is very effective at removing impulse noise, the
“pepper and salt” noise, in an image. The principle of the median ﬁlter is to replace the gray level of
each pixel by the median of the gray levels in a neighborhood of the pixels, instead of using the average
operation. For median ﬁltering, we specify the kernel size, list the pixel values covered by the kernel,
and determine the median level. If the kernel covers an even number of pixels, the average of two
median values is used. Before beginning median ﬁltering, zeros must be padded around the row edge
FIGURE 14.26A
Noisy image for a human neck.
712
CHAPTER 14 Image Processing Basics

and the column edge. Hence, edge distortion is introduced at image boundary. Let us look at
Example 14.8.
EXAMPLE 14.8
Consider a 3  3 median ﬁlter kernel and the following 8 bit grayscale original and corrupted (noisy) images:
4  4 original image:
2
66664
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
3
77775
4  4 corrupted image by impulse noise:
2
66664
100
255
100
100
100
255
100
100
255
100
100
0
100
100
100
100
3
77775
3  3 median filter kernel:
2
64
3
75
33
Perform digital ﬁltering, and compare the ﬁltered image with the original one.
FIGURE 14.26B
Enhanced image using a Gaussian lowpass ﬁlter.
14.4 Image Filtering Enhancement
713

Solution:
Step 1: The 3  3 kernel requires zero padding 3/2
1 column of zeros at the left and right edges and 3/2
1 row
of zeros at the upper and bottom edges:
100
255
100
100
100
100
100
255
255
100
100
0
100
100
100
100
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
Step 2: To process the ﬁrst element, we cover the 3  3 kernel with the center pointing to the ﬁrst element to be
processed. The sorted data within the kernel are listed in terms of thier value as
0; 0; 0; 0; 0; 100; 100; 255; 255
The median value
median(0, 0, 0, 0, 0, 100, 100, 255, 255)
0. Zero will replace 100.
Step 3: Continue for each element until the last is replaced. Let us review the element at location (1,1):
100
255
100
100
100
100
100
255
255
100
100
0
100
100
100
100
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
The values covered by the kernel are
100; 100; 100; 100; 100; 100; 255; 255; 255
The median value
median(100, 100, 100, 100, 100, 100, 255, 255, 255)
100. The ﬁnal processed
image is
2
66664
0
100
100
0
100
100
100
100
0
100
100
0
100
100
100
100
3
77775
Some boundary pixels are distorted due to the zero padding effect. However, for a large image, the portion of the
boundary pixels (outmost image edges) is signiﬁcant small so that their distortion can be omitted versus the overall
quality of the image. The 2  2 middle portion matches the original image exactly. The effectiveness of the median
ﬁlter is veriﬁed via this example.
The image in Figure 14.27A is corrupted by “pepper and salt” noise. The median ﬁlter with a 3  3
kernel is used to ﬁlter the impulse noise. The enhanced image shown in Figure 14.27B has a signiﬁcant
quality improvement. Note that a larger size kernel is not appropriate for median ﬁltering, because for
a larger set of pixels the median value deviates from the pixel value.
714
CHAPTER 14 Image Processing Basics

14.4.3 Edge Detection
In many applications, such as pattern recognition and ﬁngerprint and iris biometric identiﬁcation,
image edge information is required. To obtain the edge information, a differential convolution kernel is
FIGURE 14.27A
Noisy image (corrupted by “pepper and salt” noise).
FIGURE 14.27B
The enhanced image using a 3  3 median ﬁlter.
14.4 Image Filtering Enhancement
715

used. Of these kernels, Sobel convolution kernels are used for horizontal and vertical edge detection.
They are listed in the following:
Horizontal Sobel edge detector:
2
64
1
2
1
0
0
0
1
2
1
3
75
(14.12)
The kernel subtracts the ﬁrst row in the kernel from the third row to detect the horizontal difference.
Vertical Sobel edge detector:
2
64
1
0
1
2
0
2
1
0
1
3
75
(14.13)
The kernel subtracts the ﬁrst column in the kernel from the third column to detect the vertical
difference.
A Laplacian edge detector is devised to tackle both vertical and horizontal edges. It is described in
the following:
Laplacian edge detector:
2
64
0
1
0
1
4
1
0
1
0
3
75
(14.14)
EXAMPLE 14.9
Given the following 8 bit grayscale image, use the Sobel horizontal edge detector to detect horizontal edges:
5  4 original image:
2
6666664
100
100
100
100
110
110
110
110
100
100
100
100
100
100
100
100
100
100
100
100
3
7777775
Solution:
We pad the image with zeros before processing as follows:
100
100
100
100
110
110
110
110
100
100
100
100
100
100
100
100
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
100
100
100
100
716
CHAPTER 14 Image Processing Basics

After processing using the Sobel horizontal edge detector, we have
2
666666664
330
440
440
330
0
0
0
0
30
40
40
30
0
0
0
0
300
400
400
300
3
777777775
Adjusting the scale level leads to
2
666666664
222
255
255
222
121
121
121
121
112
109
109
112
121
121
121
121
30
0
0
30
3
777777775
Disregarding the ﬁrst row and column and the last row and column, since they are at image boundaries, we identify
a horizontal line of 109 in the third row.
Figure 14.28 shows the results from edge detection.
Figure 14.29 shows the edge detection for the grayscale image of the cruise ship in Figure 14.3.
Sobel edge detection can tackle only the horizontal edge or the vertical edge, as shown in Figure 14.29,
where the edges of the image have both horizontal and vertical features. We can simply combine the
two horizontal and vertical edge-detected images and then rescale the resultant image in the full range.
Figure 14.29(c) shows that the edge detection result is equivalent to that of the Laplacian edge detector.
Next, we apply a more sophisticated Laplacian of Gaussian ﬁlter for edge detection, which is
a combined Gaussian lowpass ﬁlter and Laplacian derivative operator (highpass ﬁlter). The ﬁlter
smoothes the image to suppress noise using the lowpass Gaussian ﬁlter, then uses the Laplacian
derivative operation for edge detection, since the noisy image is very sensitive to the Laplacian
derivative operation. As we discussed for the Gaussian lowpass ﬁlter, the standard deviation in the
Gaussian distribution function controls the degree of noise ﬁltering before the Laplacian derivative
operation. A larger value of the standard deviation may blur the image; hence, some edge boundaries
could be lost. Its selection should be based on the particular noisy image. The ﬁlter kernel with
a standard deviation of s ¼ 0:8 is given by
2
66666664
4
13
16
13
4
13
9
25
9
13
16
25
124
25
16
13
9
25
9
13
4
13
16
13
4
3
77777775
(14.15)
The processed edge detection using the Laplacian of Gaussian ﬁlter in Equation (14.15) is shown in
Figure 14.30. We can further use a threshold value to convert the processed image to a black and white
image, where the contours of objects can be clearly displayed.
14.4 Image Filtering Enhancement
717

14.4.4 MATLAB Functions for Image Filtering
MATLAB image ﬁlter design and implementation functions are summarized in Figure 14.31. The
MATLAB functions are explained in the following:
X ¼ image to be processed
fspecial(‘ﬁlter type’, kernel size, parameter) ¼ convolution kernel generation
H
FSPECIAL(‘gaussian’,HSIZE,SIGMA) ¼ returns
a
rotationally
symmetric
Gaussian
lowpass ﬁlter of size HSIZE with standard deviation SIGMA (positive)
H
FSPECIAL(‘log’,HSIZE,SIGMA) ¼ returns
a
rotationally
symmetric
Laplacian
of
Gaussian ﬁlter of size HSIZE with standard deviation SIGMA (positive)
FIGURE 14.28
Image edge detection. (Upper left) original image; (upper right) result from Sobel horizontal edge detector; (lower
left) result from Sobel vertical edge detector; (lower right) result from Laplacian edge detector.
718
CHAPTER 14 Image Processing Basics

Y
ﬁlter2([convolution kernel], X) ¼ two-dimensional ﬁlter using the convolution kernel
Y
medﬁlt2(X, [row size, column size]) ¼ two-dimensional median ﬁlter
Program 14.2 lists the sample MATLAB codes for ﬁltering applications. Figure 14.31 outlines the
applications of the MATLAB functions.
FIGURE 14.29
Edge detection (H, horizontal; V, vertical; H&V, horizontal and vertical).
FIGURE 14.30
Image edge detection using a Laplacian of Gaussian ﬁlter.
14.4 Image Filtering Enhancement
719

Indexed color image
1) Pixel value is an index; there are
256 indices.
2) Each index points to a color map
entry with three values: Red, Green
and Blue.
R G
B
0
1
255
1
RGB color image
1) Each pixel has three
values: Red, Green, and Blue.
2) There are red, green, and
blue image components.
B
G
R
Grayscale image
1) Each pixel has a value with
a range of 0 to 255.
Filter operations:
1) Gaussian lowpass filters:
remove noise, but the image
is blurred.
2) Median filters:
effectively remove "salt and
pepper" type noise.
3) Laplacian of Gaussian
filters (log filters):
find the segments or
boundaries of image.
[X, map]=imread('file name','format');
X=imread('file name','format');
X=ind2rgb(X,map)
[X,map]=rgb2ind(X,256)
X=ind2gray(X,map)
X=rgb2gray(X)
I=im2double(X)
X=mat2gray(I)
X=im2uint8(X)
h=fspecial('log',5,0.9);
image1_out=filter2(h,image1);
h=fspecial('gaussian',5,0.8);
image1_out=filter2(h,image1_g);
image1_m=medfilt2(image1_s,[3 3]);
Image filtering
FIGURE 14.31
MATLAB functions for ﬁlter design and implementation.
720
CHAPTER 14 Image Processing Basics

Program 14.2. Examples of Gaussian ﬁltering, media ﬁltering, and Laplacian of Gaussian ﬁltering.
close all;clear all; clc;
X imread(’cruise’,’jpeg’);
% Provided by the instructor
Y rgb2gray(X);
% Convert the RGB image to the grayscale image
I im2double(Y);
% Get the intensity image
image1 g imnoise(I,’gaussian’);
% Add random noise to the intensity image
ng mat2gray(image1 g);
% Adjust the range
ng im2uint8(ng);
% 8 bit corrupted image
% Linear filtering
K size
5;
% Kernel size
55
sigma
0.8;
% sigma (the bigger, the smoother the image)
h fspecial(’gaussian’,K size,sigma);
% Determine Gaussian filter coefficients
% This command will construct a Gaussian filter
% of size 55 with a main lobe width of 0.8.
image1 out filter2(h,image1 g);
% Perform filtering
image1 out mat2gray(image1 out);
% Adjust the range
image1 out im2uint8(image1 out);
% Get the 8 bit image
subplot(1,2,1); imshow(ng),title(’Noisy image’);
subplot(1,2,2); imshow(image1 out);
title(’55 Gaussian kernel’);
% Median filtering
image1 s imnoise(I,’salt & pepper’);
% Add “salt and pepper” noise to the image
mn mat2gray(image1 s);
% Adjust the range
mn im2uint8(mn);
% Get the 8 bit image
K size 3;
% Kernel size
image1 m medfilt2(image1 s,[K size, K size]); % Perform median filtering
image1 m mat2gray(image1 m);
% Adjust the range
image1 m im2uint8(image1 m);
% Get the 8 bit image
figure, subplot(1,2,1);imshow(mn)
title(’Median noisy’);
subplot(1,2,2);imshow(image1 m);
title(’33 median kernel’);
% Laplacian of Gaussian filtering
K size
5;
% Kernel size
sigma
0.9;
% Sigma parameter
h fspecial(’log’,K size,alpha);
% Determine the Laplacian of Gaussian %filter
kernel
image1 out filter2(h,I);
% Perform filtering
image1 out mat2gray(image1 out);
% Adjust the range
image1 out im2uint8(image1 out);
% Get the 8 bit image
figure,subplot(1,2,1); imshow(Y)
title(’Original’);
subplot(1,2,2); imshow(image1 out);
title(’Laplacian ﬁlter 55 kernel’);
14.4 Image Filtering Enhancement
721

14.5 IMAGE PSEUDO-COLOR GENERATION AND DETECTION
We can apply certain transformations to the grayscale image so that it becomes a color image, and
a wider range of pseudo-color enhancement can be obtained. In object detection, pseudo-color
generation can produce the speciﬁc color for the object that is to be detected, say, red. This would
signiﬁcantly increase the accuracy of the identiﬁcation. To do so, we choose three transformations of
the grayscale level to the RGB components, as shown in Figure 14.32.
As a simple choice, we choose three sine functions for RGB transformations, as shown in
Figure 14.33A. The phase and period of one sine function can be easily changed so that the
grayscale pixel level of the object to be detected is aligned to the desired color with its component
value as large as possible, while the other two functions transform the same grayscale level such
that their color component values are as small as possible. Hence, the single speciﬁed color object
can be displayed in the image for identiﬁcation. By carefully choosing the phase and period of each
sine function, certain object(s) can be transformed to the red, green, or blue with a favorable
choice.
EXAMPLE 14.10
In the grayscale image in Figure 14.13A, the area pointed to by the arrow has a grayscale value approximately
equal to 60. The background has a pixel value approximately equal to 10. Make the background to as close to blue
as possible, and make the area pointed to by the arrow as close to red as possible.
Solution:
The transformation functions are chosen as shown in Figure 14.33A, where the red value is largest at 60 and the
blue and green values approach zero. At the grayscale of 10, the blue value is dominant. Figure 14.33B shows the
processed pseudo color image; it is included in the color insert.
8 bit grayscale
pixel p(m,n)
8 bit red pixel
8 bit green pixel
8 bit green pixel
Red
transformation
Green
transformation
Blue
transformation
FIGURE 14.32
Block diagram for transforming a grayscale pixel to a pseudo-color pixel.
722
CHAPTER 14 Image Processing Basics

0
50
100
150
200
250
300
0
0.5
1
R va ue
0
50
100
150
200
250
300
0
0.5
1
G va ue
0
50
100
150
200
250
300
0
0.5
1
B va ue
60
10
FIGURE 14.33A
Three sine functions for grayscale transformation.
FIGURE 14.33B
The pseudo-color image.
14.5 Image Pseudo Color Generation and Detection
723

Indexed color image
1) Pixel value is an index; there are
256 indices.
2) Each index points to a color map
entry with three values: Red, Green
and Blue.
R G
B
0
1
255
1
RGB color image
1) Each pixel has three values:
Red, Green, and Blue.
2) There are red image, blue
image, and green image
components.
B
G
R
Grayscale image
1) Each pixel has a value with
a range of 0 to 255.
Pseudo color generation
1) Gray to Red transformation
using a sine function.
2) Gray to Green transformation
using a sine function.
3) Gray to Blue transformation
using a sine function.
Note the phases are different
[X, map]=imread('file name','format');
X=imread('file name','format');
X=ind2rgb(X,map)
[X,map]=rgb2ind(X,256)
X=ind2gray(X,map)
X=rgb2gray(X)
 Image pseudo-color
generation for detection
R
G
B
0
0
5
5
2
0
255
255
100
110
Pixel value
between 100 and
110 will look like
green
FIGURE 14.34
Illustrative procedure for pseudo-color generation.
724
CHAPTER 14 Image Processing Basics

Program 14.3 lists the sample MATLAB codes for pseudo-color generation for a grayscale image.
Program 14.3. Program examples for pseudo-color generation.
close all; clear all;clc
disp(’Convert the grayscale image to the pseudo color image’);
[X, map] imread(’clipim2’,’gif’); % Read 8 bit index image, provided by the
% instructor
Y ind2gray(X,map);
% 8 bit color image to the grayscale conversion
% Apply pseudo color functions using sinusoids
C r
304;
% Cycle change for the red channel
P r 0;
% Phase change for the red channel
C b 804;
% Cycle change for the blue channel
P b 60;
% Phase change for the blue channel
C g 304;
% Cycle change for the green channel
P g 60;
% Phase change for the green channel
r abs(sin(2*pi*[ P r:255 P r]/C r));
g abs(sin(2*pi*[ P b:255 P b]/C b));
b abs(sin(2*pi*[ P g:255 P g]/C g));
figure, subplot(3,1,1);plot(r,’r’);grid;ylabel(’R value’)
subplot(3,1,2);plot(g,’g’);grid;ylabel(’G value’);
subplot(3,1,3);plot(b,’b’);grid;ylabel(’B value’);
figure, imshow(Y);
map [r;g;b;]’;
% Construct the color map
figure, imshow(Y,map);
% Display the pseudo color image
14.6 IMAGE SPECTRA
In one-dimensional signal processing such as for speech and audio, we need to examine the frequency
contents, check ﬁltering effects, and perform feature extraction. Image processing is similar. However,
we need apply a two-dimensional discrete Fourier transform (2D-DFT) instead of a one-dimensional
(1D) DFT. The spectrum including the magnitude and phase is also in two dimensions. The equations
of the 2D-DFT are given by
X

u; v

¼
X
M
1
m ¼ 0
X
N
1
n ¼ 0
p

m; n

Wum
M Wvn
N
(14.16)
where WM ¼ e j2p
M and WN ¼ e j2p
N
m and n ¼ pixel locations
u and v ¼ frequency indices
Taking the absolute value of the 2D-DFT coefﬁcients Xðu; vÞ and dividing the absolute value by
ðM  NÞ, we get the magnitude spectrum as
A

u; v

¼
1
ðN  MÞ jXðu; vÞj
(14.17)
Instead of going through the details of the 2D-DFT, we focus on application results via
examples.
14.6 Image Spectra
725

EXAMPLE 14.11
Determine the 2D DFT coefﬁcients and magnitude spectrum for the following 2  2 image:
"
100
50
100
10
#
Solution:
Since M
N
2, applying Equation (14.16) leads to
X

u; v
	
p

0; 0
	
ej2pu0
2
 ej2pv0
2
þ p

0; 1
	
ej2pu0
2
 ej2pv1
2
þp

1; 0
	
ej2pu1
2
 ej2pv0
2
þ p

1; 1
	
ej2pu1
2
 ej2pv1
2
For u
0 and v
0, we have
X

0; 0

100ej0  ej0 þ 50ej0  ej0 þ 100ej0  ej0
10ej0  ej0
100 þ 50 þ 100
10
240
For u
0 and v
1, we have
X

0; 1

100ej0  ej0 þ 50ej0  ejp þ 100ej0  ej0
10ej0  ejp
100 þ 50  ð
1Þ þ 100
10  ð
1Þ
160
Following similar operations,
Xð1; 0Þ
60; and Xð1; 1Þ
60
Thus, we have the following DFT coefﬁcients:
X

u; v

"
240
160
60
60
#
Using Equation (14.17), we can calculate the magnitude spectrum as
A

u; v

"
60
40
15
15
#
We can use the MABLAB function fft2() to verify the calculated DFT coefﬁcients:
>> X fft2([100 50;100 10])
X
240 160
60
60
EXAMPLE 14.12
Given the 200  200 grayscale image shown in Figure 14.35A with a white rectangle (11  3 pixels) at its center
and a black background, we can compute its magnitude spectrum (which ranges from 0 to 255). We can display
the spectrum in terms of the grayscale. Figure 14.35B shows the spectrum image.
The displayed spectrum has four quarters. The left upper quarter corresponds to the frequency components,
and the other three quarters are the image counterparts. In the spectrum image, the upper left corner area in the
left upper quarter is white and hence has a highest scale value. Therefore, the image signal has low frequency
726
CHAPTER 14 Image Processing Basics

dominant components. The spectrum exhibits horizontal and vertical null lines (dark lines). The ﬁrst vertical null
line location can be estimated as 200/11 18 pixels from the left side, while the ﬁrst horizontal null line happens
at 200/3
67 pixels from the top. Next, let us apply the 2D spectrum to understand image ﬁltering effects in
image enhancement.
EXAMPLE 14.13
Figure 14.36(a) is a biomedical image corrupted by random noise. Before we apply lowpass ﬁltering, its 2D DFT
coefﬁcients are calculated. We then compute its magnitude spectrum and scale it to the range from 0 to 255. To
FIGURE 14.35A
A square image.
FIGURE 14.35B
Magnitude spectrum for the square image.
14.6 Image Spectra
727

see noise spectral components, the spectral magnitude is further multiplied by a factor of 100. Once the spectral
value is larger than 255, it is clipped to 255. The resultant spectrum is displayed in Figure 14.36(b), where we can
see that noise occupies the entirety of the image.
To enhance the image, we apply a Gaussian lowpass ﬁlter. The enhanced image is shown in Figure 14.36(c), in
which the enhancement is easily observed. Figure 14.36(d) displays the spectra for the enhanced image with the
same scaling process described just above. As we can see, the noise is signiﬁcantly reduced compared with
Figure 14.36(b).
14.7 IMAGE COMPRESSION BY DISCRETE COSINE TRANSFORM
Image compression is a must in our modern media systems, such as digital still and video cameras and
computer systems. The purpose of compression is to reduce information storage or transmission
bandwidth without losing image quality or at least without losing it signiﬁcantly. Image compression
can be classiﬁed as lossless compression or lossy compression. Here we focus on lossy compression
using the discrete cosine transform (DCT).
The DCT is a core compression technology used in the industry standards JPEG (Joint Photo-
graphic Experts Group) for still-image compression and MPEG (Motion Picture Experts Group) for
(a)
(b)
(c)
(d)
Frequency
content
Frequency
content
FIGURE 14.36
Magnitude spectrum plots for the noisy image and the noise-ﬁltered image: (a) the noisy image; (b) magnitude
spectrum of the noisy image; (c) noise-ﬁltered image; (d) magnitude spectrum of the noise-ﬁltered image.
728
CHAPTER 14 Image Processing Basics

video compression, achieving a compression ratio of 20:1 without noticeable quality degradation.
JPEG standard image compression is used everyday in real life.
The principle of the DCT is to transform the original image pixels to an identical number of DCT
coefﬁcients, where the DCT coefﬁcients have a nonuniform distribution of direct-current (DC) terms
representing the average values, and alternate-current (AC) terms representing ﬂuctuations. The
compression is achieved by applying the advantages of encoding DC terms (with a large dynamic
range) with a large number of bits and low-frequency AC terms (a few, with a reduced dynamic range)
with a reduced number of bits, and neglecting some high-frequency AC terms that have small dynamic
ranges (most of them do not affect the visual quality of the picture).
14.7.1 Two-Dimensional Discrete Cosine Transform
Image compression uses 2D-DCT, whose transform pairs are deﬁned as follows:
Forward DCT:
F

u; v

¼ 2CðuÞCðvÞ
MN
p
X
M
1
i ¼ 0
X
N
1
j ¼ 0
pði; j

cos
ð2i þ 1Þup
2M

cos
ð2j þ 1Þvp
2N

(14.18)
Inverse DCT:
p

i; j

¼
X
M
1
u ¼ 0
X
N
1
v ¼ 0
2CðuÞCðvÞ
MN
p
F

u; v

cos
ð2i þ 1Þup
2M

cos
ð2j þ 1Þvp
2N

(14.19)
where
C

m

¼
8
>
<
>
:
2
p
2
if m ¼ 0
1
otherwise
(14.20)
pði; jÞ ¼ pixel level at the location ði; jÞ
Fðu; vÞ ¼ DCT coefﬁcient at the frequency indices ðu; vÞ
JPEG divides an image into 8  8 image subblocks and applies DCT for each subblock individually.
Hence, we simplify the general 2D-DCT in terms of 8  8 size. The equation for 2D 8  8 DCT is
modiﬁed as
F

u; v

¼ CðuÞCðvÞ
4
X
7
i ¼ 0
X
7
j ¼ 0
pði; j

cos
ð2i þ 1Þup
16

cos
ð2j þ 1Þvp
16

(14.21)
The inverse of 2D 8  8 DCT is expressed as
p

i; j

¼
X
7
u ¼ 0
X
7
v ¼ 0
CðuÞCðvÞ
4
F

u; v

cos
ð2i þ 1Þup
16

cos
ð2j þ 1Þvp
16

(14.22)
14.7 Image Compression by Discrete Cosine Transform
729

To become familiar with the 2D-DCT formulas, we study Example 14.14.
EXAMPLE 14.14
Determine the 2D DCT coefﬁcients for the following image:
"
100
50
100
10
#
Solution:
Applying N
2 and M
2 to Equation (14.18) yields
F

u; v

2CðuÞCðvÞ
2  2
p
X
1
i
0
X
1
j
0
pði; j

cos
ð2i þ 1Þup
4

cos
ð2j þ 1Þvp
4

For u
0 and v
0, we achieve
F

0; 0

c

0

c

0
 P
1
i
0
P
1
j
0
pði; j

cos ð0Þ cos ð0Þ
 
2
p
2
!2
½pð0; 0Þ þ pð0; 1Þ þ pð1; 0Þ þ pð1; 1Þ
1
2 ð100 þ 50 þ 100
10Þ
120
For u
0 and v
1, we achieve
F

0; 1

c

0

c

1
 P
1
i
0
P
1
j
0
pði; j

cos ð0Þ cos
ð2j þ 1Þp
4

 
2
p
2
!
 1 

p

0; 0

cos p
4 þ p

0; 1

cos 3p
4 þ p

1; 0

cos p
4 þ p

1; 1

cos 3p
4

2
p
2
 
100 
2
p
2 þ 50
 
2
p
2
!
þ 100 
2
p
2
10
 
2
p
2
!!
80
Similarly,
Fð1; 0Þ
30; and Fð1; 1Þ
30
Finally, we get
F

u; v

"
120
80
30
30
#
Applying the MATLAB function dct2() veriﬁes the DCT coefﬁcients as follows:
>> F
dct2([100 50;100 10])
F
120.0000
80.0000
30.0000
30.0000
730
CHAPTER 14 Image Processing Basics

EXAMPLE 14.15
Given the following DCT coefﬁcients from a 2 2 image, determine the pixel pð0; 0Þ:
F
 
u; v
!
"
120
80
30
30
#
Solution:
Applying Equation (14.19) of the inverse 2D DCT with N
M
2, i
0, and j
0, it follows that
p

0; 0

P
1
u
0
P
1
v
0
cðuÞcðvÞFðu; v

cos
up
4
	
cos
vp
4
	
 
2
p
2
!

 
2
p
2
!
 F

0; 0

þ
 
2
p
2
!
 F

0; 1


 
2
p
2
!
þ
 
2
p
2
!
 F

1; 0


 
2
p
2
!
þ F

0; 1

 
2
p
2
!

 
2
p
2
!
1
2  120 þ 1
2  80 þ 1
2  30 þ 1
2

30

100
We apply the MATLAB function idct2() to verify the inverse DCT and get the following pixel values:
>> p
idct2([120 80; 30
30])
p
100.0000
50.0000
100.0000
10.0000
14.7.2 Two-Dimensional JPEG Grayscale Image Compression Example
To understand JPEG image compression, we examine an 8  8 grayscale subblock. Table 14.5 shows
a subblock of the grayscale image in Figure 14.37 that is to be compressed. Applying 2D-DCT leads to
Table 14.6.
These DCT coefﬁcients have a big DC component of 1198 but small AC component values. These
coefﬁcients are further normalized (quantized) with a quality factor Q, deﬁned in Table 14.7.
Table 14.5 8  8 Subblock
150
148
140
132
150
155
155
151
155
152
143
136
152
155
155
153
154
149
141
135
150
150
150
150
156
150
143
139
154
152
152
155
156
151
145
140
154
152
152
155
154
152
146
139
151
149
150
151
156
156
151
142
154
154
154
154
151
154
149
139
151
153
154
153
14.7 Image Compression by Discrete Cosine Transform
731

After normalization, as shown in Table 14.8, the DC coefﬁcient is reduced to 75, and a few small
AC coefﬁcients exist, while most are zero. We can encode and transmit only nonzero DCT coefﬁcients
and omit transmitting zeros, since they do not carry any information. They can be easily recovered by
resetting coefﬁcients to zero during decoding. By this principle we achieve data compression.
As shown in Table 14.8, most nonzero coefﬁcients reside in the upper left corner. Hence, the order
of encoding for each value is based on the zigzag path in which the order is numbered, as in Table 14.9.
According to the order, we record the nonzero DCT coefﬁcients as a JPEG vector, shown as
JPEG vector : ½75
1
1 0
1 3 2 EOB
where “EOB” ¼ end of block coding. The JPEG vector can further be compressed by encoding the
difference of DC values between subblocks, in differential pulse code modulation (DPCM), as dis-
cussed in Chapter 11, as well as by run-length coding of AC values and Huffman coding, which both
belong to lossless compression techniques. We will pursue this in the next section.
FIGURE 14.37
Original image.
Table 14.6 DCT Coefﬁcients for the Subblock Image in Table 14.5
1198
10
26
24
5
16
0
12
8
6
3
8
0
0
0
0
0
3
0
0
8
0
0
0
0
0
0
0
0
0
0
0
0
4
0
0
0
0
0
0
0
0
1
0
0
0
0
0
10
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
732
CHAPTER 14 Image Processing Basics

During the decoding stage, the JPEG vector is recovered ﬁrst. Then the quantized DCT coefﬁcients are
recovered according to the zigzag path. Next, the recovered DCT coefﬁcients are multiplied by
a quality factor to obtain the estimate of the original DCT coefﬁcients. Finally, we apply the inverse
DCT to achieve the recovered image subblock, which is shown in Table 14.10.
For comparison, the errors between the recovered image and original image are calculated and
listed in Table 14.11.
The original and compressed images are displayed in Figures 14.37 and 14.38, respectively. We do
not see any noticeable difference between these two grayscale images.
Table 14.7 The Quality Factor
16
11
10
16
24
40
51
61
12
12
14
19
26
58
60
55
14
13
16
24
40
57
69
56
14
17
22
29
51
87
80
62
18
22
37
56
68
109
103
77
24
35
55
64
81
104
113
92
49
64
78
87
103
121
120
101
72
92
95
98
112
100
103
99
Table 14.8 Normalized DCT Coefﬁcients
75
1
3
2
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
Table 14.9 DCT Coefﬁcient Scan Order
0
1
5
6
14
15
27
28
2
4
7
13
16
26
29
42
3
8
12
17
25
30
41
43
9
11
18
24
31
40
44
53
10
19
23
32
39
45
52
54
20
22
33
38
46
51
55
60
21
34
37
47
50
56
59
61
35
36
48
49
57
58
62
63
14.7 Image Compression by Discrete Cosine Transform
733

Table 14.10 The Recovered Image Subblock
153
145
138
139
147
154
155
153
153
145
138
139
147
154
155
153
155
147
139
140
148
154
155
153
157
148
141
141
148
155
155
152
159
150
142
142
149
155
155
152
161
152
143
143
149
155
155
152
162
153
144
144
150
155
154
151
163
154
145
144
150
155
154
151
Table 14.11 The Coding Error of the Image Subblock
3
3
2
7
3
1
0
2
2
7
5
3
5
1
0
0
1
2
2
5
2
4
5
3
1
2
2
2
6
3
3
3
3
1
3
2
5
3
3
3
7
0
3
4
2
6
5
1
6
3
7
2
4
1
0
3
12
0
4
5
1
2
0
2
FIGURE 14.38
JPEG compressed image.
734
CHAPTER 14 Image Processing Basics

14.7.3 JPEG Color Image Compression
This section is devoted to reviewing JPEG standard compression and examines the steps brieﬂy. We
focus on the encoder, since the decoder is just the reverse process of the encoding. The block diagram
for the JPEG encoder is in Figure 14.39.
The JPEG encoder has the following main steps:
1. Transform RGB to YIQ or YUV (U and V ¼ chrominance components).
2. Perform DCT on blocks.
3. Perform quantization.
4. Perform zigzag ordering, DPCM, and run-length encoding.
5. Perform entropy encoding (Huffman coding).
RGB to YIQ Transformation
The ﬁrst transformation is of the RGB image to a YIQ or YUV image. Transformation from RGB to
YIQ has previously been discussed. The principle is that in YIQ format, the luminance channel carries
more signal energy, up to 93%, while the chrominance channels carry up to only 7% of signal energy.
After transformation, more effort can be spent on coding the luminance channel.
DCT on Image Blocks
Each image is divided into 8  8 blocks. 2D-DCT is applied to each block to obtain the 8  8 DCT
coefﬁcient block. Note that there are three blocks, Y, I, and Q.
Quantization
The quantization is operated using the 8  8 quantization matrix. Each DCT coefﬁcient is quantized,
that is, divided by the corresponding value given in the quantization matrix. In this way, a smaller
RGB
YIQ or YUV
DCT
Quantization
Quantization
tables
8x8
p i j
( , )
8x8
F u v
( , )
8x8
Zigzag
DC
AC
DPCM
RLC
Coding
Tables
Entropy
coding
Header
Tables
Data
FIGURE 14.39
Block diagram for JPEG encoder.
14.7 Image Compression by Discrete Cosine Transform
735

number of bits can be used for encoding the DCT coefﬁcients. There are two different quantization
tables, one for luminance (which is the same as the one in the last section and listed here again for
comparison) and the other for chrominance (Tables 14.12 and 14.13).
We can see that the chrominance table has numbers with larger values, so that small values of DCT
coefﬁcients will result and hence fewer bits are required for encoding each DCT coefﬁcient. Zigzag
ordering to produce the JPEG vector is similar to the grayscale case, except that there are three JPEG
vectors.
Differential Pulse Code Modulation on Direct-Current Coefﬁcients
Since each 8  8 image block has only one DC coefﬁcient, which can be a very large number and
varies slowly, we make use of DPCM for coding DC coefﬁcients. As an example for the ﬁrst ﬁve image
blocks, the DC coefﬁcients are 200, 190, 180, 160, and 170. DPCM with a coding rule of
dðnÞ ¼ DCðnÞ  DCðn  1Þ with initial condition dð0Þ ¼ DCð0Þ produces a DPCM sequence of
200; 10; 10; 20; 10
Hence, the reduced signal range of these values is feasible for entropy coding.
Run-Length Coding on Alternating-Current Coefﬁcients
The run-length method encodes the pair of
• the number of zeros to skip and
• the next nonzero value.
Table 14.12 The Quality Factor for Luminance
16
11
10
16
24
40
51
61
12
12
14
19
26
58
60
55
14
13
16
24
40
57
69
56
14
17
22
29
51
87
80
62
18
22
37
56
68
109
103
77
24
35
55
64
81
104
113
92
49
64
78
87
103
121
120
101
72
92
95
98
112
100
103
99
Table 14.13 The Quality Factor for Chrominance
17
18
24
47
99
99
99
99
18
21
26
66
99
99
99
99
24
26
56
99
99
99
99
99
47
66
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
99
736
CHAPTER 14 Image Processing Basics

The zigzag scan of the 8  8 matrix makes up a vector of 64 values with a long runs of zeros. For
example, the quantized DCT coefﬁcients are scanned as
½75; 1; 0; 1; 0; 0; 1; 3; 0; 0; 0; 2; 0; 0; .; 0
with one run, two runs, and three runs of zeros in the middle and 52 extra zeros towards the end. The
run-length method encodes AC coefﬁcients by producing a pair (run length, value), where the run
length is the number of zeros in the run, while the value is the next nonzero coefﬁcient. A special pair
(0, 0) indicates EOB. Here is the result from a run-length encoding of AC coefﬁcients:
ð0; 1Þ; ð1; 1Þ; ð2; 1Þ; ð0; 3Þ; ð3; 2Þ; ð0; 0Þ
Lossless Entropy Coding
The DC and AC coefﬁcients are further compressed using entropy coding. JPEG allows Huffman
coding and arithmetic coding. We focus on the Huffman coding here.
Coding DC Coefﬁcients
Each DPCM-coded DC coefﬁcient is encoded by a pair of symbols (size, amplitude) with the size
(4-bit code) designating the number of bits for the coefﬁcient as shown in Table 14.14, while the
amplitude is encoded by the actual bits. For the negative number of the amplitude, 1’s complement is
used.
For example, we can code the DPCM-coded DC coefﬁcients 200, 10, 10, 20, 10 as
ð8; 11001000Þ; ð4; 0101Þ; ð4; 0101Þ; ð5; 01011Þ; ð4; 1010Þ
Since there needs to be 4 bits for encoding each size, we can use 45 bits in total for encoding the DC
coefﬁcients for these ﬁve subblocks.
Coding AC Coefﬁcients
The run-length AC coefﬁcients have the format (run length, value). The value can be further
compressed using the Huffman coding method, similar to coding the DPCM-coded DC coefﬁcients.
The run length and the size are each encoded by 4 bits and packed into a byte.
Table 14.14 Huffman Coding Table
Size
Amplitude
1
2
3
4
5
.
.
.
10
1,1
3, 2,2,3
7,.., 4,4,.,7
15,., 8,8,.,15
31,., 16,16,.,31
.
.
.
1023,., 512,512,.,1023
14.7 Image Compression by Discrete Cosine Transform
737

Symbol 1: (run length, size)
Symbol 2: (amplitude)
The 4-bit run length can only tackle runs for zeros from 1 to 15. If the run length of zeros is larger than
15, then a special code (15, 0) is used for Symbol 1. Symbol 2 is the amplitude in Huffman coding as
shown in Table 14.14, while the encoded Symbol 1 is kept in its format:
(run length, size, amplitude)
Let us code the following run-length code of AC coefﬁcients:
ð0; 1Þ; ð1; 1Þ; ð2; 1Þ; ð0; 3Þ; ð3; 2Þ; ð0; 0Þ
We can produce a bit stream for AC coefﬁcients:
ð0000; 0001; 0Þ; ð0001; 0001; 0Þ; ð0010; 0001; 0Þ;
ð0000; 0010; 11Þ; ð0011; 0010; 10Þ; ð0000; 0000Þ
There are 55 bits in total. Figure 14.40 shows a JPEG compressed color image (included in the color
insert). The decompressed image is indistinguishable from the original image after comparison.
14.7.4 Image Compression Using Wavelet Transform Coding
We can extend the one-dimensional discrete wavelet transform (DWT) discussed in Chapter 13 to the
two-dimensional DWT. The procedure is described as follows. Given an N  N image, the 1D-DWT
using level 1 is applied to each row of the image; and after all the rows are transformed, the level-1 1D-
DWT is applied again to each column. After the rows and columns are transformed, we achieve four
ﬁrst-level subbands labeled LL, HL, LH, and HH as shown in Figure 14.41(a). The same procedure
repeats for the LL band only and results in the second-level subbands: LL2, HL2, LH2, and HH2
FIGURE 14.40
JPEG compressed color image.
738
CHAPTER 14 Image Processing Basics

(Figure 14.41(b)). The process proceeds to higher levels as desired. With the obtained wavelet
transform, we can quantize coefﬁcients to achieve the compression requirement. For example, for the
second-level coefﬁcients, we can omit HL1, LH1, HH1 to simply achieve a 4:1 compression ratio.
Decompression reverses the process, that is, we inversely transform columns and then rows of the
wavelet coefﬁcients. We can apply the IDWT to the recovered LL band with the column and row
inverse transform processes, and continue until the inverse transform at level 1 is completed. Let us
look at an illustrative example.
EXAMPLE 14.16
Consider the following 4  4 image:
a. Perform 2D DWT using the 2 tap Haar wavelet.
b. Using the result in (a), perform 2D IDWT using the 2 tap Haar wavelet.
Solution:
a. The MATLAB function dwt() is applied to each row. The result for the ﬁrst row is displayed below:
>> dwt([1 1]/sqrt(2), [114
135
122
109],1)’
% Row vector coefﬁcients
ans
176.0696
163.3417
14.8492
9.1924
The completed row transform is listed below:
LL
HL
LH
HH
LH1
HH1
HL1
LL2 HL2
HH2
LH2
(a) Level-one transformation (b) Level-two transformation
FIGURE 14.41
The two-dimensional DWT for level 1 and level 2.
114
135
122
109
102
116
119
124
105
148
138
122
141
102
140
132
176.0696
163.3417
14.8492 9
9.1924
154.1493
171.8269
9.8995
3.5355
178.8980
183.8478
30.4056
11.3137
171.8269
192.3330
27.5772
5.6569
14.7 Image Compression by Discrete Cosine Transform
739

Next, the result for the ﬁrst column is presented:
>> dwt([1 1]/sqrt(2),[ 176.0696 154.1493 178.8980 171.8269 ],1)’
ans
233.5000 248.0000 15.5000 5.0000
Applying the transform to each column completes the level 1 transformation:
Now, we perform the level 2 transformation. Applying the transform to the ﬁrst row for the LL1 band yields
>> dwt([1 1]/sqrt(2),[ 233.5000 237.0000],1)’
ans
332.6937
2.4749
After completing the row transformation, the result is given by
Similarly, the ﬁrst column MATLAB result is listed below:
>> dwt([1 1]/sqrt(2),[ 332.6937 363.4529 ],1)’
ans
492.2500
21.7500
Finally, we achieve the completed level 2 DWT as
b. Recovering the LL2 band ﬁrst, the ﬁrst column reconstruction is given as
>> idwt([1 1]/sqrt(2),[ 492.2500
21.7500],1)’
ans
332.6937 363.4529
Completing the inverse of the second column in the LL2 band gives
233.5000
237.0000
17.5000
4.0000
248.0000
266.0000
2.0000
12.0000
15.5000
6.0000
3.5000
9.0000
5.0000
6.0000
41.0000
4.0000
332.6937
2.4749
17.5000
4.0000
363.4529
12.7279
2.0000
12.0000
15.5000
6.0000
3.5000
9.0000
5.0000
6.0000
41.0000
4.0000
492.2500
10.7500
17.5000
4.0000
21.7500
7.2500
2.0000
12.0000
15.5000
6.0000
3.5000
9.0000
5.0000
6.0000
41.0000
4.0000
332.6937
2.4749
17.5000
4.0000
363.4529
12.7279
2.0000
12.0000
15.5000
6.0000
3.5000
9.0000
5.0000
6.0000
41.0000
4.0000
740
CHAPTER 14 Image Processing Basics

Now, we show the ﬁrst row result for the LL2 band in MATLAB as follows:
>> idwt([1 1]/sqrt(2),[ 332.6937
2.4749 ],1)’
ans
233.5000 237.0000
The recovered LL1 band is shown in the following:
Now we are at the level 1 inverse process. For simplicity, the ﬁrst column result in MATLAB and the completed
results are listed below, respectively.
>> idwt([1 1]/sqrt(2),[ 233.5000 248.0000 15.5000 5.0000],1)’
ans
176.0696 154.1493 178.8980 171.8269
Finally, we perform the inverse of the row transform at level 1. The ﬁrst row result in MATLAB is listed below:
>> idwt([1 1]/sqrt(2),[ 176.0696 163.3417
14.8492 9.1924],1)’
ans
114.0000 135.0000 122.0000 109.0000
The ﬁnal inverse DWT is obtained as
Since there is no quantization for each coefﬁcient, we obtain a perfect reconstruction.
Figure 14.42 shows 8-bit grayscale image compression by applying the one-level wavelet trans-
form, in which a 16-tap Daubechies wavelet is used. The wavelet coefﬁcients (each is coded using 8
bits) are shown in Figure 14.42(b). By discarding the HL, LH, and HH band coefﬁcients, we can
achieve 4:1 compression. The decoded image is displayed in Figure 14.42(c). The MATLAB program
is listed in Program 14.4.
Figure 14.43 illustrates two-level wavelet transform and compression results. By discarding the
HL2, LH2, HH2, HL1, LH1, and HH1 subbands, we achieve 16:1 compression. However, as shown in
233.5000
237.0000
17.5000
4.0000
248.0000
266.0000
2.0000
12.0000
15.5000
6.0000
3.5000
9.0000
5.0000
6.0000
41.0000
4.0000
176.0696
163.3417
14.8492
9.1924
154.1493
171.8269
9.8995
3.5355
178.8980
183.8478
30.4056
11.3137
171.8269
192.3330
27.5772
5.6569
114.0000
135.0000
122.0000
109.0000
102.0000
116.0000
119.0000
124.0000
105.0000
148.0000
138.0000
122.0000
141.0000
102.0000
140.0000
132.0000
14.7 Image Compression by Discrete Cosine Transform
741

Figure 14.43(c), we can observe a noticeable degradation of image quality. Since the high-frequency
details are discarded, the compressed image shows a signiﬁcant smoothing effect. In addition, there are
many advanced methods to quantize and compress the wavelet coefﬁcients. Of these compression
techniques, the embedded zerotree wavelet (EZW) method is the most efﬁcient one; it can be found in
Li and Drew (2004).
Program 14.4. One-level wavelet transform and compression.
close all; clear all; clc
X imread(’cruise’,’JPEG’);
Y rgb2gray(X); % Convert the image into grayscale
h0
[0.054415842243144 0.312871590914520 0.675630736297712 .
0.585354683654425
0.015829105256675
0.284015542962009 .
0.000472484573805 0.128747426620538
0.017369301001845 .
0.044088253930837 0.013981027917411 0.008746094047413 .
0.004870352993456
0.000391740373377 0.000675449406451 .
0.000117476784125];
M
length(h0);
h1(1:2:M 1)
h0(M: 2:2);h1(2:2:M)
h0(M 1: 2:1);% Obtain QMF highpass filter
[m n] size(Y);
% Level 1 transform
[m n] size(Y);
FIGURE 14.42
(a) Wavelet coefﬁcients; (b) original image; (c) 4:1 compression.
742
CHAPTER 14 Image Processing Basics

for i 1:m
W1(i,:) dwt(h0,double(Y(i,:)),1)’;
end
for i 1:n
W1(:,i) dwt(h0,W1(:,i),1); % Wavelet coefficients at level 1
end
% Quantization using 8 bits
wmax double(max(max(abs(W1)))); % Scale factor
W1 round(double(W1)*2^7/wmax); % Get 8 bit data
W1 double(W1)*wmax/2^7;% Recover the wavelet
figure (1); imshow(uint8(W1));xlabel(’Wavelet coefﬁcients’);
% 8 bit quantization
[m, n] size(W1);
WW zeros(m,n);
WW(1:m/2,1:n/2) W1(1:m/2,1:n/2);
W1 WW;
% Decoding from level 1 using W1
[m, n] size(W1);
for i 1:n
Yd1(:,i) idwt(h0,double(W1(:,i)),1);
end
FIGURE 14.43
(a) Wavelet coefﬁcients; (b) original image; (c) 16:1 compression.
14.7 Image Compression by Discrete Cosine Transform
743

for i 1:m
Yd1(i,:) idwt(h0,double(Yd1(i,:)),1)’;
end
YY1 uint8(Yd1);
figure (2),imshow(Y);xlabel(’Original image’);
figure (3),imshow(YY1);xlabel(’4:1 Compression’);
Program 14.5. Two-level wavelet compression.
close all; clear all; clc
X imread(’cruise’,’JPEG’);
Y rgb2gray(X);
h0
[0.054415842243144 0.312871590914520 0.675630736297712 .
0.585354683654425
0.015829105256675
0.284015542962009 .
0.000472484573805 0.128747426620538
0.017369301001845 .
0.044088253930837 0.013981027917411 0.008746094047413 .
0.004870352993456
0.000391740373377 0.000675449406451 .
0.000117476784125];
M
length(h0);
h1(1:2:M 1)
h0(M: 2:2);h1(2:2:M)
h0(M 1: 2:1);% Obtain QMF highpass filter
[m n] size(Y);
% Level 1 transform
[m n] size(Y);
for i 1:m
W1(i,:) dwt(h0,double(Y(i,:)),1)’;
end
for i 1:n
W1(:,i) dwt(h0,W1(:,i),1); % Wavelet coefficients at level 1 transform
end
% Level 2 transform
Y1 W1(1:m/2,1:n/2); % Obtain LL subband
[m n] size(Y1);
for i 1:m
W2(i,:) dwt(h0,Y1(i,:),1)’;
end
for i 1:n
W2(:,i) dwt(h0,W2(:,i),1);
end
W22 W1; W22(1:m,1:n) W2; % Wavelet coefficients at level 2 transform
wmax max(max(abs(W22)));
% 8 bit quantization
W22 round(W22*2^7/wmax);
W22 double(W22)*wmax/2^7;
figure(1), imshow(uint8(W22));xlabel(’Wavelet coefﬁcients’);
[m, n] size(W22); WW zeros(m,n);
WW(1:m/4,1:n/4) W22(1:m/4,1:n/4);
W22 WW; % Discard HL2,LH2, HH2, HL1, LH1, HH1 subbands
% Decoding from level 2 transform
[m,n] size(W22); Wd2 W22(1:m/2,1:n/2);
744
CHAPTER 14 Image Processing Basics

% Level 2
[m n] size(Wd2);
for i 1:n
Wd1(:,i) idwt(h0,double(Wd2(:,i)),1);
end
for i 1:m
Wd1(i,:) idwt(h0,double(Wd1(i,:))’,1);
end
% Level 1
[m, n] size(W22);Yd11 W22;
Yd11(1:m/2,1:n/2) Wd1;
for i 1:n
Yd(:,i) idwt(h0,Yd11(:,i),1);
end
for i 1:m
Yd(i,:) idwt(h0,double(Yd(i,:)),1)’;
end
figure (2),imshow(Y),xlabel(’Original image’);
Y11 uint8(Yd); figure (3),imshow(Y11);xlabel(’16:1 compression’);
14.8 CREATING A VIDEO SEQUENCE BY MIXING TWO IMAGES
In this section, we introduce a method to mix two images to generate an image (video) sequence.
Applications of mixing the two images may include fading in and fading out images, blending two
images, or overlaying text on an image.
In mixing two images in a video sequence, a smooth transition is required from fading out one
image of interest to fading in another image of interest. We want to fade out the ﬁrst image and
gradually fade in the second. This cross-fade scheme is implemented using the following
operation:
Mixed image ¼ ð1  aÞ  image1 þ a  image2
(14.23)
where a ¼ fading in proportionally to the weight of the second image (value between 0 and 1), and
ð1  aÞ ¼ fade out proportionally to the weight of the second image.
The video sequence in Figure 14.44A consisting of six frames is generated using a ¼ 0, a ¼ 0:2,
a ¼ 0:4, a ¼ 0:6, a ¼ 0:8, and a ¼ 1:0, respectively, for two images. The equations for generating
these frames are listed as follows:
Mixed image1 ¼ 1:0  image1 þ 0:0  image2
Mixed image2 ¼ 0:8  image1 þ 0:2  image2
Mixed image3 ¼ 0:6  image1 þ 0:4  image2
Mixed image4 ¼ 0:4  image1 þ 0:6  image2
Mixed image5 ¼ 0:2  image1 þ 0:8  image2
Mixed image6 ¼ 0:0  image1 þ 1:0  image2
The sequence begins with the Grand Canyon image and fades in with the cruise ship image. At frame
4, 60% of the cruise ship is faded in, and the image begins to be discernible as such. The sequence ends
14.8 Creating a Video Sequence by Mixing Two Images
745

with the cruise ship in 100% fade-in. Figure 14.44A displays the generated grayscale sequence.
Figure 14.44B shows the RGB color video sequence (also given in the color insert).
14.9 VIDEO SIGNAL BASICS
Video signals generally can be classiﬁed as component video, composite video, and S-video. In
component video, three video signals
such as the red, green, and blue channels or the Y, I, and Q
channels
are used. Three wires are required for connection to a camera or TV. Most computer
systems use component video signals. Composite video has intensity (luminance) and two-color
(chrominance) components that modulate the carrier wave. This signal is used in broadcast color TV.
The standard by the US-based National Television System Committee (NTSC) combines channel
signals into a chroma signal, which is modulated to a higher frequency for transmission. Connecting
TVs or VCRs requires only one wire, since both video and audio are mixed into the same signal.
S-video sends luminance and chrominance separately, since the luminance presenting black-and-white
intensity contains most of the signal information for visual perception.
FIGURE 14.44A
Grayscale video sequence.
746
CHAPTER 14 Image Processing Basics

14.9.1 Analog Video
In computer systems, progressive scanning traces a whole picture, called frame via row-wise. A higher-
resolution computer uses 72 frames per second (fps). The video is usually played at a frame rate
varying from 15 frames to 30 frames.
In TV reception and some monitors, interlaced scanning is used in a cathode-ray tube display, or
raster. The odd-numbered lines are traced ﬁrst, and the even-numbered lines are traced next. We then
get the odd-ﬁeld and even-ﬁeld scans per frame. The interlaced scheme is illustrated in Figure 14.45,
where the odd lines are traced, such as A to B, then C to D, and so on, ending in the middle at E. The
even ﬁeld begins at F in the middle of the ﬁrst line of the even ﬁeld and ends at G. The purpose of using
interlaced scanning is to transmit a full frame quickly to reduce ﬂicker. Trace jumping from B to C is
called horizontal retrace, while trace jumping from E to F or G to A is called vertical retrace.
The video signal is amplitude modulated. The modulation levels for NTSC video are shown in
Figure 14.46. In the United States, negative modulation is used, meaning that the bright and dark
intensities are inverted before modulation. In the negative modulated video signal, less amplitude
comes from a brighter scene while more amplitude comes from a darker one. Since most pictures
contain more white than black levels, the video signal level is reduced. Hence, with negative modu-
lation, possible power efﬁciency can be achieved for transmission. The reverse process will apply for
display at the receiver.
FIGURE 14.44B
The RGB color video sequence.
14.9 Video Signal Basics
747

The horizontal synchronizing pulse controls the timing for the horizontal retrace. The blanking
levels are used for synchronizing as well. The “back porch” (Figure 14.46) of the blanking also
contains the color subcarrier burst for color demodulation.
The demodulated electrical signal can be seen in Figure 14.47, where a typical electronic signal for
one scan line is depicted. The white intensity has a peak value of 0.714 volt, and the black has a voltage
level of 0.055 volt, which is close to zero. The blank corresponds to zero voltage, and the synchro-
nizing pulse is at the level of -0.286 volt. Synchronizing takes 10.9 microseconds, while video
635.
s
10 9.
s
52 7.
us
t
Video signal
Video
"Back porch"
blanking level
"Front porch"
blanking level
Horizontal
synchronizing pulse
100%
75%
70%
12 5%
.
FIGURE 14.46
Video-modulated waveform.
A
B
C
D
E
F
G
FIGURE 14.45
Interlaced raster scanning.
748
CHAPTER 14 Image Processing Basics

63.6
s
10 9.
s
52 7.
us
White (0.714 V)
Black (0.055 V)
Blank (0V)
Sync ( 0.286 V)
t
FIGURE 14.47
The demodulated signal level for one NTSC scan line.
H
2
/
H
H
Equalizing pulses
Vertical
synchronizing
pulses
Equalizing pulses
Vertical blanking
H/2
Equalizing pulses
Vertical
synchronizing
pulses
Equalizing pulses
Vertical blanking
Front porch
Horizontal blanking
Horizontal syn. pulse
Back porch
Horizontal blanking
8 cycles color subcarrier burst
Color subcarrier
Odd field
Even field
FIGURE 14.48
Vertical synchronization for each ﬁeld and the color subcarrier burst.
14.9 Video Signal Basics
749

occupies 52.7 microseconds, and one entire scan line occupies 63.6 microseconds. Hence, the line scan
rate can be determined as 15.75 kHz.
Figure 14.48 describes vertical synchronization. A pulse train is generated at the end of each ﬁeld.
The pulse train contains 6 equalizing pulses, 6 vertical synchronizing pulses, and another 6 equalizing
pulses at the rate of twice the size of the line scan rate (31.5 kHz), so that the timing for sweeping half
the width of the ﬁeld is feasible. In NTSC, the vertical retrace takes the time interval of 20 horizontal
lines designated for control information at the beginning of each ﬁeld. The 18 pulses of the vertical
blanking occupy a time interval that is equivalent to 9 lines. This leaves lines 10 to 20 for other uses.
A color subcarrier resides on the back porch, as shown in Figure 14.48. The eight cycles of the
color subcarrier are recovered via a delayed gating circuit trigged by the horizontal sync pulse.
Synchronization includes the color burst frequency and phase information. The color subcarrier is then
applied to demodulate the color (chrominance).
Let us summarize NTSC video signals. The NTSC TV standard uses an aspect ratio of 4:3 (ratio of
picture width to height), and 525 scan lines per frame at 30 fps. Each frame has an odd ﬁeld and an
even ﬁeld. So there are 525/2¼262.5 lines per ﬁeld. NTSC actually uses 29.97 fps. The horizontal
sweep frequency is 525 29.97¼15,734 lines per second, and each line takes 1/15,734¼63.6 m sec.
Horizontal retrace takes 10.9 m sec, while the line signal takes 52.7 m sec. for one line of image display.
Vertical retrace and sync are also needed so that the ﬁrst 20 lines for each ﬁeld are reserved. The active
video lines per frame are 485. The layout of the video data, retrace, and sync data is shown in
Figure 14.49.
Blanking regions can be used for V-chip information, stereo audio channel data, and subtitles in
various languages. The active line is then sampled for display. A pixel clock divides each horizontal
line of video into samples. For example, vertical helical scan (VHS) uses 240 samples per line, while
Super VHS uses 400 425 samples per line.
Figure 14.50 shows the NTSC video signal spectra. The NTSC standard assigns a bandwidth of 4.2
MHz for luminance Y, 1.5 MHz for I, and 0.5 MHz for Q, due to the human perception of color
Image data
Vertcal retrace and synchronizing
Hor zonta  retrace and synchron z ng
FIGURE 14.49
Video data, retrace, and sync layout.
750
CHAPTER 14 Image Processing Basics

information. There is a wider bandwidth for I because the human eye has higher resolution to the I
color component than the Q color component.
As shown in Figure 14.50, vestigial sideband modulation (VSB) is employed for the luminance,
with a picture carrier of 1.25 MHz relative to the VSB left edge. The space between the picture carrier
and the audio carrier is 4.5 MHz.
The audio signal containing the frequency range from 50 Hz to 15 kHz is stereo frequency
modulated (FM), using a peak frequency deviation of 25 kHz. Therefore, stereo FM audio requires
a transmission bandwidth of 80 kHz, with an audio carrier located at 4.5 MHz relative to the picture
carrier.
The color burst carrier is centered at 3.58 MHz above the picture carrier. The two color components
I and Q undergo quadrature amplitude modulation (QAM) with modulated component I output, which
is VSB ﬁltered to remove two-thirds of the upper sideband, so that all chroma signals fall within a 4.2
MHz video bandwidth. The color burst carrier of 3.58 MHz is chosen such that the chroma signal and
luminance are interleaved in the frequency domain to reduce interference between them.
Aud o carr er
1.25 MHz
4.5 MHz 
1 MHz
1.5 MHz
3.579545 MHz
6 MHz
Y Luminance signal
f (MHz)
I  signal
Q signal
Color subcarrier
1.5 MHz
1 MHz
I  signal
Q signal
LSB
LSB
USB
USB
LSB
LSB
VSB
V deo carr er
4.2 MHz
Color subcarrier
Color subcarrier
USB
FIGURE 14.50
NTSC Y, I, and Q spectra.
14.9 Video Signal Basics
751

Generating a chroma signal with QAM gives
C ¼ I cos ð2pfsctÞ þ Q sin ð2pfsctÞ
(14.24)
where C ¼ chroma component and fsc ¼ color subcarrier ¼ 3.58 MHz. The NTSC signal is further
combined into a composite signal:
Composite ¼ Y þ C ¼ Y þ I cos ð2pfsctÞ þ Q sin ð2pfsctÞ
(14.25)
At decoding, the chroma signal is obtained by separating Y and C ﬁrst. Generally, the lowpass ﬁlters
located at the lower end of the channel can be used to extract Y. Comb ﬁlters may be employed to
cancel interferences between the modulated luminance signal and the chroma signal (Li and Drew,
2004). Then we perform demodulation for I and Q as follows:
C  2 cos ð2pfsctÞ ¼ I2 cos2 ð2pfsctÞ þ Q  2 sin ð2pfsctÞ cos ð2pfsctÞ
¼ I þ I  cos ð2  2pfsctÞ þ Q sin ð2  2pfsctÞ
(14.26)
Applying a lowpass ﬁlter yields the I component. Similar operation applying a carrier signal of
2sinð2pfsctÞ for demodulation recovers the Q component.
PAL Video
The phase alternative line (PAL) system uses 625 scan lines per frame at 25 fps, with an aspect ratio
of 4:3. It is widely used in Western Europe, China, and India. PAL uses the YUV color model, with an
8-MHz channel in which Y has 5.5 MHz and U and V each have 1.8 MHz with the color subcarrier
frequency of 4.43 MHz relative to the picture carrier. U and Vare the color difference signals (chroma
signals) of the B-Y signal and R-Y signal, respectively. The chroma signals have alternate signs
(e.g., þVand V) in successive scan lines. Hence, in consecutive lines, the signal and its sign-reversed
counterpart are averaged to cancel out phase errors that could be displayed as color errors.
SECAM Video
The SECAM (Se´quentiel Couleur a` Me´moire) system uses 625 scan lines per frame at 25 fps, with an
aspect ratio of 4:3 and interlaced ﬁelds. The YUV color model is employed, and U and V signals are
modulated using separate color subcarriers of 4.25 and 4.41 MHz, respectively. The U and V signals
are sent on each line alternatively. In this way, quadrature multiplexing and the possible cross-coupling
of color signals can be avoided by halving the color resolution in the vertical dimension. Table 14.15
includes a summary of analog broadband TV systems.
Table 14.15 Analog Broadband TV Systems
TV System
Frame
Rate
(fps)
Number of
Scan
Lines
Total
Bandwidth
(MHz)
Y
Bandwidth
(MHz)
U or I
Bandwidth
(MHz)
V or Q
Bandwidth
(MHz)
NTSC
29.97
525
6.0
4.2
1.6
0.6
PAL
25
625
8.0
5.5
1.8
1.8
SECAM
25
625
8.0
6.0
2.0
2.0
Source: Li and Drew, 2004.
752
CHAPTER 14 Image Processing Basics

14.9.2 Digital Video
Digital video has become dominant over the long-standing analog method in modern systems and devices
because it offers: high image quality; ﬂexibility of storage, retrieval, and editing capabilities; digital
enhancement of video images; encryption; channel noise tolerance; and multimedia system applications.
Digital video formats are developed by the Consultative Committee for International Radio
(CCIR). One of the most important standards is CCIR-601, which became ITU-R-601, an international
standard for professional video applications.
In CCIR-601, chroma subsampling is carried for digital video. Each pixel is in the YCbCr color
space, where Y is the luminance, and Cb and Cr are the chrominance. Subsampling schemes include
4:4:4 (no chroma subsampling), 4:2:2, 4:1:1, and 4:2:0 as illustrated in Figure 14.51.
Y
Cr Cb
,
480
720
480
720
Y
Cr Cb
,
480
720
480
360
4 4 4
: :
4 2 2
: :
Y
Cr Cb
,
480
720
240
360
4 2 0
: :
=Y value
=Cr and Cb values
=Y, Cr, and Cb values
FIGURE 14.51
Chroma subsampling.
14.9 Video Signal Basics
753

In each frame in a 4:4:4 video format, the number of values for each chrominance component, Cb or
Cr, is the same as that for luminance, Y, both horizontally and vertically. This format ﬁnds applications in
the computer graphics, in which the chrominance resolution is required for both horizontal and vertical
dimension. The format is not widely used in video applications due to a huge storage requirement.
As shown in Figure 14.51, for each frame in the 4:2:2 video format, the number of chrominance
components for Cr or Cb is half the number of luminance components for Y. The resolution is full
vertically, and the horizontal resolution is downsampled by a factor of 2. Considering the ﬁrst line of
six pixels, transmission occurs in the following form: (Y0, Cb0), (Y1, Cr0), (Y2,Cb2), (Y3,Cr2),
(Y4,Cb4), (Y5, Cr4), and so on. Six Y values are sent for every two Cb and Cr values that are sent.
In the 4:2:0 video format, the number of values for each chrominance Cb and Cr is half the number
of luminance Y values for both the horizontal and vertical directions. That is, the chroma is down-
sampled horizontally and vertically by a factor of 2. The location for both Cb and Cr is shown in
Figure 14.51. Digital video speciﬁcations are given in Table 14.16.
CIF was speciﬁed by the Comite´ Consultatif International Te´le´phonique et Te´le´graphique
(CCITT), which is now the International Telecommunications Union (ITU). CIF produces low bit rate
video and supports progressive scan. QCIF produces video with an even lower bit rate. Neither format
supports interlaced scan mode.
Table 14.17 outlines the high-deﬁnition TV (HDTV) formats supported by the Advanced Televi-
sion System Committee (ATSC), where “I” means interlaced scan and “P” indicates progressive scan.
MPEG compressions of video and audio are employed.
Table 14.16 Digital Video Speciﬁcations
CCIR 601
525/60
NTSC
CCR 601
625/50
PAL/SECAM
CIF
QCIF
Luminance resolution
Chrominance resolution
Color subsampling
Aspect ratio
Fields/sec
Interlaced
720  480
360  480
4:2:2
4:3
60
Yes
720  576
360  576
4:2:2
4:3
50
Yes
352  288
176  144
4:2:0
4:3
30
No
176  144
88  72
4:2:0
4:3
30
No
CCR, comparison category rating; CIF, common intermediate format; QCIF, quarter CIF.
Source: Li and Drew, 2004.
Table 14.17 High-Deﬁnition TV (HDTV) Formats
Number of Active
Pixels per Line
Number of Active
Lines
Aspect Ratio
Picture Rate
1920
1280
704
640
1080
720
480
480
16:9
16:9
16:9 and 4:3
4:3
60I 30P 24P
60P 30P 24 P
60I 60P 30P 24P
60I 60P 30P 24P
Source: Li and Drew, 2004.
754
CHAPTER 14 Image Processing Basics

14.10 MOTION ESTIMATION IN VIDEO
In this section, we study motion estimation since this technique is widely used in MPEG video
compression. A video contains a time-ordered sequence of frames. Each frame consists of image data.
When the objects in an image are still, the pixel values do not change under constant lighting
conditions. Hence, there is no motion between the frames. However, if the objects are moving, then the
pixels are moved. If we can ﬁnd the motions, which are the pixel displacements, with motion vectors,
the frame data can be recovered from the reference frame by copying and pasting at locations speciﬁed
by the motion vector. To explore such an idea, let us look at Figure 14.52.
As shown in Figure 14.52, the reference frame is displayed ﬁrst, and the next frame is the target
frame containing a moving object. The image in the target frame is divided into N  N macroblocks
(20 macroblocks). A macroblock match is searched within the search window in the reference frame to
ﬁnd the closest match between a macroblock under consideration in the target frame and the mac-
roblock in the reference frame. The differences between two locations (motion vectors) for the
matched macroblocks are encoded.
The criteria for ﬁnding the best match can be chosen using the mean absolute difference (MAD)
between the reference frame and the target frame:
MADði; jÞ ¼ 1
N2
X
N
1
k ¼ 0
X
N
1
l ¼ 0
jTðm þ k; n þ lÞ  Rðm þ k þ i; n þ l þ jÞj
(14.27)
u ¼ i; v ¼ j for MADði; jÞ ¼ minimum; and  p  i; j  p
(14.28)
There are many search methods for ﬁnding the motion vectors, including optimal, sequential, or brute
force searches, and suboptimal searches such as 2D-logarithmic and hierarchical searches. Here we
examine sequential search to understand the basic idea.
e
m
a
rf t
e
g
r
a
T
e
m
a
rf 
e
c
n
e
r
e
f
e
R
( , )
m n
( , )
m n
(
,
)
m
u n
v
N
N
Macroblock
Macroblock
Search window
MV
2p+1
2p+1
FIGURE 14.52
Macroblocks and motion vectors in the reference frame and target frame.
14.10 Motion Estimation in Video
755

The sequential search for ﬁnding the motion vectors employs methodical “brute force” to search the
entire (2pþ1)  (2pþ1) search window in the reference frame. The macroblock in the target frame
compares each macroblock centered at each pixel in the search window in the reference frame.
Comparison using Equation (14.27) proceeds pixel by pixel to ﬁnd the best match in which the vector
(i, j) produces the smallest MAD. Then the motion vector (MV(u, v)) is found to be u ¼ i, and v ¼ j.
The algorithm is described as follows:
min MAD large value
for i
p, ., p
for j
p,.,p
cur MAD MDA(i,j);
if cur MAD < min MAD
min MAD
cur MAD;
u i;
v j;
end
end
end
Sequential search provides the best match with the least MAD. However, it requires a huge
amount of computations. Other suboptimal search methods can be employed to reduce the
computational requirement, but with sacriﬁces of image quality. These topics are beyond our
scope.
EXAMPLE 14.17
An 80  80 reference frame, target frame, and their difference are displayed in Figure 14.53. A macroblock with
a size of 16  16 is used, and the search window has a size of 32  32. The target frame is obtained by moving the
reference frame to the right by 6 pixels and to the bottom by 4 pixels. The sequential search method is applied to
ﬁnd all the motion vectors. The reconstructed target frame using the motion vectors and reference image is given in
Figure 14.53.
Since 80  80=ð16  16Þ
25, there are 25 macroblocks in the target frame and 25 motion vectors in total.
The motion vectors are
Horizontal direction
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
(14.29)
Vertical direction
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
4
(14.30)
The motion vector comprises the pixel displacements from the target frame to the reference
frame. Hence, given the reference frame, directions speciﬁed in the motion vector should be
switched to indicate the motion towards the target frame. As indicated by the obtained motion
vectors, the target image is a version of the reference image moving to the right by 6 pixels and down
by 4 pixels.
756
CHAPTER 14 Image Processing Basics

14.11 SUMMARY
1. A digital image consists of pixels. For a grayscale image, each pixel is assigned a grayscale level
that presents the luminance of the pixel. For an RGB color image, each pixel is assigned a red
component, a green component, and a blue component. For an indexed color image, each pixel
is assigned an address that is the location of the color table (map) made up of the red, green,
and blue components.
2. Common image data formats are 8-bit grayscale image, 24-bit color, and 8-bit indexed color.
3. The larger the number of pixels in an image, or the larger the numbers of the RGB components,
the ﬁner is the spatial resolution in the image. Similarly, the more scale levels used for each pixel,
the better the scale-level image resolution. The more pixels and more bits used for the scale levels
in the image, the more storage is required.
4. RGB color pixels can be converted to YIQ color pixels. The Y component is the luminance
occupying 93% of the signal energy, while the I and Q components represent the color
information of the image, occupying the remainder of the energy.
5. The histogram for a grayscale image shows the number of pixels at each grayscale level. The
histogram can be modiﬁed to enhance the image. Image equalization using the histogram can
FIGURE 14.53
Reference frame, target frame, their difference, and the reconstructed frame by the motion vectors.
14.11 Summary
757

improve the image contrast and effectively enhances contrast for image underexposure. Color
image equalization can be done only in the luminance channel or RGB channels.
6. Image enhancement techniques such as average lowpass ﬁltering can ﬁlter out random noise in
the image; however, it also blurs the image. The degree of blurring depends on the kernel size.
The bigger the kernel size, the more blurring occurs.
7. Median ﬁltering effectively removes the “pepper and salt” noise in an image.
8. The edge detection ﬁlter with Sobel convolution, Laplacian, and Laplacian of Gaussian kernels
can detect image boundaries.
9. The grayscale image can be made into a facsimile of the color image by pseudo-color image
generation, using the red, green, and blue transformation functions.
10. RGB-to-YIQ transformation is used to obtain the color image in YIQ space, or vice versa. It can
also be used for color-to-grayscale conversion, that is, keeping only the luminance channel after
the transformation.
11. 2D spectra can be calculated and are used to examine ﬁltering effects.
12. JPEG compression uses the 2D-DCT transform for both grayscale and color images in the YIQ
color space. JPEG uses different quality factors to normalize DCT coefﬁcients for the luminance
(Y) channel and the chrominance (IQ) channels.
13. The mixing of two images, in which two pixels are linearly interpolated using the weights 1  a
and a, can produce video sequences that have effects such as fading in and fading out of images,
blending of two images, and overlaying of text on an image.
14. Analog video uses interlaced scanning. A video frame contains odd and even ﬁelds. Analog video
standards include NTSC, PAL, SECAM.
15. Digital video carries the modulated information for each pixel in the YCbCr color space, where Y
is the luminance and Cb and Cr are the chrominance. Chroma subsampling creates various digital
video formats. The industry standards include CCIR601, CCR601, CIF, and QCIF.
16. Motion compensation of a video sequence produces motion vectors for all the image blocks in the
target video frame, which contain displacements of these image blocks relative to the reference
video frame. Recovering the target frame involves simply copying each image block of the
reference frame to the target frame at the location speciﬁed in the motion vector. Motion
compensation is a key element in MPEG video.
14.12 PROBLEMS
14.1. Determine the memory storage requirement for each of the following images:
a. 320  240 8-bit grayscale
b. 640  480 24-bit color image
c. 1600  1200 8-bit indexed image
14.2. Determine the number of colors for each of the following images:
a. 320  240 16-bit indexed image
b. 200  100 24-bit color image
758
CHAPTER 14 Image Processing Basics

14.3. Given a pixel in an RGB image
R ¼ 200; G ¼ 120; B ¼ 100
convert the RGB values to YIQ values.
14.4. Given a pixel of an image in YIQ color format
Y ¼ 141; I ¼ 46; Q ¼ 5
convert the YIQ values back to RGB values.
14.5. Given the 2  2 RGB image,
R ¼
"
100
50
100
50
#
G ¼
"
20
40
10
30
#
B ¼
"
100
50
200
150
#
convert the image into grayscale.
14.6. Produce a histogram of the following image, which has a grayscale value ranging from 0 to
7, that is, each pixel is encoded in 3 bits.
2
66664
0
1
2
2
0
2
1
1
2
1
1
1
4
2
3
0
2
5
6
1
3
77775
14.7. Consider the following image with a grayscale value ranging from 0 to 7, that is, each pixel
is encoded in 3 bits:
2
66664
0
1
2
2
0
2
1
1
2
1
1
1
4
2
3
0
2
5
6
1
3
77775
Perform equalization using the histogram in Problem 14.6, and plot the histogram for the
equalized image.
14.8. Consider the following image with a grayscale value ranging from 0 to 7, that is, each pixel
is encoded in 3 bits:
2
66664
2
4
4
2
2
3
3
3
4
4
4
2
3
2
3
4
3
77775
Perform level adjustment to the full range, shift the level to the range from 3 to 7, and shift the
level to the range from 0 to 3.
14.11 Summary
759

14.9. Consider the following 8-bit grayscale original and noisy images and 2  2 convolution
average kernel:
4  4 original image:
2
66664
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
3
77775
4  4 corrupted image:
2
66664
93
116
109
96
92
107
103
108
84
107
86
107
87
113
106
99
3
77775
2  2 average kernel: 1
4
"
1
1
1
1
#
Perform digital ﬁltering on the noisy image, and compare the enhanced image with the original
image.
14.10. Consider the following 8-bit grayscale original and noisy image, and 3  3 median ﬁlter
kernel:
4  4 original image:
2
66664
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
3
77775
4  4 corrupted image by impulse noise:
2
66664
100
255
100
100
0
255
255
100
100
0
100
0
100
255
100
100
3
77775
3  3 average kernel:
2
64
3
75
Perform digital ﬁltering, and compare the ﬁltered image with the original image.
760
CHAPTER 14 Image Processing Basics

14.11. Given the 8-bit 5  4 original grayscale image
2
6666664
110
110
110
110
110
100
100
110
110
100
100
110
110
110
110
110
110
110
110
110
3
7777775
apply the following edge detectors to the image:
a. Sobel vertical edge detector
b. Laplacian edge detector
Scale the resultant image pixel value to the range of 0 to 255.
14.12. In Example 14.10, if we switch the transformation functions between the red function and
the green function, what is the expected color for the area pointed to by the arrow, and what
is the expected background color?
14.13. In Example 14.10, if we switch the transformation functions between the red function and
the blue function, what is the expected color for the area pointed to by the arrow, and what is
the expected background color?
14.14. Consider the following grayscale image pði; jÞ:
2
64
100
50
10
100
80
100
50
50
40
3
75
Determine the 2D-DFT coefﬁcient Xð1; 2Þ and the magnitude spectrum Að1; 2Þ.
14.15. Consider the following grayscale image pði; jÞ:
"
10
100
200
150
#
Determine the 2D-DFT coefﬁcients Xðu; vÞ and magnitude Aðu; vÞ.
14.16. Consider the following grayscale image pði; jÞ:
"
10
100
200
150
#
Apply the 2D-DCT to determine the DCT coefﬁcients.
14.17. Consider the following DCT coefﬁcients Fðu; vÞ:
"
200
10
10
0
#
14.11 Summary
761

Apply the inverse 2D-DCT to determine the 2D data.
14.18. In JPEG compression, DCT DC coefﬁcients from several blocks are 400, 390, 350, 360, and
370. Use DPCM to produce the DPCM sequence, and use the Huffman table to encode the
DPCM sequence.
14.19. In JPEG compression, DCT coefﬁcients from the an image subblock are
½175; 2; 0; 0; 0; 4; 0; 0 ; 3 7; 0; 0; 0; 0; 2; 0; 0; .; 0
a. Generate the run-length codes for AC coefﬁcients.
b. Perform entropy coding for the run-length codes using the Huffman table.
14.20. Consider the following grayscale image pði; jÞ:
"
10
100
200
150
#
Apply the 2D-DWT using the Haar wavelet to determine the level-1 DWT coefﬁcients.
14.21. Consider the following level-1 IDWT coefﬁcients Wðu; vÞ obtained using the Haar wavelet:
"
200
10
10
0
#
Apply the IDWT to determine the 2D data.
14.22. Consider the following grayscale image pði; jÞ:
2
66664
100
150
60
80
80
90
50
70
110
120
100
80
90
50
40
90
3
77775
Apply the 2D-DWT using the Haar wavelet to determine the level-1 DWT coefﬁcients.
14.23. Consider the following level-1 IDWT coefﬁcients Wðu; vÞ obtained using the Haar wavelet:
2
66664
250
50
30
20
30
20
10
20
10
20
0
0
20
15
0
0
3
77775
Apply the IDWT to determine the 2D data.
14.24. Explain the difference between horizontal retrace and vertical retrace. Which one would
take more time?
762
CHAPTER 14 Image Processing Basics

14.25. What is the purpose of using interlaced scanning in a traditional NTSC TV system?
14.26. What is the bandwidth in the traditional NTSC TV broadcast system? What is the band-
width to transmit luminance Y, and what are the required bandwidths to transmit Q and I
channels, respectively?
14.27. What type of modulation is used for transmitting audio signals in the NTSC TV system?
14.28. Given the composite NTSC signal
Composite ¼ Y þ C ¼ Y þ I cos ð2pfsctÞ þ Q sin ð2pfsctÞ
show demodulation for the Q channel.
14.29. Where does the color subcarrier burst reside? What is the frequency of the color subcarrier,
and how many cycles does the color burst have?
14.30. Compare differences of the NTSC, PAL and SECAM video systems in terms of the number
of scan lines, frame rates, and total bandwidths required for transmission.
14.31. In the NTSC TV system, what is the horizontal line scan rate? What is the vertical
synchronizing pulse rate?
14.32. Explain which of the following digital video formats achieves the most data transmission
efﬁciency:
a. 4:4:4
b. 4:2:2
c. 4:2:0
14.33. What is the difference between interlaced scan and progressive scan? Which of the
following video systems use progressive scan?
a. CCIR-601
b. CIF
14.34. In motion compensation, which of the following would require more computation? Explain.
a. Finding the motion vector using sequential search
b. Recovering the target frame with the motion vectors and reference frame
14.35. Given a reference frame and target frame of size 80  80, a macroblock size of 16  16, and
a search window size of 32  32, estimate the number of subtractions, absolute value
calculations, and additions for searching all the motion vectors using the sequential search
method.
14.12.1 MATLAB Problems
Use MATLAB to solve Problems 14.36 to 14.42.
14.36. Given the image data “trees.jpg”, use MATLAB functions to perform each of the following
processes:
a. Use MATLAB to read and display the image.
b. Convert the image to grayscale.
14.11 Summary
763

c. Perform histogram equalization for the grayscale image in (b) and display the histogram
plots for both the original grayscale image and equalized grayscale image.
d. Perform histogram equalization for the color image in (a) and display the histogram plots
of the Y channel for both the original color image and equalized color image.
14.37. Given the image data “cruise.jpg”, perform the following linear ﬁltering:
a. Convert the image to grayscale and then create an 8-bit noisy image by adding Gaussian
noise using the following code:
noise image
imnoise(I,’gaussian’);
where I is the intensity image obtained from normalizing the grayscale image.
b. Process the noisy image using a Gaussian ﬁlter with the following parameters:
convolution kernel size ¼ 4, SIGMA ¼ 0.8. Compare the ﬁltered image with the noisy
image.
14.38. Given the image data “cruise.jpg”, perform the following ﬁltering process:
a. Convert the image to grayscale and then create an 8-bit noisy image by adding “pepper
and salt” noise using the following code:
noise image
imnoise(I,’salt & pepper’);
where I is the intensity image obtained from normalizing the grayscale image.
b. Process the noisy image using median ﬁltering with a convolution kernel size of 4  4.
14.39. Given the image data “cruise.jpg”, convert the image to the grayscale and detect the image
boundaries using Laplacian of Gaussian ﬁltering with the following parameters:
a. Kernel size ¼ 4 and SIGMA ¼ 0.9
b. Kernel size ¼ 10 and SIGMA ¼ 10
Compare the results.
14.40. Given the image data “clipim2.gif’, perform the following process:
a. Convert the indexed image to grayscale.
b. Adjust the color transformation functions (sine functions) to make the object indicated
by the arrow in the image red and the background color green.
14.41. Given the image data “cruiseorg.tiff”, perform JPEG compression by completing the
following steps:
a. Convert the image to grayscale.
b. Write a MATLAB program for encoding with the following features: (1) divide the
image into 8  8 blocks; (2) transform each block using the discrete-cosine transform;
(3) scale and round DCT coefﬁcients with the standard quality factor. Note that using
lossless compression with the quantized DCT coefﬁcients is omitted here for a simple
simulation.
764
CHAPTER 14 Image Processing Basics

c. Continue and write a MATLAB program for decoding with the following features: (1)
invert the scaling process for quantized DCT coefﬁcients; (2) perform the inverse DCT
for each 8  8 image block; (3) recover the image.
d. Run the developed MATLAB program to examine the image quality using
I. The quality factor
II. The quality factor  5
III. The quality factor  10
14.42. Given the image data “cruiseorg.tiff”, perform wavelet-based compression by completing
the following steps:
a. Convert the image to grayscale.
b. Write a MATLAB program for encoding with the following features: (1) use an 8-tap
Daubechies ﬁlter; (2) apply the two-level DWT; (3) perform 8-bit quantization for
subbands LL2, LH2, HL2, HH2, LH1, HL1, and HH1 for simulation.
c. Write the MATLAB program for the decoding process.
d. Run the developed MATLAB program to examine the image quality using the following
methods:
I. Reconstruct the image using all subband coefﬁcients.
II. Reconstruct the image using LL2 subband coefﬁcients.
III. Reconstruct the image using LL2, HL2, LH2, and HH2 subband coefﬁcients.
IV. Reconstruct the image using LL2, HL2, and LH2 subband coefﬁcients.
V. Reconstruct the image using LL2, HL2, LH2, HH2, LH1, and HL1 subband
coefﬁcients.
14.11 Summary
765

This page intentionally left blank

Appendix A: Introduction to the MATLAB
Environment
Matrix Laboratory (MATLAB) is used extensively in this book for simulations. The goal here is to help
students acquire familiarity with MATLAB and build basic skills in the MATLAB environment.
Hence, Appendix A serves the following objectives:
1. Learn to use the help system to study basic MATLAB commands and syntax.
2. Learn array indexing.
3. Learn basic plotting utilities.
4. Learn to write script m-ﬁles.
5. Learn to write functions in MATLAB.
A.1 BASIC COMMANDS AND SYNTAX
MATLAB has an accessible help system through the help command. By issuing the MATLAB help
command following the topic or function (routine), MATLAB will return information on the topic and
show how to use the function. For example, by entering help sum at the MATLAB prompt, we see
information (listed partially here) on how to use the function sum().
» help sum
SUM
Sum of the elements.
For vectors, SUM(X) is the sum of the elements of X.
For matrices, SUM(X) is a row vector with the sum over
each column.
»
The following examples are given to demonstrate the usage of sum():
» x [ 1 2 3 1.5
1.5
2];
% Initialize an array
» sum(x)
% Call MATLAB function sum
ans
4
% Display the result
»
» x [1 2 3;
1.5 1.5 2.5; 4 5 6] % Initialize 3  3 matrix
x
% Display the contents of 3  3 matrix
1.0000 2.0000 3.0000
1.5000 1.5000 2.5000
4.0000 5.0000 6.0000
http://dx.doi.org/10.1016/B978-0-12-415893-1.15001-2
767

» sum(x)
% Call MATLAB function sum
ans
3.5000 8.5000 11.5000
% Display the results
»
MATLAB can be used like a calculator to work with numbers, variables, and expressions in the
command window. The following are basic syntax examples:
» sin(pi/4)
ans
0.7071
» pi*4
ans
12.5664
In MATLAB, variable names can store values, vectors and matrices. See the following
examples.
» x cos(pi/8)
x
0.9239
» y sqrt(x) 2^2
y
3.0388
» z [1
2 1 2]
z
1
2 1 2
» zz [1 2 3; 4 5 6]
zz
1 2 3
4 5 6
Complex numbers are natural in MATLAB. See the following examples.
» z 3+4i
% Complex number
z
3.0000 + 4.0000i
» conj(z)
% Complex conjugate of z
ans
3.0000
4.0000i
» abs(z)
% Magnitude of z
ans
5
» angle(z)
% Angle of z (radians)
ans
768
APPENDIX A: Introduction to the MATLAB Environment

0.9273
» real(z)
% Real part of a complex number z
ans
3
» imag(z)
% Imaginary part of a complex number z
ans
4
» exp(j*pi/4)
% Polar form of a complex number
ans
0.7071 + 0.7071i
The following shows examples of array operations. Krauss, Shure, and Little (1994) and Stearns
(2003) give detailed explanation for each operation.
» x [1 2; 3 4]
% Initialize 2  2 matrixes
x
1 2
3 4
» y [ 4 3;
2 1]
y
4 3
2 1
» x+y
% Add two matrixes
ans
3 5
1 5
» x*y
% Matrix product
ans
8 5
20 13
» x.*y
% Array element product
ans
4 6
6 4
» x'
% Matrix transpose
ans
1 3
2 4
» 2.^x
% Exponentiation: matrix x contains each exponent
ans
2 4
8 16
APPENDIX A: Introduction to the MATLAB Environment
769

» x.^3
% Exponentiation: power of 3 for each element in matrix x
ans
1 8
27 64
» y.^x
% Exponentiation: each element in y has a power
% specified by a corresponding element in matrix x
ans
4 9
8 1
» x [0 1 2 3 4 5 6]
% Initialize a row vector
x
0 1 2 3 4 5 6
» y x.*x 2*x
% Use array element product to compute a quadratic function
y
0
1 0 3 8 15 24
» z [1 3]'
% Initialize a column vector
z
1
3
» w x\z
% Invert matrix x, then multiply it by the column vector z
w
1
0
A.2 MATLAB ARRAYS AND INDEXING
Let us look at the syntax to create an array as follows:
Basic syntax:
x
begin: step: end
An array x is created with the ﬁrst element value of begin. The value increases by a value of step
for the next element in the array and stops when the next stepped value is beyond the speciﬁed end
value of end. In simulation, we may use this operation to create the sample indexes or array of time
instants for digital signals. The begin, step, and end can be assigned to integers or ﬂoating-point
numbers.
The following examples are given for illustrations:
» n 1:3:8
% Create a vector n [1 4 7]
n
1 4 7
» m 9: 1:2
% Create a vector m [9 8 7 6 5 4 3 2 ]
m
9 8 7 6 5 4 3 2
770
APPENDIX A: Introduction to the MATLAB Environment

» x 2:(1/4):4
% Create x [2 2.25 2.5 2.75 3 3.25 3.5 3.75 4]
x
Columns 1 through 7
2.0000 2.2500 2.5000 2.7500 3.0000 3.2500 3.5000
Columns 8 through 9
3.7500 4.0000
» y 2: 0.5: 1
% Create y [2 1.5 1 0.5 0
0.5
1]
y
2.0000 1.5000 1.0000 0.5000 0
0.5000
1.0000
Next, we examine creating a vector and extracting numbers in a vetcor:
» xx
[ 1 2 3 4 5 [5: 1:1] ]
% Create xx [ 1 2 3 4 5 5 4 3 2 1]
xx
1 2 3 4 5 5 4 3 2 1
» xx(3:7)
% Show elements to 7, that is, [3 4 5 5 4]
ans
3 4 5 5 4
» length(xx)
% Return of the number of elements in vetcor xx
ans
10
» yy xx(2:2:length(xx))
% Display even indexed numbers in array xx
yy
2 4 5 3 1
A.3 PLOT UTILITIES: SUBPLOT, PLOT, STEM, AND STAIR
The following are common MATLAB plot functions for digital signal processing (DSP)
simulation:
subplot opens subplot windows for plotting.
plot produces an x y plot. It can also create multiple plots.
stem produces discrete-time signals.
stair produces staircase (sample-and-hold) signals.
The following program contains different MATLAB plot functions:
t 0:0.01:0.4;
% Create time vector for time instants from 0 to 0.4 second
xx 4.5*sin(2*pi*10*t+pi/4); % Calculate a sine function with a frequency of 10 Hz
yy 4.5*cos(2*pi*5*t pi/3); % Calculate cos function with a frequency of 5 Hz
subplot(4,1,1), plot(t,xx);grid
% Plot a sine function in window 1
subplot(4,1,2), plot(t,xx, t,yy, ’
. ’ ) ;grid; % Plot sine and cos functions in window 2
subplot(4,1,3), stem(t,xx);grid
% Plot a sine function in the discrete time form
subplot(4,1,4), stairs(t,yy);grid
% Plot a cos function in the sample and hold form
xlabel( ‘ Time (sec.) ’ );
Each plot is shown in Figure A.1. Notice that dropping the semicolon at the end of the MATLAB
syntax will display values on the MATLAB prompt.
APPENDIX A: Introduction to the MATLAB Environment
771

A.4 MATLAB SCRIPT FILES
We can create a MATLAB script ﬁle using the built-in MATLAB editor (or Windows Notepad) to write
MATLAB source code. The script ﬁle is named “ﬁlename.m” and can be run by typing the ﬁle name at
the MATLAB prompt and hitting the return key. The script ﬁle test.m is described here for illustration.
Figure A.2 illustrates the plot produced by test.m.
At MATLAB prompt, run the program
>>which test
% show the folder where test.m resides
Go to the folder that contains test.m, and run your script from MATLAB.
>>test
% run the test.m
>>type test
% display the contents of test.m
test.m
t 0:0.01:1;
x sin(2*pi*2*t);
y 0.5*cos(2*pi*5*t pi/4);
plot(t,x), grid on
title( ‘ Test plots of sinusoids ’ )
ylabel( ‘ Signal amplitudes ’ );
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
-5
0
5
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
-5
0
5
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
-5
0
5
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
-5
0
5
Time (sec.)
FIGURE A.1
Illustration for the MATLAB plot functions.
772
APPENDIX A: Introduction to the MATLAB Environment

xlabel( ‘ Time (sec.) ’ ); hold on
plot(t,y, ’
. ’ );
A.5 MATLAB FUNCTIONS
A MATLAB function is often used to replace the repetitive portions of MATLAB code. It is
created using a MATLAB script ﬁle. However, the code begins with the keyword function,
followed by the function declaration, comments for the help system, and program code.
A function sumsub.m that computes the addition and subtraction of two numbers is listed here
for illustration.
sumsub.m
function [sum, sub] sumsub(x1,x2)
%sumsub: Function to add and subtract two numbers
% Usage:
% [sum, sub]
sumsub(x1,x2)
% x1
the first number
% x2
the second number
% sum
x1+x2;
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
1
0.8
0.6
0.4
0.2
0
0.2
0.4
0.6
0.8
1
S gna  amp tudes
Time (sec.)
Test plots of sinusoids
FIGURE A.2
Illustration of MATLAB script ﬁle test.m.
APPENDIX A: Introduction to the MATLAB Environment
773

% sub
x1 x2
sum
x1+x2;
% Add two numbers
sub
x1 x2;
% Subtract x2 from x1
To use the MATLAB function, go to the folder that contains sumsub.m. At the MATLAB prompt,
try the following:
» help sumsub
% Display usage information on MATLAB prompt
sumsub: Function to add and subtract two numbers
usage:
[sum, sub]
sumsub(x1,x2)
x1
the first number
x2
the second number
sum
x1+x2;
sub
x1 x2
Run the function as follows:
» [x1, x2] sumsub(3, 4 3i);
% Call function sumsub
» x1
% Display the result of sum
x1
7.0000
3.0000i
» x2
% Display the result of subtraction
x2
1.0000 + 3.0000i
MATLAB functions can also be used inside an m-ﬁle. More MATLAB exercises for introduction to
DSP can be explored in McClellan, Schafer, and Yoder (1998) and Stearns (2003).
774
APPENDIX A: Introduction to the MATLAB Environment

Appendix B: Review of Analog Signal
Processing Basics
B.1 FOURIER SERIES AND FOURIER TRANSFORM
Electronics applications require familiarity with some periodic signals such the square wave, rect-
angular wave, triangular wave, sinusoid, sawtooth wave, and so on. These periodic signals can be
analyzed in the frequency domain with the help of the Fourier series expansion. According to Fourier
theory, a periodic signal can be represented by a Fourier series that contains the sum of a series of sine
and/or cosine functions (harmonics) plus a direct current (DC) term. There are three forms of Fourier
series: (1) sine-cosine, (2) amplitude-phase, and (3) complex exponential. We will review each of them
individually in the following text. Comprehensive treatments can be found in Ambardar (1999),
Soliman and Srinath (1998), and Stanley (2003).
B.1.1 Sine-Cosine Form
The Fourier series expansion of a periodic signal xðtÞ with a period of T via the sine-cosine form is
given by
x

t

¼ a0 þ
X
N
n ¼ 1
an cos ðnu0tÞ þ
X
N
n ¼ 1
bn sin ðnu0tÞ
(B.1)
where u0 ¼ 2p=T0 is the fundamental angular frequency in radians per second, while the funda-
mental frequency in terms of Hz is f0 ¼ 1=T0. The Fourier coefﬁcients of a0, an, and bn may be found
according to the following integral equations:
a0 ¼ 1
T0
Z
T0
xðtÞdt
(B.2)
an ¼ 2
T0
Z
T0
xðtÞ cos ðnu0tÞdt
(B.3)
bn ¼ 2
T0
Z
T0
xðtÞ sin ðnu0tÞdt
(B.4)
Notice that the integral is performed over one period of the signal to be expanded. From Equation
(B.1), the signal xðtÞ consists of a DC term and sums of sine and cosine functions with their corre-
sponding harmonic frequencies. Again, note that nu0 is the nth harmonic frequency.
http://dx.doi.org/10.1016/B978-0-12-415893-1.15002-4
775

B.1.2 Amplitude-Phase Form
From the sine-cosine form, we notice that there is a sum of two terms with the same frequency. The
term in the ﬁrst sum is an cos ðnu0tÞ while the other is bn sin ðnu0tÞ. We can combine these two terms
and modify the sine-cosine form into the amplitude-phase form:
x

t

¼ A0 þ
X
N
n ¼ 1
An cos ðnu0t þ fnÞ
(B.5)
The DC term is same as before, that is,
A0 ¼ a0
(B.6)
and the amplitude and phase are given by
An ¼
a2n þ b2n
q
(B.7)
fn ¼ tan 1
bn
an

(B.8)
respectively. The amplitude-phase form provides very useful information for spectral analysis. With
the calculated amplitude and phase for each harmonic frequency, we can create the spectral plots. One
depicts a plot of the amplitude versus its corresponding harmonic frequency (the amplitude spectrum),
while the other plot shows each phase versus its harmonic frequency (the phase spectrum). Note that
the spectral plots are one-sided, since amplitudes and phases are plotted versus the positive harmonic
frequencies. We will illustrate these in Example B.1.
B.1.3 Complex Exponential Form
The complex exponential form is developed based on expanding sine and cosine functions in the sine-
cosine form into their exponential expressions using Euler’s formula and regrouping these exponential
terms. Euler’s formula is given by
ejx ¼ cos

x

 j sin

x

which can be written as two separate forms:
cos

x

¼ ejx þ e jx
2
sin

x

¼ ejx  e jx
2j
We will focus on interpretation and application rather than the derivation of this form. Thus the
complex exponential form is expressed as
x

t

¼
X
N
n ¼
N
cnejnu0t
(B.9)
776
APPENDIX B: Review of Analog Signal Processing Basics

where cn represents the complex Fourier coefﬁcients, which may be found from
cn ¼ 1
T0
Z
T0
x

t

e jnu0tdt
(B.10)
The relationship between the complex Fourier coefﬁcients cn and the coefﬁcients of the sine-cosine
form are
c0 ¼ a0
(B.11)
cn ¼ an  jbn
2
;
for
n > 0
(B.12)
Considering a real signal x(t) (x(t) is not a complex function) in Equation (B.10), c n is equal to the
complex conjugate of cn, that is, cn. It follows that
c n ¼ cn ¼ an þ jbn
2
;
for
n > 0
(B.13)
Since cn is a complex value that can be written in the magnitude-phase form, we obtain
cn ¼ jcnj:fn
(B.14)
where jcnj is the magnitude and fn is the phase of the complex Fourier coefﬁcient. Similar to the
magnitude-phase form, we can create the spectral plots for jcnj and fn. Since the frequency index n
goes from N to N, the plots of the resultant spectra are two-sided.
EXAMPLE B.1
Consider the square waveform x(t) shown in Figure B.1, where T0 represents a period. Find the Fourier series
expansions in terms of (a) the sine cosine form, (b) the amplitude phase form, and (c) the complex exponential form.
Solution:
From Figure B.1, we notice that T0
1 second and A
10. The fundamental frequency is
f0
1=T0
1 Hz
or
u0
2p  f0
2p rad=sec
a. Using Equations (B.1) to (B.3) yields
a0
1
T0
Z
T0=2
T0=2
x

t

dt
1
1
Z0:25
0:25
10dt
5
an
2
T0
Z
T0=2
T0=2
xðtÞ cos ðnu0tÞdt
2
1
Z0:25
0:25
10 cos ðn2ptÞdt
2
1
10  sin ðn2ptÞ
n2p

0:25
0:25
10 sin ð0:5pnÞ
0:5pn
APPENDIX B Review of Analog Signal Processing Basics
777

FIGURE B.1
Square waveform in Example B.1.
bn
2
T0
Z
T0=2
T0=2
xðtÞ sin ðnu0tÞdt
2
1
Z0:25
0:25
10  sin ðn2ptÞdt
2
1
10 cos ðn2ptÞ
n2p

0:25
0:25
0
Thus, the Fourier series expansion in terms of the sine cosine form is written as
x

t

5 þ
X
N
n
1
10 sin ð0:5pnÞ
0:5pn
cos

n2pt

5 þ 20
p cos

2pt

20
3p cos

6pt

þ 4
p cos

10pt

20
7p cos

14pt

þ /
b. Making use of the relations between the sine cosine form and the amplitude phase form, we obtain
A0
a0
5
An
a2n þ b2n
q
janj
10 

sin ð0:5pnÞ
0:5pn

Again, noting that
cos ðxÞ
cos ðx þ 180
Þ, the Fourier series expansion in terms of the amplitude phase form
is
x

t

5 þ 20
p cos

2pt

þ 20
3p cos

6pt þ 180

þ 4
p cos

10pt

þ 20
7p cos

14pt þ 180

þ /
c. First let us ﬁnd the complex Fourier coefﬁcients using the formula, that is,
cn
1
T0
Z
T0=2
T0=2
x

t

ejnu0tdt
1
1
Z0:25
0:25
Aejn2ptdt
10 ejn2pt
jn2p

0:25
0:25
10 

ej0:5pn
ej0:5pn
jn2p
778
APPENDIX B: Review of Analog Signal Processing Basics

Applying Euler’s formula yields
cn
10  cos 0:5pn
j sin ð0:5pnÞ
½cos ð0:5pnÞ þ j sin ð0:5pnÞ
jn2p
5 sin ð0:5pnÞ
0:5pn
Second, using the relationship between the sine cosine form and the complex exponential form, it follows that
cn
an
jbn
2
an
2
5 sin ð0:5npÞ
ð0:5npÞ
Certainly, the result is identical to the one obtained directly from the formula. Note that c0 cannot be evaluated
directly by substituting n
0, since we have the indeterminate term 0
0. Using L’Hospital’s rule, described in
Appendix G, leads to
c0
lim
n/0 5 sin ð0:5npÞ
ð0:5npÞ
lim
n/0 5
dðsin ð0:5npÞÞ
dn
dð0:5npÞ
dn
lim
n/0 5 0:5p cos ð0:5npÞ
0:5p
5
Finally, the Fourier expansion in terms of the complex exponential form is shown as follows:
x

t

/ þ 10
p ej2pt þ 5 þ 10
p ej2pt
10
3p ej6pt þ 2
p ej10pt
10
7p ej14pt þ /
B.1.4 Spectral Plots
As previously discussed, the magnitude-phase form can provide information to create a one-sided
spectral plot. The amplitude spectrum is obtained by plotting An versus the harmonic frequency nu0,
and the phase spectrum is obtained by plotting fn versus nu0, both for n  0. Similarly, if the complex
exponential form is used, the two-sided amplitude and phase spectral plots of jcnj and fn versus nu0
for N < n < N can be achieved, respectively. We illustrate this by the following example.
EXAMPLE B.2
Based on the solution to Example B.1, plot the one sided amplitude spectrum and two sided amplitude spectrum,
respectively.
Solution:
Based on the solution for An, the one sided amplitude spectrum is shown in Figure B.2.
FIGURE B.2
One-sided spectrum of the square waveform in Example B.2.
APPENDIX B Review of Analog Signal Processing Basics
779

According to the solution of the complex exponential form, the two sided amplitude spectrum is demonstrated
in Figure B.3.
A general pulse train xðtÞ with a period T0 seconds and a pulse width s seconds is shown in Figure B.4.
The Fourier series expansions for sine-cosine and complex exponential forms can be derived
similarly and are given as follows:
Sine-cosine form:
x

t

¼ sA
T0
þ 2sA
T0
sinðu0s=2Þ
ðu0s=2Þ
cos

u0t

þ sinð2u0s=2Þ
ð2u0s=2Þ
cos

2u0t

þ sinð3u0s=2Þ
ð3u0s=2Þ
cos

3u0t

þ /

(B.15)
Complex exponential form:
x

t

¼ / þ sA
T0
sinðu0s=2Þ
ðu0s=2Þ
e ju0t þ sA
T0
þ sA
T0
sinðu0s=2Þ
ðu0s=2Þ
eju0t þ sA
T0
sinð2u0s=2Þ
ð2u0s=2Þ
ej2u0t þ /
(B.16)
where u0 ¼ 2pf0 ¼ 2p=T0 is the fundamental angle frequency of the periodic waveform. The reader
can derive the one-sided amplitude spectrum An and the two-sided amplitude spectrum jcnj. The
expressions for the one-sided amplitude and two-sided amplitude spectra are given by the following:
A0 ¼ s
T0
A
(B.17)
FIGURE B.3
Two-sided spectrum of the square waveform in Example B.2.
FIGURE B.4
Rectangular waveform (pulse train).
780
APPENDIX B: Review of Analog Signal Processing Basics

An ¼ 2s
T0
A

sinðnu0s=2Þ
ðnu0s=2Þ
;
for
n ¼ 1; 2; 3.
(B.18)
jcnj ¼ s
T0
A

sinðnu0s=2Þ
ðnu0s=2Þ
;
N < n < N
(B.19)
EXAMPLE B.3
In Figure B.4, if T0
1 ms, s
0:2 ms, and A
10, use Equations (B.17) to (B.19) to derive the amplitude
one sided spectrum and two sided spectrum for each of the ﬁrst four harmonic frequency components.
Solution:
The fundamental frequency is
u0
2pf0
2p  ð1=0:001Þ
2; 000p rad=sec
Using Equations (B.17) and (B.18) yields the one sided spectrum as
A0
s
T0
A
0:0002
0:001  10
2;
for
n
0; nu0
0
For n
1, nu0
2; 000p rad/sec:
A1
2  0:0002
0:001
 10 

sin ð1  2; 000p  0:0002=2Þ
ð1  2; 000p  0:0002=2Þ

4 sin ð0:2pÞ
ð0:2pÞ
3:7420
For n
2, nu0
4; 000p rad/sec:
A2
2  0:0002
0:001
 10 

sin ð2  2; 000p  0:0002=2Þ
ð2  2; 000p  0:0002=2Þ

4 sin ð0:4pÞ
ð0:4pÞ
3:0273
For n
3, nu0
6; 000p rad/sec:
A3
2  0:0002
0:001
 10 

sin ð3  2; 000p  0:0002=2Þ
ð3  2; 000p  0:0002=2Þ

4 sin ð0:6pÞ
ð0:6pÞ
2:0182
For n
4, nu0
8; 000p rad/sec:
A4
2  0:0002
0:001
 10 

sin ð4  2; 000p  0:0002=2Þ
ð4  2; 000p  0:0002=2Þ

4 sin ð0:8pÞ
ð0:8pÞ
0:9355
The one sided amplitude spectrum is plotted in Figure B.5.
FIGURE B.5
One-sided spectrum in Example B.3.
APPENDIX B Review of Analog Signal Processing Basics
781

Similarly, applying Equation (B.19) leads to
jc0j
0:0002
0:001  10 
 lim
n/0
sin ðn  2; 000p  0:0002=2Þ
ðn  2; 000p  0:0002=2Þ

2  j1j
2
Note: We use the fact that lim
x/0
sinðxÞ
x
1:0 (see L’Hospital’s rule in Appendix G).
jc1j
jc1j
0:0002
0:001  10 

sin ð1  2; 000p  0:0002=2Þ
ð1  2; 000p  0:0002=2Þ

2 

sin ð0:2pÞ
0:2p

1:8710
jc2j
jc2j
0:0002
0:001  10 

sin ð2  2; 000p  0:0002=2Þ
ð2  2; 000p  0:0002=2Þ

2 

sin ð0:4pÞ
0:4p

1:5137
jc3j
jc3j
0:0002
0:001  10 

sin ð3  2; 000p  0:0002=2Þ
ð3  2; 000p  0:0002=2Þ

2 

sin ð0:6pÞ
0:6p

1:0091
jc4j
jc4j
0:0002
0:001  10 

sin ð4  2; 000p  0:0002=2Þ
ð4  2; 000p  0:0002=2Þ

2 

sin ð0:8pÞ
0:8p

0:4677
Figure B.6 shows the two sided amplitude spectral plot.
The following example illustrates the use of table information to determine the Fourier series
expansion of the periodic waveform. Table B.1 consists of the Fourier series expansions for common
periodic signals in the sine-cosine form while Table B.2 shows the expansions in the complex
exponential form.
FIGURE B.6
Two-sided spectrum in Example B.3.
782
APPENDIX B: Review of Analog Signal Processing Basics

Table B.1 Fourier Series Expansions for Some Common Waveform Signals in the
Sine-Cosine Form
Time Domain Signal xðtÞ
Fourier Series Expansion
x

t

A
2 þ 2A
p

sin u0t þ 1
3 sin 3u0t þ 1
5 sin 5u0t þ 1
7 sin 7u0t þ /

x

t

4A
p

cos u0t
1
3 cos 3u0t þ 1
5 cos 5u0t
1
7 cos 7u0t þ /

x

t

8A
p2

cos u0t þ 1
9 cos 3u0t þ 1
25 cos 5u0t þ 1
49 cos 7u0t þ /

x

t

2A
p

sin u0t
1
2 sin 2u0t þ 1
3 sin 3u0t
1
4 sin 4u0t þ /

x

t

Ad þ 2 Ad
sin pd
pd

cos u0t
þ2Ad
sin 2pd
2pd

cos 2u0t þ 2Ad
sin 3pd
3pd

cos 3u0t þ /
x

t

1
T0
þ 2
T0
ðcos u0t þ cos 2u0t þ cos 3u0t þ cos 4u0t þ /Þ
APPENDIX B Review of Analog Signal Processing Basics
783

TABLE B.2 Fourier Series Expansions for Some Common Waveform Signals in the Complex
Exponential Form
Time Domain Signal xðtÞ
Fourier Series Expansion
x

t


/
A
j3p ej3u0t
A
jp eju0t þ A
2 þ A
jp e ju0t þ A
j3p e j3u0t
þ A
j5p e j5u0t þ /

x

t

2A
p

/ þ 1
5 ej5u0t
1
3 ej3u0t þ eju0t þ e ju0t
1
3 e j3u0t
þ1
5 e j5u0t
/

x

t

4A
p2

/ þ 1
25 ej5u0t þ 1
9 ej3u0t þ eju0t þ e ju0t
þ1
9 e j3u0t þ 1
3 e j5u0t þ /

x

t

A
jp

/
1
3 ej3u0t þ 1
2 ej2u0t
eju0t þ e ju0t
1
2 e j2u0t
þ1
3 e j3u0t þ /

x

t

/ þ Ad
sin pd
pd

eju0t þ Ad
sin pd
pd

e ju0t
þAd
sin 2pd
2pd

e j2u0t þ Ad
sin 3pd
3pd

e j3u0t þ /
x

t

1
T0
ð/ þ ej3u0t þ ej2u0t þ eju0t þ 1 þ e ju0t þ e j2u0t
þe j3u0t þ /

784
APPENDIX B: Review of Analog Signal Processing Basics

EXAMPLE B.4
In the sawtooth waveform shown in Table B.1 and reprinted in Figure B.7, if T0
1 ms and A
10, use the
formula in the table to determine the Fourier series expansion in a magnitude phase form, and determine the
frequency f3 and amplitude value of A3 for the third harmonic. Write the Fourier series expansion in a complex
exponential form also, and determine jc3j and jc3j for the third harmonic.
Solution:
a. Based on the information in Table B.1, we have
x

t

2A
p

sin u0t
1
2 sin 2u0t þ 1
3 sin 3u0t
1
4 sin 4u0t þ /

Since T0
1 ms, the fundamental frequency is
f0
1=T0
1; 000 Hz;
and
u0
2pf0
2; 000p rad=sec
Then, the expansion is determined as
x

t

2  10
p

sin 2; 000pt
1
2 sin 4; 000pt þ 1
3 sin 6; 000pt
1
4 sin 8; 000pt þ /

Using the trigonometric identities
sin x
cos

x
90

and
sin x
cos

x þ 90

and simple algebra, we ﬁnally obtain
x

t

20
p cos

2; 000pt
90

þ 10
p cos

4; 000pt þ 90

þ20
3p cos

6; 000pt
90

þ 5
p cos

8; 000pt þ 90

þ /
From the magnitude phase form, we then determine f3 and A3 as follows:
f3
3  f0
3; 000 Hz;
and
A3
20
3p
2:1221
b. From Table B.2, the complex exponential form is
x

t

10
jp

/
1
3 ej6;000pt þ 1
2 ej4;000pt
ej2;000pt þ ej2;000pt
1
2 ej4;000pt þ 1
3 ej6;000pt þ /

From the expression, we have
FIGURE B.7
Sawtooth waveform for Example B.4.
APPENDIX B Review of Analog Signal Processing Basics
785

jc3j

10
jp  1
3


1:061
j

1:061 and
jc3j

10
jp  1
3


1:061
j

1:061
B.1.5 FOURIER TRANSFORM
The Fourier transform is a mathematical function that provides frequency spectral analysis for
a nonperiodic signal. The Fourier transform pair is deﬁned as
Fourier transform:
XðuÞ ¼
ZN
N
x

t

e jutdt
(B.20)
Inverse Fourier transform:
xðtÞ ¼ 1
2p
ZN
N
XðuÞejutdu
(B.21)
where xðtÞ is a nonperiodic signal and XðuÞ is a two-sided continuous spectrum versus the continuous
frequency variable u, where N < u < N. Again, the spectrum is a complex function that can be
further written as
XðuÞ ¼ jXðuÞj:fðuÞ
(B.22)
where jXðuÞj is the continuous amplitude spectrum, while :fðuÞ designates the continuous phase
spectrum.
EXAMPLE B.5
Let xðtÞ be a single rectangular pulse, shown in Figure B.8, where the pulse width is s
0:5 second. Find its
Fourier transform and sketch the amplitude spectrum.
FIGURE B.8
Rectangular pulse in Example B.5.
786
APPENDIX B: Review of Analog Signal Processing Basics

Solution:
Applying Equation (B.21) and using Euler’s formula, we have
X

u

ZN
N
x

t
	
ejutdt
Z0:25
0:25
10ejudt
10 ejut
ju

0:25
0:25
10 

ej0:25u
ej0:25u
ju
10  cos ð0:25uÞ
j sin ð0:25uÞ
½cos ð0:25uÞ þ j sin ð0:25uÞ
ju
5 sin ð0:25uÞ
0:25u
where the amplitude spectrum is expressed as
jXðuÞj
5 

sin ð0:25uÞ
0:25u

Using u
2pf, we can express the spectrum in terms of Hz as
jXðfÞj
5 

sin ð0:5pfÞ
0:5pf

The amplitude spectrum is shown in Figure B.9. Note that the ﬁrst null point is at u
2p=0:5
4p rad/sec, and
the spectrum is symmetric.
EXAMPLE B.6
Let xðtÞ be an exponential function given by
x

t

10e2tu

t

(
10e2t
t  0
0
t < 0
Find its Fourier transform.
FIGURE B.9
Amplitude spectrum for Example B.5.
APPENDIX B Review of Analog Signal Processing Basics
787

Solution:
According to the deﬁnition of the Fourier transform,
X

u

ZN
0
10e2tu

t

ejutdt
ZN
0
10eð2þjuÞtdt
10eð2þjuÞt
ð2 þ juÞ

N
0
10
2 þ ju
X

u

10
22 þ u2
p
:
tan1u
2
	
Using u
2pf, we get
X

f

10
2 þ j2pf
10
22 þ ð2pfÞ2
q
:
tan1ðpfÞ
The Fourier transforms for some common signals are listed in Table B.3. Some useful properties of
the Fourier transform are summarized in Table B.4.
EXAMPLE B.7
Find the Fourier transforms of the following functions:
a. xðtÞ
dðtÞ, where dðtÞ is an impulse function deﬁned by
d

t

(
s0
t
0
0
elsewhere
with a property given as
ZN
N
fðtÞdðt
sÞdt
fðsÞ
b. xðtÞ
dðt
sÞ
Solution:
a. We ﬁrst use the Fourier transform deﬁnition and then apply the delta function property,
X

u

ZN
N
d

t

ejutdt
ejut
t
0
1
b. Similar to (a), we obtain
788
APPENDIX B: Review of Analog Signal Processing Basics

X

u

ZN
N
d

t
s

ejutdt
ejut
t
s
ejus
Example B.8 shows how to use the table information to determine the Fourier transform of a nonperiodic signal.
Table B.3 Fourier Transforms for Some Common Signals
Time Domain Signal xðtÞ
Fourier Spectrum XðfÞ
X

f

As sin pfs
pfs
X

f

As
sin pfs
pfs
2
X

f

2As
p
 cos pfs
1
4f2s2

X

f

jA
2pf
sin pfs
pfs ejpfs
1

X

f

A
a þ j2pf
XðfÞ
A
APPENDIX B Review of Analog Signal Processing Basics
789

EXAMPLE B.8
Table B.4 Properties of the Fourier Transform
Line
Time Function
Fourier Transform
1
ax1ðtÞ þ bx2ðtÞ
aX1ðfÞ þ bX2ðfÞ
2
dxðtÞ
dt
j2pfXðfÞ
3
Z t
N
xðtÞdt
XðfÞ
j2pf
4
xðt
sÞ
ej2pfsXðfÞ
5
ej2pf0txðtÞ
Xðf
f0Þ
6
xðatÞ
1
aX
f
a

FIGURE B.10
Cosine pulse in Example B.8.
Use Table B.3 to determine the Fourier transform for the cosine pulse in Figure B.10.
Solution:
According to the graph, we can identify
s
2
1 ms; and A
1
s is given by
s
2  1 ms
0:002 second
Applying the formula from Table B.3 gives
X

f

2  10  0:002
p
 cos pf0:002
1
4f 20:0022

0:04
p

cos 0:002pf
1
4  0:0022f 2

790
APPENDIX B: Review of Analog Signal Processing Basics

TABLE B.5 Laplace Transform Table
Line
Time Function xðtÞ
Laplace Transform
XðsÞ [ LðxðtÞÞ
1
dðtÞ
1
2
1 or uðtÞ
1
s
3
tuðtÞ
1
s2
4
eatuðtÞ
1
s þ a
5
sin ðutÞuðtÞ
u
s2 þ u2
6
cos ðutÞuðtÞ
s
s2 þ u2
7
sin ðut þ qÞuðtÞ
s sin ðqÞ þ u cos ðqÞ
s2 þ u2
8
eat sin ðutÞuðtÞ
u
ðs þ aÞ2 þ u2
9
eat cos ðutÞuðtÞ
s þ a
ðs þ aÞ2 þ u2
(continued)
B.2 LAPLACE TRANSFORM
In this section, we will review Laplace transform and its applications.
B.2.1 Laplace Transform and Its Table
The Laplace transform plays an important role in the analysis of continuous signals and systems. We
deﬁne the Laplace transform pairs as
X

s

¼ LfxðtÞg ¼
ZN
0
x

t

e stdt
(B.23)
x

t

¼ L 1fXðsÞg ¼
1
2pj
Z
gþjN
g jN
XðsÞestds
(B.24)
Notice that the symbol Lfg denotes the forward Laplace operation, while the symbol L 1fg indicates
the inverse Laplace operation. Some common Laplace transform pairs are listed in Table B.5.
APPENDIX B Review of Analog Signal Processing Basics
791

In Example B.9, we examine the Laplace transform in light of its deﬁnition.
EXAMPLE B.9
Derive the Laplace transform of the unit step function.
Solution:
By the deﬁnition in Equation (B.23),
X

s

ZN
0
u

t
	
estdt
ZN
0
estdt
est
s

N
0
eN
s
e0
s
1
s
The answer is consistent with the result listed in Table B.5. Now we use the results in Table B.5 to ﬁnd the Laplace
transform of a function.
TABLE B.5 Laplace Transform Table (continued)
Line
Time Function xðtÞ
Laplace Transform
XðsÞ [ LðxðtÞÞ
10

A cos

ut

þ B
aA
u
sin

ut

eatu

t

As þ B
ðs þ aÞ2 þ u2
11a
tnuðtÞ
n!
snþ1
11b
1
ðn
1Þ!tn1u

t

1
sn
12a
eattnuðtÞ
n!
ðs þ aÞnþ1
12b
1
ðn
1Þ!eattn1u

t

1
ðs þ aÞn
13
ð2RealðAÞ cos ðutÞ
2ImagðAÞ sin ðutÞÞeatuðtÞ
A
s þ a
ju þ
A
s þ a þ ju
14
dxðtÞ
dt
sXðsÞ
xð0Þ
15
Z
t
0
xðtÞdt
XðsÞ
s
16
xðt
aÞuðt
aÞ
easXðsÞ
17
eatxðtÞuðtÞ
Xðs þ aÞ
792
APPENDIX B: Review of Analog Signal Processing Basics

EXAMPLE B.10
Perform the Laplace transform for each of the following functions.
a. xðtÞ
5 sin ð2tÞuðtÞ
b. xðtÞ
5e3t cos ð2tÞuðtÞ
Solution:
a. Using line 5 in Table B.5 and noting that u
2, the Laplace transform immediately follows:
XðsÞ
5Lf2 sin ð2tÞuðtÞg
5  2
s2 þ 22
10
s2 þ 4
b. Applying line 9 in Table B.5 with u
2 and a
3 yields
X

s

5L

e3t cos

2t

u

t

5ðs þ 3Þ
ðs þ 3Þ2þ22
5ðs þ 3Þ
ðs þ 3Þ2þ4
B.2.2 Solving Differential Equations Using the Laplace Transform
One of the important applications of the Laplace transform is to solve differential equations. Using the
differential property in Table B.5, we can transform a differential equation from the time domain to the
Laplace domain. This will change the differential equation into an algebraic equation, and we then
solve the algebraic equation. Finally, the inverse Laplace operation is processed to yield the time
domain solution.
EXAMPLE B.11
Solve the following differential equation using the Laplace transform:
dyðtÞ
dt
þ 10y

t

x

t

with an initial condition y

0

0;
where the input xðtÞ
5uðtÞ.
Solution:
Applying the Laplace transform on both sides of the differential equation and using the differential property (line
14 in Table B.5), we get
sY ðsÞ
yð0Þ þ 10Y ðsÞ
XðsÞ
Note that
X

s

Lf5uðtÞg
5
s
Substituting the initial condition yields
Y

s

5
sðs þ 10Þ
APPENDIX B Review of Analog Signal Processing Basics
793

Then we use a partial fraction expansion by writing
Y

s

A
s þ
B
s þ 10
where
A
sY ðsÞjs
0
5
s þ 10

s
0
0:5
and
B
ðs þ 10ÞY ðsÞjs
10
5
s

s
10
0:5
Hence,
Y

s

0:5
s
0:5
s þ 10
y

t

L1
0:5
s

L1
 0:5
s þ 10

Finally, applying the inverse of the Laplace transform leads to using the results listed in Table B.5, and we obtain
the time domain solution as
y

t

0:5u

t

0:5e10tu

t

B.2.3 Transfer Function
A linear analog system can be described using the Laplace transfer function. The transfer function
relating the input and output of the linear system is depicted as
YðsÞ ¼ HðsÞXðsÞ
(B.25)
where XðsÞ and YðsÞ are the system input and response (output), respectively, in the Laplace domain,
and the transfer function is deﬁned as a ratio of the Laplace response of the system to the Laplace input
given by
H

s

¼ YðsÞ
XðsÞ
(B.26)
The transfer function will allow us to study the system behavior. Considering an impulse function
as the input to a linear system, that is, xðtÞ ¼ dðtÞ, whose Laplace transform is XðsÞ ¼ 1, we then ﬁnd
the system output due to the impulse function to be
YðsÞ ¼ HðsÞXðsÞ ¼ HðsÞ
(B.27)
794
APPENDIX B: Review of Analog Signal Processing Basics

Therefore, the response in the time domain yðtÞ is called the impulse response of the system and can be
expressed as
h

t

¼ L 1fHðsÞg
(B.28)
The analog impulse response can be sampled and transformed to obtain a digital ﬁlter transfer
function. This topic is covered in Chapter 8.
EXAMPLE B.12
Consider a linear system described by the differential equation shown in Example B.11. xðtÞ and yðtÞ designate
the system input and system output, respectively. Derive the transfer function and the impulse response of the
system.
Solution:
Taking the Laplace transform on both sides of the differential equation yields
L
dyðtÞ
dt

þ Lf10yðtÞg
LfxðtÞg
Applying the differential property and substituting the initial condition, we have
Y ðsÞðs þ 10Þ
XðsÞ
Thus, the transfer function is given by
H

s

Y ðsÞ
XðsÞ
1
s þ 10
The impulse response can be found by taking the inverse Laplace transform as
h

t

L1

1
s þ 10

e10tu

t

B.3 POLES, ZEROS, STABILITY, CONVOLUTION, AND SINUSOIDAL
STEADY-STATE RESPONSE
This section is a review of analog system analysis.
B.3.1 Poles, Zeros, and Stability
To study system behavior, the transfer function is written in a general form given by
H

s

¼ NðsÞ
DðsÞ ¼ bmsm þ bm 1sm 1 þ / þ b0
ansn þ an 1sn 1 þ / þ a0
(B.29)
APPENDIX B Review of Analog Signal Processing Basics
795

It is a ratio of the numerator polynomial of degree m to the denominator polynomial of degree n. The
numerator polynomial is expressed as
N

s

¼ bmsm þ bm 1sm 1 þ / þ b0
(B.30)
while the denominator polynomial is given by
D

s

¼ ansn þ an 1sn 1 þ / þ a0
(B.31)
Again, the roots of NðsÞ are called zeros, while the roots of DðsÞ are called poles of the transfer
function HðsÞ. Notice that zeros and poles could be real numbers or complex numbers.
Given a system transfer function, the poles and zeros can be found. Further, a pole-zero plot could
be created on the s-plane. With the pole-zero plot, the stability of the system is determined by the
following rules:
1. The linear system is stable if the rightmost pole(s) is/are on the left-hand half plane (LHHP) on the
s-plane.
2. The linear system is marginally stable if the rightmost pole(s) is/are simple-order (ﬁrst-order) on
the ju axis, including the origin on the s-plane.
3. The linear system is unstable if the rightmost pole(s) is/are on the right-hand half plane (RHHP) of
the s-plane or if the rightmost pole(s) is/are multiple-order on the ju axis on the s-plane.
4. Zeros do not affect system stability.
EXAMPLE B.13
Determine whether each of the following transfer functions is stable, marginally stable, and unstable:
a. H

s

s þ 1
ðs þ 1:5Þðs2 þ 2s þ 5Þ
b. H

s

ðs þ 1Þ
ðs þ 2Þðs2 þ 4Þ
c. H

s

s þ 1
ðs
1Þðs2 þ 2s þ 5Þ
Solution:
a. A zero is found at s
1. The poles are calculated as s
1:5, s
1 þ j2, s
1
j2. The pole zero
plot is shown in Figure B.11A. Since all the poles are located on the LHHP, the system is stable.
b. A zero is found at s
1. The poles are calculated as s
2, s
j2, s
j2. The pole zero plot is
shown in Figure B.11B. Since the ﬁrst order poles s
j2 are located on the ju axis, the system is
marginally stable.
c. A zero is found at s
1. The poles are calculated as s
1, s
1 þ j2, s
1
j2. The pole zero plot
is shown in Figure B.11C. Since there is a pole s
1 located on the RHHP, the system is unstable.
796
APPENDIX B: Review of Analog Signal Processing Basics

FIGURE B.11A
Pole-zero plot for (a).
FIGURE B.11B
Pole-zero plot for (b).
FIGURE B.11C
Pole-zero plot for (c).
APPENDIX B Review of Analog Signal Processing Basics
797

B.3.2 Convolution
As we discussed before, the input and output relationship of a linear system in the Laplace domain is
YðsÞ ¼ HðsÞXðsÞ
(B.32)
It is apparent that in the Laplace domain, the system output is the product of the Laplace input and
transfer function. But in the time domain, the system output is given as
yðtÞ ¼ hðtÞ  xðtÞ
(B.33)
where  denotes linear convolution of the system impulse response hðtÞ and the system input xðtÞ. The
linear convolution is further expressed as
y

t

¼
ZN
0
hðsÞx

t  s

ds
(B.34)
EXAMPLE B.14
As you have seen in Examples B.11 and B.12, for a linear system, the impulse response and the input are given,
respectively, by
h

t

e10tu

t

and
x

t

5u

t

Determine the system response yðtÞ using the convolution method.
FIGURE B.12
Convolution illustration for Example B.14.
798
APPENDIX B: Review of Analog Signal Processing Basics

Solution:
Two signals hðsÞ and xðsÞ that are involved in the convolution integration are displayed in Figure B.12. To evaluate
the convolution, the time reversed signal xð sÞ and the shifted signal xðt
sÞ are also plotted for reference. Figure
B.12 shows an overlap of hðsÞ and xðt
sÞ. According to the overlapped (shaded) area, the lower limit and the
upper limit of the convolution integral are determined to be 0 and t, respectively. Hence,
y

t

Zt
0
e10s$5ds
5
10e10s

t
0
0:5e10t

0:5e100
Finally, the system response is found to be
y

t

0:5u

t

0:5e10tu

t

The solution is the same as that obtained using the Laplace transform method described in Example B.11.
B.3.3 Sinusoidal Steady-State Response
For linear analog systems, if the input to a system is a sinusoid of radian frequency u, the steady-state
response of the system will also be a sinusoid of the same frequency. Therefore, the transfer function,
which provides the relationship between a sinusoidal input and a sinusoidal output, is called the
steady-state transfer function. The steady-state transfer function is obtained from the Laplace transfer
function by substituting s ¼ ju, as shown in the following:
H

ju

¼ HðsÞjs¼ju
(B.35)
Thus we have a system relationship in a sinusoidal steady state as
YðjuÞ ¼ HðjuÞXðjuÞ
(B.36)
Since HðjuÞ is a complex function, we may write it in the phasor form:
HðjuÞ ¼ AðuÞ:bðuÞ
(B.37)
where the quantity AðuÞ is the amplitude response of the system deﬁned as
AðuÞ ¼ jHðjuÞj
(B.38)
and the phase angle bðuÞ is the phase response of the system. The following example is presented to
illustrate the application.
EXAMPLE B.15
Consider a linear system described by the differential equation shown in Example B.12, where xðtÞ and yðtÞ
designate the system input and system output, respectively. The transfer function has been derived as
H

s

10
s þ 10
APPENDIX B Review of Analog Signal Processing Basics
799

a. Derive the steady state transfer function.
b. Derive the amplitude response and phase response.
c. If the input is given as a sinusoid, that is, xðtÞ
5 sin ð10t þ 30
ÞuðtÞ, ﬁnd the steady state response yssðtÞ.
Solution:
a. By substituting s
ju into the transfer function in terms of a suitable form, we get the steady state transfer
function as
H

ju

1
s
10 þ 1
1
ju
10 þ 1
b. The amplitude response and phase response are found to be
A

u

1
 u
10
	2
þ1
r
b

u

:
tan1 u
10
	
c. When u
10 rad/sec, the input sinusoid can be written in terms of the phasor form as
X

j10

5:30

For the amplitude and phase of the steady state transfer function at u
10, we have
A

10

1
10
10
2
þ1
s
0:7071
b

10

tan1
10
10

45

Hence, we yield
H

j10

0:7071:
45

Using Equation (B.36), the system output in phasor form is obtained as
Y

j10

H

j10

X

j10


1:4141:
45

5:30

Y

j10

3:5355:
15

Converting the output in phasor form back to the time domain results in the steady state system output:
yss

t

3:5355 sin

10t
15

u

t

800
APPENDIX B: Review of Analog Signal Processing Basics

B.4 PROBLEMS
B.1. Develop equations for the amplitude spectra, that is, An (one-sided) and jcnj (two-sided), of
the pulse train xðtÞ displayed in Figure B.13, where s ¼ 10 msec.
a. Plot and label the one-sided amplitude spectrum up to 4 harmonic frequencies including
DC.
b. Plot and label the two-sided amplitude spectrum up to 4 harmonic frequencies including
DC.
B.2. In the waveform shown in Figure B.14, T0 ¼ 1 ms and A ¼ 10. Use the formula in Table
B.1 to write a Fourier series expansion in magnitude-phase form. Determine the frequency f3
and amplitude value of A3 for the third harmonic.
B.3. In the waveform shown in Figure B.15, T0 ¼ 1 ms, s ¼ 0:2 ms, and A ¼ 10.
a. Use the formula in Table B.1 to write a Fourier series expansion in magnitude-phase form.
b. Determine the frequency f2 and amplitude value of A2 for the second harmonic.
B.4. Find the Fourier transform XðuÞ and sketch the amplitude spectrum for the rectangular pulse
xðtÞ displayed in Figure B.16.
B.5. Use Table B.3 to determine the Fourier transform for the pulse in Figure B.17.
B.6. Use Table B.3 to determine the Fourier transform for the pulse in Figure B.18.
B.7. Determine the Laplace transform XðsÞ for each of the following time domain functions using
the Laplace transform in Table B.5.
FIGURE B.13
Pulse train in Problem B.1.
FIGURE B.14
Square wave in Problem B.2.
APPENDIX B Review of Analog Signal Processing Basics
801

a. xðtÞ ¼ 10dðtÞ
b. xðtÞ ¼ 100tuðtÞ
c. xðtÞ ¼ 10e 2tuðtÞ
d. xðtÞ ¼ 2uðt  5Þ
e. xðtÞ ¼ 10 cos ð3tÞuðtÞ
f. xðtÞ ¼ 10 sin ð2t þ 45
ÞuðtÞ
FIGURE B.15
Rectangular wave in Problem B.3.
FIGURE B.16
Rectangular pulse in Problem B.4.
FIGURE B.17
Triangular pulse in Problem B.5.
FIGURE B.18
Rectangular pulse in Problem B.6.
802
APPENDIX B: Review of Analog Signal Processing Basics

g. xðtÞ ¼ 3e 2tcos ð3tÞuðtÞ
h. xðtÞ ¼ 10t5uðtÞ
B.8. Determine the inverse transform of the analog signal xðtÞ for each of the following functions
using Table B.5 and partial fraction expansion.
a. XðsÞ ¼
10
s þ 2
b. XðsÞ ¼
100
ðs þ 2Þðs þ 3Þ
c. XðsÞ ¼
100s
s2 þ 7s þ 10
d. XðsÞ ¼
25
s2 þ 4s þ 29
B.9. Solve the following differential equation using the Laplace transform method:
2 dxðtÞ
dt
þ 3xðtÞ ¼ 15uðtÞ with xð0Þ ¼ 0
a. Determine XðsÞ.
b. Determine the continuous signal xðtÞ by taking the inverse Laplace transform of XðsÞ.
B.10. Solve the following differential equation using the Laplace transform method:
d2xðtÞ
dt2
þ 3 dxðtÞ
dt
þ 2xðtÞ ¼ 10u

t

with x0ð0Þ ¼ 0 and xð0Þ ¼ 0
a. Determine XðsÞ.
b. Determine xðtÞ by taking the inverse Laplace transform of XðsÞ.
B.11. Determine the locations of all ﬁnite zeros and poles in the following functions. In each case,
make an s-plane plot of the poles and zeros, and determine whether the given transfer
function is stable, unstable, or marginally stable.
a. HðsÞ ¼
ðs  3Þ
ðs2 þ 4s þ 4Þ
b. HðsÞ ¼
sðs2 þ 5Þ
ðs2 þ 9Þðs2 þ 2s þ 4Þ
c. HðsÞ ¼
ðs2 þ 1Þðs þ 1Þ
sðs2 þ 7s  8Þðs þ 3Þðs þ 4Þ
APPENDIX B Review of Analog Signal Processing Basics
803

B.12. Given the transfer function of a system
HðsÞ ¼
5
s þ 5
and the input xðtÞ ¼ uðtÞ,
a. determine the system impulse response hðtÞ;
b. determine the system Laplace output based on YðsÞ ¼ HðsÞXðsÞ;
c. determine the system response yðtÞ in the time domain by taking the inverse Laplace
transform of YðsÞ.
B.13. Given the transfer function of a system
HðsÞ ¼
5
s þ 5
a. determine the steady-state transfer function;
b. determine the amplitude response and phase response in terms of the frequency u;
c. determine the steady-state response of the system output yssðtÞ in time domain using the
results that you obtained in (b), given an input to the system of xðtÞ ¼ 5 sin ð2tÞuðtÞ.
B.14. Given the transfer function of a system
HðsÞ ¼
5
s þ 5
and the input xðtÞ ¼ uðtÞ, determine the system output yðtÞ using the convolution method; that
is, yðtÞ ¼ hðtÞ  xðtÞ.
804
APPENDIX B: Review of Analog Signal Processing Basics

Appendix C: Normalized Butterworth
and Chebyshev Functions
C.1 NORMALIZED BUTTERWORTH FUNCTION
The normalized Butterworth squared magnitude function is given by
jPnðuÞj2 ¼
1
1 þ ε2ðuÞ2n
(C.1)
where n is the order and ε is the speciﬁed ripple on the ﬁlter passband. The speciﬁed ripple in dB is
expressed as εdB ¼ 10$log10ð1 þ ε2Þ dB.
To develop the transfer function PnðsÞ, we ﬁrst let s ¼ ju and then substitute u2 ¼ s2 into
Equation (C.1) to obtain
PnðsÞPnðsÞ ¼
1
1 þ ε2ðs2Þn
(C.2)
Equation (C.2) has 2n poles, and PnðsÞ has n poles on the left-hand half plane (LHHP) on the s-plane,
while PnðsÞ has n poles on the right-hand half plane (RHHP) on the s-plane. Solving for poles
leads to
ð1Þns2n ¼ 1=ε2
(C.3)
If n is an odd number, Equation (C.3) becomes
s2n ¼ 1=ε2
and the corresponding poles are solved as
pk ¼ ε 1=nej2pk
2n ¼ ε 1=n½cos ð2pk=2nÞ þ j sin ð2pk=2nÞ
(C.4)
where k ¼ 0; 1; /; 2n  1. Thus in phasor form, we have
r ¼ ε 1=n;
and
qk ¼ 2pk=ð2nÞ
for k ¼ 0; 1; /; 2n  1
(C.5)
When n is an even number, it follows that
s2n ¼ 1=ε2
pk ¼ ε 1=nej2pkþp
2n
¼ ε 1=n½cos ðð2pk þ pÞ=2nÞ þ j sin ðð2pk þ pÞ=2nÞ
(C.6)
http://dx.doi.org/10.1016/B978-0-12-415893-1.15003-6
805

where k ¼ 0; 1; /; 2n  1. Similarly, the phasor form is given by
r ¼ ε 1=n;
and
qk ¼ ð2pk þ pÞ=ð2nÞ
for
k ¼ 0; 1; /; 2n  1
(C.7)
When n is an odd number, we can identify the poles on the LHHP as
pk ¼ r; k ¼ 0 and
pk ¼ r cos ðqkÞ þ jr sin ðqkÞ; k ¼ 1; /; ðn  1Þ=2
(C.8)
Using complex conjugate pairs, we have
p
k ¼ r cos ðqkÞ  jr sin ðqkÞ
Notice that
ðs  pkÞðs  p
kÞ ¼ s2 þ ð2r cos ðqkÞÞs þ r2
and from a factor from the real pole ðs þ rÞ, it follows that
PnðsÞ ¼
K
ðs þ rÞQðn 1Þ=2
k¼1
ðs2 þ ð2r cos ðqkÞÞs þ r2Þ
(C.9)
and
qk ¼ 2pk=ð2nÞ
for
k ¼ 1; /; ðn  1Þ=2
Setting Pnð0Þ ¼ 1 for the unit passband gain leads to
K ¼ rn ¼ 1=ε
When n is an even number, we can identify the poles on the LHHP as
pk ¼ r cos ðqkÞ þ jr sin ðqkÞ; k ¼ 0; 1; /; n=2  1
(C.10)
Using complex conjugate pairs, we have
p
k ¼ r cos ðqkÞ  jr sin ðqkÞ
The transfer function is given by
PnðsÞ ¼
K
Qn=2
k¼1ðs2 þ ð2r cos ðqkÞÞs þ r2Þ
(C.11)
qk ¼ ð2pk þ pÞ=ð2nÞ
for
k ¼ 0; 1; /; n=2  1
806
APPENDIX C: Normalized Butterworth and Chebyshev Functions

Setting Pnð0Þ ¼ 1 for the unit passband gain, we have
K ¼ rn ¼ 1=ε
Let us examine the following examples.
EXAMPLE C.1
Compute the normalized Butterworth transfer function for the following speciﬁcations:
Ripple
3 dB
n
2
Solution:
n=2
1
qk
ð2p  0 þ pÞ=ð2  2Þ
0:25p
ε2
100:13
1
r
1 and K
1
Applying Equation (C.11) leads to
P2ðsÞ
1
s2 þ 2  1  cos ð0:25pÞs þ 12
1
s2 þ 1:4141s þ 1
EXAMPLE C.2
Compute the normalized Butterworth transfer function for the following speciﬁcations:
Ripple
3 dB
n
3
Solution:
ðn
1Þ=2
1
ε2
100:13
1
r
1 and K
1
qk
ð2p  1Þ=ð2  3Þ
p=3
From Equation (C.9), we have
P3ðsÞ
1
ðs þ 1Þðs2 þ 2  1  cos ðp=3Þs þ 12Þ
1
ðs þ 1Þðs2 þ s þ 1Þ
For the unfactored form, we get
P3ðsÞ
1
s3 þ 2s2 þ 2s þ 1
APPENDIX C: Normalized Butterworth and Chebyshev Functions
807

EXAMPLE C.3
Compute the normalized Butterworth transfer function for the following speciﬁcations:
Ripple
1.5 dB
n
3
Solution:
ðn
1Þ=2
1
ε2
100:11:5
1,
r
1:1590 and K
1:5569
qk
ð2p  1Þ=ð2  3Þ
p=3
Applying Equation (C.9), we achieve the normalized Butterworth transfer function:
P3ðsÞ
1
ðs þ 1:1590Þðs2 þ 2  1:1590  cos ðp=3Þs þ 1:15902Þ
1
ðs þ 1Þðs2 þ 1:1590s þ 1:3433Þ
For the unfactored form, we obtain
P3ðsÞ
1:5569
s3 þ 2:3180s2 þ 2:6866s þ 1:5569
C.2 NORMALIZED CHEBYSHEV FUNCTION
Similar to analog Butterworth ﬁlter design, the transfer function is derived from the normalized
Chebyshev function, and the result is usually listed in a table for design reference. The Chebyshev
magnitude response function with an order of n and the normalized cutoff frequency u ¼ 1 radian per
second is given by
jBnðuÞj ¼
1
1 þ ε2C2nðuÞ
p
; n  1
(C.12)
where the function CnðuÞ is deﬁned as
CnðuÞ ¼
(
cos ðn cos 1ðuÞÞ
u  1
cos hðn cos h 1ðuÞÞ
u > 1
(C.13)
where ε is the ripple speciﬁcation on the ﬁlter passband. Notice that
cos h 1ðxÞ ¼ lnðx þ
x2  1
p
Þ
(C.14)
808
APPENDIX C: Normalized Butterworth and Chebyshev Functions

To develop the transfer function BnðsÞ, we let s ¼ ju and substitute u2 ¼ s2 into Equation (C.12)
to obtain
BnðsÞBnðsÞ ¼
1
1 þ ε2C2nðs=jÞ
(C.15)
The poles can be found from
1 þ ε2C2
nðs=jÞ ¼ 0
or
Cnðs=jÞ ¼ cos ðn cos 1ðs=jÞÞ ¼  j1=ε
(C.16)
If we introduce a complex variable v ¼ a þ jb such that
v ¼ a þ jb ¼ cos 1ðs=jÞ
(C.17)
we can then write
s ¼ j cosðvÞ
(C.18)
Substituting Equation (C.17) into Equation (C.16) and using trigonometric identities, it follows that
Cnðs=jÞ ¼ cos ðn cos 1ðs=jÞÞ
¼ cos ðnvÞ ¼ cos ðna þ jnbÞ
¼ cos ðnaÞcos hðnbÞ  j sin ðnaÞsin hðnbÞ ¼ j1=ε
(C.19)
To solve Equation (C.19), the following conditions must be satisﬁed:
cos ðnaÞcos hðnbÞ ¼ 0
(C.20)
 sin ðnaÞsin hðnbÞ ¼  1=ε
(C.21)
Since cos hðnbÞ  1 in Equation (C.20), we must let
cos ðnaÞ ¼ 0
(C.22)
which therefore leads to
ak ¼ ð2k þ 1Þp=ð2nÞ; k ¼ 0; 1; 2; /; 2n  1
(C.23)
With Equation (C.23), we have sin ðnakÞ ¼  1. Then Equation (C.21) becomes
sin hðnbÞ ¼ 1=ε
(C.24)
Solving Equation (C.24) gives
b ¼ sin h 1ð1=εÞ=n
(C.25)
Again from Equation (C.18),
s ¼ j cos ðvÞ ¼ j½cosðakÞ cos hðbÞ  j sinðakÞsin hðbÞ
for
k ¼ 0; 1; /; 2n  1
(C.26)
APPENDIX C: Normalized Butterworth and Chebyshev Functions
809

The poles can be found from Equation (C.26):
pk ¼ sin ðakÞ sin hðbÞ þ j cos ðakÞ cos hðbÞ
for
k ¼ 0; 1; /; 2n  1
(C.27)
Using Equation (C.27), if n is an odd number, the poles on the left side are
pk ¼ sin ðakÞ sin hðbÞ þ j cos ðakÞ cos hðbÞ; k ¼ 0; 1; /; ðn  1Þ=2  1
(C.28)
Using complex conjugate pairs, we have
p
k ¼ sin ðakÞ sin hðbÞ  j cos ðakÞ cos hðbÞ
(C.29)
and a real pole
pk ¼ sin hðbÞ; k ¼ ðn  1Þ=2
(C.30)
Notice that
ðs  pkÞðs  p
kÞ ¼ s2 þ bks þ ck
(C.31)
and from a factor from the real pole ½s þ sin hðbÞ, it follows that
BnðsÞ ¼
K
½s þ sin hðbÞQðn 1Þ=2 1
k¼0
ðs2 þ bks þ ckÞ
(C.32)
bk ¼ 2 sin ðakÞsin hðbÞ
(C.33)
ck ¼ ½sin ðakÞsin hðbÞ2 þ ½cos ðakÞcos h ðbÞ2
(C.34)
where
ak ¼ ð2k þ 1Þp=ð2nÞ
for
k ¼ 0; 1; /; ðn  1Þ=2  1
(C.35)
For the unit passband gain and the ﬁlter order as an odd number, we set Bnð0Þ ¼ 1. Then
K ¼ sin hðbÞ
Y
ðn 1Þ=2 1
k ¼ 0
ck
(C.36)
b ¼ sin h 1ð1=εÞ=n
(C.37)
sin h 1ðxÞ ¼ lnðx þ
x2 þ 1
p
Þ
(C.38)
Following a similar procedure for when n is even, we have
BnðsÞ ¼
K
Qn=2 1
k¼0
ðs2 þ bks þ ckÞ
(C.39)
bk ¼ 2 sin ðakÞ sin hðbÞ
(C.40)
810
APPENDIX C: Normalized Butterworth and Chebyshev Functions

ck ¼ ½sin ðakÞ sin hðbÞ2 þ ½cos ðakÞ cos hðbÞ2
(C.41)
where
ak ¼ ð2k þ 1Þp=ð2nÞ
for
k ¼ 0; 1; /; n=2  1
(C.42)
For the unit passband gain and the ﬁlter order as an even number, we require that Bnð0Þ ¼ 1=
1 þ ε2
p
,
so that the maximum magnitude of the ripple on the passband equals 1. Then we have
K ¼
Y
n=2 1
k ¼ 0
ck=
1 þ ε2
p
(C.43)
b ¼ sin h 1ð1=εÞ=n
(C.44)
sin h 1ðxÞ ¼ lnðx þ
x2 þ 1
p
Þ
(C.45)
Equations (C.32) to (C.45) are applied to compute the normalized Chebyshev transfer function. Now
let us look at the following illustrative examples.
EXAMPLE C.4
Compute the normalized Chebyshev transfer function for the following speciﬁcations:
Ripple
0.5 dB
n
2
Solution:
n=2
1
Applying Equations (C.39) to (C.45), we obtain
a0
ð2  0 þ 1Þp=ð2  2Þ
0:25p
ε2
100:10:5
1
0:1220, 1=ε
2:8630
b
sin h1ð2:8630Þ=n
lnð2:8630 þ
2:86302 þ 1
p
Þ=2
0:8871
b0
2 sin ð0:25pÞ sin hð0:8871Þ
1:4256
c0
½sin ð0:25pÞ sin hð0:8871Þ2 þ ½cos ð0:25pÞ cos hð0:8871Þ2
1:5162
K
1:5162=
1 þ 0:1220
p
1:4314
Finally, the transfer function is derived as
B2ðsÞ
1:4314
s2 þ 1:4256s þ 1:5162
APPENDIX C: Normalized Butterworth and Chebyshev Functions
811

EXAMPLE C.5
Compute the normalized Chebyshev transfer function for the following speciﬁcations:
Ripple
1 dB
n
3
Solution:
ðn
1Þ=2
1
Applying Equations (C.32) to (C.38) leads to
a0
ð2  0 þ 1Þp=ð2  3Þ
p=6
ε2
100:11
1
0:2589, 1=ε
1:9653
b
sin h1ð1:9653Þ=n
lnð1:9653 þ
1:96532 þ 1
p
Þ=3
0:4760
b0
2 sin ðp=6Þ sin hð0:4760Þ
0:4942
c0
½sin ðp=6Þ sin hð0:4760Þ2 þ ½cos ðp=6Þ cos hð0:4760Þ2
0:9942
sin hðbÞ
sin hð0:4760Þ
0:4942
K
0:4942  0:9942
0:4913
We can derive the transfer function as
B3ðsÞ
0:4913
ðs þ 0:4942Þðs2 þ 0:4942s þ 0:9942Þ
Finally, the unfactored form is found to be
B3ðsÞ
0:4913
s3 þ 0:9883s2 þ 1:2384s þ 0:4913
812
APPENDIX C: Normalized Butterworth and Chebyshev Functions

Appendix D: Sinusoidal Steady-State
Response of Digital Filters
D.1 SINUSOIDAL STEADY-STATE RESPONSE
Analysis of the sinusoidal steady-state response of digital ﬁlters will lead to the development of the
magnitude and phase responses of digital ﬁlters. Let us look at the following digital ﬁlter with a digital
transfer function HðzÞ and a complex sinusoidal input
xðnÞ ¼ VejðUnþ4xÞ
(D.1)
where U ¼ uT is the normalized digital frequency, while T is the sampling period and yðnÞ denotes
the digital output, as shown in Figure D.1.
The z-transform output from the digital ﬁlter is then given by
YðzÞ ¼ HðzÞXðzÞ
(D.2)
Since XðzÞ ¼ Vej4xz
z  ejU, we have
YðzÞ ¼ Vej4xz
z  ejUHðzÞ
(D.3)
Based on the partial fraction expansion, YðzÞ=z can be expanded to the following form:
YðzÞ
z
¼
Vej4x
z  ejUHðzÞ ¼
R
z  ejU þ sum of the rest of partial fractions
(D.4)
Multiplying the factor ðz  ejUÞ on both sides of Equation (D.4) yields
VejfxHðzÞ ¼ R þ ðz  ejUÞðsum of the rest of partial fractionsÞ
(D.5)
FIGURE D.1
Steady-state response of the digital ﬁlter.
http://dx.doi.org/10.1016/B978-0-12-415893-1.15004-8
813

Substituting z ¼ ejU, we get the residue as
R ¼ VejfxHðejUÞ
Then substituting R ¼ VejfxHðejUÞ back into Equation (D.4) results in
YðzÞ
z
¼ VejfxHðejUÞ
z  ejU
þ sum of the rest of partial fractions
(D.6)
and multiplying z on both sides of Equation (D.6) leads to
YðzÞ ¼ VejfxHðejUÞz
z  ejU
þ z  sum of the rest of partial fractions
(D.7)
Taking the inverse z-transform leads to two parts of the solution:
yðnÞ ¼ VejfxHðejUÞejUn þ Z
1ðz  sum of the rest of partial fractionsÞ
(D.8)
From Equation (D.8), we have the steady-state response
yssðnÞ ¼ VejfxHðejUÞejUn
(D.9)
and the transient response
ytrðnÞ ¼ Z
1ðz  sum of the rest of partial fractionsÞ
(D.10)
Note that since the digital ﬁlter is a stable system, and the locations of its poles must be inside the unit
circle on the z-plane, the transient response will settle to zero eventually. To develop the ﬁlter
magnitude and phase responses, we write the digital steady-state response as
yssðnÞ ¼ V
HðejUÞ
ejUþjfxþ:HðejUÞ
(D.11)
Comparing Equation (D.11) and Equation (D.1), it follows that
Magnitude response ¼ Amplitude of the steady-state output
Amplitude of the sinusoidal input
¼ V
HðejUÞ

V
¼
HðejUÞ

(D.12)
Phase response ¼ ejfxþj:HðejUÞ
ejfx
¼ ej:HðejUÞ ¼ :HðejUÞ
(D.13)
Thus we conclude that
Frequency response: HðejUÞ ¼ HðzÞjz¼ejU
(D.14)
Since HðejUÞ ¼ jHðejUÞj:HðejUÞ
Magnitude response:
HðejUÞ

(D.15)
Phase response: :HðejUÞ
(D.16)
814
APPENDIX D: Sinusoidal Steady State Response of Digital Filters

D.2 Properties of the Sinusoidal Steady-State Response
From Euler’s identity and trigonometric identity, we know that
ejðUþk2pÞ ¼ cos ðU þ k2pÞ þ j sin ðU þ k2pÞ
¼ cos U þ j sin U ¼ ejU
(D.17)
where k is an integer taking values of k ¼ 0;  1;  2; /. Then
Frequency response: HðejUÞ ¼ HðejðUþk2pÞÞ
(D.18)
Magnitude frequency response:
HðejUÞ
 ¼
HðejðUþk2pÞÞ

(D.19)
Phase response: : HðejUÞ ¼ : HðejUþ2kpÞ
(D.20)
Clearly, the frequency response is periodic, with a period of 2p. Next, let us develop the symmetric
properties. Since the transfer function is written as
HðzÞ ¼ YðzÞ
XðzÞ ¼ b0 þ b1z 1 þ / þ bMz M
1 þ a1z 1 þ / þ aNz N
(D.21)
substituting z ¼ ejU into Equation (D.21) yields
HðejUÞ ¼ b0 þ b1e jU þ / þ bMe jMU
1 þ a1e jU þ / þ aNe jNU
(D.22)
Using Euler’s identity, e jU ¼ cos U  j sin U, we have
HðejUÞ ¼ ðb0 þ b1 cos U þ / þ bM cos MUÞ  jðb1 sin U þ / þ bM sin MUÞ
ð1 þ a1 cos U þ / þ aN cos NUÞ  jða1 sin U þ / þ aN sin NUÞ
(D.23)
Similarly,
Hðe jUÞ ¼ ðb0 þ b1 cos U þ / þ bM cos MUÞ þ jðb1 sin U þ / þ bM sin MUÞ
ð1 þ a1 cos U þ / þ aN cos NUÞ þ jða1 sin U þ / þ aN sin NUÞ
(D.24)
Then the magnitude response and phase response can be expressed as
HðejUÞ
 ¼
ðb0 þ b1 cos U þ / þ bM cos MUÞ2 þ ðb1 sin U þ / þ bM sin MUÞ2
q
ð1 þ a1 cos U þ / þ aN cos NUÞ2 þ ða1 sin U þ / þ aN sin NUÞ2
q
(D.25)
:HðejUÞ ¼ tan 1
 ðb1 sin U þ / þ bM sin MUÞ
b0 þ b1 cos U þ / þ bM cos MU

 tan 1
 ða1 sin U þ / þ aN sin NUÞ
1 þ a1 cos U þ / þ aN cos NU

(D.26)
APPENDIX D: Sinusoidal Steady State Response of Digital Filters
815

Based on Equation (D.24), we also obtain the magnitude and phase response for Hðe jUÞ as
Hðe jUÞ
 ¼
ðb0 þ b1 cos U þ / þ bM cos MUÞ2 þ ðb1 sin U þ / þ bM sin MUÞ2
q
ð1 þ a1 cos U þ / þ aN cos NUÞ2 þ ða1 sin U þ / þ aN sin NUÞ2
q
(D.27)
:Hðe jUÞ ¼ tan 1

b1 sin U þ / þ bM sin MU
b0 þ b1 cos U þ / þ bM cos MU

 tan 1

a1 sin U þ / þ aN sin NU
1 þ a1 cos U þ / þ aN cos NU

(D.28)
Comparing Equation (D.25) with (D.27), and Equation (D.26) with (D.28), respectively, we obtain the
symmetric properties as
Hðe jUÞ
 ¼
HðejUÞ

(D.29)
: Hðe jUÞ ¼ : HðejUÞ
(D.30)
816
APPENDIX D: Sinusoidal Steady State Response of Digital Filters

Appendix E: Finite Impulse Response Filter
Design Equations by the Frequency
Sampling Design Method
Recall in Section 7.5 in Chapter 7 on the “Frequency Sampling Design Method” that we obtained
hðnÞ ¼ 1
N
X
N
1
k ¼ 0
HðkÞW
kn
N
(E.1)
where hðnÞ, 0  n  N  1, is the causal impulse response that approximates the ﬁnite impulse
response (FIR) ﬁlter, HðkÞ, 0  k  N  1, represents the corresponding coefﬁcients of the discrete
Fourier transform (DFT), and WN ¼ e j2p
N . We further write the DFT coefﬁcients, HðkÞ, 0  k 
N  1, in polar form:
HðkÞ ¼ Hkej4k; 0  k  N  1
(E.2)
where Hk and 4k are the kth magnitude and the phase angle, respectively. The frequency response of
the FIR ﬁlter is expressed as
HðejUÞ ¼
X
N
1
n ¼ 0
hðnÞe jnU
(E.3)
Substituting (E.1) into (E.3) yields
HðejUÞ ¼
X
N
1
n ¼ 0
1
N
X
N
1
k ¼ 0
HðkÞW
kn
N
e jUn
(E.4)
Interchanging the order of the summation in Equation (E.4) leads to
HðejUÞ ¼ 1
N
X
N
1
k ¼ 0
HðkÞ
X
N
1
n ¼ 0
ðW
k
N e jUÞn
(E.5)
Since W
k
N e jU ¼ ðe j2p=NÞ ke jU ¼ e ðjU 2pk=NÞ and using the identity PN
1
n ¼ 0 rn ¼ 1 þ r þ
r2 þ / þ rN
1 ¼ 1  rN
1  r , we can write the second summation in Equation (E.5) as
http://dx.doi.org/10.1016/B978-0-12-415893-1.15005-X
817

X
N
1
n ¼ 0
ðW
k
N e jUÞn ¼ 1  e jðU 2pk=NÞN
1  e jðU 2pk=NÞ
(E.6)
Using the Euler formula, Equation (E.6) becomes
X
N
1
n ¼ 0
ðW
k
N e jUÞn ¼ e jNðU 2pk=NÞ=2ðejNðU 2pk=NÞ=2  e jNðU 2pk=NÞ=2Þ=2j
e jðU 2pk=NÞ=2ðejðU 2pk=NÞ=2  e jðU 2pk=NÞ=2Þ=2j
¼ e jNðU 2pk=NÞ=2 sin ½NðU  2pk=NÞ=2
e jðU 2pk=NÞ=2 sin ½ðU  2pk=NÞ=2
(E.7)
Substituting Equation (E.7) into Equation (E.5) leads to
HðejUÞ ¼ 1
Ne jðN
1ÞU=2 X
N
1
k ¼ 0
HðkÞejðN
1Þkp=N sin ½NðU  2pk=NÞ=2
sin ½ðU  2pk=NÞ=2Þ
(E.8)
Let U ¼ Um ¼ 2pm
N , and substitute it into Equation (E.8) to get
HðejUmÞ ¼ 1
Ne jðN
1Þ2pm=ð2NÞ X
N
1
k ¼ 0
HðkÞejðN
1Þkp=N sin ½Nð2pm=N  2pk=NÞ=2
sin ½ð2pm=N  2pk=NÞ=2Þ
(E.9)
Clearly, when msk, the last term of the summation in Equation (E.9) becomes
sin ½Nð2pm=N  2pk=NÞ=2
sin ½ð2pm=N  2pk=NÞ=2Þ ¼
sin ðpðm  kÞÞ
sin ðpðm  kÞ=NÞ ¼
0
sin ðpðm  kÞ=NÞ ¼ 0
When m ¼ k, using L’Hospital’s rule we have
sin ½Nð2pm=N  2pk=NÞ=2
sin ½ð2pm=N  2pk=NÞ=2Þ ¼ sin ðNpðm  kÞ=NÞ
sin ðpðm  kÞ=NÞ
¼ lim
x/0
sin ðNxÞ
sin ðxÞ ¼ N
Then Equation (E.9) is simpliﬁed to
HðejUkÞ ¼ 1
Ne jðN
1Þpk=NHðkÞejðN
1Þkp=NN ¼ HðkÞ
that is,
HðejUkÞ ¼ HðkÞ; 0  k  N  1
(E.10)
where Uk ¼ 2pk
N , corresponding to the kth DFT frequency component. The fact is that if we specify
the desired frequency response, HðUkÞ, 0  k  N  1, at the equally spaced sampling frequency
determined by Uk ¼ 2pk
N , they are actually the DFT coefﬁcients; that is, HðkÞ, 0  k  N  1, via
Equation (E.10). Furthermore, the inverse of the DFT calculated using (E.10) will give the desired
impulse response, hðnÞ, 0  n  N  1.
818
APPENDIX E: Finite Impulse Response Filter Design Equations

To devise the design procedure, we substitute Equation (E.2) in Equation (E.8) to obtain
HðejUÞ ¼ 1
Ne jðN
1ÞU=2 X
N
1
k ¼ 0
Hkej4kþjðN
1Þkp=N sin ½NðU  2pk=NÞ=2
sin ½ðU  2pk=NÞ=2Þ
(E.11)
It is required that the frequency response of the designed FIR ﬁlter expressed in Equation (E.11) be
linear phase. This can easily be accomplished by setting
4k þ ðN  1Þkp=N ¼ 0; 0  k  N  1
(E.12)
in Equation (E.11) so that the summation part becomes a real value, thus resulting in the linear phase of
HðejUÞ, since only one complex term, e jðN
1ÞU=2, is left, which presents the constant time delay of the
transfer function. Second, the sequence hðnÞ must be real. To proceed, let N ¼ 2M þ 1, and due to the
properties of DFT coefﬁcients, we have
HðkÞ ¼ HðN  kÞ; 1  k  M
(E.13)
where the bar indicates complex conjugate. Note the fact that
W
k
N
¼ W
ðN
kÞ
N
; 1  k  M
(E.14)
From Equation (E.1), we write
hðnÞ ¼ 1
N
 
Hð0Þ þ
X
M
k ¼ 1
HðkÞW
kn
N
þ
X
2M
k ¼ Mþ1
HðkÞW
kn
N
!
(E.15)
Equation (E.15) is equivalent to
hðnÞ ¼ 1
N
 
Hð0Þ þ
X
M
k ¼ 1
HðkÞW
kn
N
þ
X
M
k ¼ 1
HðN  kÞW
ðN
kÞn
N
!
Using Equations (E.13) and (E.14) in the last summation term leads to
hðnÞ ¼ 1
N
 
Hð0Þ þ
X
M
k ¼ 1
HðkÞW
kn
N
þ
X
M
k ¼ 1
HðkÞW
kn
N
!
¼
1
2M þ 1
 
Hð0Þ þ
X
M
k ¼ 1
ðHðkÞW
kn
N
þ HðkÞW
kn
N
Þ
!
Combining the last two summation terms, we achieve
hðnÞ ¼
1
2M þ 1
(
Hð0Þ þ 2Re
 X
M
k ¼ 1
HðkÞW
kn
N
!)
; 0  n  N  1
(E.16)
Solving Equation (E.12) gives
4k ¼ ðN  1Þkp=N; 0  k  N  1
(E.17)
APPENDIX E: Finite Impulse Response Filter Design Equations
819

Again, note that Equation (E.13) is equivalent to
Hke j4k ¼ HN
kej4N
k; 1  k  M
(E.18)
Substituting (E.17) in (E.18) yields
HkejðN
1Þkp=N ¼ HN
ke jðN
1ÞðN
kÞp=N; 1  k  M
(E.19)
Simpliﬁcation of Equation (E.19) leads to the following result:
Hk ¼ HN
ke jðN
1Þp ¼ ð1ÞN
1HN
k; 1  k  M
(E.20)
Since we constrain the ﬁlter length to be N ¼ 2M þ 1, Equation (E.20) can be further reduced to
Hk ¼ ð1Þ2MH2Mþ1 k ¼ H2Mþ1 k; 1  k  M
(E.21)
Finally, by substituting (E.21) and (E.17) into (E.16), we obtain a very simple design equation:
hðnÞ ¼
1
2M þ 1
(
H0 þ 2
X
M
k ¼ 1
Hk cos
2pkðn  MÞ
2M þ 1
)
; 0  n  2M
(E.22)
Thus the design procedure is simply summarized as follows: Given the ﬁlter length, 2M þ 1, and the
speciﬁed frequency response, Hk at Uk ¼
2pk
ð2Mþ1Þ for k ¼ 0; 1; /; M, FIR ﬁlter coefﬁcients can be
calculated via Equation (E.22).
820
APPENDIX E: Finite Impulse Response Filter Design Equations

Appendix F: Wavelet Analysis and Synthesis
Equations
F.1 BASIC PROPERTIES
The inner product of two functions is deﬁned as
< x; y > ¼
Z
xðtÞyðtÞdt
(F.1)
Two functions are orthogonal if
< xðtÞ; xðt  kÞ > ¼
(
A
for
k ¼ 0
0
for
k s 0
(F.2)
Two functions are orthonormal if
< xðtÞ; xðt  kÞ > ¼
(
1
for k ¼ 0
0
for k s 0
(F.3)
The signal energy is deﬁned as
E ¼
Z
x2ðtÞdt
(F.4)
Many wavelet families are designed to be orthonormal:
E ¼
Z
j2ðtÞdt ¼ 1
(F.5)
E ¼
Z
j2
jkðtÞdt ¼
Z
½2j=2jð2jt  kÞ2dt ¼
Z
2jj2ð2jt  kÞdt
(F.6)
Let u ¼ 2jt  k. Then du ¼ 2jdt. Equation (F.6) becomes
E ¼
Z
2jj2ðuÞ2 jdu ¼ 1
(F.7)
http://dx.doi.org/10.1016/B978-0-12-415893-1.15006-1
821

Both father and mother wavelets are orthonormal at scale j:
Z
fjkðtÞfjnðtÞdt ¼
(
1
k ¼ n
0
otherwise
(F.8)
Z
jjkðtÞjjnðtÞdt ¼
(
1
k ¼ n
0
otherwise
(F.9)
F.2 ANALYSIS EQUATIONS
When a function fðtÞ is approximated using the scaling functions only at scale j þ 1, it can be
expressed as
fðtÞ ¼
X
N
k ¼
N
cjðkÞ2j=2fð2jt  kÞ
Using the inner product,
cjðkÞ ¼ < fðtÞ; fjkðtÞ > ¼
Z
fðtÞ2j=2fð2jt  kÞdt
(F.10)
Note that
fðtÞ ¼
X
N
n ¼
N
2
p
h0ðnÞfð2t  nÞ
(F.11)
Substituting Equation (F.11) into Equation (F.10) leads to
cjðkÞ ¼ < fðtÞ; fjkðtÞ > ¼
Z
fðtÞ2j=2 X
N
n ¼
N
2
p
h0ðnÞf½2ð2jt  kÞ  ndt
cjðkÞ ¼
X
N
n ¼
N
Z
fðtÞ2ðjþ1Þ=2h0ðnÞfð2ðjþ1Þt  2k  nÞdt
Let m ¼ n þ 2k. Interchange of the summation and integral leads to
cjðkÞ ¼
X
N
m ¼
N
Z
fðtÞ2ðjþ1Þ=2h0ðm  2kÞfð2ðjþ1Þt  mÞdt
cjðkÞ ¼
X
N
m ¼
N
 Z
fðtÞfðjþ1ÞmðtÞdt

h0ðm  2kÞ
(F.12)
822
APPENDIX F: Wavelet Analysis and Synthesis Equations

Using the inner product deﬁnition for the DWT coefﬁcient again in (F.12), we achieve
cjðkÞ ¼
X
N
m ¼
N
< fðtÞ; fðj þ 1ÞmðtÞ > h0ðm  2kÞ ¼
X
N
m ¼
N
cj þ 1ðmÞh0ðm  2kÞ
(F.13)
Similarly, notice that
jðtÞ ¼
X
N
k ¼
N
2
p
h1ðkÞfð2t  kÞ
Using the inner product gives
djðkÞ ¼ < fðtÞ; jjkðtÞ > ¼
Z
fðtÞ2j=2 X
N
n ¼
N
2
p
h1ðnÞf½2ð2jt  kÞ  ndt
djðkÞ ¼
X
N
n ¼
N
Z
fðtÞ2ðjþ1Þ=2h1ðnÞfð2ðjþ1Þt  2k  nÞdt
(F.14)
Let m ¼ n þ 2k. Interchange of the summation and integral leads to
djðkÞ ¼
X
N
m ¼
N
Z
fðtÞ2ðjþ1Þ=2h1ðm  2kÞfð2ðjþ1Þt  mÞdt
djðkÞ ¼
X
N
m ¼
N
 Z
fðtÞfðjþ1ÞmðtÞdt

h1ðm  2kÞ
(F.15)
Finally, applying the inner product deﬁnition for the wavelet discrete transform (WDT) coefﬁcient, we
obtain
djðkÞ ¼
X
N
m ¼
N
< fðtÞ; fðjþ1ÞmðtÞ > h1ðm  2kÞ ¼
X
N
m ¼
N
cjþ1ðmÞh1ðm  2kÞ
(F.16)
F.2 WAVELET SYNTHESIS EQUATIONS
We begin with
fðtÞ ¼
X
N
k ¼
N
cjðkÞ2j=2fð2jt  kÞ þ
X
N
k ¼
N
djðkÞ2j=2jð2jt  kÞ
Taking an inner product using the scaling function at scale level j þ 1 gives
cjþ1ðkÞ ¼ < fðtÞ; fðjþ1ÞkðtÞ > ¼
X
N
m ¼
N
cjðmÞ2j=2
Z
fð2jt  mÞfðjþ1ÞkðtÞdt
þ
X
N
m ¼
N
djðmÞ2j=2
Z
jð2jt  mÞfðjþ1ÞkðtÞdt
APPENDIX F: Wavelet Analysis and Synthesis Equations
823

cjþ1ðkÞ ¼
X
N
m ¼
N
cjðmÞ2j=2
Z
X
N
n ¼
N
2
p
h0ðnÞfð2jþ1t  2m  nÞfðjþ1ÞkðtÞdt
þ
X
N
m ¼
N
djðmÞ2j=2
Z
X
N
n ¼
N
2
p
h1ðnÞfð2jþ1t  2m  nÞfðjþ1ÞkðtÞdt
(F.17)
Interchange of the summation and integral yields
cjþ1ðkÞ ¼
X
N
m ¼
N
X
N
n ¼
N
cjðmÞh0ðnÞ
Z
2ðjþ1Þ=2fð2jþ1t  2m  nÞfðjþ1ÞkðtÞdt
þ
X
N
m ¼
N
X
N
n ¼
N
djðmÞh1ðnÞ
Z
2ðjþ1Þ=2fð2jþ1t  2m  nÞfðjþ1ÞkðtÞdt
Using the inner product, we get
cjþ1ðkÞ ¼
X
N
m ¼
N
X
N
n ¼
N
cjðmÞh0ðnÞ < fðjþ1Þð2mþnÞðtÞ; fðjþ1ÞkðtÞ >
þ
X
N
m ¼
N
X
N
n ¼
N
djðmÞh1ðnÞ < fðjþ1Þð2mþnÞðtÞ; fðjþ1ÞkðtÞ >
(F.18)
From the wavelet orthonormal property, we have
< fðjþ1Þð2mþnÞðtÞ; fðjþ1ÞkðtÞ > ¼
(
1
n ¼ k  2m
0
otherwise
(F.19)
Substituting Equation (F.19) into Equation (F.18), we ﬁnally obtain
cjþ1ðkÞ ¼
X
N
m ¼
N
cjðmÞh0ðk  2mÞ þ
X
N
m ¼
N
djðmÞh1ðk  2mÞ
(F.20)
824
APPENDIX F: Wavelet Analysis and Synthesis Equations

Appendix G: Some Useful Mathematical
Formulas
Form of a complex number:
Rectangular form:
a þ jb; where j ¼
1
p
(G.1)
Polar form:
Aejq
(G.2)
Euler formula:
e jx ¼ cos x  j sin x
(G.3)
Conversion from the polar form to the rectangular form:
Aejq ¼ A cos q þ jA sin q ¼ a þ jb
(G.4)
where a ¼ A cos q, and b ¼ A sin q.
Conversion from the rectangular form to the polar form:
a þ jb ¼ Aejq
(G.5)
where A ¼
a2 þ b2
p
. We usually specify the principal value of the angle such that 180
< q  180
.
The angle value can be determined as
q ¼ tan 1
b
a

if
a  0
(that is, the complex number is in the ﬁrst or fourth quadrant in the rectangular coordinate system);
q ¼ 180
 þ tan 1
b
a

if
a < 0
and
b  0
(that is, the complex number is in the second quadrant in the rectangular coordinate system); and
q ¼ 180
 þ tan 1
b
a

if
a < 0
and
b  0
http://dx.doi.org/10.1016/B978-0-12-415893-1.15007-3
825

(that is, the complex number is in the third quadrant in the rectangular coordinate system). Note that
q radian ¼ q degree
180

 p
q degree ¼ q radian
p
 180

Complex numbers:
ejp=2 ¼ j
(G.6)
ej2np ¼ 1
(G.7)
ejð2nþ1Þp ¼ 1
(G.8)
Complex conjugate of a þ jb:
ða þ jbÞ ¼ con jða þ jbÞ ¼ a  jb
(G.9)
Complex conjugate of Aejq:

Aejq ¼ con j

Aejq
¼ Ae jq
(G.10)
Complex number addition and subtraction:
ða1 þ jb1Þ  ða2 þ jb2Þ ¼ ða1  a2Þ þ jðb1  b2Þ
(G.11)
Complex number multiplication:
Rectangular form:
ða1 þ jb1Þ  ða2 þ jb2Þ ¼ a1a2  b1b2 þ jða1b2 þ a2b1Þ
(G.12)

a þ jb

$con j

a þ jb

¼

a þ jb

a  jb

¼ a2 þ b2
(G.13)
Polar form:
A1ejq1A2ejq2 ¼ A1A2ejðq1þq2Þ
(G.14)
Complex number division:
Rectangular form:
a1 þ jb1
a2 þ jb2
¼ ða1 þ jb1Þða2  jb2Þ
ða2 þ jb2Þða2  jb2Þ
¼ ða1a2 þ b1b2Þ þ jða2b1  a1b2Þ
ða2Þ2þðb2Þ2
(G.15)
826
APPENDIX G: Some Useful Mathematical Formulas

Polar form:
A1ejq1
A2ejq2 ¼
A1
A2

ejðq1
q2Þ
(G.16)
Trigonometric identities:
sin x ¼ ejx  e jx
2j
(G.17)
cos x ¼ ejx þ e jx
2
(G.18)
sin

x  90

¼  cos x
(G.19)
cos

x  90

¼ H sinx
(G.20)
sin x cos x ¼ 1
2 sin 2x
(G.21)
sin2 x þ cos2 x ¼ 1
(G.22)
sin2 x ¼ 1
2

1  cos 2x

(G.23)
cos2 x ¼ 1
2

1 þ cos 2x

(G.24)
sin ðx  yÞ ¼ sin x cos y  cos x siny
(G.25)
cos ðx  yÞ ¼ cos x cos yHsin x siny
(G.26)
sin x cosy ¼ 1
2 ðsin ðx þ yÞ þ sin ðx  yÞÞ
(G.27)
sin x siny ¼ 1
2 ðcos ðx  yÞ  cos ðx þ yÞÞ
(G.28)
cos x cos y ¼ 1
2 ðcos ðx  yÞ þ cos ðx þ yÞÞ
(G.29)
APPENDIX G: Some Useful Mathematical Formulas
827

Series of exponentials:
X
N
1
k ¼ 0
ak ¼ 1  aN
1  a ; as1
(G.30)
X
N
k ¼ 0
ak ¼
1
1  a; jaj < 1
(G.31)
X
N
k ¼ 0
kak ¼
1
ð1  aÞ2; jaj < 1
(G.32)
X
N
1
k ¼ 0
e

j2pnk
N

¼
(
0
1  n  N  1
N
n ¼ 0; N
(G.33)
L’Hospital’s rule:
If lim
x/a
fðxÞ
gðxÞ results in the undetermined form 0
0 or N
N, then
lim
x/a
fðxÞ
gðxÞ ¼ lim
x/a
f 0ðxÞ
g0ðxÞ
(G.34)
where f 0ðxÞ ¼ dfðxÞ
dx
and g0ðxÞ ¼ dgðxÞ
dx .
Solution of the quadratic equation:
For a quadratic equation expressed as
ax2 þ bx þ c ¼ 0
(G.35)
the solution is given by
x ¼ b 
b2  4ac
p
2a
(G.36)
Solution of simultaneous equations:
Simultaneous linear equations are listed below:
a11x1 þ a12x2 þ / þ a1nxn ¼ b1
a21x1 þ a22x2 þ / þ a2nxn ¼ b2
/
an1x1 þ an2x2 þ / þ annxn ¼ bn
(G.37)
The solution is given by Cramer’s rule, that is
x1 ¼ D1
D ; x2 ¼ D2
D ; /; xn ¼ Dn
D
(G.38)
828
APPENDIX G: Some Useful Mathematical Formulas

where D; D1; D2; .; Dn are the n  n determinants. Each is deﬁned below:
D ¼

a11
a12
/
a1n
a21
a22
/
a2n
«
«
1
«
an1
an2
/
ann

(G.39)
D1 ¼

b1
a12
/
a1n
b2
a22
/
a2n
«
«
1
«
bn
an2
/
ann

(G.40)
D2 ¼

a11
b1
/
a1n
a21
b2
/
a2n
«
«
1
«
an1
bn
/
ann

(G.41)
/
Dn ¼

a11
a12
/
b1
a21
a22
/
b2
«
«
1
«
an1
an2
/
bn

(G.42)
D ¼ ð  1Þ1þ1a11M11 þ ð  1Þ1þ2a12M12 þ /ð  1Þ1þna1nM1n
(G.43)
where Mij is an ðn  1Þ  ðn  1Þ determinant obtained from D by crossing out the ith row and
jth column. D can also be expanded by any row or column. As an example, using the second
column,
D ¼ ð  1Þ1þ2a12M12 þ ð  1Þ2þ2a22M12 þ /ð  1Þnþ2an2Mn2
(G.44)
2  2 determinant:
D ¼

a11
a12
a21
a22
 ¼ a11a22  a12a21
(G.45)
APPENDIX G: Some Useful Mathematical Formulas
829

3  3 determinant:
D ¼

a11
a12
a13
a21
a22
a23
a31
a32
a33

¼ ð  1Þ1þ1a11

a22
a23
a32
a33
 þ ð  1Þ1þ2a12

a21
a23
a31
a33
 þ ð  1Þ1þ3a13

a21
a22
a31
a32

¼ a11ða22a33  a23a32Þ  a12ða21a33  a23a31Þ þ a13ða21a32  a22a31Þ
(G.46)
Solution for two simultaneous linear equations:
ax þ by ¼ e
cx þ dy ¼ f
(G.47)
The solution is given by
x ¼ D1
D ¼

e
b
f
d


a
b
c
d

¼ ed  bf
ad  bc
(G.48)
y ¼ D2
D ¼

a
e
c
f


a
b
c
d

¼ af  ec
ad  bc
(G.49)
830
APPENDIX G: Some Useful Mathematical Formulas

Answers to Selected Problems
CHAPTER 2
2.1. Hint:
b.
f
kHz
X
f
s( )
−8
8
16
1.5
1.5
−
6.5
9.5
14.5
17.5
9.5
−
6.5
−
2.5/T
2.2. Hint:
a.
f
kHz
X
f
s( )
8
16
2.5
−
5.5
10.5
13.5
18.5
10.5
−
5.5
−
2 5. / T
2.5
11.2
−
4.8
−
3.2
−
3.2 4.8
11.212.8
19.2
2.5. Hint:
f
kHz
X
f
s( )
8
2.5
−
10.5
−
5.5
−
2 5. / T
2.5
11.5
−
4.5
−
3.5
−
3.5 4.5
16
5.5
10.5
13.5
18.5 19.5
11.5 12.5
c. The aliasing frequency ¼ 3.5 kHz
http://dx.doi.org/10.1016/B978-0-12-415893-1.15008-5
831

2.9.
−
+
Vin
Vo
2.25 kΩ
01. uF
0 05
.
uF
2.25 kΩ
2.10. % aliasing level ¼ 8:39%
2.13. a. % aliasing level ¼ 57.44%
b. % aliasing level ¼ 20.55%
2.17. a. % distortion ¼ 24.32%
b. % distortion ¼ 5.68%
2.18. fc ¼ 4; 686 Hz
2.21. b1b0 ¼ 01
2.22. V0 ¼ 1:25 Volts
2.25. a. L ¼ 24 ¼ 16 levels
b. D ¼ xmax  xmin
L
¼ 5
16 ¼ 0:3125
c. xq ¼ 3:125
d. binary code ¼1010
e. eq ¼ 0:075
2.27. a. L ¼ 23 ¼ 8 levels
b. D ¼ xmax  xmin
L
¼ 5
8 ¼ 0:625
c. xq ¼ 2:5 þ 2  0:625 ¼ 1:25
d. binary code ¼ 010
e. eq ¼ 0:05
2.29. a. L ¼ 26 ¼ 64 levels
b. D ¼ xmax  xmin
L
¼ 20
64 ¼ 0:3125
c. SNRdB ¼ 1:76 þ 6:02  6 ¼ 37:88 dB
832
Answers to Selected Problems

CHAPTER 3
3.1.
5
0
5
0
2
4
6
n
(a)
5
0
5
10
2
1.5
1
0.5
0
n
(b)
5
0
5
10
6
4
2
0
n
(c)
5
0
5
10
0
2
4
6
n
(d)
3.2. Hint:
a.
n
0
1
2
3
4
5
6
7
xðnÞ
1.000
0.5000
0.2500
0.1250
0.0625
0.0313
0.0156
0.0078
d.
n
0
1
2
3
4
5
6
7
xðnÞ
0.0000
1.1588
1.6531
1.7065
1.5064
1.1865
0.8463
0.5400
Answers to Selected Problems
833

3.5.
8
6
4
2
0
2
4
6
8
5
0
5
10
n
(a)
8
6
4
2
0
2
4
6
8
2
0
2
4
6
n
(b)
3.6. a. xðnÞ ¼ 3dðnÞ þ dðn  1Þ þ 2dðn  2Þ þ dðn  3Þ þ dðn  5Þ
b. xðnÞ ¼ dðn  1Þ  dðn  2Þ þ dðn  4Þ  dðn  5Þ
3.9. a. xðnÞ ¼ e 0:5nuðnÞ ¼ ð0:6065ÞnuðnÞ
b. xðnÞ ¼ 5 sin ð0:2pnÞuðnÞ
c. xðnÞ ¼ 10 cos ð0:4pn þ p=6ÞuðnÞ
d. xðnÞ ¼ 10e n sin ð0:15pnÞuðnÞ ¼ 10ð0:3679Þnsin ð0:15pnÞuðnÞ
3.10. a. nonlinear system
b. linear system
c. nonlinear system
3.13. a. time-invariant
3.15. a. causal system
b. noncausal system
c. causal system
3.16. a. hðnÞ ¼ 0:5dðnÞ  0:5dðn  2Þ
b. hðnÞ ¼ ð0:75Þn, n  0
c. hðnÞ ¼ 1:25dðnÞ  1:25ð0:8Þn, n  0
3.19. a. hðnÞ ¼ 5dðn  10Þ
b. hðnÞ ¼ dðnÞ þ 0:5dðn  1Þ
3.20. Since hðnÞ ¼ 0:5dðnÞ þ 100dðn  2Þ  20dðn  10Þ and S ¼ 0:5 þ 100 þ 20 ¼ 120:5 ¼
ﬁnite number, the system is stable.
3.23. a. hðnÞ ¼ ð0:75ÞnuðnÞ, S ¼ PN
k ¼ 0 ð0:75Þk ¼ 1=ð1  0:75Þ ¼ 4 ¼ ﬁnite, the system is stable.
b. hðnÞ ¼ ð2ÞnuðnÞ, S ¼ PN
k ¼ 0 ð2Þk ¼ 1 þ 2 þ 22 þ / ¼ N ¼ inﬁnite, the system is
unstable.
834
Answers to Selected Problems

3.25.
10
5
0
5
10
0
0.5
1
1.5
2
k
(a) h(k)
10
5
0
5
10
0
0.5
1
1.5
2
k
(a) h(-k)
10
5
0
5
10
0
0.5
1
1.5
2
k
(b) h(-k+2)
10
5
0
5
10
0
0.5
1
1.5
2
k
(b) h(-k-3)
3.27. yð0Þ ¼ 4; yð1Þ ¼ 6; yð2Þ ¼ 8; yð3Þ ¼ 6; yð4Þ ¼ 5; yð5Þ ¼ 2; yð6Þ ¼ 1;
yðnÞ ¼ 0
for
n  7
3.29. yð0Þ ¼ 0; yð1Þ ¼ 1; yð2Þ ¼ 2; yð3Þ ¼ 1; yð4Þ ¼ 0
yðnÞ ¼ 0
for
n  4
CHAPTER 4
4.1. Xð0Þ ¼ 1; Xð1Þ ¼ 2  j; Xð2Þ ¼ 1; Xð3Þ ¼ 2 þ j
4.5. xð0Þ ¼ 4; xð1Þ ¼ 3; xð2Þ ¼ 2; xð3Þ ¼ 1
4.6. Xð0Þ ¼ 10; Xð1Þ ¼ 3:5  4:3301j; Xð2Þ ¼ 2:5  0:8660j; Xð3Þ ¼ 2;
Xð4Þ ¼ 2:5 þ 0:8660j; Xð5Þ ¼ 3:5 þ 4:3301j
4.9. xð0Þ ¼ 4; xð4Þ ¼ 0
4.10. Df ¼ 2:5 Hz and fmax ¼ 10 kHz
4.13. N ¼ 4096; Df ¼ 0:488 Hz
4.15. a. w ¼ [0.0800 0.2532 0.6424 0.9544 0.9544 0.6424 0.2532 0.0800]
b. w ¼ [0 0.1883 0.6113 0.9505 0.9505 0.6113 0.1883 0]
4.16. a. xw ¼ [0 0.4000 0 0.8000 0 0]
b. xw ¼ [0 0.3979 0 0.9121 0 0.0800]
c. xw ¼ [0 0.3455 0 0.9045 0 0]
Answers to Selected Problems
835

4.19. a. A0 ¼ 0:1667, A1 ¼ 0:3727, A2 ¼ 0:5, A3 ¼ 0:3727
40 ¼ 00; 41 ¼ 154:430; 42 ¼ 00; 43 ¼ 154:430
P0 ¼ 0:0278; P1 ¼ 0:1389; P2 ¼ 0:25; P3 ¼ 0:1389
b. A0 ¼ 0:2925, A1 ¼ 0:3717, A2 ¼ 0:6375, A3 ¼ 0:3717
40 ¼ 00; 41 ¼ 145:130; 42 ¼ 00; 43 ¼ 145:130
P0 ¼ 0:0586; P1 ¼ 0:1382; P2 ¼ 0:4064; P3 ¼ 0:1382
c. A0 ¼ 0:6580, A1 ¼ 0:3302, A2 ¼ 0:9375, A3 ¼ 0:3302
40 ¼ 00; 41 ¼ 108:860; 42 ¼ 00; 43 ¼ 108:860
P0 ¼ 0:4330; P1 ¼ 0:1091; P2 ¼ 0:8789; P3 ¼ 0:1091
4.21. Xð0Þ ¼ 10; Xð1Þ ¼ 2  2j; Xð2Þ ¼ 2; Xð3Þ ¼ 2 þ 2j; 4 complex multiplications
4.22. xð0Þ ¼ 4; xð1Þ ¼ 3; xð2Þ ¼ 2; xð3Þ ¼ 1; 4 complex multiplications
4.25. Xð0Þ ¼ 10; Xð1Þ ¼ 2  2j; Xð2Þ ¼ 2; Xð3Þ ¼ 2 þ 2j; 4 complex multiplications
4.26. xð0Þ ¼ 4; xð1Þ ¼ 3; xð2Þ ¼ 2; xð3Þ ¼ 1; 4 complex multiplications
CHAPTER 5
5.1. a. X

z

¼
4z
z  1,
b. X

z

¼
z
z þ 0:7
c. X

z

¼
4z
z  e 2 ¼
4z
z  0:1353,
d. X

z

¼
4z½z  0:8  cos ð0:1pÞ
z2  ½2  0:8z cos ð0:1pÞ þ 0:82 ¼
4zðz  0:7608Þ
z2  1:5217z þ 0:64
e. X

z

¼
4e 3 sin ð0:1pÞz
z2  2e 3z cos ð0:1pÞ þ e 6 ¼
0:06154z
z2  0:0947z þ 0:00248
5.2. a. X

z

¼
z
z  1 þ
z
z  0:5
b. X

z

¼
z 4z½z  e 3 cos ð0:1pÞ
z2  ½2e 3 cos ð0:1pÞz þ e 6 ¼
z 3ðz  0:0474Þ
z2  0:0948z þ 0:0025
5.3. c. X

z

¼
5z 2
z  e 2
e. X

z

¼
4e 3 sin ð0:2pÞ
z2  2e 3 cos ð0:2pÞz þ e 6 ¼
0:1171
z2  0:0806z þ 0:0025
5.5. a. XðzÞ ¼ 15z 3  6z 5
b. xðnÞ ¼ 15dðn  3Þ  6dðn  5Þ
5.9. a. X

z

¼ 25 þ
5z
z  0:4 þ
20z
z þ 0:1, xðnÞ ¼ 25dðnÞ þ 5ð0:4ÞnuðnÞ þ 20ð0:1ÞnuðnÞ
b. X

z

¼ 1:6667z
z  0:2  1:6667z
z þ 0:4, xðnÞ ¼ 1:6667ð0:2ÞnuðnÞ  1:6667ð0:4ÞnuðnÞ
836
Answers to Selected Problems

c. X

z

¼ 1:3514z
z þ 0:2 þ
Az
z  P þ
Az
z  P
where P ¼ 0:5þ0:5j ¼ 0:707:450, A ¼ 1:1625:125:540, xðnÞ ¼ 1:3514ð0:2ÞnuðnÞþ
2:325ð0:707Þn cosð450 n125:540Þ
d. X

z

¼ 4:4z
z0:6þ 0:4z
z0:1þ
1:2z
ðz0:1Þ2;
xðnÞ ¼ 4:4ð0:6ÞnuðnÞ  0:4ð0:1ÞnuðnÞ  12nð0:1ÞnuðnÞ
5.10. Y

z

¼ 4:3333z
z  0:5 þ 5:333z
z  0:8; y

n

¼ 4:3333ð0:5Þnu

n

þ 5:3333

0:8
nu

n

5.13. Y

z

¼
9:84z
z  0:2 þ 29:46z
z  0:3 þ
20z
z  0:4
yðnÞ ¼ 9:84ð0:2ÞnuðnÞ  29:46ð0:3ÞnuðnÞ þ 20ð0:4ÞnuðnÞ
5.14. a. Y

z

¼
4z
z  0:2 þ
5z
z  0:5, yðnÞ ¼ 4ð0:2ÞnuðnÞ þ 5ð0:5ÞnuðnÞ
b. Y

z

¼
5z
z  1 þ
5z
z  0:5 þ
z
z  0:2,
yðnÞ ¼ 5uðnÞ  5ð0:5ÞnuðnÞ þ ð0:2ÞnuðnÞ
5.17. a. Y

z

¼
Az
z  P þ
Az
z  P, P ¼ 0:2 þ 0:5j ¼ 0:5385:68:200, A ¼ 0:8602:  54:460
yðnÞ ¼ 1:7204ð0:5382Þn cos ðn  68:200  54:460Þ
b. Y

z

¼ 1:6854z
z  1 þ
Az
z  P þ
Az
z  P,
where
P ¼ 0:2 þ 0:5j ¼ 0:5385:68:200,
A ¼
0:4910:  136:250
yðnÞ ¼ 1:6845uðnÞ þ 0:982ð0:5382Þn cos ðn  68:200  136:250Þ
CHAPTER 6
6.1. a. yð0Þ ¼ 0:5, yð1Þ ¼ 0:25, yð2Þ ¼ 0:125, yð3Þ ¼ 0:0625, yð4Þ ¼ 0:03125
b. yð0Þ ¼ 1, yð1Þ ¼ 0, yð2Þ ¼ 0:25, yð3Þ ¼ 0, yð4Þ ¼ 0:0625
6.3. a. yð0Þ ¼ 2, yð1Þ ¼ 2:3750, yð2Þ ¼ 1:0312, yð3Þ ¼ 0:7266, yð4Þ ¼ 0:2910
b. yð0Þ ¼ 0, yð1Þ ¼ 1, yð2Þ ¼ 0:2500, yð3Þ ¼ 0:3152, yð4Þ ¼ 0:0781
6.4. a. HðzÞ ¼ 0:5 þ 0:5z 1
b. yðnÞ ¼ 2dðnÞ þ 2dðn  1Þ, yðnÞ ¼ 5dðnÞ þ 10uðnÞ
6.5. a. H

z

¼
1
1 þ 0:5z 1
b. yðnÞ ¼ ð0:5ÞnuðnÞ, yðnÞ ¼ 0:6667uðnÞ þ 0:3333ð0:5ÞnuðnÞ
Answers to Selected Problems
837

6.9. HðzÞ ¼ 1  0:3z 1 þ 0:28z 2; AðzÞ ¼ 1; NðzÞ ¼ 1  0:3z 1 þ 0:28z 2
6.12. a. yðnÞ ¼ xðnÞ  0:25xðn  2Þ  1:1yðn  1Þ  0:18yðn  2Þ
b. yðnÞ ¼ xðn  1Þ  0:1xðn  2Þ þ 0:3xðn  3Þ
6.13. b. H

z

¼ ðz þ 0:4Þðz  0:4Þ
ðz þ 0:2Þðz þ 0:5Þ
6.15. a. zero: z ¼ 0:5, poles: z ¼ 0:25 (jzj ¼ 0:25), z ¼ 0:5  0:7416j (jzj ¼ 0:8944), stable
b. zeros: z ¼ 0:5j, poles: z ¼ 0:5 (jzj ¼ 0:5), z ¼ 2  1:7321j (jzj ¼ 2:6458), unstable
c. zero:
z ¼ 0:95,
poles:
z ¼ 0:2
(jzj ¼ 0:2),
z ¼ 0:7071  0:7071j
(jzj ¼ 1),
marginally stable
d. zeros: z ¼ 0:5, z ¼ 0:5, poles: z ¼ 1 (jzj ¼ 1), z ¼ 1, z ¼ 1 (jzj ¼ 1), z ¼ 0:36
(jzj ¼ 0:36), unstable
6.17. HðzÞ ¼ 0:5z 1 þ 0:5z 2; HðejUÞ ¼ 0:5e jU þ 0:5e j2U
HðejUÞ
 ¼ 0:5
ð1 þ cos UÞ2 þ ðsin UÞ2
q
; :H

ejU
¼ tan 1
sin U  sin 2U
cos U þ cos 2U
	
6.19. H

z

¼
1
1 þ 0:5z 2; H

ejU
¼
1
1 þ 0:5e j2U
HðejUÞ
 ¼
1
ð1 þ 0:5 cos 2UÞ2 þ ð0:5 sin 2UÞ2
q
; :H

ejU
¼ tan 1
 0:5 sin 2U
1 þ 0:5 cos 2U
	
6.21. a. HðzÞ ¼ 0:5 þ 0:5z 1, HðejUÞ ¼ 0:5 þ 0:5e jU
HðejUÞ
 ¼
ð0:5 þ 0:5 cos UÞ2 þ ð0:5 sin UÞ2
q
; :HðejUÞ ¼ tan 1

0:5 sin U
0:5 þ 0:5 cos U
	
b. HðzÞ ¼ 0:5  0:5z 1, HðejUÞ ¼ 0:5  0:5e jU
HðejUÞ
 ¼
ð0:5  0:5 cos UÞ2 þ ð0:5 sin UÞ2
q
; :HðejUÞ ¼ tan 1

0:5 sin U
0:5  0:5 cos U
	
c. HðzÞ ¼ 0:5 þ 0:5z 2, HðejUÞ ¼ 0:5 þ 0:5e j2U
HðejUÞ
 ¼
ð0:5 þ 0:5 cos 2UÞ2 þ ð0:5 sin 2UÞ2
q
; :HðejUÞ ¼ tan 1

0:5 sin 2U
0:5 þ 0:5 cos 2U
	
d. HðzÞ ¼ 0:5  0:5z 2, HðejUÞ ¼ 0:5  0:5e j2U
HðejUÞ
 ¼
ð0:5  0:5 cos 2UÞ2 þ ð0:5 sin 2UÞ2
q
; :HðejUÞ ¼ tan 1

0:5 sin 2U
0:5  0:5 cos 2U
	
6.23. H

z

¼
0:5
1 þ 0:7z 1 þ 0:1z 2;
y

n

¼ 0:5556u

n

 0:111

 0:2
nu

n

þ 0:5556

 0:5
nu

n

6.25. a. yðnÞ ¼ xðnÞ  0:9xðn  1Þ  0:1xðn  2Þ  0:3yðn  1Þ þ 0:04yðn  2Þ
b. wðnÞ ¼ xðnÞ  0:3wðn  1Þ þ 0:04wðn  2Þ
yðnÞ ¼ wðnÞ  0:9wðn  1Þ  0:1wðn  2Þ
838
Answers to Selected Problems

c. Hint: H

z

¼
ðz  1Þðz þ 0:1Þ
ðz þ 0:4Þðz  0:1Þ
w1ðnÞ ¼ xðnÞ  0:4w1ðn  1Þ
y1ðnÞ ¼ w1ðnÞ  w1ðn  1Þ
w2ðnÞ ¼ y1ðnÞ þ 0:1w2ðn  1Þ
yðnÞ ¼ w2ðnÞ þ 0:1w2ðn  1Þ
d. Hint: H

z

¼ 2:5 þ
2:1z
z þ 0:4 
3:6z
z  0:1
y1ðnÞ ¼ 2:5xðnÞ
w2ðnÞ ¼ xðnÞ  0:4w2ðn  1Þ
y2ðnÞ ¼ 2:1w2ðnÞ
w3ðnÞ ¼ xðnÞ þ 0:1w3ðn  1Þ
y3ðnÞ ¼ 3:6w3ðnÞ
yðnÞ ¼ y1ðnÞ þ y2ðnÞ þ y3ðnÞ
6.26. a. yðnÞ ¼ xðnÞ  0:5xðn  1Þ
b. yðnÞ ¼ xðnÞ  0:7xðn  1Þ
c. yðnÞ ¼ xðnÞ  0:9xðn  1Þ
The ﬁlter in (c) emphasizes high frequencies most.
CHAPTER 7
7.1. a. HðzÞ ¼ 0:2941 þ 0:3750z 1 þ 0:2941z 2
b. HðzÞ ¼ 0:0235 þ 0:3750z 1 þ 0:0235z 2
7.3. a. HðzÞ ¼ 0:1514 þ 0:1871z 1 þ 0:2000z 2 þ 0:1871z 3 þ 0:1514z 4
b. HðzÞ ¼ 0:0121 þ 0:1010z 1 þ 0:2000z 2 þ 0:1010z 3 þ 0:0121z 4
7.5. a. HðzÞ ¼ 0:0444 þ 0:0117z 1 þ 0:0500z 2 þ 0:0117z 3  0:0444z 4
b. HðzÞ ¼ 0:0035 þ 0:0063z 1 þ 0:0500z 2 þ 0:0063z 3  0:0035z 4
7.7. a. Hanning window
b. ﬁlter length ¼63
c. cutoff frequency ¼ 1,000 Hz
7.9. a. Hamming window
b. ﬁlter length ¼45
c. lower cutoff frequency ¼ 1500 Hz, upper cutoff frequency ¼ 2,300 Hz
7.11. Hint:
a. yðnÞ ¼ 0:25xðnÞ  0:5xðn  1Þ þ 0:25xðn  2Þ
b. yðnÞ ¼ 0:25½xðnÞ þ xðn  2Þ  0:5xðn  1Þ
7.13. N ¼ 3; Uc ¼ 3p=10; U0 ¼ 0; H0 ¼ 1; U1 ¼ 2p=3; H1 ¼ 0
HðzÞ ¼ 0:3333 þ 0:3333z 1 þ 0:3333z 2
7.15. HðzÞ ¼ 0:1236 þ 0:3236z 1 þ 0:6z 2 þ 0:3236z 3  0:1236z 4
7.17. HðzÞ ¼ 0:1718  0:2574z 1  0:0636z 2 þ 0:2857z 3  0:0636z 4  0:2574z 5
þ0:1781z 6
Answers to Selected Problems
839

7.19. Wp ¼ 1, Ws ¼ 12
7.21. Wp ¼ 1, Ws ¼ 122
7.23. Hamming window, ﬁlter length ¼ 33, lower cutoff frequency ¼ 3,500 Hz
7.24. Hamming window, ﬁlter length ¼ 53,
lower cutoff frequency ¼ 1,250 Hz, upper cutoff frequency ¼ 2,250 Hz
7.25. Lowpass ﬁlter: Hamming window, ﬁlter length ¼ 91, cutoff frequency ¼ 2,000 Hz
Highpass ﬁlter: Hamming window, ﬁlter length ¼ 91, cutoff frequency ¼ 2,000 Hz
CHAPTER 8
8.1. H

z

¼ 0:3333 þ 0:3333z 1
1  0:3333z 1
yðnÞ ¼ 0:3333xðnÞ þ 0:3333xðn  1Þ þ 0:3333yðn  1Þ
8.3. a. H

z

¼ 0:6625  0:6625z 1
1  0:3249z 1
yðnÞ ¼ 0:6225xðnÞ  0:6225xðn  1Þ þ 0:3249yðn  1Þ
8.5. a. H

z

¼
0:2113  0:2113z 2
1  0:8165z 1 þ 0:5774z 2
yðnÞ ¼ 0:2113xðnÞ  0:2113xðn  2Þ þ 08165yðn  1Þ  0:5774yðn  2Þ
8.7. a. H

z

¼ 0:1867 þ 0:3734z 1 þ 0:1867z 2
1  0:4629z 1 þ 0:2097z 2
yðnÞ ¼ 0:1867xðnÞ þ 0:3734xðn  1Þ þ 0:1867xðn  2Þ
þ 0:4629yðn  1Þ  0:2097yðn  2Þ
8.9. a. H

z

¼ 0:0730  0:0730z 2
1 þ 0:8541z 2
yðnÞ ¼ 0:0730xðnÞ  0:0730xðn  2Þ  0:8541yðn  2Þ
8.11. a. H

z

¼ 0:5677 þ 0:5677z 1
1 þ 0:1354z 1
yðnÞ ¼ 0:5677xðnÞ þ 0:5677xðn  1Þ  0:1354yðn  1Þ
8.13. a. H

z

¼ 0:1321  0:3964z 1 þ 0:3964z 2  0:1321z 3
1 þ 0:3432z 1 þ 0:6044z 2 þ 0:2041z 3
yðnÞ ¼ 0:1321xðnÞ  0:3964xðn  1Þ þ 0:3964xðn  2Þ  0:1321xðn  3Þ
 0:3432yðn  1Þ  0:6044yðn  2Þ  0:2041yðn  3Þ
840
Answers to Selected Problems

8.15. a. H

z

¼ 0:9609 þ 0:7354z 1 þ 0:9609z 2
1 þ 0:7354z 1 þ 0:9217z 2
yðnÞ ¼ 0:9609xðnÞ þ 0:7354xðn  1Þ þ 0:9609xðn  2Þ
0:7354yðn  1Þ  0:9217yðn  2Þ
8.17. a. H

z

¼ 0:0242 þ 0:0968z 1 þ 0:1452z 2 þ 0:0968z 3 þ 0:0242z 4
1  1:5895z 1 þ 1:6690z 2  0:9190z 3 þ 0:2497z 4
yðnÞ ¼ 0:0242xðnÞ þ 0:0968xðn  1Þ þ 0:1452xðn  2Þ
þ 0:0968xðn  3Þ þ 0:0242xðn  4Þ þ 1:5895yðn  1Þ  1:6690yðn  2Þ
þ0:9190yðn  3Þ  0:2497yðn  4Þ
8.19. a. H

z

¼
1
1  0:3679z 1
y

n

¼ xðnÞ þ 0:3679y

n  1

8.21. a. H

z

¼
0:1  0:09781z 1
1  1:6293z 1 þ 0:6703z 2
yðnÞ ¼ 0:1xðnÞ  0:0978xðn  1Þ þ 1:6293yðn  1Þ  0:6703yðn  2Þ
8.23. H

z

¼ 0:9320  1:3180z 1 þ 0:9320z 2
1  1:3032z 1 þ 0:8492z 2
yðnÞ ¼ 0:9320xðnÞ  1:3180xðn  1Þ þ 0:9329xðn  2Þ þ 1:3032yðn  1Þ  0:8492yðn  2Þ
8.25. H

z

¼ 0:9215 þ 0:9215z 1
1 þ 0:8429z 1
yðnÞ ¼ 0:9215xðnÞ þ 0:9215xðn  1Þ  0:8429yðn  1Þ
8.27. H

z

¼ 0:9607  0:9607z 1
1  0:9215z 1
yðnÞ ¼ 0:9607xðnÞ  0:9607xðn  1Þ þ 0:9215yðn  1Þ
8.29. a.
z −1
+
+
0.3430
0.6859
0.7075
−
x n
( )
0.3430
0.7313
−
z −1
z −1
+
+
y n
( )
0.4371
0.8742
0.1316
0.4371
0.1733
−
z −1
y n
1( )
w n
1( )
w n
2( )
b. For section 1: w1ðnÞ ¼ xðnÞ  0:7075w1ðn  1Þ  0:7313w1ðn  2Þ
Answers to Selected Problems
841

y1ðnÞ ¼ 0:3430w1ðnÞ þ 0:6859w1ðn  1Þ þ 0:3430w1ðn  2Þ
For section 2: w2ðnÞ ¼ y1ðnÞ þ 0:1316w2ðn  1Þ  0:1733w2ðn  2Þ
y2ðnÞ ¼ 0:4371w2ðnÞ þ 0:8742w2ðn  1Þ þ 0:4371w2ðn  2Þ
8.30. H

z

¼
0:9511z 1
1:0000  0:6180z 1 þ z 2; y

n

¼ 0:9511x

n  1

þ 0:618y

n  1

 y

n  2

8.32. a. H852

z

¼
0:6203z 1
1  1:5687z 1 þ z 2, H1477

z

¼
0:9168z 1
1  0:7986z 1 þ z 2
b. y852ðnÞ ¼ 0:6203xðn  1Þ þ 1:5678y852ðn  1Þ  y852ðn  2Þ
y1477ðnÞ ¼ 0:9168xðn  1Þ þ 0:7986y1477ðn  1Þ  y1477ðn  2Þ
y9ðnÞ ¼ y1477ðnÞ þ y852ðnÞ
8.34. X

0

¼ 2; jX

0

j2 ¼ 4; A0 ¼ 0:5 ðsingle sideÞ
X

1

¼ 1  j3; jXð1Þj2 ¼ 10; A1 ¼ 1:5811 ðsingle sideÞ
8.36. A0 ¼ 2:5, A2 ¼ 0:5
8.39. Chebyshev notch ﬁlter 1: order ¼ 2
H

z

¼ 0:9915  1:9042z 1 þ 0:9915z 2
1:0000  1:9042z 1 þ 0:9830z 2
Chebyshev notch ﬁlter 2: order ¼ 2
H

z

¼ 0:9917  1:3117z 1 þ 0:9917z 2
1:0000  1:3117z 1 þ 0:9835z 2
8.41. Filter order ¼ 4
H

z

¼ 0:1103 þ 0:4412z 1 þ 0:6618z 2 þ 0:4412z 3 þ 0:1103z 4
1:0000 þ 0:1509z 1 þ 0:8041z 2  0:1619z 3 þ 0:1872z 4
8.43. Filter order ¼ 4
H

z

¼
0:0300  0:0599z 2 þ 0:0300z 4
1:0000  0:6871z 1 þ 1:5741z 2  0:5177z 3 þ 0:5741z 4
8.45. H

z

¼
0:5878z 1
1  1:6180z 1 þ z2
yðnÞ ¼ 0:5878xðn  1Þ þ 1:6180yðn  1Þ  yðn  2Þ
8.47. X

0

¼ 1; jXð0Þj2 ¼ 1; A0 ¼ 0:25 ðsingle sideÞ
X

1

¼ 1  j2; jXð1Þj2 ¼ 5; A1 ¼ 1:12 ðsingle sideÞ
842
Answers to Selected Problems

CHAPTER 9
9.1. 0:2560123 ðdecimalÞ ¼ 0: 0 1 0 0 0 0 0 1 1 0 0 0 1 0 1 ðQ  15Þ
9.2. 0:2160123  215 ¼ 707810 ¼ 1110010001011010
 0:2160123 ðdecimalÞ ¼ 1: 1 1 0 0 1 0 0 0 1 0 1 1 0 1 0 ðQ  15Þ
9.5. 0:1 0 1 0 1 0 0 0 1 0 1 1 1 1 0 ¼ 0:6591186
1:0 1 0 1 0 1 1 1 0 1 0 0 0 1 0ðQ  15Þ ¼ 0:6591186
9.6. 0:0 0 1 0 0 0 1 1 1 1 0 1 1 1 0ðQ  15Þ ¼ 0:1400756
9.9. 1:1 0 1 0 1 0 1 1 1 0 0 0 0 0 1 þ 0:0 1 0 0 0 1 1 1 1 0 1 1 0 1 0
¼ 1:1 1 1 1 0 0 1 1 0 0 1 1 0 1 1
9.13. a. 1101 011100001100
b. 0100 101011001001
9.15. 1101 011100011011ðfloatingÞ ¼ 0:8881835  2 3 ðdecimalÞ
0100 101111100101

floating

¼ 0:5131835  24 ðdecimalÞ
0:8881835  2 3 ðdecimalÞ ¼ 0:0069389  24 ðdecimalÞ
¼ 0100 000000001110ðfloatingÞ
0100 101111100101ðfloatingÞ þ 0100 000000001110ðfloatingÞ
¼ 0100 101111110011ðfloatingÞ ¼ 8:1016ðdecimalÞ
9.18. ð1Þ1  1:025  2160 127 ¼ 8:8047  109
9.20. ð1Þ0  1:625  21;536 1;023 ¼ 4:3575  10154
9.25. B ¼ 2; S ¼ 2
xs

n

¼ xðnÞ
2
ysðnÞ ¼ 0:18xsðnÞ þ 0:8xsðn  1Þ þ 0:18xsðn  2Þ
yðnÞ ¼ 4ysðnÞ
9.26. S ¼ 1; C ¼ 2
xs

n

¼ x

n

; ys

n

¼ 0:75xs

n

þ 0:15yf

n  1

; yf

n

¼ 2ys

n

; y

n

¼ yf

n

9.29. S ¼ 8; A ¼ 2; B ¼ 4
xsðnÞ ¼ xðnÞ=8; wsðnÞ ¼ 0:5xsðnÞ  0:675wðn  1Þ  0:25wðn  2Þ;
wðnÞ ¼ 2wsðnÞ
ysðnÞ ¼ 0:18wðnÞ þ 0:355wðn  1Þ þ 0:18wðn  2Þ; yðnÞ ¼ 32ysðnÞ
Answers to Selected Problems
843

CHAPTER 10
10.1. w ¼ 2 and Jmin ¼ 10
10.3. w ¼ 5 and Jmin ¼ 50
10.5. wzw3 ¼ 1:984 and Jmin ¼ 10:0026
10.7. wzw3 ¼ 4:992 and Jmin ¼ 5:0001
10.9. a. yðnÞ ¼ wð0ÞxðnÞ þ wð1Þxðn  1Þ
eðnÞ ¼ dðnÞ  yðnÞ
wð0Þ ¼ wð0Þ þ 0:2  eðnÞxðnÞ
wð1Þ ¼ wð1Þ þ 0:2  eðnÞxðn  1Þ
b.
For n ¼ 0 :
yð0Þ ¼ 0
eð0Þ ¼ 3
wð0Þ ¼ 1:8
wð1Þ ¼ 1
For n ¼ 1 :
yð1Þ ¼ 1:2
eð1Þ ¼ 3:2
wð0Þ ¼ 2:44
wð1Þ ¼ 0:92
For n ¼ 2 :
yð2Þ ¼ 5:8
eð2Þ ¼ 4:8
wð0Þ ¼ 0:52
wð1Þ ¼ 0:04
10.13. a. nðnÞ ¼ 0:5$xðn  5Þ
b. xxðnÞ ¼ 5;000$dðnÞ, yyðnÞ ¼ 0:7071xxðn  1Þ þ 1:4141yyðn  1Þ  yyðn  2Þ
c. dðnÞ ¼ yyðnÞ  nðnÞ
d. For i ¼ 0; /; 24, wðiÞ ¼ 0
y

n

¼
X
24
i ¼ 0
wðiÞxðn  iÞ
844
Answers to Selected Problems

eðnÞ ¼ dðnÞ  yðnÞ
For i ¼ 0; /; 24
wðiÞ ¼ wðiÞ þ 2meðnÞxðn  iÞ
10.15. a. wð0Þ ¼ wð1Þ ¼ wð2Þ ¼ 0, m ¼ 0:1
yðnÞ ¼ wð0ÞxðnÞ þ wð1Þxðn  1Þ þ wð2Þxðn  2Þ
eðnÞ ¼ dðnÞ  yðnÞ
wð0Þ ¼ wð0Þ þ 0:2eðnÞxðnÞ
wð1Þ ¼ wð1Þ þ 0:2eðnÞxðn  1Þ
wð2Þ ¼ wð2Þ þ 0:2eðnÞxðn  2Þ
b. For n ¼ 0 : yð0Þ ¼ 0, eð0Þ ¼ 0, wð0Þ ¼ 0, wð1Þ ¼ 0, wð2Þ ¼ 0
For n ¼ 1 : yð1Þ ¼ 0, eð1Þ ¼ 2, wð0Þ ¼ 0:4, wð1Þ ¼ 0:4, wð2Þ ¼ 0
For n ¼ 2 : yð2Þ ¼ 0, eð2Þ ¼ 1, wð0Þ ¼ 0:6, wð1Þ ¼ 0:2,wð2Þ ¼ 0:2
10.17. a. wð0Þ ¼ wð1Þ ¼ 0, m ¼ 0:1
xðnÞ ¼ dðn  3Þ
yðnÞ ¼ wð0ÞxðnÞ þ wð1Þxðn  1Þ
eðnÞ ¼ dðnÞ  yðnÞ
wð0Þ ¼ wð0Þ þ 0:2eðnÞxðnÞ
wð1Þ ¼ wð1Þ þ 0:2eðnÞxðn  1Þ
b. For n ¼ 0 : xð0Þ ¼ 0, yð0Þ ¼ 0, eð0Þ ¼ 1, wð0Þ ¼ 0, wð1Þ ¼ 0
For n ¼ 1 : xð1Þ ¼ 0, yð1Þ ¼ 0, eð1Þ ¼ 1, wð0Þ ¼ 0, wð1Þ ¼ 0
For n ¼ 2 : xð2Þ ¼ 0, yð2Þ ¼ 0, eð2Þ ¼ 1, wð0Þ ¼ 0, wð1Þ ¼ 0
For n ¼ 3 : xð3Þ ¼ 1, yð3Þ ¼ 0, eð3Þ ¼ 1, wð0Þ ¼ 0:2, wð1Þ ¼ 0
For n ¼ 4 : xð4Þ ¼ 1, yð4Þ ¼ 0:2, eð4Þ ¼ 0:8, wð0Þ ¼ 0:36, wð1Þ ¼ 0:16
10.18. a. 30 coefﬁcients
10.20. For i ¼ 0; /; 19, wðiÞ ¼ 0
yðnÞ ¼
X
19
i ¼ 0
wðiÞxðn  iÞ
eðnÞ ¼ dðnÞ  yðnÞ
For i ¼ 0; /; 19
wðiÞ ¼ wðiÞ þ 2meðnÞxðn  iÞ
CHAPTER 11
11.1. a. D ¼ 0:714
b. For x ¼ 1:6 volts, binary code ¼ 110, xq ¼ 1:428 volts, and eq ¼ 0:172 volts
For x ¼ 0:2 volts, binary code ¼ 000, xq ¼ 0 volts, and eq ¼ 0:2 volts
Answers to Selected Problems
845

11.5.
For x ¼ 1:6 volts, binary code ¼ 111, xq ¼ 1:132 volts, and eq ¼ 0:468 volts
For x ¼ 0:2 volts, binary code ¼ 010, xq ¼ 0:224 volts, and eq ¼ 0:024 volts
11.9. a. 0 0 0 1 0 1 0 1
b. 1 1 1 0 0 1 1 1
11.10. a. 0 0 0 0 0 0 0 0 0 1 1 1
b. 1 0 1 1 0 0 1 1 0 0 0 0
11.13. 010
001
010
11.14. For binary code ¼ 110, ^xð0Þ ¼ ~xð0Þ þ dqð0Þ ¼ 0 þ 5 ¼ 5
For binary code ¼ 100, ^xð1Þ ¼ ~xð1Þ þ dqð1Þ ¼ 5 þ 0 ¼ 5
For binary code ¼ 110, ^xð2Þ ¼ ~xð2Þ þ dqð2Þ ¼ 5 þ 2 ¼ 7
11.17. a. 1:1
b. 2:1
c. 4:1
11.18. a. 128 KBPS
b. 64 KBPS
c. 32 KBPS
11.21. a. 12 channels
b. 24 channels
c. 48 channels
11.22. XDCTð0Þ ¼ 54; XDCTð1Þ ¼ 0:5412; XDCTð2Þ ¼ 4; XDCTð3Þ ¼ 1:3066
11.25. XDCTð1Þ ¼ 33:9730; XDCTð3Þ ¼ 10:4308; XDCTð5Þ ¼ 1:2001; XDCTð7Þ ¼ 1:6102
11.26. a. Inverse DCT: 10.0845 6.3973 13.6027 2.0845
b. Recovered inverse DCT: 11.3910 8.9385 15.0615 3.3910
c. Quantization error: 1.3066 2.5412 1.4588 1.3066
11.29. a. 9.0711 0.5858
13:3137
 0:0000
7:8995
0:5858
b. 3, 4, 5, 4
CHAPTER 12
12.3 a.
Anti aliasing
filter H(z)
x n
( )
w n
( )
4
y m
( )
f
Hz
s = 8000
f
Hz
s = 8000
f
KHz
sM = 2000
↓
b. Hamming window, N ¼ 133, fc ¼ 900 Hz
846
Answers to Selected Problems

12.4. a.
Interpolation
filter H(z)
x n
( )
w n
( )
3
↑
y m
( )
f
Hz
s = 8000
24000
sL
f
Hz
=
24000
sL
f
Hz
=
b. Hamming window, N ¼ 133, fc ¼ 3;700 Hz
12.7. a.
Interpolation
filter H1(z)
x n
( )
Anti aliasing
filter H2(z)
y m
( )
3
↓
4
↓
b. Combined ﬁlter HðzÞ: Hamming window, N ¼ 133, fc ¼ 2;700 KHz
12.8. a.
x n
( )
Anti aliasing
filter H2(z)
y m
( )
4
↓
10
↓
Anti aliasing
filter H1(z)
320 kHz
sf =
32 kHz
8 kHz
2
e
g
a
t
S
1
e
g
a
t
S
b. M1 ¼ 10 and M2 ¼ 4
c. Filter speciﬁcation for H1ðzÞ: Hamming window, N ¼ 43, fc ¼ 15; 700 Hz
d. Filter speciﬁcation for H2ðzÞ: Hamming window, N ¼ 177, fc ¼ 3; 700 Hz
12.9.
↑2
+
ρ0
1
0 25
05
( )
.
.
z
z
=
+
−
ρ1
0 4
( )
.
z =
x n
( )
y m
0( )
y m
1( )
z−1
y m
( )
f s
2⋅f s
w n
0( )
w n
1( )
+
ρ0
1
0 25
05
( )
.
.
z
z
=
+
−
ρ1
1
0 4
0 6
( )
.
.
z
z
=
+
−
x n
( )
y m
0( )
y m
1( )
z−1
y m
( )
f s
f s
2
w m
0( )
w m
1( )
(a)
(b)
↑2
↓2
↓2
Answers to Selected Problems
847

12.10.
(a) 
1
0( )
0.25
0.5
z
z
ρ
−
=
+
1( )
0.4
z
ρ
=
x n
( )
y n
0( )
y n
1( )
y m
( )
f s
2
sf
⋅
Switch
(b)
1
0( )
0.25
0.5
z
z
ρ
−
=
+
1
1( )
0.4
0.6
z
z
ρ
−
=
+
x n
( )
y m
0( )
y m
1( )
y m
( )
f s
Switch
+
2
sf
bank 0
bank 1
w m
0( )
w m
1( )
12.15. a. fs ¼ 2 fmax22ðn mÞ ¼ 2  15  22ð16 12Þ ¼ 7680 KHz
12 −bit ADC
Over sampling
f
KHz
s = 7680
Decimator
Over sampling rate
f
f
s
'
max
= 2
Minimum sampling rate
12.17. a.
+
−
x n
( )
Decimation
filter
y n
( )
w n
( )
H z
z
( ) =
−
−
1
1
1
z−1
+
e n
( )
Quantization
error
encoded by m bits
b. n ¼ 1 þ 1:5  log2
 128
2  4
	
 0:86z6 bits
12.18. a.
+
−
x n
( )
y n
( )
w n
( )
H z
z
( ) =
−
−
1
1
1
z−1
+
e n
( ) Quantization error
H z
z
( ) =
−
−
1
1
1
+
−
Decimator
4
↓
Anti-aliasing LPF
encoded by 10 bits
848
Answers to Selected Problems

b. n ¼ m þ 2:5  log2

fs
2 fmax
	
 2:14 ¼ 10 þ 2:5  log2
 160
2  20
	
 2:14
¼ 12:86z13 bits
12.21. a. fc=B ¼ 6 is an even number, which is case 1, so we select fs ¼ 10 kHz.
f
0
0
4
5
2
kHz
30
f kHz
40
20
0
Bandpass signal with
baseband bandwidth
B = 5 kHz
Bandpass signal
sampled at fs = 10 kHz
35
20
0
3
0
1
28
32
2
(a)
b. Since fc=B ¼ 5 is an odd number, we select fs ¼ 10 kHz.
f
0
0
4
5
2
kHz
30
f kHz
40
20
0
Bandpass signal with
baseband bandwidth
B = 5 kHz
Bandpass signal
sampled at fs = 10 kHz
35
20
0
3
0
1
23
27
3
(b)
c. Now, fc=B ¼ 6:6, which is a noninteger. We extend the bandwidth to B ¼ 5:5 kHz, so
fc=B ¼ 6 and fs ¼ 2B ¼ 11 kHz.
f
0
31
40
kHz
30
f kHz
40
20
0
Bandpass signal with
baseband bandwidth
B = 5.5 kHz
Bandpass signal
sampled at fs = 11 kHz
35
20
0
3
0
1
33
2
(c)
Answers to Selected Problems
849

CHAPTER 13
13.1. a. B ¼ fsM=2 ¼ fs=ð2MÞ; fc ¼ 2ðfs=ð2MÞÞ ¼ 2B; fc=B ¼ 2 ¼ even
4
↓
( )
w n
( )
x m
( )
X f
f
/ 2
sf
sf
/ 4
sM
s
f
f
=
/ 4
sf
b. B ¼ fsM=2 ¼ fs=ð2MÞ; fc ¼ fs=ð2MÞ ¼ B; fc=B ¼ 1 ¼ odd
4
↓
( )
w n
( )
x m
f
/ 2
sf
sf
/ 4
sM
s
f
f
=
/ 4
sf
( )
X f
13.3. From Equation (13.7), YðzÞ ¼ 1
2 ðWðzÞ þ Wðe jpzÞÞ, YðejUÞ ¼ 1
2 ðWðejUÞ þ WðejðU pÞÞÞ,
WðejðU pÞÞ is the shifted version of WðejUÞ by fs=2.
(a)
(b)
850
Answers to Selected Problems

13.5. H1

z

¼  1
2
p þ 1
2
p z 1; G0

z

¼
1
2
p þ 1
2
p z 1; G1

z

¼
1
2
p  1
2
p z 1
13.7. H1ðzÞ ¼ 0:129 þ 0:224z 1  0:837z 2 þ 0:483z 3
G0ðzÞ ¼ 0:129 þ 0:224z 1 þ 0:837z 2 þ 0:483z 3
G1ðzÞ ¼ 0:483  0:837z 1 þ 0:224z 2 þ 0:129z 3
13.9.
0
H
2
↓
( )
x n
( )
x n
1
H
2
↓
+
Analysis stage
Synthesis stage
2
↓
2
↓
2
↑
2
↑
+
0
G
2
↑
2
↑
1
G
13.11.
0
2
4
6
1
0
1
Time (sec.)
f(t)
0
2
4
6
1
0
1
Time (sec.)
(a) f(4t)
0
2
4
6
1
0
1
Time (sec.)
(b) f(t-2)
0
2
4
6
1
0
1
Time (sec.)
(c) f(2t-3)
0
2
4
6
1
0
1
Time (sec.)
(d) f(t/2)
0
2
4
6
1
0
1
Time (sec.)
(e) f(t/4-0.5)
Answers to Selected Problems
851

13.13.
0
2
4
6
2
0
2
Time (sec.)
f(t)
0
2
4
6
2
0
2
Time (sec.)
(a) f(4t)
0
2
4
6
2
0
2
Time (sec.)
(b) f(t-2)
0
2
4
6
2
0
2
Time (sec.)
(c) f(2t-3)
0
2
4
6
2
0
2
Time (sec.)
(d) f(t/2)
0
2
4
6
2
0
2
Time (sec.)
(e) f(t/4-0.5)
13.15.
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
0
1
2
j=0
t (sec)
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
0
1
2
j=1
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
0
1
2
j=2
852
Answers to Selected Problems

13.17. a. fðtÞ ¼ 4fð2tÞ  2fð2t  1Þ
b. fðtÞ ¼ fðtÞ þ 3jðtÞ
13.19. a. fðtÞ ¼ ð2=pÞfð2tÞ  ð2=pÞfð2t  1Þ
b. fðtÞ ¼ ð2=pÞjðtÞ
13.21. a.
P
N
k ¼
N
2
p
h0

k

f

4t  k

¼
2
p
h0

0

f

4t

þ
2
p
h0

1

f

4t  1

¼
2
p
 0:707fð4tÞ þ
2
p
 0:707fð4t  1Þ ¼ fð4tÞ þ fð4t  1Þ ¼ fð2tÞ
b.
P
N
k ¼
N
2
p
h1

k

f

4t  k

¼
2
p
h1

0

f

4t

þ
2
p
h1

1

f

4t  1

¼
2
p
 0:707f

4t

þ
2
p 
 0:707

f

4t  1

¼ f

4t

 f

4t  1

¼ j

2t

13.23. wðkÞ ¼ ½5:5000
0:5000
7:0711
2:1213
13.25. cðkÞ ¼ ½2:2929
3:7071
2:4142
 0:4142
13.27. cðkÞ ¼ ½2:1213
3:5355
2:8284
0
CHAPTER 14
14.1. a. 76.8 K bytes
b. 921.6 K bytes
c. 1920.768 K bytes
14.3. Y ¼ 142; I ¼ 54; Q ¼ 11
14.5.
"
53
44
59
50
#
14.7.
2
66664
1
4
6
6
1
6
4
4
6
4
4
4
6
6
6
1
6
7
7
4
3
77775
14.9.
2
66664
102
109
104
51
98
101
101
54
98
103
100
51
50
55
51
25
3
77775
Answers to Selected Problems
853

14.10. 2
66664
0
100
100
0
0
100
100
100
0
100
100
100
0
100
0
0
3
77775
14.11. a.
Vertical Sobel detector:
2
64
1
0
1
2
0
2
1
0
1
3
75 Processed image:
2
6666664
225
125
130
33
249
119
136
6
249
119
136
6
255
125
130
0
255
128
128
30
3
7777775
b.
Laplacian edge detector:
2
64
0
1
0
1
4
1
0
1
0
3
75 Processed image:
2
6666664
0
106
106
0
106
255
255
106
106
255
255
106
117
223
223
117
0
117
117
0
3
7777775
14.13. Blue is dominant in the area pointed to by the arrow; red is dominant in the background.
14.15.
X

u; v

¼
"
460
40
240
140
#
and A

u; v

¼
"
115
10
60
35
#
14.16.
Forward DCT: Fðu; vÞ ¼
"
230
20
120
70
#
14.17.
Inverse DCT: pði; jÞ ¼
"
110
100
100
90
#
14.19. a. (0, 2) (3, 4), (2, 3), (0, 7), (4, 2), (0, 0)
b. ð0000; 0010; 01Þ; ð0011; 0011; 100Þ; ð0010; 0010; 00Þ;
ð0000; 0011; 111Þ; ð0100; 0010; 01Þ; ð0000; 0000Þ
14.19. a. (0, 2) (3, 4), (2, 3), (0, 7), (4, 2), (0, 0)
b. ð0000; 0010; 01Þ; ð0011; 0011; 100Þ; ð0010; 0010; 00Þ;
ð0000; 0011; 111Þ; ð0100; 0010; 01Þ; ð0000; 0000Þ
854
Answers to Selected Problems

14.20. w ¼ 230:0000  20:0000
120:0000  70:0000
14.21. f ¼ 110:0000 100:0000
100:0000 90:0000
14.23. f ¼ 115:0000 145:0000 25:0000 45:0000
105:0000 135:0000
5:0000 25:0000
30:0000
20:0000
7:5000 27:5000
10:0000
-0:0000
-7:5000
12:5000
14.28. Hint :
Composite  2 sin ð2pfsctÞ ¼ Y  2 sin ð2pfsctÞ þ I cos ð2pfsctÞ  2 sin ð2pfsctÞ
þ Q  2 sin 2ð2pfsctÞ ¼ Y  2 sin ð2pfsctÞ þ I sin ð2  2pfsctÞ
þ Q  Q cos ð2  2pfsctÞ
Then apply lowpass ﬁltering.
14.35. 80  80
16  16 ð162  322  3Þ ¼ 19:661  106 operations
APPENDIX B
B.1. A0 ¼ 0:4; A1 ¼ 0:7916; A2 ¼ 0:7667; A3 ¼ 0:7263; A4 ¼ 0:6719
jc0j ¼ 0:4; jc1j ¼ jc 1j ¼ 0:3958;
jc2j ¼ jc 2j ¼ 0:3834; jc3j ¼ jc 3j ¼ 0:3632; jc4j ¼ jc 4j ¼ 0:3359
B.3. xðtÞ ¼ 2 þ 3:7420  cos ð2000ptÞ þ 3:0273  cos ð4000ptÞ
þ 2:0182  cos ð6000ptÞ þ 0:9355  cos ð8000ptÞ þ /
f2 ¼ 2000 Hz; A2 ¼ 3:0273
B.5. X

f

¼ 5
sin pf
pf
	2
B.7. a. XðsÞ ¼ 10
b. XðsÞ ¼ 100=s2
c. X

s

¼
10
s þ 2
d. X

s

¼ 2e 5s
s
e. X

s

¼
10s
s2 þ 9
Answers to Selected Problems
855

f. X

s

¼ 14:14 þ 7:07s
s2 þ 9
g. X

s

¼
3ðs þ 2Þ
ðs þ 2Þ2 þ 9
h. X

s

¼ 12; 000
s6
B.9. a. X

s

¼
7:5
sðs þ 1:5Þ
b. xðtÞ ¼ 5uðtÞ  5e 1:5tuðtÞ
B.11. a. zero: s ¼ 3, poles: s ¼ 2, s ¼ 2, stable
b. zeros: s ¼ 0, s ¼ 2:236j, poles: s ¼ 3j, s ¼ 1  1:732j, marginally stable
c. zeros: s ¼ j, s ¼ 1, poles: s ¼ 0, s ¼ 3, s ¼ 4, s ¼ 8, s ¼ 1, unstable
B.13. a. H

ju

¼
1
ju
5 þ 1
b. A

u

¼
1
1 þ
u
5
2
r
; b

u

¼ :  tan
u
5

c. Yðj2Þ ¼ 4:6424:  21:800 that is, yssðtÞ ¼ 4:6424 sin ð2t  21:800ÞuðtÞ
856
Answers to Selected Problems

References
Ahmed, N., & Natarajan, T. (1983). Discrete Time Signals and Systems. Englewood Cliffs, New Jersey: Prentice
Hall.
Akansu, Ali N., & Haddad, Richard A. (1992). Multiresolution Signal Decomposition: Transforms, Subbands,
and Wavelets. Boston: Academic Press, Inc.
Ambardar, A. (1999). Analog and Digital Signal Processing (second ed.). Paciﬁc Grove, CA: Brooks/Cole
Publishing Company, ITP.
Alkin, O. (1993). Digital Signal Processing: A Laboratory Approach Using PC DSP. Englewood Cliffs, New
Jersey: Prentice Hall.
Brandenburg, K. (1997). Overview of MPEG Audio: Current and Future Standards for Low Bit Rate Audio
Coding. Journal of Audio Engineering Society, 45(1/2), 4 21.
Carr, J. J., & Brown, J. M. (2001). Introduction to Biomedical Equipment Technology (fourth ed.). Upper Saddle
River, New Jersey: Prentice Hall.
Chassaing, R., & Reay, D. (2008). Digital Signal Processing and Applications with the TMS320C6713 and
TMS320C6416 DSK (second ed.). Hoboken, New Jersey: John Wiley & Sons.
Chen, W. (1986). Passive and Active Filters Theory and Implementations. New York: John Wiley & Sons.
Dahnoun, N. (2000). Digital Signal Processing Implementation Using the TMS320C6000TM DSP Platform.
Englewood Cliffs, New Jersey: Prentice Hall.
Deller, J. R., Proakis, J. G., & Hansen, J. H. L. (1993). Discrete Time Processing of Speech Signals. New York:
Macmillian Publishing Company.
El Sharkawy, M. (1996). Digital Signal Processing Applications with Motorola’s DSP56002 Processor. Upper
Saddle River, New Jersey: Prentice Hall.
Embree, P. M. (1995). C Algorithms for Real Time DSP. Upper Saddle River, New Jersey: Prentice Hall.
Gonzalez, R. C., & Wintz, P. (1987). Digital Image Processing (second ed.). Reading, Massachusetts: Addison
Wesley Publishing Company.
Grover, D., & Deller, J. R. (1998). Digital Signal Processing and the Microcontroller. Upper Saddle River, New
Jersey: Prentice Hall.
Haykin, S. (1991). Adaptive Filter Theory (second ed.). Englewood Cliffs, New Jersey: Prentice Hall.
Ifeachor, E. C., & Jervis, B. W. (2002). Digital Signal Processing: A Practical Approach (second ed.). Upper
Saddle River, New Jersey: Prentice Hall.
Jiang, J., & Tan, L. (June 2012). Teaching Adaptive Filters and Applications in Electrical and Computer
Engineering Technology Program. San Antonio, Texas: 2012 Proceedings of the American Society for
Engineering Education.
Kehtaranavaz, N., & Simsek, B. (2000). C6x Based Digital Signal Processing. Upper Saddle River, New Jersey:
Prentice Hall.
Krauss, T. P., Shure, L., & Little, J. N. (1994). Signal Processing TOOLBOX for Use with MATLAB. Natick,
Massachusetts: The Math Works Inc.
Kuo, S. M., & Morgan, D. R. (1996). Active Noise Control Systems: Algorithms and DSP Implementations. New
York: John Wiley & Sons.
Li, Z. N., & Drew, M. S. (2004). Fundamentals of Multimedia. Upper Saddle River, New Jersey: Prentice Hall.
Lipshiz, S. P., Wannamaker, R. A., & Vanderkooy, J. (May 1992). Quantization and Dither: ATheoretical Survey.
Journal of Audio Engineering Society, 40(5), 355 375.
Lynn, P. A., & Fuerst, W. (1999). Introductory Digital Signal Processing with Computer Applications (second
ed.). Chichester and New York: John Wiley & Sons.
857

Maher, Robert C. (January/February 1992). On the Nature of Granulation Noise in Uniform Quantization
Systems. Journal of Audio Engineering Society, 40(1/2), 12 20.
McClellan, J. H., Oppenheim, A. V., Shafer, R. W., Burrus, C. S., Parks, T. W., & Schuessler, H. (1998). Computer
Based Exercises for Signal Processing Using MATLAB 5. Upper Saddle River, New Jersey: Prentice Hall.
McClellan, J. H., Shafer, R. W., & Yoder, M. A. (1998). DSP First
A Multimedia Approach. Upper Saddle
River, New Jersey: Prentice Hall.
Nelson, M. (1992). The Data Compression Book. Redwood City, California: M&T Publishing, Inc.
Oppenheim, A. V., & Shafer, R. W. (1975). Discrete Time Signal Processing. Englewood Cliffs, New Jersey:
Prentice Hall.
Oppenheim, A. V., Shafer, R. W., & Buck, J. R. (1998). Discrete Time Signal Processing (second ed.). Upper
Saddle River, New Jersey: Prentice Hall.
Pan, David (1995). A Tutorial on MPEG/Audio Compression. IEEE Multimedia, 2(2), 60 74.
Phillips, C. L., & Harbor, R. D. (1991). Feedback Control Systems (second ed.). Englewood Cliffs, New Jersey:
Prentice Hall.
Phillips, C. L., & Nagle, H. T. (1995). Digital Control System Analysis and Design (third ed.). Englewood Cliffs,
New Jersey: Prentice Hall.
Porat, B. (1997). A Course in Digital Signal Processing. New York: John Wiley & Sons.
Princen, J., & Bradley, A. B. (October 1986). Analysis/Synthesis Filter Bank Design Based on Time
Domain Aliasing Cancellation. IEEE Transactions on Acoustics, Speech, and Signal Processing, Vol.
ASSP 34, No. 5, 1153 1161.
Proakis, J. G., & Manolakis, D. G. (1996). Digital Signal Processing: Principles, Algorithms, and Applications
(third ed.). Upper Saddle River, New Jersey: Prentice Hall.
Rabbani, M., & Jones, P. W. (1991). Digital Image Compression Techniques. Bellingham, Washington: The
Society of Photo Optical Instrumentation Engineers (SPIE).
Rabiner, L. R., & Schafer, R. W. (1978). Digital Processing of Speech Signals. Englewood Cliffs, New Jersey:
Prentice Hall.
Randall, R. B. (2011). Vibration Based Conditioning Monitoring: Industrial, Aerospace, and Automotive
Applications. Chichester: John Wiley & Sons.
Roddy,D.,&Coolen,J.(1997).ElectronicCommunications(fourthed.).EnglewoodCliffs,NewJersey:PrenticeHall.
Sayood, K. (2000). Introduction to Data Compression (second ed.). San Francisco: Academic Press.
Smith, M. J. T., & Barnwell, T. P. (1984). A Procedure for Designing Exact Reconstruction Filter Banks for Tree
Structured Sub band Coders. San Diego, California: Proceedings of the IEEE International Conference on
Acoustics, Speech, and Signal Processing, 27.1.1 27.1.4.
Soliman, S. S., & Srinath, M. D. (1998). Continuous and Discrete Signals and Systems (second ed.). Upper
Saddle River, New Jersey: Prentice Hall.
Sorensen, H. V., & Chen, J. P. (1997). A Digital Signal Processing Laboratory Using TMS320C30. Upper Saddle
River, New Jersey: Prentice Hall.
Stanley, W. D. (2003). Network Analysis with Applications (fourth ed.). Upper Saddle River, New Jersey:
Prentice Hall.
Stearns, S. D., & David, R. A. (1996). Signal Processing Algorithms in MATLAB. Upper Saddle River, New
Jersey: Prentice Hall.
Stearns, S. D., & Hush, D. R. (1990). Digital Signal Analysis (second ed.). Englewood Cliff, New Jersey:
Prentice Hall.
Stearns, S. D. (2003). Digital Signal Processing with Examples in MATLAB. Boca Raton, Florida: CRC Press LLC.
Tan, L., & Jiang, J. (June 2010). Improving Digital Signal Processing Course with Real Time Processing
Experiences for Electrical and Computer Engineering Technology Students. Louisville, Kentucky: 2010
Proceedings of the American Society for Engineering Education.
858
References

Tan, L., & Wang, L. (November 2011). Oversampling Technique for Obtaining Higher Order Derivative of Low
Frequency Signals. IEEE Transactions on Instrumentation and Measurement, 60(11), 3677 3684.
Tan, L., & Jiang, J. (Fall 2008). A Simple DSP Project for Teaching Real time Signal Rate Conversions. The
Technology Interface Journal, 9(1).
Tan, L., & Jiang, J. (2012). Novel Adaptive IIR Notch Filters for Frequency Estimation and Tracking, Chapter
20. Streamlining Digital Signal Processing: A Tricks of the Trade Guidebook. Edited by Richard G. Lyons,
Hoboken, New Jersey: IEEE Press/Wiley & Sons, 197 205.
Tomasi, W. (2004). Electronic Communications Systems: Fundamentals Through Advanced (ﬁfth ed.). Upper
Saddle River, New Jersey: Prentice Hall.
Texas Instruments. (1991). TMS320C3x User’s Guide. Dallas, Texas: Texas Instruments.
Texas Instruments. (1998). TMS320C6x CPU and Instruction Set Reference Guide, Literature ID# SPRU 189C.
Dallas, Texas: Texas Instruments.
Texas Instruments. (2001). Code Composer Studio: Getting Started Guide. Dallas, Texas: Texas Instruments.
Vegte, J. (2002). Fundamentals of Digital Signal Processing. Upper Saddle River, New Jersey: Prentice Hall.
Vetterli, M., & Kovacevic, J. (1995). Wavelets and Subband Coding. Englewood Cliffs, New Jersey: Prentice
Hall PTR.
Webster, J. G. (1998). Medical Instrumentation: Application and Design (third ed.). New York: John Wiley &
Sons, Inc.
Yost, William A. (1997). Fundamentals of Hearing: An Introduction (third ed.). San Diego, California: Academic
Press.
References
859

This page intentionally left blank

Index
Note: Page Numbers with “f” denote ﬁgures; “t” tables
A
Adaptive ﬁlters
adaptive echo cancellers, 479 480, 479f
electrocardiography interference cancellation,
476 478, 477f, 478f
least mean square adaptive FIR ﬁlters
corrupted signal and noise reference, 455 457, 456f,
456t
desired signal spectrum, 453, 454f
noise canceller, 454, 454f
one tap FIR ﬁlter, 455, 457
linear prediction
line enhancement, 473 475, 473f, 474f, 475f
periodic interference cancellation, 476, 476f
long distance telephone circuit, 479, 479f
noise cancellation, see Noise cancellation
system modeling, 468, 468f
MATLAB program, 470
spectrum for, 470, 472f
unknown system’s frequency responses, 469, 470f
waveforms for, 470, 471f
TMS320C6713 DSK, see TMS320C6713 DSK
Wiener ﬁlter theory
autocorrelation and cross correlation, 459
LMS algorithm, 461 462
mean square error quadratic function, 457 458,
458f
noise cancellation, 457, 457f
statistical expectation, 457 458, 461 462
steepest descent algorithm, 459, 460f, 461 462
Adaptive differential pulse code modulation (ADPCM)
decoder, 512 514, 513f
discrete function, 514 515, 515t
encoder, 512 514, 513f
FIR ﬁlter, 516 517
input and output characteristics, 514, 514t
16 level nonuniform adaptive quantizer, 514
performance measurement, 518
predictor z transfer function, 516 517
scale factor, 514 515
speech samples, 517 518, 517f
ADC, see Analog to digital conversion (ADC)
Address generators
circular buffering, 409, 410f
equivalent FIFO, 410f, 411
FIR ﬁltering, 411
Aliasing level, 28
Amplitude modulation (AM), 603, 603f
Amplitude spectrum
DFT, 87, 88f, 97 101
Fourier series, 89, 89f
Analog to digital conversion (ADC)
binary codes, 40, 41f
2 bit ﬂash ADC unit, 36, 36f
implementation, 35 36
oversampling, 587, 587f
beneﬁts of, 586
continuous vs. regular sampled vs. oversampled signal
amplitudes, 588 589, 591f
frequency response, 588 589, 589f
in band frequency range, 587
MATLAB program, 589
oversampling ratio, deﬁnition, 585 586
quantization noise power, 586 588
regular ADC system, 586 587, 586f
time vs. frequency domains, 588 589,
590f
quantization
bipolar quantizer, 38 40, 39f, 40t
deﬁnition, 35, 36f
error, 37
notations and rules, 38
process, 37
SNR, 47
unipolar quantizer, 38, 38f, 39t
SDM ADC, see Sigma delta modulation analog
to digital conversion (SDM ADC)
Analog ﬁlters
lowpass prototype transformation, 305,
306t
bandpass ﬁlter, 305, 306f
bandstop ﬁlter, 305, 306f
cutoff frequency, 304 305
highpass ﬁlter, 305, 305f
lowpass ﬁlter, 304, 304f
magnitude response, 304 305
MATLAB function, 307
steady state frequency response, 178
Analog m law companding
characteristics, 502, 502f
compressor, 501, 501f
expander, 501 502, 501f
original speech data, 504, 505f
quantization error, 501
861

Analog signal processing
convolution, 798 799
Fourier series
amplitude and phase spectrum, 779
amplitude phase form, 776
complex exponential form, 776 782, 784t
Fourier transform, 786 791, 789t, 790t
rectangular waveform, 780, 780f
sine cosine form, 775, 780, 783t
Laplace transform
differential equations, 793 794
and table, 791 793, 791t
transfer function, 794 795
poles, zeros and stability, 795 796
sinusoidal steady state response, 799 804
Analog system program, 482
Analog video
“back porch”, 748
electrical signal demodulation, 748 750, 749f
frame via row wise scanning, 747
frequency modulation, 751
interlaced raster scanning, 747, 748f
NTSC TV standard, 750, 751f
PAL system, 752
QAM, 751 752
SECAM system, 752, 752t
vertical synchronization, 749f, 750
video data, retrace and sync layout, 750, 750f
video modulated waveform, 747, 748f
Analysis ﬁlter
channel 0, 622, 623f
channel 1, 622, 623f
channel 2, 622 624, 624f
channel 3, 624, 625f
4 channel ﬁlter bank, 621 622, 622f
Anti aliasing ﬁlter
aliasing level percentage, 28
Butterworth magnitude frequency response,
25 26
Sallen Key lowpass ﬁlter, 26 27, 26f
sampled analog signal, 25, 26f
Anti image ﬁlter
DAC unit, 30 31, 30f
sample and hold effect
digital equalizer, 32, 33f
and distortion percentage, 31f, 32
lowpass ﬁltering effect, 30 31, 31f
shaping effect, 32, 33f
transfer function, 30 31
Application speciﬁc integrated circuit (ASIC), 412
Auxiliary register arithmetic units (ARAUs),
428 429
B
Bandpass ﬁlters
amplitude spectra, 203, 205f
analog lowpass ﬁlters, 321, 322f
design speciﬁcations, 389
digital Chebyshev lowpass prototype functions, 321, 322f,
331 337
digital fourth order bandpass Butterworth ﬁlter, 203
frequency responses, 203, 203f
lowpass prototype transformation, 305, 306f
MATLAB program, 204
normalized ﬁlter, 187, 187f
original and ﬁltered speech plots, 203, 204f
second order bandpass ﬁlter, 352 354, 353f
Bandpass signals, undersampling, 603 608, 603f, 604f,
605f, 606f
Bandstop ﬁlters
digital Butterworth lowpass prototype functions,
331 337
digital Chebyshev lowpass prototype functions,
331 337
lowpass prototype transformation, 305, 306f
normalized ﬁlter, 188, 188f
Bartlett window, 230, 231f
Bilinear transformation (BLT) design method, 391
analog ﬁlters, lowpass prototype transformation,
305, 306t
bandpass ﬁlter, 305, 306f
bandstop ﬁlter, 305, 306f
cutoff frequency, 304 305
highpass ﬁlter, 305, 305f
lowpass ﬁlter, 304, 304f
magnitude response, 304 305
MATLAB function, 307
design procedure, 303 304, 303f, 314 318, 316t
frequency warping, 312, 313f
digital frequency, 312
digital integration method, 308, 309f
graphical representation, 313, 314f
Laplace transfer function, 309 310
mapping properties, 310, 310f
s plane vs. z plane, frequency mapping, 312, 312f
z transform, 309 310
Bipolar quantizer, 38 40, 39f, 40t
Blackman window, 230, 231f
BLT design method, see Bilinear transformation (BLT)
design method
Bounded in and bounded out (BIBO) stability,
71 72, 71f
Butterworth ﬁlters, 338 340, 338t, 339t
see also Digital Butterworth lowpass prototype functions
Butterworth magnitude frequency response, 25 26
862
Index

C
Cascade (series) realization method, 192, 195, 196f
Causal system, 66 67
CD recording system, see Compact disc (CD) recording
system
Chebyshev ﬁlters, 388 389
see also Digital Chebyshev lowpass prototype functions
Chebyshev polynomial approximation, 269
Chrominance channels, 688 689
Circular convolution
forward ﬁlter coefﬁcients, 670
reversed ﬁlter coefﬁcients, 668
Comite´ Consultatif International Te´le´phonique et
Te´le´graphique (CCITT), 754
Compact disc (CD) recording system
decoder, 8f, 9
encoder, 7 9, 8f
Companding
analog m law companding, see Analog m law companding
digital m law companding, see Digital m law companding
Component video, 746
Composite video, 746
Compression, see Discrete cosine transform (DCT)
see also image compression
Conjugate quadrature ﬁlter (CQF), 630
Continuous wavelet transform (CWT), 638, 641
Convolution, 72 80, 798 799
impulse response, 69
linear, 142 143
Cyclic redundancy check (CRC) code, 526
D
DAC, see Digital to analog conversion (DAC)
DCT, see Discrete cosine transform (DCT)
Decimation, 556
Decimation ﬁlter, 581, 581f, 582t
commutative model, 582 583, 583f
ﬁlter bank coefﬁcients, 582
implementation, 582, 582f, 584
three tap decimation ﬁlter, 581
Decimation in frequency method
bit reversal process, 126, 127f
eight point FFT
12 complex multiplications, 124 126, 125f
ﬁrst iteration, 123 124, 125f
inverse of, 127 128, 127f
second iteration, 124, 125f
graphical operations, 123 124, 125f
index mapping for, 126, 126t
inverse FFT, deﬁnition, 126
twiddle factor, 123 124
Decimation in time method
eight point FFT algorithm, 128 129, 130f
eight point IFFT, 129 131, 131f
ﬁrst iteration, 128 129, 130f
frequency bins, 128 129
second iteration, 128 129, 130f
Decomposition, see Two channel perfect reconstruction
quadrature mirror ﬁlter bank
Delta modulation (DM), 511
Denoise, 668, 670f
DFT, see Discrete Fourier transform (DFT)
Difference equation, 67 68, 79
DSP system, input and output, 162, 162f
ﬁlter() function, 165
ﬁltic() function, 165
nonzero initial conditions, 165
transfer function
impulse response, 169
step response, 169
system response, 169 172
z transfer function, 166 167, 166f
zero initial conditions, 165
Differential pulse code modulation (DPCM)
3 bit quantizer, 509, 510t
direct current coefﬁcients, 736
encoder and decoder, 509, 509f
quantization step size, 512
Digital to analog conversion (DAC), 47
anti image ﬁlter and equalizer, 30 31, 30f
process, 40, 41f
quantization error, 40 42
quantization noise, 42
quantized vs. original signal, 44f
R 2R ladder DAC, 36 37, 37f
SNR, 42
Digital audio equalizer, 341f
audio spectrum, 343 344, 343f
audio test signal, 343 344
ﬁlter banks design, 342, 342t
magnitude frequency responses, 342, 342f
MATLAB program, 344
speciﬁcations for, 341, 341t
Digital Butterworth lowpass prototype functions, 318, 319t
magnitude response function, 318, 320f
prototype ﬁlter order, 318 320
Digital Chebyshev lowpass prototype functions, 318, 319t,
320t
analog ﬁlter speciﬁcation conversion, 321, 322t
analog lowpass and bandpass ﬁlters, 321, 322f
lowpass prototype order, 321
magnitude response function, 320 321, 321f
Digital convolution, 72 80
Digital crossover design
Index
863

Digital crossover design (Continued)
lowpass and highpass ﬁlters
impulse responses, 260, 261f
magnitude frequency responses, 260, 260f, 261f
speaker drivers, 258 259, 259f
speciﬁcations, 259 260
Digital ﬁltering system
analog ﬁlter steady state frequency response, 178
difference equation, see Difference equation
digital ﬁlters, see Digital ﬁlters
Euler’s formula, 179
FIR and IIR systems, 186
frequency response properties, 180
inverse z transform, 179
magnitude frequency response, 178, 181
normalized digital frequency, 178
signal enhancement
biomedical signals, 199
ECG signal, notch ﬁltering, 205 206, 206f, 207f, 208f
speech signals, see Speech signals
sinusoidal inputs, system response, 180, 181f
steady state frequency responses, 178, 178f, 180
system transient response, 178, 178f
types
freqz() function, 188
normalized bandpass ﬁlter, 187, 187f
normalized bandstop ﬁlter, 188, 188f
normalized highpass ﬁlter, 187, 187f
normalized lowpass ﬁlter, 186f, 187
passband, stopband and transition band, 186
z plane pole zero plot, 172f
analog to digital conversion, 174
bounded in/bounded out stability, 175
features, 172
Laplace shift property, 174
Laplace vs. z transform, 173, 174f
s plane vs. z plane mapping, 175, 175f
stability rules, 175, 176f
Digital ﬁlters
cascade (series) realization method, 192, 195, 196f
direct form II realization method, 192 195, 195f
direct form I realization method, 192 193, 194f
parallel realization method, 192, 196 199, 196f
sinusoidal steady state response, 813f
inverse z transform, 814
magnitude and phase response, 814
properties of, 815 816
z transform output, 813
Digital m law companding
8 bit compressed PCM code format, 505 506, 506t, 508
509, 508f
characteristics, 505, 506f
compressor and expander, 504, 505f
decoding table, 506 508, 507t
encoding table, 505 506, 507t
Digital signal processing (DSP), 1, 2f
aliasing distortion, 2
analog input signal, 2
audio signals and spectrums, 3, 5f
digital ﬁltering, 3, 3f, 4f
DS processor, 2
real world applications, 12, 12t
CD recording system, 7 9, 8f
data compressor, 7, 8f
data expander, 7, 8f
digital image enhancement, 9 12, 12f
interference cancellation, electrocardiography,
5 7, 7f
software audio players, 9
two band digital crossover, 5, 6f
vibration signature analysis, 9, 10f, 11f
signal frequency (spectrum) analysis, 3, 4f
speech samples and spectrum, 4, 6f
Digital signal (DS) processor
adder output, 429
ASIC, 412
features, 406, 411
FIR ﬁlter, direct form I implementation, 430, 430f
ﬁxed point format, 411 412
3 bit 2’s complement number, 412 413, 412t, 413t
computational units, 427
C program, 445 446, 446t, 447f, 448f
fractional binary 2’s complement system, 414
program control unit, 427
Q 30 format, 418, 418f
Q format number, 415, 415f, 418
TMSC320C54x family architecture, 426 427, 426f
ﬂoating point format, 411 412, 419, 419f
advantages, 427
ARAUs, 428 429
C programs, 445, 445f
IEEE format, 423 426, 423f, 425f
overﬂow, 422
rules for, 420
speech quality applications, 429
TMS320C3x processor, 427 428, 428f
underﬂow, 423
hardware units
address generators, see Address generators
MAC, 408 409, 409f
shifters, 409
Harvard architecture, 407, 407f
execution cycle, 407, 408f
pipelining operation, 408
864
Index

IIR ﬁlter
direct form II implementation, 432, 432f
transfer function, 433
linear buffering, see Linear buffering
manufactures, 411
real time processing
input and output sample clock, 438, 439f
program segment, 438, 440f
TMS320C6713 DSK setup, 438, 440f
scale factor, 429
second order section ﬁlters, 434
TMS320C67x DSK, 436f, 437
C6713 DSK board, 434 436, 435f
memory and internal buses, 438
peripherals, 438
registers of, 437, 437f
software tool, 438
Texas InstrumentsVeloci architecture, 437
TMS320C6713 DSK, 438, 439f
Von Neumann architecture, 406, 406f
applications, 408
execution cycles, 407, 408f
opcode and operand, 406
Digital signals
BIBO stability, 71 72, 71f, 80
causal system, 66 67
difference equation format, 67 68, 79
digital convolution, 72 80
digital samples, 58, 58f
digital sequences, 61, 61f
analog signal function, 62, 79
exponential function, 60, 60f, 61t
sampling rate, 61
shifted unit impulse and unit step sequences,
59, 59f
sinusoidal function, 60, 60f, 60t
unit impulse sequence, 58 59, 59f
unit step sequence, 59, 59f, 62
DS processor, 58
impulse response
digital convolution sum, 69
FIR system, 69
IIR system, 71
unit impulse response, 68, 68f
linear system, 63 65, 64f
notation of, 57 58, 58f
time invariant system, 65 66, 65f
Direct form II realization method, 192 195, 195f
Direct form I realization method, 192 193,
194f
Discrete cosine transform (DCT), 519 522, 524 525, 525f
coefﬁcients, 731, 732t
scan order, 732, 733t
image compression
2D DCT, 729 731
JPEG image compression, see JPEG image compression
lossless/lossy compression, 728
principle of, 729
wavelet transform, see Wavelet transform
Discrete Fourier transform (DFT), 625
amplitude spectrum, 87, 88f, 97 101
data window time, 97 101
deﬁnition, 88
FFT
applications of, 97, 97f
data sequence, 101 102
decimation in frequency method, see Decimation in
frequency method
decimation in time method, see Decimation
in time method
digital sequence sample, 123
interpolated spectrum, 102 103
zero padding effect, 102 103, 102f
fft() and ifft() MATLAB functions, 93, 93t
formula development, 91, 92f
Fourier series, 132
see also Fourier series
amplitude spectral components, 90
coefﬁcients, 88 89
periodic digital signal, 88, 89f
two side line amplitude spectrum, 89, 89f
frequency bin, 95
frequency resolution, 96 101
inverse of, 93
phase spectrum, 97 101
power spectrum, 97 101
signal amplitude vs. sampling time instant, 87
spectral estimation, window functions
Hamming window, 109 110, 111f
see also Hamming window function
Hanning window, 109 110, 111f
periodic, continuous and band limited data,
107, 107f
rectangular window, 109 110, 111f
signal samples and spectra, 107 108, 108f
spectral leakage, 108
triangular window, 109 110, 111f
window operation, 108 109, 109f, 110f
twiddle factor, 92 93
Discrete wavelet transform (DWT)
discrete time function, 656 657
dwt() function, 671
dyadic subband coding structure, 657, 658f
IDWT, 656
Index
865

Discrete wavelet transform (DWT) (Continued)
idwt() function, 671
lowpass and highpass ﬁlter coefﬁcients, 656
signal amplitude, 657
4 tap Daubechies ﬁlters, frequency response, 656, 657f
time frequency plane, 661 664, 662f
time frequency plot, 661 664, 661f
wavelet coefﬁcients, 656
wavelet expansion, 655
Downsampling, 557f
data sequence, 556
deﬁnition, 556
MATLAB program, 559, 609
normalized stop frequency edge, 556 557
Nyquist sampling theorem, 556
spectral plots, 556 557, 558f
TMS320C6713 DSK, 608, 612f
using anti aliasing ﬁlter, spectral plots, 558 559, 560f
without using anti aliasing ﬁlter, spectral plots, 558, 559f
z transform, 556 557
DPCM, see Differential pulse code modulation (DPCM)
DSP, see Digital signal processing (DSP)
Dual tone multifrequency (DTMF) tone generator, 442
Goertzel algorithm, 392
advantages, 380
DFT algorithm, 377
DFT coefﬁcient, 378 379
Euler’s identity, 378 379
MATLAB function, 382
modiﬁed second order Goertzel IIR ﬁlter,
380 381, 381f
second order Goertzel IIR ﬁlter, 310 311, 377
transfer function, 377
MATLAB program, 377
modiﬁed Goertzel algorithm, 384f
see also Modiﬁed Goertzel algorithm
ASCII code, 385 386
design principles, 383
frequency bins, 383, 384t
MATLAB simulation, 385 386, 386f
telephone touch keypads, 373 375, 373f, 376f
DWT, see Discrete wavelet transform (DWT)
E
Echo cancellation, 479 480, 479f
Edge detection, 717, 718f
differential convolution kernel, 715 716
grayscale image, 717, 719f
horizontal Sobel edge detector, 716
Laplacian edge detector, 716 717
Laplacian of Gaussian ﬁlter, 717, 719f
MATLAB functions, 718 721, 720f
vertical Sobel edge detector, 716
Electrocardiography (ECG)
60 Hz hum eliminator and heart rate detection, 392
cascaded frequency responses, 365, 366f
characteristics of, 362, 363f
design speciﬁcations, 364 365
harmonics, 364
heart rate, deﬁnition, 367 368
MATLAB program, 368
QRS complex, 362 364
signal enhancement system, 364, 364f
signal processing results, 366, 367f
signal spectrum, 362, 363f
transfer function and difference equation, 365
zero crossing algorithm, 366 367, 368f
interference cancellation, 476 478, 477f, 478f
Equalizer, see Anti image ﬁlter
Euler’s identity, 378 379
Exponent, ﬂoating point format, 419
F
Fast Fourier transform (FFT), 3 4
applications of, 97, 97f
data sequence, 101 102
decimation in frequency method, see Decimation in
frequency method
decimation in time method, see Decimation in time
method
digital sequence sample, 123
interpolated spectrum, 102 103
zero padding effect, 102 103, 102f
Father wavelet, 642, 644f
fconv() function, 670
fft() and ifft() MATLAB functions, 93, 93t
Finite impulse response (FIR) ﬁlter design, 69, 286t, 287
coefﬁcient accuracy effects, 282 285
Fourier transform design, 221t, 222, 290
coefﬁcient symmetry, 220
desired impulse response, 220, 221f
Fourier coefﬁcients, 219
Gibbs oscillatory behavior, 224, 229
ideal lowpass ﬁlter, 219, 219f
ideal lowpass frequency response, 219, 219f
linear phase response, 223, 224f, 226 227, 226f, 227f
magnitude and phase frequency responses, 224, 225f
nonlinear phase response, 226, 227f
periodic frequency response, 219
sinusoidal sequence, 225
symmetric coefﬁcients, 224 225
17 tap FIR lowpass ﬁlter coefﬁcients, 224, 225t
z transfer function, 220
frequency sampling, 286, 817 820
866
Index

design procedure, 263
desired ﬁlter frequency response, 262, 262f
DFT, 262
features, 262
IDFT, 262
magnitude frequency response, 269
input output relationship, 217
linear phase form, 281, 282f
noise reduction
clean signal and spectrum, 254, 255f
data acquisition process, 253
MATLAB program, 255
noise signal and spectrum, 254, 254f
passband frequency range, 254
speech noise reduction, 256 257, 256f, 257f
stopband frequency range, 254
vibration signals, 257 258, 258f, 259f
optimal design method, 286 287
see also Parks McClellan algorithm
transfer function, 218
transversal form, 280 281, 280f
two band digital crossover
impulse responses, lowpass and highpass ﬁlters, 260,
261f
magnitude frequency responses, lowpass and highpass
ﬁlters, 260, 260f, 261f
speaker drivers, 258 259, 259f
speciﬁcations, 259 260
window method, 285 286
see also Window method
Finite precision, 35, 40 42
First order IIR ﬁlter transfer function, 369 371
Fixed point DS processor, 411 412
3 bit 2’s complement number, 412, 412t
fractional representation, 413, 413t
computational units, 427
direct form II implementation, C code, 445 446, 446t,
447f, 448f
fractional binary 2’s complement system, 414
program control unit, 427
Q 30 format, 418, 418f
Q format number, 415, 415f, 418
TMSC320C54x family architecture, 426 427, 426f
Floating point DS processor, 411 412, 419, 419f
advantages, 427
ARAUs, 428 429
direct form I implementation, C code, 445, 445f
IEEE format
double precision format, 425, 425f
single precision format, 423 424, 423f
overﬂow, 422
rules for, 420
speech quality applications, 429
TMS320C3x processor, 427 428, 428f
underﬂow, 423
Folding frequency, 20, 47
Fourier series, 132
amplitude phase form, 776
amplitude and phase spectrum, 779
amplitude spectral components, 90
coefﬁcients, 88 89
complex exponential form, 776 782
waveform signals, 784t
Fourier transform, 786 791
properties, 790t
waveform signals, 789t
periodic digital signal, 88, 89f
rectangular waveform, 780, 780f
sine cosine form, 775, 780
waveform signals, 783t
two side line amplitude spectrum, 89, 89f
Frequency modulation (FM), 751
Frequency resolution, 96 101
Frequency sampling method, 286
design procedure, 263
desired ﬁlter frequency response, 262, 262f
DFT, 262, 817
Euler formula, 817
features, 262
frequency response, 819 820
IDFT, 262
L’Hospital’s rule, 817
magnitude frequency response, 269
Frequency warping effect, 312, 313f
digital frequency, 312
digital integration method, 308, 309f
graphical representation, 313, 314f
Laplace transfer function, 309 310
mapping properties, 310, 310f
s plane vs. z plane, frequency mapping, 312, 312f
z transform, 309 310
G
Gaussian ﬁlter kernel, 711 712
Gibbs effect, 224
Goertzel algorithm, 392
advantages, 380
DFT algorithm, 377
DFT coefﬁcient, 378 379
Euler’s identity, 378 379
MATLAB function, 382
modiﬁed second order Goertzel IIR ﬁlter, 380 381, 381f
second order Goertzel IIR ﬁlter, 310 311, 377
transfer function, 377
Index
867

Grayscale histogram and equalization
equalized grayscale image, human neck, 695, 697f
new pixel value, 693 695
original grayscale image, human neck, 695, 696f
pixel value distribution, 692 693
H
Hamming window function, 230, 231f
ECG data, 118f, 119
seismic data, 116, 118f
speech data, 116, 117f
vibration signal, 119, 119f, 121f, 122f
vibration signature analysis, gearbox, 119 120,
120f
Hanning window, 230, 231f
Harvard architecture, 407, 407f
execution cycle, 407, 408f
pipelining operation, 408
High deﬁnition TV (HDTV) formats, 754, 754t
Highpass ﬁlters
coefﬁcients, 656
digital Butterworth lowpass prototype functions,
322 331
digital Chebyshev lowpass prototype functions,
322 331, 322f
impulse responses, 260, 261f
lowpass prototype transformation, 305, 305f
magnitude frequency responses, 260, 260f, 261f
Histogram equalization, 9 12
Horizontal Sobel edge detector, 716
Huffman coding, 528, 737, 737t
I
IDWT, see Inverse discrete wavelet transform (IDWT)
IEEE ﬂoating point format
double precision format, 425, 425f
single precision format, 423 424, 423f
IIR ﬁlter design, see Inﬁnite impulse response (IIR) ﬁlter
design
Image processing
24 bit color image equalization, 695, 698f
equalized RGB color image, 698, 699f
histogram equalization method, 698, 699f
original RGB color image, 698, 698f
RGB channels, equalization effects, 698 699, 700f
8 bit indexed color image equalization, 700 701, 701f,
702f
compression, DCT
2D DCT, 729 731
JPEG image compression, see JPEG image compression
lossless/lossy compression, 728
principle of, 729
wavelet transform coding, see Wavelet transform coding
2D DFT, 725
deﬁnition, histogram, 692
edge detection, 717, 718f
differential convolution kernel, 715 716
grayscale image, 717, 719f
horizontal Sobel edge detector, 716
Laplacian edge detector, 716 717
Laplacian of Gaussian ﬁlter, 717, 719f
MATLAB functions, 718 721, 720f
vertical Sobel edge detector, 716
grayscale histogram and equalization
equalized grayscale image, human neck, 695, 697f
new pixel value, 693 695
original grayscale image, human neck, 695, 696f
pixel value distribution, 692 693
image level adjustment
display level adjustment, 707
linear level adjustment, 704 706, 705f, 706f
MATLAB functions, 707, 708f
lowpass noise ﬁltering
average convolution kernel, 709
Gaussian ﬁlter kernel, 711 712
noisy and enhanced image, 711 712, 711f, 712f,
713f
MATLAB functions, equalization, 702 704, 703f
median ﬁltering
enhanced image, 714, 715f
“pepper and salt” noise, 714, 715f
principle of, 712 714
notation and data formats
8 bit color image, 687, 687f
24 bit color image, 686, 686f
8 bit grayscale image, 684 685, 685f
chrominance channels, 688 689
format conversion, 690 691, 691f
grayscale image conversion, RGB to YIQ
transformation, 690, 690f
image pixel notation, 684, 685f
intensity image, 688, 688f
luminance channel, 688 689
spatial resolution, 684
transformation and inverse transformation,
688 689
pseudo color generation and detection
grayscale to pseudo color pixel, 722, 722f
MATLAB code, 725
procedure for, 724f
sine functions, RGB transformations, 722, 723f
video sequence creation, 745 746, 746f, 747f
video signals, see Video signals
Impulse function, 374
868
Index

Impulse invariant design method, 345f, 389, 392
ﬁlter DC gain, 348
inverse Laplace transform, analog impulse function, 345
346
rectangular approximation, 346 348
sampling interval effect, 348, 349f
scaled magnitude frequency response, 347f, 348
second order ﬁlter design, 348 351
Impulse response system
digital convolution sum, 69
FIR system, 69
IIR system, 71
unit impulse response, 68, 68f
Inﬁnite impulse response (IIR) ﬁlter design, 71, 389, 390t,
391f
bandpass ﬁlter design speciﬁcations, 389
BLT design method, 388
see also Bilinear transformation (BLT) design method
C code
direct form II implementation, 445 446, 446t, 447f,
448f
direct form I structure, 445, 445f
difference equation, 302 303
digital audio equalizer, 341f
audio spectrum, 343 344, 343f
audio test signal, 343 344
ﬁlter banks design, 342, 342t
magnitude frequency responses, 342, 342f
MATLAB program, 344
speciﬁcations for, 341, 341t
digital Butterworth lowpass prototype functions, 318, 319t
bandpass and bandstop ﬁlter, 331 337
lowpass and highpass ﬁlters, 322 331
magnitude response function, 318, 320f
prototype ﬁlter order, 318 320
digital Chebyshev lowpass prototype functions, 318, 319t,
320t
analog ﬁlter speciﬁcation conversion, 321, 322t
bandpass ﬁlters, 321, 322f, 331 337
bandstop ﬁlters, 331 337
highpass ﬁlters, 322 331, 322f
lowpass ﬁlters, 321 331, 322f
lowpass prototype order, 321
magnitude response function, 320 321, 321f
direct form I and direct form II, realization structure, 358
360
DTMF tone generator
Goertzel algorithm, see Goertzel algorithm
MATLAB program, 377
modiﬁed Goertzel algorithm, see Modiﬁed Goertzel
algorithm
telephone touch keypads, 373 375, 373f, 376f
ﬁrst order IIR ﬁlter transfer function, 369 371
ﬁxed point system, 432, 432f
format of, 302 303
higher order IIR ﬁlter design, cascade method, 338 340,
338t, 339t
realization structure, 361 362
60 Hz hum eliminator and heart rate detection,
electrocardiography, 392
cascaded frequency responses, 365, 366f
characteristics of, 362, 363f
design speciﬁcations, 364 365
harmonics, 364
heart rate, deﬁnition, 367 368
MATLAB program, 368
QRS complex, 362 364
signal enhancement system, 364, 364f
signal processing results, 366, 367f
signal spectrum, 362, 363f
transfer function and difference equation, 365
zero crossing algorithm, 366 367, 368f
impulse invariant design method, 345f, 389, 392
ﬁlter DC gain, 348
inverse Laplace transform, analog impulse function,
345 346
rectangular approximation, 346 348
sampling interval effect, 348, 349f
scaled magnitude frequency response, 347f, 348
second order ﬁlter design, 348 351
pole zero placement method, 389, 392
ﬁrst order highpass ﬁlter, 357 358, 357f
ﬁrst order lowpass ﬁlter, 355 357, 355f, 356f
magnitude response, 351, 352f
Nyquist limit, 351 352
second order bandpass ﬁlter, 352 354, 353f
second order bandstop (notch) ﬁlter, 354 355, 354f
second order IIR ﬁlter transfer function, 369 371
single tone generator, 374 375, 374f, 375f
transfer function, 433
Inﬁnite precision, 35, 282
Interlaced raster scan, 747, 748f
Interpolation ﬁlter, 579, 579t
commutative model, 580, 580f
ﬁlter bank coefﬁcients, 579 580
four tap interpolation ﬁlter, 578, 578f
implementation, 579, 579f, 584
Inverse discrete cosine transform (IDCT), 729
Inverse discrete Fourier transform (IDFT), 262
Inverse discrete wavelet transform (IDWT),
656, 671
Inverse fast Fourier transform (IFFT)
deﬁnition, 126
eight point IFFT, 129 131, 131f
Index
869

Inverse z transform
deﬁnition, 144
partial fraction expansion method, 144 145
constant(s) formulas, 145, 146t
MATLAB function residue(), 150 152
J
JPEG image compression
alternating current coefﬁcients, 738f
bit stream, 738
run length coding, 736 738
direct current coefﬁcients
DPCM, 736
Huffman coding, 737, 737t
encoder, 735, 735f
image blocks, 735
lossless entropy coding, 737
quantization, 735 736, 736t
RGB to YIQ transformation, 735
two dimensional grayscale image, 733, 734f
coding error, 733, 734t
DCT coefﬁcients, 731, 732t
DCT coefﬁcient scan order, 732, 733t
JPEG vector, 732 733
normalized DCT coefﬁcients, 732, 733t
original image, 731, 732f
quality factor, 731, 733t
recovered image subblock, 733, 734t
88 subblock, 731, 731t
K
Kaiser window, 230
Kernel
average convolution, 709
differential convolution, 715 716
Gaussian ﬁlter, 711 712
L
Laplace shift property, 174
Laplace transform
differential equations, 793 794
and table, 791 793, 791t
transfer function, 794 795
Laplacian edge detector, 716 717
Laplacian of Gaussian ﬁlter, 717, 719f
Least mean square (LMS) algorithm, 461 462
adaptive FIR ﬁlters
corrupted signal and noise reference, 455 457, 456f,
456t
desired signal spectrum, 453, 454f
noise canceller, 454, 454f
one tap FIR ﬁlter, 455, 457
Linear buffering
FIR ﬁlter, 441 442, 441f
IIR ﬁlter, 442, 443f
coefﬁcient buffer, 444, 444f
digital oscillation, 442
Linear convolution, 142 143
Linear midtread quantizer, 533
Linear phase response, 223, 224f, 226 227, 226f, 227f
Linear systems, 63, 64f
digital ampliﬁer, 64
system output, 65
Linear time invariant system
difference equation, 67
FIR system, 69
stability criterion, 71
unit impulse response, 68 69, 68f, 72
Lowpass ﬁlters, 304, 304f
analog ﬁlters, 321, 322f
coefﬁcients, 656
digital Butterworth lowpass prototype functions,
322 331
digital Chebyshev lowpass prototype functions,
321 331, 322f
impulse responses, 260, 261f
magnitude frequency responses, 260, 260f, 261f
Sallen Key lowpass ﬁlter, 26 27, 26f
17 tap FIR lowpass ﬁlter coefﬁcients, 224, 225t
Lowpass noise ﬁltering
average convolution kernel, 709
Gaussian ﬁlter kernel, 711 712
noisy and enhanced image, 711 712, 711f, 712f, 713f
Luminance channel, 688 689
M
MAC, see Multiplier and accumulator (MAC)
Maclaurin series expansion, 593 595
Macroblocks, 755, 755f
Mathematical formulas
complex conjugate, 826
complex number form, 825 826
addition and subtraction, 826
division, 826 828
multiplication, 826
L’Hospital’s rule, 828
quadratic equation solution, 828
simultaneous equation solution, 828
simultaneous linear equation solution, 830
Matrix Laboratory (MATLAB) programs
ADPCM coding, 539
decoding, 542
encoding, 539
analog ﬁlters, lowpass prototype transformation, 307
870
Index

arrays and indexing, 770 771
CD audio player, 572
commands and syntax
array operations, 769
complex numbers, 768
numbers, variables and expressions, 768
sum() function, 767
variable names, 768
DCT waveform coding, 546
digital audio equalizer, 344
digital m law compressor, 537
digital m law encoding and decoding, 537
digital m law expander, 538
downsampling, 559, 609
DTMF tone generator, 377
edge detection, 718 721, 720f
equalization, 702 704, 703f
fft() and ifft() function, 93, 93t
FIR ﬁlter design
noise reduction, 255
window method, 237 240, 237t, 288
ﬁrst order SDM, 597
Goertzel algorithm, 382
60 Hz hum eliminator and heart rate detection,
electrocardiography, 368
image level adjustment, 707, 708f
m law companding, 535
m law encoding and decoding, 534
m law expanding, 535
midtread quantizer
decoding, 536
encoding, 536
linear, 533
modiﬁed Goertzel algorithm, 385 386, 386f
noise cancellation, 466
noninteger factor L/M, 568
one level wavelet transform and compression, 742
oversampling, 589
plot functions, 771 772, 772f
pseudo color generation and detection, 725
residue() function, 150 152
script ﬁles, 164f, 772 773
signal to quantization noise ratio, 48, 537
sign function, 548
speech signals
bandpass ﬁltering, 204
pre emphasis of, 201
sumsub.m function, 773 774
system modeling, adaptive ﬁlters, 470
two channel perfect reconstruction quadrature mirror ﬁlter
bank, 633
two level wavelet transform and compression, 744
uniform quantization decoding, 48
uniform quantization encoding, 48
upsampling, 564, 611
wavelet data compression, 667
W MDCT function, 545
inverse function, 545
waveform coding, 546
MDCT, see Modiﬁed discrete cosine transform (MDCT)
Mean square error quadratic function, 457 458, 458f
Median ﬁltering
enhanced image, 714, 715f
“pepper and salt” noise, 714, 715f
principle of, 712 714
Modiﬁed discrete cosine transform (MDCT)
1D DCT, 522
decoding stage, 523
encoding stage, 523
W MDCT, 522, 522f
waveform coding, 524 525, 525f
wmdeth() and wimdetf() functions, 523 524
Modiﬁed Goertzel algorithm, 384f
ASCII code, 385 386
design principles, 383
frequency bins, 383, 384t
MATLAB simulation, 385 386, 386f
Mother wavelet, 642, 644, 644f
Motion estimation, 755 756, 755f
Motion vector, 755
MPEG audio
audio frame formats, 526, 527f
data frame types, 526, 526f
DCT, 519 522, 524 525, 525f
encoder, 527, 528f
Huffman coding, 528
MDCT, see Modiﬁed discrete cosine transform
(MDCT)
Multiplier and accumulator (MAC), 407 409, 409f
Multirate digital signal processing, 555 556
CD audio player
interpolation ﬁlter design, 571 572, 573f
MATLAB program, 572
sample rate conversion, 571, 571f
signal plots, 572, 574f
multistage decimation, see Multistage decimation approach
sampling rate, integer factor, see Sampling rate
Multiresolution analysis, 650 651
Multistage decimation approach
sampling rate conversion, 578
two stage decimator, 574, 575f
ﬁlter requirements, 576
stopband frequency edge, anti aliasing ﬁlter, 575 576,
575f
Index
871

N
Noise cancellation
MATLAB program, 466
MSE function vs. weights, 465, 465f
one tap adaptive ﬁlter, 462, 463f
speciﬁcations, 466
speech waveforms and spectral plots, 466,
466f, 467f
two tap adaptive ﬁlter, 463 465
Noise reduction systems
clean signal and spectrum, 254, 255f
data acquisition process, 253
MATLAB program, 255
noise signal and spectrum, 254, 254f
passband frequency range, 254
speech noise reduction, 256 257, 256f, 257f
stopband frequency range, 254
vibration signals, 257 258, 258f, 259f
Noncausal FIR ﬁlter coefﬁcients, 233
Noncausal sequence, 141, 233
Normalized bandpass ﬁlter, 187, 187f
Normalized bandstop ﬁlter, 188, 188f
Normalized Butterworth function, 805 808
Normalized Chebyshev function, 808 812
Normalized highpass ﬁlter, 187, 187f
Normalized lowpass ﬁlter, 186f, 187
Notch ﬁlter, 354 355, 354f
NTSC TV standard, 750, 751f
Nyquist frequency, 20, 47
Nyquist limit, 351 352, 562 563, 564f
O
Optimal design method, 286 287
see also Parks McClellan algorithm
Overﬂow, 422
Output digital signal, 2, 592
P
Parallel realization method, 192, 196 199, 196f
Parks McClellan algorithm
alternation theorem, 277 278
approximation error, 269
Chebyshev polynomial approximation, 269
Chebyshev real magnitude function, 277
design procedure, 270 279
disadvantages, 279
magnitude frequency response, 269 270, 270f
minimax ﬁlters, 269
Remez exchange algorithm, 269
Partial fraction expansion method, 144 145
constant(s) formulas, 145, 146t
MATLAB function residue(), 150 152
Perfect reconstruction, see Two channel perfect
reconstruction quadrature mirror ﬁlter bank
Phase alternative line (PAL) system, 752
Plot functions, 771
Pole zero placement method, 389, 392
ﬁrst order highpass ﬁlter, 357 358, 357f
ﬁrst order lowpass ﬁlter, 355 357, 355f, 356f
magnitude response, 351, 352f
Nyquist limit, 351 352
second order bandpass ﬁlter, 352 354, 353f
second order bandstop (notch) ﬁlter, 354 355, 354f
Pole zero plot, see Z plane pole zero plot
Polyphase ﬁlters
direct decimation process, 581, 581f, 582t
commutative model, 582 583, 583f
ﬁlter bank coefﬁcients, 582
implementation, 582, 582f, 584
three tap decimation ﬁlter, 581
direct interpolation ﬁlter, 579, 579t
commutative model, 580, 580f
ﬁlter bank coefﬁcients, 579 580
four tap interpolation ﬁlter, 578, 578f
implementation, 579, 579f, 584
properties, 581
Power spectrum, 97 101
Progressive scan, 754
Q
Quadrature amplitude modulation (QAM), 751 752
Quantization, 735 736, 736t
see also Waveform quantization and compression
bipolar quantizer, 38 40, 39f, 40t
deﬁnition, 35, 36f
error, 37
notations and rules, 38
process, 37
SNR, 47
unipolar quantizer, 38, 38f, 39t
Quantization error
analog m law companding, 501
DAC, 40 42
R
Radix 2 FFT algorithm, 123
decimation in frequency method, see Decimation
in frequency method
decimation in time method
eight point FFT algorithm, 128 129, 130f
eight point IFFT, 129 131, 131f
ﬁrst iteration, 128 129, 130f
frequency bins, 128 129
second iteration, 128 129, 130f
872
Index

rconv() function, 668
Realization structure
direct form I and direct form II, 358 360
higher order IIR ﬁlter design, cascade method, 361 362
Real time processing
input and output sample clock, 438, 439f
program segment, 438, 440f
TMS320C6713 DSK setup, 438, 440f
Rectangular window, 230
Reference frame, 755, 755f
Remez exchange algorithm, 269
RGB components, 686, 686f
RGB to YIQ transformation, 690, 690f
Root mean square (RMS), 42, 499
Rounded off error, 282
Run length coding, 736 738
S
Sallen Key lowpass ﬁlter, 26 27, 26f
Sampling rate
downsampling, 557f
data sequence, 556
deﬁnition, 556
MATLAB program, 559, 609
normalized stop frequency edge, 556 557
Nyquist sampling theorem, 556
spectral plots, 556 557, 558f
TMS320C6713 DSK, 608, 612f
using anti aliasing ﬁlter, spectral plots, 558 559, 560f
without using anti aliasing ﬁlter, spectral plots, 558, 559f
z transform, 556 557
noninteger factor L/M, 570 571
anti aliasing ﬁlter, 568, 569f
interpolation ﬁlter, 567, 568f
MATLAB program, 568
sampling rate conversion, 567, 567f
upsampling
deﬁnition, 562
interpolation ﬁlter, 563, 565f
MATLAB program, 564, 611
normalized stop frequency edge, 562 563
Nyquist limit, 562 563, 564f
process of, 562, 563f
sampling frequency, 562 563
TMS320C6713 DSK, 611, 612f
Scaling functions, 649 650, 650f
multiresolution analysis, 650 651
SECAM system, see Se´quentiel Couleur a´; Me´moire
(SECAM) system
Second order bandpass ﬁlter, 352 354, 353f
Second order bandstop (notch) ﬁlter, 354 355, 354f
Second order Butterworth lowpass ﬁlter, 25 26
Second order IIR ﬁlter transfer function, 369 371
Se´quentiel Couleur a´ Me´moire (SECAM) system, 752, 752t
Sequential search method, 755 756
Shannon sampling theorem, 20
Shaped in band noise power, 593 595
Shifters, 409
Sigma delta modulation analog to digital conversion (SDM
ADC)
ADC resolution, 595 596
CD player, 601 602, 601f, 602f
continuous vs. regular sampled vs. oversampled signal
amplitudes, 597, 599f
discrete time analog ﬁlter, 592, 593f
DSP model, second order SDM, 595, 596f
extrapolation method, 592
feedback control system, 592 593
ﬁrst order SDM
DSP model, 592, 593f
MATLAB program, 597
principles, 592, 592f
frequency responses, 597, 597f
MAX1402, functional diagram, 600, 600f
noise shaping ﬁlter, 592 593, 594f
shaped in band noise power, 593 595
time vs. frequency domains, 597, 598f
Signal denoising, 668, 670f
Signal to noise power ratio, 499
Signal reconstruction
aliasing frequency component, 23 25
anti aliasing ﬁltering, 35
aliasing level percentage, 28
Butterworth magnitude frequency response,
25 26
Sallen Key lowpass ﬁlter, 26 27, 26f
sampled analog signal, 25, 26f
anti image ﬁlter and equalizer, see Anti image ﬁlter and
equalizer
signal notations, 21 22, 22f
signal spectrum recovery, 22 23, 22f, 23f
Signal sampling
ADC
see also Analog to digital conversion (ADC)
sample and hold analog voltage, 15, 16f
analog (continuous) signal and digital samples vs. time
instants, 15, 16f
anti image ﬁlter, 18
DAC, see Digital to analog conversion (DAC)
DSP, 15, 16f
lowpass reconstruction ﬁlter, 20
MATLAB function
signal to quantization noise ratio calculation, 48
uniform quantization decoding, 48
Index
873

Signal sampling (Continued)
uniform quantization encoding, 48
Nyquist frequency/folding frequency, 20, 47
sampling process, 18, 18f, 47
sampling rate, 16 17
sampling theorem condition, 17 18, 17f, 20, 47
Shannon sampling theorem, 20
signal reconstruction, see Signal reconstruction
spectral analysis, 18 19, 19f
Single tone generator, 374 375, 374f, 375f
Smith Barnwell PR CQF ﬁlters, 630, 630t
Spectral leakage, 108
Speech coding
four band compression, 637, 637f, 638f
seismic data, 637, 639f
two band compression, 636 637, 636f
Speech noise reduction, 256 257, 256f, 257f
Speech signals
bandpass ﬁltering
amplitude spectra, 203, 205f
digital fourth order bandpass Butterworth ﬁlter,
203
frequency responses, 203, 203f
MATLAB program, 204
original and ﬁltered speech plots, 203, 204f
pre emphasis of
amplitude spectral plots, 201, 202f
magnitude and phase responses, 200, 200f
MATLAB program, 201
speech waveforms, 200, 201f
transfer function, 200
Stair functions, 771
Steepest descent algorithm, 459, 460f,
461 462
Stem functions, 771
Step response, 169
Subband coding
analysis and synthesis stages
channel 0, 622, 623f
channel 1, 622, 623f
channel 2, 622 624, 624f
channel 3, 624, 625f
4 channel ﬁlter bank analyzer and synthesizer,
621 622, 622f
decomposition, see Two channel perfect reconstruction
quadrature mirror ﬁlter bank
delta function, 624
discrete Fourier transform, 625
ﬁlter bank system, 621
impulse train, 625, 626f
signal ﬂow, 624, 625f
speech coding, see Speech coding
two band ﬁlter bank system, signal compression,
635 636, 636f
z transform, 626
Subplot functions, 771
S video, 746
Synthesis ﬁlter
channel 0, 622, 623f
channel 1, 622, 623f
channel 2, 622 624, 624f
channel 3, 624, 625f
4 channel ﬁlter bank, 621 622, 622f
T
17 Tap FIR lowpass ﬁlter coefﬁcients, 224, 225t
Target frame, 755, 755f
Time invariant system, 65 66, 65f
TMS320C6713 DSK
analog system program, 482
downsampling, 608, 612f
system modeling
LMS adaptive ﬁlter, 480 482, 480f, 482f
program segment, 481
tonal noise cancellation, 483, 483f, 484f
DSK1 program, 483
DSK2 program, 484
upsampling, 611, 612f
Transition band, 186
Translated function, 642, 643f
Transversal FIR ﬁlter, 280 281, 280f
Twiddle factor, 92 93, 123 124
Two band digital crossover design
lowpass and highpass ﬁlters
impulse responses, 260, 261f
magnitude frequency responses, 260, 260f, 261f
speaker drivers, 258 259, 259f
speciﬁcations, 259 260
Two channel perfect reconstruction quadrature mirror ﬁlter
bank, 626, 627f
analysis and synthesis ﬁlters, 627
autocorrelation function, 628
four band implementation
binary tree structure, 634f, 635
dyadic tree structure, 635, 635f
frequency response, 629, 629f
lowpass ﬁlter equations, 630
MATLAB program, 633
N tap FIR ﬁlters, 628
Smith Barnwell PR CQF ﬁlters, 630, 630t
two band analysis and synthesis, 632, 633f
Two dimensional discrete cosine transform (2D DCT),
729 731
Two dimensional discrete Fourier transform (2D DFT), 725
874
Index

U
Unipolar quantizer, 38, 38f, 39t
Unit circle, 175
Unit impulse sequence, 58 59, 59f
Unit step sequence, 59, 59f, 62
Underﬂow, 423
Unstable system, 175
Upsampling
deﬁnition, 562
interpolation ﬁlter, 563, 565f
MATLAB program, 564, 611
normalized stop frequency edge, 562 563
Nyquist limit, 562 563, 564f
process of, 562, 563f
sampling frequency, 562 563
TMS320C6713 DSK, 611, 612f
V
Vertical retrace, 747, 750
Vertical Sobel edge detector, 716
Vibration signature analysis, 9, 10f, 11f
Video signals
analog video
“back porch”, 748
electrical signal demodulation, 748 750, 749f
frame via row wise scanning, 747
frequency modulation, 751
interlaced raster scanning, 747, 748f
NTSC TV standard, 750, 751f
PAL system, 752
QAM, 751 752
SECAM system, 752, 752t
vertical synchronization, 749f, 750
video data, retrace and sync layout, 750, 750f
video modulated waveform, 747, 748f
component video, 746
composite video, 746
digital video
CCIR 601, chroma subsampling, 753, 753f
HDTV formats, 754, 754t
speciﬁcations, 754, 754t
motion estimation, 755 756, 755f
S video, 746
Von Neumann architecture, 406, 406f
applications, 408
execution cycles, 407, 408f
opcode and operand, 406
W
Waveform coding, 7
Waveform quantization and compression
analog m law companding
characteristics, 502, 502f
compressor, 501, 501f
expander, 501 502, 501f
original speech data, 504, 505f
quantization error, 501
digital m law companding
8 bit compressed PCM code format, 505 506, 506t,
508 509, 508f
characteristics, 505, 506f
compressor and expander, 504, 505f
decoding table, 506 508, 507t
encoding table, 505 506, 507t
DM, 511
DPCM
3 bit quantizer, 509, 510t
encoder and decoder, 509, 509f
quantization step size, 512
G.721 modulation, see Adaptive differential pulse code
modulation (ADPCM)
linear midtread quantization
characteristics of, 498 499, 498f
quantization, deﬁnition, 497 498
quantization error, 500
quantized values, 498 499, 498t
signal to noise power ratio, 499
speech data plot, 500, 500f
MATLAB programs, see MATLAB programs
MPEG audio
audio frame formats, 526, 527f
data frame types, 526, 526f
DCT, 519 522, 524 525, 525f
encoder, 527, 528f
Huffman coding, 528
MDCT, see Modiﬁed discrete cosine transform (MDCT)
TMS320C6713 DSK
digital m law encoding and decoding, 530
encoding and decoding, linear quantization,
528 529
Wavelet analysis
analysis equations, 822 823
properties, 821 822
scaled function, 641, 642f, 643f
synthesis equations, 823 824
translated function, 642, 643f
Wavelet transform
amplitudes, 639 641, 641f
analysis and synthesis stage, 664
combined signal and spectrum, 639 641, 640f
CWT, 638, 641
Daubechies 4 ﬁlter coefﬁcients, 653, 654t
DWT, 638
see also Discrete wavelet transform (DWT)
Index
875

Wavelet transform (Continued)
coefﬁcient layout, 664, 665f
hard threshold, 668, 669f
signal denoising, 668, 670f
Haar father and mother wavelets, 642, 644, 644f,
652 653
individual signal components, 639, 640f
mother wavelet, deﬁnition, 641
one level wavelet transform and compression, 741,
742f
MATLAB program, 742
scaled wavelet function, 641, 642f, 643f
scaling functions, 649 650, 650f
multiresolution analysis, 650 651
signal coding, 650, 651f
sinusoidal delaying function, 648, 648f
4 tap Daubechies father wavelet, 654, 654f
4 tap Daubechies mother wavelet, 655, 655f
translated wavelet function, 642, 643f
two dimensional DWT, 738 741, 739f
two level wavelet transform and compression,
741 742, 743f
MATLAB program, 744
types, 638
wavelet coefﬁcients, 646 647
wavelet data compression
16 bit ECG data, 668, 669f
16 bit speech data, 667, 667f
MATLAB program, 667
Wiener ﬁlter theory
autocorrelation and cross correlation, 459
LMS algorithm, 461 462
mean square error quadratic function, 457 458, 458f
noise cancellation, 457, 457f
statistical expectation, 457 458, 461 462
steepest descent algorithm, 459, 460f, 461 462
Windowed modiﬁed discrete cosine transform (W MDCT),
522 523, 522f, 545
inverse function, 545
waveform coding, 524 525, 525f, 546
Window method
Blackman window, 230, 231f
cutoff frequency, 242
design procedure, 233
Gibbs oscillations, 230
Hamming window, 230, 231f
Hanning window, 230, 231f
Kaiser window, 230
length estimation, 241, 241t
magnitude frequency response, 240
MATLAB function, 237 240, 237t, 288
passband ripple, 241 242, 241f
rectangular window, 230
stopband attenuation, 241 242, 241f
triangular (Bartlett) window, 230, 231f
Y
YCbCr color space, 753
YIQ, 690, 690f
YUV color model, 752
Z
Zero crossing algorithm, 366 367, 368f
Zigzag scan, 737
Z plane pole zero plot, 172f
analog to digital conversion, 174
bounded in/bounded out stability, 175
features, 172
Laplace shift property, 174
Laplace vs. z transform, 173, 174f
s plane vs. z plane mapping, 175, 175f
stability rules, 175, 176f
Z transform
deﬁnition, 137 138
difference equations, 152 156
exponential sequence, 138
inverse z transform
deﬁnition, 144
partial fraction expansion method, see Partial fraction
expansion method
lookup table, 156
one sided/unilateral transform, 137 138
properties of, 144t
causal sequence, 141 143
linear convolution, 142 143
linearity, 140 141
time shifted sequence, 141
region of convergence, 138
sequences for, 138 140, 139t
876
Index

