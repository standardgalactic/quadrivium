Ââåäåíèå â Ñòàíäàðòíûé ML1
Ðîáåðò Õàðïåð
School of Computer Science
Carnegie Mellon University
Pittsburg, PA 15213-3891
Ïåðåâîä íà ðóññêèé ÿçûê Ì.Ð.Êîâòóíà
ïîä ðåäàêöèåé Ñ.À.Ðîìàíåíêî
Copyright c⃝1986-1993 Robert Harper
All Rights Reserved
Copyright c⃝1996 Ì.Ð.Êîâòóí, Ñ.À.Ðîìàíåíêî
(ïåðåâîä íà ðóññêèé ÿçûê)
1C óïðàæíåíèÿìè Êåâèíà Ìèò÷åëà, Laboratory for Foundations of Computer
Science, Edinburgh University, Edinburgh, United Kingdom.


Îãëàâëåíèå
Áëàãîäàðíîñòè
v
1
Ââåäåíèå
1
2
ßäðî ÿçûêà
5
2.1
Ðàáîòà ñ ML â ðåæèìå äèàëîãà
. . . . . . . . . . . . . . . .
5
2.2
Ïåðâè÷íûå âûðàæåíèÿ, çíà÷åíèÿ è òèïû
. . . . . . . . . .
7
2.2.1
Òèï unit . . . . . . . . . . . . . . . . . . . . . . . . .
7
2.2.2
Ëîãè÷åñêèå çíà÷åíèÿ (òèï bool)
. . . . . . . . . . .
7
2.2.3
Öåëûå ÷èñëà (òèï int) . . . . . . . . . . . . . . . . .
8
2.2.4
Ñòðîêè (òèï string)
. . . . . . . . . . . . . . . . . .
9
2.2.5
Äåéñòâèòåëüíûå ÷èñëà (òèï real) . . . . . . . . . . .
10
2.2.6
Óïîðÿäî÷åííûå ýíêè . . . . . . . . . . . . . . . . . .
11
2.2.7
Ñïèñêè . . . . . . . . . . . . . . . . . . . . . . . . . .
12
2.2.8
Çàïèñè
. . . . . . . . . . . . . . . . . . . . . . . . . .
14
2.3
Èäåíòèôèêàòîðû, ïðèâÿçêè è îáúÿâëåíèÿ . . . . . . . . . .
15
2.4
Îáðàçöû
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
2.5
Îïðåäåëåíèÿ ôóíêöèé
. . . . . . . . . . . . . . . . . . . . .
24
2.6
Ïîëèìîðôèçì è ïåðåãðóçêà
. . . . . . . . . . . . . . . . . .
37
2.7
Îïðåäåëåíèÿ íîâûõ òèïîâ . . . . . . . . . . . . . . . . . . .
40
2.8
Èñêëþ÷åíèÿ
. . . . . . . . . . . . . . . . . . . . . . . . . . .
48
2.9
Èìïåðàòèâíûå âîçìîæíîñòè ÿçûêà . . . . . . . . . . . . . .
53
3
Ìîäóëè
57
3.1
Îáçîð . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
3.2
Ñòðóêòóðû è ñèãíàòóðû
. . . . . . . . . . . . . . . . . . . .
59
3.3
Àáñòðàêöèÿ . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
3.4
Ôóíêòîðû . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
80
3.5
Ìîäóëüíàÿ ñèñòåìà â ðåàëüíîé ïðàêòèêå . . . . . . . . . . .
84
iii

4
Ââîä-âûâîä
91
A Îòâåòû
97
iv

Áëàãîäàðíîñòè
Íåêîòîðûå èç èñïîëüçîâàííûõ ïðèìåðîâ áûëè çàèìñòâîâàíû èç ðà-
áîò Ëóêè Êàðäåëëè [3], Ðîáèíà Ìèëíåðà [5], Äýéâà Ìàê-Êâèíà [6] è
Àáåëüñîíà è Çóññìàíà [1]. Èîàõèì Ïàððîó, Äîí Ñàí¼ëëà è Äýâèä Óîêåð
âíåñëè ðÿä öåííûõ ïðåäëîæåíèé.
v

vi

Ãëàâà 1
Ââåäåíèå
Ýòè ëåêöèè ÿâëÿþòñÿ ââîäíûì êóðñîì â ÿçûê ïðîãðàììèðîâàíèÿ
Ñòàíäàðòíûé ML. Ïåðå÷èñëèì íàèáîëåå âàæíûå ÷åðòû Ñòàíäàðòíîãî
ML:
• ML ÿâëÿåòñÿ ôóíêöèîíàëüíûì ÿçûêîì ïðîãðàììèðîâàíèÿ. Ôóíê-
öèè ÿâëÿþòñÿ ïîëíîïðàâíûìè îáúåêòàìè: îíè ìîãóò ïåðåäàâàòüñÿ
â êà÷åñòâå àðãóìåíòîâ, âûðàáàòûâàòüñÿ â êà÷åñòâå ðåçóëüòàòà è
õðàíèòüñÿ â ïåðåìåííûõ. Îñíîâíîé ñïîñîá îðãàíèçàöèè óïðàâëå-
íèÿ â ïðîãðàììàõ íà ML  ðåêóðñèâíîå ïðèìåíåíèå ôóíêöèé.
• ML ÿâëÿåòñÿ èíòåðàêòèâíûì ÿçûêîì. Êàæäîå ââåäåííîå ïðåäëî-
æåíèå àíàëèçèðóåòñÿ, êîìïèëèðóåòñÿ è èñïîëíÿåòñÿ, è çíà÷åíèå,
ïîëó÷åííîå â ðåçóëüòàòå èñïîëíåíèÿ ïðåäëîæåíèÿ, âìåñòå ñ åãî òè-
ïîì âûäàåòñÿ ïîëüçîâàòåëþ.
• ML ÿâëÿåòñÿ ñòðîãî òèïèçèðîâàííûì ÿçûêîì. Êàæäîå äîïóñòè-
ìîå âûðàæåíèå èìååò òèï, êîòîðûé àâòîìàòè÷åñêè îïðåäåëÿåòñÿ
êîìïèëÿòîðîì. Ñòðîãàÿ òèïèçàöèÿ ãàðàíòèðóåò, ÷òî â ïåðèîä èñ-
ïîëíåíèÿ íå ìîæåò âîçíèêíóòü îøèáîê â ñîãëàñîâàíèè òèïîâ.1
• ML èìååò ïîëèìîðôíóþ ñèñòåìó òèïîâ. Êàæäîå äîïóñòèìîå ïðåä-
ëîæåíèå ÿçûêà îáëàäàåò îäíîçíà÷íî îïðåäåëÿåìîé íàèáîëåå îáùåé
òèïèçàöèåé, êîòîðàÿ îïðåäåëÿåò êîíòåêñòû, â êîòîðûõ ïðåäëîæå-
íèå ìîæåò áûòü èñïîëüçîâàíî.
1Çàìåòèì, ÷òî îøèáêè òàêîãî ðîäà  âåñüìà ðàñïðîñòðàíåííàÿ âåùü, è äèàãíîñòè-
êà èõ íà ýòàïå êîìïèëÿöèè çàìåòíî îáëåã÷àåò îòëàäêó ïðîãðàììû. (Ïðèì. ïåðåâ.)
1

2
ÃËÀÂÀ 1. ÂÂÅÄÅÍÈÅ
• ML ïîääåðæèâàåò àáñòðàêòíûå òèïû äàííûõ. Àáñòðàêòíûå òè-
ïû  âåñüìà ïîëåçíûé ìåõàíèçì â ìîäóëüíîì ïðîãðàììèðîâàíèè.
Íîâûå òèïû äàííûõ ìîãóò áûòü îïðåäåëåíû âìåñòå ñ íàáîðîì îïå-
ðàöèé íàä çíà÷åíèÿìè ýòèõ òèïîâ. Äåòàëè âíóòðåííåé ñòðóêòóðû
çíà÷åíèé è ðåàëèçàöèè îïåðàöèé ñêðûòû îò ïðîãðàììèñòà, èñïîëü-
çóþùåãî äàííûå àáñòðàêòíîãî òèïà; âûñîêàÿ ñòåïåíü èçîëÿöèè äà-
åò ñóùåñòâåííûå ïðåèìóùåñòâà ïðè ðàçðàáîòêå è ñîïðîâîæäåíèè
áîëüøèõ ïðîãðàìì.
• Â ML îáëàñòè äåéñòâèÿ èäåíòèôèêàòîðîâ îïðåäåëÿþòñÿ ñòàòè÷å-
ñêè. Ñìûñë âñåõ èäåíòèôèêàòîðîâ â ïðîãðàììå îïðåäåëÿåòñÿ ñòà-
òè÷åñêè, ÷òî ïîçâîëÿåò ñîçäàâàòü áîëåå ìîäóëüíûå è áîëåå ýôôåê-
òèâíûå ïðîãðàììû.
• ML ñîäåðæèò íàäåæíî òèïèçèðîâàííûé ìåõàíèçì îáðàáîòêè èñ-
êëþ÷èòåëüíûõ ñîáûòèé. Ìåõàíèçì îáðàáîòêè èñêëþ÷èòåëüíûõ
ñîáûòèé ÿâëÿåòñÿ óäîáíûì ñðåäñòâîì îïèñàíèÿ äåéñòâèé â íåíîð-
ìàëüíûõ ñèòóàöèÿõ, âîçíèêàþùèõ â ïåðèîä èñïîëíåíèÿ ïðîãðàì-
ìû.
• ML ñîäåðæèò ñðåäñòâà ðàçáèåíèÿ ïðîãðàìì íà ìîäóëè, îáåñïå÷è-
âàþùèå âîçìîæíîñòü ðàçðàáîòêè áîëüøèõ ïðîãðàìì ïî ÷àñòÿì.
Ïðîãðàììà íà ML ñòðîèòñÿ êàê íàáîð âçàèìîçàâèñèìûõ ñòðóê-
òóð, ñâÿçûâàåìûõ äðóã ñ äðóãîì ñ ïîìîùüþ ôóíêòîðîâ. Ðàçäåëü-
íàÿ êîìïèëÿöèÿ îñóùåñòâëÿåòñÿ ïîñðåäñòâîì ýêñïîðòà è èìïîðòà
ôóíêòîðîâ.
Ñòàíäàðòíûé ML ÿâëÿåòñÿ íîâåéøèì èç ñåìåéñòâà ÿçûêîâ, áåðóùèõ
ñâîå íà÷àëî îò ÿçûêà ML, ðàçðàáîòàííîãî â Ýäèíáóðãå Ìàéêîì Ãîðäî-
íîì, Ðîáèíîì Ìèëíåðîì è Êðèñîì Óîäñâîðòîì â ñåðåäèíå 70-õ ãîäîâ [4].
Ñ òåõ ïîð âîçíèêëî ìíîãî äèàëåêòîâ è ðåàëèçàöèé, êàê â ñàìîì Ýäèí-
áóðãå, òàê è â äðóãèõ ìåñòàõ. Ñòàíäàðòíûé ML îñíîâûâàåòñÿ íà ñèíòåçå
ìíîãèõ èäåé, âîïëîùåííûõ â ðàçëè÷íûõ âàðèàíòàõ ÿçûêà (èç êîòîðûõ â
ïåðâóþ î÷åðåäü ñëåäóåò îòìåòèòü äèàëåêò, ðàçðàáîòàííûé Ëóêîé Êàð-
äåëëè [3]), è íà èäåÿõ ôóíêöèîíàëüíîãî ÿçûêà ÍÎÐÅ, ðàçðàáîòàííîãî
Ðîäîì Áåðñòåëîì, Äýéâîì Ìàê-Êâèíîì è Äîíîì Ñàí¼ëëà [2]. Ïîñëåä-
íåå äîáàâëåíèå â ÿçûê  ìîäóëüíàÿ ñòðóêòóðà, ïðåäëîæåííàÿ Äýéâîì
Ìàê-Êâèíîì â [6].
Ýòè ëåêöèè ÿâëÿþòñÿ íåôîðìàëüíûì ââåäåíèåì â ÿçûê, îïèñûâàþ-
ùèì åãî âîçìîæíîñòè è ñïîñîáû èñïîëüçîâàíèÿ, è íå äîëæíû ðàññìàò-
ðèâàòüñÿ êàê ôîðìàëüíîå îïèñàíèå Ñòàíäàðòíîãî ML. Îíè ïèñàëàñü è

3
ïåðåïèñûâàëàñü â òå÷åíèå íåñêîëüêèõ ëåò, è ñåé÷àñ íóæäàþòñÿ â íåêîòî-
ðîé ïåðåðàáîòêå ñ öåëüþ îòðàçèòü èçìåíåíèÿ, ïðîèçîøåäøèå â ÿçûêå, è
îïûò åãî èñïîëüçîâàíèÿ. Ïîýòîìó àâòîð áóäåò ðàä ëþáûì ïðåäëîæåíèÿì
îò ÷èòàòåëåé ïî ýòîìó âîïðîñó.
Ôîðìàëüíîå îïðåäåëåíèå Ñòàíäàðòíîãî ML èìååòñÿ â [7]. Íåñêîëüêî
ìåíåå ôîðìàëüíîå (è íåñêîëüêî óñòàðåâøåå) îïèñàíèå èìååòñÿ â Îò÷åòå
Ýäèíáóðãñêîãî óíèâåðñèòåòà [5]. Äëÿ äåòàëüíîãî çíàêîìñòâà ñ ÿçûêîì
÷èòàòåëþ ñëåäóåò îáðàòèòüñÿ ê åãî ôîðìàëüíîìó îïðåäåëåíèþ.

4
ÃËÀÂÀ 1. ÂÂÅÄÅÍÈÅ

Ãëàâà 2
ßäðî ÿçûêà
2.1
Ðàáîòà ñ ML â ðåæèìå äèàëîãà
Ïðàêòè÷åñêè âñå ðåàëèçàöèè ML ÿâëÿþòñÿ èíòåðàêòèâíûìè; îíè îñ-
íîâûâàþòñÿ íà äèàëîãå òèïà ïðî÷åñòü-âû÷èñëèòü-íàïå÷àòàòü (õîðîøî
çíàêîìîìó ïîëüçîâàòåëÿì LISP). Â ïðîöåññå òàêîãî äèàëîãà ïîëüçîâà-
òåëü ââîäèò âûðàæåíèå, ML-ñèñòåìà åãî àíàëèçèðóåò, êîìïèëèðóåò, âû-
ïîëíÿåò è âûäàåò ðåçóëüòàò íà òåðìèíàë1.
Âîò îáðàçåö äèàëîãà:
- 3+2;
> 5 : int
ML çàïðàøèâàåò ââîä ñ ïîìîùüþ -  è ïðåäâàðÿåò âûâîä > . Ïîëü-
çîâàòåëü ââîäèò ôðàçó 3+2. ML âû÷èñëÿåò âûðàæåíèå è ïå÷àòàåò åãî
çíà÷åíèå, 5, âìåñòå ñ òèïîì çíà÷åíèÿ, int.
Â ïðîöåññå äèàëîãà ìîãóò âîçíèêàòü ðàçëè÷íûå âèäû îøèáîê. Â
îñíîâíîì îíè ðàñïàäàþòñÿ íà òðè êàòåãîðèè: ñèíòàêñè÷åñêèå îøèáêè,
îøèáêè â ñîãëàñîâàíèè òèïîâ è îøèáêè âðåìåíè èñïîëíåíèÿ. Âåðîÿòíî,
âû çíàêîìû ñ ñèíòàêñè÷åñêèìè îøèáêàìè è îøèáêàìè âðåìåíè èñïîë-
íåíèÿ ïî âàøåìó îïûòó ðàáîòû ñ äðóãèìè ÿçûêàìè ïðîãðàììèðîâàíèÿ.
Ïðèâåäåì ïðèìåð òîãî, ÷òî ïðîèñõîäèò, êîãäà ââåäåíà ñèíòàêñè÷åñêè
íåïðàâèëüíàÿ ôðàçà:
1Äåòàëè èíòåðàêòèâíîé ðàáîòû ñ ML-ñèñòåìîé ìåíÿþòñÿ îò îäíîé ðåàëèçàöèè ê
äðóãîé, íî äóõ îáùåíèÿ îäèíàêîâ âî âñåõ èçâåñòíûõ àâòîðó ñèñòåìàõ. Ïðèìåðû â
íàñòîÿùåé êíèãå ïîäãîòîâëåíû ñ èñïîëüçîâàíèåì Ýäèíáóðãñêîãî êîìïèëÿòîðà 1988
ãîäà.
5

6
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
- let x=3 in x end;
Parse error: Was expecting "in" in ... let <?> x ...
Îøèáêè âðåìåíè èñïîëíåíèÿ (êàê, íàïðèìåð, äåëåíèå íà 0) ÿâëÿþòñÿ
îäíèì èç âèäîâ èñêëþ÷èòåëüíûõ ñîáûòèé (ïîäðîáíî îíè áóäóò ðàññìîò-
ðåíû äàëåå). Ñåé÷àñ ìû òîëüêî ïðèâåäåì ïðèìåð òîãî, ÷òî âû ìîæåòå
ïîëó÷èòü ïðè âîçíèêíîâåíèè îøèáêè âðåìåíè èñïîëíåíèÿ:
-3 div 0;
Failure:
Div
Îøèáêè â ñîãëàñîâàíèè òèïîâ íå òàê ïðèâû÷íû. Ìû ïîäðîáíî ðàñ-
ñìîòðèì òèïû è ñâÿçàííûå ñ íèìè îøèáêè ïîçäíåå; ïîêà îòìåòèì, ÷òî
îøèáêè â ñîãëàñîâàíèè òèïîâ âîçíèêàþò ïðè íåêîððåêòíîì èñïîëüçîâà-
íèè çíà÷åíèé, íàïðèìåð, ïðè ïîïûòêå ïðèáàâèòü 3 ê true:
- 3+true;
Type clash in:
3+true
Looking for a:
int
I have found a:
bool
Îäíîé èç âåñüìà íåïðèÿòíûõ îøèáîê, íå ðàñïîçíàâàåìûõ ML-ñèñòå-
ìîé, ÿâëÿåòñÿ áåñêîíå÷íûé öèêë. Åñëè âû ïîäîçðåâàåòå, ÷òî âàøà ïðî-
ãðàììà çàöèêëèëàñü, âû ìîæåòå ïðåêðàòèòü åå âûïîëíåíèå, íàæàâ êëà-
âèøó ïðåðûâàíèÿ (îáû÷íî Ctrl-C). ML âûäàñò ñîîáùåíèå, ãîâîðÿùåå î
òîì, ÷òî âîçíèêëî èñêëþ÷èòåëüíîå ñîáûòèå "interrupt", è âåðíåòñÿ íà
âåðõíèé óðîâåíü âûïîëíåíèÿ ïðîãðàììû. Íåêîòîðûå ðåàëèçàöèè ñîäåð-
æàò ñðåäñòâà îòëàäêè, êîòîðûå ìîãóò ïîìî÷ü â îïðåäåëåíèè ïðè÷èíû
çàöèêëèâàíèÿ.
Áûâàþò è äðóãèå âèäû îøèáîê, íî îíè âñòðå÷àþòñÿ çíà÷èòåëüíî ðå-
æå, è âîçìîæíûå ïðè÷èíû èõ òðóäíî îáúÿñíèòü â îáùåì ñëó÷àå. Åñëè
âû âñòðåòèòåñü ñ ñîîáùåíèåì îá îøèáêå, ñìûñë êîòîðîãî âû íå ìîæå-
òå ïîíÿòü, ïîñòàðàéòåñü íàéòè êîãî-íèáóäü, êòî èìååò áîëüøå îïûòà â
ðàáîòå ñ ML, ÷òîáû îí ïîìîã âàì ðàçîáðàòüñÿ â ñèòóàöèè.
Äåòàëè èíòåðôåéñà ïîëüçîâàòåëÿ ìåíÿþòñÿ îò ðåàëèçàöèè ê ðåàëèçà-
öèè, îñîáåííî â ÷àñòè ôîðìàòà âûâîäà è ñîîáùåíèé îá îøèáêàõ. Ïðèâî-
äèìûå â íàñòîÿùåé êíèãå ïðèìåðû îñíîâûâàþòñÿ íà Ýäèíáóðãñêîì ML;
ìû ïîëàãàåì, ÷òî ïîñëå çíàêîìñòâà ñ ýòèìè ïðèìåðàìè ó âàñ íå äîëæíî
âîçíèêíóòü òðóäíîñòåé â ïîíèìàíèè âûäà÷ äðóãèõ ML-ñèñòåì.

2.2. ÏÅÐÂÈ×ÍÛÅ ÂÛÐÀÆÅÍÈß, ÇÍÀ×ÅÍÈß È ÒÈÏÛ
7
2.2
Ïåðâè÷íûå âûðàæåíèÿ, çíà÷åíèÿ è òèïû
Ìû íà÷íåì íàøå ââåäåíèå â ML ñ îïèñàíèÿ ìíîæåñòâà ïåðâè÷íûõ
òèïîâ. Â ML òèï åñòü ìíîæåñòâî çíà÷åíèé. Íàïðèìåð, öåëûå ÷èñëà îá-
ðàçóþò òèï; ìíîæåñòâî âñåõ ñèìâîëüíûõ ñòðîê è ìíîæåñòâî ëîãè÷åñêèõ
çíà÷åíèé (èñòèíà è ëîæü) òàêæå îáðàçóþò òèïû. Åñëè èìåþòñÿ äâà
òèïà σ è τ, òî ìíîæåñòâî âñåõ óïîðÿäî÷åííûõ ïàð, ïåðâûé ÷ëåí êîòîðûõ
èìååò òèï σ, à âòîðîé  òèï τ, ÿâëÿåòñÿ òèïîì. Áîëåå òîãî, ìíîæåñòâî
âñåõ ôóíêöèé, îòîáðàæàþùèõ çíà÷åíèÿ îäíîãî òèïà â çíà÷åíèÿ äðóãîãî
òèïà, òàêæå îáðàçóþò òèï. Â äîïîëíåíèå ê ýòèì è äðóãèì îïðåäåëåí-
íûì â ÿçûêå òèïàì ML ïîçâîëÿåò ïðîãðàììèñòó îïðåäåëèòü ñâîè ñîá-
ñòâåííûå òèïû; ê áîëåå ïîäðîáíîìó îáñóæäåíèþ ýòîé âîçìîæíîñòè ìû
îáðàòèìñÿ ïîçäíåå.
Âûðàæåíèÿ â ML èçîáðàæàþò çíà÷åíèÿ òî÷íî òàê æå, êàê ïîñëå-
äîâàòåëüíîñòè öèôð èçîáðàæàþò ÷èñëà. Òèï âûðàæåíèÿ îïðåäåëÿåòñÿ
ñèñòåìîé ïðàâèë, êîòîðûå ãàðàíòèðóþò, ÷òî åñëè âûðàæåíèå èìååò çíà-
÷åíèå, òî çíà÷åíèå âûðàæåíèÿ ïðèíàäëåæèò òèïó âûðàæåíèÿ (íó êàê,
ïîíÿòíî?). Íàïðèìåð, êàæäàÿ ïîñëåäîâàòåëüíîñòü öèôð èìååò òèï int,
ïîñêîëüêó çíà÷åíèåì ïîñëåäîâàòåëüíîñòè öèôð ÿâëÿåòñÿ öåëîå ÷èñëî.
Ìû ïðîèëëþñòðèðóåì ñèñòåìó òèïîâ ML ïðèìåðàìè.
2.2.1
Òèï unit
Òèï unit ñîñòîèò èç åäèíñòâåííîãî çíà÷åíèÿ, çàïèñûâàåìîãî êàê ().
Ýòîò òèï èñïîëüçóåòñÿ â òåõ ñëó÷àÿõ, êîãäà âûðàæåíèå íå èìååò êàêîãî-
ëèáî îñìûñëåííîãî çíà÷åíèÿ, à òàêæå âìåñòî àðãóìåíòà ôóíêöèè â òåõ
ñëó÷àÿõ, êîãäà ôóíêöèÿ íå äîëæíà èìåòü àðãóìåíòîâ2.
2.2.2
Ëîãè÷åñêèå çíà÷åíèÿ (òèï bool)
Òèï bool ñîñòîèò èç çíà÷åíèé true è false. Äëÿ ðàáîòû ñî çíà÷åíè-
ÿìè ýòîãî òèïà èìåþòñÿ îäíîìåñòíàÿ îïåðàöèÿ not è äâå äâóõìåñòíûõ
îïåðàöèè andalso è orelse (ñîîòâåòñòâóþùèå îáû÷íûì ëîãè÷åñêèì îïå-
ðàöèÿì íå, è è èëè)3.
2Èíîãäà âîçíèêàåò íåîáõîäèìîñòü ðàññìàòðèâàòü ôóíêöèè, ïðèíèìàþùèå ïîñòî-
ÿííûå (íå çàâèñÿùèå îò àðãóìåíòà) çíà÷åíèÿ. Ïîñêîëüêó çà÷àñòóþ â òàêèõ ñëó÷àÿõ
îáëàñòü îïðåäåëåíèÿ íåñóùåñòâåííà, óìåñòíî â êà÷åñòâå íåå èñïîëüçîâàòü unit. Ïðè
ýòîì â ML âàæíî îòëè÷àòü ñàìó ôóíêöèþ (÷òî çàïèñûâàåòñÿ êàê f) îò ðåçóëüòàòà åå
ïðèìåíåíèÿ (÷òî çàïèñûâàåòñÿ êàê f()). (Ïðèì. ïåðåâ.)
3Èìåþòñÿ âåñêèå ïðè÷èíû, ïî êîòîðûì âìåñòî òðàäèöèîííûõ íàçâàíèé and è or
äëÿ áèíàðíûõ ëîãè÷åñêèõ îïåðàöèé èñïîëüçóþòñÿ íåîæèäàííûå andalso è orelse.

8
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
Óñëîâíîå âûðàæåíèå
if e then e1 else e2
ìû òàêæå ðàññìîòðèì
çäåñü, ïîñêîëüêó åãî ïåðâûé àðãóìåíò, e, äîëæåí èìåòü òèï bool. Îá-
ðàòèòå âíèìàíèå, ÷òî ÷àñòü else äîëæíà ïðèñóòñòâîâàòü îáÿçàòåëüíî.
Ïðè÷èíà ýòîãî â òîì, ÷òî if â ML ÿâëÿåòñÿ óñëîâíûì âûðàæåíèåì, à
íå óñëîâíûì óòâåðæäåíèåì, êàê, íàïðèìåð, â Pascal'å. Åñëè áû ÷àñòü
else îòñóòñòâîâàëà, òî ïðè çíà÷åíèè e ðàâíîì false âûðàæåíèå íå èìå-
ëî áû çíà÷åíèÿ. Êðîìå òîãî, òèïû âûðàæåíèé e1 è e2 äîëæíû ñîâïàäàòü.
Âûðàæåíèå
if true then true else ()
ÿâëÿåòñÿ íåêîððåêòíûì ñ òî÷êè çðåíèÿ òèïèçàöèè (èëè, êîðî÷å, íåòè-
ïèçèðóåìûì), ïîñêîëüêó òèï âûðàæåíèÿ â ÷àñòè then åñòü bool, à òèï
âûðàæåíèÿ â ÷àñòè else  unit.
- not true;
> false : bool
- false andalso true;
> false: booi
- false orelse true;
> true : bool
- if false then false else true;
> true: bool
- if true then false else true;
> false: bool
2.2.3
Öåëûå ÷èñëà (òèï int)
Òèï int ÿâëÿåòñÿ ìíîæåñòâîì (ïîëîæèòåëüíûõ è îòðèöàòåëüíûõ)
öåëûõ ÷èñåë. Öåëûå ÷èñëà çàïèñûâàþòñÿ îáû÷íûì ñïîñîáîì, çà èñêëþ-
÷åíèåì òîãî, ÷òî äëÿ îòðèöàòåëüíûõ ÷èñåë çíàê çàïèñûâàåòñÿ òèëüäîé
~ âìåñòî òðàäèöèîííîãî ìèíóñà -.
Ïðè÷èíû ýòîãî ñëåäóþùèå. ML ÿâëÿåòñÿ ñòðîãèì ÿçûêîì; ýòî îçíà÷àåò, ÷òî âñå àð-
ãóìåíòû ôóíêöèè âû÷èñëÿþòñÿ äî âû÷èñëåíèÿ çíà÷åíèÿ ôóíêöèè. Åñëè ïðè ýòîì
îêàæåòñÿ, ÷òî êàêîé-ëèáî àðãóìåíò íå ìîæåò áûòü âû÷èñëåí (íàïðèìåð, â ïðîöåññå
åãî âû÷èñëåíèÿ âîçíèêàåò çàöèêëèâàíèå), òî è ñàìî çíà÷åíèå ôóíêöèè íå ñìîæåò
áûòü âû÷èñëåíî. Îïåðàöèè æå andalso è orelse ÿâëÿþòñÿ èñêëþ÷åíèÿìè èç ýòîãî
ïðàâèëà: ïðè âû÷èñëåíèè, íàïðèìåð, e1 andalso e2 ñíà÷àëà âû÷èñëÿåòñÿ e1, è åñëè
åãî çíà÷åíèå åñòü false, òî e2 íå âû÷èñëÿåòñÿ, à çíà÷åíèåì âñåãî âûðàæåíèÿ áóäåò
false. Òàêèì îáðàçîì, âûðàæåíèå false andalso e2 áóäåò âñåãäà îïðåäåëåíî (è áó-
äåò èìåòü çíà÷åíèå false)  â îòëè÷èå, íàïðèìåð, îò âûðàæåíèÿ 0 * e2, çíà÷åíèå
êîòîðîãî áóäåò íå îïðåäåëåíî, åñëè íå îïðåäåëåíî e2. (Ïðèì. ïåðåâ.)

2.2. ÏÅÐÂÈ×ÍÛÅ ÂÛÐÀÆÅÍÈß, ÇÍÀ×ÅÍÈß È ÒÈÏÛ
9
- 75;
> 75 : itn
- ~24;
> ~24 : int
- (3+2) div 2;
> 2 : int
- (3+2) mod 2;
> 1 : int
Âûðàæåíèÿ ìîãóò ñîäåðæàòü îáû÷íûå çíàêè àðèôìåòè÷åñêèõ îïåðà-
öèé +, -, *, div è mod (div è mod îáîçíà÷àþò ñîîòâåòñòâåííî öåëî÷èñëåí-
íîå äåëåíèå è ïîëó÷åíèå îñòàòêà îò äåëåíèÿ íàöåëî). Èìåþòñÿ è çíàêè
äëÿ îïåðàöèé ñðàâíåíèÿ <, <=, >, >=, = è <>. Âñå ýòè îïåðàöèè òðåáóþò
äâóõ àðãóìåíòîâ òèïà int è âîçâðàùàþò ðåçóëüòàò òèïà bool (true èëè
false â ñîîòâåòñòâèè ñ òåì, âûïîëíåíî óñëîâèå èëè íåò).
- 3<2
> false : bool
- 3*2 >= 12 div 6
> true: bool
- if 4*5 mod 3 = 1 then 17 else 51;
> 51 : int
Îáðàòèòå âíèìàíèå íà òî, ÷òî îïåðàöèè ñðàâíåíèÿ, ïðèìåíåííûå ê
äâóì öåëî÷èñëåííûì âûðàæåíèÿì, âûðàáàòûâàþò true èëè false, è ïî-
ýòîìó èõ ðåçóëüòàò èìååò òèï bool.
2.2.4
Ñòðîêè (òèï string)
Òèï string ñîñòîèò èç âñåõ êîíå÷íûõ ïîñëåäîâàòåëüíîñòåé ëèòåð.
Ñòðîêè çàïèñûâàþòñÿ îáû÷íûì ñïîñîáîì, êàê ïîñëåäîâàòåëüíîñòü ëèòåð
ìåæäó äâîéíûìè êàâû÷êàìè. Åñëè äâîéíàÿ êàâû÷êà äîëæíà âîéòè â
ñîñòàâ ñòðîêè, îíà çàïèñûâàåòñÿ êàê \".
- "Fish knuckles";
> "Fish knuckles" : string
- "\"";
> """ : string
Ñïåöèàëüíûå ëèòåðû òàêæå ìîãóò áûòü âñòàâëåíû â ñòðîêè, íî ìû
íå áóäåì îñòàíàâëèâàòüñÿ íà ñïîñîáå ñäåëàòü ýòî, ò.ê. â íàøèõ ïðèìå-
ðàõ ýòî íå ïîíàäîáèòñÿ. Çà áîëåå ïîäðîáíîé èíôîðìàöèåé îáðàòèòåñü ê
ôîðìàëüíîìó îïèñàíèþ ÿçûêà [7].

10
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
Ôóíêöèÿ size âîçâðàùàåò äëèíó ñòðîêè â ëèòåðàõ. Ôóíêöèÿ ^ ÿâëÿ-
åòñÿ èíôèêñíîé äâóõìåñòíîé îïåðàöèåé êîíêàòåíàöèè ñòðîê4.
- "Rhinocerous " ^ "Party";
> "Rhinocerous Party" : string
- size "Walrus whistle";
> 14 : int
2.2.5
Äåéñòâèòåëüíûå ÷èñëà (òèï real)
Òèï ÷èñåë ñ ïëàâàþùåé òî÷êîé íàçûâàåòñÿ â ML real. Äåéñòâèòåëü-
íûå ÷èñëà çàïèñûâàþòñÿ áîëåå-ìåíåå îáû÷íûì äëÿ ÿçûêîâ ïðîãðàììè-
ðîâàíèÿ ñïîñîáîì: öåëîå ÷èñëî, çà êîòîðûì ñëåäóåò äåñÿòè÷íàÿ òî÷êà,
çà êîòîðîé ñëåäóåò ïîñëåäîâàòåëüíîñòü èç îäíîé èëè áîëåå äåñÿòè÷íûõ
öèôð, çà êîòîðûìè ñëåäóåò çíàê ýêñïîíåíòû, Å, çà êîòîðûì ñëåäóåò äðó-
ãîå ÷èñëî. Ýêñïîíåíòà ìîæåò áûòü îïóùåíà, åñëè ïðèñóòñòâóåò äåñÿòè÷-
íàÿ òî÷êà; äåñÿòè÷íàÿ òî÷êà ìîæåò áûòü îïóùåíà, åñëè ïðèñóòñòâóåò
ýêñïîíåíòà. Âñå ýòî íóæíî äëÿ òîãî, ÷òîáû îòëè÷àòü öåëûå ÷èñëà îò
äåéñòâèòåëüíûõ (ML íå îáåñïå÷èâàåò âêëþ÷åíèÿ îäíîãî òèïà â äðóãîé
íè â êàêîé ôîðìå; ïðè íåîáõîäèìîñòè öåëîå ÷èñëî äîëæíî áûòü ÿâíûì
îáðàçîì ïðåîáðàçîâàíî â äåéñòâèòåëüíîå).
- 3.14159;
> 3.14159: real
- 3E2;
> 300.0 : real
- 3.14159Å2;
> 314.159 : real
Äëÿ äåéñòâèòåëüíûõ ÷èñåë èìåþòñÿ îáû÷íûå àðèôìåòè÷åñêèå îïåðà-
öèè -, +, -, *, / (/ îáîçíà÷àåò îïåðàöèþ äåëåíèÿ äåéñòâèòåëüíûõ ÷èñåë;
îïåðàöèé div è mod äëÿ äåéñòâèòåëüíûõ ÷èñåë íåò) è îïåðàöèè ñðàâíåíèÿ
<, <=, >, >=, =, <>. Íå äîïóñêàåòñÿ, ÷òîáû îäèí èç îïåðàíäîâ ýòèõ îïåðàöèé
áûë äåéñòâèòåëüíûì, à äðóãîé  öåëûì. Òàêæå èìåþòñÿ ôóíêöèè sin,
sqrt, exp è ò.ä., ñîîòâåòñòâóþùèå îáû÷íûì ìàòåìàòè÷åñêèì ôóíêöèÿì.
Ôóíêöèÿ real ïðåîáðàçóåò öåëûé àðãóìåíò â ñîîòâåòñòâóþùåå äåéñòâè-
òåëüíîå ÷èñëî, à ôóíêöèÿ floor ïðåîáðàçóåò äåéñòâèòåëüíûé àðãóìåíò
â íàèáîëüøåå öåëîå ÷èñëî, íå ïðåâîñõîäÿùåå àðãóìåíò.
4Èíôèêñíîé ìû íàçûâàåì ôóíêöèþ, èìåþùóþ äâà àðãóìåíòà, çíàê êîòîðîé çà-
ïèñûâàåò ìåæäó àðãóìåíòàìè  êàê, íàïðèìåð, îáû÷íî çàïèñûâàåòñÿ â ìàòåìàòèêå
îïåðàöèÿ ñëîæåíèÿ.

2.2. ÏÅÐÂÈ×ÍÛÅ ÂÛÐÀÆÅÍÈß, ÇÍÀ×ÅÍÈß È ÒÈÏÛ
11
- 3.0 + 2.0;
> 5.0 : real
- (3.0 + 2.0) = real(3 + 2);
> true : bool
- floor(~3.2);
> ~4 : int
- cos(O.O);
> 1.0: real
- cos(O);
Type clash in:
(cos 0)
Looking for a:
real
I have found a: int
Ýòèì çàâåðøàåòñÿ îáçîð àòîìàðíûõ òèïîâ ML. Òåïåðü ìû ïåðåõîäèì
ê ñîñòàâíûì òèïàì, êîòîðûå ñòðîÿòñÿ èç äðóãèõ òèïîâ.
2.2.6
Óïîðÿäî÷åííûå ýíêè
Òèï σ*τ, ãäå σ è τ  ïðîèçâîëüíûå òèïû, ÿâëÿåòñÿ òèïîì óïîðÿ-
äî÷åííîé ïàðû, ãäå ïåðâûé ÷ëåí èìååò òèï σ, à âòîðîé  òèï τ. Óïî-
ðÿäî÷åííàÿ ïàðà çàïèñûâàåòñÿ êàê (e1,e2), ãäå e1 è e2  âûðàæåíèÿ.
Àíàëîãè÷íî îáðàçóþòñÿ óïîðÿäî÷åííûå ýíêè5. À èìåííî, ïîñëåäîâàòåëü-
íîñòü âûðàæåíèé, îòäåëåííûõ äðóã îò äðóãà çàïÿòûìè, çàêëþ÷àåòñÿ â
êðóãëûå ñêîáêè. Åñëè âûðàæåíèÿ e1, e2, . . . , en èìåþò òèïû σ1, σ2, . . . ,
σn ñîîòâåòñòâåííî, òî òèïîì óïîðÿäî÷åííîé ýíêè (e1,e2,. . .,en) áóäåò
σ1*σ2*. . .*σn.
- (true, ());
> (true, ()): bool * unit
- (1, false, 17, "Blubbet");
> (1,false, 17,"Blubbet"): int * bool * int * string
- (if 3=5 then "Yes" else "No", 14 mod 3 );
> ("No",2): string * int
Ðàâåíñòâî ìåæäó ýíêàìè  ïîêîìïîíåíòíîå: äâå ýíêè ðàâíû, åñëè èõ
ñîîòâåòñòâóþùèå êîìïîíåíòû ðàâíû. Åñëè äâå ýíêè èìåþò ðàçëè÷íûå
òèïû, òî ïðè ïîïûòêå èõ ñðàâíåíèÿ âîçíèêàåò îøèáêà â ñîãëàñîâàíèè
5Ìû ðåøèëèñü ââåñòè òåðìèí ýíêà êàê îáîáùåíèå òåðìèíîâ äâîéêà, òðîéêà è ò.ä.
(âìåñòî âûãëÿäÿùåãî íåñêîëüêî ñòðàííî n-êà) ïî àíàëîãèè ñ ïîëó÷èâøèì øèðîêîå
ðàñïðîñòðàíåíèå àíãëèéñêèì òåðìèíîì tuple. (Ïðèì. ïåðåâ.)

12
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
òèïîâ: áåññìûñëåííî ñïðàøèâàòü, ðàâíû ëè ("abc", ()) è (true, 7),
ïîñêîëüêó ñîîòâåòñòâóþùèå êîìïîíåíòû ýòèõ ïàð èìåþò ðàçíûå òèïû.
- (14 mod 3, not false ) = ( 1+1, true );
> true : bool
- ( "abc", (5*4) div 2 ) = ("a"^"bc", 11);
> false : bool
- (true, 7) = ("abc", ());
Type clash in:
(true,7) = ("abc",())
Looking for a:
bool * int
I have found a: string * unit
2.2.7
Ñïèñêè
Òèï τ list ñîñòîèò èç êîíå÷íûõ ïîñëåäîâàòåëüíîñòåé, èëè ñïèñêîâ,
çíà÷åíèé òèïà τ. Íàïðèìåð, òèï int list ñîñòîèò èç ñïèñêîâ öåëûõ ÷è-
ñåë, à òèï bool list ñîñòîèò èç ñïèñêîâ ëîãè÷åñêèõ çíà÷åíèé. Èìååòñÿ
äâà ñïîñîáà çàïèñè ñïèñêîâ, îñíîâíîé è ñîêðàùåííûé. Ïåðâûé îñíîâû-
âàåòñÿ íà ñëåäóþùåì îïðåäåëåíèè ñïèñêà: ñïèñîê çíà÷åíèé òèïà τ ëèáî
ïóñò, ëèáî ñîñòîèò èç çíà÷åíèÿ òèïà τ, çà êîòîðûì ñëåäóåò ñïèñîê çíà-
÷åíèé òèïà τ. Â ñîîòâåòñòâèè ñ ýòèì îïðåäåëåíèåì ïóñòîé ñïèñîê çàïè-
ñûâàåòñÿ êàê nil, à íåïóñòîé ñïèñîê çàïèñûâàåòñÿ êàê e :: l, ãäå e 
âûðàæåíèå òèïà τ, à l  âûðàæåíèå òèïà τ list. Íàçâàíèå îïåðàöèè ::
ïðîèçíîñèòñÿ êàê êîíñ (cons)  â ïàìÿòü î ñîîòâåòñòâóþùåé ôóíêöèè
ÿçûêà LISP.
Ïîðàçìûñëèâ íåêîòîðîå âðåìÿ, âû ïîéìåòå, ÷òî ëþáîé íåïóñòîé ñïè-
ñîê ìîæåò áûòü çàïèñàí â ñëåäóþùåì âèäå:
e1 :: e2 :: ... :: en :: nil
ãäå êàæäîå ei ÿâëÿåòñÿ âûðàæåíèåì òèïà τ è n ≥1. Ýòî ñîîòâåòñòâó-
åò èíòóèòèâíîìó ïîíÿòèþ ñïèñêà çíà÷åíèé äàííîãî òèïà, ïðè ýòîì nil
èãðàåò ðîëü çàâåðøèòåëÿ ñïèñêà.
Òàêîé ìåòîä îïðåäåëåíèÿ íàçûâàåòñÿ èíäóêòèâíûì (èëè ðåêóðñèâ-
íûì) îïðåäåëåíèåì. Èíäóêòèâíîå îïðåäåëåíèå ñîñòîèò èç îäíîãî èëè
áîëåå íà÷àëüíûõ ñëó÷àåâ, îïèñûâàþùèõ îïðåäåëÿåìûå ïðåäìåòû íåïî-
ñðåäñòâåííî, è îäíîãî èëè áîëåå èíäóêòèâíûõ øàãîâ, ïîçâîëÿþùèõ èç
óæå ïîñòðîåííûõ ïðåäìåòîâ ñòðîèòü íîâûå6.
6Èíäóêòèâíîå îïðåäåëåíèå çàäàåò îïðåäåëÿåìûé êëàññ ïðåäìåòîâ â ñîîòâåòñòâèè
ñî ñëåäóþùèìè òðåìÿ ïóíêòàìè: (1) âñÿêèé ïðåäìåò, îïèñàííûé îäíèì èç íà÷àëü-
íûõ ñëó÷àåâ, ÿâëÿåòñÿ îïðåäåëÿåìûì ïðåäìåòîì: (2) âñÿêèé ïðåäìåò, ïîëó÷åííûé

2.2. ÏÅÐÂÈ×ÍÛÅ ÂÛÐÀÆÅÍÈß, ÇÍÀ×ÅÍÈß È ÒÈÏÛ
13
Â ñëó÷àå ñïèñêîâ, íà÷àëüíûì ñëó÷àåì ÿâëÿåòñÿ nil, à èíäóêòèâ-
íûì øàãîì ÿâëÿåòñÿ ïðèìåíåíèå îïåðàöèè ::. Èíäóêòèâíûå îïðåäåëå-
íèÿ òèïîâ èãðàþò âàæíóþ ðîëü â ôóíêöèîíàëüíîì ïðîãðàììèðîâàíèè,
ïîñêîëüêó îðãàíèçàöèÿ ôóíêöèîíàëüíîé ïðîãðàììû âî ìíîãîì îïðåäå-
ëÿåòñÿ ñòðóêòóðîé îáðàáàòûâàåìûõ äàííûõ.
Íèæå ïðèâîäÿòñÿ ïðèìåðû èñïîëüçîâàíèÿ nil è :: äëÿ ïîñòðîåíèÿ
ñïèñêîâ:
- nil;
> [] : 'a list
- 3 :: 4 :: nil;
> [3,4] : int list
- (3:: nil):: (4 :: 5 :: nil) :: nil;
> [[3],[4,5]]: int list list
- ["This", "is", "it" ];
> ["This","is","it"]: string list
Îáðàòèòå âíèìàíèå íà òî, ÷òî ML âûâîäèò ñïèñêè â ñîêðàùåííîì
ôîðìàòå: ïîñëåäîâàòåëüíîñòü ðàçäåëåííûõ çàïÿòûìè ýëåìåíòîâ ñïèñêà,
çàêëþ÷åííàÿ â êâàäðàòíûå ñêîáêè. Ýòîò ôîðìàò ìîæåò èñïîëüçîâàòüñÿ
è äëÿ ââîäà ñïèñêîâ  íî ïîìíèòå, ÷òî ýòî ëèøü ñîêðàùåíèå äëÿ ïîëíîãî
ôîðìàòà.
Òèï ñïèñêà nil  îñîáûé: îí âêëþ÷àåò ïåðåìåííóþ òèïà (âûâîäèòñÿ
êàê 'à è ïðîèçíîñèòñÿ êàê àëüôà). Ïðè÷èíîé ýòîãî ÿâëÿåòñÿ òî, ÷òî â
ïóñòîì ñïèñêå íåò íèêàêîé èíôîðìàöèè î òîì, ñïèñêîì ýëåìåíòîâ êàêîãî
òèïà îí ÿâëÿåòñÿ. Áûëî áû ãëóïî òðåáîâàòü, ÷òîáû èìåëèñü îòäåëüíûå
êîíñòàíòû, îáîçíà÷àþùèå ïóñòîé ñïèñîê öåëûõ, ïóñòîé ñïèñîê ëîãè÷å-
ñêèõ è ò.ä. Ïîýòîìó ML òðàêòóåò nil êàê ïîëèìîðôíûé îáúåêò, ò.å. êàê
òàêîé îáúåêò, êîòîðûé ìîæåò ïðèíàäëåæàòü ëþáîìó òèïó èç íåêîòîðîãî
êëàññà. Êîíñòàíòà nil ìîæåò ðàññìàòðèâàòüñÿ êàê int list, êàê bool
list èëè êàê int list list â çàâèñèìîñòè îò êîíòåêñòà, â êîòîðîì îíà
íàõîäèòñÿ. Ýòî âûðàæàåòñÿ òåì, ÷òî êîíñòàíòå nil ïðèïèñûâàåòñÿ òèï
'a list, ãäå 'à ÿâëÿåòñÿ ïåðåìåííîé, ïðîáåãàþùåé ìíîæåñòâî òèïîâ.
×àñòíûå ñëó÷àè òèïà, âêëþ÷àþùåãî ïåðåìåííûå òèïà (òàêîé òèï ìû
áóäåì òàêæå íàçûâàòü ïîëèìîðôíûì òèïîì, èëè, êîðî÷å, ïîëèòèïîì),
ïîëó÷àþòñÿ ïóòåì çàìåíû âñåõ âõîæäåíèé äàííîé ïåðåìåííîé òèïà íà
êàêîé-ëèáî òèï (ïðè ýòîì âñå âõîæäåíèÿ äàííîé ïåðåìåííîé çàìåíÿ-
þòñÿ íà îäèí è òîò æå òèï); ïîäñòàâëÿåìûé âìåñòî ïåðåìåííîé òèï
èç óæå ïîñòðîåííûõ îïðåäåëÿåìûõ ïðåäìåòîâ ïóòåì ïðèìåíåíèÿ êàêîãî-ëèáî èíäóê-
òèâíîãî øàãà, ÿâëÿåòñÿ îïðåäåëÿåìûì ïðåäìåòîì; (3) íèêàêèõ äðóãèõ îïðåäåëÿåìûõ
ïðåäìåòîâ, êðîìå ïîëó÷åííûõ ñ ïîìîùüþ ïóíêòîâ (1) è (2), íåò. (Ïðèì. ïåðåâ.)

14
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
ñàì ìîæåò áûòü ïîëèìîðôíûì. Íàïðèìåð, òèïû int list è (int*'b)
list ÿâëÿþòñÿ ÷àñòíûìè ñëó÷àÿìè ïîëèòèïà 'a list. Òèïû, êîòîðûå íå
ñîäåðæàò ïåðåìåííûõ òèïà, íàçûâàþòñÿ ìîíîìîðôíûìè òèïàìè (èëè,
êîðî÷å, ìîíîòèïàìè).
Ðàâåíñòâî äëÿ ñïèñêîâ ÿâëÿåòñÿ ïîýëåìåíòíûì: äâà ñïèñêà ðàâíû,
åñëè îíè ñîñòîÿò èç îäíîãî è òîãî æå ÷èñëà ýëåìåíòîâ è ñîîòâåòñòâóþ-
ùèå ýëåìåíòû ðàâíû ìåæäó ñîáîé. Êàê è â ñëó÷àå óïîðÿäî÷åííûõ ýíîê,
íåâîçìîæíî ñðàâíåíèå äâóõ ñïèñêîâ ñ ýëåìåíòàìè ðàçíûõ òèïîâ, è ïî-
ïûòêà âûïîëíèòü òàêóþ îïåðàöèþ ïðèâåäåò ê îøèáêå â ñîãëàñîâàíèè
òèïîâ.
- [1,2,3] = 1 :: 2 :: 3 :: nil;
> true : bool
- [[1], [2,4] ] = [ [2 div 2], [1+1, 9 div 3] ];
> false : bool
2.2.8
Çàïèñè
Ïîñëåäíèé ñîñòàâíîé òèï, êîòîðûé ìû ðàññìîòðèì â íàñòîÿùåì ðàç-
äåëå, åñòü òèï çàïèñè. Çàïèñè â ML àíàëîãè÷íû çàïèñÿì â Pascal'e,
ñòðóêòóðàì â Ñ è ò.ä. Çàïèñü ñîñòîèò èç êîíå÷íîãî ìíîæåñòâà ïîìå÷åí-
íûõ ïîëåé, êàæäîå èç êîòîðûõ ÿâëÿåòñÿ çíà÷åíèåì íåêîòîðîãî òèïà; êàê
è â ñëó÷àå óïîðÿäî÷åííûõ ýíîê, ðàçëè÷íûå ïîëÿ ìîãóò èìåòü ðàçëè÷íûå
òèïû. Çàïèñü çàäàåòñÿ ïîñëåäîâàòåëüíîñòüþ ðàâåíñòâ â ôîðìå l=e (ãäå
l åñòü ìåòêà è e  âûðàæåíèå), çàêëþ÷åííîé â ôèãóðíûå ñêîáêè. Êàæ-
äîå ðàâåíñòâî l=e óñòàíàâëèâàåò çíà÷åíèå ïîëÿ, ïîìå÷åííîãî ìåòêîé l=e,
ðàâíûì çíà÷åíèþ âûðàæåíèÿ e. Òèïîì çàïèñè ÿâëÿåòñÿ ïîñëåäîâàòåëü-
íîñòü ïàð âèäà l:τ (ãäå l åñòü ìåòêà, è τ  òèï), ðàçäåëåííûõ çàïÿòûìè è
çàêëþ÷åííûõ â ôèãóðíûå ñêîáêè. Ïîðÿäîê ðàâåíñòâ, çàäàþùèõ çàïèñü,
íå èìååò çíà÷åíèÿ: êîìïîíåíòû çàïèñè îïðåäåëÿþòñÿ ñâîèìè ìåòêàìè, à
íå ïîëîæåíèåì â çàïèñè. Ðàâåíñòâî äëÿ çàïèñåé  ïîêîìïîíåíòíîå: äâå
çàïèñè ðàâíû, åñëè îíè èìåþò îäíî è òî æå ìíîæåñòâî ìåòîê ïîëåé, è
ïîëÿ, ïîìå÷åííûå îäèíàêîâûìè ìåòêàìè, èìåþò ðàâíûå çíà÷åíèÿ.
- {name="Foo", used=true };
> {name="Foo", used=true }: {name:string, used:bool}
- {name="Foo", used=true } = { used=not false, name="Foo"};
> true : bool
- {name="Bar", used=true} = {name="Foo", used=true};
> false : bool

2.3. ÈÄÅÍÒÈÔÈÊÀÒÎÐÛ, ÏÐÈÂßÇÊÈ È ÎÁÚßÂËÅÍÈß
15
Óïîðÿäî÷åííûå ýíêè ÿâëÿþòñÿ ÷àñòíûì ñëó÷àåì çàïèñåé: óïîðÿäî-
÷åííàÿ ýíêà òèïà σ1*σ2*...*σn ÿâëÿåòñÿ ñîêðàùåííûì îáîçíà÷åíèåì
äëÿ çàïèñè òèïà { 1:σ1, 2:σ2,...,n:σn }. Íàïðèìåð, âûðàæåíèÿ (3,4)
è {1=3, 2=4} îáîçíà÷àþò â òî÷íîñòè îäíî è òî æå.
Íà ýòîì çàâåðøàåòñÿ íàøå ââåäåíèå â ïåðâè÷íûå òèïû, çíà÷åíèÿ è
âûðàæåíèÿ ÿçûêà ML. Ìû õîòèì îáðàòèòü âàøå âíèìàíèå íà òî, ÷òî
çíà÷åíèÿ âñåõ ðàññìîòðåííûõ òèïîâ ñòðîÿòñÿ íåêîòîðûì åäèíîîáðàç-
íûì ìåòîäîì. Äëÿ êàæäîãî òèïà èìååòñÿ ñâîé íàáîð ôîðìàòîâ âûðà-
æåíèé, çàäàþùèõ çíà÷åíèÿ ýòîãî òèïà. Äëÿ àòîìàðíûõ òèïîâ òàêèìè
âûðàæåíèÿìè ÿâëÿþòñÿ êîíñòàíòû ýòèõ òèïîâ. Íàïðèìåð, êîíñòàíòà-
ìè òèïà int ÿâëÿþòñÿ ïîñëåäîâàòåëüíîñòè öèôð ñî çíàêîì, à êîíñòàí-
òàìè òèïà string ÿâëÿþòñÿ ïîñëåäîâàòåëüíîñòè ëèòåð, çàêëþ÷åííûõ â
äâîéíûå êàâû÷êè. Äëÿ ñîñòàâíûõ òèïîâ çíà÷åíèÿ ñòðîÿòñÿ ñ ïîìîùüþ
êîíñòðóêòîðîâ çíà÷åíèé, ôóíêöèåé êîòîðûõ ÿâëÿåòñÿ ïîñòðîåíèå çíà-
÷åíèé ñîñòàâíîãî òèïà èç çíà÷åíèé êîìïîíåíò. Íàïðèìåð, êîíñòðóêòîð
ïàðû, çàïèñûâàåìûé êàê ( , ), áåðåò äâà çíà÷åíèÿ è ôîðìèðóåò èç íèõ
çíà÷åíèå òèïà óïîðÿäî÷åííàÿ ïàðà. Àíàëîãè÷íî, nil è :: ÿâëÿþòñÿ
êîíñòðóêòîðàìè, êîòîðûå ôîðìèðóþò çíà÷åíèå òèïà ñïèñîê. Ñèíòàê-
ñèñ çàïèñè ìîæåò òàêæå ðàññìàòðèâàòüñÿ êàê êîíñòðóêòîð. Òàêîé âçãëÿä
íà äàííûå, êàê íà ôîðìèðóåìûå èç êîíñòàíò ñ ïîìîùüþ êîíñòðóêòîðîâ,
ÿâëÿåòñÿ îñíîâîïîëàãàþùèì â ML è áóäåò èãðàòü âàæíóþ ðîëü â ïîñëå-
äóþùèõ ðàññìîòðåíèÿõ.
Â ML èìååòñÿ åùå îäèí î÷åíü âàæíûé òèï, òèï ôóíêöèé. Îäíàêî
ïåðåä òåì, êàê ïðèñòóïèòü ê ðàññìîòðåíèþ ôóíêöèé, ìû ðàññìîòðèì
ðàçëè÷íûå ôîðìû îáúÿâëåíèé è îñíîâíûå âèäû âûðàæåíèé â ML. Ýòî
îáëåã÷èò ïîñëåäóþùåå èçó÷åíèå ôóíêöèé.
2.3
Èäåíòèôèêàòîðû, ïðèâÿçêè è îáúÿâëåíèÿ
Â ýòîì ðàçäåëå ìû ââåäåì ïîíÿòèå îáúÿâëåíèÿ; îáúÿâëåíèÿ èñïîëü-
çóþòñÿ â ML äëÿ ââåäåíèÿ èäåíòèôèêàòîðîâ. Êàæäûé èäåíòèôèêàòîð
ïåðåä èñïîëüçîâàíèåì äîëæåí áûòü îáúÿâëåí (èìåíà âñòðîåííûõ ôóíê-
öèé  òàêèõ, êàê + èëè size  ñ÷èòàþòñÿ îáúÿâëåííûìè çàðàíåå). Èäåí-
òèôèêàòîðû â ML ìîãóò èñïîëüçîâàòüñÿ ìíîãèìè ðàçëè÷íûìè ñïîñîáà-
ìè, è â ñîîòâåòñòâèè ñ ýòèìè ñïîñîáàìè ñóùåñòâóþò ðàçëè÷íûå ôîð-
ìû îáúÿâëåíèé. Â íàñòîÿùåì ðàçäåëå ìû ðàññìîòðèì èäåíòèôèêàòîðû
çíà÷åíèé, èëè ïåðåìåííûå. Ïåðåìåííàÿ ââîäèòñÿ ïóòåì ïðèâÿçêè èäåí-
òèôèêàòîðà ê çíà÷åíèþ. Íàïðèìåð:
- val x = 4*5;

16
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
> val õ = 20 : int
- val s = "Abc"A"def";
> val s = "Abcdef" : string
- val pair = (x, s);
> val pair = (20, "Abcdef"): int * string
Ôðàçà val x = 4*5 íàçûâàåòñÿ ïðèâÿçêîé ê çíà÷åíèþ. ×òîáû âûïîë-
íèòü ïðèâÿçêó, ML âû÷èñëÿåò çíà÷åíèå âûðàæåíèÿ ñïðàâà îò çíàêà ðà-
âåíñòâà è óñòàíàâëèâàåò çíà÷åíèå ïåðåìåííîé, óêàçàííîé ñëåâà îò çíàêà
ðàâåíñòâà, ðàâíûì âû÷èñëåííîìó çíà÷åíèþ. Â ïðèâåäåííîì âûøå ïðè-
ìåðå õ ïðèâÿçûâàåòñÿ ê öåëîìó ÷èñëó 20. Ïîñëå ýòîãî èäåíòèôèêàòîð õ
íàâñåãäà îñòàåòñÿ ïðèâÿçàííûì ê ýòîìó çíà÷åíèþ; òàê, çíà÷åíèå (x,s)
îáðàçóåòñÿ èç çíà÷åíèé õ è s. Îáðàòèòå âíèìàíèå íà òî, ÷òî âûäà÷à
ML òåïåðü ñëåãêà îòëè÷àåòñÿ îò ïðèâîäèâøèõñÿ ðàíåå: ïåðåä çíà÷åíèåì
ïåðåìåííîé ïå÷àòàåòñÿ õ = . Ïðè÷èíîé ýòîãî ÿâëÿåòñÿ òî, ÷òî ñðàçó
ïîñëå òîãî, êàê èäåíòèôèêàòîð îáúÿâëåí, ML ïå÷àòàåò åãî îïðåäåëåíèå
(ôîðìà îïðåäåëåíèÿ çàâèñèò îò ñîðòà èäåíòèôèêàòîðà; ïîêà ÷òî ìû âè-
äåëè òîëüêî ïåðåìåííûå, äëÿ êîòîðûõ îïðåäåëåíèåì ÿâëÿåòñÿ çíà÷åíèå
ïåðåìåííîé). Íàïîìíèì, ÷òî êîãäà íà âåðõíåì óðîâíå äèàëîãà (â îòâåò
íà çàïðîñ ââîäà) ââîäèòñÿ âûðàæåíèå, òî îíî âû÷èñëÿåòñÿ, è çàòåì ïå-
÷àòàåòñÿ åãî çíà÷åíèå âìåñòå ñ òèïîì. Íà ñàìîì äåëå çäåñü ML ïðèâÿçû-
âàåò ê ýòîìó çíà÷åíèþ èäåíòèôèêàòîð it, òàê ÷òî â äàëüíåéøèõ ôðàçàõ
âåðõíåãî óðîâíÿ äèàëîãà èäåíòèôèêàòîð it ìîæåò èñïîëüçîâàòüñÿ äëÿ
äîñòóïà ê ýòîìó çíà÷åíèþ7.
Âàæíî îòìåòèòü îòëè÷èå ïîíÿòèÿ ïåðåìåííîé â ML îò ïîíÿòèÿ ïå-
ðåìåííîé â äðóãèõ ÿçûêàõ ïðîãðàììèðîâàíèÿ. Îáúÿâëåíèå ïåðåìåííîé
â ML áîëåå ïîõîæå íà îïèñàíèå const â Pascal'e, íåæåëè íà îïèñàíèå
var; â ÷àñòíîñòè, ïðèâÿçêà íå ÿâëÿåòñÿ ïðèñâàèâàíèåì. Êîãäà íåêîòî-
ðûé èäåíòèôèêàòîð ïðèâÿçûâàåòñÿ ê çíà÷åíèþ, ñîçäàåòñÿ íîâûé èäåí-
òèôèêàòîð  è îí íå èìååò íèêàêîãî îòíîøåíèÿ ê (âîçìîæíî) ðàíåå
îáúÿâëåííîìó òàêîìó æå èäåíòèôèêàòîðó. Áîëåå òîãî, ïîñëå òîãî, êàê
èäåíòèôèêàòîð ïðèâÿçàí ê çíà÷åíèþ, íåò íèêàêîãî ñïîñîáà èçìåíèòü
ýòî çíà÷åíèå: åãî çíà÷åíèå âñåãäà îñòàåòñÿ òåì, ê êîòîðîìó ìû ïðèâÿ-
çàëè åãî â ìîìåíò îáúÿâëåíèÿ. Åñëè âû íåçíàêîìû ñ ôóíêöèîíàëüíûìè
ÿçûêàìè ïðîãðàììèðîâàíèÿ, ýòî ìîæåò ïîêàçàòüñÿ íåñêîëüêî ñòðàííûì;
ïîäîæäèòå, ïîêà ìû íå ðàññìîòðèì ïðèìåðû ïðîãðàìì è íå ïîêàæåì,
7Òàêèì îáðàçîì, ìîæíî ñ÷èòàòü, ÷òî ââîä íà âåðõíåì óðîâíå äèàëîãà âûðàæåíèÿ e
ÿâëÿåòñÿ ñîêðàùåííîé ôîðìîé äëÿ val it = e. Â íåêîòîðûõ ðåàëèçàöèÿõ ML ýòîò
ôàêò ÿâíî îòðàæåí  â îòâåò íà ââîä âûðàæåíèÿ ïå÷àòàåòñÿ val it = çíà÷åíèå :
òèï (âìåñòî ïðèâîäèìîé çäåñü â ïðèìåðàõ âûäà÷è çíà÷åíèå : òèï). (Ïðèì. ïåðåâ.)

2.3. ÈÄÅÍÒÈÔÈÊÀÒÎÐÛ, ÏÐÈÂßÇÊÈ È ÎÁÚßÂËÅÍÈß
17
êàê ýòî ìîæåò èñïîëüçîâàòüñÿ. Òàê êàê ðàíåå îáúÿâëåííûå èäåíòèôèêà-
òîðû ìîãóò áûòü ïðèâÿçàíû ê íîâûì çíà÷åíèÿì, íåîáõîäèìî óòî÷íèòü,
êàêàÿ èç ïðèâÿçîê äîëæíà áûòü èñïîëüçîâàíà â äàííîé òî÷êå ïðîãðàì-
ìû. Äàâàéòå ðàññìîòðèì ñëåäóþùóþ ïîñëåäîâàòåëüíîñòü ïðèâÿçîê:
- val x = 17;
> val õ = 17 : int
- val ó = x;
> val y = 17 : int
- val x = true;
> val x = true : bool
- val z = x;
> val z = true : bool
Âòîðàÿ ïðèâÿçêà x çàñëîíÿåò ïåðâóþ (íî íå îêàçûâàåò íèêàêîãî
âëèÿíèÿ íà çíà÷åíèå ïåðåìåííîé ó). Âñÿêèé ðàç, êîãäà èäåíòèôèêàòîð
èñïîëüçóåòñÿ â âûðàæåíèè, îí ñ÷èòàåòñÿ ññûëàþùèìñÿ íà òåêñòóàëüíî
áëèæàéøóþ îáúåìëþùóþ ïðèâÿçêó ýòîãî èäåíòèôèêàòîðà. Òàêèì îáðà-
çîì, èñïîëüçîâàíèå õ â ïðàâîé ÷àñòè ïðèâÿçêè èäåíòèôèêàòîðà z ññûëà-
åòñÿ íà âòîðóþ ïðèâÿçêó èäåíòèôèêàòîðà õ, è ïîýòîìó çíà÷åíèå z åñòü
true, à íå 17. Ýòî ïðàâèëî àíàëîãè÷íî ïðàâèëàì âèäèìîñòè â ÿçûêàõ
ñ áëî÷íîé ñòðóêòóðîé. Ñ ïîìîùüþ êëþ÷åâîãî ñëîâà and, èñïîëüçóåìîãî
â êà÷åñòâå ðàçäåëèòåëÿ, ìîæíî ïðèâÿçàòü ê çíà÷åíèÿì ñðàçó íåñêîëüêî
èäåíòèôèêàòîðîâ:
- val x = 17;
> val õ = 17 : int
- val x = true and ó = x;
> val x = true : bool
val ó = 17 : int
Îáðàòèòå âíèìàíèå íà òî, ÷òî y ïîëó÷àåò çíà÷åíèå 17, à íå true!
Íåñêîëüêî ïðèâÿçîê, ñîåäèíåííûõ ñëîâîì and, âû÷èñëÿþòñÿ ïàðàëëåëü-
íî  ñíà÷àëà âû÷èñëÿþòñÿ èõ ïðàâûå ÷àñòè, à çàòåì èäåíòèôèêàòîðû,
óêàçàííûå â ëåâûõ ÷àñòÿõ, ïðèâÿçûâàþòñÿ ê ïîëó÷åííûì çíà÷åíèÿì.
Äëÿ òîãî ÷òîáû ïðîäîëæèòü èçëîæåíèå, íàì íóæíî ââåñòè íåñêîëüêî
îïðåäåëåíèé. Ìû áóäåì ãîâîðèòü, ÷òî ðîëü îáúÿâëåíèÿ ñîñòîèò â îïðå-
äåëåíèè èäåíòèôèêàòîðà äëÿ äàëüíåéøåãî èñïîëüçîâàíèÿ â ïðîãðàììå.
Ñóùåñòâóþò ðàçëè÷íûå âîçìîæíîñòè èñïîëüçîâàíèÿ èäåíòèôèêàòîðà â
ïðîãðàììå; îäíèì èç íèõ ÿâëÿåòñÿ èñïîëüçîâàíèå â êà÷åñòâå ïåðåìåííîé.
×òîáû îïðåäåëèòü èäåíòèôèêàòîð äëÿ êàêîé-íèáóäü öåëè, íåîáõîäèìî

18
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
èñïîëüçîâàòü ïðèâÿçêó, ñîîòâåòñòâóþùóþ ýòîé öåëè. Íàïðèìåð, ÷òîáû
îïðåäåëèòü èäåíòèôèêàòîð êàê ïåðåìåííóþ, ñëåäóåò èñïîëüçîâàòü ïðè-
âÿçêó ê çíà÷åíèþ (êîòîðàÿ ïðèâÿçûâàåò ïåðåìåííóþ ê çíà÷åíèþ è óñòà-
íàâëèâàåò åå òèï). Äðóãèå ôîðìû ïðèâÿçîê áóäóò ââåäåíû ïîçæå. Â îá-
ùåì ñëó÷àå, ðîëü îáúÿâëåíèÿ ñîñòîèò â ïîñòðîåíèè íåêîòîðîé ñðåäû,
êîòîðàÿ îïðåäåëÿåò ñìûñë âñåõ îáúÿâëåííûõ èäåíòèôèêàòîðîâ. Íàïðè-
ìåð, ïîñëå âûïîëíåíèÿ ïðèâåäåííûõ âûøå ïðèâÿçîê ê çíà÷åíèÿì ñðåäà
ñîäåðæèò èíôîðìàöèþ î òîì, ÷òî çíà÷åíèå x åñòü true è çíà÷åíèå y
åñòü 17. Âû÷èñëåíèå âûðàæåíèÿ âñåãäà ïðîèñõîäèò â íåêîòîðîé ñðåäå; â
óïîìÿíóòîé ñðåäå çíà÷åíèåì âûðàæåíèÿ x áóäåò true.
Òî÷íî òàê æå, êàê âûðàæåíèÿ ìîãóò áûòü ñîåäèíåíû äðóã ñ äðóãîì
îïåðàöèÿìè (êàê, íàïðèìåð, ñëîæåíèå èëè îáðàçîâàíèå óïîðÿäî÷åííîé
ïàðû) ñ öåëüþ ïîëó÷èòü íîâûå âûðàæåíèÿ, îáúÿâëåíèÿ ìîãóò áûòü ñî-
åäèíåíû ñ äðóãèìè îáúÿâëåíèÿìè. Ðåçóëüòàòîì ñîñòàâíîãî îáúÿâëåíèÿ
ÿâëÿåòñÿ ñðåäà, êîòîðàÿ îïðåäåëÿåòñÿ ñðåäàìè, ïîðîæäàåìûìè êîìïî-
íåíòàìè ñîñòàâíîãî îáúÿâëåíèÿ. Îäèí èç ñïîñîáîâ ñîåäèíåíèÿ îáúÿâëå-
íèé ìû óæå âèäåëè: òî÷êà ñ çàïÿòîé ïîçâîëÿåò ñòðîèòü ïîñëåäîâàòåëü-
íóþ êîìïîçèöèþ ñðåä 8.
- val õ = 17; val õ = true and ó = õ;
> val x = 17: int
> val x = true : bool
val ó = 17: int
Êîãäà äâà îáúÿâëåíèÿ ñîåäèíÿþòñÿ òî÷êîé ñ çàïÿòîé, ML ñíà÷àëà âû-
÷èñëÿåò ëåâîå îáúÿâëåíèå, ïîðîæäàÿ ñðåäó E, à çàòåì âû÷èñëÿåò ïðàâîå
îáúÿâëåíèå (â ñðåäå E), ïîðîæäàÿ ñðåäó E′. Âòîðîå îáúÿâëåíèå ìîæåò
ñêðûòü êàêèå-òî èäåíòèôèêàòîðû èç ïåðâîãî îáúÿâëåíèÿ (êàê ïîêàçàíî
â ïðèìåðå).
Òàêæå ïîëåçíî èìåòü ëîêàëüíûå îáúÿâëåíèÿ, ðîëü êîòîðûõ ñîñòî-
èò òîëüêî â òîì, ÷òîáû îáëåã÷èòü ïîñòðîåíèå äðóãèõ îáúÿâëåíèé. Ýòî
ìîæåò áûòü ñäåëàíî, íàïðèìåð, ñëåäóþùèì ñïîñîáîì:
- local
val x = 10
in
val u = x*x + x*x
val v = 2*x + (x div 5)
8Òî÷êà ñ çàïÿòîé ïî ñèíòàêñèñó íåîáÿçàòåëüíà: äâå ïîñëåäîâàòåëüíûå ïðèâÿçêè ê
çíà÷åíèþ ñ÷èòàþòñÿ ðàçäåëåííûìè òî÷êîé ñ çàïÿòîé

2.4. ÎÁÐÀÇÖÛ
19
end;
> val u = 200 : int
val v = 22 : int
Ïðèâÿçêà èäåíòèôèêàòîðà x ÿâëÿåòñÿ ëîêàëüíîé ïî îòíîøåíèþ ê
ïðèâÿçêàì èäåíòèôèêàòîðîâ u è v; x äîñòóïíî â ïðîöåññå ïðèâÿçêè u è
v, íî íå äàëüøå. Ýòî îòðàæåíî è â ðåçóëüòàòå îáúÿâëåíèÿ: îáúÿâëåíû
òîëüêî u è v. Èìååòñÿ òàêæå âîçìîæíîñòü ëîêàëèçîâàòü îáúÿâëåíèå,
èñïîëüçóåìîå ïðè âû÷èñëåíèÿ âûðàæåíèÿ:
- let
val x = 10
in
õ*õ + 2*õ + 1
end;
> 121: int
Îáúÿâëåíèå x ÿâëÿåòñÿ ëîêàëüíûì è ïîýòîìó íåâèäèìî çà ïðåäåëà-
ìè ïðèâåäåííîé êîíñòðóêöèè. Òåëî êîíñòðóêöèè let (ðàñïîëàãàþùååñÿ
ìåæäó êëþ÷åâûìè ñëîâàìè in è end) âû÷èñëÿåòñÿ â ñðåäå, ïîëó÷åííîé
â ðåçóëüòàòå âû÷èñëåíèÿ îáúÿâëåíèé, ðàñïîëîæåííûõ ïåðåä in. Â ïðè-
âåäåííîì ïðèìåðå, ðàñïîëîæåííîå òàì îáúÿâëåíèå ïðèâÿçûâàåò èäåí-
òèôèêàòîð x ê çíà÷åíèþ 10. Â ïîëó÷åííîé ñðåäå çíà÷åíèå âûðàæåíèÿ
x*x+2*x+1 åñòü 121; ýòî çíà÷åíèå è áóäåò çíà÷åíèåì âñåãî âûðàæåíèÿ.
Óïðàæíåíèå 2.3.1 Êàêîé ðåçóëüòàò áóäåò íàïå÷àòàí ML-ñèñòåìîé
â îòâåò íà ââîä ñëåäóþùèõ îáúÿâëåíèé (ïðåäïîëàãàåòñÿ, ÷òî íåò íè-
êàêèõ äðóãèõ ïðèâÿçîê äëÿ x, y u z):
1. val x=2 and y=x+1;
2. val x=1; local val x=2 in val y=x+1 end; val z=x+1;
3. let val x=1 in let val x=2 and y=x in x+y end end;
2.4
Îáðàçöû
Êàê âû, âåðîÿòíî, çàìåòèëè, ïîêà ÷òî ó íàñ íå èìååòñÿ ñðåäñòâ äëÿ
âûäåëåíèÿ, íàïðèìåð, ïåðâîãî ÷ëåíà óïîðÿäî÷åííîé ïàðû. Âûäåëåíèå
÷àñòåé ñîñòàâíûõ çíà÷åíèé âûïîëíÿåòñÿ ñ ïîìîùüþ ñîïîñòàâëåíèÿ ñ
îáðàçöîì. Çíà÷åíèÿ ñîñòàâíûõ òèïîâ ñàìè ÿâëÿþòñÿ ñîñòàâíûìè; îíè

20
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
ñòðîÿòñÿ èç ñîñòàâëÿþùèõ èõ çíà÷åíèé ñ ïîìîùüþ êîíñòðóêòîðîâ. Åñòå-
ñòâåííî èñïîëüçîâàòü àíàëîãè÷íóþ êîíñòðóêöèþ äëÿ ðàçëîæåíèÿ èõ íà
ñîñòàâëÿþùèå çíà÷åíèÿ.
Ïðåäïîëîæèì, ÷òî x èìååò òèï int*bool. Òîãäà õ ÿâëÿåòñÿ ïàðîé,
ëåâàÿ êîìïîíåíòà êîòîðîé ÿâëÿåòñÿ öåëûì, à ïðàâàÿ  ëîãè÷åñêèì. Ìû
ìîæåì ïîëó÷èòü çíà÷åíèÿ ëåâîé è ïðàâîé êîìïîíåíò, èñïîëüçóÿ ñëåäó-
þùóþ îáîáùåííóþ ôîðìó ïðèâÿçêè ê çíà÷åíèþ:
- val x = (17, true);
> val x = (17,true) : int*bool
- val (left, right) = x;
> val left = 17 : int
val right = true : bool
Ëåâàÿ ÷àñòü âòîðîé ïðèâÿçêè ÿâëÿåòñÿ îáðàçöîì. Â îáùåì ñëó÷àå îá-
ðàçåö ñòðîèòñÿ èç ïåðåìåííûõ è êîíñòàíò ñ ïîìîùüþ êîíñòðóêòîðîâ.
Òàêèì îáðàçîì, îáðàçåö åñòü âûðàæåíèå, âîçìîæíî, âêëþ÷àþùåå ïåðå-
ìåííûå. Îòëè÷èå îò ðàíåå ðàññìàòðèâàâøèõñÿ âûðàæåíèé ñîñòîèò â òîì,
÷òî â îáðàçöå ïåðåìåííûå íå èçîáðàæàþò çíà÷åíèÿ îïðåäåëåííûå ïðåä-
øåñòâóþùèìè ïðèâÿçêàìè, à ÿâëÿþòñÿ ïåðåìåííûìè, êîòîðûå äîëæíû
áûòü ïðèâÿçàíû ê çíà÷åíèÿì â ïðîöåññå ñîïîñòàâëåíèÿ ñ îáðàçöîì. Â
ïðèâåäåííîì âûøå ïðèìåðå left è right ñóòü íîâûå èäåíòèôèêàòîðû,
êîòîðûå äîëæíû áûòü ïðèâÿçàíû ê çíà÷åíèÿì. Ñîïîñòàâëåíèå ñ îáðàç-
öîì ñîñòîèò â ïàðàëëåëüíîì ðàçëîæåíèè íà ñîñòàâíûå ÷àñòè çíà÷åíèÿ
x è îáðàçöà, è ñîïîñòàâëåíèè êîìïîíåíò çíà÷åíèÿ ñ ñîîòâåòñòâóþùè-
ìè èì ÷àñòÿìè îáðàçöà. Ïåðåìåííàÿ ìîæåò áûòü ñîïîñòàâëåíà ñ ëþáûì
çíà÷åíèåì, è òîãäà èäåíòèôèêàòîð ïðèâÿçûâàåòñÿ ê ýòîìó çíà÷åíèþ.
Åñëè æå îáðàçåö ñîäåðæèò êîíñòàíòó, òî îíà äîëæíà ñîâïàäàòü ñ ñîîò-
âåòñòâóþùåé ÷àñòüþ çíà÷åíèÿ, ñ êîòîðûì âûïîëíÿåòñÿ ñîïîñòàâëåíèå.
Â ïðèâåäåííîì âûøå ïðèìåðå, ïîñêîëüêó x ÿâëÿåòñÿ óïîðÿäî÷åííîé ïà-
ðîé, ñîïîñòàâëåíèå çàâåðøàåòñÿ óñïåøíî; ïðè ýòîì ëåâàÿ êîìïîíåíòà x
ïðèâÿçûâàåòñÿ ê left, à ïðàâàÿ  ê right.
Îáðàòèòå âíèìàíèå íà òî, ÷òî ïðîñòåéøèì ñëó÷àåì îáðàçöà ÿâëÿåò-
ñÿ ïåðåìåííàÿ. Òàêèì îáðàçîì, ðàññìîòðåííàÿ ðàíåå ïðèâÿçêà ÿâëÿåòñÿ
÷àñòíûì ñëó÷àåì ñîïîñòàâëåíèÿ ñ îáðàçöîì.
Áåññìûñëåííî ïûòàòüñÿ ñîïîñòàâèòü, íàïðèìåð, öåëîå ñ óïîðÿäî÷åí-
íîé ïàðîé èëè ñïèñîê ñ çàïèñüþ. Ïîýòîìó ëþáàÿ òàêàÿ ïîïûòêà ðàññìàò-
ðèâàåòñÿ êàê îøèáêà â ñîãëàñîâàíèè òèïîâ, è îáíàðóæèâàåòñÿ ñòàòè÷å-
ñêè, ò.å. â ïåðèîä êîìïèëÿöèè. Îäíàêî, ñîïîñòàâëåíèå ñ îáðàçöîì ìîæåò
ïîòåðïåòü íåóäà÷ó è äèíàìè÷åñêè, ò.å. âî âðåìÿ èñïîëíåíèÿ ïðîãðàììû:

2.4. ÎÁÐÀÇÖÛ
21
- val õ = (false, 17);
> val õ = (false,17) : bool*int
- val (false, w) = x;
> val w = 17 : int
- val (true, w) = x;
Failure:
Match
Îáðàòèòå âíèìàíèå íà òî, ÷òî âî âòîðîé è â òðåòüåé ïðèâÿçêå îáðà-
çåö ñîäåðæèò êîíñòàíòó â êà÷åñòâå ëåâîãî ÷ëåíà óïîðÿäî÷åííîé ïàðû.
Òîëüêî ïàðà ñ òàêèì æå çíà÷åíèåì ëåâîãî ÷ëåíà ìîæåò áûòü óñïåøíî
ñîïîñòàâëåíà ñ òàêèì îáðàçöîì. Âî âòîðîì ñëó÷àå ýòî óñëîâèå âûïîëíå-
íî, è ñîïîñòàâëåíèå çàâåðøàåòñÿ óñïåøíî, ïðèâÿçûâàÿ èäåíòèôèêàòîð
w ê çíà÷åíèþ 17. Â ïîñëåäíåì æå ñëó÷àå óñëîâèå íå âûïîëíåíî; ñîîáùå-
íèå Failure: Match ãîâîðèò î òîì, ÷òî â ïåðèîä èñïîëíåíèÿ âîçíèêëà
îøèáêà ïðè ñîïîñòàâëåíèè ñ îáðàçöîì.
Ñîïîñòàâëåíèå ñ îáðàçöîì ìîæåò áûòü âûïîëíåíî äëÿ çíà÷åíèé èìå-
þùèõ ëþáîé èç ââåäåííûõ ðàíåå òèïîâ. Íàïðèìåð, ìû ìîæåì ïîëó÷èòü
êîìïîíåíòû òðåõýëåìåíòíîãî ñïèñêà ñëåäóþùèì îáðàçîì:
- val lst = [ "Lo", "and", "behold" ];
> val lst = [ "Lo", "and", "behold" ]: string list
- val [x1,x2,x3] = lst
> val x1 = "Lo" : string
val x2 = "and" : string
val x3 = "behold" : string
Ýòî ðàáîòàåò ïðåêðàñíî  äî òåõ ïîð, ïîêà ìû çíàåì äëèíó ñïèñêà.
Íî êàê áûòü â ñëó÷àå íåïóñòîãî ñïèñêà lst ïðîèçâîëüíîé äëèíû? ßñíî,
÷òî åãî íåâîçìîæíî ðàçëîæèòü íà êîìïîíåíòû ñ ïîìîùüþ îäíîãî ôèê-
ñèðîâàííîãî îáðàçöà! Òåì íå ìåíåå, ìû ìîæåì ðàçëîæèòü lst, îïèðàÿñü
íà èíäóêòèâíîå îïðåäåëåíèå ñïèñêà.
- val lst = [ "Lo", "and", "behold" ];
> val lst = [ "Lo", "and", "behold" ]: string list
- val hd :: tl = lst;
> val hd = "Lo": string
val tl = ["and","behold"]: string list
Çäåñü hd ïðèâÿçûâàåòñÿ ê çíà÷åíèþ ïåðâîãî ýëåìåíòà ñïèñêà lst (íà-
çûâàåìîãî ãîëîâîé (head) ñïèñêà lst) è tl ïðèâÿçûâàåòñÿ ê ñïèñêó, ïî-
ëó÷àþùåìóñÿ ïîñëå óäàëåíèÿ ïåðâîãî ýëåìåíòà èç lst (ýòîò ñïèñîê íà-
çûâàåòñÿ õâîñòîì (tail) ñïèñêà lst). Òèïîì hd ÿâëÿåòñÿ string, à òèïîì

22
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
tl  string list. Ïðè÷èíà ýòîãî â òîì, ÷òî êîíñòðóêòîð :: òðåáóåò â
êà÷åñòâå ëåâîãî àðãóìåíòà ýëåìåíò ñïèñêà, à â êà÷åñòâå ïðàâîãî  ñïè-
ñîê.
Óïðàæíåíèå 2.4.1 ×òî ïðîèçîéäåò, åñëè ìû íàïèøåì [hd,tl]=lst
âìåñòî òîãî, ÷òî áûëî íàïèñàíèå âûøå? (Ïîäñêàçêà: Çàìåíèòå ñîêðà-
ùåíèå [hd,tl] ïîëíîé çàïèñüþ.)
Ïðåäïîëîæèì, ÷òî íàñ èíòåðåñóåò òîëüêî ãîëîâà ñïèñêà. Òîãäà íàì
íåçà÷åì ïðèïèñûâàòü èìÿ õâîñòó (ñ åäèíñòâåííîé öåëüþ íåìåäëåííî åãî
çàáûòü). ×òîáû èçáàâèòüñÿ îò íåîáõîäèìîñòè âûäóìûâàòü èìåíà, êîòî-
ðûå â äàëüíåéøåì âñå ðàâíî íå áóäóò èñïîëüçîâàòüñÿ, ML ïîçâîëÿåò
ïèñàòü âìåñòî íèõ óíèâåðñàëüíûé îáðàçåö, èëè äæîêåð (îáîçíà÷àåìûé
çíàêîì _  ïîä÷åðêèâàíèå), êîòîðûé ìîæåò áûòü ñîïîñòàâëåí ñ ëþáûì
çíà÷åíèåì áåç ïðèâÿçêè ê íåìó èäåíòèôèêàòîðà.
- val lst = [ "Lo", "and", "behold" ];
> val lst = [ "Lo", "and", "behold" ] : string list
- val hd :: _ = lst;
> val hd = "Lo" : string
Ñîïîñòàâëåíèå ñ îáðàçöîì ìîæåò áûòü ïðèìåíåíî è äëÿ çàïèñåé, è,
êàê âû ìîæåòå ïðåäïîëîæèòü, äåëàåòñÿ ýòî ñ ïîìîùüþ ïîìå÷åííûõ ïî-
ëåé. Ñëåäóþùèé ïðèìåð èëëþñòðèðóåò ñîïîñòàâëåíèå ñ îáðàçöîì äëÿ
çàïèñåé:
- val r = {name="Foo", used=true};
> val r = {name="Foo",used=true} : {name:string,used:bool}
- val { used=u, name=n } = r;
> val n = "Foo" : string
val u = true : bool
Èíîãäà óäîáíî âûïîëíèòü ÷àñòè÷íîå ñîïîñòàâëåíèå çàïèñè ñ îáðàç-
öîì. Ýòî ìîæåò áûòü âûïîëíåíî ñ ïîìîùüþ óíèâåðñàëüíîãî îáðàçöà äëÿ
çàïèñåé, êàê â ñëåäóþùåì ïðèìåðå:
- val {used=u,...} = r;
> val u = true : bool
Ñóùåñòâåííûì îãðàíè÷åíèåì ïðè èñïîëüçîâàíèè óíèâåðñàëüíîãî îá-
ðàçöà äëÿ çàïèñåé ÿâëÿåòñÿ ñëåäóþùåå: ïîëíûé òèï çàïèñè äîëæåí îïðå-
äåëÿòüñÿ íà ýòàïå êîìïèëÿöèè (ò.å. ïîëíûé ñïèñîê èìåí ïîëåé çàïèñè è
èõ òèïîâ äîëæåí îïðåäåëÿòüñÿ ïî êîíòåêñòó, â êîòîðûé âõîäèò îáðàçåö).

2.4. ÎÁÐÀÇÖÛ
23
Ïîñêîëüêó âûäåëåíèå îäíîãî ïîëÿ èç çàïèñè ÿâëÿåòñÿ øèðîêî ðàñ-
ïðîñòðàíåííîé îïåðàöèåé, äëÿ íåå ïðåäóñìîòðåíî ñïåöèàëüíîå îáîçíà÷å-
íèå: ïîëå name çàïèñè r ìîæåò áûòü îáîçíà÷åíî êàê #name r. Íà ñàìîì
äåëå #name ÿâëÿåòñÿ íå áîëåå ÷åì ñîêðàùåííûì îáîçíà÷åíèåì äëÿ ôóíê-
öèè fn {name=n,...} => n, âûäåëÿþùåé ïîëå name èç çàïèñè. Ïîýòîìó,
â ÷àñòíîñòè, òèï çàïèñè äîëæåí îïðåäåëÿòüñÿ èç êîíòåêñòà, â êîòîðîì
ýòà ôóíêöèÿ èñïîëüçóåòñÿ. Íàïðèìåð, fn x => #name x áóäåò îøèáêîé,
ïîñêîëüêó òèï çàïèñè x íå îïðåäåëÿåòñÿ îäíîçíà÷íî êîíòåêñòîì. Ïî-
ñêîëüêó óïîðÿäî÷åííûå ýíêè ÿâëÿþòñÿ ÷àñòíûì ñëó÷àåì çàïèñè (èìå-
íàìè ïîëåé ó íèõ ÿâëÿþòñÿ öåëûå ÷èñëà îò 1 äî n), i-òàÿ êîìïîíåíòà
óïîðÿäî÷åííîé ýíêè ìîæåò áûòü âûäåëåíà ñ ïîìîùüþ ôóíêöèè #i.
Îáðàçöû ìîãóò âêëàäûâàòüñÿ äðóã â äðóãà, êàê â ïðèâîäèìîì íèæå
ïðèìåðå:
- val x = (("foo",true), 17);
> val x = (("foo",true), 17) : (string*bool)*int
- val ((ll,lr), r) = x;
> val ll = "foo" : string
val lr = true : bool
val r = 17 : int
Èíîãäà áûâàåò óäîáíî ââåñòè ïðîìåæóòî÷íûå ïåðåìåííûå â îá-
ðàçöå. Íàïðèìåð, íàì ìîæåò ïîíàäîáèòüñÿ ïðèâÿçàòü ê ïàðå (ll,rr)
èäåíòèôèêàòîð l. Ýòî âûïîëíÿåòñÿ ñ ïîìîùüþ ìíîãîóðîâíåâûõ îáðàç-
öîâ. Ìíîãîóðîâíåâûé îáðàçåö ïîëó÷àåòñÿ ïóòåì ïðèïèñûâàíèÿ îáðàçöà
ê ïåðåìåííîé âíóòðè äðóãîãî îáðàçöà, êàê â ñëåäóþùåì ïðèìåðå:
- val x = (("foo", true), 17);
> val x = (("foo", true), 17): (string*bool)*int
- val (l as (ll,lr), r) = x;
> val l = ("foo", true): string*bool
val ll = "foo": string
val lr = true : bool
val r = 17 : int
Çäåñü ñîïîñòàâëåíèå ñ îáðàçöîì âûïîëíÿåòñÿ îáû÷íûì ñïîñîáîì: l
è r ïðèâÿçûâàþòñÿ ê çíà÷åíèÿì ëåâîé è ïðàâîé êîìïîíåíò x, íî äî-
ïîëíèòåëüíî ïðîèçâîäèòñÿ ñîïîñòàâëåíèå ïðèâÿçàííîãî ê l çíà÷åíèÿ ñ
îáðàçöîì (ll,lr). Ðåçóëüòàò âûâîäèòñÿ êàê îáû÷íî.
Èìååòñÿ åùå îäíî âàæíîå îãðàíè÷åíèå: ëþáàÿ ïåðåìåííàÿ ìîæåò âõî-
äèòü â îáðàçåö òîëüêî îäèí ðàç. Â ÷àñòíîñòè, íåëüçÿ çàäàòü îáðàçåö âðî-

24
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
äå (x,x)  êîòîðûé äîëæåí áûë áû áûòü ñîïîñòàâèì òîëüêî ñ ñèììåò-
ðè÷íûìè ïàðàìè. Ýòî îãðàíè÷åíèå íà ïðàêòèêå íå âûçûâàåò òðóäíîñòåé,
íî óïîìÿíóòü åãî íåîáõîäèìî.
Óïðàæíåíèå 2.4.2 Ïîñòðîéòå îáðàçåö, êîòîðûé ïðèâÿçûâàë áû ïåðå-
ìåííóþ x ê çíà÷åíèþ 0 ïðè ñîïîñòàâëåíèè ñî ñëåäóþùèì âûðàæåíèåì
(íàïðèìåð, åñëè äàíî âûðàæåíèå (true,"hello",0), îáðàçöîì äîëæíî
áûòü (_,_,x):
1. {a=1, b=0, c=true}
2. [~2, ~1, 0, 1, 2]
3. [(1,2), (0,1)]
2.5
Îïðåäåëåíèÿ ôóíêöèé
Ìû óæå èñïîëüçîâàëè ïðåäîïðåäåëåííûå ôóíêöèè, òàêèå, êàê àðèô-
ìåòè÷åñêèå îïåðàöèè è îïåðàöèè ñðàâíåíèÿ. Â ýòîì ðàçäåëå ìû ðàññìîò-
ðèì ïðèâÿçêè ê ôóíêöèîíàëüíûì çíà÷åíèÿì, ïîñðåäñòâîì êîòîðûõ â ML
îïðåäåëÿþòñÿ íîâûå ôóíêöèè.
Íà÷íåì ñ íåñêîëüêèõ îáùèõ çàìå÷àíèé, êàñàþùèõñÿ ïîíÿòèÿ ôóíê-
öèè â ML. Ôóíêöèè èñïîëüçóþòñÿ ïóòåì ïðèìåíåíèÿ èõ ê àðãóìåíòàì
(ìû áóäåì òàêæå èñïîëüçîâàòü òåðìèí àïïëèêàöèÿ). Ñèíòàêñè÷åñêè ýòî
çàïèñûâàåòñÿ êàê äâà âûðàæåíèÿ îäíî çà äðóãèì (çíà÷åíèåì ïåðâîãî
âûðàæåíèÿ äîëæíà ÿâëÿòüñÿ ôóíêöèÿ, à çíà÷åíèåì âòîðîãî  åå àð-
ãóìåíò)  êàê, íàïðèìåð, size "abc" äëÿ âûçîâà ôóíêöèè size ñ àð-
ãóìåíòîì "abc". Âñå ôóíêöèè ÿâëÿþòñÿ ôóíêöèÿìè îäíîãî àðãóìåíòà;
ïðè íåîáõîäèìîñòè èñïîëüçîâàòü ôóíêöèè (ñîäåðæàòåëüíî) íåñêîëüêèõ
àðãóìåíòîâ, n àðãóìåíòîâ ôóíêöèè óïàêîâûâàþòñÿ â îäèí  óïîðÿäî-
÷åííóþ ýíêó. Òàê, íàïðèìåð, åñëè ôóíêöèÿ append äîëæíà ïîëó÷àòü äâà
àðãóìåíòà-ñïèñêà è âîçâðàùàòü ðåçóëüòàò-ñïèñîê, ïðèìåíåíèå åå áóäåò
èìåòü âèä append(l1,l2): ôîðìàëüíî ôóíêöèÿ ïðèìåíÿåòñÿ ê îäíîìó
àðãóìåíòó, êîòîðûé ÿâëÿåòñÿ óïîðÿäî÷åííîé ïàðîé (l1,l2). Äëÿ íåêî-
òîðûõ ôóíêöèé îò äâóõ àðãóìåíòîâ (îáû÷íî, âñòðîåííûõ) èñïîëüçóåòñÿ
ñïåöèàëüíûé ñèíòàêñèñ  òàê íàçûâàåìàÿ èíôèêñíàÿ çàïèñü, â êîòîðîé
çíàê ôóíêöèè çàïèñûâàåòñÿ ìåæäó äâóìÿ åå àðãóìåíòàìè. Íàïðèìåð,
çàïèñü e1 + e2 â äåéñòâèòåëüíîñòè îçíà÷àåò ïðèìåíèòü ôóíêöèþ + ê
óïîðÿäî÷åííîé ïàðå (e1, e2). Ìîæíî èñïîëüçîâàòü èíôèêñíóþ çàïèñü
è äëÿ ôóíêöèé, îïðåäåëÿåìûõ ïîëüçîâàòåëåì, îäíàêî ìû íå áóäåì çäåñü
íà ýòîì îñòàíàâëèâàòüñÿ.

2.5. ÎÏÐÅÄÅËÅÍÈß ÔÓÍÊÖÈÉ
25
Àïïëèêàöèÿ â ML ìîæåò èìåòü áîëåå ñëîæíóþ ôîðìó, ÷åì â äðó-
ãèõ ÿçûêàõ ïðîãðàììèðîâàíèÿ. Ïðè÷èíîé ýòîãî ÿâëÿåòñÿ ñëåäóþùåå: â
áîëüøèíñòâå ÿçûêîâ ïðîãðàììèðîâàíèÿ ôóíêöèÿ ìîæåò îáîçíà÷àòüñÿ
òîëüêî èäåíòèôèêàòîðîì, è ïîýòîìó âûçîâ ôóíêöèè âñåãäà èìååò âèä
f(e1,...,en), ãäå f  èäåíòèôèêàòîð. Â ML íåò òàêîãî îãðàíè÷åíèÿ:
ôóíêöèÿ ÿâëÿåòñÿ îáû÷íûì çíà÷åíèåì, è ìîæåò áûòü ïîëó÷åíà â ðå-
çóëüòàòå âû÷èñëåíèÿ âûðàæåíèÿ. Ïîýòîìó â îáùåì ñëó÷àå àïïëèêàöèÿ
â ML èìååò âèä e e′. Âû÷èñëåíèå òàêîãî âûðàæåíèÿ âûïîëíÿåòñÿ ñëå-
äóþùèì îáðàçîì: ñíà÷àëà âû÷èñëÿåòñÿ âûðàæåíèå e, â ðåçóëüòàòå ÷åãî
ïîëó÷àåòñÿ íåêîòîðàÿ ôóíêöèÿ f; çàòåì âû÷èñëÿåòñÿ âûðàæåíèå e′, â
ðåçóëüòàòå ÷åãî ïîëó÷àåòñÿ íåêîòîðîå çíà÷åíèå ν; ïîñëå ýòîãî ôóíêöèÿ
f ïðèìåíÿåòñÿ ê çíà÷åíèþ ν. Â ïðîñòåéøåì ñëó÷àå, êîãäà âûðàæåíèå e
ÿâëÿåòñÿ èäåíòèôèêàòîðîì (êàê, íàïðèìåð, size), âû÷èñëåíèå e ÿâëÿåò-
ñÿ êðàéíå ïðîñòîé îïåðàöèåé: íóæíî ïðîñòî âçÿòü çíà÷åíèå, ê êîòîðîìó
ïðèâÿçàí èäåíòèôèêàòîð (îíî äîëæíî áûòü ôóíêöèåé). Íî â îáùåì ñëó-
÷àå ïðîöåññ âû÷èñëåíèÿ e ìîæåò áûòü ñêîëü óãîäíî ñëîæíûì. Îáðàòè-
òå âíèìàíèå íà òî, ÷òî ïðàâèëà âû÷èñëåíèÿ àïïëèêàöèè ïðåäïîëàãàþò
ïåðåäà÷ó àðãóìåíòà ïî çíà÷åíèþ, ïîñêîëüêó àðãóìåíò âû÷èñëÿåòñÿ äî
ïðèìåíåíèÿ ôóíêöèè.
Êàêèì ñïîñîáîì ìîæíî ãàðàíòèðîâàòü, ÷òî â àïïëèêàöèè e e′ ðåçóëü-
òàòîì âû÷èñëåíèÿ âûðàæåíèÿ e áóäåò ôóíêöèÿ (à, íàïðèìåð, íå öåëîå
÷èñëî)? ×òîáû îòâåòèòü íà ýòîò âîïðîñ, êîíå÷íî, ñëåäóåò ïîñìîòðåòü,
êàêîé òèï èìååò e. Ôóíêöèè ÿâëÿþòñÿ çíà÷åíèÿìè, à êàæäîå çíà÷åíèå
â ML èìååò òèï. Ôóíêöèîíàëüíûå òèïû ÿâëÿþòñÿ ñîñòàâíûìè òèïàìè,
÷ëåíàìè êîòîðûõ ÿâëÿþòñÿ ôóíêöèè. Ôóíêöèîíàëüíûå òèïû çàïèñûâà-
þòñÿ êàê σ -> τ (ïðîèçíîñèòñÿ σ â τ), ãäå σ è τ  òèïû. Âûðàæåíèå
òàêîãî òèïà èìååò â êà÷åñòâå çíà÷åíèÿ ôóíêöèþ, êîòîðàÿ ìîæåò áûòü
ïðèìåíåíà ê àðãóìåíòó òèïà σ (è òîëüêî ê àðãóìåíòó òàêîãî òèïà), è,
åñëè åå âû÷èñëåíèå çàâåðøàåòñÿ óñïåøíî, âîçâðàùàåò ðåçóëüòàò òèïà τ
(ê ñîæàëåíèþ, â îáùåì ñëó÷àå íåâîçìîæíî îïðåäåëèòü, çàâåðøàåòñÿ ëè
âû÷èñëåíèå ôóíêöèè äëÿ ëþáîãî àðãóìåíòà èëè íåò). Òèï σ íàçûâàåòñÿ
òèïîì îáëàñòè îïðåäåëåíèÿ ôóíêöèè, à òèï τ  òèïîì îáëàñòè çíà÷å-
íèé. Àïïëèêàöèÿ e e′ äîïóñòèìà òîãäà è òîëüêî òîãäà, êîãäà òèï e åñòü
σ>τ, a òèï e′  σ; òèï âñåãî âûðàæåíèÿ åñòü τ.
Íàïðèìåð:
- size;
> size = fn : string -> int
- not;
> not = fn : bool -> bool

26
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
- not 3;
Type clash in: not 3
Looking for a: bool
I have found a: int
Òèï size ïîêàçûâàåò, ÷òî îíà ïîëó÷àåò àðãóìåíò òèïà string è âîç-
âðàùàåò ðåçóëüòàò òèïà int (êàê ìû è ìîãëè ïðåäïîëàãàòü). Àíàëîãè÷-
íî, not ÿâëÿåòñÿ ôóíêöèåé, ïîëó÷àþùåé ëîãè÷åñêèé àðãóìåíò è âîçâðà-
ùàþùåé ëîãè÷åñêèé ðåçóëüòàò. Ïîñêîëüêó ôóíêöèè íå èìåþò íèêàêîãî
âíåøíåãî ïðåäñòàâëåíèÿ, âñå îíè ïå÷àòàþòñÿ êàê fn. Ïðèìåíåíèå not ê
3 âûçûâàåò îøèáêó, ïîñêîëüêó òèï îáëàñòè îïðåäåëåíèÿ not åñòü bool,
â òî âðåìÿ êàê òèï 3 åñòü int.
Ïîñêîëüêó ôóíêöèè ÿâëÿþòñÿ çíà÷åíèÿìè, ìû ìîæåì ïðèâÿçàòü
èäåíòèôèêàòîð ê ôóíêöèè, èñïîëüçóÿ îáû÷íûé ìåõàíèçì ïðèâÿçêè
èäåíòèôèêàòîðà ê çíà÷åíèþ, ââåäåííûé â ïðåäûäóùåì ðàçäåëå. Íàïðè-
ìåð:
- val len = size;
> vai len = fn : string -> int
- len "abc";
> 3 : int
Èäåíòèôèêàòîð size ïðèâÿçàí ê íåêîòîðîé (ïðåäîïðåäåëåííîé) ôóíê-
öèè òèïà string->int. Ïðèâåäåííàÿ âûøå ïðèâÿçêà âûïîëíÿåòñÿ òàê:
èçâëåêàåòñÿ çíà÷åíèå èäåíòèôèêàòîðà size (êîòîðîå ÿâëÿåòñÿ ôóíêöè-
åé), è çàòåì ê ýòîìó çíà÷åíèþ ïðèâÿçûâàåòñÿ èäåíòèôèêàòîð len. Àï-
ïëèêàöèÿ len "abc" âû÷èñëÿåòñÿ ïóòåì èçâëå÷åíèÿ ôóíêöèè, ê êîòîðîé
ïðèâÿçàí èäåíòèôèêàòîð len, âû÷èñëåíèÿ çíà÷åíèÿ "abc" (êîòîðûì ÿâ-
ëÿåòñÿ ñàìà ýòà ñòðîêà) è ïðèìåíåíèÿ ôóíêöèè ê ñòðîêå. Ðåçóëüòàòîì
ÿâëÿåòñÿ 3, ïîñêîëüêó ôóíêöèÿ, ê êîòîðîé â ML ïðèâÿçàí èäåíòèôèêà-
òîð size, âîçâðàùàåò êîëè÷åñòâî ëèòåð â ñòðîêå-àðãóìåíòå.
Ôóíêöèè ÿâëÿþòñÿ ñîñòàâíûìè îáúåêòàìè; îäíàêî îíè íå ÿâëÿþòñÿ
ïîñòðîåííûìè ïóòåì ñîåäèíåíèÿ äðóãèõ îáúåêòîâ â òîì ñìûñëå, â êàêîì,
íàïðèìåð, óïîðÿäî÷åííàÿ ïàðà ïîñòðîåíà èç ñâîèõ êîìïîíåíò. Ïîýòî-
ìó èõ ñòðóêòóðà íåäîñòóïíà ïðîãðàììèñòó, è, â ÷àñòíîñòè, ê ôóíêöèÿì
íåïðèìåíèìî ñîïîñòàâëåíèå ñ îáðàçöîì. Êðîìå òîãî, íåâîçìîæíî ïðî-
âåðèòü ýêñòåíñèîíàëüíîå ðàâåíñòâî ôóíêöèé (ò.å. âûäàþò ëè äâå ôóíê-
öèè ðàâíûå ðåçóëüòàòû ïðè ðàâíûõ àðãóìåíòàõ), ïîñêîëüêó ýòî ÿâëÿåòñÿ
àëãîðèòìè÷åñêè íåðàçðåøèìîé çàäà÷åé. Çàìåòèì, ÷òî äëÿ âñåõ äðóãèõ
ðàíåå ââåäåííûõ òèïîâ ðàâåíñòâî èìåëîñü. Â äàëüíåéøåì ìû áóäåì ãî-
âîðèòü, ÷òî òèï äîïóñêàåò ïðîâåðêó íà ðàâåíñòâî, åñëè ìû ìîæåì äëÿ

2.5. ÎÏÐÅÄÅËÅÍÈß ÔÓÍÊÖÈÉ
27
ëþáûõ äâóõ çíà÷åíèé ýòîãî òèïà ïðîâåðèòü, ðàâíû îíè èëè íåò. Íèêà-
êîé ôóíêöèîíàëüíûé òèï íå äîïóñêàåò ïðîâåðêè íà ðàâåíñòâî, à ëþ-
áîé àòîìàðíûé òèï  äîïóñêàåò. ×òî æå ìîæíî ñêàçàòü îòíîñèòåëüíî
äðóãèõ ñîñòàâíûõ òèïîâ? Íàïîìíèì, ÷òî ðàâåíñòâî óïîðÿäî÷åííûõ ïàð
áûëî îïðåäåëåíî êàê ïîêîìïîíåíòíîå: äâå óïîðÿäî÷åííûõ ïàðû ðàâ-
íû òîãäà è òîëüêî òîãäà, êîãäà ðàâíû èõ ëåâûå êîìïîíåíòû è ðàâíû èõ
ïðàâûå êîìïîíåíòû. Òàêèì îáðàçîì, òèï σ*τ äîïóñêàåò ïðîâåðêó íà ðà-
âåíñòâî òîãäà è òîëüêî òîãäà, êîãäà îáà òèïà σ è τ äîïóñêàþò ïðîâåðêó
íà ðàâåíñòâî. Àíàëîãè÷íûå ïðàâèëà ïðèìåíèìû è ê òèïàì, ïîñòðîåí-
íûì äðóãèìè ñïîñîáàìè. Ãðóáîå, íî ÷àñòî äàþùåå ïðàâèëüíûé îòâåò
ïðàâèëî ñîñòîèò â òîì, ÷òî òèï, ïðè ïîñòðîåíèè êîòîðîãî èñïîëüçîâà-
ëèñü ôóíêöèîíàëüíûå òèïû, íå äîïóñêàåò ïðîâåðêè íà ðàâåíñòâî (ýòî
íå âñåãäà âåðíî; êîãäà âû ëó÷øå ïîçíàêîìèòåñü ñ ML, èçó÷èòå òî÷íîå
îïðåäåëåíèå äîïóñòèìîñòè ïðîâåðêè íà ðàâåíñòâî â [7]).
Ïîñëå ïðèâåäåííûõ âûøå çàìå÷àíèé ìû ãîòîâû ïåðåéòè ê îáñóæ-
äåíèþ ñïîñîáîâ îïðåäåëåíèÿ ôóíêöèé ïîëüçîâàòåëåì. Ñèíòàêñèñ îïðå-
äåëåíèÿ ôóíêöèè âî ìíîãîì ïîõîæ íà èñïîëüçóåìûé â äðóãèõ ÿçûêàõ.
Ïðèâåäåì íåñêîëüêî ïðèìåðîâ:
- fun twice x = 2*õ;
> val twice = fn : int->int
- twice 4;
> 8 : int
- fun fact x = if x=0 then 1 else x*fact(x-1);
> val fact = fn : int->int
- fact 5;
> 120 : int
- fun plus(x,y) : int = x+y
> val plus = fn : int*int->int
- plus(4,5);
> 9 : int
Ôóíêöèè îïðåäåëÿþòñÿ ïóòåì ïðèâÿçêè èäåíòèôèêàòîðà ê ôóíêöèî-
íàëüíîìó çíà÷åíèþ; ýòà êîíñòðóêöèÿ íà÷èíàåòñÿ êëþ÷åâûì ñëîâîì fun.
Çà èìåíåì ôóíêöèè ñëåäóþò åå ïàðàìåòðû, êîòîðûå çàäàþòñÿ îáðàçöîì.
Â ïåðâûõ äâóõ ïðèìåðàõ ïàðàìåòð ÿâëÿåòñÿ ïðîñòûì îáðàçöîì, ñîñòî-
ÿùèì èç îäíîãî èäåíòèôèêàòîðà; â òðåòüåì ïðèìåðå îáðàçåö ÿâëÿåò-
ñÿ óïîðÿäî÷åííîé ïàðîé, ëåâàÿ êîìïîíåíòà êîòîðîé åñòü õ è ïðàâàÿ ó.
Êîãäà âûïîëíÿåòñÿ ïðèìåíåíèå îïðåäåëåííîé ïîëüçîâàòåëåì ôóíêöèè,
çíà÷åíèå àðãóìåíòà ñîïîñòàâëÿåòñÿ ñ ïàðàìåòðîì-îáðàçöîì  òî÷íî òàê

28
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
æå, êàê è ïðè ïðèâÿçêå ê çíà÷åíèþ; ðåçóëüòàòîì ýòîãî ñîïîñòàâëåíèÿ
ÿâëÿåòñÿ íåêîòîðàÿ ñðåäà, â êîòîðîé è âûïîëíÿåòñÿ âû÷èñëåíèå òåëà
ôóíêöèè. Íàïðèìåð, â ñëó÷àå ôóíêöèè twice, x ïðèâÿçûâàåòñÿ ê àð-
ãóìåíòó (êîòîðûé äîëæåí áûòü öåëûì ÷èñëîì, ïîñêîëüêó òèï ôóíêöèè
twice åñòü int->int) è çàòåì âû÷èñëÿåòñÿ òåëî ôóíêöèè twice (ò.å. 2*x);
ðåçóëüòàòîì ÿâëÿåòñÿ 8. Â ñëó÷àå ôóíêöèè plus ñîïîñòàâëåíèå ñ îáðàç-
öîì íåñêîëüêî áîëåå ñëîæíîå, ïîñêîëüêó àðãóìåíò ÿâëÿåòñÿ óïîðÿäî÷åí-
íîé ïàðîé,  îäíàêî ýòî ñîïîñòàâëåíèå íè÷åì íå îòëè÷àåòñÿ îò ïðèâÿçêè
ê çíà÷åíèþ, ðàññìîòðåííîé â ïðåäûäóùåì ðàçäåëå: çíà÷åíèå àðãóìåíòà
ñîïîñòàâëÿåòñÿ ñ îáðàçöîì (x,y), â ðåçóëüòàòå ÷åãî x è y ïðèâÿçûâà-
þòñÿ ê çíà÷åíèÿì. Çàòåì â ïîëó÷åííîé ñðåäå âû÷èñëÿåòñÿ çíà÷åíèå òå-
ëà ôóíêöèè, è ðåçóëüòàò îïðåäåëÿåòñÿ ïî îáû÷íûì ïðàâèëàì. : int
â îïðåäåëåíèå plus íàçûâàåòñÿ ÿâíûì îãðàíè÷åíèåì òèïà, îíî çäåñü
íåîáõîäèìî, ïîñêîëüêó èç êîíòåêñòà íåâîçìîæíî îïðåäåëèòü, î ñëîæåíèè
çíà÷åíèé êàêîãî òèïà  int èëè real  èäåò ðå÷ü. Ïîçæå ìû îáñóäèì
ÿâíûå îãðàíè÷åíèÿ òèïà áîëåå ïîäðîáíî.
Óïðàæíåíèå 2.5.1 Çàïèøèòå ôóíêöèè circumference è area, âû÷èñ-
ëÿþùèå ñîîòâåòñòâåííî äëèíó îêðóæíîñòè è ïëîùàäü êðóãà ïî ðàäè-
óñó.
Óïðàæíåíèå 2.5.2 Çàïèøèòå ôóíêöèþ, âû÷èñëÿþùóþ ìîäóëü äåéñò-
âèòåëüíîãî ÷èñëà.
Îïðåäåëåíèå ôóíêöèè fact èëëþñòðèðóåò âàæíóþ îñîáåííîñòü îïðå-
äåëåíèÿ ôóíêöèé â ML: ôóíêöèè, îïðåäåëÿåìûå ñ ïîìîùüþ êîíñòðóê-
öèè fun, ÿâëÿþòñÿ ðåêóðñèâíûìè; ýòî îçíà÷àåò, ÷òî âõîæäåíèÿ èäåíòè-
ôèêàòîðà fact â ïðàâóþ ÷àñòü îïðåäåëåíèÿ ôóíêöèè fact ññûëàþòñÿ íà
îïðåäåëÿåìóþ ôóíêöèþ (à íå êàêîå-ëèáî äðóãîå çíà÷åíèå, ê êîòîðîìó
ìîã áû áûòü ïðèâÿçàí èäåíòèôèêàòîð fact â îêðóæàþùåé ñðåäå). Òàêèì
îáðàçîì, ôóíêöèÿ fact â ïðîöåññå âû÷èñëåíèÿ åå òåëà âûçûâàåò ñàìó
ñåáÿ. Îáðàòèòå âíèìàíèå íà òî, ÷òî ïðè êàæäîì ñëåäóþùåì ðåêóðñèâ-
íîì âûçîâå àðãóìåíò ôóíêöèè fact ñòàíîâèòñÿ ìåíüøå, ÷òî ãàðàíòèðóåò,
÷òî ïðîöåññ âû÷èñëåíèÿ ôóíêöèè çàâåðøèòñÿ (åñëè èñõîäíîå çíà÷åíèå
àðãóìåíòà áûëî íåîòðèöàòåëüíûì). Êîíå÷íî, âîçìîæíû è îïðåäåëåíèÿ
ôóíêöèé, âû÷èñëåíèå êîòîðûõ íèêîãäà íå çàâåðøàåòñÿ. Íàïðèìåð:
- fun f(x) = f(x);
> val f = fn : 'a->'b
Ëþáîé âûçîâ f ïðèâåäåò ê âîçíèêíîâåíèþ áåñêîíå÷íîãî öèêëà, â êîòî-
ðîì f âûçûâàåò ñåáÿ ñíîâà è ñíîâà.

2.5. ÎÏÐÅÄÅËÅÍÈß ÔÓÍÊÖÈÉ
29
Óïðàæíåíèå 2.5.3 Àëüòåðíàòèâíûé ñèíòàêñèñ äëÿ óñëîâíîãî âûðà-
æåíèÿ ìîæåò áûòü îïðåäåëåí êàê:
fun new_if ( À, Â, Ñ ) = if A then Â else Ñ
Îáúÿñíèòå, ÷òî ñòàíåò íåïðàâèëüíûì â îïðåäåëåíèè ôóíêöèè fact,
åñëè â íåì èñïîëüçîâàòü ýòîò íîâûé âàðèàíò óñëîâíîãî âûðàæåíèÿ.
Òåïåðü ìû ãîòîâû ïðîäîëæèòü ïîñòðîåíèå íîâûõ èíòåðåñíûõ ôóíê-
öèé è ïðèìåðîâ ïðîãðàììèðîâàíèÿ íà ML. Ðåêóðñèÿ ÿâëÿåòñÿ êëþ÷åâûì
ìîìåíòîì ôóíêöèîíàëüíîãî ïðîãðàììèðîâàíèÿ, è ïîýòîìó, åñëè âû åùå
íå î÷åíü õîðîøî îâëàäåëè ýòèì ïðèåìîì, ìû ñîâåòóåì âàì âíèìàòåëüíî
ðàçáèðàòü âñå ïðèâîäèìûå ïðèìåðû è ïðîâîäèòü âû÷èñëåíèå ðåêóðñèâ-
íûõ ôóíêöèé âðó÷íóþ.
Ïîêà ÷òî ìû ðàññìîòðåëè ôóíêöèè, àðãóìåíò-îáðàçåö êîòîðûõ ÿâ-
ëÿåòñÿ ïðîñòîé ïåðåìåííîé èëè óïîðÿäî÷åííîé ïàðîé. Äàâàéòå ðàññìîò-
ðèì, êàê ìû ìîæåì îïðåäåëèòü ôóíêöèè íà ñïèñêàõ  è äëÿ íà÷àëà
ïîïðîáóåì ïîñòðîèòü ôóíêöèþ is_nil, êîòîðàÿ îïðåäåëÿåò, ÿâëÿåòñÿ
ëè àðãóìåíò ïóñòûì ñïèñêîì èëè íåò. Ñïèñêîâûé òèï èìååò äâà êîí-
ñòðóêòîðà: nil è ::. Ôóíêöèÿ, îïðåäåëåííàÿ íà ñïèñêàõ, äîëæíà ðàáî-
òàòü íåçàâèñèìî îò òîãî, ÿâëÿåòñÿ ëè ñïèñîê ïóñòûì èëè íåò, è ïîýòîìó
äîëæíà áûòü îïðåäåëåíà ðàçáîðîì ñëó÷àåâ, îäèí èç êîòîðûõ åñòü nil, à
äðóãîé åñòü ::. Âîò îïðåäåëåíèå ôóíêöèè is_nil:
- fun is_nil (nil) = true
| is_nil (_::_) = false;
> is_nil = fn : 'a list -> bool
- is_nil nil;
> true: bool
- is_nil [2,3];
> false : bool
Îïðåäåëåíèå is_nil îòðàæàåò ñòðóêòóðó ñïèñêîâ: ôóíêöèÿ îïðåäåëÿåò-
ñÿ ñ ïîìîùüþ äâóõ ïðåäëîæåíèé  îäíî ïðåäëîæåíèå äëÿ nil, à äðóãîå
 äëÿ hd::tl. Â îïðåäåëåíèè ôóíêöèè ïðåäëîæåíèÿ îòäåëÿþòñÿ äðóã
îò äðóãà âåðòèêàëüíîé ÷åðòîé.
Â îáùåì ñëó÷àå, åñëè òèï àðãóìåíòà îïðåäåëÿåìîé ôóíêöèè èìååò
áîëåå îäíîãî êîíñòðóêòîðà, òî îïðåäåëåíèå ôóíêöèè äîëæíî ñîäåðæàòü
ïî îäíîìó ïðåäëîæåíèþ íà êàæäûé êîíñòðóêòîð. Ýòî ãàðàíòèðóåò òî,
÷òî ôóíêöèÿ ìîæåò ïðèíÿòü ëþáîé àðãóìåíò äàííîãî òèïà. Òàêîé ñïî-
ñîá îïðåäåëåíèÿ ôóíêöèé íàçûâàåòñÿ îïðåäåëåíèåì ñ ïîìîùüþ ðàçáîðà

30
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
ñëó÷àåâ, ïîñêîëüêó îïðåäåëåíèå ñîäåðæèò ïî îäíîìó ïðåäëîæåíèþ äëÿ
êàæäîãî ñëó÷àÿ ôîðìû àðãóìåíòà.
Ðàçóìååòñÿ, îïðåäåëåíèå ôóíêöèè ñ ïîìîùüþ ðàçáîðà ñëó÷àåâ ïðè-
ìåíèìî è äëÿ ðåêóðñèâíûõ ôóíêöèé. Ïðåäïîëîæèì, ìû õîòèì îïðå-
äåëèòü ôóíêöèþ append, êîòîðàÿ ïîëó÷àåò â êà÷åñòâå àðãóìåíòà äâà
ñïèñêà è âîçâðàùàåò ðåçóëüòàò, êîòîðûé ÿâëÿåòñÿ ñïèñêîì, ïîëó÷åííûì
ïóòåì ïðèïèñûâàíèÿ âòîðîãî ñïèñêà â êîíåö ïåðâîãî. Âîò åå îïðåäåëå-
íèå:
- fun append (nil, lst) = lst
| append (hd :: tl, lst) = hd :: append (tl, lst);
> val append = fn : ('a list * 'a list) -> 'a list
Îïðåäåëåíèå ðàññìàòðèâàåò äâà ñëó÷àÿ, îäèí  äëÿ ïóñòîãî ñïèñêà, è
âòîðîé  äëÿ íåïóñòîãî. Äîáàâëåíèå ñïèñêà lst ê ïóñòîìó ñïèñêó âû-
ïîëíÿåòñÿ êðàéíå ïðîñòî: ðåçóëüòàòîì ÿâëÿåòñÿ ñïèñîê lst. Â ñëó÷àå
íåïóñòîãî ïåðâîãî ñïèñêà (ò.å. èìåþùåãî âèä hd::tl) ìû äîëæíû äîáà-
âèòü ñïèñîê lst ê tl, è ðåçóëüòàò ñîåäèíèòü â ñïèñîê ñ hd.
Óïðàæíåíèå 2.5.4 Âû÷èñëèòå âûðàæåíèå append([1,2],[3]) âðó÷-
íóþ, ÷òîáû óáåäèòüñÿ â ïðàâèëüíîñòè îïðåäåëåíèÿ append.
Óïðàæíåíèå 2.5.5 ×òî äåëàåò ñëåäóþùàÿ ôóíêöèÿ:
fun r [] = [] | r (h :: t) = append (r(t), [h])
Òèïîì ôóíêöèè append ÿâëÿåòñÿ ïîëèìîðôíûé òèï, ò.å. òèï, ÷üå
îïðåäåëåíèå âêëþ÷àåò ïåðåìåííóþ òèïà 'a. Ïðè÷èíîé ýòîãî ÿâëÿåòñÿ
òî, ÷òî ôóíêöèÿ append ìîæåò áûòü ïðèìåíåíà ê ñïèñêàì ýëåìåíòîâ
ëþáîãî òèïà; åäèíñòâåííûì îãðàíè÷åíèåì ÿâëÿåòñÿ òî, ÷òî òèïû ýëå-
ìåíòîâ îáîèõ ñïèñêîâ-àðãóìåíòîâ äîëæíû ñîâïàäàòü (è ýòî îòðàæåíî â
ñòðóêòóðå òèïà ôóíêöèè append), append ÿâëÿåòñÿ ïðèìåðîì ïîëèìîðô-
íîé ôóíêöèè. Ðàññìîòðèì íåñêîëüêî ïðèìåðîâ ïðèìåíåíèÿ append:
- append ([], [1,2,3]);
> [1,2,3] : int list
- append ([1,2,3], [4,5,6]);
> [1,2,3,4,5,6]: int list
- append ([ "Bowl", "of" ], [ "soup" ]);
> ["Bowl","of","soup"]: string list

2.5. ÎÏÐÅÄÅËÅÍÈß ÔÓÍÊÖÈÉ
31
Îáðàòèòå âíèìàíèå íà òî, ÷òî ìû ïðèìåíèëè append è ê ñïèñêàì
òèïà int list, è ê ñïèñêàì òèïà string list.
Â îáùåì ñëó÷àå, ML ïðèñâàèâàåò âûðàæåíèþ íàèáîëåå îáùèé òèï
èç âîçìîæíûõ. Ïîä íàèáîëåå îáùèì òèïîì ïîíèìàåòñÿ òàêîé òèï, â
êîòîðîì îòðàæåíû âñå îãðàíè÷åíèÿ, âûòåêàþùèå èç âíóòðåííåé ñòðóê-
òóðû âûðàæåíèÿ, íî íå áîëåå òîãî. Íàïðèìåð, â îïðåäåëåíèè ôóíêöèè
append ïåðâûé àðãóìåíò ñîïîñòàâëÿåòñÿ ñ îáðàçöàìè nil è ::, èç ÷åãî
ñëåäóåò, ÷òî îí äîëæåí èìåòü ñïèñêîâûé òèï. Òèï âòîðîãî àðãóìåíòà
äîëæåí áûòü òàêæå ñïèñêîâûì òèïîì ñ òåì æå òèïîì ýëåìåíòîâ ñïèñêà,
ïîñêîëüêó â íåãî ìîãóò çàíîñèòüñÿ ýëåìåíòû èç ïåðâîãî ñïèñêà. Èç ýòèõ
äâóõ óñëîâèé ñëåäóåò, ÷òî òèï ðåçóëüòàòà äîëæåí ñîâïàäàòü ñ òèïîì îáî-
èõ àðãóìåíòîâ, è, òàêèì îáðàçîì, òèï ôóíêöèè append åñòü ('a list *
'a list) -> 'a list.
Âåðíåìñÿ ê ïðèâåäåííîìó âûøå ïðèìåðó ôóíêöèè f(x), êîòîðàÿ áû-
ëà îïðåäåëåíà êàê âûäàþùàÿ ðåçóëüòàò f(x). Ìû âèäèì, ÷òî åå òèï
åñòü 'a->'b: ïîñêîëüêó òåëî ôóíêöèè íå íàêëàäûâàåò íèêàêèõ îãðàíè-
÷åíèé íà àðãóìåíò, òèïîì àðãóìåíòà áóäåò 'a (÷òî îçíà÷àåò ïðîèçâîëü-
íûé òèï). Àíàëîãè÷íî íåò íèêàêèõ îãðàíè÷åíèé íà òèï ðåçóëüòàòà, è
ïîýòîìó îí åñòü 'b. Óáåäèòåñü, ÷òî íå ìîæåò âîçíèêíóòü íèêàêîé îøèá-
êè â ñîãëàñîâàíèè òèïîâ ïðè êàêîì óãîäíî èñïîëüçîâàíèè f, íåñìîòðÿ
íà òî, ÷òî f èìååò ñàìûé óíèâåðñàëüíûé òèï 'a>'b.
Ïðèâÿçêè ê ôóíêöèîíàëüíûì çíà÷åíèÿì ÿâëÿþòñÿ îäíîé èç ôîðì
îáúÿâëåíèÿ, àíàëîãè÷íîé ïðèâÿçêàì ê çíà÷åíèÿì, ðàññìîòðåííûì â ïðå-
äûäóùåì ðàçäåëå (ôàêòè÷åñêè ïðèâÿçêà ê ôóíêöèîíàëüíîìó çíà÷åíèþ
ÿâëÿåòñÿ ñïåöèàëüíîé ôîðìîé ïðèâÿçêè ê çíà÷åíèþ). Òàêèì îáðàçîì,
ê íàñòîÿùåìó ìîìåíòó ìû èìååì äâà ñïîñîáà ïîñòðîåíèÿ îáúÿâëåíèé:
ïðèâÿçêà ê çíà÷åíèþ è ïðèâÿçêà ê ôóíêöèîíàëüíîìó çíà÷åíèþ. Èç ýòî-
ãî, â ÷àñòíîñòè, ñëåäóåò, ÷òî ôóíêöèè ìîãóò áûòü îïðåäåëåíû âåçäå,
ãäå ìîæåò áûòü îïðåäåëåíî çíà÷åíèå; íàïðèìåð, âîçìîæíû ëîêàëüíûå
îáúÿâëåíèÿ ôóíêöèé. Íèæå ïðèâîäèòñÿ ïðèìåð ýôôåêòèâíîé ôóíêöèè
èíâåðòèðîâàíèÿ ñïèñêîâ:
- fun reverse lst =
let fun rev(nil, y) = ó
| rev(hd::tl, y) = rev(tl, hd::y)
in
rev(lst, nil)
end;
> val reverse = fn : 'a list -> 'a list
Ôóíêöèÿ rev ÿâëÿåòñÿ ëîêàëüíîé; îíà äîñòóïíà òîëüêî âíóòðè êîíñòðóê-

32
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
öèè let. Îáðàòèòå âíèìàíèå íà òî, ÷òî rev îïðåäåëåíà ðåêóðñèåé ïî ïåð-
âîìó àðãóìåíòó, a reverse ïðîñòî âûçûâàåò rev, è ïîýòîìó äëÿ reverse
íåò íåîáõîäèìîñòè àíàëèçèðîâàòü àðãóìåíò.
Â ïðåäåëàõ îáúÿâëåíèÿ ôóíêöèè ìîãóò èñïîëüçîâàòüñÿ íå òîëüêî åå
ïàðàìåòðû è ëîêàëüíûå ïåðåìåííûå, íî è ëþáûå ïåðåìåííûå, êîòîðûå
äîñòóïíû â òî÷êå îáúÿâëåíèÿ ôóíêöèè. Ðàññìîòðèì ñëåäóþùèé ïðèìåð:
- fun pairwith (õ, lst) =
let fun p y = (x, y)
in map ð lst end;
> val pairwith = fn : 'a * 'b list -> ('a * 'b) list
- val lst = [1,2,3];
> val lst = [1,2,3]: int list
- pairwith ("a", lst);
> [("a", 1), ("a", 2), ("a", 3)] : (string * int) list
Ëîêàëüíàÿ ôóíêöèÿ p èñïîëüçóåò íåëîêàëüíóþ (îòíîñèòåëüíî íåå) ïðè-
âÿçêó èäåíòèôèêàòîðà x  ïàðàìåòð ôóíêöèè pairwith. Çäåñü ïðèìå-
íÿåòñÿ îáû÷íîå ïðàâèëî: ïðè ññûëêå íà íåëîêàëüíûé èäåíòèôèêàòîð
èñïîëüçóåòñÿ íàèáîëåå áëèçêàÿ îáúåìëþùàÿ ïðèâÿçêà åãî ê çíà÷åíèþ.
Ýòî â òî÷íîñòè òî æå ïðàâèëî, ÷òî è èñïîëüçóåìîå â äðóãèõ ÿçûêàõ ñ
áëî÷íîé ñòðóêòóðîé, íàïðèìåð, â Pascal'e (íî îíî îòëè÷àåòñÿ îò ïðàâèë,
ïðèìåíÿåìûõ â áîëüøèíñòâå ðåàëèçàöèé LISP'a).
Óïðàæíåíèå 2.5.6 Ñîâåðøåííûì íàçûâàåòñÿ ÷èñëî, êîòîðîå ðàâíî
ñóììå âñåõ ñâîèõ äåëèòåëåé, âêëþ÷àÿ 1, íî èñêëþ÷àÿ ñàìî ÷èñëî; íà-
ïðèìåð, 6  ñîâåðøåííîå ÷èñëî, òàê êàê
6 = 1 + 2 + 3. Îïðåäåëèòå
ïðåäèêàò (ôóíêöèþ òèïà int->bool) isperfect, ïðîâåðÿþùèé, ÿâëÿ-
åòñÿ ëè åãî àðãóìåíò ñîâåðøåííûì ÷èñëîì.
Âûøå áûëî ïîä÷åðêíóòî, ÷òî ôóíêöèè â ML ÿâëÿþòñÿ ïîëíîïðàâíû-
ìè çíà÷åíèÿìè; îíè èìåþò òå æå ïðàâà è òå æå ïðèâèëåãèè, ÷òî è ëþáûå
äðóãèå çíà÷åíèÿ. Â ÷àñòíîñòè, ýòî îçíà÷àåò, ÷òî ôóíêöèè ìîãóò áûòü ïå-
ðåäàíû â êà÷åñòâå àðãóìåíòà äðóãèì ôóíêöèÿì è ìîãóò áûòü âûðàáîòà-
íû ôóíêöèÿìè â êà÷åñòâå ðåçóëüòàòà. Ôóíêöèè, êàêèå-ëèáî àðãóìåíòû
èëè ðåçóëüòàò êîòîðûõ ÿâëÿþòñÿ ôóíêöèÿìè, èíîãäà íàçûâàþò ôóíê-
öèÿìè âûñøèõ ïîðÿäêîâ. Ýòà òåðìèíîëîãèÿ ïîä÷åðêèâàåò, ÷òî ôóíêöèè
ÿâëÿþòñÿ ñóùåñòâåííî áîëåå ñëîæíûìè îáúåêòàìè  â îòëè÷èå, íàïðè-
ìåð, îò öåëûõ ÷èñåë (êîòîðûå íàçûâàþò îáúåêòàìè ïåðâîãî ïîðÿäêà).
Îäíàêî, îáðàùàåì âàøå âíèìàíèå íà òî, ÷òî â ML íåò íèêàêîé ïðèíöè-
ïèàëüíîé ðàçíèöû ìåæäó, íàïðèìåð, ôóíêöèÿìè, ïîëó÷àþùèìè â êà÷å-
ñòâå àðãóìåíòà ÷èñëî, è ôóíêöèÿìè, ïîëó÷àþùèìè â êà÷åñòâå àðãóìåíòà

2.5. ÎÏÐÅÄÅËÅÍÈß ÔÓÍÊÖÈÉ
33
äðóãóþ ôóíêöèþ; ïîýòîìó óïîìÿíóòàÿ òåðìèíîëîãèÿ ìîæåò óêàçûâàòü
ðàçâå ÷òî íà ñîäåðæàòåëüíûé ñïîñîá èñïîëüçîâàíèÿ ôóíêöèè.
Ðàññìîòðèì ñíà÷àëà ôóíêöèè, êîòîðûå âûðàáàòûâàþò ôóíêöèè â
êà÷åñòâå ðåçóëüòàòà. Ïóñòü f  òàêàÿ ôóíêöèÿ. ×òî òîãäà ìîæíî ñêà-
çàòü î åå òèïå? Ïóñòü îíà èìååò îäèí àðãóìåíò òèïà τ è âûðàáàòûâàåò
ðåçóëüòàò òèïà σ->ρ. Òîãäà òèï ôóíêöèè f åñòü τ->(σ->ρ). Ðåçóëüòàò
ïðèìåíåíèÿ ôóíêöèè f ê àðãóìåíòó òèïà τ åñòü ôóíêöèÿ òèïà σ->ρ, êî-
òîðàÿ ìîæåò áûòü ïðèìåíåíà ê àðãóìåíòó òèïà σ è âûðàáîòàòü ðåçóëüòàò
òèïà ρ. Òàêîå ïîñëåäîâàòåëüíîå ïðèìåíåíèå çàïèñûâàåòñÿ êàê f(e1)(e2),
èëè ïðîñòî fe1e2. Çàìåòüòå, ÷òî ýòî íå òî æå ñàìîå, ÷òî f(e1,e2)! (e1,e2)
åñòü îäèí îáúåêò  óïîðÿäî÷åííàÿ ïàðà, è f(e1,e2) îçíà÷àåò ïðèìåíèòü
ôóíêöèþ f ê óïîðÿäî÷åííîé ïàðå (e1,e2), â òî âðåìÿ êàê fe1e2 îçíà÷à-
åò ïðèìåíèòü f ê e1, ïîëó÷èòü ôóíêöèþ è ïðèìåíèòü åå ê e2. Òåïåðü
ñòàíîâèòñÿ ïîíÿòíûì, ïî÷åìó ðàíåå ïðè îáúÿñíåíèè ïîíÿòèÿ ïðèìåíå-
íèÿ ôóíêöèè ê àðãóìåíòó ìû ïîä÷åðêèâàëè, ÷òî ôóíêöèÿ âû÷èñëÿåòñÿ:
çäåñü ìû ïîëó÷èëè ïðèìåð òîãî, ÷òî ôóíêöèÿ çàäàíà íå èäåíòèôèêàòî-
ðîì, à ñëîæíûì âûðàæåíèåì.
Ïðèâåäåì íåñêîëüêî ïðèìåðîâ, ïðîÿñíÿþùèõ ñêàçàííîå:
- fun times (x:int) (y:int) = x*y;
> val times = fn : int->(int->int)
- val twice = times 2;
> val twice = fn: int->int
- twice 4;
> 8 : int
- times 3 4;
> 12: int
Ôóíêöèÿ times îïðåäåëåíà êàê ôóíêöèÿ, áåðóùàÿ â êà÷åñòâå àðãóìåíòà
öåëîå ÷èñëî è âûðàáàòûâàþùàÿ ôóíêöèþ, áåðóùóþ â êà÷åñòâå àðãóìåí-
òà öåëîå ÷èñëî è âûðàáàòûâàþùóþ öåëîå ÷èñëî9. Èäåíòèôèêàòîð twice
ïðèâÿçûâàåòñÿ ê çíà÷åíèþ times 2. Ïîñêîëüêó 2 èìååò òèï int, ôóíê-
öèÿ times ìîæåò áûòü ïðèìåíåíà ê 2, è ðåçóëüòàòîì áóäåò îáúåêò òèïà
int->int  êàê ýòî è âèäíî èç ñîîáùåíèÿ î òèïå twice. Òàê êàê twice
åñòü ôóíêöèÿ, îíà ìîæåò áûòü ïðèìåíåíà ê àðãóìåíòó  è â íàøåì
ïðèìåðå ðåçóëüòàò âû÷èñëåíèÿ twice 4 åñòü 8 (ðàçóìååòñÿ!). Íàêîíåö,
times ïðèìåíÿåòñÿ ê 3, è çàòåì ðåçóëüòàò ýòîãî ïðèìåíåíèÿ ïðèìåíÿåò-
ñÿ ê 4, â ðåçóëüòàòå ÷åãî ïîëó÷àåòñÿ 12. Â ýòîì ïîñëåäíåì âûðàæåíèè
ïîäðàçóìåâàåòñÿ ñëåäóþùàÿ ðàññòàíîâêà ñêîáîê: (times 3) 4.
9Íåîáõîäèìîñòü : int ïðè x è y áóäåò îáúÿñíåíà äàëåå â ðàçäåëå 2.6.

34
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
Ñòîëü æå ñâîáîäíî ìîãóò èñïîëüçîâàòüñÿ ôóíêöèè, ïîëó÷àþùèå äðó-
ãèå ôóíêöèè â êà÷åñòâå àðãóìåíòîâ. Òàêèå ôóíêöèè ÷àñòî íàçûâàþò
ôóíêöèîíàëàìè èëè îïåðàòîðàìè (íî, îïÿòü ïîä÷åðêèâàåì, â ML òàêàÿ
òåðìèíîëîãèÿ ìîæåò óêàçûâàòü òîëüêî íà ñîäåðæàòåëüíîå èñïîëüçîâà-
íèå ôóíêöèé, à íå íà êàêèå-òî îñîáûå èõ ÿçûêîâûå ñâîéñòâà). Êëàññè÷å-
ñêèì ïðèìåðîì ôóíêöèè òàêîãî ðîäà ÿâëÿåòñÿ ôóíêöèÿ map. Îíà ïîëó-
÷àåò â êà÷åñòâå àðãóìåíòîâ ôóíêöèþ è ñïèñîê, è âîçâðàùàåò â êà÷åñòâå
ðåçóëüòàòà ñïèñîê, ïîëó÷åííûé èç èñõîäíîãî ïðèìåíåíèåì ôóíêöèè-àð-
ãóìåíòà ê êàæäîìó åãî ýëåìåíòó. Òèï îáëàñòè îïðåäåëåíèÿ ôóíêöèè-àð-
ãóìåíòà äîëæåí ñîâïàäàòü ñ òèïîì ýëåìåíòîâ ñïèñêà, íî òèï åå îáëàñòè
çíà÷åíèé ïðîèçâîëåí. Âîò åå îïðåäåëåíèå íà ML:
- fun map f nil = nil
| map f (hd::tl) = f(hd) :: map f tl;
> val map = fn : ('a->'b) -> ('a list) -> ('b list)
Îáðàòèòå âíèìàíèå íà òî, ÷òî òèï map îòðàæàåò ñâÿçü ìåæäó òèïîì îá-
ëàñòè îïðåäåëåíèÿ ôóíêöèè-àðãóìåíòà è òèïîì ýëåìåíòîâ ñïèñêà-àðãó-
ìåíòà, à òàêæå ìåæäó òèïîì îáëàñòè çíà÷åíèé ôóíêöèè-àðãóìåíòà è
òèïîì ýëåìåíòîâ ñïèñêà-ðåçóëüòàòà.
Âîò íåñêîëüêî ïðèìåðîâ èñïîëüçîâàíèÿ ôóíêöèè map:
- val lst = [1,2,3,4,5];
> val lst = [1,2,3,4,5] : int list
- map twice lst;
> [2,4,6,8,10] : int list
- fun listify x = [x];
> val listify = fn : 'a -> 'a list
- map listify lst;
> [[1], [2], [3], [4], [5]] : int list list
Óïðàæíåíèå 2.5.7 Îïðåäåëèòå ôóíêöèþ powerset, êîòîðàÿ ïîëó÷à-
åò â êà÷åñòâå àðãóìåíòà ìíîæåñòâî (ïðåäñòàâëåííîå ñïèñêîì) è âîç-
âðàùàåò â êà÷åñòâå ðåçóëüòàòà ìíîæåñòâî âñåõ åãî ïîäìíîæåñòâ.
Ñî÷åòàÿ âîçìîæíîñòü ðàññìîòðåíèÿ ôóíêöèé êàê çíà÷åíèé è âîç-
ìîæíîñòü âîçâðàùàòü â êà÷åñòâå ðåçóëüòàòà ôóíêöèþ, ìû ìîæåì îïðå-
äåëèòü ôóíêöèþ, êîòîðàÿ ñòðîèò êîìïîçèöèþ äâóõ äðóãèõ ôóíêöèé:
- fun compose (f, g) (x) = f(g(x));
> val compose = fn : ('a->'b * 'c->'a) -> ('c->'b)
- val fourtimes = compose (twice, twice);

2.5. ÎÏÐÅÄÅËÅÍÈß ÔÓÍÊÖÈÉ
35
> val fourtimes = fn : int -> int
- fourtimes 5;
> 20 : int
Äàâàéòå ðàññìîòðèì ýòîò ïðèìåð âíèìàòåëüíî. Ôóíêöèÿ compose ïîëó-
÷àåò â êà÷åñòâå àðãóìåíòà ïàðó ôóíêöèé (f,g) è âîçâðàùàåò â êà÷åñòâå
ðåçóëüòàòà ôóíêöèþ; ýòà ôóíêöèÿ, áóäó÷è ïðèìåíåíà ê àðãóìåíòó x,
âîçâðàùàåò â êà÷åñòâå ðåçóëüòàòà f(g(x)). Ïîñêîëüêó ðåçóëüòàò åñòü
f(g(x)), òèï x äîëæåí áûòü òèïîì îáëàñòè îïðåäåëåíèÿ g; ïîñêîëüêó
f ïðèìåíÿåòñÿ ê g(õ), òèï îáëàñòè îïðåäåëåíèÿ f äîëæåí ñîâïàäàòü ñ
òèïîì îáëàñòè çíà÷åíèé g. Òàêèì îáðàçîì ìû ïîëó÷àåì òèï compose, êî-
òîðûé áûë ñîîáùåí ML-ñèñòåìîé. Ôóíêöèÿ fourtimes ïîëó÷àåòñÿ ïóòåì
ïðèìåíåíèÿ compose ê ïàðå ôóíêöèé (twice,twice). Ðåçóëüòàòîì áóäåò
ôóíêöèÿ, êîòîðàÿ, áóäó÷è ïðèìåíåíà ê x, âîçâðàòèò twice(twice(x)); â
íàøåì ñëó÷àå, êîãäà x åñòü 5, ðåçóëüòàòîì ÿâëÿåòñÿ 20.
Òåïåðü, êîãäà âû áëèæå ïîçíàêîìèëèñü ñ ôóíêöèÿìè â ML, âû ìî-
æåòå çàìåòèòü íà äàííîì ýòàïå îïðåäåëåííóþ àñèììåòðèþ ìåæäó ôóíê-
öèîíàëüíûìè çíà÷åíèÿìè è çíà÷åíèÿìè äðóãèõ òèïîâ: ó íàñ ïîêà íåò
íèêàêèõ ñïîñîáîâ çàïèñè âûðàæåíèé, âûðàáàòûâàþùèõ ôóíêöèè íåïî-
ñðåäñòâåííî; åäèíñòâåííûé ñïîñîá ïîëó÷åíèÿ ôóíêöèè  ýòî ïðèâÿçêà
èäåíòèôèêàòîðà ê ôóíêöèîíàëüíîìó çíà÷åíèþ. Íî ïî÷åìó äîëæíî òðå-
áîâàòüñÿ, ÷òîáû êàæäàÿ ôóíêöèÿ èìåëà èìÿ? Â îïðåäåëåííûõ ñëó÷à-
ÿõ ýòî óäîáíî, íî åñòü òàêæå ñèòóàöèè, â êîòîðûõ óäîáíî èñïîëüçîâàòü
áåçûìÿííûå ôóíêöèè, èëè ëÿìáäà-âûðàæåíèÿ (ïîñëåäíèé òåðìèí âîñ-
õîäèò ê LISP'y è λ-èñ÷èñëåíèþ). Òàêèå ñðåäñòâà èìåþòñÿ â ML, è íèæå
ïðèâîäÿòñÿ ïðèìåðû èõ èñïîëüçîâàíèÿ:
- fun listify x = [õ];
> val listify = fn : 'a -> 'a list
- val listify2 = fn x => [x];
> listify2 = fn : 'a -> 'a list
- listify 7;
> [7] : int list
- listify2 7;
> [7] : int list
- (fn x => [x]) (7);
> [7] : int list
- val lst = [1, 2, 3];
> val lst = [1, 2, 3] : int list
- map (fn x => [x], 1st );
> [[1], [2], [3]]: int list list

36
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
Ìû íà÷àëè ñ îïðåäåëåíèÿ î÷åíü ïðîñòîé ôóíêöèè listify, êîòîðàÿ ïðå-
îáðàçóåò àðãóìåíò â îäíîýëåìåíòíûé ñïèñîê. Ôóíêöèÿ listify2 ïîëíî-
ñòüþ ýêâèâàëåíòíà ôóíêöèè listify çà èñêëþ÷åíèåì ñïîñîáà åå îïðåäå-
ëåíèÿ. Ðåçóëüòàòîì âû÷èñëåíèÿ âûðàæåíèÿ fn õ => [õ] ÿâëÿåòñÿ ôóíê-
öèÿ, êîòîðàÿ ïðåîáðàçóåò àðãóìåíò x â ñïèñîê [x]  òî÷íî òàê æå, êàê
ýòî äåëàåò ôóíêöèÿ listify. Òàêîå âûðàæåíèå, âûðàáàòûâàþùåå ôóíê-
öèþ, ìû ìîæåì ïðèìåíÿòü ê àðãóìåíòó íåïîñðåäñòâåííî (êàê â ïðåä-
ïîñëåäíåì ñëó÷àå) èëè ïåðåäàòü â êà÷åñòâå àðãóìåíòà äðóãîé ôóíêöèè
(êàê â ïîñëåäíåì ñëó÷àå).
Òî÷íî òàê æå, êàê è ïðè èñïîëüçîâàíèè fun, ïðè èñïîëüçîâàíèè fn
ìîæíî ïðèìåíÿòü ñîïîñòàâëåíèå ñ îáðàçöîì:
- ( fn nil => nil | hd::tl => tl ) ([1,2,3]);
> [2,3] : int list
- (fn nil => nil | hd::tl=>tl)([]);
> nil : int list
Îïèñàíèå êàæäîãî ñëó÷àÿ çäåñü íàçûâàåòñÿ ïðàâèëîì, à òàêîé ñïîñîá
îïðåäåëåíèÿ ôóíêöèè  îïðåäåëåíèåì ñ ïîìîùüþ íàáîðà ïðàâèë.
Çàìåòèì, ÷òî áåçûìÿííàÿ ôóíêöèÿ íå ìîæåò áûòü ðåêóðñèâíîé, ïî-
ñêîëüêó íåò íèêàêîãî ñïîñîáà ñîñëàòüñÿ íà íåå â ïðîöåññå îïðåäåëåíèÿ.
Ýòî îäíà èç ïðè÷èí òîãî, ïî÷åìó ôóíêöèè â ML òåñíî ñâÿçàíû ñ îáúÿâ-
ëåíèÿìè: îäíà èç öåëåé ïðèâÿçêè ê ôóíêöèîíàëüíîìó çíà÷åíèþ ñîñòîèò
â òîì, ÷òîáû ââåñòè èìÿ ôóíêöèè ñ òåì, ÷òîáû ýòî èìÿ ìîãëî áûòü èñ-
ïîëüçîâàíî â îïðåäåëåíèè ôóíêöèè.
Óïðàæíåíèå 2.5.8 Ðàññìîòðèì ñëåäóþùóþ çàäà÷ó: ñêîëüêèìè ñïîñî-
áàìè ìîæíî ðàçìåíÿòü ñóììó â £1 ìîíåòàìè äîñòîèíñòâîì â 1, 2,
5, 10, 20 è 50 ïåíñîâ. Ïðåäïîëîæèì, ÷òî ìû ââåëè íåêîòîðûé ïîðÿäîê
íà ìíîæåñòâå äîñòîèíñòâ ìîíåò. Î÷åâèäíî, ÷òî òîãäà âûïîëíÿåòñÿ
ñëåäóþùåå ñîîòíîøåíèå:
Êîëè÷åñòâî ñïî-
ñîáîâ ðàçìåíÿòü
ñóììó a èñïîëü-
çóÿ n òèïîâ ìî-
íåò
=
Êîëè÷åñòâî ñïîñîáîâ
ðàçìåíÿòü ñóììó a,
èñïîëüçóÿ âñå òèïû
ìîíåò, êðîìå ïåðâî-
ãî
+
Êîëè÷åñòâî
ñïîñîáîâ
ðàçìåíÿòü ñóììó a−d,
èñïîëüçóÿ âñå n òèïîâ
ìîíåò
(ãäå
d
åñòü
äîñòîèíñòâî
ìîíåòû
ïåðâîãî òèïà)
Ýòî ñîîòíîøåíèå ìîæåò áûòü ïðåîáðàçîâàíî â ðåêóðñèâíîå îïðåäåëå-
íèå ôóíêöèè, åñëè äîáàâèòü ñëó÷àè, îïèñûâàþùèå çàâåðøåíèå ðåêóðñèè.
Èìåííî, åñëè a = 0, èìååòñÿ ðîâíî 1 ñïîñîá ðàçìåíà; åñëè a < 0 èëè
n = 0, ñïîñîáîâ ðàçìåíà íåò. Ýòè çàìå÷àíèÿ ïîçâîëÿþò çàïèñàòü ñëå-
äóþùåå îïðåäåëåíèå ôóíêöèè:

2.6. ÏÎËÈÌÎÐÔÈÇÌ È ÏÅÐÅÃÐÓÇÊÀ
37
fun first_denom 1 = 1
| first_denom 2 = 2
| first_denom 3 = 5
| first_denom 4 = 10
| first_denom 5 = 20
| first_denom 6 = 50;
fun cc(0,_) = 1
| cc(_,0) = 0
| cc(amount, kinds) =
if amount < 0 then 0
else cc( amount-(first_denom kinds), kinds)
+ cc( amount, (kinds-1));
fun count_change amount = cc(amount,6);
Èçìåíèòå ýòîò ïðèìåð òàê, ÷òîáû â íåì èñïîëüçîâàëñÿ ñïèñîê äîñòî-
èíñòâ ìîíåò (âìåñòî ôóíêöèè first_denom).
Óïðàæíåíèå 2.5.9 Ïðèâåäåííûé âûøå àëãîðèòì ïëîõ â òîì ñìûñëå,
÷òî â íåì âûïîëíÿåòñÿ ìíîãî èçëèøíèõ âû÷èñëåíèé. Ìîæåòå ëè âû
ïðåäëîæèòü áîëåå áûñòðûé àëãîðèòì? (Ýòî íåïðîñòàÿ çàäà÷à, è âû
ìîæåòå ïðîïóñòèòü åå ïðè ïåðâîì ÷òåíèè).
Óïðàæíåíèå 2.5.10 (Õàíîéñêèå áàøíè) Èìååòñÿ òðè ñòåðæíÿ (îáî-
çíà÷èì èõ A, B è C). Íà ñòåðæåíü A íàäåòî n äèñêîâ ðàçíîãî ðàçìåðà
òàê, ÷òî âíèçó íàõîäèòñÿ íàèáîëüøèé, íàä íèì  ÷óòü ìåíüøèé, è
ò.ä.; íàâåðõó íàõîäèòñÿ ñàìûé ìàëåíüêèé äèñê. Òðåáóåòñÿ ïåðåíåñòè
äèñêè ñî ñòåðæíÿ A íà ñòåðæåíü C ïî ñëåäóþùèì ïðàâèëàì: çà îäèí
õîä ìîæíî ïåðåëîæèòü ñ îäíîãî èç ñòåðæíåé âåðõíèé äèñê íà äðóãîé
ñòåðæåíü ïðè óñëîâèè, ÷òî ïåðåêëàäûâàåìûé äèñê ìåíüøå äèñêà, íà
êîòîðûé îí êëàäåòñÿ. Îïðåäåëèòå ôóíêöèþ, ðåøàþùóþ ýòó çàäà÷ó.
2.6
Ïîëèìîðôèçì è ïåðåãðóçêà
Èìååòñÿ îäíà òîíêàÿ, íî âàæíàÿ äåòàëü, êîòîðóþ íóæíî çíàòü äëÿ
ïîíèìàíèÿ ðåàëèçàöèè ïîëèìîðôèçìà â ML. Íàïîìíèì, ÷òî ïîëèìîðô-
íûì òèïîì ìû íàçûâàåì òèï, â êîòîðûé âõîäÿò ïåðåìåííûå òèïà (â
ïðîòèâîïîëîæíîñòü ìîíîìîðôíûì òèïàì, â êîòîðûå òàêèå ïåðåìåííûå
íå âõîäÿò). Â ïðåäûäóùåì ðàçäåëå ìû îïðåäåëèëè ïîëèìîðôíóþ ôóíê-
öèþ êàê ôóíêöèþ, ðàáîòàþùóþ ñ àðãóìåíòàìè ðàçëè÷íûõ òèïîâ (èç

38
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
íåêîòîðîãî êëàññà) åäèíîîáðàçíûì ñïîñîáîì. Êëþ÷åâàÿ èäåÿ ñîñòîèò â
òîì, ÷òî òàêóþ ôóíêöèþ íå èíòåðåñóþò òèïû çíà÷åíèé (èëè êîìïîíåíò
çíà÷åíèé); ïîýòîìó îíà ðàáîòàåò íåçàâèñèìî îò ýòèõ çíà÷åíèé, è, òàêèì
îáðàçîì, äîïóñêàåò ðàçëè÷íûå òèïû çíà÷åíèé. Íàïðèìåð, òèï ôóíêöèè
append åñòü 'a list * 'a list -> 'a list, ÷òî îòðàæàåò òîò ôàêò, ÷òî
ôóíêöèÿ append íå èíòåðåñóåòñÿ òèïîì ýëåìåíòîâ ñïèñêà; åäèíñòâåííîå,
÷òî òðåáóåòñÿ, ýòî ÷òîáû ýëåìåíòû îáîèõ ñïèñêîâ-àðãóìåíòîâ èìåëè îäè-
íàêîâûé òèï. Òèï ïîëèìîðôíîé ôóíêöèè âñåãäà åñòü ïîëèìîðôíûé òèï;
îí çàäàåò áåñêîíå÷íîå ñåìåéñòâî òèïîâ, ñîñòîÿùåå èç òèïîâ, ÿâëÿþùèõ
÷àñòíûìè ñëó÷àÿìè ïîëèìîðôíîãî òèïà (ò.å. ïîëó÷àåìûõ â ðåçóëüòà-
òå çàìåíû ïåðåìåííûõ òèïà íà êàêèå-ëèáî êîíêðåòíûå òèïû). Íàïðè-
ìåð, append ìîæåò ðàáîòàòü ñ àðãóìåíòàìè òèïà int list, bool list,
int*bool list è òàê äàëåå äî áåñêîíå÷íîñòè. Îáðàòèòå âíèìàíèå íà òî,
÷òî ïîëèìîðôèçì íå îãðàíè÷èâàåòñÿ ôóíêöèÿìè: ïóñòîé ñïèñîê nil ÿâ-
ëÿåòñÿ ñïèñêîì ýëåìåíòîâ ëþáîãî òèïà, è ïîýòîìó òèïîì nil ÿâëÿåòñÿ
'a list.
Ïîëèìîðôèçì îòëè÷àåòñÿ îò äðóãîãî ïîíÿòèÿ  ïåðåãðóçêè (õîòÿ,
íà ïåðâûé âçãëÿä, îíè ñõîæè). Ïåðåãðóçêà ñâÿçàíà ñî ñïîñîáîì çàïèñè,
à íå ñî ñïîñîáîì îïðåäåëåíèÿ ôóíêöèè. Ïðèìåðîì ïåðåãðóçêè ìîæåò
ñëóæèòü ôóíêöèÿ ñëîæåíèÿ, îáîçíà÷àåìàÿ +. Ìû çàïèñûâàåì ñëîæåíèå
öåëûõ ÷èñåë 2 è 3 êàê 2+3, à ñëîæåíèå äåéñòâèòåëüíûõ ÷èñåë 2.0 è 3.0
 êàê 2.0+3.0. Ýòî ìîæåò ïîêàçàòüñÿ ïîõîæèì íà ñëó÷àè ïðèìåíåíèÿ
ôóíêöèè append ê äâóì ñïèñêàì öåëûõ ÷èñåë è äâóì ñïèñêàì äåéñòâè-
òåëüíûõ ÷èñåë. Îäíàêî ñõîæåñòü çäåñü ëèøü ÷àñòè÷íàÿ: îäíà è òà æå
ôóíêöèÿ append ïðèìåíÿåòñÿ äëÿ ñîåäèíåíèÿ ñïèñêîâ ëþáîãî òèïà, íî
àëãîðèòì ñëîæåíèÿ öåëûõ ÷èñåë îòëè÷àåòñÿ îò àëãîðèòìà ñëîæåíèÿ
äåéñòâèòåëüíûõ ÷èñåë. (Åñëè âû çíàêîìû ñ îáû÷íûì ïðåäñòàâëåíèåì
÷èñåë â êîìïüþòåðå, ó âàñ ýòî íå âûçîâåò ñîìíåíèÿ). Òàêèì îáðàçîì,
îäèí è òîò æå ñèìâîë + èñïîëüçóåòñÿ äëÿ îáîçíà÷åíèÿ äâóõ ðàçëè÷íûõ
ôóíêöèé  à íå îäíîé ïîëèìîðôíîé ôóíêöèè. Â êàæäîì êîíêðåòíîì
ñëó÷àå âûáîð ôóíêöèè, êîòîðóþ ñëåäóåò èñïîëüçîâàòü, çàâèñèò îò òèïà
àðãóìåíòîâ.
Â ýòîì ïðè÷èíà òîãî, ÷òî íåëüçÿ ïðîñòî íàïèñàòü fun plus(x,y) =
x+y: êîìïèëÿòîð äîëæåí çíàòü òèïû x è y, ÷òîáû îïðåäåëèòü, êàêàÿ èç
äâóõ ôóíêöèé ñëîæåíèÿ äîëæíà áûòü èñïîëüçîâàíà  è ïîýòîìó îí íå
äîïóñêàåò òàêîãî îïðåäåëåíèÿ. Ñïîñîá ðåøåíèÿ ýòîé ïðîáëåìû ñîñòîèò
â ÿâíîì óêàçàíèè òèïà àðãóìåíòîâ ôóíêöèè plus; ýòî çàïèñûâàåòñÿ êàê
fun plus(x:int, y:int) = x+y. Èíòåðåñíûé ôàêò ñîñòîèò â òîì, ÷òî,
åñëè áû íå áûëî ïåðåãðóæåííûõ ôóíêöèé, òî íèêîãäà áû íå âîçíèêàëà

2.6. ÏÎËÈÌÎÐÔÈÇÌ È ÏÅÐÅÃÐÓÇÊÀ
39
íåîáõîäèìîñòü ÿâíî óêàçûâàòü òèïû10. Íî äëÿ òîãî, ÷òîáû îáåñïå÷èòü
âîçìîæíîñòü ïåðåãðóçêè, è äëÿ òîãî, ÷òîáû ïîâûñèòü íàäåæíîñòü ïðî-
ãðàììû, ML ïîçâîëÿåò âàì ÿâíî óêàçûâàòü òèï êîíñòðóêöèè ïóòåì ïðè-
ïèñûâàíèÿ ê íåìó òèïîâîãî âûðàæåíèÿ. Íèæå ìû ïðèâîäèì ïðèìåðû
èñïîëüçîâàíèÿ ÿâíîãî óêàçàíèÿ òèïà:
- fun plus(x,y) = õ+ó;
Unresolvable overloaded identifier: +
- fun plus(x:int,y:int) = x+y;
> val plus = fn : int*int -> int
- 3 : bool
Type clach in: 3 : bool
Looking for a: bool
I have found a: int
- (plus, true) : (int*int -> int) * bool
> (fn, true): (int*int -> int) * bool
- fun id ( x : 'a ) = x;
> val id = fn : 'a->'a
Çàìåòüòå, ÷òî â ïðîãðàììå ïåðåìåííûå òèïà çàïèñûâàþòñÿ òî÷íî òàê
æå, êàê èõ âûâîäèò ML: àïîñòðîô, çà êîòîðûì ñëåäóåò èäåíòèôèêàòîð.
Ðàâåíñòâî ÿâëÿåòñÿ èíòåðåñíûì ïðîìåæóòî÷íûì ñëó÷àåì. Ðàâåíñòâî
íå ÿâëÿåòñÿ ïîëèìîðôíîé ôóíêöèåé â òîì ñìûñëå, â êàêîì òàêîâîé ÿâ-
ëÿåòñÿ ôóíêöèÿ append; îäíàêî, â ïðîòèâîïîëîæíîñòü ñëîæåíèþ, ðàâåí-
ñòâî îïðåäåëåíî ïî÷òè äëÿ âñåõ òèïîâ. Êàê óïîìèíàëîñü âûøå, íå âñå
òèïû äîïóñêàþò ïðîâåðêó íà ðàâåíñòâî, îäíàêî äëÿ âñåõ òèïîâ, äîïóñ-
êàþùèõ ïðîâåðêó íà ðàâåíñòâî, ñóùåñòâóåò ôóíêöèÿ =, êîòîðàÿ âîçâðà-
ùàåò true èëè false â ñîîòâåòñòâèè ñ òåì, ðàâíû èëè íåò ñðàâíèâàåìûå
çíà÷åíèÿ. Ïîñêîëüêó ML ìîæåò ñàì îïðåäåëèòü, äîïóñêàåò òèï ïðîâåð-
êó íà ðàâåíñòâî èëè íåò, îí ïîçâîëÿåò èñïîëüçîâàòü ðàâåíñòâî êâàçèïî-
ëèìîðôíûì ïóòåì. Äëÿ ýòîãî ââîäèòñÿ íîâûé ñîðò ïåðåìåííûõ òèïà,
çàïèñûâàåìûõ êàê a, êîòîðûå ïðîáåãàþò ìíîæåñòâî âñåõ òèïîâ, äîïóñ-
êàþùèõ ïðîâåðêó íà ðàâåíñòâî. Äàëåå ML ñëåäèò çà òåì, òðåáóåòñÿ èëè
íåò, ÷òîáû êàêîé-ëèáî òèï äîïóñêàë ïðîâåðêó íà ðàâåíñòâî, è îòðàæàåò
ýòîò ôàêò â âûâåäåííûõ òèïàõ. Íàïðèìåð:
- fun member (x, nil) = false
| member (x, hd::tl) = if x=h then true else member(x,tl);
> val member = fn : ''a * ''a list -> bool
10Çà èñêëþ÷åíèåì ñëó÷àÿ èñïîëüçîâàíèÿ ÷àñòè÷íûõ îáðàçöîâ, êàê. íàïðèìåð, fun
f{x,...} = x.

40
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
Âõîæäåíèÿ a â òèï ôóíêöèè member óêàçûâàþò, ÷òî member ìîæåò ïðè-
ìåíÿòüñÿ òîëüêî ê àðãóìåíòàì, äîïóñêàþùèì ïðîâåðêó íà ðàâåíñòâî.
2.7
Îïðåäåëåíèÿ íîâûõ òèïîâ
ML îáëàäàåò ðàñøèðÿåìîé ñèñòåìîé òèïîâ. Èìååòñÿ òðè ôîðìû îáú-
ÿâëåíèÿ èäåíòèôèêàòîðà êàê íîâîãî êîíñòðóêòîðà òèïà.
Ïðîñòåéøåé ôîðìîé ÿâëÿåòñÿ ïðîçðà÷íàÿ ïðèâÿçêà ê òèïó, èëè ââå-
äåíèå ñîêðàùåííîãî íàèìåíîâàíèÿ òèïà. Êîíñòðóêòîð òèïà (âîçìîæíî,
ñ ïàðàìåòðàìè) îïðåäåëÿåòñÿ êàê ñîêðàùåíèå äëÿ íåêîòîðîãî (ñëîæíî-
ãî) òèïîâîãî âûðàæåíèÿ. Âñå èñïîëüçîâàíèÿ òàêîãî êîíñòðóêòîðà òèïà
ïîëíîñòüþ ýêâèâàëåíòíû èñïîëüçîâàíèþ âìåñòî íåãî èñõîäíîãî âûðàæå-
íèÿ.
- type intpair = int*int;
> type intpair = int*int
- fun f (x : intpair) = let val (l,r)=x in l end;
> val f = fn : intpair -> int
- f(3,2);
> 3 : int
- type 'a pair = 'a*'a;
> type 'a pair = 'a*'a
- type boolpair = bool pair;
> type boolpair = bool pair
Íåò íèêàêîé ðàçíèöû ìåæäó intpair è int*int, ïîñêîëüêó òèï intpair
îïðåäåëåí ðàâíûì òèïó int*int. Åäèíñòâåííàÿ ïðè÷èíà, ïî êîòîðîé ML
ïå÷àòàåò intpair â òèïå ôóíêöèè f  ýòî òî, ÷òî ýòîò òèï ÿâíî áûë
óêàçàí ïðè îáúÿâëåíèè ôóíêöèè.
Ñèñòåìà òèïîâ ML ìîæåò áûòü òàêæå ðàñøèðåíà ñ ïîìîùüþ ðåêóð-
ñèâíî îïðåäåëÿåìûõ òèïîâ (èëè, êîðî÷å, ðåêóðñèâíûõ òèïîâ)11. Â ýòîé
êîíñòðóêöèè óêàçûâàåòñÿ èìÿ íîâîãî òèïà (âîçìîæíî, ñ ïàðàìåòðàìè)
11Ýòîò ñïîñîá îïðåäåëåíèÿ íîâûõ òèïîâ ïðåäîñòàâëÿåò ìíîãîîáðàçíûå âîçìîæíî-
ñòè è ÿâëÿåòñÿ, ïîæàëóé, íàèáîëåå âàæíûì â ñèñòåìå òèïîâ ML (äà è äðóãèõ ôóíê-
öèîíàëüíûõ ÿçûêîâ). Íàçâàíèå ðåêóðñèâíûé îòðàæàåò ëèøü îäíó (õîòÿ è íàèáîëåå
ñóùåñòâåííóþ) ÷åðòó ýòîãî ñïîñîáà îïðåäåëåíèÿ òèïîâ. Ýòî íàçâàíèå íå ÿâëÿåòñÿ ïî-
âñåìåñòíî ïðèíÿòûì: òàê, íàïðèìåð, â Haskell'e èñïîëüçóåòñÿ òåðìèí àëãåáðàè÷åñêèé:
÷àùå æå âñåãî â àíãëîÿçû÷íîé ëèòåðàòóðå èñïîëüçóåòñÿ òåðìèí datatype (ïðîñòî êî-
ïèðóþùèé ââîäÿùåå îïðåäåëåíèå êëþ÷åâîå ñëîâî)  îäíàêî äîñëîâíûé ïåðåâîä ýòî-
ãî òåðìèíà (òèï äàííûõ) â ðóññêîì ÿçûêå íå îòðàæàåò îñîáåííîñòåé ýòîãî ïîíÿòèÿ.
(Ïðèì. ïåðåâ.)

2.7. ÎÏÐÅÄÅËÅÍÈß ÍÎÂÛÕ ÒÈÏÎÂ
41
è íàáîð êîíñòðóêòîðîâ çíà÷åíèé äëÿ ïîñòðîåíèÿ îáúåêòîâ ýòîãî òèïà. Â
ïðîñòåéøåì ñëó÷àå ðåêóðñèâíîå îáúÿâëåíèå òèïà âûãëÿäèò òàê:
- datatype color = Red | Blue | Yellow;
> type color
con Red : color
con Blue : color
con Yellow : color
- Red;
> Red : color
Ïðèâåäåííîå îáúÿâëåíèå ïðèâÿçûâàåò èäåíòèôèêàòîð color ê íîâîìó
òèïó äàííûõ, èìåþùåìó êîíñòðóêòîðû Red, Blue è Yellow12. Ýòîò ñëó-
÷àé ðåêóðñèâíîãî îáúÿâëåíèÿ íàïîìèíàåò ïåðå÷èñëèìûå òèïû â Pascal'e.
Îáðàòèòå âíèìàíèå íà òî, ÷òî ML âûâîäèò ñëîâî color áåç ïîñëåäó-
þùåãî çíàêà ðàâåíñòâà, ïîä÷åðêèâàÿ ýòèì, ÷òî color ÿâëÿåòñÿ íîâûì
òèïîì äàííûõ: îí íå ñîâïàäàåò íè ñ êàêèì ðàíåå îïðåäåëåííûì òèïîì
äàííûõ, è ïîýòîìó ðàâåíñòâî çäåñü áûëî áû íåóìåñòíûì. Êðîìå îáúÿâ-
ëåíèÿ íîâîãî òèïà, ïðèâåäåííàÿ âûøå êîíñòðóêöèÿ datatype îáúÿâëÿåò
òàêæå òðè íîâûõ êîíñòðóêòîðà çíà÷åíèé. Ýòè êîíñòðóêòîðû âûâîäÿò-
ñÿ ñ ïðåäøåñòâóþùèì êëþ÷åâûì ñëîâîì con (à íå val), ïîä÷åðêèâàÿ
òåì ñàìûì, ÷òî ýòî êîíñòðóêòîðû. Ââåäåííûå êîíñòðóêòîðû ìîãóò áûòü
èñïîëüçîâàíû äëÿ ïîñòðîåíèÿ îáðàçöîâ ïðè îïðåäåëåíèè ôóíêöèè ðàç-
áîðîì ñëó÷àåâ. Òàêèì îáðàçîì, ðåêóðñèâíîå îïðåäåëåíèå òèïà ÿâëÿåòñÿ
äîñòàòî÷íî ñëîæíûì: îíî îäíîâðåìåííî ââîäèò è íîâûé êîíñòðóêòîð
òèïà, è íîâûå êîíñòðóêòîðû çíà÷åíèé.
Ðåêóðñèâíûå îïðåäåëåíèÿ òèïîâ øèðîêî èñïîëüçóþòñÿ â ML. Íàïðè-
ìåð, ìîæíî ñ÷èòàòü, ÷òî âñòðîåííûé òèï bool îáúÿâëåí êàê:
- datatype bool = true | false;
> type bool
con true : bool
con false: bool
Ôóíêöèè, àðãóìåíòû êîòîðûõ èìåþò òèïû, ââåäåííûå ïîëüçîâàòåëåì,
ìîãóò áûòü îïðåäåëåíû ïóòåì ðàçáîðà ñëó÷àåâ òàê æå, êàê è â ñëó÷àå
èñõîäíûõ òèïîâ ÿçûêà. Ïðè ýòîì êîíñòðóêòîðû çíà÷åíèé ìîãóò áûòü
èñïîëüçîâàíû â îáðàçöàõ òî÷íî òàê æå, êàê ðàíåå ìû èñïîëüçîâàëè nil
è :: ïðè îïðåäåëåíèè ôóíêöèé, ðàáîòàþùèõ ñî ñïèñêàìè. Íàïðèìåð:
12Êîíñòðóêòîðû áåç àðãóìåíòîâ èíîãäà íàçûâàþò êîíñòàíòàìè.

42
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
-fun favorite Red = true
| favorite Blue = false
| favorite Yellow = false;
> val favorite = fn : color->bool
- val color = Red;
> val color = Red : color
- favorite color;
> true : bool
Ýòîò ïðèìåð òàêæå èëëþñòðèðóåò âîçìîæíîñòü èñïîëüçîâàíèÿ îäíî-
ãî è òîãî æå èäåíòèôèêàòîðà äëÿ íåñêîëüêèõ ðàçëè÷íûõ öåëåé. Èäåí-
òèôèêàòîð color èñïîëüçóåòñÿ è êàê èìÿ îïðåäåëåííîãî âûøå òèïà, è
êàê ïåðåìåííàÿ, ïðèâÿçàííàÿ ê Red. Òàêîå äâîéíîå èñïîëüçîâàíèå íå çà-
ïðåùåíî (õîòÿ è íå ðåêîìåíäóåòñÿ, ïîñêîëüêó ìîæåò ïðèâåñòè ê çàòåì-
íåíèþ ñìûñëà ïðîãðàììû), ïîñêîëüêó êîìïèëÿòîð âñåãäà ìîæåò ïîíÿòü
èç êîíòåêñòà, äîëæíî ëè â äàííîì ìåñòå íàõîäèòñÿ èìÿ òèïà èëè èìÿ
ïåðåìåííîé.
Îïðåäåëÿåìûå ïîëüçîâàòåëåì êîíñòðóêòîðû çíà÷åíèé ìîãóò èìåòü
àðãóìåíòû:
- datatype money = nomoney | coin of int | note of int |
check of string*int;
> type money
con nomoney : money
con coin : int->money
con note: int->money
con check: string*int->money
- fun amount(nomoney) = 0
| amount(coin(pence)) = pence
| amount(note(pounds)) = 100*pounds
| amount(check(bank,pence)) = pence;
> val amount = fn : money -> int
Òèï money èìååò ÷åòûðå êîíñòðóêòîðà, ïåðâûé èç êîòîðûõ ÿâëÿåòñÿ
êîíñòàíòîé, à òðè îñòàëüíûõ èìåþò àðãóìåíòû. Ôóíêöèÿ amount, îïðå-
äåëåííàÿ ðàçáîðîì ñëó÷àåâ ñ èñïîëüçîâàíèåì ýòèõ êîíñòðóêòîðîâ, âîç-
âðàùàåò ñóììó â ïåíñàõ, ïðåäñòàâëåííóþ îáúåêòîì òèïà money.
À ÷òî ìîæíî ñêàçàòü ïî ïîâîäó ðàâåíñòâà äëÿ îïðåäåëåííûõ ïîëü-
çîâàòåëåì ðåêóðñèâíûõ òèïîâ? Íàïîìíèì îïðåäåëåíèå ðàâåíñòâà äëÿ
ñïèñêîâ: äâà ñïèñêà ðàâíû òîãäà è òîëüêî òîãäà, êîãäà îíè ëèáî îáà åñòü
nil, ëèáî èìåþò ôîðìó h::t è h'::t' ñîîòâåòñòâåííî, è h ðàâíî h' è t

2.7. ÎÏÐÅÄÅËÅÍÈß ÍÎÂÛÕ ÒÈÏÎÂ
43
ðàâíî t'. Â îáùåì ñëó÷àå, äâà çíà÷åíèÿ íåêîòîðîãî ðåêóðñèâíîãî òèïà
ðàâíû, åñëè îíè ïîñòðîåíû îäíèì è òåì æå ñïîñîáîì (ò.å. íà âåðõíåì
óðîâíå èñïîëüçîâàíû îäèí è òîò æå êîíñòðóêòîð) è ñîîòâåòñòâóþùèå
êîìïîíåíòû ðàâíû ìåæäó ñîáîé. Êàê ñëåäñòâèå òàêîãî îïðåäåëåíèÿ ðà-
âåíñòâà, ìû ïîëó÷àåì, ÷òî îïðåäåëåííûé ïîëüçîâàòåëåì ðåêóðñèâíûé
òèï äàííûõ äîïóñêàåò ïðîâåðêó íà ðàâåíñòâî òîãäà è òîëüêî òîãäà, êîãäà
âñå àðãóìåíòû âñåõ êîíñòðóêòîðîâ çíà÷åíèé èìåþò òèïû, äîïóñêàþùèå
ïðîâåðêó íà ðàâåíñòâî. Â ðàññìîòðåííîì ïðèìåðå òèï money äîïóñêàåò
ïðîâåðêó íà ðàâåíñòâî, ïîñêîëüêó òèïû int è string äîïóñêàþò åå.
- nomoney = nomoney;
> true : bool
- nomoney = coin(5);
> false : bool
- coin(5) = coin(2+3);
> true : bool
- check("TSB",500) <> check("Clydesdale",500);
> true : bool
Â ðåêóðñèâíîì îïðåäåëåíèè òèïà äîïóñêàåòñÿ èñïîëüçîâàíèå ðåêóð-
ñèè13. Ïðåäïîëîæèì, ÷òî ìû õîòèì îïðåäåëèòü òèï äâîè÷íûõ äåðåâüåâ.
Äâîè÷íîå äåðåâî åñòü ëèáî ëèñò, ëèáî âåðøèíà, èìåþùàÿ äâà äâîè÷íûõ
äåðåâà â êà÷åñòâå ñûíîâåé. Â ñîîòâåòñòâèè ñ ýòèì çàïèñûâàåòñÿ òèï:
- datatype btree = empty | leaf | node of btree*btree;
> type btree
con empty: btree
con leaf: btree
con node : btree*btree->btree
- fun countleaves (empty) = 0
| countleaves (leaf) = 1
| countleaves (node(tree1,tree2)) =
countleaves(tree1) + countleaves(tree2);
> val countleaves = fn : btree->int
Îáðàòèòå âíèìàíèå íà òî, ÷òî ðåêóðñèâíîå îïðåäåëåíèå òèïà btree
ñëåäóåò
íåôîðìàëüíîìó
îïðåäåëåíèþ
äâîè÷íîãî
äåðåâà.
Ôóíêöèÿ
countleaves ÿâëÿåòñÿ ðåêóðñèâíîé ôóíêöèåé, îïðåäåëåííîé íà äâîè÷-
íûõ äåðåâüÿõ; îíà ïîäñ÷èòûâàåò êîëè÷åñòâî ëèñòüåâ äåðåâà. Âàæíî îò-
ìåòèòü, ÷òî ôóíêöèÿ, îïðåäåëåííàÿ íà ðåêóðñèâíûõ äàííûõ, ÿâëÿåòñÿ
13Â êîíöå êîíöîâ, íå çðÿ æå ìû åãî òàê íàçâàëè! (Ïðèì. ïåðåâ.)

44
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
ðåêóðñèâíîé14. Îïðåäåëåíèå ôóíêöèè append, ðàññìîòðåííîå ðàíåå, äå-
ìîíñòðèðóåò ýòîò ôàêò. Ýòî íå ñëó÷àéíî, ïîñêîëüêó ìîæíî ñ÷èòàòü, ÷òî
ïðåäîïðåäåëåííûé òèï τ list îáúÿâëåí ñëåäóþùèì îáðàçîì15:
- datatype 'a list = nil | :: of 'a * 'a list;
> type 'a list
con nil : 'a list
con :: : ('a * ('a list)) -> ('a list)
Ýòîò ïðèìåð èëëþñòðèðóåò çàîäíî èñïîëüçîâàíèå ïàðàìåòðîâ â îïðåäå-
ëåíèè òèïà: òèï list ïîëó÷àåò â êà÷åñòâå ïàðàìåòðà äðóãîé òèï, îïðåäå-
ëÿþùèé òèï ýëåìåíòîâ ñïèñêà. Ýòîò òèï ïðåäñòàâëåí ïåðåìåííîé òèïà
'a. Ìû èñïîëüçóåì òåðìèí êîíñòðóêòîð òèïà, ïîñêîëüêó list ñòðî-
èò íîâûé òèï èç äðóãîãî òèïà ïîäîáíî òîìó, êàê êîíñòðóêòîð çíà÷åíèÿ
ñòðîèò íîâîå çíà÷åíèå èç äðóãèõ çíà÷åíèé.
Ïðèâåäåì äðóãîé ïðèìåð ðåêóðñèâíîãî òèïà ñ ïàðàìåòðîì:
- datatype 'a tree = empty | leaf of 'a |
node of 'a tree * 'a tree;
> type 'a tree
con empty : 'a tree
con leaf: 'a -> 'a tree
con node : 'a tree * 'a tree -> 'a tree
- fun frontier( empty ) = []
| frontier( leaf(x) ) = [x]
| frontier ( node(t1,t2) ) =
append(frontier(tl), frontier(t2));
> val frontier = fn : 'a tree -> 'a list
- val tree = node(leaf("a"), node(leaf("b"), leaf("c")));
> val tree = node(leaf("a"), node (leaf("b"), leaf("c")))
: string tree
- frontier tree;
> ["a","b","c"] : string list
Ôóíêöèÿ frontier ïîëó÷àåò â êà÷åñòâå àðãóìåíòà äåðåâî è âîçâðàùàåò
ñïèñîê çíà÷åíèé, ïðèïèñàííûõ ëèñòüÿì äåðåâà-àðãóìåíòà.
14Ýòî íå ôîðìàëüíîå, à ñîäåðæàòåëüíîå óòâåðæäåíèå. Êîíå÷íî, ìû ìîæåì îïðå-
äåëèòü ôóíêöèþ ñ àðãóìåíòîì òèïà btree êàê fun f(empty) = 1 | f(leaf) = 2 |
f(node(_,_)) = 3, è çäåñü íåò íèêàêîé ðåêóðñèè. Îäíàêî âñå ñîäåðæàòåëüíî èíòå-
ðåñíûå ôóíêöèè, îïðåäåëåííûå íà ðåêóðñèâíûõ òèïàõ äàííûõ, çà ðåä÷àéøèì èñ-
êëþ÷åíèåì áóäóò ðåêóðñèâíûìè. (Ïðèì. ïåðåâ.)
15Â ýòîì ïðèìåðå ìû èãíîðèðóåì òîò ôàêò, ÷òî äëÿ êîíñòðóêòîðà :: èñïîëüçóåòñÿ
èíôèêñíàÿ ôîðìà çàïèñè: ýòî íå êàñàåòñÿ ñóòè ðàññìàòðèâàåìîãî âîïðîñà.

2.7. ÎÏÐÅÄÅËÅÍÈß ÍÎÂÛÕ ÒÈÏÎÂ
45
Óïðàæíåíèå 2.7.1 Îïðåäåëèòå ôóíêöèþ samefrontier(x,y), êîòî-
ðàÿ âîçâðàùàåò true, åñëè äåðåâüÿ x u y èìåþò îäíè è òå æå ëèñòüÿ è
â îäíîì è òîì æå ïîðÿäêå, íåçàâèñèìî îò âíóòðåííåé ñòðóêòóðû äåðå-
âà, è false â ïðîòèâíîì ñëó÷àå. Ïðàâèëüíîå, íî íåóäîâëåòâîðèòåëüíîå
ðåøåíèå áóäåò òàêèì:
fun samefrontier (õ, ó) = (frontier x) = (frontier ó)
Ýòî äîâîëüíî òðóäíîå óïðàæíåíèå; îñíîâíàÿ ïðîáëåìà ñîñòîèò â òîì,
÷òîáû èçáåæàòü ïîëíîé ðàçâåðòêè äåðåâà â ñëó÷àå, êîãäà ôóíêöèÿ äîë-
æíà âûäàòü false.
ML òàêæå îáåñïå÷èâàåò ìåõàíèçì îïðåäåëåíèÿ àáñòðàêòíûõ òè-
ïîâ16. Îíè ââîäÿòñÿ ñ ïîìîùüþ êîíñòðóêöèè abstype. Àáñòðàêòíûé òèï
äàííûõ ïðåäñòàâëÿåò ñîáîé íåêîòîðûé ðåêóðñèâíûé òèï äàííûõ è íà-
áîð ôóíêöèé äëÿ ðàáîòû ñ äàííûìè ýòîãî òèïà. Ðåêóðñèâíûé òèï äàí-
íûõ íàçûâàåòñÿ òèïîì ðåàëèçàöèè àáñòðàêòíîãî òèïà, à íàáîð ôóíêöèé
íàçûâàåòñÿ åãî èíòåðôåéñîì. Òèï, îïðåäåëåííûé ñ ïîìîùüþ êîíñòðóê-
öèè abstype, ÿâëÿåòñÿ àáñòðàêòíûì â òîì ñìûñëå, ÷òî êîíñòðóêòîðû
åãî òèïà ðåàëèçàöèè íåäîñòóïíû ïðîãðàììàì, èñïîëüçóþùèì ýòîò òèï:
äîñòóïíûì ÿâëÿåòñÿ òîëüêî èíòåðôåéñ. Ïîñêîëüêó ïðîãðàììà, èñïîëü-
çóþùàÿ àáñòðàêòíûé òèï äàííûõ, íè÷åãî íå çíàåò î åãî òèïå ðåàëèçà-
öèè, îíà ïîëüçóåòñÿ äëÿ ðàáîòû ñ äàííûìè àáñòðàêòíîãî òèïà òîëüêî
ôóíêöèÿìè èíòåðôåéñà. Ïîýòîìó ðåàëèçàöèÿ àáñòðàêòíîãî òèïà äàí-
íûõ ìîæåò áûòü èçìåíåíà â ëþáîé ìîìåíò, è ýòî íèêàê íå ñêàæåòñÿ
íà ïðîãðàììå, èñïîëüçóþùåé àáñòðàêòíûé òèï äàííûõ. Èñïîëüçîâàíèå
àáñòðàêòíûõ òèïîâ äàííûõ  âàæíûé ýëåìåíò ñòðóêòóðíîãî ïðîãðàì-
ìèðîâàíèÿ, ïîñêîëüêó îí ïîçâîëÿåò èçáåæàòü íåíóæíûõ ñâÿçåé ìåæäó
êîìïîíåíòàìè áîëüøîé ïðîãðàììû.
Ïðèâåäåì ïðèìåð îáúÿâëåíèÿ àáñòðàêòíîãî òèïà:
- abstype color = blend of int*int*int
with val white = blend(0,0,0)
and red = blend(15,0,0)
and blue = blend(0,15,0)
and yellow = blend(0,0,15)
fun mix (parts:int, blend(r,b,y),
parts':int, blend(x',y',z')) =
if parts<0 orelse parts'<0 then white
16Áîëåå ìîùíûì èíñòðóìåíòîì, îäíàêî, îêàçûâàþòñÿ ìîäóëè, ðàññìàòðèâàåìûå â
ñëåäóþùåé ãëàâå.

46
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
else let val tp = parts+parts'
and rp = (parts*r+parts'*r') div tp
and bp = (parts*b+parts'*b') div tp
and yp = (parts*y+parts'*y') div tp
in blend(rp,bp,yp) end;
end;
> type color
val white = - : color
val red = - : color
val blue = - : color
val yellow = - : color
val mix = fn : int*color*int*color->color
- val green = mix(2, yellow, 1, blue);
> val green = - : color
- val black = mix (1, red, 2, mix(1, blue, 1, yellow));
> val black = - : color
Ìû äîëæíû ñäåëàòü íåñêîëüêî çàìå÷àíèé îòíîñèòåëüíî ïðèâåäåííî-
ãî ïðèìåðà. Òî, ÷òî èäåò ïîñëå ñëîâà abstype, ÿâëÿåòñÿ ðåêóðñèâíûì
îïðåäåëåíèåì òèïà (è çäåñü èñïîëüçóåòñÿ òîò æå ñàìûé ñèíòàêñèñ). Ýòà
÷àñòü åñòü îïðåäåëåíèå òèïà ðåàëèçàöèè. Äàëåå èäåò îïèñàíèå èíòåð-
ôåéñà, çàêëþ÷åííîå â ñèíòàêñè÷åñêèå ñêîáêè with è end. Â âûäà÷å ML
ìû âèäèì, ÷òî ïîñëå ñëîâà color íåò çíàêà ðàâåíñòâà; ýòî îòðàæàåò òîò
ôàêò, ÷òî color  ýòî íîâûé òèï, íå ñîâïàäàþùèé íè ñ êàêèì äðóãèì. Íî
â îòëè÷èå îò ðåêóðñèâíîãî îïðåäåëåíèÿ òèïà, â ðåçóëüòàòå âûïîëíåíèÿ
abstype íå ñîçäàíî íèêàêèõ êîíñòðóêòîðîâ: ýòî äåëàåò íåâîçìîæíûì
ñîçäàíèå íîâûõ çíà÷åíèé òèïà color èíà÷å, êàê ïóòåì èñïîëüçîâàíèÿ
çíà÷åíèé è ôóíêöèé èíòåðôåéñà. Ýòî îáåñïå÷èâàåò âûñîêóþ ñòåïåíü
èçîëÿöèè ïðîãðàììû, èñïîëüçóþùåé àáñòðàêòíûé òèï äàííûõ, îò åãî
îïðåäåëåíèÿ. Çàìåòüòå òî, ÷òî ôóíêöèè, îïðåäåëåííûå âíóòðè with, âñå
æå èìåþò äîñòóï ê òèïó ðåàëèçàöèè è åãî êîíñòðóêòîðàì  èíà÷å áû
ýòîò òèï áûë áåñïîëåçíûì!
Îáðàòèòå âíèìàíèå íà òî, ÷òî âíåøíÿÿ ïðîãðàììà íå ìîæåò îïðå-
äåëÿòü ôóíêöèè ñ àðãóìåíòàìè àáñòðàêòíîãî òèïà ïóòåì ðàçëîæåíèÿ
àðãóìåíòà íà ñîñòàâíûå ÷àñòè (ñ ïîìîùüþ ñîïîñòàâëåíèÿ ñ îáðàçöîì).
Ýòî, â ÷àñòíîñòè, îçíà÷àåò, ÷òî àáñòðàêòíûé òèï íå äîïóñêàåò ïðîâåðêó
íà ðàâåíñòâî. Åñëè äëÿ àáñòðàêòíîãî òèïà äîëæíî áûòü ðàâåíñòâî, îíî
äîëæíî áûòü ÿâíî îïðåäåëåíî êàê îäíà èç èíòåðôåéñíûõ ôóíêöèé.
Èòàê, èìååòñÿ òðè ñïîñîáà îïðåäåëåíèÿ íîâûõ òèïîâ â ML. Ïðîçðà÷-
íûå îïðåäåëåíèÿ ïðåäíàçíà÷åíû äëÿ ñîêðàùåííîé çàïèñè ñëîæíûõ òè-

2.7. ÎÏÐÅÄÅËÅÍÈß ÍÎÂÛÕ ÒÈÏÎÂ
47
ïîâûõ âûðàæåíèé; èõ çàäà÷à  ïîâûñèòü ÷èòàáåëüíîñòü òåêñòà ïðîãðàì-
ìû, à íå ñîçäàíèå íîâûõ òèïîâ êàê òàêîâûõ. Ðåêóðñèâíûå òèïû îáåñïå-
÷èâàþò ðàñøèðåíèå ñèñòåìû òèïîâ ML. Îáúÿâëåíèå ðåêóðñèâíîãî òèïà
ââîäèò íîâûé êîíñòðóêòîð òèïà è íåêîòîðûé íàáîð êîíñòðóêòîðîâ çíà-
÷åíèé ýòîãî òèïà. Ðåêóðñèâíîå îïðåäåëåíèå òèïà ïîäõîäèò äëÿ ñëîæíûõ
ñòðóêòóð äàííûõ (êàê, íàïðèìåð, äåðåâüÿ), âíóòðåííÿÿ ñòðóêòóðà êî-
òîðûõ äîëæíà áûòü äîñòóïíà ïðîãðàììå. Åñëè æå âàæíûì ÿâëÿåòñÿ
òîëüêî ïîâåäåíèå çíà÷åíèé íîâîãî òèïà (êàê, íàïðèìåð, â ñëó÷àå ñòå-
êà èëè î÷åðåäè), áîëåå ïîäõîäÿùèì ÿâëÿåòñÿ îïðåäåëåíèå àáñòðàêòíîãî
òèïà, ñòðóêòóðà ðåàëèçàöèè êîòîðîãî íåâèäèìà äëÿ èñïîëüçóþùåé àá-
ñòðàêòíûé òèï ïðîãðàììû, è ìîæåò èñïîëüçîâàòüñÿ òîëüêî ôóíêöèÿìè,
îïðåäåëÿþùèìè ïîâåäåíèå äàííûõ.
Óïðàæíåíèå 2.7.2 Àáñòðàêòíûé òèï set ìîæåò áûòü îïðåäåëåí
êàê:
abstype 'a set = set of 'a list
with val emptyset: 'a set = ...
fun singleton(e: 'a ): 'a set = ...
fun union(s1: 'a set, s2: 'a set): 'a set = ...
fun member(e: 'a, s: 'a set) : bool = ...
| member(e, set(h::t)) = (e=h)
orelse member(e, set t)
fun intersection (s1: 'a set, s2: 'a set): 'a set = ...
end;
Çàâåðøèòå îïðåäåëåíèå ýòîãî àáñòðàêòíîãî òèïà äàííûõ.
Óïðàæíåíèå 2.7.3 Ìîäèôèöèðóéòå ñâîå ðåøåíèå òàê, ÷òîáû ýëåìåí-
òû ìíîæåñòâà õðàíèëèñü â âèäå óïîðÿäî÷åííîãî ñïèñêà. (Ïîäñêàçêà:
Îäèí èç ïóòåé ðåøåíèÿ ñîñòîèò â òîì, ÷òîáû ïåðåäàâàòü îòíîøåíèå
ïîðÿäêà (ò.å. ôóíêöèþ òèïà 'a*'a->bool â êà÷åñòâå äîïîëíèòåëüíî-
ãî ïàðàìåòðà êàæäîé ôóíêöèè. Äðóãîé ïóòü ñîñòîèò â òîì, ÷òîáû
îòíîøåíèå ïîðÿäêà ïåðåäàâàòü òîëüêî òåì ôóíêöèÿì, êîòîðûå ñòðî-
ÿò ìíîæåñòâà èç èñõîäíûõ ýëåìåíòîâ  ñ òåì, ÷òîáû îíè âñòàâëÿëè
åãî â ïðåäñòàâëåíèå ìíîæåñòâà. Òîãäà, íàïðèìåð, ôóíêöèÿ ïîñòðîåíèÿ
îáúåäèíåíèÿ ìîãëà áû èçâëå÷ü îòíîøåíèå ïîðÿäêà èç ñâîèõ àðãóìåíòîâ
è èñïîëüçîâàòü åãî äëÿ ïîñòðîåíèÿ ðåçóëüòàòà. Ìû âåðíåìñÿ ê ýòîé
ïðîáëåìå ïîçæå, êîãäà áóäåì â ñîñòîÿíèè ïðåäëîæèòü áîëåå ýëåãàíò-
íûé ìåõàíèçì ïàðàìåòðèçàöèè òàêîãî ñîðòà).

48
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
2.8
Èñêëþ÷åíèÿ
Ïðåäïîëîæèì, ÷òî ìû õîòèì íàïèñàòü ôóíêöèþ head, âûðàáàòû-
âàþùóþ ïåðâûé ýëåìåíò ñïèñêà-àðãóìåíòà. Ïåðâûé ýëåìåíò íåïóñòîãî
ñïèñêà ëåãêî ïîëó÷èòü ïóòåì ñîïîñòàâëåíèÿ ñ îáðàçöîì, íî ÷òî äîëæíà
âîçâðàùàòü head, åñëè åå àðãóìåíò åñòü nil? ßñíî, ÷òî ÷òî-òî íóæíî
ñäåëàòü,  âåäü head äîëæíà áûòü îïðåäåëåíà äëÿ âñåõ çíà÷åíèé àðãó-
ìåíòà, â òîì ÷èñëå è äëÿ nil,  íî ÷òî èìåííî íóæíî äåëàòü, íå î÷åíü
ïîíÿòíî. Âîçâðàùàòü êàêîå-ëèáî ñòàíäàðòíîå çíà÷åíèå íå î÷åíü õîðîøî
ïî äâóì ïðè÷èíàì: âî-ïåðâûõ, íåïîíÿòíî, êàêîå æå çíà÷åíèå âûáðàòü
ñòàíäàðòíûì, à, âî-âòîðûõ, ýòî îãðàíè÷èò îáëàñòü îïðåäåëåíèÿ ôóíê-
öèè: íàïðèìåð, åñëè ìû ïîëîæèì head(nil) ðàâíûì nil, òî ôóíêöèÿ
head áóäåò ïðèìåíèìà òîëüêî ê ñïèñêàì ñïèñêîâ).
Äëÿ òîãî, ÷òîáû ìîæíî áûëî îïèñàòü ðàçóìíîå ïîâåäåíèå ïðîãðàììû
â ïîäîáíûõ ñëó÷àÿõ, ML ïðåäëàãàåò ìåõàíèçì îáðàáîòêè èñêëþ÷èòåëü-
íûõ ñîáûòèé. Öåëüþ ýòîãî ìåõàíèçìà ÿâëÿåòñÿ ïðåäîñòàâëåíèå ôóíê-
öèè âîçìîæíîñòè çàâåðøèòü ðàáîòó èçÿùíûì è íå íàðóøàþùèì ïðàâè-
ëà ñîãëàñîâàíèÿ òèïîâ ñïîñîáîì â òåõ ñèòóàöèÿõ, êîãäà îíà íå ìîæåò èëè
íå õî÷åò âîçâðàòèòü ðåçóëüòàò. Íàïðèìåð, ôóíêöèþ head ìîæíî áûëî áû
çàïèñàòü ñëåäóþùèì ñïîñîáîì:
- exception Head;
> exception Head
- fun head(nil) = raise Head
| head(x::y) = x;
> val head = fn : 'a list -> 'a
- head [1,2,3];
> 1 : int
- head nil;
Failure:
Head
Ïåðâàÿ ñòðîêà ÿâëÿåòñÿ ïðèâÿçêîé ê èñêëþ÷åíèþ (èñêëþ÷èòåëüíîìó
çíà÷åíèþ): îíà îáúÿâëÿåò, ÷òî èäåíòèôèêàòîð Head ÿâëÿåòñÿ èìåíåì
èñêëþ÷åíèÿ. Ôóíêöèÿ head îïðåäåëÿåòñÿ îáû÷íûì ñïîñîáîì ïóòåì ðàç-
áîðà ñëó÷àåâ. Â ñëó÷àå íåïóñòîãî ñïèñêà çíà÷åíèå ôóíêöèè head åñòü
ïðîñòî ïåðâûé ýëåìåíò ñïèñêà. Íî â ñëó÷àå nil ôóíêöèÿ head íå â ñî-
ñòîÿíèè âåðíóòü êàêîå-ëèáî ðàçóìíîå çíà÷åíèå, ïîýòîìó îíà âîçáóæäà-
åò èñêëþ÷åíèå. Ðåçóëüòàò ýòîãî âèäåí â ñëåäóþùèõ çà îïðåäåëåíèåì
head ñòðîêàõ: â îòâåò íà ïðèìåíåíèå head ê nil âûâîäèòñÿ ñîîáùåíèå
Failure: Head, ïîêàçûâàþùåå, ÷òî âû÷èñëåíèå âûðàæåíèÿ head(nil)
ïðèâåëî ê òîìó, ÷òî áûëî âîçáóæäåíî èñêëþ÷åíèå Head. Íàïîìíèì, ÷òî

2.8. ÈÑÊËÞ×ÅÍÈß
49
ïîïûòêà äåëåíèÿ íà 0 ïðèâîäèò ê àíàëîãè÷íîìó ðåçóëüòàòó, è ýòî íå
ñëó÷àéíî: âî âñòðîåííîé ôóíêöèè div ïðè ïîïûòêå äåëåíèÿ íà 0 âîç-
áóæäàåòñÿ èñêëþ÷åíèå Div.
Ñ ïîìîùüþ êîíñòðóêöèé exception è raise ìû ìîæåì îïðåäåëÿòü
ôóíêöèè, êîòîðûå ñèãíàëèçèðóþò î âîçíèêíîâåíèè íåæåëàòåëüíûõ ñè-
òóàöèé ïóòåì âîçáóæäåíèÿ èñêëþ÷åíèé. Íî, ñ äðóãîé ñòîðîíû, íóæíû
åùå è êàêèå-òî ñðåäñòâà äëÿ îáðàáîòêè ýòèõ èñêëþ÷åíèé. Òàêàÿ âîçìîæ-
íîñòü, åñòåñòâåííî, åñòü â ML; ñîîòâåòñòâóþùàÿ êîíñòðóêöèÿ íàçûâàåò-
ñÿ îáðàáîò÷èêîì èñêëþ÷åíèé (èëè ïðîñòî îáðàáîò÷èêîì). Ìû ïðîèëëþ-
ñòðèðóåì åå èñïîëüçîâàíèå íà ñëåäóþùåì ïðîñòîì ïðèìåðå:
- fun head2 lst = head(lst) handle Head => 0;
> val head = fn : int list -> int
- head2([1,2,3]);
> 1 : int
- head2(nil);
> 0 : int
Âûðàæåíèå âèäà e handle exn => e′ âû÷èñëÿåòñÿ ñëåäóþùèì ñïîñîáîì:
ñíà÷àëà âû÷èñëÿåòñÿ e; åñëè ðåçóëüòàòîì ÿâëÿåòñÿ íåêîòîðîå çíà÷åíèå
v, òî çíà÷åíèåì âñåãî âûðàæåíèÿ ÿâëÿåòñÿ v; åñëè â ïðîöåññå âû÷èñëå-
íèÿ e âîçáóæäàåòñÿ èñêëþ÷åíèå exn, òî âû÷èñëÿåòñÿ âûðàæåíèå e′, è
åãî çíà÷åíèå áóäåò çíà÷åíèåì âñåãî âûðàæåíèÿ; åñëè æå âîçáóæäàåòñÿ
êàêîå-ëèáî äðóãîå èñêëþ÷åíèå, òî è âñå âûðàæåíèå âîçáóæäàåò ýòî èñ-
êëþ÷åíèå. Çàìåòüòå, ÷òî òèïû âûðàæåíèé e è e′ äîëæíû ñîâïàäàòü 
èíà÷å òèï âñåãî âûðàæåíèÿ çàâèñåë áû îò òîãî, âîçáóäèëîñü ëè â ïðî-
öåññå âû÷èñëåíèÿ e èñêëþ÷åíèå èëè íåò. Ýòèì îáúÿñíÿåòñÿ òî, ÷òî òèï
ôóíêöèè head2 åñòü int list -> int, õîòÿ èç àíàëèçà àðãóìåíòà lst
íèêàê íå ñëåäóåò, ÷òî ýòîò ñïèñîê ÿâëÿåòñÿ ñïèñêîì öåëûõ ÷èñåë. Â ïðè-
âåäåííîì âûøå ïðèìåðå head2 ïûòàåòñÿ ïðèìåíèòü head ê lst; åñëè ýòà
ïîïûòêà çàâåðøàåòñÿ óñïåøíî, ò.å. åñëè head âîçâðàùàåò çíà÷åíèå, òî
ýòî çíà÷åíèå è ñòàíîâèòñÿ çíà÷åíèåì head2; èíà÷å, ò.å. åñëè â ïðîöåññå
âû÷èñëåíèÿ head(lst) âîçáóæäàåòñÿ èñêëþ÷åíèå Head, â êà÷åñòâå ðå-
çóëüòàòà âîçâðàùàåòñÿ 0.
Åñëè ïðîöåññå âû÷èñëåíèÿ âûðàæåíèÿ ìîæåò áûòü âîçáóæäåíî íå-
ñêîëüêî ðàçëè÷íûõ èñêëþ÷åíèé, òî èõ ìîæíî ïåðåõâàòèòü ñ ïîìîùüþ
îäíîãî îáðàáîò÷èêà:
- exception Odd;
> exception Odd
- fun foo n = if n mod 2 <> 0 then

50
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
raise Odd
else 17 div n;
> val foo = fn : int -> int
- fun bar m = foo(m) handle Odd => 0
| Div => 9999;
> val bar = fn : int -> int
- foo 0;
Failure: Div
- bar 0;
> 9999 : int;
-foo 3;
Failure: Odd
- bar 3;
> 0 : int
- foo 20;
> 1 : int
- bar 20;
> 1 : int
Ïðè âû÷èñëåíèè ôóíêöèè foo ìîæåò ïðîèçîéòè äâà èñêëþ÷èòåëüíûõ
ñîáûòèÿ: äåëåíèå íà 0, â ðåçóëüòàòå ÷åãî âîçáóæäàåòñÿ èñêëþ÷åíèå Div,
èëè ïåðåäà÷à åé íå÷åòíîãî àðãóìåíòà, â ðåçóëüòàòå ÷åãî âîçáóæäàåòñÿ
èñêëþ÷åíà Odd. Ôóíêöèÿ bar îáðàáàòûâàåò îáà ýòèõ èñêëþ÷åíèÿ: åñëè
ïðè âû÷èñëåíèè foo(m) âîçáóæäàåòñÿ èñêëþ÷åíèå Odd, òî bar(m) âîç-
âðàùàåò 0; åñëè ïðè âû÷èñëåíèè foo(m) âîçáóæäàåòñÿ èñêëþ÷åíèå Div.
òî bar(m) âîçâðàùàåò 9999; â ïðîòèâíîì ñëó÷àå bar(m) âîçâðàùàåò çíà-
÷åíèå foo(m).
Îáðàòèòå âíèìàíèå íà òî, ÷òî ñèíòàêñèñ îáðàáîò÷èêà íåñêîëüêèõ èñ-
êëþ÷åíèé î÷åíü ïîõîæ íà ñèíòàêñèñ îïðåäåëåíèÿ áåçûìÿííîé ôóíêöèè
ñ ïîìîùüþ íàáîðà ïðàâèë. Äåéñòâèòåëüíî, ìîæíî ðàññìàòðèâàòü îáðà-
áîò÷èê èñêëþ÷åíèé êàê áåçûìÿííóþ ôóíêöèþ, òèï îáëàñòè îïðåäåëåíèÿ
êîòîðîé åñòü exn (òèï èñêëþ÷èòåëüíûõ çíà÷åíèé), à òèï îáëàñòè çíà÷å-
íèé êîòîðîé åñòü òèï âûðàæåíèÿ ñëåâà îò îáðàáîò÷èêà. Ñ òî÷êè çðåíèÿ
ïðîâåðêè ñîîòâåòñòâèÿ òèïîâ èäåíòèôèêàòîðû èñêëþ÷åíèé ñóòü íå ÷òî
èíîå, êàê êîíñòðóêòîðû èñêëþ÷èòåëüíûõ çíà÷åíèé òèïà exn  òî÷íî
òàê æå, êàê nil è :: ÿâëÿþòñÿ êîíñòðóêòîðàìè òèïà 'a list.
Áîëåå òîãî, èñêëþ÷åíèÿ ìîãóò ñîäåðæàòü âíóòðè ñåáÿ äðóãèå çíà÷å-
íèÿ  äëÿ ýòîãî äîñòàòî÷íî ïðîñòî îáúÿâèòü èõ ñ àðãóìåíòîì ïîäõî-
äÿùåãî òèïà. Ïðèñîåäèíåííîå ê èñêëþ÷åíèþ çíà÷åíèå ìîæåò áûòü èñ-
ïîëüçîâàíî îáðàáîò÷èêîì èñêëþ÷åíèé. Ñëåäóþùèé ïðèìåð èëëþñòðè-

2.8. ÈÑÊËÞ×ÅÍÈß
51
ðóåò ýòó âîçìîæíîñòü:
- exception oddlist of int list and oddstring of string;
> exception oddlist of int list
exception oddstring of string
- ... handle oddlist(nil) => 0
| oddlist(h::t) => 17
| oddstring("") => 0
| oddstring(s) => size(s)-1
Çäåñü îáúÿâëåíèå exception ââîäèò äâà èñêëþ÷åíèÿ: oddlist ñ àðãóìåí-
òîì òèïà int list, è oddstring ñ àðãóìåíòîì òèïà string. Îáðàáîò÷èê
âûïîëíÿåò ðàçáîð ñëó÷àåâ  ñíà÷àëà îïðåäåëÿåò, êàêîå èñêëþ÷åíèå áû-
ëî âîçáóæäåíî, à çàòåì àíàëèçèðóåò åãî àðãóìåíò. Â ýòîì îòíîøåíèè
îáðàáîò÷èê óñòðîåí òàê æå, êàê è îïðåäåëåíèå ôóíêöèè, çàäàííîé íàáî-
ðîì ïðàâèë.
×òî ïðîèçîéäåò, åñëè îáîçíà÷åííîå â ïðèìåðå âûøå ìíîãîòî÷èåì âû-
ðàæåíèå âîçáóäèò èñêëþ÷åíèå, îòëè÷íîå îò oddlist è oddstring? Çäåñü
àíàëîãèÿ ñ ôóíêöèÿìè çàêàí÷èâàåòñÿ: â ñëó÷àå ôóíêöèè, åñëè àðãóìåíò
íå îòîæäåñòâèòñÿ íè ñ îäíèì èç îáðàçöîâ, âîçáóæäàåòñÿ èñêëþ÷åíèå
Match; â ñëó÷àå æå îáðàáîò÷èêà èñêëþ÷åíèé, åñëè âñòðå÷àåòñÿ èñêëþ÷å-
íèå, íå ïðåäóñìîòðåííîå â îáðàáîò÷èêå, ýòî èñêëþ÷åíèå âîçáóæäàåòñÿ
ñíîâà  â íàäåæäå, ÷òî êàêîé-ëèáî îáúåìëþùèé îáðàáîò÷èê èñêëþ÷å-
íèé âñå æå îáðàáîòàåò åãî. Íàïðèìåð:
- exception Theirs and Mine;
> exception Theirs
exception Mine
- fun f(x) = if x=0 then raise Mine else raise Theirs;
> val f = fn : int -> 'a
- f(0) handle Mine => 7;
> 7 : int
- f(1) handle Mine => 7;
Failure: Theirs
- (f(1) handle Mine => 7) handle Theirs => 8;
> 8 : int
Ïîñêîëüêó èñêëþ÷åíèÿ â äåéñòâèòåëüíîñòè ÿâëÿþòñÿ çíà÷åíèÿìè òè-
ïà exn, àðãóìåíòîì êîíñòðóêöèè raise ìîæåò áûòü íå òîëüêî èäåíòèôè-
êàòîð, íî è ïðîèçâîëüíîå âûðàæåíèå (âûðàáàòûâàþùåå çíà÷åíèå òèïà
exn). Íàïðèìåð, ôóíêöèÿ f èç ïðèâåäåííîãî âûøå ïðèìåðà ìîæåò áûòü
çàïèñàíà êàê:

52
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
- fun f(x) = raise (if x=0 then Mine else Theirs);
> val f = fn : int -> 'a
Êàê è ïðè îïðåäåëåíèè ôóíêöèè, â îáðàçöå â îáðàáîò÷èêå èñêëþ÷åíèé
ìîãóò áûòü èñïîëüçîâàíû óíèâåðñàëüíûå îáðàçöû (èëè äæîêåðû), êîòî-
ðûå ìîãóò áûòü ñîïîñòàâëåíû ñ ëþáûì èñêëþ÷åíèåì. Íàïðèìåð, ñëåäó-
þùåå âûðàæåíèå ïåðåõâàòûâàåò ëþáûå èñêëþ÷åíèÿ, è, â ýòîì ñëó÷àå,
âûðàáàòûâàåò 0:
... handle _ => 0;
Îáúÿâëåíèå èñêëþ÷åíèÿ ÿâëÿåòñÿ îáû÷íûì îáúÿâëåíèåì, è ïîýòîìó
ìîæåò áûòü ëîêàëüíûì. Åñëè îáðàáîò÷èê ïåðåõâàòûâàåò íåêîòîðîå èñ-
êëþ÷åíèå, îí äîëæåí íàõîäèòüñÿ â îáëàñòè äåéñòâèÿ ñîîòâåòñòâóþùåãî
îáúÿâëåíèÿ. Íåïðàâèëüíûé ó÷åò ýòîãî îáñòîÿòåëüñòâà ìîæåò ïðèâåñòè
ê ñòðàííûì (íà ïåðâûé âçãëÿä) ñîîáùåíèÿì îá îøèáêàõ, êàê, íàïðèìåð:
- exception Åõñ;
> exception Åõñ
- (let exception Åõñ in raise Åõñ end) handle Åõñ => 0;
Failure:
Åõñ
Íåñìîòðÿ íà òî, ÷òî èäåíòèôèêàòîð Åõñ îáúÿâëåí íà âíåøíåì óðîâíå,
âíåøíèé îáðàáîò÷èê íå ìîæåò ðàñïîçíàòü èñêëþ÷åíèå, âîçíèêøåå âíóò-
ðè êîíñòðóêöèè let, ïîñêîëüêó îáëàñòü âèäèìîñòè ýòîãî èñêëþ÷åíèÿ,
ëåæèò âíóòðè êîíñòðóêöèè let. (Îäíàêî îáðàáîò÷èê ñ îáðàçöîì _ ñìîã
áû îáðàáîòàòü ýòî èñêëþ÷åíèå).
Óïðàæíåíèå 2.8.1 Îáúÿñíèòå, ÷òî íåïðàâèëüíîãî â ñëåäóþùèõ äâóõ
ïðîãðàììàõ:
1. exception Exn of bool;
fun f x =
let exception Exn of int
in if x> 100 then raise Exn x else x+1 end;
f(200) handle Exn true => 500 | Exn false => 1000;
2. fun f x =
let exception Exn in
if p x then a x else if q x
then f(b x) handle Exn => ñ x
else raise Exn
end;
f v;

2.9. ÈÌÏÅÐÀÒÈÂÍÛÅ ÂÎÇÌÎÆÍÎÑÒÈ ßÇÛÊÀ
53
Óïðàæíåíèå 2.8.2 Íàïèøèòå ïðîãðàììó, ðàçìåùàþùóþ n ôåðçåé íà
øàõìàòíîé äîñêå ðàçìåðîì n∗n òàê, ÷òî íè îäíà èç ôèãóð íå íàïàäàåò
íà äðóãóþ.
Óïðàæíåíèå 2.8.3 Ìîäèôèöèðóéòå
ïðåäûäóùóþ
ïðîãðàììó
òàê,
÷òîáû îíà âîçâðàùàëà âñå ðåøåíèÿ çàäà÷è.
2.9
Èìïåðàòèâíûå âîçìîæíîñòè ÿçûêà
ML ðàçðåøàåò èñïîëüçîâàòü ññûëêè è ïðèñâàèâàíèÿ. Ññûëêè ÿâëÿ-
þòñÿ óêàçàòåëÿìè â êó÷ó, äëÿ êîòîðûõ âûïîëíÿåòñÿ ïðîâåðêà ñîãëàñî-
âàíèÿ òèïîâ. Ïðèñâàèâàíèÿ ïîçâîëÿþò èçìåíÿòü çíà÷åíèå, íà êîòîðîå
óêàçûâàåò ññûëêà. Òèï τ ref ÿâëÿåòñÿ òèïîì ññûëîê íà çíà÷åíèÿ òèïà
τ 17. Ôóíêöèÿ ref òèïà 'a -> 'a ref âûäåëÿåò â êó÷å ìåñòî äëÿ àðãóìåí-
òà, êîïèðóåò òóäà àðãóìåíò è âîçâðàùàåò â êà÷åñòâå ðåçóëüòàòà ññûëêó
íà ýòî ìåñòî. Ôóíêöèÿ ! òèïà 'a ref -> 'à âûðàáàòûâàåò òî çíà÷åíèå,
íà êîòîðîå óêàçûâàåò ññûëêà. Ôóíêöèÿ := òèïà 'a ref * 'à -> unit
âûïîëíÿåò îïåðàöèþ ïðèñâàèâàíèÿ.
- val x = ref 0;
> val x = ref(O): int ref
- !x;
> 0 : int
- x := 3;
> (): unit;
- !x;
> 3 : int
Âñå ññûëî÷íûå òèïû äîïóñêàþò ïðîâåðêó íà ðàâåíñòâî. Îáúåêòû òè-
ïà τ ref ÿâëÿþòñÿ àäðåñàìè â êó÷å, è äâà òàêèõ îáúåêòà ðàâíû òîãäà è
òîëüêî òîãäà, êîãäà îíè ñîâïàäàþò. Çàìåòüòå, ÷òî õîòÿ ðàâíûå ññûëêè
çàâåäîìî óêàçûâàþò íà îäíî è òî æå çíà÷åíèå, îáðàòíîå íå âñåãäà âåðíî:
íà îäíî è òî æå çíà÷åíèå ìîãóò óêàçûâàòü è íåñêîëüêî íåðàâíûõ ññûëîê!
- val x = ref 0;
> val x = ref 0 : int ref
- val y = ref 0;
> val ó = ref 0 : int ref
17Â íàñòîÿùåå âðåìÿ τ ìîæåò áûòü òîëüêî ìîíîìîðôíûì òèïîì: îäíàêî ïðåäïîëà-
ãàåòñÿ â áóäóùåì âêëþ÷èòü â ÿçûê îäèí èç ðàññìàòðèâàåìûõ íûíå ñïîñîáîâ ðàáîòû
ñ ïîëèìîðôíûìè ññûëêàìè.

54
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ
- x = y
> false : bool
- !x = !y;
> true : bool
Ýòî ñîîòâåòñòâóåò ñèòóàöèè â ÿçûêàõ òèïà Pascal'ÿ, ãäå ìîæíî èìåòü
äâå ðàçëè÷íûå ïåðåìåííûå, ñîäåðæàùèå îäèíàêîâûå çíà÷åíèÿ (â äàííûé
ìîìåíò). Äëÿ òåõ, êòî çíàêîì ñ LISP'îì, çàìåòèì, ÷òî ðàâåíñòâî ññûëîê
â ML ñîîòâåòñòâóåò ôóíêöèè eq, à íå equal.
Âìåñòå ñî ññûëêàìè â ÿçûêå ïîÿâëÿþòñÿ îáû÷íûå äëÿ èìïåðàòèâ-
íîãî ÿçûêà êîíñòðóêöèè: êîìïîçèöèÿ ïîñëåäîâàòåëüíûõ óòâåðæäåíèé
è èòåðàòèâíîå âûïîëíåíèå. Â ML óòâåðæäåíèÿ ïðåäñòàâëÿþòñÿ âûðà-
æåíèÿìè òèïà unit (òèï èõ âûðàæàåò èäåþ òîãî, ÷òî ýòè âûðàæåíèÿ
âû÷èñëÿþòñÿ ðàäè èõ ïîáî÷íîãî ýôôåêòà, à íå ðàäè çíà÷åíèÿ âûðàæå-
íèÿ). Ñ ïîìîùüþ èíôèêñíîé îïåðàöèè ; îñóùåñòâëÿåòñÿ ïîñëåäîâà-
òåëüíîå âûïîëíåíèå óòâåðæäåíèé, à êîíñòðóêöèÿ while e do e′ îáåñïå-
÷èâàåò èòåðàòèâíîå âûïîëíåíèå.
Óïðàæíåíèå 2.9.1 Ñëåäóþùèé àáñòðàêòíûé òèï äàííûõ ìîæåò
áûòü èñïîëüçîâàí äëÿ ñîçäàíèÿ áåñêîíå÷íîãî ïîòîêà çíà÷åíèé:
abstype 'a stream = stream of unit -> ('a * 'a stream)
with fun next(stream f) = f()
val mkstream = stream
end;
Åñëè äàí íåêîòîðûé ïîòîê S, òî next S âîçâðàùàåò ïåðâîå çíà÷åíèå èç
S è ïîòîê, ñîñòîÿùèé èç îñòàëüíûõ çíà÷åíèé. Ýòî èëëþñòðèðóåòñÿ
ñëåäóþùèì ïðèìåðîì:
- fun natural n = mkstream(fn () => (n, natural(n+1)));
> val natural = fn : int -> int stream
- val s = natural 0;
> val s = - : int stream
- val (first, rest) = next s;
> val first = 0 : int
val rest = - : int stream
- val (next,_) = next rest;
> val next = 1 : int
Íàïèøèòå ôóíêöèþ, êîòîðàÿ âîçâðàùàåò áåñêîíå÷íûé ñïèñîê ïðîñòûõ
÷èñåë â âèäå ïîòîêà.

2.9. ÈÌÏÅÐÀÒÈÂÍÛÅ ÂÎÇÌÎÆÍÎÑÒÈ ßÇÛÊÀ
55
Óïðàæíåíèå 2.9.2 Ïðèâåäåííàÿ âûøå ðåàëèçàöèÿ ïîòîêà êàê àáñò-
ðàêòíîãî òèïà äàííûõ ìîæåò îêàçàòüñÿ êðàéíå íåýôôåêòèâíîé, åñëè
îäíè è òå æå ýëåìåíòû ïîòîêà èñïîëüçóþòñÿ ìíîãîêðàòíî. Ýòî ïðî-
èñõîäèò ïîòîìó, ÷òî ôóíêöèÿ next âû÷èñëÿåò î÷åðåäíîé ýëåìåíò ïî-
òîêà âñÿêèé ðàç, êîãäà îíà âûçûâàåòñÿ. Ïîâòîðíîå âû÷èñëåíèå áóäåò
áåñïîëåçíîé òðàòîé âðåìåíè äëÿ òàêèõ ïîòîêîâ, êàê, íàïðèìåð, ïðî-
ñòûå ÷èñëà, ãäå âîçâðàùàåìîå çíà÷åíèå áóäåò âñåãäà îäíèì è òåì æå.
Èçìåíèòå îáúÿâëåíèå òèïà Stream ñ èñïîëüçîâàíèå ññûëîê òàê, ÷òîáû
óñòðàíèòü ýòó íåýôôåêòèâíîñòü.
Óïðàæíåíèå 2.9.3 Èçìåíèòå îáúÿâëåíèå òèïà stream òàê, ÷òîáû îí
äîïóñêàë êàê êîíå÷íûå, òàê è áåñêîíå÷íûå ïîòîêè, èñïîëüçóÿ ïðåäèêàò
endofstream äëÿ îïðåäåëåíèÿ êîíöà ïîòîêà.

56
ÃËÀÂÀ 2. ßÄÐÎ ßÇÛÊÀ

Ãëàâà 3
Ìîäóëè
3.1
Îáçîð
Âîçìîæíîñòü ðàçëîæåíèÿ áîëüøîé ïðîãðàììû íà íåêîòîðîå êîëè÷å-
ñòâî îòíîñèòåëüíî íåçàâèñèìûõ ìîäóëåé ñ ÷åòêî îïðåäåëåííûì èíòåð-
ôåéñîì ÿâëÿåòñÿ êðàéíå âàæíîé ïðè ðàçðàáîòêå êðóïíûõ ïðîãðàììíûõ
ïðîäóêòîâ. Ìîäóëè â ML ïðåäíàçíà÷åíû äëÿ ðåøåíèÿ ýòîé ïðîáëåìû.
Ìíîãèå èç ñîâðåìåííûõ ÿçûêîâ ïðîãðàììèðîâàíèÿ îáëàäàþò ïîäîá-
íûìè ñâîéñòâàìè. Ê ñîæàëåíèþ, â ýòîé îáëàñòè íå ñëîæèëîñü åäèíîé
òåðìèíîëîãèè. Ïðîãðàììíûå êîìïîíåíòû íàçûâàþòñÿ ìîäóëÿìè, ïà-
êåòàìè, êëàñòåðàìè è ò.ä., è ò.ï. Â ML èñïîëüçóåòñÿ òåðìèí ñòðóêòó-
ðà, êàê ñîêðàùåíèå äëÿ ñòðóêòóðà ñðåäû. Òàêîé âûáîð òåðìèíîëîãèè
ãîâîðèò î òîì, ÷òî â ML ïðîãðàììíûé ìîäóëü åñòü èíñòðóìåíò ïîñòðî-
åíèÿ ñðåäû. Íàïîìíèì, ÷òî ñðåäà åñòü õðàíèëèùå èíôîðìàöèè î ñìûñ-
ëå èäåíòèôèêàòîðîâ, îáúÿâëåííûõ â ïðîãðàììå. Íàïðèìåð, â ðåçóëüòà-
òå âûïîëíåíèÿ îáúÿâëåíèÿ val x=3 â ñðåäå ïîÿâëÿåòñÿ çàïèñü î òîì,
÷òî èäåíòèôèêàòîð x ïðèâÿçàí ê çíà÷åíèþ 3 òèïà int. Òàêèì îáðàçîì,
ðàçáèåíèå ïðîãðàììû íà ìîäóëè â ML ïîíèìàåòñÿ êàê ðàçáèåíèå ñðå-
äû íà îòäåëüíûå ÷àñòè, êîòîðûìè ìîæíî ìàíèïóëèðîâàòü îòíîñèòåëüíî
íåçàâèñèìî äðóã îò äðóãà. Ìû ãîâîðèì îòíîñèòåëüíî, ïîñêîëüêó, åñëè
íåñêîëüêî ìîäóëåé îáúåäèíÿþòñÿ â îäíó ïðîãðàììó, îíè äîëæíû õîòü
êàê-òî âçàèìîäåéñòâîâàòü ìåæäó ñîáîé. Ñëåäîâàòåëüíî, äîëæíà áûòü
êàêàÿ-òî âîçìîæíîñòü îïèñàíèÿ è îðãàíèçàöèè ýòîãî âçàèìîäåéñòâèÿ.
Ýòî íàçûâàåòñÿ ïðîáëåìîé ñîèñïîëüçîâàíèÿ (sharing).
Òî, êàêîé íàáîð îïåðàöèé íàä ïðîãðàììíûì ìîäóëåì äîñòóïåí, è òî,
êàêèå åñòü ñðåäñòâà óïðàâëåíèÿ ñîèñïîëüçîâàíèåì, ÿâëÿþòñÿ îñíîâíûìè
õàðàêòåðèñòèêàìè ëþáîãî ìåõàíèçìà ðàçáèåíèÿ íà ìîäóëè. Ïî ìåíüøåé
57

58
ÃËÀÂÀ 3. ÌÎÄÓËÈ
ìåðå, äîëæíà áûòü âîçìîæíîñòü íåçàâèñèìîé êîìïèëÿöèè îòäåëüíîãî
ïðîãðàììíîãî ìîäóëÿ, âîçìîæíîñòü ñâÿçûâàíèÿ ñêîìïèëèðîâàííûõ ìî-
äóëåé â åäèíóþ ïðîãðàììó è âîçìîæíîñòü èçîëÿöèè îäíîãî ìîäóëÿ îò
äðóãîãî ñ öåëüþ èçáåæàòü íåæåëàòåëüíîé çàâèñèìîñòè ìåæäó ìîäóëÿ-
ìè, îñíîâàííîé íà ñëó÷àéíûõ ñâîéñòâàõ ìîäóëÿ  òàêèõ, êàê äåòàëè
âíóòðåííåé ðåàëèçàöèè. Ñîîòíîøåíèå è âçàèìîñâÿçü ìåæäó èçîëÿöèåé
(àáñòðàêöèåé) è ñîèñïîëüçîâàíèåì åñòü êëþ÷åâîé ìîìåíò, îïðåäåëÿþ-
ùèé ðåøåíèå äðóãèõ ïðîáëåì â ñèñòåìå ðàçäåëåíèÿ íà ìîäóëè.
Òî÷íî òàê æå, êàê òèï èäåíòèôèêàòîðà ÿâëÿåòñÿ ïîñðåäíèêîì, îïè-
ñûâàþùèì âîçìîæíîñòè èñïîëüçîâàíèÿ èäåíòèôèêàòîðà â ïðîãðàììå,
òàê è ñòðóêòóðà îáëàäàåò íåêîòîðîãî ðîäà òèïîì, íàçûâàåìûì ñèãíà-
òóðîé, êîòîðûé îïèñûâàåò òî, êàê âèäíà ñòðóêòóðà âî âíåøíåì ìèðå. Â
ëèòåðàòóðå òèï ïðîãðàììíîãî ìîäóëÿ èíîãäà íàçûâàåòñÿ èíòåðôåéñîì
èëè îïèñàíèåì ïàêåòà. Òåðìèíîëîãèÿ ML âîçíèêàåò èç àíàëîãèè ìåæ-
äó ñòðóêòóðîé ñðåäû è àëãåáðàè÷åñêîé ñòðóêòóðîé  à òèï ïîñëåäíåé
îáû÷íî íàçûâàåòñÿ ñèãíàòóðîé. Òî÷íî òàê æå, êàê òèï ÿâëÿåòñÿ êðàò-
êîé ñâîäêîé ñâîéñòâ îáúåêòà, èñïîëüçóåìûõ â ïåðèîä êîìïèëÿöèè, òàê è
ñèãíàòóðà ÿâëÿåòñÿ êðàòêîé ñâîäêîé ñâîéñòâ ñòðóêòóðû, èñïîëüçóåìûõ
â ïåðèîä êîìïèëÿöèè. Îäíàêî, â ïðîòèâîïîëîæíîñòü ÿäðó ÿçûêà, ÿâíîå
ïðèïèñûâàíèå ñèãíàòóðû êàêîé-ëèáî ñòðóêòóðå âëèÿåò íà åå ñâîéñòâà è
â ïåðèîä êîìïèëÿöèè, è â ïåðèîä èñïîëíåíèÿ, ïîñêîëüêó ñèãíàòóðà íà-
êëàäûâàåò îãðàíè÷åíèÿ íà âèäèìîñòü ñîäåðæèìîãî äàííîé ñòðóêòóðû.
Ôóíêòîðîì
íàçûâàåòñÿ ôóíêöèÿ, ïðåîáðàçóþùàÿ ñòðóêòóðû â
ñòðóêòóðû. Èäåÿ ôóíêòîðà ñîñòîèò â ñëåäóþùåì: åñëè êàêàÿ-ëèáî
ñòðóêòóðà S çàâèñèò îò ñòðóêòóðû T òîëüêî â òîé ÷àñòè, êîòîðàÿ îïè-
ñàíà â ñèãíàòóðå T, òî ñòðóêòóðà S ìîæåò áûòü èçîëèðîâàíà îò äåòàëåé
ðåàëèçàöèè ñòðóêòóðû T ïóòåì îïðåäåëåíèÿ íåêîòîðîé ôóíêöèè, êî-
òîðàÿ ïî ñòðóêòóðå T ñ çàäàííîé ñèãíàòóðîé âûðàáàòûâàåò ñòðóêòóðó
S, â êîòîðóþ âìîíòèðîâàíà ñòðóêòóðà T. Â ëèòåðàòóðå ýòî íàçûâàåò-
ñÿ ïàðàìåòðèçîâàííûìè ìîäóëÿìè èëè ãåíåðè÷åñêèìè ïàêåòàìè. Â
ML âûáðàí òåðìèí ôóíêòîð ïî òîé ïðè÷èíå, ÷òî îí, ñ îäíîé ñòîðî-
íû, áîëüøå ïîäõîäèò äëÿ ôóíêöèîíàëüíîãî ÿçûêà, à, ñ äðóãîé ñòîðîíû,
ïðèíÿò â ìàòåìàòè÷åñêîé òåðìèíîëîãèè, èñïîëüçóþùåé òåðìèíû ñòðóê-
òóðà è ñèãíàòóðà. Îáúÿâëåíèå ôóíêòîðà îïðåäåëÿåò èçîëèðîâàííóþ
ñòðóêòóðó S, à ïðèìåíåíèå ôóíêòîðà ê ñòðóêòóðå ñîîòâåòñòâóåò îïå-
ðàöèè ñâÿçûâàíèÿ ìîäóëåé â åäèíîå öåëîå. Ôóíêòîðû ÿâëÿþòñÿ òàêæå
îñíîâîé äëÿ ýëåãàíòíîãî ìåõàíèçìà ñîêðûòèÿ èíôîðìàöèè, íàçûâàåìîãî
àáñòðàêöèåé. Âî ìíîãèõ ñëó÷àÿõ àáñòðàêöèÿ ÿâëÿåòñÿ óäà÷íîé çàìåíîé
àáñòðàêòíûõ òèïîâ äàííûõ.
Ìû íà÷íåì íàøå ââåäåíèå â ìîäóëüíóþ ñòðóêòóðó ML ñ ðàññìîòðå-

3.2. ÑÒÐÓÊÒÓÐÛ È ÑÈÃÍÀÒÓÐÛ
59
íèÿ ñòðóêòóð è ñèãíàòóð.
3.2
Ñòðóêòóðû è ñèãíàòóðû
Ñòðóêòóðà åñòü íå ÷òî èíîå, êàê ìàòåðèàëèçîâàííàÿ ñðåäà, ïðåâðà-
ùåííàÿ â îáúåêò, êîòîðûì ìîæíî ìàíèïóëèðîâàòü. Îñíîâíûì ñðåäñòâîì
îïðåäåëåíèÿ ñòðóêòóð ÿâëÿþòñÿ èíêàïñóëèðîâàííûå îáúÿâëåíèÿ, ñîñòîÿ-
ùèå èç ïîñëåäîâàòåëüíîñòè îáúÿâëåíèé, çàêëþ÷åííûõ â ñèíòàêñè÷åñêèå
ñêîáêè struct è end. Âîò ïðîñòîé ïðèìåð èíêàïñóëèðîâàííîãî îáúÿâëå-
íèÿ:
struct
type t = int;
val x = 3;
fun f(x) = if x=0 then 1 else x*f(x-1)
end
Çíà÷åíèåì ýòîãî èíêàïñóëèðîâàííîãî îáúÿâëåíèÿ ÿâëÿåòñÿ ñòðóêòóðà,
â êîòîðîé èäåíòèôèêàòîð òèïà t ïðèâÿçàí ê òèïó int, à èäåíòèôèêà-
òîðû çíà÷åíèé x è f ïðèâÿçàíû ñîîòâåòñòâåííî ê ÷èñëó 3 è ê ôóíêöèè
âû÷èñëåíèÿ ôàêòîðèàëà. Õîòÿ ìû è ñêëîííû ðàññìàòðèâàòü ñòðóêòóðû
êàê íåêîòîðûé ñîðò çíà÷åíèé, èõ ñòàòóñ îòëè÷àåòñÿ îò ñòàòóñà îáû÷íûõ
çíà÷åíèé. Â ÷àñòíîñòè, èíêàïñóëèðîâàííîå îáúÿâëåíèå íåëüçÿ ïðîñòî
íàïèñàòü íà âåðõíåì óðîâíå äèàëîãà - êàê, íàïðèìåð, ìîæíî íàïèñàòü
àðèôìåòè÷åñêîå âûðàæåíèå. Îäíàêî ê íåìó ìîæíî ïðèâÿçàòü èäåíòè-
ôèêàòîð  íî è ýòà ôîðìà îáúÿâëåíèÿ, íàçûâàåìàÿ ïðèâÿçêîé ê ñòðóê-
òóðå, ìîæåò ïîÿâèòüñÿ òîëüêî ëèáî íà âåðõíåì óðîâíå äèàëîãà, ëèáî
âíóòðè èíêàïñóëèðîâàííîãî îáúÿâëåíèÿ. Íà âðåìÿ ìû îãðàíè÷èì íàøå
âíèìàíèå òîëüêî ïðèâÿçêàìè ê ñòðóêòóðàì íà âåðõíåì óðîâíå, à ïðèâÿç-
êè âíóòðè èíêàïñóëèðîâàííîãî îáúÿâëåíèÿ ðàññìîòðèì ïîçæå. Ê ïðèâå-
äåííîìó âûøå èíêàïñóëèðîâàííîìó îáúÿâëåíèþ ìîæåò áûòü ïðèâÿçàí
èäåíòèôèêàòîð ñëåäóþùèì ñïîñîáîì:
- structure S =
struct
type t = int;
val x = 3;
fun f(x) = if x=0 then 1 else x*f(x-1)
end;
> structure S =
struct

60
ÃËÀÂÀ 3. ÌÎÄÓËÈ
type t = int
val f = fn : int -> int
val x = 3 : int
end
Îáðàòèòå âíèìàíèå íà òî, ÷òî ðåçóëüòàò ïðèâÿçêè ê ñòðóêòóðå ÿâëÿåò-
ñÿ ñðåäîé1. ML ïå÷àòàåò ñðåäó, ïîëó÷àþùóþñÿ â ðåçóëüòàòå âûïîëíåíèÿ
îáúÿâëåíèé ìåæäó struct è end ïî÷òè â òîé æå ôîðìå, â êàêîé âûâîäÿò-
ñÿ ñîîáùåíèÿ ïîñëå îáúÿâëåíèé íà âåðõíåì óðîâíå. Êîíå÷íî, ñòðóêòóðà
çàäàåò íåçàâèñèìóþ ñðåäó â òîì ñìûñëå, ÷òî îáúÿâëåíèÿ, ïîÿâèâøèå-
ñÿ âíóòðè èíêàïñóëèðîâàííîãî îáúÿâëåíèÿ, íèêàê íå âëèÿþò íà äðóãèå
îáúÿâëåíèÿ, âûïîëíåííûå íà âåðõíåì óðîâíå. Òàê, íàïðèìåð, ïîñëå ïðè-
âåäåííîãî âûøå ïðèìåðà íè t, íè f íåäîñòóïíû íà âåðõíåì óðîâíå.
Îäíàêî ê èäåíòèôèêàòîðàì, îáúÿâëåííûì âíóòðè ñòðóêòóðû, ìîæåò
áûòü ïîëó÷åí äîñòóï ñ ïîìîùüþ ñîñòàâíûõ (qualied) èìåí. Ñîñòàâíîå
èìÿ ñîñòîèò èç ïóòè äîñòóïà ê ñòðóêòóðå, òî÷êè è ñàìîãî èäåíòèôè-
êàòîðà. Â íàñòîÿùèé ìîìåíò ïóòü äîñòóïà ê ñòðóêòóðå áóäåò ñîñòîÿòü
ïðîñòî èç èäåíòèôèêàòîðà ñòðóêòóðû; ïîçæå íàì ïðèäåòñÿ îáîáùèòü ïî-
íÿòèå ïóòè äî ïîñëåäîâàòåëüíîñòè èäåíòèôèêàòîðîâ ñòðóêòóð. Ìû ìî-
æåì èñïîëüçîâàòü êîìïîíåíòû ñòðóêòóðû S ñ ïîìîùüþ ñîñòàâíûõ èìåí
ñëåäóþùèì îáðàçîì:
- õ;
Type checking error in: x
Unbound value identifier: x
- S.x;
> 3 : int
- S.f(S.x);
> 6 : int
- S.x : S.t;
> 3 : S.t
Âûðàæåíèå S.x ÿâëÿåòñÿ ñîñòàâíûì èìåíåì, êîòîðîå ññûëàåòñÿ íà çíà-
÷åíèå, ê êîòîðîìó ïðèâÿçàí èäåíòèôèêàòîð õ â ñòðóêòóðå S. Çíà÷åíèå
âûðàæåíèÿ S.x, êàê âû è ìîæåòå ïðåäïîëîæèòü, åñòü 3. Àíàëîãè÷íî, S.f
îáîçíà÷àåò ôóíêöèþ f, îáúÿâëåííóþ â ñòðóêòóðå S (ôóíêöèþ âû÷èñëå-
íèÿ ôàêòîðèàëà). Êîãäà îíà ïðèìåíÿåòñÿ ê S.x (ò.å. ê 3), ðåçóëüòàòîì
áóäåò 6. Èñïîëüçîâàíèå èäåíòèôèêàòîðîâ, îáúÿâëåííûõ â S, íå îãðàíè-
1Ïî òåõíè÷åñêèì ïðè÷èíàì íåêîòîðûå ðåàëèçàöèè ML ïåðåóïîðÿäî÷èâàþò êîì-
ïîíåíòû ñðåäû ïåðåä âûâîäîì íà ýêðàí.

3.2. ÑÒÐÓÊÒÓÐÛ È ÑÈÃÍÀÒÓÐÛ
61
÷èâàåòñÿ çíà÷åíèÿìè: ïîñëåäíèé ïðèìåð ïîêàçûâàåò âîçìîæíîñòü èñ-
ïîëüçîâàíèÿ èäåíòèôèêàòîðà òèïà S.t, îáúÿâëåííîãî â S êàê int.
Åñëè â êàêîé-òî ÷àñòè ïðîãðàììû óïîìèíàþòñÿ íåñêîëüêî êîìïîíåíò
îäíîé è òîé æå ñòðóêòóðû, âûïèñûâàíèå ñîñòàâíûõ èìåí ïðåâðàùàåòñÿ
â óòîìèòåëüíîå çàíÿòèå. ×òîáû îáëåã÷èòü æèçíü â òàêèõ ñèòóàöèÿõ, ML
ïðåäîñòàâëÿåò âîçìîæíîñòü îòêðûòü ñòðóêòóðó ñ òåì, ÷òîáû ê îïðåäå-
ëåííûì âíóòðè íåå èäåíòèôèêàòîðàì ñòàë âîçìîæåí íåïîñðåäñòâåííûé
äîñòóï.
- let open S in f(x) end;
> 6 : int
- open S;
> val x = 3 : int
val f = fn : int -> int
type t = int
Â ïåðâîì ïðèìåðå ìû ëîêàëüíî îòêðûâàåì ñòðóêòóðó S âíóòðè âûðà-
æåíèÿ let, ÷òî ïîçâîëÿåò ïèñàòü f(x) âìåñòî ãðîìîçäêîãî S.f(S.x). Âî
âòîðîì ïðèìåðå ìû îòêðûâàåì ñòðóêòóðó S íà âåðõíåì óðîâíå, è òåì
ñàìûì äîáàâëÿåì ê ñðåäå âåðõíåãî óðîâíÿ íîâûå ïðèâÿçêè èäåíòèôèêà-
òîðîâ  êàê ýòî è âèäíî èç âûäà÷è ML.
×àñòî áûâàåò ïîëåçíî ðàññìàòðèâàòü ñòðóêòóðû êàê çíà÷åíèÿ íåêî-
òîðîãî îñîáîãî ðîäà, ïîñêîëüêó, âî-ïåðâûõ, ýòî ñîîòâåòñòâóåò ïðåäñòàâ-
ëåíèþ î ñðåäå êàê î íåêîòîðîì îáúåêòå, à, âî-âòîðûõ, èìååòñÿ íåêîòîðûé
íàáîð îïåðàöèé íàä ñòðóêòóðàìè. Â ÿäðå ÿçûêà êàæäîå çíà÷åíèå èìååò
òèï; àíàëîãè÷íî, ñòðóêòóðû òàêæå èìåþò òèïû: ýòî ñèãíàòóðû. Ñèãíà-
òóðû õàðàêòåðèçóþò ñòðóêòóðû âî ìíîãîì ïîäîáíî òîìó, êàê îáû÷íûå
òèïû õàðàêòåðèçóþò îáû÷íûå çíà÷åíèÿ, îïèñûâàÿ ñïîñîáû, êîòîðûìè
çíà÷åíèå ìîæåò áûòü èñïîëüçîâàíî â ïðîöåññå âû÷èñëåíèé. Õîòÿ, ñòðî-
ãî ãîâîðÿ, ñèãíàòóðû íå ÿâëÿþòñÿ òèïàìè, íî, òåì íå ìåíåå, àíàëîãèÿ
ìåæäó ñèãíàòóðàìè è òèïàìè äîëæíà ïîìî÷ü âàì ïîíÿòü, äëÿ ÷åãî íóæ-
íû ñèãíàòóðû.
Åñëè ìû ðàññìîòðèì âûäà÷ó ML â ïðèâåäåííûõ âûøå ïðèìåðàõ, òî
óâèäèì íåêîòîðûå ðàçëè÷èÿ ìåæäó âûäà÷åé â ñëó÷àå îáû÷íîé ïðèâÿç-
êè ê çíà÷åíèþ è â ñëó÷àå ïðèâÿçêè ê ñòðóêòóðå. À èìåííî, ïðè îáû÷-
íîé ïðèâÿçêå ê çíà÷åíèþ, ML â îòâåò ïå÷àòàåò è çíà÷åíèå, è åãî òèï.
Â ñëó÷àå æå ïðèâÿçêè ê ñòðóêòóðå ïå÷àòàåòñÿ òîëüêî çíà÷åíèå. Äàâàé-
òå ðàññìîòðèì, ÷òî áû ïðîèçîøëî, åñëè áû ML òâåðäî ïðèäåðæèâàëñÿ
ïðèíöèïîâ ðàáîòû ñ îáû÷íûìè çíà÷åíèÿìè è â ñëó÷àå ñòðóêòóðíûõ çíà-
÷åíèé:

62
ÃËÀÂÀ 3. ÌÎÄÓËÈ
- structure S =
struct
val x = 2+2;
val b = (x=4)
end;
> structure S =
struct
val x = 4
val b = true
end
:
sig
val x : int
val b : bool
end
Â ýòîì ïðè÷óäëèâîì ïðèìåðå èíôîðìàöèÿ î òèïàõ ïåðåìåííûõ ïîÿâ-
ëÿåòñÿ âíóòðè ñèãíàòóðû, â òî âðåìÿ êàê çíà÷åíèÿ ïîÿâëÿþòñÿ âíóòðè
ñòðóêòóðû. Ýòî ñîîòâåòñòâóåò íàøåìó èíòóèòèâíîìó ïîíèìàíèþ ñèãíà-
òóðû êàê õàðàêòåðèñòèêè çíà÷åíèÿ (èìåííî, ñòðóêòóðû). ßñíî, ÷òî åñ-
ëè áû ðåçóëüòàò ïðèâÿçêè ê òàêèì òîëñòûì îáúåêòàì êàê ñòðóêòóðû
ïå÷àòàëñÿ â òîì æå âèäå, êàê è ðåçóëüòàò ïðèâÿçêè ê îáû÷íûì çíà÷å-
íèÿì, ðåçóëüòàò ïå÷àòè ïîëó÷àëñÿ áû ñëèøêîì ãðîìîçäêèì, è ïîýòîìó
ML-ñèñòåìû ïå÷àòàþò ðåçóëüòàò ïðèâÿçêè ê ñòðóêòóðå êàê íåêîòîðóþ
ñìåñü èç ñòðóêòóðû è åå ñèãíàòóðû.
Âûðàæåíèå, çàêëþ÷åííîå â ñêîáêè sig è end â ïðèâåäåííîì âûøå
ïðèìåðå, íàçûâàåòñÿ ñèãíàòóðîé; åãî òåëî íàçûâàåòñÿ ñïåöèôèêàöèåé.
Ñïåöèôèêàöèÿ âî ìíîãîì ïîäîáíà îáúÿâëåíèþ, ñ òåì îòëè÷èåì, ÷òî îíà
òîëüêî îïèñûâàåò èäåíòèôèêàòîð, ñâÿçûâàÿ ñ íèì òèï, à íå ïðèäàåò
èäåíòèôèêàòîðó çíà÷åíèå (èç êîòîðîãî â ñëó÷àå îáû÷íîãî îáúÿâëåíèÿ
âûâîäèòñÿ òèï). Ïîêà ÷òî ìû ðàññìîòðåëè òîëüêî val-ñïåöèôèêàöèè;
ïîçäíåå ìû ðàññìîòðèì è äðóãèå. Â ïðèâåäåííîì âûøå ïðèìåðå óêàçû-
âàåòñÿ, ÷òî õ èìååò òèï int, a b èìååò òèï bool.
Ñèãíàòóðû íå òîëüêî âûâîäÿòñÿ ML-êîìïèëÿòîðîì. Îíè èãðàþò
âàæíóþ ðîëü â èñïîëüçîâàíèè ìîäóëüíîé ñèñòåìû, â ÷àñòíîñòè, ïðè îáú-
ÿâëåíèè ôóíêòîðîâ, è ïîýòîìó îíè ÷àñòî ïèøóòñÿ ïîëüçîâàòåëåì. Èäåí-
òèôèêàòîð ìîæåò áûòü ïðèâÿçàí ê ñèãíàòóðå ïóòåì ïðèâÿçêè ê ñèãíà-
òóðå  ïîäîáíî ïðèâÿçêå ê òèïó. Ïðèâÿçêà ê ñèãíàòóðå îáîçíà÷àåòñÿ
êëþ÷åâûì ñëîâîì signature, è ìîæåò ïîÿâëÿòüñÿ òîëüêî íà âåðõíåì
óðîâíå.

3.2. ÑÒÐÓÊÒÓÐÛ È ÑÈÃÍÀÒÓÐÛ
63
- signature SIG =
sig
val x : int
val b : bool
end;
> signature SIG =
sig
val x : int
val b : bool
end
Ïîñêîëüêó èíôîðìàöèÿ âûäàâàåìàÿ ML â îòâåò íà îáúÿâëåíèå ñèãíàòó-
ðû íå ñîäåðæèò íè÷åãî èíòåðåñíîãî, â ïîñëåäóþùèõ ïðèìåðàõ îíà áóäåò
îïóñêàòüñÿ.
Îñíîâíàÿ ïîëüçà ñèãíàòóð çàêëþ÷àåòñÿ â òîì, ÷òî ñòðóêòóðû ìîãóò
ñîïîñòàâëÿòüñÿ ñ ñèãíàòóðàìè. Ñòðóêòóðà íàçûâàåòñÿ ñîïîñòàâèìîé ñ
ñèãíàòóðîé, åñëè, ãðóáî ãîâîðÿ, ñòðóêòóðà ñîîòâåòñòâóåò ñïåöèôèêàöè-
ÿì ñèãíàòóðû. Ïîñêîëüêó ñïåöèôèêàöèè ïîäîáíû òèïàì, èäåÿ ñîïîñòàâ-
ëåíèÿ ñ ñèãíàòóðîé áëèçêà ïðîâåðêå ñîîòâåòñòâèÿ òèïîâ â ÿäðå ÿçûêà,
õîòÿ íåêîòîðûå äåòàëè çäåñü äîâîëüíî ñëîæíû. Îäèí èç ñïîñîáîâ èñ-
ïîëüçîâàíèÿ ñèãíàòóðû ñîñòîèò â óêàçàíèè åå ïîñëå èìåíè ñòðóêòóðû
ïðè ïðèâÿçêå èäåíòèôèêàòîðà ê ñòðóêòóðå (÷òî î÷åíü ïîõîæå íà óêàçà-
íèå òèïà ïðè ïðèâÿçêå èäåíòèôèêàòîðà ê îáû÷íîìó çíà÷åíèþ) ñ öåëüþ
îáåñïå÷åíèÿ äîïîëíèòåëüíîé ïðîâåðêè â ïåðèîä êîìïèëÿöèè:
- structure S : SIG =
struct
val x = 2+1
val b = (x=7)
end;
> structure S =
struct
val x = 3 : int
val b = false : bool
end
:SIG ïîêàçûâàåò, ÷òî èíêàïñóëèðîâàííîå îáúÿâëåíèå ñïðàâà îò çíàêà
ðàâåíñòâà äîëæíî áûòü ñîïîñòàâèìî ñ ñèãíàòóðîé SIG.
Ïîñêîëüêó, ïî ìíåíèþ ML, ïðèâåäåííîå âûøå îáúÿâëåíèå ÿâëÿåòñÿ
ïðèåìëåìûì, óêàçàííàÿ ñòðóêòóðà ñîïîñòàâèìà ñ óêàçàííîé ñèãíàòóðîé.

64
ÃËÀÂÀ 3. ÌÎÄÓËÈ
Ïî÷åìó ýòî òàê? Äàííàÿ ñòðóêòóðà ñîïîñòàâèìà ñ ñèãíàòóðîé SIG, ïî-
ñêîëüêó:
1. S.x ïðèâÿçàí ê 3, ÷òî èìååò òèï int, êàê è òðåáóåò ñèãíàòóðà SIG.
2. S.b ïðèâÿçàí ê false, ÷òî èìååò òèï bool, êàê è òðåáóåò ñèãíàòóðà
SIG.
Êîðî÷å ãîâîðÿ, åñëè â ñèãíàòóðå äëÿ ïåðåìåííîé x óêàçàí òèï τ, òî â
ñòðóêòóðå èäåíòèôèêàòîð x äîëæåí ïðèâÿçûâàòüñÿ ê çíà÷åíèþ òèïà τ.
Ñèãíàòóðà ìîæåò îïèñûâàòü ìåíüøå èäåíòèôèêàòîðîâ, ÷åì èõ ïðåä-
ñòàâëåíî â ñòðóêòóðå. Íàïðèìåð:
- structure S : SIG =
struct
val x = 2+1
val b = (x=7)
val s = "Garbage"
end;
> structure S =
struct
val x = 3 : int
val b = false : bool
end
Çäåñü â ñòðóêòóðå S îáúÿâëÿþòñÿ ïåðåìåííûå x, b è s, â òî âðåìÿ êàê ñèã-
íàòóðà SIG îïèñûâàåò òîëüêî ïåðåìåííûå x è b. Â ðåçóëüòàòå íå òîëüêî
òèï ïåðåìåííîé s ÿâëÿåòñÿ íåñóùåñòâåííûì, íî è âñÿ ïåðåìåííàÿ óäàëÿ-
åòñÿ èç ñòðóêòóðû â ïðîöåññå ñîïîñòàâëåíèÿ ñ ñèãíàòóðîé. Ñìûñë ýòîãî
ñîñòîèò â òîì, ÷òî ñèãíàòóðà SIG îïðåäåëÿåò ïðîåêöèþ (view) ñòðóêòó-
ðû, ò.å. òî, ÷òî äîëæíî áûòü âèäíî â ñòðóêòóðå; èìåííî, îíà ãîâîðèò, ÷òî
äîëæíû áûòü âèäíû òîëüêî ïåðåìåííûå x è b. Äðóãèå ñèãíàòóðû ìîãóò
áûòü èñïîëüçîâàíû äëÿ ïîëó÷åíèÿ äðóãèõ ïðîåêöèé òîé æå ñòðóêòóðû.
Íàïðèìåð:
- structure S =
struct
val x = 2+1
val b = false
val s = "String"
end;
> structure S =

3.2. ÑÒÐÓÊÒÓÐÛ È ÑÈÃÍÀÒÓÐÛ
65
struct
val x = 3 : int
val b = false : bool
val s = "String": string
end
- signature SIG' =
sig
val x : int
val b : bool
end
and SIG" =
sig
val b : bool
val s : string
end;
- structure S': SIG' = S and S'' : SIG'' = S; >
> structure S' =
struct
val x = 3 : int
val b = false : bool
end
structure S'' =
struct
val b = false : bool
val s = "String": string
end
Óïðàæíåíèå 3.2.1 Ñèãíàòóðà äëÿ ñòðóêòóð, êîòîðûå ñîäåðæàò ïðå-
äèêàò óïîðÿäî÷åíèÿ äëÿ íåêîòîðîãî òèïà, ìîæåò áûòü çàïèñàíà òàê:
signature ORD =
sig
type t
val le : t*t -> bool
end
Ñîçäàéòå ñîïîñòàâèìûå ñ ýòîé ñèãíàòóðîé ñòðóêòóðû, êîòîðûå ñî-
äåðæàò ïðåäèêàò óïîðÿäî÷åíèÿ äëÿ òèïîâ int è real*string.
Åñëè çíà÷åíèå â ñòðóêòóðå èìååò ïîëèìîðôíûé òèï, òî îíî áóäåò óäî-
âëåòâîðÿòü ëþáîé ñïåöèôèêàöèè, êîòîðàÿ çàäàåò ÷àñòíûé ñëó÷àé ýòîãî

66
ÃËÀÂÀ 3. ÌÎÄÓËÈ
ïîëèìîðôíîãî òèïà. Òàê, íàïðèìåð, åñëè x ïðèâÿçàíî â ñòðóêòóðå ê
nil, òî x áóäåò èìåòü òèï 'a list, è ïîýòîìó áóäåò óäîâëåòâîðÿòü ñïå-
öèôèêàöèÿì, íàïðèìåð, int list è bool list list. Íî ÷òî áóäåò, åñëè
ñïåöèôèêàöèÿ ñîäåðæèò ïîëèìîðôíûé òèï? Ïóñòü, íàïðèìåð, â ñïåöè-
ôèêàöèè óêàçàíî, ÷òî èäåíòèôèêàòîð f äîëæåí èìåòü òèï 'a list ->
'a list. ×òîáû ñîîòâåòñòâîâàòü òàêîé ñïåöèôèêàöèè, â ñòðóêòóðå èäåí-
òèôèêàòîð f äîëæåí áûòü ïðèâÿçàí ê ôóíêöèè, ïîëó÷àþùåé â êà÷åñòâå
àðãóìåíòà ñïèñîê ëþáîãî òèïà è âîçâðàùàþùåé â êà÷åñòâå ðåçóëüòàòà
ñïèñîê òîãî æå òèïà. Íåäîñòàòî÷íî, ÷òîáû f èìåëà òèï, ñêàæåì, int
list -> int list, ïîñêîëüêó ñïåöèôèêàöèÿ òðåáóåò, ÷òîáû f áûëà ïðè-
ìåíèìà ê bool list è ò.ä. Îáùèé ïðèíöèï ñîñòîèò â òîì, ÷òî ñòðóêòóðà
äîëæíà áûòü ïî êðàéíåé ìåðå ñòîëü æå îáùåé, ñêîëü îáùåé ÿâëÿåòñÿ
ñèãíàòóðà. Òàêèì îáðàçîì, åñëè â íåêîòîðîé ñòðóêòóðå èìÿ f ïðèâÿçà-
íî ê òîæäåñòâåííîé ôóíêöèè, êîòîðàÿ èìååò òèï 'à->'à, òî f óäîâëå-
òâîðÿåò ñïåöèôèêàöèè, òðåáóþùåé ôóíêöèè òèïà 'a list -> 'a list.
Ïðè÷èíà ñîñòîèò â òîì, ÷òî f ìîæåò ïîëó÷èòü àðãóìåíò ëþáîãî è òèïà
è âûðàáîòàòü ðåçóëüòàò òîãî æå òèïà, è òåì áîëåå f ìîæåò ïîëó÷èòü
ñïèñîê íåêîòîðîãî òèïà è âûðàáîòàòü â ðåçóëüòàòå ñïèñîê òîãî æå òèïà.
Âîò íåñêîëüêî ïðèìåðîâ:
- signature SIG =
sig
val n : 'a list
val l: int list
val f: 'a list -> 'a list
end;
- structure S : SIG =
struct
val n = nil
(* : 'a list *)
val l = nil
(* : 'a list *)
fun f(x) = x
(* : 'a->'a *)
end
Óïðàæíåíèå 3.2.2 ×òî íåïðàâèëüíîãî â ñëåäóþùåì îáúÿâëåíèè?
structure S : SIG =
struct
val n = [3,4]
val l = nil
fun f(x) = x
end

3.2. ÑÒÐÓÊÒÓÐÛ È ÑÈÃÍÀÒÓÐÛ
67
Ïðèâÿçêà èäåíòèôèêàòîðîâ ê èñêëþ÷åíèÿì â ñòðóêòóðàõ ïîä÷èíåíà
òåì æå îãðàíè÷åíèÿì, ÷òî è â ÿäðå ÿçûêà: îíè äîëæíû èñïîëüçîâàòü
òîëüêî ìîíîìîðôíûå òèïû. Ñïåöèôèêàöèÿ èñêëþ÷åíèÿ çàäàåò òîëüêî
åãî òèï. Ïðàâèëà ñîïîñòàâëåíèÿ ñ ñèãíàòóðîé òàêèå æå, êàê è â ñëó÷àå
ïåðåìåííûõ (çà èñêëþ÷åíèåì òîãî, ÷òî ñëîæíîñòåé, ñâÿçàííûõ ñ ïîëè-
ìîðôíûìè òèïàìè, çäåñü íå âîçíèêàåò).
- structure S =
struct
exception Barf
exception Crap = Barf
fun f(x) = if x=0 then raise Barf
else if x=1 then raise Crap
else 7
end;
> structure S =
struct
exception Barf
exception Crap
val f = fn : int->int
end
- S.f(O);
Failure:
Barf
- S.f(4);
> 7 : int
Íåêîòîðûå èíòåðåñíûå äîïîëíèòåëüíûå âîïðîñû âîçíèêàþò â ñâÿçè ñ
îáúÿâëåíèÿìè è ñïåöèôèêàöèÿìè òèïîâ. Âî-ïåðâûõ, ðàññìîòðèì ïðî-
çðà÷íîå îáúÿâëåíèå òèïà â ñòðóêòóðå  êàê, íàïðèìåð, â ïåðâîì ïðèìå-
ðå ýòîãî ðàçäåëà, ãäå èäåíòèôèêàòîð t ïðèâÿçûâàëñÿ ê òèïó int. Êàêîâà
áóäåò ñèãíàòóðà ýòîé ñòðóêòóðû? Äàâàéòå ðàññìîòðèì, ÷òî ïîëó÷èëîñü
áû ïðè ãèïîòåòè÷åñêîì ðåæèìå ïå÷àòè, óïîìèíàâøåìñÿ ðàíåå:
- structure S =
struct
type t = int
val x = 3
fun f(x) = if x=0 then 1 else x*f(x-1)
end;
> structure S =
struct

68
ÃËÀÂÀ 3. ÌÎÄÓËÈ
type t = int
val f = fn
val x = 3
end
:
sig
type t
val f : int->int
val x : int
end
Ñïåöèôèêàöèÿ äëÿ èäåíòèôèêàòîðà t â ñòðóêòóðå, ê êîòîðîé ïðèâÿçàí
S, åñòü ïðîñòî type t, ÷òî ãîâîðèò î òîì. ÷òî çíà÷åíèåì t ÿâëÿåòñÿ
òèï.
Åñëè òèï èìååò ïàðàìåòð, åãî ñïåöèôèêàöèÿ òàêæå î÷åâèäíà:
- structure S =
struct
type 'a t = 'a * int
val x = (true,3)
end;
> structure S =
struct
type 'a t = 'a * int
val x = (true,3)
end
:
sig
type 'a t
val x : bool * int
end
Îáðàòèòå âíèìàíèå íà ôîðìó ñïåöèôèêàöèè äëÿ t.
Îáå ïðèâåäåííûå âûøå ñïåöèôèêàöèè äîïóñòèìû ïðè çàïèñè ñèãíà-
òóðû. Íî ÷òî ïðîèçîéäåò ïðè ñîïîñòàâëåíèè ñ òàêîé ñèãíàòóðîé? Ðàñ-
ñìîòðèì ñëåäóþùèé ïðèìåð:
- signature SIG =
sig
type 'a t
val x : int * bool

3.2. ÑÒÐÓÊÒÓÐÛ È ÑÈÃÍÀÒÓÐÛ
69
end;
- structure S : SIG =
struct
type 'a t = 'a * bool
val x = (3,true)
end;
> structure S =
struct
type 'a t = 'a * bool
val x = (3,true): int * bool
end
Ñòðóêòóðà, ê êîòîðîé ïðèâÿçûâàåòñÿ S, ñîïîñòàâèìà ñ ñèãíàòóðîé SIG,
ïîñêîëüêó S.t åñòü óíàðíûé (ò.å. èìåþùèé îäèí àðãóìåíò) êîíñòðóêòîð
òèïà  êàê ýòîãî è òðåáóåò SIG.
Åñëè ñèãíàòóðà çàäàåò íåêîòîðûé êîíñòðóêòîð òèïà, òî ýòîò êîí-
ñòðóêòîð ìîæåò èñïîëüçîâàòüñÿ äàëåå â ñèãíàòóðå. Íàïðèìåð:
- signature SIG =
sig
type 'a t
val x : int t
end;
Ýòà ñèãíàòóðà îïðåäåëÿåò êëàññ ñòðóêòóð, êîòîðûå îáúÿâëÿþò óíàðíûé
êîíñòðóêòîð òèïà t è ïåðåìåííóþ òèïà int t (äëÿ ýòîãî êîíñòðóêòîðà
t).
Òåïåðü äàâàéòå âåðíåìñÿ ê ïðèâåäåííîé âûøå ñòðóêòóðå S è ðàññìîò-
ðèì âîïðîñ, ñîïîñòàâèìà îíà èëè íåò ñ ñèãíàòóðîé SIG. Â ñîîòâåòñòâèè
ñ íåôîðìàëüíûì îïèñàíèåì SIG, êîòîðîå ìû òîëüêî ÷òî äàëè, îíà áóäåò
ñîïîñòàâèìîé. Áîëåå ñòðîãî, S áóäåò ñîïîñòàâèìà ñ SIG, ïîòîìó ÷òî:
1. S.t, êàê è òðåáóåòñÿ, åñòü óíàðíûé êîíñòðóêòîð òèïà.
2. Òèï S.x åñòü int*bool. Ïîñêîëüêó, ïî îïðåäåëåíèþ S.t, int t ðàâ-
íî int*bool, S.x ñîîòâåòñòâóåò ñïåöèôèêàöèè int t.
Âàæíî îñîçíàâàòü, ÷òî â ïðîöåññå ñîïîñòàâëåíèÿ ñ ñèãíàòóðîé âñå
èäåíòèôèêàòîðû òèïà â ñèãíàòóðå çàìåíÿþòñÿ íà ñîîòâåòñòâóþùèå
èäåíòèôèêàòîðû èç ñòðóêòóðû, è ïîýòîìó ñïåöèôèêàöèÿ int t ïðåâðà-
ùàåòñÿ â int S.t.

70
ÃËÀÂÀ 3. ÌÎÄÓËÈ
Óïðàæíåíèå 3.2.3 Êàêàÿ ñèãíàòóðà ìîæåò áûòü ñîïîñòàâëåíà ñî
ñëåäóþùåé ñòðóêòóðîé?
structure S =
struct
type 'a t = 'a * int
val x = (true, 3)
end
Ïðè ðàçðàáîòêå ïðîãðàìì ïîëåçíî ïðèäåðæèâàòüñÿ ïðàâèëà çàìêíó-
òîñòè ñèãíàòóðû, êîòîðîå òðåáóåò, ÷òîáû ñâîáîäíûìè èäåíòèôèêàòîðà-
ìè2 â ñèãíàòóðå áûëè òîëüêî èäåíòèôèêàòîðû äðóãèõ ñèãíàòóð è èäåí-
òèôèêàòîðû âñòðîåííûõ ôóíêöèé (òàêèå, êàê + èëè ::)3.
Óïðàæíåíèå 3.2.4 Ïóñòü äàíû ñòðóêòóðû:
structure A = struct datatype 'a D = d of 'a end
structure Â =
struct
type t = int A.D
fun f(A.d(x)) = A.d(x+1)
end
Ñ êàêèìè èç ñëåäóþùèõ ñèãíàòóð áóäåò ñîïîñòàâèìà ñòðóêòóðà Â?
1. sig type t val f: int A.D -> int A.D end
2. sig type t val f: t -> int A.D end
3. sig type t val f: t -> t end
Èñïîëüçîâàíèå ðåêóðñèâíûõ îïðåäåëåíèé òèïîâ â ñòðóêòóðàõ íå âû-
çûâàåò îñîáûõ òðóäíîñòåé. Ðàññìîòðèì ñëåäóþùèé ïðèìåð:
- signature SIG =
sig
type 'a List
val Append : 'a List * 'a List -> 'a List
2Ñâîáîäíûì íàçûâàåòñÿ èäåíòèôèêàòîð, êîòîðûé íå îáúÿâëåí â ñèãíàòóðå. (Ïðèì.
ïåðåâ.)
3Ïîä÷åðêíåì, ÷òî ïðàâèëî çàìêíóòîñòè ñèãíàòóðû ÿâëÿåòñÿ íå ôîðìàëüíûì òðå-
áîâàíèåì ÿçûêà, à ðåêîìåíäàöèåé, ñëåäîâàíèå êîòîðîé îáëåã÷àåò ïîñòðîåíèå ñëîæ-
íûõ ïðîãðàìì. (Ïðèì. ïåðåâ.)

3.2. ÑÒÐÓÊÒÓÐÛ È ÑÈÃÍÀÒÓÐÛ
71
end;
- structure S : SIG =
struct
datatype 'a List = Nil | Cons of 'a * 'a List
fun Append (x,Nil) = x
| Append (x,Cons(h,t)) = Cons(h,Append(x,t))
end;
> structure S =
struct
type 'a List
val Append = fn : 'a List * 'a List -> 'a List
end
Â êà÷åñòâå óïðàæíåíèÿ óáåäèòåñü, ÷òî ñòðóêòóðà S äåéñòâèòåëüíî ñî-
ïîñòàâèìà ñ ñèãíàòóðîé SIG (ñëåäóéòå òåì æå ïóòåì, êàêèì ìû øëè â
ïðèâîäèìûõ ðàíåå ïðèìåðàõ).
Â ïðèâåäåííîì âûøå ïðèìåðå ñèãíàòóðà SIG, ïðèïèñàííàÿ ñòðóêòóðå
S, íå ñîäåðæèò óïîìèíàíèé î êîíñòðóêòîðàõ çíà÷åíèé òèïà List. Èìå-
åòñÿ äâà ñïîñîáà âêëþ÷èòü ýòè êîíñòðóêòîðû â ñèãíàòóðó. Îäèí èç íèõ
ñîñòîèò â òîì, ÷òî êîíñòðóêòîðû òðàêòóþòñÿ êàê îáû÷íûå çíà÷åíèÿ, êàê
ïîêàçûâàåò ñëåäóþùèé ïðèìåð:
- signature SIG =
sig
type 'a List
val Nil: 'a List
val Cons ; 'a * 'a List -> 'a List
val Append : 'a List * 'a List -> 'a List
end;
- structure S : SIG =
struct
datatype 'a List = Nil | Cons of 'a * 'a List
fun Append(x,Nil) = x
| Append(x,Cons(h,t)) = Cons(h,Append(x,t))
end;
> structure S =
struct
type 'a List
val Nil: 'a List
val Cons : 'a * 'a List -> 'a List
val Append = fn : 'a List * 'a List -> 'a List

72
ÃËÀÂÀ 3. ÌÎÄÓËÈ
end
Îáðàòèòå âíèìàíèå íà òî, ÷òî 'a List áîëüøå íå ÿâëÿåòñÿ ðåêóðñèâ-
íûì òèïîì, è ÷òî Nil è Cons ÿâëÿþòñÿ îáû÷íûìè ïåðåìåííûìè, à íå
êîíñòðóêòîðàìè çíà÷åíèé.
Äðóãîé ñïîñîá ñîñòîèò â òîì, ÷òîáû îáúÿâèòü êîíñòðóêòîðû êîí-
ñòðóêòîðàìè, è òåì ñàìûì ñäåëàòü âèäèìûì óñòðîéñòâî òèïà. Ôîðìà
ñïåöèôèêàöèè, êîòîðàÿ ïîçâîëÿåò ýòî ñäåëàòü, ñèíòàêñè÷åñêè èäåíòè÷-
íà îáúÿâëåíèþ ðåêóðñèâíîãî òèïà:
- signature SIG =
sig
datatype 'a List = Nil | Cons of 'a * 'a List
val Append : 'a List * 'a List -> 'a List
end;
- structure Ò : SIG = S;
> structure Ò =
struct
type 'a List
con Nil : 'a List
con Cons : 'a * 'a List -> 'a List
val Append = fn : 'a List * 'a List -> 'a List
end
Ïîëåçíîñòü ýòîãî ïîäõîäà, ïðè êîòîðîì ìû ñïåöèôèöèðóåì êîíñòðóêòî-
ðû, áóäåò ïðîÿñíåíà ïîçæå, êîãäà ìû ââåäåì ôóíêòîðû.
Îáúÿâëåíèÿ àáñòðàêòíûõ òèïîâ äàííûõ â ñòðóêòóðàõ íå ïðèâíîñÿò
íè÷åãî íîâîãî â ñîïîñòàâëåíèå ñ ñèãíàòóðîé, ïîñêîëüêó òàêîå îáúÿâëåíèå
ââîäèò òîëüêî íîâûé òèï è íåêîòîðûå ñâÿçàííûå ñ íèì èäåíòèôèêàòîðû.
Ñïåöèôèêàöèè àáñòðàêòíûõ òèïîâ íå èñïîëüçóþòñÿ, ïîòîìó ÷òî, êàê
ìû óâèäèì äàëåå, èìååòñÿ äðóãîå ñðåäñòâî àáñòðàãèðîâàíèÿ òèïîâ, è
ïîýòîìó â òàêèõ ñïåöèôèêàöèÿõ íåò íóæäû.
Óïðàæíåíèå 3.2.5 Ðåàëèçóéòå ñòåê, èñïîëüçóÿ ñòðóêòóðû è ñèãíà-
òóðû.
Íà ïðàêòèêå ñòðóêòóðû îáû÷íî ñòðîÿòñÿ íà îñíîâå äðóãèõ ñòðóêòóð
â ñîîòâåòñòâèè ñ ïðèíöèïàìè, îïðåäåëÿåìûìè ðåøàåìîé çàäà÷åé. Åñëè
ñòðóêòóðà S ïîñòðîåíà íà îñíîâå äðóãîé ñòðóêòóðû Ò, òî ãîâîðÿò, ÷òî
S çàâèñèò îò Ò. Ìàê-Êâèí ðàññìàòðèâàë äâå êëàññèôèêàöèè çàâèñèìî-
ñòè. Âî-ïåðâûõ, çàâèñèìîñòü S îò T ìîæåò áûòü ñóùåñòâåííîé èëè íåñó-
ùåñòâåííîé. Ñóùåñòâåííàÿ çàâèñèìîñòü èìååò ìåñòî òîãäà, êîãäà S íå

3.2. ÑÒÐÓÊÒÓÐÛ È ÑÈÃÍÀÒÓÐÛ
73
ìîæåò áûòü èñïîëüçîâàíà áåç T  ñâÿçü ìåæäó ñòðóêòóðàìè íàñòîëüêî
òåñíàÿ, ÷òî ðàçäåëüíîå èõ èñïîëüçîâàíèå ÿâëÿåòñÿ áåññìûñëåííûì. Ëþ-
áûå äðóãèå ôîðìû çàâèñèìîñòè ÿâëÿþòñÿ íåñóùåñòâåííûìè. Âî-âòîðûõ,
çàâèñèìîñòü S îò T ìîæåò áûòü ÿâíîé èëè íåÿâíîé. Çàâèñèìîñòü S îò T
áóäåò ÿâíîé, åñëè ñèãíàòóðà S ìîæåò áûòü çàïèñàíà òîëüêî ñî ññûëêà-
ìè íà ñèãíàòóðó T; â ïðîòèâíîì ñëó÷àå çàâèñèìîñòü ÿâëÿåòñÿ íåÿâíîé.
Çàìåòüòå, ÷òî ÿâíàÿ çàâèñèìîñòü âñåãäà ÿâëÿåòñÿ ñóùåñòâåííîé.
Ïðîñòåéøèé ñëó÷àé íåñóùåñòâåííîé çàâèñèìîñòè âîçíèêàåò, åñëè S
èìïîðòèðóåò íåêîòîðûå çíà÷åíèÿ èç T, êàê â ñëåäóþùåì ïðèìåðå:
- structure Ò =
struct
val x = 7
end;
> structure T =
struct
val x = 7 : int
end
- structure S =
struct
val ó = Ò.õ+1
end;
> structure S =
struct
val ó = 8 : int
end
ßñíî, ÷òî S ìîæåò áûòü èñïîëüçîâàíà íåçàâèñèìî îò T, õîòÿ S è îïðåäå-
ëåíà ñ ïîìîùüþ ññûëêè íà T. Ýòà ôîðìà çàâèñèìîñòè èíîãäà íàçûâàåòñÿ
çàâèñèìîñòüþ ïî ïîñòðîåíèþ.
Ñóùåñòâåííàÿ çàâèñèìîñòü ÿâëÿåòñÿ ãîðàçäî áîëåå âàæíîé. Îäíà èç
ôîðì ñóùåñòâåííîé çàâèñèìîñòè âîçíèêàåò òîãäà, êîãäà T îáúÿâëÿåò èñ-
êëþ÷åíèÿ, êîòîðûå ìîãóò âîçáóæäàòüñÿ ôóíêöèÿìè, ïðèíàäëåæàùèìè
S. Íàïðèìåð:
- structure Ò =
struct
exception Barf
fun foo(x) = if x=0 then raise Barf else 3 div x
end;
> structure Ò =

74
ÃËÀÂÀ 3. ÌÎÄÓËÈ
struct
exception Barf
val foo(x) = fn :int -> int
end
- structure S =
struct
fun g(x) = T.foo(x)+1
end
Ïîñêîëüêó âû÷èñëåíèå S.g(0) âîçáóæäàåò èñêëþ÷åíèå Barf, èñïîëüçî-
âàíèå S âîçìîæíî òîëüêî â òîì êîíòåêñòå, â êîòîðîì äîñòóïíà T  èíà÷å
èñêëþ÷åíèå íå ñìîæåò áûòü îáðàáîòàíî. Ïîýòîìó S ñóùåñòâåííî çàâè-
ñèò îò T, è äîëæíà èñïîëüçîâàòüñÿ òîëüêî âìåñòå ñ T. Çàìåòüòå, îäíàêî,
÷òî çàâèñèìîñòü ÿâëÿåòñÿ íåÿâíîé, ïîñêîëüêó ñèãíàòóðà S íå ñîäåðæèò
ññûëîê íà T.
Ñóùåñòâåííàÿ è ÿâíàÿ çàâèñèìîñòü âîçíèêàåò òîãäà, êîãäà S îòêðûòî
èñïîëüçóåò ðåêóðñèâíûé òèï, îïðåäåëåííûé â T, êàê íàïðèìåð:
- structure Ò =
struct
datatype 'a List = Nil | Cons of 'a * 'a List
fun len(Nil) = 0
| len(Cons(h,t)) = 1 + len(t)
end;
> structure Ò =
struct
type 'a List
con Nil : 'a List
con Cons : 'a * 'a List -> 'a List
val len = fn : 'a List -> int
end;
- structure S =
struct
val len = T.len
end;
> structure S =
struct
val len = fn : 'a T.List -> int
end
Çàìåòüòå, ÷òî ñèãíàòóðà ñòðóêòóðû S ñîäåðæèò ññûëêó íà ñòðóê-
òóðó T, îòðàæàÿ òîò ôàêò, ÷òî len ìîæåò áûòü ïðèìåíåíà òîëüêî ê

3.2. ÑÒÐÓÊÒÓÐÛ È ÑÈÃÍÀÒÓÐÛ
75
çíà÷åíèÿì òèïà, îïðåäåëåííîãî â T. Çàìåòüòå, ÷òî ïðàâèëî çàìêíóòî-
ñòè ñèãíàòóðû íå ïîçâîëÿåò â ïðèâåäåííîì âûøå ïðèìåðå ïðèïèñàòü
ñòðóêòóðå S êàêóþ-ëèáî íåòðèâèàëüíóþ ñèãíàòóðó, ïîñêîëüêó ñèãíàòó-
ðà íå ìîæåò ñîäåðæàòü ñâîáîäíûé èäåíòèôèêàòîð ñòðóêòóðû T. Ýòî íà
ïåðâûé âçãëÿä ìîæåò ïîêàçàòüñÿ íåîïðàâäàííûì îãðàíè÷åíèåì; îäíàêî
ýòîì ïîçâîëÿåò ïðèâëå÷ü âíèìàíèå ê òîìó ôàêòó, ÷òî S è T òåñíî ñâÿ-
çàíû ìåæäó ñîáîé, è ïîýòîìó äîëæíû áûòü îáúåäèíåíû â îäèí ìîäóëü.
Òàêîå îáúåäèíåíèå ìîæåò áûòü âûïîëíåíî ïóòåì âêëþ÷åíèÿ ñòðóêòóðû
T â ñòðóêòóðó S â êà÷åñòâå ïîäñòðóêòóðû; ïîñëåäíåå äîñòèãàåòñÿ ñ ïîìî-
ùüþ âêëþ÷åíèÿ îáúÿâëåíèÿ T â íàáîð èíêàïñóëèðîâàííûõ îáúÿâëåíèé
S, êàê ýòî ïîêàçàíî â ñëåäóþùåì ïðèìåðå:
- structure S =
struct
structure T =
struct
datatype 'a List = Nil | Cons of 'a * 'a List
fun len(Nil) = 0 | len (Cons(h,t)) = 1 + len(t)
end
val len = T.len
end
> structure S =
struct
structure Ò =
struct
type 'a List
con Nil : 'a List
con Cons : 'a * 'a List -> 'a List
val len = fn : 'a List -> int
end
val len = fn : 'a T.List -> int
end
Òàêèì ïóòåì ìîæíî èåðàðõè÷åñêè îðãàíèçîâàòü âçàèìîñâÿçàííûå ñòðóê-
òóðû, è îáúåäèíèòü íàáîð ñâÿçàííûõ ñòðóêòóð â ìîäóëü.
Ïîÿâëåíèå ïîäñòðóêòóð òðåáóåò îáîáùåíèÿ ââåäåííîãî ðàíåå ïîíÿ-
òèÿ ïóòè äîñòóïà ê ñòðóêòóðå. Â îáùåì ñëó÷àå ïóòü äîñòóïà ê ñòðóêòóðå
çàïèñûâàåòñÿ êàê ðàçäåëåííàÿ òî÷êàìè ïîñëåäîâàòåëüíîñòü èìåí ñòðóê-
òóð, â êîòîðîé êàæäàÿ ïîñëåäóþùàÿ ñòðóêòóðà ÿâëÿåòñÿ ïîäñòðóêòó-
ðîé ïðåäûäóùåé. Íàïðèìåð, S.T ÿâëÿåòñÿ ïóòåì äîñòóïà ê ñòðóêòóðå,

76
ÃËÀÂÀ 3. ÌÎÄÓËÈ
a S.T.len ÿâëÿåòñÿ ñîñòàâíûì èìåíåì, êîòîðîå âûáèðàåò ôóíêöèþ len
ïîäñòðóêòóðû Ò ñòðóêòóðû S.
Åñëè Ò ÿâëÿåòñÿ ïîäñòðóêòóðîé ñòðóêòóðû S, òî ñèãíàòóðà S áóäåò
âûãëÿäåòü ñëåäóþùèì îáðàçîì:
- signature SIGT =
sig
datatype 'a List = Nil | Cons of 'a * 'a List
val len : 'a List -> int
end;
- signature SIGS =
sig
structure Ò: SIGT
val len : 'a T.List -> int
end;
Îáðàòèòå âíèìàíèå íà ñïåöèôèêàöèþ â SIGS, êîòîðàÿ óêàçûâàåò, ÷òî
ïîäñòðóêòóðà T äîëæíà áûòü ñîïîñòàâèìà ñ ñèãíàòóðîé SIGT. Çàìåòüòå
òàêæå òî, ÷òî ñïåöèôèêàöèÿ äëÿ len â SIGS ñîäåðæèò T.List; T.List
ÿâëÿåòñÿ ëîêàëüíûì â SIGS áëàãîäàðÿ òîìó, ÷òî T åñòü ïîäñòðóêòóðà S.
Óïðàæíåíèå 3.2.6 Îïðåäåëèòå ñòðóêòóðó Åõð, êîòîðàÿ ðåàëèçóåò
íåêîòîðûé ðåêóðñèâíûé òèï âûðàæåíèé è íàáîð ñâÿçàííûõ ñ íèìè îïå-
ðàöèé. Ýòà ñòðóêòóðà äîëæíà áûòü ñîïîñòàâèìîé ñ ñèãíàòóðîé
signature ÅÕÐ =
sig
datatype id = Id of string
datatype exp = Var of id
| App of id * (exp list)
end
Îïðåäåëèòå äðóãóþ ñèãíàòóðó SUBST è ñòðóêòóðó Subst, êîòîðàÿ ðå-
àëèçóåò îïåðàöèþ ïîäñòàíîâêè äëÿ ýòèõ âûðàæåíèé (ò. å. îïðåäåëè-
òå òèï Subst êàê ñïèñîê ïàð èäåíòèôèêàòîð/âûðàæåíèå, è ôóíêöèþ
ïîäñòàíîâêè, êîòîðàÿ ïî âûðàæåíèþ è ïîäñòàíîâêå (çíà÷åíèþ òèïà
subst) ñòðîèò âûðàæåíèå, ïîëó÷àþùååñÿ èç èñõîäíîãî ïóòåì çàìåíû
îïèñàííûõ â ïîäñòàíîâêå èäåíòèôèêàòîðîâ íà ñîîòâåòñòâóþùèå âû-
ðàæåíèÿ).

3.3. ÀÁÑÒÐÀÊÖÈß
77
3.3
Àáñòðàêöèÿ
Ðàíåå ìû îòìåòèëè, ÷òî ïðîöåññ ñîïîñòàâëåíèÿ ñòðóêòóðû ñ ñèãíà-
òóðîé îáðåçàåò ñòðóêòóðó òàê, ÷òî â íåé îñòàþòñÿ òîëüêî êîìïîíåí-
òû, ïðèñóòñòâóþùèå â ñèãíàòóðå. Ïðèïèñûâàíèå ñèãíàòóðû ñòðóêòóðå
ñîçäàåò íåêîòîðóþ ïðîåêöèþ ýòîé ñòðóêòóðû, è, òàêèì îáðàçîì, ñî-
ïîñòàâëåíèå ñ ñèãíàòóðîé îáåñïå÷èâàåò íåêîòîðûé îãðàíè÷åííûé ñïîñîá
ñîêðûòèÿ èíôîðìàöèè, îãðàíè÷èâàÿ äîñòóï ê ñòðóêòóðå òîëüêî òåìè
êîìïîíåíòàìè, êîòîðûå èìåþòñÿ â ñèãíàòóðå. Îäíà èç ïðè÷èí ôîðìè-
ðîâàíèÿ òàêèõ îãðàíè÷åíèé ñîñòîèò â òîì, ÷òî ïðè ïîñòðîåíèè ñëîæíûõ
ïðîãðàììíûõ ñèñòåì ïîëåçíî èìåòü âîçìîæíîñòü òî÷íîãî îïèñàíèÿ èí-
òåðôåéñà êàæäîãî ïðîãðàììíîãî ìîäóëÿ. Òî æå ñàìîå ìîæåò áûòü óêàçà-
íî êàê îäíà èç ïðè÷èí èñïîëüçîâàíèÿ àáñòðàêòíûõ òèïîâ äàííûõ â ÿäðå
ÿçûêà: ýòî ïîçâîëÿåò ñäåëàòü âñåõ ïîëüçîâàòåëåé äàííîãî àáñòðàêòíîãî
òèïà äàííûõ íåçàâèñèìûìè îò äåòàëåé åãî ðåàëèçàöèè. Ñîïîñòàâëåíèå
ñ ñèãíàòóðîé ìîæåò îáåñïå÷èòü íåêîòîðûå èç âîçìîæíîñòåé, ïðåäîñòàâ-
ëÿåìûõ àáñòðàêòíûìè òèïàìè äàííûõ, ïîñêîëüêó ñ ïîìîùüþ íåãî âîç-
ìîæíî óáðàòü êîíñòðóêòîðû ðåêóðñèâíûõ òèïîâ, è, òàêèì îáðàçîì,
ñïðÿòàòü âíóòðåííåå ïðåäñòàâëåíèå. Íî ýòî ÿâëÿåòñÿ îäíèì èç ÷àñòíûõ
ñëó÷àåâ áîëåå îáùåãî ñïîñîáà ñîêðûòèÿ èíôîðìàöèè â ML, íàçûâàåìîãî
àáñòðàêöèåé.
Ôóíäàìåíòàëüíàÿ èäåÿ ñîñòîèò â òîì, ÷òî ïðè íåêîòîðûõ îáñòîÿ-
òåëüñòâàõ íàì õîòåëîñü áû îãðàíè÷èòü òî, ÷òî âèäíî èç ñòðóêòóðû, â
òî÷íîñòè òåì, ÷òî óêàçàíî â ñèãíàòóðå. Ýòî ìîæåò áûòü ïðîèëëþñòðè-
ðîâàíî ñëåäóþùèì ïðèìåðîì:
- signature SIG =
sig
type t
val x : t -> t
end;
- structure S : SIG =
struct
type t = int
val x = fn x => x
end;
> structure S =
struct
type t = int
val x = fn : t -> t

78
ÃËÀÂÀ 3. ÌÎÄÓËÈ
end
- S.x(3);
> 3 : int
- S.x(3) : S.t;
> 3 : int : S.t
Îáðàòèòå âíèìàíèå íà òî, ÷òî S.t åñòü int, õîòÿ ñèãíàòóðà SIG íè î ÷åì
òàêîì íå ãîâîðèò.
Öåëü àáñòðàêöèè ñîñòîèò â òîì, ÷òîáû ñêðûòü âñþ èíôîðìàöèþ î
ñòðóêòóðå, êîòîðàÿ íå óïîìèíàåòñÿ ÿâíî â ñèãíàòóðå.
- abstraction S : SIG =
struct
type t = int
val x = fn x => x
end;
> abstraction S : SIG
- S.x(3);
> 3 : int
- S.x(3) : S.t;
Type error in: S.x(3) : S.t
Looking for a: int
I have found a: S.t
Ýôôåêò îáúÿâëåíèÿ àáñòðàêöèè ñîñòîèò â îãðàíè÷åíèè âñåé äîñòóïíîé
îá S èíôîðìàöèè òîëüêî òîé èíôîðìàöèåé, êîòîðàÿ óêàçàíà â SIG.
Èìååòñÿ òåñíàÿ ñâÿçü ìåæäó àáñòðàêöèåé è àáñòðàêòíûìè òèïàìè
äàííûõ. Ðàññìîòðèì ñëåäóþùèé àáñòðàêòíûé òèï:
- abstype 'a set = set of 'a list
with
val empty_set = set([])
fun union(set(l1),set(l2)) = set(l1@l2)
end;
> type 'a set
val empty_set = - : 'a set
val union = fn : 'a set * 'a set -> 'a set
- empty_set;
> - : 'a set
Ýòî îáúÿâëåíèå îïðåäåëÿåò òèï 'a set ñ îïåðàöèÿìè empty_set è union.
Êîíñòðóêòîð set ñïðÿòàí äëÿ òîãî, ÷òîáû ìîæíî áûëî ðó÷àòüñÿ, ÷òî òèï

3.3. ÀÁÑÒÐÀÊÖÈß
79
ÿâëÿåòñÿ àáñòðàêòíûì (ò.å. ÷òî íè îäíà ïðîãðàììà, èñïîëüçóþùàÿ ýòîò
òèï, íå îêàæåòñÿ çàâèñèìîé îò åãî ïðåäñòàâëåíèÿ).
Â îáùåì ñëó÷àå îáúÿâëåíèå abstype îïðåäåëÿåò òèï è íàáîð îïåðà-
öèé íàä äàííûìè ýòîãî òèïà, ñêðûâàÿ ïðè ýòîì òèï ðåàëèçàöèè. Àá-
ñòðàêöèÿ ïðåäëàãàåò äðóãîé ïóòü ðåøåíèÿ ýòîé æå çàäà÷è, ÷òî ìîæíî
óâèäåòü èç ñëåäóþùåãî ïðèìåðà:
- signature SET =
sig
type 'a set
val emty_set: 'a set
val union : 'a set * 'a set -> 'a set
end;
- abstraction Set: SET =
struct
datatype 'a set = set of 'a list
val empty_set = set([])
fun union(set(l1),set(l2)) = set(l1@l2)
end;
> abstraction Set : SET
- Set.set;
Undefined variable Set.set
- S.empty_set;
> - : 'a S.set
Óïðàæíåíèå 3.3.1 Îïðåäåëèòå àáñòðàêöèþ äëÿ êîìïëåêñíûõ ÷èñåë,
èñïîëüçóÿ ñëåäóþùóþ ñèãíàòóðó:
signature COMPLEX =
sig
type complex
exception divide: unit
val rectangular: {real: real, imag : real} -> complex
val plus : complex * complex -> complex
val minus : complex * complex -> complex
val times : complex * complex -> complex
val divide : complex * complex -> complex
val eq : complex * complex -> bool
val real_part : complex -> real
val imag_part: complex -> real
end

80
ÃËÀÂÀ 3. ÌÎÄÓËÈ
Ïîäñêàçêà: èñïîëüçóéòå ñëåäóþùèå ôîðìóëû äëÿ ðåàëèçàöèè îïåðàöèé
íàä êîìïëåêñíûìè ÷èñëàìè:
(a + ib) + (c + id) = (a + c) + i(b + d)
(a + ib) −(c + id) = (a −c) + i(b −d)
(a + ib) ∗(c + id) = (ac −bd) + i(ad + bc)
(a + ib)/(c + id) = (ac + bd) + i(bc −ad)
c2 + d2
Àáñòðàêöèÿ ÿâëÿåòñÿ áîëåå ãèáêîé ïî ñðàâíåíèþ ñ àáñòðàêòíûìè òè-
ïàìè äàííûõ â îäíèõ ñëó÷àÿõ è ìåíåå ãèáêîé â äðóãèõ. Áîëüøàÿ ãèá-
êîñòü ïðîèñòåêàåò èç òîãî, ÷òî àáñòðàêöèÿ íå îáÿçàíà áûòü òèïîì äàí-
íûõ ñ îïåðàöèÿìè, êàê ýòî âûòåêàåò èç ñàìîé ôîðìû àáñòðàêòíûõ òè-
ïîâ. Íàïðèìåð, ìîæåò áûòü íå îáúÿâëåíî íè îäíîãî òèïà âîîáùå, à îáú-
ÿâëåííûå òèïû íå îáÿçàíû áûòü ðåêóðñèâíûìè òèïàìè. Àáñòðàêòíûå
òèïû äàííûõ íåñêîëüêî áîëåå ãèáêè ïîòîìó, ÷òî îíè, ÿâëÿÿñü îáû÷íîé
ôîðìîé îáúÿâëåíèÿ, ìîãóò ïîÿâëÿòüñÿ âåçäå, ãäå ìîãóò ïîÿâëÿòüñÿ îáú-
ÿâëåíèÿ,  â òî âðåìÿ êàê àáñòðàêöèè ìîãóò ïîÿâëÿòüñÿ ëèøü òàì, ãäå
ìîãóò ïîÿâëÿòüñÿ ñòðóêòóðû: íà âåðõíåì óðîâíå èëè â èíêàïñóëèðîâàí-
íûõ îáúÿâëåíèÿõ. Ýòî îãðàíè÷åíèå íå êàæåòñÿ ñóùåñòâåííûì, ïîñêîëü-
êó îáû÷íî òèïû îïðåäåëÿþòñÿ íà âåðõíåì óðîâíå4.
3.4
Ôóíêòîðû
ML-ïðîãðàììà ÿâëÿåòñÿ èåðàðõè÷åñêè îðãàíèçîâàííûì ñîáðàíèåì
âçàèìîñâÿçàííûõ ñòðóêòóð. Ôóíêòîðû (êîòîðûå ÿâëÿþòñÿ ôóíêöèÿìè
íàä ñòðóêòóðàìè) èñïîëüçóþòñÿ äëÿ óïîðÿäî÷åíèÿ ïðîöåññà ðàçðàáîòêè
ïðîãðàìì. Â íåêîòîðîì ñìûñëå ðîëü ôóíêòîðîâ àíàëîãè÷íà ðîëè ñâÿçû-
âàþùåãî çàãðóç÷èêà â äðóãèõ ÿçûêàõ ïðîãðàììèðîâàíèÿ: îíè ÿâëÿþò-
ñÿ èíñòðóìåíòîì, ïîçâîëÿþùèì èç îòäåëüíûõ ÷àñòåé ñîáðàòü ãîòîâóþ
ïðîãðàììó. Ôóíêòîðû îïðåäåëÿþòñÿ ïóòåì ïðèâÿçêè ê ôóíêòîðàì; ýòà
êîíñòðóêöèÿ ìîæåò ïîÿâëÿòüñÿ òîëüêî íà âåðõíåì óðîâíå. Ñèíòàêñèñ
ïðèâÿçêè ê ôóíêòîðó ïîõîæ íà ïðèâÿçêó ê ôóíêöèè â ÿäðå ÿçûêà. Ïðè-
âåäåì ïðèìåð:
4Ìû ðåêîìåíäóåì ïðè ïðîãðàììèðîâàíèè íà ML èçáåãàòü àáñòðàêòíûõ òèïîâ äàí-
íûõ, ïîñêîëüêó â äàëüíåéøåì îíè ìîãóò áûòü óñòðàíåíû èç ÿçûêà (òàê êàê àáñòðàê-
öèÿ äîñòàòî÷íà äëÿ èõ çàìåíû).

3.4. ÔÓÍÊÒÎÐÛ
81
- signature SIG =
sig
type t
val eq : t*t -> bool
end;
- functor F( P : SIG ) : SIG =
struct
type t = P.t * P.t
fun eq((x,y),(u,v)) = P.eq(x,u) andalso P.eq(y,v)
end;
> functor F( P : SIG ) : SIG
Ñèãíàòóðà SIG îïðåäåëÿåò òèï t è áèíàðíîå îòíîøåíèå eq. Ôóíêòîð F
îïðåäåëÿåò ôóíêöèþ, êîòîðàÿ, ïîëó÷èâ ñòðóêòóðó, ñîïîñòàâèìóþ ñ ñèã-
íàòóðîé SIG, âûðàáàòûâàåò äðóãóþ ñòðóêòóðó (êîòîðàÿ â äàííîì ïðè-
ìåðå òàêæå äîëæíà áûòü ñîïîñòàâèìà ñ ñèãíàòóðîé SIG  îäíàêî, ðà-
çóìååòñÿ, â äðóãèõ ñëó÷àÿõ ñèãíàòóðà ñòðóêòóðû-ðåçóëüòàòà íå îáÿçàíà
ñîâïàäàòü ñ ñèãíàòóðîé ñòðóêòóðû-ïàðàìåòðà).
Ôóíêòîðû ïðèìåíÿþòñÿ ê ñòðóêòóðàì è âûðàáàòûâàþò äðóãèå
ñòðóêòóðû.
- structure S : SIG =
struct
type t = int
val eq : t*t->bool = op =
end;
> structure S =
struct
type t = int
val eq = fn : t*t->bool
end
- structure SS : SIG = F(S);
> structure SS =
struct
type t = int*int
val eq = fn : t*t->bool
end
Çäåñü ìû ñîçäàëè ñòðóêòóðó S, ñîïîñòàâèìóþ ñ ñèãíàòóðîé SIG. Ôóíê-
òîð F, ïðèìåíÿåìûé ê ñòðóêòóðå S, ñòðîèò íîâóþ ñòðóêòóðó ñ òîé æå
ñèãíàòóðîé  íî â êîòîðîé t óæå ÿâëÿåòñÿ òèïîì óïîðÿäî÷åííûõ ïàð

82
ÃËÀÂÀ 3. ÌÎÄÓËÈ
öåëûõ ÷èñåë, à ôóíêöèÿ ðàâåíñòâà îïðåäåëåíà íà ýòèõ ïàðàõ. Îáðàòèòå
âíèìàíèå íà òî, êàê SS ñòðîèòñÿ èç S ñ ïîìîùüþ ôóíêòîðà F.
Ôóíêòîðû â âûñîêîé ñòåïåíè îáëàäàþò ïîëèìîðôèçìîì, ÷òî îáúÿñ-
íÿåòñÿ òåì, ÷òî ñîïîñòàâëÿåìàÿ ñ ñèãíàòóðîé ñòðóêòóðà ìîæåò ñîäåð-
æàòü áîëüøå èíôîðìàöèè, ÷åì ýòîãî òðåáóåò ñèãíàòóðà. Íàïðèìåð:
- structure Ò : SIG =
struct
type t = string * int
val eq : t*t->bool = op =
fun f(x:t) = (x,x)
end;
> structure T =
struct
type t = string * int
val eq : t*t->bool
end
- structure TT : SIG = F(T);
> structure TT =
struct
type t = (string*int)*(string*int)
val eq : t*t->bool
end
Õîòÿ è èìååòñÿ îãðàíè÷åíèå, ÷òî ôóíêòîð äîëæåí èìåòü ðîâíî îäèí àð-
ãóìåíò, îíî íå ÿâëÿåòñÿ ñóùåñòâåííûì: ïðè íåîáõîäèìîñòè íåñêîëüêî
ñòðóêòóð ìîãóò áûòü âêëþ÷åíû â îäíó êàê ïîäñòðóêòóðû, è çàòåì ýòà
ñòðóêòóðà ìîæåò áûòü ïåðåäàíà ôóíêòîðó. Íà ïðàêòèêå ýòî îáû÷íî íå
ñîçäàåò íèêàêèõ íåóäîáñòâ, ïîñêîëüêó â òåõ ñëó÷àÿõ, êîãäà íåñêîëüêî
ñòðóêòóð äîëæíû áûòü ïåðåäàíû â êà÷åñòâå àðãóìåíòà ôóíêòîðó, îíè,
êàê ïðàâèëî, íàñòîëüêî òåñíî ñâÿçàíû ìåæäó ñîáîé, ÷òî èìååòñÿ ìíîãî
äðóãèõ ïðè÷èí, ïî êîòîðûì èõ ðàçóìíî îáúåäèíèòü â îäíó ñòðóêòóðó.
Ôóíêòîðû äîëæíû ïîä÷èíÿòüñÿ òîìó æå (ðåêîìåíäàòåëüíîìó) ïðàâè-
ëó çàìêíóòîñòè, ÷òî è ñèãíàòóðû: îíè íå äîëæíû ñîäåðæàòü îòêðûòûõ
ññûëîê íà çíà÷åíèÿ, òèïû è èñêëþ÷åíèÿ âî âíåøíåé ñðåäå (çà èñêëþ÷å-
íèåì ïðåäîïðåäåëåííûõ ñèñòåìíûõ ïðèìèòèâîâ). Â òåëå ôóíêòîðà áåç
âñÿêèõ îãðàíè÷åíèé ìîãóò èñïîëüçîâàòüñÿ ññûëêè íà ïàðàìåòð è åãî
êîìïîíåíòû (ñ èñïîëüçîâàíèåì óòî÷íÿþùèõ èìåí), íà ëîêàëüíûå èäåí-
òèôèêàòîðû è íà ðàíåå îïðåäåëåííûå ôóíêòîðû è ñèãíàòóðû.
Òåëî ôóíêòîðà íå îáÿçàíî ïðåäñòàâëÿòü èç ñåáÿ èíêàïñóëèðîâàííûå
îáúÿâëåíèÿ (õîòÿ, âåðîÿòíî, ýòî íàèáîëåå ðàñïðîñòðàíåííûé ñëó÷àé).

3.4. ÔÓÍÊÒÎÐÛ
83
Â òåëå ôóíêòîðà ìîãóò ñâîáîäíî èñïîëüçîâàòüñÿ ñîñòàâíûå èìåíà è àï-
ïëèêàöèè ôóíêòîðîâ (îäíàêî âàæíûé ìîìåíò: ôóíêòîð íå ìîæåò áûòü
ðåêóðñèâíûì!). Ïðèâåäåì ïðèìåðû:
- functor G( Ð : SIG ) : SIG = F(F(P));
> functor G( Ð : SIG ) : SIG
- functor I( P : SIG ) : SIG = P;
> functor I( P : SIG ) : SIG
Íóæíî îòìåòèòü, ÷òî ôóíêòîð I íå ÿâëÿåòñÿ òîæäåñòâåííûì: åñëè S åñòü
ñòðóêòóðà, ñîïîñòàâèìàÿ ñ ñèãíàòóðîé SIG, íî ñ áîëüøèì êîëè÷åñòâîì
êîìïîíåíò, ÷åì óïîìÿíóòî â ñèãíàòóðå, òî F(S) áóäåò óðåçàííîé ïî
ñðàâíåíèþ ñ S. Íàïðèìåð:
- structure S =
struct
type t = int
val eq = op =
fun f(x) = x
end;
> structure S =
struct
type t = int
val eq = fn : int*int -> bool
val f = fn : 'a -> 'a
end
- structure S' = I(S);
> structure S' =
struct
type t = int
val eq = fn : int*int -> bool
end
Îáðàòèòå âíèìàíèå íà òî, ÷òî êîìïîíåíòà f ñòðóêòóðû S îòñóòñòâóåò â
I(S).
Óïðàæíåíèå 3.4.1 Ïðåîáðàçóéòå âàøó ðåàëèçàöèþ ìíîæåñòâ íà îñ-
íîâå óïîðÿäî÷åííûõ ñïèñêîâ â ôîðìó, â êîòîðîé ôóíêöèè ðàâåíñòâà
è ïîðÿäêà ïåðåäàþòñÿ â êà÷åñòâå àðãóìåíòîâ ôóíêòîðó, ñòðîÿùåìó
ñòðóêòóðó äëÿ ðàáîòû ñ ìíîæåñòâàìè.

84
ÃËÀÂÀ 3. ÌÎÄÓËÈ
Ýòèì çàâåðøàåòñÿ íàøå ââåäåíèå â ìîäóëüíóþ ñèñòåìó ML. Íàì
îñòàëîñü îáñóäèòü îäíó âàæíóþ èäåþ  ñîèñïîëüçîâàíèå. Ýòî ìû îá-
ñóäèì íåñêîëüêî ïîçæå, ïîñëå òîãî, êàê ðàññìîòðèì ïðèìåðû èñïîëüçî-
âàíèÿ ìîäóëåé â ïðîãðàììèðîâàíèè.
3.5
Ìîäóëüíàÿ ñèñòåìà â ðåàëüíîé ïðàêòèêå
Â ýòîì ðàçäåëå ìû ïðîèëëþñòðèðóåì âîçìîæíîñòè èñïîëüçîâàíèÿ
ìîäóëüíîé ñèñòåìû äëÿ ïîñòðîåíèÿ ïðîãðàìì. Ìû ðàññìîòðèì (â îá-
ùèõ ÷åðòàõ) ðàçðàáîòêó ñèíòàêñè÷åñêîãî àíàëèçàòîðà, ïðåîáðàçóþùåãî
âõîäíóþ ñòðîêó â àáñòðàêòíîå äåðåâî ñèíòàêñè÷åñêîãî ðàçáîðà è çàíî-
ñÿùåãî íåêîòîðóþ èíôîðìàöèþ î ñèìâîëàõ âî âõîäíîé ñòðîêå â òàáëèöó
ñèìâîëîâ. Ïðîãðàììà áóäåò ñîñòîÿòü èç ÷åòûðåõ ìîäóëåé: îäèí áóäåò
ñîäåðæàòü ñîáñòâåííî ñèíòàêñè÷åñêèé àíàëèçàòîð, âòîðîé  ïðîöåäóðû
ðàáîòû ñ äåðåâîì ñèíòàêñè÷åñêîãî ðàçáîðà, òðåòèé  ïðîöåäóðû ðàáîòû
ñ òàáëèöåé ñèìâîëîâ è ÷åòâåðòûé  ñêàíåð. Âîò ñèãíàòóðû ýòèõ ìîäó-
ëåé:
signature SYMBOL =
sig
type symbol
val mksymbol : string -> symbol
val eqsymbol : symbol*symbol -> bool
end;
signature ABSTSYNTAX =
sig
structure Symbol : SYMBOL
type term
val idname : term -> Symbol.symbol
end;
signature SYMBOLTABLE =
sig
structure Symbol : SYMBOL
type entry type table
val mktable : unit -> table
val lookup : Symbol.symbol * table -> entry
end;
signature PARSER =
sig
structure AbstSyntax : ABSTSYNTAX

3.5. ÌÎÄÓËÜÍÀß ÑÈÑÒÅÌÀ Â ÐÅÀËÜÍÎÉ ÏÐÀÊÒÈÊÅ
85
structure SimbolTable : SYMBOLTABLE
val symtable : Symboltable.table
val parse : string -> AbstSyntax.term
end;
Ðàçóìååòñÿ, ýòè ñèãíàòóðû èäåàëèçèðîâàíû è ïðåäåëüíî ñîêðàùåíû, íî
âñå æå îíè äîñòàòî÷íî ïðàâäîïîäîáíû, ÷òîáû ñëóæèòü â êà÷åñòâå óáåäè-
òåëüíîãî è èíôîðìàòèâíîãî ïðèìåðà. Îáðàòèòå âíèìàíèå íà èåðàðõè÷å-
ñêóþ îðãàíèçàöèþ ýòèõ ñòðóêòóð. Ïîñêîëüêó ñîáñòâåííî ñèíòàêñè÷åñêèé
àíàëèçàòîð ñóùåñòâåííî èñïîëüçóåò ôóíêöèè ðàáîòû è ñ äåðåâîì ñèí-
òàêñè÷åñêîãî ðàçáîðà, è ñ òàáëèöåé ñèìâîëîâ, ñîîòâåòñòâóþùèå ñòðóêòó-
ðû äîëæíû áûòü ÿâíî âêëþ÷åíû â íåãî êàê ïîäñòðóêòóðû. Àíàëîãè÷íî,
è ìîäóëü ðàáîòû ñ äåðåâîì ñèíòàêñè÷åñêîãî ðàçáîðà, è ìîäóëü äîñòóïà
ê òàáëèöå ñèìâîëîâ èñïîëüçóþò ñêàíåð êàê ïîäñòðóêòóðó.
Òåïåðü äàâàéòå ïîñìîòðèì, êàê íà îñíîâå ýòîãî ìû ìîæåì ïîñòðîèòü
ñèíòàêñè÷åñêèé àíàëèçàòîð. Îòëîæèâ íà âðåìÿ âîïðîñû âûáîðà àëãî-
ðèòìà è ïðåäñòàâëåíèÿ, ìû ìîæåì íàïèñàòü ñëåäóþùèå ñòðóêòóðû:
structure Symbol: SYMBOL =
struct
datatype symbol = symbol of string * ...
fun mksymbol(s) = symbol(s, ...)
fun eqsymbol(syml,sym2) = ...
end;
structure AbstSyntax : ABSTSYNTAX =
struct
structure Symbol : SYMBOL = Symbol
datatype term = ...
fun idname(term) = ...
end;
structure SymbolTable : SYMBOLTABLE =
struct
structure Symbol: SYMBOL = Symbol
type entry = ...
type table = ...
fun mktable() = ...
fun lookup(sym, table) = ...
end;
structure Parser: PARSER =
struct
structure AbstSyntax : ABSTSYNTAX = AbstSyntax

86
ÃËÀÂÀ 3. ÌÎÄÓËÈ
structure SymbolTable : SYMBOLTABLE = SymbolTable
val symtable = SymbolTable.mktable();
fun parse(str) =
... SymbolTable.lookup(AbstSyntax.idname(t),symtable)...
end;
Îáðàòèòå âíèìàíèå íà òî, ÷òî â ïîñëåäíåé ñòðîêå ñòðóêòóðû Parser ìû
çàïèñàëè ïðèìåíåíèå ôóíêöèè SymbolTable.lookup ê ðåçóëüòàòó ôóíê-
öèè AbstSyntax.idname. Ýòî ïðèìåíåíèå êîððåêòíî ñ òî÷êè çðåíèÿ ñî-
ãëàñîâàíèÿ òèïîâ òîëüêî áëàãîäàðÿ òîìó, ÷òî ñòðóêòóðû AbstSyntax è
SymbolTable âêëþ÷àþò îäíó è òó æå ñòðóêòóðó Symbol. Åñëè áû áû-
ëî äâå ñòðóêòóðû, ñîïîñòàâèìûå ñ ñèãíàòóðîé SYMBOL, è îäíà èç íèõ
áûëà èñïîëüçîâàíà â ñòðóêòóðå SymbolTable, à äðóãàÿ  â ñòðóêòóðå
AbstSyntax, â óïîìÿíóòîé ñòðîêå âîçíèêëà áû îøèáêà íåñîîòâåòñòâèÿ
òèïîâ. Èìåéòå ýòî â âèäó ïðè ÷òåíèè äàëüíåéøåãî.
Îðãàíèçàöèÿ íàøåãî ñèíòàêñè÷åñêîãî àíàëèçàòîðà ïîêà êàæåòñÿ
âïîëíå óäîâëåòâîðèòåëüíîé  ïî êðàéíåé ìåðå äî òåõ ïîð, ïîêà ìû
ðàññìàòðèâàåì ñòàòè÷åñêóþ ñòðóêòóðó ïðîãðàììû. Íî åñëè ìû ïðåäïî-
ëîæèì, ÷òî èìåþòñÿ åùå ìíîãî÷èñëåííûå ñòðóêòóðû, è êàæäàÿ èç íèõ
ñîäåðæèò íåñêîëüêî òûñÿ÷ ñòðîê êîäà, òî òîãäà ïðåäëîæåííàÿ ñòðóêòó-
ðà îêàæåòñÿ íå ñîâñåì óäîáíîé. Ïðåäïîëîæèì, íàïðèìåð, ÷òî ìû íàøëè
îøèáêó â ñòðóêòóðå SymbolTable è èñïðàâèëè åå. Òåïåðü íàì íóæíî
ñîáðàòü ñèíòàêñè÷åñêèé àíàëèçàòîð çàíîâî. Ýòî ïîòðåáóåò ïåðåêîìïè-
ëÿöèè âñåõ ïðèâåäåííûõ âûøå ñòðóêòóð (à òàêæå, âîçìîæíî, è äðóãèõ
ñâÿçàííûõ ñ íèìè). ßñíî, ÷òî íóæíà êàêàÿ-òî âîçìîæíîñòü ðàçäåëüíîé
êîìïèëÿöèè è ïîñëåäóþùåãî ñâÿçûâàíèÿ ñêîìïèëèðîâàííûõ ìîäóëåé.
Òî, ÷òî íàì íóæíî  ýòî âîçìîæíîñòü îòäåëüíî ñêîìïèëèðîâàòü îäèí
ìîäóëü è çàòåì ñâÿçàòü ìîäóëè â åäèíóþ ïðîãðàììó. Ýòà èäåÿ, ðàçóìå-
åòñÿ, íå íîâà; íîâûì, îäíàêî, ÿâëÿåòñÿ òî, êàê ýòà ïðîáëåìà ðåøàåòñÿ â
ML.
Êëþ÷åâàÿ èäåÿ ñîñòîèò â òîì, ÷òîáû íèêîãäà íå çàïèñûâàòü ññûëêè
íà ñòðóêòóðû ÿâíî, à âìåñòî ýòîãî îðãàíèçîâûâàòü ïðîãðàììó â âèäå
íàáîðà ôóíêòîðîâ, êàæäûé èç êîòîðûõ ïîëó÷àåò â êà÷åñòâå àðãóìåíòà
ñòðóêòóðû, îò êîòîðûõ îí çàâèñèò (èëè íè÷åãî, åñëè ôóíêòîð íè îò ÷åãî
íå çàâèñèò). Ïîñëå ýòîãî ðåäàêòèðîâàíèå ñâÿçåé áóäåò ñîñòîÿòü â ïðèìå-
íåíèè ôóíêòîðîâ. Â íàøåì ñëó÷àå ôóíêòîðû ìîãóò âûãëÿäåòü ñëåäóþ-
ùèì îáðàçîì:
functor SymbolFun() : SYMBOL =
struct
datatype symbol = symbol of string * ...

3.5. ÌÎÄÓËÜÍÀß ÑÈÑÒÅÌÀ Â ÐÅÀËÜÍÎÉ ÏÐÀÊÒÈÊÅ
87
fun mksymbol(s) = symbol(s,...)
fun eqsymbol(syml,sym2) = ...
end;
functor AbstSyntaxFun( Symbol: SYMBOL ): ABSTSYNTAX =
struct
structure Symbol: SYMBOL = Symbol
datatype term =... fun idname(term) = ...
end;
functor SymbolTableFun( Symbol : SYMBOL ): SYMBOLTABLE =
struct
structure Symbol: SYMBOL = Symbol
type entry = ...
type table = ...
fun mktable() = ...
fun lookup(sym,table) = ...
end;
signature PARSER_PIECES =
sig
structure SymbolTable : SYMBOLTABLE
structure AbstSyntax : ABSTSYNTAX
end;
functor ParserFun( Pieces : PARSER_PIECES ): PARSER =
struct
structure AbstSyntax : ABSTSYNTAX = Pieces.AbstSyntax
structure SymbolTable : SYMBOLTALBLE = Pieces.SymbolTable
val symtable = SymbolTable.mktable();
fun parse(str) =
... SymbolTable.lookup( AbstSyntax.idname(t), symtable )...
end;
Ñèãíàòóðà PARSER_PIECES ñîäåðæèò äâå êîìïîíåíòû, îò êîòîðûõ çàâè-
ñèò ñèíòàêñè÷åñêèé àíàëèçàòîð,  òàáëèöó ñèìâîëîâ è äåðåâî ñèíòàê-
ñè÷åñêîãî ðàçáîðà. Ôóíêòîð ParserFun èñïîëüçóåò ýòó ïàðó äëÿ ïîñòðî-
åíèÿ ñèíòàêñè÷åñêîãî àíàëèçàòîðà. Ôóíêòîð SymbolFun íå èìååò àðãó-
ìåíòîâ, ïîñêîëüêó îí íå çàâèñèò íè îò ÷åãî.
Ïðîãðàììà ñòðîèòñÿ èç ýòèõ ôóíêòîðîâ ñ ïîìîùüþ ñëåäóþùåé ïî-
ñëåäîâàòåëüíîñòè îáúÿâëåíèé. Óáåäèòåñü, ÷òî ðåçóëüòàò áóäåò òåì æå,
÷òî è ðàíåå.
structure Symbol: SYMBOL = SymbolFun();
structure Pieces: PARCER_PIECES =

88
ÃËÀÂÀ 3. ÌÎÄÓËÈ
struct
structure SymbolTable: SYMBOLTABLE = SymbolTableFun(Symbol)
structure AbstSyntax: ABSTSYNTAX = AbstSyntaxFun(Symbol)
end;
structure Parser: PARSER = ParserFun( Pieces );
Îäíàêî ìû óìîë÷àëè î ïðîáëåìå ñ ParserFun. Íàïîìíèì, ÷òî ôóíê-
öèÿ parse, îïðåäåëåííàÿ â Parser, ÿâëÿåòñÿ êîððåêòíîé ñ òî÷êè çðå-
íèÿ ñîãëàñîâàííîñòè òèïîâ òîëüêî ïîòîìó, ÷òî ñòðóêòóðû SymbolTable
è AbstSyntax âêëþ÷àþò îäíó è òó æå ïîäñòðóêòóðó Symbol, è áëàãîäàðÿ
ýòîìó èñïîëüçóþò îäèí è òîò æå òèï ñèìâîëîâ. Íî òåïåðü â ParserFun
ôóíêöèÿ parse çíàåò òîëüêî ñèãíàòóðû ýòèõ äâóõ ñòðóêòóð, è íè÷åãî íå
çíàåò î òîì, êàê îíè ðåàëèçîâàíû. Ïîýòîìó ML-êîìïèëÿòîð óêàæåò íà
îøèáêó â ParserFun,  è íàøà èäåÿ èñïîëüçîâàíèÿ ôóíêòîðîâ äëÿ îáåñ-
ïå÷åíèÿ ìîäóëüíîãî ñòèëÿ ïðîãðàììèðîâàíèÿ îêàçûâàåòñÿ ïîä óãðîçîé.
Ñïàñòè äåëî ïîìîãàþò ñïåöèôèêàöèè ñîèñïîëüçîâàíèÿ. Èäåÿ ñîñòîèò
â òîì, ÷òîáû âêëþ÷èòü â ñèãíàòóðó PARSER_PIECES íàáîð ðàâåíñòâ, ãà-
ðàíòèðóþùèõ òîò ôàêò, ÷òî òîëüêî ïàðà ñîâìåñòèìûõ âàðèàíòîâ ñòðóê-
òóð (äëÿ ðàáîòû ñ òàáëèöåé ñèìâîëîâ è äëÿ ðàáîòû ñ äåðåâîì ñèíòàê-
ñè÷åñêîãî ðàçáîðà) ìîæåò áûòü ïåðåäàíà ôóíêòîðó ParserFun. Íîâûé
âàðèàíò ñèãíàòóðû PARSER_PIECES áóäåò âûãëÿäåòü ñëåäóþùèì îáðà-
çîì:
signature PARSER_PIECES =
sig
structure SymboiTable : SYMBOLTABLE
structure AbstSyntax: ABSTSYNTAX
sharing SymbolTable.Symbol = AbstSyntax.Symbol
end;
Ôðàçà sharing ãàðàíòèðóåò òî, ÷òî ìîæåò áûòü èñïîëüçîâàíà òîëüêî ñîâ-
ìåñòèìàÿ ïàðà ñòðóêòóð SymboiTable è AbstSyntax (ãäå ñîâìåñòèìàÿ
îçíà÷àåò èñïîëüçóþùàÿ îäíó è òó æå ñòðóêòóðó Symbol). Åñëè òåïåðü
ìû èñïîëüçóåì ýòó ìîäèôèöèðîâàííóþ ñèãíàòóðó, òî îáúÿâëåíèå ôóíê-
òîðà ParserFun ñòàíîâèòñÿ äîïóñòèìûì.
Â îáùåì ñëó÷àå èìååòñÿ äâå ôîðìû ñïåöèôèêàöèè ñîèñïîëüçîâàíèÿ
 îäíà äëÿ òèïîâ, à äðóãàÿ äëÿ ñòðóêòóð. Â ïîñëåäíåì ïðèìåðå ìû
èñïîëüçîâàëè ôîðìó äëÿ ñòðóêòóð  è îáåñïå÷èëè ñ ïîìîùüþ íåå òî,
÷òî îáå êîìïîíåíòû ïàðàìåòðà èñïîëüçóþò ðàâíûå ïîäñòðóêòóðû. Äâå
ñòðóêòóðû ðàâíû òîãäà è òîëüêî òîãäà, êîãäà îíè ïîëó÷åíû â ðåçóëüòà-
òå âû÷èñëåíèÿ îäíîãî òîãî æå îáúÿâëåíèÿ ñòðóêòóðû èëè ïðèìåíåíèÿ

3.5. ÌÎÄÓËÜÍÀß ÑÈÑÒÅÌÀ Â ÐÅÀËÜÍÎÉ ÏÐÀÊÒÈÊÅ
89
îäíîãî è òîãî æå ôóíêòîðà ê ðàâíûì àðãóìåíòàì. Íàïðèìåð, ñëåäóþ-
ùàÿ ïîïûòêà ñôîðìèðîâàòü àðãóìåíòû äëÿ ôóíêòîðà ParserFun áóäåò
îòâåðãíóòà, ïîñêîëüêó îíà íå óäîâëåòâîðÿåò ñïåöèôèêàöèè sharing:
structure Pieces : PARSER_PIECES =
struct
structure SymboiTable = SymbolTableFun( SymbolFun() )
structure AbstSyntax = AbstSyntaxFun( SymbolFun() )
end;
Ïðè÷èíà çäåñü â òîì, ÷òî êàæäîå ïðèìåíåíèå SymbolFun ñîçäàåò íîâóþ
ñòðóêòóðó, îòëè÷íóþ îò âñåõ äðóãèõ.
Äðóãàÿ ôîðìà ñïåöèôèêàöèè ñîèñïîëüçîâàíèÿ èìååò äåëî ñ òèïàìè.
Íàïðèìåð, ñëåäóþùàÿ âåðñèÿ PARSER_PIECES áóäåò âïîëíå ïîäõîäÿùåé,
åñëè åäèíñòâåííîå, â ÷åì äîëæíû ñîâïàäàòü ñòðóêòóðû SymboiTable è
AbstSyntax  ýòî èñïîëüçóåìûé èìè òèï symbol:
signature PARSER_PIECES =
sig
structure SymboiTable : SYMBOLTABLE
structure AbstSyntax : ABSTSYNTAX
sharing SymboiTable.Symbol.symbol=AbstSyntax.Symbol.symbol
end;
Ðàâåíñòâî òèïîâ ïîäîáíî ðàâåíñòâó ñòðóêòóð: äâà òèïà ðàâíû, åñëè îíè
ïîëó÷åíû â ðåçóëüòàòå âû÷èñëåíèÿ îäíîãî è òîãî æå îáúÿâëåíèÿ. Òàê,
íàïðèìåð, åñëè äâà òèïà çàäàíû èäåíòè÷íûìè îáúÿâëåíèÿìè datatype,
îíè áóäóò ðàçëè÷íûìè.
Âîçâðàùàÿñü ê íàøåìó ïðèìåðó, ïîñìîòðèì, ÷òî ïðîèçîéäåò, åñëè ìû
íàøëè è èñïðàâèëè îøèáêó â ôóíêòîðå SymbolFun. ×òî ìû äîëæíû ñäå-
ëàòü ïîñëå ýòîãî? Âî-ïåðâûõ, êîíå÷íî, íåîáõîäèìî ïåðåêîìïèëèðîâàòü
SymbolFun. À çàòåì äîñòàòî÷íî ïîâòîðèòü ïðèâåäåííóþ âûøå ïîñëåäî-
âàòåëüíîñòü ïðèìåíåíèé ôóíêòîðîâ  íî ïîâòîðíîé êîìïèëÿöèè âñåõ
äðóãèõ ôóíêòîðîâ íå òðåáóåòñÿ.

90
ÃËÀÂÀ 3. ÌÎÄÓËÈ

Ãëàâà 4
Ââîä-âûâîä
ML îáåñïå÷èâàåò òîëüêî íåáîëüøîå êîëè÷åñòâî ïðèìèòèâîâ ââîäà-
âûâîäà, âûïîëíÿþùèõ ïîñèìâîëüíûé îáìåí ñ òåðìèíàëîì è ôàéëàìè.
Ôóíäàìåíòàëüíûì ïîíÿòèåì â ñèñòåìå ââîäà-âûâîäà ML ÿâëÿåòñÿ ïîòîê
ëèòåð  êîíå÷íàÿ èëè áåñêîíå÷íàÿ ïîñëåäîâàòåëüíîñòü ëèòåð. Èìååò-
ñÿ äâà ïîòîêîâûõ òèïà: instream  äëÿ ïîòîêîâ ââîäà, è outstream 
äëÿ ïîòîêîâ âûâîäà. Ïîòîê ââîäà ïîëó÷àåò ñâîè ëèòåðû îò èñòî÷íè-
êà (îáû÷íî ýòî òåðìèíàë èëè äèñêîâûé ôàéë), à ïîòîê âûâîäà ïîñûëà-
åò ñâîè ëèòåðû ïîëó÷àòåëþ (òàêæå îáû÷íî òåðìèíàëó èëè äèñêîâîìó
ôàéëó). Ïîòîê èíèöèàëèçèðóåòñÿ ïóòåì ïîäêëþ÷åíèÿ åãî ê èñòî÷íèêó
èëè ïîëó÷àòåëþ. Âõîäíîé ïîòîê ìîæåò èìåòü èëè íå èìåòü êîíåö; â òîì
ñëó÷àå, êîãäà êîíåö èìååòñÿ, ML îáåñïå÷èâàåò âîçìîæíîñòü ïðîâåðêè
óñëîâèÿ äîñòèæåíèÿ êîíöà âõîäíîãî ïîòîêà.
Îñíîâíûå ïðèìèòèâû ââîäà-âûâîäà íàõîäÿòñÿ â ñòðóêòóðå BasicIO;
åå ñèãíàòóðà BASICIO èìååò ñëåäóþùèé âèä:
signature BASICIO =
sig
(* Types and exceptions *)
type instream
type outstream
exception io_failure: string
(* Standard input and output streams *)
val std_in : instream
val std_out: outstream
(* Stream creation *)
91

92
ÃËÀÂÀ 4. ÂÂÎÄ-ÂÛÂÎÄ
val open_in : string -> instream
val open_out: string -> outstream
(* Operations on input streams *)
val input: instream * int -> string
val lookahead : instream -> string
val close_in : instream -> unit
val end_of_stream : instream -> bool
(* Operations on output streams *)
val output: outstream * string -> unit
val close_out: outstream -> unit
end;
Ñòðóêòóðà BasicIO àâòîìàòè÷åñêè îòêðûâàåòñÿ ïðè çàïóñêå ML-ñèñòå-
ìû, ïîýòîìó âñå óïîìÿíóòûå èäåíòèôèêàòîðû ìîãóò èñïîëüçîâàòüñÿ â
ïðîãðàììå áåç óïîìèíàíèÿ èìåíè ñòðóêòóðû.
Òèïû instream è outstream ÿâëÿþòñÿ òèïàìè ñîîòâåòñòâåííî âõîä-
íûõ è âûõîäíûõ ïîòîêîâ. Èñêëþ÷åíèå io_failure èñïîëüçóåòñÿ äëÿ èí-
ôîðìèðîâàíèÿ ïðîãðàììû î ëþáûõ îøèáêàõ, âîçíèêøèõ â ïðîöåññå ââî-
äà-âûâîäà. Çíà÷åíèå òèïà string, ñâÿçàííîå ñ ýòèì èñêëþ÷åíèåì, ñîäåð-
æèò èíôîðìàöèþ î âîçíèêøåé îøèáêå (îáû÷íî â ôîðìå ñîîáùåíèÿ îá
îøèáêå).
Ïîòîêè std_in è std_out àâòîìàòè÷åñêè ñâÿçûâàþòñÿ ñ òåðìèíàëîì1
(è íå äîëæíû îòêðûâàòüñÿ èëè çàêðûâàòüñÿ ïðèêëàäíîé ïðîãðàììîé).
Ïðèìèòèâû open_in è open_out èñïîëüçóþòñÿ äëÿ ñâÿçûâàíèÿ ïîòî-
êà ñ äèñêîâûì ôàéëîì. Â ðåçóëüòàòå âû÷èñëåíèÿ âûðàæåíèÿ open_in(s)
ñîçäàåòñÿ íîâûé âõîäíîé ïîòîê, ÷üèì èñòî÷íèêîì ÿâëÿåòñÿ ôàéë ñ èìå-
íåì s, è ýòîò ïîòîê ÿâëÿåòñÿ ðåçóëüòàòîì ýòîãî âûðàæåíèÿ. Åñëè ôàéëà
ñ èìåíåì s íå ñóùåñòâóåò, òî âîçáóæäàåòñÿ èñêëþ÷åíèå io_failure, à
ïàðàìåòðîì åå ñòàíîâèòñÿ ñòðîêà "Cannot open "^s. Àíàëîãè÷íî, âûðà-
æåíèå open_out(s) ñîçäàåò íîâûé âûõîäíîé ïîòîê, ÷üèì ïîëó÷àòåëåì
ÿâëÿåòñÿ ôàéë ñ èìåíåì s, è âîçâðàùàåò ýòîò ïîòîê â êà÷åñòâå ðåçóëü-
òàòà.
Ïðèìèòèâ ââîäà input èñïîëüçóåòñÿ äëÿ ÷òåíèÿ ïîñëåäîâàòåëüíîñòè
ëèòåð èç âõîäíîãî ïîòîêà. Â ðåçóëüòàòå âû÷èñëåíèÿ input(s,n), n ëèòåð
óäàëÿþòñÿ èç âõîäíîãî ïîòîêà, è ñôîðìèðîâàííàÿ èç íèõ ñòðîêà âîçâðà-
1Â îïåðàöèîííîé ñèñòåìå UNIX ýòè ïîòîêè ñâÿçûâàþòñÿ ñ ôàéëàìè ñòàíäàðòíîãî
ââîäà è âûâîäà, êîòîðûå ìîãóò áûòü ïîäêëþ÷åíû ëèáî ê òåðìèíàëó, ëèáî åùå êóäà-
òî.

93
ùàåòñÿ â êà÷åñòâå ðåçóëüòàòà. Åñëè â äàííûé ìîìåíò â ïîòîêå äîñòóïíî
ìåíåå n ëèòåð, òî ïðîãðàììà îæèäàåò, ïîêà âñå íåîáõîäèìûå ëèòåðû íå
ñòàíóò äîñòóïíûìè2. Åñëè â ïðîöåññå ââîäà äîñòèãàåòñÿ êîíåö ïîòîêà, òî
âîçâðàùàåìàÿ ñòðîêà ìîæåò ñîñòîÿòü ìåíåå ÷åì èç n ëèòåð. Â ÷àñòíîñòè,
ðåçóëüòàòîì ÷òåíèÿ èç çàêðûòîãî ïîòîêà áóäåò ïóñòàÿ ñòðîêà. Ôóíêöèÿ
lookahead(s) âîçâðàùàåò î÷åðåäíóþ ëèòåðó âõîäíîãî ïîòîêà s áåç óäà-
ëåíèÿ åå èç ïîòîêà. Ðàáîòà ñ âõîäíûì ïîòîêîì çàâåðøàåòñÿ ñ ïîìîùüþ
ôóíêöèè close_in. Îáû÷íî íåò íåîáõîäèìîñòè çàêðûâàòü âõîäíûå ïîòî-
êè, îäíàêî ðåêîìåíäóåòñÿ âñå-òàêè çàêðûâàòü âõîäíîé ïîòîê ïîñëå òîãî,
êàê ÷òåíèå èç íåãî çàâåðøåíî  èíà÷å ìîãóò âîçíèêíóòü íåïðèÿòíîñòè,
ñâÿçàííûå ñ îïåðàöèîííîé ñèñòåìîé. Êîíåö âõîäíîãî ïîòîêà ìîæåò áûòü
îïðåäåëåí ñ ïîìîùüþ ïðåäèêàòà end_of_stream, êîòîðûé îïèñàí êàê:
val end_of_stream(s) = (lookahead(s)="")
Ïðèìèòèâ output èñïîëüçóåòñÿ äëÿ çàïèñè ëèòåð â ïîòîê (èìåííî,
çàïèñûâàþòñÿ ëèòåðû èç ñòðîêè-àðãóìåíòà). Ôóíêöèÿ close_out çàâåð-
øàåò âûâîä. Ïîñëå òîãî, êàê âûõîäíîé ïîòîê çàêðûò, ëþáàÿ ïîïûòêà
âûâåñòè â íåãî ÷òî-òî âîçáóæäàåò èñêëþ÷åíèå io_failure ñ ïàðàìåòðîì
"Output stream is closed".
Â äîïîëíåíèå ê áàçèñíîìó íàáîðó ïðèìèòèâîâ ââîäà-âûâîäà ML òàê-
æå îáåñïå÷èâàåò íåñêîëüêî äîïîëíèòåëüíûõ ôóíêöèé. Îäíà èç íèõ 
input_line (òèïà instream -> string)  âûïîëíÿåò ÷òåíèå ñòðîêè èç
âõîäíîãî ïîòîêà. Ñòðîêà îïðåäåëÿåòñÿ êàê ïîñëåäîâàòåëüíîñòü ëèòåð,
çàâåðøàþùàÿñÿ ïðèçíàêîì êîíöà ñòðîêè \n. Äðóãàÿ  ôóíêöèÿ use òè-
ïà string list -> unit  ïîëó÷àåò â êà÷åñòâå àðãóìåíòà ñïèñîê èìåí
ôàéëîâ; â ðåçóëüòàòå åå âû÷èñëåíèÿ ñîäåðæèìîå óêàçàííûõ ôàéëîâ ïðî-
÷èòûâàåòñÿ ML-ñèñòåìîé òàê, êàê áóäòî áû îíî áûëî ââåäåíî íà âåðõíåì
óðîâíå äèàëîãà. ×àñòî ýòîò ïðèìèòèâ èñïîëüçóåòñÿ ïðè èíòåðàêòèâíîé
ðàáîòå äëÿ çàãðóçêè óæå ãîòîâîé ÷àñòè ïðîãðàììû.
Óïðàæíåíèå 4.0.1 Ìîäèôèöèðóéòå âàøó ïðîãðàììó ðåøåíèÿ çàäà÷è
ñ õàíîéñêèìè áàøíÿìè òàê, ÷òîáû îíà âûâîäèëà íàéäåííóþ ïîñëåäîâà-
òåëüíîñòü õîäîâ íà òåðìèíàë.
Óïðàæíåíèå 4.0.2 Íàïèøèòå ôóíêöèþ, ïå÷àòàþùóþ ðåøåíèå çàäà-
÷è î ôåðçÿõ â ôîðìå øàõìàòíîé äîñêè.
2Òî÷íûé ñìûñë ñëîâà äîñòóïíûå çàâèñèò îò ðåàëèçàöèè. Íàïðèìåð, îïåðàöè-
îííàÿ ñèñòåìà îáû÷íî áóôåðèçóåò ââîä ñ òåðìèíàëà, è ïåðåäàåò ïðîãðàììå ñòðîêó
öåëèêîì: â ýòîì ñëó÷àå ëèòåðû ñòàíîâÿòñÿ äîñòóïíûìè ïðîãðàììå ïîñëå íàæàòèÿ
êëàâèøè êîíöà ñòðîêè.

94
ÃËÀÂÀ 4. ÂÂÎÄ-ÂÛÂÎÄ

Ëèòåðàòóðà
[1] Harold Abelson and Gerald Sussman, Structure and Interpetation of
Computer Programs, The MIT Press, 1985.
[2] Rod Burstall, David MacQueen, and Donald Sannella, HOPE: An Ex-
perimental Applicative Language, Edinburgh University Interyal Report
CSR-62-80, 1980.
[3] Luca Cardelli, ML under UNIX, AT&T Bell Laboratories, 1984.
[4] Michael Gordon. Robin Milner, and Christopher Wadsworth, Edinburgh
LCF, Springer-Verlag Lecture Notes in Computer Science, vol. 78, 1979.
[5] Robert Harper. David MacQueen, and Robin Milner, Standard ML,
Edinburgh University Internal Report ECS-LFCS-86-2, March, 1986.
[6] David MacQueen. Modules for Standard ML, in [5].
[7] Robin Milner, Mads Tofte, and Robert Harper, The Denition of
Standard ML, MIT Press, 1990.
95

96
ËÈÒÅÐÀÒÓÐÀ

Ïðèëîæåíèå A
Îòâåòû
Îòâåò 2.3.1:
1. Unbound value identifier: x
2. > val x = 1 : int
> val ó = 3 : int
> val z = 2 : int
3. > 3:int
Îòâåò 2.4.1:
ML-ñèñòåìà áóäåò ïûòàòüñÿ ñîïîñòàâèòü hd::tl::nil ñ
"Eat"::"the"::"walnut"::nil. Ïîñêîëüêó ýòè ñïèñêè èìåþò
ðàçíóþ äëèíó, ñîïîñòàâëåíèå ïîòåðïèò íåóäà÷ó.
Îòâåò 2.4.2:
1. { b=õ, ... }
2. _::_::õ::_
èëè
[ _, _, õ, _, _]
3. [_, (õ, _)]
Îòâåò 2.5.1:
local val pi=3.141592654
in fun circumference r = 2.0 * pi * r
fun area r = pi * r * r
end
97

98
ÏÐÈËÎÆÅÍÈÅ A. ÎÒÂÅÒÛ
Îòâåò 2.5.2:
fun abs x = if x < 0.0 then -x else x
Îòâåò 2.5.3:
Äëÿ âû÷èñëåíèÿ fact(n) ïîòðåáóåòñÿ âû÷èñëèòü âûðàæå-
íèå new_if(n=0,1,fact(n-1)). Àðãóìåíòû ôóíêöèè âû÷èñ-
ëÿþòñÿ äî âû÷èñëåíèÿ ñàìîé ôóíêöèè; ïîýòîìó ïîòðåáó-
åòñÿ âû÷èñëèòü fact(n-1) (äàæå êîãäà n = 0!); âû÷èñëå-
íèå fact(n-1) ïî òåì æå ïðè÷èíàì ïîòðåáóåò âû÷èñëåíèÿ
fact(n-2)  è ò.ä.; âîçíèêíåò áåñêîíå÷íûé öèêë.
Îòâåò 2.5.5:
Ýòà ôóíêöèÿ íåýôôåêòèâíûì ñïîñîáîì âûïîëíÿåò ïåðåñòà-
íîâêó ýëåìåíòîâ ñïèñêà â îáðàòíîì ïîðÿäêå.
Îòâåò 2.5.6:
fun isperfect n =
let fun addfactors(1) = 1
| addfactors(m) =
if n mod m = 0 then m + addfactors(m-1)
else addfactors(m-l)
in (n<2) orelse (addfactors(n div 2) = n) end
Îòâåò 2.5.7:
fun cons h t = h::t
fun powerset [] = [[]]
| powerset(h::t) =
let val pst = powerset t
in (map (cons h) pst) @ pst end;
Îòâåò 2.5.8:
fun cc(0, _) = 1
| cc(_,[]) = 0
| cc(amount, kinds as (h::t)) =
if amount < 0 then 0
else cc(amount-h,kinds) + cc(amount,t);
fun count_change coins amount = cc(amount, coins);

99
Îòâåò 2.5.9:
fun nth(0,lst) = lst
| nth(n,h::t) = nth(n-1,t);
fun count_change coins sum =
let fun initial_table [] = [[0]]
| initial_table (h::t) = [] :: (initial_table t)
fun count(amount,table) =
let fun count_using([],lst) = lst
| count_using(h::t,h1::t1) =
let val t1' as ((c::_)::_) =
count_using(t,t1)
val diff = amount - h
val cnt = ñ + if diff<0 then 0
else if diff=0 then 1
else hd(nth(h-1,h1))
in (cnt::h1)::t1' end
in
if amount > sum
then hd(hd table)
else count(amount+1, count_using(coins,table))
end
in count (0, initiaHable coins) end
Îòâåò 2.5.10:
local
fun move_disk(from, to) = (from, to);
fun transfer(from, to, spare, 1) = [move_disk(from,to)]
| transfer(from, to, spare, n ) =
transfer(from, spare, to, n-1) @
[move_disk(from,to)] @
transfer(spare, to, from, n-1)
in fun tower_of_hanoi(n) = transfer("A","B","C",n) end
Àëüòåðíàòèâíîå ðåøåíèå, êîòîðîå ÿâíî ìîäåëèðóåò äèñêè è
ïðîâåðÿåò äîïóñòèìîñòü õîäîâ, ìîæåò áûòü çàïèñàíî ñëåäó-
þùèì îáðàçîì:
local
fun incl(m,n) = if m>n then 0 else m::incl(m+1,n)
fun move_disk((f,fh::fl), (t,[]), spare) =

100
ÏÐÈËÎÆÅÍÈÅ A. ÎÒÂÅÒÛ
((f,fl), (t,[fh]), spare)
| move_disk((f,fh::fl), (t,tl as (th::tt)), spare) =
if (fh:int) > th then error "Illegal move"
else ((f,fl), (t,fh::tl), spare)
fun transfer(from, to, spare, 1) =
move_disk(from, to, spare)
| transfer(from, to, spare, n) =
let val (f1,s1,t1) = transfer(from,spare,to,n-1)
val (f2,t2,s2) = move_disk(f1,t1,s1)
val (s3,t3,f3) = transfer(s2,t2,f2,n-1)
in (f3,t3,s3) end
in
fun tower_of_hanoi(n) =
transfer(("A", incl(1,n)), ("B", []), ("C", []), n)
end
Îòâåò 2.7.1:
fun samefrontier(empty,empty) = true
| samefrontier(leaf x, leaf ó) = x=y
| samefrontier(node(empty,t1),node(empty,t2)) =
samefrontier(t1,t2)
| samefrontier(node(leaf x,t1), node(leaf y,t2)) =
x=y andalso samefrontier(t1,t2)
| samefrontier(t1 as node _, t2 as node _) =
samefrontier(adjust t1, adjust t2)
| samefrontier(_,_) = false
and adjust(x as node(empty,_)) = x
| adjust(x as node(leaf _,_)) = x
| adjust(node(node(t1,t2),t3)) =
adjust(node(t1,node(t2,t3)))
Ïðèâåäåì è äðóãîå ðåøåíèå, èñïîëüçóþùåå èñêëþ÷åíèÿ (ñì.
ðàçäåë 2.8):
fun sameftrontier(treel,tree2) =
let
exception samefringe : unit
fun check_el(empty,empty,rest_t2) = rest_t2
| check_el(leaf x, leaf y, rest_t2 ) =
if x=y then rest_t2 else raise samefringe

101
| check_el(el,node(l,r), rest_t2) =
check_el(el, l, r::rest_t2)
| check_el(_,_,_) =
raise samefringe
fun check(_, []) =
raise samefringe
| check(empty,tree2) =
check_el(empty, hd tree2, tl tree2)
| check(l as leaf(el),tree2) =
check_el(l, hd tree2, tl tree2)
| check(node(t1,t2),tree2) =
check(t2, check(t1,tree2))
in
null (check(tree1,[tree2])) handle samefringe => false
end
Îòâåò 2.7.2:
abstype 'a set = set of 'a list
with
val emptyset = set []
fun singleton e = set []
fun union(set l1, set l2) = set (l1 @ l2)
fun member(e, set []) = false
| member(e, set(h::t)) =
(e=h) orelse member(e, set t)
fun intersection(set [], s2) = set []
| intersection(set(h::t), s2) =
let val tset as (set tl) =
intersection(set t, s2)
in if member(h,s2) then set(h::tl) else tset end
end
Îòâåò 2.7.3:
abstype 'a set = set of ('a list *
{eq : 'a*'a->bool, lt : 'a*'a->bool})
with
fun emptyset ops = set([],ops)
fun singleton(e,ops) = set([e],ops)
fun member(e,set(l,{eq,lt}) =

102
ÏÐÈËÎÆÅÍÈÅ A. ÎÒÂÅÒÛ
let fun find [] = false
| find(h::t) = if eq(e,h) then true
else if lt(e,h) then false
else find(t)
in find l end
fun union(set(lst, ops as {eq,lt}), set(lst',_)) =
let fun merge([],lst) = lst
| merge(lst,[]) = lst
| merge(l1 as (h1::t1), l2 as (h2::t2)) =
if eq(h1,h2) then h1::merge(t1,t2)
else if lt(h1,h2) then h1::merge(t1,t2)
else h2::merge(t1,t2)
in set(merge(lst,lst'),ops) end
fun intersect(set(lst, ops as {eq,lt}), set(lst',_)) =
let fun inter([],lst) = []
| inter(lst, []) = []
| inter(l1 as (h1::t1), l2 as (h2::t2)) =
if eq(h1,h2) then h1::inter(tl,t2)
else if lt(h1,h2) then inter(t1,l2)
else merge(l1,t2)
in set(inter(lst,lst'), ops) end
end
Îòâåò 2.8.1:
1. Èñêëþ÷åíèå, ïðèâÿçàííîå ê Exn âíå let, îòëè÷àåòñÿ îò
ïðèâÿçàííîãî ê Exn âíóòðè let. Ïîýòîìó èñêëþ÷åíèå,
âîçíèêàþùåå â ïðîöåññå âû÷èñëåíèÿ f(200) (èìåþùåå
öåëî÷èñëåííûé ïàðàìåòð 200), ìîæåò áûòü îáðàáîòàíî
òîëüêî îáðàáîò÷èêîì èñêëþ÷åíèé âíóòðè let  è íå ìî-
æåò áûòü îáðàáîòàíî âíåøíèì îáðàáîò÷èêîì (êîòîðûé,
ê òîìó æå, îæèäàåò ïàðàìåòðà òèïà bool). Â ðåçóëüòàòå
ñîîáùåíèå î âîçíèêíîâåíèè íåîáðàáîòàííîãî èñêëþ÷å-
íèÿ áóäåò âûäàíî íà âåðõíåì óðîâíå äèàëîãà. Ñèòóàöèÿ
íå èçìåíèòñÿ è â òîì ñëó÷àå, åñëè âíåøíåå èñêëþ÷åíèå
áóäåò îáúÿâëåíî êàê ïîëó÷àþùåå ïàðàìåòð òèïà int 
îáà èñêëþ÷åíèÿ ïî-ïðåæíåìó îñòàíóòñÿ ðàçëè÷íûìè.
2. Åñëè ïðè âû÷èñëåíèè f(v) îêàæåòñÿ, ÷òî p(v) ëîæíî, a
q(v) èñòèííî, òî áóäåò ðåêóðñèâíî âûçâàíà ôóíêöèÿ f
ñ ïàðàìåòðîì b(v). Äàëåå, åñëè p(b(v)) è q(b(v)) îêà-
æóòñÿ ëîæíûìè, áóäåò âûðàáîòàíî èñêëþ÷åíèå Exn. Íî

103
ýòî èñêëþ÷åíèå íå áóäåò îáðàáîòàíî ïðèâåäåííûì â ïðè-
ìåðå îáðàáîò÷èêîì, ïîñêîëüêó óêàçàííîå â íåì èñêëþ-
÷åíèå Exn åñòü êîíñòðóêòîð, ñîçäàííûé ïðè âû÷èñëåíèè
f(v)  à âûðàáîòàííîå Exn åñòü êîíñòðóêòîð, ñîçäàí-
íûé ïðè âû÷èñëåíèè f(b(v))  è ýòî äâå ðàçíûå âåùè.
(Åùå ðàç îáðàùàåì âíèìàíèå íà òî, ÷òî âñå îîáúÿâëå-
íèÿ âíóòðè îáúÿâëåíèÿ ôóíêöèè èñïîëíÿþòñÿ êàæäûé
ðàç ïðè ðåêóðñèâíîì âûçîâå, è ïðè ýòîì âûïîëíÿåòñÿ
íîâàÿ ïðèâÿçêà èäåíòèôèêàòîðîâ).
Îòâåò 2.8.2:
fun threat((x::int,y), (x',y')) =
(õ=õ')
orelse (y=y')
orelse (õ+ó=õ'+ó')
orelse (x-y=x'-y')
fun conflict(pos, []) = false
| conflict(pos, h::t) =
threat(pos, h) orelse conflict(pos, t)
exception Conflict;
fun addqueen(l,n,place) =
let fun tryqueen(j) =
( if conflict((i,j), place) then raise Conflict
else if i=n then (i,j)::place
else addqueen(l+1, n, (i,j)::place) )
handle Conflict =>
if j=n then raise Conflict else tryqueen(j+1)
in tryqueen(1) end
fun queens(n) = addqueen(1, n, [])
Îòâåò 2.8.3:
exception Conflict of ((int*int) list) list
fun addqueen(l,n,place,places) =
let fun tryqueen(j, places) =
( if conflict ((i,j), place)

104
ÏÐÈËÎÆÅÍÈÅ A. ÎÒÂÅÒÛ
then raise Conflict(((i,j)::place)::places)
else addqueen (1+1, n, (ij)::place, places) )
handle Conflict newplace =>
if j=n then raise Conflict(newplace)
else tryqueen(j+1,newplaces)
in tryqueen(1,places) end
fun allqueens(n) = addqueen(1, n, [], [])
handle Conflict(places) => places
Îòâåò 2.9.1:
val primes =
let fun nextprime(n,l) =
let fun check(n,[]) = n
| check(n,h::t) = if (n mod h) = 0
then check(n+1,l)
else check(n,t)
in check(n,l) end
fun primstream(n,l) =
mkstream (fn () =>
let val n'=nextprime(n,l)
in (n', primstream(n'+1,n'::l)) end)
in primstream(2, []) end
Îòâåò 2.9.2:
abstype 'a stream =
stream of ( unit -> ('a * 'a stream)) ref
with fun next(stream f) =
let val res = (!f)()
in (f := fn() => res; res) end
fun mkstream f = stream(ref f)
end
Ïðèâåäåì äðóãîå ðåøåíèå  áîëåå ìíîãîñëîâíîå, íî, âîçìîæ-
íî, áîëåå ïîíÿòíîå:
abstype 'a stream = stream of 'a streamelmt ref
and 'a streamelmt = uneval of (unit -> ('a*'a stream))
| eval of 'a*'a stream
with fun next(stream(r as ref(uneval(f)))) =

105
let val res=f() in (r := eval res; res ) end
| next ( stream (ref(eval(r)))) = r
fun mkstream f = stream(ref(uneval f))
end
Îòâåò 2.9.3:
abstype 'a stream =
stream of (unit -> ('a * 'a stream)) ref
with local exception EndOfStream in
fun next(stream f) =
let val res = (!f)()
in (f := fn () => res; res)
end
fun mkstream f = stream (ref f)
fun emptystream() =
stream(ref (fn () => raise EndOfStream))
fun endofstream(s) =
(next s; false) handle endofstream => true
end
end
Îòâåò 3.2.1:
structure INTORD : ORD =
struct
type t = int
val le : int*int -> bool = op <
end
structure RSORD : ORD =
struct
type t = real*string
fun le((r1:real, s1:string), (r2,s2)) =
(r1 < r2) oresle ((r1 = r2) andalso (s1 < s2)) end
Îòâåò 3.2.2:
Ñèãíàòóðà óêàçûâàåò, ÷òî òèï n åñòü 'a list; îòñþäà, â ÷àñò-
íîñòè, ñëåäóåò, ÷òî åñëè ñòðóêòóðà T ñîïîñòàâèìà ñ ñèãíàòó-
ðîé SIG, òî âûðàæåíèå true::(T,n) äîëæíî áûòü äîïóñòè-
ìûì. Ýòî óñëîâèå íå áóäåò âûïîëíåíî â íàøåì ïðèìåðå, ïî-
ñêîëüêó n èìååò áîëåå êîíêðåòíûé òèï, à èìåííî int list.

106
ÏÐÈËÎÆÅÍÈÅ A. ÎÒÂÅÒÛ
Ïîýòîìó äàííîå îïðåäåëåíèå êîìïèëÿòîð ïðèçíàåò îøèáî÷-
íûì.
Îòâåò 3.2.3:
sig type 'a t val x : bool*int end
è
sig type 'a t vai x : bool t end
Îòâåò 3.2.4:
Òîëüêî ñèãíàòóðà B óäîâëåòâîðÿåò ïðàâèëó çàìêíóòîñòè ñèã-
íàòóðû (âñå îñòàëüíûå ñîäåðæàò îòêðûòûå ññûëêè íà ñòðóê-
òóðó À).
Îòâåò 3.2.5:
signature STACK =
sig
datatype 'a stack = nilstack | push of 'a * 'a stack
exception pop and top
val empty : 'a stack -> bool
and pop : 'a stack -> 'a stack
and top : 'a stack -> 'a
end
structure Stack : STACK =
struct
datatype 'a stack = nilstack | push of 'a * 'a stack
exception pop and top
fun empty(nilstack) = true
| empty _ = false
fun pop(push(_,s)) = s
| pop _ = raise pop
fun top(push(x, _)) = x
| top _ = raise top
end
Îòâåò 3.2.6:
structure Exp : EXP =
struct
datatype id = Id of string

107
datatype exp = Var of id
| App of id * (exp list)
end
signature SUBST =
sig
structure E : EXP
type subst
val subst: (E.id * E.exp) list -> subst
val lookup : E.id * subst -> E.exp
val substitute : subst -> E.exp -> E.exp
end
structure Subst: SUBST =
struct
structure E = Exp
type subst = (E.id * E.exp) list
fun subst(x) = x
fun lookup(id, Q) = E.Var id
| lookup (id, (id',e)::l) =
if id=id' then e else lookup(id,l)
fun substitute s (E.Var id) = lookup(id.s)
| substitute s (E.App(id.args)) =
E.App(id, map(substitute s) args)
end
Îòâåò 3.3.1:
abstraction Rect: COMPLEX =
struct
datatype complex = rect of real*real
exception divide
fun rectangular{real,imag} =
rect(real,imag)
fun plus(rect(a,b), rect(c,d)) = rect(a+c, b+d)
fun minus(rect(a,b), rect(c,d)) = rect(a-c, b-d)
fun times(rect(a,b), rect(c,d)) =
rect(a*c-b*d, a*d+b*c)
fun divide(rect(a,b), rect(c,d)) =
let val cd2 = c*c+d*d in
if cd2=0.0 then raise divide

108
ÏÐÈËÎÆÅÍÈÅ A. ÎÒÂÅÒÛ
else rect ((a*c+b*d)/cd2, (b*c-a*d)/cd2 )
end
fun eq(rect(a,b), rect(c,d)) = (a=c) andalso (b=d)
fun real_part(rect(a,_)) = a
fun imag_part(rect(_,b)) = b
end
Îòâåò 3.4.1:
signature ORD =
sig
type elem
val eq : elem*elem -> bool
val le : elem*elem -> bool
end
signature SET =
sig
type set
structure Î : ORD
val emptyset: set
val singleton : O.elem -> set
val member: O.elem * set -> bool
val union : set * set -> set
val intersect: set * set -> set
end
functor Set(Î : ORD) : SET =
struct
datatype set = set of O.elem list
structure O = O
val emptyset = set []
fun singleton e = set [e]
fun member(e, set l) =
let fun find [] = false
| find (h::t) = if O.eq(e,h) then true
else if O.lt(e,h) then false
else find(t)
in find l end
fun union(set l, set l') =
let fun merge([],l) = l

109
| merge(l,[]) = l
| merge(l1 as (h1::t1), l2 as (h2,t2)) =
if O.eq(h1,h2) then h1::merge(t1,t2)
else if O.lt(h1,h2) then h1::merge(t1,l2)
else h2::merge(l1,t2)
in set(merge(l,l')) end
fun intersect(set l, set l') =
let fun inter([],l) = []
| inter(l, []) = []
| inter(l1 as (h1::t1), l2 as (h2::t2)) =
if O.eq(h1,h2) then h1::inter(t1,t2)
else if O.lt(h1,h2) then inter(t1,l2)
else inter(l1,t2))
in set(inter(l,l')) end
end
Îòâåò 4.0.1:
local
fun incl(m,n) = if m>n then [] else m::incl(m+1,n)
fun move_disk ((f, fh::fl), (t, tl), spare) =
if not(null tl) andalso (fh:int) > hd tl
then error "Illegal move"
else (output (std_out,
"Move " ^ (makestring fh) ^
" from " ^ f ^ " to " ^ t ^ "\n" );
((f,fl), (t,fh::tl), spare))
fun transfer(from, to, spare, 1) =
move_disk (from, to, spare)
| transfer(from, to, spare, n) =
let val (f1,s1,t1) =
transfer (from, spare, to, n-1)
val (f2,t2,s2) = move_disk(f1, t1, s1)
val (s3,t3,f3) = transfer(s2, t2, f2, n-1)
in (f3,t3,s3)
end
in
fun tower_of_hanoi(n) =
(transfer(("A",incl(1,n)), ("B",[]), ("C",[]), n); ())
end

110
ÏÐÈËÎÆÅÍÈÅ A. ÎÒÂÅÒÛ
Îòâåò 4.0.2:
fun printboard(place,n,s) =
let fun present(pos : (int*int), []) = false
| present(pos, h::t) =
(pos=h) orelse present(pos,t)
fun printcolumn(i, j) =
if j>n then ()
else ( output (s, if present((i,j),place)
then " Q "
else " . ");
printcolumn(i,j+1) )
fun printrow(i) =
if i>n then ()
else ( printcolumn(ij);
output(s,"\n");
printfow(i+1) )
in ( printrow(1); output(s,"\n") )
end

