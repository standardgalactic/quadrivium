An Interdisciplinary Approach
Robert Sedgewick
Kevin Wayne

Introduction
to
Programming in Java

Introduction
to
Programming in Java
An InterdisciplinaryApproach
Robert Sedgewick
and
KevinWayne
Princeton University
Boston San Francisco NewYork
London Toronto Sydney Tokyo Singapore Madrid
Mexico City Munich Paris Cape Town Hong Kong Montreal

Publisher
GregTobin
Executive Editor
Michael Hirsch
Associate Editor
LindseyTriebel
Associate ManagingEditor
Jeffrey Holcomb
SeniorDesigner
Joyce Cosentino Wells
Digital Assets Manager
Marianne Groth
SeniorMediaProducer
BethanyTidd
SeniorMarketingManager
Michelle Brown
MarketingAssistant
SarahMilmore
SeniorAuthor Support/
Technology Specialist
JoeVetere
SeniorManufacturingBuyer
CarolMelville
Copyeditor
Genevieve d'Entremont
Composition andIllustrations
Robert Sedgewick andKevin Wayne
Cover Image: ©RobertSedgewick and Kevin Wayne
Page 353 ©2006 C.Herscovici, Brussels / Artists Rights Society (ARS), NewYork Banque d' Images, ADAGP / Art
Resource, NY
Many ofthe designations used by manufacturers and sellers todistinguish their products are claimed as trade
marks. Where those designations appear inthis book, and Addison-Wesley was aware ofatrademark claim, the
designations have beenprinted ininitial caps orallcaps.
The interior of this book wascomposedin AdobeInDesign.
LibraryofCongressCataloging-in-Publication Data
Sedgewick, Robert,1946-
Introduction toprogramming inJava: aninterdisciplinary approach / byRobert Sedgewick andKevin Wayne.
p. cm.
Includes index.
ISBN978-0-321-49805-2(alk.paper)
1. Java (Computer program language) 2. Computer programming. I.Wayne, Kevin Daniel, 1971- II.Title.
QA76.73.J38S413 2007
005.13'3-dc22
2007020235
Copyright ©2008 Pearson Education, Inc. All rights reserved. No partof this publication may be reproduced,
stored in a retrieval system, or transmitted, in anyform or byanymeans, electronic, mechanical, photocopying,
recording, or otherwise, without theprior written permission of thepublisher. Printed in theUnited States of
America. Forinformationon obtainingpermissionforuseofmaterialin thiswork,pleasesubmitawrittenrequest
to PearsonEducation,Inc., Rightsand Contracts Department, 501BoylstonStreet,Suite900,Boston,MA02116,
fax(617)671-3447, or online at http: //www.pearsoned. com/1egal /permi ssi ons. htm.
ISBN-13:978-0-321-49805-2
ISBN-10:0-321-49805-4
123456789 10—CRW—11 10 09 08 07

The basis for educationin the lastmillenniumwas "reading, writing,and arith
metic;" now it isreading, writing, andcomputing. Learning to program isan
essential part of the education of every student in the sciences and engineering.
Beyond direct applications, it isthefirst step in understanding thenatureofcom
puter science's undeniable impact on the modern world.This book aims to teach
programming to those who need or want to learn it, in a scientific context.
Our primary goal is to empower students by supplying the experience and
basic tools necessary to use computation effectively. Ourapproach isto teach stu
dents thatwriting a program isa natural, satisfying, andcreative experience (not
an onerous task reserved for experts). We progressively introduce essential con
cepts, embrace classic applications from applied mathematics and the sciences to
illustrate theconcepts, andprovide opportunities for students to write programs
to solveengagingproblems.
We usetheJava programming language foralloftheprograms inthisbook—
we refer to Java after programming in thetitle to emphasize theidea thatthebook
isaboutfundamental concepts inprogramming, not Java per se. This bookteaches
basic skills forcomputational problem-solving thatare applicable inmanymodern
computing environments, and is a self-contained treatment intended for people
withno previous experience in programming.
Thisbook isan interdisciplinary approachto the traditional CS1 curriculum,
where we highlight the role of computing in otherdisciplines, frommaterials sci
enceto genomics to astrophysics to network systems. This approach emphasizes
for studentsthe essential idea that mathematics, science, engineering, and com
puting are intertwinedin the modern world. While it is a CS1 textbookdesigned
for anyfirst-year college studentinterested in mathematics, science, or engineer
ing (including computerscience), the bookalso canbe usedfor self-study or as a
supplementin a coursethat integrates programmingwith another field.

VI
Coverage
The bookisorganized around fourstages oflearning to program: ba
sic elements, functions, object-oriented programming, and algorithms (with data
structures). We provide thebasic information readers need to buildconfidence in
writing programs ateach level before moving tothenext level. An essential feature
of our approach isto use example programs that solve intriguing problems, sup
ported with exercises ranging from self-study drills to challenging problems that
call for creative solutions.
Basic elements include variables, assignment statements, built-in types of
data,flow of control (conditionals and loops), arrays, and input/output, including
graphics and sound.
Functions andmodules are the student's first exposure to modular program
ming. We build upon familiarity with mathematical functions to introduce Java
static methods, and then consider the implications of programming with func
tions, including libraries of functions and recursion. We stress the fundamental
idea ofdividing a program into components thatcan beindependently debugged,
maintained, and reused.
Object-orientedprogrammingisourintroduction to data abstraction. We em
phasize the concepts ofadata type (aset ofvalues and aset ofoperations onthem)
and an object (an entity that holds a data-type value) and their implementation
using Java's class mechanism. We teach students how to use, create, anddesign data
types. Modularity, encapsulation, and other modern programming paradigms are
the central concepts of this stage.
Algorithms and data structures combine these modern programming para
digms with classic methods of organizing and processing data thatremain effec
tive for modern applications. We provide an introduction to classical algorithms
for sorting and searching as well as fundamental data structures (including stacks,
queues, and symbol tables) and their application, emphasizing theuse ofthescien
tificmethod to understand performance characteristics of implementations.
Applications in science and engineering are a key feature ofthetext. We moti
vate eachprogrammingconceptthat weaddress by examiningits impact on spe
cific applications. We draw examples from applied mathematics, the physical and
biological sciences, andcomputer science itself, andinclude simulation ofphysical
systems, numerical methods, data visualization, sound synthesis, image process
ing, financial simulation, andinformation technology. Specific examples include a
treatment in the firstchapterof Markov chains for webpageranks and case stud
iesthat addressthe percolation problem,N-body simulation, and the small-world

phenomenon. These applications are anintegral partofthetext. They engage stu
dents in thematerial, illustrate theimportance oftheprogramming concepts, and
provide persuasive evidence of the critical role played bycomputation in modern
scienceand engineering.
Our primary goalisto teach the specific mechanismsand skills that are need
edto develop effective solutions toanyprogramming problem. We workwithcom
plete Java programs andencourage readers touse them. We focus onprogramming
byindividuals, not library programming or programming in the large (which we
treat briefly in an appendix).
Use in the Curriculum
This book is intended for a first-year college course
aimed at teaching novices to program in the context of scientific applications.
Taught from thisbook, prospective majors in any area of science and engineering
will learnto programin a familiar context. Students completing a course basedon
this bookwillbe well-prepared to apply their skills in latercourses in science and
engineering and to recognize when further education in computer science might
be beneficial.
Prospective computer science majors, in particular, canbenefit fromlearning
to program in the contextof scientific applications. Acomputerscientist needsthe
same basic background in the scientific method andthesame exposure to the role
ofcomputation in science as does abiologist, anengineer, or a physicist.
Indeed, our interdisciplinary approach enables colleges and universities to
teach prospective computer science majors andprospective majors in otherfields
ofscience andengineering inthesame course. We cover thematerial prescribed by
CS1, but our focus on applications brings life to the concepts and motivates stu
dents to learn them. Ourinterdisciplinary approach exposes students to problems
in manydifferent disciplines, helping themto morewisely choose a major.
Whatever thespecific mechanism, theuse ofthis bookisbestpositioned early
in the curriculum. First, this positioning allows us to leverage familiar material
in high school mathematics and science. Second, students who learnto program
early intheircollege curriculum will thenbeable touse computers moreeffectively
whenmoving on to courses in their specialty. Like reading and writing, program
ming is certain to be an essential skill for any scientistor engineer. Students who
have grasped the concepts in thisbookwill continually develop that skill through a
lifetime,reaping the benefitsof exploitingcomputation to solve or to better under
stand the problems and projects that arise in their chosen field.
VII

VIII
Prerequisites
Thisbook is meant to be suitable for typical science and engi
neering students in theirfirst year ofcollege. Thatis, we do notexpect preparation
beyond what is typically required for other entry-level science and mathematics
courses.
Mathematical maturity isimportant. While we do not dwell on mathematical ma
terial,we do referto the mathematics curriculum that students havetaken in high
school, including algebra, geometry, andtrigonometry. Moststudents in our target
audience (those intending to major in thesciences and engineering) automatically
meetthese requirements. Indeed, we take advantage of their familiarity with the
basic curriculum to introduce basic programming concepts.
Scientific curiosity isalso anessential ingredient. Science andengineering students
bring with them asense offascination intheability ofscientific inquiry tohelp ex
plain what goes oninnature. We leverage this predilection with examples ofsimple
programs that speak volumes aboutthenaturalworld. We do not assume anyspe
cific knowledge beyond thatprovided bytypical highschool courses inmathemat
ics,physics, biology, or chemistry.
Programming experience is not necessary, but also is not harmful. Teaching pro
gramming isour primary goal, sowe assume no prior programming experience.
But writing a program to solve anew problem isa challenging intellectual task, so
students who have written numerous programs in high school can benefit from
taking an introductory programming course based on this book (just as students
whohave writtennumerous essays inhighschool canbenefit fromanintroductory
writing course in college). The book cansupport teaching students withvarying
backgrounds because theapplications appeal tobothnovices andexperts alike.
Experience using a computer isalso not necessary, but also isnot at all a problem.
College students use computers regularly, to communicate withfriends and rela
tives, listento music, process photos,and manyother activities. The realization that
they can harness the power of their own computer in interesting and important
ways is an excitingand lastinglesson.
In summary,virtuallyallstudentsin science and engineeringare prepared to takea
course based on this book as a part of their first-semester curriculum.

Goals
What can instructors of upper-level courses in science and engineering
expect of students who havecompleteda coursebased on this book?
We cover the CS1 curriculum, but anyone who has taught an introductory
programming course knows that expectations of instructors in later courses are
typicallyhigh: eachinstructorexpects allstudentstobefamiliar withthe computing
environment and approach that he or she wants to use.A physics professor might
expectsome students to design a program overthe weekendto run a simulation; an
engineeringprofessormight expectother students to be usinga particular package
to numericallysolvedifferentialequations; or a computer scienceprofessor might
expect knowledge of the details of a particular programming environment. Is it
realistic to meetsuchdiverse expectations? Should therebeadifferent introductory
coursefor eachset of students? Colleges and universities have beenwrestling with
such questions sincecomputers came into widespread use in the latter part of the
20thcentury. Our answer to them isfound in thiscommonintroductory treatment
of programming, which is analogous to commonly accepted introductorycourses
in mathematics, physics, biology, and chemistry. An Introduction to Programming
strives to provide the basic preparation needed by all students in scienceand en
gineering,while sending the clearmessage that there is much more to understand
about computer science than programming. Instructors teaching students who
have studiedfrom this book can expect that theyhave the knowledge and experi
encenecessaryto enablethem to adapt to newcomputational environments and to
effectively exploit computers in diverse applications.
What can students who havecompleteda coursebased on this book expect to ac
complish in later courses?
Our message is that programming is not difficult to learn and that harness
ing the power of the computer is rewarding. Students who master the material in
this book are prepared to address computational challenges wherever they might
appear later in their careers. Theylearn that modern programming environments,
such as the one provided by Java, help open the door to any computational prob
lem they might encounter later, and they gain the confidence to learn, evaluate,
and use other computational tools. Students interested in computer science will be
well-prepared to pursue that interest; students in science and engineering will be
ready to integrate computation into their studies.
IX

Booksite
An extensiveamount of information that supplements this text may
be found on the web at
http://www.cs.pri nceton.edu/IntroProgramming
For economy, we refer to this siteasthe booksite throughout.It contains material
for instructors, students, and casual readers of the book. We briefly describe this
materialhere,though,asallwebusers know, it isbestsurveyed bybrowsing. With a
fewexceptions to support testing,the material is allpubliclyavailable.
One of the most important implications of the booksite is that it empow
ers instructors and students to use their own computers to teach and learn the
material. Anyone with a computer and a browser can begin learning to program
by following a few instructions on the booksite. The process is no more difficult
than downloading a media player or a song. As with any website, our booksite is
continually evolving. Itisanessential resource foreveryone whoowns thisbook.In
particular, the supplemental materials arecritical to our goal of making computer
science an integralcomponentofthe education of allscientists and engineers.
For instructors, the booksite contains information about teaching. This in
formation is primarilyorganized around a teaching style that we have developed
over the past decade, where we offer two lectures per week to a large audience,
supplemented bytwoclass sessions perweek where studentsmeetin small groups
with instructorsor teaching assistants. Thebooksite haspresentationslides for the
lectures, which set the tone.
For teaching assistants, the booksite containsdetailedproblem sets and pro
gramming projects, which arebased on exercises fromthe bookbut containmuch
more detail.Eachprogramming assignmentisintended to teach a relevantconcept
in the contextof an interestingapplicationwhilepresentingan invitingand engag
ing challenge to each student. The progression of assignments embodies our ap
proach to teachingprogramming.The booksitefullyspecifies all the assignments
and providesdetailed, structured information to help students complete them in
the allotted time, including descriptions of suggested approaches and outlines for
what should be taught in classsessions.
For students, the booksite contains quick accessto much of the material in the
book, including source code, plus extra material to encourage self-learning. Solu
tions are provided for many of the book's exercises, including complete program
code and test data. There is a wealth of information associated with programming
assignments, including suggested approaches, checklists, FAQs, and test data.

For casual readers (including instructors, teaching assistants, and students!),
the booksite is a resource for accessing allmanner of extra information associated
with the book's content. Allof the booksite content providesweb links and other
routes to pursue more information about the topic under consideration. There is
far more information accessible than anyindividualcouldfullydigest,but our goal
is to provide enough to whet any reader's appetite for more information about the
book's content.
Acknowledgements
Thisproject hasbeenunder development since 1992, so
far too many people have contributed to its success for us to acknowledge them
allhere. Special thanks are due to Anne Rogers for helpingto start the ball rolling;
to Dave Hanson, Andrew Appel,and Chris van Wyk, for their patience in explain
ing data abstraction; and to Lisa Worthington, for being the first to truly relish
the challengeof teaching this material to first-year students. Wealso gratefullyac
knowledge the efforts of /dev/126 (the summer students who have contributed
so much of the content); the faculty, graduate students, and teaching staff who
havededicated themselves to teachingthis material over the past 15yearshere at
Princeton; and the thousands of undergraduates who havededicatedthemselves to
learning it.
Robert Sedgewick
Madeira, Portugal
Kevin Wayne
SanFrancisco, California
July, 2007
XI


Preface
v
Elements of Programming
3
1.1
Your First Program
4
1.2
Built-in Typesof Data
14
1.3
Conditionals and Loops
46
1.4
Arrays
86
1.5
Input and Output
120
1.6
Case Study: Random WebSurfer
162
Functions and Modules
183
2.1
Static Methods
184
2.2
Libraries and Clients
218
2.3
Recursion
254
2.4
Case Study: Percolation
286
Object-Oriented Programming
315
3.1
Data Types
316
3.2
Creating Data Types
370
3.3
Designing Data Types
416
3.4
Case Study: N-body Simulation
456
Algorithms and Data Structures
471
4.1
Performance
472
4.2
Sorting and Searching
510
4.3
Stacks and Queues
550
4.4
Symbol Tables
608
4.5
Case Study: SmallWorld
650
Context
695
Index
699
XIII


1.1
Your First Program
4
1.2
Built-in Types of Data
14
1.3
Conditionals and Loops
46
1.4
Arrays
86
1.5
Input and Output
120
1.6
Case Study: Random Web Surfer. . . 162
Our goal in this chapter isto convinceyou that writing a program is easier than
writing a piece of text, such as a paragraph or essay. Writing prose is difficult:
wespend many years in school to learn how to do it. Bycontrast, just a fewbuilding
blockssufficeto enable us to write programs that can help solveallsorts offascinat
ing, but otherwise unapproachable, problems. In this chapter, we take you through
these building blocks, get you started on programming in Java,and study a variety
of interesting programs. You willbe able to expressyourself (bywriting programs)
within just a few weeks. Like the ability to write prose, the ability to program is a
lifetime skillthat you can continually refinewellinto the future.
In this book, you willlearn the Javaprogramming language.This task will be
much easier for you than, for example, learning a foreign language. Indeed, pro
gramming languages are characterized by no more than a few dozen vocabulary
words and rules of grammar. Much of the material that wecoverin this book could
be expressedin the C or C++ languages, or any of severalother modern program
ming languages.But we describe everything specifically in Javaso that you can get
started creating and running programs right away. On the one hand, we will focus
on learning to program, as opposed to learning details about Java. On the other
hand, part of the challenge of programming is knowing which details are relevant
in a givensituation. Java iswidelyused,solearningto program in this languagewill
enableyou to write programs on many computers (your own, for example).Also,
learningto program in Java willmakeit easyforyoulearn other languages, includ
ing lower-level languages such as C and specialized languagessuch as Matlab.

Elements of Programming
1.1
Your First Program
In this section, our plan isto leadyou into the world of Javaprogramming by tak
ingyou through the basicstepsrequired to geta simpleprogram running. The Java
system is a collection of applications, not unlike many of the other applications
that you are accustomed to using (such
as your word processor, email program,
LU Heu0,World
6
and internet browser). As with any ap-
1.1.2
Using acommand-line argument . . 8
plication, you need to be sure that Java
Pwpam in this section
is properly installed on your computer. It
comes preloaded on many computers, or
you can download it easily. Youalso need a text editor and a terminal application.
Your first task is to find the instructions for installing such a Java programming
environment on yourcomputer by visiting
http://www.cs.pri nceton.edu/IntroProgrammi ng
We refer to this site as the booksite. It contains an extensive amount of supplemen
tary information about the material in this book for your reference and use. You
will find it useful to have your browser open to this site while programming.
Programming in Java
To introduce you to developing Java programs, we
break the process down into three steps.Toprogram in Java,you need to:
• Create a program by typing it into a filenamed, say, MyCode. j ava.
• Compile it by typing j avac MyCode. j ava in a terminal window.
• Run (or execute) it by typing Java MyCode in the terminal window.
In the first step, you start with a blank screen and end with a sequence of typed
characters on the screen, just as when you write an email message or a paper. Pro
grammers use the term code to refer to program text and the term coding to refer
to the act of creating and editing the code. In the second step, you use a system ap
plication that compiles your program (translates it into a form more suitable for the
computer) and puts the resultin a file named MyCode. cl ass. In the third step,you
transfer control of the computer from the systemto your program (which returns
control back to the system when finished). Many systems have several different
waysto create, compile, and execute programs. We choose the sequence described
here becauseit isthe simplestto describe and use for simpleprograms.

/. /
Your First Program
Creating aprogram. AJava programisnothingmorethan a sequence of charac
ters, like a paragraph or a poem, stored in a file with a .Java extension. To create
one, therefore, you need only define that sequenceof characters,in the same way
as you do for email or any other computer application.You can use any texteditor
for this task,or you can use one of the more sophisticated program development
environments described on the booksite. Such environments are overkill for the
sorts of programs we consider in this book, but they are not difficultto use, have
many useful features, and are widelyused by professionals.
Compiling a program. Atfirst, it mightseem that Java isdesigned to be best un
derstoodbythe computer. To the contrary, the language isdesigned to be best un
derstood by the programmer (that's you). The computer's language is far more
primitivethan Java. Acompiler isan applicationthat translatesa program from the
Java languageto a languagemore suitablefor executing on the computer. The com
piler takes a file with a .Java extensionas input (your program) and produces a
file with the same name but with a .cl ass extension(the computer-languagever
sion). To use your Javacompiler, type in a terminal window the javac command
followedby the filename ofthe program you want to compile.
Executing a program. Onceyou compile the program,you can run it. This is the
excitingpart, where your program takescontrol of your computer (within the con
straints of what the Java systemallows). It isperhaps more accurateto saythat your
computer follows your instructions. It is even more accurate to say that a part of
the Javasystem known as the Java VirtualMachine (the /VM, for short) directs your
computer to follow your instructions. To use the JVM to execute your program,
type the Java command followed by the program name in a terminal window.
use anytexteditorto
type javac HelloWorid. Java
type Java Hell 0W0rid
create yourprogram
tocompile yourprogram
toexecute yourprogram
i
i
i
^HelloWorld. class —
editor -^HelloWorid. Java—*- compiler
JVM — "Hello, World"
i
'
'
I
'—'
j
yourprogram
computer-language
mtput
(atextfile)
version ofyour program
Developinga Java program

Elements of Programming
^iMSMte^
m
Program 1.1.1
Hello, World
public class HelloWorld
{
public static void main(String[] args)
{
System.out.print("Hello, World");
System.out.println();
}
}
This code isaJava program that accomplishes asimple task. Itistraditionally a beginner'sfirst
program. The box below shows what happens when you compile andexecute the program. The
terminal application gives a command prompt (% in this book) andexecutes the commands
that you type (javac and then Java in the example below). The result in this case is that the
program prints a message in the terminal window {the third line).
% javac HelloWorld.java
% java HelloWorld
Hello, World
Program 1.1.1 is an example of a complete Java program. Its name is Hel1oWorld,
which means that its code residesin a filenamed Hel1oWor1d. j ava (by convention
in Java). The program's soleactionis to print a message back to the terminal win
dow. For continuity, we will use some standardJava terms to describethe program,
butwewill not define them until laterin the book: Program1.1.1 consistsofasingle
class named Hel 1oWorl dthat hasasinglemethodnamed mai n(). This method uses
two other methods named System. out. pri nt() and System. out. pri ntl n() to
do the job. (When referring to a method in the text, we use () after the name to
distinguish it from other kinds of names.) Until Section 2.1,where we learn about
classes that define multiple methods, allofour classes will havethis same structure.
Forthe time being, you can think of"class" asmeaning "program."
The firstline of a method specifiesits name and other information; the rest is
a sequence of statementsenclosed in bracesand each followed by a semicolon. For
the time being, you can think of "programming" as meaning "specifying a class

7./
Your First Program
name and a sequence of statements for its main() method." In the next two sec
tions, you will learn many differentkinds of statementsthat you can use to make
programs. For the moment, wewilljust use statements for printing to the terminal
like the ones in Hel 1oWorl d.
When you type java followed by a
classname in your terminal application, the
system calls the main() method that you
defined in that class, and executes its state
ments in order, one by one. Thus, typing
java Hel1oWorld causes the system to call
on the mai n() method in Program 1.1.1 and
execute its two statements. The first state
ment callson System. out. pri nt() to print
in the terminal window the message be
tween the quotation marks, and the second
statement calls on System, out. pri ntl n()
to terminate the line.
Since the 1970s, it has been a tradition that a beginning programmer's first
program should print "Hel 1o, Worl d". So,you should type the code in Program
1.1.1 into a file, compile it, and executeit. Bydoing so,you willbe followingin the
footsteps of countless others who havelearned how to program. Also, you will be
checking that you have a usable editor and terminal application. At first, accom
plishing the task of printing something out in a terminal window might not seem
very interesting; upon reflection, however, you will see that one of the most basic
functions that we need from a program is its abilityto tell us what it is doing.
For the time being, all our program code will be just like Program 1.1.1, ex
cept with a different sequence of statements in mai n(). Thus, you do not need to
start with a blank page to write a program. Instead,you can
• Copy Hel1oWorl d. j ava into a new file having a new program name of
your choice, followed by . j ava.
• Replace Hel1oWorl d on the first line with the new program name.
• Replace the System. out. pri nt () and System. out. pri ntl n() statements
with a different sequence of statements (each ending with a semicolon).
Your program is characterized by its sequence of statements and its name. Each
Java program must reside in a file whose name matches the one after the word
cl ass on the first line, and it also must have a . java extension.
textfile named HelloWorld. java
name
I
public class HelloWorld
{
mainQ method
publi c
{
static void main(String[] args)
}
}
System.out.print("Hello, World");
System.out.p ri ntln();
statements
Anatomy of a program
body

8
Program 1.1.2
Usinga command-line argument
public class UseArgument
{
public static void main(String[] args)
{
System.out.print("Hi, ");
System.out.pri nt(args[0]);
System.out.println(".
How are you?");
}
}
Elements of Programming
This program shows thewayin which wecan control the actions ofourprograms: byproviding
an argument on thecommand line. Doingsoallows usto tailor thebehavior ofourprograms.
% javac UseArgument.java
% java UseArgument Alice
Hi,
Alice.
How are you?
% java UseArgument Bob
Hi,
Bob. How are you?
mmm
^P»p^ss?fs$^3^;?£;
Wfw&^i^M.
:iMMMMiM^M
Errors, It is easyto blur the distinction among editing, compiling, and executing
programs. You should keep them separate in your mind when you are learning to
program, to better understand the effects of the errors that inevitably arise. You
can find severalexamples of errors in the Q&Aat the end of this section. Youcan
fix or avoid most errors by carefully examining the program as you create it, the
same way you fix spelling and grammatical errors when you compose an email
message. Some errors, known as compile-time errors, are caught when you compile
the program, because they prevent the compiler from doing the translation. Other
errors, known as run-time errors, do not show up until you execute the program.
In general, errors in programs, also commonly known as bugs, are the bane of a
programmer's existence: the error messages can be confusing or misleading, and
the sourceof the error can be veryhard to find.One of the first skills that you will
learn isto identifyerrors;you willalsolearn to be sufficiently carefulwhen coding,
to avoid making many of them in the first place.

/. /
Your First Program
Input asid Output
Typically, wewant to provide input to our programs: data
that theycanprocess to producea result. Thesimplest way to provide input data is
illustrated in UseArgument (Program 1.1.2).Whenever UseArgument is executed,
it reads the command-line argument that you type after the program name and
prints it back out to the terminal as part of the message. The result of executing
this program depends on what we type afterthe program name.Aftercompiling
the program once,we can run it for different command-line arguments and get
different printed results.Wewilldiscussin more detail the mechanism that we use
to pass arguments to our programs later,in Section 2.1.In the meantime, you can
use args [0] within your program's body to represent the string that you type on
the command line when it is executed,just as in UseArgu
ment.
Alice -<
input string
Again, accomplishing the task ofgetting a program
1
to write back out what we type in to it may not seem in-
H^^H
teresting at first, but upon reflection you will realize that
^^^H^
bjack box
another basic function of aprogram is its ability to re-
^^J|
spond tobasic information from the user tocontrol what
I
output string
the program does. The simple model that UseArgument
Hi, Alice. How are you?
represents will suffice to allow us to consider Java's basic
programming mechanismand to addressallsorts of inter-
Abird's-eye view ofaJava program
esting computational problems.
Stepping back, we can see that UseArgument does neither more nor less than
implementa functionthat mapsa stringofcharacters (theargument)into another
string of characters (the message printed backto the terminal).When using it, we
might think of our Java program as a blackbox that converts our input string to
some output string. This model is attractivebecause it is not only simple but also
sufficiently general to allow completion, in principle, of any computational task.
For example,the Java compiler itself is nothing more than a program that takes
one string of characters as input (a .java file) and produces another string of
charactersasoutput (the corresponding .cl ass file). Later, wewillbe ableto write
programs that accomplish a varietyof interesting tasks (though we stop short of
programs as complicated as a compiler). For the moment, we livewith various lim
itations on the size and type of the input and output to our programs; in Section
1.5,we will see how to incorporate more sophisticatedmechanisms for program
input and output. In particular, wecan work with arbitrarily long input and output
strings and other types of data such as sound and pictures.

Elements of Programming
K$&A
Q. Why Java?
A. The programs that we are writing are verysimilar to their counterparts in sev
eral other languages, so our choiceof languageis not crucial.Weuse Javabecause
it iswidelyavailable, embracesa fullset of modern abstractions, and has a variety
of automatic checksfor mistakes in programs, so it is suitable for learning to pro
gram.Thereisno perfectlanguage, andyoucertainlywillbe programming in other
languages in the future.
Q. Do I reallyhaveto type in the programs in the book to try them out? I believe
that you ran them and that they produce the indicated output.
A. Everyone should type in and run HelloWorld. Your understanding will be
greatly magnified ifyoualsorun UseArgument, try it on variousinputs,and modify
it to test differentideas of your own. Tosave some typing, you can find all of the
code in this book (and much more) on the booksite. This site also has information
about installing and running Java on your computer, answers to selectedexercises,
web links, and other extra information that you may find useful or interesting.
Q. What is the meaning of the words pub!i c, stati c and voi d?
A. Thesekeywords specify certain properties of mai n() that you willlearn about
later in the book. For the moment, wejust include these keywordsin the code (be
cause they are required) but do not referto them in the text.
Q. What is the meaning of the //, /*, and */ character sequences in the code?
A. Theydenote comments, whichareignoredbythe compiler.Acomment iseither
text in between /* and */ or at the end of a line after //. As with most online code,
the code on the booksite is liberallyannotated with comments that explain what it
does; we use fewer comments in code in this book because the accompanying text
and figures provide the explanation.
Q. What are Java's rules regarding tabs, spaces, and newline characters?
A. Such characters are known as whitespace characters. Java compilers consider
all whitespace in program text to be equivalent. For example, we could write Hel-

/. /
YourFirst Program
loWorld as follows:
public class HelloWorld { public static void main ( String []
args) { System.out.print("Hello, World")
; System.out.
println()
;} }
But we do normally adhere to spacingand indenting conventionswhen we write
Java programs, just aswealways indent paragraphsand linesconsistentlywhen we
write prose or poetry.
Q. What are the rules regardingquotation marks?
A. Material insidequotation marksis an exception to the rule definedin the pre
vious question: things within quotes are taken literallyso that you can precisely
specify what gets printed. If you put any number of successive spaceswithin the
quotes, you get that number of spaces in the output. If you accidentally omit a
quotation mark, the compiler may get veryconfused,because it needs that mark to
distinguishbetweencharactersin the string and other parts of the program.
Q. What happenswhenyouomit abraceor misspell one of thewords,likepub!i c
or stati c or voi d or mai n?
A. It dependsupon precisely whatyoudo.Sucherrorsare called syntax errors and
are usuallycaught bythe compiler. Forexample, ifyou makea program Bad that is
exactly the same as Hel 1oWorl d except that you omit the line containing the first
left brace (and change the program name from HelloWorld to Bad), you get the
following helpful message:
% javac Bad.java
Bad.java:2:
,{l expected
public static void main(String[] args)
A
1 error
From this message,you might correctly surmise that you need to insert a left brace.
But the compiler may not be able to tellyou exactlywhat mistake you made, so the
error message maybe hard to understand. For example, if you omit the second left
brace instead of the first one, you get the following messages:
11

Elements of Programming
% javac Bad.java
Bad.j ava:4:
f;'
expected
System.out.print("Hello, World");
A
Bad.java:7:
'class1 or 'interface1 expected
}
A
Bad.java:8:
'class1 or 'interface1 expected
A
3
errors
One wayto get used to such messages is to intentionallyintroduce mistakes into a
simple program and then seewhat happens.Whateverthe error message says, you
should treat the compiler as a friend, for it is just trying to tell you that something
is wrong with your program.
Q. Can a program use more than one command-line argument?
A. Yes, you can use many arguments,though wenormally usejust a few. Note that
the count starts at 0, so you referto the first argument as args [0], the second one
as args [1], the third one as args [2], and so forth.
Q. What Java methods are available for me to use?
A. There are literallythousands of them.Weintroduce them to you in a deliberate
fashion (starting in the next section) to avoidoverwhelmingyou with choices.
Q. When I ran UseArgument, I got a strange error message. What's the problem?
A. Most likely, you forgot to include a command-line argument:
% java UseArgument
Hi,
Exception in thread "main"
java.lang.ArraylndexOutOfBoundsException:
0
at UseArgument.mai n(UseArgument.j ava:6)
The JVMis complaining that you ran the program but did not type an argument as
promised. Youwilllearn more details about array indices in Section 1.4.Remember
this error message: you are likely to see it again. Even experienced programmers
forget to type arguments on occasion.

/. 7 Your First Program
1.1.1
Write a program that prints the Hello, World message 10times.
1.1.2
Describewhat happens if you omit the following in Hel 1oWorl d. j ava:
a.
public
b.
static
c.
voi d
d. args
1.1.3
Describewhat happens if you misspell (by, say, omitting the second letter)
the following in Hel1oWorl d. j ava:
a. public
b. stati c
c.
voi d
d. args
1.1.4
Describe what happens if you try to executeUseArgument with each of the
following command lines:
a. java UseArgument java
b. java UseArgument @!&a%
c.
java UseArgument 1234
d. java UseArgument.java Bob
e.
java UseArgument Alice Bob
1.1.5
ModifyUseArgument. java to makea program UseThree. java that takes
three names and prints out a proper sentencewith the names in the reverse of the
order given, so that, for example, java UseThree Alice
Bob Carol gives Hi
Carol,
Bob,
and Alice.
13

Elements of Programming
le2
Built-in Types of Data
When programming in Java, youmust always be aware of the type of data that your
program is processing. The programsin Section 1.1 process strings of characters,
many of the programs in this sectionprocess numbers, and we consider numer
ous other types later in the book. Under
standing thedistinctions among them is
L2.i
String concatenation example ... 20
so important that we formally definethe
1.2.2
Integer multiplication and division 22
idea: a data type isaset ofvalues andaset
L2-3
Quadratic formula
24
ofoperations defined on those values. You
!«" *fp.year
/ ' \
H
r
...
. ,
.
r
1.2.5
Casting to get a random mteger . . 33
are familiar with various types of num
bers, such as integers and real numbers,
Programs in this section
and with operations defined on them,
such as addition and multiplication. In mathematics, we are accustomed to think
ing of sets of numbers as being infinite;in computer programs we have to work
with a finite number of possibilities. Each operation that we perform is well-de
fined onlyfor the finite set of valuesin an associateddata type.
There are eight primitive types of data in Java, mostly for different kinds of
numbers. Of the eight primitive types,we most often use these: i nt for integers;
doubl e for real numbers; and boo!ean for true-false values. There are other types
of data available in Javalibraries:for example,the programs in Section 1.1use the
type St ri ng for strings of characters. Java treats the Stri ng type differently from
other typesbecause itsusage forinput and output isessential. Accordingly, it shares
some characteristicsof the primitive types:for example,some of its operations are
built in to the Javalanguage. For clarity, we refer to primitive types and String
collectively as built-in types. For the time being, we concentrate on programs that
are based on computing with built-in types.Later,you willlearn about Javalibrary
data types and building your own data types.Indeed, programming in Javais often
centered on building data types, as you shall see in Chapter 3.
After defining basic terms, we consider several sample programs and code
fragments that illustrate the use of different types of data. These code fragments
do not do much real computing, but you will soon see similar code in longer pro
grams. Understanding data types (values and operations on them) is an essential
step in beginning to program. It sets the stage for us to begin working with more
intricate programs in the next section. Everyprogram that you write will use code
like the tiny fragments shown in this section.

1.2 Built-in Types of Data
type
set of values
common operators
sampleliteralvalues
int
integers
+ -
* /
%
99 -12 2147483647
double
floating-point numbers
+ -
* /
3.14 -2.5 6.022e23
boolean
boolean values
&& ||
!
true false
char
characters
,A,
,1.
,%,
,\n,
String
sequences of characters
+
"AB" Hello" "2.5"
Basic built-in datatypes
Definitions
To talkaboutdatatypes, we need to introduce someterminology.
Todo so,westart with the following codefragment:
int a,
b, c;
a = 1234;
b = 99;
c = a + b;
The first line is a declaration that declares the names of three variables to be the
identifiers a, b,and c and their type to be i nt. The next three linesare assignment
statements that change the values of the variables, using the literals 1234 and 99,
and the expression a + b,with the end result that c has the value 1333.
Identifiers. We useidentifiers to name variables (andmany otherthings) in Java.
Anidentifierisa sequence ofletters, digits, _,and $,the firstof whichisnot a digit.
The sequencesof characters abc, Ab$, abcl23, and a_b are alllegalJavaidentifiers,
but Ab*, labc, and a+b are not. Identifiers are case-sensitive, so Ab,ab, and AB are all
different names. You cannot use certain reserved words—such as publ i c, stati c,
i nt, doubl e, and so forth—to name variables.
Literals. A literal is a source-code representation of a data-type value. We use
strings of digits like 1234 or 99 to define i nt literalvalues,and add a decimal point
as in 3.14159 or 2.71828 to define doubl e literal values.Tospecifya bool ean val
ue, we use the keywordstrue or fal se, and to specifya Stri ng,we use a sequence
of characters enclosed in quotes, such as "Hel1o, Worl d". We will consider other
kinds of literals as we consider each data type in more detail.
Variables. A variable is a name that we use to refer to a data-type value.We use
variables to keep track of changing values as a computation unfolds. For example,
15

16
Elements of Programming
we use the variable n in manyprogramsto count things.We createa variable in a
declaration that specifies its type and gives it a name.Wecomputewith it by using
the name in an expression that uses operations defined for its type. Each variable
always stores one of the permissible data-typevalues.
Declaration statements.
A declaration statement associates a variable name with
a type at compile time. Java requires us to use declarations to specify the names
and types of variables. Bydoing so,we are being explicitabout any computation
that wearespecifying. Java is saidto be a strongly-typed language, because the Java
compiler cancheck forconsistencyatcompile time (forexample, it doesnot permit
us to add a String to a double). This situation is preciselyanalogous to making
sure that quantities have the proper units in a sci-
dedamion smement
entific application (for example, it does not make
sense to add a quantity measured in inches to an-
variable name^
other measured in pounds). Declarations can ap-
assignment
pear anywherebefore a variableisfirst used—most
statement
often, we put them at the point of first use.
*-
combined declaration
Assignmentstatements. An assignmentstatement -das^nment statement
associates a data-type value with avariable. When
jjsingaprimitive data type
we write c = a + b in Java, we are not expressing
mathematical equality, but are instead expressing an action: set the value of the
variable c to be the value of a plus the value of b.It is true that c is mathematically
equal to a + b immediatelyafter the assignmentstatement has been executed, but
the point of the statement is to changethe value of c (if necessary). The left-hand
side of an assignment statement must be a singlevariable;the right-hand side can
be an arbitrary expression that producesvaluesof the type. For example,we can say
discriminant = b*b - 4*a*c in Java, but we cannot saya + b = b + aorl = a.
In short, the meaningof= isdecidedly notthe same asin mathematical equations. For
example, a = b is certainly not the same as b = a, and while the value of c is the
value of a plus the value of b after c = a + b has been executed, that may cease to
be the caseif subsequent statements change the values of any of the variables.
Initialization. In a simple declaration, the initialvalue of the variable is unde
fined.For economy,we can combine a declaration with an assignment statement to
provide an initial value for the variable.
1
i
|int
s a
=
-b =
a, b;|
11234|1
99;
- literal
|int
c
=
a
+ b:|

1.2 Built-in Types of Data
17
Tracing changes in variable values. As a final check onyour understanding of
the purpose of assignment statements, convince yourself that the following code
exchanges the values of a and b (assume that a and b are i nt variables):
int t
= a;
a = b;
b = t;
To do so,usea time-honored methodof examining pro
gram behavior: study a table of the variable values after
each statement (such a table is known as a trace).
Expressions. An expression is a literal, a variable, or a
sequence of operations on literals and/or variables that
producesa value. Forprimitive types, expressions lookjust like mathematical for
mulas, which are based on familiar symbols or operators that specify data-type
operations to be performed on one or more operands. Each operand can be any
expression. Mostof the operatorsthat weusearebinary operators that takeexactly
twooperands, suchasx +1 ory / 2.Anexpression thatisenclosed in parentheses
isanother expression with the samevalue. Forexample, wecanwrite 4 * (x - 3) or
operands
4*x ~12 on the right-hand side of an assignment statement
(and expressions)
anc[ fa compiler will understandwhatwemean.
0 11 ( x - 3 )]
Precedence. Such expressions are shorthand for specifying a
I
sequence ofcomputations: inwhat ordershould theybeper
formed? Java has natural and well-definedprecedence rules
Anatomy ofan expression
(see fa booksite) that fully specify this order. For arithmetic
operations, multiplication and division are performed before
addition and subtraction, so that a-b*c and a- (b*c) representthe same sequence
of operations. When arithmetic operators have the same precedence, the order is
determined by left-associativity\ so that a-b-c and (a-b) -c represent the same se
quence of operations. You can use parentheses to override the rules, so you should
not need to worry about the details of precedence for most of the programs that
you write. (Some of the programs that you read might depend subtly on prece
dence rules, but we avoid such programs in this book.)
Converting strings to primitive values for command-line arguments. Java
provides the library methods that we need to convert the strings that we type as
operator
int a, bJ
undefined undefined
a = 1234;
1234
undefined
b = 99;
1234
99
int t
= a;
1234
99
1234
a = b;
99
99
1234
b = t;
99
1234
1234
Yourfirst trace

18
Elements of Programming
command-line arguments into numeric values for primitive types. We use the
Java library methods Integer.parselntO and Double.parseDoubleO for
this purpose. For example, typing Integer.parselnt("123") in program text
yields theliteral value 123 (typing 123 has thesame effect) andthecode Integer.
parselnt(args [0]) produces the same result asthe literalvalue typedasa string
on the command line.You willseeseveral examplesof this usagein the programs
in this section.
Convertingprimitive type values to stringsforoutput. As mentioned atthebe
ginning ofthis section, the Java built-in Stri ng type obeys special rules. One of
these special rules isthatyou caneasilyconvert anytypeofdatatoa Stri ng: when
ever weusethe + operatorwitha Stri ng asoneofitsoperands, Java automatically
converts the other to a St ri ng, producingasa resultthe Stri ng formed from the
characters of the first operandfollowed by the characters of the second operand.
Forexample, the resultof thesetwocodefragments
String a = "1234";
String a = "1234";
String b = "99";
int b = 99;
String c = a + b;
String c = a + b;
are both the same: they assign to c the value "123499". We use this automatic
conversion liberally to form Stri ng values for System.out. pri nt () and System.
out. pri ntl n() for output. Forexample, wecanwrite statementslikethis one:
System.out.println(a + " + " + b + " = " + c);
If a, b, and c are int variableswith the values 1234,99, and 1333, respectively, then
this statement prints out the string 1234 + 99 = 1333.
With these mechanisms, our view of each Java program as a black box that takes
string arguments and producesstring resultsisstillvalid,but wecan now interpret
those strings as numbers and use them as the basisfor meaningful computation.
Next, we consider these details for the basic built-in types that you will use most
often (strings, integers, floating-point numbers,and true-false values), alongwith
sample code illustrating their use.Tounderstand how to use a data type, you need
to know not just its defined set of values, but also which operations you can per
form, the language mechanism for invoking the operations, and the conventions
for specifying literal values.

1.2 Built-in Types of Data
Characters and Strings
Achar isanalphanumeric character or symbol, like
the ones that you type. There are 216 different possible character values, but we
usuallyrestrict attention to the ones that representletters,
numbers, symbols, and whitespace characterssuch as tab
and newline. Literals for char are characters enclosed in
singlequotes;for example, 'a' represents the lettera.For
tab,newline, backslash, single quoteand doublequote,we
use the special escape sequences f\t', f\n!, f\\', ' \f f,
and ,\" \ respectively. The characters are encoded as
16-bit integers using an encoding schemeknown as Uni
code,and there areescape sequences forspecifying special
charactersnot found on your keyboard (see the booksite).
We usually donot performanyoperations directly on characters otherthan assign
ing values to variables.
A St ri ngisa sequenceof characters. AliteralSt ri ngisa sequenceof charac
terswithin doublequotes, suchas "He!1o, Worl d". The St ri ngdata type is nota
primitivetype,but Java sometimes treatsit like one.Forexample, the concatenation
operator (+) that wejust considered isbuiltin to the language asa binary operator
in the same wayas familiar operations on numbers.
The concatenationoperation (along with the abilityto declare Stri ng vari
ables and to use them in expressions and assignment statements) is sufficiently
powerful to allow us to attacksome nontrivial computing tasks. As an example,
Ruler (Program 1.2.1) computes a table of
values of the ruler function that describes
the relative lengths of the marks on a ruler.
One noteworthy feature of this computa
tion isthat it illustrates how easyis is to craft
short programs that produce huge amounts
of output. If you extend this program in the
obvious wayto print five lines, six lines, sev
en lines, and so forth, you will see that each
time you add just two statements to this
program, you increase the sizeof its output by preciselyone more than a factor of
two.Specifically, if the program prints nlines,the nthline contains 2"— 1 numbers.
For example, if you were to add statements in this wayso that the program prints
30 lines, it would attempt to print more than 1 billion numbers.
19
values
typical
literals
operation
operator
sequences of characters
'Hello," "1 " " * "
concatenate
expression
"Hi,
" + "Bob"
"1"
+
"
2
"
+ "1"
'1234"
+ "
+ "
+ "99
"1234"
+ "99"
value
"Hi,
Bob"
"1 2
1"
'1234 + 99"
"123499"
Typical Stri ng expressions
Java's built-in Stri ng data type

20
Elements of Programming
fcfefe^^^
ft
s$3
5S?
f#3
Program 1.2.1
Stringconcatenation example
public class Ruler
{
public static void main(String[] args)
{
String rulerl = "1";
String ruler2 = rulerl + " 2
String ruler3 = ruler2 + " 3
String ruler4 = ruler3 + " 4
System.out.pri ntln(rulerl);
System.out.pri ntln(ruler2);
System.out.pri ntln(ruler3);
System.out.pri ntln(ruler4);
}
}
+ rulerl;
+ ruler2;
+ ruler3;
This program prints the relative lengths ofthe subdivisions on a ruler. The nth line ofoutput
is the relative lengths ofthe marks on a ruler subdivided in intervals of 1/2" ofan inch. For
example, thefourth line ofoutputgives the relative lengths ofthe marks that indicate intervals
ofone-sixteenth ofan inch ona ruler.
% javac Ruler.Java
% Java Ruler
1
12
1
12 13 12
1
121312141213121
mmm.
S5^fi«3>?jK&?^»4)?5C rf&m!$$?w^$&WJ&&%^^^%^
I I
I
I I
I
I
I
I I
I
121312141213121
The rulerfunction for n = 4
WUPWiPSi^^W
As just discussed, our most frequent use (by far) of the concatenationoperation is
to put togetherresults of computation foroutput with System. out. pri nt() and
System. out. pri ntl n(). Forexample, we could simplify UseArgument (Program
1.1.2)by replacingits three statements with this single statement:
System.out.println("Hi,
" + args[0] + ".
How are you?");
We have considered the String type first preciselybecause we need it for output
(and command-line input) in programs that processother types of data.

7.2 Built-in Types of Data
Integers
An i nt isan integer (natural number) between -2147483648 (-231)
and 2147483647 (231-1). These bounds derive from the fact that integers are rep
resented in binarywith 32binarydigits: there are 232 possible values. (The term
binary digit isomnipresent in computer science, andwe nearly always use theab
breviation bit: abitiseither 0or1.) The range ofpossible int values isasymmetric
because zerois includedwith the positive values. See the booksite for more details
about number representation, but in the present context it suffices to know that
an i nt isone of the finite setof values in the range
justgiven. Sequences ofthecharacters 0through 9,
expression
possibly witha plusor minus sign at thebeginning
(that, when interpreted as decimal numbers, fall
within the defined range),areinteger literalvalues.
We usei nts frequently because theynaturally arise
when implementing programs.
Standard arithmetic operators for addition/
subtraction (+ and -), multiplication (*), division
(/), and remainder (%) for the int data type are
built in to Java. These operators take two i nt op
erands and produce an i nt result, withonesignifi
cant exception—division or remainder by zero is
(
not allowed. These operationsaredefined justasin
3
grade school (keepingin mind that allresultsmust
be integers):giventwo i nt valuesa and b,the value
of a / b isthe number of times b goes into a with
thefractional part discarded, andthevalue ofa % bistheremainder thatyou get
whenyoudividea byb.Forexample, thevalue of 17/ 3is 5,and the valueof 17%3
is2. The i nt results thatwe get from arithmetic operations are justwhat we expect,
except that if the result is too large to fit into i nt's 32-bit representation, then it
will betruncated in a well-defined manner. This situation isknown asoverflow. In
value
comment
21
5
5
5
5
5
1
3
*
3
+
3
-
3
-
-
(
/
0
5
-
/
8
2
15
1
2
13
5
-4
-4
0
no fractional part
remainder
run-time error
* has precedence
/ has precedence
left associative
better style
unambiguous
values
typicalliterals
operations
operators
add
+
Typical int expressions
integers between -231 and +231-1
1234
99
-99
0
1000000
subtract
multiply
divide
/
Java's built-ini nt data type
remainder

22
as
Elements of Programming
Program 1.2.2
Integer multiplication anddivision
^^$JiiL^&£AJii&&?x&&'±li!£i^v\;Vi
public class IntOps
{
public static void main(String[] args)
{
int a = Integer.parselnt(args[0]);
int b = Integer.parselnt(args[1]);
int p = a * b;
int q = a /
b;
int r = a % b;
System.out.println(a + " * " + b + '
System.out.println(a + " / " + b + '
System.out.println(a + " % " + b + '
System.out.println(a + " = " + q + '
}
}
+ P);
+ q);
+ r);
+
b
+
+ r);
Arithmeticfor integers is built in to Java. Most ofthis code is devoted to the task ofgetting the
values inand out; the actual arithmetic isinthe simple statements inthe middle oftheprogram
thatassign values top,q, and r.
% javac IntOps.Java
% Java IntOps 1234 99
1234 *
99 = 122166
1234 /
99 = 12
1234 % 99 = 46
1234 = 12 * 99 + 46
*iHiliiliPi
WPP^g
general, wehave to take care that such aresult isnot misinterpreted by ourcode.
For the moment, wewillbe computingwith small numbers,so you do not haveto
worry abouttheseboundary conditions.
Program 1.2.2 illustrates basic operations for manipulating integers, suchas
the useof expressions involving arithmetic operators. It also demonstrates the use
of Integer.parselnt() to convert String values on the command line to int
values, as well as the use of automatic type conversion to convert i nt values to
Stri ng values for output.

1.2 Built-in Types of Data
Three other built-in types are different representations of integers in Java.
The long,short, and byte types are thesame as int except that they use 64,16,
and8bitsrespectively, sothe range of allowed values isaccordingly different. Pro
grammers use long whenworking withhuge integers, and the other types to save
space. You canfind a table with themaximum andminimum values for each type
on the booksite, or youcanfigure themout foryourself from thenumbers of bits.
Floating-point numbers
The double type is for representing floating-point
numbers, foruse in scientific andcommercial applications. Theinternal represen
tationislike scientific notation, so that we cancompute withnumbers in a huge
range.We use floating-point numbers to repre
sentrealnumbers,but theyaredecidedly not the
sameasrealnumbers! Thereareinfinitely many
realnumbers,but wecan onlyrepresent a finite
number of floating-points in any digital com
puter representation. Floating-point numbers
do approximate real numbers sufficiently well
that we can use them in applications, but weof
ten need to cope with the fact that we cannot
always do exactcomputations.
We can use a sequence of digits with a
decimal point to type floating-point numbers.
For example, 3.14159 represents a six-digit ap
proximation to it. Alternatively, we can use a notation like scientificnotation: the
literal 6.022e23represents thenumber6.022 X 1023. As withintegers, youcanuse
these conventions to write floating-point literals in your programs or to provide
floating-point numbers as string parameterson the command line.
The arithmetic operators +, -, *,and / are defined for double. Beyond the
built-in operators, the Java Math library defines the square root, trigonometric
expression
value
23
3.141 +
.03
3.141 -
.03
6.02e23 /
2.0
5.0 /
3.0
10.0 % 3.141
1.0 /
0.0
Math.sqrt(2.0)
Math.sqrt(-l.O)
3.171
3.111
3.01e23
1.6666666666666667
0.577
Infinity
1.4142135623730951
NaN
values
typicalliterals
operations
operators
Typical doubl e expressions
real numbers (specified by IEEE 754standard)
3.14159
6.022e23
-3.0
2.0
1.4142135623730951
add
subtract
multiply
divide
+
/
Java's built-in doubl e datatype

24
Elements of Programming
[ftffla*^^^^
ft
*•«#
:"£'$
Program 1.2.3
Quadraticformula
public class Quadratic
{
public static void main(String[] args)
{
double b = Double.parseDouble(args[0]);
double c = Double.parseDouble(args[l]);
double discriminant = b*b - 4.0*c;
double d = Math.sqrt(discriminant);
System.out.println((-b + d) / 2.0);
System.out.println((-b - d) / 2.0);
}
This program prints out the roots ofthe polynomial x2 + bx + c, using the quadraticformula.
For example, the roots ofx2 - 3x+ 2 are 1and 2 since we can factor the equation as (x - 1)
(x- 2); the roots ofx2 -x-1 are$ and 1- 4>, where (|> isthe golden ratio, and the roots ofx2 +
x + 1 are not real numbers.
% javac Quadratic.Java
% Java Quadratic -3.0 2.0
2.0
1.0
^^sss
wmmmmMsmmZ&SPW^F-i
% Java Quadratic -1.0 -1.0
1.618033988749895
-0.6180339887498949
% Java Quadratic 1.0 1.0
NaN
NaN
^^S^S^S^R^^^^i^SSI^P^^pi^^^^^^S^^^
Si
W
Nf.
W
ift
Wi
m
functions, logarithm/exponential functions, and other common functions for
floating-point numbers. To use oneof these values in anexpression, wewrite the
name of the function followed by its argument in parentheses. For example, you
canusethe code Math. sqrt(2.0) when you want to use the square root of2 in an
expression. We discuss in moredetail the mechanism behindthis arrangement in
Section 2.1 and more detailsabout the Math library at the end ofthis section.
When working with floating point numbers, one of the first things that
you will encounter is the issue of precision: 5.0/2.0 is 2.5 but 5.0/3.0 is
1.6666666666666667.In Section 1.5, you willlearnJava's mechanism for control-

1.2 Built-in Types of Data
lingthenumberofsignificant digits thatyousee inoutput.Until then,we will work
with the Java defaultoutput format.
The result of a calculation canbe one of the special values Infi nity (if the
number is too large to be represented) or NaN (if the result of the calculation is
undefined). Though there are myriad details to considerwhen calculationsinvolve
these values, youcanuse doubl e inanatural way andbegin towrite Java programs
instead of using a calculator for all kinds of calculations. For example, Program
1.2.3 shows the use of doubl e values in computing the roots of a quadratic equa
tion using the quadratic formula. Several of the exercises at the end of this section
further illustrate this point.
As with long, short, and byte for integers, there is another representation
for real numbers called f1oat. Programmers sometimes use f1oat to save space
when precision is a secondary consideration. Thedouble typeis useful for about
15 significant digits; the f1oat typeisgood foronlyabout7 digits. We do not use
f 1oat in this book.
25
values
literals
operations
operators
true or false
true false
and
&&
II
not
Booleans
The boolean type has justtwo values: true
and fal se. These are the two possible boolean literals. Ev
ery boolean variable has one of thesetwovalues, and every
bool ean operation has operands and a result that takes on
just one of thesetwo values. Thissimplicity is deceiving—
boolean valueslie at the foundation of computer science.
The most important operations defined for booleans are and (&&), or (| |),
and not (!), which have familiar definitions:
• a && b is true if both operands are true, and fal se if either is fal se.
• a || b is f al se if both operands are fal se, and true if either is true.
• !a is true if a is fal se, and fal se if a is true.
Despite the intuitive nature of these definitions, it is worthwhile to fully specify
each possibilityfor each operation in tablesknown as truth tables. The notfunction
Java s built-in bool ean datatype
!a
a
&& b
true
false
false
false
false
false
false
true
false
true
false
true
true
false
false
true
true
true
true
true
Truth-table definitions of bool ean operations

26
Elements of Programming
a
&& b
!a
!a | |
!b
!(!a
!b)
false
false
false
true
true
true
false
false
true
false
true
false
true
false
true
false
false
false
true
true
false
true
true
true
false
false
false
true
Truth--table proofthata && b and !(!a ||
•b) are identical
has onlyoneoperand: itsvalue for each ofthetwo possible values oftheoperand is
specified inthesecond column. The and andor functions each have two operands:
therearefourdifferent possibilities foroperandinput values, andthevalues of the
functionsfor eachpossibility arespecified in the right two columns.
We can usethese operators with parentheses to develop arbitrarily complex
expressions, each of which specifies a well-defined boolean function. Often the
same function appears in different guises. Forexample, the expressions (a && b)
and !(! a
11
!b) are equivalent.
Thestudy ofmanipulating expressions ofthiskindisknown asBoolean logic.
This field of mathematics is fundamental to computing: it plays an essentialrole
in the design and operation of computer hardware itself, and it is also a starting
pointforthetheoretical foundations ofcomputation. In thepresentcontext, weare
interested in boolean expressions because weusethem to controlthe behaviorof
our programs. Typically, a particular condition ofinterest isspecified asa boolean
expression anda piece of program code iswritten to execute onesetof statements
iftheexpression istrue andadifferent setofstatements ifthe expression isfal se.
The mechanics of doing so are the topic of Section 1.3.
Comparisons
Somemixed-type operatorstakeoperands of one type and pro
duce a resultof another type. The most important operators of this kind are the
comparison operators ==, !=, <, <=, >, and>=, which allaredefined foreach primi
tivenumerictypeand producea boolean result. Since operationsaredefined only
non-negative discriminant?
(b*b - 4.0*a*c) >= 0.0
beginning ofa century?
(year % 100) == 0
legal month?
(month >= 1) && (month
<= 12)
Typical comparison expressions

1.2 Built-in Types of Data
w^ii^^
sail
If
W£
Program 1.2.4
Leap year
public class LeapYear
{
public static void main(String[] args)
{
int year = Integer.parselnt(args[0]);
boolean isLeapYear;
isLeapYear = (year % 4 == 0);
isLeapYear = isLeapYear && (year % 100 != 0);
isLeapYear = isLeapYear
|| (year % 400 == 0);
System.out.pri ntln(i sLeapYear);
}
}
This program tests whether aninteger corresponds to a leap year inthe Gregorian calendar. A
year isa leap year ifitisdivisible by 4 (2004), unless itisdivisible by 100 inwhich case itisnot
(1900), unless it isdivisible by400in which case it is (2000).
% javac LeapYear.java
% java LeapYear 2004
true
% java LeapYear 1900
false
% java LeapYear 2000
true
^w^^Sf|?$£*^^"!•s^^ra^i^^sqs^Kipqs^jj^^^^^^gp^Fss?'
with respect to data types, each of thesesymbols stands for many operations, one
for each data type.It isrequired thatbothoperands beof the same type.The result
is always bool ean.
Even without going into the details of number representation, it is clear that
the operations forthe various types are really quitedifferent: forexample, it is one
thing to comparetwo i nts to check that (2 <= 2) is true but quite another to
compare two doubl es to check whether (2.0 <= 0.002e3) is true or fal se. Still,
these operations arewell-defined and useful to write code that tests for conditions
suchas(b*b - 4.0*a*c) >= 0.0, which is frequently needed,asyou will see.
27

28
Elements of Programming
The comparison operations have lower precedence thanarithmetic operators
and higher precedence than boolean operators, soyoudonotneed theparentheses
inanexpression like (b*b - 4.0*a*c) >= 0.0, andyoucould write anexpression
likemonth >= 1 && month <= 12without parentheses to testwhetherthe valueof
the i nt variable monthisbetween 1and 12. (It isbetter styleto usethe parentheses,
however.)
Comparison operations, together
with boolean logic,providethe basisfor
decision-making in Java programs. Pro
gram 1.2.4 is an example of their use,
and you can find other examples in the
exercises at the end ofthis section. More
importantly, in Section 1.3 we will see
the rolethat boolean expressions playin
more sophisticated programs.
true
false
op
meaning
==
equal
2
==
2
2
==
3
!=
notequal
3
!= 2
2
!= 2
<
less than
2
< 13
2
<
2
<=
less than orequal
2
<=
2
3 <= 2
>
greater than
13 >
2
2
>
13
>=
greater than orequal
3 >= 2
2
>=
3
Comparisons with i nt operands anda bool ean result
Library methods and APIs
As we have seen, many programming tasks in
volve usingJava library methodsinaddition to thebuilt-inoperations on data-type
values. The number of available library methods is vast.As you learn to program,
youwill learn to use more and more library methods, but it isbestatthebeginning
to restrict yourattention to a relatively small setof methods. In this chapter, you
have already used some of Java's methods for printing, for converting data from
onetype to another, and for computing mathematical functions (the Java Math li
brary). Inlater chapters, youwill learn not justhowto useothermethods, but how
to createand use your own methods.
For convenience, wewillconsistentlysummarizethe librarymethods that you
need to know how to use in tables like this one:
public class System.out
void
print(St ring s)
prints
voi d
pri ntl n(Stri ng s)
print s, followed by a newline
voi d
pri ntl n()
print a newline
Note: Anytype ofdatacanbeused (andwillbeautomatically converted toStri ngj.
Excerptsfrom Java's libraryfor standard output

1.2 Built-in Types of Data
29
Such a table is known as an application programming interface (API). It provides
the informationthat you needto writeanapplication program that uses the meth
ods. Here iS anAPIfor the most commonlyusedmethods in Java's Math library:
public class Math
double
abs (double a)
absolute value ofa
double
max(double a, double b)
maximum ofaand b
double
mi n(double a, double b)
minimum ofaand b
Note 1: abs (), max(), andmin() aredefined also for i nt, 1ong, and float.
double
sin (double theta)
sinefunction
double
cos (double theta)
cosinefunction
double tan (double theta)
tangentfunction
Note2:Angles areexpressed in radians. UsetoDegrees () and toRadi ans () to convert.
Note3: Use asi n(), acos (), and atan () for inversefunctions.
double
exp(double a)
exponential(ea)
double
log (double a)
natural log (loge a, orIn a)
double
pow(double a, double b)
raise a to the bthpower (ab)
long
round(double a)
round tothe nearest integer
doubl e
random()
random number in [0,1)
double
sqrt(double a)
square root ofa
doubl e
E
value ofe (constant)
doubl e
PI
value ofit (constant)
Seebooksitefor other availablefunctions.
ExcerptsfromJava's mathematics library
With the exception of random(), these methods implement mathematical func
tions—they use their arguments to compute avalueofaspecifiedtype. Eachmeth
od is described by aline in the API that specifies the information you need to know
in order to use the method. The code in the tables is notthe code that you type to
use the method; it is known as the method's signature. The signature specifiesthe
type ofthe arguments, the method name, and the type ofthe value that the method
computes (the returnvalue).When your program is executed, we saythat it calls the
system library code for the method, which returns the value for use in your code.

30
library name
public class Math'
signature
\
method name
-/-
double sqrt(double a)
—t
1—
return type
argument type
Anatomy ofa method signature
Elements of Programming
Note that random() does not implement a mathematical
functionbecause it doesnot takeanargument.On the other
hand, System.out.print() and System.out.println()
do not implement mathematicalfunctionsbecause they do
not return values and therefore do not have a return type.
(This condition is specified in the signature by the keyword
void.)
In your code, you can use a library method by typ
ing its name followed by arguments of the specified type,
enclosedin parentheses and separated by commas. You can
usethis codein the samewayasyou usevariables andliterals in expressions.When
you do so, you can expect that method to
compute a value of the appropriate type, as
documented in the left column of the API.
For example, you can write expressions like
Math.sin(x) * Math.cos(y) and so on.
Method arguments may also be expressions,
as in Math.sqrt(b*b - 4.0*a*c).
The Math libraryalso defines the precise constantvaluesPI (for it) and E(for
e), so that you can use those names to referto those constants in your programs.
For example,the value of Math. si n(Math.PI/2) is 1.0 and the value of Math.
1og(Math. E) is 1.0 (because Math.si n() takesits argument in radiansand Math.
1og() implements the naturallogarithm function).
To be complete,we also includeherethe following API for Java's conversion
methods, which we use for command-line arguments:
int
Integer, parselnt(String s)
converts to an int value
double
Double. parseDouble(String s)
converts to a double value
long
Long.parseLong(String s)
converts to along value
Java library methodsfor converting strings toprimitivetypes
library name
methodname
\
/
double d = Math.sqrt(b*b - 4.0*a*c);
\
/
N return type
argument
Using a library method
You do not need to use methods like these to convert from i nt, doubl e, and 1ong
values to String values for output, because Java automatically converts any val
ue used as an argument to System, out. pri nt() or System, out. pri ntl n() to
String for output.

1.2 Built-in Types of Data
31
expression
library
type
value
Integer.parselnt("123")
Integer
int
123
Math.sqrt(5.0*5.0 - 4.0*4.0)
Math
double
3.0
Math.random()
Math
double
random in [0,1)
Math.round(3.14159)
Math
long
3
Typical expressions thatuseJava library methods
These APIs are typical of the online documentation that is the standard in
modern programming. There is extensive online documentation of the JavaAPIs
that is usedby professional programmers, and it is available to you (if you are in
terested) directlyfrom the Java website or through our booksite.You do not need
to go to the online documentation to understand the code in this book or to write
similarcode,because wepresentand explain in the text allof the library methods
that weusein APIs liketheseand summarize them in the endpapers. Moreimpor
tant, in Chapters 2and 3youwilllearn in thisbook howto develop your ownAPIs
and to implement functions for your own use.
Type conversion
One of the primary rulesof modern programming isthat you
should always be awareof the type of data that your program is processing. Only
by knowing the type can you know precisely which set of valueseach variable can
have, which literals you can use, and which operations you can perform. Typical
programming tasks involveprocessingmultiple types of data, so we often need to
convert data from one type to another. There are several ways to do so in Java.
Explicit type conversion. You can use a method that takes an argument of one
type (the value to be converted) and produces a result of another type. We have
already used the Integer. parselnt() and Doubl e. parseDoubl e() library meth
ods to convert String values to int and double values, respectively. Many other
methods are availablefor conversion among other types. For example, the library
method Math.round() takes a double argument and returns a long result: the
nearest integer to the argument. Thus, for example, Math.round(3.14159) and
Math. round (2.71828) are both of type long and have the same value (3).
Explicit cast. Java has some built-in type conversion conventions for primitive
types that you can take advantage of when you are awarethat you might lose infor-

32
Elements of Programming
mation.You haveto makeyour intention to do soexplicitbyusinga device calleda
cast. You castan expression from one primitivetype to another by prepending the
desiredtypenamewithin parentheses. Forexample, the expression (i nt) 2.71828
is a cast from double to int that produces an int with value 2. The conversion
methods definedfor caststhrow away information in a reasonable way (for a full
list, see the booksite). For example,casting a floating-point number to an integer
discards the fractionalpart byroundingtowards zero. Ifyouwant a differentresult,
suchasroundingto the nearestinteger, youmust usethe explicit conversion meth
od Math. round (), as just discussed (but you then need to use an explicit cast to
i nt, since that method returns a long). Randomlnt (Program 1.2.5) is an example
that uses a cast for a practical computation.
Automatic promotion for numbers. You canuse dataof anyprimitive numeric
typewhere avalue whose typehasalarger range ofvalues isexpected, because Java
automatically converts to the typewiththe largerrange. Thiskind of conversion is
cdHedpromotion. Forexample,we
used numbers all of type doubl e
in Program 1.2.3, so there is no
conversion. If we had chosen to
make b and c of type i nt (using
Integer.parselntO to convert
the command-line arguments),
automatic promotion would be
used to evaluate the expression
b*b - 4.0*c. First, c is promot
ed to doubl e to multiply by the
doubl e literal 4.0, with a doubl e
result. Then, the i nt value b*b is
promoted to doubl e for the sub
traction, leaving a doubl e result.
Or, we might have written b*b -
4*c. In that case,the expression b*b - 4*c would be evaluated as an i nt and then
the result promoted to doubl e, because that is what Math. sq rt () expects. Promo
tion isappropriate because your intent isclearand it can be done with no loss of in
formation. On the other hand, a conversion that might involveloss of information
(for example, assigning a doubl e to an i nt) leads to a compile-time error.
expression
expression
type
expression
value
"1234"
+ 99
String
"123499"
Integer.parselnt("123")
int
123
(int)
2.71828
int
2
Math.round(2.71828)
long
3
(int) Math.round(2.71828)
int
3
(int) Math.round(3.14159)
int
3
11 * 0.3
double
3.3
(int)
11 * 0.3
double
3.3
11 * (int) 0.3
int
0
(int)
(11 * 0.3)
int
3
Typical type conversions

1.2 Built-in Types of Data
y^j^^
u;
15
I
m
Program 1.2.5
Casting toget a random integer
public class Randomlnt
{
public static void main(String[] args)
{
int N = Integer.parselnt(args[0]);
double
r = Math.randomO;
// uniform between 0 and 1
int n = (int) (r * N);
// uniform between 0 and N-l
System.out.pri ntln(n);
}
}
This program uses theJava method Math.random() to generate a random number r in the
interval [0> l)y then multiplies r by thecommand-line argument Ntoget a random number
greater thanorequalto0 and less thanN, then uses a casttotruncate theresultto bean integer
n between 0 and N-l.
% javac Randomlnt.java
% java Randomlnt 1000
548
% java Randomlnt 1000
141
% java Randomlnt 1000000
135032
WMmmm
Casting has higher precedence than arithmetic operations—any cast is applied to
the value that immediately follows it. For example, if we write i nt n = (i nt) 11
* 0.3, the cast is no help: the literal 11 is alreadyan integer,so the cast (i nt) has
no effect. In this example, the compiler produces a possible loss of precision
error messagebecausethere would be a lossof precision in converting the resulting
value(3.3) to an i nt for assignmentto n.Theerror ishelpfulbecausethe intended
computation for this code is likely (i nt) (11 * 0.3), which has the value 3, not
3.3.
33

34
Elements of Programming
Beginning programmers tend to find typeconversion to be an annoyance, but expe
riencedprogrammers knowthat paying careful attention to data types is a keyto
success in programming. It iswell worthyourwhile to takethe time to understand
whattypeconversion isallabout. After youhave writtenjust a few programs, you
will understand that these rules help you to make your intentions explicitand to
avoid subtle bugs in your programs.
Summary
A data type is a set ofvalues and a set ofoperations on those values.
Java has eight primitive data types:boolean, char, byte, short, i nt, 1ong, f1oat,
and double. In Java code,we use operators and expressions likethose in familiar
mathematical expressions to invoke the operationsassociated with eachtype.The
boolean type is for computingwith the logical values true and false; the char
type isthe setof charactervalues that wetype;and the other sixare numeric types,
for computingwith numbers.In this book,we most often use boolean, i nt, and
doubl e; we do not use short or f1oat. Another data type that we use frequently,
Stri ng, is not primitive, but Java has somebuilt-in facilities for Stri ngs that are
like those for primitive types.
When programming in Java, wehaveto be aware that everyoperation is de
fined only in the contextof its data type (so we mayneed type conversions) and
that alltypescan haveonly a finite number of values (so we may need to live with
imprecise results).
The boolean type and its operations—&&, | |, and ! —are the basisfor logi
cal decision-making in Java programs,when used in conjunction with the mixed-
type comparison operators ==, !=, <, >, <=, and >=. Specifically, we use boolean
expressions to control Java's conditional(i f) and loop (for and whi 1e) constructs,
which we will study in detail in the next section.
The numeric types and Java's libraries giveus the ability to use Javaas an ex
tensive mathematical calculator.Wewrite arithmetic expressions using the built-in
operators +,-, *,/, and %along with Java methods from the Math library.Although
the programs in this section are quite rudimentary by the standards of what wewill
be able to do after the next section, this classof programs is quite useful in its own
right. You will use primitive types and basic mathematical functions extensively
in Java programming, so the effort that you spend now understanding them will
certainly be worthwhile.

1.2 Built-in Types of Data
Q. What happens if I forgetto declare a variable?
A, The compiler complains, as shown below for a program IntOpsBad, which is
the same as Program 1.2.2except that the i nt variable p is omitted from the decla
ration statement.
% javac IntOpsBad.java
IntOpsBad.java:7:
cannot resolve symbol
symbol
: variable p
location: class IntOpsBad
p = a * b;
A
IntOpsBad.java:10:
cannot resolve symbol
symbol
: variable p
location: class IntOpsBad
System.out.println(a + " * " + b + " -
2 errors
+ p);
A
The compiler says that there are two errors,but there isreallyjust one: the declara
tion of p ismissing. Ifyouforget to declare a variable thatyouuse often, youwill
getquite a fewerror messages. Agood strategyisto correctthefirst error and check
that correction before addressing later ones.
Q. What happens if I forgetto initialize a variable?
A. The compiler checks for this condition and will giveyou a variable might
not have been i ni ti al i zed error message if you try to use the variable in an
expression.
Q. Is there a difference between = and ==?
A. Yes, they are quite different! The first is an assignment operator that changes
the value of a variable, and the second is a comparison operator that produces a
bool ean result.Yourability to understand this answeris a sure test of whether you
understood the material in this section. Think about how you might explain the
difference to a friend.
35

Elements of Programming
Q. Whydo i nt valuessometime becomenegative when they get large?
A, If you havenot experiencedthis phenomenon, seeExercise 1.2.10. The problem
has to do with the wayintegers are represented in the computer. You can learn the
details on the booksite. In the meantime, a safestrategy is using the int type when
you know the valuesto be lessthan ten digitsand the 1ong type when you think the
values might get to be ten digits or more.
Q. It seems wrong that Java should just let i nts overflow and give bad values.
Shouldn't Javaautomatically check for overflow?
A. Yes, this issueis a contentious one among programmers. The short answer for
now is that the lack of such checkingis one reason such types are calledprimitive
data types.A little knowledgecan go a long wayin avoiding such problems. Again,
it is fine to use the i nt type for small numbers, but when values run into the bil
lions, you cannot.
Q. What is the value of Math, abs (-2147483648)?
A. -2147483648.Thisstrange (but true) resultisa typicalexampleof the effects of
integer overflow.
Q. It isannoyingto seeallthosedigitswhenprinting a f1oat or a double. Can we
get System. out. pri ntl n() to print out just two or three digits after the decimal
point?
A. That sort of task involves a closer look at the method used to convert from
double to String. The Java library function System.out.printf() is one way
to do the job,and it is similarto the basic printing method in the C programming
language and many modern languages, as discussed in Section 1.5.Until then, we
will live with the extra digits (which is not all bad, since doing so helps us to get
used to the different primitive types of numbers).
Q. Howcan I initialize a double variable to infinity?
A, Java has built-in constants available for this purpose: Double.POSITIVE_IN-
FINITY and Double.NEGATIVE INFINITY.

1.2 Built-in Types of Data
Q. What is the value of Math. round(6.022e23)?
A. You should get in the habit of typing in a tiny Java program to answer such
questions yourself (and trying to understand whyyour program produces the re
sult that it does).
Q. Can you compare a doubl e to an i nt?
A, Not without doing a type conversion, but rememberthat Java usuallydoes the
requisitetype conversionautomatically. For example, if x is an i nt with the value
3,then the expression (x < 3.1) is true—Java convertsx to doubl e (because 3.1
is a doubl e literal) before performing the comparison.
Q. Are expressionslike 1/0 and 1.0/0.0 legalin Java?
A. No and yes. The first generates a run-time exception for divisionby zero (which
stopsyour program becausethe valueisundefined); the secondislegaland has the
value Infinity.
Q. Arethere functions in Java's Math library for other trigonometric functions, like
cosecant, secant, and cotangent?
A. No,becauseyou could useMath.si n(), Math.cos (), and Math.tan () to com
putethem. Choosingwhichfunctions to includein anAPI isa tradeoffbetweenthe
convenience of having everyfunction that you need and the annoyance of having
to find one of the fewthat you need in a long list.No choicewill satisfyall users,
and the Java designers have manyusers to satisfy. Notethat thereareplentyof re
dundancies even in the APIsthat we havelisted.For example,you could use Math.
si n(x) /Math. cos (x) instead of Math. tan (x).
Q. Can you use <and >to compareStri ngvariables?
A. No. Those operators are defined only for primitive types.
Q. How about == and != ?
A. Yes, but the result maynot be whatyou expect, because of the meanings these
operators have fornon-primitive types. Forexample, thereisa distinction between

38
Elements of Programming
a String and its value. The expression "abcM == "ab" + x is false when x is a
Stri ng with value "c" becausethe two operands are stored in different places in
memory (even though they have the same value). This distinction is essential, as
you will learn when we discuss it in more detail in Section 3.1.
Q. What isthe result ofdivision andremainder fornegative integers?
A. The quotient a / b rounds toward0;the remainder a % b is defined such that
(a / b) * b + a % b is always equalto a. For example, -14/3 and 14/-3 areboth
-4, but -14 % 3 is -2 and 14 % -3 is 2.
Q. Will (a < b < c) test whether three numbers are in order?
A. No,that will not compile.You need to say(a < b && b < c).
Q. Fifteen digits for floating-point numberscertainly seemsenough to me. Do I
really need to worry much about precision?
A. Yes, because you are used to mathematics basedon real numbers with infinite
precision, whereas the computer always deals with approximations. For example,
(0.1 +0.1==0.2) is true but (0.1 +0.1 +0.1==0.3) is false! Pitfalls like this
are not at all unusualin scientific computing.Novice programmers should avoid
comparingtwo floating-point numbers forequality.
Q. Why do we say(a && b) andnot (a & b)?
A. Java also has a&operator thatwedo not use in thisbook but which you may
encounterif you pursueadvanced programming courses.
Q. Why is the value of 10A6 not 1000000but 12?
A. The a operator is not an exponentiation operator, which you must havebeen
thinking. Instead,it is an operatorlike &that we do not use in this book. You want
theliteral le6.You could also use Math. pow(10, 6) but doing soiswasteful if you
areraising10 to a known power.

1.2 Built-in Types of Data
1.2.1
Suppose that a and b are i nt values.What does the following sequence of
statements do?
int t
= a; b=t; a=b;
1.2.2
Write a program that uses Math.si n() and Math.cos () to check that the
value of cos2 0 + sin2 6 is approximately 1for any0 entered asa command-line argu
ment. Just print the value.Why are the valuesnot always exactly1?
1.2.3
Suppose that a and b are i nt values.Showthat the expression
(!(a && b) && (a || b)) || ((a && b) ||
!(a || b))
is equivalent to true.
1.2.4
Suppose that a and b are i nt values. Simplifythe following expression:
(!(a < b)
&& !(a > b)).
1.2.5
The exclusive oroperator a for boolean operands is defined to be true if
they are different, fal se if they are the same. Givea truth table for this function.
1.2.6
Why does 10/3 give 3 and not 3.333333333?
Solution. Sinceboth 10 and 3 are integer literals,Java seesno need for type conver
sion and usesintegerdivision.You shouldwrite10.0/3.0 ifyou mean the numbers
to be doubl e literals. If you write 10/3.0 or 10.0/3, Javadoes implicit conversion
to get the same result.
1.2.7
What do each of the following print?
a.
System.out.println(2 + "be");
b. System.out.println(2 + 3 + "be")
c.
System.out.println((2+3) + "be")
d. System.out.println("bc" + (2+3))
e.
System, out. pri ntl n("be" + 2 + 3)
Explain each outcome.

40
Elements of Programming
1.2.8
Explain how to use Program 1.2.3to find the square root of a number.
1.2.9
What do each of the followingprint?
a. System.out.printlnC'b1);
b. System.out.pn'ntln(fbf + 'c');
c. System.out.println((char) ("a1 + 4));
Explain each outcome.
1.2.10 Suppose that a variable a is declared as i nt a = 2147483647 (or equiva-
lently,Integer. MAX_VALUE). What do each of the followingprint?
a. System.out.println(a);
b. System.out.print!n(a+l);
c. System.out. pri ntln(2-a);
d. System.out.println(-2-a);
e. System. out. pri ntl n(2*a);
/
System.out.pri ntln(4*a);
Explain each outcome.
1.2.11 Suppose that avariable a isdeclared asdouble a = 3.14159.What do each
of the followingprint?
a. System, out. println (a);
b. System, out. pri ntl n(a+l);
c. System.out.println(8/(int) a);
d. System.out.println(8/a);
e. System. out. pri ntl n( (i nt) (8/a));
Explain each outcome.
1.2.12 Describewhat happens ifyou write sqrt instead of Math.sqrt in Program
1.2.3.
1.2.13 What is the value of (Math. sqrt(2) * Math. sqrt(2) == 2)

1.2 Built-in Types of Data
1.2.14 Write a program that takes two positive integers as command-line argu
ments and prints true if either evenlydivides the other.
1.2.15 Write a program that takes three positive integers as command-line argu
ments and prints t rue if any one of them is greater than or equal to the sum of the
other two and false otherwise. (Note: This computation tests whether the three
numbers could be the lengths of the sides of some triangle.)
1.2.16 A physicsstudent gets unexpected results when using the code
F = G * massl * mass2 /
r
* r;
to compute values according to the formula F = Gmxm21 r2.Explain the problem
and correct the code.
1.2.17 Givethe value of a after the execution of each of the following sequences:
int a = 1;
a
=
a
+
a;
a
=
a
+
a;
a
=
a
+
a;
boolean a = true;
a
= !a;
a
= !a;
a
= !a;
int a = 2;
a
= a
* a;
a
= a
* a;
a
= a
* a;
1.2.18 Suppose that x and y are doubl e values that represent the Cartesian coor
dinates ofa point (x,y) in the plane. Givean expression whose value is the distance
of the point from the origin.
1.2.19 Write a program that takestwo i nt valuesa and b from the command line
and prints a random integer between a and b.
1.2.20 Write a program that prints the sum of two random integers between 1 and
6 (such as you might get when rolling dice).
1.2.21 Write a program that takes a double value t from the command line and
prints the value of sin(2t) + sin(3t).
1.2.22 Write a program that takesthree doubl e valuesx0, v0, and t from the com
mand line and prints the valueof x0 + v0t + gt2/2, wheregisthe constant 9.78033.
(Note: This value the displacement in meters after t seconds when an object is
thrown straight up from initial position x0 at velocity v0 meters per second.)
1.2.23 Writea program that takes twoi nt values mand d from the command line
and prints true if dayd of month misbetween3/20and 6/20,f al se otherwise.

42
Elements of Programming
Creativ&ixeKcises
1.2.24 Loan payments. Write a program that calculates the monthly payments
you would have to make over a givennumber of years to pay off a loan at a given
interest rate compounded continuously,taking the number of years t,the principal
P, and the annual interest rate r as command-line arguments. The desired value is
given by the formula Pen. Use Math.exp().
1.2.25 Wind chill. Given the temperature t (in Fahrenheit) and the wind speed v
(in miles per hour), the NationalWeatherService definesthe effective temperature
(the wind chill) to be:
w = 35.74 + 0.6215 t + (0.4275 t - 35.75) v0-16
Write a program that takes two double command-line arguments t and v and
prints out the wind chill.UseMath.pow(a, b) to compute ab. Note:The formula is
not valid if tislarger than 50in absolutevalue or if vis larger than 120or lessthan
3 (you may assume that the valuesyou get are in that range).
1.2.26 Polar coordinates. Write a program that converts from Car
tesian to polar coordinates.Your program should take two real num
bers x and y on the command line and print the polar coordinates r
and 0. Usethe Javamethod Math.atan2 (y, x) which computes the
arctangent value ofy/x thatis intherange from -ir toit.
Polar coordinates
1.2.27 Gaussian random numbers. One way to generate a random
number taken from the Gaussian distribution is to use the Box-Muller formula
w = sin(2iTv) (-2lnt/)1/2
where u and v are real numbers between 0 and 1 generated by the Math. random()
method. Write a program StdCaussian that prints out a standard Gaussian ran
dom variable.
1.2.28 Order check. Write a program that takes three double values x, y, and z
ascommand-linearguments and prints true if the values are strictlyascending or
descending (x<y <zorx>y>z),and false otherwise.
1.2.29 Dayofthe week. Writea program that takesa date as input and prints the
day of the weekthat date falls on. Your program should take three command line

1.2 Built-in Types of Data
parameters: m(month), d (day), and y (year).For m, use 1 for January, 2 for Febru
ary,and so forth. For output, print 0 for Sunday, 1 for Monday, 2 for Tuesday, and
so forth. Usethe followingformulas, for the Gregorian calendar:
y0 =y-(U-m)l\2
*
=y0 + ro/4-Vioo+V4()o
m0 = m + 12 X ((14 - m)112) - 2
d0 = (d + x+(31Xm0)/12)%7
Example:
On what day of the weekwasFebruary 14,2000?
y0 = 2000 - 1 = 1999
x
=
1999 + 1999/4 -
1999/100 + 1999/400 = 2483
m0= 2 + 12X1 -2 = 12
d0 = (14 + 2483 + (31X12) /12) % 7 = 2500% 7 = 1
Answer:
Monday.
1.2.30 Uniform random numbers. Write a program that prints five uniform ran
dom values between 0 and 1, their average value, and their minimum and maxi
mum value. Use Math. random(), Math. min(), and Math. max().
1.2.31 Mercatorprojection. The Mercatorprojection isa conformal (angle preserv
ing) projection that maps latitude 9 and longitude Xto rectangular coordinates
(x,y). It is widely used—for example, in nautical charts and in the maps that you
print from the web. The projection is defined by the equations x = X —X0 and
y = 1/2 In((1 + sincp) / (1 —sincp)), where X0 is the longitude of the point in the
center of the map. Write a program that takes\0 and the latitude and longitude of
a point from the command line and prints its projection.
1.2.32 Color conversion. Severaldifferent formats are used to represent color. For
example, the primary format for LCD displays, digital cameras, and web pages,
known as the RGB format, specifies the level of red (R), green (G), and blue (B)
on an integer scale from 0 to 255. The primary format for publishing books and
magazines, known as the CMYKformat, specifies the level of cyan (C), magenta
(M), yellow (Y), and black (K) on a real scalefrom 0.0 to 1.0.Write a program RG-
BtoCMYK that converts RGBto CMYK. Takethree integers—r, g, and b—from the

Elements of Programming
command line and print the equivalent CMYK values. If the RGB values are all 0,
then the CMY values are all 0 and the K value is 1; otherwise, use these formulas:
w = max(r/255,g/255,b/255)
c = (w-(r/255))/w
m = (w-(g/255)) Iw
y = (w-(fo/255)) Iw
k = 1 — w
1.2.33 Great circle. Write a program GreatCi rcl e that takes four command-line
arguments—xl, yl, x2, and y2—(the latitude and longitude, in degrees, of two
points on the earth) and prints out the great-circle distance between them. The
great-circle distance (in nautical miles)is givenby the equation:
d = 60 arccos(sin(x1) sin(x2) + cos^) cos(x2) cos(yx —y2))
Note that this equation uses degrees,whereas Java's trigonometric functions use
radians. Use Math.toRadiansO and Math.toDegreesO to convert between the
two. Useyour program to compute the great-circle distance between Paris (48.87°
N and -2.33° W) and San Francisco (37.8° N and 122.4° W).
1.2.34 Three-sort. Write a program that takesthree int values from the command
line and prints them in ascending order. UseMath.mi n() and Math.max().
1.2.35 Dragon curves. Write a program to print
the instructions for drawing the dragon curves of
order 0 through 5. The instructions are strings of
F, L, and R characters, where F means "draw line
while moving 1 unit forward,'' Lmeans "turn left,"
and Rmeans "turn right." A dragon curve of order
N is formed when you fold a strip of paper in half N
times, then unfold to right angles.The keyto solving
this problem is to note that a curve of order N is a
curve of order N— 1 followed by an Lfollowed by a
curve of order N—1 traversed in reverse order, and
then to figure out a similar description for the reverse curve
j
b
FLF
FLFLFRF
FLFLFRFLFLFRFRF
Dragoncurves of order 0, ly2, and 3

1.2 Built-in Types of Data
45

Elements of Programming
1.3
Conditionals and Loops
In the programsthat wehaveexamined to this point, each of the statements in the
program isexecutedonce,in the order given. Mostprograms aremore complicated
because the sequence of statements and the number of times each is executedcan
vary.Weuse the term controlflowto referto statement sequencing in a program. In
this section, we introduce statements that
allowus to changethe control flow, using
1.3.1
Flipping afair coin
49
logic about the values of program vari-
1.3.2
Your first while loop
51
ables. This feature is an essential compo-
L3'3
Computing powers oftwo
53
r
.
1.3.4
Your first nested loops
59
nent ofprogramming.
135 Harmonic numbers
61
Specifically, we consider Java state-
L3.6
Newton's method
62
ments that implement conditionals,where
1.3.7
Converting tobinary
64
some other statements may or may not
L3-8
Gambler's ruin simulation
66
be executed depending on certain condi-
L3'9 Factoring integers
69
tions, andloops, where some other state-
Programs in this section
ments may be executed multiple times,
again depending on certain conditions. Asyou will see in numerous examples in
this section, conditionals and loops truly harness the power of the computer and
will equip you to write programs to accomplish a broad variety of tasks that you
could not contemplate attempting without a computer.
If statements
Mostcomputations requiredifferentactionsfor differentinputs.
One wayto express these differencesin Javais the i f statement:
if (<boolean expression)
{ <statements> }
This description introduces a formal notation known as a template that we will
use to specifythe format of Java constructs. We put within angle brackets (< >) a
construct that we have alreadydefined,to indicate that we can use any instance of
that construct where specified. In this case, <boolean expression> represents an
expression that has a boolean value,such as one involving a comparison operation,
and <statements> represents a statement block (a sequence of Java statements,
each terminated by a semicolon). This latter construct is familiar to you: the body
of mai n() is such a sequence.If the sequenceis a singlestatement, the curly braces
are optional. It is possible to make formal definitions of <boolean expression
and <statements>> but werefrainfromgoinginto that level of detail.The meaning

1.3 Conditionals and Loops
of an i f statement is self-explanatory: the statement(s) in the sequenceare to be
executedif and only if the expressionis true.
Asa simple example,supposethat you want to compute the absolute value of
an i nt value x.This statement does the job:
47
if (x < 0) x = -x;
Asa second simple example, consider the followingstatement:
if (x > y)
{
int t
= x;
x
=
y;
y
= t;
}
boolean
expression
\
{
z (|x > y|)
•
ts
int t
= x;
x
=
y;
y
= t;
sequence
statements
}
Anatomyof an i f statement
This code puts x and y in ascendingorder by exchangingthem if
necessary.
You can also add an el se clauseto an i f statement, to expressthe concept of
executingeither one statement (or sequenceof statements) or another, depending
on whether the boolean expression is true or fal se, asin the following template:
if (<boolean expression^ <statements T>
else
<statements
F>
As a simple example of the need for an el se clause, consider the following code,
which assigns the maximum oftwo i nt values to the variable max:
if (x > y) max = x;
else
max = y;
One wayto understand control flowis to visualize it with a diagram called aflow
chart. Paths through the flowchartcorrespond to flow-of-controlpaths in the pro-
if (x < 0)
x = -x;
yf-d
\
<
0
?
-x;
if (x > y) max = x;
else
max = y;
\
yes
/
r\
no
max
=
x;
—czz
max
=
y;
zzi—
Flowchartexamples (i f statements)

48
absolute value
putx andy
into
sorted order
maximum of
x andy
error check
for division
operation
error check
for quadratic
formula
if (x < 0)
x = -x;
if (x > y)
{
int t
= x;
y
=
x;
x
= t;
}
if (x > y) max = x;
else
max = y;
Elements of Programming
if (den == 0) System.out.println("Division by zero");
else
System.out.println("Quotient = " + num/den);
double discriminant = b*b - 4.0*c;
if (discriminant < 0.0)
{
System.out.println("No real roots");
}
else
{
System.out.println((-b + Math.sqrt(discriminant))/2.0);
System.out.println((-b - Math.sqrt(discriminant))/2.0);
}
Typical examples ofusing i f statements
gram.In the earlydaysof computing,whenprogrammers usedlow-level languages
and difficult-to-understand flows of control, flowcharts were an essential part of
programming.With modern languages, weuseflowcharts just to understand basic
building blockslike the i f statement.
The accompanying table contains some examples of the use of i f and i f-
el se statements.Theseexamples aretypicalof simple calculationsyou might need
in programs that you write. Conditional statements are an essential part of pro
gramming.Since the semantics (meaning)of statementsliketheseissimilarto their
meanings as natural-language phrases, you will quickly grow used to them.
Program 1.3.1 is another example of the use of the if-else statement, in
this case for the task of simulating a coin flip. The body of the program is a single
statement, like the ones in the table above,but it is worth special attention because
it introduces an interesting philosophical issue that is worth contemplating: can a
computer program produce random values?Certainly not, but a program canpro
duce numbers that have many of the properties of random numbers.

1.3 Conditionals and Loops
^^^^^^^M
|§j
Program 1.3.1
Flipping afair coin
public class Flip
{
public static void main(String[] args)
{
// Simulate a coin flip.
if (Math.randomO < 0.5) System.out.println("Heads");
else
System.out.pri ntln("TaiIs");
}
}
This program uses Math. random() to simulate a coin flip. Each time you run it, itprints either
heads ortails. A sequence offlips will have many ofthe same properties asa sequence that you
would getbyflipping afair coin, hut itisnot a truly random sequence.
Many computations areinherently repetitive. The basic Java con
struct for handlingsuchcomputationshasthe following format:
while (<boolean expression} { <statements> }
The whi 1e statementhasthe sameformasthe i f statement(theonlydifference be
ingthe useofthe keywordwhi 1e instead of i f), but the meaningis quite different.
It is an instruction to the computer to behave asfollows: ifthe expression is fal se,
do nothing;if the expression is true, execute the sequence of statements (just as
with i f) but then check the expressionagain, executethe sequence of statements
again if the expressionis true, and continue aslong asthe expression is true. We
often refer to the statementblockin aloop as the body of the loop.As with the i f
statement, the braces areoptional if awhi1e loop body has just one statement.
The whi1e statement is equivalent to a sequenceofidentical i f statements:
49

50
Elements of Programming
if (<boolean expression^
if (<boolean expression^
if Q<boolean expression^
{ <statements> }
{ <statements> }
{ <statements> }
initialization is a
separate statement
int
v
while
loop
continuation
condition
= i;
/
(|v <= N/21)
braces are
f
optional ^
whenbody
is asingle ^
statement
At some point, the code in one of the statements must
changesomething (such as the valueof some variablein
the boolean expression) to make the boolean expression
f al se, and then the sequence is broken.
A common programming paradigm involves main
taining an integervaluethat keeps track of the number of
times a loop iterates. We start at some initialvalue, and then increment the value
by 1eachtime through the loop,testingwhetherit exceeds a predetermined maxi
mum before deciding to continue. TenHellos
(Program 1.3.2)is a simple example of this para
digmthat usesa whi 1e statement.The keyto the
computation is the statement
}
v = 2*v;
t
body
Anatomy ofa whi1e loop
int i = 4;
while (i <
{
System.out.pri ntln(i
i = i + 1;
10)
+ "th Hello");
= 4;
.(i <= io ? y
\yes
System.out.println(i + "th Hello");
_L
i
+ 1;
zi
f
Flowchart example (whilestatement)
i
= i +1;
As a mathematical equation, this statement is
nonsense, but as a Java assignment statement it
makesperfect sense:it saysto compute the value
i + 1 and then assignthe result to the variable i.
Ifthe value of i was 4 before the statement, it be
comes 5 afterwards; if it was 5 it becomes 6; and
so forth. With the initial condition in TenHel 1os
that the value of i starts at 4, the statement block
is executed five times until the sequence is bro
ken, when the value of i becomes 11.
Using the whi 1e loop is barelyworthwhile for this simple task,but you will
soon be addressing taskswhere you willneed to specifythat statements be repeated
far too many times to contemplate doing it without loops. There is a profound
difference between programs with whi 1e statements and programs without them,
because while statements allow us to specify a potentially unlimited number of
statements to be executed in a program. In particular, the whi1e statement allows
us to specify lengthy computations in short programs. This ability opens the door
to writing programs for tasks that we could not contemplate addressing without a

7.3 Conditionals and Loops
Program 1.3.2
Yourfirst while loop
public class TenHellos
{
public static void main(String[] args)
{
// Print 10 Helios.
System.out.pri ntln("1st Hel1o");
System.out.println("2nd Hello");
System.out.println("3rd Hello");
int i
= 4;
while (i
<= 10)
{
// Print the ith Hello.
System.out.println(i + "th Hello");
i = i + 1;
}
}
This program uses a while loop for the simple, repetitive task ofprinting the output shown
below. After the third line, the lines to be printed differ only in the value of the index counting
the line printed, so we define a variable i to contain that index. After initializing the value of
i to4, weenter into a whi 1e loop where weuse the value ofi in the System. out .pri ntl n()
statement and increment it each time through the loop. After printing 10th Hel 1o, the value
ofi becomes 11 and theloop terminates.
% Java TenHellos
1st Hello
2nd Hello
3rd Hello
4th Hello
5th Hello
6th Hello
7th Hello
8th Hello
9th Hello
10th Hello
>immm
I
4
5
6
7
8
9
10
11
i
<= 10
true
true
true
true
true
true
true
false
output
4th Hello
5th Hello
6th Hello
7th Hello
8th Hello
9th Hello
10th Hello
Trace ofj ava TenHel 1os
51

52
Elements of Programming
computer. But there is also a price to pay: as your pro
grams become more sophisticated, they become more
difficult to understand.
PowersOfTwo (Program 1.3.3) uses a while loop
to print out a table of the powersof 2.Beyondthe loop
control counter i, it maintains a variable v that holds
the powersof two as it computesthem. The loop body
contains three statements: one to print the current
power of 2,one to compute the next (multiplythe cur
rent one by 2), and one to increment the loop control
counter.
There are many situations in computer science
where it is useful to be familiar with powers of 2. You
should know at least the first 10 values in this table
and you should note that 210 isabout 1thousand, 220 is
about 1 million, and 230 is about 1 billion.
PowersOfTwo is the prototype for many use
ful computations. By varying the computations that
change the accumulated value and the way that the
loop control variable is incremented, we can print out
tablesof a varietyof functions (seeExercise 1.3.11).
It is worthwhile to carefullyexamine the behav
ior of programs that use loops by studying a trace of
the program. For example, a trace of the operation of
PowersOfTwo should show the value of each variable
before each iteration of the loop and the value of the
conditional expression that controls the loop. Trac
ing the operation of a loop can be verytedious,but it
is nearly always worthwhile to run a trace because it
clearlyexposeswhat a program is doing.
PowersOfTwo is nearly a self-tracing program,
because it prints the values of its variables each time
through the loop. Clearly, you can make any program
produce a trace of itselfby adding appropriate System.
out. pri ntl n() statements. Modern programming en
vironments provide sophisticated tools for tracing, but
i
<=
N
0
1
true
1
2
true
2
4
true
3
8
true
4
16
true
5
32
true
6
64
true
7
128
true
8
256
true
9
512
true
10
1024
true
11
2048
true
12
4096
true
13
8192
true
14
16384
true
15
32768
true
16
65536
true
17
131072
true
18
262144
true
19
524288
true
20
1048576
true
21
2097152
true
22
4194304
true
23
8388608
true
24
16777216
true
25
33554432
true
26
67108864
true
27
134217728
true
28
268435456
true
29
536870912
true
30
1073741824
false
Trace of jawa PowersOfTwo 29

13 Conditionals and Loops
53
Program 1.3.3
Computingpowers of two
public class PowersOfTwo
{
public static void main(String[] args)
{
// Print the first N powers of 2.
int N = Integer.parselnt(args[0]);
int v = 1;
int i
= 0;
while (i
<= N)
{
// Print ith power of 2.
System.out,println(i + "
v
= 2 * v;
i
= i
+ 1;
loop termination value
loopcontrol counter
current powerof2
8
IS
''^*$!5sSli£^CT
+ v);
}
}
This program takes a command-line argument Nand prints a table ofthe powers of2 that are
less than or equal to 2N. Each time through the loop, we increment the value ofi and double
the value ofv. We show only the first three and the last three lines ofthe table; the program
prints N+l lines.
% Java PowersOfTwo 5
0
1
1
2
2
4
3
8
4
16
5
32
i
'"^^p^^^^^^^^w^^^^^^^^^^^
% Java PowersOfTwo 29
0
1
1
2
2
4
27 134217728
28 268435456
29
536870912
$
l
"^^^^^^J^^^^fif^^??^
SlWHf
SSFS^Sp^Sgi^B^aKj
this tried-and-truemethod is simpleand effective. You certainly should add print
statements to the first fewloopsthat you write,to be surethat they are doing pre
ciselywhat you expect.
There is a hidden trap in PowersOfTwo, because the largest integer in Java's
i nt data type is 231 - 1 and the program does not test for that possibility. If you

54
Elements of Programming
invoke it with Java PowersOfTwo 31, you may be surprised by the lastline of
output:
1073741824
-2147483648
The variable v becomestoo large andtakeson anegative valuebecause of the way
Java represents integers. The maximumvalue of ani nt is available for usto useas
Integer. MAX_VALUE. A better version ofProgram 1.3.3would use this value to test
for overflow and print an error message if the usertypes too large avalue,though
getting sucha program to work properly for all inputs is trickier than you might
think. (Fora similarchallenge, seeExercise 1.3.14.)
As a more complicated example, suppose that we
want to compute the largest power of two that is less
than or equalto a given positiveinteger N. If Nis 13 we
want the result 8;if Nis 1000, we want the result 512; if N
is 64, we want the result 64;and so forth. This computa
tion is simple to perform with awhi1e loop:
int v = 1;
while (v <= N/2)
v
= 2*v;
It takes some thought to convinceyourselfthat this sim
plepieceofcode produces the desired result. You cando
so by making these observations:
• v is always a power of 2.
• v is never greaterthan N.
• v increases each time through the loop, so the loop
must terminate.
• After the loop terminates, 2*v is greater than N.
Reasoning ofthis sort is often important in understandinghow whi1e loops work.
Eventhough many ofthe loops you will write aremuch simpler than this one, you
should be sure to convince yourself that eachloop you write is going to behave as
you expect.
The logic behind such arguments is the same whether the loop iterates just
a few times, as in TenHellos, dozens of times, as in PowersOfTwo, or millions of
times, as in severalexamples that we will soon consider. That leap from a few tiny
casesto a huge computation is profound. When writing loops, understanding how
*
int v = 1;
\
rc
v <= N/2 ?
""Xrto
jf yes
v = 2*v;
i
r
Flowchartfor thestatements
int v = 1;
while (v <= N/2)
v
= 2*v;

1.3 Conditionals and Loops
thevalues of thevariables change each time through theloop (andchecking that
understanding byadding statements to trace theirvalues and runningfor a small
number of iterations) is essential. Having done so, you can confidently remove
thosetrainingwheels andtrulyunleash thepower ofthecomputer.
For loops
As you will see, thewhi 1e loop allows us to write programs for all
manner of applications. Before considering more examples, wewilllook at an al
ternate Java construct that allows us evenmore flexibility when writing programs
with loops. This alternate notation is not fundamentally different from the basic
whi 1e loop,but it is widely usedbecause it oftenallows us to write more compact
and more readableprograms than if weusedonlywhi 1e statements.
Fornotation. Manyloopsfollow this scheme: initialize an indexvariable to some
value and then use a while loop to test a loop continuation conditioninvolving
the indexvariable, wherethe laststatementin the whi 1e loopincrementsthe index
variable. You can express suchloopsdirectly with Java's for notation:
for (<initialize>m, <boolean expression>; <increment>)
{
<statements>
}
This codeis,with only a fewexceptions, equivalent to
<initialize>;
while (<boolean expression^
{
<statements>
<increment>m,
}
Your Java compilermight evenproduce identicalresultsfor the two loops. In truth,
<initia 7ize> and <increment> canbeanystatements at all, but wenearlyalways
usefor loopsto support thistypical initialize-and-increment programmingidiom.
For example, the following two linesof codeare equivalent to the corresponding
lines of code in TenHellos (Program 1.3.2):
for (int i
= 4;
i
<= 10;
i
= i
+ 1)
System.out.println(i + "th Hello");
55

56
Elements of Programming
Typically, we work with a slightly more compact version of this code, using the
shorthand notation discussed next.
Compound assignment idioms. Modifying the value of a variable is something
that wedo sooftenin programming that Java provides avarietyof different short
hand notationsfor the purpose.Forexample, the following four statementsallin
crement the value of i by 1 in Java:
i
= i
+ 1;
i ++;
++i;
i
+= 1;
You canalso say i -- or --i or i -= 1or i = i -1 to decrementthat value of i by1.
Mostprogrammers usei ++ or i -- in for loops, thoughanyoftheotherswoulddo.
The ++ and -- constructs are normallyused for integers,but the compound assign
mentconstructs are useful operations for any arithmetic operator in any primitive
numerictype. Forexample, youcansay v *= 2 or v += v instead of v = 2*v. All
of theseidiomsarefor notational convenience, nothing more.This combination of
shortcuts cameinto widespreadusewiththe C programming languagein the 1970s
and havebecomestandard.Theyhavesurvivedthe test of time becausetheyleadto
compact, elegant, and easily understood programs. When you learn to write (and
to read) programsthat usethem,youwill be ableto transferthat skill to program
ming in numerous modern languages, not just Java.
Scope. Thescope of avariable isthe part of the programwhereit isdefined. Gen
erally the scope of a variable is comprised of the statementsthat follow the decla
ration in the same block as the declaration. For this purpose, the code in the for
loop header is consideredto be in the sameblockasthe for loop body. Therefore,
the whi 1e and for formulations of loops are not quite equivalent:in a typical for
loop,the incrementing variable is not available for use in later statements; in the
corresponding whi 1e loop, it is. This distinction is often a reason to use a whi 1e
instead of a for loop.
Choosing among different formulations of the same computation is a matter of
eachprogrammer's taste,aswhen a writer picksfrom among synonymsor chooses
between using active and passive voice when composing a sentence.You will not
find good hard-and-fast rules on how to compose a program any more than you
willfind such rules on how to compose a paragraph. Yourgoal should be to find a
stylethat suitsyou, getsthe computation done, and can be appreciated by others.

1.3 Conditionals and Loops
57
The accompanyingtableincludes
several code fragments with typical
examples of loops used in Java code.
Some of these relate to code that you
have alreadyseen;others arenew code
for straightforward computations. To
cement your understanding of loops
in Java, put these code snippets into a
class's codethat takesanintegerNfrom
the command line (like PowersOfTwo)
and compileand run them.Then, write
some loops of your own for similar computations of your own invention, or do
some of the earlyexercises at the end of this section.There is no substitute for the
experience gained by running code that you create yourself, and it is imperative
thatyou develop anunderstanding of howto writeJava code that uses loops.
initialize another
variable in a
separate .
statement^.
declare and initialize
a loopcontrolvariable
\
l00P
\
continuation
\
condition
increment
int v =1;\
|
/
for (|int i = Ofc |i <= Nfc [i++~l)
{
printlargest powerof two
less than orequaltoN
compute afinite sum
(1+2 + ...+N)
compute afiniteproduct
(N! = 1x2 x ... x N)
printa table of
function values
print therulerfunction
(seeProgram 1.2.1)
}
System.out.pri ntln(i
v = 2*v;
t
body
+ v);
Anatomy ofa for loop (thatprintspowers of2)
int v = 1;
while (v <= N/2)
v = 2*v;
System.out.p ri ntln(v);
int sum = 0;
for (int i = 1; i <= N;
i++)
sum += i;
System.out.pri ntln(sum);
int product = 1;
for (int i = 1; i <= N;
i++)
product *= i;
System.out.pri ntln(product);
for (int i = 0; i <= N;
i++)
System.out.println(i + " ' + 2*Math.PI*i/N);
String ruler = " ";
for (int i
= 1;
i
<= N; i++)
ruler = ruler + i
+ ruler;
System.out.pri ntln(ruler);
Typical examples of usingfor and whi 1e statements

58
Elements of Programming
Nesting
The i f, whi1e, and for statements have the same status as assignment
statements or any other statements in Java. That is, we can use them whenever a
statement iscalledfor.In particular,wecan use one or more of them in the <body>
of another to make compound statements. As a first example, DivisorPattern
(Program 1.3.4) has a for loop whose statements are a for loop (whose statement
is an i f statement) and a print statement. It prints a pattern of asteriskswhere the
ith row has an asterisk in each position corresponding to divisors of i (the same
holds true for the columns).
Toemphasize the nesting,we use indentation in the program code.Werefer
to the i loop asthe outerloop and the j loopasthe inner loop.The inner loop iter
atesallthe waythrough for eachiterationof the outer loop.Asusual,the bestway
to understand a newprogramming construct likethis isto study a trace.
Di vi sorPattern has a complicatedcontrol structure, asyou can seefrom its
flowchart. A diagram like this illustrates the importance of using a limited num
ber of simple control structures in programming. With nesting, you can compose
loopsand conditionals to buildprograms that areeasy to understandeven though
theymayhave a complicated controlstructure. Agreatmanyuseful computations
canbe accomplished withjust one or twolevels of nesting.Forexample, manypro
grams in this book havethe samegeneralstructure as Di vi sorPattern.
i
= i;
T
7}—»( i <= N?)
\ yes
j = i;
T
j++; [_^( j <= N?y
\ yes
>!L((i %j == 0) || (j %i == 0) ?yz
System.out.print("* ");
System.out.print("
");
System.out.pri ntln(i);
I
I
Flowchartfor Di vi so rPattern

1.3 Conditionals and Loops
&fiffl£^^
Program 1.3.4
Your first nested loops
public class DivisorPattern
{
public static void main(String[] args)
{
// Print a square that visualizes divisors,
int N = Integer.parselnt(args[0]);
for (int i
= 1;
i
<= N; i++)
{
// Print the ith line
for (int j = 1;
j
<= N; j++)
{
// Print the jth entry in the ith line,
if ((i % j ==0) || (j % i
== 0))
System.out.print("* ");
else
System.out.print("
}
}
System.out.pri ntln(i);
");
59
iL^£&?\&.-irt •}•'>$&£ 1'^""'
number of rows
and columns
row index
column index
'•mmmmmk V|P J^Bp^sP^
m
i
i
1
m
This program takes aninteger Hasthe command-line argument and uses nested for loops to
printan H-by-H table with anasterisk in row i andcolumn j ifeither i divides j orj divides
i. The loop control variables i andj control the computation.
% Java DivisorPattern 3
*
*
*
i
*
*
2
*
*
3
% Java DivisorPattern 16
*
*
2
*
3
*
4
*
5
6
*
7
*
8
9
10
11
12
*
13
*
14
*
15
*
16
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
I
4jjyjujim^
J^s*£B^ft<8»5immmmmmmsF
i
j
i % j
j % i
1
1
1
2
1
3
2
1
2
2
2
3
3
1
3
2
3
3
0
0
0
1
0
1
1
2
0
output
Trace of Java DivisorPattern 3
i

60
Elements of Programming
As a secondexample of nesting, consider the following program fragment,
which atax preparation programmight use to compute income tax rates:
if
(income
<
0) rate = 0.0;
else if (income
<
47450)
rate =
.22;
else if (income
<
114650)
rate =
.25;
else if (income
<
174700)
rate «
.28;
else if (income
<
311950)
rate =
.33;
else
rate =
.35;
In this case, a number of i f statements are nested to test from among a number
of mutually exclusive possibilities. Thisconstruct isaspecial onethatweuseoften.
Otherwise, it is best to use braces to resolve ambiguities when nesting i f state
ments. This issueand more examples are addressed in the Q&A and exercises.
Applications
Theability to program withloops immediately opens upthe full
world of computation. To emphasize this fact, wenext consider avariety of exam
ples. These examples all involve working withthetypes of data thatweconsidered
in Section 1.2, but rest assured that the same mechanisms serve us well for any
computational application. The sample programs are carefully crafted, and by
studying andappreciating them,youwillbe prepared to writeyourown programs
containing loops, as requested in manyof the exercises atthe end of this section.
The examples that we consider here involve computingwith numbers. Sev
eral of our examples are tied to problems faced by mathematicians and scientists
throughout the past several centuries. While computers have existed for only 50
years or so, many of the computational methods thatweuse are based on a rich
mathematical tradition tracingback to antiquity.
Finite sum. The computational paradigm used by PowersOfT
wo isone that you willuse frequently. It uses two variables—one
as an index that controlsa loop and the other to accumulate a
computational result. Harmonic (Program 1.3.5) usesthe same
paradigm to evaluate the finite sum HN = 1 + 1/2 + 1/3 + ... +
1/N. These numbers, which are known as the Harmonic num
bers, arise frequently in discrete mathematics. Harmonic numbersare the discrete
analog of the logarithm. They also approximate the area under the curvey = l/x.
You can use Program1.3.5 asamodel for computing the valuesofother sums (see
Exercise 1.3.16).
Trrm

1.3 Conditionals and Loops
Program 1.3.5
Harmonic numbers
public class Harmonic
{
public static void main(String[] args)
{
// Compute the Nth Harmonic number.
int N = Integer.parselnt(args[0]);
double sum = 0.0;
for (int i
= 1;
i
<= N; i++)
{
// Add the ith term to the sum
sum += 1.0/i;
}
System.out.pri ntln(sum);
}
}
N
i
sum
61
number of terms in sum
loopindex
cumulated sum
-^mmmmmmmmmmmm
Thisprogram computes the value ofthe NthHarmonic number. The value isknownfrom math
ematical analysis tobeabout ln(N) + 0.57721 for large N. NotethatIn(lOOOO) ~ 9.21034.
% Java Harmonic 2
1.5
% Java Harmonic 10
2.9289682539682538
% Java Harmonic 10000
9.787606036044348
Hi
I
1
Computing thesquareroot. Howare functions in Java's Math li
brary,such as Math.sqrt(), implemented? Sqrt (Program 1.3.6)
illustrates one technique. To compute the square root function, it
uses an iterativecomputation that wasknown to the Babylonians
over 4,000 years ago. It is also a special case of a general com
putational technique that was developed in the 17th century by
Isaac Newton and Joseph Raphson and is widely known as New
ton's method. Under generousconditions on a given function/(x),
Newton's method is an effective way to find roots (values of x for
which the function is0). Startwith aninitialestimate,t0. Giventhe
j^^S^f^
y=f(x)-
Newtons method

62
Elements of Programming
Program 1.3.6
Newton's method
m
mm
public class Sqrt
{
public static void main(String[] args)
{
double c = Double.parseDouble(args[0]);
double epsilon = le-15;
double t
= c;
while (Math.abs(t - c/t) > epsilon * t)
{
// Replace t by the average of t and c/t
t = (c/t + t) / 2.0;
}
System.out.pri ntln(t);
argument
error tolerance
estimate ofc
}
y
Thisprogram computes thesquare root ofitscommand-line argument to15decimalplaces of
accuracy, using Newton's method (see text).
% Java Sqrt 2.0
1.414213562373095
% Java Sqrt 2544545
1595.1630010754388
4»»yji
wmwmf?
estimate tiy compute
a new estimate by
drawing a line tan
gent to the curve y
-fix) at the point (*,-,/(*,•)) and set ti+l to the x-coordinate of the point where that
line hits the x-axis. Iterating this process,we get closer to the root.
Computing the squareroot ofapositivenumber cis equivalent to finding the
positive root of the function f(x) = x2 - c. Forthis specialcase, Newton's method
amounts to the process implemented in Sqrt (see Exercise 1.3.17). Start with the
estimate t = c.If tis equal to c/t, then t is equal to the square root of c,so the com
putation is complete. If not, refinethe estimate by replacingt with the average of t
iteration
2.0000000000000000
1
1.5000000000000000
2
1.4166666666666665
3
1.4142156862745097
4
1.4142135623746899
5
1.4142135623730950
1.0
1.3333333333333333
1.4117647058823530
1.4142114384748700
1.4142135623715002
1.4142135623730951
JWMWW
Trace ofJava Sqrt 2,
mmmmmmmmmmmmm
o
!

1.3 Conditionals and Loops
and c/t.With Newton's method, we get the valueof the
square root of 2 accurate to 15placesin just 5 iterations
of the loop.
Newton's method is important in scientificcom
puting because the same iterative approach is effec
tive for finding the roots of a broad class of functions,
including many for which analytic solutions are not
known (so the Java Math library would be no help).
Nowadays, we take for granted that we can find what
ever values we need of mathematical functions; before
computers, scientists and engineers had to use tables or
computed values by hand. Computational techniques
that were developed to enable calculations by hand
needed to be very efficient, so it is not surprising that
many of those same techniques are effective when we
use computers. Newton's method is a classicexample of
this phenomenon. Another useful approach for evalu
ating mathematical functions is to use Taylorseriesex
pansions (see Exercises 1.3.35-36).
Number conversion. Binary (Program 1.3.7) prints
the binary (base 2) representation of the decimal num
ber typed as the command-line argument. It isbased on
decomposing a number into a sum of powers of two.
For example, the binary representation of 19 is 10011,
which is the same as saying that 19 = 16 + 2 + 1. To
compute the binary representation of N, weconsider the
powers of 2 less than or equal to Nin decreasing order
to determine which belong in the binary decomposi
tion (and therefore correspond to a 1 bit in the binary
representation). The process corresponds precisely to
using a balance scale to weigh an object, using weights
whose values are powers of two. First, we find largest
weight not heavier than the object. Then, considering
the weights in decreasing order, we add each weight to
test whether the object is lighter. If so, we remove the
greaterthan 16
1????
less than 16 + 8
less than 16 + 4
100??
63
greaterthan 16+ 2
1001?
equal to 16 + 2+1
10011
10000+10+1
=
10011
Scaleanalog to binaryconversion

64
Elements of Programming
Siligt^^
•*:?.
W
m
1
m
m%0
p
i
i
i
®|
18
Program 1.3.7
Convertingto binary
public class Binary
{
public static void main(String[] args)
{
// Print binary representation of N.
int N = Integer.parselnt(args[0]);
int v = 1;
while (v <= N/2)
v
= 2*v;
// Now v is the largest power of 2 <= N.
int n = N;
while (v > 0)
{
// Cast out powers of 2 in decreasing order.
if (n < v) { System.out.print(0);
else
{ System.out.print(l);
n
v = v/2;
}
System.out.pri ntln();
-=
v;
integer to convert
currentpowerof2
current excess
Thisprogram printsthebinary representation ofapositive integer givenas thecommand-line
argument, bycasting outpowers of2 in decreasing order (seetext).
% Java Binary 19
10011
% Java Binary 100000000
101111101011110000100000000
Z&VST&Si^!^^S^*3^'i^K;^^»5^S»^p^^^a^
^^Q
weight; if not, we leavethe weight and try the next one. Eachweight corresponds to
abit in the binary representationofthe weight ofthe object:leavingaweight corre
sponds to a 1bit in the binary representation ofthe object'sweight, and removing a
weight corresponds to a0 bit in the binary representation ofthe object's weight.
In Binary, the variablev corresponds to the current weight being tested, and
the variable n accounts for the excess (unknown) part of the object's weight (to

1.3 Conditionals and Loops
n
binary
representation
V
v
>
0
binary
representation
n
<
v
output
19
10011
16
true
10000
false
1
3
0011
8
true
1000
true
0
3
Oil
4
true
100
true
0
3
01
2
true
10
false
1
1
1
1
true
1
false
1
0
0
false
Trace of'casting-out-powers-oftwo loopfor Java Binary 19
simulate leaving a weight on the balance,wejust subtract that weight from n). The
value of v decreases through the powersof two.When it is larger than n, Binary
prints 0; otherwise, it prints 1 and subtracts v from n.As usual, a trace (of the val
ues of n, v, n < v, and the output bit for each loop iteration) can be very useful in
helping you to understand the program. Read from top to bottom in the rightmost
column of the trace, the output is 10011, the binary representation of 19.
Converting data from one representation to another is a frequent theme in
writing computer programs. Thinking about conversion emphasizes the distinc
tion between an abstraction (an integer like the number of hours in a day) and a
representation of that abstraction (24 or 11000). The irony here is that the com
puter's representation of an integer is actuallybased on its binary representation.
Simulation. Our next example isdifferent in char
acter from the ones we have been considering, but
it is representative of a common situation where we
use computers to simulate what might happen in
the real world so that we can make informed deci
sions. The specific example that we consider now is
from a thoroughly studied classof problems known
as gambler's ruin. Suppose that a gambler makes a
series of fair $1 bets, starting with some given ini
tial stake. The gambler alwaysgoes broke eventually,
but when we set other limits on the game, various
questions arise. For example, suppose that the gam-
stake
goal
stake
Gambler simulationsequences
65

66
Elements of Programming
''^rtfrfr.afrartiiftSiird1
11
m
Program 13.8
Gambler's ruin simulation
public class Gambler
{
public static void main(String[]
args)
{
// Run T experiments that start with $stake
// and terminate on $0 or Sgoal.
int stake = Integer.parselnt(args[0]);
int goal
= Integer.parselnt(args[1]);
int T
= Integer.parselnt(args[2]);
int bets = 0;
int wins = 0;
for (int t = 0; t < T; t++)
{
// Run one experiment.
int cash = stake;
while (cash > 0 && cash < goal)
{
// Simulate one bet.
bets++;
if (Math.random()
< 0.5) cash++;
else
cash—;
}
// Cash is either 0 (ruin) or $goal
(win)
if (cash == goal) wins++;
}
System.out.println(100*wins/T + "% wins");
System.out.println("Avg # bets:
" + bets/T);
}
}
stake
goal
T
bets
wins
cash
initial stake
walkaway goal
number of trials
bet count
win count
cash on hand
The inner while loop in this program simulates a gambler with $stake who makes a series
of%l bets, continuing untilgoingbroke orreaching Sgoal. The running timeof this program
isproportional to Ttimes the average number ofbets. For example, the third command below
causes nearly 100 million random numbers tobegenerated.
% Java Gambler 10 20 1000
50% wins
Avg # bets: 100
% Java Gambler 50 250 100
19% wins
Avg # bets: 11050
% Java Gambler 500 2500 100
21% wins
Avg # bets: 998071
~,^^^^^^^~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^s
^^^P^^W«l^lP^^^^^pf!PP^P
i

1.3 Conditionals and Loops
67
bier decidesahead of time to walkawayafter reachinga certain goal.What are the
chancesthat the gamblerwillwin?How manybets might be needed to win or lose
the game? What isthe maximum amount of moneythat the gamblerwillhavedur
ing the course of the game?
Gambler (Program 1.3.8) is a simulation that can help answer these ques
tions. It does a sequence of trials, using Math. random() to simulate the sequence
of bets, continuing until the gambler is broke or the goal is reached, and keeping
track of the number ofwins and the number of bets. After running the experiment
for the specified number of trials, it averages and prints out the results. Youmight
wish to run this program for various values of the command-line arguments, not
necessarilyjust to plan your next trip to the casino,but to help you think about the
following questions: Is the simulation an accurate reflection of what would hap
pen in real life? How many trials are needed to get an accurate answer?What are
the computational limits on performing such a simulation?Simulations are widely
used in applications in economics, science,and engineering, and questions of this
sort are important in any simulation.
In the caseof Gambl er, we are verifyingclassical results from probability the
ory,which saytheprobability ofsuccess isthe ratio ofthe stake tothegoaland that the
expected number ofbets istheproduct ofthe stake and the desiredgain(the difference
between the goal and the stake).For example, if you want to go to Monte Carlo to
try to turn $500 into $2,500,you have a reasonable (20%) chance of success, but
you should expect to make a million $1 bets! If you try to turn $1 into $1,000,you
havea .1% chance and can expect to be done (ruin, most likely) in about 999 bets.
Simulation and analysis go hand-in-hand, eachvalidatingthe other. In prac
tice,the value of simulation is that it can suggest answers to questions that might
be too difficult to resolve with analysis. For example, suppose that our gambler,
recognizingthat there will never be enough time to make a million bets, decides
ahead of time to set an upper limit on the number of bets. How much money can
the gambler expectto take home in that case? You can addressthis question with
an easychangeto Program 1.3.8 (seeExercise 1.3.24), but addressingit with math
ematical analysis is not so easy.

68
Elements of Programming
Factoring. Aprime is an integergreater than one whoseonlypositive divisors are
one and itself.The prime factorization of an integer isthe multiset of primes whose
product is the integer. For example, 3757208 = 2*2*2*7*13*13*397. Factors
(Program 1.3.9)computes the prime factorization of any givenpositive integer.In
contrast to many of the other programs that we have seen (which we could do in a
few minutes with a calculator or even a pencil and paper),
this computation would not be feasible without a comput
er. How would you go about trying to find the factors of
a number like 287994837222311? You might find the fac
tor 17 quickly, but evenwith a calculatorit would takeyou
quite a while to find 1739347.
Although Factors is compact and straightforward,
it certainly will take some thought to for you to convince
yourselfthat it produces the desired result for any givenin
teger.Asusual,followinga trace that showsthe valuesofthe
variablesat the beginning of each iteration of the outer for
loop is a good wayto understand the computation. For the
case where the initial value of Nis 3757208, the inner whi1e
loop iterates three times when i is 2, to remove the three
factors of 2; then zero times when i is 3, 4, 5, and 6, since
none of those numbers divide 469651; and so forth. Trac
ing the program for a few exampleinputs clearly reveals its
basicoperation.To convince ourselves that the programwill
behaveas expectedfor all inputs, we reason about what we
expecteachof the loops to do.The whi 1e loop clearlyprints
and removes from n all factors of i, but the key to under
standingthe program is to seethat the following factholds
at the beginningof eachiteration of the for loop: n has no
factorsbetween2 and i -1. Thus, if i is not prime, it willnot
divide n;if i is prime, the whi 1e loop will do its job. Once
we know that n has no factors lessthan or equal to i, we also know that it has no
factors greaterthan n/i, soweneedlookno further when i isgreaterthan n/i.
In a more naive implementation, wemightsimplyhave usedthe condition (i
<n) to terminatethe for loop.Even given the blindingspeedof modern comput
ers, such a decision would have a dramatic effect on the size of the numbers that
wecouldfactor. Exercise 1.3.26 encourages youto experiment withthe programto
2
3757208
3
469651
4
469651
5
469651
6
469651
7
469651
8
67093
9
67093
10
67093
11
67093
12
67093
13
67093
14
397
15
397
16
397
17
397
18
397
19
397
20
397
output
2
2
2
13
13
397
Trace of Java Factors 3757208

1.3 Conditionals and Loops
69
^Ifll^^^^^S
nSs^
^VftSafcafeaata
Program 13.9
Factoring integers
public class Factors
{
public static void main(String[]
args)
{
// Print the prime factors of N.
long N = Long.parseLong(args[0]);
long n = N;
for (long i = 2;
i <= n/i;
i++)
{
// Test whether i is a factor.
while (n % i == 0)
{
// Cast out and print i factors,
n /= i;
System.out.print(i + " ");
}
// Any factors of n are greater than i.
}
if (n > 1) System.out.print(n);
System.out.println();
Java Factors 3757208
2
2
2
7
13 13 397
learn the effectivenessof this simple change. On a computer that can do billions
of operations per second, we could factor numbers on the order of 109 in a few
seconds; with the (i <= n/i) test we can factor numbers on the order of 1018 in a
comparable amount of time. Loops give us the ability to solvedifficult problems,
but they also giveus the ability to construct simple programs that run slowly, so we
must alwaysbe cognizant of performance.
In modern applications in cryptography, there are important situations where
we wish to factor truly huge numbers (with, say, hundreds or thousands of digits).
Such a computation is prohibitively difficult even withthe use of a computer.
integer tofactor
unfactoredpart
potentialfactor

70
Elements of Programming
Other conditional and loop constructs
To more fully cover the Java lan
guage, we consider here four more control-flow constructs. You need not think
about using these constructs for every program that you write, because you are
likelyto encounter them much lessfrequentlythan the i f, whi 1e, and for state
ments.You certainly do not needto worryabout usingtheseconstructsuntil you
are comfortable using i f, whi 1e, and for. You might encounter one of them in a
program in a book or on the web, but many programmers do not use them at all
and we do not use any of them outside this section.
Break statement. In some situations, we want to immediately exit aloopwithout
letting it run to completion. Java provides the break statement for this purpose.
For example, the following codeis an effective wayto test whether a giveninteger
N>1 is prime:
i nt i;
for (i
= 2;
i
<= N/i;
i++)
if (N % i
== 0) break;
if (i > N/i) System.out.println(N + " is prime");
There are two different ways to leavethis loop: either the break statement is ex
ecuted (because i divides N, so Nis not prime) or the for loop condition is not
satisfied (because no i with i <= N/i wasfound that dividesN, which impliesthat
Nis prime). Note that we have to declare i outside the for loop instead of in the
initializationstatement so that its scopeextendsbeyond the loop.
Continue statement. Java also provides a wayto skip to the next iteration of a
loop: the continue statement. When a continue is executed within a loop body,
the flow of control transfers directly to the increment statement for the next itera
tion of the loop.
Switch statement. The i f and i f-el se statements allow one or two alternatives
in directing the flowof control. Sometimes,a computation naturally suggestsmore
than two mutually exclusive alternatives. We could use a sequence or a chain of
if-else statements,but the Java switch statement provides a direct solution. Let
us move right to a typical example.Rather than printing an i nt variable day in a
program that works with days of the weeks (such as a solution to Exercise 1.2.29),
it is easier to use a swi tch statement, as follows:

7.3 Conditionals and Loops
swi tch
{
case
case
case
case
case
case
(day)
case
6:
System.out.
System.out.
System.out.
System.out.
System.out.
System.out,
System.out.
}
("Sun")
("Mon")
due")
("Wed")
("Thu")
("Fri")
("Sat")
pri ntl n
println
println
println
println
println
println
break;
break;
break;
break;
break;
break;
break;
When you have a program that seems to have a long and regular sequence of i f
statements, you might consider consulting the booksite and using a switch state
ment, or using an alternate approach described in Section 1.4.
Do-whileloop. Anotherway to writea loopisto usethe template
do { <statements> } while Q<boolean expression^;
The meaning of this statement is the same as
while Q<boolean expression^ { <statements> }
exceptthat the firsttest of the condition is omitted.If the condition initiallyholds,
there is no difference. For an example in which do-while is useful, consider the
problem of generating points that are randomly distributed in the unit disk. We
can use Math. random() to generate x and y coordinates independently to get points
that are randomly distributed in the 2-by-2 square centered on the origin. Most
points fallwithin the unit disk, so we just reject those that do not. We always want
to generate at least one point, so a do-whi1e loop isidealfor this computation. The
following code setsx and y such that the point (x, y) is randomly distributed in the
unit disk:
do
{
// Scale x and y to be random in
x = 2.0*Math.random()
- 1.0;
y = 2.0*Math.random()
- 1.0;
} while (Math.sqrt(x*x + y*y) > 1.0);
(-1, 1).
Since the area of the disk is tt and the area of the square is 4, the
expected number of times the loop is iterated is 4/ir (about 1.27).
/
(0,0)
71
(i,i)
/

72
Elements of Programming
Infinite loops
Before you write programs that use loops, you need to think
about the following issue: whatiftheloop-continuation conditionin a whi 1e loop
is always satisfied? With the statements that you havelearned so far,one of two bad
things could happen, both of whichyou need to learn to cope with.
First,suppose that such a loop calls System. out. pri ntl n(). For example,if
the conditionin TenHellos were (i > 3) insteadof (i
<= 10), it would always
be true. What happens? Nowadays, weuse print asan abstractionto mean display
ina terminal window and the result of attempting to displayan unlimited number
of lines in a terminal window is dependent on operating-system conventions. If
your system is set up to have print mean print characters on
a piece ofpaper> you might run out of paper or have to un
plugthe printer.In a terminalwindow,you need a stopprinting
operation. Beforerunning programs with loops on your own,
you make sure that you know what to do to "pull the plug" on
an infinite loop of System. out. pri ntl n() calls and then test
out the strategy by making the change to TenHel1os indicated
aboveand trying to stop it. On most systems,<ctrl -c> means
stop thecurrentprogram, and should do the job.
Second, nothing might happen. If your program has an
infinite loop that does not produce any output, it will spin
through the loop and you will see no results at all.When you
find yourself in such a situation, you can inspect the loops to
make sure that the loop exit condition always happens, but the
problem may not be easy to identify. One way to locate such
a bug is to insert calls to System. out. pri ntl n() to produce
a trace. If these calls fall within an infinite loop, this strategy
reducesthe problem to the casediscussedin the previous para
graph, but the output might giveyou a clue about what to do.
You might not know (or it might not matter) whether a loop is infinite or just
very long. Even BadHel 1os eventuallywould terminate after printing over a billion
lines because ofoverflow.If you invoke Program 1.3.8with arguments such as j ava
Gambler 100000 200000 100, you may not want to wait for the answer.Youwill
learn to be awareof and to estimate the running time of your programs.
Why not have Javadetect infinite loops and warn us about them? Youmight
be surprised to know that it is not possible to do so, in general. This counterintui
tive fact is one of the fundamental results of theoretical computer science.
public class BadHellos
int i = 4;
while (i > 3)
{
System.out.pri ntln
(i + "th Hello");
i = i +1;
}
% Java BadHellos
1st Hello
2nd Hello
3rd Hello
5th Hello
6th Hello
7th Hello
An infinite loop

1.3 Conditionals and Loops
73
Summary
For reference, the accompanying table lists the programs that we
haveconsidered in this section. They are representativeof the kinds of taskswe can
address with short programs comprised of i f, whi 1e, and for statements process
ing built-in types of data. These types of
computations are an appropriate way to
become familiar with the basic Java flow-
of-control constructs. The time that you
spend now working with as many such
programs as you can will certainly pay
off for you in the future.
To learn how to use condition
als and loops, you must practice writ
ing and debugging programs with if,
while, and for statements. The exer
cises at the end of this section provide
many opportunities for you to begin this
process. For each exercise,you will write
a Java program, then run and test it. All
programmers know that it is unusual to
have a program work as planned the first
time it is run, so you will want to have an understanding of your program and an
expectation of what it should do, step by step.At first, use explicit traces to check
your understanding and expectation.Asyou gainexperience, you willfind yourself
thinking in terms of what a trace might produce as you composeyour loops. Ask
yourself the following kinds of questions: What will be the values of the variables
after the loop iterates the first time?The secondtime? The final time? Is there any
waythis program could get stuck in an infinite loop?
Loops and conditionals are a giant step in our ability to compute: i f, whi1e,
and for statements take us from simple straight-line programs to arbitrarily com
plicatedflow of control. In the next several chapters, wewilltake more giant steps
that will allow us to process large amounts of input data and allow us to define
and process types of data other than simple numeric types. The if, while, and
for statements of this section will play an essential role in the programs that we
consider as we take these steps.
program
description
Flip
simulate a coin flip
TenHellos
your firstloop
PowersOfTwo
compute and print a table of values
DivisorPattern
your first nested loop
Harmonic
compute finite sum
Sqrt
classiciterative algorithm
Binary
basic number conversion
Gambler
simulation with nested loops
Factors
whi 1e loop within a for loop
Summary ofprograms in thissection

Elements of Programming
Q. What is the difference between = and ==?
A, We repeatthis questionhere to remindyou to be sure not to use = when you
mean == in a conditional expression. The expression (x = y) assigns the value of
y to x,whereas the expression (x == y) testswhether the two variables currently
have the same values. In some programming languages,this difference can wreak
havoc in a program and be difficult to detect, but Java's type safety usually will
come to the rescue. For example, if we make the mistake of typing (t = goal)
instead of (t == goal) in Program 1.3.8,the compiler finds the bug for us:
javac Gambler.java
Gambler.Java:18: incompatible types
found
: int
required:
boolean
if (t = goal) wins++;
A
1
error
Becareful about writing i f (x = y) when x and y are bool ean variables, since this
will be treated as an assignment statement, which assigns the value of y to x and
evaluates to the truth value of y. For example, instead of writing if (i sPri me =
false), you should write if (HsPrime).
Q. SoI need to pay attention to using ==instead of=when writing loops and con
ditionals. Is there something elsein particular that I should watch out for?
A. Another common mistake is to forget the braces in a loop or conditional with a
multi-statement body. For example, consider this version of the code in Gambl er:
for (int t
= 0;
t
< T;
t++)
for (cash = stake; cash > 0 && cash < goal;
bets++)
if (Math.random()
< 0.5)
cash++;
else
cash--;
if (cash == goal) wins++;
The code appears correct, but it is dysfunctional because the second i f is outside
both for loops and gets executedjust once. Our practice ofusing explicit braces for
long statements is preciselyto avoid such insidious bugs.

13 Conditionals and Loops
Q. Anything else?
A. The third classic pitfallis ambiguity in nested i f statements:
if <exprl> if <expr2> <stmntA> else <stmntB>
In Java this is equivalent to
if <exprl> {if <expr2> <stmntA> else <stmntB> }
even if you might have been thinking
if <exprl> {if <expr2> <stmntA> } else <stmntB>
Again,using explicitbraces is a good wayto avoidthis pitfall.
Q. Aretherecases whereI must usea for loopbut not awhi 1e, or viceversa?
A. No. Generally, you should use a for loop when you havean initialization, an
increment, and aloop continuation test (if you do not need the loop control vari
able outsidethe loop). But the equivalent whi 1e loop stillmight be fine.
Q. What are the rules on where we declare the loop-control variables?
A. Opinionsdiffer. In olderprogramming languages, it was required that all vari
ables be declared at the beginningof a <body>, so many programmers are in this
habit and there is a lot ofcode out there that follows this convention. But it makes a
lot of sense to declare variables where they are first used,particularly in for loops,
when it isnormallythe case that the variable isnot neededoutsidethe loop.How
ever, it is not uncommon to need to test (and therefore declare) the loop-control
variable outside the loop, asin the primality-testing codewe considered asan ex
ample ofthe break statement.
Q. What is the difference between ++i and i ++?
A. As statements, there is no difference. In expressions, both increment i, but ++i
has the value after the increment and i++ the value before the increment. In this
book,we avoid statements like x = ++i that have the side effectof changing vari
ablevalues. So,it is safe to not worry much aboutthis distinction and just use i++
75

76
Elements of Programming
in for loops and as a statement. When we do use ++i in this book, we will call at
tention to it and saywhy we areusing it.
Q. So,<initia7ize> and <increment>canbe anystatementswhatsoeverin a for
loop. How can I take advantage ofthat?
A. Some experts take advantage of this ability to createcompact code fragments,
but, as a beginner, it is best for you to use a whi1e loop in such situations. In fact,
the situation is even more complicated because <initialize> and <increment>
canbe sequences ofstatements, separated by commas. This notation allowsfor code
that initializes and modifies other variablesbesides the loop index. In some cases,
this ability leads to compact code. For example, the following two lines of code
could replace the lasteight lines in the body ofthe main() method in PowersOfTwo
(Program 1.3.3):
for (int i
= 0,
v = 1;
i
<= n;
i++,
v *= 2)
System, out. pri ntl n(i + " " + v);
Such code is rarelynecessaryand better avoided,particularlyby beginners.
Q Can I use a doubl e value asan index in a for loop?
A It is legal, but generally bad practice to do so.Consider the followingloop:
for (double x = 0.0;
x <= 1.0;
x += 0.1)
System.out.println(x + " " + Math.sin(x));
How many times does it iterate? The number of iterationsdepends on an equality
test between doubl e values,which may not always givethe result that you expect.
Q. Anything elsetricky about loops?
int v = 1;
A. Not all parts of afor loop need to be filled
whi]e^2T N/2)
in with code. The initialization statement, the
null increment
statement
*
boolean expression, the increment statement,
for ^"^Y =l; v <- N/2; )
and the loop body can eachbe omitted. It is gen
erallybetter style to use a while statement than
for (int v = 1; v <= N/2; v *= 2)
null statements inaforloop. In the code inthis
; * """loop body
book, we avoid null statements.
Three equivalent loops

1.3 Conditionals and Loops
1.3.1
Write a program that takes three integer command-line arguments and
prints equal if all three are equal, and not equal otherwise.
1.3.2
Write a more general and more robust version of Quadratic (Program
1.2.3) that prints the roots of the polynomial ax2 + bx+ c, prints an appropriate
messageif the discriminant is negative, and behavesappropriately (avoiding divi
sion by zero) if a is zero.
1.3.3
What (if anything) iswrong with eachof the following statements?
a. if (a > b) then c = 0;
b. if a > b { c = 0;
}
c.
if (a > b)
c = 0;
d. if (a > b)
c = 0 else b = 0;
1.3.4
Write a code fragment that prints true if the doubl e variables x and y are
both strictly between 0 and 1 and f al se otherwise.
1.3.5
Improveyour solution to Exercise 1.2.25 by addingcodeto checkthat the
values of the command-line arguments fall withinthe ranges ofvalidity of the for
mula,and alsoadding codeto print out an error message if that is not the case.
1.3.6
Supposethat i and j areboth of type i nt. What isthe valueof j aftereach
of the followingstatements is executed?
a.
for (i = 0,
j = 0;
i
< 10; i++)
b.
for (i = 0,
j = 1; i < 10; i++)
c.
for (j = 0;
j
< 10; j++) j += j;
d.
for (i = 0,
j = 0; i < 10; i++)
3
+= i;
j
+= j;
j
+= j++;
1.3.7
Rewrite TenHel1os to makea program Hel 1os that takes the number of
lines to print asa command-line argument. You mayassume that the argumentis
less than 1000. Hint: Use i %10 and i %100 to determine when to use st, nd, rd, or
th for printing the i th Hel1o.
1.3.8
Writea program that, usingone for loop and one i f statement,prints the
77

78
Elements of Programming
integers from 1,000to 2,000with five integers per line. Hint: Usethe %operation.
1.3.9
Write a program that takes an integer Nas a command-line argument,
uses Math. random() to print Nuniform random values between 0 and 1,and then
prints their averagevalue (seeExercise 1.2.30).
1.3.10 Describewhat happens whenyou try to print a ruler function (seethe table
on page 57) with a value of Nthat is too large,such as 100.
1.3.11 Write a program FunctionGrowth that prints a table of the values logJV,
JV, JVlogJV, JV2, JV3, and 2N for JV = 16,32,64,..., 2048. Usetabs (\t characters) to
line up columns.
1.3.12 What are the values of mand n after executing the following code?
int n = 123456789;
int m = 0;
while
(n != 0)
{
m = (10 * m) + (n % 10);
n = n / 10;
}
1.3.13 What does the followingprogram print ?
int f = 0,
g = 1;
for (int i
= 0;
i
<= 15; i++)
{
System.out.p ri ntln(f);
f = f + g;
g = f
-
g;
}
Solution.
Even an expert programmer will tell you that the only way to under
stand a program likethis isto traceit.Whenyou do,you willfind that it prints the
values 0,1,1,2,3,5,8,13,21,34,55,89,134,233,377, and 610. These numbers are
the first sixteen of the famous Fibonacci sequence, which are defined by the follow
ing formulas: F0 = 0, Fx = 1,and Fn = FnA + Fn_2 for ft > 1.The Fibonaccisequence
arises in a surprising variety of contexts,they have been studied for centuries, and

1.3 Conditionals and Loops
many of their properties are well-known. For example,the ratio of successive num
bers approaches the golden ratio <|> (about 1.618) as n approaches infinity.
1.3.14 Write a program that takes a command-line argument JV and prints all the
positivepowersof two lessthan or equalto JV. Makesure that your program works
properlyfor allvaluesof JV. (Integer. parselnt() willgeneratean error ifJVis too
large,and your program should print nothing if JV is negative.)
1.3.15 Expand your solution to Exercise 1.2.24 to print a table giving the total
amount paid and the remaining principalaftereachmonthly payment.
1.3.16 Unlike the harmonic numbers, the sum l/l2 + 1/22 + ... + 1/JV2 does con
verge to a constant as JV grows to infinity. (Indeed, the constant is tt2/6, so this
formula canbe usedto estimate thevalue of it.) Which of the following for loops
computes this sum? Assume that Nis an int initialized to 1000000 and sum is a
doubl e initialized to 0.0.
<= N; i++) sum += 1 /
(i*i);
<= N; i++) sum += 1.0 / i*i;
<= N; i++) sum += 1.0 /
(i*i);
<= N; i++) sum += 1 /
(1.0*i*i);
1.3.17 Show that Program 1.3.6 implements Newton's method for finding the
squareroot of c. Hint: Use the factthat the slope ofthe tangentto a (differentiable)
function f(x) atx = t isf'(t) to findthe equation of the tangent line and then use
that equationto findthe point where the tangentlineintersects the x-axis to show
thatyoucanuseNewton's methodto find a rootofanyfunction asfollows: at each
iteration, replace the estimatetby t - fit) /f'(t).
1.3.18 Using Newton's method, develop a program that takes integers Nand kas
command-line arguments and prints the kth root of N(Hint: seeExercise 1.3.17).
1.3.19 ModifyBinary to get a program Karythat takesi and k as command-line
argumentsand converts i to base k. Assume that i isan integerin Java's long data
type and that k is an integerbetween 2 and 16. For bases greaterthan 10,use the
letters Athrough Fto represent the 11ththrough16thdigits, respectively.
a. for (int i
= 1;
i
b. for (int i
= 1;
i
c.
for (int i
= 1;
i
d. for (int i
= 1;
i

Elements of Programming
1.3.20 Write a code fragment that puts the binary representation of a positive
integer Ninto a Stri ng s.
Solution.
Java has a built-in method Integer. toBi naryStri ng(N) for this job,
but the point of the exercise is to seehow such a method might be implemented.
Workingfrom Program 1.3.7, wegetthe solution
String s = "";
int v = 1;
while (v <= n/2) v = 2*v;
while (v > 0)
{
if (n < v)
{ s += 0;
}
else
{ s += 1;
n -= v;
}
v = v/2;
}
Asimpleroption isto workfrom right to left:
String s = "";
for (int n = N; n > 0;
n /= 2)
s = (n % 2) + s;
Both of these methods are worthy of carefulstudy.
1.3.21 Write a version of Gambl er that usestwo nested whi1e loops or two nested
for loopsinsteadof a whi 1e loopinside a for loop.
1.3.22 Write a program GamblerPlot that traces a gambler's ruin simulation by
printing aline after each betinwhich one asterisk corresponds to each dollar held
by the gambler.
1.3.23 Modify Gambler to take an extra command-line argument that specifies
the (fixed) probabilitythat the gamblerwins eachbet. Useyour program to try to
learnhowthisprobability affects the chance ofwinning and the expected number
of bets.Trya valueofp close to .5 (say, .48).
1.3.24 Modify Gambler to take an extra command-line argument that specifies
the numberofbetsthe gambler iswilling to make, sothat therearethreepossible

1.3 Conditionals and Loops
waysfor the game to end: the gambler wins, loses,or runs out of time. Add to the
output to givethe expectedamount of money the gamblerwillhavewhen the game
ends. Extra credit: Useyour program to plan your next trip to Monte Carlo.
1.3.25 Modify Factors to print just one copyeach of the prime divisors.
1.3.26 Run quick experiments to determine the impact of using the termination
condition (i <= N/i) instead of (i < N) in Factors in Program 1.3.9. For each
method, find the largestn such that when you type in an n digit number, the pro
gram is sure to finish within 10 seconds.
1.3.27 Writea program Checkerboard that takes one command-lineargument N
and usesa loop within a loop to print out a two-dimensional N-by-N checkerboard
pattern with alternating spaces and asterisks.
1.3.28 Write a program GCD that finds the greatest commondivisor (gcd) of two
integers using Euclid's algorithm, which is an iterative computation based on the
following observation: if xisgreater than y,thenif ydivides x,the gcdof xand y is
y;otherwise,the gcdof x and y is the sameasthe gcdof x % y and y.
1.3.29 Write a program RelativelyPrime that takes one command-line argu
ment Nand prints out an N-by-N table such that there isan * in row i and column j
if the gcdof i and j is1 (i and j arerelatively prime)and a space in that position
otherwise.
1.3.30 Writea program PowersOfKthat takes aninteger kascommand-lineargu
ment and prints allthe positive powers of kin the Java long data type.Note: The
constant Long.MAX_VALUE is the value of the largestinteger in 1ong.
1.3.31 Generatea random point (x, y, z) on the surface of a sphere using Mar-
saglia's method: Pick a random point (a, b) in the unit disk using the method de-
scribed attheendofthis section. Then, set x= 2aJl -a2 - b2 .y = 2 bJl -a2 - b2.
andz= l-2(a2 + fr2).
81

82
Elements of Programming
X^reatm^S^eXSes..
1.3.32 Ramanujan's taxi. Srinivasa Ramanujan was an Indian mathematician
who became famous for his intuition for numbers. When the English mathemati
cian G. H. Hardy came to visit him one day, Hardy remarked that the number of
his taxi was 1729,a rather dull number. Towhich Ramanujan replied,"No, Hardy!
No,Hardy! It is a veryinterestingnumber. It is the smallestnumber expressible as
the sum of two cubes in two differentways."Verify this claim by writing a program
that takesa command-line argument Nand prints out allintegerslessthan or equal
to Nthat can be expressed as the sum of two cubesin two differentways. In other
words, finddistinctpositive integers a, b, c, and dsuchthat a3 + b3 = c3 + d3. Usefour
nested for loops.
1.3.33 Checksum. The International Standard Book Number (ISBN) is a 10-digit
code that uniquely specifies a book. The rightmost digit is a checksum digit that
canbe uniquely determined fromthe other 9 digits, from the conditionthat dx +
2d2 +3d3 +... + 10d10 mustbeamultiple of 11 (here d{ denotes theithdigit from the
right).Thechecksum digitd{canbeanyvalue from0to 10. TheISBN convention is
to use the character 'X1 to denote 10.Example: the checksum digit corresponding
to 020131452 is 5since5 is the onlyvalueof x between 0 and 10 for which
10-0 + 9-2 + 8-0 + 7-1 + 6-3 + 5-1 +44 +3-5 + 2-2 + 1-x
isa multiple of 11. Write a programthat takes a 9-digitintegerasa command-line
argument, computes the checksum, and printsout the the ISBN number.
1.3.34 Countingprimes. Write a programPrimeCounterthat takes a command-
line argument Nand finds the number of primes less than or equalto N. Useit to
print out the numberofprimesless than or equalto 10million. Note: ifyouarenot
careful, your program maynot finish in a reasonable amount of time!
1.3.35 2D random walk. A two-dimensional random walk simulates the behavior
of a particle moving in a grid of points. At each step, the random walker moves
north, south, east,or westwith probabilityequal to 1/4, independent of previous
moves. Writea program RandomWal ker that takesa command-lineargument Nand
estimates how long it willtakea random walker to hit the boundary of a 2N-by-2N
square centered at the starting point.

13 Conditionals and Loops
1.3.36 Exponential function. Assume thatx isapositive variable of type doubl e.
Write a code fragmentthat usesthe Taylor series expansion to set the value of sum
to ex = 1+ x + x2/2\ + x3/3! +... .
Solution.
The purpose of thisexercise isto get youto think about howalibrary
function likeMath. exp() mightbeimplemented interms of elementary operators.
Trysolving it,then compare yoursolution with the onedeveloped here.
We startby considering the problem of computingone term. Suppose that x
andtermare variables of typedoubl e andnisavariable oftypei nt. The following
code fragment sets term to xN/N\ using thedirect methodof having oneloop for
the numerator andanother loop for the denominator, then dividing the results:
double num = 1.0, dem = 1.0;
for (int i = 1; i <= n;
i++) num *= x;
for (int i = 1; i <= n;
i++) den *= i;
double term = num/den;
A betterapproach isto usejust asingle for loop:
double term =1.0;
for (i = 1;
i
<= n;
i++) term *= x/i;
Besides beingmore compact and elegant, the latter solution is preferable because
it avoids inaccuracies caused by computing with huge numbers. For example, the
two-loop approach breaks down for values like x = 10and N = 100because 100! is
too large to represent asa doubl e.
To compute e*, we nest this for loopwithin another for loop:
double term = 1.0;
double sum =0.0;
for (int n = 1;
sum != sum + term;
n++)
{
sum += term;
term = 1.0;
for (int i
= 1;
i
<= n;
i++) term *= x/i;
}
The number of times the loop iterates depends on the relative valuesof the next
term and the accumulated sum. Once the value of the sum stops changing, we

84
Elements of Programming
leave the loop. (This strategy is more efficient than using the termination condi
tion (term > 0) becauseit avoids a significant number of iterations that do not
change thevalue ofthesum.) This code iseffective, but it isinefficient because the
inner for loop recomputes allthe values it computedon the previous iterationof
the outer for loop.Instead, wecan makeuseof the term that wasadded in on the
previous loop iterationand solve the problemwith a single for loop:
double term = 1.0;
double sum =0.0;
for (int n = 1;
sum != sum + term; n++)
{
sum += term;
term *= x/n;
}
1.3.37 Trigonometric functions. Write two programs, Sin
and Cos, that
compute the sine and cosine functions using their Taylor series expansions
sin x = x -
x3/3! + x5/5\ -
... and cos x = 1 - x2/2\ + x4/4! - ... .
1.3.38 Experimental analysis. Runexperiments to determine the relative costs of
Math.expO and the methods from Exercise 1.3.36 for computing ex: the direct
method with nested for loops,the improvement with a single for loop, and the
latter with the termination condition (term > 0). Use trial-and-error with a com
mand-line argumentto determine how manytimesyour computer can perform
each computation in 10seconds.
1.3.39 Pepys problem. In 1693 Samuel Pepys asked Isaac Newtonwhich is more
likely: getting 1 at leastoncewhen rolling a fair die sixtimes or getting 1 at least
twice whenrolling it 12times. Write a programthat couldhave providedNewton
with a quick answer.
1.3.40 Game simulation. In the 1970s game show Let's Make a Deal,a contestant
ispresented withthreedoors. Behind oneofthemisavaluable prize. After the con
testant choosesa door, the host opens one of the other two doors (never revealing
the prize,of course).The contestantis then giventhe opportunity to switchto the
other unopened door. Should the contestant do so? Intuitively, it might seem that

13 Conditionals and Loops
the contestant's initial choice door and the other unopened door are equally likely
tocontain the prize, so there wouldbeno incentive toswitch.Write aprogram Mon-
teHal1to testthisintuitionbysimulation. Your program should takea command-
line argument N, play the game Ntimes using each ofthe two strategies (switch or
do notswitch), and print the chance ofsuccess for each ofthe two strategies.
1.3.41 Median-of-5. Write a program that takes five distinct integers from the
command line and prints the median value (the valuesuch that two of the others
are smaller and two are larger). Extra credit: Solve the problem with aprogram that
compares values fewer than seven times forany given input.
1.3.42 Sorting three numbers. Suppose that the variables a, b, c, and t are all of
thesame numeric primitive type. Prove thatthe following code puts a, b, andc in
ascending order:
if (a > b) { t = a; a = b;
b = t; }
if (a > c) { t = a; a = c; c = t; }
if (b > c) { t = b;
b = c; c = t; }
1.3.43 Chaos. Write aprogram tostudy the following simple model for popula
tiongrowth, which mightbeapplied to study fish in apond,bacteria in atesttube,
or any ofahost ofsimilar situations. We suppose thatthepopulation ranges from
0 (extinct) to 1(maximum population thatcan besustained). Ifthepopulation at
time tisx,then wesupposethe populationat time t + 1to be rx{\—x), wherethe
argument r, known asthefecundity parameter, controls the rate of growth. Start
with asmall population—say,x=0.01—and studythe result ofiterating themodel,
for various values of r.For which values ofr does thepopulation stabilize atx = 1
- 1/r?Canyou sayanythingabout the populationwhenr is 3.5? 3.8? 5?
1.3.44 Euler's sum-of-powers conjecture. In 1769 Leonhard Euler formulated a
generalized version ofFermat's Last Theorem, conjecturing thatatleast nnth pow
ersareneeded to obtainasumthatisitselfannth power, forn> 2.Write aprogram
to disprove Euler's conjecture (which stood until 1967), using a quintuply nested
loop to find four positive integers whose 5thpower sums to the5thpower of an
other positiveinteger.That is,find a, b,c,d,and esuch that a5 + b5 + c5+ d5= e5.
Use the 1ong data type.
85

Elements of Programming
1.4
Arrays
In this section,weconsidera fundamental programmingconstruct known as the
array. The primary purpose of an array isto facilitate storing and manipulating
large quantities ofdata. Arrays play anessential role inmany data processing tasks.
They also correspond tovectors andmatrices, which are widely used inscience and
in scientific programming. Wewill con-
sider basicproperties of array processing
in Java, with many examples illustrating
whytheyare useful.
Anarraystoresa sequence ofvalues
that are all of the same type. Processing
such a set of values is very common. We
might have exam scores, stock prices, nucleotides inaDNA strand, orcharacters in
a book. Each of these examples involve a large numberofvalues that areallofthe
same type.
We want not onlyto storevalues but also directly access eachin
dividual value. The method that we use to refer to individual values in
an arrayisnumbering and then indexing them. Ifwehave N values, we
think of them asbeingnumberedfrom0 to N-1. Then,wecan unam
biguously specify oneofthembyreferring to the zth value foranyvalue
of i from 0 to N— 1. To refer to the ith value in an array a, we use the
notation a[i], pronounced a sub i. This Java construct is known as a
one-dimensional array.
The one-dimensional arrayis our firstexample in this book of a
data structure (a method for organizing data).We also considerin this
sectiona more complicated data structureknownasa two-dimensional
array. Datastructuresplayan essential rolein modern programming—
Chapter 4 islargelydevotedto the topic.
Typically, when we have a large amountof datato process, we first put allof
the data into one or more arrays. Thenweusearrayindexing to referto individual
values andto process thedata. We consider suchapplications whenwediscuss data
input in Section 1.5 and in the case study that isthe subject of Section 1.6. In this
section, we expose the basicproperties of arrays by considering examples where
our programs first populate arrays withcomputed values fromexperimental stud
ies and then process them.
1.4.1
1.4.2
1.4.3
1.4.4
Samplingwithout replacement. . . 94
Coupon collector simulation. ... 98
Sieve of Eratosthenes
100
Self-avoiding random walks .... 109
Programs in thissection
a[0]
a[l]
a[2]
a[3]
a[4]
a[5]
a[6]
a[7]
An array

1.4 Arrays
g7
Arrays in Java
Making anarray inaJava program involves three distinct steps:
• Declare the array name and type.
• Create the array.
• Initialize the array values.
To declare thearray, youneed tospecify aname andthetype ofdataitwill contain.
To create it,youneedto specify its size (thenumber of values). Forexample, the
following code makes an array of Nnumbers oftype doubl e,allinitialized to 0.0:
doubled
a;
a = new double[N];
for (int i
= 0;
i
< N; i++)
a[i]
= 0.0;
Thefirst statement isthe arraydeclaration. It isjustlike a declaration of a variable
of the corresponding primitive type except for the square brackets following the
typename, which specify that wearedeclaring an array. Thesecond statementcre
ates the array. This action is unnecessary for variables of a primitive type (so we
have not seen asimilar action before), but it isneeded forallothertypes ofdatain
Java (see Section 3.1). Inthecode inthisbook, we normallykeep thearraylengthin
an integervariable N, but anyinteger-valued expression willdo.The for statement
initializes the Narrayvalues. We refer to each value byputtingitsindexin brackets
afterthe arrayname. Thiscodesets allof the array entries to thevalue 0.0.
When youbegin to write code that uses an array, youmustbe surethat your
codedeclares, creates, and initializes it. Omitting one of these steps is a common
programmingmistake. Foreconomy in code, weoftentakeadvantage of Java's de
fault array initialization convention andcombine all three steps intoa single state
ment. Forexample, the following statement isequivalent to the code above:
doubled
a = new double[N];
The code to the left of the equal sign constitutes the declaration; the code to the
rightconstitutes the creation. Thefor loopisunnecessary in thiscase because the
default initial value ofvariables oftype doubl e in a Java array is0.0, but it would
be required if a nonzero value were desired. The default initial value is zero for all
numbers and fal se fortypebool ean.ForStri ng andothernon-primitive types,
the defaultis the value null, whichyouwilllearn about in Chapter 3.
After declaring and creating an array, you can referto any individualvalue
anywhere youwouldusea variable namein a programbyenclosing an integerin-

88
Elements of Programming
dexin braces afterthearrayname. We refer to the ith itemwiththe codea[i ]. The
explicit initialization code shown earlier isanexample ofsuch a use. The obvious
advantage of using arrays isto avoid explicitly naming each variable individually.
Using anarrayindexisvirtuallythesame as appending theindex tothearray name:
forexample, if we wanted to process eight variables of type doubl e, we could de
clare each of them individuallywith the declaration
double aO, al, a2, a3, a4, a5, a6,
a7;
and then refer to them as aO, al and so forth instead of declaring them with dou
ble[] a = new double[8] and referring to them asa[0], a[1], and so forth. But
naming dozens ofindividual variables inthiswaywould becumbersome andnam
ing millionsis untenable.
Asan example of codethat uses arrays, considerusingarrays to representvec
tors. We consider vectors in detail in Section 3.3; for the moment, think of a vector
asa sequence ofreal numbers. The dotproduct oftwo vectors (ofthesame length)
is the sum of the products of their corresponding components. The dot product
of twovectors that arerepresented asone-dimensional arrays x[] and y[] that are
each of length 3 isthe expression x[0]*y[0] + x[l]*y[l] + x[2]*y[2]. If we
represent the two vectors asone-dimensional arrays x[] and y[] that areeach of
length Nand of type double, the dot product is
easy to compute:
0
double sum = 0.0;
0
30
50
15
15
for (int i
= 0;
i
< N; i++)
sum += x[i]*y[i];
i
x[i]
y[i]
x[i]*y[i]
sum
1
.60
.10
.06
.21
2
.10
.40
.04
.25
The simplicity of coding such computations
.25
makes the use ofarrays the natural choice for all
Trace 0fdotproduct computation
kindsof applications. (Notethat whenweusethe
notation x[], we are referring to the whole array,
asopposedto x[i ], whichisa reference to the i th
entry.)
Theaccompanying tablehasmanyexamples ofarray-processing code, andwe
willconsider evenmore examples later in the book, because arraysplaya central
rolein processing data in manyapplications. Before considering more sophisticat
ed examples, we describe a number of important characteristics of programming
with arrays.

1.4 Arrays
create an array
with random values
doubl e[] a = new doubl e[N];
for (int i
= 0;
i
< N; i++)
a[i] = Math.randomO;
print the array values,
oneper line
for (int i = 0;
i
< N; i++)
System.out.pri ntln(a[i]);
find themaximum of
thearray values
double max = Double.NEGATIVE_INFINITY;
for (int i
= 0;
i
< N; i++)
if (a[i] > max) max = a[i];
compute theaverage of
thearray values
double sum =0.0;
for (int i
= 0;
i
< N; i++)
sum += a[i];
double average = sum /
N;
copy toanother array
doubl e[]
b = new doubl e[N];
for (int i
= 0;
i
< N; i++)
b[i] = a[i];
reverse the elements
withinan array
for (int i =0;
i
< N/2;
i++)
{
double temp = b[i];
b[i] = b[N-l-i];
b[N-i-l] = temp;
}
Typical array-processing code (for arrays ofN double values)
Zero-based indexing. We always refer tothefirst element ofanarray asa[0], the
secondasa[1], and soforth.It mightseemmorenaturalto youto referto the first
element as a[l], the second value as a[2], and so forth, but starting the index
ing with 0 has some advantages and has emerged as the convention used in most
modernprogramming languages. Misunderstanding thisconvention oftenleads to
off-by one-errors that arenotoriously difficult to avoid and debug, sobe careful!
Array length. Oncewecreate an array, itssize isfixed. Thereason that weneedto
explicitly createarraysat runtime isthat the Java compilercannot knowhowmuch
space to reserve for the arrayat compile time (asit can for primitive-type values).
Our convention is to keep the size of the array in a variable Nwhose value can be
set at runtime (usuallyit is the value of a command-line argument). Java's stan
dard mechanism is to allow a program to refer to the length of an arraya[] with
the code a.length; we normallyuse Nto create the array, or set the valueof Nto
a, 1ength. Note that the last element of an array is always a[a. 1ength-1].
89

90
Elements of Programming
Memory representation. Arrays are fundamental data structures in that they
have a direct correspondence with memory systems on virtually all computers.
The elements of an array are stored consecutively in memory, so that it is easy
to quickly access any array value. Indeed, we can view memory itself as a giant
array. On moderncomputers, memory is implemented in hardware as
a sequence of indexed memory locations that each can be quickly ac
cessedwith an appropriate index.When referringto computer memory,
wenormally refer to a location's indexasits address. It is convenient to
think of the name of the array—say, a—asstoringthe memory address
of the first elementof the array a[0]. For the purposes of illustration,
jS
suppose that the computer's memoryisorganized as 1,000 values, with
addresses from 000to 999. (This simplifiedmodel ignoresthe fact that
arrayelements canoccupy differing amountsof memorydepending on
their type,but youcanignore suchdetails for the moment.) Now, sup
posethat an arrayof eightelements is storedin memorylocations 523
through 530. In sucha situation, Java wouldstorethe memory address
(index) of the first array valuesomewhere else in memory, along with
the arraylength. We refer to the address as a pointer and think of it as
pointing to the referenced memory location. Whenwespecify a[i ], the
compiler generates code that accesses the desired value by adding the
index i to the memory address of the array a[]. For example, the Java
code a[4] would generatemachine codethat findsthe value at memory
location 523 + 4 = 527. Accessing element i of an array is an efficient
operation because itsimply requires adding two integers andthenrefer
encing memory—just two elementary operations. Extending themodel
to handle different-sized array elements just involves multiplying the
indexbythe elementsize before addingto the arrayaddress.
000 l;
vt
£
, ,
-'
123
523
124
8
} a.length
523 %\
a[0]
524
a[l]
525 r;
a[2]
526 ^
a[3]
527
a[4]
528 .-;
a[5]
529
a[6]
530
\
a [7]
;
999 ,
Memoryrepresentation
Memory allocation. When youusenew to create an array, Java reserves
space in memory for it. This process is called memory allocation. The
same process is required for allvariablesthat you use in a program. We
callattention to it nowbecause it isyour responsibilityto use new to al
locate memoryforan arraybefore accessing anyof itselements. Ifyoufail to adhere
to this rule,you willget a compile-timeuninitialized variable error. Java automati
cally initializes allof thevalues in anarraywhenit iscreated. You shouldremember
that the time required to createan array is proportional to its length.

1A Arrays
91
Bounds checking. As already indicated, you must be careful when programming
with arrays. It is your responsibility to use legal indices when accessing an array
element. Ifyouhave created an arrayof size Nand usean indexwhose value isless
than 0 or greater than N-l, your program will terminate with an Arraylndex-
OutOfBounds run-time exception. (In manyprogramming languages, such bujfer
overflow conditions arenot checked bythesystem. Such unchecked errors can and
do leadto debugging nightmares, but it isalso not uncommon for suchan error to
go unnoticed and remain in a finished program. You mightbe surprised to know
that such a mistake canbe exploited bya hacker to take control of a system, even
your personal computer, to spread viruses, steal personal information, or wreak
othermalicious havoc.) The errormessages provided byJava may seem annoying
to youat first, but theyaresmall price to payto have a moresecure program.
Setting array values at compile time. Whenwe have a small number of literal
values that wewantto keep in array, we candeclare and initialize it bylisting the
values between curlybraces, separated bycommas. Forexample, wemightusethe
following codein a programthat processes playing cards.
String[] suit = { "Clubs", "Diamonds", "Hearts", "Spades" };
String[]
rank =
{
"2", "3", "4", "5", "6", "7", "8", "9", "10",
"Jack",
"Queen", "King",
"Ace"
};
After creatingthe two arrays, we can usethem to print out a random card name,
such as Queen of Clubs, as follows:
int i = (int)
(Math.random() * rank.length);
int j = (int)
(Math.randomO * suit.length);
System.out.println(rank[i] + " of " + suit[j]);
Thiscodeuses theidiomintroduced inSection 1.2 to generate randomindices and
then uses the indicesto pick strings out of the arrays. Wheneverthe values of all
arrayentriesareknown at compile time (and the size of the arrayis not too large)
it makes sense to usethismethodofinitializing the array—just put allthe values in
braces on the right hand sideof an assignment in the arraydeclaration. Doingso
implies array creation, so the new keyword is not needed.

92
Elements of Programming
Setting array values at runtime. A more typical situation is when we wish to
compute the values to be stored in an array. In this case, we canuse array names
with indices in the samewaywe usevariable nameson the left sideof assignment
statements. For example, we mightusethe following code to initialize an array of
size 52 thatrepresents adeck of playing cards, using thetwo arrays justdefined:
String[] deck = new String[suit.length * rank.length];
for (int i
= 0;
i
< suit.length; i++)
for (int j = 0;
j < rank.length;
j++)
deck[rank.length*i + j] = rank[i] + " of " + suit[j];
After this code hasbeen executed, if you wereto print out the contents of deck in
orderfromdeck [0] throughdeck[51] usingSyst em. out.printlnO, youwould
getthe sequence
2 of Clubs
2 of Diamonds
2 of Hearts
2 of Spades
3 of Clubs
3 of Diamonds
Ace of Hearts
Ace of Spades
Exchange. Frequently, wewishto exchange twovalues in anarray. Continuingour
example with playing cards, the following code exchanges the cards at position i
and j usingthe same idiomthatwetraced asour first example ofthe useofassign
ment statements in Section 1.2:
String t
= deck[i];
deck[i] = deck[j];
deck[j] = t;
When we use this code,we areassured that we are perhapschanging the order of
the values in the arraybut not the setofvalues in the array.When i and j are equal,
the array is unchanged. When i and j are not equal,the valuesa[i ] and a[j] are
found in different places in the array. For example,if we wereto usethis codewith
i equal to 1 and j equal to 4 in the deck array of the previous example, it would
leave 3 of Clubs in deck[1] and 2 of Diamonds in deck[4].

1.4 Arrays
Shuffle. The following codeshuffles our deckof cards:
int N = deck.length;
for (int i = 0; i < N;
i++)
{
int r = i + (int) (Math.random() * (N-i));
String t = deck[i] ;
deck[i] = deck[r];
deck[r] = t;
}
Proceeding from left to right, we pick a random card from deck[i] through
deck[N-l] (each cardequallylikely) and exchange it with deck[i]. This code is
more sophisticatedthan it might seem: First, we ensure that the cardsin the deck
after the shuffle are the same as the cards in the deck before the shuffle by using
the exchange idiom. Second, we ensure thatthe shuffleisrandomby choosinguni
formly from the cards not yet chosen.
Sampling without replacement. In manysituations, wewantto draw a random
sample from a set such that each member of the set appears at most once in the
sample. Drawing numbered ping-pong balls from a basket for a lottery is an ex
ample of this kind of sample, as is dealing a hand from a deck of cards. Sampl e
(Program 1.4.1) illustrates how to sample, using the basic operation underlying
shuffling. It takes command-line argumentsMand Nand creates apermutation of
size N(a rearrangement of the integers from 0 to N-l) whose first Mentries com-
perm
1
r
0
1
2
3
4
5
6
7
8
9
10
11 12
13
14
15
0
1
2
3
4
5
6
7
8
9
10 11 12 13 14 15
0
9
9
1
2
3
4
5
6
7
8
0
10
11 12
13
14
15
1
5
9
5
2
3
4
1
6
7
8
0
10
1.1
12
13
14
1.5
2
13
9
5 13
3
4
1
6
7
8
0
10
1.1
12
2
14
1.5
3
5
9
5
13
1
4
3
6
7
8
0
10
11
12
2
14 15
4
11
9
5
13
1
11
3
6
7
8
0
10
4
12
2
14
15
5
8
9
5
13
1
1.1
8
6
6
7
7
3
3
0
0
1.0
10
4
4
12
12
2
2
14
15
9
5
13
1
11
8
1.4
15
Trace ofJava Sample 6 16
93

94
Elements of Programming
Program 1.4.1
Sampling without replacement
m
m
&
public class Sample
{
public static void main(String[] args)
{
// Print a random sample of M integers
// from 0 ...
N-1 (no duplicates).
int M = Integer.parselnt(args[0]);
int N = Integer.parselnt(args[1]);
int[]
perm = new int[N];
// Initialize perm[].
for (int j = 0;
j < N; j++)
perm[j] = j;
// Take sample.
for (int i
= 0;
i
< M; i++)
{
// Exchange perm[i] with a random element to its right.
int r = i + (int) (Math.random()
* (N-i));
int t = perm[r];
perm[r] = perm[i];
perm[i] = t;
}
// Print sample.
for (int i
= 0;
i
< M;
i++)
System.out.print(perm[i] + " ");
System.out.pri ntln();
}
M
N
perm[]
sample size
range
permutation ofOtoN-
'^^s^K^PP^^^^^B^^^I^
This program takes two command-line arguments MandNandproduces a sample ofM of the
integers from 0 to N-1. This process is useful, notjustin state andlocal lotteries, hutin scien
tific applications ofallsorts. If thefirst argument isequal to the second, theresult isa random
permutation of theintegers from 0 to N-1. If thefirstargument isgreater than thesecond, the
program will terminate with an ArrayOutOfBounds exception.
% Java Sample 6 16
9
5 13
1
11 8
% Java Sample 10 1000
656 488 298 534 811 97 813 156 424 109
% Java Sample 20
20
6
12
9
8
13 19 0
2
4
5 18
1
14 16 17
3
7
11 10 15
"wmmwmmmmmBmmmmm
W^^Wf^f^^^^^^^'^^s^^ffTS?5SP7^*S5"

7.4 Arrays
95
prise a random sample. The accompanying trace of the contents of the perm[]
array at the end of eachiteration of the main loop (for a run wherethe valuesof M
and N are 6 and 16,respectively) illustrates the process.
If the valuesof r are chosensuchthat eachvaluein the givenrange is equally
likely, then perm[0] through perm[M-l] are a random sample at the end of the
process (even though some elements might move multiple times) because each
element in the sample is chosen by taking each item not yet sampled, with equal
probability for each choice. One important reason to explicitly compute the per
mutation is that we can use it to print out a random sample of anyarray by using
the elements of the permutation as indices into the array.Doing so is often an at
tractive alternative to actually rearranging the array because it may need to be in
order for some other reason (for instance,a companymight wishto draw a random
sample from a list of customers that is kept in alphabetical order). To see how this
trick works, suppose that we wish to draw a random poker hand from our deck []
array, constructed as just described. We use the code in Sampl e with N = 52 and M
= 5 and replace perm[i] with deck[perm[i]] in the System.out.print() state
ment (and changeit to pri ntl n()), resultingin output such as the following:
3 of Clubs
Jack of Hearts
6 of Spades
Ace of Clubs
10 of Diamonds
Samplinglikethis iswidelyused as the basisfor statistical studiesin polling,scien
tific research,and many other applications,wheneverwewant to draw conclusions
about a largepopulation by analyzing a smallrandom sample.
Precomputed values. One simple application of arrays is to save values that you
have computed, for later use.As an example, suppose that you are writing a pro
gram that performs calculations using small values of the harmonic numbers (see
Program 1.3.5).An efficientapproach is to save the valuesin an array,as follows:
double[]
H = new double[N];
for (int i =1;
i
< N; i++)
H[i]
= H[i-1]
+ 1.0/i;
Then you can just usethe code H[i ] to referto anyof the values.Precomputing val
ues in this way is an example of a space-time tradeoff, by investing in space (to save

96
Elements of Programming
the values) we savetime (since we do not need to recompute them). This method
is not effective if we need valuesfor huge N, but it is very effective if we need values
for small Nmany different times.
Simplifying repetitive code. As an example of another simpleapplication of ar
rays,consider the followingcode fragment, which prints out the name of a month
givenits number (1 for January,2 for February,and so forth):
"Dan")
"Feb")
"Mar")
"Apr")
"May")
"Jun")
"Dul")
"Aug")
"Sep")
"Oct")
"Nov")
"Dec")
Wecould also use a switch statement, but a much more compact alternative is to
use a Stri ng array consisting of the names of each month:
String[] months =
{
"", "Jan",
"Feb",
"Mar", "Apr",
"May", "Jun",
"Jul",
"Aug", "Sep", "Oct", "Nov",
"Dec"
};
System.out.pri ntln(months[m]);
This technique would be especially useful if you needed to access the name of a
month by its number in severaldifferent placesin your program. Note that we in
tentionally waste one slot in the array (element 0) to make months[1] correspond
to January,as required.
Assignments andequality tests. Suppose thatyouhave created thetwoarrays a[]
and b[]. What does it mean to assignone to the other with the code a = b; ?Simi
larly,what does it mean to test whether the two arrays are equal with the code (a
== b)?The answers to these questions may not be what you first assume, but if you
think about the array memory representation, you will see that Java'sinterpretation
if
(m
==
1) System.out.pri ntln(
else if (m
==
2) System.out.pri ntln(
else if (m
==
3) System.out.pri ntln(
else if (m
==
4) System.out.pri ntln(
else if (m
==
5) System.out.pri ntln(
else if (m
==
6) System.out.pri ntl n(
else if (m
==
7) System.out.pri ntl n(
else if (m
==
8) System.out.pri ntln(
else if (m
==
9) System.out.pri ntln(
else if (m
== 10) System.out.p ri ntln(
else if (m
== 11) System.out.pri ntln(
else if (m
== 12) System.out.pri ntln(

IA Arrays
97
of these operations makes sense:An assignment makes the names a and b refer to
the same array. The alternative would be to have an implied loop that assigns each
valuein bto the corresponding valuein a. Similarly, an equalitytest checkswhether
the two names refer to the same array.The alternativewould be to have an implied
loop that tests whether each value in one array is equal to the corresponding value
in the other array. In both cases,the implementation in Javais very simple: it just
performs the standard operation as if the array name were a variable whose value
is the memory address of the array. Note that there are many other operations
that you might want to perform on arrays: for example, it would be nice in some
applications to say a = a + b and have it mean "add the corresponding element
in b[] to each element in a[]," but that statement is not legal in Java. Instead, we
write an explicitloop to perform allthe additions.Wewillconsider in detail Java's
mechanism for satisfyingsuch higher-levelprogramming needs in Section 3.2. In
typical applications,we use this mechanism,so we rarelyneed to use Java's assign
ments and equality tests with arrays.
With these basic definitions and examples out of the way, we can now consider two
applicationsthat both addressinterestingclassical problemsand illustrate the fun
damental importance of arrays in efficient computation. In both cases, the idea of
usingdata to indexinto an arrayplays a centralroleand enables a computation that
would not otherwise be feasible.
Coupon collector
Supposethat you havea shuffled deckof cards and
you turn them face up, one by one. How many cards do you need to turn
up before you have seen one of each suit? How many cards do you need to
turn up before seeing one of each value?These are examples of the famous
coupon collector problem. In general, suppose thatatradingcardcompany
Coupon collection
issuestrading cards with N different possiblecards:how many do you have
to collectbefore you haveallN possibilities, assumingthat each possibilityis equal
ly likelyfor each card that you collect?
Coupon collecting isno toyproblem.Forexample, it isveryoften the casethat
scientists want to know whether a sequence that arises in nature has the same char
acteristics as a random sequence. If so,that fact might be of interest; if not, further
investigation may be warranted to look for patterns that might be of importance.
For example, such tests are used by scientists to decide which parts of genomes
are worth studying. One effective test for whether a sequence is truly random is

98
Elements of Programming
Program L4.2
Coupon collectorsimulation
public class CouponCollector
{
public static void main(String[]
args)
{
// Generate random values in (0..N]
until finding each one.
int N = Integer.parselnt(args[0]);
boolean[] found = new boolean[N];
int cardcnt = 0, valcnt = 0;
while (valcnt < N)
{
// Generate another value.
int val = (int) (Math.random() * N);
cardcnt++;
if (!found[val])
{
valcnt++;
found[val] = true;
}
}
// N different values found.
System.out.pri ntln(cardcnt);
}
}
N
range
cardcnt
values generated
valcnt
different valuesfound
found []
table offound values
This program simulates coupon collection bytaking a command-line argument Nandgenerat
ingrandom numbers between 0 and N-1 untilgettingevery possible value.
% Java CouponCollector 1000
6583
% Java CouponCollector 1000
6477
% Java CouponCollector 1000000
12782673
•^g^Sjf^fl^^^^sg&P^
I^^^^S^^^^^^^^^^^^^^^^^^raP^^^^
the coupon collector test: compare the number of elements that need to be exam
ined before allvalues are found againstthe corresponding number for a uniformly
random sequence. CouponCol 1ector (Program 1.4.2) is an example program that
simulates this processand illustratesthe utilityofarrays. It takes the value ofN from
the command line and generates a sequence of random integer values between 0

IA Arrays
and N— 1 using the code (i nt) (Math. randomO * N) (see Program 1.2.5). Each
value represents a card: for each card, we want to know if we have seen that value
before. To maintain that knowledge, we use an array found [], which uses the card
value as an index: found [i ] is true if we have seen
a card with value i and f al se if we have not. When
we get a new card that is represented by the integer
val, we check whether we have seen its value before
simply by accessing found [val ]. The computation
consists of keeping count of the number of distinct
values seen and the number of cards generated and
printing the latter when the former getsto N.
Asusual,the best wayto understand aprogram
is to consider a trace of the values of its variables for
a typical run. It is easy to add code to CouponCol -
lector that produces a trace that gives the values
of the variables at the end of the whi 1e loop for a
typical run. In the accompanying figure, we use F
for the value f al se and T for the value t rue to make
the trace easier to follow. Tracingprograms that use
large arrays can be a challenge: when you have an
array of sizeN in your program, it representsN vari
ables, so you have to list them all. Tracing programs
that use Math. random() also can be a challengebecause you get a different trace
every time you run the program. Accordingly, we check relationships among vari
ablescarefully. Here, note that val cnt always isequal to the number of t rue values
in found [].
Without arrays,we could not contemplatesimulating the coupon collector
processfor huge N; with arrays it is easyto do so.Wewill see many examples of
such processes throughout the book.
99
val
found
0 12
3
4
5
valcnt
cardcnt
F
F
F
T
T
F T
F
F
F
TFT
T
T
T
p
j
r
F
T
F
T
T
T
F
T
f
T
j
j
F
T
T
TTTFTT
TTT
T
T
T
F
T
T
T
T
7
0
1
2
3
3
4
4
5
5
5
6
0
1
2
3
4
5
6
7
8
9
10
Tracefora typical run of
Java CouponCollector 6
Sieve of Eratosthenes
Primenumbersplayan important rolein mathematics
and computation, including cryptography. A prime number is an integer greater
than one whose only positivedivisorsare one and itself. The prime counting func
tion tt(JV) is the number of primes lessthan or equalto N. For example,tt(25) = 9
sincethe first nine primes are 2,3,5,7,11,13,17,19, and 23.This function playsa
central role in number theory.

100
Elements of Programming
m
I
PS
ProgramIA3
Sieve ofEratosthenes
public class PrimeSieve
{
public static void main(String[] args)
{
// Print the number of primes <= N.
int N = Integer.parselnt(args[0]);
boolean[] isPrime = new boolean[N+l];
for (int i
= 2;
i
<= N; i++)
isPrime[i] = true;
for (int i
= 2;
i
<= N/i;
i++)
{
if (isPrime[i])
{
// Mark multiples of i
as nonprime.
for (int j = i;
j
<= N/i;
j++)
isPrime[i * j] = false;
}
}
// Count the primes.
int primes = 0;
for (int i =2;
i
<= N; i++)
if (isPrime[i])
primes++;
System. out. pri ntl n(pri mes);
}
N
isPrime[i]
primes
argument
is i prime7,
primecounter I
This program takes a command-line argument Nandcomputes the number ofprimes less than
orequal to N. To doso, it computes anarray ofboolean values with i sPri me [i ] setto true if
i isprime, andtofal se otherwise. First, itsets totrue all array elements in order to indicate
that nonumbers are initially known to be nonprime. Then itsets tofal se array elements cor
responding to indices that are known to be nonprime (multiples ofknown primes). I/a[i] is
still true after all multiples of smaller primes have been set to false, then we know i to be
prime. The termination test inthe second for loop isi <= N/i instead ofthe naive i <= Nbe
cause anynumber with nofactor less than N/i has nofactor greater than N/i, sowedonothave
to lookforsuchfactors. This improvement makes itpossible to run theprogramforlarge N.
% Java PrimeSieve 25
9
% Java PrimeSieve 100
25
% Java PrimeSieve 1000000000
50847534
wmmmmimmmmmmmm
^M^^S^^^^^dki^Si^Sd^^M
i

IA Arrays
101
isPrime
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
2
T
T
F
T
F
T
F
T
F
T
F
T
F
T
F
T
F
T
F
T
F
T
F
T
3
T
T
F
T
F
I
F
F
F
T
F
T
F
F
F
T
F
I
F
F
F
T
F
1
5
T
T
F
T
F
T
F
F
F
T
F
T
F
F
F
T
F
T
F
F
F
T
F
F
T
T
F
T
F
T
F
F
F
T
F
T
F
F
F
T
F
T
F
F
F
T
F
F
Trace ofJava PrimeSieve 25
One approach to counting primes isto usea program like Factors (Program
1.3.9). Specifically, we could modifythe code in Factors to set a boolean value to
be true if a given number is prime and fal se otherwise (instead of printing out
factors), then enclose that code in a loop that increments a counter for each prime
number. This approach is effective for smallN, but becomes too slowas N grows.
PrimeSieve (Program 1.4.3) takes a command-line integer Nand computes
the prime count using a technique known asthe Sieve ofEratosthenes. The program
uses a boolean array isPrime[] to record which integers are prime. The goal is
to set i sPri me [i ] to true if i is prime, and to fal se otherwise. The sieveworks
as follows: Initially, set all array elementsto true, indicating that no factors of any
integer have yet been found. Then, repeat the followingsteps as long as i <= N/i:
• Find the next smallest i for which no factors have been found.
• Leave i sPri me[i ] as true since i has no smaller factors.
• Set the i sPri me [] entries for all multiples of i to be fal se.
When the nested f or loop ends,wehavesetthe i sPri me [] entries for allnonprimes
to be false and have left the isPrime[] entries for all primes as true. With one
more passthrough the array,wecan count the number of primeslessthan or equal
to N. As usual, it is easy to add code to print a trace. For programs such as Prime-
Si eve, you have to be a bit careful—it contains a nested for-i f-for, so you have
to pay attention to the braces in order to put the print code in the correct place.
Note that we stop when i > N/i, just as we did for Factors.
With PrimeSieve, we can compute tt(N) for large Ny limited primarily by
the maximum array size allowed by Java. This is another example of a space-time
tradeoff. Programs like PrimeSi eve playan important role in helping mathemati
cians to develop the theory of numbers, which has many important applications.

102
Elements of Programming
Two-dimeesiomal arrays
Inmany applications, a convenient way tostore in
formation is to use a table of numbers organized in a rectangular table and refer
to rows and columns in the table. For example, a teacher might need to maintain
a table witha rowcorresponding to each studentand a columncorresponding to
each assignment, a scientist might need to maintain a table of experimental data
with rows corresponding to experiments and columns corre
sponding to various outcomes, or a programmer mightwant
a[i][2]
to prepare an image for displayby setting a table of pixels to
various grayscalevalues or colors.
row i-
The mathematical abstraction corresponding to such
tables is a matrix; the corresponding Java construct is a two-
dimensional array. You are likely to have already encountered
many applications of matrices and two-dimensional arrays,
and you will certainly encounter many others in science, in
engineering, and in computing applications, as we will dem
onstrate with examplesthroughout this book. Aswith vectors
and one-dimensional arrays,many of the most important ap-
column i
plications involve processinglarge amounts of data, and we
defer considering those applications untilwe consider input
Tna omy°Ja
j
^
^ .
n
- _
two-dimensional array
and output, in Section 1.5.
7
Extending Java array constructs to handle two-dimen
sional arrays is straightforward. To refer to the element in row i and column j of
a two-dimensional array a[] [], we use the notation a[i ] [j]; to declare a two-di
mensionalarray,weadd another pair of brackets;and to createthe array,wespecify
the number of rowsfollowed bythe number of columns after the type name (both
within brackets), as follows:
doubl e[][]
a = new doubl e [M] [N];
We refer to such an array as an M-by-AT array.Byconvention, the first dimension
is the number of rows and the second is the number of columns. As with one-
dimensional arrays, Javainitializes all entries in arrays of numbers to zero and in
arrays ofboolean values to fal se.
Initialization. Default initialization of two-dimensional arrays is useful because
it masksmore codethan for one-dimensionalarrays.The following code isequiva
lent to the single-linecreate-and-initialize idiom that wejust considered:
99
85\ 98
|98
57
78
92
77
76
94
32
11
99
34
22
90
46
54
76
59
88
92
66
89
97
71
24
89
29
38
t

IA Arrays
doubled []
a;
a = new double[M][N];
for (int i
= 0;
i
< M;
i++)
{
// Initialize the ith row.
for (int j = 0;
j
< N; j++)
a[i][j] = 0.0;
}
This code is superfluous when initializing to zero, but the nested for loops are
needed to initialize to some other value(s).Asyou willsee,this code is a model for
the code that we use to access or modify each element of a two-dimensional array.
Output. We use nested for loops for many array-processing operations. For ex
ample, to print an M-by-AT array in the familiar tabular format, we would use the
following code
for (int i
= 0;
i
< M; i++)
{
// Print the ith row.
for (int j = 0;
j < N; j++)
System.out.print(a[i][j] +
System.out.pri ntln();
}
");
regardless of the array elements' type. If desired, we
a^^
could add code to embellish the output with row and
\.
column numbers (see Exercise 1.4.6), but Java pro
grammers typically tabulate arrays with row numbers
running top to bottom from 0 and column number
running left to right from 0. Generally, we also do so
and do not bother to use labels.
Memory representation. Java represents a two-di-
a[5]-*-
mensional array as an array of arrays. A matrix with
M rows and N columns is actually an array of length
M, each entry of which is an array of length N. In a
two-dimensional Javaarray a [] [], we can use the code
a[i] to refer to the ith row (which is a one-dimen
sional array), but we have no corresponding way to
refer to a column.
103
a[0][0]
a[0][l]
a[0][2]
a[l][0]
a[l][l]
a[l][2]
a[2][0]
a[2][l]
a[2][2]
a[3][0]
a[3][l]
a[3][2]
a[4][0]
a[4][l]
a[4][2]
Kill
a[6][0]
a[6][l]
a[6][2]
a[7][0]
a[7][l]
a[7][2]
a[8][0]
a[8][l]
a[8][2]
a[9][0]
a[9][l]
a[9][2]
A 10-by-3 array

104
Elements of Programming
Setting values at compile time. TheJava methodforinitial
izing an array of values at compile time follows immediately
from the representation. Atwo-dimensional array is an array
of rows,each row initialized as a one-dimensional array. To
initialize a two-dimensional array,we enclose in braces a list
of terms to initialize the rows, separated by commas. Each
term in the listisitselfa list:the valuesfor the array elements
in the row,enclosedin bracesand separatedby commas.
Spreadsheets. Onefamiliar use ofarrays isa spreadsheet for
maintaining a table of numbers. For example,a teacher with
M students and N test grades for each student might main
tain an (M+l)-by-(N+l) array,reservingthe last column for
each student's average grade and the last row for the average
test grades.Even though we typically do such computations
within specialized applications,it is worthwhileto study the
underlying code as an introduction to array processing. To compute the average
grade for each student (average values for each row), sum the entries for each row
and divide by N. The row-by-row order in which this code processes the matrix
int[][]
a
=
{
{ 99, 85, 98,
0 },
{ 98, 57, 78,
0 },
{ 92, 77, 76,
0 },
{ 94, 32, 11.
0 },
{ 99, 34, 22,
0 },
{ 90, 46, 54,
0 },
{ 76, 59, 88,
0 },
{ 92, 66, 89,
0 },
{ 97, 71, 24,
0 },
{ 89, 29, 38,
0 },
{
o,
0,
0,
0 }
};
Compile-time initialization
ofa two-dimensional array
N=3
averages
in column N
99
85
98
94
98
57
78
77
I92
77
76
811
94
32
11
45
99
34
22
51
90
46
54
63
76
59
88
74
92
66
89
82
97
71
24
64
89
29
38
52
92
55
57-
92+77+76
Computerowaverages
for (int i = 0; i < M; i++)
{
// Compute average for row i
double sum =0.0;
for (int j = 0; j < N;
j++)
sum += a[i][j];
a[i][N] = (int) Math.round(sum/N);
}
M = 10
85+57+...+29
10
column
averages
in row M
Compute columnaverages
for (int j = 0; j < N;
j++)
{
// Compute average for column j
double sum =0.0;
for (int i
= 0;
i
< M; i++)
sum += a[i][j];
a[M][j] = (int) Math.round(sum/M);
}
Typical spreadsheet calculations

IA Arrays
entries is known as row-major order. Similarly, to compute the average test grade
(average values for each column), sum the entries for each column and divide by
M. The column-by-column order in which this code processesthe matrix entries is
known as column-major order.
a[][]
b[][]
b[l][2]
c[][]
c[l][2]
Matrix addition
Matrix operations. Typical applications in science and
engineering involve representing matrices as two-di
mensional arrays and then implementing various math
ematical operations with matrix operands. Again, even
though such processingis often done within specialized
applications, it is worthwhile for you to understand the
underlying computation. For example, we can add two
N-by-N matrices as follows:
doubl e[][]
c = new doubl e [N] [N];
for (int i
= 0;
i
< N; i++)
for (int j = 0;
j
< N; j++)
c[i][j] = a[i][j] + b[i][j];
Similarly,we can multiply two matrices. You may have
learned matrix multiplication, but if you do not recallor
are not familiar with it, the Javacode belowfor square matrices is es
sentiallythe same as the mathematical definition.Eachentry c[i ] [j]
in the product of a [] and b[] is computed by taking the dot product
of row i of a [] with column j of b[].
a[][]
105
.30
.60
.101— row 1
doubl e[][]
c = new doubl e [N] [N];
for (int i
= 0;
i
< N; i++)
{
for (int j
= 0;
j
< N; j++)
{
// Compute dot product of row i
and column j,
for (int k = 0;
k < N;
k++)
c[i][j] += a[i][k]*b[k][j];
}
}
The definition extends to matrices that are not necessarilysquare (see
Exercise 1.4.17).
b[][]
column 2
C[][]
Matrix multiplication
'.5
M
-.4

106
Elements of Programming
Special cases ofmatrix multiplication. Two special cases ofmatrixmultiplication
are important. These special casesoccur when one of the dimensions of one ofthe
matrices is 1,so it may be viewed as a vector.Wehave matrix-vector multiplication^
where we multiply an M-by-N matrix by a column vector (an N-by-1 matrix) to get
an M-by-1 column vector result (each entry
in the result is the dot product of the corre
sponding row in the matrix with the oper
and vector). The second case is vector-matrix
multiplication^ where we multiply a row vector
(a 1-by-M matrix) by an M-by-N matrix to
get a 1-by-N row vector result (each entry in
the result is the dot product of the operand
vector with the corresponding column in the
matrix). These operations provide a succinct
wayto expressnumerous matrix calculations.
For example, the row-average computation
for such a spreadsheet with M rows and N
columns is equivalent to a matrix-vector
multiplication where the column vector has
M entries all equal to 1/M. Similarly, the col
umn-average computation in such a spread
sheet is equivalent to a vector-matrix multi
plication where the row vector has N entries
all equal to 1/N. We return to vector-matrix
multiplication in the context of an important
application at the end of this chapter.
Matrix-vectormultiplication a[] []*x[] = b[]
for (int i =0;
i
< M; i++)
{
// Dot product of row i and x[],
for (int j
= 0;
j
< N; j++)
a[i][j]*x[j];
}
b[i]
+-
a[][]
b[]
~99
85
98
~94~
98
57
78
77
92
77
76
x[]
81
94
32
11
45
99
34
22
.33
51
90
46
54
.33
63
76
59
88
.33
74
92
66
89
82
97
71
24
64
89
29
38
52
row
averages
Vector-matrix multiplication y[]*a[][] = c[]
for (int j
= 0;
j
< N; j++)
{
// Dot product of y[] and column
for (int i
= 0;
i
< M; i++)
c[j] +- y[i]*a[i][j];
}
y[]
[ .1 .1 .1 .1 .1 .1 .1 .1 .1 .1 ]
a[][]
3-
99
85
98
98
57
78
92
77
76
94
32
11
99
34
22
90
46
54
76
59
88
92
66
89
97
71
24
89
29
38
c[]
[92
55
57]
column
averages
Matrix-vector and vector-matrix multiplication
Ragged arrays. There isactually no require
ment that allrowsin a two-dimensional array
have the same length—an array with rows of
nonuniform length isknown as a ragged array
(see Exercise 1.4.32 for an example applica
tion). The possibility of ragged arrays creates
the need for more care in crafting array-pro
cessing code. For example, this code prints
the contents of a ragged array:

IA Arrays
for (int i
= 0;
i
< a.length;
i++)
{
for (int j = 0;
j < a[i].length;
j++)
System, out. print(a [i][j] + " ");
System.out.pri ntln();
}
This code tests your understanding of Java arrays,so you should take the time to
study it. In this book, we normally usesquareor rectangulararrays,whose dimen
sion is givenby a variable Mor N. Code that uses a[i ]. 1ength in this wayis a clear
signal to you that an array is ragged.
Multidimensional arrays. The same notation extends to allow us to write code
using arraysthat haveany number of dimensions.Forinstance,we can declareand
initializea three-dimensional array with the code
doubled [][]
a = new double[N] [N] [N];
and then refer to an entry with code like a [i ] [j ] [k], and so forth.
Two-dimensional arrays provide a natural representation for matrices, which are
omnipresent in science,mathematics, and engineering.They also provide a natural
wayto organize large amounts of data, a keyfactor in spreadsheets and many other
computing applications. Through Cartesian coordinates, two- and three-dimen
sional arrays also provide the basis for a models of the physicalworld.Weconsider
their use in all three arenas throughout this book.
dead end
escape
107
Example: self-avoiding random walks
Suppose that you leave
your dog in the middle of a large city whose streets form a familiar grid
pattern. We assume that there are N north-south streets and N east-west
streets all regularly spaced and fullyintersecting in a pattern known as a
lattice. Tryingto escapethe city,the dog makesa random choiceof which
way to go at each intersection, but knows by scent to avoid visiting any
place previously visited. But it is possible for the dog to get stuck in a
dead end where there is no choice but to revisit some intersection. What
is the chance that this will happen? This amusing problem is a simple
example of a famous model known as the self-avoiding random walk,
which has important scientificapplications in the study of polymers and
in statistical mechanics, among many others. For example, you can see
Self-avoiding walks

108
Elements of Programming
that this processmodels a chain of material growinga bit at a time, until no growth
is possible. To better understand such processes, scientists seek to understand the
properties of self-avoidingwalks.
The dog's escapeprobability is certainly dependent on the sizeof the city.In
a tiny 5-by-5 city, it is easy to convince yourself that the dog is certain to escape.
But what are the chances of escapewhen the city is large?We are also interested in
other parameters. For example, how long is the dog's path, on the average? How
often does the dog come within one block of a previous position other than the
one just left, on the average? How often does the dog come within one block of
escaping? These sorts of properties are important in the various applications just
mentioned.
Sel f Avoidi ngWal k (Program 1.4.4) is a simulation ofthis situation that uses
a two-dimensional bool ean array,where each entry represents an intersection. The
value true indicates that the dog has visited the intersection; fal se indicates that
the dog has not visited the intersection. The path starts in the center and takes ran
dom steps to placesnot yetvisiteduntil getting stuck or escapingat a boundary. For
simplicity,the code iswritten so that if a random choice is made to go to a spot that
has already been visited, it takes no action, trusting that some subsequent random
choice will find a new place (which is assured because the code explicitlytests for a
dead end and leavesthe loop in that case).
Note that the code depends on Javainitializing allof the array entries to fal se
for each experiment. It also exhibits an important programming technique where
we code the loop exit test in the whi 1e statement as a guard against an illegalstate
ment in the body of the loop. In this case,the whi1e loop continuation test serves
as a guard against an out-of-bounds array access within the loop. This corresponds
to checking whether the dog has escaped.Within the loop, a successful dead-end
test results in a break out of the loop.
Asyou can see from the sample runs, the unfortunate truth is that your dog
is nearly certain to get trapped in a dead end in a large city.If you are interested in
learning more about self-avoidingwalks,you can find several suggestions in the ex
ercises. For example, the dog is virtually certain to escape in the three-dimensional
version of the problem. While this is an intuitive result that is confirmed by our
tests, the development of a mathematical model that explains the behavior ofself-
avoiding walksis a famous open problem: despite extensiveresearch, no one knows
a succinctmathematical expressionfor the escapeprobability,the averagelength of
the path, or any other important parameter.

1.4 Arrays
109
P
1
1%
;Vji»:
A^i^^Sl^^fil
'0$4W)t^!k
>^?pl^"^p's
jiiiiii»
Program IAA
Self-avoiding random walks
public class SelfAvoidingWalk
{
public static void main(String[] args)
{
// Do T random self-avoiding walks
//
int
int
int
for
{
in an N-by-N lattice
N = Integer.parselnt(args[0]);
T = Integer.parselnt(args[1]);
deadEnds = 0;
(int t
= 0;
t
< T; t++)
boolean[][]
a = new boolean[N][N]
int x = N/2,
y = N/2;
while (x > 0 && x < N-1 && y > 0
N
T
deadEnds
a[][]
x,
y
lattice size
number of trials
trials resulting in a deadend
intersections visited
currentposition
random number in (0, 1)
}
{
// Check for dead end and make a
a[x][y] = true;
if (a[x-l][y]
&& a[x+l][y] && a[x] [y-1]
&& a[x][y+l])
{
deadEnds++;
break;
}
double r = Math.random();
if
(r < 0.25) { if (!a[x+l][y])
else if (r < 0.50) { if (!a[x-l][y])
else if (r < 0.75) { if (!a[x] [y+1])
else if (r < 1.00) { if (!a[x] [y-1])
}
}
System.out.println(100*deadEnds/T + "% dead ends");
&& y < N-1)
random move.
x++;
}
x—;
}
y++;
y—;
}
}
This program takes command-line arguments NandT andcomputes T self-avoiding walks in
an N-by-N lattice. For each walk, it creates a boolean array, starts thewalk in thecenter, and
continues untileither a dead endora boundary isreached. The result ofthecomputation isthe
percentage ofdeadends. Asusual, increasing the number ofexperiments increases theprecision
of theresults.
% Java SelfAvoidingWalk 5 100
0% dead ends
% Java SelfAvoidingWalk 20 100
36% dead
ends
% Java SelfAvoidingWalk 40 100
80% dead
ends
% Java SelfAvoidingWalk 80 100
98% dead
ends
% Java SelfAvoidingWalk 160 100
100% dead
ends
W^m^^^lw^ww^^^W^^W^^^^
!
% Java SelfAvoidingWalk 5 1000
0% dead
ends
% Java SelfAvoidingWalk 20 1000
32% dead
ends
% Java SelfAvoidingWalk 40 1000
70% dead ends
% Java SelfAvoidingWalk 80 1000
95% dead
ends
% Java SelfAvoidingWalk 160 1000
100% dead
ends
'^^^W^J^w^m^^^^^^^^^'^^W^^^^^&^^^!'

110
Elements of Programming
! Jjl.
r
Tti
i-
T
i.
.1.
£
±
t
•?
"it I s^*3r' •
i-±'
uii I
!:f •
-J-T. H
i—fiF?;
~:Jft *t T:
B P#:EifiEjim
:Bjf:| ill
t4
M#W --+•
IwjjRj-.
iJTntH"}:-
flni||i4-H--
ffljl iWiUH--.
11
::|±|x:x -T-Ttfrt
\ujk.
-fin ttRffir:
:ifS
i Til"
TtPlttft
"ffjfS
..±LL1|- [•#•
+HttitHi
•U.|±{.|.1I1 -t4^ -t4- -rf--
.±:=-:o: | j-4.
:t:t:h
. i—•
|| is t:5'
f-J-W-M+^f
RBit".t,1.|.lli|'
"±tSi +tffi[-:
iHTHl •
5l"I-fifHrr-:
l.faitr{.|'|hfMt'
::»i TT
-IRM l rr
"t:t"
'" rtT«' •
v
::ffi1;i
*:.t:
•HiHiHItlil
11 I!
i t! tit !
-H-fi-t-T-r:+-
"is
-r-r
.*.t-
*it iii ji It
"Ti RIP H_
mttffifr mfj:: . .ff»
,|l|,|..jj,..|,n
IIHI
x't-*vi M:
.DI4I
.... .i.. 4. - jiuiiii.
±ltHj : :x -
WW-ftUfftyrnHii*H
Self-avoiding random walks in a 21-by-21 grid
:ni-SKB
X -r-iitiisP
"X*
TI"
X T-iiniH-
xn
-:--HHHIf-
.j.
-L.
-r
-
,
t
iiiillllfflS::

IA Arrays
111
Summary
Arrays are the fourth basic element (after assignments, conditionals,
and loops) found in virtuallyeveryprogramminglanguage, completingour cover
age of basic Java constructs. Asyou haveseen with the sample programs that we
havepresented,you can write programs that can solve all sorts of problems using
just these constructs.
Arraysare prominent in many of the programs that weconsider,and the basic
operations that we have discussedhere willserveyou wellin addressing many pro
gramming tasks.When you are not using arrays explicitly(and you are sure to be
doing so frequently),you willbe usingthem implicitly, becauseallcomputers have
a memorythat isconceptually equivalent to an indexed array.
The fundamentalingredientthat arrays add to our programsis a potentially
hugeincrease in the size of a program's state. Thestateof a programcanbe defined
asthe information you needto knowto understandwhat a program is doing. In a
program without arrays, if you know the values of the variables and which state
ment is the next to be executed, you can normally determine what the program
willdo next.When we trace a program, we are essentially tracking its state.When
a program uses arrays,however, there can be too huge a number of values (each of
whichmightbe changedin eachstatement)forusto effectivelytrackthem all. This
difference makes writing programs with arrays more of a challenge than writing
programs without them.
Arrays directly represent vectors and matrices, so they are of direct use in
computations associatedwith manybasicproblemsin science and engineering.Ar
raysalso provide a succinct notation for manipulating a potentiallyhuge amount
of data in a uniform way, so they playa criticalrolein anyapplicationthat involves
processinglarge amounts of data, asyou willseethroughout this book.

Elements of Programming
Q. SomeJava programmersusei nt a[] insteadof i nt [] a to declarearrays.What's
the difference?
A. In Java, both are legaland equivalent. The former is how arrays are declaredin
C.The latter isthe preferredstyle in Java sincethe type of the variablei nt [] more
clearly indicates that it isan array of integers.
Q. Whydo arrayindices start at 0 insteadof 1?
A, This convention originated with machine-language programming, where the
address of an arrayelementwouldbecomputedbyaddingthe indexto the address
of the beginning of an array. Starting indices at 1 would entail either a waste of
space at the beginningof the arrayor a waste of time to subtract the 1.
Q. What happens if I use a negative number to index an array?
A, The same thing as when you use an indexthat is too big.Whenevera program
attempts to index an array with an index that is not between zero and the array
length minus one,Java willissue an ArraylndexOutOfBoundsException and ter
minate the program.
Q. What happens when I compare two arrayswith (a == b)?
A. The expression evaluates to t rue onlyif a[] and b[] referto the samearray,not
if they havethe same sequenceof elements. Unfortunately, this is rarelywhat you
want.
Q. If a[] is an array,why does System.out. pri ntl n(a) print out a hexadecimal
integer,like @f62373 , instead of the elements of the array?
A. Good question. It is printing out the memory address of the array,which, un
fortunately, is rarely what you want.
Q. What other pitfallsshould I watch out for when using arrays?
A. It is very important to remember that Java always initializes arrays when you
create them, so that creating an array takes timeproportional tothesizeof thearray.

Exercises
1.4.1
Write a program that declares and initializes an array a[] of size1000 and
accesses a [1000]. Does your program compile?What happens when you run it?
1.4.2
Describe and explainwhat happens when you try to compile a program
with the following statement:
int N = 1000;
int[]
a = new int[N*N*N*N];
1.4.3
Given two vectors of length Nthat are represented with one-dimensional
arrays, write a code fragment that computes the Euclidean distance between them
(the squareroot of the sumsof the squares of the differences between correspond
ing entries).
1.4.4
Writea code fragment that reverses the order of a one-dimensional array
a[] of St ri ngvalues. Do not create another arrayto hold the result. Hint: Usethe
code in the text for exchangingtwo elements.
1.4.5
What iswrong with the following codefragment?
int[] a;
for (int i =0;
i
< 10; i++)
a[i]
= i
* i;
Solution.
It does not allocate memory for a[] with new. This code results in a
variable a might not have been initialized compile-timeerror.
1.4.6
Write a code fragment that prints the contents of a two-dimensional bool
ean array,using *to represent true and a spaceto represent fal se. Include row and
column numbers.
1.4.7
What does the following codefragmentprint?
int[]
a = new int[10];
for (int i =0;
i
< 10; i++)
a[i]
= 9 - i;
for (int i
= 0;
i
< 10; i++)
a[i] = a[a[i]];
for (int i = 0; i < 10; i++)
System.out.pri ntln(a[i]);

114
Elements of Programming
1.4.8
What values does the followingcode put in the array a [] ?
int N = 10;
int[]
a = new int[N];
a[0]
= 1;
a[l]
= 1;
for (int i
= 2;
i
< N; i++)
a[i]
= a[i-l]
+ a[i-2];
1.4.9
What does the following code fragment print?
int[]
a = { 1, 2,
3 };
int[]
b = { 1, 2,
3 };
System.out.println(a == b);
1.4.10 Write a program Deal that takesan command-line argument Nand prints
Npoker hands (five cards each) from a shuffleddeck,separated by blank lines.
1.4.11 Write code fragments to create a two-dimensional array b[] [] that is a
copy of an existing two-dimensional array a[] [], under each of the following as
sumptions:
a. a[] [] is square
b. a[] [] is rectangular
c.
a [] [] may be ragged
Yoursolution to bshould work for a, and your solution to c should work for both
band a, but your code should get progressively more complicated.
1.4.12 Write a code fragment to print the transposition (rows and columns
changed) of a square two-dimensional array.For the example spreadsheet array in
the text, you code would print the following:
99
98
92
94
99
90
76
92
97
89
85
57
77
32
34
46
59
66
71
29
98
78
76
11
22
54
88
89
24
38
1.4.13 Write a code fragment to transpose a square two-dimensional array inplace
without creating a second array.

1.4 Arrays
1.4.14 Writea program that takes an integerN from the command line and cre
ates an N-by-Nboolean array a[] [] such that a[i ] [j] is true if i and j are rela
tively prime (have no commonfactors), and fal se otherwise. Use your solutionto
Exercise 1.4.6to print the array.Hint Usesieving.
1.4.15 Write a program that computes the product of two square matrices of
booleanvalues, usingthe oroperationinstead of + and the and operation instead
of*.
1.4.16 Modify the spreadsheet code fragment in the text to compute a weighted
average of the rows,where the weights of eachtest scoreare in a one-dimensional
arrayweights []. Forexample, to assign the lastof the threetestsin our exampleto
be twicethe weightof the others,you would use
double[] weights = { .25,
.25,
.50 };
Note that the weights should sum to 1.
1.4.17 Write a code fragment to multiply two rectangular matrices that are not
necessarily square.Note: For the dot product to be well-defined, the number of col
umns in the firstmatrix must be equalto the number of rowsin the second matrix.
Print an error message if the dimensionsdo not satisfy this condition.
1.4.18 Modify SelfAvoi di ngWal k (Program 1.4.4) to calculate and print the av
erage length of the paths as well as the dead-end probability. Keep separate the
average lengthsof escapepaths and dead-endpaths.
1.4.19 Modify SelfAvoi di ngWal k to calculate and print the average area of the
smallest axis-oriented rectangle that encloses the path. Keep separate statistics for
escapepaths and dead-end paths.
115

116
Elements of Programming
1.4.20 Dicesimulation. The following codecomputes the exactprobability distri
bution for the sum of two dice:
double[] dist = new double[13];
for (int i
= 1;
i
<= 6;
i++)
for (int j = 1;
j
<= 6;
j++)
dist[i+j] += 1.0;
for (int k = 1;
k <= 12;
k++)
dist[k]
/= 36.0;
The value di st [k] is the probability that the dice sum to k. Run experiments to
validatethis calculation simulatingN dicethrows,keeping track of the frequencies
of occurrence of each value when you compute the sum of two random integers
between 1 and 6. HowlargedoesN haveto be beforeyour empirical results match
the exact results to three decimal places?
1.4.21 Longestplateau. Given an arrayof integers, findthe lengthand locationof
the longestcontiguoussequence of equalvalues where the valuesof the elements
just before and just after this sequenceare smaller.
1.4.22 Empirical shuffle check. Run computational experimentsto checkthat our
shuffling codeworksas advertised. Writea program Shuff1eTest that takescom
mand-line argumentsM and 1ST, doesN shuffles of an array of sizeM that is initial
izedwith a[i ] = i before eachshuffle, and prints an M-by-M table such that row
i gives the number of times i wound up in position j for all j. Allentries in the
array should be closeto N/M.
1.4.23 Bad shuffling. Suppose that you choose a random integer between 0 and
N-1in our shuffling codeinsteadof onebetweeni and N-1. Showthat the resulting
order is notequallylikelyto be one of the N! possibilities.Run the test of the previ
ous exercise for this version.
1.4.24 Music shuffling. You setyour musicplayerto shufflemode. It playseachof
the N songs before repeating any. Write a program to estimate the likelihood that
you will not hear any sequential pair of songs (that is,song 3 does not followsong
2, song 10 does not follow song 9, and so on).

IA Arrays
1.4.24 Minima in permutations. Write a program that takes an integer Nfrom
the command line, generates a randompermutation, printsthe permutation, and
printsthenumberofleft-to-rightminimainthepermutation(thenumber oftimes
an element isthesmallest seen sofar). Then write a program thattakes integers M
and Nfrom the command line, generates Mrandom permutations of size N, and
prints theaverage number ofleft-to-right minima inthepermutations generated.
Extra credit: Formulate a hypothesis about thenumber ofleft-to-right minima in
a permutation of size N, as a function of N.
1.4.25 Inverse permutation. Write a program that reads in a permutation of the
integers 0 to N-1 from Ncommand-line arguments andprintsthe inverse permu
tation. (Ifthepermutation isin an array a[], itsinverse isthearray b[] such that
a[b[i ]] = b[a [i ]] = i.) Besureto check that the input isa validpermutation.
1.4.26 Hadamard matrix. TheN-by-NHadamardmatrixH(N) isa boolean ma
trixwiththe remarkable property that any two rows differ in exactly N/2 entries.
(This property makes it useful for designing error-correcting codes.) H(l) is a
1-by-lmatrix withthesingle entrytrue, andfor AT>1, H(2N) isobtained byalign
ingfourcopies ofH(N) in alarge square, andtheninverting alloftheentries in the
lower right N-by-N copy, as shown inthefollowing examples (with Trepresenting
true and Frepresenting fal se, as usual).
H(l)
H(2)
H(4)
T
T T
T T T T
T
F
T
F T
F
T
T
F
F
T
F
F T
Write a program that takes one command-line argument N and prints H(N). As
sume that JV is a power of 2.
1.4.27 Rumors. Alice isthrowing apartywithN otherguests, including Bob. Bob
startsa rumor aboutAlice bytelling it to oneoftheotherguests. Apersonhearing
this rumor for the first time will immediately tellit to one other guest, chosen at
random from all the people at the party except Alice and the person from whom
117

118
Elements of Programming
theyheard it.Ifa person (including Bob) hears therumorfora second time, heor
she will not propagate it further. Write a program to estimate the probability that
everyone attheparty(exceptAlice) will hear therumorbefore itstops propagating.
Also calculate an estimateof the expected number of peopleto hear the rumor.
1.4.28 Find aduplicate. Given an array of Nelements witheach element between
1 and N, write an algorithm to determine whether thereareanyduplicates. You do
not needto preserve the contents ofthe given array, but do not usean extraarray.
1.4.29 Countingprimes. Compare PrimeSi evewiththe method that we used to
demonstrate the break statement, at the end of Section 1.3.This is a classicexample
of a time-space tradeoff: PrimeSieve isfast, but requires a boolean array of size
N;the otherapproach uses only two integer variables, but is substantially slower.
Estimate the magnitude of thisdifference byfinding the value of N forwhich this
second approach can complete the computation in about the sametime as Java
PrimeSeive 1000000.
1.4.30 Minesweeper. Write a programthat takes 3 command-line argumentsM,
N,andp andproduces anM-by-Nboolean arraywhere each entryisoccupiedwith
probabilityp.Intheminesweeper game, occupied cells represent bombs andempty
cells represent safe cells. Printoutthearrayusing anasteriskforbombs andaperiod
forsafe cells. Then, replace each safe square withthenumberofneighboring bombs
(above, below, left, right,or diagonal) and print out the solution.
*
*
.
.
.
*
*
1
0
0
3
3
2
0
0
.
*
.
.
.
1*10 0
Try towrite your code sothatyou have as few special cases as possible todeal with,
by using an (M+2)-by-(N+2) boolean array.
1.4.31 Self-avoiding walk length. Suppose that there isno limiton thesize of the
grid. Runexperiments to estimate the average walk length.
1.4.32 Three-dimensional self-avoiding walks. Run experiments to verifythat the
dead-end probabilityis 0 for a three-dimensional self-avoiding walk and to com
pute the average walklengthforvariousvalues of N.

IA Arrays
1.4.33 Random walkers. Suppose that N random walkers, starting in the center
ofan N-by-Ngrid, move onestep at a time, choosing to goleft, right,up,or down
with equalprobability at each step. Write a programto helpformulate and test a
hypothesisabout the number of stepstakenbeforeallcells are touched.
1.4.34 Bridge hands. In the game of bridge, four players are dealt hands of 13
cardseach.An important statisticisthe distribution of the number of cards in each
suit in a hand.Whichis the most likely, 5-3-3-2,4-4-3-2, or 4-3-3-3?
1.4.35 Birthday problem. Suppose that people enter an empty room untila pair
of people share a birthday. On average, howmany people will have to enterbefore
there isa match? Run experiments to estimate thevalue of this quantity. Assume
birthdays to be uniform random integers between 0 and 364.
1.4.36 Coupon collector. Run experiments to validate the classical mathematical
result that the expected number of coupons needed to collect N values is about
NHN. For example, if you are observing the cards carefully at the blackjack table
(andthe dealer hasenough decks randomly shuffled together), youwill waituntil
about235 cards aredealt, on average, before seeing every cardvalue.
1.4.37 Binomial coefficients. Write aprogram thatbuilds andprintsatwo-dimen
sional ragged array asuch thata[N] [k]containstheprobabilitythatyougetexactly
kheads when you toss acoin Ntimes. Take acommand-line argument tospecifythe
maximum value of N. These numbers areknown asthebinomial distribution: ifyou
multiply each entryin rowiby2N, yougetthebinomial coefficients (thecoefficients
ofxk in (x+l)*) arranged in Pascal's triangle. To compute them,startwitha[N] [0]
= 0forall Nanda[1] [1] = 1,thencompute values insuccessive rows, leftto right,
witha[N][k] = (a[N-l][k] + a[N-l] [k-l])/2.
Pascal's triangle
binomial distribution
l
l
l
l
1/2
1/2
12
1
1/4
1/2
1/4
13
3
1
1/8
3/8
3/8
1/8
14
6
4
1
1/16 1/4
3/8
1/4
1/16
119

Elements of Programming
1.5
Input and Output
In this section weextend the set of simpleabstractions (command-line input and
standard output) that we have been using as the interfacebetween our Java pro
grams and the outside world to include
standard input, standard drawing, and
1.5.1
Generating arandom sequence. .. 122
standard audio. Standard input makes it
1.5.2. Interactive user input....... ,129
convenient for us to write programs that
l33 Averagingastream ofnumbers. . .130
,.
x
r •
.
j
1.5.4
Asimplefilter
134
process arbitrary amounts of input and
l55 Input:t0.drawingfiiter
139
to interact with our programs; standard
L5m6
Bouncing ball
145
drawing makes it possible for us to work
1.5.7
Digital signal processing
150
with graphical representations ofimages,
Programs in this section
freeing us from having to encode every
thing as text; and standard audio adds
sound. Theseextensions areeasyto use,and youwillfind that they bring you to yet
another new world of programming.
The abbreviation I/Ois universally understoodto mean input/output, a col
lective term that refers to the mechanisms by whichprograms communicatewith
the outsideworld. Your computer's operatingsystem controlsthe physical devices
that areconnected to yourcomputer. To implementthe standard I/O abstractions,
we use libraries of methods that interface to the operating system.
You have already been accepting argument values from the command line
andprinting strings in aterminal window; thepurpose ofthissection isto provide
youwith a much richer setof tools for processing and presenting data. Like the
System, out. pri nt() and System,out. pri ntl n() methods that you have been
using, these methods do not implement mathematical functions—their purposeis
to causesome side effect, either on an input deviceor an output device.Our prime
concernisusingsuchdevices to getinformationinto and out of our programs.
An essential feature of standard I/O mechanisms is that there is no limit on
the amount of input or output data, from the point of view of the program. Your
programs can consumeinput or produce output indefinitely.
One use of standard I/O mechanisms is to connect your programs to fileson
your computer's disk. It is easy to connectstandard input, standard output, stan
dard drawing, and standard audio to files. Such connections make it easyto have
your Java programs save or load results to files for archival purposes or for later
reference by other programs or other applications.

1.5 Input and Output
121
Bird's-eye view
Theconventional model thatwe have beenusing forJava pro
gramming has served us since Section 1.1. To build context, we begin by briefly
reviewing the model.
AJava programtakes input values fromthe commandlineand prints a string
of characters as output. Bydefault, both command-line input and standard output
are associated with the application that takes commands (the one in which you
have beentypingthe Java and javac commands). We usethe generic term termi
nalwindow to referto this application. Thismodelhas proven to be a convenient
and directwayfor us to interactwithour programs and data.
Command-line input. This mechanism, which we have been using to provide
input values to our programs, is a standardpart of Java programming. Allclasses
have a mai n() method that takes a Stri ng arrayargs [] asitsargument. That ar
rayisthe sequence of command-line arguments that we type, provided to Java by
the operating system. By convention, both Java and the operating system process
the arguments asstrings, so if we intendfor an argument to be a number, weuse
a method such as Integer.parselnt() or Double.parseDoubleO to convert it
from Stri ngto the appropriatetype.
Standard output. To print output values in our programs, we have been using
thesystem methods System. out. pri ntl n() andSystem. out. pri nt (). Java puts
the results of a program's sequence of callson these methods into the form of an
abstract stream of characters known as standard output. By default, the operating
system connects standardoutput to the terminal window. All of the output in our
programsso farhas been appearingin the terminalwindow.
For reference, and as a starting point, RandomSeq (Program 1.5.1) is a program
that uses thismodel. It takes a command-line argument N andproduces an output
sequence ofN random numbers between 0 and 1.
Nowweare going to complement command-lineinput and standard output with
three additionalmechanisms that address their limitations and provide us with a
farmore useful programming model. These mechanisms give us a newbird's-eye
view ofaJava programin which theprogram converts astandardinput streamand
a sequenceof command-line argumentsinto a standard output stream,a standard
drawing, and a standard audio stream.

122
Elements of Programming
:^;j^^^
m
Program 1.5.J
Generatinga randomsequence
public class RandomSeq
{
public static void main(String[] args)
{
// Print a random sequence of N real values in [0, 1)
int N = Integer.parselnt(args[0]);
for (int i
= 0;
i
< N; i++)
System.out.pri ntln(Math.random());
}
}
This program illustrates the conventional model that we have been using so farforJava pro
gramming. Ittakes acommand-line argumentNandprints Nrandom numbers between 0and
1. From the program's point ofview, there isno limit on the length ofthe output sequence.
% Java RandomSeq 1000000
0.2498362534343327
0.5578468691774513
0.5702167639727175
0.32191774192688727
0.6865902823177537
^lllllSPPI^PSiKllll^SPPwi^PPr^S^^TJ^f^jW^
1
W
Standard input. Our class Stdin is a library that implements a standard input
abstraction to complement the standard output abstraction. Just asyou can print
avalueto standard output at anytime duringthe executionof your program, you
can read avalue from a standard input stream at any time.
Standard drawing. Our class StdDraw allows you to create drawings with your
programs. It uses asimple graphics modelthat allows youto create drawings con
sisting of pointsandlines in awindowon yourcomputer. StdDraw also includes
facilities for text, color, and animation.
Standard audio. Our class StdAudio allows you to createsound with your pro
grams. It usesastandard format to convert arrays of numbers into sound.

7.5 Input and Output
Touseboth command-lineinput and standardoutput, youhavebeen usingbuilt-in
Java facilities. Java alsohas built-in facilities that support abstractionslikestandard
input,standarddraw, andstandardaudio,but theyaresomewhat morecomplicated
to use, so we have developed a simpler interface
to them in our Stdin, StdDraw, and StdAudi o li
braries.Tologically complete our programming
model, we also include a StdOut library. To use
these libraries, download Stdin. Java, StdOut.
Java, StdDraw. Java, and StdAudio. Java and
place them in the same directory as your pro
gram (or use one of the other mechanisms for
sharing libraries described on the booksite).
The standard input and standard output
abstractions date back to the development of
the Unix operating system in the 1970s and are
found in some form on all modern systems. Al
though they are primitive bycomparison to vari
ous mechanisms developed since, modern programmers stilldepend on them asa
reliable way to connectdatato programs. We have developed forthisbookstandard
draw andstandard audio in thesame spirit asthese earlier abstractions to provide
youwith an easy wayto producevisual and auraloutput.
123
standard input [•
command-line
arguments
| standard output
standard audio
standarddrawing
A bird's-eye viewofaJava program (revisited)
Standard output
Java's System,out. print() and System,out. pri ntl n()
methods implement the basic standard output abstraction that we need. Never
theless, to treat standard input and standard output in a uniform manner (and
to provide a few technical improvements), starting in this section and continuing
through the rest ofthe book, we use similar methods that are defined in our StdOut
library. StdOut.print() and StdOut.printlnO are nearly the sameas the Java
methods that you havebeen using (seethe booksitefor a discussion of the differ
ences,whichneed not concernyou now).The StdOut. pri ntf() method is a main
topicof this section and will be of interest to younowbecause it gives you more
control overthe appearance of the output. It wasa featureof the C languageof the
early1970s that stillsurvives in modern languages becauseit is so useful.
Since the firsttime that weprinted double values, wehave been distractedby
excessive precision in the printed output. For example,when we use System. out.
print(Math. PI) we get the output 3.141592653589793, even though we might

124
Elements of Programming
public class StdOut
void
print(St ring s)
prints
void
pri ntl n(String S)
prints, followed bynewline
void
pri ntl n()
printa newline
void
printf(String f,
. . . )
formatted print
APIforourlibrary ofstaticmethods forstandard output
prefer to see 3.14 or 3.14159. The print() andpri ntl n() methodspresent each
number to 15 decimal places evenwhen we would be happy with just a fewdigits
of precision. The printf() method is more flexible: it allows us to specify the
numberof digits andthe precision whenconverting data type values to strings for
output.With pri ntf(), we canwrite StdOut. pri ntf("%7.5f", Math.PI) to get
3.14159, and we can replace System. out. pri nt(t) with
StdOut.printf("The square root of %.lf is %.6f", c, t);
in Newton (Program 1.3.6) to getoutput like
The square root of 2.0 is 1.414214
Next, we describe the meaning and operationof these statements,alongwith ex
tensions to handle the other built-in types of data.
Formatted printing basics. In its simplest form, pri ntf() takes two arguments.
The first argument is aformat string that describes how to convertthe secondar
gumentinto a string for output.The simplest type of format string begins with %
and ends with a one-letter conversion code. The conversion codes that we use most
frequently are d (fordecimal values from Java's integer types), f (for floating-point
values), and s (for String values). Between the %
format
and the conversion code is an integer that specifies
string
numbertoprint
^ ^ ^^ q{^ converted yalue (the number
StdOut. printf("|%BJ1", Math. PI)
of characters in the converted output string). By
/
| N^
default, blanks are added on the left to make the
field width
J^
conversion code j^ Qf ^ conyerted Qutput equal tQ ^ fidd
width; if we want the blanks on the right, we can
Anatomy ofaformatted print statement
insert a minus sign before the field width. (If the

1.5 Input and Output
converted output string is larger than the field width, the field width is ignored.)
Following the width, we have the option of including a period followed by the
number of digits to put afterthe decimal point (the precision) for a doubl e value
or the number of characters to take from the beginning of the string for a St ri ng
value. The most important thing to remember about using printf() is that the
conversion code in theformatand thetypeofthecorrespondingargument mustmatch.
That is, Java must be ableto convert from the type of the argument to the type re
quiredby the conversioncode.Everytype of datacanbe convertedto St ri ng,but
if you write StdOut. pri ntf("%12d", Math.PI) or StdOut. pri ntf("%4.2f",
512), you will get an II1 egal FormatConversionExcepti on run-time error.
Format string. The first argument of pri ntf() is a String that may contain
characters other than a formatstring. Any partofthe argumentthat isnot partofa
format string passes through to the output, with the format stringreplaced by the
argument value (converted to a string asspecified).For example, the statement
StdOut.printf("PI is approximately %.2f\n", Math.PI);
prints the line
PI is approximately 3.14
Note that we need to explicitlyincludethe newlinecharacter \n in the argument in
order to print a new line with pri ntf().
type
code
int
double
String
s
typical
literal
512
sample
formatstrings
"%14d"
"%-14d"
"%14.2f"
1595.1680010754388
"%.7f"
"%14.4e"
"%14s"
"Hello, World"
"%-14s"
"%-14.5s"
Formatconventionsfor pri ntf() (seethebooksitefor manyotheroptions)
converted string
valuesfor output
512"
'512
1595.17"
"1595.1680011"
1.5952e+03"
"
Hello, World"
"Hello, World
"
"Hello
125

126
Elements of Programming
Multiple arguments. Thepri ntf() function cantakemorethan twoarguments.
In this case, the format string willhavea format specifierfor each additional argu
ment, perhaps separated by other characters to pass through to the output. For
example,if you were making payments on a loan, you might use code whose inner
loop contains the statements
String formats = "%3s
$%6.2f
$%7.2f
$%5.2f\n";
StdOut.printf(formats, month[i], pay, balance, interest);
to print the secondand subsequentlinesin a tablelikethis (seeExercise 1.5.14):
payment
balance
interest
Dan
$299.00
$9742.67
$41.67
Feb
$299.00
$9484.26
$40.59
Mar
$299.00
$9224.78
$39.52
Formatted printing is convenientbecause this sort of code is much more compact
than the string-concatenation codethat wehavebeen using.
Standard input
Our Stdin librarytakesdata from a standard inputstream that
maybe empty or maycontain a sequence ofvaluesseparatedbywhitespace (spaces,
tabs, newline characters, and the like). Each value is a Stri ng or a value from one of
Java's primitive types. One of the keyfeatures of the standard input stream is that
your program consumes values when it reads them. Once your program has read
a value, it cannot back up and read it again. This assumption is restrictive,but it
reflects physical characteristics of someinput devices and simplifies implementing
the abstraction. The library consistsof the nine methods: i sEmptyO, readlnt(),
readDoubleO, readLongO, readBooleanO, readCharO, readStringO, read-
Line(), and readAl1() . Within the input stream model, these methods are large
ly self-documenting (the names describetheir effect),but their precise operation is
worthy of careful consideration, so wewillconsider severalexamplesin detail.
Typing input. When you use the Java command to invokea Javaprogram from
the command line, you actuallyare doing three things: issuing a command to start
executing your program, specifying the values of the command line arguments,
and beginning to define the standard input stream. The string of characters that
you type in the terminal window after the command line is the standard input
stream. When you type characters, you are interacting with your program. The

1.5 Input and Output
127
public class Stdin
bool ean
i sEmpty()
true ifnomore values, fal se otherwise
i nt
readlnt ()
read a value oftype i nt
doubl e
readDoubl e()
read a value oftype double
1ong
read Long ()
read a value oftype long
bool ean
readBool ean ()
read a value oftype bool ean
char
readChar ()
read a value oftype char
Stri ng
readStri ng()
read a value oftype Stri ng
St ri ng
readLi ne()
read the rest ofthe line
Stri ng
readAl 1()
read the rest ofthe text
APIfor ourlibraryofstaticmethods for standardinput
program waits for you to create the standardinput stream. Forexample, consider
the following program, which takes a command-line argument Ny then reads N
numbers from standard input and adds them:
public class Addlnts
{
public static void main(String[] args)
{
int N = Integer.parselnt(args[0]);
int sum = 0;
for (int i
= 0;
i
< N; i++)
{
int value = Stdin.readlnt();
sum += value;
}
StdOut.println("Sum is " + sum);
}
}
When you type j ava Addlnts 4, afterthe programtakesthe command-line argu
ment, it calls the method Stdin. readlnt() and waits for you to type an integer.
Suppose that you want 144 to be the first value.As you type 1, then 4, and then 4,
nothing happens, because Stdin does not know that you are done typing the in
teger. But when you then type <return> to signify the end of your integer,Stdin.
readlnt() immediately returns the value 144, which your program adds to sum

128
Elements of Programming
and then calls Stdin. readlnt() again. Again, nothing happens until you type the
second value:if you type 2,then 3,then 3,and then <return> to end the number,
Stdin. readlnt () returns the value 233,which your program again adds to sum.
Afteryou havetyped four numbers in this way, Addlnts expects no more input and
prints out the sum, as desired.
Input format. If you type abc or 12.2 or true when
Stdin. readlnt() is expecting an int, it will respond
with a NumberFormatException. The format for each
type is the same as you have been using for literal val
ues within Javaprograms. For convenience, Stdin treats
strings of consecutive whitespace charactersas identical
to one space and allows you to delimit your numbers
with such strings. It does not matter how many spaces
you put between numbers, or whether you enter num
bers on one line or separate them with tab characters
or spread them out over severallines, (except that your
terminal application processesstandard input one line at a time, so it willwait un
til you type <return> before sending all of the numbers on that line to standard
input). Youcan mix values of different types in an input stream, but whenever the
program expects a value of a particular type, the input stream must have a value
of that type.
Interactive user input. TwentyQuestions (Program 1.5.2) is a simple example
of a program that interacts with its user.The program generates a random integer
and then gives cluesto a user trying to guessthe number. (Asa side note: by using
binary search, you can always get to the answer in at most twenty questions. See
Section 4.2.) The fundamental difference between this program and others that
we havewritten is that the user has the abilityto change the control flowwhile the
program is executing. This capability was very important in early applications of
computing, but we rarely write such programs nowadays because modern applica
tions typically take such input through the graphical user interface, as discussed
in Chapter 3. Even a simple program like TwentyQuestions illustrates that writ
ing programs that support user interaction is potentially very difficult because you
have to plan for all possible user inputs.
command line
\
command-line
argument
% Java Addlnts 4
144
233
377
1024
standard inputstream
Sum is 1778
\
standard outputstream
Anatomy ofa command

7.5 Input and Output
129
m
1
m
Is
m
•^y^jy^^
Program 1.5.2
Interactive user input
public class TwentyQuestions
{
public static void main(String[]
args)
{
// Generate a number and answer questions
// while the user tries to guess the value,
int N = 1 + (int) (Math.random() * 1000000);
StdOut.print("Ifm thinking of a number ");
StdOut.println("between 1 and 1,000,000");
int m = 0;
while
(m != N)
{
// Solicit one guess and provide one answer
StdOut.print("What's your guess? ");
m = Stdin.readlnt();
if (m == N) StdOut.println("You win!");
if (m < N)
StdOut.println("Too low ");
if (m > N)
StdOut.println("Too high");
}
}
}
hidden value
user's guess
This program plays a simple guessing game. You type numbers, each of which is an implicit
question ("Is this the number?") andthe program tells you whether your guess is too high or
too low. You can always getit to print You wi n! with less than twenty questions. To use this
program, you need tofirst download Stdin .Java andStdOut.Java into the same directory
as thiscode (which is in afile named TwentyQuesti ons. javaj.
% Java TwentyQuestions
I'm thinking of a number between 1 and 1,000,000
What's your guess? 500000
Too high
What's your guess? 250000
Too low
What's your guess? 375000
Too high
What's your guess? 312500
Too high
What's your guess? 300500
Too low
I
w^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

130
Elements of Programming
Ws
M
^^^^^&2^
vMMM^,
Program 1.5.3
Averaging a stream of numbers
public class Average
{
public static void main(String[] args)
{
// Average the numbers on the input stream.
double sum =0.0;
int cnt = 0;
while (!Stdin.isEmptyO)
{
// Read a number and cumulate the sum.
double value = Stdin. readDoubleO;
sum += value;
cnt++;
}
double average = sum /
cnt;
StdOut.println("Average is " + average);
}
}
cnt
sum
countof numbers read
cumulated sum
This program reads ina sequence ofreal numbersfrom standard inputandprintstheir average
onstandard output (provided thatthe sumdoes notoverflow). From itspoint of view, there is
no limiton thesizeof theinputstream. The commands on theright below useredirection and
piping(discussed in thenextsubsection) toprovide 100,000 numbers toaverage.
% java RandomSeq 100000 > data.txt
H
% Java Average < data.txt
Average is 0.5010473676174824
% Java Average
10.0
5.0 6.0
3.0
7.0
32.0
<ctrl-d>
Average is 10.5
?^*i?r™?^PPIP
1
% Java RandomSeq 100000 | Java Average
Average is 0.5000499417963857
jw!
W^^^^^-^^W^^^^^^^^^^^^^^^'
Processing an arbitrary-size input stream. Typically, input streams are finite:
your program marches through the input stream, consuming values until the
stream isempty.But there isno restriction of the sizeof the input stream, and some
programs simply process all the input presented to them. Average (Program 1.5.3)
is an example that reads in a sequence of real numbers from standard input and
prints their average. It illustrates akeyproperty of usingan input stream:the length

1.5 Input and Output
131
of the stream is not known to the program.We type allthe numbers that wehave,
and then the program averages them. Before reading each number, the program
uses the method Stdin. i sEmpty() to checkwhether there are any more numbers
in the input stream.Howdo wesignal that wehave no more data to type? Bycon
vention, wetypeaspecial sequence ofcharacters known astheend-of-file sequence.
Unfortunately, the terminal applications that we typically encounter on modern
operatingsystems use different conventions for this critically important sequence.
In this book, we use <ctrl -d> (manysystems require<ctrl -d> to be on a line by
itself); the other widelyused convention is <ctrl -z> on a line by itself. Average
is a simpleprogram,but it represents a profound newcapability in programming:
with standard input, we can write programsthat process an unlimited amount of
data.Asyou willsee,writing such programsisan effective approach for numerous
data-processing applications.
Standard input is a substantial step up from the command-line input model that
wehave been using,for tworeasons, asillustrated byTwentyQuesti ons and Aver
age. First, we can interact with our program—with command-line arguments, we
can only provide data to the program before it begins execution. Second,we can
readin largeamounts of data—with command-line arguments, wecan only enter
valuesthat fit on the command line. Indeed, as illustrated by Average, the amount
of datacanbe potentially unlimited, and manyprograms aremadesimplerbythat
assumption.A third raison d'etre for standard input is that your operating system
makes it possible to change the source ofstandardinput,sothat youdo not have to
typeallthe input. Next, weconsider the mechanisms that enable this possibility.
Redirection and piping
For many applications, typing input data as a stan
dard input streamfrom the terminalwindow is untenable because our program's
processing power isthen limitedbythe amountof datathat wecantype (and our
typingspeed). Similarly, weoftenwanttosave theinformation printedon thestan
dard output streamforlateruse. To address such limitations, wenextfocus on the
ideathat standardinput is an abstraction—the programjust expects its input and
has no dependence on the source of the input stream. Standardoutput is a similar
abstraction. The powerof theseabstractions derives from our ability(through the
operating system) to specifyvarious othersources forstandard input andstandard
output, such as a file, the network,or another program.Allmodern operating sys
tems implement these mechanisms.

132
Elements of Programming
Redirecting standard output to afile. By adding a simple directive to the com
mandthat invokes aprogram,wecanredirectitsstandardoutput to a file, eitherfor
permanentstorage or for input to anotherprogramat a latertime.Forexample,
% Java RandomSeq 1000 > data.txt
specifies that the standard output stream is not to be printed in the terminal win
dow, but instead is to be written to a text file named data. txt. Each call to Sys
tem.out. pri nt () or System. out. pri ntl n() appends text at the end of that file.
In this example, the end result is a file that contains 1,000random values. No out
put appears in the terminal window: it goesdirectly into the filenamed after the >
symbol.Thus, wecan saveawayinformation for later retrieval.Note that wedo not
haveto changeRandomSeq (Program 1.5.1) in anyway
for this mechanismto work—it is using the standard
output abstraction and is unaffected by our use of a
different implementation of that abstraction. Youcan
use this mechanism to save output from any program
that you write. Once we have expended a significant
amount of effort to obtain a result, we often want to
save the resultfor later reference. In a modern system,
you can save some information by using cut-and-paste or some similar mecha
nism that is providedby the operatingsystem, but cut-and-paste is inconvenient
for large amounts of data.By contrast, redirection is specifically designed to make
it easyto handle large amounts of data.
Redirecting from a file to standard input. Similarly, we can redirect standard
input so that Stdin readsdata from a file insteadof the terminal application:
% Java Average < data.txt
Thiscommand reads a sequence ofnumbers fromthe file data. txt andcomputes
their average value. Specifically, the <symbol isa directive that tells the operating
system to implement the standard input stream
.
. ^
^ ^
/
r
t
r
java Average < data.txt
by reading from the text file data. txt instead of
waiting for the user to type something into the
terminal window. When the program calls St
din . readDoubl e(), the operating system reads
the value from the file. The file data. txt could
Java RandomSeq 1000 > data.txt
RandomSeq
is standard output
data.txt
Redirecting standard outputtoafile
data.txt
standard inputOl
Average
Redirectingfrom afile tostandard input

1.5 Input and Output
havebeen createdby any application,not just a Java program—virtuallyeveryap
plication on yourcomputercancreate textfiles. This facility to redirect froma file
to standard input enables us to create data-driven code where we can change the
dataprocessed bya program withouthaving to change theprogram at all. Instead,
wekeepdata in files and write programsthat readfrom standard input.
Connecting twoprograms. The most flexible way to implementthe standard in
put and standard output abstractions is to specify that they are implemented by
our own programs! This mechanismiscalledpiping. Forexample, the command
% Java RandomSeq 1000 | Java Average
specifies that the standard output for RandomSeq and the standard input stream for
Average are the samestream. The effect is as if RandomSeq were typing the num
bers it generates into the terminal windowwhileAverage is running. This example
also has the same effectas the followingsequence of commands:
% Java RandomSeq 1000 > data.txt
% Java Average < data.txt
In this case, the file data. txt is not created. This difference is profound, because
it removes another limitation on the size of the input and output streams that we
can process.For example,we could replace1000in our examplewith 1000000000,
even though we might not have the
space to save abillion numbers on our
java *™d™s*<* 100° I Java Avera9e
computer (we do need the timeto pro
cess them, however). When RandomSeq
calls System.out.println(), a string
is added to the end of the stream; when
Average
calls
Stdin.readlnt(),
a
string is removed from the beginning
of the stream. The timing of precisely
what happens is up to the operating
system: it might run RandomSeq until it produces some output, and then run Av
erage to consume that output, or it might run Average until it needs some output,
and then run RandomSeq until it producesthe needed output. The end result is the
same,but our programs are freed from worryingabout such detailsbecause they
work solelywith the standard input and standard output abstractions.
RandomSeq
U
standard output —•
standard input
133
DL
Average
Piping the output ofoneprogram tothe input ofanother

134
Elements of Programming
m
fi
Program 1.5.4
A simplefilter
public class RangeFilter
{
public static void main(String[] args)
{
// Filter out numbers not between lo and hi.
int lo = Integer.parselnt(args[0]);
int hi = Integer.parselnt(args[l]);
while (!Stdin.isEmptyO)
{
// Process one number,
int t
= Stdin.readlnt();
if (t >= lo && t
<= hi) StdOut.print(t + " ");
}
StdOut.printlnO;
}
}
lo
hi
t
lower bound ofrange
upper boundof range
current number
W^^^^^x
This filter copies to the output stream the numbers from the input stream that fall inside the
range given by the command-line parameters. There isnolimit on the length ofthe streams.
% Java RangeFilter 100 400
358
1330 55 165
689
1014 3066
387
575 843
203 48
292
877 65
998
<ctrl-d>
358 165
387
203
292
^^p^^^^^Ps^P^^^W^^^^S^^^^^^^^^^^^^^
IWWJ^
Filters. Piping, a core feature ofthe original Unix system of theearly 1970s, still
survives in modern systems because it is a simple abstraction for communicating
amongdisparate programs. Testimonyto the power ofthisabstractionisthat many
Unixprograms are stillbeing used today to processfiles that are thousands or mil
lionsof timeslargerthan imaginedbythe programs'authors.Wecan communicate
with other Java programs via calls on methods, but standard input and standard
output allowus to communicatewith programs that werewritten at another time
and, perhaps, in another language. Withstandardinput and standard output, we
are agreeing on a simple interface to the outside world. For many common tasks,
it is convenientto think of eachprogram as afilter that convertsa standard input
stream to a standard output stream in some way, with piping as the command

\
1.5 Input and Output
135
mechanism to connect programs together. For example, RangeFilter (Program
1.5.4) takes two command-line arguments and prints on standard output those
numbers from standard input that fallwithin the specifiedrange.Youmight imag
ine standard input to be measurement data from some instrument, with the filter
being used to throw awaydata outside the range of interest for the experiment at
hand. Several standard filters that were designed for Unix still survive (sometimes
with different names) as commands in modern operating systems. For example,
the sort filter puts the lines on standard input in sorted order:
% Java RandomSeq 6 | sort
0.035813305516568916
0.14306638757584322
0.348292877655532103
0.5761644592016527
0.7234592733392126
0.9795908813988247
We discuss sorting in Section 4.2. A second useful filter is grep, which prints the
lines from standard input that match a givenpattern. For example, if you type
% grep lo < RangeFilter.Java
you get the result
// Filter out numbers not between lo and hi.
int lo = Integer.parselnt(args[0]);
if (t >= lo && t
<= hi) StdOut.print(t + " ")",
Programmers often use tools such as grep to get a quick reminder of variable
names or language usagedetails.Athird usefulfilteris more,which reads data from
standard input and displaysit in your terminal window one screenful at a time. For
example, if you type
% Java RandomSeq 1000 | more
you will see as many numbers as fit in your terminal window, but more will wait
for you to hit the space bar before displaying each succeeding screenful. The term
filter is perhaps misleading: it was meant to describe programs like RangeFilter
that write some subsequence of standard input to standard output, but it is now
often used to describe any program that reads from standard input and writes to
standard output.

136
Elements of Programming
Multiple streams. Formany common tasks, we wantto writeprograms that take
input frommultiplesources and/or produceoutput intendedfor multipledestina
tions. In Section 3.1 we discuss our Out and In libraries,which generalize StdOut
and Stdin to allowfor multiple input and output streams. Theselibraries include
provisions not just for redirecting these streams to and from files, but also from
arbitrary web pages.
Processing large amounts of information plays an essential role in many applica
tions of computing. A scientistmayneed to analyze data collectedfrom a seriesof
experiments,a stock trader maywishto analyzeinformation about recent financial
transactions, or a student may wish to maintain collections of music and mov
ies.In these and countlessother applications, data-driven programs are the norm.
Standard output, standard input, redirection, and piping provides us with the ca
pability to address such applicationswith our Java programs. Wecan collect data
into files on our computer through the webor any of the standard devices and use
redirection and piping to connect data to our programs. Many (if not most) of the
programming examplesthat we consider throughout this book have this ability.
Standard drawing
Up to this point, our input/output abstractions have fo
cusedexclusively on text strings. Nowwe introduce an abstraction for producing
drawings as output. Thislibraryiseasy to useand allows us to takeadvantage of a
visual medium to cope with far more information than is possiblewith just text.
Aswith standard input, our standard drawing abstraction is implemented in
a library that you need to download from the booksite, StdDraw. Java. Standard
drawing isvery simple:we imaginean abstract drawing devicecapableof drawing
lines and points on a two-dimensional canvas. The deviceis capable of responding
to the commands that our programs issue in the form of calls to methods in Std
Draw such as the following:
public class StdDraw (basic drawing commands)
void
line(double xO, double yO,
double xl, double yl)
void
point(double x, double y)
Like the methods for standard input and standard output, thesemethods arenearly
self-documenting: StdDraw.line() draws a straightline segmentconnectingthe

1.5 Input and Output
(w0)
1
(0,0)X *
StdDraw.line(xO, yO, xl, yl);
(i,D
.. „/
point (xQy y0) with the point {xv yx) whose coor
dinates are given as arguments. StdDraw. poi nt()
draws a spot centered on the point (x,y) whose co
ordinatesaregivenasarguments.The default scale
is the unit square (all coordinates between 0 and
1).The standard implementation displaysthe can
vas in a window on your computer's screen, with
black lines and points on a white background.
The window includes a menu option to save your
drawing to a file, in a format suitable for publish
ing on paper or on the web.
Yourfirstdrawing. The Hel 1oWorl d equivalent for graphics programming with
StdDraw is to draw a triangle with a point inside. To form the triangle, we draw
three lines: one from the point (0, 0) at the lower left corner to the point (1, 0),
one from that point to the third point at (1/2,
V3/2), and one from that point backto (0,0).
Asa finalflourish, we draw a spot in the mid
dle of the triangle. Once you have success
fully downloaded StdDraw. Java and then
compiled and run Tri angl e, you are off and
running to write your own programs that
draw figures comprised of lines and points.
This ability literally adds a new dimension to
the output that you can produce.
When you use a computer to create
drawings, you get immediate feedback (the
drawing) so that you can refine and improve
your program quickly. With a computer pro
gram, you can create drawings that you could
not contemplate making by hand. In particu
lar, instead of viewing our data as just num
bers, we can use pictures, which are far more
expressive. We will consider other graphics
examples after we discuss a few other draw
ing commands.
class Triangle
137
public
{
public static void main(String[] args)
{
double t = Math.sqrt(3.0)/2.0;
StdDraw.line(0.0,
0.0, 1.0, 0.0)
StdDraw.line(1.0,
0.0, 0.5,
t)
StdDraw.line(0.5,
t, 0.0, 0.0)
StdDraw.point(0.5, t/3.0);
}
-^^w^ww^^w^^^^^^ww^^
Yourfirstdrawing

138
Elements of Programming
Control commands. The default coordinate system for standard drawing is the
unit square, but we often want to draw plots at different scales. For example, a
typical situation is to use coordinates in some range for the x-coordinate, or the
/-coordinate, or both. Also,we often want to draw lines of different thickness and
points of different size from the standard. To accommodate these needs, StdDraw
has the following methods:
public class StdDraw (basiccontrol commands)
void
setXscale(double xO, double xl)
resetx range to (x0JXj)
void
setYscale(double yO, double yl)
resety range to (y0,yJ
void
setPenRadi us (double r)
setpen radius to r
Note: Methods withthesamenames butnoarguments reset todefault values.
For example, when we issue the command StdDraw. setXscal e (0, N),we are tell
ing the drawing device that wewillbe usingx-coordinatesbetween 0 and N. Note
that the two-call sequence
StdDraw.setXscale(x0, xl);
StdDraw.setYscale(yO,
yl);
sets the drawing coordinates to be within a bound
ing box whose lower left corner is at (x0, y0) and
whose upper right corner is at (xv yj. If you use
integer coordinates, Java casts them to double, as
expected. Scalingis the simplest of the transforma
tions commonly used in graphics. In the applica
tions that we consider in this chapter,we use it in a
straightforward way to match our drawings to our
data.
The pen is circular, so that lines have rounded
ends, and when you set the pen radius to r and draw
a point, you get a circleof radius r.The default pen
radius is .002and isnot affectedby coordinate scal
ing. This default is about 1/500the width of the de
fault window,sothat ifyou draw200points equally
spaced along a horizontal or vertical line, you will
int N = 50;
StdDraw.setXscale(0, N);
StdDraw.setYscale(0,
N);
for (int i =0;
i <= N;
StdDraw.line(0,
N-i,
(0,0)
i, 0);
(N,N)
Scalingto integer coordinates

7.5 Input and Output
139
m
m
1
h
Program 1.5.5
Input-to-drawingfilter
public class PlotFilter
{
public static void main(String[] args)
{
// Plot points in standard input.
// Scale as per first four values.
double xO = Stdin. readDoubleO;
double yO = Stdin. readDoubleO;
double xl = Stdin. readDoubleO ;
double yl = Stdin.readDoubleO;
StdDraw.setXscale(xO, xl);
StdDraw.setYscale(yO, yl);
// Read and plot the rest of the points,
while (!Stdin.isEmptyO)
{
// Read and plot a point.
double x = Stdin. readDoubleO;
double y = Stdin.readDoubleO;
StdDraw.point(x, y);
xO
yo
xl
yi
x,
y
leftbound
bottom bound
rightbound
topbound
currentpoint
Somedata is inherently visual Thefile USA. txt on thebooksite has thecoordinates of the US
cities withpopulations over 500 (byconvention, thefirstfour numbers aretheminimum and
maximumx andy values).
™» %java pl0tF1lter <USA.txt
§M*&M
if' '
•
'**•'. '•/• • •.' •
'•'•"'.''••'.;-.v,->li
^s^^^P^^^^^^^^^p^w^^^^^
IK^SWi^^^N^^^^^^^^^i^^^S^^^WP'^l^

140
Elements of Programming
be ableto seeindividual circles, but ifyou draw 250such points, the result willlook
like a line. When you issue the command StdDraw.setPenRadius(.01), you are
saying that you want the thickness of the lines and the size of the points to be five
times the .002 standard.
Filtering data to a standard drawing. Oneof the simplest applications of stan
dard draw is to plot data, by filteringit from standard input to the drawing. PIot-
Fi1ter (Program 1.5.5)is such a filter: it reads a sequence of points defined by (x,
y) coordinates and draws a spot at each point. It adopts the convention that the
first four numbers on standard input specifythe bounding box, so that it can scale
the plot without having to make an extra pass through all the points to determine
the scale (this kind of convention is typical with such data files). The graphical
representation of points plotted in this way is far more expressive (and far more
compact) than the numbers themselvesor anything that we could create with the
standard output representation that our programs have been limited to until now.
The plotted image that is produced by Program 1.5.5makes it far easier for us to
infer properties of the cities (such as,for example, clustering ofpopulation centers)
than does a list of the coordinates. Whenever we are processing data that represents
the physical world, a visual image is likelyto be one of the most meaningful ways
that we can use to display output. PlotFilter illustrates just how easily you can
create such an image.
Plotting a junction graph. Another importantuseof StdDraw is to plot experi
mental data or the values of a mathematical function. For example, suppose that
wewant to plot values of the function y - sin(4x) + sin(20x) in the interval [0,it] .
Accomplishingthis task is a prototypical example oi sampling, there are an infinite
number ofpoints in the interval, sowehaveto make do with evaluating the function
at a finite number of points within the interval. We sample the function by choos
ing a set of x-values, then computing y-values by evaluating the function at each
x-value. Plotting the function by connecting successivepoints with lines produces
what is known as a piecewise linear approximation. The simplest way to proceed is
to regularly spacethe x values:wedecide ahead of time on a sample size,then space
the x-coordinates by the interval sizedivided by the sample size.To make sure that
the values we plot fall in the visiblecanvas,we scalethe x-axis corresponding to the
interval and the y-axis corresponding to the maximum and minimum values ofthe
function within the interval. The smoothness of the curve depends on properties

1.5 Input and Output
141
of the function and the size of the sample.
If the sample size is too small, the rendition
of the function may not be at all accurate
(it might not be very smooth, and it might
miss major fluctuations); if the sample is
too large, producing the plot may be time-
consuming, since some functions are time-
consuming to compute. (In Section 2.4, we
willlook at a method for plotting a smooth
curve without using an excessive number of
points.) Youcan use this same technique to
plot the function graph of anyfunction you
choose: decide on an x-interval where you
want to plot the function, compute function
values evenly spaced through that interval
and store them in an array, determine and
set the y-scale, and draw the line segments.
double[]
x = new double[N+l];
doubled y = new double [N+l];
for (int i =0; i
<= N; i++)
x[i] = Math.PI * i
/
N;
for (int i = 0;
i
<= N; i++)
y[i] = Math.sin(4*x[i]) + Math.sin(20*x[i]);
StdDraw.setXscale(0, Math.PI);
StdDraw.setYscale(-2.0, 2.0);
for (int i = 1;
i
<= N; i++)
StdDraw.line(x[i-l], y[i-l], x[i], y[i]);
N=20
N=200
Plotting afunction graph
Outline andfilled shapes. StdDraw also includes methods to draw circles, rect
angles, and arbitrary polygons. Each shape defines an outline. When the method
name is just the shape name, that outline is traced by the drawing pen. When the
name begins with f i 11ed, the named shape is instead filled solid, not traced. As
usual, we summarize the available methods in an API:
public class StdDraw (shapes)
void
circle(double x, double y, double r)
void
filledCircle(double x, double y, double r)
void
square(double x, double y, double r)
void
filledSquare(double x, double y, double r)
void
polygon (doubled x, doubled
y)
void
filledPolygon(doubled
x, doubled
y)
The arguments for ci rcl e() and f i 11edCi rcl e() define a circle of radius r cen
tered at (x,y); the arguments for square() and filledSquareO define a square

142
Elements of Programming
of sidelength 2r centeredon (x,y);and the arguments for polygon() and f i 11 ed-
PolygonO define a sequence of points that we connect by lines, including one
from the last point to the first point. If you want to define
shapes other than squares or circles,use one of these meth
ods. For example,
doubled
xd = { x-r, x,
x+r,
x };
doubled
yd = { y,
y+r, y, y-r };
StdDraw.polygon(xd, yd);
plots a diamond (a rotated 2r-by-2r square) centered on
the point (x>y).
StdDraw.circle(x, y,
r);
Textandcolor. Occasionally, youmaywishto annotateor
highlight various elements in your drawings. StdDraw has
a method for drawing text, another for setting parameters
associated with text, and another for changing the color
of the ink in the pen. We make scant use of these features
in this book, but they can be very useful, particularly for
drawingson your computer screen.Youwillfind many ex
amples of their use on the booksite.
public class StdDraw (text and colorcommands)
void
text(double x, double y, String s)
void
setFont(Font f)
void
setPenColor(Color c)
StdDraw.square(x,
doubled
x =
doubled
y =
StdDraw.polygon(x,
In this code, Font and Color are non-primitive types that
you will learn about in Section 3.1. Until then, we leave
the details to StdDraw. The available pen colors are BLACK,
BLUE, CYAN, DARK_GRAY, GRAY, GREEN, LIGHT_GRAY, MA
GENTA, ORANGE, PINK, RED, WHITE, and YELLOW, defined as
constants within StdDraw.For example, the call StdDraw.
setPenCol or(StdDraw. GRAY) changes to gray ink. The
default ink color is BLACK. The default font in StdDraw suffices for most of the
drawings that you need (and you can find information on using other fonts on

7.5 Input and Output
StdDraw.square(.2,
.8,
.1)
StdDraw.fi11edSquare(.8,
.8,
StdDraw.circle(.8,
.2,
.2)
double[]
xd = {
.1,
.2,
.3
doubled
yd = { .2,
.3,
.2
StdDraw.fi11edPolygon(xd,
yd);
StdDraw.text(.2,
.5, "black text")
StdDraw.setPenColor(StdDraw.WHITE)
StdDraw.text(.8,
.8, "white text")
143
.2);
.2 };
.1 };
the booksite). For example, you might wish to use
these methods to annotate function plots to high
light relevantvalues,and you might find it usefulto
develop similar methods to annotate other parts of
your drawings.
Shapes, color, and text are basic tools that you
can use to produce a dizzying variety of images,
but you should use them sparingly. Useof such ar
tifacts usually presents a design challenge, and our
StdDraw commands are crude by the standards of
modern graphics libraries, so that you are likely to
need an extensive number of calls to them to pro
duce the beautiful imagesthat you mayimagine. On
the other hand, using color or labelsto helpfocuson
important information in drawings is often worth
while,as is using color to represent data values.
Animation. The StdDraw library supplies addi
tional methods that provide limitless opportunities
for creating interesting effects.
Shape and textexamples
public class StdDraw (advanced controlcommands)
void
setCanvasSize(int w, int h)
void
clear()
void
clear(Color c)
void
show(int dt)
void
show()
create canvas in screen windowof
width from wandheight h (inpixels)
clear thecanvas towhite (default)
clear the canvas; color it c
draw, then pausedt milliseconds
draw, turn offpausemode
The default canvas size is 512-by-512 pixels; if you want to change it, call set-
CanvasSi ze() before any drawing commands. The cl ear() and show() methods
support dynamic changes in the images on the computer screen. Such effects can
provide compelling visualizations.Wegive an examplenext that also works for the
printed page. There are more examples in the booksite that are likely to capture
your imagination.

144
Elements of Programming
Bouncing ball. The Hel1oWorl d of animation isto produce a black ballthat ap
pears tomove around onthe canvas. Suppose that the ball is atposition (rx, ry) and
wewant to createthe impression of moving it to a new position nearby,such as,for
example, (rx + .01,r + .02).Wedo so in two steps:
• Erase the drawing.
• Draw a black ball at the new position.
To create the illusion of movement, we iterate these steps for a whole sequence of
positions (one that will form a straight line, in this case). But these two steps do
not suffice, becausethe computer is so quick at drawing that the image of the ball
will rapidly flicker between black and white instead of creating an animated im
age. Accordingly, StdDraw has a show() method that allows us to control when the
resultsof drawing actions are actually shown on the display. You can think of it as
collecting all of the lines,points, shapes, and text that we tell it to draw,and then
immediatelydrawingthem allwhenweissuethe show() command. Tocontrol the
apparent speed, show() takes an argument dt that tells StdDraw to wait dt mil
liseconds after doing the drawing. Bydefault, StdDrawissues a show() after each
line(), point(), or other drawing command; we turn that option off when we
call StdDraw. show(t) and turn it back on when we call StdDraw. show() with no
arguments. With these commands, we can create the illusion of motion with the
following steps:
• Erase the drawing (but do not show the result).
• Draw a black ball at the new position.
• Show the result of both commands, and wait for a brief time.
BouncingBall (Program 1.5.6) implements these steps to create the illusion of a
ball moving in the 2-by-2 box centered on the origin. The current position of the
ball is(rx, r ),andwe compute thenew position ateach step byadding vxtorxand vy
to r . Since (vx> v) is the fixeddistancethat the ball movesin each time unit, it rep
resentsthe velocity. Tokeepthe ballin the drawing,wesimulate the effectof the ball
bouncing off the walls accordingto the laws of elasticcollision. This effectis easy
to implement: when the ball hits a vertical wall, we just change the velocity in the
x-direction from vx to -vx, and when the ball hits a horizontal wall,we change the
velocity inthey-direction from vy to-vy. Ofcourse, you have todownload thecode
from the booksite and run it on your computer to see motion. To make the image
clearer on the printed page, we modified BouncingBal1 to use a gray background
that also shows the track of the ball as it moves (see Exercise 1.5.34).

1.5 Input and Output
145
!i
public class BouncingBall
{
public static void main (Stri ng[]
{
// Simulate the movement of a
StdDraw.setXscale(-1.0, 1.0);
StdDraw.setYscale(-1.0, 1.0);
double rx = .480,
ry = .860;
double vx = .015, vy = .023;
double radius = .05;
while(true)
{
// Update ball position
if (Math.abs(rx + vx) +
if (Math.abs(ry + vy) +
rx
=
rx
+
vx;
ry
=
ry + vy;
StdDraw.clear();
StdDraw.fi11edCi rcle(rx,
ry,
radius);
StdDraw.show(20);
args)
bouncing ball
}
}
and draw
radius
>
radius
>
it there.
1.0)
1.0)
vx
=
-vx;
vy
= -vy;
position
velocity
wait time
ball radius
This program simulates the movement ofa bouncing ball in the box with coordinates between
-1 and +1. The ball bounces offthe boundary according to the laws of elastic collision. The
20-millisecond waitfor StdDraw. show() keeps the black image of the ball persistent on the
screen, even though most of the baIVs pixels alternate between black and white. Ifyou modify
this code to take the wait time dt asa command-line argument, you can control the speed of
the ball The images below, which show the track ofthe ball, areproduced bya modified version
of thiscode(seeExercise 1.5.34).
W

146
Elements of Programming
Standard drawingcompletes our programming modelby adding a "picture is worth
a thousand words"component. It isa natural abstraction that you can use to better
open up your programs to the outside world.With it, you can easilyproduce the
function plots and visualrepresentationsof data that are commonly used in science
and engineering.Wewillput it to such usesfrequently throughout this book. Any
time that you spend now workingwith the sample programs on the last fewpages
willbe wellworth the investment.You can find many usefulexampleson the book-
site and in the exercises, and you are certain to find some outlet for your creativity
byusingStdDraw to meetvariouschallenges. Canyou drawan AT-pointed star?Can
you make our bouncing ball actually bounce (add gravity)? You may be surprised
at how easilyyou can accomplishthese and other tasks.
public class StdDraw
void
line(double xO,
double yO,
double xl, double yl)
void
point(double x, double y)
void
text(double x, double y, String s)
void
circle(double x, double y, double r)
void
filledCircle(double x, double y, double r)
void
square(double x, double y, double r)
void
filledSquare(double x, double y, double r)
void
pol ygon (doublet] x, doubled
y)
void
fi 11 edPol ygon (doubled x, doubled
y)
void
setXscale(double xO,
double xl)
resetxrange to(x0,x})
void
setYscale(double yO,
double yl)
resety range to(y0,yJ
void
setPenRadius(double r)
setpen radius to r
void
setPenColor(Color c)
setpencolor to c
void
setFont(Font f)
set textfont tof
void
setCanvasSize(int w, int h)
setcanvas tow-by-h window
void
clear (Col or c)
clearthecanvas; colorit c
voi d
show(i nt dt)
showall; pausedt milliseconds
void
save(String filename)
savetoa .jpgorw.pngfile
Note:Methods with thesamenames butnoarguments reset todefaultvalues.
APIfor ourlibrary ofstaticmethodsfor standard drawing

1.5 Input and Output
Asa final example of a basicabstraction for output, we consid
er StdAudio, a library that you can use to play, manipulate, and synthesize sound
files. You probablyhave usedyour computerto process music. Nowyou can write
programs to do so.At the same time, you willlearn some conceptsbehind a ven
erable and important area of computer science and scientific computing: digital
signalprocessing. We willonlyscratch the surface ofthisfascinating subject, but you
maybe surprised at the simplicity of the underlying concepts.
Concert A. Sound is the perception of the vibration of molecules, in particular,
the vibration of our eardrums.Therefore, oscillation is the keyto understanding
sound. Perhaps the simplest placeto start is to consider the musical note A above
middle C,which isknownasconcertA. This noteisnothingmorethan a sinewave,
scaled to oscillate at a frequency of 440times per second. The function sin(t) re
peatsitselfonceevery 2ir unitsonthex-axis, soifwe measure tin seconds and plot
the function sin(2irtX440), we get a curve that oscillates 440 times per second.
WhenyouplayanAbyplucking a guitarstring, pushing airthrougha trumpet, or
causing a small cone to vibrate in a speaker, this sinewave is the prominent part
of the sound that you hear and recognize asconcert A. We measure frequency in
hertz (cycles persecond). Whenyoudouble or halve thefrequency, youmove up or
down one octaveon the scale. For example, 880hertz is one octave aboveconcert
Aand 110 hertzistwooctaves below concert A. Forreference, thefrequency range
of human hearingisabout 20to 20,000 hertz. Theamplitude (y-value) of a sound
corresponds to the volume. We plot our curves between -1 and +1 and assume
that anydevices that recordand playsound will scale asappropriate, with further
scalingcontrolled byyou when you turn the volumeknob.
1
4
6
9
11
ITU
0
2
3
5
7
8
10 12
frequency
A
0
440.00
Atl
or Bb
1
466.16
B
2
493.88
C
3
523.25
Ct» or Db
4
554.37
D
5
587.33
Dtf
or Eb
6
622.25
E
7
659.26
F
8
698.46
>
FU or Cb
9
739.99
G
10
783.99
GU or Ab
11
830.61
A
12
880.00
440 x 2"
Notes, numbers, and waves
'wvvwwvy
'WVVWWW^
vwwwww
WWWVWXAA
vwvwwww
vwwwwww
wwwwwww
wwwwwvww
WVWXAAAAAAAAAA
WWWWWWWAAA
WWWVWWAAAAAM
147

148
Elements of Programming
Othernotes. A simple mathematical formula characterizesthe other notes on the
chromatic scale. There are twelve notes on the chromatic scale,divided equallyon a
logarithmic (base 2) scale.Weget the ith note above
a given note by multiplying its frequency by the
(i/12)th power of 2. In other words, the frequency
of each note in the chromatic scale is precisely the
frequency of the previous note in the scale multi
plied by the twelfth root of two (about 1.06). This
information suffices to create music! For example,
to play the tune Frere Jacques, we just need to play
each of the notes A B C#A by producing sine waves
of the appropriate frequencyfor about half a second
and then repeat the pattern. The primary method in
the StdAudio library, StdAudio. pi ay(), allowsyou
to do just that.
Sampling. For digital sound, we represent a curve
by sampling it at regular intervals, in precisely the
same manner as when we plot function graphs.
We sample sufficiently often that we have an ac
curate representation of the curve—a widely used
sampling rate for digital sound is 44,100 samples
per second. For concert A, that rate corresponds to
plotting each cycle of the sine wave by sampling it
at about 100 points. Sincewe sample at regular in
tervals,we only need to compute the y-coordinates
of the sample points. It is that simple: we represent
sound asan array ofnumbers (doubl e valuesthat are
between -1 and +1). Our standard sound library
method StdAudi o. pi ay() takes an array as its ar
gument and plays the sound represented by that ar
ray on your computer. For example, suppose that
you want to playconcert A for 10seconds.At44,100
samples per second, you need an array of 441,001
doubl e values.Tofillin the array,use a for loop that
samples the function sin(2TrtX440) at t = 0/44100,
1/40 second (various sample rates)
5,512 samples/second, 137samples
11,025samples/second, 275 samples
22,050samples/'second, 551 samples
A
A
A
A
A
A
A
A
A
A
VVVVv/VVVVVv
44,100 samples/second, 1,102samples
44,100samples/second (various times)
1/40 second, 1,102samples
1/200second, 220 samples
111000 second
1/1000 second, 44 samples
Samplinga sinewave

7.5 Input and Output
1/44100, 2/44100, 3/44100, . . . 441000/44100. Once we fill the array with these
values, weareready forStdAudi o. piay(), asin the following code:
int sps = 44100;
// samples per second
int hz = 440;
// concert A
double duration = 10.0;
// ten seconds
int N = (int) (sps * duration);
// total number of samples
doubled
a = new double [N+l];
for (int i
= 0;
i
<= N; i++)
a[i] = Math.sin(2*Math.PI * i * hz / sps);
StdAudio.pl ay(a);
This code isthe Hel 1oWorl dofdigital audio. Once youuse it to getyourcomputer
to playthis note,you can write codeto playother notesand makemusic! The dif
ference between creating sound andplotting an oscillating curve isnothing more
than the output device. Indeed, it isinstructive and entertaining to sendthe same
numbers to both standard draw and standard audio (seeExercise 1.5.27).
Saving to a file. Music can take up a lot of space on your computer. At 44,100
samples per second, a four-minutesongcorresponds to 4X60X44100=10,584,000
numbers. Therefore, it is common to represent the numbers corresponding to a
songin a binaryformat that uses less space than thestring-of-digits representation
thatweuseforstandardinputandoutput.Many such formats have beendeveloped
in recent years—StdAudio uses the .wav format. You can find some information
about the .wav format on the booksite, but you do not need to know the details,
because StdAudio takes care of the conversions foryou. Our standard library for
audio allows youto play .wav files, to write programs to create and manipulate ar
rays of doubl e values, and to read and write them as .wav files.
public class StdAudio
void
pi ay (St ring file)
play the given .wavfile
void
pi ay (doubled a)
play the given sound wave
void
pi ay (double X)
play samplefor 1/44100 second
void
save(St ring file, doubled a)
save to a.wavfile
doubled
read (St ring file)
readfrom a.wavfile
APIfor ourlibrary ofstatic methodsforstandard audio
149

150
Elements of Programming
Illllllll^^
Si
Program 1.5.7
Digital signalprocessing
pitch
duration
hz
N
a[]
distancefromA
noteplay time
frequency
number ofsamples
sampled sinewave
public class PlayThatTune
{
public static void main(String[] args)
{
// Read a tune from Stdin and play it.
int sps = 44100;
while (!Stdin.isEmptyO)
{
// Read and play one note,
int pitch = Stdin.readlnt();
double duration = Stdin.readDoubleO;
double hz = 440 * Math.pow(2, pitch / 12.0);
int N = (int)
(sps * duration);
doubled
a = new double [N+l];
for (int i
= 0;
i
<= N; i++)
a[i] = Math.sin(2*Math.PI * i
* hz /
sps);
StdAudio.pl ay(a);
^mmmmmmmmmmmm
}
}
This is a data-driven program that plays pure tones from the notes on the chromatic scale,
specified on standard input asapitch (distancefrom concertA)and a duration (in seconds).
The test client reads the notesfrom standard input, creates anarray by sampling a sine wave
ofthe specifiedfrequency and duration at44100 samples per second, and then plays each note
bycalling StdAudio. pi ay().
% more elise.txt
7
.25
6
.25
7
.25
6
.25
7
.25
2
.25
5
.25
3
.25
0
.50
wmmmmmmsamm
I
I
% Java PlayThatTune < elise.txt
I
toSs^^HPI^
wsmmmMmmmim^mmm

1.5 Input and Output
151
PlayThatTune (Program 1.5.7) is an examplethat showshow easilywe can
create music with StdAudio. It takes notes from standard input, indexed on the
chromaticscale from concertA,and plays them on standardaudio.You can imag
ine all sorts of extensions on this basic scheme, some ofwhich are addressed in the
exercises. Weinclude StdAudio in our basicarsenalof programming tools because
sound processing is one important application of scientific computingthat is cer
tainly familiar to you. Not only has the commercial application of digital signal
processinghad a phenomenal impact on modern society, but the science and en
gineering behind it combines physics and computer science in interesting ways.
We willstudy more components of digital signal processing in some detaillater in
the book. (For example,you willlearn in Section 2.1how to create sounds that are
more musicalthan the pure sounds producedby PIayThatTune.)
I/O isa particularly convincingexample of the powerof abstraction becausestan
dard input, standard output, standard draw,and standard audio can be tied to dif
ferent physical devices at different times withoutmaking anychanges to programs.
Althoughdevices may differdramatically, wecan write programsthat can do I/O
without depending on the properties of specific devices. From this point forward,
wewill usemethodsfrom StdOut,Stdin, StdDraw, and/or StdAudi o in nearlyev
eryprogram in this book, and youwillusethem in nearlyallof your programs,so
makesureto downloadcopies of theselibraries. Foreconomy, wecollectively refer
to theselibraries as Std*. One important advantage of usingsuchlibrariesis that
you can switch to new devices that are faster, cheaper, or hold more data without
changing your program at all. In such a situation, the details of the connection are
a matter to be resolved betweenyour operatingsystem and the Std* implementa
tions. On modern systems, new devices are typically supplied with software that
resolves such detailsautomaticallyfor both the operatingsystem and for Java.
Conceptually, one ofthe mostsignificant features ofthestandardinput, stan
dard output, standard draw, and standardaudiodatastreams is that they are infi
nite: fromthe point ofviewofyourprogram, thereisno limiton their length.This
point of view not onlyleads to programs that have a longuseful life (because they
are less sensitive to changes in technologythan programs with built-in limits). It
also is related to the Turing machine, an abstract device used by theoretical com
puter scientiststo help us understand fundamental limitations on the capabilities
of real computers. One of the essentialproperties of the model isthe idea of a finite
discretedevice that workswith an unlimited amount of input and output.

152
Elements of Programming
Q. Whyarewenot usingthe standardJava librariesfor input, graphics,and sound?
A, We are using them, but we prefer to work with simpler abstract models. The
Javalibraries behind Stdin, StdDraw,and StdAudi o are built for production pro
gramming, and the libraries and their APIs are a bit unwieldy. To get an idea of
what they arelike,look at the codein Stdin. j ava, StdDraw.j ava, and StdAudio.
Java.
Q. So, let me getthis straight.IfI usethe format%2. 4f for a double value,I gettwo
digitsbeforethe decimalpoint and four digitsafter, right?
A. No, that specifies just four digits after the decimal point. The first value is the
width of the whole field.You want to use the format %7. 2f to specifysevencharac
ters in total, four before the decimal point, the decimal point itself, and two digits
after the decimal point.
Q. What other conversion codes are there for pri ntf()?
A. For integervalues, there is o for octaland x for hexadecimal. There are also nu
merous formats for dates and times. See the booksite for more information.
Q. Can my program re-read data from standard input?
A. No.You only getone shot at it, in the samewaythat you cannot undo a pri nt-
ln() command.
Q. What happensif myprogramattemptsto readdata from standard input afterit
is exhausted?
A. You will get an error. Stdin. i sEmpty() allows you to avoid such an error by
checking whether there is more input available.
Q. What does the error message Exception in
thread
"main"
java.lang.
NoClassDefFoundError: Stdin mean?
A. Youprobably forgot to put Stdin. j ava in your working directory.
Q. I have a different working directory for each project that I am working on, so I

1.5 Input and Output
have copies of StdOut. j ava, Stdin. j ava, StdDraw.j ava, and StdAudi o. j ava in
each of them. Is there some better way?
A. Yes. You canput them allin one directoryand usethe"classpath" mechanismto
tellJava whereto findthem.Thismechanism isoperating-system dependent—you
can find instructions on how to use it on the booksite.
Q. Myterminal window hangs at the endofa program using StdAudi o.Howcan
I avoidhavingto use <ctrl -c> to geta commandprompt?
A. Adda call to System. exit (0) asthelastlinein mai n(). Don'taskwhy.
Q. So I use negative integers to go below concert A when making input files for
PlayThatTune?
A. Right. Actually, our choice to put concertAat0isarbitrary. Apopularstandard,
knownasthe MIDI Tuning Standard, startsnumbering at the Cfive octaves below
concertA.Bythat convention, concertAis69and youdo not needto usenegative
numbers.
Q. Whydo I hearweird results on standard audio when I try to sonify a sinewave
with a frequency of 30,000Hertz (or more)?
A. The Nyquistfrequency, defined as one-halfthe sampling frequency, represents
the highest frequency that can be reproduced. For standardaudio, the sampling
frequency is 44,100, so the Nyquistfrequency is 22,050.
153

Elements of Programming
1.5.1
Writea program that reads in integers (as many as the user enters) from
standard input and prints out the maximum and minimum values.
1.5.2
Modify your programfromthe previous exercise to insistthat the integers
must be positive (by prompting the user to enter positive integers whenever the
value entered is not positive).
1.5.3
Write a program that takes an integer N from the command line, reads
N double values from standard input, and prints their mean (average value) and
standarddeviation (square rootofthe sumof thesquares of theirdifferences from
the average, divided by N-1).
1.5.4
Extendyourprogramfromtheprevious exercise to createafilter that prints
all the values that are further than 1.5 standard deviations from the mean. Use an
array.
1.5.5
Writea program that reads in a sequence of integers and prints out both
the integer that appears in a longest consecutive run and the lengthof the run. For
example, ifthe input is1 22151177771 1,then yourprogramshould
print Longest run: 4 consecutive 7s.
1.5.6
Writeafilterthat readsin asequence ofintegersand prints out the integers,
removing repeated values that appear consecutively. For example, if the input i
1221511777711111111 1, your program should print out
12 15 17 1.
1.5.7
Writea program that takes a command-line argument N, readsin N-1 dis
tinct integersbetween1 and N, and determines the missingvalue.
1.5.8
Write a program that readsin positive real numbers from standard input
andprintsout theirgeometric andharmonicmeans. Thegeometric mean ofATposi
tive numbersxvx^ ..., xN is (xx Xx^ X... XxN)l/N. Theharmonic mean is (\/xl + 1/
x2 +... + l/xN) I (l/N). Hint: Forthegeometric mean, consider taking logs to avoid
overflow.
1.5.9
Suppose that the file input.txt contains the two strings F and F. What

1.5 Input and Output
does the following command do (seeExercise 1.2.35)?
Java Dragon < input.txt | Java Dragon | Java Dragon
public class Dragon
{
public static void main(String[] args)
{
String dragon = Stdin.readStringO;
String nogard = Stdin. readStringO;
StdOut.print(dragon + "L" + nogard);
StdOut.printC ");
StdOut.print(dragon + "R" + nogard);
StdOut.printlnO;
}
}
1.5.10 Writea filterTenPerLine that takes a sequence of integers between0 and
99 and prints 10 integers per line, with columns aligned. Then write a program
RandomlntSeq that takes two command-line arguments Mand Nand outputs N
random integers between0 and M-1. Test your programswith the command Java
RandomlntSeq 200 100 | Java TenPerLine.
1.5.11 Writea program that readsin textfrom standardinput and prints out the
number of words in the text. Forthe purposeof thisexercise, a wordisa sequence
of non-whitespace characters that issurroundedbywhitespace.
1.5.12 Write a program that reads in lines from standard input with each line
containinga name and two integersand then usespri ntf() to print a tablewith a
column ofthenames, theintegers, andtheresult ofdividing thefirst bythesecond,
accurate to three decimal places. You couldusea programlikethis to tabulatebat
ting averages for baseballplayers or gradesfor students.
1.5.13 Whichofthe following require saving allthevalues fromstandardinput (in
an array, say), andwhichcouldbeimplemented asafilter usingonlya fixed number
of variables? For each,the input comesfrom standard input and consistsof N real
numbers between 0 and 1.
155

156
Elements of Programming
• Print the maximum and minimum numbers.
• Print the /cth smallest value.
• Print the sum ofthe squares ofthe numbers.
• Print the average ofthe N numbers.
• Print the percentage of numbers greater than the average.
• Print the N numbers in increasingorder.
• Print the N numbers in random order.
1.5.14 Write a programthat prints a table of the monthly payments, remaining
principal, andinterestpaidforaloan,takingthreenumbers ascommand-line argu
ments:thenumber ofyears, the principal, andthe interestrate (see Exercise 1.2.24).
1.5.15 Write a program that takes three command-line arguments x, y, and z,
reads from standard input asequence of point coordinates (x,, ypz,),and prints the
coordinates of the point closest to (x, y, z). Recall that the squareof the distance
between (x, y, z) and (xf, y{, z{)is (x - x{)2 +(y —y{)2 +(z —z{)2. For efficiency, do
not use Math.sqrt() orMath.pow().
1.5.16 Given the positionsand masses of a sequenceof objects,write a program
to compute their center-of-mass, or centroid. The centroid is the average position
ofthe N objects, weightedby mass. If the positionsand masses are givenby (xi9 yf,
m|y), then the centroid (x, y, m) is given by:
m = ml + m2 +... + mN
x =(mlx}+ ... + mnxN)/m
y =(m]yJ+ ... + mnyN)/m
1.5.17 Write aprogram that reads in asequence ofreal numbersbetween -1 and
+1 and printsout theiraverage magnitude,average power, andthe number ofzero
crossings. The average magnitude is the average of the absolute valuesof the data
values. The average poweristhe average ofthe squares ofthe datavalues. The num
ber of zero crossings is the number of times a datavalue transitions from a strictly
negativenumber to a strictly positivenumber, or vice versa. These three statistics
arewidely used to analyzedigital signals.

1.5 Input and Output
1.5.18 Write a programthat takesacommand-line argument Nand plots an N-by-
Ncheckerboard with red and black squares. Color the lowerleft square red.
1.5.19 Write a program that takes ascommand-line arguments an integer N and
adouble value p (between 0 and 1),plots Nequallyspaced points ofsizeon the cir
cumference of a circle, and then, with probability p foreachpairof points, drawsa
grayline connecting them.
16
.125
16
.25
16 1.0
^"•v
1.5.20 Write code to draw hearts, spades, clubs, and diamonds. To draw a heart,
drawadiamond,then attach two semicircles to the upperleftandupperrightsides.
1.5.21 Write a programthat takesa command-line argumentN and plots a rose
with N petals (if N is odd) or 2N petals (if N is even),by plotting the polarcoordi
nates(r,G) ofthe function r= sin(NO) for8 ranging from 0 to 27r radians.
1.5.22 Write a program that takes a string s from the command line and displays
it in banner styleon the screen, moving from left to right and wrapping back to the
beginningof the string asthe end is reached. Add a secondcommand-line argu
ment to control the speed.
157

158
Elements of Programming
1.5.23 Modify PlayThatTune to take additional command-line arguments that
control the volume (multiply each sample value by the volume) and the tempo
(multiply each note's duration by the tempo).
1.5.24 Write a program that takesthe name ofa .wav file and a playbackrate r as
command-line arguments and plays the file at the given rate.First, use StdAudi o.
read() to read the file into an array a[]. If r = 1, just play a[]; otherwise create
a new arrayb[] of approximate size r times a. length. If r < 1, populate b[] by
sampling from the original; if r> 1,populate b[] by interpolating from the original.
Then playb[].
1.5.25 Write programsthat uses StdDraw to create eachof the following designs.
1.5.26 Write a program Circl es that draws filled circles of random size at ran
dom positionsin the unit square, producingimageslikethose below.Your program
should take four command-line arguments: the number of circles, the probability
that each circle is black, the minimum radius, and the maximum radius.
200
1
.01
.01
100
1
.01
.05
500
.5
.01
.05
50
.75
.1
.2
£•-?.
*^5

1.5 Input and Output
WB^§is0OSMtt^A
1.5.27 Visualizingaudio. ModifyPIayThatTuneto sendthe valuesplayedto stan
dard drawing, so that you can watch the sound waves as they are played.Youwill
haveto experiment with plotting multiple curvesin the drawing canvasto synchro
nize the sound and the picture.
1.5.28 Statisticalpolling. When collectingstatisticaldata for certain political polls,
it isvery important to obtain an unbiased sample of registeredvoters.Assume that
you havea file with Nregistered voters,one per line.Writea filterthat prints out a
random sample of size M(see Program 1.4.1).
1.5.29 Terrain analysis. Supposethat aterrain isrepresented bya two-dimension
algrid of elevationvalues(in meters).Apeak isa grid point whosefour neighboring
cells (left,right,up,and down) havestrictlylowerelevation values.Writea program
Peaks that reads a terrain from standard input and then computes and prints the
number of peaks in the terrain.
1.5.30 Histogram. Suppose that the standard input stream is a sequence of dou
bl e values.Write a program that takes an integer N and two doubl e values / and r
from the command line and uses StdDraw to plot a histogram of the count of the
numbers in the standard input stream that fall in eachof the N intervalsdefinedby
dividing (/, r) into JV equal-sized intervals.
1.5.31 Spirographs. Write a program that takesthree parameters R,r, and a from
the command line and draws the resulting spirograph. A spirograph (technically,
an epicycloid) is a curveformed by rollinga circle of radius r around a larger fixed
circleof radius R. If the pen offsetfrom the centerof the rollingcircleis (r+a), then
the equation of the resultingcurveat time tis given by
x(t) = (R + r) cos (t) - (r + a) cos ((R + r)t/r)
y(t) = (R + r) sin (t) - (r + a) sin ((£ +r)t/r)
Such curves were popularized by a best-selling toy that contains discs with gear
teeth on the edges and smallholesthat you couldput a pen in to trace spirographs.

160
Elements of Programming
1.5.32 Clock. Write a program that displays an animation of the second, minute,
and hour hands of an analog clock. Usethe method StdDraw.show(lOOO) to up
date the displayroughly once per second.
1.5.33 Oscilloscope. Write a program to simulate the output of an oscilloscope
and produce Lissajouspatterns. These patterns are named after the French physi
cist, JulesA. Lissajous,who studied the patterns that arise when two mutually per
pendicular periodic disturbances occur simultaneously.Assume that the inputs are
sinusoidal, so that the followingparametric equations describe the curve:
x(t)=Axsm(wxt + Qx)
y(t)=Ay sin (wyt + Qy)
Take thesix parameters AXt wXf QXfAy wy> and0^ from thecommand line.
1.5.34 Bouncing ballwith tracks. Modify BouncingBall to produce images like
the ones shown in the text, which show the track of the ball on a gray background.
1.5.35 Bouncing ballwithgravity. Modify BouncingBall to incorporate gravity
in the vertical direction. Add calls to StdAudio. pi ay() to add one sound effect
when the ball hits a wall and a different one when it hits the floor.
1.5.36 Random tunes. Write a program that uses StdAudio to playrandom tunes.
Experiment with keepingin key, assigninghigh probabilities to whole steps,repeti
tion, and other rules to produce reasonable melodies.
1.5.37 Tile patterns. Using your solution to Exercise 1.5.25, write a program
Ti1ePattern that takesa command-line argument Nand drawsan N-by-N pattern,
using the tile of your choice. Add a second command-line argument that adds a
checkerboard option. Add a third command-line argument for color selection. Us
ingthe patterns on the facing pageasastarting point, designatilefloor.Becreative!
Note: These are all designs from antiquity that you can find in many ancient (and
modern) buildings.

1.5 Input and Output
p^
^
nrrj
^
^
^'r^'^^'n!^^l.
*^^'"
7^
5^5
^
^
7^9^
^1
4i&
njSn n
^n h| lip Si IPP
•1
^Pj^^^j^l^^f^r
M
31 iB
jglll ^K 1111 IBflii
5liG jHc Jhiiu Sliu Slilj kyl2
ry ry <-% r> <r% ^%
w
w
w
w
w
w
ry ry ry ry ry ry
w
w
w
w
w
w
/a «*% <~\ ^
ry ry
w
w
w
w
w
w
<*% ^% ry ry ry ry
w
w
w
w
v/ w
ry ry ry ry ry ry
w
w
w
w
w
w
<~% <*-%. <~>, ry ry ry
161

Elements of Programming
L6
Case Study: RandomWeb Surfer
Communicating across the web has become an integral part of everydaylife. This
communication is enabled in part by scientific studies of the structure of the web,
a subjectof active research sinceits inception.Wenext considera simplemodel of
the web that has proven to be a particularly successful approach to understand
ing some of its properties. Variants of
this model are widelyused and havebeen
a key factor in the explosive growth of
search applications on the web.
The model is known as the random
surfer model, and is simple to describe.
We consider the web to be a fixed set of
pages, with each page containing a fixed set of hyperlinks (for brevity,we use the
term links), and eachlink a reference to some other page.Westudy what happens
to a person (the random surfer) who randomly movesfrom pageto page,either by
typing a page name into the addressbar or by clickinga link on the current page.
The underlying mathematical model behind the web model is known as the
graph, which we will consider in detail at the end of the book (in Section 4.5).
Wedeferdiscussionof detailsabout processing
graphs until then. Instead, we concentrate on
calculations associated with a natural and well-
studied probabilistic model that accurately de
scribes the behavior of the random surfer.
The first step in studying the random
surfer model is to formulate it more precise
ly. The crux of the matter is to specify what it
means to randomly move from page to page.
The following intuitive 90-10 rule captures
both methods of moving to a new page: As
sume that 90 per cent of the time the random
surfer clicks a random linkon thecurrent page
(each link chosen with equal probability) and
that 10 percent of the time the random surfer
goes directly toa random page (allpages on the
web chosen withequalprobability).
Pages and links
1.6.1
1.6.2.
1.6.3
Computing the transition matrix . 165
Simulating a random surfer
167
Mixing a Markov chain
174
Programs in thissection

1.6 Case Study: Random Web Surfer
You can immediately see that this model has flaws, becauseyou know from
your own experience that the behaviorof a realwebsurferisnot quite so simple:
• No one chooses links or pageswith equal probability.
• There is no real potential to surf directlyto eachpageon the web.
• The 90-10 (or any fixed) breakdown is just a guess.
• It does not take the back button or bookmarks into account.
• Wecan only afford to work with a smallsampleof the web.
Despite these flaws, the model is sufficiently rich that computer scientists have
learneda great deal about properties of the web by studying it. Toappreciate the
model,consider the smallexampleon the previouspage. Which pagedo you think
the random surfer is most likelyto visit?
Each person using the web behaves a bit like the random surfer, so under
standing the fateof the random surferisof intenseinterestto peoplebuilding web
infrastructure and web applications. The modelis a tool for understanding the ex
perienceof each of the hundreds of millionsof webusers. In this section,you will
use the basic programming tools from this chapter
to study the model and its implications.
163
more tiny.txt
•+—N
Input format
We want to be able to study the
behavior of the random surfer on various web mod
els,not just one example.Consequently, wewant to
write data-driven code, where we keep data in files
and write programs that read the data from standard
input. The first step in this approach is to define an
inputformat that we can use to structure the infor
mation in the input files. Weare freeto define anyconvenient input format.
Later in the book, you will learn how to read web pages in Java programs
(Section 3.1) and to convert from names to numbers (Section 4.4) as well as other
techniques forefficient graphprocessing. Fornow, weassume that there areN web
pages, numberedfrom 0 to N-1, and werepresent links withorderedpairsof such
numbers, the first specifying thepage containing thelinkandthesecondspecifying
the page to which it refers. Given these conventions, a straightforward input for
mat forthe random surferproblemisan input stream consisting of an integer(the
value of N) followed by a sequence of pairs of integers (the representations of all
the links). Stdin treatsallsequences ofwhitespace characters asa single delimiter,
sowearefree to eitherput onelinkper lineor arrange them several to a line.
1
2
1
3
4
2
1
4
' links
Random surfer inputformat

164
Elements of Programming
Transition matrix
We use a two-dimensional matrix, that we refer to as the
transition matrix, to completelyspecify the behavior of the random surfer.With N
webpages, wedefine an N-by-Nmatrixsuchthat the entry in rowi and column j
istheprobability that therandomsurfer moves to page j whenon page i. Our first
taskisto writecodethat cancreate sucha matrixforanygiven input.Bythe 90-10
rule, this computation is not difficult. Wedo so in three steps:
• ReadN, and then create arrays counts [] [] and outDegree [].
• Read the links and accumulate counts so that counts [i ] [j] counts the
links fromi to j and outDegree[i ] countsthe linksfrom i to anywhere.
• Usethe 90-10rule to compute the probabilities.
The firsttwo stepsare elementary, and the third is not much more difficult: multi
ply counts [i ] [j ] by .90/degree [i ] if there is a link from i to j (take a random
linkwith probabiUty .9),and then add .10/N to each entry (goto a random page
with probability.1).Transition (Program 1.6.1) performs this calculation: It is a
filterthat convertsthe list-of-linksrepresentationof a webmodel into a transition-
matrix representation.
The transition matrix is significant because each row represents a discrete
probability distribution—the entries fully specify the behavior of the random surf
er's next move, giving the probability of surfing to eachpage. Note in particular
that the entriessum to 1 (the surferalways goes somewhere).
The output of Transition defines another file format, one for matrices of
double values: the numbers of rows and columnsfollowed bythe valuesfor matrix
entries. Now,we can write programs that read and process transition matrices.
inputgraph
1
2
1
3
4
2
leapprobabilities
!02 .02 .02 .02 .02"
.02
.02
.02
.02
.02
.02
.02
.02
.02
.02
.02
.02
.02
.02
.02
.02
.02
.02
.02
.02
link counts
tiegrees
~0
1
0
0
0"
~1
4
0
0
2
2
1
5
0
0
0
1
0
1
10
0
0
0
1
10
1
0
0_
2
linkprobabilities
transition matrix
0
.90
0
0
0"
"02 .92 .02 .02
.02"
0
0
.36
.36
.18
.02
.02
.38
.38
.20
+
0
0
0
.90
0
=
.02
.02
.02
92
.02
.90
0
0
0
0
.92
.02
.02
.02
.02
.45
0
.45
0
0
.47
.02
.47
.02
.02
Transition matrix computation

1.6 Case Study: Random Web Surfer
165
Program 1.6.1
Computingthe transitionmatrix
public class Transition
{
public static void main(String[] args)
{
// Print random-surfer probabilites.
int N = Stdin.readlnt();
int[][] counts = new int[N][N];
int[] outDegree = new int[N];
while (!Stdin.isEmptyO)
{
// Accumulate link counts,
int i
= Stdin.readlnt();
int j = Stdin.readlnt();
outDegree[i]++;
counts[i][j]++;
}
}
StdOut.println(N
for (int i
= 0;
i
< N; i++)
{
// Print probability distribution for row i.
for (int j
= 0;
j
< N; j++)
{
// Print probability for column j.
double p = .90*counts[i][j]/outDegree[i] +
StdOut.printf("%8.5fM,
p);
}
StdOut.printlnO;
+ "
" + N);
counts[i][j]
outDegree[i]
numberofpages
countof linksfrom
pagei topagej
countof linksfrom
page i toanywhere
transition probability
.10/N;
This program isafilter that reads links from standard input and produces the corresponding
transition matrix on standard output. First, itprocesses the input to count the outlinks from
each page. Then itapplies the 90-10 rule to compute the transition matrix (see text). Itassumes
that there are nopages that have nooutlinks in the input (see Exercise 1.6.3).
1
4
4
2
!Mki
% Java Transition < tiny.txt
5
5
0.02000 0.92000 0.02000
0.02000 0.02000
0.02000 0.02000
0.92000 0.02000 0.02000 0.02000 0.02000
0.47000 0.02000 0.47000 0.02000 0.02000
m^mmwmd
0.02000 0.02000
0.38000 0.38000 0.20000
0.02000 0.92000 0.02000

166
Elements of Programming
Simulation
Given thetransition matrix, simulatingthebehavior oftherandom
surfer involves surprisingly littlecode, asyou can seein RandomSurfer (Program
1.6.2). This program reads a transition matrix and surfs according to the rules,
starting atpage 0 and taking thenumber of moves as acommand-line argument.
Itcounts thenumber of times that thesurfer visits each page. Dividing thatcount
bythenumber of moves yields anestimate of the probability thatarandom surfer
windsup on the page. Thisprobability isknown as the page's rank. In otherwords,
RandomSurfer computes an estimateofallpageranks.
One random move. The keyto the computation is the random move, which is
specified by the transition matrix.We maintain avariable pagewhose value is the
current location of the surfer. Rowpage of the matrixgives, for each j, the prob
abilitythat the surfernext goes to j. In other words, when the surferis at page,
our task is to generate a random inte-
j
0 12
3
4
ger between 0 and N-1 according to the
probabilities p[page] [j]
.47 .02 .47 .02 .02
distribution given by row page in the
cumulated sum values
.47 .49 .96 .98 1.0
transition matrix (the one-dimensional
.71, return 2
array PCpage]). How canwe accomplish
\
this task? We can use Math. random() to
"++
+H
generate arandom number r between 0
and 1, but how does that help us get to
a random page? One way to answerthis
Generating a random integer from adiscrete distribution
question is to think of the probabilities
in row page as defining a set of N inter
vals in (0,1) with each probability corresponding to an interval length. Then our
random variable r falls intooneoftheintervals, withprobability preciselyspecified
bytheinterval length. Thisreasoning leads to the following code:
double sum =0.0;
for (int j = 0;
j < N; j++)
{
// Find interval containing r.
sum += p[page][j];
if (r < sum) { page = j; break; }
}
The variable sum tracks the endpoints of the intervals defined in rowp[page], and
the for loop finds the interval containing the random value r. For example, sup
pose thatthesurfer isatpage 4inourexample. Thetransition probabilities are .47,
t
/\
/t\
0.0
.47
.49
.96 .98 1.0

1.6 Case Study: Random Web Surfer
167
fmm
{.3$n
hi
S
81
^iii^i
Program 1.6.2
Simulating a random surfer
public class RandomSurfer
{
public static void main(String[] args)
{
// Simulate random-surfer leaps and links,
int T = Integer.parselnt(args[0]);
int N = Stdin.readlnt();
Stdin.readlnt();
// Read transition matrix.
doubled []
p = new double[N] [N];
for (int i
= 0;
i
< N;
i++)
for (int j = 0;
j < N; j++)
p[i][j] = Stdin. readDoubleO;
int page = 0; // Start at page 0.
int[]
freq = new int[N];
for (int t
= 0;
t
< T;
t++)
{
// Make one random move.
double
r = Math.randomO;
double sum =0.0;
for (int j = 0;
j < N; j++)
{
// Find interval containing r.
sum += p[page][j];
if (r < sum) { page = j; break;
}
}
freq[page]++;
}
for (int i =0;
i
< N; i++)
// Print page ranks.
Std0ut.printf(n%8.5fM,
(double)
freq[i]
/ T);
StdOut.printlnO;
T
N
page
p[i][j]
freq[i]
8M
number of moves
number ofpages
current page
probability that the
surfer movesfrom
pagei topagej
number of times the
surfer hitspagei
mmmmm
This program uses a transition matrix tosimulate thebehavior ofa random surfer. It takes the
number of moves as a command-line argument, reads thetransition matrix, performs thein
dicated number of moves asprescribed bythematrix, andprints therelativefrequency of hit
tingeach page. Thekey to thecomputation is therandom move to thenextpage (seetext).
mm
m%Wo^w^ww**!
m
#1
[*•*••
••• *"••,,•:--•:..
:>;-. :-••**•*.
f,-
% Java Transition < tiny.txt | Java RandomSurfer 100
0.24000 0.23000 0.16000 0.25000 0.12000
% Java Transition < tiny.txt | Java RandomSurfer 10000
0.27280 0.26530 0.14820 0.24830 0.06540
% Java Transition < tiny.txt | Java RandomSurfer 1000000
0.27324 0.26568 0.14581 0.24737 0.06790
l^^^^^^^^^p^^^^^^^^^^p

168
Elements of Programming
.02, .47, .02, and .02, and sum takes on the values 0.0,0.47,0.49,0.96,0.98, and
1.0. These values indicate that the probabilities define the five intervals (0, .47),
(.47, .49), (.49, .96), (.96, .98), and (.98, 1),onefor each page. Now, suppose that
Math. random() returns the value .71. We increment j from 0 to 1to 2 and stop
there, which indicates that . 71 is in the interval (.49, .96), so we send the surfer to
the third page(page 2).Then,weperformthe samecomputationfor p[2], and the
random surfer is offand surfing. Forlarge JV, wecan use binary search to substan
tiallyspeed up this computation (see Exercise 4.2.36). Typically, we are interested
in speeding up the search in this situation because we are likely to need a huge
number of random moves, asyou willsee.
Markov chains. Therandomprocess that describes the surfer's behaviorisknown
as a Markov chain, named after the Russian mathematician Andrey Markov, who
developed the concept in the early20th century. Markovchains are widelyappli
cable, well-studied, and have many remarkableand useful properties. For exam
ple,you mayhave wonderedwhyRandomSurfer starts the random surfer at page
0 whereas you might have expected a random choice. A basic limit theorem for
Markov chains says that the surfer could start anywhere, because the probability
that a random surfer eventuallywinds up on any particular page is the same for all
starting pages! No matter wherethe surferstarts,the processeventuallystabilizes to
a point where further surfing provides no further information. This phenomenon
is known as mixing. Though this phenomenon is perhaps counterintuitive at first,
it explainscoherent behavior in a situation that might seem chaotic. In the present
context,it captures the idea that the weblooks pretty much the same to everyone
after surfing for a sufficiently long time. However, not all Markov chains have this
mixing property. For example, if we eliminate the random leap from our model,
certain configurations of web pages can present problems for the surfer. Indeed,
there existon the web sets of pages known as spider traps, which are designed to
attract incoming links but have no outgoing links.Without the random leap, the
surfer could getstuck in a spider trap. The primary purpose of the 90-10rule is to
guarantee mixing and eliminate such anomalies.
Page ranks. The RandomSurfer simulation isstraightforward: it loops forthein
dicated number of moves, randomly surfing through the graph. Because of the
mixing phenomenon, increasing the number of iterations gives increasingly ac
curate estimates of the probability that the surferlands on each page (the page

1.6 Case Study: Random Web Surfer
169
ranks). How do the results compare with your intuition when you first thought
about the question? You might have guessed that page 4 was the lowest-ranked
page, but did you think that pages 0 and 1 would rank higher than page 3? If we
want to know which page is the highest rank, we need more precision and more
accuracy. RandomSurfer needs 10" moves to getanswers precise to ndecimalplaces
and many more movesfor those answers to stabilize to an accuratevalue.For our
example, it takes tens of thousands of iterations to get answers accurate to two
decimalplaces and millionsofiterationsto getanswers accurateto three places(see
Exercise 1.6.5).The end result is that page 0 beats page 1 by 27.3% to 26.6%.That
such a tiny difference would appear in such a smallproblem is quite surprising: if
you guessedthat page 0 is the most likely spot for the surfer to end up, you were
lucky! Accurate page rank estimatesfor the web are valuablein practice for many
reasons. First, using them to put in order the pages that match the search criteria
for web searches proved to be vastly more in line with people's expectations than
previous methods. Next, this measure of confidence and reliability led to the in
vestment of huge amounts of money in web advertisingbased on page ranks. Even
in our tiny example, page ranks might be used to convinceadvertisersto pay up to
four times as much to place an ad on page 0 as on page 4. Comput
ing page ranks is mathematically sound, an interesting computer
science problem, and big business, all rolled into one.
Visualizing thehistogram. WithStdDraw, it isalso easy to create a
visual representation that can giveyou a feelingfor how the random
surfer visit frequencies convergeto the page ranks. Simplyadd
StdDraw.clear();
StdDraw.setXscale(-l,
N);
StdDraw.setYscale(0, t);
n
StdDraw.setPenRadius(. 5/N) ;
Pa8e mnks mth h*st°g™™
for (int i =0;
i
< N; i++)
StdDraw.1ine(i, 0, i, freq[i]);
StdDraw.show(20);
mi.
to the random move loop, run RandomSurfer for large values of T,and you will see
a drawing of the frequency histogram that eventually stabilizesto the page ranks.
Afteryou haveused this tool once,you are likelyto find yourself using it every time

170
Elements of Programming
you want to study a new model (perhaps with some minor adjustments to handle
larger models).
Studyingother models. RandomSu rfer andTransi ti onareexcellent examples of
data-driven programs. You caneasily create a data modeljustbycreating a file like
ti ny.txt that starts with an integerNand then specifies pairs of integersbetween
0 and N-1 that representlinks connecting pages. You are encouragedto run it for
various data models as suggested in the exercises, or to make up some models of
your own to study. If you have everwondered how web page ranking works,this
calculation is your chance to develop better intuition about what causes one page
to be ranked more highly than another. What kind of page is likely to be rated
highly? One that has many links to other pages, or one that has just a fewlinks to
other pages? The exercises in this section present many opportunities to study the
behavior of the random surfer.Since RandomSurfer uses standard input, you can
write simple programs that generatelargeinput models, pipe their output to Ran
domSu rfer, and therefore study the random surfer on largemodels. Suchflexibility
is an important reason to use standard input and standard output.
Directly simulating the behavior of a random surfer to understand the structure
of the web is appealing,but it has limitations. Think about the followingquestion:
Could you use it to compute pageranks for a web model with millions (or billions!)
of web pages and links?The quick answerto this question is no,because you can
not even afford to store the transition matrix for such a large number of pages. A
matrix for millions of pageswould have trillions of entries. Do you have that much
space on your computer? Could you use RandomSurfer to find page ranks for a
smaller model with, say, thousands of pages? To answer this question, you might
run multiple simulations, record the results for a large number of trials, and then
interpret those experimental results.We do use this approach for many scientific
problems (the gambler's ruin problem is one example; Section 2.4 is devoted to
another), but it can be very time-consuming, as a huge number of trials may be
necessaryto get the desired accuracy. Evenfor our tiny example, we sawthat it takes
millions of iterations to get the pageranks accurate to three or four decimal places.
For larger models, the required number of iterations to obtain accurate estimates
becomes truly huge.

1.6 Case Study: Random Web Surfer
Mixing a Markov chain
It isimportant to rememberthat the pageranks are a
property of the web model, not any particular approach for computing it. That is,
RandomSurfer is just onewayto compute page ranks. Fortunately,a simple com
putational model based on a well-studiedareaof mathematicsprovides a far more
efficientapproach than simulation to the problem of computing page ranks. That
model makes use of the basic arithmetic operations on two-dimensional matrices
that we considered in Section 1.4.
Squaring a Markov chain. What is the probability that the random surfer will
move from page i to page j in two moves? The first move goes to an intermedi
ate page k, so we calculatethe probabilityof movingfrom i to k and then from k
to j for all possible k and add up the results.For
our example, the probability of moving from 1
to 2 in two moves is the probability of moving
from 1 to 0 to 2 (.02X.02), plus the probability
of moving from 1 to 1 to 2 (.02X.38), plus the
probability of moving from 1 to 2 to 2 (.38X.02),
plus the probability of moving from 1 to 3 to 2
(.38X.02), plus the probability of moving from
1 to 4 to 2 (.20X.47), which adds up to a grand
total of .1172. The same process works for each
pair of pages. This calculation is one thatwe have
seen before, in the definition of matrix multipli
cation: the entry in row i and column j in the
result is the dot product ofrow i and column j in
the original. In other words, the result of multi
plying p[] [] by itself is a matrix where the entry
in row i and column j is the probability that the
random surfer moves from page i to page j in
two moves. Studying the entries of the two-move
transition matrix for our example is well worth
your time and will help you better understand the
movement ofthe random surfer. For instance, the
largest entry in the square is the one in row 2 and column 0, reflecting the fact that
a surfer starting on page 2 has only one link out, to page 3,where there is also only
one link out, to page 0. Therefore, by far the most likelyoutcome for a surfer start-
171
probability of
surfingfrom i to 2
in one move
.02
.92
.02
.02
.02
.02
.02
.38
.38
.20
.02
.02
.02
.92
.02
.92
.02
.02
.02
.02
.47
.02
.47
.02
.02
probability of
surfingfrom 1 toi
in one move
probability of
surfingfrom lto2
in two moves
(dotproduct)
Squaring a Markov chain

172
Elements of Programming
ing on page 2 is to end up in page 0 after two moves. All of the other two-move
routes involvemore choices and are less probable. It is important to note that this
isan exactcomputation (up to the limitations ofJava's floating-point precision),in
contrast to RandomSurfer, which produces an estimate and needs more iterations
to get a more accurate estimate.
The power method. We mightthen calculate the probabilities for three movesby
multiplying by p[] [] again, and for fourmovesby multiplying by p[] [] yet again,
and so forth. However, matrix-matrix multiplicationisexpensive, andwe areactu
ally interested in a vector-matrix calculation. For our example, we start with the
vector
[1.0 0.0 0.0 0.0 0.0 ]
which specifies that the random surferstartson page0. Multiplying this vector by
the transition matrix givesthe vector
[.02
.92 .02 .02 .02 ]
which is the probabilities that the surfer winds up on each of the pages after one
step.Now, multiplying thisvector by the transition matrix givesthe vector
[.05
.04 .36 .37 .19 ]
which contains the probabilitiesthat the surfer winds up on each ofthe pagesafter
two steps. Forexample, the probability of moving from 0 to 2 in two moves is the
probability of moving from 0 to 0 to 2 (.02X.02), plus the probability of mov
ing from 0 to 1 to 2 (.92X.38), plus the probability of moving from 0 to 2 to 2
(.02X.02),plusthe probabilityofmoving from 0 to 3to 2 (.02X.02),plusthe prob
abilityof moving from 0 to 4 to 2 (.02X.47),which addsup to a grandtotal of .36
. Fromthese initial calculations, the pattern is clear: The vectorgivingtheprobabili
ties that the random surfer is at each pageaftert stepsis precisely theproductof the
corresponding vectorfor t —1steps and thetransition matrix. By the basiclimit theo
rem for Markov chains, this process converges to the same vector no matter where
we start; in other words, after a sufficient number of moves, the probability that
the surferends up on any given page is independent of the starting point. Markov
(Program 1.6.3) is an implementation that you can use to check convergence for
our example. Forinstance,it getsthe same results (the pageranks accurateto two
decimal places) as RandomSurfer, but with just 20 matrix-vector multiplications

1.6 Case Study: Random Web Surfer
rank[]
firstmove
[ 1.0 0.0 0.0 0.0 0.0 ] *
second move
probabilities of surfing
from 0 toi in onemove
/
/
I
\
\
[ .02 .92 .02 .02 .02 ]
third move
probabilities ofsurfing
from 0 toi in two moves
/
/
I
\
\
[ .05 .04 .36 .37 .19 ]
20th move
probabilities ofsurfing
from 0 toi in 19 moves
/
/
I
\
\
[ .27 .26 .15
.25 .07 ] *
p[][]
'02 .92 .02 .02 .02"
.02
.02
.38
.38
.20
,02
.02
.02
.92
.02
.92
.02
.02
.02
.02
.47
.02
.47
.02
.02
newRank[]
[ .02 .92
.02
.02
.02 ]
\
\
t
/
/
probabilities ofsurfing
from0 10 1 in onemove
probabilities ofsurfing
/ from i to2 inonemove
02
.92
.02
02
.02
.38
02
.02
.02
92
.02
.02
47
.02
.47
.02
.02
.38 .20
.92
.02
.02
.02
.02
.02
.02
.92
.02
.02
.02
.02
.02
.38
.38
.20
,02
.02
.02
.92
.02
,92
.02
.02
.02
.02
.47
.02
.47
.02
.02
.02
.92
.02
.02
.02
.02
.02
.38
.38 .20
.02
.02
.02
.92
.02
.92
.02
.02
.02
.02
.47
.02
.47
.02
.02
probability of surfingfrom 0 to2
in twomoves (dotproduct)
l
= [ .05 .04 [IS].37 .19 ]
\
\
I
/
/
probabilities of surfing
from 0 toi in two moves
[ .44 .06 .12
.36 .03 ]
\
\
1
/
/
probabilities ofsurfing
from 0 toi in three moves
= [ .27 .26 .15
.25 .07 ]
\
\
!
/
/
probabilities ofsurfing
from 0 toi in20 moves
(steadystate)
Thepowermethodfor computingpageranks (limitvalues of transition probabilities)
173

174
Elements of Programming
0r
m
J3
™
^P
Program 1.6.3
Mixing a Markov chain
public class Markov
{
//
Compute page ranks after T moves.
public static void main(String[] args)
{
int T = Integer.parselnt(args[0]);
int N = Stdin.readlnt();
Stdin.readlnt();
// Read p[][] from Stdin.
doubl e[][]
p = new doubl e[N] [N];
for (int i =0;
i < N;
i++)
for (int j = 0; j < N;
j++)
p[i][j] = Stdin. readDoubleO;
// Use the power method to compute page ranks,
double[] rank = new double[N];
rank[0]
= 1.0;
for (int t = 0; t < T; t++)
{
// Compute effect of next move on page ranks,
double[] newRank = new double[N];
for (int j = 0; j < N;
j++)
{
//
New rank of page j is dot product
//
of old ranks and column j of p[][].
for (int k = 0; k < N;
k++)
newRank[j] += rank[k]*p[k][j];
}
}
for (int j
= 0;
j
< N; j++)
rank[j] = newRank[j];
T
N
p[][]
rank[]
newRank[]
for (int i
= 0;
i
< N; i++)
// Print page ranks.
StdOut.pri ntf("%8.5f", rank[i]);
StdOut.printlnO;
}
number ofiterations
|
number ofpages
transition matrix
pageranks
newpageranks
This program reads a transition matrix from standard input and computes the probabilities
that a random surfer lands on each page (page ranks) after the number of steps specified as
command-line argument.
&
• ••••••-
• —
• —- -
•••-
••
- -
Yo Java Transition < tiny.txt | Java Markov 20
0.27245 0.26515 0.14669 0.24764 0.06806
% Java Transition < tiny.txt | Java Markov 40
0.27303 0.26573 0.14618 0.24723 0.06783
»^v-v
^^^^^^^^^^^^^^^^^^^s^i^^S^IW^^^^^^^^^^^^rf
;j.:S^:
^••ftlfpl

1.6 Case Study: Random Web Surfer
0
.002
1
.017
2
.009
3
.003
4
.006
5
.016
6
.066
7
.021
8
.017
9
.040
10
.002
11
.028
12
.006
13
.045
14
.018
15
.026
16
.023
17
.005
18
.023
19
.026
20
.004
21
.034
22
.063
23
.043
24
.011
25
.005
26
.006
27
.008
28
.037
29
.003
30
.037
31
.023
32
.018
33
.013
34
.024
35
.019
36
.003
37
.031
38
.012
39
.023
40
.017
41
.021
42
.021
43
.016
44
.023
45
.006
46
.023
47
.024
48
.019
49
.016
,l...lllll.l.llll.ll.llli..il.lllill.lillllll.llll
6
22
Pageranks with histogram for a larger example
175

176
Elements of Programming
insteadof the tens of thousands of iterationsneededby RandomSurfer. Another 20
multiplicationsgives the resultsaccurateto three decimalplaces, ascomparedwith
millions of iterations for RandomSurfer, and just a fewmore givethe results to full
precision (see Exercise 1.6.6).
Markov chainsare well-studied, but their impact on the web wasnot truly felt un
til 1998, when two graduate students, Sergey Brin and Lawrence Page, had the au
dacity to build a Markov chain and compute the probabilities that a random surfer
hits each page for thewhole web. Their work revolutionized web search and is the
basisfor the pageranking method usedbyGoogle,the highlysuccessful websearch
companythat they founded. Specifically, the company periodicallyrecomputesthe
random surfer's probability for each page.Then, when you do a search, it lists the
pages related to your search keywords in order of these ranks. Such page ranks
now predominate because they somehow correspond to the expectations of typi
cal web users, reliably providing them with relevant web pages for typical searches.
The computation that is involved is enormously time-consuming, due to the huge
number of pages on the web,but the result has turned out to be enormously profit
able and well worth the expense. The method used in Markovis far more efficient
than simulating the behavior of a random surfer, but it is still too slow to actually
compute the probabilities for a huge matrix corresponding to all the pages on the
web.That computation is enabledby better data structures for graphs (seeChapter
4).
Lessons
Developing a full understanding of the random surfer model is beyond
the scope of this book. Instead, our purpose is to show you an application that in
volveswriting a bit more code than the short programs that we have been using to
teach specificconcepts. What specificlessons can we learn from this case study?
We already have afull computational model Primitive types ofdataandstrings,
conditionals and loops, arrays, and standard input/output enable you to address in
teresting problems of all sorts. Indeed, it is a basic precept of theoretical computer
science that this model suffices to specifyany computation that can be performed
on any reasonable computing device.In the next two chapters, we discuss two criti
calwaysin which the model has been extended to drastically reduce the amount of
time and effort required to develop large and complex programs.

1.6 Case Study: Random Web Surfer
177
Data-driven code isprevalent. Theconcept of using standardinput and output
streams and saving data in files is a powerful one. Wewrite filters to convert from
one kind of input to another, generatorsthat can produce hugeinput files for study,
and programs that can handle a wide variety of different models.Wecan savedata
for archivingor later use.Wecan alsoprocessdata derivedfrom some other source
and then save it in a file, whether it is from a scientific instrument or a distant
website.The concept of data-driven code isan easyand flexible wayto support this
suite of activities.
Accuracy can be elusive. It is a mistake to assume that a program produces ac
curate answers simply because it can print numbers to many decimal places of
precision.Often, the most difficultchallenge that we face is ensuring that we have
accurate answers.
Uniform random numbers are only a start. When we speak informally about
random behavior,we often are thinking of something more complicated than the
"every value equally likely" modelthat Math. random() gives us.Manyof the prob
lems that weconsiderinvolve workingwith random numbers from other distribu
tions, such as RandomSurfer.
Efficiency matters. It isalso amistake to assume thatyourcomputer issofast that
it can do any computation. Someproblemsrequiremuch more computational ef
fort than others. Chapter 4 is devoted to a thorough discussion of evaluating the
performance of the programs that you write. We defer detailed consideration of
such issues until then, but remember that you always need to have some general
idea of the performance requirements of your programs.
Perhapsthe most important lessonto learn from writing programs for complicated
problems likethe examplein this sectionisthat debugging isdifficult. The polished
programs in the book mask that lesson, but you can rest assured that each one is
the product of alongbout of testing,fixing bugs,and running the programs on nu
merous inputs. Generally we avoid describing bugs and the process of fixing them
in the text becausethat makesfor a boring account and overlyfocuses attention on
bad code,but you can find some examplesand descriptions in the exercises and on
the booksite.

178
Elements of Programming
1.6.1
ModifyTransition to take the leap probability from the command line
and use your modified version to examine the effecton page ranks of switching to
an 80-20 rule or a 95-5 rule.
1.6.2
ModifyTransi ti on to ignore the effectof multiple links. That is, if there
are multiple links from one pageto another, count them as one link. Create a small
examplethat showshow this modification can change the order of page ranks.
1.6.3
ModifyTransi ti on to handle pageswith no outgoing links,by fillingrows
corresponding to such pageswith the value UN.
1.6.4
The code fragment in RandomSu rfer that generatesthe random move fails
if the probabilities in the row p[page] do not add up to 1.Explainwhat happens in
that case,and suggesta wayto fixthe problem.
1.6.5
Determine, to within a factor of 10, the number of iterations required by
RandomSurfer to compute page ranks to four decimal places and to five decimal
places for tiny.txt.
1.6.6.
Determine the number of iterations required by Markovto compute page
ranks to three decimal places, to four decimal places,and to ten decimal placesfor
tiny.txt.
1.6.7
Download the file medi urn. txt from the booksite (which reflects the 50-
page example depicted in this section) and add to it linksfrom page 23 to every
other page.Observethe effect on the pageranks, and discussthe result.
1.6.8
Add to medi um. txt (seethe previous exercise) links topage 23fromevery
other page, observe the effecton the page ranks, and discuss the result.
1.6.9
Suppose that your page is page 23 in medium. txt. Is there a link that you
could add from your page to some other page that would raise the rank of your
page?
1.6.10 Suppose that your page is page 23 in medium. txt. Is there a link that you
could add from your page to some other page that would lower the rank of that
page?

1.6 Case Study: Random Web Surfer
1.6.11 UseTransi ti on and RandomSurfer to determine the transition probabili
ties for the eight-page example shown below.
1.6.12 UseTransi ti on and Markov to determine the transition probabilities for
the eight-page example shown below.
Eight-page example
179

Elements of Programming
:SCreati\^lB^eB3^s
1.6.13 Matrix squaring. Write a program like Markov that computes page ranks
by repeatedlysquaringthe matrix, thus computing the sequence p, p2,p4,p8, p16,
and so forth.Verify that allofthe rowsin the matrix convergeto the same values.
1.6.14 Random web. Write a generator forTransi ti on that takes asinput a page
count Nand a link count Mand prints to standard output Nfollowed by Mrandom
pairsof integers from 0 to N-l. (See Section 4.5 for a discussion of more realistic
web models.)
1.6.15 Hubs and authorities. Add to your generator from the previous exercise a
fixed number of hubsy which have links pointing to them from 10% of the pages,
chosen at random, and authorities^ which havelinks pointing from them to 10%of
the pages. Compute pageranks.Which rank higher,hubs or authorities?
1.6.16 Page ranks. Design an arrayof pagesand links where the highest-ranking
pagehas fewerlinks pointing to it than some other page.
1.6.17 Hittingtime. The hitting time for a pageis the expected number of moves
between times the random surfervisits the page.Run experiments to estimate page
hitting times forti ny. txt, comparewith page ranks, formulate ahypothesis about
the relationship,and test your hypothesis on medium. txt.
1.6.18 Covertime. Write a program that estimates the time required for the ran
dom surfer to visit every pageat least once, starting from a random page.
1.6.19 Graphical simulation. Create a graphical simulation where the size of the
dot representingeachpageis proportionalto its rank. To make your program data-
driven, design a file format that includes coordinates specifying where each page
should be drawn. Test your program on medium. txt.

1.6 Case Study: Random Web Surfer
181

^^^*^^Mi«m^^

Functions and Modules
is^iip^'^
••
mfim§S§li|§l
Mil
2.1
Static Methods
184
2.2
Libraries and Clients
218
2.3
Recursion
254
2.4
Case Study: Percolation
286
This chapter iscentered on a constructthat hasasprofound an impact on con
trol flow asdo conditionals and loops: thefunction, which allows us to trans
fercontrol backand forth between different pieces of code. Functions (which are
known as static methods in Java) are important because they allow us to clearly
separate tasks within a program and because theyprovide a general mechanism
that enables us to reuse code.
We group functions together in modules, which we cancompile independent
ly. We usemodulesto breaka computational taskintosubtasks ofa reasonable size.
You will learnin thischapter howto build modules ofyourown and to usethem,
in a style of programming known asmodularprogramming.
Some modules aredeveloped withtheprimary intentof providing code that
canbe reusedlaterby manyother programs. We referto suchmodulesas libraries.
In particular, weconsider in thischapter libraries forgenerating randomnumbers,
analyzing data, and input/output for arrays. Libraries vastly extend the setof op
erations that we use in our programs.
We pay special attention to functions that transfer control to themselves. This
process isknownas recursion. Atfirst, recursion mayseem counterintuitive, but it
allows us to develop simple programs that canaddress complex tasks that would
otherwise be much more difficult to handle.
Wheneveryou can clearly separate tasks within programs, you should doso. We
repeat this mantra throughoutthischapter, and end the chapter with an example
showing how a complex programming task can be handled by breaking it into
smallersubtasks, then independentlydeveloping modules that interact with one
another to address the subtasks.
183

Functions and Modules
2.1
Static Methods
The Java construct for implementing functions is known as the staticmethod. The
modifier static distinguishes this kind of method from the kind discussed later
in Chapter3—we willapplyit consistently fornowand discuss the difference then.
You haveactuallybeen usingstaticmeth-
ods since the beginning of this book,
iu
Newton>s method (revisited). . . .186
from printing with System, out. print-
212
Gaussian functions
.195
ln() to mathematical functions such as
2.1.3
Coupon collector (revisited) ... .197
Math.absO and Math.sqrtO to all of
2.1.4
Playthat tune (revisited)
205
the methods in Stdln, StdOut, StdDraw,
Programs inthis section
and StdAudio. Indeed, every Java pro
gram that you have written has a static
method named mai n(). In this section, youwilllearn how to define and usestatic
methods.
In mathematics, a function maps a value of a specified type (the domain)
to another value of another specified type (the range). For example, the function
f(x) =x2 maps 2 to 4, 3 to 9,4 to 16, and so forth. At first, we work with static
methods that implement mathematical functions, because they are so familiar.
Many standard functions are implemented inJava's Math library, but scientists and
engineers work with a broad variety of mathematical functions, which cannot all
be included in the library. Atthe beginning of this section, you will learn howto
implement and usesuch functions on your own.
Later, youwill learn thatwe candomore withstatic methods thanimplement
mathematical functions: static methods can have strings and other types as their
range or domain, andthey canhave side effects such asproducing output. We also
consider in this section how to use static methods to organizeprograms and thus
to simplify complicated programming tasks.
Static methods supportakey concept thatwill pervade yourapproach to pro
gramming from thispointforward: Wheneveryou can clearly separate tasks within
programs, you should do so. We will beoveremphasizing thispointthroughout this
section andreinforcing itthroughoutthisbook.Whenyouwritean essay, youbreak
it upintoparagraphs; when youwrite aprogram,youwill breakit upintomethods.
Separating a larger task into smaller ones is much more important in program
mingthan in writing, because it greatly facilitates debugging, maintenance, and re
use, which are all critical in developinggood software.

2.1
Static methods
Using and defining static methods
As you know from using Java's Math li
brary, the useofstaticmethods iseasyto understand. Forexample, whenyouwrite
Math. abs(a-b) in a program, the effect isasifyouwere to replace that codebythe
value that iscomputed byJava's Math. abs() methodwhen presented withtheval
ue a-b. This usage is so intuitivethat wehave hardlyneededto comment on it. If
youthink about whatthe system hasto do to create this effect, youwill see that it
involves changing aprogram's controlflow. Theimplications ofbeing able tochange
thecontrolflow in thisway isasprofound asdoing soforconditionals and loops.
Youcan define static methods other than mai n() in a .j ava file, as illustrated
in Newton (Program 2.1.1). This implementation isbetter thanour original imple
mentation of Newton's algorithm (Program 1.3.6) because it clearly separates the
two primarytasks performedbythe program: calculating the squareroot and in
teracting withtheuser. Wheneveryou can clearlyseparate tasks withinprograms, you
should do so. The code here differs from Program
_,
1.3.6in two additional respects. First, sqrt() re
turns Doubl e. NaN when itsargument isnegative;
second,mai n() tests sqrt() not just for one val
ue, but for all the values given on the command
line. A static method must return a well-defined
value foreachpossible argument, andtaking mul
tiplecommand-line arguments facilitates testing
that Newton operates as expectedfor various in
put values.
While Newton appeals to our familiarity
with mathematical functions, we will examine
it in detailso that you can think carefully about
whata staticmethod isand howit operates.
public class Newton
{
185
c
public static double sqrt(double c)
{
if (c < 0) return Double.NaN;
double err = le-15;
double t
= c;
while (Math.abs(t - c/t) > err * t)
t
= (c/t + t) /
2.0;
return t;
}
J
1
public static void main(String[] args)
{
int N = args.length;
doubled
a = new double[N];
for (int i
= 0;
i
< N; i++)
a[il = Double.parseDouble(args[i]);
for (int i =0;
i
< N; i++)
{
double x =(sqrt(a[i]);)-
StdOut.println(x);
Controlflow. Newton comprises twostaticmeth
ods: sqrt() and main(). Even though sqrt()
appears first in the code, the first statement exe
cutedwhen the program is executed is,as always,
the first statement in mai n(). The next few state
mentsoperate asusual, except thatthecode sqrt(a[i ]), which isknownasafunc
tion call on the staticmethod sqrt(), causes a transfer ofcontrol (to the firstlineof
code in sq rt()), each time that it is encountered. Moreover, the value of c within
Flowofcontrolfor a callon a staticmethod

186
Wi
m
S
public class Newton
{
public static double sqrt(double c)
{
// Compute the square root of c.
if (c < 0) return Double.NaN;
double err = le-15;
double t
o c;
while (Math.abs(t - c/t) > err * t)
t
= (c/t + t) /
2.0;
return t;
}
public static void main(String[] args)
{
// Print square roots of arguments.
int N = args.length;
doubled
a = new double[N];
for (int i
= 0;
i
< N; i++)
a[i] o Double.parseDouble(args[i]);
for (int i
= 0; i
< N; i++)
{
// Print square root of ith argument.
double x = sqrt(a[i]);
StdOut.println(x);
}
}
}
Functions and Modules
err
t
desired precision
current estimate
^f^W^^^^^i^^s^^W
N
a[]
argument count
argument 1
This program defines two static methods, one named sqrtO that computes the square root
ofits argument using Newton's algorithm (see Program 1.3.6) and one named mai n(), which
tests sqrt () on command-line argument values. The constant values NaN and Infi nity stand
for "not a number" andinfinity, respectively.
1.0
1.414213562373095
1.7320508075688772
1000.000499999875
% java Newton NaN Infinity 0 -0 -2
NaN
Infinity
0.0
-0.0
NaN
^ssSfSSjSESP»($SMg?s8&£P
mmmmmmmmmm
i

2.1
Static methods
187
sq rt() is initialized to the value of a [i ] within main() at the time ofthe call. Then
the statementsin sqrt() are executed in sequence, as usual, until reaching a re
turn statement, which transfers control back to the statement in main() contain
ing the call on sq rt(). Moreover, the effectof the callis the same as if sq rt(a[0] )
were a variable whose value is the value of t in sqrt() when the return t state
ment is executed. The end result exactlymatches our intuition: the first value as
signed to xandprintedispreciselythevalue computed bycode in sqrt() (withthe
value of c initialized to a[0]). Next, the same process transfers control to sqrt
again (with the value of c initialized to a[l]), and so forth.
Function call trace. One simple approach to fol-
main({l, 2})
lowing the control flow through function calls is
sqrt(l)
....^i^rr...
,
Math.abs(O)
to imagine that each function prints its name and
return 0.0
argumentwhen it iscalledand its return value just
return 1.0
before returning, with indentation added oncalls
sqrM(?u u ^ n^
it.
Math.absCl•0)
and subtracted on returns. The result is a special
return 1.0
case of the process of tracing a program by print-
Math •abs C1•416666666666667)
4,
,
r^
. i_i
f. i
ti
return 1.416666666666667
ing the values of its variables, which we have been
using since Section 1.2.However, the added inden-
return 1.414213562373095
tation exposes the flow of the control, and helps
return
us check that each function has the effect that we
Function calltracefor java Newton 1 2
expect. Adding calls on StdOut. pri ntf() to trace
a program's control flow in this way isa fine way to beginto understand what it is
doing(see Exercise 2.1.7). Ifthe returnvalues matchour expectations, weneednot
trace the function code in detail,savingus a substantialamount of work.
Anatomy ofa static method. The square root function maps anonnegative real
numberto a nonnegative realnumber; the sqrt() static methodin Newton maps
a double to a double. The firstline of a staticmethod,known asits signature, de
scribes this information. The typeof the domain is indicated in parentheses after
thefunction name, along witha namecalled an argument variable that wewill use
to refer to the argument. The type of the range is indicatedbefore the function
name—we can put code that calls this function anywhere wecould put an expres
sion of that type.We willdiscuss the meaning of the pub! i c keyword in the next
sectionand the meaningof the stati c keyword in Chapter3.(Technically, the sig
nature in Java does not include thesekeywordmodifiersor the return type, but we

188
leave that distinction for experts.)
Following the signature is the
body of the method, enclosed
in braces. For sqrt()
this code
is the same as we discussed in
Section 1.3, except that the last
statement is a return statement,
which causes a transfer of control
back to the point where the static
method was called. For any given
initial value ofthe argument vari
able, the method must compute
a return value. The variables that
aredeclared and usedin thebodyofthemethodareknownaslocal variables. There
are two local variables in sqrt (): er r and t. These variables are local to the code in
the bodyof the methodand cannotbe usedoutsideof the method.
Properties of static methods
Forthe restof this chapter, your programming
willbe centered on creatingand using static methods, so it is worthwhile to con
sider in more detail their basic properties.
Terminology. As wehave been doing throughout, it isuseful to drawa distinction
between abstract concepts and Java mechanisms to implement them (the Java i f
statement implements the conditional, the whi 1e statementimplements the loop,
and so forth). There are several conceptsrolled up in the idea of a function, and
Java constructs correspondingto each,assummarized in the following table:
signature
local
variables z
method^
body
Functions and Modules
return
type
method
name
argument
type
argument
variable
\^_i^
public static [doubleIIsqrtl ( Idouble cl)|
if (c < 0) return Double.
;
NaN;
>
err
\
* t)
Idouble err|= le-15
Idouble3= c;
while
t
=
(Math.abs(t - c/t)|
(c/t + t)
/' 2.0;
>
|returnus
call on another method
return statement
Anatomy ofa static method
concept
Java construct
description
function
static method
mapping
domain
argument type
set ofvalues where function is defined
range
return type
set ofvalues a function can return
formula
method body
function definition
When we use a symbolicname in a formula that definesa mathematical function
(suchas/(x) = 1+x + x2), the symbolisa placeholderfor somevaluein the domain

2.1
Static methods
that will be substituted into the formula when computing the function value. In
Java, the symbol that we use is the name of an argument variable. It representsthe
particularvalue of interest where the function is to be evaluated.
Scope. The scope of a variable name is the set of statements that can referto that
name. The general rule in Java is that the scopeofthe variables in ablock of state
ments islimited to the statementsin thatblock.In particular, the scopeofavariable
in a staticmethod is limited to that method's body.Therefore, you cannot referto
a variable in one static method that is declared in another. If the method includes
smaller blocks—forexample, the body of an i f or a for statement—the scope of
anyvariables declared in one ofthoseblocksislimitedto justthe statementswith
in the block. Indeed,it iscommon practice to usethe samevariable names in inde
pendent blocks of code. When we do so,we are declaring different independent
variables. For example,we havebeen following this practice when we use an index
i in two differentfor loopsin the sameprogram. A guiding principle when design
ing software is that eachvariable should be defined so that its scope is as small as
possible. One ofthe important reasons that we use staticmethods is that they ease
debuggingby limiting variable scope.
public class Newton
{
public static double sqrt(double c)
{
if (c < 0) return Double.NaN;
double err = le-15;
scope of
^ double t = c;
c, err, and t
while (Math.abs(t - c/t) > err * t)
t
= (c/t + t) /
2.0;
return t;
}
public static void main(String[] args)
{
int N = args.length;
doubled
a = new double[N];
for (int i
= 0;
i
< N; i++)
a[i] = Double.parseDouble(args[i]);
scope of
\
args[LN,fl/K/a[]
f{or (int 1' ° 0; i <N; i++)
scope ofiv
double x = sqrt(a[i]);
StdOut.println(x); ^^\
^^
}
- scope ofi andx
Scope oflocal andargument variables
thiscodecannotrefer to
args[], N, ora[]
this code cannot referto
"^
c[],err, ort
i two different
variables
189

190
Functions and Modules
Argument variables. You can use argument variables anywhere inthe code inthe
body of the function in the same wayyou use local variables. The only difference
between an argument variable and alocal variable is that the argument variable is
initialized with the argument value provided by the calling code. This approach
is known aspassby value. The method works with the valueof its arguments, not
the arguments themselves. One consequence of this approach isthat changing the
value of an argument variable within a static method has no effect on the calling
code.An alternative known aspass by reference, where the method actuallyworks
with the calling code's variable, is favored in some programming environments
(and actually is akinto the wayJava works for nonprimitive arguments, aswe will
see).For clarity, we do not change argumentvariables in the codein this book: our
staticmethods take the values ofargumentvariables and producearesult.
Multiple methods. You can define as manystatic methods as youwantina .java
file. Each has a body that consists of a sequence of statements enclosed in braces.
These methods areindependent, exceptthat they may refer to each other through
calls. They can appearin any order in the file.
Calling other static methods. Asevidencedbymai n() calling sqrt() and sqrt()
calling Math, abs() in Newton, any static method defined in a .Java file can call
anyother staticmethod in the same file or anystatic method in a Java librarysuch
as Math. Also, as we see in the next section, a static method can call a static method
in any .Java file in the same directory. In Section 2.3,we considerthe ramifica
tions ofthe idea that a static method can even callitself.
Multiple arguments. Like amathematical function, aJava static method can take
on more than one argument,andthereforecanhavemore than one argument vari
able. For example,the following method computes the length ofthe hypotenuse of
aright triangle with sidesoflength a and b:
public static double hypotenuse(double a, double b)
{
return Math.sqrt(a*a + b*b);
}
Although the argument variables areof the same type in this case, in generalthey
can be of different types. The type and the name of each argument variableis de
claredin the function signature,separated by commas.

2.1
Static methods
absolute value ofan
i nt value
absolute valueofa
double value
primality test
hypotenuse of
a righttriangle
Harmonic number
uniform random
integer in [0, N)
draw a triangle
public static int abs(int x)
{
if (x < 0) return -x;
else
return
x;
}
public static double abs(double x)
{
if (x < 0.0) return -x;
else
return
x;
}
public static boolean isPrime(int N)
{
if (N < 2) return false;
for (int i
= 2;
i
<= N/i;
i++)
if (N % i
== 0) return false;
return true;
}
public static double hypotenuse(double a, double b)
{
return Math.sqrt(a*a + b*b);
}
public static double H(int N)
{
double sum = 0.0;
for (int i
= 1;
i
<= N; i++)
sum += 1.0 / i;
return
sum;
}
public static int uniform(int N)
{
return (int)
(Math.random() * N);
}
public static void drawTriangle(double xO,
double y0,
double xl, double yl,
double x2, double y2
)
{
StdDraw.line(xO, yO, xl, yl);
StdDraw.line(xl, yl, x2, y2);
StdDraw.line(x2, y2, xO,
yO);
}
Typical codefor implementingfunctions
191

192
Functions and Modules
Overloading. Static methods whose signatures differ aredifferent static methods.
For example,we often want to define the same operation for values of different
numeric types, as in the following static methods for computing absolute values:
public static int abs(int x)
{
if (x < 0) return -x;
else
return
x;
}
public static double abs(double x)
{
if (x < 0.0)
return -x;
else
return
x;
}
These are two different methods, but sufficientlysimilar so as to justify using the
same name (abs). Usingone name for two static methods whose signatures differ
is known as overloading, and is common in Java programming. For example, the
Java Math library uses this approach to provide implementations of Math.abs(),
Math.min(), and Math.max() for all primitive numeric types. Another common
use of overloading is to define two different versions of a function, one that takes
an argument and another that uses a default value of that argument.
Single return value. Like a mathematical function, a Java staticmethod canpro
videonlyone return value,ofthetypedeclaredin the method signature.Thispolicy
isnot asrestrictive asit might seem.First,youwillseein Chapter 3 that manytypes
of data in Java can contain more information than a value of a single primitive
type. Second,you will see later in this section that we can use arrays as arguments
and return values for static methods.
Multiple return statements. Control goes backto the calling programassoonas
the first return statement in a static method is reached. Youcan put return state
ments wherever you need them, as in sqrt(). Even though there may be multiple
retu rn statements, anystatic method returns a singlevalue each time it is invoked:
the value following the first return statement encountered. Some programmers
insist on having only one return per function, but we are not so strict in this
book.

2.1 Static methods
193
Side effects. Astaticmethodmayusethekeyword voidasitsreturn type, to indi
cate that it has no return value.An explicit return is not necessaryin a voi d static
method: control returns to the caller after the last statement. In this book, we use
voi d static methods for two primary purposes:
• For I/O, using Stdln, StdOut, StdDraw, and StdAudio
• To manipulate the contents of arrays
You have been using voi d static methods for output since mai n() in Hel1oWorl d,
and we will discuss their use with arrays later in this section.A voi d static method
issaidto produce side effects (consumeinput, produceoutput, or otherwisechange
the state of the system). For example, the main() static method in our programs
has a voi d return type becauseits purpose is to produce output. It is possible in
Java to write methods that haveother side effects, but wewillavoiddoing so until
Chapter 3, where we do so in a specific manner supported by Java. Technically,
voi d static methods do not implement mathematical functions (and neither does
Math, random() or the methods in Stdln, which take no arguments but do pro
duce return values).
Implementing mathematical functions
Why not just use the static meth
ods that are definedwithin Java, such asMath.sqrt () ?The answerto this question
isthat wedousesuch implementationswhentheyarepresent.Unfortunately, there
are an unlimited number of mathematical functionsthat we maywish to use and
only a small set of basic functions in the library. When you encounter a function
that is not in the library,you need to implement a correspondingstatic method.
As an example, we consider the kind of code required for a familiar and im
portant application that is of interest to many high school and college students in
the United States. In a recent year, over 1 millionstudents took a standard college
entrance examination. Scores range from 400 (lowest) to 1600 (highest) on the
multiple-choiceparts of the test.Thesescores playa rolein makingimportant deci
sions: for example,student athletes are required to havea score of at least 820,and
the minimum eligibility requirement for certain academic scholarships is 1500.
What percentage of test takersare ineligible for athletics? What percentage are eli
gible for the scholarships?
Twofunctions from statistics enable us to compute accurate answers to these
questions. The Gaussian (normal) distribution function is characterized by the fa
miliar bell-shaped curve and defined by the formula 4>(x) = e~x2^2lyJ2iv. The cu
mulative Gaussian distribution function <$>(z) is defined to be the area under the

194
Functions and Modules
curvedefined by <j>(x) abovethe x-axisand to the left of the verticallinex-z. These
functions play an important role in science, engineering, and finance because they
ariseas accurate models throughout the natural world and becausethey are essen
tial in understanding experimental error.
In particular, these functions are known to accurately describe the distribu
tion of test scores in our example,as a function of the mean (averagevalue of the
scores) and the standard deviation (square root of the sum of the squares of the
differences between each score and the mean), which are
published each year. Given the mean |x and the standard
deviation a of the test scores, the percentage of students
with scoreslessthan a givenvaluez is closelyapproximated
by the function <£((z - |i)/a). Staticmethods to calculate <J>
and $ are not available in Java's Math library, so we need to
develop our own implementations.
Closed form. In the simplest situation, we havea closed-
form mathematical formula defining our function in terms
of functions that are implemented in the library. This situ
ation is the case for <|>—the Java Math library includes
methods to compute the exponential and the square root
functions (and a constant value for it), so a static method
phi () corresponding to the mathematical definition is easy
to implement (seeProgram 2.1.2).
No closedform. Otherwise, wemayneed a more compli
cated algorithm to compute function values. This situation
is the casefor <I>—no closed-form expression existsfor this
function. Such algorithms sometimes follow immediately
from Taylor seriesapproximations, but developingreliably
accurate implementations of mathematical functions is an art that needs to be ad
dressed carefully, taking advantage of the knowledge built up in mathematics over
the past several centuries. Many different approaches have been studied for evalu
ating O. For example,a Taylor seriesapproximation to the ratio of <£ and <(> turns
out to be an effective basis for evaluating the function:
*(z) = 1/2 +
<(>(z) (z + z3/3 + z5/(3-5) + z7/(3-5-7) +...).
distribution <\>
area is0>{zq)
Gaussian probabilityfunctions

2.1
Static methods
195
Program2.1.2
Gaussianfunctions
public class Gaussian
{
// Implement Gaussian (normal) distribution functions
public static double phi(double x)
{
return Math.exp(-x*x/2) / Math.sqrt(2*Math.PI);
}
public static double Phi(double z)
{
if (z < -8.0) return 0.0;
if (z >
8.0) return 1.0;
double sum = 0.0, term = z;
for (int i
= 3;
sum
!= sum + term;
i
+= 2)
{
sum
= sum + term;
term = term * z
* z
/ i;
}
return 0.5 + phi(z) * sum;
}
public static void main(String[] args)
{
double z
= Double.parseDouble(args[0]);
double mu
= Double.parseDouble(args[1]);
double sigma = Double.parseDouble(args[2]);
Std0ut.printf("%.3f\n", Phi((z - mu) /
sigma));
}
cumulated sum
current term
This code implements theGaussian (normal) density (phi) andcumulative distribution (Phi)
functions, which arenot implemented inJava's Math library. The phi () implementation fol
lowsdirectlyfrom its definition, and the Phi () implementation uses a Taylor series and also
callsphi () (seeaccompanying textat leftand Exercise 1.3.36).
%Mi
% Java Gaussian 820 1019 209
0.171
% Java Gaussian 1500 1019 209
0.989
% Java Gaussian 1500 1025 231
0.980

196
Functions and Modules
This formula readilytranslates to the Java code for the static method Phi () in Pro
gram2.1.2. For small (respectivelylarge)z,the valueisextremelycloseto 0 (respec
tively1),so the code directlyreturns 0 (respectively 1);otherwise, it usesthe Taylor
series to add terms until the sum converges.
Running Gaussian with the appropriate arguments on the command line
tells us that about 17% of the test takers were ineligible for athletics and that only
about 1% qualified for the scholarship.In a year when the mean was 1025 and the
standard deviation 231,about 2% qualifiedfor the scholarship.
Computing with mathematical functions of all sorts has always played a central
role in science and engineering. In a great many applications, the functions that
you need are expressed in terms of the functions in Java's Math library as we have
just seen with phi (), or in terms of Taylor series approximations that are easyto
compute, as we havejust seen with Phi (). Indeed, support for such computations
has playeda central role throughout the evolution of computing systemsand pro
gramming languages. You willfind many exampleson the booksite and throughout
this book.
Using static methods to organize code
Beyond evaluating mathematical
functions, the process of calculating a result value on the basis of an input value is
important as a general technique for organizing control flow in any computation.
Doing so is a simple example of an extremely important principle that is a prime
guiding force for any good programmer: Whenever you can clearly separate tasks
within programs, youshould doso.
Functions are natural and universal for expressing computational tasks. In
deed, the "bird's-eye view"of a Javaprogram that we began with in Section 1.1was
equivalent to a function: webegan by thinking of a Javaprogram as a function that
transforms command-line arguments into an output string. This view expresses
itself at many different levelsof computation. In particular, it is generally the case
that a long program is more naturally expressed in terms of functions instead of as
a sequence ofJavaassignment, conditional, and loop statements. With the ability to
definefunctions, we can better organizeour programs by defining functions within
them when appropriate.
For example, Coupon(Program 2.1.3) is a version ofCouponCol1ector (Pro
gram 1.4.2) that better separates the individual components ofthe computation. If
you study Program 1.4.2,you will identify three separate tasks:

2.1
Static methods
197
KS
Program 2,1.3
Coupon collector (revisited)
1
public class Coupon
{
public static int uniform(int N)
{
// Generate a random integer between 0 and N-1.
return (int)
(Math.random()
* N);
}
public static int collect(int N)
{
// Collect coupons until getting one of each value.
boolean[] found = new boolean[N];
int cardcnt = 0, valcnt = 0;
while (valcnt < N)
found[]
{
int val = uniform(N);
cardcnt++;
if (!found[val]) valcnt++;
found[val] = true;
cardcnt
valcnt
val
cumulated sum
number collected
number thatdiffer
current value
}
return cardcnt;
}
public static void main(String[]
args)
{
// Print the number of coupons collected
// to get N different coupons.
int N = Integer.parselnt(args[0]);
int count = collect(N);
StdOut.pri ntln(count) ;
}
-mmmmmmmmm
This version ofProgram 1.4.2illustrates the style ofencapsulating computations instatic meth
ods. This code has the sameeffect as CouponCol lector, butbetter separates thecode into its
three constituent pieces: generating a random integer between 0 andN-1, running a collection
experiment, and managing theI/O.
% Java Coupon 1000
6522
% Java Coupon 1000
6481
% Java Coupon 1000000
12783771
*mmumuMm&MmmMm
I

198
Functions and Modules
• Given N, compute a random coupon value.
• GivenN, do the coupon collection experiment.
• GetN fromthe command line,then compute and print the result.
Coupon rearranges the codein CouponCol 1ect to reflect the reality that thesethree
functions underlie the computation.
With this organization, we couldchange uniform() (for example, we might
want to draw the random numbers from a different distribution) or main() (for
example, wemight wantto takemultipleinputsorrun multipleexperiments)with
out worrying about the effect of anychanges on col 1ect().
Usingstatic methods isolates the implementation of eachcomponent of the
collection experiment from others, or encapsulates them. Typically, programs have
many independent components,which magnifies the benefits of separating them
into different static methods. We will discuss these benefits in further detail after we
have seen several other examples, but you certainlycan appreciate that it is better
to express a computation in a programby breaking it up into functions, just asit
isbetterto express anideain anessay by breaking it up into paragraphs. Whenever
youcan clearly separate tasks within programs, youshould do so.
ImplemeBtiiug static methods for arrays
A static method cantakean array
asan argumentor asareturnvalue. This capability is a special case of Java's object
orientation,which isthe subjectofChapter3.We considerit in the presentcontext
because the basicmechanismsare easyto understandandto use,leading usto com
pactsolutionsto a number of problems that naturallyarise when we use arrays to
help us process large amounts of data.
Arrays as arguments. When a static method takes an array as an argument, it
implements a function that operates on an arbitrary number ofvaluesofthe same
type. For example,the following static method computes the mean (average) value
of an arrayof doubl e values.
public static double mean(doubled
a)
{
double sum =0.0;
for (int i = 0; i < a.length; i++)
sum = sum + a[i];
return sum / a.length;
}

2.1
Static methods
199
Wehavebeen using arraysas arguments from the beginning.The code
public static void main(String[] args)
defines main() as a static method that takes an array of strings as an argument
and returns nothing. Byconvention, the Java system collects the strings that you
type after the program name in the Java command into an array args [] and calls
main() with that array as argument. (Most programmers use the name args for
the argument variable,even though any name at allwould do.) Within mai n(), we
can manipulate that array just like any other array. The mai n() method in Newton
(Program 2.1.1) is an example of such code.
Side effects with arrays. It is oftenthe case that the purposeof a static method
that takes an array as argument is to produce a side effect (changevalues of array
elements). A prototypical example of such a method is one that exchangesthe val
ues at two given indices in a given array.We can adapt the code that we examined
at the beginning of Section 1.4:
public static void exch(String[] a, int i, int j)
{
String t
= a[i] ;
a[i]
= a[j];
a[j]
= t;
}
This implementation stems naturally from the Java array representation. The argu
ment variable in exch () is a reference to the array, not to all of the array's values:
when you pass an array as argument to a static method, you are giving it the op
portunity to operate on that array (not a copyof it).Asecondprototypical example
of a static method that takes an array argument and produces side effects is one
that randomly shuffles the valuesin the array, using this version of the algorithm
that we examined in Section 1.4 (and the exch() and uniformO methods just
defined):
public static void shuffle(String[] a)
{
int N = a.length;
for (int i =0;
i
< N; i++)
exch(a, i,
i
+ uniform(N-i));
}

200
find themaximum
of thearray values
dotproduct
exchange two elements
in an array
print a ID array
(and its length)
reada 2D array
of double values
(with dimensions)
in row-major order
Functions and Modules
public static double max (doubled
a)
{
double max = Double.NEGATIVE_INFINITY;
for (int i = 0;
i < a.length; i++)
if (a[i]
> max) max = a[i];
return max;
}
public static double dot(double[] a, doubled
b)
{
double sum = 0.0;
for (int i = 0;
i < a.length; i++)
sum += a[i]
* b[i];
return
sum;
}
public static void exch(String[] a, int i, int j)
{
String t
= a[i];
a[i] = a[j];
a[j] = t;
}
public static void print(doubled a)
{
StdOut.pri ntln(a.1ength);
for (int i =0; i < a.length;
i++)
StdOut.println(a[i]);
}
public static doubled []
readDouble2D()
{
int M = Stdln.readlntO;
int N = Stdln. readlntO;
doubled []
a = new double[M] [N] ;
for (int i
= 0;
i
< M;
i++)
for (int j = 0;
j < N; j++)
a[i][j] = Stdln. readDoubleO;
return a;
}
Typical codefor implementingfunctions witharrays

2.1
Static methods
201
Similarly, we will consider in Section 4.2 methods that sort an array (rearrange
its values so that they are in order). All of theseexamples highlightthe basic fact
that the mechanismfor passingarraysin Java isa call-by-reference mechanismwith
respectto the contents of the array. Unlike primitive-type arguments,the changes
that a method makes in the contents of an array arereflectedin the client program.
A method that takes an array as argument cannot change the array itself—the ref
erence is the same memory location assignedwhen the array was created, and the
length is the value set when the array wascreated—but it can change the contents
of the array to any values whatsoever.
Arrays as return values. A method that sorts,shuffles, or otherwise modifies an
array taken as argument does not haveto return a referenceto that array,because it
is changing the contents of a client array,not a copy. But there are many situations
where it is useful for a static method to provide an array as a return value. Chief
among these are static methods that createarraysfor the purpose of returning mul
tiple values of the same type to a client. For example,the following static method
produces an array of the kind used by StdAudio (seeProgram 1.5.7) that contains
values sampled from a sine waveof a given frequency (in hertz) and duration (in
seconds), sampled at the standard 44,100samples per second.
public static doubled tone(double hz, double t)
{
int sps = 44100;
int N = (int)
(sps * t);
doubled
a = new double[N+l];
for (int i
= 0;
i
<= N; i++)
a[i] = Math.sin(2 * Math.PI * i
* hz /
sps);
return a;
}
In this code, the size of the array returned depends on the duration: if the given
duration is t, the size of the array is about 44100*t. With static methods like this
one, we can write code that treats a sound waveas a single entity (an array contain
ing sampled values), as we will see next in Program 2.1.4.

202
Functions and Modules
Examples superposition of soumd waves
As discussed in Section 1.5, the
simple audio model that we studied there needs to be embellished in order to create
sound that resembles the sound producedbya musicalinstrument. Manydifferent
embellishments are possible;with staticmethods we can systematicallyapplythem
to produce sound waves that are far more complicated than the simple sine waves
that we produced in Section 1.5. As an illustration of the effective use of static
methods to solve an interesting computational problem, we consider a program
that has essentiallythe same functionality as PlayThatTune (Program 1.5.7),but
adds harmonic tones one octave above and one octave below each note in order to
produce a more realisticsound.
Chords and harmonics. Notes like concert A have a pure sound that is not very
musical, because the sounds that you are accustomed to hearing have many other
components. The sound from the guitar
string echoes off the wooden part of the
instrument, the walls of the room that
you are in, and so forth. You may think
of such effects as modifying the basic
sine wave. For example, most musical
instruments produce harmonics (the
same note in different octaves and not
as loud), or you might playchords (mul
tiple notes at the same time). Tocombine
multiple sounds, we use superposition:
simply add their waves together and res-
cale to make sure that all values stay be
tween —1 and +1. As it turns out, when
wesuperpose sine waves of differentfrequencies in this way, we can get arbitrarily
complicatedwaves. Indeed, one of the triumphs of 19th century mathematics was
the development of the idea that anysmooth periodic function can be expressedas
a sum of sine and cosine waves, known as a Fourier series. This mathematical idea
corresponds to the notion that we can create a large range of sounds with musical
instruments or our vocal chords and that all sound consists of a composition of
various oscillating curves.Any sound corresponds to a curve and any curve cor
responds to a sound, and we can createarbitrarily complex curves with superposi
tion.
A majorchord
concert A with harmonics
440.00
554.37
659.26
440.00
220.00
880.00
Superposing waves to make composite sounds

2.1
Static methods
Superposition. Since werepresent sound waves byarrays of numbersthat repre
sent their values at the same sample points, superposition is simple to implement:
weadd together their sample valuesat eachsamplepoint to produce the combined
result and then rescale. For greatercontrol,wespecify a relative weight for each of
the two waves to be added, with the property that the weightsare positiveand sum
to 1. For example, if we want the first sound to have three times the effect of the
second, we would assign the first a weight of .75 and the second a weight of .25.
Now,if one waveis in an array a[] with relative weightawt and the other is in an
array b[] with relative weight bwt, we compute their weighted sum with the fol
lowing code:
doubled
c = new double [a. length];
for (int i = 0;
i
< a.length; i++)
c[i] = a[i]*awt + b[i]*bwt;
The conditions that the weightsare positive and sum to 1 ensure that this opera
tion preserves our convention of keeping the values of all of our wavesbetween —1
and+1.
.982
-.693
.144
.374
.259
lo = tone(220,
.0041);
lo[44] = .982
hi = tone(880,
.0041);
hi[44] = -.693
h = sum(hi, lo,
.5,
.5);
h[44] = .5*lo[44]+.5*hi[44];
=
.5*.982
-
.5*.693 =
.144
A = tone(440,
.0041);
A[44] = .374
sum(A,
h,
.5,
.5);
A[44] + h[44] = .5*. 144 + .5*. 374
=
.259
Addingharmonics to concertA (180samples at 44,100 samples/sec)
203

204
Functions and Modules
Program 2.1.4 isan implementation that applies these concepts to produce a more
realisticsound than that produced byProgram 1.5.7. In order to do so,it makesuse
of functions to divide the computation into four parts:
• Given a frequency and dura
tion, create apure tone.
.
J
• Given two sound waves and
relativeweight, superpose
them.
• Given a pitch and duration,
create a note with harmonics.
• Read and play a sequence of
pitch/duration pairs from
standard input.
These
tasks
are
each
amenable
to implementation as functions,
which depend on
one another.
Each function is well-defined and
straightforward to implement. All
of them (and StdAudio) represent
sound as a series of discrete values
kept in an array, corresponding to
sampling a sound wave at 44,100
samples per second.
Up to this point, the use of
functions has been somewhat of a
notational convenience. For exam
ple, the control flow in Programs
2.1.1-2.1.3 is simple—each func
tion is called in just one place in
the code. By contrast, PlayThat-
TuneDeluxe (Program 2.1.4) is a
convincing example of the effec
tivenessofdefining functions to or
ganizea computation becausethe functions are each called multiple times. For ex
ample, the function note() callsthe function tone() three times and the function
sum() twice.Without static methods, wewould need multiple copiesof the code in
y
public class PlayThatTune
{
(r
public static double[] sum(double[] a,
doubled b,
double awt, double bwt)
{
doublet] c = new double[a.length];
for (int i
o 0;
i
< a.length; i++)
c[i] = a[i]*awt + b[i]*bwt;
return c;
fcr„
public static doublet] tone(double hz, double t)
{
int sps » 44100;
int N - (int) (sps * t);
doubled
a = new double[N+l];
for (int i
= 0;
i
<= N; i++)
a[i] - Math.sin(2 * Math.PI * i
* hz /
sps);
return a;
}
M.
public static double[] note(int pitch, double t)
{
double hz =. 440.0 * Math.pow(2. pitch / 12.0);
double[] a
°(tone(hz, t);)
double[] hi °(tone(2*hz, t);>-
double[] lo »(tone(hz/2r"t)p-
double[]
h
-(sum(hi, lo, .5, .5);>-
return(sum(a, h, .5, .5);^)-
J
public static void main(String[] args)
{
while (!Stdln.isEmpty())
{
int pitch = Stdln.readlntO;
double duration ° Stdln.readDoubleQ;
double[] a °(note(pitch, duration)Q -
StdAudi o.piay(a);
^
Flowofcontrol amongseveral staticmethods

2.1
Static methods
205
1
?3S
SI
•fet
ft?
Hi
P
*
,-:..J
Program 2.1.4
Play that Tune (revisited)
public class PlayThatTuneDeluxe
{
public static doubled
sum(double[] a, doubled
b,
double awt, double bwt)
{
// Superpose a and b, weighted.
doubled
c = new double[a.length];
for (int i
= 0;
i
< a.length; i++)
c[i] = a[i]*awt + b[i]*bwt;
return c;
}
public static doubled tone (double hz, double t)
// see text
public static doubled note(int pitch, double t)
{
// Play note of given pitch, with harmonics.
double hz = 440.0 * Math.pow(2,
pitch / 12.0);
doubled
a
= tone(hz, t);
doubled
hi = tone(2*hz, t);
doubled lo = tone(hz/2, t);
doubled
h
= sum(hi, lo,
.5,
.5);
return sum(a,
h,
.5,
.5);
}
public static void main(String[] args)
{
// Read and play a tune, with harmonics.
while (!Stdln.isEmptyO)
{
// Read and play a note, with harmonics.
int pitch = Stdln.readlntO;
double duration = Stdln.readDouble();
doubled
a = note(pitch, duration);
StdAudio.pl ay(a);
}
}
hz
a[]
hi[]
lo[]
h[]
m
frequency
pure tone
upper harmonic
lower harmonic
tone with harmonics
This code embellishes thesounds produced byProgram 1.5.7byusing static methods tocreate
harmonics, which results in a more realistic sound than the puretone.
% more el i se .txt
7
.25
6
.25
7
.25
6
.25
7
.25
% Java PlayThatTuneDeluxe < elise.txt
^mammummm

206
Functions and Modules
tone() and sum(); with static methods, we can deal directlywith concepts close
to the application. As with loops, methods have a simple but profound effect: we
have one sequence of statements (those in the method definition) executed mul
tiple times during the execution of our program—once for each time the method
is called in the control flow in mai n().
Static methods are important because they give us the ability to extend the Java
language within a program. Having implemented and debugged static methods
such as sqrt(), phi(), Phi(), mean(), abs(), exch(), shuffle(), isPrimeO,
H(), uniformO, sum(), note(), and tone(), we can use them almost as if they
were built into Java. The flexibility to do so opens up a whole new world of pro
gramming.Before, you weresafein thinking about a Java program asa sequenceof
statements. Now you need to think of a Javaprogram as a setofstaticmethods that
can call one another. The statement-to-statement control flow to which you have
been accustomed isstillpresent within staticmethods, but programs havea higher-
level control flow defined by static method calls and returns. This ability enables
you to think in terms of operations calledfor bythe application,not just the simple
arithmetic operations on primitive types that are built in to Java.
Wheneveryoucanclearly separate tasks within programs, youshould doso. The
examplesin this section (and the programs throughout the rest ofthe book) clearly
illustrate the benefits of adhering to this maxim. With static methods, we can
• Divide a long sequence of statements into independent parts.
• Reusecode without having to copy it.
• Work with higher-levelconcepts (such as sound waves).
This produces code that is easier to understand, maintain, and debug than a long
program composed solelyofJavaassignment, conditional, and loop statements. In
the next section, we discuss the idea of using static methods defined in other pro
grams, which again takesus to another levelof programming.

2. /
Static methods
Q. Whydo I need to usethe return type void? Whynot just omit the return type?
A. Java requires it; we have to include it. Second-guessing a decision made by a
programming-language designer is the first step on the road to becoming one.
Q. Can I return from a void function by using return? If so,what return value
should I use?
A. Yes.Use the statement return; with no return value.
Q. What happens if I leave out the keyword stati c?
A. As usual, the bestwayto answer a question like this isto try it yourselfand see
what happens. Here is the result of omitting stati c for sqrt() in Newton:
Newton.Java:13: non-static method sqrt(double)
cannot be referenced from
a static context
double x = sqrt(i);
A
1 error
Non-static methods are different from static methods. You will learn about the
former in Chapter 3.
Q. What happens if I write code after a return statement?
A. Once a return statement is reached, control immediately returns to the caller,
so any code after a return statement is useless. The Java compiler identifies this
situation as an error, reporting unreachabl e code .
Q. What happens if I do not include a return statement?
A. No problem, if the return type is void. In this case, control will return to the
callerafter the last statement. When the return type is not voi d, the compiler will
report a mi ssi ng retu rn statement error if there is any path through the code
that does not end in a return.
Q. This issuewith side effects and arrayspassedas arguments is confusing.Is it re
ally all that important?
207

208
Functions and Modules
A. Yes. Properly controlling side effects is one of a programmer's most important
tasks in large systems. Taking thetimeto besurethat youunderstand the difference
between passing a value (when arguments are of a primitive type) and passing a
reference (whenargumentsarearrays) willcertainlybe worthwhile. Theverysame
mechanism is used for all other types of data, as you willlearn in Chapter 3.
Q. Sowhynot just eliminatethe possibility of sideeffects by makingallarguments
pass-by-value, including arrays?
A. Think of a huge array with, say, millions of elements. Does it make sense to
copy all of those values for a static method that is just going to exchange two of
them? For this reason, most programming languagessupport passing an array to a
functionwithout creatinga copyofthe arrayelements—Matlabisa notableexcep
tion.

2.7
Static methods
2.1.1
Writea staticmethod max3 () that takesthree i nt values asarguments and
returns the value of the largestone.Addan overloadedfunction that does the same
thing with three doubl e values.
2.1.2
Write a static method odd() that takes three boolean inputs and returns
true if an odd number of inputs are true, and fal se otherwise.
2.1.3
Writeastaticmethod majori ty() that takes threeboolean argumentsand
returns true if at leasttwo of the arguments havethe valuetrue, and fal se other
wise. Do not use an i f statement.
2.1.4
Writea staticmethod eq() that takes two arrays of integers as arguments
and returns true if theycontainthe samenumber of elements and allcorrespond
ing pairs of elements are equal.
2.1.5
Write a static method areTri angul ar() that takes three doubl e values as
arguments and returns true if they couldbe the sidesof a triangle (none of them
is greater than or equal to the sum of the other two). SeeExercise 1.2.15.
2.1.6
Write a static method si gmoi d() that takesa double argument x and re
turns the doubl e value obtained from the formula 1/(1—e~x).
2.1.7
If the argument ofsqrt() in Newton (Program 2.1.1) has the value Infin-
i ty, then Newton. sqrt () returns the valueInfi ni ty, as desired. Explainwhy.
2.1.8
Add a method abs() to Newton (Program 2.1.1), change sqrt() to use
abs () instead of Math.abs (), and add print statementsto produce a function call
trace,asdescribedin the text.Hint: You needto add an argument to each function
to give the level of indentation.
2.1.9
Give the function call trace for Java Newton 4.0 9.0.
2.1.10 Write a static method lg() that takes a double value Nas argument and
returns the base 2 logarithm of N. You mayuse Java's Math library.
2.1.11 Write a static method lg() that takes an int value Nas argument and re
turns the largest i nt not larger than the base-2 logarithm of N. Do not use Math.
209

210
Functions and Modules
2.1.12 Write a static method si gnum() that takes an i nt value Nas argument and
returns -1 if Nis less than 0,0 if Nis equal to 0, and +1 if Nis greater than 0.
2.1.13 Consider the static method dupl i cate() below.
public static String duplicate(String s)
{
String t
= s + s;
return t;
}
What does the following code fragment do?
String s = "Hello";
s = duplicate(s);
String t
= "Bye";
t
= duplicate(duplicate(duplicate(t)));
StdOut.println(s + t);
2.1.14 Consider the static method cube() below.
public static void cube(int i)
{
i
= i
* i
* i;
}
How many times is the followingfor loop iterated?
for (int i
= 0;
i
< 1000; i++)
cube(i);
Answer: Just 1,000 times. A call to cube() has no effect on client code. It changes
the value of its local argument variable i, but that change has no effect on the i in
the for loop, which is a different variable. If you replace the call to cube(i) with
the statement i = i * i * i; (maybe that was what you were thinking), then
the loop is iterated fivetimes, with i taking on the values 0,1, 2, 9, and 730 at the
beginning of the fiveiterations.
2.1.15 The following checksum formula is widely used by banks and credit card

2.1
Static methods
companies to validate legalaccount numbers:
d0 +M) + d2 +f(d3) + d4 +f(d5) + ... =0 (mod 10)
The dx are the decimal digits of the account number and f(d) is the sum of the
decimal digits of 2d (for example,/(7) = 5 because2X7 = 14 and 1+ 4 = 5). For
example17327 is validbecause 1+5+3+4+7=20, whichis a multiple of 10.Imple
ment the function/and write a program to takea 10-digit integeras a command-
line argument and print a valid 11-digit number with the given integeras its first
10digitsand the checksumas the last digit.
2.1.16 Given twostarswithangles of declination and rightascension (dvax) and
(d2> a2), the anglethey subtend isgiven bythe formula
2 arcsin((sin2(d/2) + cos (d1)cos(d2)sin2(a/2))1/2),
where ax and a2 areangles between -180 and 180 degrees, dx andd2 areangles be
tween -90 and90degrees, a=a2- avandd= d2- dvWrite aprogramto takethe
declination and rightascension oftwostars ascommand-line arguments andprint
the angle theysubtend.Hint: Be careful aboutconverting fromdegrees to radians.
2.1.17 Write a readBoolean2D() method that reads a two-dimensional boolean
matrix (with dimensions) into an array.
Solution: The body of the method is virtually the same as for the corresponding
method given in the tablein the textfor 2Darrays of double values:
public static boolean[][]
readBoolean2D()
{
int M = Stdln.readlntO;
int N = Stdln.readlntO;
boolean[][] a = new boolean[M][N];
for (int i
= 0;
i
< M;
i++)
for (int j = 0;
j < N; j++)
a[i][j] = Stdln.readBoolean();
return
a;
}
Note that Stdln accepts0 and 1 as boolean values in the input stream.
2.1.18 Write a method that takes an array of double valuesas argument and re-
211

212
Functions and Modules
scales the arrayso that each element is between 0 and 1 (by subtracting the mini
mum value from each element and then dividing each element by the difference
between the minimum and maximum values). Use the max() method defined in
the table in the text, and write and use a matching min() method.
2.1.19 Write a method hi stogramO that takes an arraya[] of i nt values and an
integerMasargument and returnsan array oflength Mwhose i th entry is the num
ber of times the integeri appeared in the argument array. If the valuesin a[] are
allbetween 0 and M-l, the sum ofthe values in the returned arrayshould be equal
to a.length.
2.1.20 Assemble code fragments in this section and in Section 1.4to develop a
program that takes JV from the command line and printsN five-card hands,sepa
rated by blanklines, drawn from arandomlyshuffledcard deck,one card perline
using cardnames like Ace of Clubs.
2.1.21
Write a method multi piy0 that takes two squarematrices of the same
dimensionasarguments andproduces theirproduct(another square matrixofthat
samedimension). Extra credit: Make your program work wheneverthe number of
rowsin the first matrix is equalto the number of columns in the second matrix.
2.1.22 Write a method any() that takes an arrayof bool ean values as argument
and returns true if any of the entriesin the array is true, and fal se otherwise.
Write a method al 1() that takes an array of bool ean values as argument and re
turns true if allofthe entries in the arrayaretrue, and fal se otherwise.
2.1.23 Developaversion of getCouponO that better models the situation when
one of the coupons is rare: choose one value at random, return that value with
probability N/1000, and return allothervalues with equalprobability. Extra credit:
How does this changeaffectthe average value ofthe coupon collector function?
2.1.24 Modify PI ayThatTune to addharmonicstwo octaves awayfrom eachnote,
with half the weight ofthe one-octave harmonics.

2.1
Static methods
2.1.25 Birthday problem. Develop a class with appropriate static methods for
studying the birthday problem (seeExercise 1.4.35).
2.1.26 Euler's totientfunction. Euler's totient function is an important function
in number theory: cp(n) isdefined as thenumber ofpositive integers less than or
equalto nthat are relatively prime with n (no factors in common with nother than
1). Write a class witha function thattakes aninteger argument nandreturns <p(n),
and a mai n() that takes an integer fromthe command line, calls the function, and
prints the result.
2.1.27 Harmonic numbers. Write a program Harmonic that contains threestatic
methods H(), Hsmall (), and HlargeO for computing the Harmonic numbers.
The Hsmall () method should just compute the sum (as in Program 1.3.5), the
HlargeO method should use theapproximation HN = log^N) + 7 + 1/(2N) -
1/(12N2) + 1/(120N4) (the number 7 = .577215664901532... is known as Euler's
constant), and the H() method should call Hsmall () for N < 100 and HlargeO
otherwise.
2.1.28 Gaussian random values. Experiment with the following method for gen
erating random variables from theGaussian distribution, which isbased ongener
atinga randompointin theunit circle andusing aformoftheBox-Muller formula
(see Exercise 1.2.27 and the discussion of do-whi 1e at theendofSection 1.3).
public static double gaussian()
{
double r, x,
y;
do
{
x = uniform(-1.0, 1.0);
y = uniform(-1.0, 1.0);
r = x*x + y*y;
} while (r >= 1 j| r == 0);
}
return x * Math.sqrt(-2 * Math.log(r) /
r);
Take acommand-line argument Nandgenerate Nrandom numbers, using anarray
a [20] to count the numbers generated that fallbetween i *. 05 and (i +1)*. 05 for
213

214
Functions and Modules
i from 0 to 19. Then use StdDraw to plot the values and to compare your result
with the normal bell curve.
2.1.29 Binary search. A general method that we study in detailin Section4.2 is
effective forcomputing theinverse ofacumulative probabilitydensityfunction like
Phi (). Such functions are continuous and nondecreasing from (0,0) to (1,1). To
find thevalue x0 for whichf(x0) =yQy check thevalue of/(.5). Ifitisgreater thany0,
then x0 mustbebetween 0and .5; otherwise, itmustbebetween .5 and1. Eitherway,
wehalve the lengthof the interval knownto containx0. Iterating, wecan compute
xQ towithin agiven tolerance. Add amethod Phi InverseO toGaussi anthatuses
binary search to compute theinverse. Change mai n() to take a numberp between
0 and 100 asa third command-line argumentand print the minimum score that a
student would need to be in the topp percentof students taking the SAT in a year
when the mean and standard deviation were the first two command-line argu
ments.
2.1.30 Black-Scholes option valuation. The Black-Scholes formula supplies the
theoretical valueof a European call option on a stockthat pays no dividends, given
the currentstockprice s,the exercise price x,the continuously compounded risk-
freeinterest rate r,the standard deviation a of the stock'sreturn (volatility),and the
time (in years) tomaturity t The value is given by the formula s<&(a) - xe~rtQ>(b)>
where <£(z) is the Gaussian cumulative distribution function, a = (ln(s/x) +
(r + ct2/2) t) I (vft)y andb=a- aft.Write aprogram thattakes s, x, r, si gma, and
t from the command line and prints the Black-Scholes value.
2.1.31 Impliedvolatility. Typicallythevolatilityistheunknownvalue intheBlack-
Scholes formula. Write a programthat reads s, x, r, t, and the current priceof the
European calloption fromthe commandlineand usesbinary search (see Exercise
2.1.29) to compute or.
2.1.32 Homers method. Write a class Horner with a method double eval (double
x, double[] p) that evaluates the polynomialp(x) whose coefficients are the en
tries in p[]:
Po + Pi*1 + P2*2 + ••• + Pn-2*n~2 + Pn-i*n_1

2.1
Static methods
Use Horner's method, an efficient way to perform the computations that is sug
gestedby the following parenthesization:
P0+ *(Pl + *(P2 + "• + *(PiV-2 +*Pn-i)) ••• )
Write atestclient witha static methodexp() thatuses Horner.eval () to compute
an approximation to ex, usingthe firstATtermsoftheTaylor series expansion ex= 1
+x +x2/2\ + x3/3\ +.... Take an argumentxfromthe command-line, and compare
your resultagainstthat computed by Math. exp(x).
2.1.33 Benford's law. The American astronomer Simon Newcomb observed a
quirkin a book that compiled logarithm tables: the beginning pages were much
grubbierthan the endingpages. Hesuspected that scientists performedmorecom
putationswith numbers startingwith 1 than with8 or 9,and postulated the first
digit law, which says that undergeneral circumstances, the leading digit is much
more likelytobe1(roughly30%) thanthedigit 9(less than4%). This phenomenon
isknown asBenford's law andisnowoften used asastatistical test. Forexample, IRS
forensic accountants relyon itto discover taxfraud. Write aprogramthat reads in a
sequenceof integersfrom standard input and tabulatesthe number of timeseachof
the digits 1-9 isthe leading digit, breaking the computation into a setof appropri
ate static methods. Useyour program to test the lawon some tablesof information
from your computer or from the web. Then, write a program to foil the IRS by
generating random amounts from $1.00 to $1,000.00 with the same distribution
that you observed.
2.1.34 Binomial distribution. Write a function
public static double binomial(int N, int k,
double p)
tocompute theprobabilityofobtainingexactlykheads iniVbiased coinflips (heads
with probabilityp) using the formula
f(N,k,p) =pHl-p)N-kM/(kl(N-k)\).
Hint:Tostaveoff overflow, computex = Inf(N, k,p) and then return e*. In mai n(),
take N and p from the command line and check that the sum over all values of k
between 0 and JV is (approximately) 1.Also, compare every valuecomputed with
the normal approximation

216
0 Mm
1 •••II
2 ..i.i
3 nil.
4 ilnl
5 .1.1.
6 .11..
7 I...I
8 lull
9 hln
Functions and Modules
f(N,k,p)~<b(Np,Np(l-p))
(see Exercise 2.2.1).
2.1.35 Coupon collectingfrom a binomial distribution. Develop a version ofget-
Coupon () that uses bi nomi al () fromtheprevious exercise to return couponvalues
according to thebinomial distribution with p = 1/2. Hint: Generate a uniformly
distributed random number x between 0 and 1, then return the smallest value of
kforwhich the sum off(N,j,p) for all j<k exceeds x.Extra credit: Develop a hy
pothesis for describing thebehavior of the coupon collector function under this
assumption.
2.1.36 Chords. Develop a version of PlayThatTune that can handle songs with
chords (including harmonics). Develop aninputformat that allows you to specify
different durations for each chord and different amplitude weights for each note
withina chord.Create testfiles that exercise yourprogramwithvariouschordsand
harmonics, and create a version ofFurElisethat uses them.
2.1.37 Postal bar codes. The barcode used by the
U.S. Postal System to routemailisdefined asfollows:
Eachdecimaldigit in the zip codeis encoded using
a sequence of three half-height and two full-height
bars. The barcode starts and ends with a full-height
bar (theguard rail) andincludes a checksum digit (after the five-digit zipcode or
ZIP+4), computed bysumming up the original digits modulo 10. Implement the
following functions
• Draw a half-height or full-heightbar on StdDraw.
• Given a digit,drawits sequence of bars.
• Compute the checksum digit.
and a test clientthat readsin a five- (or nine-) digit zip code as the command-line
argument and draws the corresponding postal bar code.
2.1.38 Calendar. Writea program Calendar that takestwo command-line argu
ments Mand Yand prints out the monthly calendarfor the Mth month of year Y, as
in this example:
08540 111•••I••I••I•I••I••1111••ImmJ I
guard
/
guard
checksum
digit
rail

2.1
Static methods
% Java Calendar 2
February 2009
M Tu
2
3
9
10
W Th
4
5
11 12
F
6
13 14
2009
S
7
S
1
8
15 16 17 18 19 20 21
22 23 24 25 26 27 28
Hint See LeapYear (Program 1.2.4) and Exercise 1.2.29.
2.1.39 Fourier spikes. Write a program that takes a command-line argument JV
and plots the function
(cos(f) + cos(21) + cos(31) +... + cos(Nt)) IN
for 500 equallyspacedsamples oftfrom -10 to 10 (inradians). Run your program
forJV = 5 andJV = 500. Note: You will observe thatthesumconverges to a spike
(0everywhere except a single value). This property isthebasis fora proofthat any
smooth function can be expressedasa sum of sinusoids.
217

Functions and Modules
2.2
Libraries and Clients
Each program that you havewritten consists of Java code that resides in a single
.java file. For large programs, keeping all the code in a single file in this way is
restrictive and unnecessary. Fortunately,
it isveryeasy in Java to refer to amethod
2.2.1
Random number library
226
in one file that is defined in another. This
2.2.2 ArrayI/O library
230
ability has two important consequences
223
Iterated runction systems
233
7
.
r
r
.
^
2.2.4
Data analysis library
237
on our style ofprogramming.
225 plotting data values mm^
239
First,it enables codereuse. One pro-
2.2.6
Bernoulli trials
242
gram can make use ofcode that is already
progmms {n m$ sectim
written anddebugged, not by copying the
code,but justby referring to it.This abil
ityto define code thatcan bereused isanessential part of modernprogramming. It
amountsto extending Java—you can define anduseyourown operations on data.
Second, it enables modular programming. You cannot only divide a program
up intostatic methods, as just described in Section 2.1, but also keep themin dif
ferent files, grouped together according to the needs of the application. Modular
programming isimportant because it allows usto independently develop, compile,
anddebug parts of bigprograms onepiece atatime,leaving each finished piece in
itsown file for later usewithout having to worryaboutitsdetails again.We develop
libraries of static methods for use by any other program, keeping each libraryin
its own file and usingits methods in anyother program. Java's Math library and
our Std* libraries for input/output are examples that you havealready used.More
important, youwill soon see thatitisveryeasyto define libraries of yourown.The
ability to define libraries and thento use them in multiple programs is a critical
ingredient in ourability to buildprograms to address complex tasks.
Having just moved in Section 2.1 from thinking of a Java program as a se
quence of statements to thinking of a Java program as a class comprising a setof
methods (one of which is mai n()), you will be readyafterthis section to think of
a Java program asasetof classes, each ofwhichisanindependent module consist
ingof a setof methods. Since each method can call a method in another class, all
of yourcode caninteract as anetwork of methodsthat call one another, grouped
together in classes. With this capability, you can start to think about managing
complexity when programming by breaking up programming tasks into classes
that canbe implemented and tested independently.

2.2 Libraries and Clients
Using static methods in other programs
To refer to a staticmethod in one
class that is defined in another, we use the same mechanism that we have been us
ing to invoke methods such as StdOut. pri ntf() and StdAudio. pi ay ():
• Keep both classes in the samedirectoryin your computer.
• Tocalla method, prepend its class nameand a periodseparator.
For example, consider Gaussian (Program 2.1.2). The definition of one of its
methods requires the squareroot function. For purposes of illustration, suppose
that wewish to use the sqrt() implementationfrom Newton (Program 2.1.1).All
thatweneedtodoistokeep Gaussi an. javainthesame directory asNewton. j ava
and prepend the class name when calling sqrtQ. If wewant to use the standard
SATmyYear.Java
public class SATmyYear
{
Gaussian.Java
public static void main(String[] args)
{
public class Gaussian
double z = Double.parseDouble(args[0]);
{
double v =(Gaussian.Phi ((z - 1019)/209);)
-
StdOut.println(v);
Newton.java
public class Newton
{
public static double sqrt(double c)
{
if (c
< 0) return Double.NaN;
double err = le-15;
double t
= c;
while (Math.abs(t - c/t) > err * t)
t
= (c/t + t)
/
2.0;
return t;
}
.
•
.
r
public static void main(String[] args)
{
doubled a = new double[args.length];
for (int i =0; i < args.length; i++)
a[i] = Double.parseDouble(args[i]);
for (int i =0; f < allength; i++)
{
double x
<= sqrt(a[i]);
StdOut. printl nOO;
}
}
• ' :
-
1
•
•
public static double Phi(double z)
{
if (z < -8.0) return 0.0;
if (z >
8.0) return 1.0;
double sum = 0.0, term = z;
for (int i = 3; sum != sum + term; i += 2)
{
sum
= sum + term;
term = term * z * z / i;
}
return
0.5
+
1
»
(phiOT)
T
cr.
sum;
public static double phi(double x)
{
return Math.exp(-x*x/2) /
(Newton. sqrt(2*Math. PI)p
}
1
public static void main(String[] args)
{
double z
» Double.parseDouble(args[0]);
double mu
= Double.parseDouble(args[1]);
double sigma » Double.parseDouble(args[2]);
StdOut.println(Phi((z - mu) / sigma));
.}*'•••.•
A modularprogram
219

220
Functions and Modules
Java implementation, we call Math. sqrt(); if we want to use our own implemen
tation, we call Newton.sqrt(). Moreover, any other class in that directory can
make use of the methods defined in Gaussian, by calling Gaussi an. phi () or
Gaussi an. Phi(). Forexample,we might wish to have a simple client SATmyYear.
Java that takes avalue z from the command line and prints <I>((z-1019)/209),so
that we do not need to type in the mean and standarddeviation eachtime wewant
to know the percentage scoring less than a given value for a certain year. The files
Gaussi an. j ava, Newton. j ava, and SATmyYear. j ava implement Java classes that
interact with one another: SATmyYear calls a method in Gaussian, which calls a
method that calls a method in Newton.
The potential effectof programming by defining multiple files, each aninde
pendentclass with multiplemethods,isanother profoundchange in our program
ming style. Generally, we refer to this approach asmodular programming. We inde
pendentlydevelop anddebug methods for anapplication andthen utilizethem at
anylater time. In this section, we will consider numerous illustrative examples to
helpyou getusedto the idea. However, there are several details aboutthe process
that we need to discussbefore consideringmore examples.
The public keyword. We have been identifying every method as public since
Hel1oWorld. This modifier identifies the method as available for use by any other
program with access to the file. You can also identify methods as private (and
there are a fewother categories), but you haveno reason to do so atthis point.We
will discuss various options in Section 3.3.
Each module is a cl ass. We use the term module to refer to all the code that we
keep in asingle file. In Java, by convention, eachmodule isa Java cl ass that iskept
in a filewith the same name ofthe class but has a . j ava extension. In this chapter,
each class is merely a set of static methods (one of which is main()). You will
learnmuch more about the general structure ofthe Java cl ass in Chapter 3.
The .cl ass file. When you compile the program (by typing javac followed by
the class name), the Java compiler makes a file with the class name followed by
a .class extension that has the code of your program in a language more suited
to your computer. If you have a .cl ass file, you can use the module's methods in
another program even without havingthe sourcecode in the corresponding .Java
file (but you areon your own ifyou discoverabug!).

2.2 Libraries and Clients
221
Compile when necessary. When you compile a program, the Java compilerwill
compile everything that needsto be compiled in orderto run that program. If you
callNewton. sqrt() in Gaussi an,then, when you type javac Gaussi an. j ava, the
compiler will alsocheck whether you modified Newton. Java sincethe last time it
was compiled (by checking the time it waslastchanged against the time Newton.
cl ass was created).If so,it will alsocompile Newton! If you think about this policy,
you will agree that it is actually quite helpful. If you find abug in Newton (and fix
it), you want allthe classes that callNewton.sqrt() to use the new version.
Multiple main methods. Another subtlepoint isto note that more than one class
might have a main() method. In our example, SATmyYear, Newton and Gaussi an
eachhavemai n() methods. If you recall the rule forexecutinga program,you will
seethat there is no confusion:when you type Java followed by a class name, Java
transfers control to the machine code corresponding to the main() static method
definedin that class. Typically, we put amai n() static method in everyclass, to test
and debug its methods. When we want to run SATmyYear, we type Java SATmy
Year; when we want to debug Newton or Gaussian,we type java Newton or j ava
Gaussian (with appropriate command-line arguments).
If you think of each program that you write as something that you might want to
make use oflater, you will soon find yourselfwith allsortsofuseful tools. Modular
programming allows us to view everysolution to acomputational problem that we
may develop asadding value to our computational environment.
For example, suppose that you need to evaluate <£ for some future applica
tion. Why not just cut and paste the code that implements Phi() from Gaussi an?
That would work, but would leaveyou with two copiesofthe code, making it more
difficult to maintain. If you laterwant to fixor improve it, you would need to do so
in both copies. Instead, you can just callGaussi an. Phi(). Our implementations
and uses ofthem aresoon goingto proliferate, so having just one copy ofeachis a
worthy goal.
From this point forward, you should write every program by identifying a
reasonable way to divide the computation into separateparts of a manageable size
and implementing each part asifsomeone will want to use it later.Most frequently,
that someone will be you, and you will have yourself to thank for saving the effort
of rewriting and re-debugging code.

222
Functions and Modules
Libraries
We refer to a module whose methods are primarilyintendedfor use
by many other programs as a library. One of the most important characteristics of
programming in Javais that many,many methods havebeen predefined for you, in
literallythousands of Javalibraries that are available for your use.We revealinfor
mation about those that might be of interest to
you throughout the book, butwewillpostpone
a detailed discussion ofthe scopeof Javalibrar
ies until the end of the book, because many of
them are designed for use by experienced pro
grammers. Instead, we focus in this chapter
on the even more important idea that we can
build user-defined libraries, which are nothing
more than classes that each contain a set of re
lated methods for use by other programs. No
Java library can contain all the methods that
we might need for a given computation, so this
ability is a crucial step in addressing complex
programming applications.
Clients. We use the term client to refer to
the program that calls a given method. When
a class contains a method that is a client of a
method in another class,we say that the first
class is a client of the second class. In our ex
ample, Gaussi an is a client of Newton. A given
class might have multiple clients. For example,
all of the programs that you have written that
callMath.sqrt() or Math. random() are Math clients.When you implement a new
static method or a new class, you need to havea very clear of idea of what it is going
to do for its clients.
client
calls methods
API
public class Gaussian
double phi (double x)
<}>(*)
double Phi(double z)
<£(z)
implementation
defines signatures
and describes methods
Java code that
implements methods
Library abstraction
APIs. Programmers normally think in terms of a contract between the client and
the implementation that is a clear specification ofwhat the method is to do. When
you are writing both clients and implementations, you are making contracts with
yourself,which by itselfishelpfulbecauseit provides extra help in debugging. More
important, this approach enablescode reuse.Youhavebeen able to write programs

2.2 Libraries and Clients
223
that are clients of Std* and Math and other built-in Java classes because of an in
formal contract (an English-languagedescription of what they are supposed to do)
along with a precise specification of the signatures of the methods that are avail
ablefor use.Collectively, this information isknown as an application programming
interface (API). This same mechanism is effective for user-defined libraries. The
API allowsany client to use the library without having to examine the code in the
implementation, just as you have been doing for Mathand Std*. The guiding prin
ciple in API design is to provide toclients the methods they need and no others. An
APIwith a huge number of methods maybe a burden to implement; an APIthat is
lacking important methods may be unnecessarilyinconvenient for clients.
Implementations. We usethe term implementation to describe the Java codethat
implements the methods in an API, kept by convention in a file with the library
name and a .Java extension. EveryJava program is an implementation of some
API, and no API is of any use without some implementation. Our goal when de
veloping an implementation is to honor the terms of the contract. Often, there are
many waysto do so,and separating client code from implementation code givesus
the freedom to substitute new and improved implementations.
For example, consider the Gaussiandistribution functions. These do not appear in
Java's Math library but are important in applications, so it is worthwhile for us to
put them in a library for use by future client programs and to articulate this API:
public class Gaussian
double
phi (double x)
§(x)
double
phi (double x, double m, double s)
§(x, |x,o)
double
Phi (double z)
$(z)
double
Phi (double z, double m, double s)
<l>(z, [x, a)
APIforour library ofstatic methodsforc|) and O
Implementing these four static methods isstraightforward from the code in Gauss-
ian (Program 2.1.2)—see Exercise 2.2.1.Adding the three-argument versions of
phi () and Phi () to the Gaussian library saves us from having to worry about
those cases later on.

224
Functions and Modules
Howmuch information shouldanAPIcontain?This isa grayareaand a hotly
debatedissueamong programmersand computer-science educators.Wemight try
to put as much information aspossiblein the API,but (aswith any contract!) there
are limits to the amount of information that we can productively include. In this
book, we stick to a principle that parallels our guiding design principle: provide
to client programmers the information they need and no more. Doing so gives us
vastlymore flexibility than the alternative of providing detailedinformation about
implementations. Indeed, any extra information amounts to implicitly extending
the contract, which is undesirable. Many programmers fall into the bad habit of
checkingimplementation code to try to understand what it does. Doing so might
lead to client code that depends on behavior not specified in the API,which would
not work with a new implementation. Implementations change more often than
you might think. For example, each new releaseof Javacontains many new imple
mentations of library functions.
Often, the implementation comes first. You might have a working module
that you later decide might be useful for some task, and you can just start using
its methods in other programs. In such a situation, it is wise to carefullyarticulate
the API at some point. The methods may not havebeen designed for reuse, so it is
worthwhile to use an API to do such a design (aswe did for Gaussi an).
The remainder of this section is devoted to severalexamples of libraries and
clients. Our purpose in considering these libraries is twofold. First, they provide
a richer programming environment for your use as you develop increasingly so
phisticated client programs of your own. Second,they serve as examples for you to
study as you begin to develop libraries for your own use.
Random Burnibers
We have writtenseveral programs that useMath. random(),
but our code often uses particular idioms that convert the random doubl e values
between 0 and 1 that Math, random() provides to the type of random numbers
that we want to use (random bool ean values or random i nt values in a specified
range, for example). To effectively reuse our code that implements these idioms,
wewill,from now on, use the StdRandom library in Program 2.2.1. StdRandom uses
overloading to generate random numbers from various distributions. Youcan use
any of them in the same way that you use our standard I/O libraries (download
StdRandom. j ava and keep it in a directory with your client programs, or use your
operating system's classpath mechanism). As usual, we summarize the methods in
our StdRandom library with an API:

2.2 Libraries and Clients
public class StdRandom
int
uniform(int N)
integer between 0 and N-1
double
uniform(double lo,
double hi)
real between lo and hi
boolean
bernoulli(double p)
double
gaussianO
double
gaussian(double m, double s)
int
discrete(double[] a)
void
shuffle (doubled a)
true withprobability p
normal, mean 0, standard deviation 1
normal mean m,standard deviation s
i withprobability a [i ]
randomly shuffle thearray a []
APIfor ourlibrary ofstatic methodsfor random numbers
These methods are sufficientlyfamiliar that the short descriptions in the API suf
fice to specifywhat they do. Bycollecting all of these methods that use Math. ran
dom() to generate random numbers of various types in one file(StdRandom.j ava),
we concentrate our attention on generating random numbers to this one file (and
reuse the code in that file) instead of spreading them through every program that
uses these methods. Moreover, each program that uses one of these methods is
more clear than code that calls Math, random() directly, because its purpose for
using Math. random()
is clearly articulated by the choice of method from Std
Random.
API design. We makecertainassumptions about the values passed to eachmeth
od in StdRandom. For example, we assume that clients will call uniform(N) only
for positive integers N, bernoul 1i (p) only for p between 0 and 1,and di screteO
only for an array whose entries are between 0 and 1 and sum to 1.All of these as
sumptions are part of the contract between the client and the implementation.
We strive to design libraries such that the contract is clear and unambiguous and
to avoid getting bogged down with details. As with many tasks in programming,
a good API design is often the result of several iterations of trying and living with
various possibilities. We always take special care in designing APIs, because when
we change an API we might have to change allclients and all implementations. Our
goalisto articulate what clientsare to expectseparatefrom the code in the API.This
practice frees us to change the code, and perhaps to use an implementation that
achieves the desired effect more efficiently or with more accuracy.
225

226
Functions and Modules
5|
Program 2.2.1
Random number library
M
m
:^
m
m
public class StdRandom
{
public static int uniform(int N)
{
return (int)
(Math.random() * N);
}
public static double uniform(double lo, double hi)
{
return lo + Math.random() * (hi
- lo);
}
public static boolean bernoulli(double p)
{
return Math.random() < p;
}
public static double gaussian()
{
/* See Exercise 2.1.28. */
}
public static double gaussian(double m, double s)
{
return m + s * gaussianO;
}
public static int discrete(double[] a)
{
// See Program 1.6.2.
double r = uniform(0.0, 1.0);
double sum = 0.0;
for (int i
= 0;
i
< a.length;
i++)
{
sum += a[i];
if (sum > r) return i;
}
return a.length - 1;
}
public static void shuffle(double[] a)
{
/* See Exercise 2.2.4. */
}
}
public static void main(String[] args)
{
/* See text. */
}
This is a library of methods to compute various types of random numbers: random non-
negative integer less than agiven value, uniformly distributed inagiven range, random bit
(Bernoulli), Gaussian, Gaussian with given mean andstandard deviation, and distributed
according toa givendiscrete distribution.
% Java StdRandom 5
90 26.36076 false
8
18.02210 false 9
56.41176 true
79269
03992
13
58
8.80501
29
16.68454 false 8.90827
85
86.24712 true
8.95228
!
' "WreS.-SfiK^v'
s^pllPP^l^i^lsPiF
Wmir-^yw^^^^v^^^^Ws^W^^^^^
!:•••
i
I
ft
II
ft
s
m
$

2.2 Libraries and Clients
227
Unit testing. Even though we implement StdRandom without reference to any
particular client,it is good programming practice to include a test client mai n()
that, althoughnot usedwhena clientclass uses the library, ishelpfulfor usewhen
debugging and testing the methods in thelibrary. Wheneveryou create a library, you
should include a mai n() methodforunittesting and debugging. Proper unit testing
can be a significantprogramming challenge in itself(for example, the best wayof
testing whether the methods in StdRandom produce numbers that have the same
characteristicsas truly random numbers isstilldebated byexperts).Ata minimum,
you should always include a mai n() method that
• Exercises all the code
• Provides some assurance that the code is working
• Takes an argument from the command line to allowmore testing
Then, you should refine that mai n() method to do more exhaustivetesting as you
use the library more extensively. For example, we might start with the following
code for StdRandom (leavingthe testingof shuff1e() for an exercise):
public static void main(String[] args)
{
int N = Integer.parselnt(args[0]);
double[] t = { .5,
.3,
.1,
.1 };
for (int i = 0; i < N;
i++)
{
StdOut.printf(" %2d " , uniform(lOO));
StdOut.printf(M%8.5f
M,
uniform(10.0, 99.0));
StdOut.printf(M%5b "
, bernoulli(.5));
StdOut.printf("%7.5f ", gaussian(9.0,
.2));
StdOut.printf("%2d "
, discrete(t));
StdOut.println();
}
}
When we include this code in StdRandom. Java and invoke this method as illus
trated in Program 2.2.1, the output carries no surprises: the integers in the first
column might be equallylikely to be anyvalue from 0 to 99;the numbers in the
second column might be uniformly spread between10.0 and 99.0; about half of
the values in the third column are true; the numbers in the fourth column seem to
average about 9.0, and seem unlikely to be too far from 9.0; and the last column
seems to be not far from 50% 0s, 30% Is, 10% 2s,and 10% 3s. If something seems
amiss in one of the columns, we can type Java StdRandom 10 or 100 to see many

228
Functions and Modules
more results.In this particular case,wecan (and should) do far more extensivetest
inginaseparate client to check thatthenumbers have many ofthesame properties
as truly random numbers drawn from the cited distributions (seeExercise 2.2.3).
One effective approach isto write test clientsthat use StdDraw,as data visualization
can be a quickindicationthat a programis behaving as intended. For example, a
plot of a large number of points whose x and y coordinates are both drawn from
various distributions often produces
a pattern that gives direct insight into
the important properties of the dis
tribution. More important, a bug in
the random number generation code
is likely to show up immediately in
such a plot.
public class RandomPoints
{
public static void main(String[] args)
{
int N = Integer.parselnt(args[0]);
for (int i = 0; i < N;
i++)
{
double x = StdRandom.gaussian(.5,
.2);
double y = StdRandom.gaussian(.5,
.2);
StdDraw.point(x, y);
Stress testing. Anextensivelyusedli
brary such as StdRandom should also
be subject to stress testing, where we
make sure that it does not crash when
the client does not follow the contract
or makes some assumption that is not
explicitly covered. You can be sure
that Java libraries have been subject
to such testing, which requires care
fullyexamining each line of code and
questioning whether some condition
might cause a problem. What should
discrete() do if array entries do
not sum to exactly 1?What if the ar
gument is an array of size 0? What
should the two-argument uniformO
do if one or both of its arguments is NaN? Infi nity? Any question that you can
think of is fair game. Such casesare sometimes referred to as corner cases. Youare
certain to encounter a teacher or a supervisor who is a stickler about corner cases.
With experience, most programmers learn to address them early, to avoidan un
pleasant bout of debugging later. Again, a reasonable approach is to implement a
stress test as a separate client.
}
}
A StdRandom test client

2.2 Libraries and Clients
229
Input and output for arrays
We have seenandwillseemanyexamples where
we wish to keep data in arrays for processing. Accordingly, it is useful to build a
library of staticmethods that complements Stdln and StdOut by providingstatic
methods for reading arrays of primitive types from standard input and printing
them to standard output, as expressedin this API:
public class StdArraylO
doubl e []
readDoubl elD()
read a one-dimensional array o/doubl e values
doubl e [] []
readDoubl e2D()
read a two-dimensional array o/doubl e values
voi d
pri nt(doubl e [] a)
print a one-dimensional array o/doubl e values
voi d
pri nt (doubl e [] [] a)
print a two-dimensional array o/doubl e values
Notes:
1. IDformatisan integer Nfollowed byN values.
2. 2Dformat is two integers MandNfollowed by MxN values inrow-major order.
3. Methodsfor i nt and bool ean arealsoincluded.
APIfor ourlibrary ofstatic methodsforarray input andoutput
The first two notes at the bottom of the table reflect the idea that we need to settle
on afileformat. For simplicityand harmony,we adopt the convention that allval
ues appearing in standard input include the dimension(s) and appear in the order
indicated. The read*() methods expect this format, the print() methods pro
duce output in this format, and we can easily create files in this format for data
from some other source. The third note at the bottom of the table indicates that
StdArraylO actually contains twelve methods—four each for int, double, and
boolean. The print() methods are overloaded (they all have the same name
pri nt() but differenttypesof arguments),but the read* () methods need different
names, formed by adding the type name (capitalized, as in Stdln) followed by ID
or 2D.
Implementing these methods is straightforward from the array-processing
code that we have considered in Section 1.4 and in Section 2.1, as shown in StdAr
raylO (Program 2.2.2). Packaging up all of these static methods into one file—
StdArraylO. Java—allows us to easily reuse the code and saves us from having
to worry about the detailsof reading and printing arrayswhen writing client pro
grams later on.

230
Functions and Modules
mm^^^^^^^^^^^^^^^^^mms^
*0$l
Program2.2.2
Array I/O library
public class StdArraylO
{
public static doubled
readDoublelD()
{
/* See Exercise 2.2.6
*/
}
public static doubled []
readDouble2D()
{
int M = Stdln.readlntO;
int N = Stdln.readlntO;
doubled []
a = new double[M] [N];
for (int i = 0; i < M;
i++)
for (int j = 0; j < N;
j++)
a[i][j] = Stdln.readDouble();
return
a;
}
public static void print(doubled a)
{
/* See Exercise 2.2.6
*/
}
public static void pri nt (doubl e [] [] a)
{
int M = a.length;
int N = a[0].length;
System.out.println(M + " " + N);
for (int i
= 0;
i
< M; i++)
{
for (int j = 0;
j < N; j++)
StdOut. print(a[i][j] + " ");
StdOut.println();
}
StdOut.println();
}
// Methods for other types are similar (see booksite),
public static void main(String[] args)
{
print(readDouble2D());
}
}
% more tiny.txt
4
3
.000
.246
.222
-.032
.270
.000
.224 -.036
.176
.0893
.739
.270
% Java StdArraylO < tiny.txt
4
3
0.00000
0.24600
0.22200
-0.03200
0.27000
0.22400
0.17600
0.73900
0.00000
-0.03600
0.08930
0.27000
5^?nH||!
m
This library ofstatic methods facilitates reading one-dimensional and two-dimensional ar
raysfrom standard input and printing them to standard output. Thefileformat includes the
dimensions (see accompanying text). Numbers inthe output inthe example are truncated.

2.2 libraries and Clients
231
Iterated faiHCtioB systems
Scientists havediscovered that complexvisual im
ages can arise unexpectedly from simple computational processes. With StdRan
dom, StdDraw, and StdArraylO, wecan easily studythe behavior of such systems.
Sierpinksi triangle. As a first example, consider the following simple process:
Start by plotting a point at one of the vertices of a given equilateraltriangle. Then
pick one of the three vertices at random and plot a newpoint halfway between the
point just plotted and that vertex. Continue performing this same operation. Each
time, we are picking a random vertexfrom the triangle to establishthe line whose
midpoint willbe the next point plotted.Since weare makinga random choice,the
set of points should have some of the characteristics of random points, and that
does seem to be the case after the first few iterations:
(1/2, N3/2)
lastpoint
(0,0)
random vertex
A random process
But we can study the process for a large number of iterations by writing a program
to plot T points according to the rules:
doubled
ex = { 0.000, 1.000, 0.500 };
doubled cy = { 0.000, 0.000, 0.866 };
double x=0.0, y=0.0;
for (int t
= 0;
t
< T; t++)
{
int r = StdRandom.uniform(3);
x = (x + cx[r]) / 2.0;
y = (y + cy[r]) / 2.0;
StdDraw.point(x, y);
}
Wekeepthe x and/ coordinatesof the trianglevertices in the arraysex[] and cy[],
respectively. Weuse StdRandom. uniform() to choosea random index r into these

232
Functions and Modules
arrays—the coordinates of the chosen vertex are (cx[r],
cy[r]). The x-coordi-
nateofthemidpoint oftheline from (x, y)to thatvertex isgiven bytheexpression
(x + ex[r]) /2.0, and asimilar calculation gives they coordinate. Adding a call to
StdDraw. point () and putting this codein a loop completes the implementation.
Remarkably, despite the randomness, the samefigure always emerges aftera large
number of iterations! This figure is known as the Sierpinski triangle (see Exercise
2.3.27). Understandingwhysuch a regularfigure should arisefrom such a random
process is a fascinating question.
A A
•*
•.
-...
-"t
•:'*
A
i\
A
a
A random process?
Barnsleyfern. To addtothemystery, we canproduce pictures ofremarkable diver
sitybyplaying the samegamewith different rules. One strikingexample isknown
as the Barnsleyfern. Togenerate it, we use the same process, but this time driven
by the following table of formulas. At eachstep,we choosethe formulas to use to
updatex andy with the indicated probability (1%of the time weusethe firstpair
of formulas, 85%of the time weusethe secondpair of formulas,and so forth).
probability
x-update
y-update
1%
x=
.500
x=
A60y
85%
x = .85*+ .04/ + .075
/ = .04*+ .85/ + .180
7%
x = .20* - .26/ + .400
y = 23x + .22/ + .045
7%
x = A5x+ .28/ + .575
/ = .26* + .24/ - .086
We couldwritecode justlike the code we justwrote for the Sierpinski triangle to
iteratethese rules, but matrixprocessing provides a uniformway to generalize that

2.2 Libraries and Clients
233
f&#
U:-s.
Program2.2.3
Iteratedfunction systems
public class IFS
{
public static void main (St ring argsd)
{
// Plot T iterations of IFS on Stdln.
int T = Integer.parselnt(args[0]);
double[] dist
= StdArraylO.readDoublelD();
ex
= StdArraylO.readDouble2D();
cy
= StdArraylO.readDouble2D();
0.0, y = 0.0;
=0;
t < T; t++)
// Plot 1 iteration.
int r = StdRandom.discrete(dist);
doubled []
doubled []
double
x
=
for (int t
{
T
dist[]
cx[][]
cy[][]
x,
y
double xO = cx[r][0]*x
double yO = cy[r][0]*x
x = xO;
y = yO;
StdDraw.point(x,
y);
cx[r][l]*y
cy[r][l]*y
cx[r][2];
cy[r][2];
}
iterations
probabilities
x coefficients
y coefficients
currentpoint
This data-driven client ofStdArraylO, StdRandom, andStdDraw iterates thefunction system
defined bya l-by-M vector (probabilities) andtwo M-by-3 matrices (coefficients for updat
ingx andy respectively) onstandard input, plotting the result asa setofpoints onstandard
draw. Curiously thiscode does notneed toknow thevalue ofM, as it uses separate methods
to create and process thematrices.
% more sierpinski.txt
3
.33
.33
.34
3
3
.50 .00 .00
.50
.00
.50
.50
.00
.25
3
3
.00
.50 .00
.00
.50
.00
.00
.50
.433
•»4HI«WMI^^
% Java IFS 10000 < sierpinski.txt
T^s^s»!p^^^»i^^^^^^^^pp
5K^*^WSg^mm^^mm!?PP?flIl|!

234
% more barnsley.txt
4
.01
.85
.07
.07
4
3
.00
.00
.500
.85
.04
.075
.20
-.26
.400
-.15
.28
.575
4
3
.00
.16
.000
-.04
.85
.180
.23
.22
.045
.26
.24 -.086
% more tree .txt
6
.1
.1
.2
.2
.2
.2
6
3
.00
.00
.550
-.05
.00
.525
.46 - .15
.270
.47 - .15
.265
.43
.26
.290
.42
.26
.290
6
3
.00
.60
.000
-.50
.00
.750
.39
.38
.105
.17
.42
.465
-.25
.45
.625
-.35
.31
.525
more coral.txt
.40
.15
.45
3
3
.3077 - .5315
.8863
.3077 - .0769
.2166
.0000
.5455
.0106
3
3
-.4615
- .2937 1.0962
.1538 - .4476
.3384
.6923 - .1958
.3808
Functions and Modules
% Java IFS 20000 < barnsley.txt
Java IFS 20000 < tree.txt
% Java IFS 20000 < coral.txt
Examples ofiteratedfunction systems

2.2 Libraries and Clients
235
code to handle any set of rules.WehaveM differenttransformations, chosen from
a 1-by-M vector with StdRandom.discrete(). For each transformation, we have
an equation for updating x and an equation for updating /, so we use two M-by-3
matrices for the equation coefficients, one for x and one for/. IFS (Program 2.2.3)
implements this data-driven version of the computation. This program enables
limitless exploration: it performs the iteration for any input containing a vector
that defines the probability distribution and the two matrices that define the coef
ficients, one for updating x and the other for updating /. For the coefficients just
given,again, even though we choose a random equation at each step, the same fig
ure emerges every time that we do this computation: an image that looks remark
ably similar to a fern that you might see in the woods, not something generated by
a random process on a computer.
Generating a Barnsleyfern
That the same short program that takes a few numbers from standard input and
plots points on standard draw can (given different data) produce both the Sierpin
ski triangle and the Barnsley fern (and many, many other images) is truly remark
able. Becauseof its simplicity and the appeal of the results, this sort of calculation
is useful in making synthetic images that have a realisticappearance in computer-
generated movies and games. Perhaps more significantly, the ability to produce
such realistic diagrams so easilysuggestsintriguing scientificquestions: What does
computation tell us about nature? What does nature tell us about computation?

236
Functions and Modules
Standard statistics
Next, we considera library for a set of mathematical cal
culationsand basicvisualization tools that arise in all sorts of applicationsin sci
enceand engineeringand are not allimplemented in standard Java libraries.These
calculations relateto the taskof understandingthe statistical propertiesof a set of
numbers. Sucha library is useful, for example, when we perform a seriesof scien
tificexperiments that yieldmeasurements ofaquantity.One ofthe most important
challenges facing modern scientists is proper analysis of such data, and computa
tion is playing an increasingly important role in such analysis. These basic data
analysis methodsthat wewill consider aresummarized in the following API:
public class StdStats
double
max(doubled a)
largest value
double
mi n (doubl e[] a)
smallest value
double
mean(doubled a)
average
double
var(double[] a)
sample variance
double
Stddev(double[] a)
sample standard deviation
double
medi an (doubl e[] a)
median
void
pi otPoints (doubl e[] a)
plotpoints at (i, aim
void
pi OtLines(doubled a)
plotlines connectingpoints at (i, a[i])
void
pi otBars (doubl e[] a)
plot bars to points at Qi^W)
Note: overloaded implementations areincludedforall numeric types
APIfor ourlibrary ofstatic methodsfor dataanalysis
Basic statistics. Suppose that wehave Nmeasurements x0> xv.., xN_v Theaverage
value of those measurements, otherwise known as the mean, is given by the for
mula|x = (x0 + xx + ... 4- xN_x) /Nand isan estimateof the valueof the quantity.
The minimum and maximum values are also ofinterest, as is the median (the value
which issmaller than andlarger than halfthevalues). Also of interestisthesample
variance, which is givenby the formula
a2 = ((x0-(ji)2 + (^-^)2 + ... + (%-i-|x)2))/(N-l)

2.2 Libraries and Clients
1
m
m
m.
m
Program 2.2.4
Data analysis library
public class StdStats
{
public static double max(double[] a)
{
// Compute maximum value in a[].
double max = Double.NECATIVE_INFINITY;
for (int i
= 0;
i
< a.length;
i++)
if (a[i] > max) max = a[ij;
return max;
}
public static double mean(double[] a)
{
// Compute the average of the values in a[].
double sum =0.0;
for (int i = 0; i < a.length;
i++)
sum = sum + a[i];
return sum / a.length;
}
public static double var(double[]
a)
{
// Compute the sample variance of the values in a[],
double avg = mean(a);
double sum =0.0;
for (int i = 0; i < a.length;
i++)
sum += (a[i]
- avg) * (a[i]
- avg);
return sum / (a.length - 1);
}
public static double stddev(double[] a)
{
return Math.sqrt(var(a));
}
// See Program 2.2.5 for plotting methods.
public static void main(String[] args)
{
/* See text. */
}
This code implements methods tocompute the maximum, mean, variance, andstandard de
viation ofnumbers ina client array. The methodforcomputing the minimum isomitted, and
plotting methods arein Program 2.2.5 (see Section 4.2for a discussion of themedian).
% more tiny.txt
5
3.0 1.0 2.0
5.0 4.0
237
i
mw
I-
I
k
m
m
ffl
1
ipi
% Java StdStats < tiny.txt
min
1.000
mean
3.000
max
5.000
std dev
1.581
3
^^^^^^^^^^^^m^^^^^^^^^^^^^^^^^^^^^^1'

238
Functions and Modules
and the sample standard deviation, the square root of the sample variance. Std
Stats (Program 2.2.3) shows implementations of static methods for computing
thesebasicstatistics(the median is more difficultto compute than the others—we
will consider the implementation of medi an() in Section 4.2). The main() test cli
ent for StdStats reads numbers from standard input into an array and callseach
of the methods to print out the minimum, mean, maximum, and standard devia
tion, as follows:
public static void main(String[] args)
{
doublet]
a = StdArraylO.readDoublelD();
StdOut.printf("
min %7.3f\n", min(a));
StdOut.printf("
mean %7.3f\n", mean(a));
StdOut.printf("
max %7.3f\n", max(a));
StdOut.printf("
std dev %7.3f\n", stddev(a));
}
As with StdRandom, a more extensive test of the calculations is called for (see Ex
ercise 2.2.3). Typically, as we debug or test new methods in the library, we adjust
the unit testing code accordingly, testing the methods one at a time. A mature and
widelyusedlibrary likeStdStats alsodeserves a stress-testingclient for extensively
testing everything after anychange.Ifyou are interested in seeingwhat such a client
might look like,you can find one for StdStats on the booksite. Most experienced
programmers will adviseyou that any time spent doing unit testing and stress test
ing will more than pay for itselflater.
Plotting. One important use of StdDraw is to help us visualize data rather than
relyingon tables of numbers. In a typical situation, we perform experiments, save
the experimental data in an array, and then compare the results against a model,
perhaps a mathematical function that describes the data. To expedite this process
for the typical casewhere valuesof one variable are equally spaced, our StdStats
library contains static methods that you can use for plotting data in an array.Pro
gram 2.2.5 is an implementation of the plotPoints(), plotLinesO, and plot-
Bars() methods for StdStats. These methodsdisplay the values in the argument
array at regularly spaced intervals in the drawing window, either connected to
gether by line segments (1i nes), filled circles at each value (poi nts), or bars from
the x-axis to the value (bars). They all plot the points with x coordinate i and y
coordinate a[i ] usingfilled circles, linesthrough the points, and bars,respectively.

2.2 Libraries and Clients
239
Wm
ft
wm
till
Program 2.2.5
Plotting data values in an array
public static void piotPoints(double[] a)
{
// Plot points at (i, a[i]).
int N = a.length;
StdDraw.setXscale(0,
N-1);
StdDraw.setPenRadius(l/(3.0*N));
for (int i =0;
i < N;
i++)
StdDraw.point(i,
a[i]);
}
public static void piotLines(double[]
a)
{
// Plot lines through points at (i,
a[i]),
int N = a.length;
StdDraw.setXscale(0,
N-1);
StdDraw.setPenRadi us();
for (int i = 1; i < N;
i++)
StdDraw.line(i-l,
a[i-l],
i,
a[i]);
}
public static void piotBars(double[] a)
{
// Plot bars from (0,
a[i]) to (i,
a[i]).
int N = a.length;
StdDraw.setXscale(0, N-1);
StdDraw.setPenRadius(0.5 / N);
for (int i = 0; i < N;
i++)
StdDraw.1ine(i, 0, i,
a[i]);
}
^^fe^tii^^i^'^o^U*.*;:1;
This code implements three methods in StdStats (Program 2.2.4)for plotting data. They
plotthepoints (i, a[i ]) withfilled circles, connecting linesegments, and bars, respectively.
plotPoints(a);
piotLines(a);
piotBars(a);
f
int N = 20;
double[]
a = new doubl e[N];
for (int i
= 0;
i
< N; i++)
a[i] = 1.0/Ci+l);
^Ss^KswgEiPsl^ysjsiss^
llllllllllliiii

240
Functions and Modules
They all rescale x to fill the drawingwindow (so that the points are evenlyspaced
along the x-coordinate) and leave to the client scalingthe y-coordinates.
These methods are not intended to be a general-purpose plotting package,
you can certainlythink of all sorts of things that you might want to add: different
typesof spots,labeledaxes, color, and manyother artifacts arecommonlyfound in
modern systems that can plot data. Some situations might call for more compli
cated methods than these.
Our intent with StdStats isto introduce you to data analysiswhile showing
you how easyit isto definea library to take careof usefultasks.Indeed, this library
has alreadyproven useful—we usetheseplotting methods to produce the figures in
this book that depict function graphs,sound waves, and experimental results.Next,
we consider severalexamplesof their use.
Plotting function graphs. You can use
the StdStats. pi ot* () methods to draw a
plot of the function graph for anyfunction
at all:choose an x-interval where you want
to plot the function, compute function
values evenly spaced through that interval
and store them in an array, determine and
set the y scale, and then call StdStats.
pi otLi nes () or another plot*() meth
od. For example, to plot a sine function,
rescale the y-axis to cover values between
—1 and +1. Scalingthe x-axis is automati
callyhandled by the StdStats methods. If
you do not know the range,you can handle the situation by calling:
StdDraw.setYscale(StdStats.mi n(a), StdStats.max(a));
The smoothness of the curve is determined by properties of the function and by
the number of points plotted.Aswediscussedwhen first considering StdDraw,you
have to be careful to sample enough points to catch fluctuations in the function.
Wewillconsider another approach to plotting functions based on samplingvalues
that are not equally spaced in Section 2.4.
int N = 50;
doubled
a = new double[N+l];
for (int i
= 0;
i
<= N;
i++)
a[i] = Gaussian.phi(-4.0 + 8.0*i/N);
StdStats.piotPoi nts(a);
StdStats.piotLi nes(a);
Plottingafunctiongraph

2.2 Libraries and Clients
241
Plottingsoundwaves. Boththe StdAudi olibraryand the StdStats plot methods
work with arrays that contain sampled valuesat regular intervals.The diagrams of
sound waves in Section 1.5and at the beginning of this
section were each produced by first scaling the /-axis
StdDraw. setYscale(-1.0, 1.0);
withStdDraw.setYscaleC-l, 1), then plotting the
^^UyTnltTune.tone(880, .01);
points with StdStats.piotPoints(). As you have
StdStats.piotPoints(hi);
seen, such plots givedirect insight into processing au-
^
^
^
^
dio. You can also produce interesting effects by plot-
/
\
ting sound wavesas you play them with StdAudio, al
though this task is a bit challenging because of the
'^
'^
'^
huge amount ofdata involved (see Exercise 1.5.23).
Plottingasound wave
Plotting experimental results You can put multiple
plotson the samedrawing. One typical reasonto do soisto compareexperimental
results with a theoretical model. For example, Bernoulli (Program 2.2.6) counts
the number of heads found when a fair coin is flipped N times and compares the
result with the predicted normal (Gaussian)distribution function. A famous result
from probabilitytheory is that the distribution of this quantity is the binomial
distribution, which is extremely well-approximated by the normal distribution
function c|> with mean N/2 and standard deviation yjN/2. The more often we run
the experiment,the more accurate the approximation. The drawingproduced by
Bernoul 1i is a succinct summary of the results of the experiment and a convinc
ing validation of the theory. This exampleis prototypical of a scientific approach
to applications programming that weuse often throughout this book and that you
should use whenever you run an experiment. If a theoretical model that can ex
plainyour resultsis available, avisualplot comparingthe experimentto the theory
can validate both.
These few examples are intended to indicate to you what is possible with a well-
designed library of static methods for data analysis. Several extensions and other
ideas are explored in the exercises. You will find StdStats to be useful for basic
plots, and you are encouraged to experiment with these implementations and to
modify them or to add methods to make your own library that can draw plots of
your own design.Asyou continue to addressan ever-wideningcircleof program
ming tasks, you will naturally be drawn to the idea of developing tools like these
for your own use.

242
Functions and Modules
i
-•;ste^^
III
m
m
Program 2.2.6
Bernoulli trials
public class Bernoulli
{
public static int binomial(int N)
{
// Simulate flipping a coin N times,
int heads = 0;
for (int i = 0; i < N;
i++)
if (StdRandom.bernoulli(0.5))
heads++;
return heads;
}
public static void main(String[] args)
{
// Perform experiments, plot results and model,
int N = Integer.parselnt(args[0]);
int T = Integer.parselnt(args[l]);
}
int[] freq = new int[N+l];
for (int t
= 0;
t
< T; t++)
freq[bi nomi al(N)]++;
doubled
norm = new double[N+l];
for (int i =0;
i <= N;
i++)
norm[i] = (double) freq[i]
/ T;
StdStats.piotBars(norm);
double stddev = Math.sqrt(N)/2.0;
double stddev = Math.sqrt(N)/2.0;
doubled
phi
= new double[N+l];
for (int i = 0; i <= N;
i++)
phi [i] = Gaussian.phi(i,
mean,
stddev);
StdStats.piotLi nes(phi);
N
T
freq[]
norm[]
phi[]
number offlipspertrial
number of trials
experimental results
normalized results
Gaussian model
ThisStdStats, StdRandom, and Gaussian clientprovides convincing visual evidence that
thenumber of heads observed whenafair coinisflippedN timesobeys a Gaussian distribu
tion. Ituses theoverloaded Gaussi an. phi () thattakes asarguments themean andstandard
deviation (see Exercise2.2.1).
% Java Bernoulli
20 100000
-wffllW.

2.2 Libraries and Clients
Modular programming
Thelibraryimplementations that wehave developed
illustrate a programming styleknown as modularprogramming. Instead of writing
a new program that is self-contained in its own file to address a new problem, we
break up each task into smaller, more manageable subtasks, then implement and
independently debug code that addresses each subtask. Good libraries facilitate
modular programming by allowingus to defineand to provide solutions of impor
tant subtasks for future clients. Whenever you can clearly separate tasks within a
program, youshould doso. Javasupports such separation byallowingus to indepen
dently debug and later use classes in separatefiles. Traditionally, programmers use
the term module to refer to code that can be compiled and run independently; in
Java each class is a module.
IFS (Program 2.2.3) exemplifies modular programming because it is a rela
tively sophisticated computation that is
implemented with several relatively small
modules, developed independently. It uses
StdRandom and StdArraylO), as well as the
methods from Integer and StdDraw thatwe
are accustomed to using. If we were to put
all of the code required for IFS in a single
file, we would have a large amount of code
on our hands to maintain and debug; with
modular programming, we can study iter
ated function systemswith some confidence
that the arrays are read properly and that the
random number generator will produce properly distributed values, because we
alreadyimplemented and tested the code for these tasks in separate modules.
Similarly, Bernoulli (Program 2.2.6) also exemplifies modular program
ming. It is a client of Gaussian, Integer, Math, StdRandom, and StdStats. Again,
we can have some confidencethat the methods in these modules produce the ex
pected results because they are system libraries or libraries that we have tested,
debugged, and used before.
Todescribe the relationships among modules in a modular program, we often
draw a dependencygraph, where we connect two classnames with an arrow labeled
with the name of a method if the first class contains a call on the method and the
second classcontains the definition of the method. Such diagrams play an impor-
243
API
description
Gaussian
Gaussian distribution functions
StdRandom
random numbers
StdArraylO
input and output for arrays
IFS
client for iterated function systems
StdStats
functions for data analysis
Bernoulli
client for Bernoulli trials experiments
Summary of classes in thissection

244
readDoublelDO
readDouble2D()
readDoubleO,
readlnt()
Functions and Modules
Dependency graph for themodules in thissection
tant role because understanding the relationships among modules is necessaryfor
proper development and maintenance.
We emphasize modular programming throughout this book because it has
many important advantages that have come to be accepted as essential in modern
programming, including the following:
• Wecan have programs of a reasonable size,even in large systems.
• Debugging is restricted to small piecesof code.
• Wecan reuse code without having to reimplement it.
• Maintaining (and improving) code is much simpler.
The importance of these advantagesisdifficultto overstate, so wewill expand upon
each of them.
Programs of a reasonable size. Nolarge taskis so complex that it cannotbe di
vided into smaller subtasks. If you find yourself with a program that stretches to
more than a few pages of code, you must ask yourself the following questions: Are
there subtasks that could be implemented separately? Do some of these subtasks
logicallygroup together in a separate library? Could other clients use this code in
the future?At the other end of the range, if you find yourself with a huge number
of tiny modules, you must ask yourself questions such as: Is there some group of
subtasks that logicallybelong in the same module? Is each module likelyto be used
by multiple clients? There is no hard-and-fast rule on module size: one implemen-

2.2 Libraries and Clients
245
tation of a critically important abstractionmight properlybe a few lines of code,
whereas anotherlibrarywitha large numberof overloaded methods mightprop
erly stretch to hundreds of lines of code.
Debugging. Tracing a program rapidly becomes more difficult asthe number of
statements and interacting variables increases. Tracing a programwith hundreds
ofvariables requires keeping track ofhundreds ofvalues, as any statement might
affect or be affected by any variable. To do so for hundreds or thousands of state
ments or more is untenable. With modularprogramming and our guiding prin
ciple of keeping the scope of variables local to theextent possible, we severely re
strict thenumber ofpossibilities thatwe have toconsider when debugging. Equally
important is the ideaof a contractbetween client and implementation. Oncewe
are satisfied thatanimplementation ismeeting its endofthebargain, we can debug
allits clients under that assumption.
Code reuse. Oncewehave implemented libraries suchasStdStats and StdRan
dom, we do not have to worry aboutwriting code to compute averages or standard
deviations or to generate random numbers again—we can simply reuse the code
thatwe have written. Moreover, we do notneed to make copies of thecode: any
module canjustrefer to anypublic method in any othermodule.
Maintenance. Like a good piece ofwriting, a good program can always beim
proved, andmodular programming facilitates the process ofcontinuallyimproving
your Java programs becauseimprovinga moduleimproves allof its clients. Forex
ample, it isnormally thecase thatthere are several different approaches to solving
a particular problem. Withmodularprogramming, youcanimplement morethan
one and trythem independently. More importantly, suppose thatwhile developing
a new client, you find abug in some module. With modular programming, fixing
that bug amounts to fixing bugsin allof the module's clients.
If you encounter an old program (or a new program written byan oldprogram
mer!), you are likely to find one huge module—a long sequence of statements,
stretching to several pages or more, where anystatement can refer to anyvariable
in the program. Variables whose scope extends to a whole program areknown as
global variables. We avoid global variables in modular programs, but their use is
commonin lower-level and olderprogramming languages. Hugemodulesthat use

246
Functions and Modules
global variables are extremely difficult to understand, maintain, and debug. Old
programs ofthiskindarefound in critical partsof our computational infrastruc
ture (forexample, some nuclear power plants and some banks) precisely because
the programmers charged with maintaining them cannot even understand them
well enough torewrite them inamodern language! With support formodular pro
gramming, modern languages like Java help usavoid such situations byseparately
developing libraries of methods in independent classes.
The ability to share static methods among different files fundamentally ex
tends our programming model in two different ways. First, it allows us to reuse
code withouthaving to maintain multiple copies of it. Second, by allowing us to
organize a program into files of manageable size that can be independently de
bugged and compiled, it strongly supports our basic message: Whenever you can
clearly separate tasks within aprogram, you should do so. We use thetermlibrary to
capture theidea of developing methods for later reuse and modularprogramming
to capture theidea ofindependently developing pieces connected bywell-defined
interfaces instead of a big,monolithicpieceof code.
In thissection, wehave supplemented the Std* libraries of Section 1.5 with
several otherlibraries that you can use: Gaussian, StdArraylO, StdRandom, and
StdStats. Furthermore, we have illustrated their use with several client programs.
Thesetoolsarecenteredon basicmathematical concepts that arisein anyscientific
project orengineering task. Our intent is notjust toprovide tools, butalso toillus
trate toyou thatit iseasy for you to create your own tools. The first question that
most modern programmers ask when addressing a complex task is"What tools do
I need?"When the neededtoolsarenot conveniently available, the secondquestion
is"Howdifficult wouldit be to implementthem?" To be a good programmer, you
need to havethe confidenceto build a software tool when you need it and the wis
domto knowwhenit mightbebetterto seek a solutionin alibrary.
After libraries andmodular programming, youhave onemorestepto learna
complete modern programming model: object-oriented programming, the topic of
Chapter3.Withobject-oriented programming, youcanbuildlibraries offunctions
that use sideeffects (in a tightlycontrolled manner) to vastly extendthe Java pro
gramming model. Before moving toobject-oriented programming, we consider in
thischapter theprofound ramifications oftheidea that any method cancall itself
(in Section 2.3) and a more extensive case study (in Section 2.4) of modular pro
grammingthan the smallclients in this section.

2.2 Libraries and Clients
Q. I tried to use StdRandom, but got the error message Exception in thread
"main" java.lang.NoClassDefFoundError: StdRandom. What'swrong?
A. You needto download StdRandom. Java intothedirectory containing yourcli
ent, or use your operating system'sclasspath mechanism, as described on the book-
site.
Q. Isthere akeyword that identifies a class asalibrary?
A. No, any setofpublic methods will do. There isabitofaconceptual leap inthis
viewpoint because it is one thing to sit down to create a .Java file that you will
compile and run, quite another thing to create a .Java file that you will rely on
much later in the future, and stillanother thing to create a .Java file for someone
else to usein thefuture. You needto develop some libraries foryourownusebefore
engaging in thissortofactivity, which istheprovince ofexperienced systems pro
grammers.
Q. How doI develop anew version ofalibrary thatI have been using for awhile?
A. With care. Any change to theAPI might break any client program, soit isbest
towork inaseparate directory. Butthenyou are working with acopyofthecode. If
you are changing alibrary thathas alotofclients, you can appreciate theproblems
faced bycompanies putting outnew versions oftheir software. Ifyou justwant to
add afew methods toalibrary, go ahead: that isusually nottoodangerous, though
you should realize that you might find yourself in a situation where you have to
support that library for years!
Q. How doI know thatanimplementation behaves properly? Why notautomati
cally check that it satisfies the API?
A. We use informal specifications because writing a detailed specification is not
much different than writing a program. Moreover, a fundamental tenet of theo
retical computer science says thatdoing sodoes noteven solve thebasic problem,
because generally there isnoway tocheck thattwo different programs perform the
same computation.

248
Functions and Modules
TxercisSIm
mm^^^1^
2.2.1
Add to Gaussi an (Program 2.1.2)the method implementation phi (x, mu,
si gma) specified in the API that computes the Gaussian distribution with a given
mean jx andstandarddeviation a, basedontheformula${x,|x,a) = <J>((x-|x)/a)/a.
Also include the implementation of the associated cumulative distribution func
tion Phi (z, mu, si gma),based on the formula 4>(z, |x,a) = 0((z-|x)/a).
2.2.2
Write a static method library that implements the hyperbolic trigonomet
ric functions based on the definitions sinh(x) = (ex - e~x)/2 and cosh(x) = (ex +
e~x)/2, with tanh(x), coth(x), sech(x), and csch(x) defined in a manner analogous
to standard trigonometric functions.
2.2.3
Write a test client for both StdStats and StdRandom that checks that the
methods in both libraries operateasexpected. Take a command-lineargument N,
generate N random numbers using each ofthemethods in StdRandom, andprint
out their statistics. Extra credit: Defendthe resultsthat you getby comparing them
to those that are to be expectedfrom analysis.
2.2.4
Add to StdRandom a method shuff1e() that takes an array of doubl e val
ues as argument andrearranges them inrandom order. Implement atest client that
checks that each permutation ofthearray isproduced about the same number of
times.
2.2.5
Develop a client that does stress testing for StdRandom. Pay particular at
tention to di screte(). For example, do the probabilitiessum to 1?
2.2.6
Develop afull implementation ofStdArray10(implement all 12 methods
indicated in the API).
2.2.7
Write a method that takes doubl e values ymi n and ymax (with ymi n strictly
less than ymax), andadouble arraya[] asarguments and uses the StdStats library
to linearly scale thevalues in a[] sothatthey areall between ymi nandymax.
2.2.8
Writea Gaussi an and StdStats clientthat exploresthe effects of changing
the mean and standard deviation on the Gaussian distribution curve. Create one
plotwith curves having a fixed mean andvarious standard deviations andanother
with curveshavinga fixed standard deviationand various means.

2.2 Libraries and Clients
2.2.9
Add to StdRandom a static method maxwellBoltzmannC) that returns a
random value drawn from a Maxwell-Boltzmann distribution with parameter o\
To produce sucha value, return thesquare root ofthesumof the squares of three
Gaussian randomvariables withmean0 and standard deviation a. The speeds of
moleculesin an ideal gashavea Maxwell-Boltzmann distribution.
2.2.10 Modify Bernoul1i (Program 2.2.6) to animate thebargraph, replotting it
aftereachexperiment, sothat youcanwatch it converge to thenormaldistribution.
Thenaddacommand-line argument andanoverloaded binomi al () implementa
tionto allowyouto specifytheprobabilitypthatabiased coincomes up heads, and
run experiments to getafeeling forthedistribution corresponding to abiasedcoin.
Besure to try values of p that are closeto 0 and closeto 1.
2.2.11 Write alibrary Matri xthatimplements thefollowing API:
public class Matrix
double
dot(double[] a, doubled
b)
doubled []
mu! ti ply(doubl e[][] a, doublet] []
b)
doubled []
transpose(double[][] a)
doubled
multiply(double[][] a, doubled x)
doubl e[]
multi ply(doubl e[] x, doubled d
a)
vector dotproduct
matrix-matrixproduct
transpose
matrix-vectorproduct
vector-matrix product
(See Section 1.4.) As a test client, use thefollowing code, which performs thesame
calculation as Markov (Program 1.6.3).
public static void main(String[] args)
{
int T = Integer.parselnt(args[0]);
double[][] p = StdArraylO.readDouble2D();
double[]
rank = new double[p.length];
rank[0]
= 1.0;
for (int t
= 0;
t
< T;
t++)
rank = Matrix.multiply(rank, p);
StdArraylO.print(rank);

250
Functions and Modules
Mathematiciansand scientistsuse mature libraries or special-purposematrix-pro
cessing languages for such tasks (see theContext section attheendofthis bookfor
some details). Seethe booksite forinformation on using such libraries.
2.2.12 Write a Matrix client that implements the version of Markov described
in Section 1.6 but isbased on squaring the matrix,insteadof iterating the vector-
matrix multiplication.
2.2.13 Rewrite RandomSurfer (Program 1.6.2) using the StdArraylO and Std
Random libraries.
Partial solution.
double[][] p = StdArraylO.readDouble2D();
int page = 0; // Start at page 0.
int[] freq = new int[N];
for (int t = 0; t < T; t++)
{
page = StdRandom.discrete(p[page]);
freq[page]++;
}
2.2.14 Add amethod exp() to StdRandom that takesan argument Xand returns a
random numberfrom theexponential distribution withrate X. Hint Ifxisarandom
number uniformly distributed between 0 and 1, then-In xl Xisarandom number
from the exponentialdistributionwith rate X.

2.2 Libraries and Clients
i:9^^im^SSKi^^
2.2.15 Sicherman dice. Suppose that you have two six-sided dice, one with faces
labeled 1,3,4,5,6, and 8 and the other with faceslabeled 1,2,2, 3,3, and 4. Com
pare the probabilities of occurrence of eachof the valuesof the sum ofthe dicewith
those for a standard pair of dice. UseStdRandom and StdStats.
2.2.16 Craps. The following are the rulesfor apass bet in the gameof craps. Roll
two six-sided dice, and let x be their sum.
• If x is 7 or 11,you win.
• If x is 2,3, or 12,you lose.
Otherwise, repeatedly roll the two dice until their sum is either x or 7.
• If their sum is x,you win.
• If their sum is 7,you lose.
Writea modular program to estimate the probability ofwinninga passbet.Modify
your program to handle loaded dice, where the probability of a die landing on
1 is taken from the command line, the probability of landing on 6 is 1/6 minus
that probability, and 2-5 are assumed equally likely. Hint: Use StdRandom.dis-
crete().
2.2.17 Dynamic histogram. Suppose that thestandardinput streamisa sequence
of double values. Writea programthat takes an integer Nand twodouble values 1
and r fromthe commandlineand uses StdStats to plot a histogramof the count
of the numbers in the standard input stream that fall in each of the N intervals
defined by dividing (/, r) into N equal-sized intervals. Use your program to add
codeto your solutionto Exercise 2.2.3 to plotahistogramof the distribution of the
numbers produced by eachmethod,takingNfromthe commandline.
2.2.18 Tukey plot. A Tukey plot is a data visualization that generalizes a histo
gram, and is appropriate for usewhen eachinteger in a given range is associated
witha setofyvalues. Foreachinteger in therange, wecomputethe mean,standard
deviation, 10th percentile, and 90th percentile of allthe associated y values; draw
a verticalline with x-coordinate i running from the 10th percentiley value to the
90thpercentile/value; and then drawathin rectangle centeredon thelinethat runs
from one standard deviation below the mean to one standard deviation above the
mean. Supposethat the standard input stream is a sequence of pairs of numbers
251

252
Functions and Modules
wherethe firstnumber in eachpair isan i nt and the seconda double value.Writea
StdStats and StdDraw client that takesan integer N from the command line and,
assumingthat all the i nt values on the input stream are between0 and N-l, uses
StdDrawto make a Tukeyplot of the data.
2.2.19 IFS. Experimentwithvariousinputs to IFS to createpatterns ofyour own
designlikethe Sierpinski triangle, the Barnsley fern, or the other examples in the
table in the text.You might begin by experimentingwith minor modifications to
the given inputs.
2.2.20 IFS matrix implementation. Writea versionof IFS that usesMatri x.mul-
t i pi y0 (seeExercise 2.2.11)instead of the equations that compute the newvalues
of xO and yO.
2.2.21 Stress test. Develop a client that does stress testing for StdStats. Work
with a classmate, with one person writingcodeand the other testing it.
2.2.22 Gambler's ruin. Develop a StdRandom client to study the gambler's ruin
problem (see Program 1.3.8 andExercises 1.3.21-24. Note: Defining a static meth
od for the experiment is more difficult than for Bernoulli because you cannot
return two values.
2.2.23 Libraryforproperties ofintegers. Develop a librarybasedon the functions
that wehaveconsideredin thisbook for computingproperties of integers. Include
functions for determining whether a given integer is prime; whether two integers
are relatively prime;computingallthe factors of a given integer; the greatest com
mon divisor and least common multiple of two integers; Euler's totient function
(Exercise 2.1.26); and anyother functions that you think mightbe useful. Include
overloaded implementations for1ong values. Create an API, a clientthat performs
stresstesting,and clients that solve several of the exercises earlierin this book.
2.2.24 Voting machines. Develop a StdRandom client (with appropriate static
methods of its own) to study the following problem: Suppose that in a popula
tion of 100 million voters, 51% vote for candidate A and 49% vote for candidate
B.However, the voting machinesare prone to make mistakes, and 5% of the time

2.2 Libraries and Clients
they produce the wrong answer. Assuming the errors are made independently and
at random, is a 5% error rate enough to invalidate the results of a close election?
What error rate can be tolerated?
2.2.25 Poker analysis. Write a StdRandom and StdStats client (with appropriate
staticmethods of its own) to estimatethe probabilities of gettingone pair,two pair,
three of a kind, a full house, and a flush in a five-card poker hand via simulation.
Divideyour program into appropriate staticmethodsand defendyour designdeci
sions. Extra credit: Add straight and straight flush to the list of possibilities.
2.2.26 Music library Develop a library based on the functions in PIayThatTune
(Program 2.1.4)that you can useto writeclientprogramsto createand manipulate
songs.
2.2.27 Animated plots. Write a program that takesa command-line argument M
and producesabar graph ofthe Mmostrecentdouble values on standard input. Use
the same animation technique that we used for BouncingBall (Program 1.5.6):
erase,redraw, show, and waitbriefly. Eachtimeyour program readsa new number,
it should redrawthe wholegraph. Since most of the picture does not changeas it
is redrawn slightlyto the left,your program willproduce the effectof a fixed-size
windowdynamically slidingoverthe input values. Use yourprogram to plot a huge
time-variant data file,such as stock prices.
2.2.28 Array plot library. Develop your own plot methods that improve upon
thosein StdStats. Becreative! Tryto makea plottinglibrarythat youthink willbe
useful for some application in the future.
253

Functions and Modules
23
Recursion
The ideaof calling one function from another immediately suggeststhe possibility
of a function calling itself The function-call mechanism in Javaand most modern
programming languages supports this possibility,which is known as recursion. In
this section, wewillstudy examplesof el
egant and efficient recursivesolutions to
avariety ofproblems. Once you get used
23A
Euclid>s %>rithm
•
259
x
.
'
r
.„
-
'
&.
.
2.3.2
Towers ofHanoi
262
totheidea, you will see thatrecursion isa
?33 G
d
267
powerful general-purpose programming
2^4 Recursive graphic! ........ .269
technique with many attractive proper-
2.3.5
Brownian bridge
271
ties. It is a fundamental tool that we use
Programs in this section
often in this book. Recursive
programs are often more com
pact and easier to understand than their nonrecursive counterparts. Few
programmers become sufficientlycomfortable with recursion to use it in
everydaycode, but solvinga problem with an elegantlycrafted recursive
program isa satisfying experiencethat is certainlyaccessible to everypro
grammer (even you!).
Recursion is much more than a programming technique. In many
settings,it is a usefulwayto describe the natural world. For example,the
r.
x
,
j,
recursive tree (to the left) resembles a real tree, and has a natural recur-
of the natural world
.
. v
'
.
sive description. Many, many phenomena are well-explained by recursive
models. In particular, recursion playsa central role in computer science.
It provides a simple computational model that embraces everything that can be
computed with any computer; it helps us to organize and to analyzeprograms; and
it is the key to numerous criticallyimportant computational applications, ranging
from combinatorial search to tree data structures that support information pro
cessingto the Fast Fourier Transform for signalprocessing.
One important reason to embrace recursion is that it provides a straightfor
ward wayto build simple mathematical models that we can use to prove important
facts about our programs. The proof technique that we use to do so is known as
mathematical induction. Generally, we avoid going into the details ofmathematical
proofs in this book, but you willseein this section that it isworthwhile to make the
effort to convince yourself that recursive programs have the intended effect.

I®
Si
til
11
2.3 Recursion
Mi^^^^I;';<I
2m^&j±sii£&si.
'•^^IM^Ms^M^i\
Functions and Modules
2.3
Recursion
The ideaohcalling one wnction from another immediatelysuggeststhe possibility
of a function callingitself.The function-callmechanism in Javaand most modern
programminglanguagessupports this possibility,which is known as recursion. In
this section,we willstudy examplesof el
egant and efficient recursivesolutions to
a varietyof problems.Once you getused
to the idea,you willseethat recursionisa
powerful general-purposeprogramming
technique with many attractive proper
ties. It is a fundamental tool that we use
often in this book. Recursive
programsarcoften more com
pactand easierto understand than their nonrecursivecounterparts.Few
programmersbecome sufficientlycomfortablewith recursionto use it in
everydaycode,but solvinga problemwith an elegantlycraftedrecursive
satisfyingexperiencethatiscertainlyaccessible to everypro
grammer (even you!).
Recursionis much more than a programmingtechnique.In many
settings,it isa usefulwayto describethe naturalworld.Forexample,the
' '/""'
recursive tree (tothe left) resembles areal tree, and has anatural recur
sivedescription.Many,many phenomena arewell-explainedby recursive
models. In particular,recursionplaysa centralrolein computer science.
It provides a simple computational model that embraces everything that can be
computedwith anycomputer;it helpsusto organizeandto analyzeprograms; and
it isthe key to numerouscriticallyimportantcomputationalapplications, ranging
from combinatorialsearchto tree datastructuresthat support informationpro
cessingto the FastFourierTransformforsignalprocessing.
One important reasonto embracerecursionis that it providesa straightfor
wardwayto buildsimplemathematicalmodelsthatwecanuseto proveimportant
factsabout our programs.The proof techniquethat we use to do so is known as
mathematical induction. Generally, weavoidgoinginto thedetailsof mathematical
proofsin this book, but you willseein this sectionthat it isworthwhileto make the
effort toconvincejraurscjfthat recursive programs have theintended effect.
23J
TowmofHanoi. ..
Z3J
Graycode.
23.4
Rcctmivcgraphics..
Proglottis inadsstetson
ylilidizzoqarilzlzagguzvjalsibammitarilonstaaA Morrovim hmoduluad to A3aihhT
rnabomtzom bno svsl ni mzinsfbam Um-noiftnu) arfT\latti gnilh» noittnin*slo
ni .nointnaizs nworolzi rbiriw,xliIidizzoqzirfiziioqquz zagsugnslgnimmsigoiq
-lalo zalqmsxaybutz Itiwaw.noilaazzirit
ol znobuloz aviaimai inaiorfb bne insga
bazulag uov,aanO.zmaldoiq1o ylahsv s
s ainoiziusai isrilaazlliwuov,,sabiad)ot
gnimms-igoiq azoqiuq-lsianag luhawoq
•taqoiq aviftsilts ynem riliw aupintbal
azu aw Isril loo) Islnamsbnul e zi II job
avirumJI jlood ziril
ni
nafto
-rnoD aiom naflo aic zmsigoiq
waH .zmqialnuoa aviziroainonliariinsrflbnsiziabnu o) laizoabns lacq
ni ti azuot noiziuaairiliwaldsnolmco ybnabfftuz amcoadziammsigoiq
aviziiroi battels xbnsgab n* riliwmaldoiq s gnivloatud ,abroYakY131"
-oiq \iava ot aldizzasasYJnistiaazilsdt asnahaqxagnivlzbBZs zi msigoiq
.(luov.nava)lammsig
Xnern nl .aupinriaal gnirnmsigoiq s nerflaiom (bum zi noizimafl
aril.alqmBxaicfl .bhow Ismlsn ariladrrazab ol yew liiiazub zi Ji.zgniltaz
-iirniIsiulsn bzbiI bns.aailIsai bzaldmazai (flal aril ol)aailavizimai
' |"1"
aviziuaaiyd banislqxa-Ilawais BnamonariqYnsm .ynsM .nobqmzab aviz
.asnabzlatuqnio? ni aloi isitnaa s zyslq noizunai .islmbisq ni .zbbom
ad nsa teril gnirirfiavazaacidmaIsril bborn Isnobsluqrnco alqmh e zabivoiq H
bns ;zmsigoiqaliens ol bn6axinsgiool zuzqlarili ;ialuqni03yns riliwbaluqmoa
gnignsi .znoitsailqqsisnoilstuqmo} instioqmi xllsabrn zuoiamun ol v»l arilzi li
•oiq noilBrmoInilioqquz isril zaiulsinlz slsb aail ol ibisaz Isholsnidmco moil
.gnizzaxnqIsngizid) miotansiT lahuoHIttrlarilol gnizzas
-lobrigisilzs zabivoiqli isril zi noiziuoaiaasidmaol nozsai Inslioqmi anO
tnclioqmi avoiqol azunsoawlBrilzbbom IsahsmarilBm alqmizbliud ol ysw biBw
zbnwomlzi oaob ol azuawIsrilaupimballooiq arIT.zmsigoiq mo luods zlss)
Isaiismarilsmlo zlislabarilolni gniogbiovsaw.ylknanaO.notouWt \tk»tttmamt>m
arila)(smol aliriwrinowzili isril nobaazzirilni aazlliw ooy lud ,)loodtiril ni atomq
.taafiababnalni arilavsrizmsigoiq aviziusai Isrilllaziuoy aanivnos ol ndfla
lonsHlomwoT
S.tS
aixw^nD
e.C£
....... .nlffqoissWniiMfl
*.t£
sgWidntinvraiS Z.IS
notottitth ni imm^onfl
A recursive image
255

256
Functions and Modules
Your first recursive program
The Hel 1oWorl d for recursion (the first recur
siveprogram that most programmers implement) is the factorial function, defined
for positive integers ATby the equation
N\=NX (N-l) X (N-2) X ... X 2 X 1
In other words, N! is the product of the positive integers less than or equal to N.
Now,N! is easyto compute with a for loop, but an even easier method is to use the
following recursive function:
public static long factorial(int N)
{
if (N == 1) return 1;
return N * factorial(N-l);
}
This static method callsitself.The implementation clearlyproduces the desired ef
fect.Youcan persuade yourself that it does so by noting that f actori al () returns
1 = 1!when AT is 1 and that if it properly computes the value
(N-l)! - (N-l) X (N-2) X ... X 2 X 1
then it properly computes the value
. N\=NX (N-l)!
= N X (N-l) X (N-2) X ... X 2 X 1
Tocompute factori al (5), the recursivemethod mul
tiplies 5by f actori al (4); to compute f actori al (4),
it multiplies 4 by factorial (3); and so forth. This
process is repeated until facto ri al (1), which direct
ly returns the value 1. We can trace this computation
in precisely the same way that we trace any sequence
of function calls.Sincewe treat all of the callsas being
independent copies of the code, the fact that they are
recursive is immaterial.
Our factorial () implementation exhibits the
two main components that are required for every recursive function. The base case
returns a value without making any subsequent recursive calls.It does this for one
or more special input values for which the function can be evaluated without re-
factorial(5)
factorial (4)
factorial (3)
factorial (2)
factorial (1)
return
1
return 2*1 =
return
3*2
=
6
return 4*6
=
24
return
5*24
=
120
Function call tracefor factorial

2.3 Recursion
257
cursion. For factorial (), the base caseis N = 1.The reduction step is the central
part of a recursive function. It relates the function at one (or more) inputs to the
function evaluatedat one (or more) other inputs. Forfactorial 0, the reduction
step is N * factorial (N-l). All recursive functions must have
these two components. Furthermore, the sequenceof parameter
valuesmust convergeto the base case.For facto ri al (), the value
of N decreases by one for each call, so the sequence of argument
values converges to the base case JV = 1.
Tiny programs such as facto rial() are perhaps slightly
more clearifweput the reduction step in an el se clause. However,
adopting this convention for everyrecursive program would un
necessarily complicate larger programs because it would involve
putting most of the code (for the reduction step) within braces
after the el se. Instead,weadopt the conventionof always putting
the base case as the first statement, ending with a return, and
then devoting the rest of the code to the reduction step.
The factorial () implementation itself is not particularly
useful in practice because N! growsso quicklythat the multiplica
tion will overflowand produce incorrect answers for N > 20. But
the same technique is effective for computing all sorts of func
tions. For example, the recursive function
public static double H(int N)
{
if (N == 1) return 1.0;
return H(N-l)
+ 1.0/N;
}
is an effective method for computing the Harmonic numbers (see Program 1.3.5)
when JV is small,based on the following equations:
HN= 1 + 1/2 + ... + 1/N
= (l + l/2 +... + l/(N-l)) + l/N = H^ + l/N
2
2
3
6
4
24
5
120
6
720
7
5040
8 40320
9
362880
10 3628800
11 39916800
12 479001600
13 6227020800
14 87178291200
15
1307674368000
16 20922789888000
17
355687428096000
18 6402373705728000
19 121645100408832000
20 2432902008176640000
Values of N\ in long
Indeed, this same approach iseffective for computing, with only a fewlines of code,
the value of any discrete sum for which you have a compact formula. Recursive
programs like these are just loops in disguise, but recursion can help us better un
derstand this sort of computation.

258
Functions and Modules
Mathematical induction
Recursive programmingis directly relatedto math
ematical induction, a technique for proving facts about discrete functions.
Proving that a statement involving an integer JV is true for infinitely many
values of JVbymathematical induction involvesthe following two steps:
• The base case: prove the statement true for some specificvalue or values of
JV (usually 1).
• The induction step (the central part of the proof): assume the statement
to be true for all positiveintegerslessthan JV, then use that fact to prove it
true for JV.
Such a proofsufficesto show that the statement is true for allJV: we can start at the
base case,and use our proof to establish that the statement is true for each larger
value ofJV, one by one.
Everyone'sfirst induction proofis to demonstrate that the sum ofthe positive
integers lessthan or equal to JVis givenby the formula JV(JV+l)/2. That is,we wish
to prove that the following equation is valid for all JV > 1:
1+2 + 3 ... + (JV-1)+JV = JV(N+l)/2
The equation is certainly true for JV = 1 (base case).If we assume it to be true for all
integerslessthan JV, then, in particular, it is true for JV— 1,so
1 + 2 + 3 ... +(JV-1) = (JV-l)JV/2
and we can add JV to both sides of this equation and simplify to get the desired
equation (induction step).
Everytime we write a recursive program, we need mathematical induction to
be convinced that the program has the desired effect. The correspondence between
induction and recursion is self-evident. The difference in nomenclature indicates
a difference in outlook: in a recursive program, our outlook is to get a computa
tion done by reducing to a smaller problem, so we use the term reduction step; in
an induction proof, our outlook is to establishthe truth of the statement for larger
problems, so we use the term induction step.
When wewrite recursiveprograms weusuallydo not write down a full formal
proof that they produce the desired result, but we are always dependent upon the
existence of such a proof. We do often appeal to an informal induction proof to
convince ourselvesthat a recursiveprogram operates as expected. For example,we
just discussedan informal proofto becomeconvincedthat f actori al () computes
the product ofthe positive integerslessthan or equal to JV.

2.3 Recursion
259
m^m^m^mMmmMm^^mmmiM^Mmmmmmmmm
Program 2.3.1
Euclid's algorithm
public class Euclid
{
public static int gcd(int p, int q)
{
if (q == 0) return p;
return gcd(q,
p % q);
}
public static void main(String[] args)
{
int p = Integer.parselnt(args[0]);
int q = Integer.parselnt(args[l]);
int d = gcd(p, q);
StdOut.println(d);
}
}
P,
q
d
arguments
greatest common divisor
This program prints outthegreatest common divisor ofitstwo command-line arguments, us
inga recursive implementation ofEuclid's algorithm.
^S™%java Euclid 1440 408
24
% Java Euclid 314159 271828
1
"^^s^i^^^^^^^^^^^i^^i^^P^IP^^
Euclid's algorithm
Thegreatest common divisor (gcd) of two positive integers
isthe largestintegerthat dividesevenlyinto both of them. Forexample,the greatest
common divisor of 102and 68 is 34 since both 102and 68 are multiples of 34,but
no integer larger than 34 divides evenlyinto 102 and 68.You may recall learning
about the greatest common divisorwhen you learned to reduce fractions. For ex
ample, we can simplify68/102 to 2/3 by dividingboth numerator and denominator
by 34, their gcd. Finding the gcd of huge numbers is an important problem that
arises in many commercial applications, including the famous RSAcryptosystem.
Wecan efficientlycompute the gcd using the following property, which holds
for positive integersp and q:

260
Functions and Modules
Ifp>q, thegcdofp andq is thesameas thegcdofqandp %q.
Toconvinceyourself of this fact,first note that the gcd ofp and qis the same as the
gcd of q and p—qy because a number divides both p and q if and only if it divides
both qandp—q. Bythe sameargument,qandp—2q, qandp—3q, and so forth have
the same gcd,and one wayto compute p % qis to subtract qfrom
9CdCcdC4084°216)
Puntil 8ettin8anumber less than <?•
gcd(2l6, 24)
The static method gcd() in Euclid (Program 2.3.1) is a
gcd(192, 24)
compactrecursive function whosereduction step isbased on this
gc return 24
property. The base case is when qis 0,with gcd(p, 0) = p. To see
return 24
that the reduction step converges to the base case, observe that
return 24
faesecondinput strictlydecreases in eachrecursive callsincep %
return 24
.
return 24
9 < q. Ifp <^>the first recursivecallswitchesthe arguments. In
Function call trace for qcd
^act> ^e second input decreases by atleast afactor oftwo for ev
ery second recursive call,so the sequence of inputs quickly con
vergesto the base case (see Exercise 2.3.11). This recursive solu
tion to the problem of computing the greatestcommon divisor isknown asEuclid's
algorithm and is one of the oldest known algorithms—it is over 2,000years old.
Towers of Hanoi
No discussion of recursion would be complete without the
ancient towers ofHanoiproblem. In this problem, we have three poles and n discs
that fit onto the poles.The discsdifferin sizeand are initiallystackedon one of the
poles,in order from largest(discn)at the bottom to smallest (disc 1)at the top. The
task is to move all n discs to another pole, while obeying the following rules:
• Move only one disc at a time.
• Never place a larger disc on a smaller one.
One legend saysthat the world will end when a certain group of monks accom
plishes this task in a temple with 64 golden discs on three diamond needles. But
how can the monks accomplish the task at all, playing by the rules?
Tosolvethe problem, our goalis to issuea sequence of instructions for mov
ingthe discs. Weassumethat the polesarearranged in a row,and that eachinstruc
tion to move a disc specifies its number and whether to move it left or right. If a
disc is on the left pole, an instruction to move left means to wrap to the right pole;
if a disc is on the right pole, an instruction to move right means to wrap to the left
pole. When the discs are all on one pole, there are two possible moves (move the
smallest disc left or right); otherwise, there are three possible moves (move the
smallestdiscleft or right, or make the one legalmove involvingthe other two poles).

23 Recursion
Choosing among these possibilities on each move to achievethe goal is a challenge
that requires a plan. Recursion provides just the plan that we need, based on the
followingidea: first we move the top n—\ discsto an empty pole, then we move the
largest disc to the other empty pole (where it does not inter
ferewith the smaller ones), and then we complete the job by
moving the n—\ discs onto the largest disc.
TowersOfHanoi (Program 2.3.2) is a direct imple
mentation of this strategy. It reads in a command-line argu
ment n and prints out the solution to the Towers of Hanoi
problem on n discs. The recursive static method moves ()
prints the sequence of moves to move the stack of discs to
the left (if the argument left is true) or to the right (if
1eft is fal se). It does so exactly according to the plan just
described.
startposition
261
moven-1 discsto theright(recursively)
Function call trees
To better understand the behav
ior of modular programs that have multiple recursive calls
(such as TowersOfHanoi), we use a visual representation
known as afunction calltree. Specifically, we represent each
method call as a tree node, depicted as a circle labeled with
the values of the arguments for that call. Below each tree
node, we draw the tree nodes corresponding to each callin
that useof the method (in order from leftto right) and lines
connecting to them. This diagram contains all the information we need to under
stand the behavior of the program. It contains a tree node for each method call.
We can use function call trees to understand the behavior of any modular
program, but they are particularly useful in exposing the behavior of recursive
programs. For example, the tree
corresponding to a call to move()
in TowersOfHanoi is easy to con
struct. Start by drawing a tree
node labeled with the values of
the
command-line
arguments.
The first argument is the number
of discs in the pile to be moved
Function calltreefor moves (4, true) in TowersOfHanoi
(and the label of the disc to actu-
movelargest discleft(wrapto rightmost)
moven-1 discsto theright(recursively)
Recursive planfor towers ofHanoi

262
Functions and Modules
Program 2.3.2
TowersofHanoi
public class TowersOfHanoi
{
public static void moves(int n, boolean left)
{
if (n == 0)
return;
moves(n-1,
!left);
if (left) StdOut.println(n + " left");
else
StdOut.println(n + " right");
moves(n-1,
!left);
}
public static void main(String[]
args)
{
// Read n,
print moves to move n discs left.
int n = Integer.parselnt(args[0]);
moves(n, true);
}
}
n
left
number of discs
direction to movepile
I
The recursive method moves() prints themoves needed to move n discs to theleft(if left is
true) orto theright(if~\ eft isfal se).
% Java TowersOfHanoi
1 right
2 left
1 right
% Java TowersOfHanoi
1 left
2 right
1
left
3 left
1
left
2 right
1 left
right
left
right
right
ri ght
left
right
left
right
left
right
right
right
left
right
i
^^^^^^P^^^^^^^^^^^^roSS?^^
^^^|^SPSI?SiSSiSf^^Wm^^^W^^^^'-mmm*

2.3 Recursion
ally be moved); the second is the direction to move the pile. For clarity, we depict
the direction (a bool ean value) as an arrow that points left or right, since that is
our interpretation of the value—the direction to move
the piece. Then draw two tree nodes below with the
number of discs decremented by 1 and the direction
switched, and continue doing so until only nodes with
labels corresponding to a first argument value 1 have
no nodes below them. These nodes correspond to calls
on moves () that do not lead to further recursive calls.
Take a moment to study the function call tree
depicted earlier in this section and to compare it with
the corresponding function calltrace depicted at right.
When you do so, you will see that the recursion tree is
just a compact representation of the trace. In particu
lar, reading the node labels from left to right gives the
moves needed to solvethe problem.
Moreover,when you study the tree, you probably
notice several patterns, including the followingtwo:
• Alternate moves involve the smallest disc.
• That disc alwaysmoves in the same direction.
These observations are relevant because they give a
solution to the problem that does not require recur
sion (or even a computer): every other move involves
the smallest disc (including the first and last), and each
intervening move is the only legal move at the time
not involving the smallest disc. We can prove that this
method produces the same outcome as the recursive
program, using induction. Having started centuries ago
without the benefit of a computer, perhaps our monks
are using this method.
Trees are relevant and important in understand
ing recursion because the tree is the quintessential
recursive object. As an abstract mathematical model,
trees play an essential role in many applications, and in
Chapter 4, we will consider the use of trees as a computational model to structure
data for efficient processing.
moves(4,
true)
moves(3,
false)
moves(2,
true)
moves(1,
false)
1 right
A
263
2 left
moves(1, false)
1 right
AH
3 right
moves(2, true)
moves(1, false)
1 right
2
left
moves(1, false)
1 right
4
left
moves(3,
false)
moves(2, true)
moves(1, false)
1 right
2 left
moves(1,
false)
1 right
3 right
moves(2, true)
moves(1,
false)
1 right
2 left
moves(1
1
false)
right
XA 1
3 discs moved right
1 iX
disc4 movedleft
1 ±X
UX
ux
1U
1 1*
3 discsmovedright
Function call tracefor moves(4, true)

264
Functions and Modules
Exponential time
One advantage of using recursion is that often we can de
velop mathematical models that allowus to prove important facts about the behav
ior of recursive programs. For the towers of Hanoi, we can estimate the amount of
time until the end of the world (assuming that the legend is true). This exercise is
important not just because it tellsus that the end of the world is quite far off (even
if the legend is true), but also because it provides insight that can help us avoid
writing programs that will not finish until then.
For the towers of Hanoi, the mathematical model is simple: if we define the
function T(n) to be the number of movedirectives issued by TowersOf-
Hanoi to move n discs from one peg to another, then the recursive code
immediately implies that T(n)must satisfythe followingequation:
oo, 2*>)-
T(n) = 2 T(n-1) 4- 1 for n > 1,with T(l) = 1
Such an equation is known in discrete mathematics as a recurrence rela
tion. Recurrence relations naturally arise in the study of recursive pro
grams.Wecan often use them to derivea closed-form expressionfor the
quantity of interest.For T(n), you mayhavealreadyguessedfrom the ini
tial values 7X1) = 1, T(2) = 3, T(3), = 7, and T(4) = 15 that T(n) = 2n - 1.
The recurrencerelation provides a wayto prove this to be true, by math
ematical induction:
• Base case: T(l) = 2n - 1 = 1
• Induction step: if T(n-1)= 2""1 - 1, T(n) = 2 (2n~l - I) + 1 = 2" - 1
Therefore,by induction, T(ri) = 2"—1 for all n > 0. The minimum pos
sible number of moves also satisfies the same recurrence (see Exercise
2.3.9).
Knowing the value of T(n),we can estimate the amount of time re
quired toperform all themoves. Ifthemonks move discs attherate ofone
xPonen ia
growth
per second, it would take more than one week for them to finish a 20-disc
problem, more than 31 yearsto finish a 30-disc problem, and more than
348centuries for them to finish a40-disc problem (assumingthat theydo not make
a mistake). The 64-disc problem would take more than 1.4 million centuries. The
end of the world islikelyto be evenfurther offthan that becausethose monks pre
sumablyneverhavehad the benefitof usingProgram 2.3.2, and might not be able
to movethe discsso rapidlyor to figure out so quicklywhich discto move next.
Even computers are no match for exponential growth. A computer that can
do a billion operations per secondwillstilltakecenturiesto do 264 operations, and
no computer will ever do 21000 operations, say. The lesson is profound: with recur-

2.3 Recursion
265
sion, you can easily write simple short programs that take exponential time, but
they simply will not run to completion when you try to run them for large n. Nov
ices are often skeptical of this basic fact, so it is worth your while to pause now to
think about it. To convince yourself that it is true, take the print statements out of
TowersOfHanoi and run it for increasing values of n starting at 20. Youcan easily
verifythat each time you increasethe valueof nby 1,the running time doubles, and
you will quickly lose patience waiting for it to finish. If you wait for an hour for
some value of n, you will wait more than a day for rc+5, more than a month for
n+10, and more than a century for n+20 (no one has thatmuch patience). Your
computer isjust not fast enough to run everyshort Javaprogram that you write, no
matter how simplethe program might seem! Beware ofprograms thatmight require
exponential time.
We are often interested in predictingthe running time of our programs. In
Section 4.1, we will discuss the use of the same process that we just used to help
estimate the running time of other programs.
Gray codes
The towers of Hanoi problem is no toy. It is intimately related to
basicalgorithms for manipulatingnumbersand discrete objects.Asan example, we
considerGray codes, a mathematicalabstractionwith numerous applications.
The playwright Samuel Beckett, perhaps best known for Waitingfor Godot,
wrote a playcalled Quad that had the following property: startingwith an empty
stage, characters enter and exit one at a time so that each subset of characters on
the stage appearsexactly once.Howdid Beckett generate the stage
directions for thisplay?
code
subset
One way to represent asubset ofndiscrete objects is to use a
o0 0 1
"T*'
string of n bits. For Beckett's problem,we use a 4-bit string, with
0 0 l l
2 1
enter 2
bits numbered from right to left and abit value of1indicating the
q110
322
enter 3
character onstage. For example, the string 0 10 1 corresponds
0 1 l 1
3 2 1
enter l
to the scene with characters 3and 1onstage. This representation
ql 0o
^
exit ?
gives a quickproof of a basicfact: the number different subsets ofn
noo
4 3
enter 4
objects isexactly 2".Quad hasfour characters, sothereare24 = 16
} } ? }
A3,1,
enter x
'
'_
_.
,
,.
11114321
enter 2
different scenes. Our task is to generate the stage directions,
l l l o
4 3 2
exit 1
An ra-bit Gray code is a list of the 2" different rc-bit binary
} 5 } °
4->2
exit 3
,
iii
.
i
i.
i.«-
•
.i
i.
1011
421
enter 1
numbers such that each entry in the list differs in precisely one bit
i o 0 1
4 1
exit 2
from its predecessor. Gray codes directlyapplyto Beckett's prob-
10 0 0
4
exit l
lem becausechangingthe valueof a bit from 0 to 1correspondsto
Gray code representations
enter
1

266
2-bit
3-bit
Functions and Modules
a character entering the subset onstage; changing a bit from 1 to 0 corresponds to
a character exiting the subset.
How do we generate a Graycode? A recursiveplan that is very similar to the
one that we used for the towers of Hanoi problem is effective. The n-bit binary-
reflected Gray code is defined recursively as follows:
• The (n— 1) bit code, with 0 prepended to each word, followed by
• The (n—1) bit code in reverse order, with 1 prepended to each word
The 0-bit code is defined to be null, so the 1-bit code is 0 followedby 1.From this
recursivedefinition, we can verifyby induction that the n-bit binary reflected Gray
code has the required property: adjacent codewords dif
fer in one bit position. It is true by the inductive hypoth
esis,exceptpossiblyfor the last codeword in the first half
and the first codeword in the second half:this pair differs
only in their first bit.
The recursive definition leads, after some careful
thought, to the implementation in Beckett (Program
2.3.3) for printing out Beckett's stage directions. This
program is remarkably similar to TowersOfHanoi. In
deed, except for nomenclature, the only difference is
in the values of the second arguments in the recursive
calls!
As with the directions in TowersOfHanoi, the en
ter and exit directions are redundant in Beckett, since
exit is issued only when an actor is onstage, and enter
is issuedonlywhen an actor is not onstage. Indeed, both
Beckett and TowersOfHanoi directly involve the ruler
function that we considered in one of our first programs
(Program 1.2.1).Without the redundant instructions, they both implement a sim
ple recursive function that could allow Rul er to print out the values of the ruler
function for any value givenas a command-line argument.
Gray codes have many applications, ranging from analog-to-digital convert
ers to experimental design.Theyhavebeen used in pulse code communication, the
minimization of logic circuits, and hypercube architectures, and were even pro
posed to organize books on library shelves.
1-bit code
3-bit code
1
I
0
0
4-bit
0
0
0
0
0
1
0
0
0
1
1
1
0
0 11
1
0 \
0
0 10
1-bit code
0 110
(reversed)
0 111
2-bit code
0 10 1
\
0
1
10 0
0
0
0
10 0
0
0
1
1 10 1
0 11
1 111
0
1
0
1
1
110
0 10
1
1
0
1 11
1
0 11
1
0
1
1
0
0
1
1
0
0
1
0
0
0
t
t
2-bit code
3-bit code
0 evtrscd)
(reversed)
2-, 3-, and 4-bit Gray codes

2.3 Recursion
267
ISA
ill
u$
m
mIII
r
Si
Program 2.3.3
Gray code
public class Beckett
{
public static void moves(int n, boolean enter)
{
if (n == 0) return;
moves(n-l, true);
if Center) StdOut.println("enter " + n);
else
StdOut.println("exit
" + n);
moves(n-1,
false);
}
}
public static void main(String[] args)
{
int n = Integer.parselnt(args[0]);
moves(n, true);
}
n
enter
number ofcharacters
stagedirection
^m$&mtMmm^mmmw*
This recursive program gives Beckett's stage instructions (the bitpositions that change in a
binary-reflected Gray code). The bit position that changes isprecisely described by the ruler
function, and(ofcourse) each character alternately enters and exits.

268
order 1
order 2
Functions and Modules
Recursive graphics
Simple recursive drawing schemes can lead to pictures
that are remarkably intricate. Recursive drawings not only relate to numerous ap
plications,but they alsoprovide an appealingplatform for developinga better un
derstanding of properties of recursiveprograms, because we can watch the process
of a recursive figure taking shape.
As a first simple example, consider Htree (Program 2.3.4), which, given a
command-line argument n,drawsan H-tree oforder n,defined as follows: The base
case is to draw nothing for n = 0. The reduction step is to draw, within the unit
square
• three lines in the shape of the letter H
• four H-trees of order n—\, one connected to each tip of the H
with the additional provisos that the H-trees of order n— 1 are halved in size and
centered in the four quadrants of the square.
Drawings like these have many practical applications. For example,
consider a cablecompany that needsto run cableto allofthe homes distrib
uted throughout its region. A reasonable strategy is to use an H-tree to get
the signalto a suitable number of centers distributed throughout the region,
then run cablesconnecting eachhome to the nearest center.The same prob
lem is faced by computer designers who want to distribute power or signal
throughout an integrated circuit chip.
Though every drawing is in a fixed-size window, H-trees certainly ex
hibit exponential growth. An H-tree of order n connects 4" centers, so you
would be trying to plot more than a million lines with n = 10,more than a
billion with n = 15, and the program will certainly not finish the drawing
with n = 30.
If you take a moment to run Htree on your computer for a drawing
that takes a minute or so to complete,you will,just by watching the drawing
progress, have the opportunity to gain substantial insight into the nature of
recursive programs, because you can see the order in which the H figures
appear and how they form into H-trees. An even more instructive exercise,
which derives from the fact that the same drawing results no matter in what
order the recursive draw() calls and the StdDraw. 1i ne() calls appear, is to
observe the effectof rearranging the order of these callson the order in which the
lines appear in the emerging drawing (see Exercise2.3.14).
H
M
H
H
order 3
hHljl MM
hTh H H
M|M m|m
HH HH
H-trees

2.3 Recursion
269
mimmm^^^^^^mm^^^^^^mmm^^m
IP
f&
m
H
Program 2.3.4
Recursive graphics
public class Htree
{
public static void draw(int n, double sz, double x, double y)
{
// Draw an H-tree centered at x,
y
// of depth n and size sz.
if (n == 0) return;
double xO = x - sz/2,
xl = x + sz/2;
double yO = y - sz/2, yl = y + sz/2;
StdDraw.line(xO,
y,
xl,
y);
StdDraw.line(xO,
yO,
xO,
yl);
StdDraw.line(xl,
yO,
xl,
yl);
draw(n-l,
sz/2,
xO,
yO);
draw(n-l,
sz/2,
xO,
yl);
draw(n-l,
sz/2,
xl,
yO);
draw(n-l,
sz/2,
xl,
yl);
}
public static void main(String[] args)
{
int n = Integer.parselnt(args[0]);
draw(n,
.5,
.5,
.5);
}
fro'/i)
This recursiveprogram draws three lines in the shape ofthe letter H that connect the center (x,
y) ofthe square with the centers ofthefour quadrants, then calls itselfforeach ofthe quadrants,
using an integer argument tocontrol thedepth ofthe recursion.
M
M
M
M
H
H
H
H
H
H
H
H
H
H
H
H
^SBSHi
W$$M$i$2W&%8$*\!%;
\
hnlji rp rp rp rp rp rp
HJH HfH HJH rW\
H[H hrjjM
Hhrl MM
hIh HJH
MjhH
HlH
rri Jti \t\ Jti rr\ hrl rH hp
HH HH HH HH
^^^^^^K^*^R^fS
W^^^^^^^e9

270
random
displacement 8
Functions and Modules
Brownian bridge
An H-tree isa simpleexampleof afractal: a geometric shape
that can be divided into parts, eachof which is (approximately) a reduced-size copy
of the original.Fractalsare easyto produce with recursiveprograms, although sci
entists,mathematicians,and programmers study them from many differentpoints
of view. Wehave alreadyencountered fractals several times in this book—for ex
ample, IFS (Program 2.2.3).
The studyof fractals plays an important and lastingrolein artisticexpression,
economic analysis and scientific discovery. Artists and scientistsuse them to build
compactmodelsof complexshapesthat arisein nature and resistdescription using
conventionalgeometry, such as clouds,plants, mountains, riverbeds, human skin,
and many others. Economists also use fractals to model function graphs of eco
nomic indicators.
Fractional Brownian motion is a mathematical model for creating realistic
fractal models for many naturally rugged shapes. It is used in computational fi
nance and in the study of many natural phenomena, including ocean flows and
nerve membranes. Computing the exact fractals specifiedby
the model can be a difficult challenge,but it is not difficult
to compute approximations with recursive programs. We
consider one simple example here; you can find much more
information about the model on the booksite.
Brownian (Program 2.3.5) produces a function graph
that approximates a simple exampleof fractional Brownian
motion known asaBrownian bridge and closelyrelated func
tions.You can think of this graph as a random walkthat con
nectstwo points,from (x0, y0) to (xvyx), controlledby a few
parameters. The implementation is based on the midpoint displacement method,
whichis a recursive plan for drawingthe plot within the interval [x0, xx]. The base
case (when the size of the interval is smaller than a given tolerance) is to draw a
straightline connecting the twoendpoints. The reduction case is to dividethe in
terval into two halves,proceeding as follows:
• Compute the midpoint (xm,ym) of the interval.
• Addto the y-coordinateym of the midpoint a random value8, chosen from
the Gaussian distribution with mean 0 and a given variance.
• Recur on the subintervals, dividing the variance by a givenscalingfactor s.
The shape of the curve is controlled by two parameters: the volatility (initial value
of the variance) controls the distance the graph strays from the straight line con-
(^r« +8)
(*o>ro)
Brownian bridge calculation

2.3
Recursion
271
IM
JjMM&i$v&£*
Program2.3.5
Brownian bridge
public class Brownian
{
public static void curve(double xO,
double yO,
double xl,
double yl,
double var,
double s)
if (xl -
xO < .01)
{
StdDraw.line(xO,
yO, xl, yl);
return;
}
double xm = (xO + xl)
/
2;
double ym = (yO + yl) /
2;
double delta = StdRandom.gaussian(0, Math.sqrt(var));
curve(xO,
yO,
xm,
ym+delta, var/s, s);
curve(xm, ym+delta, xl, yl, var/s, s);
public static void main(String[] args)
{
double H = Double.parseDouble(args[0]);
double s = Math.pow(2,
2*H);
curve(0,
.5, 1.0,
.5,
.01, s);
}
Byaddingasmall, random Gaussian toa recursiveprogram that would otherwiseplotastraight
line, wegetfractal curves. The command-line argument H, known as theHurst exponent, con
trols thesmoothness of thecurves.
Java Brownian 1
H»»fflliiPiW»

272
Functions and Modules
necting the points, and theHurst exponent controls the smoothness of the curve.
We denote the Hurst exponent by H and divide the variance by 22H at each recur
sivelevel.When H is 1/2 (divide by 2 at each level) the curve is a Brownian bridge:
a continuous version of the gambler's ruin problem (see Program 1.3.8). When
0 <H < 1/2, the displacements tend to increase, resulting in a rougher curve; and
when 2 > H > 1/2, the displacements tend to decrease, resulting in a smoother
curve. The value 2 —H is known as the fractal dimension of the curve.
The volatility and initial endpoints of the interval have to do with scale and
positioning. The mai n() test client in Browni an allowsyou to experiment with the
smoothness parameter. With valueslarger than 1/2, you get plots that look some
thing like the horizon in a mountainous landscape; with values smaller than 1/2,
you get plots similar to those you might see for the value of a stock index.
Extending the midpoint displacement method to two dimensions produces
fractals known asplasma clouds. Todraw a rectangular plasma cloud, we use a re
cursiveplan where the base caseis to draw a rectangle of a given color and the re
duction step is to draw a plasma cloud in each quadrant with colors that are per
turbed from the average with a random Gaussian. Using the same volatility and
smoothness controls as in Browni an, we can produce synthetic clouds that are re
markablyrealistic. Wecan usethe samecodeto produce syntheticterrain, by inter
preting the colorvalueasthe altitude.Variants of this schemearewidelyused in the
entertainment industry to generate background scenery for movies and computer
games.
fflPp-
$l|ll-;
* fa":;'•."•"•::;•
:>*-f::-•
'••^^M$f%-t
*•''...
.'•..•"V'
A plasmacloud

2.3 Recursion
273
Pitfalls of recursion
By now, you are perhaps persuaded that recursion can
help you to write compact and elegant programs. Asyou begin to craft your own
recursive programs, you need to be aware of severalcommon pitfalls that can arise.
Wehave alreadydiscussed one of them in some detail (the running time of your
program might growexponentially). Onceidentified, theseproblems are generally
not difficultto overcome, but you willlearn to be verycareful to avoidthem when
writing recursive programs.
Missing base case. Consider the following recursive function, which issupposed
to compute Harmonic numbers, but is missinga base case:
public static double H(int N)
{
return H(N-l) + 1.0/N;
}
If you run a clientthat calls this function, it will repeatedly call itselfand neverre
turn, soyour program willneverterminate.You probablyalreadyhaveencountered
infinite loops, where you invoke your program and nothinghappens (or perhaps
you get an unending sequence of lines of output). With infinite recursion, however,
the result isdifferent because the system keeps trackof each recursive call (using a
mechanism that we will discuss in Section 4.3, based on a data structure known as
astack) andeventually runs out ofmemory tryingto doso. Eventually, Java reports
a StackOverflowError. When you write a recursive program,you should always
try to convince yourselfthat it hasthe desired effect byan informalargumentbased
on mathematical induction.Doingso mightuncover a missing basecase.
No guarantee of convergence. Another common problem is to include within a
recursive function a recursive call to solve a subproblem that is not smaller than
the original problem. For example, the following method will go into an infinite
recursive loop for anyvalueof its argument Nexcept 1:
public static double H(int N)
{
if (N == 1) return 1.0;
return H(N)
+ 1.0/N;
}

274
Functions and Modules
Bugslike this one are easyto spot, but subtle versions of the same problem can be
harder to identify.You may find severalexamplesin the exercises at the end of this
section.
Excessive memory requirements. If a function calls itselfrecursively an excessive
number of times before returning, the memory required by Java to keep track of
the recursive calls may be prohibitive, resulting in a StackOverflowError. To get
an idea of how much memory isinvolved, run a small set of experiments using our
recursive program for computing the Harmonic numbers for increasingvalues of
N:
public static double H(int N)
{
if (N == 1) return 1.0;
return H(N-l) + 1.0/N;
}
The point at whichyou get StackOverflowError willgive you some idea of how
much memory Java uses to implement recursion. By contrast, you can run Pro
gram 1.3.5 to compute HN for hugeN usingonly a tiny bit of space.
Excessive recomputation. Thetemptationto writea simple recursive program to
solve a problem must always be temperedby the understanding that a simplepro
gram might takeexponentialtime (unnecessarily) due to excessive recomputation.
This effect is possible even in the simplestrecursive programs, and you certainly
need to learn to avoid it. For example,the Fibonacci sequence
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 ...
is definedby the recurrenceFn = Fn_x + Fn_2 for n > 2 with JF0 = 0 and Fx = 1.The
Fibonacci sequence hasmanyinteresting propertiesand arisein numerousapplica
tions.A noviceprogrammer might implement this recursive function to compute
numbers in the Fibonacci sequence:
public static long F(int n)
{
if (n == 0) return 0;
if (n == 1) return 1;
return F(n-l)
+ F(n-2);
}

2.3 Recursion
However, this program is spectacularly inefficient! Novice programmers often re
fuse to believe this fact, and run code like this expecting that the computeris cer
tainlyfast enough to crank out an answer. Go ahead; see if your computer is fast
enough to use this program to compute P50. To seewhyit is futile to do so, con
sider what the function does to compute jF(8) = 21.
It firstcomputesF(7) = 13and F(6) = 8.To compute
F(7),it recursively computes F(6) = 8 again and F(5)
= 5. Things rapidly get worse because both times it
computes F(6), it ignores the fact that it already
computed F(5), and so forth. In fact, you can prove
byinduction that the number of timesthisprogram
computes F(l) when computing F(n) is precisely
Fn (seeExercise 2.3.12). The mistakeof recomputa-
tion is compounded exponentially. As an example,
to compute F(200), the number of times this meth
od needsto compute F(l) is F200 > 1043! Noimag
inable computer will ever be able to do this many
calculations. Beware ofprograms that might require
exponential time. Many calculations that arise and
find natural expression as recursive programs fall
into this category. Do not fall into the trap of imple
menting and trying to run them.
The following is one caveat: a systematictech
nique known as memoization allows us to avoid this
pitfallwhilestilltakingadvantage of the compactre
cursive description of a computation. In memoiza
tion, we maintain an array that keeps track of the
valueswehavecomputed so that wecan return those
valuesand make recursivecallsonly for new values.
This technique is a form of dynamicprogramming, a
well-studiedtechnique for organizingcomputations
that you willlearn if you take coursesin algorithms
or operations research.
F(7)
F(6)
F(5)
F(4)
F(3)
F(2)
F(l)
return
F(0)
return
return
1
F(l)
return
1
return
2
F(2)
F(l)
return
1
F(0)
return
0
return
1
return
3
F(3)
F(2)
F(l)
return
1
F(0)
return
0
return
1
F(l)
return
1
return
2
return
5
F(4)
F(3)
F(2)
275
Wrong waytocompute Fibonacci numbers

276
Functions and Modules
Perspective
Programmers who do not use recursion are missing two oppor
tunities. First recursion leads to compact solutions to complex problems. Second,
recursive solutions embody an argument that the program operates as anticipated.
In the early days of computing, the overhead associated with recursive programs
was prohibitive in some systems, and many people avoided recursion. In modern
systems likeJava, recursion is often the method of choice.
Ifyou areintrigued bythe mystery of howthe Java system managesto imple
ment the illusionof independentlyoperating copiesof the same pieceof code,be
assured that we will consider this issue in Chapter 4. Youmay be surprised at the
simplicityof the solution. It is so easyto implement that programmers wereusing
recursion well before the advent of high-level programming languages like Java.
Indeed, you might be surprised to learn that you could write programs equivalent
to the ones considered in this chapter with just the basic loops, conditionals, and
arrays programming model discussedin Chapter 1.
Recursion has reinforced for us the idea of proving that a program operates
as intended. The natural connection between recursion and mathematical induc
tion is essential. For everydayprogramming, our interest in correctness is to save
time and energytracking down bugs.In modern applications,security and privacy
concerns make correctness an essential part of programming. If the programmer
cannot be convinced that an application works as intended, how can a user who
wants to keep personal data private and secure be so convinced?
Recursive functions truly illustrate the power of a carefully articulated ab
straction. While the concept of a function having the ability to call itself seems
absurd to many people at first, the many examples that we have considered are
certainlyevidence that mastering recursion is essentialto understanding and ex
ploiting computation and in understanding the role of computational models in
studying natural phenomena.
Recursionisthe lastpiecein a programming model that servedto build much
of the computational infrastructure that was developed as computers emerged to
take a central role in dailylifein the latter part of the 20th century.Programs built
from libraries of functions consisting of statements that operate on primitive types
of data, conditionals, loops, and function calls(including recursive ones) can solve
important applications of all sorts. In the next section, we emphasize this point
and review these concepts in the context of a large application. In Chapter 3 and
in Chapter 4, we will examine extensions to these basic ideas that embrace a more
expansivestyle of programming that now dominates the computing landscape.

2.3 Recursion
Q. Are there situations when iteration is the only option available to address a
problem?
A. No,anyloop canbe replaced bya recursive function, thoughthe recursive ver
sion might require excessive memory.
Q. Are there situations when recursion is the only option available to address a
problem?
A. No, anyrecursive function canbe replaced byan iterative counterpart. In Sec
tion 4.3, we will see howcompilers produce code forfunction calls byusinga data
structure called a stack.
Q. Which should I prefer,recursion or iteration?
A. Whichever leads to the simpler, more easily understood, or more efficient
code.
Q. I get the concern about excessive space andexcessive recomputation in recur
sivecode.Anything elseto be concerned about?
A. Be extremely wary of creating arrays in recursive code. The amountof space
used can pile up very quickly, as can the amount of time required for memory
management.
277

278
Functions and Modules
2.3.1
What happens if you callfacto ri al () with a negativevalue of n? With a
large value, say, 35?
2.3.2
Write a recursive function that computes the value ofIn (N\)
2.3.3
Givethe sequenceof integersprinted by a callto ex233(6) :
public static void ex233(int n)
{
if (n <= 0)
return;
StdOut.println(n);
ex233(n-2);
ex233(n-3);
StdOut.println(n);
}
2.3.4
Give the value of ex234(6):
public static String ex234(int n)
{
if (n <= 0) return "";
return ex234(n-3) + n + ex234(n-2) + n;
}
2.3.5
Criticizethe followingrecursivefunction:
public static String ex235(int n)
{
String s = ex235(n-3) + n + ex235(n-2) + n;
if (n <= 0) return "";
return s;
}
Answer: The base case will never be reached. A call to ex235 (3) will result in calls
toex235(0),ex235(-3),ex235(-6),andsoforthuntilaStackOverflowError.
2.3.6
Givenfour positiveintegers a, b, c, and d, explain what value is computed
bygcd(gcd(a, b), gcd(c, d)).

2.3 Recursion
2.3.7
Explainin terms of integersand divisors the effect of the following Euclid
like function.
public static boolean gcdlike(int p, int q)
{
if (q == 0) return (p == 1);
return gcdlikeCq,
p % q);
}
2.3.8
Consider the following recursive function.
public static int mystery(int a, int b)
{
if (b == 0)
return 0;
if (b % 2 == 0) return mystery(a+a, b/2);
return mystery(a+a, b/2) + a;
}
What are the values of mystery(2,
25) and mystery(3,
11)? Given positive
integers a and b, describe what value mystery(a, b) computes. Answer the same
question, but replace + with *.
2.3.9
Write a recursive program Rul er to plot the subdivisions of a ruler using
StdDraw as in Program 1.2.1.
2.3.10 Solve the following recurrence relations,all with T(l) = 1.Assume N is a
power of two.
• T(N) = T(N/2) + 1.
• T(N) = 2T(N/2) + 1.
•T(N) = 2T(N/2)+iV.
• T(N) = 4T(JV/2) + 3.
2.3.11 Prove by induction that the minimum possible number of moves needed
to solve the towers of Hanoi satisfies the same recurrence as the number of moves
used by our recursive solution.
2.3.12 Proveby induction that the recursive program givenin the text makes ex
actly Fn recursive callsto F(l) when computing F(n).
279

Functions and Modules
2.3.13 Prove that the second argument to gcd() decreases by at least a factor of
two for every second recursive call, and then prove that gcd(p,
q) uses at most
log2 AT recursive calls whereN isthe largerof p and q.
2.3.14 Modify Htree (Program 2.3.4) to animate the drawing of the H-tree.
20%
40%
60%
80%
100%
Next,rearrange the order of the recursive calls(and the base case),viewthe result
ing animation, and explain each outcome.

2.3 Recursion
^BliiiiliiiEfcra^i
2.3.15 Binary representation. Write a program that takes a positive integer N (in
decimal) from the command line and prints out itsbinary representation. Recall, in
Program 1.3.7,that weused the method of subtracting out powersof 2.Instead, use
the followingsimpler method: repeatedlydivide 2 into N and read the remainders
backwards. First, write a while loop to carry out this computation and print the
bits in the wrong order. Then, use recursion to print the bits in the correct order.
2.3.16 A4 paper. The width-to-height ratio of paper in the ISO format is the
square root of 2 to 1.Format AO has an areaof 1squaremeter.Format Al isAO cut
with a verticalline into two equal halves, A2isAl cut with a horizontal line into in
two halves, and so on. Write a programthat takes a command-line integern and
usesStdDraw to showhow to cut a sheetof AO paper into 2n pieces.
2.3.17 Permutations. Write a program Permutati ons that takesa command-line
argumentnand prints out alln! permutationsof the nlettersstartingat a (assume
that nisno greater than 26). Apermutation of nelements isoneof the n! possible
orderings oftheelements. As an example, when n= 3youshould getthefollowing
output. Do not worry about the order in whichyou enumerate them.
bca cba cab acb bac
abc
2.3.18 Permutations of size k. Modify Permutations so that it takes two com
mand-lineargumentsnand k, andprintsout allP(n,k) = n\ I(n~k)\ permutations
that containexactly kof the nelements. Below isthe desired output when k= 2 and
n = 4.Youneed not print them out in any particular order.
ab ac ad
ba be bd ca cb cd da db dc
2.3.19 Combinations. Write a program Combi nati ons that takesone command-
line argument n and prints out all 2" combinations of anysize. A combination is
a subsetof the n elements, independent of order. As an example, when n = 3 you
should get the following output.
a
ab abc ac
b
be
c
Note that your program needs to print the empty string (subsetof size0).
281

Functions and Modules
2.3.20 Combinations of size k. Modify Combinations so that it takes two com
mand-line arguments n and fc, and prints out all C(n, k) = n\ I (k\(n—k)\) combi
nations of size k.For example, when n = 5 and k= 3, you should get the following
output:
abc abd abe acd ace ade bed bee bde cde
2.3.21 Hamming distance. The Hamming distance between two bit strings of
length n is equal to the number of bits in which the two strings differ. Write a
program that readsin an integer k and a bit string s from the commandline,and
prints out allbit stringsthat have Hammingdistance at most kfrom s. Forexample
if k is 2 and s is 0000,then your program should print
0011 0101 0110 1001 1010 1100
Hint: Choose k of the n bits in s to flip.
2.3.22 Recursive squares. Writeaprogramto produce eachof the following recur
sive patterns. Theratioofthe sizes ofthesquares is2.2:1. To drawa shadedsquare,
drawa filled graysquare,then an unfilled blacksquare.
2.3.23 Pancake flipping. You have a stack of n pancakes of varying sizes on a
griddle. Your goalis to rearrange the stackin descending order so that the largest
pancake ison the bottom and the smallest one ison top.You are onlypermittedto
flipthe top kpancakes,thereby reversing their order. Devisea recursive scheme to
arrange the pancakesin the proper order that usesat most In —3 flips.
2.3.24 Gray code. Modify Beckett (Program 2.3.3) to print out the Gray code
(not just the sequence of bit positions that change).

2.3
Recursion
2.3.25 Towers of Hanoi variant. Consider the following variant of the towers of
Hanoi problem. There are 2n discs of increasing sizestored on three poles. Initially
all of the discs with odd size (1, 3,..., 2n-l) are piled on the left pole from top to
bottom in increasing order of size;all of the discs with even size (2, 4,..., 2n) are
piled on the right pole.Write a program to provide instructions for moving the
order i
odd discsto the right pole and the evendiscs to the leftpole,obeyingthe same
rules as for towers of Hanoi.
2.3.26 Animated towers of Hanoi. Use StdDraw to animate a solution to the
towers of Hanoi problem, moving the discs at a rate of approximately 1 per
second.
2.3.27 Sierpinski triangles. Write a recursive program to draw Sierpinskitri
angles (see Program 2.2.3). Aswith Htree, use a command-line argument to
control the depth of the recursion.
2.3.28 Binomial distribution. Estimate the number of recursive calls that
would be used by the code
public static double binomial(int N, int k)
{
if ((N == 0) [I (k < 0)) return 1.0;
return (binomial(N-l,
k) + binomial(N-l, k-l))/2.0;
}
Sierpinski
triangles
to compute bi nomi al (100,
50). Develop a better implementation that is based
on memoization. Hint: See Exercise 1.4.37.
2.3.29 Collatzfunction. Consider the following recursive function, which is relat
ed to a famous unsolvedproblem in number theory,known asthe Collatzproblem^
or the 3n+l problem:

Functions and Modules
public static void collatz(int n)
{
StdOut.print(n + " ");
if (n == 1) return;
if (n % 2 == 0) collatz(n /
2);
else
collatz(3*n + 1);
}
For example,a callto col 1atz (7) prints the sequence
7
22 11 34 17 52 26 13 40 20 10
5 16
8
4
2
1
as a consequence of 17recursive calls. Writea program that takesa command-line
argument Nand returns the value of n < Nforwhichthe number of recursive calls
for col 1atz (n) ismaximized.The unsolvedproblem isthat no one knows whether
the function terminates for all positivevalues of n (mathematical induction is no
help,because one of the recursive calls isfor a largervalueof the argument).
2.3.30 Brownian island. B. Mandelbrot asked the famous question How long is
the coast ofBritain? ModifyBrowni an to geta program Browni anlsl and that plots
Brownian islands, whose coastlines resemble that of Great Britain. The modifica
tions aresimple: first,changecurve() to add a Gaussianto the x-coordinate aswell
asto the/-coordinate; second, change mai n() to drawa curvefrom the point at the
center of the canvasbackto itself. Experimentwith various valuesof the parameters
to getyour program to produce islands with a realistic look.
Brownian islands withHurstexponentof .76
2.3.31 Plasmaclouds. Write a recursiveprogram to draw plasma clouds, using the
method suggested in the text.

2.3 Recursion
2.3.32 A strangefunction. Consider McCarthy's 91 function:
public static int mcCarthy(int n)
{
if (n > 100) return n - 10;
return mcCarthy(mcCarthy(n+ll));
}
Determine the value of mcCarthy(50) without using a computer. Givethe number
of recursive calls used by mcCarthy() to compute this result. Prove that the base
case is reached for all positive integers n or givea value of n for which this function
goes into a recursive loop.
2.3.30 Recursive tree. Write a program Tree that takesa command-line argument
Nand produces the followingrecursivepatterns for Nequal to 1,2,3,4, and 8.
1
T
285

Functions and Modules
2.4
Case Study; Percolation
The programmingtools that wehaveconsidered to this point allow us to attack all
manner of important problems.Weconcludeour study of functions and modules
by consideringa casestudy of developing a program to solve an interestingscien
tificproblem. Our purpose in doing so is
to review the basic elements that we have
covered, in the context of the various
2.4.1
Percolation scaffolding ...... .290
challenges that you might face in solv-
2-4-2
Vertical percolation detection
292
ing a specific problem, and to illustrate
^.4.3 VisualizationcUent ..... .295
°
.
,
,
,
2.4.4
Percolation probabilityestimate . .297
a programming style that you can apply
245 PerColationdetection
299
broadly.
2.4.6
Adaptive plot client
302
Our example applies a computing
Progmms fa m$section
technique to a simple model that has been
extremely useful in helping scientists and
engineers in numerous contexts.Weconsider a widely applicable technique known
as Monte Carlo simulation to study a natural model known as percolation. This is
not just of direct importance in materials science and geology, but also explains
many other natural phenomena.
The term "Monte Carlo simulation" is broadly used to encompass any tech
nique that employs randomness to generate approximate solutions to quantitative
problems. We have used it in several other contexts already—for example, in the
gambler's ruin and coupon collector problems. Rather than develop a complete
mathematical model or measure all possible outcomes of an experiment, we rely
on the lawsof probability.
Wewilllearn quite a bit about percolation in this casestudy,but our focus is
on the process of developing modular programs to address computational tasks.
We identify subtasks that can be independently addressed, striving to identify the
key underlying abstractions and asking ourselvesquestions such as the following:
Is there some specificsubtask that would help solve this problem? What are the es
sential characteristics ofthis specificsubtask? Might a solution that addresses these
essential characteristics be useful in solvingother problems? Askingsuch questions
payssignificant dividend, because they lead us to develop software that is easier to
create, debug, and reuse, so that we can more quickly address the main problem of
interest.

2.4 Case Study: Percolation
Percolation
It is not unusual for localinteractions in a system to implyglobal
properties. For example, an electrical engineer might be interested in composite
systemscomprised of randomly distributed insulating and metallic materials: what
fraction of the materials need to be metallic so that the composite system is an
electrical conductor? As another example, a geologist might be interested in a po
rous landscape with water on the surface (or oil below).Under what conditions will
the water be able to drain through to the bottom (or the oil to gush through to the
surface)? Scientistshave defined an abstract processknown aspercolation to model
such situations. It has been studied widely, and shown to be
an accurate model in a dizzying variety of applications, be
yond insulating materials and porous substances to the
spread of forest fires and disease epidemics to evolution to
the study of the internet.
For simplicity,we begin byworking in two dimensions
and model the system as an N-by-iV grid of sites. Each site
is either blocked or open; open sitesare initiallyempty. Afull
site is an open site that can be connected to an open site in
the top row via a chain of neighboring (left,right, up, down)
open sites. If there is a full site in the bottom row,then we
saythat the systempercolates. In other words, a systemper
colates if we fill all open sites connected to the top row and
that process fillssome open site on the bottom row. For the
insulating/metallic materials example, the open sites corre
spond to metallic materials, so that a system that percolates
has a metallic path from top to bottom, with full sites con
ducting. For the porous substance example, the open sites
correspond to empty space through which water might
flow, so that a systemthat percolatesletswater fillopen sites,
flowing from top to bottom.
In a famous scientificproblem that has been heavilystudied for decades, re
searchers are interested in the following question: if sites are independently set to
be open with vacancy probability p (and therefore blocked with probability 1—p)y
what is the probability that the system percolates? No mathematical solution to
this problem has yet been derived. Our task isto write computer programs to help
study the problem.
percolates
empty
open —*-|
site
287
blocked
site
full
-open
site
opensiteconnected to top
doesnotpercolate
no opensiteconnected to top
Percolation examples

288
Functions and Modules
Basic scaffolding
To address percolation witha Java program, weface numer
ous decisions and challenges, and we certainly will end up with much more code
than in the short programs that wehaveconsidered so far in this book. Our goal is
to illustratean incremental styleof programming whereweindependently develop
modules that address parts of the problem, building confidence
with a small computational infrastructure of our own design and
construction as we proceed.
The first step is to pick a representation of the data. This deci
sion can have substantial impact on the kind of code that we write
later, so it is not to be taken lightly. Indeed, it is often the case that
we learn something while working with a chosen representation
that causesus to scrap it and start allover using a new one.
For percolation, the path to an effective representation is
clear: use two-dimensionalarrays.What type of data should we use
for each entry? One possibility is to use integers, with a code such
as 0 to indicate an empty site, 1 to indicate a blocked site, and 2 to
indicatea fullsite.Alternatively, note that wetypicallydescribesites
in terms of questions: Is the site open or blocked?Is the site full or
empty? This characteristic of the entries suggests that wemight use
boolean matrices, where all entries are true or fal se.
Boolean matrices are fundamental mathematical objects
with manyapplications. Java itselfdoesnot providedirectsupport
for operations on boolean matrices, but we can use the methods
in StdArraylO (see Program 2.2.2) to read and write them. This
choiceillustrates a basicprinciplethat often comesup in program
ming: the effort required to build a more general tool usually pays
dividends. Using a natural abstraction such as boolean matrices is
preferable to usinga specialized representation.In the present con
text, it turns out that using boo!ean instead of i nt matrices also
leads to code that is easierto understand. Eventually, we willwant
to work with random data, but we also want to be able to read and
write to files because debugging programs with random inputs can
be counterproductive. With random data, you get different input
eachtime that you run the program;afterfixing a bug,what you want to seeis the
same input that you just used,to checkthat the fixwas effective. Accordingly, it is
best to start with some specific cases that weunderstand, kept in files formatted to
percolation system
blocked sites
opensites
0
0 11
0
1
0
1
1
0
1
full sites
0
0
1
Percolation representations

2.4 Case Study: Percolation
289
be read by StdArraylO. readBool ean2D() (dimensions followed by 0 and 1 values
in row-major order).
When you start working on a new problem that involves severalfiles, it is usu
allyworthwhile to create a new folder (directory) to isolatethose files from others
that you may be working on. For example, we might start with stdl i b. jar in a
folder named percol ati on, so that we have access to the methods in our libraries
StdArraylO.Java, Stdln.Java,StdOut.Java, StdDraw.Java, StdRandom.Java,
and StdStats. j ava. Wecan then implement and debug the basic code for reading
and writing percolation systems, create test files, check that the files are compat
ible with the code, and so forth, before really worrying about percolation at all.
This type of code, sometimes calledscaffolding, is straightforward to implement,
but makingsure that it is solidat the outset willsave us from distraction when ap
proaching the main problem.
Now we can turn to the code for testing whether a boolean matrix represents
a system that percolates. Referring to the helpful interpretation in which we can
think of the task assimulatingwhatwouldhappen ifthe top werefloodedwith wa
ter (doesit flowto the bottom or not?),our firstdesigndecisionisthat wewillwant
to have a flow() method that takes as an argument a two-dimensional boolean
arrayopen[] [] that specifies whichsites areopenand returns another two-dimen
sionalboolean array f ul1[] [] that specifies whichsites are full. For the moment,
wewillnot worry at allabout howto implementthis method;wearejust deciding
how to organize the computation.It is also clear that wewillwant client code to
be able to use a percolatesO method that checks whether the array returned by
f 1ow() has any full sites on the bottom.
Percolation (Program 2.4.1) summarizes these decisions. It does not per
form any interestingcomputation, but, after running and debuggingthis code we
can start thinking about actuallysolving the problem.A method that performs no
computation,suchasf1ow(),issometimes called a stub. Having thisstub allows us
to testand debugpercol ates () and mai n() in the context in which wewillneed
them. We refer to code like Program 2.4.1 as scaffolding. As with scaffolding that
construction workersuse when erectinga building,this kind of code providesthe
support that weneed to develop a program.Byfully implementingand debugging
this code (much, if not all, of which we need, anyway) at the outset, we provide a
sound basis for building code to solve the problem at hand. Often,we carry the
analogy one stepfurther and remove the scaffolding (or replace it with something
better) after the implementation is complete.

290
Functions and Modules
%k?i
§
£4
•••'.:•*'
1
m
:r0^ri^
pM^^ii^^^^^^
Program 2A.1
Percolation scaffolding
public class Percolation
{
public static boolean[][] flow(boolean[] [] open)
{
int N = open.length;
boolean[][] full
= new boolean[N][N];
// Percolation flow computation goes here,
return full;
}
public static boolean percolates(boolean[][] open)
{
boolean[][] full = flow(open);
int N = full.length;
for (int j = 0;
j < N; j++)
if (full[N-l][j]) return true;
return false;
}
N
full[][]
open[][]
public static void main(String[] args)
{
boolean[][] open = StdArraylO.readBoolean2D();
StdArrayIO.print(flow(open));
StdOut.pri ntln(percolates(open));
}
systemsize (N-by-N)
full sites
opensites
To get started with percolation, we implement and debug this code, which handles all the
straightforward tasks surrounding the computation. The primaryfunction flow() returns an
array giving the full sites (none, in the placeholder code here). The helper function perco-
1ates() checks the bottom row ofthe returned array to decide whether the system percolates.
The test client mai n() reads a boolean matrixfrom standard input andthen prints the result
ofcalling f1ow() and percol ates () for thatmatrix.

2.4 Case Study: Percolation
Vertical percolation
Given a boolean matrix that represents the open sites,
how do we figure out whether it representsa systemthat percolates? Aswe will see
at the end of this section, this computation turns out to be directly related to a
fundamental question in computer science. For the moment, we will consider a
much simpler version of the problem that we call vertical per
colation.
The simplification is to restrict attention to vertical con
nection paths. If such a path connects top to bottom in a sys
tem, we saythat the system vertically percolates along the path
(and that the system itself vertically percolates). This restric
tion is perhaps intuitive if we are talking about sand traveling
through cement,but not ifwearetalkingabout watertraveling
through cementor about electrical conductivity. Simpleasit is,
vertical percolation is a problem that is interesting in its own
right becauseit suggests variousmathematicalquestions. Does
the restriction make a significant difference? How many verti
cal percolation paths do weexpect?
Determining the sites that are filled by some path that
is connected vertically to the top is a simple calculation. We
initialize the top row of our result array from the top row of
the percolation system, with full sites corresponding to open
ones.Then, movingfromtop to bottom, wefill in each rowof
the arraybychecking thecorresponding rowof the percolation
system. Proceeding from top to bottom,we fill in the rows of ful1[] [] to mark
as true all entries that correspond to sites in open[] [] that are vertically con
nected to a full site on the previous row.Program 2.4.2is an
implementation of f 1ow() for Percol ation that returns a
boolean array of fullsites(true if connectedto the top via
a vertical path, f al se otherwise).
vertically percolates
site connectedto top
with a vertical path
doesnot vertically percolate
no open site connectedto
topwitha vertical path
Vertical percolation
291
connectedto top via a
vertical path offilled sites
Testing
Afterwebecome convincedthat our codeis be
having asplanned,wewantto run it on abroadervariety of
test cases and address some of our scientific questions. At
thispoint, our initialscaffoldingbecomes less useful, asrep
resenting largebooleanmatrices withOs and Is on standard
input and standard output and maintaininglargenumbers
H^-X!
notconnected to top
\|
via such apath
connected to top
viasuchapath
Vertical percolation calculation

292
Functions and Modules
mi
m
public static boolean[][] flow(boolean[] [] open)
{
// Compute full sites for vertical percolation
int N = open.length;
boolean[][] full
= new boolean[N][N];
for (int j = 0;
j
< N; j++)
full[0][j]
= open[0][j];
N
full[][]
open[][]
system size (N-by-N)
full sites
opensites
for (int i
= 1;
i
< N; i++)
for (int j
= 0;
j
< N; j++)
full[i][j] = open[i][j]
&& full [i-1] [j];
return full;
•^^^^^^^^^^^^p^^
Substituting this methodforthe stub inProgram 2.4.2 gives asolution to the vertical-onlyper
colation problem that solves our test case asexpected (see text).
'^^^^S^^^^^^^^^^^^^^^^^'
^^^P^S^^^^5^^^^^^^^/^^^
^WS^P^P
of testcases quickly becomes uninformative and unwieldy. Instead, wewantto au
tomatically generatetest cases and observe the operation of our code on them, to
besurethat it isoperating asweexpect. Specifically, to gainconfidence in our code
and to develop abetterunderstanding ofpercolation, our nextgoals areto:
• Testour code for large random inputs.
• Estimate the probabilitythat a system percolates for a given p.
To accomplish these goals, we neednewclients that areslightly moresophisticated
thanthescaffoldingwe used toget theprogram upandrunning. Ourmodular pro
gramming style isto develop suchclients in independent classes without modifying
ourpercolation codeat all.

2.4 Case Study: Percolation
293
Data visualization. We can work with much bigger problem instances if we use
StdDraw for output. The following static method for Percolation allows us to
visualize the contents of boolean matrices as a subdivision of the StdDraw canvas
into squares, one for each site.
public static void show(boolean[][] a, boolean which)
{
int N = a.length;
StdDraw.setXscale(-l,
N);
StdDraw.setYscale(-l,
N);
for (int i
= 0;
i
< N; i++)
for (int j
= 0;
j
< N; j++)
if (a[i][j] == which)
StdDraw.fi11edSquare(j, N-i-1,
.5);
}
The second argument which specifieswhether we want to display the entries cor
responding to true or to f al se. This method is a bit ofa diversion from the calcu
lation, but paysdividends in its abilityto help us visualize large problem instances.
Using show() to draw our arrays representing blocked and full sites in different
colors gives a compelling visual representation of percolation.
Monte Carlo simulation. Wewant our code to work properly for anyboolean
matrix. Moreover, the scientific question of interest involvesrandom matrices. To
this end, we add another static method to Percol ati on:
public static boolean[][]
random(int N, double p)
{
boolean[][]
a = new boolean[N] [N];
for (int i =0;
i
< N; i++)
for (int j
= 0;
j
< N; j++)
a[i][j] = StdRandom.bernoulli(p);
return a;
}
This method generates a random N-by-N matrix of any givensize,each entry true
with probability p. Having debugged our code on a few specific test cases, we are
ready to test it on random systems. It is possible that such cases may uncover a few
more bugs,so some care is in order to checkresults.However, having debugged our
code for a small system, we can proceed with some confidence. It is easier to focus
on new bugs after eliminating the obvious bugs.

294
Functions and Modules
With these tools, a client for testing our percolation code on a much larger set
of trials is straightforward. Visualize (Program 2.4.3) consists of just a main()
method that takes N and p from the commandline,generates Ttrials (takingthis
number from the command line), and displays the result of the percolation flow
calculation for each case,pausing for a brief time between cases.
This kind of client is typical. Our eventual goal is to compute an accurate
estimate of percolation probabilities, perhaps by running a large number of tri
als,but this simple tool gives us the opportunity to gain more familiarity with the
problem by studying some large cases (whileat the same time gaining confidence
that our code is working properly). Before reading further, you are encouraged to
download and run this code from the booksite to study the percolation process.
When you run Visual i ze for moderate sizeN (50 to 100,say) and various p, you
will immediately be drawn into using this program to try to answer some questions
about percolation. Clearly, the system never percolates when p is low and always
percolates when p is very high. How does it behave for intermediate values of p?
How does the behavior change as N increases?
Estimating probabilities
Thenextstep in our programdevelopment process
is to write code to estimate the probability that a random system (of size N with
site vacancy probability p) percolates. We refer to this quantity as the percolation
probability. To estimate its value, we simply run a number of experiments. The
situation is no different than our study of coin flipping (see Program 2.2.6), but
instead of flipping a coin, we generate a random system and check whether or not
it percolates.
Esti mate (Program 2.4.4)encapsulatesthis computation in a method eval ()
that returns an estimate of the probability that an N-by-N systemwith sitevacancy
probability p percolates,obtained by generating Trandom systemsand calculating
the fraction of them that percolate. The method takes three arguments: N, p, and
T.
How many trials do we need to obtain an accurate estimate? This question
is addressed by basic methods in probability and statistics, which are beyond the
scope of this book, but we can get a feeling for the problem with computational
experience. With just a few runs of Estimate, you can learn that the site vacancy
probability is close to 0 or very close to 1, then we do not need many trials, but
that there are values for which we need as many as 10,000 trials to be able to esti
mate it within two decimal places.To study the situation in more detail, we might

2.4 Case Study: Percolation
Program 2.4.3
Visualization client
public class Visualize
{
public static void main(String[] args)
{
int N
= Integer.parselnt(args[0]);
double p = Double.parseDouble(args[l]);
int T
= Integer.parselnt(args[2]);
for (int t = 0; t < T; t++)
{
boolean[][] open = Percolation.random(N,
p);
StdDraw.clear();
StdDraw.setPenColor(StdDraw.BLACK);
Percolation.show(open, false);
StdDraw.setPenColor(StdDraw.BLUE);
boolean[][] full
= Percolation.flow(open);
Percolation.show(full, true);
StdDraw.show(lOOO);
>
>
N
P
T
open[][]
full[][]
295
system size (N-by-N)
sitevacancy probability
numberof trials
opensites
full sites
-mmmmmmMMm
This client generates N-by-N random instances with sitevacancy probability p, computes the
directed percolationflow, anddraws the result onStdDraw. Such drawings increase confidence
thatour code is operating properly and help develop an intuitive understanding ofpercola
tion.

296
Functions and Modules
modify Estimate to produce output like Bernoulli (Program 2.2.6), plotting a
histogram of the data points so that we can see the distribution of values (see Ex
ercise 2.4.10).
Using Estimate. eval () represents a giant leap in the amount of computa
tion that we are doing. All of a sudden, it makes sense to run thousands of trials.
It would be unwise to try to do so without first having thoroughly debuggedour
percolation methods. Also, we need to begin to take the time required to complete
the computation into account. The basic methodology for doing so is the topic of
Section 4.1, but the structure of these programs is sufficientlysimple that we can
do a quick calculation,which we can verifyby running the program. Weare doing
T trials, each of which involve N2 sites, so the total running time of Estimate,
eval () is proportional to N2T. If we increase T by a factor of 10 (to gain more
precision), the running time increasesby about a factor of 10.If we increase JV by
a factor of 10 (to study percolation for larger systems),the running time increases
by about a factor of 100.
Can we run this program to determine percolation probabilities for a system
with billions of siteswith several digits of precision? No computer is fast enough
to use Esti mate. eval () for this purpose. Moreover,in a scientific experiment on
percolation, the value of N is likelyto be much higher.Wecan hope to formulate a
hypothesisfrom our simulationthat canbe testedexperimentallyon a much larger
system,but not to preciselysimulatea systemthat corresponds atom-for-atom with
the real world. Simplification of this sort is essential in science.
You are encouraged to download Esti mate from the booksite to get a feelfor
both the percolation probabilities and the amount of time required to compute
them. When you do so,you are not just learning more about percolation, but also
you are testing the hypothesis that the models we have just described apply to the
running times of our simulations of the percolation process.
What isthe probabilitythat a system with sitevacancyprobabilityp vertically
percolates? Vertical percolation is sufficiently simple that elementary probabilistic
models can yield an exact formula for this quantity, which we can validate experi
mentally with Estimate. Since our only reason for studying vertical percolation
wasan easystarting point around whichwecould develop supporting softwarefor
studyingpercolation methods,weleave further study of verticalpercolation for an
exercise (seeExercise 2.4.11)and turn to the main problem.

2.4 Case Study: Percolation
297
$0<
m
||
^MSMM£^^
Program 2.4.4
Percolation probability estimate
public class Estimate
{
public static double eval(int N, double p, int T)
{
// Generate T random networks,
return empirical
// percolation probability estimate.
int cnt = 0;
for (int t
= 0;
t
< T;
t++)
{
// Generate one
random network.
boolean[][] open = Percolation.random(N,
p);
if (Percolation.percolates(open)) cnt++;
}
return (double) cnt / T;
}
public static void main(String[] args)
{
int N
= Integer.parselnt(args[0]);
double p = Double.parseDouble(args[l]);
int T
= Integer.parselnt(args[2]);
double q = eval(N,
p, T);
StdOut.println(q);
N
P
T
open[][]
q
system size (N-by-N)
site vacancy probability
number oftrials
open sites
percolation probability
}
•^^^^^m^^m^^mmmm^
}
To estimate theprobability thata network percolates, wegenerate random networks andcom
putethefraction ofthem thatpercolate. This isa Bernoulli process, nodifferent than coin flip
ping(see Program 2.2.6).Increasing the number oftrials increases the accuracy ofthe estimate.
If thesitevacancy probability isclose to0 orto 1,notmany trials areneeded.
% Java Estimate 20 .5 10
0.0
% Java Estimate 20 .75 10
0.0
% Java Estimate 20 .95 10
1.0
% Java Estimate 20 .85 10
0.7
% Java Estimate 20 .85 1000
0.564
% Java Estimate 20
.85 1000
0.561
% Java Estimate 40
.85 100
0.1
^^^^•^^•^^S^^^^^^^'^P^W-

298
Functions and Modules
Recursive solution for percolation
Howdo wetestwhethera system perco
latesin the generalcasewhen any path starting at the top and ending at the bottom
(not just a vertical one) will do the job?
Remarkably, we can solvethis problem with
a compact program, based on a classic recursive
schemeknown asdepth-firstsearch. Program 2.4.5
is an implementation of flow() that computes
the flowarray,based on a recursivefour-argument
version of f 1ow() that takes as arguments the site
vacancy array open[] [], the flow array full []
[], and a site position specifiedby a row index i
and a column index j. The base case is a recursive
call that just returns (we refer to such a call as a
nullcall),for one of the followingreasons:
• Either i or j are outside the array bounds.
• The site is blocked (open [i ] [j] is f al se).
• Wehavealreadymarked the siteas full
(full[i][j] is true).
The reduction case is to mark the site as filled and
issue recursive calls for the site's four neighbors:
open[i+l][j], open[i][j+l], open[i] [j-1],
and open[i-l] [j]. To implement flow(), we
call the recursive method for every site on the
top row.The recursion always terminates because
each recursive call either is null or marks a new
site as full. We can show by an induction-based
argument (as usual for recursive programs) that a
site is marked as full if and only if it is connected
to one of the sites on the top row.
Tracing the operation of flow() on a tiny
test case is an instructive exercise in examining
the dynamics of the process. The function calls
itself for every site that can be reached via a path of open sites from the top. This
example illustrates that simple recursive programs can mask computations that
otherwise are quite sophisticated.This method is a specialcaseof the classicdepth-
first search algorithm, which has many important applications.
flow(...,0,0)
flow(.
flow(...,l,4)
,2,4)
.,3,4)
flow(...,3,3)
flow(...,4,3)
flow(...,3,2)
1 flow(...,2,2)
Recursive percolation (nullcalls omitted)

2.4 Case Study: Percolation
Program2.4.5
Percolationdetection
public static boolean[][] flow(boolean[] [] open)
{
// Fill every site reachable from the top row.
int N a open.length;
boolean[][] full
= new boolean[N][N];
for (int j = 0;
j < N; j++)
flow(open,
full, 0, j);
return full;
}
public static void flow(boolean[] [] open,
boolean[][] full,
{
// Fill every site reachable from (i,
int N = full.length;
if (i < 0 || i
>= N) return;
if (j < 0 jj j >= N) return;
if (!open[ij [j]) return;
if (full[i][j])
return;
full[i][j]
flow(open,
flow(open,
flow(open,
flow(open,
= true;
full,
i+1,
j);
full,
i, j+1);
full,
i,
j-1);
full,
i-1,
j);
// Down.
// Right.
// Left.
// Up.
299
Substituting these methodsforthe stub inProgram 2.4.1 gives a depth-first-search-based solu
tion tothe percolation problem. The recursive f1ow()fills sites by setting totrue the entry in
f ul1[] [] corresponding toanysitethat can bereachedfrom open[i ] [j] via apath ofopen
sites. The one-argument f1ow() calls the recursive methodforevery siteonthe top row.
% more test8.txt
8
8
I
wmmmmmmmmmm*
% Java Percolation < test8.txt
8
8
true
wmmmmmmmmmmmmmwm:
*

300
Functions and Modules
To avoid conflict with our solution for vertical percolation (Program 2.4.2),
we might rename that class Percol ati onEZ, making another copy of Percola
tion (Program 2.4.1) and substituting the two flow() methods in Program 2.4.5
for the placeholder f low(). Then, we can visualize and perform experiments with
this algorithm with the Visual i ze and Experi ment tools that we have developed.
Ifyou do so,and try various valuesfor N andp, you willquicklyget a feelingfor the
situation: the systemsalways percolatewhenp ishigh and never percolate whenp is
low,and (particularly as N increases) there is a value of p above which the systems
(almost) always percolate and belowwhich they (almost) never percolate.
% java Visualize 20 .65 1
% Java Visualize 20 .60 1
% Java Visualize 20 .55 1
Percolation is less probable as thesitevacancyprobability decreases
Having debuggedVisualize and Experiment on the simple vertical percolation
process, we can use them with more confidence to study percolation, and turn
quickly to study the scientific problem of interest.Note that if we want to experi
ment with vertical percolation again, we would need to edit Visualize and Ex
periment to refer to Percol ati onEZ instead of Percolation, or write other cli
ents ofboth Pe r col ati onEZ and Pe r col ati on that run methods in both classes to
compare them.
Adaptive plot
Togain more insightinto percolation,the next step in program
developmentisto write a program that plots the percolation probabilityas a func
tion of the site vacancyprobabilityp for a given value of N. Perhaps the best way
to produce such a plot is to first derivea mathematical equation for the function,
and then use that equation to make the plot. For percolation, however, no one has
been able to derive such an equation, so the next option is to use the Monte Carlo
method: run simulations and plot the results.

2.4 Case Study: Percolation
Immediately, we are faced with numerous decisions. For how many valuesof
p should wecompute an estimateof the percolationprobability? Which valuesofp
should we choose? How much precision should we aim for in these calculations?
Thesedecisions constitute an experimental design problem.Muchaswemight like
to instantlyproduce an accuraterendition of the curvefor anygivenJV, the compu
tation cost can be prohibitive.For example,the firstthing that comes to mind is to
plot, say, 100to 1,000 equallyspacedpoints, usingStdStats (Program 2.2.5).But,
as you learned from using Esti mate, computing a sufficiently precisevalue of the
percolation probability for each point might take several seconds or longer, so the
whole plot might take minutes or hours or evenlonger.Moreover, it is clear that a
lot of this computation time is completelywasted, becauseweknow that valuesfor
smallp are 0 and values for largep are 1.Wemight prefer to spend that time on
more precise computations for intermediate p. How should we proceed?
PercPlot (Program 2.4.6) implements a recursive
approach with the same structure as Brownian (Program
2.3.5)that iswidelyapplicableto similarproblems.The ba
sic idea is simple: we choose the minimum distance that we
want between values of the x-coordinate (which we refer to
as the gap tolerance), the minimum known error that we
wishto tolerate in the/-coordinate (whichwereferto asthe
error tolerance), and the number of trials Tper point that
we wish to perform. The recursive method draws the plot
within a given interval [x0, xj, from (x0, yQ) to (xvyx). For
our problem, the plot is from (0,0) to (1,1). The base case (if the distance between
x0 and xx islessthan the gaptolerance, or the distance between the line connecting
the two endpoints and the valueof the function at the midpoint islessthan the er
ror tolerance) isto simply drawa linefrom (x0,y0) to (xvyl). The reduction stepis
to (recursively) plot the twohalves of the curve, from (x0,y0) to (xm,ym) and from
(xm>ym)to{xvyl).
Thecodein PerePIot isrelatively simple and produces a good-looking curve
at relativelylowcost.Wecan useit to studythe shapeof the curvefor variousvalues
of AT or choose smaller tolerances to be more confident that the curve is close to the
actualvalues. Precise mathematicalstatementsabout qualityof approximation can,
in principle,be derived,but it isperhaps not appropriate to gointo too much detail
whileexploringand experimenting,sinceour goalis simplyto develop a hypoth
esisabout percolation that can be tested by scientificexperimentation.
error
tolerance
301
(xvy0
Adaptive plot tolerances

302
Functions and Modules
^^rv^sz}^
Program 2.4.6
Adaptiveplot client
public class PercPlot
{
public static void curve(int N,
double xO,
double yO,
double xl, double yl)
{
// Perform experiments and plot results,
double gap = .005;
double err = .05;
int T
= 10000;
double xm
= (xO + xl)/2;
double ym
= (y0 + yl)/2;
double fxm = Estimate.eval(N,
xm, T);
if (xl - xO < gap && Math.abs(ym -
fxm) < err)
{
StdDraw.line(xO,
yO,
xl,
yl);
return;
}
curve(N,
xO,
yO,
xm,
fxm);
StdDraw.filledCircle(xm,
fxm,
.005);
curve(N,
xm,
fxm, xl, yl);
}
}
public static void main(String[] args)
{
// Plot experimental curve for N-by-N percolation system
int N = Integer.parselnt(args[0]);
curve(N, 0.0, 0.0, 1.0, 1.0);
}
N
xO,
yO
xl, yl
xm,
ym
fxm
gap
err
T
system size
leftendpoint
rightendpoint
midpoint
valueat midpoint
gap tolerance
error tolerance
number of trials
This recursive program draws aplotofthepercolation probability (experimental observations)
against the sitevacancy probability (control variable).
% Java PercPlot 20
l-
perxolation
probability
0
0.593
1
site vacancy probability p
9
^m^^^^^^^^^^^^^^^0^§^]^t^^^^^^^«>^^^^^^^^"
1
i % Java PercPlot 100
;
l-
percolation
probability
0
0.593
1
site vacancy probability p
s
4IfWlPro^

2.4 Case Study: Percolation
303
Indeed, the curves produced by PercPlot immediately confirm the hypoth
esis that there is a threshold value (about .593): ifp is greater than the threshold,
then the system almostcertainly percolates; ifp is less than
the threshold, then the system almost certainly does not per
colate. As N increases, the curve approaches a step function
that changes valuefrom 0to 1at the threshold.Thisphenom
enon, known as aphase transition, is found in manyphysical
systems.
The simple form of the output of Program 2.4.6masks
the hugeamount of computationbehind it.Forexample, the
curve drawn for JV = 100 has 18 points, each the result of
10,000 trials, each trial involving JV2 sites. Generating and
testingeachsiteinvolves a fewlinesofcode,sothisplot comes
at the cost of executing billions of statements. There are two
lessons to be learned from this observation: First, we need to
have confidence in any line of code that might be executed
billions of times, so our care in developing and debugging
codeincrementallyisjustified. Second, althoughwemightbe
interested in systems that are much larger, we need further
study in computer scienceto be to handle larger cases: to de
velop faster algorithms and a framework for knowing their
performance characteristics.
With this reuse of all of our software,we can study all
sorts of variants on the percolation problem, just by imple
menting different f1ow() methods. For example, if you leave
out the last recursive call in the recursive flow() method in
Program 2.4.6,it tests for a type of percolation known as di
rectedpercolation, where paths that go up are not considered.
This model might be important for a situation like a liquid
percolating through porous rock, where gravitymight play a
role,but not for a situation likeelectrical connectivity. Ifyou
run PercPlot for both methods, will you be able to discern
the difference (see Exercise 2.4.5)?
To model physical situations such as water flowing
through porous substances, we need to use three-dimensional arrays. Is there a
similar threshold in the three-dimensional problem? If so,what is its value? Depth-
PercPlot.curveO
Estimate.evalO
Percolation.random()
StdRandom.bernoul1i()
•
N2 times
StdRandom.bernoulli()
return
Percolati on.percolates()
flow()
return
return
• T times
Percolation. random 0
StdRandom.bernoul1 iO
•
N2 times
StdRandom.bernoul1i()
return
Pe rcolati on.percolates()
flowO
return
return
return
. oncefor eachpoint
Estimate.eval()
Pe rcolati on.random()
StdRandom.bernoul1i()
•
N2 times
StdRandom.bernoul1i()
return
Percolation.percolates()
flowO
return
return
• T times
Percolation. randomO
StdRandom.bernoul1i()
•
M2 times
StdRandom.bernoul1i()
return
Percolati on.percolates()
flowO
return
return
return
return
Call tracefor Java PercPlot

304
Functions and Modules
firstsearch is effective for studying this question, though the addition of another
dimension requires that wepayeven moreattentionto the computational costof
determiningwhethera system percolates (seeExercise 2.4.19). Scien
tists also study more complex lattice structures that are not well-
modeledbymultidimensional arrays—we willseehowto modelsuch
structures in Section 4.5.
Percolation is interesting to study via in silico experimentation
because no one has been able to derive the threshold value mathemat
ically for several natural models. The only waythat scientists know
the valueisby usingsimulations like Percol ati on.Ascientistneeds
to do experimentsto seewhetherthe percolation model reflects what
is observed in nature, perhaps through refining the model (for ex
ample, using a different lattice structure). Percolation is an example
of an increasingnumber of problems where computer scienceof the
kind describedhere is an essential part of the scientificprocess.
percolates (pathnevergoesup)
doesnotpercolate
Directedpercolation
LessoBS
Wemight have approached the problem of studying per
colation by sitting down to design and implement a single program,
which probably would run to hundreds of lines, to produce the kind of plots that
are drawn by Program 2.4.6. In the early days of computing, programmers had
little choicebut to work with such programs, and would spend enormous amounts
of time isolatingbugs and correcting designdecisions.With modern programming
tools like Java, we can do better, using the incremental modular style of program
ming presented in this chapter and keeping in mind some of the lessons that we
have learned.
Expect bugs. Every interesting piece ofcodethat youwriteisgoingto have at least
one or two bugs, if not many more. Byrunning small pieces of code on small test
cases that you understand, you can more easily isolate any bugs and then more
easilyfix them when you find them. Once debugged, you can depend on using a
library as a building block for any client.
Keep modules small. You canfocus attentionon at mosta few dozenlinesofcode
at a time, so you may as well break your code into small modules as you write it.
Some classesthat contain libraries of related methods may eventually grow to con
tain hundreds of lines of code; otherwise, we work with small files.

2.4 Case Study: Percolation
Limit interactions. In a well-designed modular program, most modules should
depend on just a few others. In particular, a module that calls a large number of
other modules needs to be divided into smaller pieces. Modules that arecalled bya
large number of other modules (you should have only a few) need special atten
tion, becauseifyou do need to makechanges in a module'sAPI,you haveto reflect
those changes in all its clients.
Develop code incrementally. You should runanddebug each small module asyou
implement it. That way, you are neverworkingwith more than a fewdozen lines of
unreliable code at any giventime. If you put
all your code in one big module, it is diffi
cult to be confident that anyof it issafefrom
bugs. Running code earlyalsoforces you to
think sooner rather than later about I/O for
mats, the nature of problem instances, and
other issues. Experiencegainedwhen think
ing about such issues and debuggingrelated
code makes the code that you developlater
in the process more effective.
Solve an easier problem. Some working
solution is better than no solution, so it is
typicalto begin byputting together the sim
plest code that you can craft that solves a
given problem, as we did with vertical-only
percolation. This implementation is the first
step in a process of continual refinements
and improvements aswe develop a morecomplete understanding of the problem
byexamining abroadervariety oftestcases anddeveloping supportsoftware such
as our Visual i ze and Experi ment classes.
305
Case study dependencies (notincluding system calls)
Consider a recursive solution. Recursion isanindispensable tool inmodern pro
grammingthat you should learn to trust. If you are not already convinced of this
fact bythesimplicity andelegance of PercPlot and Percolati on,youmightwish
to try to develop a nonrecursive program for testingwhether a system percolates
and then reconsider the issue.

306
Functions and Modules
Build tools when appropriate. Our visualization method show() and random
boolean matrix generation method random() are certainly useful for many other
applications, as is the adaptiveplotting method of PercPlot. Incorporating these
methods into appropriate librarieswouldbe simple.It isno more difficult(indeed,
perhapseasier) to implementgeneral-purpose methodslikethesethan it wouldbe
to implement special-purpose methods for percolation.
Reuse software when possible. OurStdin, StdRandom, and StdDraw libraries all
simplified the process of developing the codein this section, and wewere also im
mediately able to reuse programs suchas PercPlot, Esti mate, and Vi sual i ze for
percolation afterdeveloping them for vertical percolation. After you have written
a few programs of thiskind, youmightfind yourself developing versions of these
programs that you can reuse for other Monte Carlo simulations or other experi
mental data analysis problems.
The primary purpose of this case studyis to convince you that modular program
mingwill take you muchfurther than youcould getwithout it.Although no ap
proach to programming is a panacea, the tools and approach that we have dis
cussed in this section will allow you to attack complex programming tasks that
might otherwise be farbeyondyour reach.
The success of modular programming is only a start. Modern programming
systems have avastlymore flexible programming modelthantheclass-as-a-library-
of-fiinctions model that we have been considering. In the next two chapters, we
develop thismodel, along withmanyexamples that illustrate its utility.

2.4 Case Study: Percolation
Q. Editing Visualize and Estimate to rename Percolation to PercolationEZ
or whatever methodwewantto studyseems to bea bother. Istherea way to avoid
doing so?
A. Yes, this is a keyissue to be revisited in Chapter 3. In the meantime, you can
keepthe implementations in separate subdirectories and usethe classpath, but that
can getconfusing. Advanced Java language mechanisms are also helpful, but they
alsohave their own problems.
Q. That recursive flowO method makes me nervous. How can I better under
stand what it's doing?
A. Runit for smallexamples ofyour ownmaking, instrumentedwith instructions
to print a function call trace.Aftera few runs, you will gain confidencethat it al
ways fills the sitesconnected to the start point.
Q. Isthere a simplenonrecursive approach?
A. There are several methods that perform the samebasiccomputation. Wewill
revisit the problem at the end of the book, in Section 4.5. In the meantime, work
ing on developing a nonrecursive implementation of flow() is certain to be an
instructive exercise,if you are interested.
Q. PrecPlot (Program 2.4.6) seems to involve ahuge amountofcalculation to get
a simplefunction graph. Isthere somebetter way?
A. Well, the best would be a mathematical proof of the threshold value, but that
derivation has eluded scientists.
307

308
Functions and Modules
2.4.1
Write a program that takesN from the command line and createsan N-
by-Nmatrixwiththe entryin rowiand columnj setto t rue if i andj arerelatively
prime,then shows the matrixon the standarddrawing (see Exercise 1.4.13). Then,
write a similar program to draw the Hadamard matrix of order N (see Exercise
1.4.25) and the matrix suchwith the entry in rowN and columnj setto t rue if the
coefficient of a* in (l+x)N (binomial coefficient) is odd (see Exercise 1.4.33). You
maybe surprised at the pattern formed by the latter.
2.4.2
Implement a pri nt() method for Percol ati on that prints 1 for blocked
sites,0 for open sites,and * for full sites.
2.4.3
Givethe recursive callsfor Percol ati on given the following input:
3
0
1
0
0
1
0
2.4.4
Write a client of Percol ati on like Visual i ze that does a series of experi
ments for a value of N taken from the command line where the site vacancy prob
abilityp increases from 0 to 1by a givenincrement (alsotaken from the command
line).
2.4.5
Createa program Percol ati onDi rected that testsfor directed percolation
(by leaving off the last recursive callin the recursive show() method in Program
2.4.5, as described in the text), then use PercPlot to draw a plot of the directed
percolationprobabilityas a function of the sitevacancyprobability.
2.4.5
Write a client of Pe rcol ati on and Pe rcol ati onDi rected that takes a site
vacancyprobabilityp from the command line and prints an estimate of the prob
ability that a system percolatesbut does not percolate down. Use enough experi
ments to get an estimate that is accurate to three decimal places.
2.4.6
Describe the order in which the sites are marked when Percolation is
used on a systemwith no blocked sites.Which is the last site marked?What is the
depth of the recursion?

2.4 Case Study: Percolation
2.4.7
Experimentwith using PercPlot to plot variousmathematicalfunctions
(justbyreplacing the call on Esti mate.eval () withan expression that evaluates
thefunction). Try thefunction si n(x) + cos(10*x) tosee how theplotadapts to
an oscillating curve, and comeup withinteresting plotsfor threeor four functions
of your own choosing.
2.4.8
Modify Percolati on to animate theflow computation, showing thesites
filling onebyone.Check youranswer to theprevious exercise.
2.4.9
Modify Percolation to compute that maximum depth of the recursion
used in theflow calculation. Plot theexpected value ofthatquantity asa function
ofthesite vacancy probabilityp.How does your answer change iftheorder ofthe
recursive calls is reversed?
2.4.10 Modify Estimate to produce output like that produced by Bernoulli
(Program 2.2.6). Extra credit'. Use your program tovalidate thehypothesis thatthe
data obeys the Gaussian (normal) distribution.
309

310
Functions and Modules
Vreml^B^m^USs.
2.4.11 Verticalpercolation. Showthatasystem withsite vacancyprobabilitypver
ticallypercolateswith probability 1- (1 - pN)N, anduse Esti mate tovalidateyour
analysis forvariousvalues of N.
2.4.12 Rectangular percolation systems. Modify the code in this section to allow
you to study percolation in rectangular systems. Compare thepercolation prob
ability plots ofsystems whose ratio ofwidth to height is 2 to 1with those whose
ratio is 1 to 2.
2.4.13 Adaptive plotting. Modify PercPlot to take its control parameters (gap
tolerance, error tolerance, and number of trials) from the command line. Experi
mentwithvarious values oftheparameters tolearn theireffect onthequalityofthe
curve and the costof computing it.Briefly describe yourfindings.
2.4.14 Percolation threshold. Write a Percolation client that uses binary search
to estimate the threshold value (see Exercise 2.1.29).
2.4.15 Nonrecursive directedpercolation. Write a nonrecursive program that tests
for directed percolation bymoving from top tobottom as in ourvertical percola
tioncode. Baseyour solution onthefollowing computation: ifanysite inacontigu
ous subrow of open sites in thecurrent row isconnected to some full site on the
previous row, thenall ofthesites inthesubrow become full.
connected totop viaapathof
filledsites thatnever goes up
notconnected to top
(bysuch apath)
connected to top
Directed percolation calculation

2.4 Case Study: Percolation
2.4.16 Fast percolation test. Modify the recursive flowO method in Program
2.4.5 so that it returns as soon as it finds a site on the bottom row (and fillsno more
sites).Hint. Use an argument done that is true if the bottom has been hit, f al se
otherwise. Give a rough estimate of the performance improvement factor for this
change when running PercPlot. Use values of N for which the programs run at
leasta few seconds but not morethana few minutes. Note thatthe improvement is
ineffective unless the first recursive call in f 1ow() is for the site below the current
site.
2.4.17 Bondpercolation. Write a modular program forstudying percolation un
dertheassumption thattheedges ofthegrid provide connectivity. Thatis, anedge
canbe eitheremptyor full, and a system percolates if thereisa path consisting of
full edges that goes from top to bottom.Note: Thisproblem hasbeen solved ana
lytically, so your simulations should validate the hypothesis that the percolation
thresholdapproaches 1/2asJV gets large.
2.4.19 Percolation in three dimensions. Implement a class Percol ati on3D and
a class BooleanMatrix3D (forI/O and random generation) to study percolation
in three-dimensional cubes, generalizing the two-dimensional case studied in this
chapter. Apercolation system isan AT-by-N-by-JV cubeof sites that are unit cubes,
each open withprobabilitypandblocked with probability 1-p. Paths canconnect
anopen cube with any open cube thatshares acommon face (one ofsix neighbors,
except on the boundary). The system percolates if there exists a path connecting
anyopensiteon thebottom planeto anyopensiteonthetop plane. Use a recursive
version of f1ow() like Program 2.4.5, but witheightrecursive calls insteadof four.
Plot percolation probability versus site vacancy probability foraslarge a value of
N asyou can.Be sure to develop your solution incrementally, as emphasized
throughout this section.
2.4.18 Bond percolation on a triangular grid. Write a modular program for
studying bondpercolation on a triangular grid, where thesystem iscomposed
of 2N1 equilateral triangles packed together in an N-by-N grid of rhombus
shapes. Each interior pointhas six bonds; each pointontheedge hasfour; and
each corner point has two.
311
does not
does not

312
Functions and Modules
2.4.20 Game oflife. Implement a class Li fe that simulates Conway's game oflife.
Consider a boolean matrix correspondingto a system of cells that we refer to as
beingeitherlive or dead. Thegame consists of checking and perhapsupdatingthe
value of each cell, depending on the values of its neighbors (the adjacentcells in
every direction, including diagonals). Live cells remain live and deadcells remain
dead, with the following exceptions:
• A dead cellwith exactly three live neighborsbecomeslive.
•Alive cellwith exactly one live neighborbecomesdead.
• Alivecellwith more than three liveneighbors becomesdead.
Initializewith a random matrix, or use one of the starting patterns on the booksite.
Thisgame hasbeenheavily studied, andrelates to foundations ofcomputerscience
(see the booksite for more information).
HI eH mH pM\ We.
time t
timet+l
time t+2
time t+3
time H-4
Five generations ofaglider

2.4 Case Study: Percolation
313

&^8^^^^^

3.1
Data Types
316
3.2
Creating Data Types
370
3.3
Designing Data Types
416
3.4
Case Study: N-body Simulation . . . 456
Your next stepto programming effectivelyis conceptuallysimple. Now that you
knowhowto useprimitive types of data,youwill learnin this chapterhowto
use, create, and design higher-level data types.
Anabstraction isasimplified description ofsomething thatcaptures itsessen
tialelements while suppressing all otherdetails. In science, engineering, and pro
gramming, wearealways striving to understand complex systems through abstrac
tion. In Java programming, wedo sowith object-orientedprogramming, wherewe
breaka large and potentially complex program into a setof interacting elements,
or objects. The ideaoriginates frommodeling (in software) real-world entitiessuch
as electrons, people, buildings, or solar systems and readily extends to modeling
abstract entities suchasbits,numbers, colors, images, or programs.
A data type is a set of values and a set of operationsdefinedon those values.
Thevalues and operations for primitivetypessuchasi nt and double arebuilt into
the Java language. In object-oriented programming, wewrite Java code to create
newdatatypes. Anobjectisanentity thatcantake onadata-type value. Anobject's
value canbe returnedto a client or changed byoneofitsdatatype's operations.
Thisability to define newdatatypes andto manipulate objects holdingdata
type values is also known as data abstraction, and leads us to a style of modular
programming that naturally extends the function abstraction style for primitive
typesthat wasthe basisfor Chapter 2.A data type allows us to isolatedata aswell
asfunctions. Our mantraforthischapter isthis: Wheneveryou can clearly separate
data andassociated tasks within a computation, you should doso.
315

Object-Oriented Programming
3a1
Data Types
Organizing data for processing is an essential step in the development of a com
puter program. Programming in Java islargely basedon doing so with data types
known as reference types that are designed to support object-oriented program
ming,a styleof programming that facilitates
organizingand processingdata.
3.1.1
Charged particles
320
The eightprimitive data types (bool-
3.1.2
Albers squares
.325
ean, byte, char, double, float, int, long,
3*L3
Luminance library
. . . .328
,
,
N .
,
,
.
3.1.4
Converting color to grayscale. . . .331
and short) that you have been using are
315 Imagescaling
333
supplemented in Java by extensive libraries
3.1.6
Fade effect
335
of reference types that are tailored for a large
3.1.7
Visualizing electric potential .... 337
variety ofapplications. Stri ng is one exam-
3-1-8
Finding genes in agenome
342
pie of such a type that you have used. You
' '
oncaena n8
es • • • • • • • • •
r
/r
/
3.1.10 Screen scraping forstockquotes . .349
will learn more about the String data type
3#L11 splittingafile
.350
in this section, as well as how to use several
n
. ....
'
.
.
Programs in thissection
other reference types for image processing
and input/output. Some of them are built
into Java (String and Color), and some were developed for this book (In, Out,
Draw, and Pictu re) and areusefulasgeneral resources, likethe Std* staticmethod
libraries that we introduced in Section 1.5.
You certainlynoticed in the firsttwo chaptersof this book that our programs
were largely confined to operations on numbers. Of course, the reasonisthat Java's
primitive types represent numbers; however, with reference types you can write
programs that operate on strings, pictures, sounds, or any of hundreds of other
abstractions that are available in Java's standard libraries or on the booksite.
Even more significant than this largelibrary of predefined data types is the
idea that the range of data types that are available to you in Javaprogramming is
open-ended,because you can defineyour own data types to implementanyabstrac
tion whatsoever. This ability is crucial in modern programming. No library can
meet the needs of all possibleapplications, so programmers routinely build data
typesto meet their own needs.You willlearn how to do so in Section 3.2.
In this section, we focus on client programs that use data types, to giveyou
some concrete referencepoints for understanding these new concepts and to illus
trate their broad reach. Wewill consider programs that manipulate colors, images,
strings,files, and web pages—quite a leap from the primitive types of Chapter 1.

3.1 Data Types
Basic definitions.
Adata type isa setofvalues anda setofoperations defined
on those values. This statement is one of several mantras that we repeat often be
cause of its importance. In Chapter 1,we discussed in detail Java's primitive data
types:for example,the valuesof the primitive data type i nt are integers between
—231 and 231 —1;the operations of int are the basic arithmetic and comparison
operations, including +,*, %, <, and >.You alsohavebeen using a data type that is
not primitive—the Stri ng data type.Your experience with using St ri ng demon
strates that you do not need to know howa data type is implemented in order to be
able to use it (yetanother mantra). You knowthat values of Stri ng are sequences
of charactersand that you can perform the operationof concatenatingtwo Stri ng
values to produce a Stri ng result. Youwill learn in this section that there are doz
ens of other operations available for processing strings,such as finding a string's
length or extractinga substring. Every data type is defined by its set of values and
the operations defined on them, but whenwe use the data type, we focus on the
operations, not the values. Whenyouwriteprogramsthat usei nt or Stri ngvalues,
you are not concerning yourselfwith how they are represented (wenever did spell
out the details), and the sameholdstrue whenyouwriteprogramsthat use refer
ence types such as Color and Picture.
317
Example. As a running example of how to use a data type, we
will consider a data type Charge for charged particles. In par
ticular, we are interested in a two-dimensional model that uses
Coulomb's law, whichtells us that the electric potentialat a point
dueto agiven charged particle isrepresented byV= kq Ir, where q
isthe charge value, r isthe distance fromthe point to the charge,
and fc=8.99X 109 Nm2/C2 is the electrostatic constant. For consis
tency,we use SI (Systeme International d'Unites): in this formula,
N designates Newtons (force), m designates meters (distance),
and C representcoulombs(electric charge). Whentherearemul
tiple charged particles, the electric potential at any point is the
sum of the potentials due to eachcharge. Our interestiscomput
ing the potential at variouspoints in the planedue to a given set
of chargedparticles.Todo so,wewillwrite programsthat define,
create, and manipulatevariables of typeCharge. In Section3.2, youwilllearn how
to implement the data type, but you do notneed to know how a data typeisimple
mented in order to be able to use it.
potential at (x,y)
due toc is kq/r
(*,y)
(Wo>
charged particlec
with valueq
Coulomb's lawfor a
charged particlein theplane

318
Object-Oriented Programming
API. The Java class provides a mechanism for defining data types. In a class, we
specify the data-type valuesand implement the data-type operations. In order to
fulfill our promise that youdonotneed toknow how a data type is implemented in
order tobeable touseit,wespecifythe behavior of classes for clients by listing their
methods in an API(application programming interface), in the same manner as we
havebeendoingfor librariesof staticmethods.The purpose of an APIisto provide
the information that you need to write programs using the data type. (In Section
3.2,you willseethat the sameinformationspecifies the operations that you need
to implement it.) For example, thisAPIspecifies our classCharge for writing pro
grams that processcharged particles:
public class Charge
Charge(double xO, double yO, double qO)
doubl e
potenti al At (doubl e x,
doubl e y)
electricpotential at (x, y) duetocharge
Stri ng
toStri ng()
string representation
APIfor charged particles
Thefirst entry, withthesame nameastheclass andno return type,defines aspecial
method known as a constructor. The other entries define instance methods that can
take arguments andreturnvalues inthesame mannerasthestatic methods thatwe
have beenusing, but theyarenotstatic methods: theyimplement operations forthe
data type. Charge has two instance methods: The first is potentialAt(), which
computes and returns the potentialdueto the charge at the given point (x,y).The
second is toStri ng(), which returns a string that represents the charged particle.
Using a data type. As withlibraries of static methods, the codethat implements
each class resides in a file that has the same name as the class but with a .Java
extension. To write a clientprogram that uses Charge,you need access to the file
Charge. Java, either by havinga copyin the current directory or by using Java's
classpath mechanism (described in the booksite). With this understood,you will
nextlearn howto usea data typein your ownclientcode.Todo so,you need to be
ableto declare variables, create objects to hold data-type values, and invoke methods
to manipulate these values. Theseprocesses are differentfrom the corresponding
processes for primitivetypes,though you willnotice many similarities.

3.1 Data Types
319
Declaring variables. You declare variables ofa reference typein preciselythe same
waythat you declarevariables of a primitive type, using a statement consisting of
the data type name followedby a variable name. For example,the declaration
Charge c;
declaresa variable c of type Charge. This statement does not create anything; it just
saysthat we will use the name c to refer to a Charge object.
Creating objects. In Java, each datatypevalue isstored in an object. Whena client
invokes a constructor, the Java systemcreates (or instantiates) an individual object.
Toinvoke a constructor,usethe keyword new; followed bythe class name; followed
bythe constructor'sarguments, enclosed in parentheses and separatedbycommas,
in the same manner as a static method call. For example, new Charge(xO, yO,
qO) createsa new Charge objectwith position (x0,y0) and chargeq0. Typically, cli
ent code invokes a constructor to createan objectand assigns it to a variablein the
same line of code as the declaration:
Charge c = new Charge(0.51, 0.63, 21.3);
You can createanynumber of objects from the sameclass; eachobjecthas its own
identityand may or may not storethe same value as another objectof the same
type. For example, the code
Charge cl = new Charge(0.51, 0.63, 21.3)
Charge c2 = new Charge(0.13, 0.94, 85.9)
Charge c3 = new Charge(0.51, 0.63, 21.3)
creates three different Charge objects. In particular, cl and c3 refer to different
objects,eventhough the objectsstore the samevalue.
Invoking methods. Themostimportant difference between a variable of a refer
ence typeand a variable of a primitive typeisthatyoucanusereference typevari
ables to invoke the methods that implement data type operations (in contrast to
the built-in syntax involving operators suchas+and * that weusedfor primitive
types).Suchmethods are known as instance methods. Invokingan instancemethod
is similar to invoking a static method in another class, except that an instance
methodis associated not justwith a class, but also withan individual object. Ac
cordingly, we use an object name (variable of the given type) insteadof the class
name to identify the method. For example, if c is a variableof type Charge, then

320
Object-Oriented Programming
o;:',^^
Program 3.1.1
Charged particles
public class Charged ient
{
public static void main(String[] args)
{
// Print total potential at (x, y).
double x = Double.parseDouble(args[0]);
double y = Double.parseDouble(args[l]);
Charge cl = new Charge(.51,
.63, 21.3);
Charge c2 = new Charge(.13,
.94, 81.9);
double vl = cl.potentia!At(x, y);
double v2 = c2.potentialAt(x, y);
StdOut.pri ntf("%.le\n", vl+v2);
}
}
x,
y
cl
vl
c2
v2
querypoint
firstcharge
potentialdue to cl
second charge
potential duetool
This object-oriented client takes a query point (x, y) as command-line argument, creates two
charges cl and c2 with fixed position and electric charge, and uses the potentialAt() in
stance method inCharge tocompute the potential at (x, y) dueto the two charges.
% Java Chargedient .2 .5
2.2e+12
% Java Chargedient .51 .94
2.5e+12
>!
c.potentialAt(x,
y) re
turns a double value that
represents the potentialat (x,
y) due to the charge q0 at (x0,
y0). The values x and y be
long to the client, the values
Km Vm and cin belonc to the
^^^^^^^^^^ffi^^^RH^^H^^^^^^^^^^^^^^SRI^^^^'
object. For example, Charged ient (Program 3.1.1) creates two Charge objects
and computes the total potential at a query point taken from the command line
due to the two charges. This codeclearly exhibitsthe ideaofdeveloping anabstract
model and separating the codethat implements the abstractionfrom the codethat
uses it. This ability characterizes object-oriented programming and is a turning
i|PjSjfiffi3§$5^^k
charged particle c2
with value 81.9
(.13, .94)(
.38
.45 *
potentialat thispoint is
8.99xl09(21.3/.31+81.9/.38)
/
= 2.5xl012
--f(.51,.94)
•31
,(.51,-63)
(•2,.5)W-
t
potentialat thispoint is
8.99xl09(21.3/.34+81.9/.45)
= 2.2xl012
.34
charged particle cl
with value 21.3

3.1 Data Types
321
point in this book: we have not yet seen any code of this nature, but virtually all of
the code that wewrite from this point forward willbe based on defining and invok
ing methods that implement data types operations.
References. Aconstructor creates anobject andreturns totheclient a
reference to the object, not the object itself (hence the name reference
type). What isa reference? Nothing more than a mechanism for access
ing an object. There are several different ways for Java to implement
references, but we do not need to know the details in order to use
them. Still, it is worthwhile to have a mental model of one common
implementation. One approach is for new to assignmemory space to
hold the object'scurrent data typevalueand return apointer (machine
address) to that space. We re-
declare a variable (object name)
invoke a constructor to createan object
/
Charge cl;
cl =|new Charge(.51,
.63, 21.3)
double v =[[c
/
object name
potentialAt(x,
y)
\
invoke an instance method
thatoperates on theobject's value
Using a reference data type
fer to the memory space asso
ciated with the object as the
object's identity. Why not just
process the object itself? For
small objects, it might make
sense to do so, but for large
objects, cost becomes an issue:
data-type values can be com
plicated and consume large
amounts of memory. It does
not make sense to copy or
move allof its data every time that wepass an object as an argument
to a method. If this reasoning seemsfamiliar to you, it is becausewe
have used precisely the same reasoning before, when talking about
passing arrays as arguments to static methods in Section 2.1. Indeed,
arraysare objects,aswewillseelater in this section.Bycontrast, prim
itivetypeshavevalues that arenaturalto represent directly in memory
and operations that translate directlyto machineoperations,so that it
does not make sense to use a reference to access each value. We will
discuss referencesin more detail after you have seen severalexamples
of clientcodethat usesreference types. Your Java system might usesomethingmore
complicatedthan machine addresses to implement references, but this model cap
tures the essentialdifferencebetween primitive and referencetypes.
one object
1
I
reference
cl
459
459
.51
Lt— positioi
460
.63
461
21.3
-<—charge
1
twoobjects
1
cl
459
c2
611
identity
isofcl
459
.51
460
.63
461
21.3
identity
y
«f&
611
.13
612
.94
613
81.9
1
1
Object representation

322
Object-Oriented Programming
Using objects. Adeclaration give us avariable name for an objectthat wecan use
in code in much the same wayaswe use a variable name for an integer or floating
point number:
• Asan argument or return value for a method
• In an assignment statement
• In an array
Wehavebeen usingStri ngobjects in thiswayeversinceHel 1oWorl d:most of our
programs call StdOut. pri ntl n() with a String argument, and all of our pro
grams have a mai n() method that takes an argument that is an array of Stri ng
objects. Aswe have alreadyseen,there is one criticallyimportant addition to this
list for variables that refer to objects:
• To invoke an instance method defined on it
This usageisnot available forvariables of a primitivetype,wherealloperations are
built into the language and invoked usingoperators such as +,-, *,and /.
Type conversion. If you want to convert an objectfrom one type to another,you
have to write code to do it. Often, there is no issue, because values for different data
types aresodifferent that no conversion iscontemplated. Forinstance, whatwould
it mean to convert a Charge to a Color? But you have already seen one casewhere
conversionis worthwhile: all Java reference types have a method toStri ng() that
returns a String. Moreover, Java automatically calls this method for any object
when a Stri ngis expected. One consequence of this conventionis that it enables
youto write StdOut.pri ntl n(x) foranyvariable x.Forexample, adding the call
StdOut. pri ntl n(cl); to Charged ient would add charge
21.3 at
(0.51,
0.63) to the output. The nature of the conversion is completely up to the imple
mentation, but usuallythe string encodesthe object'svalue.
Uninitialized variables. Whenyou declare a variable of a reference type but do
not assign avalue to it,thevariable isuninitialized, which leads to the samebehav
ior asfor primitive typeswhenyoutry to usethe variable. Forexample, the code
Charge bad;
double v = bad.potentialAt(.5,
.5);
willnot compile, because it istryingto usean uninitializedvariable,whichleadsto
the error variable bad might not have been initialized.

3.1 Data Types
Distinction between instance methods andstatic methods. Finally, youareready
to appreciate the meaning of the keyword stati c that we have been using since
Program 1.1,one of the last mysterious details in the Javaprograms that you have
been writing. The primary purpose of static methods is to implement functions;
the primary purpose of non-static (instance) methods is to implement data-type
operations. You can distinguish between the uses of the two types of methods in
our client code, because a static method call always starts with a class name (up
percase, by convention) and a non-static method call always starts with an object
name (lowercase, by convention). These differences are summarized in the follow
ing table, but after you have written some client code yourself,you will be able to
quickly recognize the difference.
instance method
static method
samplecall
cl.potentialAt(x, y)
Math.sqrt(2.0)
invoked with
object name
class name
parameters
reference to object and argument(s)
argument(s)
primarypurpose
manipulate object value
compute return value
Instance methods vs. static methods
The basic concepts that wehave just covered are the starting point for object-ori
ented programming, so it is worthwhile to briefly summarize them:A data type is
a set of values and a set of operations definedon thosevalues. Weimplement data
typesin independent modulesand write clientprogramsthat usethem. An object
isan instance of a data type.Objectsarecharacterized bythree essential properties:
state, behavior, and identity. Thestate ofan object isavalue fromitsdata type.The
behavior of an object is defined by the data type's operations. The identity of an
object is the place where it is storedin memory. In object-oriented programming,
we invoke constructors to createobjects and then modifytheir state by invoking
their instance methods.
To demonstrate the power of object orientation, we next consider several
more examples. First,weconsiderthe familiarworldof imageprocessing, wherewe
process Color and Picture objects. Then, we consider the operations associated
with Stri ng objectsand their importance in a scientific application.
323

324
Object-Oriented Programming
Color.
Color is a sensation in the eye from electromagnetic radiation. Since we
want to viewand manipulatecolorimages on our computers,colorisawidelyused
abstraction in computer graphics, and Java provides a Color data type. In profes
sional publishing in print and on the web,workingwith color isa complextask.For
example, the appearance of a color image depends in a significant way on the me
dium used to present it. The Color data type separates the creative designer's prob
lem of specifyinga desired color from the system'sproblem of faithfully reproduc
ing it.
Java has hundreds of data types in its libraries, so we need to explicitly list
which Javalibraries we are usingin our program to avoid naming conflicts.Specifi
cally, we include the statement
import Java.awt.Color;
at the beginning of any program that usesColor. (Until now,
we have been using standard Java libraries or our own, so
there has been no need to import them.)
To represent color values, Color uses the RGB system
where a color is defined by three integers (eachbetween 0 and
255) that represent the intensity of the red, green, and blue
(respectively) components of the color. Other color values
are obtained by mixing the red, green,and blue components.
That is,the data type values of Color are three 8-bit integers.
We do not need to know whether the implementation uses
i nt, short, or char values to represent these integers. With
this convention, Javais using 24 bits to represent each color
and can represent 2563 = 224 ~ 16.7 millionpossiblecolors.Scientists estimatethat
the human eyecan distinguishonlyabout 10million distinct colors.
Color has a constructor that takes three integer arguments, so that you can
write, for example
Color red
= new Color(255,
0,
0);
Color bookBlue = new Col or(
9,
90,
166);
to create objects whose values represent red and the blue used to print this book,
respectively. Wehavebeen usingcolorsin StdDraw sinceSection 1.5,but havebeen
limited to a set of predefined colors, such as StdDraw. BLACK, StdDraw. RED, and
StdDraw. PINK. Now you have millions of available colors. AlbersSquares (Pro
gram 3.1.2) is a StdDraw client that allowsyou to experiment with them.
red
green
blue
255
0
0
red
0
255
0
green
0
0
255
blue
0
0
0
black
100
100
100
darkgray
255
255
255
white
255
255
0
yellow
255
0
255
magenta
9
90
166
this color
Some color values

3.7 Data Types
325
"• «My'f,
- aft v^* *
/
,y ymm ^ *ta. x .^v
rJ&L&JL!!^
if
lia
11
1
HSi
Program3.J.2
Alberssquares
import java.awt.Color;
public class AlbersSquares
{
public static void main(String[] args)
{
// Display Albers squares for the two RGB
// colors entered on the command line,
int rl = Integer.parselnt(args[0]);
int gl = Integer.parselnt(args[1]);
int bl = Integer.parselnt(args[2]);
Color cl = new Color(rl, gl, bl);
int r2 = Integer.parselnt(args[3]);
int g2 = Integer.parselnt(args[4]);
int b2 = Integer.parselnt(args[5]);
Color c2 = new Color(r2, g2, b2);
}
StdDraw.setPenColor(cl);
StdDraw.filledSquare(.25,
.5,
.2);
StdDraw.setPenColor(c2);
StdDraw.filledSquare(.25,
.5,
.1);
StdDraw.setPenColor(c2);
StdDraw.filledSquare(.75,
.5,
.2);
StdDraw.setPenColor(cl);
StdDraw.filledSquare(.75,
.5,
.1);
a
*-~
^
,£&!j&»*i ~_
rl,
gl,
bl
cl
r2,
g2,
b2
c2
This program displays the two colors entered in RGB representation on the command linein
thefamiliarformat developed in the 1960s by the color theoristJosefAlbers that revolutionized
thewaythatpeople think aboutcolor.
^^^^^Wftl^^
Java AlbersSquares 9 90 166
100 100 100
,mmww'f^mMMmmmmm

326
Object-Oriented Programming
Asusual, when we address a new abstraction, we are introducing you to Color
by describingthe essentialelementsof Java's color model, not allof the details.The
API for Col or contains several constructors and over 20 methods; the ones that we
will use are briefly summarized next.
public class java.awt.Color
Color(int r, int g, int b)
i nt
getRed ()
red intensity
i nt
getGreen ()
green intensity
i nt
getBl ue ()
blue intensity
Col or
bri ghte r ()
brighter version ofthis color
Col Or
darke r ()
darker version ofthiscolor
Stri ng toStri ng ()
string representation ofthis color
bool ean
equal S(Col or c)
isthis color's value the same ascs.?
Seeonline documentation andbooksitefor other available methods.
Excerptsfrom the APIforJavas Color datatype
Our primary purpose is to use Color as an example to illustrate object-oriented
programming, while at the sametimedeveloping a few useful toolsthat wecanuse
to writeprogramsthat process colors. Accordingly, wechoose one colorpropertyas
an example to convince you that writingobject-oriented codeto process abstract
conceptslikecolor is a convenientand usefulapproach
Luminance. Thequality oftheimages on moderndisplays suchasLCD monitors,
plasmaTVs, and cellphone screens depends on an understandingof a colorprop
ertyknownas monochrome luminance, or effective brightness. Astandard formula
for luminance is derived from the eye's sensitivity to red, green, and blue. It is a
linear combination of the three intensities: if a color's red, green, and blue values
are r,g,and b,respectively, then its luminanceis definedby this equation:
Y= 0.299r + 0.587g+ 0.114b
Sincethe coefficients are positiveand sum to 1 and the intensities are all integers
between 0 and 255, the luminance is a real number between 0 and 255.

3.1 Data Types
Grayscale. The RGB system hasthe propertythat when allthreecolorintensities
are the same, the resulting color is on a grayscale that ranges from black (all Os) to
white (all 255s).Toprint a color photograph in a black-and-white newspaper (or a
book), weneed a static method to convertfrom colorto grayscale. Asimplewayto
converta color to grayscale isto replace the colorwith a newone whosered, green,
and blue values equal its monochrome luminance.
Color compatibility. Theluminance value isalso crucial in determining whether
two colors are compatible, in the sensethat printing text in one of the colors on a
background in the other colorwillbe readable. Awidelyused rule of thumb is that
the difference between the luminance of the
foreground and background colors should be at
least 128. For example, black text on a white
background has a luminance difference of 255,
but blacktext on a (book) blue background has
a luminance difference of only 74. This rule is
important in the design of advertising, road
signs, websites, and many other applications.
Luminance (Program 3.1.3) is a static method
librarythatwecanuseto converta colorto gray
scale and to testwhethertwocolorsarecompat
ible,for example, whenweusecolorsin StdDraw
applications. Themethods in Lumi nance illustrate theutility of using datatypes to
organize information. Using the Color refer
ence type and passing objects as arguments
makes these implementations substantially
simpler than the alternative of having to pass
around the three intensity values. Returning
multiple values from a function also would be
problematic without reference types.
red
9
green
90
blue
166
this color
74
74
74
grayscale version
black
0.299*9 + 0.587*90 + 0.114* 166= 74.445
Grayscale example
luminance
74
232
Having an abstraction for color is important
not just for direct use, but also in building
higher-level data types that have Color values. Next, we illustrate this point by
building on the color abstraction to develop a data type that allows us to write
programs to process digital images.
compatible
Compatibility example
327
difference
232
158
74

328
Object-Oriented Programming
^»»^§f^
Program 3.1.3
Luminance library
import Java.awt.Color;
public class Luminance
{
public static double lum(Color color)
{
// Compute luminance of color.
int r = color.getRedO;
int g = color.getCreenO;
int b = color.getBlueO;
return .299*r + .587*g + .114*b;
}
public static Color toGray(Color color)
{
// Use luminance to convert to grayscale.
int y = (int) Math.round(lum(color));
Color gray = new Color(y,
y,
y);
return gray;
}
public static boolean compatible(Color a, Color b)
{
// Print true if colors are compatible, false otherwise,
return Math.abs(lum(a)
- lum(b)) >= 128;
}
public static void main(String[] args)
{
// Are the two given RGB colors compatible?
int[]
a = new int[6];
for (int i
= 0;
i
< 6; i++)
a[i] = Integer.parselnt(args[i]);
Color cl = new Color(a[0], a[l], a[2]);
Color c2 = new Color(a[3], a[4], a[5]);
StdOut.println(compatible(cl, c2));
}
a[]
cl
c2
i nt valuesof args
firstcolor
second color
fH
This library comprises three importantfunctions for manipulating color: luminance, conver
siontogray, and background/foreground compatibility.
Java Luminance 232
232
232
true
% Java Luminance
9
90 166
232 232 232
true
% Java Luminance
9
90 166
0
0
0
false
mmmmmmm
^^^•^^^m^^j^^^^^^^^^^^S^*
r

3.1 Data Types
Digital image processing
You are familiar with theconcept of aphotograph.
Technically, wemight definea photograph asa two-dimensional imagecreatedby
collecting and focusing visible wavelengths of electromagnetic radiation that con
stitutes a representation of a scene at a point in time. That technical definition is
beyond our scope, except to note that the historyof photography is a history of
technological development. During the last century, photography was based on
chemical processes, but its future is nowbasedin computation. Your camera and
your cellphone are computers with lenses and light-sensitive devices capable of
capturing images in digital form, and your computerhas photo-editing software
that allows you to process those images. You can crop them, enlarge and reduce
them, adjust the contrast,brighten or darkenthem, remove red
eye, orperformscores ofotheroperations. Many such operations
areremarkably easy to implement, given asimple basic datatype
that captures the ideaof a digital image, asyouwill nowsee.
Digital images. We have been using StdDraw toplot geometric
rowy
objects (points, lines, circles, squares) in a window on the com
puter screen. Which set of values do we need to process digital
images, and which operations do we needto perform on those
values? Thebasic abstraction for computer displays isthe same
one that is used for digital photographs and is very simple: A
digital image is a rectangular grid of pixels (picture elements),
where thecolor of each pixel isindividually defined. Digital im
ages aresometimes referred to as raster or bitmapped images, in
contrastto the typesof images weproducewith StdDraw, which
are referredto as vector images.
Our class Picture is a data type for digital images whose
definition follows immediatelyfrom thedigital image abstraction. Thesetofvalues
is nothing more than a two-dimensional matrix ofColor values, andtheopera
tions are what you might expect: create animage (either ablank one with a given
width andheight orone initialized from apicture file), set the value ofa pixel toa
given color, returnthecolor ofa given pixel, return thewidth or theheight, show
the image in a window on your computer screen, andsave the image to a file. In
this description, we intentionally use the word matrix instead ofarraytoemphasize
thatwe are referring toanabstraction (amatrix ofpixels), notaspecific implemen
tation (a Java two-dimensional arrayof Color objects). You do notneed to know
pixel
0,0
\
column x
width •
329
pixelsare
references to
color values
Anatomy ofa digitalimage

330
Object-Oriented Programming
howa class isimplemented inorder tobeable touseit.Indeed, typical imageshaveso
many pixels that implementations are likely to use a more efficientrepresentation
than an array of Color values (see Exercise 3.1.29). Such considerations are inter
esting,but can be dealt with independent of client code. Towrite client programs
that manipulate images,you just need to know this API:
public class Picture
PiCture(Stri ng f i 1ename)
create apicturefrom afile
Pi CtU re (i nt W, i nt h)
create a blank w-fry-h picture
i nt
wi dth ()
return thewidth of thepicture
i nt
hei ght ()
return the height ofthe picture
Color
get(int X, int y)
return the color ofpixel (x,y)
void
set(int x, int y, Color c)
setthe color ofpixel (x,y) toe
voi d
show()
display theimage ina window
void
save(String filename)
save the image to afile
APIforourdata typefor image processing
By convention, (0,0) istheupper leftmost pixel, sotheimage islaidasin the cus
tomary order for arrays (by contrast, the convention for StdDraw is to have the
point(0,0) atthelower left corner, sothatdrawings areoriented asin thecustom
arymanner for Cartesian coordinates). Most image processing programs are filters
that scan through the pixels in a source image as theywould a two-dimensional
array andthenperform some computation to determine the color of each pixel in
a target image. Thesupported file formats forthefirst constructor and the save()
methodarethewidely used .png and .j pgformats, sothat youcanwriteprograms
toprocess yourown photographs andaddtheresults toanalbum orawebsite. The
show() window alsohas an interactive option for savingto a file. These methods,
togetherwith Java's Col or datatype,openthe door to image processing.
Grayscale. You will find many examples ofcolor images onthebooksite, andall of
the methods that wedescribeareeffective for full-colorimages,but allour example
images in the textwillbe grayscale. Accordingly, our firsttaskisto write a program
that can convertimages from colorto grayscale. Thistask is a prototypicalimage-

3.1 Data Types
J^^^^i^^^»li^^^^^#SS^^^^M^j§^^
Program3.1A
Convertingcolor tograyscale
import Java.awt.Color;
public class Grayscale
{
public static void main(String[] args)
{
// Show image in grayscale.
Picture pic = new Picture(args[0]);
for (int x = 0;
x < pic.width(); x++)
{
for (int y = 0;
y < pic.height(); y++)
{
Color color = pic.get(x,
y);
Color gray
= Luminance.toGray(color);
pic.set(x,
y,
gray);
}
}
pic.show();
}
331
pic
imagefromfile
x,
y
pixel coordinates
color
pixel color
gray
pixelgrayscale
This program illustrates a simple image processing client. First, it creates a Picture object
initialized with an image file named by the command-line argument. Then it converts each
pixel in the image to grayscale by creating agrayscale version ofeach pixel's color and reset
ting the pixel to that color. Finally, itshows the image. You can perceive individual pixels in
the image on the right, which was upscaledfrom alow-resolution image (see "Scaling' on the
nextpage).
--J
j? •'•''•'•*••:?]
% Java Grayscale mandrill.jpg
% Java Grayscale darwin.jpg
I
^^SmB&
^^P^^^^^^^^^^^^^^P^^^^^^^^e

332
Object-Oriented Programming
processingtask: for each pixel in the source, we have a pixel in the target with a
different color. Grayscal e (Program 3.1.4) is a filter that takes a file name from the
command line and produces a grayscale version of that image.It createsa new Pic-
ture object initialized with the color image, then sets the color of
each pixelto a new Col or havinga grayscale value computed by ap
plying the toGrayO method in Luminance (Program 3.1.3) to the
color of the corresponding pixelin the source.
downscaling
source
i!?!i
target
I
upscaling
I
target
Scaling a digital image
Scaling. One of the most common image-processing tasks is to
make an image smaller or larger. Examples of this basic operation,
knownasscaling, include making small thumbnailphotosfor usein
a chat room or a cellphone, changing the size of a high-resolution
photo to make it fitinto a specific space in a printed publication or
on a webpage, or zooming in on a satellite photograph or an image
producedby a microscope. In optical systems, we can just move a
lens to achieve a desiredscale, but in digital imagery, we haveto do
more work.
In somecases, the strategyisclear. Forexample,if the targetim
age isto behalfthe size (ineach dimension) of the source image, we
simply choose halfthepixels, say, bydeleting halfthe rows andhalf
the columns. Thistechnique isknownassampling. Ifthe targetimage
is to be double the size (in each dimension) of the source image, we
canreplace each source pixel byfourtarget pixels of the same color.
Note that we can lose information when we downscale, so halving
an image andthendoubling it generally does not give backthe same
image.
Asingle strategy is effective forboth downscaling and upscal
ing. Ourgoal isto produce thetarget image, sowe proceed through
thepixels inthetarget, onebyone, scaling each pixel's coordinates to
identify a pixel in thesource whose color canbe assigned to the tar
get. If thewidth andheight ofthesource arews and hs (respectively)
and the width and heightof the target are wt and ht (respectively),
then wescale the columnindexby ws/wt and the rowindexby hs/ht.
Thatis, we getthe color ofthe pixel in row y and column x of the targetfromrow
yXhs/ht andcolumn xXws/wt inthesource. Forexample, ifwe arehalving thesize
ofa picture, thescale factors are2,sothepixel in row2 and column 3ofthetarget

3.1 Data Types
333
fy-:fav:.v^%y*£^
m
W
."•••'y
i
Program 3.1.5
Image scaling
public class Scale
{
public static void main (Stri ng[] args)
{
int w = Integer.parselnt(args[1]);
int h = Integer.parselnt(args[2]);
Picture source = new Picture(args[0]);
Picture target = new Picture(w, h);
for (int tx = 0; tx < w; tx++)
{
for (int ty = 0; ty < h; ty++)
{
int sx = tx * source.width()
/ w;
int sy = ty * source.height() / h;
target.set(tx,
ty, source.get(sx,
sy));
}
}
source.show();
target.show();
}
}
w, h
source
target
tx,
ty
sx,
sy
m
target dimensions
source image
targetimage
targetpixel coords
source pixelcoords
This program takes the name ofa picture file and two integers (width wand height h) as
%::
command-line arguments and scales the image to w-fcy-h.
.•;•'••••.'•:':'".'
Java Scale mandrill.jpg 800 800

334
Object-Oriented Programming
getsthe color of the pixelin row 4 and column 6 of the source; if we are doubling
the sizeof the picture, the scalefactors are 1/2,so the pixel in row 6 and column 4
of the target getsthe color of the pixelin row 3 and column 2 of the source.Seal e
(Program 3.1.5) is an implementation of this strategy. More sophisticated strate
gies canbe effective for low-resolutionimagesof the sort
that you might find on old web pagesor from old cam
eras. For example, we might downscale to half size by
averaging the values of four pixels in the sourceto make
one pixel in the target. For the high-resolution images
that are common in most applications today,the simple
approach used in Seal e is effective.
The same basic idea of computing the color value
of eachtarget pixel as a function of the color values of
specific source pixels is effective for all sorts of image-
processing tasks. Next, we considertwo more examples,
and youwillfind numerous other examples in the exer
cises and on the booksite.
Java Fade mandrill.jpg Darwin.jpg 9
Fade effect. Our next image-processing example is an
entertaining computation where we transform one im
age to anotherin a series of discrete steps. Such a trans
formation is sometimes known as a fade effect. Fade
(Program 3.1.6)is a Picture and Color client that uses
a linear interpolation strategy to implement this effect.
It computes Af—1 intermediate images, with each pixel
in the tth image a weighted average of the correspond
ing pixels in the source and target. The static method
blendO implements the interpolation: the sourcecolor
isweighted by a factor of 1 - 11M and the target color
bya factoroft/M (when tis0,wehavethe sourcecolor,
and when t is M, we have the target color). This simple
computationcan producestriking results. Whenyou run Fadeon your computer,
the change appears to happen dynamically. Try runningit on some images from
your photolibrary. Note that Fade assumes that the images have the same width
and height;if you haveimages for whichthis is not the case, you can use Seal e to
created a scaled version of one or both of them for Fade.

3.1 Data Types
^^^^M^^^J^iMi
Program 3.1.6
Fade effect
import java.awt.Color;
public class Fade
{
public static Color blend(Color c, Color d, double alpha)
{
// Compute blend of c and d,
weighted by x.
double r = (l-alpha)*c.getRed()
+ alpha*d.getRed();
double g = (l-alpha)*c.getGreen() + alpha*d.getGreen();
double b = (l-alpha)*c.getBlue()
+ alpha*d.getBlue();
return new Color((int) r, (int) g, (int) b);
}
public static void main(String[] args)
{
// Show M-image fade sequence from source to target.
Picture source = new Picture(args[0]);
Picture target = new Picture(args[l]);
int M = Integer.parselnt(args[2]);
int width
= source.width();
int height = source.height();
Picture pic = new Picture(width, height);
for (int t
= 0; t
<= M; t++)
{
for (int x = 0; x < width; x++)
{
for (int y = 0;
y < height; y++)
{
Color cO = source.get(x, y);
Color cM = target.get(x, y);
Color c = blend(c0,
cM,
(double) t/M);
pic.set(x, y, c);
}
}
pic.showQ;
335
M
pic
t
cO
cl
number of images
currentimage
imagecounter
source color
target color
blended color
}
Tofadefrom one image into another in Msteps, we set each pixel in the tth image to aweighted
average ofthe corresponding pixel in the source and the destination, with the source getting
weight 1-t/Mand the destination getting weight t/M. An example transformation is shown on
thefacingpage.

336
Object-Oriented Programming
Potentialvaluevisualization. Imageprocessing isalsohelpfulin scientific visual
ization.Asan example, we considera Picture client for visualizing properties of
the Charge data type that we introduced at the beginning of this chapter. Poten-
tial (Program 3.1.7) visualizes the potential values created by a set of charged
particles. First, Potenti al creates an array of particles, with values taken from
standardinput. Next, it creates a Picture object and sets eachpixel in the picture
to a shade of gray that isproportional to the potential value at the corresponding
point.Thecalculation at theheartofthe methodisverysimple: for each pixel, we
compute corresponding (x,y) values in the unit square,then call potentialAt()
to findthe potential at that point dueto allof the charges, summingthe values re
turned. With appropriate assignment of poten
tial values to grayscale values (scaling them to
fallbetween0 and 255),we get a striking visual
-100
^^^^^^^^^^^M
representation of the electric potential that is
40
^^^^^B^HRf!!
an excellent aid to understanding interactions
10 ^^^^^|^^^g|fl
among such particles.We could produce asim-
5 ^^^^H^^H^H
ilar image using filledSquare() in StdDraw,
but Picture provides us with more accurate
control over the color of each pixel on the
screen. The same basic method is useful in
manyother settings—you can find several ex-
ampleson the booksite.
Potential value visualizationfora setofcharges
It is worthwhile to reflect briefly on the code
in Potential, because it exemplifies data ab
straction and object-oriented programming.
We wantto produce an image that shows interactions among charged particles,
and our codereflects precisely the process of creating that image, usinga Picture
object for the image (which is manipulated via Color objects) and Charge objects
fortheparticles. When we want information aboutaCharge, we invoke theappro
priate method directly for that Charge; whenwewant to createa Color, weuse a
Col or constructor;whenwewantto seta pixel, wedirectlyinvolve the appropriate
methodforthe Picture. These datatypes areindependently developed, but their
use together in a single client is easy and natural. We next consider several more
examples, to illustrate the broad reach of data abstraction while at the same time
adding a numberof useful datatypes to ourbasic programming model.

3.1 Data Types
337
!$!
ill
«
*gg$ij§£'^^^^^^^^^^^^^^^^^^^^t^^^^^^^^^^^^^^^i
Program 3.1.7
Visualizing electricpotential
import Java.awt.Col or;
public class Potential
{
public static void main(String[] args)
{
// Read charges from Stdin into a[].
int N = Stdin.readlnt();
Charged
a = new Charge[N];
for (int k = 0;
k < N;
k++)
{
double xO = Stdin.readDouble();
double yO = Stdin. readDoubleO;
double qO = Stdin. readDoubleO;
a[k] = new Charge(xO,
yO,
qO);
// Create and show image depicting potential values
int size = 512;
Picture pic = new Picture(size, size);
for (int i = 0; i < size;
i++)
{
for (int j = 0; j < size; j++)
{
// Compute pixel
color.
double x = (double) i / size;
double y = (double) j / size;
double V = 0.0;
for (int k = 0; k < N;
k++)
V += a[k].potentialAt(x,
y);
int g - 128 + (int) (V / 2.0el0);
if (g < 0)
g = 0;
if (g > 255) g = 255;
Color c = new Color(g,
g,
g);
pic.set(i,
size-l-j,
c);
}
}
pic.showQ;
N
a[]
xO, yO
qO
number ofcharges
array of charges
charge position
charge value
x,
pixelposition
point in unitsquare
scaledpotentialvalue
pixel color
Thisprogram reads valuesfrom standard input to create an array ofchargedparticles, sets each
pixel color in an image to agrayscale value proportional to the total ofthepotentials due to the
particles atcorrespondingpoints, and shows the resulting image.

338
Object-Oriented Programming
String processing
You have been using strings since your first Java program.
Java's Stri ngdata type includesa longlist of other operations on strings.It is one
of Java's most important data typesbecause string processing is criticalto many
computational applications. Strings lieat the heart of our ability to compile and
run Java programs and to perform many other core computations; they are the
basisof the information-processing systems that are criticalto most businesssys
tems; people usethemevery daywhen typing intoemail, blog, or chatapplications
or preparing documents forpublication; andtheyhave proven to becritical ingre
dientsin scientific progress in several fields, particularly molecular biology.
A String value is an indexedsequence of char values. We summarize here
the methods from the JavaAPI that we use most often. Severalof the methods use
integers to refer to a character's index within a string; as with arrays, these indices
start at 0. As indicated in the note at the bottom, this list is a small subset of the
Stri ngAPI;the full API has over 60 methods!
public class String (Javastring data type)
String(String s)
int
length()
char
charAt(int i)
String
substring(int i, int j)
boolean
contains(String sub)
boolean
startsWith(String pre)
boolean
endsWith(String post)
int
indexOf(String p)
int
indexOf(String p, int i)
String
concat(String t)
int
compareTo(String t)
String
replaceAll(String a,
String b)
String[]
split(String delim)
boolean
equals(String t)
create a string with thesame value ass
stringlength
i th character
i th through (j -l)st characters
does string contain sub asa substring?
does string start withpre?
does stringendwithpost?
index offirstoccurrence ofp
index offirstoccurrence ofp after i
this string with t appended
stringcomparison
result ofchanging as to bs
strings between occurrences o/del i m
is this string's value thesameast's?
See online documentation andbooksiteformany other available methods.
Excerptsfrom the APIforJavas Stri ngdata type

3.1 Data Types
Java provides special language support for manipulatingstrings. Instead of
initializing a string with a constructor, we can use a string literal, and instead of
invoking the method concat(), wecanusethe +operator:
shorthand
String s = "abc";
longhand
String s = new String("abc");
String t
= r + s;
String t
= r.concat(s);
These notationsareshorthand forstandarddata-type mechanisms.
Stri ngvalues arenot the sameasarrays of characters, but the two aresimilar,
and novice Java programmers sometimes confuse them. For example, the differ
ences are evident in one of the most common code idioms for both strings and
arrays: for loops to process each element (for arrays) orcharacter (forstrings):
for (int i = 0;
i < a.length; i++)
{
...
a[i]
...
}
array
for (int i = 0;
i < s.length(); i++)
{
...
s.charAt(i)
...
}
string
For arrays, we have direct language support: brackets for indexed access and
.length (with no parentheses) for length. For strings, both indexed access and
length are just Stri ng methods.
The split() method in the String API is powerful because many options,
known as regular expressions, are available for delim. For example, "\\s+" means
"one ormorewhitespace characters." Using thisdelimit
er with split() transformsa stringof words delimited
bywhitespace into an arrayofwords.
Why not just use arrays of characters instead of
String values? When we process strings, we want to
write client code that operates on strings, not arrays.
The methods in Java's String data type implement
natural operations on String values and also simplify
client code, as you will see. We have been working with
programs that usea few short strings for output,but it
is not unusual for strings, not numbers, to be the pri
marydatatypeof interestin an application, and to have
programs that process hugestrings or hugenumbers of
strings. Next, we consider in detail such an application.
Examples ofstring operations
339
String a = "now is
»
String b = "the time ";
String c = "to"
call
value
a.length()
7
a.charAt(4)
i
a.substring(2,
5)
"w i"
startsWith("the")
true
a.index0f("is")
4
a.concat(c)
"now is to
.replaceCtVT')
"The Time
a.split(" ")[0]
"now"
a.splitC ")[1]
"is"
b.equals(c)
false

340
is thestring
a palindrome?
extractfile name
andextension from a
command-line
argument
printall lineson
standard inputthat
containa string
specifiedfroma
command line
argument
create an array
of thestrings on
standard input
delimited bywhitespace
check whetheran array
ofstrings is in
alphabetical order
printall thehyperlinks
(to educational institu
tions)of thestrings on
standard input
Object-Oriented Programming
public static boolean isPalindrome(String s)
{
int N = s.lengthO;
for (int i
= 0;
i
< N/2;
i++)
if (s.charAt(i)
!= s.charAt(N-l-i))
return false;
return true;
}
String s = args[0];
int dot = s.indexOf(".");
String base
= s.substring(0, dot);
String extension = s. substring(dot + 1, s.lengthO);
String query = args[0];
while (! Stdin. isEmptyO)
{
String s = Stdin.readLineO;
if (s.contains(query)) StdOut.println(s);
}
String input = Stdin.readAHO;
String[] words = input.split("\\s+");
public boolean isSorted(String[] a)
{
for (int i = 1;
i
< a.length;
i++)
{
if (a[i-l].compareTo(a[i]) > 0)
return false;
}
return true;
}
while (!Stdin.isEmptyO)
{
String s = Stdln.readStringO;
if (s.startsWithC'http://") && s.endsWith(".edu"))
StdOut.println(s);
}
Typical string-processing code

3.1 Data Types
341
String-processingapplication: genomics
To give you more experience with
string processing, we will give a very briefoverview of the field of genomics and
consider aJava program thatsolves abasic problem known asgenefinding. Genom
icsis a quintessentialstring-processing application.
Biologists usea simple modelto represent thebuilding blocks of life: Thelet
tersA, C, T, andGrepresent thefournucleotides in theDNA ofliving organisms. In
each living organism, these basic building blocks appear ina set oflong sequences
(onefor eachchromosome) knownasagenome. Scientists knowthat understand
ingproperties of the genome isa key to understanding the processes that manifest
themselves inliving organisms. The genomic sequences for many living things are
known, including a human genome, which is a sequence of about three billion
characters. You canfind these sequences in many places on theweb. (We have col
lected severalon the booksite: for instance,the file genomeVi rus. txt, which is the
6252-character genome of a simple virus.) Knowing the sequences, scientists are
now writing computer programs to study thestructure ofthese sequences. String
processing is now one of the most important methodologies—experimental or
computational—in molecular biology forelucidating biological function.
Genefinding. Agene isa substring ofagenome that represents a functional unit
ofcritical importance in understanding life processes. Genes are substrings ofthe
genome ofvarying length, andthere are varying numbers ofthem within agenome.
Agene isasequence ofcodons, each ofwhich isanucleotide triplet thatrepresents
oneamino acid. The start codon ATG marks thebeginning ofa gene, andany ofthe
stop codons TAG, TAA, or TGA markthe endof a gene (andthereareno occurrences
ofany ofthe codons ATG, TAA, TAG, orTGA within the gene). One ofthe first steps
in analyzing a genome isto identify its genes, which, as you certainly now realize,
isastring-processing problem thatJava's Stri ng data type equips usto solve. Gen-
eFind (Program 3.1.8) isa Java program thatcandothejob. To understand howit
works, we will consider a tiny example thatdoes notrepresent a real genome. Take
a moment to identifythe genes markedbythe start codon ATG and the end codon
TAG in the following string:
ATAGATGCATAGCGCATAGCTAGATGTGCTAGC
There are several occurrences of both ATG and TAG, and they overlap in various
ways, soyouhave to do abit ofwork to identify thegenes. GeneFi nd accomplishes
the taskin one left-to-rightscanthrough the genome, asshownnext.

342
Object-Oriented Programming
Program 3.1.8
Findinggenes in a genome
18
It
public class GeneFind
{
public static void main(String[] args)
start
{
// Use start and stop to find genes in genome.
stop
String start
= args[0];
String stop
= args[l];
String genome = Stdin.readAll();
int beg = -1;
for (int i =0; i < genome.length()
{
// Check next codon for start or
String codon = genome.substring(i,
i+3);
if (codon.equals(start)) beg = i;
if ((codon.equals(stop)) && beg
!= -1)
{
// Check putative gene alignment.
String gene = genome.substring(beg+3,
if (gene.length() % 3 == 0)
{
// Print and restart.
StdOut.pri ntln(gene);
beg = -1;
}
genome
2; i++)
stop.
i);
beg
codon
gene
start codon
stop codon
full genome
putativegene
startposition
character index
next codon
discovered gene
This program prints all the genes in thegenome on standard input defined by the start and stop
codes on the command line. Tofind agene inagenome, we scanfor the start codon, remember
its index, and then scan to the next stop codon. If the length of the intervening sequence is a
multiple of3, wehavefoundagene.
% more genomeTiny.txt
ATAGATGCATAGCGCATAGCTAGATGTGCTAGC
% Java GeneFind ATG TAG < genomeTiny.txt
CATAGCGCA
TGC
% java GeneFind ATG TAG < genomeVirus.txt
CGCCTGCGTCTGTAC
TCGAGCGGATCGCTCACAACCAGTCGG
AGATTATCAAAAAGGATCTTCACC

3.1 Data Types
343
codon
1
start
stop
uey
0
-1
1
TAG
-1
4
ATG
4
9
TAG
4
16
TAG
4
20
TAG
-1
23
ATG
23
29
TAG
23
gene
remainingportion of inputstring
ATAGATGCATAGCGCATAGCTAGATGTGCTAGC
ATAGATGCATAGCGCATAGCTAGATGTGCTAGC
ATAGATGCATAGCGCATAGCTAGATGTGCTAGC
ATAGATGCATAGCGCATAGCTAGATGTGCTAGC
CATAGCGCA
ATAGATGCATAGCGCATAGCTAGATGTGCTAGC
ATAGATGCATAGCGCATAGCTAGATGTGCTAGC
ATAGATGCATAGCGCATAGCTAGATGTGCTAGC
TGC
ATAGATGCATAGCGCATAGCTAGATGTGCTAGC
Thevariable begholdstheindexofthemostrecently encountered ATG start codon:
thevalue -1 indicates thatthecurrent portion ofthegenome could notbea gene,
eitherbecause no ATG hasbeenseen (atthebeginning) or because no ATG hasbeen
seensince the lastgenewas found. If weencounter a TAG stop codonwhen beg is
-1, weignore it; otherwise,wehavefound a gene. Thistrace illustratesthe cases of
interest: we ignore theTAG codons at1and 20 because beg is-1, indicating thatwe
have not seen an ATG; we set beg to the current index each time that we encounter
an ATG; we ignore theTAG at 9because it marks theputative gene CA whose length
isnotamultiple of3,soit could notbeasequence ofcodons; andwe outputgenes
at16and29 because we have valid start andstop codons with nointervening stop
codons and a genelengththat isa multiple of 3.
GeneFi nd issimple but subtle, typical ofstringprocessing programs. In prac
tice,the rules that definegenesare more complicated than thosewehavesketched:
othercodons may beprohibited, there may bebounds on thelength, some genes
have to be spliced from multiple pieces, andgenes satisfying various othercriteria
may be of interest. GeneFi nd is intended to exemplify how a basic knowledge of
Java programming canenable a scientist to make appropriate tools to studythese
sequences. Actual genomes are similar to our testcase, just muchlonger. You can
experiment with GeneFi ndto look for genes in genomeVi rus. txt and severaloth
er genomes on the booksite. The quick leap from examining a toyprogramming
example thatillustrates thebasic Java Stri ng datatype to studying scientific ques
tionson actual data isa remarkable characteristic of modern genomics. As wewill
see, someof the verysame algorithms that were developed bycomputerscientists
that underly basic computational mechanisms andhave proven importantin com
mercial applications arealso nowplaying a critical role in genomic research.

344
Object-Oriented Programming
Input and output revisited
In Section 1.5 youlearnedhowto readandwrite
numbers and text using Stdin and StdOutand to make drawings with StdDraw.
You have certainly come to appreciate the utility of these mechanism in getting
informationinto and out ofyourprograms. One reasonthat theyareconvenient is
that the "standard" conventions makethem accessible from anywherewithin a pro
gram. Onedisadvantage ofthese conventions isthat theyleave usdependent upon
the operating system's piping and redirection mechanism for access to files, and
they restrict us to working with
just one input file, one output
inputstreams
file, and one drawing for any giv
en program. With object-orient
ed programming, we can define
mechanisms that are similar to
Stdin, StdOut, and StdDraw but
allow us to work with multiple
input streams, output streams,
and drawings within one pro
gram.
Specifically, we define in
this section the data types In,
Out, and Draw for input streams,
output streams, and drawings
(respectively). As usual, you can
download the files In. j ava, Out.
java, and Draw.Java from the
booksite to use these data types.
These data types give us the
flexibility that weneedto address
many common data-processing
tasks within our Java programs. Rather than being restricted to just one input
stream, oneoutput stream, and onedrawing, we caneasily define multiple objects
of each type, connecting the streams to various sources and destinations. We also
get the flexibility to assign such objects to variables, pass them as arguments or
return values from methods, and to createarraysof them, manipulating them just
aswemanipulate objects ofanytype. We will consider several examples oftheiruse
after we have presented the APIs.
to
-
f
—1
standard input -|
jfUWH
pictures
drawings
command-line
y
arguments
output streams
A bird's-eye view ofa Java program (revisited again)

3.1 Data Types
345
Input stream data type. The data type In isamore general version ofStdin that
supports reading numbers and text from files and websites as well as the standard
input stream. It implements the input stream datatype, withthe following API:
public class In
In ()
create an input streamfrom standard input
In (St ri ng name)
create an input streamfrom afile or website
bool ean
i sEmpty()
true ifno more input, fal se otherwise
i nt
readlnt ()
read avalue oftype i nt
doubl e
readDoubl e ()
read avalue oftype doubl e
Note: All operations supported by Stdin are also supportedfor In objects.
APIforour data typeforinput streams
Instead ofbeing restricted toone abstract input stream (standard input), you now
also have theabilitytodirectly specifythesource ofaninputstream. Moreover, that
source can beeither afile ora website. When invoked with aconstructor having a
Stri ng argument, In will first trytofind afile inthecurrent directory ofyour local
computer thathas thatname. Ifitcannot do so, itwill assume theargument tobe
awebsite nameandwill try to connect to thatwebsite. (Ifno suchwebsite exists, it
will issue aruntime exception.) Ineither case, thespecified file orwebsite becomes
thesource oftheinputfor theinput stream object thus created, andthe read*()
methods will provide values from that stream. This arrangement makes itpossible
toprocess multiple files within the same program. Moreover, the ability todirectly
access the web opens up the whole web as potential input for your programs. For
example, itallows you toprocess data that is provided and maintained by someone
else. You can find such files all over the web. Scientists now regularly post data files
with measurements or results ofexperiments, ranging from genome and protein
sequences to satellitephotographs to astronomicalobservations; financialservices
companies, suchasstockexchanges, regularlypublish ontheweb detailed informa
tion about the performance ofstock and other financial instruments; governments
publish election results; and so forth. Now you can write Java programs that read
these kinds offiles directly. In gives you agreat deal offlexibility totake advantage
of the multitude of data sources that are now available.

346
Object-Oriented Programming
Output stream data type. Similarly, our data typeOutis a more general version
of StdOut that supports writingtextto avarietyof output streams,includingstan
dard output and files. Again, the API specifies the same methods as its StdOut
counterpart.You specify the file that youwantto usefor output by usingthe one-
argument constructor withthefile's nameasargument. Outinterprets thisstringas
the nameofanewfile onyourlocal computer, andsendsitsoutput there.Ifyouuse
the no-argumentconstructor, thenyouobtainstandardoutput.
public class Out
Out ()
create an output stream tostandard output
Out(Stri ng name)
create anoutput stream to afile
VOid
pri nt(Stri ng S)
print s to the output stream
voi d
pri ntl n(Stri ng s)
print s and a newline to the output stream
VOid
pri ntl n()
print a newline tothe output stream
VOid
pri ntf(Stri ng f,
. . .)
formatted print to the output steam
APIforourdata typeforoutput streams
File concatenation andfiltering. Program 3.1.9 isa sample client of In andOut
thatuses multiple input streams toconcatenate several input files into asingle out
putfile. Some operating systems have acommand known as cat that implements
thisfunction. However, a Java program that does the same thing is perhaps more
useful, because we cantailor it tofilter the input files in various ways: we might
wish toignore irrelevant information, change theformat, orselect onlysome ofthe
data, to name justa few examples. We now consider oneexample ofsuch process
ing, andyoucanfindseveral others in theexercises.
Screen scraping. The combinationofIn (which allows ustocreate aninputstream
from anypage ontheweb) and Stri ng (which provides powerful tools for process
ingtext strings) opens up the entire web to direct access by our Java programs,
withoutanydirect dependence on theoperating system or the browser. Onepara
digm is known as screen scraping: the goal is to extract some information from a
web page with aprogram rather than having tobrowse to find it.To doso, we take

3.1 Data Types
347
• ^H&?£& ••\ •^-•':.:.'v
v;
Program3.1.9
Concatenatingfiles
public class Cat
{
public static void main(String[] args)
{
// Copy input files to out (last argument).
Out out = new Out(args[args.length-1]);
for (int i = 0;
i < args.length - 1; i++)
{
// Copy input file named on ith arg to out.
In in = new In(args[i]);
String s = in.readAl1();
out.println(s);
}
}
}
This program creates an outputfile whose name is given by the last argument and whose con
tents are copies ofthe inputfiles whose names are given as the other arguments.
..•
••"*"{
'l£^-'s«**-"'-?!'•''•''["*
t&:
'••'•
=^*?:;>''''^":''-
••'•'.'i
3
% more ini.txt
This is
%
more in2.txt
a tiny
test.
^m
#?isf§PK8Klifl^Pi
% Java Cat ini.txt in2.txt out.txt
% more out.txt
This
is
a tiny
test.
'^^^^^^^ci^^^^^^SI^^P^^^^^^^^^iPP^^^^^
I
advantage ofthe fact that many web pages are defined with text files in a highly
structured format (because they are created bycomputer programs!). Your browser
has amechanism thatallows you toexamine the source code thatproduces theweb
page thatyou are viewing, and byexamining that source you can often figure out
what todo. For example, suppose that we want totake astock trading symbol as a
command-line argument andprint out itscurrenttrading price. Such information
ispublished ontheweb byfinancial service companies and internet service provid
ers. For example, you canfind thestock price ofa company whose symbol isgoog
bybrowsing tohttp: //fi nance. yahoo. com/q?s=goog. Like many web pages, the
name encodes anargument (goog), andwe could substitute any otherticker sym-

348
Object-Oriented Programming
<tr>
bol to get a webpagewith financial information for any other company. Also, like
manyother files on the web, the referenced file isa textfile, written in a formatting
language known as HTML. (See the Context section at the end of this book for
some detailsabout this language.) From the point of viewof a Java program, it is
justa Stri ng value accessible throughan In input stream.You canuseyourbrows
er to download the source of that file, or you could use
Java Cat "http://finance.yahoo.com/q?s=goog" mycopy.txt
to put the source into a local file mycopy.txt on your computer (thoughthereis
no real need to do so). Now, suppose that goog is trading at $475.11 at the mo
ment.Ifyousearch forthestring"475.11" in thesource
of that page, youwillfind the stockpriceburied within
<td class="yfnc_„tableheadl"
some HTML code. Without having to know details of
wi dth="48%">
HTML, you can figure outsomething about the context
</td>TPade=
in w^ich the price appears. In this case, you can see that
<td class="yfnc_tabledatalH>
the stock price is enclosed between the tags "<b>" and
<bigxb>475. ll</bx/big>
"</b>", a bit afterthe string "Last Trade:". With the
<tr>></tr>
Stn" n9 datatyPe methods indexOf() and substri ng()
<td class="yfnc„_tableheadl"
y0U can easily grab this information, as illustrated in
width=n48%">
StockQuote (Program 3.1.10). This program depends
Trade Time:
,
i
r
r\
,,_<-.
u
</td>
on the web page format of http://finance.yahoo.
<td class=,,yfnc_tabledatal">
com; if this format changes, StockQuote not work.Still,
11:13AM ET
making appropriate changes is not likely to be difficult.
You can entertain yourselfby embellishingStockQuote
HTML codefrom the web
inall ]dnds ofinteresting ways. For example, you could
grab thestock price on a periodic basis andplotit,com
pute amoving average, orsave the results toafile for later analysis. Ofcourse, the
same technique works for sources ofdata found all over theweb.You can find many
examples intheexercises atthe end ofthis section andonthebooksite.
Extracting data. The ability tomaintain multiple inputandoutputstreams gives
usa great deal offlexibility in meeting thechallenges ofprocessing large amounts
ofdatacoming from avariety ofsources. We consider onemore example: Suppose
that ascientist or afinancial analyst hasalarge amountofdatawithinaspreadsheet
program. Typically such spreadsheets are tables with a relatively large number of
rows anda relatively small number ofcolumns. You are not likely to beinterested

3. / Data Types
349
1
i
m
£i
Program3.1.10
Screenscrapingfor stockquotes
public class StockQuote
{
public static double price(String symbol)
{
// Return current stock price for symbol.
In page = new In("http.-//finance, yahoo. com/q?s=" + symbol);
String in = page.readAl1();
int trade = in.indexOf("Last Trade:",
int from =
in.indexOf("<b>", trade);
int to =
in.indexOf("</b>",
from);
String price = in.substring(from + 3,
return Double.parseDouble(price);
}
}
public static void main(String[] args)
{
StdOut.pri ntln(pri ce(args[0]));
}
0);
to);
page
in
trade
from
to
price
input stream
contents o/page
Last. . .
index
<b>
index
</b> index
currentprice
Thisprogram takes the ticker symbol ofastock asacommand-line argument, reads a web page
containing the stock price,finds the stock price using the Stri ngmethod i ndexOf(), extracts it
using the method substri ng(), and prints the price out to standard output.
% Java StockQuote goog
475.11
% Java StockQuote adbe
41.125
I
t
^^^^^W^^^^^^K^^^^^^^v^'
in allthe data in the spreadsheet, but youmaybeinterestedin a fewof the columns.
You can do some calculations within the spreadsheet program (this is its purpose,
afterall), but youcertainly do not have the flexibility that youhave with Java pro
gramming. One wayto addressthis situation is to havethe spreadsheetexport the
data to a text file, using some special character to delimit the columns, and then
write a Java program that readsthat file from an input stream. One standard prac
ticeisto use commasas delimiters: print one lineper column,with commassepa
rating row entries. Such files are known as comma-separated-value or .csv files.
With the spl i t () method in Java's Stri ngdata type,wecan read the file line-by-

350
Object-Oriented Programming
iS(M^^^
Program 3.1.11
Splitting a file
mm
public class Split
{
public static void main(String[] args)
{
// Split file by column into N files.
String name = args[0];
int N = Integer.parselnt(args[l]);
String delim = ",";
// Create output streams.
Out[] out = new Out[N];
for (int i
= 0;
i
< N; i++)
out[i]
= new Out(name + i
+ ".txt");
name
basefile name
N
argument index
delim
delimiter (comma)
i n
inputstream
out[]
output streams
line
current line
f i el ds []
values in current line
In in = new In(name + ".csv");
while (!in.isEmptyO)
{
// Read a line and write fields to output streams.
String line = in.readLineO;
String[] fields = 1ine. split(del i m);
for (int i
= 0;
i
< N; i++)
out[i].pri ntln(fi elds[i]);
}
}
This program uses multiple output streams to split a .csvfile into separatefiles, onefor each
comma-delimitedfield. The name ofthe outputfilecorresponding to the i thfield isformed by
concatenating i andthen .txt tothe end ofthe originalfile name.
%
more DJIA.csv
31-Oct-29,264.97,7150000,273.51
30-Oct-29,230.98,10730000,258.47
29-0ct-29,252.38,16410000,230.07
28-0ct-29,295.18,9210000,260.64
25-Oct-29,299.47,5920000,301.22
24-0ct-29,305.85,12900000,299.47
23-Oct-29,326.51,6370000,305.85
22-0ct-29,322.03,4130000,326.51
21-Oct-29,323.87,6090000,320.91
£
% Java Split DJIA 3
% more DJIA2.txt
7150000
10730000
16410000
9210000
5920000
12900000
6370000
4130000
6090000
^^^Si^^^^^^^SS^^^^Sg^SS^^
isragswssw

3.1 Data Types
351
line and isolate the data that we want. Wewillseeseveralexamples ofthis approach
later in the book. Spl i t (Program 3.1.11) is an In and Out client that goes one step
further: it creates multiple output streams and makes one filefor each column.
Theseexamples are convincing illustrations of the utility of working with text files,
with multiple input and output streams, and with direct access to web pages.Web
pagesare written in HTML preciselyso that they are accessible to any program that
can read strings. People use text formats such as .csv filesrather than data formats
that are beholden to particular applications precisely in order to allow as many
people as possibleto access the data with simpleprogramslikeSpli t.
Drawing data type. Whenusing the Pictu re datatypethat weconsidered earlier
in this section, we could write programs that manipulated multiple pictures, ar
raysof pictures,and so forth, precisely because the data type providesus with the
capability for computingwith Picture objects. Naturally, wewouldlikethe same
capability for computing with the kinds of objects that we createwith StdDraw.
Accordingly, wehavea Draw data typewith the following API:
public class Draw
Draw()
void
line(double xO, double yO, double xl, double yl)
void
point(double x, double y)
Note: All operations supported by StdDraw are also supportedforDraw objects.
As for anydata type, you can create a newdrawing by using new to create a Draw
object, assign it to a variable, and use that variable name to call the methods that
createthe graphics.For example,the code
Draw d = new Draw();
d.circle(.5,
.5,
.2);
draws a circle in the center of a window on your screen. As with Picture, each
drawing hasitsownwindow, sothatyoucanaddress applications that call formul
tiple different drawings.

352
Object-Oriented Programming
Properties of reference types
Now that you have seen several examples of
reference types (Charge, Color, Picture, String, In, Out, and Draw) and client
programs that use them, we discuss in more detail some of their essential prop
erties. To a large extent, Java protects novice programmers from having to know
these details. Experienced programmers know that a firm understanding of these
properties is helpful in writing correct,effective, and efficientobject-oriented pro
grams.
A reference captures the distinction between a thing and its name. This dis
tinction is a familiar one, as illustrated in these examples:
type
typical object
typical name
website
our booksite
www.cs.pri nceton.edu/IntroProgrammi ng
person
father of computer science
Alan Turing
planet
third rock from the sun
Earth
building
our office
35 Olden Street
ship
superliner that sank in 1912
RMS Titanic
number
circumference/diameter in a circle
IT
Picture
new Picture("mandrill.jpg")
pic
Agiven object may have multiple names, but each object hasits ownidentity. We
cancreatea newname for an objectwithout changing the object's value(viaan as
signment statement), but when we change an object's value (by invoking an in
stancemethod), allof the object'snamesreferto the changedobject.
Thefollowing analogy mayhelpyoukeep thiscrucial distinction clearinyour
mind. Suppose that you want to have your housepainted, so you write the street
address ofyourhouse in pencil on a piece ofpaperandgive it to afew housepaint
ers. Now, ifyouhireoneofthepainters to paintthe house, it becomes a different
color. Nochanges have beenmade to anyofthepieces of paper, but thehouse that
theyallrefer to haschanged. Oneof the painters mighterase whatyou've written
and write the address of another house, but changing what is written on one piece
ofpaper does notchange what iswritten onanother piece ofpaper. Java references
arelike the pieces of paper: theyholdnames of objects. Changing a reference does
not changethe object,but changingan objectmakesthe changeapparent to every
one having a reference to it.

3.7 Data Types
The famous Belgian artist Rene Magritte captured this same concept in a
painting where he created an image of a pipe along with the caption cecinyest pas
unepipe{this isnotapipe) below it.Wemight interpret the cap
tion assayingthat the image is not actuallya pipe,just an image
of a pipe. Or perhaps Magritte meant that the caption isneither
a pipe nor an image of a pipe, just a caption! In the present con
text, this image reinforcesthe idea that a reference to an object
is nothing more than a reference; it is not the object itself.
353
C&u. n-eAtpa* wwfuft&.
Aliasing. An assignment statement witha reference typecre
ates a second copy of the reference. The assignment statement
does notcreate a new object, just anotherreference to an existing
object. Thissituationisknownas aliasing: both variables refer to the sameobject.
The effectof aliasingis a bit unexpected,becauseit is different than for variables
holding values of a primitive type. Be sure thatyou un
derstand the difference. If x and y arevariables of a primi
tivetype, then the assignmentstatement x = y copiesthe
valueof y to x.For reference types,the reference is copied
(not the value). Aliasing is a common source of bugs in
Java programs, asillustratedby the following example:
This is a picture ofa pipe
Color
a
=
new Col or(160, 82, 45);
Color b = a;
811
812
813
811
811
160
82
45
preferences*
Picture a = new PictureC'mandrill.jpg");
same object
Picture b = a;
a.set(i,
j, colorl);
// a is updated
b.set(i,
j, color2);
// a is updated again
Afterthe assignment statement, the variables a and b both
refer to the same Picture. Changing the state of an ob
ject impacts all code involving aliasedvariables referenc
ing that object. We are used to thinking of two different
variables of primitivetypesasbeingindependent, but that
-sienna
intuition doesnot carryoverto reference objects. For ex
ample, if the code above is assumingthat a and b refer to
different Picture objects, then it willproduce the wrong
result. Such aliasing bugs dace, common in programs writ
ten bypeoplewithout much experience in usingreference
Aliasing
objects (that'syou, sopayattentionhere!).

354
Object-Oriented Programming
Immutable types. Forthis veryreason, it is common to define data typeswhose
valuescannot change.A data type that has no methods that can change an object's
value is said to be immutable (as are objectsof that type). For example,Java's Color
and Stri ng objects are immutable (there are no operations availableto clients that
change a color's value), but Picture objects are mutable (we can change pixelcol
ors). Wewill consider immutability in detail in Section 3.3.
Comparing objects. When applied to references, the == operator checks whether
the two references have the same identity (that is, whether they point to the same
object). That is not the same as checkingwhether the objects have the same value.
For example, consider the followingcode:
Color a = new Color(142,
213,
87);
Color b = new Color(142,
213,
87)',
Color c = b;
Now (a == b) is fal se and (b == c) is true, but when you are thinking about
equality testingfor Col or, you probably arethinkingthat you want to testwheth
er their values are the same—you might want all three of these to test as equal.
Javadoes not have an automatic mechanism for testing equality of object values,
which leaves programmers with the opportunity (and responsibility) to define it
for themselves by definingfor anyclass a customizedmethod named equal s (), as
describedin Section 3.3.Forexample, Col or has such a method, and a. equal s (c)
is true in our example. Stri ng also contains an implementationof equal s () be
causewe often want to test that two Stri ng objects have the same value.
Pass by value. When we call a method with arguments, the effect in Java is asif
eachargumentvaluewere to appearon the right-hand sideof an assignment state
ment with the corresponding argument name on the left.That is,Java passesa copy
of the argumentvaluefrom the calling program to the method. This arrangement
is known aspass by value. One important consequence is that the method cannot
changethe value of a caller's variable. For primitive types, this policy is what we
expect (the two variables are independent), but eachtime that we use a reference
type as a method argument, we create an alias, so we must be cautious. In other
words, the convention is to pass the reference by value (make a copy of it) but to
passthe objectbyreference. Forexample, ifwepassa reference to an objectof type
Picture, the method cannot changethe original reference (make it point to a dif-

3.1 Data Types
355
ferent Picture), but it can changethe valueof the object,for exampleby invoking
the method set() to change a pixel'scolor.
Arrays are objects. In Java, every value of anynonprimitive type is an object. In
particular, arrays are objects.Aswith strings, there is speciallanguagesupport for
certain operations on arrays: declarations, initialization, and indexing. Aswith any
other object,when wepassan array to a method or usean arrayvari
able on the right hand side of an assignmentstatement, weare mak
ing a copy of the array reference, not a copyof the array. Arrays are
mutable objects: This convention is appropriate for the typical case
where we expect the method to be able to modify the array by rear
ranging its entries, as in, for example, the exch() and shuffleO
methods that we considered in Section 2.1.
Arrays ofobjects. Arrayentries canbeofanytype, aswehave already
seen on several occasions, from args [] (an array of strings) in our
mai n() implementations, to the array of Charge objectsin Program
3.1.7.When we create an array of objects,wedo so in two steps:
• Create the array,using the bracket syntaxfor array constructors
• Create each object in the array,using a standard constructor
For example,we would use the following code to createan array of
two Charge objects:
Charged
a = new Charge[2];
a[0] = new Charge(.51,
.63, 21.3);
a[l] = new Charge(.13,
.94, 85.9);
Naturally,an array of objects in Javais an array of references^ not the
objects themselves. If the objects are large, then we gain efficiency
by not havingto move them around, just their references. If they are
small,we lose efficiency by having to follow a reference each time we
need to get to some information.
\.
a
123
••
323
124
2
a.length
323
459
-«-a[0]
324
611
—
a[l]
459
.51
460
.63
461
21.3
611
.13
612
.94
613
81.9
An arrayof objects
Safe pointers. To provide the capability to manipulate memoryaddresses that re
fer to data, many programming languagesinclude thepointer (which islikethe Java
reference)as a primitive data type. Programming with pointers is notoriously error

356
Object-Oriented Programming
prone, so operations provided for pointers need to be carefully designed to help
programmers avoid errors. Javatakes this point of view to an extreme (that is fa
vored by many modern programming-language designers). In Java, there is only
onewayto create a reference (new) and only onewayto change a reference (with an
assignment statement). That is, the only things that a programmer can do with
references is to create them and copy them. In program
ming-language jargon, Java references are known as safe
pointers, because Java can guarantee that each reference
points to an object of the specified type. Programmers
used to writing code that directly manipulates pointers
think of Java as having no pointers at all, but people still
debate whether it is really desirable to have unsafe point
ers. In short, when you program in Java, you will not be
directly accessing pointer values, but if you find yourself
doing so in some other languagein the future, be careful!
Orphaned objects. The ability to assign a new value to
a reference variable creates the possibility that a program
may have created an object that it can no longer reference.
For example, consider the three assignment statements in
the figure at right. After the third assignment statement,
not only do a and b refer to the same Color object (the
one whose RGB values are 160,82, and 45), but also there
is no longer a reference to the Color object that was cre
ated and used to initialize b. The only reference to that
object was in the variable b, and this reference was over
written by the assignment, so there is no way to refer to
the object again. Such an object is said to be orphaned.
Objects are also orphaned when they go out of scope.Java
programmers pay little attention to orphaned objects be
cause the system automatically reuses the memory that
they occupy, as we discuss next.
Color
a
=
new Col or(160,
82, 45);
Color
b
=
new Color(255,
255, 0);
Color b = a;
i
a
811
>*\ references to
b
811
jS sameobject
orphaned
s
object
655
255
656
255
-<— yellow
657
0
811
160
812
82
•<—
sienna
813
45
1
1
An orphaned object
Memory management. Programs tend to create huge numbers of objects (and
primitive-type variables) but only have a need for a small number of them at any
given point in time. Accordingly, programming languages and systems need mech-

3.1 Data Types
357
anisms to allocate memory for data type values during the time they are needed
and to freethe memory when they are no longer needed (for an object, sometime
after it is orphaned). Memory management is easier for primitive types because all
of the information needed for memory allocation is known at compile time. Java
(and most other systems) take care of reservingspace for variables when they are
declared and freeing that spacewhen they go out of scope.Memory management
for objects is more complicated: the compiler knows to allocate memory for an
object when it is created, but cannot know precisely when to free the memory as
sociated with an object, because the dynamics of a program in execution determine
when an object is orphaned.
Memory leaks. In many languages (such as C and C++) the programmer
is responsible for both allocating and freeing memory. Doing so is tedious and
notoriously error-prone. For example, suppose that a program deallocates the
memory for an object, but then continues to refer to it (perhaps much later in the
program). In the meantime, the system may have allocated the same memory for
another use, so all kinds of havoc can result. Another insidious problem occurs
when a programmer neglects to ensure that the memory for an orphaned object is
deallocated. This bug is known as a memory leak because it can result in a steadily
increasing amount of memory devoted to orphaned objects (and therefore not
available for use). The effectis that performance degrades, just as if memory were
leakingout of your computer.Haveyou everhad to reboot your computer because
it was gradually getting lessand lessresponsive? A common cause of such behavior
is a memory leak in one ofyour applications.
Garbage collection. One of Java's most significant features is its abilityto auto
maticallymanage memory. The idea is to freethe programmers from the respon
sibilityof managing memory by keeping track of orphaned objectsand returning
the memory they use to a pool of freememory. Reclaiming memory in this wayis
known as garbage collection, and Java's safepointer policy enables it to do this ef
ficiently and automatically. Garbagecollection isan old idea,but peoplestilldebate
whether the overhead of automatic garbagecollectionjustifiesthe convenience of
not having to worry about memory management. The same conclusion that we
drew for pointers holds: when you program in Java, you will not be writing code to
allocate and free memory, but if you find yourself doing so in some other language
in the future, be careful!

358
Object-Oriented Programming
For reference, we summarize the examples that we have considered in this section in
the table below. These examples are chosen to help you understand the essential
properties of data types and object-orientedprogramming.
Adata type isasetofvalues andasetofoperations defined onthose values. With
primitivedata types,weworkedwith a smalland simple set of values. Colors,pic
tures, strings, and input-output streams are high-level data types that indicate the
breadth of applicabilityof data abstraction. You donotneed toknow howa datatype
isimplemented inorder tobeable touse it. Eachdata type (there are hundreds in the
Javalibraries, and you will soon learn to
create your own) is characterized by an
API (application programming inter
face) that provides the information that
you need in order to use it. A client pro
gram creates objects that hold data type
values and invokes instance methods to
manipulate those values. We write cli
ent programs with the basic statements
and control constructs that you learned
in Chapters 1 and 2, but now have the
capability to work with a vast variety of
data types,not just the primitive ones to
which you have grown accustomed.With experience,you will find that this ability
opens up for you new horizons in programming.
Our Charge example indicates that you can tailor one or more data types
to the needs of your application. The ability to do so is profound, and also is the
subject of the next section. When properly designed and implemented, data types
lead to client programs that are clearer, easier to develop, and easier to maintain
than equivalent programs that do not takeadvantageof data abstraction. The client
programs in this section are testimony to this claim. Moreover, as you will see in
the next section, implementing a data type is a straightforward application of the
basic programming skillsthat you have already learned. In particular, addressing a
large and complex application becomes a process ofunderstanding its data and the
operations to be performed on it, then writing programs that directly reflect this
understanding. Once you have learned to do so,you might wonder how program
mers ever developed large programs without using data abstraction.
API
description
Charge
electrical charges
Color
colors
Picture
digitalimages
String
characterstrings
In
input streams
Out
output streams
Draw
drawings
Summary ofdatatypes in this section

3.1 Data Types
Q. Why the distinction between primitive and referencetypes?
A. Performance. Javaprovides the wrapper referencetypes Integer, Double, and
so forth that correspond to primitive types and can be used by programmers who
prefer to ignore the distinction. Primitivetypes are closerto the types of data that
are supported by computer hardware, so programs that use them usually run faster
than programs that use corresponding referencetypes.
Q. Whathappensif I forget to usenew whencreating an object?
A. ToJava, it looksasthough youwant to call a staticmethod with a return value
of the objecttype. Since you have not defined sucha method, the error message is
the sameaswhenyou referto an undefinedsymbol. Ifyou compile the code
Charge c = Charge(.51,
.63, 21.3);
you get this error message:
cannot find symbol
symbol
: method Charge(double,double,double)
Constructors do not provide return values (their signature has no return value
type)—they can only follow new. You get the same kind of errormessage if you
provide the wrong number of arguments to a constructor or method.
Q. Why don'twewrite StdOut.printl n(x. toStri ng()) to printobjects thatare
not strings?
A. Good question. That code works fine, butJava saves us the trouble ofwriting
it byautomatically invoking toStri ng() forusanytime a Stri ng typeis needed.
This policyimpliesthat everydata type must havea toStri ng() method. Wewill
discuss in Section 3.3. Java's mechanism forensuring that thisisthe case.
Q. What is the differencebetween =,==, and equal s ()?
A, The single equals sign (=) is the basis of theassignment statement—you cer
tainly arefamiliar withthat.The double equals sign (==) isa binaryoperator for
checking whether itstwooperands areidentical. If theoperands areof a primitive

360
Object-Oriented Programming
type, the result is true if they havethe samevalue,and fal se otherwise.If the op
erands are references, the result is true if they refer to the same object, and f al se
otherwise.That is,we use == to test objectidentity equality. The data-type method
equal s () is included in everyJavatype so that the implementation can provide the
capability for clients to test whether two objects have the same value. Note that (a
== b) implies a. equal s (b), but not the other wayaround.
Q. Howcan I arrange to passan arrayto a function in such a waythat the function
cannot change the array?
A, There is no direct wayto do so—arraysare mutable. In Section 3.3,you will see
how to achieve the same effect bybuilding a wrapper data type and passinga value
of that type instead (Vector, in Program 3.3.3).
Q. What happens if I forgetto use new when creating an array of objects?
A. Youneed to use new for each object that you create, so when you create an array
of N objects, you needto use new N+l times: oncefor the arrayand oncefor each
of the N objects.If you forgetto createthe array:
Charged a;
a[0] = new Charge(0.51, 0.63, 21.3);
yougetthesameerror message thatyouwouldgetwhentryingto assign avalue to
any uninitializedvariable:
variable a might not have been initialized
a[0] = new Charge(0.51, 0.63, 21.3);
but if you forget to use new whencreating an objectwithin the array and then try
to use it to invoke a method:
Charged a = new Charge[2];
double x = a[0].potentialAt(.5,
.5);
you geta Nul 1PointerExcepti on.As usual, the bestwayto answer suchquestions
is to write and compile such code yourself,then try to interpret Java's error mes
sage. Doing so might help you more quicklyrecognize mistakeslater.

3.1 Data Types
Q. Where can I find more details on how Javaimplements references and garbage
collection?
A. One Javasystem might differ completelyfrom another. For example, one natu
ral scheme is to use a pointer (machine address); another is to use a handle (a
pointer to a pointer). The former givesfaster access to data; the latter provides for
better garbage collection.
Q. Why red, green, and blue instead of red,yellow, and blue?
A. In theory, any three colors that contain some amount of each primary would
work, but two different schemes have evolved: one (RGB) that has proven to pro
duce good colors on television screens, computer monitors, and digital cameras,
and the other (CMYK) that is typically used for the printed page (see Exercise
1.2.21). CMYK does include yellow (cyan, magenta,yellow, and black). Two dif
ferent schemes are appropriate becauseprinted inks absorb color, so where there
are two different inks there are more colorsabsorbed andfewer reflected;but video
displaysemitcolor, so where there are two different colored pixels there are more
colors emitted.
Q. What exactly does it mean to i mport a name?
A. Not much: it just saves sometyping. You could type Java.awt.Color every
where in your code instead of using the i mport statement.
<)• Is there anything wrongwith allocating and deallocating thousands of Color
objects, as in Grayscal e (Program 3.1.4)?
A. Allprogramming-language constructs come at some cost.In this casethe cost
is reasonable, since the time for these allocations is tiny compared to the time to
actually draw the picture.
Q. Whydoesthe Stri ng methodcall s. substri ng(i, j) return the substringof
s starting at index i and ending at j -1 (and not j)?
A. Whydo the indicesof an array a[] go from 0 to a. 1ength-1 instead of from 1
to 1ength? Programming-language designers make choices; we live with them.

362
Object-Oriented Programming
3.1.1
Write a program that takes a doubl e value wfrom the command line, cre
ates four Charge objects with charge value 1.0 that are each distance win each of
the four cardinal directions from (.5, .5), and prints the potential at (.25, .5).
3.1.2
Write a program that takesfrom the command line three integers between
0 and 255that represent red, green,and blue valuesof a color and then createsand
shows a 256-by-256 Picture of that color.
3.1.3
ModifyAl bersSquares (Program3.1.2) to take nine command-line argu
ments that specifythree colorsand then drawsthe sixsquaresshowingallthe Albers
squares with the largesquarein eachcolorand the smallsquare in each different
color.
3.1.4
Write a program that takes the name of a grayscale picture file as a
command-lineargumentand uses StdDraw to plot a histogramof the frequency of
occurrence of each of the 256 grayscaleintensities.
3.1.5
Writea program that takes the name of a picture file as a command-line
argumentand flips the image horizontally.
3.1.6
Write a programthat takes the nameof an picturefile asa command-line
input,andcreates threeimages, onethatcontains onlythe redcomponents, onefor
green, and one for blue.
3.1.7
Write a programthat takes the nameof an picturefile asa command-line
argumentand prints the pixel coordinates of the lower leftcorner and the upper
rightcornerof the smallest bounding box(rectangle parallel to the x- andy-axes)
that contains all of the non-white pixels.
3.1.8
Write a programthat takes as command line arguments the name of an
image file and the pixel coordinates of a rectangle within the image; reads from
standard input a list of Color values (represented as triples of int values); and
serves asa filter, printingout thosecolorvalues forwhichallpixels in the rectangle
are background/foreground compatible. (Such a filter can be used to pick a color
for text to label an image.)

3.1 Data Types
3.1.9
Write a function isValidDNAO that takes a string as input and returns
t rue if and only if it is comprised entirely of the characters A, C, T,and G.
3.1.10 Write a function compl ementWC() that takesa DNAstring asits inputs and
returns its Watson-Crick complement: replaceAwith T,Cwith G, and vice versa.
3.1.11 Write a function pal i ndromeWC () that takes a DNA string as its input and
returns true if the string is a Watson-Crick complemented palindrome, and f al se
otherwise. A Watson-Crick complementedpalindrome is a DNAstring that is equal
to the reverse of its Watson-Crick complement.
3.1.12 Write a program to check whether an ISBN number is valid (see Exercise
1.3.33), taking into account that an ISBN number can have hyphens inserted at
arbitrary places.
3.1.13 What does the followingcode fragment print?
String stringl = "hello";
String string2 = stringl;
stringl = "world";
StdOut.pri ntln(stri ngl);
StdOut.pri ntln(stri ng2);
3.1.14 What does the following codefragmentprint?
String s = "Hello World";
s.tollpperCaseO;
s.substring(6, 11);
StdOut.println(s);
Answer. "Hello
World". String objects are immutable—string methods each
return a new String object with the appropriate value (but they do not change
the value of the object that was used to invoke them). This code ignores the
objects returned and just prints the original string. To print "WORLD", use s
=
s.tollpperCaseO ands = s.substring(6, 11).
363

Object-Oriented Programming
3.1.15 A string s is a circular shiftof a string t if it matches when the characters
are circularlyshifted by anynumber of positions. For example, ACTGACG isa circular
shift of TGACGAC, and viceversa.Detecting this condition is important in the study
of genomic sequences. Write a program that checks whether two given strings s
and t are circular shifts of one another. Hint: The solution is a one-liner with i n-
dexOf() and string concatenation.
3.1.16 Given a string site that represents a website, write a code fragment to
determine its domain type. For example, the domain type for the string http: //
www.cs.princeton.edu/IntroProgramming is edu.
3.1.17 Write a static method that takes a domain name as argument and returns
the reversedomain (reversethe order of the strings between periods). For example,
the reverse domain of cs. pri nceton. edu is edu. pri nceton. cs. This computa
tion is usefulfor web log analysis. (See Exercise 4.2.35.)
3.1.18 What does the following recursivefunction return?
public static String mystery(String s)
{
int N = s.lengthO;
if (N <= 1) return s;
String a = s.substring(0, N/2);
String b = s.substring(N/2, N);
return mystery(b) + mystery(a);
}
3.1.19 Modify GeneFi ndto handleallthreestop codes(insteadof handlingthem
one at atimethrough the commandline).Also add command-lineargumentsto al
lowthe user to specify lowerand upper bounds on the length of the genesought.
3.1.20 Write a version of GeneFind based on using the indexOf() method in
Stri ng to find patterns.
3.1.21 Write a program that takes a start string and a stop string as command-
line arguments and prints all substrings of a given string that start with the first,
end with the second, and otherwise contain neither. Note: Be especially careful of
overlaps!

3.1 Data Types
3.1.22 Write a filter that reads text from an input stream and prints it to an output
stream, removing any lines that consist only of whitespace.
3.1.23 Modify Potential (Program 3.1.7) to take an integer N from the com
mand line and generate ATrandom Charge objectsin the unit square,with potential
values drawn randomly from a Gaussian distribution with mean 50 and standard
deviation 10.
3.1.24 Modify StockQuote (Program 3.1.10) to take multiple symbols on the
command line.
3.1.25 The examplefile data usedfor Spli t (Program3.1.11) liststhe date,high
price,volume, and lowprice of the DowJones stockmarket average for everyday
since records have beenkept.Download thisfile fromthebooksite and writea pro
gram that createstwo Draw objects, one for the pricesand one for the volumes,and
plots them at a rate taken from the command line.
3.1.26 WriteaprogramMerge thattakes adelimiter stringfollowed byanarbitrary
number of file namesascommandlinearguments, concatenates the corresponding
lines of each file, separated by the delimiter,and then writes the result to standard
output, thus performing the opposite operation from Spli t (Program 3.1.11).
3.1.27 Find a website that publishes the current temperature in your area, and
write a screen-scraperprogram Weather so that typingJava Weather followed by
your zip code will giveyou a weather forecast.
3.1.28 Suppose that a[] and b[] areeachinteger arrays consisting of millions of
integers. What doesthe following codedo,and howlongdoesit take?
int[]
t
= a;
a = b;
b = t;
Answer. It swaps them, but it does so by copyingreferences, so that it is not neces
sary to copy millions of elements.
365

Object-Oriented Programming
CmatMesM^^mms.
3.1.29 Picture filtering. Write a library RawPicture with read() and write()
methods for use with standard input and standard output. The write() method
takes a Picture as argument and writes the picture to standard output, using the
followingformat: if the picture isw-by-/z, write w,then /z, then whtriples of integers
representing the pixelcolorvalues, in rowmajor order.The read () method takes
no arguments and returns a Picture, whichit creates by reading a picture from
standard input, in the format just described. Note: Be aware that this will use up
much more diskspacethan the picture—thestandard formats compress this infor
mation so that it will not take up so much space.
3.1.30 Sound visualization. Writea program that uses StdAudio and Picture to
create an interesting two-dimensional colorvisualization of a sound file while it is
playing. Becreative!
3.1.31 Kama Sutra cipher. Writea filter KamaSutra that takestwo stringsascom
mand-line argument (the key strings), then reads standard input, substitutes for
eachletter asspecified bythe keystrings, and writesthe resultto standard output.
Thisoperationisthebasis foroneoftheearliest knowncryptographic systems. The
conditionon the keystringsisthat theymustbe of equallengthand that anyletter
in standardinput mustbe in oneofthem.Forexample, ifinput isallcapitalletters
and the keys areTHEQUICKBROWN and FXJMPSVRLZYDG, then wemake the table.
U
I
C
P
S
V
K
B
R 0
W N
L
A
Z
Y
D G
which tells us that we should substitute Ffor T,T for F, Hfor X, Xfor H, and so forth
whencopying the input to the output. The message is encoded by replacing each
letter with its pair.For example, the message MEET AT ELEVEN is encoded as Q33F
BF JKJCJG. Someonereceiving the message can use the same keys to get the mes
sageback.
3.1.32 Safepassword verification. Writeastaticmethod that takesa stringasargu
ment and returns true if it meets the followingconditions, f al se otherwise:
• At least eight characters long
• Contains at least one digit (0-9)
• Contains at least one upper-case letter

3.1 Data Types
367
• Contains at least one lower-case letter
• Contains at least one character that is neither a letter nor a number
Suchchecks are commonly used for passwords on the web.
3.1.33 Color study. Writea programthat displays the colorstudyshownat right,
which gives Albers squares corresponding to each
of the 256 levels of blue and graythat were used to
DlIilZitMlIiaailMlilll'Blillilli
printthisbook.
^^^^^^^^^^^^^^^^^^M
3.1.34 Entropy. The Shannon entropy measures
^^^^^^^^B^^^^S^^^m
the information contentofan input string and plays
nSHHHU
a cornerstone role in information theory and data
]^Q^^^^^^ffm^^0^0li^^i
compression. Given astring of Ncharacters, let fc
^^^S^^mBS^XM^^MM
be the frequency ofoccurrence ofcharacter cThe
|i^fi^^^^^^^^^Sl^^^S
quantitypc =fc/Nis anestimate ofthe probability
',y''''^;gWWm§Wm^VmM:*wi
that c would be in the string if it were a random
l a B a a p • m••••••
•
string, and the entropy is defined to be the sum of
'-' »•••••••••••••
the quantity -pclog2pc, over all characters that ap-
•^•••••••••••i
pear in the string. The entropy is said to measure
:~. &t mmmmmmmmmmmw
the information content of a string:if eachcharacter
appears the same number times, the entropy is at
its minimum value.Write a program that computes
and prints the entropy of the string on standard input. Run your program on a
webpagethat you read regularly, a recentpaper that youwrote,and on the fruit fly
genome found on the website.
3.1.35 Minimizepotential. Writea function that takesan array of Charge objects
with positivepotential as its argument and findsa point such that the potential at
that point iswithin 1%of the minimum potentialanywhere in the unit square.Use
a Charge object to return this information. Add a call to this function and print
out the point coordinates and chargevaluefor the data givenin the text and for the
random charges described in Exercise 3.1.23.
3.1.36 Slide show. Write a program that takes the names of several image files as
command-line arguments and displays them in a slide show (one every two sec
onds), using a fade effect to black and a fade from black between pictures

Object-Oriented Programming
3.1.37 Tile. Writea program that takesthe name of an imagefile and twointegers
M and N as command-line arguments and creates an M-by-JV tiling of the pic
ture.
3.1.38 Rotation filter. Write a program that takestwo command-
line arguments (the name of an imagefile and a realnumber theta)
and rotates the image 0 degrees counterclockwise. To rotate, copy
the color ofeach pixel (sf, s;) inthe source image toa target pixel
(t;,f •) whose coordinates aregiven bythe following formulas:
t{ = (s{ —cf)cos0 ~ (s;- - c;)sin0 + c{
tj = (s; - cf)sin0 + (sj - c;)cos0 + c;-
where (cf, cj) is the center ofthe image.
3.1.39 Swirlfilter. Creating a swirleffectissimilar to rotation, ex
cept that the angle changes as a function of distanceto the center.
Use the same formulas as in the previous exercise, but compute 0
as afunction of(sf, s;), specifically tt/256 times the distance tothe
center.
3.1.40 Wavefilter. Write a filterlikethose in the previous two ex
ercisesthat createsa waveeffect, by copyingthe color of each pixel
(sf, sj) inthe source image toatarget pixel (t{, t;), where t{ =s; and
tj =Sj +20sin(2 tts^/128). Add code totake the amplitude (20 inthe
accompanying figure) and the frequency (128 in the accompany
ing figure) as command-line arguments.Experimentwith various
values of these parameters.
3.1.41 Glassfilter. Write a program that takesthe name of an im
age file as a command-line argument and applies a glass filter, set
each pixel p to the color of a random neighboring pixel (whose
pixel coordinates both differ fromp's coordinates by at most 5).
rotate 30 degrees
swirlfilter
wavefilter
glassfilter
Exercises infiltering

3. / Data Types
3.1.42 Morph. Theexample images inthetextfor Fade do not quitelineup in the
vertical direction (the mandrill's mouth is much lower than Darwin's). Modify
Fade to add a transformation in the vertical dimension that makes a smoother
transition.
3.1.43 Digital zoom. Write a program Zoom that takes the
name of an image file and three numbers s,x, and y as com
mand-line arguments and shows an output image that zooms
in on a portion of the input image. The numbers are all be
tween 0and 1,withstobeinterpreted asascale factor and (x,y)
asthe relative coordinatesof the point that isto be at the center
ofthe output image. Use thisprogram to zoomin onyourdog
or a friend in some digital image on your computer. (If your
image camefromacell phoneor anoldcamera,youmaynotbe
ableto zoom in too close without having visible artifacts from
scaling.)
3.1.44 Edge detection. An edgeis an area of a picture with a
strong contrast or discontinuity in intensity from one pixelto
the next. Finding the edges of an image isa fundamental prob
lem in image processing and computervision because edges
characterize the object boundaries.Writea program EdgeDe-
tect that takesthe name of an imagefile and producesan im
agewith the edgeshighlighted.
java Picture kitten.jpg
java EdgeDetect kitten.jpg
Edgedetection
java Zoom pup
Digital zoom
369

Object-Oriented Programming
3.2
Creating Data Types
In principle, wecould write all of our programsusingonlythe eightbuilt-in prim
itive types, but, as wesawin the lastsection, it is much more convenient to write
programs at ahigherlevel ofabstraction. Thus,avariety ofdatatypes arebuiltinto
the Java language and libraries. Still, we certainly cannot expect Java to contain
every conceivable datatypethatwemighteverwishto use, soweneedto beableto
define our own. The purpose of this sec
tion is to explainhow to build data types
with the familiar Java cl ass.
3-2-1
Charged-particle implementation .375
Implementing adata type as aJava
?•" Stopwatch
.379
.
r
5-13C
/
•
i
3-2-3
Histogram
381
class is not very different from imple-
324 Turtle graphics
383
menting a function library as a set of
3.2.5
Spira mirabilis
. .387
static methods. The primary difference
3.2.6
Complex numbers
.393
is that we associate data with the meth-
32J
Mandelbrot set
397
, .
,
, ,.
rp,
Am
.£
3.2.8
Stockaccount
. .401
od implementations. The API specifies
the methods that we need to implement,
Programs in this section
but we are free to choose any convenient
representation. To cement the basic con
cepts, webeginby considering the implementation of the data type for charged
particles that weintroduced at thebeginning of Section3.1. Next, weillustrate the
process of creating data typesby considering a range of examples, from complex
numbers to stock accounts, including a number of softwaretools that we will use
later in the book. Usefulclient code is testimony to the value of any data type, so
we also consider a number of clients, including one that depicts the famous and
fascinatingMandelbrot set.
The process of defining a data typeisknown as data abstraction (asopposed
to thefunction abstraction style that isthe basisof Chapter 2).Wefocuson the data
and implement operations on that data. Wheneveryoucan clearly separate data and
associated operations within aprogram, youshould doso. Modelingphysicalobjects
or familiar mathematical abstractions is straightforward and extremely useful, but
the true power of data abstraction is that it allows us to model anything that we
can preciselyspecify. Once you gain experience with this style of programming,
you will seethat it naturally helps us address programming challengesof arbitrary
complexity.

3.2 Creating Data Types
371
Basic elements ofadata type
To illustrate theprocess ofimplementing adata
type in a Java class, we discuss in detail an implementation of the Charge data
type of Section 3.1.Wehave already considered clientprogramsthat demonstrate
the utility of havingsuch a data type (in Programs3.1.1 and 3.1.7)—nowwefocus
on the implementation details. Every data-type implementation that you will de
velop hasthe samebasicingredients asthissimple example.
API. The application programming interface is the contract with all clientsand,
therefore, the startingpoint for anyimplementation. To emphasize that APIs are
criticalfor implementations, werepeathereour example ChargeAPI:
public class Charge
Charge(double xO, double yO, double qO)
double
potentialAt(double x, double y)
electricpotential at(x, y)due to charge
Stri ng toStri ng()
string representation
APIfor chargedparticles {see Program 3.2.1)
To implement Charge, weneedto define thedatatypevalues, implement the con
structor that creates objects having specified values, and implementtwo methods
that manipulate those values. When faced with the problem of creating a com
pletely new class for some application, thefirst step isto develop anAPI. This step
isa design activity that wewill address in Section 3.3. We needto design APIs with
carebecause afterweimplement classes and writeclient programs that use them,
wedo notchange theAPI, because that would imply changing allclients.
Class. Thedata-typeimplementation isaJava cl ass. As withthelibraries of static
methods that we have beenusing, we put thecode fora datatypein a file withthe
samename asthe class, followed bythe .j ava extension. We have been implement
ing Java classes, but the classes that wehave been implementing do not have the
keyfeatures of data types: instance variables, constructors, and instance methods. In
stance variables aresimilarto thevariables thatwehave beenusingin our program,
and constructors and methods are similar to functions, but their effect is quite
different. Eachof thesebuildingblocks is also qualified by an access (or visibility)
modifier. Wenext consider these four concepts, with examples.

372
Object-Oriented Programming
Access modifiers. Thekeywords publi c, pri vate, and fi nal that sometimes pre
cede classand variable names are known as access modifiers. The publ \c and pri
vate modifiers control access from client code: we designate every instance vari
ableand method within a class aseither publi c (this entity is accessible by clients)
or private (this entity is not accessible by clients). The fi nal modifierindicates
that the valueof the variablewillnot changeonceit isinitialized—its access isread
only. Our convention isto use publ i c forthe constructors and methods in theAPI
(since we are promising to provide them to clients) and private for everything
else. Typically, our private methods are helper methods used to simplify code in
other methods in the class. Java is not so restrictiveon its usage of modifiers—we
defer to Section 3.3 a discussion of our reasons for these conventions.
Instancevariables. Towrite code for the methods that manipulate data type val
ues, the first thingthat we need is to declare variables that wecan useto refer to
thesevalues in code.Thesevariables can be any type of data. Wedeclarethe types
and names of these instance variables in the samewayaswe declarelocalvariables:
for Charge, we use three double values, two to describe the charge's position in
the planeand one to describe the amount of charge. These declarations appearas
the first statements in the class, not inside mai n() or any other method. There is a
critical distinction between instance variables and the local variables within a static
methodorablock thatyouareaccustomed to:thereisjustonevalue corresponding
to each local variable at a given time, but there
are numerous values corresponding to each in
stance variable (one for each object that is an
instanceof the data type). There is no ambiguity
with this arrangement, because each time that
we invoke an instance method, we do so with an
objectname—that objectisthe one whosevalue
we are manipulating.
public class Charge
{
modifiers
Instance variables
Constructors. A constructor creates an object and provides a reference to that
object. Java automatically invokes a constructor when a clientprogram uses the
keyword new. Java does most of the work: our code only needs to initialize the
instance variables to meaningful values.Constructors always share the same name
as the class, but we can overload the name and have multiple constructors with
differentsignatures, just as with staticmethods.Tothe client,the combination of

3.2 Creating Data Types
access
modifier
constructor name
type
(same asdnss name)
argument
variables
\
\_/_
11 publ ic| [Charge! (| double xp" , double yO , double q0| )
f
instance^
rx = xO;
names
~"~
ry
-
yv,
§ = qO;
}
body
signature
Anatomy ofa constructor
new followed bya constructorname(withargument values enclosed withinparen
theses) isthe sameasafunction call that returnsavalue ofthecorresponding type.
A constructor signature has no return type, because constructors always return
a reference to an objectof its data type (the name of the type, the class, and the
constructor are all the same). Each time that a client invokes a constructor, Java
automatically:
•Allocates memory spacefor the object
• Invokes the constructor code to initialize the instance variables
• Returns a referenceto the object
The constructor in Charge is typical: it initializes the instancevariables with the
valuesprovided by the client as arguments.
Instance methods. To implement instance methods, we write code that is pre
ciselylikethe codethat welearnedin Chapter2to implementstaticmethods (func
tions).Each method has a signature (which specifies its return type and the types
and names of its argumentvariables) and a body(which consists of a sequence of
local
"_
variables*
access
return
modifier
type
\
i
method
name
_\_
argument
variables
Ipubl i clldoubl elIpotentialAtl(ldoubl e xl, [double vl)
'|double k |- 8. 99e09j__ argument variable name
-[double dxl =1x1 - rx:
• .
• M
bz^z==
'—'
^-- instance variable name
[double dyl= y - |ry|;
return k * q /|Math.sqrt(dx*dx + dy*[dyl) ;
call on a static method
Anatomyof an instance method
\
local variable name
signature
373

374
Object-Oriented Programming
statements,including a return statement that provides a value of the return type
back to the client).When a client invokes a method, the systeminitializesthe argu
ment variables with client values; executes statements until reaching a return
statement; and returns the computed valueto the client,with the same effect as if
the method invocation in the clientwerereplacedwith that return value.Allof this
action is the same as for static methods, but there is one critical distinction for in
stance methods: they canperform operations oninstance variables.
Variables withinmethods. Accordingly, the Java codethat wewriteto implement
instance methods uses three kinds of variables:
• Argument variables
• Local variables
• Instance variables
The firsttwo are the sameasfor staticmethods:argument variablesare specifiedin
the method signature and initialized with clientvalues when the method is called,
and localvariables are declared and initialized within the method body. The scope
of argument variables isthe entire method; the scope of local variables is the fol
lowing statements in the block where theyaredefined. Instance variables arecom
pletely different: theyhold data-type values for objects in a class, and their scope
is the entire class. How do we specify which object'svalue we want to use? If you
think for a moment about this question, you will recallthe answer. Each object in
the classhas a value: the code in a classmethod refers to the valuefor theobject that
was used to invoke the method. When wesaycl. potenti al At(x,
y), the code in
potentialAt() is referring to the instance variables for cl. The code in poten-
ti al At O uses all three kinds of variable names, as summarized in this table:
variable
purpose
example
scope
instance
specifydata-type value
rx,
ry
class
argument
passvaluefrom clientto method
x, y
method
local
temporaryusewithinmethod
dx, dy
block
Variables within instance methods
Be sure thatyou understand the distinctions among these three kinds of variables.
These differences are a key to object-oriented programming.

3.2 Creating Data Types
375
$3?
m
%**&•:
3&a
Program 3.2.1
Charged-particle implementation
public class Charge
{
private final
double rx,
ry;
private final
double q;
public Charge(double xO, double yO, double qO)
{
rx = xO; ry = yO; q = qO;
}
public double potentialAt(double x, double y)
{
double k = 8.99e09;
double dx = x -
rx;
double dy = y -
ry;
return k * q / Math.sqrt(dx*dx + dy*dy);
}
public String toStringO
{
k
dx,
dy
electrostatic constant
delta distances to
querypoint
••^m^^^^^^^^^^m:^m
}
return q + " at " + "(" + rx + ",
" + ry + ")'
public static void main(String[] args)
{
double x = Double.parseDouble(args[0]);
double y = Double.parseDouble(args[1]);
Charge cl = new Charge(.51,
.63, 21.3);
Charge c2 = new Charge(.13,
.94, 81.9);
double vl = cl.potentialAt(x, y);
double v2 = c2.potentialAt(x, y);
StdOut.printf(M%.le\nM, (vl + v2));
}
x,
y
cl
vl
c2
v2
query point
firstcharge
potentialdue to cl
second charge
potential due to c2
This implementation ofour data typefor charged particles contains the basic elementsfound
in every data type: instance variables rx, ry, andq;a constructor Charge(); instance methods
potenti al At() andtoStri ng(); anda test client mai n() (see also Program 3.1.1).

376
Object-Oriented Programming
These are the basic components that you need to understand to be able to build
data types in Java. Everydata-type implementation (Java class) that we will con
sider has instance variables, constructors, instance methods, and a test client. In
eachdata type that wedevelop, wegothrough the samesteps.Ratherthan thinking
about what action we need to take next to accomplish a computational goal (aswe
did when first learning to program), wethink about the needs of a client,then ac
commodate them in a data type.
The first step in creatinga data type is to specify an API.The purpose of the
API is to separate clients from implementations, to enable modular programming.
Wehavetwo goals when specifying an API. First,wewant to enable clear and cor
rect clientcode.Indeed,it is a goodideato write some clientcodebeforefinalizing
the APIto gainconfidence that the specified data-type operations arethe onesthat
clients need. Second,we want to be able to implement the operations. There is no
point specifying operationsthat wehave no ideahow to implement.
The secondstep in creatinga data type isto implement a Java class that meets
the API specifications. First, we choose the instancevariables, then we write the
codethat manipulatesthe instancevariables to implement the specified methods.
The third step in creating a data type is to write test clients,to validate the
designdecisionsmade in the firsttwo steps.
In this section,westart eachexample with an API,and then consider imple
mentations, then clients. You will find many exercises at the end of this section
intended to give you experience with data-type creation.Section 3.3isan overview
of the designprocessand relatedlanguage mechanisms.
What are the valuesthat definethe type, and what operations do clientsneed
to perform on those values? With these basic decisions made, you can create new
data types and write clients that use the data types that you have defined in the
same wayasyou havebeen using built-in types.

3.2 Creating Data Types
public class Charge
{
instance
variables
constructor -
instance
methods
test client
create
and
initialize"
object
private final
double rx,
ry;
private final
double q;
public Charge(double xO, double yO, double qO)
{
rx = xO; ry = yO; q = qO;
}
public double potentialAt(double x, double y)
{
^^^^ instance
double k = 8.99e09; ^—-~
variable
double dx = x -
rx ;
names
double dy = y - ry;
return k * q /
Math.sqrt(dx*dx +
}
dy*dy)/
public String toString()
{
return q +" at " + "("+ rx + ",
" + ry +")";
}
public static void main(String[] args)
{
double x = Double.parseDouble(args[0])
double y = Double.parseDouble(args[1])
Charge cl =|new Charge(.51,
.63, 21.3)
Charge c2 = new Charge(.13,
.94, 81.9); \
double vl = cl. potential At (x, y) ;
invoke
double v2 =| c2. potenti alAt ( x, y);
constructor
StdOut.prin/f("%.le\n", (vl + v20);
object
name
Anatomy ofa class
invoke
method
377

378
Object-Oriented Programming
Stopwatch
One of the hallmarks of object-oriented programming is the idea
of easily modeling real-world objects by creating abstract programming objects.
As a simple example, consider Stopwatch (Program 3.3.2), which implements the
followingAPI:
public class Stopwatch
Stopwatch ()
create a newstopwatch andstartit running
doubl e
el apsedTi me()
return the elapsed time since creation, inseconds
APIforstopwatches {see Program 3.2.2)
In other words, a Stopwatch is a stripped-down version of an old-fashioned stop
watch.When you create one, it starts running, and you can ask it how long it has
been running by invokingthe method el apsedTi me (). You might imagine adding
all sorts of bells and whistlesto Stopwatch, limited only by your imagination. Do
you want to be ableto resetthe stopwatch? Start and stop it?Include a lap timer?
Thesesorts of things are easyto add (seeExercise 3.2.11).
The implementation in Program 3.2.2uses the Javasystem method System,
cur rentTi meMi 11i s (), which (aswell-describedby its name) returns along value
giving the current time in milliseconds (the number of milliseconds since mid
night on January 1, 1970 UTC). The data-type implementation could hardly be
simpler.A Stopwatch saves its creation time in an instance variable, then returns
the difference between that time and the current time whenever a client invokes
its el apsedTi me() method. A Stopwatch itself does not actually tick (an internal
systemclockon your computer does all the ticking for all Stopwatch objects and
many other data types);it just creates the illusionthat it does for clients. Why not
just use System.currentTi meMi 11 i s() in clients? We could do so,but using the
higher-level Stopwatch abstractionleadsto clientcode that is easierto understand
and maintain.
The test client is typical. It creates two Stopwatch objects, uses them to mea
sure the running time of two different computations, then prints the ratio of the
running times.The question of whether one approach to solvinga problem isbet
ter than another has been lurking since the first few programs that you have run,
and playsan essentialrole in program development. In Section 4.1,wewill develop
a scientific approach to understanding the cost of computation. Stopwatch is a
useful tool in that approach.

3.2 Creating Data Types
Pit
Program3.2.2
Stopwatch
public class Stopwatch
{
private final
long start;
public Stopwatch()
{
start = System.currentTimeMillisQ;
}
}
public double elapsedTime()
{
long now = System.currentTimeMillis();
return (now - start) / 1000.0;
}
public static void main(String[] args)
{
int N = Integer.parselnt(args[0]);
double totalMath =0.0;
Stopwatch swMath = new Stopwatch();
for (int i
= 0;
i
< N; i++)
total Math += Math.sqrt(i);
double timeMath = swMath.elapsedTime();
double totalNewton = 0.0;
Stopwatch swNewton = new Stopwatch();
for (int i = 0; i < N;
i++)
total Newton += Newton.sqrt(i);
double timeNewton = swNewton.elapsedTime();
StdOut.pri ntln(total Newton/totalMath);
StdOut.pri ntln(ti meNewton/ti meMath);
This class implements a simple data type that wecan use to compare running times ofperfor
mance-critical methods (see Section 4.1). The test client compares the methodfor computing
square roots in Java's Math library with our implementation from Program 2.1.1 that uses
Newton's methodfor thetask ofcomputing thesumof thesquare roots of thenumbersfrom 0
toN-l. For this quick test, theJava implementation Math.sqrt () isabout20 timesfasterthan
our Newton. sq rt () (as it should be!).
% java Stopwatch 1000000
1.0
19.961538461538463
•mmm
S"*3$^P
••^^SJP^^S^Vs^SJr*^?^)^;y^^^Jm^^^^^^^^^^^^^'
379
mi

380
Object-Oriented Programming
Histogram
Data-typeinstance variables can be arrays. As an illustration, con
sider Histogram (Program 3.2.3), which maintains an array of the frequency of
occurrence of integer values in a given interval [0, N) and uses StdStats. plot-
Bars () to display a histogram of the values,controlled by this API:
public class Histogram
Histog ram(i nt N)
create a dynamic histogram for theN int values in [0y N)
double
addDataPoint(int i)
addan occurrence of thevalue i
voi d
draw()
draw thehistogram usingstandard draw
APIforhistograms {see Program 3.2.3)
Bycreatinga simpleclass such as Hi stogram, wereap the benefitsof modular pro
gramming (reusable code, independent development of small programs, and so
forth) that we discussed in Chapter 2,with the additional benefit that we also sepa
rate the data. A histogram client need not maintain the data (or know anything
about its representation); it just creates a histogram and calls addDataPoi nt().
When studying this code and the next severalexamples, it is best to carefully
consider the client code. Each classthat we implement essentially extends the Java
language, allowing us to declare variables of the new data type, instantiate them
with values,and perform operations on them. Allclient programs are conceptually
the same as the first programs that you learned that use primitive types and built-
in operations. Now you have the ability to define whatever types and operations
you need in your client code!In this case,using Hi stog ram actually enhances read
abilityof the client code,as the addDataPoint () callfocuses attention on the data
being studied.Without Hi stog ram, wewould haveto mix the code for creatingthe
histogram with the code for the computation of interest, resulting in a program
much more difficult to understand and maintain than the two separate programs.
Whenever you canclearly separate dataand associated operations within a program,
you shoulddoso.
Once you understand how a data type will be used in client code, you can
consider the implementation. An implementation is characterized by its instance
variables (data type values). Hi stog ram maintains an array with the frequency of
each point and a doubl e value max that stores the height ofthe tallest bar (for scal
ing). Its private drawQ method scalesthe drawing and then plots the frequencies.

3.2 Creating Data Types
381
m^^^s^^^M^^^^sm^^m^^^mmmm
Program 3.2.3
Histogram
public class Histogram
private final doubled freq;
freq[]
private double max;
max
public Histogram(int N)
{
// Create a new histogram.
freq = new double[N];
}
public void addDataPoint(int i)
{
// Add one occurrence of the value i.
freq[i]++;
if (freq[i]
> max) max = freq[i];
}
public void draw()
{
// Draw (and scale) the histogram.
StdDraw.setYscale(0,
max);
StdStats.piotBars(freq);
}
public static void main(String[] args)
{
// See Program 2.2.6.
int N = Integer.parselnt(args[0]) ;
">^^^^^^^^^^^^
int T = Integer.parselnt(args[1]);
Histogram histogram = new Histogram(N+l);
for (int t = 0; t < T; t++)
hi stogram.addDataPoi nt(Bernoul1i.bi nomi al(N));
StdDraw.setCanvasSize(500, 100);
histogram.draw();
}
frequency counts
maximumfrequency
mm^m.
% java Histogram 50 1000000
This data type supports simple client code to create dynamic histograms of thefrequency of
occurrence of values in [0, N). Thefrequencies are kept in an instance-variable array andan
instance variable max tracks the maximum frequency (forscaling). To make a dynamically
changing histogram, adda calltoStdDraw.cl ear() before anda callto StdDraw.show(20)
after thecallto hi stogram. drawQ in theclientcode..

382
Object-Oriented Programming
Turtle graphics
Whenever you can clearly separate tasks within aprogram, you
should do so. In object-oriented programming, we extend that mantra to include
state with the tasks.Asmall amount of state can be immensely valuablein simplify
ing a computation. Next, we consider turtle graphics, which is based on the data
type defined by this API:
public class Turtle
-i-.ui^jlt
rtJUT
rt-ii-n
^
create a new turtle at (xn, yn)facing an
Turtle(double xO, double yO, double aO)
,
,
,
•
/
,
.
degreescounterclockwisefrom the x-axis
void
turnLeft(double delta)
rotate delta degrees counterclockwise
voi d
goForward(doubl e step)
move distance step, drawing a line
APIfor turtle graphics (seeProgram 3.2.4)
Imagine a turtle that lives in the unit square and draws lines as it moves. It can
move a specifieddistance in a straight line, or it can rotate left (counterclockwise)
a specified number of degrees. According to
the API, when we create a turtle, we place it at
a specified point, facing a specified direction.
Then, we create drawings by givingthe turtle a
sequence of goForwardO and turnLeft()
commands.
For example, to draw a triangle we create
a Turtl e at (0, .5) facing at an angle of 60 de
grees counterclockwise from the origin, then
direct it to take a step forward,then rotate 120
degrees counterclockwise, then take another
step forward, then rotate another 120 degrees
counterclockwise, and then take a third step
forward to complete the triangle. Indeed, allof
the turtle clients that we will examine simply
create a turtle, then giveit an alternating series
of step and rotate commands, varying the step
size and the amount of rotation. As you will
seein the next severalpages,this simple model
double
xO
= 0.5;
double yO = 0.0;
double
aO
= 60.0;
double step = Math sqrt(3)/2;
Turtle
t
=
new Turtle(x0,
yo,
t.goForward(step);
(x0,y0)
aO);
A turtle'sfirststep

(*n
3.2 Creating Data Types
allows us to create arbitrarily complex drawings, with many im
portant applications.
Turtle (Program 3.2.4) is an implementation of this API
that uses StdDraw. It maintains three instance variables: the co
ordinates of the turtle's position and the current direction it is
facing, measured in degrees counterclockwise from the x-axis.
Implementing the two methods requires updating the values
of these variables, so they are not
final. The necessary updates are
straightforward:
tu rnLeft (del ta)
adds delta to the current angle, and
goForward(step) adds the step size
times the cosine of its argument to the
current x-coordinate and the step size
times the sine of its argument to the
current y-coordinate.
The test client in Turt1e takes an
integer Nas command-line argument
and draws a regular polygon with Nsides. If you are interested
in elementary analytic geometry,you might enjoyverifying that
fact.Whether or not you choose to do so, think about what you
would need to do to compute the coordinates of allthe points in
the polygon. The simplicity of the turtle's approach is very ap
pealing. In short, turtle graphics servesasa usefulabstraction for
describing geometric shapes of allsorts. For example, we obtain
a good approximation to a circle by taking N to a sufficiently
large value.
Youcan use a Turt1e asyou use any other object. Programs
can create arrays of Turtle objects, pass them as arguments to
functions, and so forth. Our examples will illustrate these capa
bilities and convinceyou that creatinga data type likeTurtl e is
both very easy and very useful. For each of them, as with regu
lar polygons, it is possible to compute the coordinates of all the
points and draw straight lines to get the drawings,but it is easier
to do so with a Turtle. Turtle graphics exemplifies the value of
data abstraction.
(x0 + dcosa, y0 +dsin a)
dsina
Turtle trigonometry
t.goForward(step);
t.goForward(step);
t.goForward(step);
Yourfirst turtle
graphics drawing
383

384
Object-Oriented Programming
Program 3.2A
Turtle graphics
m
W.
si
«5*
Si
X-.':,
1
public class Turtle
{
private double x,
y;
private double angle;
public Turtle(double xO, double yO,
double aO)
{
x = xO; y = yO; angle = aO;
}
public void turnLeft(double delta)
{
angle += delta;
}
public void goForward(double step)
{
// Compute new position, move and draw line to it.
double oldx = x, oldy = y;
x += step * Math.cos(Math.toRadians(angle));
y += step * Math.sin(Math.toRadians(angle));
StdDraw.line(oldx, oldy, x, y);
}
public static void main(String[] args)
{
// Draw an N-gon.
int N = Integer.parselnt(args[0]);
double angle = 360.0 /
N;
double step = Math.sin(Math.toRadians(angle/2));
Turtle turtle = new Turtle(.5,
.0, angle/2);
for (int i
= 0;
i
< N; i++)
{
turtle.goForward(step);
turtle.turnLeft(angle);
}
}
x,
y
angle
position (in unit square)
direction of motion (degrees,
counterclockwisefromx axis)
1ft
m
ftp
&#3
"if"
?&•:>•
m
This datatype supports turtle graphics, which often simplifies thecreation ofdrawings.

3.2 Creating Data Types
385
Recursive graphics. A Koch curve of order 0 is a straight line. To form a Koch
curve of order n, draw a Koch curve of order n-1, turn left 60 degrees, draw a
second Kochcurve of order n-1, turn right 120degrees (left-120 degrees),draw a
third Kochcurve of order n-1, turn left60 degrees, and draw a fourth Kochcurve
of order n-1. These recursive instructions lead immediately to turtle client code.
With appropriate modifications, recursive schemes likethis have proven usefulin
modeling self-similarpatterns found in nature, such assnowflakes.
The client code below is straightforward,exceptfor the value of the step size
sz. If you carefully examine the first few examples, you will see (and be able to
prove by induction) that the width of the curveof order n is 3"times the step size,
sosettingthe stepsize to 1/3"produces a curveofwidth 1.Similarly, the number of
stepsin a curveof order nis 4M, so Koch willnot finish ifyou invoke it for largen.
You can find many examples of recursive patterns of this sort that havebeen
studied and developed by mathematicians,scientists, and artists from many cul
tures in many contexts. Here, our interest in them is that the turtle graphics ab
straction greatlysimplifies client codethat drawsthem.
public class Koch
0
{
public static void koch(int n, double step, Turtle turtle)
{
if (n == 0)
{
1
turtle.goForward(step);
A
return;
/ \
koch(n-l, step, turtle);
0
turtle.turnLeft(60.0);
koch(n-l, step, turtle);
r^y
turtle. turnl_eft(-120.0);
—/w
V^\_
koch(n-l,
step, turtle);
turtle.turnLeft(60.0);
3
koch(n-l, step, turtle);
.a/^Ls
}
^iJIjV
public static void main(String[] args)
t
4
int n = Integer, parselnt(args [0]);
«*•***•*»
double step = 1.0 / Math.pow(3.0,
n);
**t r
S
s*t
Turtle turtle = new Turtle(0.0, 0.0, 0.0);
*" w
w
**"
koch(n,
step,
turtle);
}
Drawing Koch curves withturtle graphics

386
Object-Oriented Programming
Spira mirabilis. Perhaps theturtleisabittiredafter taking 4"steps to drawaKoch
curve.Accordingly, imaginethat the turtle's step sizedecays by a tiny constant fac
tor eachtimethat it takesa step. Whathappensto our drawings? Remarkably, mod
ifying the polygon-drawing test client in Program 3.2.4 to answer this question
leadsto an imageknownasa logarithmic spiral, a curvethat isfound in manycon
texts in nature.
Spi ral (Program 3.2.5) is an implementation of this curve. It takes Nand the
decayfactorascommand-lineargumentsand instructs the turtle to alternatelystep
and turn until it has wound around itself 10 times. As you can see from the four
examples given with the program,the path spirals into the center of the drawing.
The argument Ncontrolsthe shapeof the spiral.You are encouragedto experiment
with Spi ral yourselfin order to develop an understanding of the wayin which the
parameters control the behavior of the spiral.
The logarithmic spiral was first described by Rene Descartes in 1638.Jacob
Bernoulliwasso amazedby its mathematicalproperties that he named it the spira
mirabilis (miraculous spiral) and evenaskedto haveit engraved on his tombstone.
Many people also consider it to be "miraculous" that this precise curve is clearly
present in a broad variety of natural phenomena. Three examples are depicted be
low: the chambers of a nautilus shell, the arms of a spiral galaxy, and the cloud
formation in a tropical storm. Scientists havealso observed it as the path followed
bya hawkapproachingitspreyand the path followed bya chargedparticlemoving
perpendicular to a uniform magnetic field.
One of the goalsof scientificenquiry isto provide simple but accurate models
of complex natural phenomena. Our tired turtle certainly passesthat test!
nautilus shell
galaxy
storm
Examples ofthespira mirabilis in nature

3.2 Creating Data Types
387
••¥J:
SI
m
Program 3.2.5
Spiramirabilis
public class Spiral
{
public static void main(String[] args)
{
int N
= Integer.parselnt(args[0]);
double decay
= Double.parseDouble(args[l]);
double angle
= 360.0 /
N;
double step
= Math.sin(Math.toRadians(angle/2));
Turtle turtle = new Turtle(0.5, 0, angle/2);
for (int i
= 0;
i
< 10 * 360 /
angle;
i++)
{
step /= decay;
turtle.goForward(step);
turtle.turnLeft(angle);
}
This code isa modification ofthe test client inProgram 3.2.4 that decreases the step size ateach
step andcycles around 10times. The angle controls the shape; the decay controls the nature of
thespiral.
% java Spiral
3 1.0
java Spiral
3 1.2
'^HSW^^K^SS^S?i^^^^^^^^SIS^P

388
Object-Oriented Programming
Brownian motion. Or, perhaps the turtle has had one too many. Accordingly,
imagine that the disoriented turtle (again following its standard alternating turn
and stepregimen) turns in a random direction before eachstep. Again, it is easy to
plot the path followed by such a turtle for millions of steps, and again, such paths
arefound in nature in many contexts. In 1827, the botanist Robert Brownobserved
through a microscope that pollengrainsimmersedin waterseemedto moveabout
in just such a random fashion, which later became known as Brownian motion and
led to Albert Einstein's insightsinto the atomic nature of matter.
Or perhapsour turtle hasfriends, allof whom have had one too many. After
theyhave wandered aroundfora sufficiently longtime, theirpathsmerge together
and become indistinguishable from a single path.Astrophysicists todayare using
this model to understand observed propertiesof distant galaxies.
Turtle graphics was originally developed by Seymour Papert at MIT in the 1960s
as part of an educational programming language, Logo, that is stillusedtodayin
toys. But turtle graphics is no toy, as we havejust seen in numerous scientific ex
amples. Turtlegraphics also has numerouscommercial applications. For example,
it is the basis for PostScript, a programming languagefor creating printed pages
that is used for most newspapers, magazines, and books. In the present context,
Turtle is a quintessential object-oriented programming example,showing that a
smallamount of saved state (data abstractionusingobjects,not just functions) can
vastly simplify a computation.
10000 .01
public class DrunkenTurtle
{
public static void main(String[] args)
{
int T = Integer.parselnt(args[0]);
double step = Double.parseDouble(args[l]);
Turtle turtle = new Turtle(0.5, 0.5, 0.0);
for (int t
= 0;
t
< T; t++)
{
turtle.turnLeft(360.0 * Math.random());
turtle.goForward(step);
}
}
}
Brownian motion ofa drunken turtle (moving afixeddistance in a random direction)

3.2 Creating Data Types
public class DrunkenTurtles
{
public static void main(String[] args)
{
int N = Integer.parselnt(args[0]);
int T = Integer.parselnt(args[l]);
double step = Double.parseDouble(args[2]);
Turtle[] turtles = new Turtle[N];
for (int i
= 0;
i
< N; i++)
turtles[i] = new Turtle(Math.random(), Math.random(),
for (int t
= 0;
t
< T;
t++)
{
//All turtles take one step.
for (int i
= 0;
i
< N; i++)
{
// Turtle i takes one step in a random direction.
turtles[i] .turnl_eft(360.0 * Math, random()) ;
tu rtles[i].goForward(step);
}
}
}
20 500
.005
20 5000
.005
?
£r *|
20 1000
.005
// number of turtles
// number of steps
// step size
0.0);
Brownian motion ofa bale ofdrunken turtles
389

390
Object-Oriented Programming
Complexnumbers
Acomplex number is anumber ofthe form x+iy, where x
and y are realnumbers and i is the squareroot of -1. The number x is known as
thereal partofthecomplex number, andthenumber yisknown as theimaginary
part.This terminology stems from theidea that thesquare root of -1 hasto bean
imaginary number, because no real number canhave thisvalue. Complex numbers
are a quintessential mathematical abstraction: whether or not one believes that it
makes sense physically to take the square root of -1, complex numbers help us
understand the natural world. They are used extensively in applied mathematics
andplay an essential role in many branches of science and engineering. They are
used to model physical systems of allsorts,from circuitsto sound waves to electro
magnetic fields. These models typically require extensive computations involving
manipulating complex numbers according to well-defined arithmetic operations,
so wewant to write computer programsto do the computations. In short, we need
a new data type.
Developing a data type for complex numbers is a prototypical example of
object-oriented programming. No programming language canprovide implemen
tations of every mathematical abstraction that we might need, but the ability to
implement datatypes give usnotjusttheabilityto write programs to easily manip
ulate abstractions such as complex numbers, polynomials, vectors, matrices, but
also the freedom to thinkin terms of new abstractions.
Theoperations on complex numbers that areneeded forbasic computations
are to add and multiply them by applying the commutative,associative, and dis
tributive laws of algebra (along with theidentity i2 = -1); to compute themagni
tude; andto extract thereal andimaginary parts, according to thefollowing equa
tions:
•Addition: (x+iy) + (v+iw) = (x+v) + i(y+w)
•Multiplication: (x+ iy) * jv+ iw) = (xv-yw) + i(yv + xw)
•Magnitude: \x + iy\= Jx2 +y2
• Realpart Re(x + iy)=x
• Imaginarypart Im(x +iy)=y
Forexample, if a = 3 + 4iand b=-2 + 3i,then a +b= 1+ li, a *b = -18 + i,Re(a)
= 3,Im(a) = 4,and \a\ = 5.
With these basic definitions, thepathto implementing a datatypefor com
plex numbers is clear. As usual, we startwith an API that specifies the data-type
operations:

3.2 Creating Data Types
public class Complex
Complex(double real, double imag)
Complex
pi us(Complex b)
Complex times(Complex b)
double
abs()
double
re()
double
im()
String
toString()
sumofthis number and b
product ofthis number and b
magnitude
realpart
imaginarypart
stringrepresentation
APIforcomplex numbers (see Program 3.2.6)
For simplicity, we concentrate in the text on just the basicoperations in this API,
but Exercise 3.2.19asksyou to considerseveral other usefuloperations that might
be included in such an API.
Compl ex (Program 3.2.2) is a class that implements this API. It has all of the
same components as did Charge (and everyJava data type implementation): in
stance variables (re and im), a constructor, instance methods (plus(), times(),
abs (), re (), i m(), and toStri ng()), and a test client.The test client first sets z0 to
1 + i,then setsz to z0, and then evaluates:
Z= Z2 + Zq = (i + i)2 + (i + {) = (! + 2i -1) + (1 + i) = 1 + 3*
z = z2 + Zq = (! + 3Q2 + (l + i) = (1 + 6i -9) + (1 + i) = -7 + li
This code is straightforwardand similarto codethat you have seen earlierin this
chapter, with one exception: the code that implements the arithmetic methods
makes use of a new mechanism for accessing object values.
Accessing instance variables in objects of this type. Both plus() and times()
need to access values in two objects: the object passed as an argument and the
object used to invokethe method. If we callthe method with a. pi us(b), we can
access the instance variables of a using the names re and i m, as usual, but to access
the instance variables of of b we use the code b. re and b. i m. Keeping the instance
variables private means that client code cannot access directly instance variables in
another class (but code in the same class can access any object's instance variables
directly).
391

392
Object-Oriented Programming
Chaining. Observe the manner in which main() chains two method calls into
one compact expression: the expression z. ti mes (z). pi us (zO) evaluates to z2 +
zQ. This usage is convenient because we do not have to invent a variable name for
the intermediate value. If you study the expression, you can see that there is no
ambiguity: moving fromleftto right,each methodreturnsareference to a Compl ex
object, which is used to invoke thenext method. If desired, we canuse parenthe
sesto override the default precedence order (for example, z. ti mes (z. pius(zO))
evaluates to z{z+ z0)).
Creating and returning new objects. Observe themanner in which pius() and
timesO providereturn values to clients: they need to return a Complex value, so
theyeachcompute the requisite real andimaginary parts,usethem to create a new
object, andthen return a reference to that object. Thisarrangement allow clients to
manipulate complex numbers bymanipulating local variables of typeCompl ex.
Final values. The two instance variables inCompl ex are final,meaning that their
values are setforeach Compl exobject when it iscreated anddo not change during
thelifetime ofan object. Again, we discuss thereasons behind thisdesign decision
in Section 3.3.
Complex numbers are the basis for sophisticated calculations from appliedmath
ematics that have many applications. Some programming languages have complex
numbers builtin asa primitive type, andprovide special language supportforuse
ofoperators such as*and+to perform addition, multiplication, andotheropera
tions, in thesame way asforintegers or floating-point numbers. Java does not sup
port overloadingforbuilt-in operators. Java's support for data typesis much more
general, allowing usto compute withabstractions ofalldescription. Compl exisbut
one example.
To give you a feeling for the natureof calculations involving complex num
bers and the utility of the complexnumber abstraction, we next consider a famous
example of a Compl ex client.

3.2 Creating Data Types
393
l^^^g^^^^^ii^^^Mi^ilig^iiiiliil
Program 3.2.6
Complex numbers
public class Complex
{
private final double re;
private final double im;
public Complex(double real, double imag)
{
re = real;
im = imag;
}
public Complex pi us(Complex b)
{
// Return the sum of this number and b.
double real
= re + b.re;
double imag = im + b.im;
return new Complex(real, imag);
}
public Complex times(Complex b)
{
// Return the product of this number and b
double real =re*b.re-im*b.im;
double imag = re * b.im
return new Complex(real, imag);
}
public double abs()
{
return Math.sqrt(re*re + im*im);
public double re()
public double im()
{ return
re;
{ return im;
public String toString()
{
return re + " + " + im
public static void main(String[] args)
{
Complex zO = new Complex(1.0,
1.0);
Complex z = zO;
z = z.times(z).plus(zO);
z = z.times(z).plus(zO);
StdOut.println(z);
}
This data type is the basisforwriting Java programs that manipulate complex numbers.

394
Object-Oriented Programming
Mandelbrot set
The Mandelbrot set isa specific setof complex numbers dis
covered by Benoit Mandelbrot. It has manyfascinating properties. It is a fractal
pattern that is related to the Barnsley fern, the Sierpinski triangle, the Brownian
bridge, the Koch curve, the drunken turtle, and other recursive (self-similar) pat
terns and programs that we have seen in this book. Patterns of this kind are found
in natural phenomena ofall sorts, andthese models andprograms arevery impor
tant in modern science.
Thesetofpointsin theMandelbrot setcannotbedescribed bya single math
ematical equation. Instead, it is defined by an algorithm, and therefore a perfect
candidate fora Compl ex client: we studythe setbywritingprograms to plot it.
Therulefordetermining whether a complex numberz0 isin the Mandelbrot
setissimple: Consider thesequence ofcomplex numbers z0, zx, z2,..., zt,..., where
zt+i = (zt¥ + zo- F°r example, this table shows the first few entriesin the sequence
corresponding to z0 =1 + i:
*
zt
(^
W+Zp
0
1 + /
1+ 2/+
/2 =
2/
2/+(l + /) =
1+3/
1
1 + 3/
1+ 6i+
9i2 =-8 + 6/
-8 + 6/ + (1 + i) = -7 + li
2
-7 + 7i
49 - 98/ + 49i2 =
—98i
-98* + (1 + i) =
1- 97/
Mandelbrot sequence computation
Now, ifthesequence \zt\ diverges to infinity, thenz0 isnot in theMandelbrot set; if
the sequence isbounded,thenz0is in theMandelbrot set. Formanypoints,the test
is simple; for manyother points,the test requires more computation, as indicated
by the examples in this table:
0 + 0/
2 + 0/
1 + /
-.5 + 0/
.10 -
.64/
0
0 + 0i
2 + 0i
1 +
i
-.5 +
0*
.10- Mi
1
0 + 0/
6 + 0i
l + 3i
-.25 + Oi
-.30- .Hi
2
0 + 0i
36 + Oi
-7 + li
-.44 + Of
-.40- .18i
3
0 + 0i
1446 + Oi
1 -
97*'
-.31 +
Oi
.23- .50*
4
0 + 0i
2090918 + 0/
-
9407 -
193*'
-.40 + Oi
-.09- .87i
in the set?
yes
no
no
yes
yes
Mandelbrot sequenceforseveral startingpoints

3.2 Creating Data Types
.64/
Mandelbrot set
Forbrevity, the numbers in the rightmost
two columns of this table are given to just
two decimal places.In some cases,we can
prove whether numbers are
in the set: for example, 0 +
0/ iscertainlyin the set (since
the magnitude of all the
numbers in its sequence is
0), and 2 + 0/ is certainly not
in the set (since its sequence
dominates the powers of 2,
which diverges). In some
other cases, the growth is
readily apparent: for exam
ple, 1 + / does not seem to be in the set.Other sequences exhibita
periodicbehavior: for example, / maps to —1 + i to —i to —1 + / to
—/.... And some sequences go on for a very long time before the
magnitude of the numbers beginsto getlarge.
To visualize the Mandelbrot set, we sample complex points, just
as we sample real-valued points to plot a real-valued function. Each
complexnumber x+ iy corresponds to a point (x, y) in the plane,
so we can plot the results as follows: for a specified resolution N, we
definea regularly spacedN-by-Npixel gridwithin a specified square
and drawa blackpixelif the correspondingpoint isin the Mandelbrot
set and a white pixel if it is not. This plot is a strangeand wondrous
pattern,with allthe blackdots connected and falling roughly within
the 2-by-2 square centered on the point -1/2 + 0/. Large values of
N will produce higher-resolution images, at the cost of more com
putation. Looking closerreveals self-similarities throughout the plot.
For example, the same bulbous pattern with self-similar appendages
appears all around the contour of the main blackcardioid region, of
sizesthat resemblethe simple ruler function of Program 1.2.1. When
we zoom in near the edge of the cardioid, tiny self-similar cardioids
appear!
But how, precisely, do we produce such plots? Actually, no one
knows for sure, because there is no simple test that would enable us to
395
1015 -.633 1.0
.1015 -.633
Zoomingin on theset

396
Object-Oriented Programming
conclude that a pointissurely in theset. Given a complex point, we cancompute
the terms at the beginning of its sequence, but maynot be able to knowfor sure
thatthesequence remains bounded. There isatestthattells usforsurethatapoint
is not in the set: if the magnitude of anynumber in the sequence evergets to be
greater than 2 (such as2 + Oi), thenthesequence surely will diverge.
Mandelbrot (Program 3.2.7) uses this test to plot a visualrepresentation of
the Mandelbrot set.Since our knowledge of the set is not quite black-and-white,
we use grayscale in our visual representation. It isbased on the function mand () (a
Compl exclient), which takes aCompl exargument zO andan i nt argumentmax and
computes the Mandelbrot iteration sequence startingat zO, returningthe number
of iterations forwhich the magnitude stays less than 2,up to the limitmax.
For each pixel, the method main() in Mandelbrot computes the point zO
corresponding to the pixeland then computes 255 - mand (zO, 255) to create a
grayscale colorforthe pixel. Any pixel that isnot blackcorresponds to a point that
weknowto be not in the Mandelbrot setbecause the magnitude of the numbers
in its sequence grew past 2 (and therefore will go to infinity). The black pixels
(grayscale value 0) correspond to points that we assume to be in the set because
themagnitude stayed less than2for255 iterations, but wedo not necessarily know
for sure.
The complexity of the images that this simpleprogram producesis remark
able, evenwhenwezoomin on a tinyportion of the plane.Forevenmore dramatic
pictures, we can use use color (see Exercise 3.2.34). And the Mandelbrot set is de
rived from iteratingjust one function (z2 + z0): wehave a greatdealto learn from
studying the properties of other functions, as well.
Thesimplicityofthecodemasks asubstantial amountofcomputation. There
are about one-quarter million pixels in a 512-by-512 image, and all of the black
onesrequire255iterations,soproducingan imagewith Mandel brot requireshun
dreds of millions of operations on Compl ex values.
Fascinating as it is to study,our primary interest in Mandel brot is as an ex
ampleclientof Compl ex,to illustrate that computingwith a typeof datathat isnot
built into Java (complex numbers) is a natural and useful programming activity.
Mandel brot isasimple andnaturalexpression ofthe computation, madesobythe
design and implementation of Compl ex.You couldimplement Mandel brot with
out usingCompl ex,but the codewouldessentially have to mergetogetherthe code
in Programs 3.2.6 and 3.2.7 and therefore would be much more difficult to under
stand. Wheneveryou can clearly separate tasks within aprogram, you should do so.

3.2 Creating Data Types
397
msmmmmsmmmmmmm^
Program 3.2.7
Mandelbrot set
import java.awt.Color;
public class Mandelbrot
{
private static int mand(Complex zO,
int max)
{
Complex z = zO;
for (int t = 0; t < max; t++)
{
if (z.absO > 2.0) return t;
z = z.times(z).plus(zO);
}
return
max;
}
public static void main(String[] args)
{
double xc
= Double.parseDouble(args[0]);
double yc
= Double.parseDouble(args[l]);
double size = Double.parseDouble(args[2]);
int N = 512;
Picture pic = new Picture(N,
N);
for (int i
= 0;
i
< N;
i++)
for (int j = 0;
j < N; j++)
{
double xO = xc - size/2 + size*i/N;
double yO = yc - size/2 + size*j/N;
Complex zO = new Complex(xO,
yO);
int t
= 512 - mand(z0,
512);
Color c = new Color(t, t, t);
pic.set(i, N-l-j, c);
}
pic.showQ;
}
m
xO,
yO
point in square
zO
x0+ iy0
max
iteration limit
xc,
yc
center ofsquare
size
squareissize-by-size
N
gridisN-by-N pixels
pic
imagefor output
c
pixelcolorfor output
^"^^^^^^^^^yw^^^^^mm^^^i-
-.5
0
2
-.1015 -.633
.01
PPP
This program takes three command-line arguments thatspecify the center andsizeofa square
region ofinterest, andmakes a digital image showing the result ofsampling theMandelbrot set
in thatregion at a 512*512 gridof equally spaced pixels. It colors each pixel witha grayscale
value thatis determined bycounting the number ofiterations before theMandelbrot sequence
for thecorresponding complex number grows past2.0, up to255.
m
&
i"

398
Object-Oriented Programming
Commercial data processing
One ofthedriving forces behind thedevelop
ment of object-orientedprogramminghasbeen the need for an extensive amount
of reliable software for commercial dataprocessing. As an illustration,weconsider
nextan example of a data typethat mightbe usedbya financial institution to keep
track of customer information.
Suppose that a stock broker needs to maintain customer accounts contain
ing shares of various stocks. That is,the set of values the broker needs to process
includes the customer's name, numbers of different stocks held, amount of shares
and tickersymbolsfor each,and perhapsthe total valueof the stocksin the account.
Toprocessan account, the broker needsat leastthe operations defined in this API:
public class StockAccount
StockAccount(In in)
create a newaccountfrom
information in inputstream
doubl e
val ue()
total value in dollars
void
buy (int amount, String symbol)
addshares ofstock toaccount
doubl e
sel 1(i nt amount, Stri ng symbol)
subtract shares ofstockfrom account
voi d
wri te (Out out)
save account toan output stream
voi d
pri ntReport()
printa detailed report ofstocks andvalues
APIforprocessing stock accounts {see Program 3.2.8)
Thebroker certainlyneedsto buy,sell, and providereports to the customer,but the
firstkeyto understanding this kind of data processing is to considerthe StockAc
count () constructor and the wri te() method in this API. The customer informa
tion has a long lifetime and needs to be saved in afile or database. To process an
account, a clientprogram needs to read information from the correspondingfile;
process the information as appropriate; and, if the information changes, write it
backto the file, saving it for later. To enable this kind of processing, weneed afile
formatand an internal representation, or a datastructure, for the account informa
tion.Thesituationisanalogous to whatwesawfor matrix processing in Chapter 1,
wherewedefined a file format (numbersof rows and columnsfollowed by entries
in row-majororder) and an internalrepresentation (Java two-dimensional arrays)
to enable usto writeprograms forthe random surferand other applications.

3.2 Creating Data Types
Asa (whimsical) running example,we imagine that a broker is maintaining a
small portfolio of stock in leading softwarecompaniesfor Alan Turing, the father
of computing. Asan aside: Turing'slifestory is a fascinating one that is worth pur
suing.Among many other things,he workedon computationalcryptography that
helpedto bring about the end of the Second World War, he developed the basisfor
modern theoretical computer science, he designedand built one of the first com
puters, and he was a pioneer in artificial intelligence research. It is perhaps safeto
assume that Turing, whatever his financial situation as an academic researcher in
the middle of the last century,would be sufficiently optimistic about the potential
impact of computing software in today's world that he would make some small
investments.
399
Fileformat. Modernsystems normally usetextfiles, even fordata,
to minimize dependence on formats defined by any one program.
For simplicity, we use a direct representation wherewe list the ac
count holder's name (a string), cashbalance (a floating-point num
ber), and number of stocks held (an integer), followedby a line for
each stock giving the number of shares and the ticker symbol. It is
alsowise to use tags such as <Name> and <Number of shares>and
so forth to label all the information, to further minimize depen
dencies on any one program, but we omit tags here for brevity.
% more Turing,.txt
Turing,
Alan
10.24
5
100 ADBE
25 G00G
97
IBM
250
MSFT
200 YH00
Fileformat
Data structure. Torepresent information for processingby Javaprograms, we use
object instance variables. They specify the type of infer-
mation and provide the structure that we need in order
to clearly refer to it in code. For our example, we clearly
need the following:
• A Stri ng value for the account name
• A doubl e value for the cash balance
• An i nt value for the number of stocks
• An array of Stri ng values for stock symbols
• An array of i nt values for numbers of shares
We directly reflect these choices in the instance variable
declarations in StockAccount (Program 3.2.8). The
arrays stocks [] and shares [] are known as parallel arrays. Given an index i,
stocks [i ] gives a stock symbol and shares [i ] give the number of shares of that
public class StockAccount
{
private final
String name;
private double cash;
private int N;
private int[] shares;
private String[]
stocks;
}
Data structure blueprint

400
Object-Oriented Programming
stock in the account.An alternative designwould be to define a separate data type
for stocks to manipulate this information for eachstock and maintain an array of
objects of that type in StockAccount.
StockAccount includes a constructor, which reads a file and builds an account
with this internal representation, and the method implementation for value(),
which uses StockQuote (Program 3.1.10) to get each stock's price from the web.
For example,our broker needs to provide a periodic detailed report to customers,
perhaps using the following code for pri ntReport () in StockAccount:
public void printReport()
{
StdOut.printfC'XsXn", name);
StdOut.printf("
Cash:
$%9.2f\n",
cash);
double total = cash;
for (int i = 0;
i < N;
i++)
{
int amount = shares[i];
double p = StockQuote.price(stocks[i]);
StdOut.printf("%4d
%4s ", amount, stocks[i]);
StdOut.printf("
$%6.2f
$%9.2f\n", p, amount * p);
total += amount * p;
}
StdOut.printf("
Total: $%9.2f\n", total);
}
On the one hand, this client illustrates the kind of computing that was one of the
primary drivers in the evolution of computing in the 1950s.Banks and other com
panies bought early computers preciselybecause of the need to do such financial
reporting. For example,formatted printing wasdevelopedpreciselyfor such appli
cations.On the other hand, this clientexemplifies modern web-centric computing,
as it getsinformation directlyfrom the web,without using a browser.
The implementations of buy() and sell () require the use of basic mecha
nisms introduced in Section 4.4, so we defer them to that section. Beyond these
basic methods, an actual application of these ideas would likely use a number of
other clients.For example, a broker might want to build an array of all accounts,
then process a list of transactions that both modify the information in those ac
counts and actually carry out the transactions through the web. Of course, such
code needs to be developed with great care!

3.2 Creating Data Types
401
iiikSiiSSii^^
\
m
ii
Program 3.2.8
Stock account
public class StockAccount
{
private final String name;
private double cash;
private int N;
private int[] shares;
private String[] stocks;
public StockAccount(In in)
{
// Build data structure from input stream,
name = in.readl_ine();
cash = in.readDouble();
N = in.readlntO;
shares = new int[N];
stocks = new String[N];
for (int i
= 0;
i
< N; i++)
{
// Process one stock.
shares [i]
= in.readlntO;
stocks[i] = in.readStringO ;
}
}
}
public void printReport()
{
/* See text. */
}
public static void main(String[]
args)
{
In in = new In(args[0]);
StockAccount acct = new StockAccount(in);
acct.pri ntReport();
}
name
customer name
cash
cash balance
N
number ofstock
shares []
share counts
stocks []
stock symbols
in
input stream
This class for processing stock accounts illustrates typical usage of object-oriented program
mingforcommercial dataprocessing.
% more Turing.txt
Turing, Alan
10.24
5
100 ADBE
25
G00G
97
IBM
250 MSFT
200 YH00
IW^SfP
rf-™*- .^e„*i- xA~*~b.,w.*,.**....™**J1**,^i^™^•;",".•
'>,'..',
java StockAccount Turing.txt
Turing, Alan
100
25
97
250
200
ADBE
G00G
IBM
MSFT
YH00
Cash:
$
10.24
$ 42.23
$473.25
$104.40
$ 30.25
$ 28.39
Total:
$
4222.91
$ 11831.25
$ 10126.80
$
7562.50
$
5678.00
$ 39431.70
I
S!^^^^^^^^^^^^^fe^^S^^RfflS^W^^fe^^^fe^^?^fw^

402
Object-Oriented Programming
When you learned how to define functions that can be used in multiple places in
a program (or in other programs) in Chapter 2, you moved from a world where
programs are simplylistsof statements in a singlefileto the world of modular pro
gramming, summarized in our mantra: whenever you canclearly separate subtasks
within aprogram, youshould doso.Theanalogouscapabilityfor data, introduced in
this chapter, moves you from aworldwheredata has to be one of a fewelementary
types of data to a world whereyou can define your own types of data. This pro
found new capabilityvastly extends the scopeof your programming.Aswith the
conceptof a function,onceyouhavelearnedto implement and usedata types,you
willmarvel at the primitive nature of programs that do not use them.
But object-oriented programming ismuch more than structuring data. It en
ablesus to associatethe data relevantto a subtaskwith the operations that manipu
late that data and to keep both separate in an independent module. With object-
oriented programming,our mantra is this: whenever youcan clearly separate data
andassociated operationsforsubtasks within a computation, youshould doso.
The examples that we have considered are persuasive evidence that object-
oriented programming can playa usefulrolein a broad range of activities. Whether
we are trying to design and build a physical artifact, develop a software system,
understand the natural world,or process information, a keyfirst step is to define
an appropriate abstraction, such as a geometric description of the physical arti
fact,a modular designof the software system, a mathematical model of the natural
world, or a data structure for the information. When wewant to write programs to
manipulate instances of a well-defined abstraction, we can just implement it as a
data type in a Java class and write Java programs to createand manipulate objects
of that type.
Eachtime that we develop a class that makesuse of other classes by creating
and manipulating objectsof the typedefinedbythe class, weare programming at a
higher layerof abstraction.In the nextsection,wediscuss some of the designchal
lengesinherent in this kind of programming.

3.2 Creating Data Types
Q. Do instance variables have initial valuesthat we can depend upon?
A Yes. They are automatically set to 0 for numeric types, f al se for the bool ean
type, and the specialvalue null for all referencetypes. These values are consistent
with the wayarray entries are initialized. This automatic initialization ensures that
everyinstance variable always stores a legal(but not necessarily meaningful) value.
Writing code that depends on these valuesis controversial: some experienced pro
grammers embrace the idea becausethe resultingcode can be verycompact; others
avoid it because the code is opaque to someone who does not know the rules.
Q. What is null?
A It is a literal value that refers to no object. Invoking a method using the null
reference is meaningless and results in a NullPointerException. If you get this
error message,check to make sure that your constructor properly initializes all of
its instance variables.
Q. Can we initialize instance variablesto other valueswhen declaring them?
A. Yes, you can initialize instance variablesusing the same conventions asyou have
been using for initializing local variables. Each time a client creates an object with
new, Java initializes its instance variables with those values, and then calls the con
structor.
Q. Must every classhave a constructor?
A. Yes, but if you do not specifya constructor, Java provides a default (no-argu
ment) constructor automatically. When the client invokes that constructor with
new, the instance variables are auto-initialized as usual. If you dospecifya construc
tor, the default no-argument constructor disappears.
Q. Suppose I do not include a toStri ng() method. What happens if I try to print
an object of that type with StdOut. pri ntl n()?
A. The printed output is an integer that is unlikelyto be of much use to you.
Q. Can I have a static method in a classthat implements a data type?

Object-Oriented Programming
A. Of course. For example, all of our classes have mai n() . But it is easy to get
confused when static methods and instance methods are mixed up in the same
code.Forexample, it isnatural to considerusingstaticmethods for operations that
involve multiple objects where none of them naturally suggests itself as the one
that should invoke the method.Forexample, wesayz. abs() to get \z\, but saying
a. pi us(b) to get the sum is perhaps not so natural. Why not b. pi us (a)?An alter
nativeis to definea static method likethe following within Compl ex:
public static Complex pi us(Complex a, Complex b)
{
return new Complex(a.re + b.re, a.im + b.im);
}
Wegenerallyavoid such usageand livewith expressions that do not mix static and
instance methods to avoid having to write code like this:
z = Complex.pi us(Complex.times(z, z),
zO)
Instead, we would write:
z = z.times(z).plus(zO)
Q. These computations with plus() and times() seem rather clumsy. Is there
some wayto use symbols like + and * in expressionsinvolving objects where they
make sense,like Compl ex and Vector, so that we could write expressionslike z =
z
*
z
+ zO instead?
A. Some languages (notably C++) support this feature, which is known
as operator overloading, but Java does not do so (except that there is lan
guage support for overloading + with string concatenation). As usual, this
is a decision of the language designers that we just live with, but many
Javaprogrammers do not consider this to be much of a loss. Operator overloading
makessenseonlyfor typesthat representnumeric or algebraicabstractions, a small
fraction of the total, and many programs are easierto understand when operations
havedescriptive names such as pi us and times. The APL programming language
of the 1970s took this issue to the opposite extreme by insisting that every opera
tion be represented by a singlesymbol (including Greekletters).

3.2 Creating Data Types
Q. Are there other kinds of variables besides argument, local, and instancevari
ables in a class?
A If you include the keyword stati c in a variable declaration (outside of any
method), it creates a completely different type of variable, known as a static vari
able or class variable. Like instance variables, static variables areaccessible to every
methodin the class; however, theyarenot associated withanyobject—there isone
variable per class. In older programminglanguages, such variables are known as
global variables because of their global scope. In modernprogramming, we focus
on limiting scopeand thereforerarelyusesuchvariables.
Q. Mandelbrot creates hundreds of millions of Complex objects. Doesn't allthat
object-creationoverheadslowthingsdown?
A. Yes, butnotsomuch thatwe cannot generate ourplots. Ourgoal istomake our
programs readable and easy to maintain—limiting scope viathe complex number
abstraction helps usachieve thatgoal. You certainly could speed up Mandel brot by
bypassing the complex numberabstraction orbyusing a different implementation
of Complex. We will revisit this issue in the next section.
405

406
Object-Oriented Programming
3.2.1
Consider the following data-type implementation for (axis-aligned) rect
angles, which represents each rectangle withthecoordinates ofitscenter pointand
its width and height:
public class Rectangle
{
private final double x
private final double y;
private final double width
private final double height;
public Rectangle(double xO, double yO, double w, double h)
{
x = xO;
y = yO;
width = w;
height = h;
}
public double area()
{
return width * height;
}
}
public double perimeter()
{
/* Compute perimeter. */
}
public boolean intersects(Rectangle b)
{
/* Does this rectangle intersect b? */
}
public boolean contains(Rectangle b)
{
/* Is b inside this rectangle? */
}
public void show(Rectangle b)
{
/* Draw rectangle on StdDraw.
*/
}
representation
height
(x,y)
width
a
b
m
Write an API for this class, and fill in the code for perimeter(), intersects(),
and contai ns(). Note:Treatcoincident lines as intersecting, so that, for example,
a. intersects (a) is true and a. contains (a) is false.
3.2.2
Write a test client for Rectangl e that takes three command-line arguments
N, mi n, and max; generates Nrandom rectangles whose width and height are uni-

3.2 Creating Data Types
formly distributed between mi n and max in the unit square; draws them on Std
Draw; and prints their average area and average perimeterto standard output.
3.2.3
Add code to your test client from the previous exercise code to compute
the average number of pairs of rectangles that intersect and are contained in one
another.
3.2.4
Develop an implementation of your Rectangle API from Exercise 3.2.1
that representsrectangles with the coordinates of their lowerleft and upper right
corners. Do notchange the API.
3.2.5
What iswrong with the following code?
public class Charge
{
private double rx,
ry;
// position
private double q;
// charge
public Charge(double xO, double yO, double qO)
{
double rx = xO;
double ry = yO;
double q = qO;
}
}
Answer.
The assignment statements in the constructor are also declarations that
create new localvariables rx, ry, and q, which are assigned values from the argu
ments but are never used. The instance variables rx, ry, and q remain at their de
fault value of 0. Note: A local variable with the same name as an instance variable is
said to shadow the instance variable—we discuss in the next section a wayto refer
to shadowedinstancevariables, whicharebestavoided bybeginners.
3.2.6
Createa data type Locati on that representsa location on Earth using lati
tudes and longitudes. Include a method distanceToO that computes distances
using the great-circle distance (see Exercise1.2.33).
407

Object-Oriented Programming
3.2.7
Implement adatatype Rational forrational numbers thatsupports addi
tion, subtraction, multiplication, and division.
public class Rational
Rational(int numerator, int denominator)
Rational
plus(Rational b)
sum ofthis number and b
Rational
minus(Rati onal b)
difference ofthisnumber and b
Rational
times (Rati onal b)
product ofthisnumber and b
Rati onal
over(Rati onal b)
quotient ofthis number andb
St ri ng toSt ri ng()
string representation
Use Eucli d. gcd() (Program 2.3.1) to ensure that the numerator and denomina
tor never have anycommon factors. Include a test client that exercises allof your
methods. Do not worryabouttesting foroverflow (see Exercise 3.3.24).
3.2.8
Writea data type Interval that implements the following API:
public class Interval
Interval(double left, double right)
bool ean
contai ns (doubl e x)
isx in this interval?
boolean
intersects(Interval b)
does this interval and b intersect?
String
toStri ng()
string representation
An intervalis definedto be the setof allpoints on the line greaterthan or equalto
1eft and less than or equalto ri ght. In particular, an intervalwith ri ght less than
1eft is empty. Write a client that is a filter that takes a double value x from the
commandlineand prints allof the intervals on standardinput (each defined bya
pair of doubl e values) that contain x.
3.2.9
Writea clientforyour Interval class from the previousexercise that takes
an i nt value N as command-line argument, reads N intervals (each defined by a

3.2 Creating Data Types
pair of double values)from standard input, and prints allpairs that intersect.
3.2.10 Develop an implementation of your Rectangle API from Exercise 3.2.1
that takesadvantageof Interval to simplify and clarifythe code.
3.2.11 Write a data type Point that implementsthe following API:
public class Point
Point (double x, double y)
doubl e
di stanceTo(Poi nt q)
Euclidean distance between this pointandq
Stri ng
toStri ng()
string representation
3.2.12 Add methods to Stopwatch that allowclientsto stop and restart the stop
watch.
3.2.13 Use a Stopwatch to compare the cost of computing Harmonic numbers
with a for loop (seeProgram 1.3.5) asopposedto usingthe recursive method given
in Section 2.3.
3.2.14 Develop a version of Hi stogram that uses Draw, so that a client can create
multiplehistograms. Addto the display aredvertical lineshowing the samplemean
and blue vertical lines at a distance oftwo standard deviations from the mean. Use a
test client that createshistograms for flippingcoins (Bernoullitrials) with a biased
cointhat is headswith probabilityp, forp = .2,.4,.6.and .8,takingthe number of
flips and the number of trials from the command line, as in Program 3.2.3.
3.2.15 Modifythe test client in Turtl e to produce starswith Npoints for odd N.
3.2.16 Modify the toString() method in Complex (Program 3.2.2) so that it
prints complex numbers in the traditional format. For example,it should print the
value3-ias3 - i instead of 3.0 + -1.0i,thevalue3as3insteadof 3.0 + O.Oi,
and the value 3i as 3i instead of 0.0 + 3. Oi.
409

410
Object-Oriented Programming
3.2.17 Write a Complex client that takes three double values a, b, and c as com
mand-linearguments and prints out the complex roots ofax2 + bx+ c.
3.2.18 Write a Compl ex client Roots that takes two doubl e values a and band an
integer N from the command lineand prints the Nth roots of a + hi.Note: skip
this exercise if you arenot familiar withthe operationof takingroots of complex
numbers.
3.2.19 Implement the following additions to the Compl ex API:
double
thetaO
Complex
minus(Complex b)
Complex
conj ugate()
Complex
divides(Complex b)
Complex
power(int b)
phase (angle) of this number
difference ofthis number andb
conjugate ofthisnumber
result ofdividing this number byb
result ofraising thisnumber to thebthpower
Write a test client that exercises all of your methods.
3.2.20 Suppose you want to add a constructor to Complex that takes a double
value asargument and creates a Compl ex numberwith that value asthe realpart
(and no imaginarypart).You writethe following code:
public void Complex(double real)
{
re = real;
im = 0.0;
}
But then Compl ex c = new Compl ex(1.0) does not compile. Why?
Answer.
Constructors do not have return types, not even voi d. The code above
defines a method named Compl ex, not a constructor. Remove the keyword voi d.
3.2.21 Find a Compl ex valuefor which mand () returns a number greater than 100,
and then zoom in on that value, as in the example in the text.
3.2.22 Implementthe write() methodfor StockAccount (Program3.2.8).

3.2 Creating Data Types
3.2.23 Mutable charges. ModifyChargesothat the chargeqisnot final, and
add a method i ncreaseChargeO that takes a double argument and adds the
givenvalueto the charge.Then, write a clientthat initializes an array with:
Charged
a = new Charge[3];
a[0]
= new Charge(.4,
.6,
50)
a[l] = new Charge(.5,
.5, -5)
a[2] = new Charge(.6,
.6,
50)
and then displays the result of slowlydecreasingthe charge value of a[i ] by
wrapping the code that computes the picture in a loop likethe following:
for (int t
= 0;
t
< 100; t++)
{
// compute the picture
pic.showO;
a[l].change(-2);
}
3.2.24 Complex timing. Writea Stopwatch clientthat compares the cost of
using Complex to the cost of writing code that directlymanipulates two dou
bl e values, for the task of doing the calculations in Mandel brot. Specifically,
createa version of Mandel brot that just doesthe calculations (remove the code
that refersto Pictu re), then createaversionof that program that does not use
Compl ex, and then compute the ratio of the running times.
3.2.25 Quaternions. In 1843, Sir William Hamilton discovered an extension
to complex numbers called quaternions. Aquaternionisavectora = (a0, ax, a2,
a3) with the following operations:
•Magnitude: \a\ = yja02 + ax2 + a22 + a32.
• Conjugate: the conjugateof a is (a0, —av —a2, —a3).
• Inverse: arx = (a0/\a\, —ax/\a\, -a2/\a\, -a3/\a\).
• Sum: a+b = (a0+ b0,ax + bx,a2 + b2,a3 + b3).
• Product a*b= (a0bQ —axbx —a2b2 —a3b3,aQbx —albQ-\- a2b3 —a3b2,
a0 b2 —axb3+ a2 bQ + a3 bx, a0 b3 + ax b2 —a2 bx + a3 b0).
• Quotient alb =ab~l.
411
ItL
-105
-155
-205
Mutatinga charge

412
Object-Oriented Programming
Create a data type for quaternionsand a test clientthat exercises allof your code.
Quaternions extend the concept of rotation in three dimensions to four dimen
sions. Theyare used in computer graphics, control theory,signalprocessing, and
orbital mechanics.
3.2.26 Dragon curves. Writea recursive Turtl e client Dragon that draws dragon
curves (see Exercises 1.2.35 and 1.5.9).
% java Dragon 15
Answer: These curves, originally discovered by three
NASA physicists, were popularized in the 1960s by
Martin Gardner and later used by MichaelCrichton in
the book and movie JurassicPark.This exercise can be
solvedwith remarkably compact code,based on a pair
of mutuallyinteracting recursive functionsderiveddi
rectly from the definition in Exercise 1.2.35. One of
them, dragon (), should draw the curve as you expect;
the other, nogardO, should draw the curve in reverse
order. See the booksite for details.
3.2.27 Hilbertcurves. Aspace-fillingcurveisacontinuous curvein the unit square
that passes throughevery point.Write arecursive Turtl e clientthat produces these
recursive patterns, which approach a space-filling curve that was defined by the
mathematician David Hilbert at the end of the 19th century.
zi c
Partial answer Seethe previous exercise. You need a pair of methods: hi 1bert(),
which traverses a Hilbert curve, and treblih(), which traverses a Hilbert curve in
reverse order. See the booksite for details.

3.2 Creating Data Types
3.2.28 Gosper island. Write a recursive Turtle client that produces these recur
sive patterns.
3.2.29 Dataanalysis. Write a data type for usein running experiments where the
control variable is an integer in the range [0,N) and the dependent variable is a
double value. (For example,studyingthe running time of a program that takesan
integer argument would involve such experiments.) Implement the following API.
public class Data
Data(int N, int max)
create a newdata analysisobject
for theN int valuesin [0, N)
double
addDataPoint(int i, double x)
add adata point (i, x)
voi d
piot()
plot allthe data points
void
TukeyPlotO
draw a Tukeyplot (see Exercise 2.2.18)
You can use the static methods in StdStats to do the statistical calculations and
draw the plots. Use StdDraw so clients can use different colors for plot() and
TukeyPlotO (for example,light gray for all the points and black for the Tukey
plot). Writea test clientthat plots the results (percolation probability) of running
experiments with Percol ati on as the grid sizeincreases.
3.2.30 Elements. Create a data type Element for entries in the Periodic Table of
Elements. Includedata type valuesforelement,atomicnumber,symbol,and atomic
weight and accessor methods for each of these values. Then, create a data type
413

Object-Oriented Programming
Peri odi cTabl e that reads values from a file to create an array of Element objects
(you can find the file and a description of its format on the booksite) and responds
to queries on standard input so that a user can type a molecular equation like
H20 and the program responds byprinting the molecular weight.DevelopAPIsand
implementations for each data type.
3.2.31 Stock prices. The file DJIA.txt on the booksite contains all closing stock
pricesin the history of the DowJonesIndustrial Average, in the comma-separated-
value format. Create a data type Entry that can hold one entry in the table, with
values for date, opening price, daily high, daily low, closing price, and so forth.
Then, createa data type Table that readsthe file to build an array of Entry objects
and supports methods for computing averages overvarious periods of time. Finally,
createinterestingTabl e clientsto produce plots of the data. Becreative: this path is
well-trodden.
3.2.32 Chaos with Newton's method. The polynomial/(z) = z4 - 1has four roots:
at 1, —1, i, and —i. We can find the roots using Newton's method in the complex
plane:zk+x = zk- f(zk)/f(zk). Here,/(z) = z4 - 1and/l(z) = 4z3. The method con
vergesto one of the four roots, depending on the starting point z0. Write a Compl ex
client Newton that takes a command-line argument N and colors pixels in an N-
by-NPicture white,red,green,or bluebymapping the pixels complexpoints in a
regularly spacedgrid in the squareof size 2centeredat the origin and coloringeach
pixel according to which of the four roots the corre
sponding point converges (black if no convergence
after 100 iterations).
3.2.33 Equipotential surfaces. An equipotential sur
face is the set of all points that have the same electric
potential V. Given a group of point charges,it is useful
to visualize the electric potential by plotting equipo
tential surfaces (also known as a contour plot). Write
a program Equipotenti al that draws a line every 5V
by computing the potential at each pixel and check
ing whether the potential at the corresponding point
if (g
!= 255)
17 % 256;

3.2 Creating Data Types
is within 1 pixel of a multiple of 5V. Note: A very easy approximate solution to this
exercise is obtained from Program 3.1.7 by scrambling the color values assigned
to each pixel, rather than having them be proportional to the grayscalevalue. For
example, the accompanying figure is created by inserting the code above it before
creating the Color. Explain why it works,and experiment with your own version.
3.2.34 ColorMandelbrotplot. Create a fileof 256integer triples that represent in
teresting Color values, and then use those colors instead of grayscalevalues to plot
each pixel in Mandel brot: Read the values to create an array of 256 Color values,
then index into that array with the return value of mand (). Byexperimenting with
various color choicesat various places in the set,you can produce astonishing im
ages.Seemandel. txt on the booksite for an example.
3.2.35 Julia sets. The Julia set for a given complex number c is a set of points
related to the Mandelbrot function. Instead of fixingz and varying c,we fix c and
vary z.Those points z for which the modified Mandelbrot function staysbounded
are in the Julia set,those for which the sequencediverges to infinity are not in the
set.Allpoints z of interest lie in the 4-by-4box centeredat the origin. The Juliaset
for cis connected if and only if cisin the Mandelbrotset! Writea program Color-
Jul i a that takestwo command line arguments a and b,and plots a color version of
the Julia set for c = a + bi,using the color-table method described in the previous
exercise.
3.2.36 Biggest winner and biggest loser. Write a StockAccount client that builds
an array of StockAccount objects, computes the total value of each account, and
prints a report for the accounts with the largest value and the account with the
smallestvalue.Assume that the information in the accounts are kept in a single file
that contains the information for the accounts, one after the other, in the format
given in the text.

Object-Oriented Programming
3.3
Designing Data Types
The ability to create data types turns everyprogrammer into a language designer.
You do not have to settle for the types of data and associated operations that are
built into the language, because you can
easilycreate your own types of data and
.1
..
i.
.
.-,
.
,i
3.3.1
Complex numbers (alternate)
. . .421
then write client programs that use them.
.. „
_
\
„„_
r
°
3.3.2
Counter
425
Java does not have complex numbers
333 spatial vectors
432
built in, but you can define Compl ex and
3.3,4
Document
.441
writeprograms suchasMandel brot. Java
3.3.5
Similarity detection
. .444
doesnot have a built-in facility for turtle
Programs in this section
graphics, but you can define Turtl e and
write client programs that take immedi
ate advantageof this abstraction. Evenwhen Javadoes havea particular facility, we
can use a data type to tailor it to our needs,aswedo when weuse our Std* libraries
instead the more extensiveones provided by Javafor software developers.
Now,the first thing that we strive for when creating a program is an under
standing of the types of data that wewillneed. Developingthis understanding is a
design activity. In this section,wefocus on developing APIsas a criticalstep in the
development of any program. Weneed to considervarious alternatives,understand
their impact on both client programs and implementations, and refine the design
to strike an appropriate balance between the needs of clients and the possible im
plementation strategies.
If you take a course in systemsprogramming, you will learn that this design
activity is critical when building large systems,and that Javaand similar languages
have powerful high-level mechanisms that support code reuse when writing large
programs. Manyof thesemechanismsareintended for usebyexpertsbuilding large
systems, but the general approach is worthwhile for every programmer, and some
of these mechanisms are usefulwhen writing small programs.
In this section we discuss encapsulation, immutability, and inheritance, with
particular attention to the use of these mechanisms in data-type design to enable
modular programming, facilitate debugging, and write clear and correct code.
At the end of the section, we discuss Java's mechanisms for use in checking
design assumptions againstactual conditions at runtime. Such tools are invaluable
aids in developing reliable software.

3.3 Designing Data Types
DesigningAPIs*
In Section 3.1, wewrote client programs that useAPIs; in Sec
tion 3.2, we implemented APIs. Now we consider the challengeof designing APIs.
Treating these topics in this order and with this focus is appropriate because most
of the time that you spend programmingwillbe writingclientprograms.
Often the most important and most challengingsteps in building software is
designing the APIs.This task takes practice,
careful deliberation, and many iterations.
However, any time spent designing a good
API is certain to be repaid in time saved
during debugging or with code reuse.
Articulating an API might seem to
be overkill when writing a small program,
but you should consider writing everypro
gram as though you will need to reuse the
code someday—not because you know
that you will reuse that code, but because
you are quite likely to want to reuse some
of your code and you cannot know which
code you will need.
client
API
creates objects
and invokes methods
public class Charge
417
Charge(double xO, double yO, double qO)
double potentialAt(double x, double y)
due^o charge
string
representation
Standards. It is easy to understand why
writing to an API is so important by con
sidering other domains. From railroad
tracks, to threaded nuts and bolts, to fax
machines, to radio frequencies
standards, we know that using a
standard interface enables the broadest us
age of a technology. Java itself is another
example: your Javaprograms are clients of
the Java virtual machine, which is a stan
dard interface that is implemented on a
wide variety of hardware and software
platforms. By using APIs to separate cli
ents from implementations, we reap the
benefits of standard interfaces for every
program that we write.
String toStringQ
implementation
defines signatures
and describes methods
\kM public Charge(double xO, double yO, double qO)
lit
•••
>
BFPSWfl-W "W* XWr-J*.
[f;M public double potentialAt(double x, double y)
W3 J
}
definesinstance variables
and implements methods
Object-oriented library abstraction

418
Object-Oriented Programming
Specification problem. Our APIs are lists of methods, along with brief English-
language descriptions of what the methods are supposed to do. Ideally, an API
would clearlyarticulate behavior for all possible inputs, including side effects, and
then wewould have softwareto checkthat implementations meet the specification.
Unfortunately, a fundamental result from theoretical computer science, known as
the specification problem, saysthat this goal is actually impossible to achieve.Briefly,
such a specificationwould have to be written in a formal language like a program
ming language, and the problem of determining whether two programs perform
the same computation isknown, mathematically,to be unsolvable. (If you are inter
ested in this idea, you can learn much more about the nature of unsolvable prob
lems and their role in our understanding of the nature of computation in a course
in theoretical computer science.)Therefore,weresort to informal descriptions with
examples, such as those in the text surrounding our APIs.
Wide interfaces. Awide interface isonethat hasan excessive number of methods.
An important principle to follow in designing an API is to avoid wide interfaces.
The sizeof an API naturally tends to growovertime because it is easyto add meth
ods to an existingAPI,whereasit is difficultto remove methods without breaking
existing clients. In certain situations, wide interfaces are justified—for example, in
widely used systems libraries such as Stri ng.Various techniques are helpful in re
ducing the effective width of an interface.For example,we considered in Chapter 2
severallibraries that use overloading to provide implementations of basic methods
for alltypes of data.Another approach isto include methods that are orthogonal in
functionality. For example,Java's Math library includes methods for si n(), cos(),
and tan (), but not sec().
Start with client code. One of the primary purposes of developing a data type
is to simplify client code. Therefore, it makes sense to pay attention to client code
form the start when designing an API.Veryoften, doing so is no problem at all,
because a typical reason to develop a data type in the first place is to simplify client
code that isbecoming cumbersome. When you find yourself with some client code
that you are not proud of, one wayto proceed is to write a fanciful simplified ver
sion of the code that expressesthe computation the way you are thinking about it,
at some higher levelthat does not involvethe details ofthe code. If you have done a
good job of writing succinct comments to describe your computation, one possible
starting point is to think about opportunities to convert the comments into code.

3.3 Designing Data Types
419
Remember the basic mantra for data types: whenever you can clearly separate data
andassociated operations within a program, you should doso. Whatever the source,
it is normally wise to write client code (and developthe API) before working on an
implementation. Writing two clientsis evenbetter.Starting with client code is one
wayof ensuring that developing an implementation willbe worth the effort.
Avoid dependence on representation. Usually whendeveloping an API, wehave
a representation in mind. After all, a data type is a set of values and a set of opera
tions on those values, and it does not make much senseto talk about the operations
without knowing the values.But that is different from knowing the representation
of the values. One purpose of the data type is to simplifyclient code by allowing it
to avoid details of and dependence on a particular representation. For example, our
client programs for Pictu re and StdAudio work with simple abstract representa
tions of pictures and sound, respectively. The primary value of the APIs for these
abstraction is that they allow client code to ignore a substantial amount of detail
that is found in the standard representations of those abstractions.
Pitfalls in API design. An API may be too hard to implement, implying imple
mentations that are difficult or impossible to develop; or too hard to use, creating
client code that is more complicated than without the API.An API might be too
narrow, omitting methods that clients need; or too wide, including a large number
of methods not needed by any client.AnAPImaybe too general, providing no use-
fillabstractions; or too specific, providing abstractions so detailed or so diffuse as to
be useless.These considerations are sometimes summarized in yet another motto:
provide toclients themethods theyneed and noothers.
When you first started programming,you typed in He!1oWor1d. j ava without un
derstanding much about it except the effect that it produced. From that starting
point, you learned to program by mimicking the code in the book and eventually
developing your own code to solve various problems. You are at a similar point
with API design.There are many APIs available in the book, on the booksite, and
in online Java documentation that you can study and use, to gain confidence in
designing and developing APIs of your own.

420
Object-Oriented Programming
Encapsulation.
The process of separating clients from implementations by
hiding information is known as encapsulation. Details of the implementation are
kept hidden from clients,and implementations have no wayof knowing details of
client code, which may even be created in the future.
Asyou may havesurmised,wehavebeen practicing encapsulation in our data
type implementations.In Section3.1,westarted with the mantrayoudonotneed to
know howa datatype isimplemented inorder touseit.This statement describes one
of the prime benefits of encapsulation.We consider it to be so important that we
have not described to you any other wayof building a data type. Now,we describe
our three primary reasons for doing so in more detail.We use encapsulation:
• Toenable modular programming
• Tofacilitatedebugging
• To clarifyprogram code
These reasons are tied together (well-designed modular code is easierto debug and
understand than code based entirelyon primitive types in long programs).
Modular programming. The programming style that we have been developing
since learning functions in Chapter 2 has been predicated on the idea of break
ing largeprograms into small modules that can be developedand debugged inde
pendently.This approach improvesthe resiliency of our softwareby limiting and
localizingthe effects of making changes,and it promotes code reuse by making it
possibleto substitute new implementations of a data type to improve performance,
accuracy, or memory footprint. The same idea works in many settings. We often
reap the benefits of encapsulation when we use system libraries. New versions of
the Javasystem often include new implementations of various data types or static
method libraries, but the APIs donotchange. There is strong and constant motiva
tion to improvedata-type implementationsbecauseallclientscan potentiallyben
efit from an improved implementation. The key to success in modular program
ming isto maintain independence among modules.Wedo so by insisting on the API
being the onlypoint of dependence between client and implementation. You donot
need to know howa data type is implemented in order to useit. The flip side of this
mantra is that a data-type implementation code can assume that the client knows
nothing but the API.
Example. For example, considerCompl ex (Program 3.3.1).It has the same name
and APIasProgram 3.2.6,but usesa differentrepresentation for the complexnum-

3.3 Designing Data Types
421
II
111
Program33A
Complexnumbers (alternate)
public class Complex
{
private final double r;
private final double theta;
public Complex(double re, double im)
{
r = Math.sqrt(re*re + im*im);
theta = Math.atan2(im,
re);
}
public Complex pi us(Complex b)
{
// Return the sum of this number and b.
double
real = re() + b.re();
double imag = im() + b.im();
return new Complex(real,
imag);
}
public Complex times(Complex b)
{
// Return the product of this number and b.
double
radius = r * b.r;
double angle
= theta + b.theta;
// See Q & A.
Polar representation
}
public double abs()
{
return
r;
}
public double re()
public double im()
public String toString()
{
return re() + " + " + im() + "i";
}
public static void main (Stri ng[] args)
{
Complex zO = new Complex(1.0,
1.0);
Complex z = zO;
z = z.times(z).plus(zO);
z = z.times(z).plus(zO);
StdOut.println(z);
{ return r * Math.cos(theta);
}
{ return r * Math.sin(theta); }
This data type implements the same APIasProgram 3.2.5. It uses the same instance methods
butdifferent instance variables. Since the instance variables are private, this program might
beused inplaceofProgram 3.2.5without changing anyclientcode.
-7.0
+ 7.0i
sSpJOTsSS'*

422
Object-Oriented Programming
bers. Program 3.2.6 uses the Cartesian representation, where instance variables x
and y represent a complexnumber x + iy. Program 3.3.1uses the polarrepresenta
tion, where instance variables r and theta represent a complex number in the
form r(cos 0 + isin 0). The polar representationis of interest because certain op
erations on complex number are easier to perform in the polar
representation. Addition and subtraction are easier in the Carte
sian representation; multiplication and division are easier in the
polar representation. Asyou willlearn in Section 4.1,it is often the
case that performancedifferences aredramatic.The ideaof encap
sulation is that we can substitute one of these programs for the
other (for whatever reason) without changing client code. The
choicebetweenthe two implementationsdepends on the client.Indeed,in princi
ple,the only difference to the clientshould be in differentperformance properties.
Thiscapability is of criticalimportancefor many reasons. One of the most impor
tant is that it allows us to improvesoftware constantly:when we developa better
wayto implement a data type,all of its clients can benefit. You take advantage of
this property every time you install a newversion of a software system, including
Java itself.
Private. Java's languagesupport for enforcingencapsulation is the private vis
ibilitymodifier. Whenyou declare a variable to be pri vate, you are makingit im
possible for any client (code in another module) to directly access the instance
variable(or method) that isthe subjectof the modifier. Clientscan only access the
API through the public methods and constructors (the API). Accordingly, you
can modify the implementation of private methods (or use different private
instancevariables) with certain knowledge that no client willbe directlyaffected.
Java does not require that all instance variables be private, but we insist on this
convention in the programs in this book. For example, if the instance variable re
and i min Compl ex (Program 3.2.6) were publ i c, then a client could write code that
directlyaccesses them. If z refersto a Compl ex object, z. re and z. i mrefer to those
values. But any client code that does so becomes completely dependent on that
implementation, violatinga basicpreceptof encapsulation.A switchto a different
implementation, such as the one in Program 3.3.1, would render that code use
less. Toprotect ourselves againstsuch situations,wealways make instancevariables
private; there is no good reason to make them public. Next, we examine some
ramifications of this convention.

3.3 Designing Data Types
423
Planningfor thefuture. Therehave beennumerous examples of important ap
plications where significant expense can be directly traced to programmers not
encapsulating their data types.
• Zip codes. In 1963,The United States Postal Service (USPS) began using a
five-digit zip code to improve the sorting and deliveryof mail. Program
mers wrote software that assumed that these codes would remain at five
digits forever, and representedthem in their programs using a single32-bit
integer. In 1983,the USPSintroduced an expanded zip code called ZIP+4,
which consists of the original five-digit zip code plus four extra digits.
• IPv4vs. IPv6. The Internet Protocol (IP) is a standard used by electronic
devices to exchange data overthe internet. Eachdeviceis assigneda unique
integer or address.IPv4uses32-bit addresses and supports about 4.3
billion addresses. Due to explosivegrowth of the internet, a new version,
IPv6, uses 128-bit addresses and supports 2128 addresses.
• Vehicle identification numbers. The 17-character naming schemefor ve
hicles known as the Vehicle Identification Number (VIN) that was estab
lished in 1981describes the make, model, year,and other attributes of
cars, trucks, buses, and other vehicles in the United States. But automakers
expect to run out of numbers by 2010.Either the length of the VIN must
be increased, or existingVINs must be reused.
In each of these cases,a necessarychangeto the internal representation means that
a large amount of client code that depends on a current standard (because the data
type is not encapsulated) will simply not function as intended. The estimated costs
for the changes in each of these casesruns to hundreds of millions of dollars! That
is a huge cost for failing to encapsulate a single number. These predicaments might
seem distant to you, but you can be sure that everyindividual programmer (that's
you) who does not take advantage of the protection available through encapsula
tion risks losing significant amounts of time and effort fixing broken code when
conventions change. Our convention to define allof our instance variables with the
private access modifier provides some protection against such problems. If you
adopt this convention when implementing a data type for a zip code, IP address,
VIN, or whatever,you can change the representation without affectingclients.The
data-type implementation knows the data representation, and the object holds the
data; the clientholds only a reference to the object and does not know the details.

424
Object-Oriented Programming
Limiting the potential for error. Encapsulation also helps programmers ensure
that their code operates as intended. As an example, we consider yet another hor
ror story: In the 2000 presidential election,Al Gore received negative 16,022votes
on an electronic voting machine in Volusia County, Florida. The counter variable
was not properly encapsulated in the voting machine software! To understand the
problem, consider Counter (Program 3.3.2),which implements a simple counter
according to the followingAPI:
public class Counter
Counter(Stri ng id, i nt max)
create a counter, initialized to 0
voi d
i ncrement ()
increment the counter unless itsvalue ismax
i nt
val ue()
return the value ofthe counter
Stri ng toStri ng()
string representation
APIfor a counter (seeProgram 3.3.2)
This abstraction is useful in many contexts, including, for example, an electronic
voting machine. It encapsulatesa singleinteger and ensures that the only operation
that can be performed on the integeris increment byone. Therefore,it can never go
negative. The goalof data abstraction isto restrictthe operations on the data. It also
isolates operations on the data. For example,we could add a new implementation
with a logging capability so that i ncrement () saves a timestamp for each vote or
some other information that can be used for consistency checks. But without the
private modifier, there could be client code like the following somewhere in the
voting machine:
Counter c = new Counter("Volusia",
VOTERS_IN_VOLUSIA_COUNTY);
c.count = -16022;
With private, code like this will not compile; without it, Gore's vote count was
negative.Usingencapsulation isfar from a complete solution to the voting security
problem, but it is a good start.
Code clarity. Precisely specifying a data type isgood design also because it leads
to client code that can more clearly express its computation. You have seen many
examples of such client code in Sections 3.1and 3.2,and we already mentioned this
issue in our discussionof Hi stogram (Program 3.2.3).Clients of that program are

3.3 Designing Data Types
425
Hi
Wm
m
Program 33.2
Counter
public class Counter
{
private final
String name;
private final
int maxCount;
private int count;
public Counter(String id, int max)
{
name = id;
maxCount = max; }
public void increment()
{
if (count < maxCount) count++;
}
public int value()
{
return count;
}
public String toString()
{
return name + ": " + count;
}
public static void main(String[]
args)
{
int N = Integer.parselnt(args[0]);
int T = Integer.parselnt(args[1]);
Counter[]
hits = new Counter[N];
for (int i = 0; i < N;
i++)
hits[i] = new Counter(i + "", T);
for (int t = 0; t < T; t++)
hits[StdRandom.uni form(N)].i ncrement();
for (int i = 0; i < N;
i++)
StdOut.pri ntln(hi ts[i]);
name
maxCount
count
counter name
maximum value
value
This class encapsulates a simple integer counter, assigning it a string name and initializing
it to 0 (Java's defaultinitialization), incrementing it each time theclientcallsi ncrement(),
reporting the value when the client calls value(), and creating a suing with its name and
value in toStri ng().
%java Counter 6 600000
|f
0:
100684
1:
99258
2:
100119
3:
100054
4:
99844
5:
100037
^5^w5^ffi^^^^S^wWSi^ER^^w
|
I-

426
Object-Oriented Programming
more clear than without it because calls on the instance method addDataPoi nt ()
clearlyidentifypoints of interest in the client.One keyto good design is to observe
that code written with the proper abstractions can be nearly self-documenting.
Some aficionados of object-oriented programming might argue that Histogram
itself would be easier to understand if it were to use Counter (see Exercise 3.3.5),
but that point is perhaps debatable.
We havestressed the benefits of encapsulation throughout this book. We summa
rize them again here, in the context of designing data types. Encapsulation enables
modular programming, allowingus to:
• Independently developof client and implementation code
• Substitute improved implementations without affectingclients
• Support programs not yet written (any client can write to the API)
Encapsulation also isolatesdata-type operations, which leads to the possibility of:
• Adding consistencychecksand other debugging tools in implementations
• Clarifyingclient code
A properly implemented data type (encapsulated) extends the Java language, al
lowing any client program to make use of it.

3.3 Designing Data Types
Immutability.
An immutable data type,suchasa Java St ri ng,has the property
that the value of an object never changesonce constructed. Bycontrast, a mutable
data type, such as a Java array, manipulates object values that are intended to
change. Of the data types considered in this chapter, Charge, Color, Stopwatch,
and Compl ex are all immutable, and Pi cture, Histogram, Turtl e, StockAccount,
and Counter are all mutable. Whether to make a data type immutable is an impor
tant design decision and depends on the application at hand.
Immutable types. Thepurposeof manydatatypes isto encapsulate values that do
not change so that they behave in the same wayas primitive types. For example, a
programmer implementing a Compl ex client might reasonably expect to write the
code z = zO for two Compl ex variables, in the same way as for doubl e or i nt val
ues. But if Complex were mutable and the value of z were
to change after the assignment z = zO, then the value of
zO would alsochange (they are both referencesto the same
object)! This unexpected result, known as an aliasing bug,
comes as a surprise to many newcomers to object-oriented
programming. One very important reason to implement
immutable types is that we can use immutable objects in
assignment statements and as arguments and return values
from functions without having to worry about their values
changing.
Mutable types. For manydata types, the verypurposeof
the abstraction is to encapsulate values as they change. Turtle (Program 3.2.4)
is a prime example. Our reason for using Turtle is to relieve client programs of
the responsibility of tracking the changing values.Similarly, Pictu re, Hi stogram,
StockAccount, Counter, and Java arrays are all types where we expect values to
change.When we pass a Turtl e as an argument to a method, as in Koch, we expect
the values of the instance variables to change.
Arrays and strings. You have already encountered this distinctionasa clientpro
grammer, when using Java arrays (mutable) and Java's String data type (immu
table). When you pass a Stri ng to a method, you do not need to worry about that
method changing the sequence of characters in the Stri ng, but when you pass an
array to a method, the method is free to change the elements of the array. Stri ng
427
mutable
immutable
Picture
Charge
Histogram
Color
Turtle
Stopwatch
StockAccount
Complex
Counter
String
Java arrays
primitive types

428
Object-Oriented Programming
objects are immutable because we generallydo notwant Stri ng values to change,
and Java arrays are mutable because we generally do want array values to change.
There are also situations where we want to have mutable strings (that is the pur
pose of Java's Stri ngBui 1der class)and where we want to have immutable arrays
(that is the purpose of the Vector classthat we consider later in this section).
Advantages ofimmutability. Generally, immutable types
are easier to use and harder to misuse because the scope
of code that can change their values is far smaller than for
mutable types. It is easier to debug code that uses immu
table types becauseit iseasierto guarantee that variablesin
the client code that uses them remain in a consistent state.
When using mutable types,you must always be concerned
about where and when their valueschange.
Cost of immutability. The downside of immutability is
that a newobject mustbecreatedfor every value. For exam
ple, the expression z = z. ti mes (z) .plus (zO) involves
creating a new object (the return value of z.times(z),
then using that object to invoke pi us(), but never saving
a referenceto it.A program such as Mandel brot (Program
3.2.7) might create a large number of such intermediate
orphans. However, this expense is normally manageable
because Javagarbage collectors are typically optimized for
such situations. Also, as in the case of Mandel brot, when
the point of the calculation is to create a large number of
values, we expect to pay the cost of representing them.
Mandelbrot also creates a large number of (immutable)
Color objects.
Complex zO;
zO = new Complex(1.0,
1.0);
Complex z = zO;
z = z.times(z).plus(zO);
ipSSiilitii
reference
zO I
811
1 t^tol +i
z 1 223
1 ^
reference
to 1 + 3/
223 i
i-o 1<
1 + 3/
224 * 3,° E
orphaned
^/ object
459 i °'° i <
0 + 2;
460 i 2,°
811 1
i.o 1 <
1'+»"
812 1
i.o 1
Ss88!it&V8ftS#!*Ms&&?^
An intermediate orphan
Final. Java's language support for helping to enforce immutability is the fi nal
modifier.When you declare a variable to be f i nal, you are promising to assign
it a value only once, either in an initializer or in the constructor. Code that could
modify the value of a f i nal variable leads to a compile-time error. In our code, we
always use the modifier f i nal with instance variableswhose values never change.
This policyservesas documentation that the value does not change, prevents acci-

3.3 Designing Data Types
429
dental changes,and makesprograms easierto debug.Forexample,you do not have
to include a f i nal value in a trace, sinceyou know that its value never changes.
Reference types. Unfortunately, final guarantees immutability only when in
stance variables are primitive types, not reference types. If an instance variable of
a reference type has the f i nal modifier, the value of that instance variable (the
reference to an object) will never change—it will always refer to the same object.
However,the value of the object itselfcan change.For example,if you have a f i nal
instance variable that is an array,you cannot changethe array (to change its length,
say), but you can change the individual array elements. Thus, aliasing bugs can
arise.For example,this code does notimplement an immutable type:
public class Vector
{
private final doubled coords;
public Vector(double[] a)
{
coords = a;
}
}
A client program could create a Vector by specifying the entries in an array,and
then (bypassing the API) change the elements of the Vector after construction:
doubled
a = { 3.0, 4.0 };
Vector vector = new Vector(a);
a[0] =17.0;
// Bypasses the public API.
The instance variable coords [] is pri vate and f i nal, but Vector is mutable be
causethe client holds the data, not the implementation. To ensure immutability of
a data type that includesan instancevariable of a mutabletype,weneed to make a
local copy,known as a defensive copy. Next,weconsider such an implementation.
Immutability needsto betaken into account in any data-type design. Ideally,wheth
er a data type is immutable should be specifiedin the API,so that clients know that
object valueswill not change.Implementing an immutable type can be a burden
in the presence of referencetypes. For complextypes,making the copy is one chal
lenge;ensuring that none of the instance methods change values is another.

430
Object-Oriented Programming
Example: spatial vectors
To illustrate these ideas in the context of a useful
mathematical abstraction, we now consider a vector data type. Like complex num
bers, the basic definition of the vector abstraction is familiar because it has played
a central role in applied mathematics for over 100years.The field of mathematics
known as linear algebra is concerned with properties of vectors. Linear algebra is a
rich and successful theory with numerous applications, and plays an important
role in all fields of social and natural science. Full treatment of linear algebra is
certainly beyond the scope of this book, but several important applications are
based upon elementary and familiar calculations, so we touch upon vectors and
linear algebra throughout the book (for example, the random surfer example in
Section 1.6is based on linear algebra).Accordingly, it is worthwhile to encapsulate
such an abstraction in a data type.
A spatial vector is an abstract entitythat has a magni-
direction
tude and a direction. Spatial vectors provide a natural way
to describe properties of the physical world, such as force,
velocity, momentum, or acceleration. One standard way to
specifya vector is as an arrow from the origin to a point in
a Cartesian coordinate system:the direction is the ray from
the origin tothe point and the magnitude is the length ofthe
Y
a spatial vector
arrow (distance from the origin to the point). To specifythe
vector it suffices to specifythe point.
This concept extends to any number of dimensions: an ordered list of AT real
numbers (the coordinates of an N-dimensional point) suffices to specify a vector
in JV-dimensional space.Byconvention,we use a boldface letter to refer to a vector
and numbers or indexed variable names (the same letter in italics) separated by
commas within square brackets to denote its value. For example, we might use x to
denote (x0, xx,..., xN_x) andy to denote (y0,yv...,yN_x).
API. The basicoperationson vectors areto add twovectors, multiplya vectorby
a scalar (real number), compute the dot product of two vectors, and compute the
magnitude and direction, as follows:
•Addition: x + y = (xq+ ^Xj +yp.. .,xN_x +yN_i)
• Scalarproduct: tx = (tx0, txv..., txN_x)
• Dotproduct: x •y = x^y0 + x^yx + ... + xN_]yN_l
•Magnitude: |x|= (x02 + xx2 + ... + xN_l2)m
• Direction: x/ |x| = (x0/ |x|,xxl |x|,..., xN_x/ |x|)

3.3 Designing Data Types
The resultof addition, scalar product,and the direction are vectors, but the mag
nitude and the dot product are scalarquantities (double values). For example, if
x = (0, 3,4, 0),and y = (0, -3,1, -4), then x + y = (0,0, 5, -4), 3x = (0, 9,12, 0),
x •y = —5, |x| = 5,and x/ |x| = (0,.6,.8,0). Thedirectionvectorisa unitvector: its
magnitude is 1.These definitions lead immediatelyto an API:
public class Vector
Vector(double[]
a)
Vector
pi us(Vector b)
Vector
minus(Vector b)
Vector
times(double t)
double
dot(Vector b)
double
magnitude()
Vector
directi onO
double
cartesian(int i)
String
toStringQ
create a vector withthegivenCartesian coordinates
sumof thisvector and b
difference of thisvector and b
scalarproduct of thisvector and t
dotproduct of thisvector and b
magnitude of thisvector
unit vector with same direction as this vector
i thcartesian coordinate of thisvector
stringrepresentation
APIfor a spatialvector {seeProgram 3.3.3)
Aswith Compl ex, this API does not explicitly specify that this type is immutable,
but weknow that clientprogrammers (whoarelikely to be thinking in terms of the
mathematical abstraction) willcertainlyexpectthat.
Representation. Asusual, our first choice in developing an implementation is to
choose a representation for the data. Usingan array to hold the Cartesian coor
dinates provided in the constructor is a clear choice, but not the only reasonable
choice. Indeed, one of the basic tenets of linear algebra is that other sets of JV vec
tors can be used as the basis for a coordinate system: any vector can be expressed
as a linear combination of a set of N vectors, satisfying a certain condition known
as linear independence. This ability to change coordinate systemsaligns nicelywith
encapsulation. Most clientsdo not need to know about the representation at alland
can work with Vector objects and operations. If warranted, the implementation
can change the coordinate system without affectingclient code.
431

432
m
Object-Oriented Programming
Program333
Spatial vectors
public class Vector
{
private final double[] coords;
coords[] | Cartesian
public Vector(double[] a)
{
// Make a defensive copy to ensure immutability.
coords = new double[a.length];
for (int i
= 0;
i
< a.length; i++)
coords[i]
= a[i];
}
public Vector pi us(Vector b)
{
// Sum of this vector and b.
doubled
c = new double[coords. 1ength];
for (int i = 0; i < coords.length;
i++)
c[i] = coords[i] + b.coords[i];
return new Vector(c);
}
public Vector times(double t)
}
{
// Product of this vector and b.
doubled
c = new double[coords. 1ength];
for (int i =0;
i < coords.length;
i++)
c[i] = t * coords[i];
return new Vector(c);
}
public double dot(Vector b)
{
// Dot product of this vector and b.
double sum =0.0;
for (int i
= 0;
i
< coords.length; i++)
sum = sum + (coords[i]
* b.coords[i]) ;
return sum;
}
public double magnitudeO
{
return Math.sqrt(this.dot(this));
}
public Vector direction()
{
return this.times(l/this.magnitudeO) ;
}
public double cartesian(int i)
{
return coords[i];
}
coordinates
B
mmmw
This implementation encapsulates themathematical spatial-vector abstraction, in an immu
table Java datatype. Document (Program 3.3.4) and Body (Program 3.4.2) aretypical clients.

3.3 Designing Data Types
433
Implementation. Given the representation, the code that im
plements all of these operations (Vector, in Program 3.3.3) is
straightforward. Twoofthe methods (mi nus () and toStri ng())
are left for exercises, as is the test client. The constructor makes
a defensive copy of the client array and none of the methods as
sign values to the copy, so that Vector objects are immutable.
The cartesi an() method iseasyto implement in our Cartesian
coordinate representation: return the ith coordinatein the array.
It actually implements a mathematical function that is defined
for anyVector representation: the geometric projection onto the
ith Cartesian axis.
,"'
(VV x^ •
,'/
x,
Projecting a vector (3D)
The this reference. ThemagnitudeO anddi recti on() methods in Vector make
use of the name this. Java provides the this keyword to give us a way to refer
within the code of an instance method to the object whose name was used to in
voke this method. You can use this in code in the same wayyou use any other
name. Some Javaprogrammers always use thi s to refer to instance variables. Their
scopeis the whole class, and this policyis easyto defendbecauseit documents ref
erencesto instance variables.However, it does result in a surfeit of thi s keywords,
so wetake the opposite tack and use thi s sparinglyin our code.
Why go to the trouble of using a Vector data type when all of the operations are
so easily implemented with arrays? Bynow the answerto this question should be
obviousto you: to enablemodular programming,facilitate debugging, and clarify
code.The array is a low-level Java mechanism that admits all kinds of operations.
Byrestrictingourselves to just the operationsin the Vector API(whicharethe only
ones that we need,for many clients), wesimplify the process of designing, imple
menting, and maintaining our programs. Because the type is immutable, we can
use it as we use primitive types. For example,when we pass a Vector to a method,
we are assured its value will not change,but we do not havethat assurance with an
array. Afteryou have seenseveral more examples of object-oriented programming,
we will discuss some more nuances in support of the assertion that it simplifies
design, implementation,and maintenance. In thecase ofVector, writingprograms
that useVector and well-defined Vector operationsis an easy and natural wayto
take advantage of the extensive amount of mathematical knowledge that has been
developed around this abstract concept.

434
Object-Oriented Programming
Inheritance
Java provides language support for defining relationships among
objects, knownasinheritance. Software developers usethesemechanismswidely, so
youwillstudythem in detailifyoutakeacoursein software engineering. Generally,
effective use of such mechanisms is beyond the scope of this book, but we briefly
describe them here because there are a few situations where you may encounter
them.
Interfaces. Interfaces provide a mechanism for specifying a relationship between
otherwise unrelated classes, by specifying a set of common methods that each im
plementingclass must contain.We referto this arrangement asinterface inheritance
because an implementing class inherits methods that are not otherwise in its API
through the interface.This arrangement allows us to write clientprograms that can
manipulate objectsof varyingtypes,by invokingmethods in the interface.Aswith
most new programming concepts, it is a bit confusing at first,but will make sense
to you after you haveseen a fewexamples.
Comparable. One interface that youarelikely to encounteris Java's Comparabl e
interface. The interface associatesa natural order for values within a data type, us
ing a method named compareToO,asdescribedin the following API:
public interface Comparable<Key>
i nt
compareTo(Key b)
compare this object with bfor order
APIforJava's Comparable interface
The <Key> notation, which we will introduce in Section 4.3, ensures that the two
objects being comparedhave the sametype.Assuming a and b are objects of the
same type, a. compareTo(b) must return:
• A negativeinteger if a is less than b
• A positive integer if if a greater than b
• Zero if a is equalto b
Additionally, the compareToO method must be consistent:for example, if a isless
than b, then b must be greater than a. A class that implements the Comparable
interface—such as String, Integer, or Double—promises to include a compa
reToO method accordingto these rules.Asexpected,the natural order for strings
is alphabetical and for integers is ascending.

3.3 Designing Data Types
435
To illustrate the utilityof having such an interface, we start byconsidering a sort
filter forStri ng objects. Thefollowing code takes aninteger Nfromthe command-
line, reads in Nstrings from standard input,sortsthem,and prints the strings on
standard output in alphabetical order.
import java.util.Arrays;
public class SortClient
{
public static void main(String[] args)
{
int N = Integer.parselnt(args[0]);
String[]
names = new String[N];
for (int i
= 0;
i
< N; i++)
names[i] = Stdln.readStringO ;
Arrays.sort(names);
for (int i =0;
i
< N; i++)
StdOut.pri ntln(names[i]);
}
}
Wewill examine sorting in detail in Section 4.2,so for the moment, we use a static
method Arrays. sort() from Java's java. uti 1 library. Now, if we replace the ar
ray input with the three lines
Integer[]
names = new Integer[N];
for (int i
= 0;
i
< N; i++)
names[i]
= Stdln.readlntO ;
SortClient sorts Integer values from standard input. You might speculate that
Arrays. sort() has overloaded implementations, one for Stri ng and one for In
teger. But this is not the case because Arrays.sort() must be able to sort an
arrayof any type that implements the Comparabl e interface (even a data type not
contemplated when writing the sorting method). To do so, the code in Arrays.
sort() declares variables of type Comparable—such variables may store values
of type String, Integer, Double, or of any type that implements the Compara
bl e interface.When you invoke the compareToO method of such a variable, Java
knows whichcompareToO methodto call, because it knows the type of the invok
ing object.This powerfulprogramming mechanismis known aspolymorphism or
dynamic dispatch.

436
Object-Oriented Programming
To make a class implement the Comparable interface, include the phrase imple
ments Comparabl e after the classdefinition, and then add a compareTo () method.
For example, modify Counter (Program 3.3.2) as follows:
public class Counter implements Comparable<Counter>
{
public int compareTo(Counter b)
{ if
(count < b.count) return -1
else if (count > b.count) return +1
else
return
0
}
}"""
Sinceyou are implementing compareToO,you have the flexibility to specify any
sort order whatever. For example, you might create a version of Counter to allow
clients to sort Counter values in decreasing order (perhaps for a voting applica
tion), by changingthe compareToO method as follows:
public int compareTo(Counter b)
{
if
(count < b.count)
return +1
else if (count > b.count) return -1
else
return
0
}
For another example, ifyou were to modify StockAccount as follows:
public class StockAccount implements Comparable<StockAccount>
{
public int compareTo(StockAccount b)
{
return name.compareTo(b.name);
}
}"
you could then sort an array of StockAccount values by account name with Ar
rays. sort(). (Note that this compareToO implementation for StockAccount

3.3 Designing Data Types
437
uses Java's compareToO method for Stri ng.) Thisabilityto arrangeto write a cli
ent to sort any type of data is a persuasive exampleof interfaceinheritance.
Computing with functions. Often, particularly inscientific computing, we want
to compute withfunctions: wewant to computeintegralsand derivatives, find roots,
and so forth. In someprogramming languages, known as functional programming
languages, this desirealignswith the underlying
design of the language, which uses computing
with functions to substantially simplify client
code. Unfortunately, methods are notfirst-class
objects inJava. Asan example,considerthe prob
lem of estimating the integral of a positivefunc
tion (area under the curve) in an interval (a, b).
This computation is known as quadrature or numerical integration. One simple
method for estimatingthe integralisthe rectangle rule: computethe total areaof N
equally-spaced rectangles under thecurve. To implement thisrule, wemighttry to
writethe following codeto approximate thevalue ofan integral by:
public double integrate(double f(double x),
double a, double b, int N)
{
double delta = (a - b)
double sum =0.0;
for (int i =0;
i
sum += delta * f(a + delta * (i + 0.5));
}
Such a method would enable client code such as this:
/
N;
< N;
i++)
f(a + delta
\
H
Th^,
Approximating an integral
integrate(Gaussian.phi(), a, b,
N)
Unfortunately, this code isnot legal in Java. You cannot pass methods asarguments.
We cangetaround this restriction bydefining an interface forfunctions and using
that interfaceto implement i ntegrate (). You can find that solution on the book-
site, along with many examples of methods and classes that involve computing
with functions in Java, whichwillbe of interestifyou plan to takefuture coursesin
scientificcomputing.
Event-based programming. Another powerful example ofthevalue of interface
inheritance is its use in event-based programming. In a familiar setting, consider

438
Object-Oriented Programming
the problem of extendingDraw to respond to user input such as mouse clicks and
keystrokes. Onewayto do soisto define an interface to specify whichmethods the
drawpackage should call when userinput happens. The descriptive term callback
is sometimes used to describe a call from a method in one class to a method in
another class through an interface. You can find on the booksite an example in
terface DrawListener and information on how to write code to respond to user
mouse clicks and keystrokes within Draw. java. You willfind it easyto write code
that createsa Draw objectand includesa method that the Draw method can invoke
(callback your code) to tell your method the charactertyped on a user keystroke
event or the mouse position on a mouse click. Writing interactivecode is fun but
challenging becauseyou haveto plan for allpossible user input actions.
Subtyping. Another approach to enabling codereuse isknown as subtyping. It is
a powerful technique that enables a programmer to change the behavior of a class
and add functionality withoutrewriting the entireclass from scratch. The ideaisto
define a new class (subclass, or derived class) that inherits instance variables and in
stancemethods from another class (superclass, or base class). The subclass contains
more methods than the superclass. Subtypingis widelyused by systems program
mers to build so-called extensible libraries. The idea is that one programmer (even
you) canaddmethods toalibrarybuiltbyanotherprogrammer (or,perhaps, ateam
ofsystems programmers), effectively reusing thecode in a potentially huge library.
Thisapproach iswidely used, particularly in the development of userinterfaces, so
that the largeamount of coderequiredto provideallthe facilities that usersexpect
(drop-downmenus,cut-and-paste, access to files, and so forth) canbe reused. The
useof subtypingiscontroversial amongsystems programmers(itsadvantages over
interface inheritance are debatable), and we do not use it in this book, because it
generally works against encapsulation. Subtyping makes modular programming
more difficult for two reasons. First, any change in the superclass affects all sub
classes. The subclass cannot be developed independently of the superclass; indeed,
it is completely dependent on the superclass. This problem is known as thefragile
base class problem. Second, the subclass code,having access to instance variables,
can subvert the intention of the superclass code. For example, the designer of a
class such asVector mayhavetakengreatcareto makethe Vector immutable,but
a subclass, with full access to the instance variables, can just change them. How
ever, certainvestiges of the approacharebuilt into Java and thereforeunavoidable.
Specifically, everyclass is a subtype of Java's Object class. This structure enables

3.3 Designing Data Types
implementation of the "convention"that everyclass includesan implementations
of toStri ng(), equal s(), hashCodeO (a method that we will encounter later in
thissectionand in Chapter 4),and several othermethods. Every class inheritsthese
methods from Object through subtyping.
Application: data miimimg
To illustrate some oftheconcepts discussed in this
section in the context of an application, we next consider a software technology
that is provingimportant in addressing the daunting challenges of data mining, a
term that is widelyused to describe the process of searching through the massive
amounts of information now accessible to everyuser on the web (not to mention
our own computers).Thistechnologycan serve asthe basisfor dramatic improve
ments in the quality of web searchresults,for multimedia information retrieval, for
biomedical databases, for plagiarism detection, for research in genomics, for im
provedscholarship in many fields, for innovationin commercial applications, for
learning the plansof evildoers, and for manyotherpurposes. Accordingly, thereis
intenseinterestand extensive ongoingresearch on data mining.
You have directaccess to thousandsof files on yourcomputerand indirectac
cess to billions of files on the web. As youknow, these files areremarkably diverse:
there are commercial web pages, music and video, email, program code, and all
sorts of other information. For simplicity, we will restrict attention to text docu
ments (though the method wewillconsiderapplies to pictures,music,and allsorts
ofotherfiles aswell). Even withthisrestriction, thereisremarkable diversity in the
types of documents. For reference, you can find thesedocuments on the booksite:
Our interestis in finding efficient ways to search throughthe files usingtheir con
tent to characterize documents. One fruitful approach to this problem is to as-
file name
description
Constitution.txt
legal document
TomSawye r. txt
American novel
HuckFinn.txt
Prejudice.txt
Picture.java
DDIA.csv
Amazon.html
ACTG.txt
American novel
English novel
Java code
financialdata
webpagesource
virusgenome
sampletext
. of both Houses shall be determined by .
."Say, Tom, let ME whitewash a little." .
.was feeling pretty good after breakfast.
. dared not even mention that gentleman..
.String suffix = filename.substring(file.
.Ol-Oct-28,239.43,242.46,3500000,240.01 .
.<table width="100%" border="0" cellspac.
.GTATGGAGCAGCAGACGCGCTACTTCGAGCGGAGGCATA.
Some text documents
439

440
Object-Oriented Programming
sociate with each document a vector known as a profile, which is a function of its
content. The basic idea is that the profile should characterize a document, so that
documents that are different haveprofilesthat are different and documents that are
similar have profiles that are similar.You probably are not surprised to learn that
this approach can enable us to distinguish among a novel, a Java program, and a
genome, but you might be surprised to learn that content searchescan tell the dif
ferencebetween novelswritten by different authors and can be effective as the basis
for many other subtle search criteria.
To start, we need an abstraction for documents. What is a document? What
operations do wewant to perform on documents?The answersto these questions
inform our design and therefore, ultimately, the code that we write. For the pur
posesof data mining, it is clearthat the answerto the first question is that a docu
ment is defined by an input stream. The answer to the second question is that we
need to be ableto compute a number (for example, a double value) to measure the
similaritybetween a documentand anyotherdocument.Theseconsiderations lead
to the following API.
public class Document
Document(String name, int k, int d)
doubl e
si mTo(Document doc)
similarity measure between this document and doc
Stri ng name ()
name ofthis document
APIfordocuments (seeProgram 3.3.4)
The argumentsof the constructor area file or website name (for useby In) and two
integers that control the quality of the search. Clients can use simToO to deter
mine the extent of similaritybetween this Document and any other Document on a
scaleof 0 (not similar) to 1 (similar).This simple data type provides a good separa
tion betweenimplementing a similaritymeasure and implementing clientsthat use
the measure to search among documents.
Computing profiles Computing the profile isthe firstchallenge. Our firstchoice
isto useVector to representa document's profile. Butwhat information should go
into computing the profileand how do wecompute the value of the Vector profile
of a Document (in the constructor)? Many different approaches have been studied,
and researchers are still activelyseeking efficient and effectivealgorithms for this

3.3 Designing Data Types
441
w^^^^^^^^^^^^^^^s^^mmm^
<$?<
Program 33A
Document
public class Document
{
private final
String id;
private final Vector profile;
public Document(String name,
int k,
int d)
{
id = name;
String s = (new In(name)).readAll();
int N = s.1ength();
doubled freq = new double[d];
for (int i
= 0;
i
< N-k;
i++)
{
int h = s.substring(i, i+k).hashCode();
freq[Math.abs(h % d)] += 1;
id
profile
file nameor URL
unit vector
name
k
d
s
N
freq[]
h
document name
length ofgram
dimension
entire document
document length
hash frequencies
hash for k-gram
}
profile = (new Vector(freq)).direction();
}
public double simTo(Document doc)
{
return profile.dot(doc.profi1e);
}
public String name()
{
return id;
}
public static void main(String[] args)
{
String name = args[0];
int k = Integer.parselnt(args[l]);
int d = Integer.parselnt(args[2]);
Document doc = new Document(name,
k, d);
StdOut.pri ntln(doc.profi1e);
}
zm^t&for&^&^S^WMSzk
}
This Vector client creates a unit vector from a document's k-grams that clients can use to
measure itssimilaritywith otherdocuments (seetext).
% more genomeA.txt
ATAGATGCATAGCGCATAGC
% java Document genomeA.txt 2 16
[ 0 0 0.51 0.39 0.39 0 0 0 .13 0.39 0 0 0.13 0.13 0.51 0 0 ]

442
Object-Oriented Programming
task.Our implementation Document (Program3.3.4) usesa simplefrequency count
approach. The constructor has two arguments, an integer kand a vector dimen
sion d.It scansthe document and examinesallof the k-grams in the document: the
substrings of lengthkstartingat each position. In its simplest form,the profile isa
vectorthat gives the relative frequency of occurrence of the fc-grams in the string:
an entryforeach possible fc-gram giving thenumberof fc-grams in thecontentthat
have that value. Forexample, suppose that weusek= 2 in genomic data,with d=
16(there are 4 possiblecharactervaluesand there
fore 16 possible 2-grams). The 2-gram AT occurs
4 times in the string ATAGATGCATAGCGCATAGC, so,
for example, the vector entry correspondingto AT
would be 4.Tobuild the frequency vector, we need
to be able to convert each of the fc-grams into an
integer between 0and 15 (thisinteger function ofa
stringisknownasa hash value). Forgenomic data,
this is an easy exercise (see Exercise 3.3.26). Then,
we can compute an array to build the frequency
vector in one scan through the text, incrementing
the array entry correspondingto each fc-gram en
countered. It would seem that we lose information
by disregarding the order of the fc-grams, but the
remarkable fact is that the information content of
that order is lower than that of their frequency.A
Markov model paradigm not dissimilar from the
one that we studied for the random surfer in Sec
tion 1.6 can be used to take order into account—
such models are effective, but much more work
to implement. Encapsulating the computation in
Document gives ustheflexibility toexperiment withvarious designs without need
ing to rewrite Document clients.
ClIICGGIII
GGAACCGAAG
CCGCGCGTCT
ATAGATGCAT TGTCTGCTGC
hash
AGCGCATAGC AGCATCGTTC
2-gram
count
unit
count
unit
AA
0
0
0
2
.137
AC
1
0
0
1
.069
AG
2
4
.508
1
.069
AT
3
3
.381
2
.137
CA
4
3
.381
3
.206
CC
5
0
0
2
.137
CG
6
0
0
4
.275
CT
7
1
.127
6
.412
GA
8
3
.381
0
0
GC
9
0
0
5
.343
GG
10
0
0
6
.412
GT
11
1
.127
4
.275
TA
12
1
.127
2
.137
TC
13
4
.508
6
.412
TG
14
0
0
4
.275
TT
15
0
0
2
.137
Profilinggenomic data
Hashing. ForASCII text strings there are 128 different possible char values for
eachcharacter, sothere are 128* possible fc-grams, and the dimension dwould have
to be 128* for the simple scheme justdescribed. Thisnumber is prohibitively large
even for moderately large fc. For Unicode, with 65,536 characters, even 2-grams
lead to huge vector profiles. To ameliorate this problem, we use hashing, a fun-

3.3 Designing Data Types
443
damental operation related to search algorithms that we consider in Section 4.4.
Indeed,the problem of convertinga string to an integerindexis so important that
it is built into Java. Asjust mentioned in our discussion of inheritance, all objects
inherit from Object a method hashCodeO that returns an int value. Given any
string s, we compute Math.abs (s. hashcode() % d). Thisvalueis an integer be
tween0 and d— 1that wecan useasan indexinto an arrayto compute frequencies.
The profilethat weuseisthe direction of the vectordefined byfrequencies of these
values for all fc-grams in the document (the unit vector with the same direction).
Comparingprofiles. The second challenge is tocompute asimilarity measure be
tweentwo profiles. Again, there are many different ways to compare two vectors.
Perhaps the simplest is to compute the Euclidean distance between them. Given
vectorsx and y, this distance is definedby:
|x-y| = ((x0-y0)2 + {xx-yx)2 + ...+
(x^ -yd.x)2)^
You are familiar with this formula for d = 2 or d = 3. With Vector, the distance is
easyto compute. If x and y are two Vector values,then x. mi nus (y) .magnitude ()
is the Euclidean distance between them. If documents are similar, we
expect their profiles to be similar and the distance between them to be
%mor.e.docf •txt
low. Another widely used similarity measure, known as the cosine simi-
jomSawyer.txt
larity measure, is evensimpler:sinceour profiles are unit vectors with
HuckFi nn.txt
nonnegative coordinates, their dot product
Pr.eJ udl C(:•txt
0
r
Picture.java
x -y = x0y0 + x$x + ... +
xd_$d_x
isa number between0 and 1.Geometrically, thisquantityisthe cosine
of the angle formed by the two vectors (seeExercise 3.3.12).The more
similar the documents, the closerweexpectthis measure to be to 1.
Comparing allpairs. CompareAll (Program 3.3.5) is a simple and useful Docu
ment client that provides the information needed to solve the following problem:
given a setofdocuments, findthetwothat aremostsimilar. Since thisspecification
isa bit subjective, CompareAl 1 prints out the cosine similarity measurefor allpairs
of documents on an input list.Formoderate-size fc and d,the profiles do a remark
ablygoodjob of characterizing our sample set of documents. The results saynot
onlythat genomicdata,financial data,Java code, andwebsourcecodearequite dif
ferentfromlegal documentsand novels, but also that Tom Sawyer and Huckleberry
DJIA.csv
Amazon.html
ACTG.txt

444
Object-Oriented Programming
llliPlfPP^$S!!^
i
II
#3
Program3.3.5
Similarity detection
public class CompareAll
{
public static void main(String[] args)
{
int k = Integer.parselnt(args[0]);
int d = Integer.parselnt(args[1]);
int N = Stdln.readlntO;
Document []
a = new Document[N];
<*
for (int i = 0; i < N;
i++)
a[i] = new Document(Stdln.readStringO , k, d) ;
StdOut.print("
");
for (int j
= 0;
j
< N; j++)
StdOut.printf(M
%.4s", a[j].name());
StdOut.println();
for (int i
= 0;
i
< N; i++)
{
StdOut.printf("%.4s",
a[i].name());
for (int j = 0; j < N;
j++)
StdOut.printfCJa.Zf",
a[i] .simTo(a[j])) ;
StdOut.println();
k
d
N
a[]
length ofgram
dimension
numberof documents
all documents
}
}
}
This Document client reads a document listfrom standard input, computes profiles based on
k-gram frequenciesforallthe documents, and prints a matrix ofsimilarity measures between
allpairs ofdocuments. Ittakes two argumentsfrom the command line: the value ofk andthe
dimension d oftheprofiles.
% java CompareAll 5 10000 <
docs.txt
i
Cons
TomS
Huck
Prej
Pict
DJIA
Amaz
ACTG
Cons
1.00
0.66
0.60
0.64
0.17
0.18
0.21
0.11
TomS
0.66
1.00
0.93
0.88
0.10
0.24
0.18
0.14
1
Huck
0.60
0.93
1.00
0.82
0.07
0.23
0.16
0.12
ii.
Prej
0.64
0.88
0.82
1.00
0.10
0.25
0.19
0.15
Pict
0.17
0.10
0.07
0.10
1.00
0.05
0.37
0.03 1
1
D3IA
0.18
0.24
0.23
0.25
0.05
1.00
0.16
0.11
Amaz
0.21
0.18
0.16
0.19
0.37
0.16
1.00
0.07
ACTG
0.11
0.14
0.12
0.15
0.03
0.11
0.07
1.00
p.
I1
ii"
m
fit
i

3.3 Designing Data Types
445
Finnare much more similar to each other than to Pride andPrejudice. A researcher
in comparative literature could use this program to discoverrelationships between
texts;a teacher could also use this program to detect plagiarismin a set of student
submissions (indeed, many teachers douse such programs on a regular basis); or
a biologist could use this program to discover relationships among genomes. You
can find many documents on the booksite (or gather your own collection) to test
the effectivenessof CompareAl 1 for various parameter settings.
Searchingfor similar documents. Another natural Document client is one that
uses profiles to search among a large number of documents to identify those that
are similar to a given document. For example,web search engines uses clients of
this type to present you with pages that are similar to those you have previously
visited, online book merchants use clients of this type to recommend books that
are similar to ones you have purchased, and social networking websites use clients
of this type to identify people whose personal interests are similar to yours. Since
In can take web addresses instead of file names, it is feasible to write a program
that can surfthe web,compute profiles,and return linksto pagesthat haveprofiles
that are similar to the one sought. Weleavethis client for a challenging exercise.
This solution is just a sketch. Many sophisticated algorithms for
efficiently computing profiles and comparing them are still being
invented and studied by computer scientists. Our purpose here is
to introduce you to this fundamental problem domain while at
the same time illustrating the power of abstraction in addressing
/
primitive typey^
a computational challenge. Vectors are an essential mathematical
/
bit
abstraction, and we can build search solutions by developing lay
ers of abstraction: Vector is built with the Javaarray, Document is
/
->
built with Vector, and client code uses Document. As usual, we have
spared you from a lengthy account of our many attempts to develop these APIs,
but you can see that the data types are designed in response to the needs of the
problem, with an eye toward the requirements of implementations. Identifying
and implementing appropriate abstractions is the key to effective object-oriented
programming. The power of abstraction—in mathematics, physical models, and
in computer programs—pervades these examples.Asyou become fluent in devel
oping data types to address your own computational challenges, your apprecia
tion for this power will surely grow.

446
Object-Oriented Programming
Design-by-contract.
To conclude, we briefly discuss Java language mecha
nisms that enable you to verify assumptions about your program as it is running.
For example, if you have a data type that represents a particle, you might assert
that its mass is positive and its speed is lessthan the speed oflight. Or if you have a
method to add two vectors of the same length, you might assert that the length of
the resulting vector also has the same length.
Exceptions. Anexception isa disruptive eventthat occurswhilea program isrun
ning, often to signal an error. The action taken is known as throwing an exception.
We have already encountered exceptions thrown by Java system methods in the
course of learning to program: StackOverflowException, Di videByZeroExcep-
tion, NullPointerException, and ArrayOutOfBoundsException are typical
examples. You can also create your own exceptions. The simplest kind is a Run-
timeException that terminates execution of the program and prints out an error
message.
throw new RuntimeException("Error message here.");
It is good practice to use exceptionswhen they can be helpful to the user. For ex
ample, in Vector (Program 3.3.3),we should throw an exception in pi us() if the
two Vectors to be added have different dimensions. To do so, we insert the follow
ing statement at the beginning of pi us ():
if (coords.length
!= b.coords.length)
throw new RuntimeException("Vector dimensions disagree.");
This leads to a more informative error message than the ArrayOutOfBoundsEx-
cepti on than the client would otherwise receive.
Assertions. An assertion is a boolean expression that you are affirming is true at
that point in the program. If the expression is f al se, the program will terminate
and report an error message. Assertionsare widelyused by programmers to detect
bugs and gain confidence in the correctness of programs. They also serve to docu
ment the programmer's intent. Forexample,in Counter (Program 3.3.2),wemight
check that the counter is never negativeby adding the following assertion as the last
statement in i ncrement ():
assert count >= 0;

3.3 Designing Data Types
447
which would identify a negativecount.You can alsoadd an optional detail message,
such as
assert count >= 0 : "Negative count detected in increment()";
to help you locate the bug. By default, assertions are disabled, but you can en
able them from the command line by using the -enabl easserti ons flag (-ea for
short). Assertions are for debuggingonly:your program should not rely on asser
tions for normal operation sincethey maybe disabled. When you take a course in
systems programming, you will learn to use assertions to ensure that your code
never terminates in a systemerror or goesinto an infiniteloop. One model, known
as the design-by-contract model of programming, expresses the idea. The designer
of a data type expresses a precondition (the condition that the client promises to
satisfywhen callinga method), a postcondition (the condition that the implemen
tation promises to achieve when returning from a method), invariants (any condi
tion that the implementation promises to satisfy while the method is executing),
and side effects (any other change in state that the method could cause). During
development, these conditions can be tested with assertions. Many programmers
use assertions liberally to aid in debugging.
The language mechanisms discussed throughout this section illustrate that effec
tive data-type design takes us into deep water in programming-language design.
Experts are still debating the best waysto support some of the design ideas that we
are discussing.Why does Javanot allowfunctions as arguments?Why does Matlab
not support mutable data types? As mentioned earlyin Chapter 1, it is a slippery
slope from complaining about features in a programming language to becoming
a programming-language designer. If you do not plan to do so, your best strategy
is to use widely available languages. Most systemshave extensivelibraries that you
certainly should use when appropriate, but you often can simplifyyour client code
and protect yourselfby building abstractionsthat can easilytransport to other lan
guages. Yourmain goal is to develop data types so that most of your work is done
at a levelof abstraction that is appropriate to the problem at hand.

Object-Oriented Programming
W+ A
Q. What happens if I try to access a private instance variable or method from
another file?
A. You geta compile-timeerror that says the given instancevariable or method has
private accessin the given class.
Q. The instance variables in Complex are private, but when I am executing the
method ti mes () for a Compl ex object a, I can access object b's instance variables.
Shouldn't they be inaccessible?
A. The granularity of private access is at the class level, not the instancelevel. De
claring an instance variableas private means that it is not directly accessible from
any other class. Methods within the Compl ex class can access (read or write) the
instance variablesof any instance in that class. It might be nice to have a more re
strictiveaccess modifier, say, superprivate—that would make the granularity at
the instance levelso that only the invoking object can access its instance variables,
but Javadoes not have such a facility.
Q I seethe problem with the ti mes () method in Compl ex. It needs a constructor
that takes polar coordinates as arguments. How can we add such a constructor?
A. That is a problem since we already have one constructor that takes two real
arguments. A better design would be to have two methods createRect(x,
y)
and createPol ar(r, theta) in the API that create and return new objects. This
design is better because it would provide the client with the capability to switch to
polar coordinates. This exampledemonstrates that it is a good idea to think about
more than one implementation when developinga data type.
Q. Is there a relationship between the Vector in this section and the Vector class
in the Javalibrary?
A. No.Weusethe name becausethe term vector properlybelongsto linear algebra
and vector calculus.
Q. What is a deprecated method?
A. A method that is no longer fully supported, but kept in an API to maintain

3.3 Designing Data Types
compatibility. For example, Javaonce included a method Character.isSpace(),
and programmers wrote programs that relied on using that method's behavior.
When the designers of Javalater wanted to support additional Unicode whitespace
characters, they could not changethe behavior of i sSpace () without breaking cli
ent programs. So,instead, they added a newmethod Character. i sWhi teSpace ()
and deprecated the old method. As time wears on, this practice certainly compli
cates APIs.
Q. I am interested in the methods that all objects inherit from Object. We have
been using toStri ng() and the use of hashCodeO in Document is interesting, but
what about equal s ()? Isn't it important for me to know how about that?
A. Well, yes,in principle, but you would be verysurprised at how difficult it is to
properly implement equal s(), even for simple objects. For example, the following
is an implementation of equal s () for Counter:
public boolean equals(Object y)
{
if (y == this) return true;
if (y == null) return false;
if (y.getClass()
!= this.getClassO) return false;
Counter b = (Counter) y;
return (count == b.count);
}
449

Object-Oriented Programming
,0Exerclmlsl.
3.3.1
Represent a point in time by using an i nt to store the number of seconds
since January 1,1970. When will programs that use this representation facea time
bomb? How should you proceed when that happens?
3.3.2
Create a data type Location for dealing with locations on Earth using
spherical coordinates (latitude/longitude). Include methods to generate a random
location on the surface of the Earth, parse a location "25.344 N, 63.5532 W", and
compute the great circledistance between two locations.
3.3.3
Create a data type for a three-dimensional particle with position (rx, ry,
rz), mass (m), and velocity (vx> vy> vz). Include amethod toreturn its kinetic energy,
which equals 1/2 m(vx2 + vy2 + vz2). Use Vector.
3.3.4
If you know your physics, develop an alternate implementation for you
data type ofthe previous exercise based onusing the momentum (px, py, pz) as an
instance variable.
3.3.5
Develop an implementation of Hi stogram (Program 3.2.3) that uses Coun
ter (Program 3.3.2).
3.3.6
Givean implementation of mi nus () for Vector solelyin terms of the other
Vector methods, such as di recti on() and magnitudeO.
Answer:
public Vector minus(Vector b)
{
return this.plus(b.times(-1.0));
}
The advantage of such implementations is that they limit the amount of detailed
code to check; the disadvantage is that they can be inefficient. In this case, pi us ()
and timesO both create new Vector objects, so copying the code for pi us() and
replacing the minus sign with a plus sign is probably a better implementation.
3.3.7
Implement the method toStri ng() for Vector.

3.3 Designing Data Types
3.3.8
Addthe codenecessaryto makeVector implement Comparabl e (using the
valueof the magnitude to determine the sort order) and writea test clientthat takes
k and Nas command-line arguments, reads Nfc-dimensional vectors from standard
input, sorts them with Arrays.sortO, and prints the sorted result on standard
output.
3.3.10 Implement a data type Vector2Dfor two-dimensionalvectorsthat has the
same API as Vector, except that the constructor takes two doubl e values as argu
ments. Use two doubl e values (instead of an array) for instance variables.
3.3.11 Implement the Vector2D data type of the previous exerciseusing one Com
pl ex value as the only instance variable.
3.3.12 Prove that the dot product of two two-dimensional unit-vectors is the co
sine of the angle between them.
3.3.13 Implement a data type Vector3D for three-dimensional vectors that has
the same API as Vector, except that the constructor takes three double values as
arguments. Also, add a cross product method: the cross product of two vectors is
another vector, defined by the equation
aXb = c|a||b|sin6
where c is the unit normal vector perpendicular to both a and b, and 0 is the angle
between a and b. In Cartesian coordinates, the followingequation defines the cross
product:
(a0, av a2) X (2?0, bv b2) = {ax b2 -a2 bva2 b0 -aQbva0 bx -ax b0)
The cross product arises in the definition of torque, angular momentum, and vec
tor operator curl.Also, |a X b| isthe areaof the parallelogram with sidesa and b.
3.3.14 Use assertions and exceptions to develop an implementation of Rati onal
(see Exercise 3.2.7) that is immune to overflow.
3.3.15 Add code to Counter to throw a RuntimeException if the client tries to
construct a Counter object using a negative value for max.

452
Object-Oriented Programming
^ata-t^g0Destg^JExerci^^
This listof exercises is intended to give you experience in developing data types. For
each problem, design oneor more APIs with APIimplementations, testing your de
sign decisions byimplementing typical client code. Some ofthe exercises require either
knowledge ofaparticular domain ora searchforinformation about it on the web.
3.3.16 Statistics. Developa data type for maintaining statisticsof a set of doubl e
values.Providea method to add data points and methods that return the number of
points, the mean, the standard deviation,and the variance.Developtwo implemen
tations: one whose instance valuesare the number of points, the sum of the values,
and the sum of the squaresofthevalues, and another that keepsan array containing
all the points. For simplicity, you may take the maximum number of points in the
constructor. Yourfirst implementation is likelyto be faster and use substantially
lessspace,but is also likelyto be susceptibleto roundoff error. Seethe booksite for
a well-engineered alternative.
3.3.17 Genome. Develop a data type to store the genome of an organism. Biolo
gistsoften abstract the genome to a sequence of nucleotides (A, C, G, or T).The data
type should support the methods addCodon(char c) andnucleotideAt(int i),
as well as findGeneO (see Program 3.1.8). Develop three implementations. First,
use one instance variable of type String, implementing addCodon() with string
concatenation. Each method calltakes time proportional to the size of the current
genome. Second, use an array of characters, doubling the sizeofthe array each time
it fills up. Third, use a boo!ean array,using two bits to encode each codon.
3.3.18 Time. Develop a data type for the time of day.Provide client methods that
return the current hour, minute, and second, as well as toStri ng() and compa
reToO methods. Developtwo implementations: one that keepsthe time as a single
i nt value (number of seconds since midnight) and another that keeps three i nt
values, one each for seconds, minutes, and hours.
3.3.19 Vectorfields. Developa data type for forcevectors in two dimensions. Pro
vide a constructor, a method to add two vectors,and an interesting test client.
3.3.20 VIN number. Develop a data type for VIN numbers that can report back
all relevant information.

3.3 Designing Data Types
3.3.21 Generating random numbers. Develop a data type for random numbers.
(Convert StdRandom to a data type). Instead of using Math.random(), base your
data type on a linear congruential random number generator. This method traces
to the earliest days of computing and is also a quintessentialexample of the value
of maintaining state in a computation (implementing a data type). Togenerate ran
dom i nt values, maintain an i nt value x (the value of the last "random" number
returned). Each time the client asks for a new value, return a*x + b for suitably
chosen valuesof a and b (ignoring overflow). Usearithmetic to convert these val
ues to "random" values of other types of data. Assuggestedby D. E.Knuth, use the
values 3141592621 for a and 2718281829for b,or checkthe booksite for other sug
gestions. Providea constructor allowing the clientto start with an i nt valueknown
as a seed (the initial value of x). This ability makes it clear that the numbers are
not at all random (even though they may havemany of the properties of random
numbers) but that fact can be used to aid in debugging, since clients can arrange to
see the same numbers each time.
453

454
Object-Oriented Programming
IjFcafiSi^teiifils
3.3.22 Encapsulation. Is the following class immutable?
import java.util.Date;
public class Appointment
{
private Date date;
private String contact;
public Appointment(Date date)
{
// Code to check for a conflict.
this.date = date;
this.contact = contact;
}
public Date getDateO
{
return date;
}
}
Answer. No.Java's Date class is mutable.The method setDate(seconds) changes
the valueof the invokingdate to the number of milliseconds sinceJanuary 1,1970,
00:00:00 GMT. This has the unfortunate consequence that when a client gets a
date with d = getDateO, the client program can then invoke d. setDate() and
change the date in an Appoi ntment object type, perhaps creating a conflict. In a
data type, we cannot let references to mutable objects escapebecause the callercan
then modifyits state. One solution is to createa defensive copy of the Date before
returning it using new Date (date. getTi me()) ; and a defensivecopy when stor
ing it via thi s. date = new Date(date. getTi me()). Manyprogrammers regard
the mutability of Date as a Javadesign flaw. (Gregori anCal endar is a more mod
ern Java library for storing dates,but it is mutable, too.)
3.3.23 Date. Develop an implementation of Java's Date API that is immutable
and therefore corrects the defectsof the previous exercise.
3.3.24 Calendar. Develop Appointment and Calendar APIs that can be used to
keeptrack of appointments (byday)in a calendaryear. Your goalisto enableclients
to schedule appointmentsthat do not conflict and to report current appointments
to clients.

3.3 Designing Data Types
3.3.25 Vectorfield. Avector field associates avector withevery point in a Euclid
eanspace. Write a version of Potenti al (Program 3.1.7) that takes asinput a grid
size N,computes the Vector value ofthe potential dueto the point charges at each
point in an N-by-N grid of equally spaced points, and draws the unit vectorin the
direction of the accumulated field at each point. (Modify Charge to return a Vec
tor.)
3.3.26 Genomeprofiling. Writeafunction hash() thattakes asargumentafc-gram
(stringof length fc) whose characters are allA, C, G, or Tand returns an i nt value
between 0 and 4k that corresponds to treating the string as base-4 numbers with
{A, C, G, T} replacedby {0,1,2,3}, respectively, assuggested by the table in the text.
Next, write a function unhash() that reverses the transformation. Use your meth
ods to create a classGenome that is like Document, but is based on exact counting of
fc-grams in genomes. Finally, writeaversion of CompareAl 1forGenome objects and
use it to look for similarities among the set of genome files on the booksite.
3.3.27 Profiling. Pick an interesting set of documents from the booksite (or use
a collection of your own) and run CompareAl 1 with various valuesof the two pa
rameters, to learn about their effect on the computation.
3.3.28 Multimedia search. Develop profiling strategies for sound and pictures,
and use them to discoverinteresting similaritiesamong songsin the music library
and photos in the photo album on your computer.
3.3.29 Data mining. Write a recursive program that surfs the web, starting at a
pagegiven as the first command-line argument,lookingfor pages that are similar
to the page given as the second command-line argument, as follows: to process a
name, open an input stream, do a readAl1(), profileit, and print the name if its
distanceto the target pageisgreaterthan the threshold valuegivenasthe third com
mand-line argument. Then scan the page for all strings that contain the substring
http: // and (recursively) process pages with those names. Note: This program
could read a very large number of pages!
455

Object-Oriented Programming
3.4
Case Study: N-body Simulation
Severalof the examples that weconsideredin Chapters 1and 2 arebetter expressed
as object-oriented programs. For example,BouncingBal1 (Program 1.5.6)isnatu
rallyimplemented as a data type whose values are the position and the velocity
of the ball and a client that calls instance
methods to move and draw the ball. Such
„, t
_
.
.
'
,
-
itr
ii.
3.4.1
Gravitational body
460
a data type enables, for example, clients
3A2 N_bodysimulation
463
that can simulate the motion of several
_
....
,„
,
^
^..xr...
Programs in this section
balls at once (see Exercise 3.4.1). Simi
larly, our case study for Percolation in
Section 2.4 certainly makes an interesting exercise in object-oriented program
ming, as does our random surfer casestudy in Section 1.6.Weleavethe former for
an exercise (see Exercise 3.4.2) and will revisit the latter in Section 4.5. In this sec
tion, we consider a new examplethat exemplifies object-oriented programming.
Our task is to write a program that dynamically simulates the motion of N
bodies under the influence of mutual gravitational attraction. This problem was
first formulated by Newton over 350 years ago, and it is still studied intensely to
day.
What is thesetofvalues, andwhataretheoperations on those values? One rea
son that this problem is an amusing and compelling example of object-oriented
programming isthat it presents a direct and natural correspondence between phys
ical objects in the realworld and the abstract objects that we use in programming.
The shift from solving problems by putting together sequences of statements to be
executedto beginning with data type design is a difficult one for many novices.As
you gain more experience, you will appreciate the value in this approach to com
putational problem-solving.
We recalla fewbasic conceptsand equations that you learned in high school
physics. Understanding those equations fully is not required to appreciate the
code—because of encapsulation, these equations are restricted to a few methods,
and because of data abstraction, most ofthe code is intuitive and will make sense to
you. In a sense,this is the ultimate object-oriented program.

3.4 Case Study: N-Body Simulation
N-body simmlatioB
The bouncing ball simulation of Section 1.5 is based on
Newton'sfirstlawofmotion: a body in motion remains in motion at the same veloc
ity unless acted on by an outside force. Embellishing that example to include New
ton's second law of motion (which explains how outside forces affectvelocity) leads
us to a basic problem that has fascinated scientists for ages. Given a system of N
bodies, mutually affected by gravitational forces, the problem is to describe their
motion. The same basic model applies to problems ranging in scale from astro
physicsto molecular dynamics.
In 1687, Isaac Newton formulated the principles governing the motion of
two bodies under the influence of their mutual gravitational attraction, in his fa
mous Principia. However, Newton was unable to develop a mathematical descrip
tion of the motion of three bodies. It has sincebeen shown that not only is there no
such description in terms of elementary functions, but also that chaotic behavior
is possible, depending on initial values. To study such problems, scientists have
no recourse but to develop an accurate simulation. In this section, we develop an
object-oriented program that implements such a simulation. Scientists are inter
ested in studying such problems at a high degree of accuracy for huge numbers of
bodies, so our solution is only an introduction to the subject, but you are likely to
be surprised at the ease with which we can develop realistic images depicting the
complexity of the motion.
Body data type. In BouncingBall (Program 1.5.6), we keep the displacement
from the origin in the double values rx and ry and the velocity in the double
values vx and vy, and displace the ball the amount it moves in one time unit with
the statements:
rx
=
ry
=
rx
ry
vx;
vy;
r
+
\
457
With Vector (Program 3.3.3), we can keep the position in
the Vector value r and the velocity in the Vector value v,
and then displace the body the amount it moves in dt time
units with a single statement:
r = r.plus(v.times(dt));
In JV-body simulation, we have several operations of this
kind, so our first design decision is to work with Vector val
ues instead of individual component values. This decision
Adding vectors to movea ball

458
Object-Oriented Programming
leadsto code that isclearer, more compact,and more flexible than the alternativeof
working with individual components. Body (Program 3.4.1) is a Javaclassthat uses
Vector to implement a data type for moving bodies. The values of the data type
are Vector values that carry the body's position and velocity, as well as a double
value that carries the mass.The data-type operations allowclients to move and to
draw the body (and to compute the force vector due to gravitational attraction of
another body), as defined by the following API:
public class Body
Body(Vector r, Vector v, double mass)
void
move(Vector f,
double dt)
applyforce f, move bodyfor dt seconds
void
draw()
draw theball
Vector
force From(Body b)
force vector between this body andb
APIfor bodies moving under Newton s laws (seeProgram 3.4.1)
Technically, the body's position (displacement from the origin) is not a vector (it is
a point in space,not a direction and a magnitude), but it is convenient to represent
it as a Vector because Vector's operations lead to compact code for the transfor
mation that weneed to movethe body,asjust discussed.When wemove a Body, we
need to change not just its position, but alsoits velocity.
Force and motion. Newton's second law ofmotion says that the force on a body (a
vector) is equal to the scalar product of its mass and its acceleration (also a vector):
f = ma. In other words, to compute the acceleration of a body, we compute the
time t
time t+1
newposition isvector sumof
oldposition and velocity
stationary
body
Motion neara stationary body
new velocity is vector sum of
old velocityand acceleration

3.4 Case Study: N-Body Simulation
force, then divide by its mass. In Body, the force is a Vector argument f to move(),
so that we can first compute the acceleration vector just by dividing by the mass (a
scalar value that is kept as a doubl e value in an instance variable) and then com
pute the change in velocityby adding to it the amount this vector changes over the
time interval (in the same wayasweused the velocityto changethe position). This
law immediately translates to the followingcode for updating the position and ve
locity of a body due to a given force vector f and amount of time dt:
Vector a = f.times(l/mass);
v = v.plus(a.times(dt));
r = r.plus(v.times(dt));
This code appears in the move() instance method in Body, to adjust its values to
reflect the consequences of that force being applied for that amount of time: the
body moves and its velocitychanges.This calculation assumesthat the acceleration
is constant during the time interval.
459
Forces among bodies. The computation of the force im
posed by one body on another isencapsulated in the instance
method forceFromO in Body, which takes a Body object as
argument and returns a Vector. Newton's law of universal
gravitation isthe basisfor the calculation:it says that the mag
nitude of the gravitational force between two bodies is given
by the product of their masses divided by the square of the
distance between them (scaled by the gravitational constant
G,which is 6.67 x 1011 N m2/ kg2) and that the direction of
the force is the line between the two particles. This lawtrans
lates to the followingcode for computing a. forceFrom(b):
double G = 6.67e-ll;
Vector delta = a.r.minus(b.r);
double dist = delta.magnitudeO;
double F = (G * a.mass * b.mass) /
(dist * dist);
return delta.directi on().times(F);
The magnitude of the force vector is the double value F, and the direction of the
force vector is the same as the direction of the difference vector between the two
body's positions. The force vector is the product of magnitude and direction.
unit vector
magnitude offorce is
Forcefrom one body toanother

460
Object-Oriented Programming
IB
Si
il
.••••f^'J
i
Program 3.4.1
Gravitational body
f
dt
forceon thisbody
time increment
acceleration
public class Body
{
private Vector
r;
private Vector v;
private final double mass;
public Body(Vector rO, Vector vO,
double mO)
{
r = rO;
v = vO; mass = mO;
}
public void move(Vector f, double dt)
{
// Update position and velocity.
Vector a = f.times(1/mass);
v = v.plus(a.times(dt));
r = r.plus(v.times(dt));
}
public Vector forceFrom(Body b)
{
// Compute force on this body from b.
Body a = this;
double G = 6.67e-ll;
Vector delta = a.r.minus(b.r);
double dist = delta.magnitudeO;
double F = (G * a.mass * b.mass)
/
(dist * dist);
retu rn delta.di recti on().ti mes(F);
}
"^^^^^^^P^^^^^s^
a
b
G
delta
dist
F
public void draw()
{
StdDraw.setPenRadius(0.025);
StdDraw.poi nt(r.cartesi an(0),
r.cartesi an(1));
}
thisbody
anotherbody
gravitational constant
vectorfrom b toa
distancefrom b toa
magnitude offorce
Thisdata typeprovides theoperations thatwe needtosimulatethemotionofphysicalbodies
such asplanetsoratomicparticles. It is a mutable type whose instance variables aretheposi
tion andvelocity ofthebody, which change inthe move() method in response toexternalforces
(thebody's mass is notmutable). The force From() method returns aforcevector.

3.4 Case Study: N-Body Simulation
Universe data type. Uni verse (Program3.4.2) isa data typethat implementsthe
followingAPI:
public class Universe
UniverseO
void
increaseTime(double dt)
void
draw()
APIfor a universe {see Program 3.4.2)
simulate thepassing ofdt seconds
draw the universe
Its data-type values define a universe (its size,number of bodies, and an array of
bodies) and two data-type operations: increaseTi me (), which adjusts the posi
tions (and velocities) ofall ofthe bodies, and draw(), which draws all ofthe bodies.
The key to the N-body simulation is the implementation of increaseTi me () in
Universe. The first part of the computation is a double loop that computes the
forcevector that describesthe gravitationalforceof eachbody on each other body.
It applies the principle of superposition^ which says
that we can add together the forcevectors affectinga
body to get a singlevector representing allthe forces.
After it has computed all of the forces, it calls the
move() operation for each body to apply the com
puted force for a fixedtime quantum.
% more 2body.txt
2
5.0el0
O.OeOO
4.5el0
1.0e04 0.
O.OeOO -4.5el0 -1.0e04
0.
% more 3body.txt
3
1.25ell
O.OeOO
O.OeOO 0.05e04 0.
O.OeOO
4.5el0
3.0e04
0.
O.OeOO -4.5el0 -3.0e04 0.
% more 4body.txt
E— N
I 5.0el0|^— radius
-3.5elO O.OeOO O.OeOO j 1.4e03|3.0e28
-l.OelO O.OeOO[0T0e00~
l.OelO O.OeOO 0.OeOO
I 3.5elO O.OeOOl0.OeOO
velocity
OeOO
OeOO
OeOO
OeOO
OeOO
461
5e30
5e30
97e24
989e30
989e30
\
Vile format. As usual, we use a data-driven design
with input taken from standard input. The construc
tor reads the universe parameters and body descrip
tions from a filethat contains the following informa
tion:
• The number of bodies
• The radius of the universe
• The position, velocity, and mass of eachbody
As usual, for consistency, all measurements are in
standard SI units (recall also that the gravitational
constant G appears in our code). With this defined
file format, the code for our Uni verse constructor is
straightforward.
1.4e04|3.0e28
1.4e04 3.0e28
1.4e03 3.0e28
t
position
Universefile format examples

462
Object-Oriented Programming
public UniverseO
{
N = Stdln.readlntO;
radius = Stdln.readDoubleO;
StdDraw.setXscale(-radi us, +radi us);
StdDraw.setYscale(-radius, +radius);
orbs = new Body[N];
for (int i =0;
i
< N; i++)
{
double rx = Stdln.readDoubleO;
double ry = Stdln.readDoubleO;
doubled
position = { rx,
ry };
double vx = Stdln.readDoubleO;
double vy = Stdln.readDoubleO;
doubled velocity = { vx, vy };
double mass = Stdln.readDoubleO;
Vector r = new Vector(position);
Vector v = new Vector(velocity);
orbs[i] = new Body(r, v, mass);
}
}
Each Body isdescribed by fivedoubl e values:the x and y coordinates ofits position,
the x and y components of its initial velocity, and its mass.
To summarize, wehavein the test client mai n() in Uni verse a data-driven program
that simulates the motion of N bodies mutually attracted by gravity.The construc
tor creates an array of N Body objects, reading each body's initial position, initial
velocity, and mass from standard input. The increaseTi me() method calculates
the mutual force on the bodies and uses that information to update the accelera
tion, velocity,and position of each body after a time quantum dt. The main() test
client invokes the constructor, then stays in a loop calling increaseTi me() and
draw() to simulate motion.
Youwill find on the booksite a variety of files that define "universes" of all
sorts, and you are encouraged to run Universe and observe their motion. When
you view the motion for even a small number of bodies, you will understand why
Newton had trouble deriving the equations that define their paths. The images on
the chapter openings for Chapters 2, 3, and 4 of this book show the result of run
ning Uni verse for the 2-body, 3-body,and 4-body examples in the data filesshown
here. The 2-body example is a mutually orbiting pair, the 3-body example is a cha-

3.4 Case Study: N-Body Simulation
Program 3.4.2
N-hody simulation
public class Universe
{
private final
double radius;
private final int N;
private final
Body[] orbs;
public UniverseO
{
/* See text. */
}
public void increaseTime(double dt)
{
Vector[]
f
= new Vector[N];
for (int i
= 0;
i
< N; i++)
f[i]
= new Vector(new double[2]);
for (int i
= 0;
i
< N; i++)
for (int j
= 0;
j
< N; j++)
if (i
!= j)
f[i]
= f[i].plus(orbs[i].forceFrom(orbs[j]));
for (int i
= 0;
i
< N; i++)
orbs[i].move(f[i], dt);
}
radius
N
orbs[]
463
radiusof universe
number of bodies
arrayof bodies
% java Universe 20000 < 3body.txt
880 steps
public void draw()
{
for (int i
= 0;
i
< N; i++)
orbs[i].draw();
}
public static void main(String[] args)
{
Universe newton = new UniverseO;
double dt = Double.parseDouble(args[0]);
while (true)
^^^^^^^^^^^^^^^^^^^s^^^
{
StdDraw.clear();
newton.increaseTime(dt);
newton.draw();
StdDraw.show(10);
}
}
This data-driven program simulates motion in the universe defined by the standard input
stream, increasing timeat therate specified on thecommand line.
I
mm.

464
Object-Oriented Programming
otic situation with a moon jumping between two orbiting planets, and the 4-body
example is a relativelysimple situation where two pairs of mutually orbiting bodies
are slowlyrotating. The static images on these pages are made by modifying Uni
verse and Body to draw the bodies in white, and then black on a gray background,
as in BouncingBal1 (Program 1.5.6): the dynamic images that you get when you
run Uni verse as it stands givea realisticfeelingof the bodies orbiting one another,
which is difficult to discern in the fixed pictures. When you run Universe on an
example with a large number of bodies, you
can appreciate why simulation is such an
planetaryscale
important tool for scientists trying to un-
%more 2bodv-txt
derstand a complex problem. The N-body
Qel0
simulation model is remarkably versatile, as
0.Oeoo
4.5eio l. 0e04 o.Oeoo l. 5e30
you will see if you experiment with some of
O.OeOO -4.5eio -i.0e04 O.OeOO i.5e30
these files.
, ,
.
subatomic scale
You will certainly be tempted to design
0/
,.
. _.
7
r
°
% more 2bodyTiny.txt
your own universe (see Exercise 3.4.7). The
2
biggestchallengein creating a data fileis ap-
5.Oe-io
propriately scaling the numbers so that the
°•0e0°
4.5e-io l.0e-i6 o.Oeoo l. 5e-30
radius of the universe, time scale, and the
°-0e00 -4-5e"10 -1"06-16 °-0e00 1-5e"30
mass and velocity of the bodies lead to in
teresting behavior. You can study the motion of planets rotating around a sun or
subatomic particles interacting with one another, but you will have no luck study
ing the interaction of a planet with a subatomic particle. When you work with your
own data, you are likely to have some bodies that will fly off to infinity and some
others that will be sucked into others, but enjoy!
Our purpose in presenting this example isto illustrate the utility ofdata types,
not present simulation code for production use. There are many issues that scien
tists have to deal with when using this approach to study natural phenomena. The
first is accuracy: it is common for inaccuracies in the calculations to accumulate to
present dramatic effects in the simulation that would not be observed in nature.
For example, our code takes no special action when bodies collide. The second is
efficiency: the move() method in Universe takes time proportional to N2 and is
therefore not usable for huge numbers of bodies. As with genomics, addressing
scientific problems related to the N-body problem now involvesnot just knowledge
of the original problem domain, but also understanding core issues that computer
scientists have been studying since the early days of computation.

3.4 Case Study: N-Body Simulation
For simplicity,we are working with a two-dimension
aluniverse, whichis realistic onlywhen weare considering
bodies in motion on a plane. But an important implication
of basing the implementation of Body on Vector is that a
client could use three-dimensional vectors to simulate the
motion of moving balls in three dimensions (actually, any
number of dimensions) without changing the code at all!
The draw() method projects the position onto the plane
defined by the first two dimensions.
The test client in Universe is just one possibility:we
can use the same basic model in all sorts of other situations
(for example, involving different kinds of interactions
among the bodies). One such possibility is to observe and
measure the current motion of some existing bodies and
then run the simulation backwards! That is one method
that astrophysicists use to try to understand the origins of
the universe. In science,we try to understand the past and
to predict the future; with a good simulation, we can do
both.
465
java Universe 25000 < 4body.txt
100 steps
500 steps
1000 steps
3000 steps
Simulating a 4-body universe

466
Object-Oriented Programming
Q. The Universe API is certainly small. Why not just implement that code in a
mai n() test client for Body?
A. Well, our design is an expression of what most people believe about the uni
verse: it was created, and then time moves on. It clarifies the code and allows for
maximum flexibilityin simulating what goes on in the universe.
Q. Why is forceFrom() an instance method? Wouldn't it be better for it to be a
static method that takes two Body objects as arguments?
A. Yes, implementing forceFrom() as an instance method is one of several pos
sible alternatives, and having a static method that takes two Body objects as argu
ments is certainly a reasonable choice. Some programmers prefer to completely
avoid static methods in data-type implementations; another option is to maintain
the force acting on each Body as an instance variable. Our choice is a compromise
between these two.

3.4 Case Study: N-Body Simulation
3.4.1
Write an object-oriented version of BouncingBall (Program 1.5.6). In
clude a constructor that starts each ball moving a random direction at a random
velocity (within reasonable limits) and a test client that takes an integer Nfrom the
command line and simulates the motion of Nbouncing balls.
3.4.2
Write an object-oriented version of Percol ati on (Program 2.4.5). Think
carefullyabout the design before you begin,and be prepared to defend your design
decisions.
3.4.3
What happens in a universe where Newton's second law does not apply?
This situation would correspond to forceToO in Body always returning the zero
vector.
3.4.4
Create a data type Uni verse3D to model three-dimensional universes. De
velop a data file to simulate the motion of the planets in our solar system around
the sun.
3.4.5
Modify Universe so that its constructor takes an In object and a Draw
object as arguments. Write a test client that simulates the motion of two different
universes (defined by two different files and appearing in two different Draw win
dows).Youalso need to modify the draw() method in Body.
3.4.6
Implement a class RandomBody that initializes its instance variables with
(carefully chosen) random valuesinstead of usinga constructor and a client Ran-
domUni verse that takes a single argument ATfrom the command line and simulates
motion in a random universe with N bodies.
467

468
Object-Oriented Programming
3.4.7
Newuniverse. Design a new universe with interesting properties and simu
late its motion with Uni verse. This exerciseis truly an opportunity to be creative!

3.4 Case Study: N-Body Simulation
469

ifilfe|iiiftii^ii|
PS5^|^^I%, ifi?^f^SpP%, Pil3^gif|i»
:
•••V-:
i&
4-...>
f\
*••:•
a-.
•
W\
.Cl-'
^5PP^^^^?S|:
^JP?P^^PPp^^"

Algorithms and Data Structures
4.1
Performance
472
4.2
Sorting and Searching
510
4.3
Stacks and Queues
550
4.4
Symbol Tables
608
4.5
Case Study: Small World
650
In this chapter, weDiscuss the fundamental data typesthat are essentialbuilding
blocks for a broadvariety of applications. Thischapter isa guide to usingthem,
whether youchoose to useJava libraryimplementations or choose to develop your
own variations based on the code givenhere.
Objects can contain references to other objects, so we can build structures
known as linked structures, which can be arbitrarily complex. With linked struc
tures and arrays, we can build data structures to organize information in such a
way that wecan efficiently process it with associated algorithms. In a data type,we
usethe setofvalues to builddatastructures and the methodsthat operateon those
valuesto implement algorithms.
Thealgorithmsand data structuresthat weconsider in thischapterintroduce
a bodyof knowledge developed overthe past 50years that constitutes the basisfor
the efficient use of computers for a broad variety of applications. From N-body
simulation problems in physics to geneticsequencing problems in bioinformatics,
the basic methods we describe have become essential in scientific research; from
database systemsto search engines,these methods are the foundation of commer
cial computing.As the scope of computing applications continues to expand, so
grows the impact ofthese basic methods.
Algorithms and data structures themselves are valid subjects of scientific
study. Accordingly, we begin by describing a scientific approach for analyzing the
performanceof algorithms, whichweusethroughout the chapterto studythe per
formance characteristics of our implementations.
471

Algorithms and Data Structures
4.1
Performance
In this section, you will learn to respect a principle that is succinctlyexpressedin
yetanother mantra that shouldlive withyou wheneveryou program: Pay attention
tothe cost. Ifyou become an engineer, that
willbeyourjob;ifyoubecomeabiologist
4JJ 3.sumproblem ;
475
ora physicist, the cost will dictate which
4<L2 Validating adoubling hypothesis. .477
scientific problems you can address; if
n
. +7.
..
v
7
y
Programs in thissection
you are in business or become an econo
mist, this principle needs no defense;and
if you become a software developer, the costwilldictatewhetherthe software that
you build willbe usefulto anyof your clients.
Tostudythe costof running them,westudy our programs themselves viathe
scientific method, the commonlyaccepted body of techniques universally used by
scientiststo developknowledge about the natural world.Wealsoapply mathemati
calanalysis to derive concisemodels of the cost.
What features of the natural world are we studying? In most situations, we are
interested in one fundamental characteristic: time. On each occasion that we run
a program, we are performing an experimentinvolving the natural world, putting
a complexsystemof electronic circuitrythrough seriesof state changesinvolving
a huge number of discrete events that we are confident will eventually stabilize
to a state with results that we want to interpret. Although developed in the ab
stract world of Javaprogramming, these events most definitely are happening in
the natural world. What will be the elapsed time until we see the result? It makes
a great deal of difference to us whether that time is a millisecond, a second,a day,
or a week, and therefore we want to learn, through the scientific method, how to
properly control the situation, just as when we launch a rocket,build a bridge, or
smash an atom.
On the one hand, modern programs and programming environments are
complex; on the other hand, they are developed from a simple (but powerful) set
of abstractions. It is a small miracle that a program produces the same result each
time we run it. Topredict the time required, we take advantage of the relativesim
plicityof the supporting infrastructurethat we use to build programs.You maybe
surprised at the ease with which you can develop cost estimates for many of the
programs that you write.

4.1
Performance
Scientific method The following five-step approach briefly summarizes thescien
tific method.
• Observe some feature of the natural world.
• Hypothesize a model that is consistent with the observations.
• Predict eventsusing the hypothesis.
• Verify the predictions by makingfurther observations.
• Validate byrepeating until the hypothesis and observations agree.
One of the keytenets of the scientific methodis that the experiments we design
must be reproducible, so that otherscanconvince themselves of the validity of the
hypothesis. In addition,the hypotheses weformulate mustbefalsifiable, sothat we
canknowfor surewhen a hypothesis iswrong(and thus needsrevision).
Observations
Ourfirst challenge isto make quantitative measurements ofthe
running time of our programs. Although measuring the exact running time of our
program is difficult, usuallywe are happy with approximateestimates. There are a
number of tools available to help us obtain such ap
proximations. Perhaps the simplestis a physical stop
watchor the Stopwatch (see Program3.2.2) datatype.
Wecan simplyrun a program on variousinputs, mea
suring the amount of time to process eachinput.
Our firstqualitative observationabout mostpro
grams is that there is a problem sizethat characterizes
the difficulty of the computationaltask. Normally, the
problem sizeis either the sizeof the input or the value
of a command-line argument. Intuitively, the running
time should increase with the problem size, but the
question of how much it increases naturally arises ev
ery time we developand run a program.
Another qualitative observation for many pro
grams is that the running time is relatively insensitive
to the input itself; it dependsprimarilyon the problem
size. If this relationship does not hold, we need to run more experiments to better
understand, and perhaps better control,the running time'ssensitivity to the input.
Since this relationshipdoesoftenhold,wefocus nowon the goalofbetter quantify
ing the correspondencebetweenproblem sizeand running time.
473
% Java ThreeSum < lKints.txt
tick tick tick
0
% Java ThreeSum < 2Kints.txt
>
tick tick tick tick tick tick
tick tick tick tick tick tick
tick tick tick tick tick tick
tick tick tick tick tick tick
391930676 -763182495
371251819
-326747290 802431422
-475684132
Observing therunning timeofaprogram

474
Algorithms and Data Structures
As aconcrete example,westartwithThreeSum (Program 4.1.1), which counts
the numberof triples in a setofN numbers that sum to 0.Thiscomputationmay
seem contrived toyou, but it isdeeply related to numerous fundamental computa
tionaltasks, particularlythose found incomputational geometry, soit isaproblem
worthy of careful study. What isthe relationship between the problem size N and
running time for ThreeSum?
Hypotheses
In theearly days ofcomputer science, Donald Knuth showed that,
despite allof the complicating factors in understanding the running times of our
programs, it ispossible in principle to create accurate models that canhelp uspre
dictprecisely how longa particular program will take. Proper analysis ofthissort
involves:
• detailed understanding of the program
• detailedunderstanding of the systemand the computer
• advanced tools of mathematical analysis
and so isbestleftfor experts. Butevery programmer needs to knowback-of-the-
envelope performance estimates. Fortunately, we canoftenacquire suchknowledge
byusing a combination ofempirical observations anda small setofmathematical
tools.
Doubling hypotheses. For a great many programs, we can quickly formulate a
hypothesis forthefollowing question: What isthe effect on the running time ofdou
bling the size ofthe input? Forclarity, werefer to this hypothesis as a doubling hy
pothesis. Perhaps the easiest way to payattention to the costis to askyourself this
question about your programs during development and also as you use them in
practical applications. Next, we describe how to develop answers viathe scientific
method.
Empirical analysis. Onesimple wayto develop adoubling hypothesis isto double
the size of the input and observe the effect on the running time.Forexample, Dou-
blingTest (Program 4.1.2) generates a sequence of random input arrays for
ThreeSum, doubling the array size at each step, and prints the ratio of running
timesof ThreeSum. count () for eachinput overthe previous (whichwasone-half
the size). If you run this program, you will find yourself caught in a prediction-
verification cycle: It prints several linesveryquickly, but then beginsto slowdown.
Eachtime it prints a line,you find yourselfwondering how long it willbe until it

4.1
Performance
475
f
I
•!v.,:<
Si
public class ThreeSum
{
public static void printAll(int[] a)
{
/* See Exercise 4.1.1.
V
}
public static int count(int[] a)
{
// Count triples that sum to 0.
int N = a.length;
int cnt = 0;
for (int i
= 0;
i
< N; i++)
for (int j = i+1;
j < N; j++)
for (int k = j+1;
k < N; k++)
if (a[i] + a[j] + a[k]
== 0)
cnt++;
return cnt;
}
public static void main(String[] args)
{
// Count triples that sum to 0 in input.
int[]
a = StdArraylO.readlntlDO;
int cnt = count(a);
StdOut.println(cnt);
if (cnt < 10) printAll(a);
}
N
a[]
cnt
number of inputs
integerinputs
number of triples
that sum to 0
The count () method counts the triples of integers in a[] whose sum is 0. The test client in
vokes count () forthe integers onstandard input and prints the triples if the count islow. The
fileIKints. txt contains 1,024 random valuesfrom the i nt data type. Such afileisnotlikely
tohavesuch a triple (seeExercise 4.1.28).
% Java ThreeSum < 8ints.txt
30 -30
0
30
-20 -10
-30 -10
40
-10
0
10
% Java ThreeSum < lKints.txt
0
6
^m^^^^mm^^^^mmm^^^^mmm

476
Algorithms and Data Structures
prints the next line. Checkingthe stopwatchas the program runs, it is easyto pre
dict that the elapsed time increases by about a factor
of eight to print each line. This prediction is verified
by the Stopwatch measurements that the program
prints, and leads immediatelyto the hypothesis that
the running time increases by a factor of eight when
the input sizedoubles.Wemight alsoplot the running
times, either on a standard plot (left), which clearly
shows that the rate of increase of the running time
increases with input size,or on a log-log plot. In the
caseofThreeSum, the log-logplot (below) is a straight
linewith slope3,whichclearlysuggests the hypothesis
that the running time satisfies apower law of the form
cN3 (see Exercise 4.1.30).
Standard plot
Mathematical analysis. Knuth's basic insight on building a mathematical model
to describe the running time of a program is simple: the total running time is de
termined by two primary factors:
• The cost of executing each statement
• The frequency of executionof eachstatement
The former is a property of the system, and the latter is a
property of the algorithm. If we know both for all instruc
tions in the program, wecanmultiplythem together and sum
for all instructions in the program to get the running time.
The primary challenge isto determinethe frequencyof
execution ofthe statements. Some statements are easy to ana
lyze: for example,the statement that sets cnt to 0 in Three-
Sum, count() is executed only once. Others require higher-
levelreasoning: for example, the if statement in ThreeSum.
count() is executed preciselyN(N-l)(N-2)/6 times (that
is preciselythe number of ways to pick three different num
bers from the input array—seeExercise 4.1.4).
Frequencyanalyses of this sort can lead to complicated
and lengthy mathematical expressions. Tosubstantially sim
plify matters in the mathematical analysis, we develop sim
pler approximate expressionsin twoways. First,wework with
Log-logplot

4.1
Performance
477
?S8
w
Program 4.1.2
Validating a doubling hypothesis
public class DoublingTest
{
public static double timeTrial(int N)
{
// Compute time to solve a random instance of size
int[]
a = new int[N];
for (int i
= 0;
i
< N; i++)
a[i]
= StdRandom.uniform(2000000)
-
1000000;
Stopwatch s = new Stopwatch();
int cnt = ThreeSum.count(a);
return s.elapsedTime();
}
public static void main(String[] args)
{
// Print table of doubling ratios.
double prev = timeTrial(256);
for (int N = 512; true;
N += N)
{
// Print doubling ratio for problem size
double curr = timeTrial(N);
Std0ut.printf("%7d %4.2f\nM,
N, curr /
prev);
prev
= curr;
}
}
This program prints a table showing how doubling the problem sizeaffects therunning time
ofTh reeSum.count () forproblem sizes starting at256 anddoublingfor each rowofthetable.
These experiments lead immediately to the hypothesis that the running time increases by a
factor ofeight when theinput size doubles. When yourun the program, note carefully thatthe
elapsed time between lines printed increases by afactor ofeightforeach line, at once verifying
thehypothesis.
% Java Doubling Iest
512 6.48
1024 8.30
2048 7.75
4096 8.00
8192 8.05
'^^^^^^^^^^^^^^^P^^iS^^^^^^^

478
Algorithms and Data Structures
public class ThreeSum
117.
r
^
.
1
{
the leading term of mathematical ex-
pubiic static int count(int[] a)
pressions by using a mathematical
device known as the tilde notation.
We write ~/(N) to represent any
quantity that, when divided by/(N),
approaches 1 as AT grows. We also
write g(N)~f(N) to indicate that
g(N) /f(N) approaches 1asN grows.
With this notation, we can ignore
complicated parts of an expression
that represent small values. For ex
ample, the i f statement in ThreeSum
is
executed
~N3/6
times because
N(N-l)(N-2)/6 = N3/6 - N2/2 +
N/3, which certainly,when divided by
N3/6, approaches 1 as N grows. This
notation is useful when the terms af
ter the leading term are relativelyin
significant (for example,when JV = 1000, this assumption amounts to sayingthat
—N2/2 + N/3 « —499,667 is relatively insignificant by comparison with N3/6 »
166,666,667, which it is). Second, we focus on the instructions that are executed
most frequently, sometimes referred to as the inner loop of the program. In this
program it is reasonable to assume that the time devoted to the instructions outside
the inner loop is relativelyinsignificant.
The key point in analyzingthe running time of a program is this: for a great
many programs, the running time satisfies the relationship
T(N) - cf(N)
where c is a constant and/(N) a function known
as the order of growth of the running time. For
typical programs,/(N) isa function such aslogN,
N, N log N, N2, or N3, as you will soon see (cus
tomarily, we express order-of-growth functions
without any constant coefficient). When/(N) is
a power of N, as is often the case, this assump
tion is equivalent to saying that the running time
satisfiesa power law.In the case ofThreeSum,it is
inner
loop
}
int N = a.length;
int cnt = 0;
for (int i
= 0;
i
< N; i++)
-i
for (int j
= i+1;
j
< N; j++)
-i— h
\
for (int k = j+1;
k < N; k++)
k|
if (a[ij + a[;j]
+ a[k] == 0)\--
cnt++; ^
\
return cnt;
\
depends on input data
•N2/2
•NV6
public static void main(String[] args)
{
int[] a = StdArraylO.readlntlDO;
int cnt = count(a);
StdOut.println(cnt);
}
Anatomy ofaprogram's statement executionfrequencies
N(N- l)(N-2)/6
166,167,000
1,000
Leading-term approximation

4.1
Performance
a hypothesis already verified by our empirical observations: theorder ofgrowth of
the running timeofThreeSum is N3. The value of the constant c depends both on
the cost of executing instructions and on details of the frequency analysis,but we
normally do not need to work out the value, as you will now see.
The order of growth is a simple but powerful model of running time. For
example, knowing the order of growth typically leads immediately to a doubling
hypothesis.In the caseof ThreeSum, knowingthat the order of growth isN3 tellsus
to expect the running time to increase by a factor of eight when we double the size
of the problem because
T(2N)/T(N) -> c(2N)3/(cN3) = 8
This matches the value resulting from the empirical analysis,thus validating both
the model and the experiments. Study this example carefullyy becauseyou canusethe
same method to better understand the performance ofanyprogram thatyou write.
Knuth showed that it is possible to develop an accurate mathematical model
of the running time of anyprogram, and manyexpertshavedevotedmuch effort to
developing such models. But you do not need such a detailed model to understand
the performance of your programs: it is typically safeto ignore the cost of the in
structions outside the inner loop (becausethat cost is negligibleby comparison to
the cost of the instruction in the inner loop) and not necessaryto know the value
of the constant in the running-time approximation (because it cancels out when
you use a doubling hypothesis).
number of
time per instruction
instructions
in seconds
frequency
total time
6
4
4
10
2xl0-9
N3/6 - N2I2 + N/3
(2N3 - 6N2 + 4N) x 10"9
3xl0"9
NV2-N/2
(6N2 + 6N)xlO"9
3xl0"9
N
(12N)xlO"9
lxlO"9
1
lOxlO"9
grand total:
(2 N3 + 22 N + 10) X 10 "9
tilde notation
(2 N3) X 10 ~~9
order ofgrowth
N3
Analyzingtherunningtimeofaprogram (example)
479

480
Algorithms and Data Structures
These approximations are significantbecause they relate the abstract world of
a Javaprogram to the realworld of a computer running it. The approximations are
such that characteristics of the particular machine that you are using do not play a
significantrole in the models—we separate the algorithm from the system. The or
der of growth of the running time of ThreeSum is N3 does not depend on whether
it is implemented in Java, or whether it is running on your laptop, someone else's
cellphone, or a supercomputer; it depends primarily on the fact that it examines
all the triples. The properties of the computer and the system are all summarized
in various assumptions about the relationship between program statements and
machine instructions, and in the actual running times that we observe as the basis
for the doubling hypothesis.The algorithm that you are using determines the order
of growth. This separation is a powerful concept because it allows us to develop
knowledge about the performanceof algorithmsand then apply that knowledgeto
anycomputer.In fact,much of the knowledge about the performance of classic al
gorithms wasdevelopeddecades ago,but that knowledge is stillrelevant to today's
computers.
Empirical and mathematical analyses like those we have described constitute a mod
el (an explanation of what is going on) that might be formalized by listing all of
the assumptions mentioned (eachinstruction takesthe same amount of time each
time it is executed,running time has the givenform, and so forth). Not many pro
grams are worthy of a detailedmodel,but you need to havean idea of the running
time that you might expect for everyprogram that you write. Payattention to the
cost Formulating a doubling hypothesis—through empirical studies, mathemati
cal analysis, or (preferably) both—is a good wayto start. This information about
performance is extremelyuseful, and you willsoon find yourselfformulating and
validatinghypotheseseverytime you run a program. Indeed, doing so isa good use
of your time while you wait for your program to finish!
Order ofgrowth classifications
We usejustafew structuralprimitives (state
ments, conditionals, loops, and method calls)to build Javaprograms, so very often
the order of growth of our programs is one of just a fewfunctions of the problem
size,summarized in the table on the next page.These functions immediately lead to
a doubling hypothesis, which we can verifyby running the programs. Indeed, you
have been running programs that exhibit these orders of growth, as you can see in
the following brief discussions.

4.1
Performance
Constant. A program whose running time's order of growth is constant executesa
fixednumber of statements to finish its job; consequentlyits running time does not
depend on the problem size.Our firstseveralprograms in Chapter 1—such as Hel-
loWorld (Program 1.1.1) and LeapYear (Program 1.2.4)—fall into this classifica
tion. They each execute several statements just once. All of Java's operations on
primitive types take constant time, asdo Java's Math library functions. Note that we
do not specifythe sizeof the constant. For example, the constant for Math. tan () is
somewhat larger than for Math. abs ().
481
Logarithmic. A program whose running time's
order of growth is logarithmic is barely slower than
a constant-time program. The classic example of a
program whose running time is logarithmic in the
problem size is looking up an entry in an ordered
table, which we consider in the next section (see
BinarySearch, in Program 4.2.3). The base of the
logarithm is not relevant with respect to the order of
growth (since all logarithms with a constant base are
related by a constant factor), so we use log JV when
referring to order of growth. Occasionally, we write
more precise formulas using lgJV (base 2, or binary
log) or InJV (base e> or natural log) becausetheyboth
arise naturally when studying computer programs.
For example, lgJV, rounded up, is the number ofbits
in the binary representation of JV, and In N arises in
the analysis of binary search trees (see Section 4.4).
order ofgrowth
description
function
factorfor
doubling
hypothesis
constant
1
logarithmic
log JV
linear
JV
linearithmic
JVlog JV
quadratic
cubic
exponential
JV2
N3
2N
1
Commonly encountered growth functions
Linear. Programs that spend a constant amount of time processing each piece
of input data, or that are based on a single for loop, are quite common. The or
der of growth of such a program is said to be linear—its running time is directly
proportional to the problem size. Average (Program 1.5.3), which computes the
average of the numbers on standard input, is prototypical, as is our code to shuffle
the entries in an array in Section 1.4. Filters such as PlotFilter (Program 1.5.5)
also fall into this classification,as do the various image-processing filters that we
considered in Section 3.2, which perform a constant number of arithmetic opera
tions per input pixel.

482
time
I
1024T
512T
64T -
8T -
4T •
2T •
T
Algorithms and Data Structures
Linearithmic. Weuse the term linearithmic to describeprograms whose running
time for a problem of size JV has order of growth JV log N. Again,the base of the
logarithm is not relevant. For example, CouponCollector (Program 1.4.2) is lin
earithmic. The prototypical example is mergesort (see Program 4.2.6). Severalim
portant problems have natural solutions that are quadratic but clever algorithms
that are linearithmic. Such algorithms (including mergesort) are criticallyimpor
tant in practice because they enable us to address problem sizes far larger than
could be addressed with quadratic solutions. In the next section, we consider a
general design technique for developing
linearithmic algorithms.
Quadratic. A typical program whose
running time has order of growth JV2
has two nested for loops, used for some
calculation involving all pairs of JV ele
ments. The force update double loop in
NBody (Program 3.4.2) is a prototype of
the programs in this classification, as is
the elementary sorting algorithm Inser-
tion (Program 4.2.4).
Cubic. Our example for this section,
ThreeSum, is cubic (its running time has
order of growth JV3) because it has three
nested for loops, to process all triples of
JV elements. The running time of matrix
multiplication, as implemented in Sec
tion 1.4 has order of growth M3 to mul
tiply two M-by-M matrices, so the basic matrix multiplication algorithm is often
considered to be cubic. However,the sizeof the input (the number ofentries in the
matrices) is proportional to JV = M2, so the algorithm is best classified as JV3/2, not
cubic.
—\
1
1
r~
IK
2K
4K
8K
Orders ofgrowth (log-logplot)
constant
n
r
1024K
Exponential. As discussed in Section 2.3, both TowersOfHanoi (Program 2.3.2)
and GrayCode(Program 2.3.3)haverunning times proportional to 2Nbecause they
process all subsets of JV elements. Generally, we use the term "exponential" to refer

4.1
Performance
483
to algorithmswhoseorder of growthis bN for anyconstant b> 1,eventhough dif
ferentvaluesof blead to vastlydifferentrunning times.Exponentialalgorithms are
extremely slow—you willnever run one of them for a largeproblem. They play a
critical role in the theory of algorithmsbecause there exists a large class of prob
lems for which it seemsthat an exponential algorithm is the best possible choice.
Theseclassifications are the mostcommon, but certainlynot a complete set.Indeed,
the detailedanalysis of algorithmscan requirethe fullgamut of mathematical tools
that have been developed over the centuries. Understanding the running time of
programs such as Factor (Program 1.3.9), PrimeSieve (Program 1.4.3) and Eu-
cl i d (Program 2.3.1),requires fundamental resultsfrom number theory. Standard
algorithms like BST (Program 4.4.3) require carefulmathematical analysis.Newton
(Program 2.1.1) and Markov (Program 1.6.3)are prototypes for numerical compu
tation: their running time is dependent on the rate of convergence of a computa
tion to a desired numerical result. Simulations such as Gambler (Program 1.3.8)
and its variants are of interest preciselybecausedetailed mathematical models are
not alwaysavailable.
But a great many of the programs that you will write have straightforward
performance characteristics that can be accurately described by one of the orders
of growth that we have considered. Accordingly, we can usually work with simple
higher-level hypotheses, such as theorder ofgrowth oftherunning timeof mergesort
is linearithmic. For economy, we abbreviate such a statement to just say mergesort
is linearithmic. Most of our hypotheses about cost are of this form, or of the form
mergesort isfaster than insertion sort. Again,a notable feature of such hypotheses is
that they are statements about algorithms, not just about programs.
Predictions
You can always try to learn the running time of a program by sim
ply running it, but that might be a poor way to proceed when the problem size
is large. In that case,it is analogous to trying to learn where a rocket will land by
launching it, how destructive a bomb willbe by igniting it, or whether a bridge will
stand by building it.
Knowing the order ofgrowth ofthe running time allowsus to make decisions
about addressing large problems so that we can investwhatever resources we have
to deal with the specific problems that we actually need to solve.We typically use
the resultsof verifiedhypothesesabout the order of growth of the running time of
programs in one of the following four ways.

484
Algorithms and Data Structures
Estimating thefeasibility ofsolving largeproblems. To payattention to the cost,
you need to answerthis basicquestion for everyprogram that you write: Will this
program beable toprocess this input data in a reasonable amount of time? For ex
ample, a cubic algorithm that runs in a couple of seconds for a problem of sizeJV
will require a few weeks for a problem of size 100JV because it will be a million
(1003) times slower, and a couple of million
seconds is a few weeks. If that is the size of
the problem that you need to solve,you have
to find a better method. Knowing the order
of growth of the running time of an algo
rithm provides precisely the information
that you need to understand limitations on
the size of the problems that you can solve.
Developingsuch understanding is the most
important reason to study performance.
Without it, you are likely have no idea how
much time a program willconsume; with it,
you can make a back-of-the-envelope calcu
lation to estimate costs and proceed accord
ingly.
order ofgrowth
predicted running timeif
problem sizeis increased by
afactorof 100
linear
a few minutes
linearithmic
a few minutes
quadratic
several hours
cubic
a few weeks
exponential
forever
Effect of increasingproblem size
for a program thatrunsfor afew seconds
Estimating the value ofusing afaster computer. To payattentionto thecost, you
also maybe facedwith this basic question, periodically:Howmuchfaster canI solve
theproblem if I get a faster computer? Again, knowing the order of growth of the
running time provides precisely the information that you need. A famous rule of
thumb known as Moore's Law implies that you can expect to have a computer with
about double the speed and double the memory 18 months from now, or a com
puter with about 10times the speed and 10times the memory in about 5 years.It
is natural to think that if you buy a new computer that is 10times faster and has 10
times more memory than your old one, you can solve a problem 10 times the size,
but that is not the case for quadratic or cubic algorithms. Whether it is an invest
ment banker running daily financial models or a scientist running a program to
analyze experimentaldata or an engineerrunning simulations to test a design,it is
not unusual for people to regularly run programs that take several hours to com
plete. Suppose that you are using a program whose running time is cubic, and then
buy a new computer that is 10 times fasterwith 10 times more memory, not just

4.1
Performance
485
because you need a new computer, but because you faceproblems that are 10times
larger.The rude awakeningis that it willtake a severalweeks to get results, because
the larger problems would be a thousand times slower on the old computer and
improved by only a factor of 10on the newcomputer.Thiskind of situation is the
primary reason that linear and linearithmic algorithms are so valuable because
with such an algorithm and a new computer that is 10 times faster with 10 times
more memory than an old computer, you can solve a problem that is 10 times
larger than could be solved by the old computer in the same amount of time. In
other words, you cannot keep pace with Moore's Lawif you are using a quadratic
or a cubic algorithm.
Processing multiple instances. For fast algorithms,
we often think in terms of multiple problem instanc
es. For example, consider the effect of Moore's law on
a company that provides web services, say, at the rate
of a million problems of size JV every few seconds. At
what rate can problems that are 10 times larger be han
dled with a computer that is 10 times faster (or with 10
times as many computers)? If the algorithm is linear,
the rate stays the same; remarkably, if the algorithm is
logarithmic, the rate can be increased by a factor of 10,
even though problems are 10 times larger. For exam
ple, a company that can handle 10 million requests of
size IONper second (using a logarithmic algorithm) is
likely to do much better than one competitor that can
handle only 1 million requests of size 10JV per second
and another competitor that can handle only 10million
requests of size JV per second.
order ofgrowth
predictedfactor
ofproblem size
increase ifcomputer
speed is increased by
afactorof 10
linear
10
linearithmic
10
quadratic
3-4
cubic
2-3
exponential
1
Effect ofincreasing computer speed
onproblem sizethatcanbesolved in
afixed amountof time
Comparing programs. We are always seeking to improve our programs, and we
can often extend or modify our hypothesesto evaluatethe effectiveness of various
improvements. With the ability to predict performance, we can make design deci
sions during the development of an implementation that can guide us towards bet
ter, more efficient code. As an example, a novice programmer might have written
the nested for loops in ThreeSum as

486
Algorithms and Data Structures
for (int i
= 0;
i
< N; i++)
for (int j = 0;
j < N; j++)
for (int k = 0;
k < N;
k++)
if (i
< j
&& j < k)
if (a[i] + a[j] + a[k] == 0)
cnt++;
so that frequency of execution of the instructions in the inner loop would be ex
actlyJV3 (instead of approximatelyJV3/6). It is easyto formulate and verifythe hy
pothesis that ThreeSumis six times as fast as this variant. Note that improvements
likethis for code that is notin the inner loop willhavelittle or no effect. More gen
erally, given two algorithms that solvethe same problem, we want to know which
one willsolve our problem usingfewer computational resources. In many cases, we
can determine the order of growth of the running times and developaccurate hy
potheses about comparative performance. The order of growth is extremely useful
in this process because it allowsus to compare one particular algorithm with whole
classes of algorithms. For example,once we have a linearithmic algorithm to solve
a problem, webecome lessinterested in quadratic or cubic algorithms (evenif they
are highly optimized) to solvethe same problem.
Caveats
There are many reasons that you might get inconsistent or misleading
results when trying to analyze program performance in detail. All of them have
to do with the idea that one or more of the basic assumptions underlying our hy
pothesesmight not be quite correct.Wecan developnew hypothesesbased on new
assumptions, but the more details that we need to take into account, the more care
is required in the analysis.
Instruction time. The assumption that each instruction always takes the same
amount of time isnot always correct.Forexample, most modern computer systems
use a technique known as caching to organize memory, in which case accessing
elements in huge arrays can take much longer if they are not closetogether in the
array.Youcan observethe effectof cachingfor ThreeSum by letting Doubl i ngTest
run forawhile. Afterseeming to converge to 8,the ratio of running timeswilljump
to a largervalue for largearraysbecauseof caching.
Nondominant inner loop. The assumption that the inner loop dominates may
not always be correct.The problem size JV might not be sufficiently large to make

4.1
Performance
487
the leading term in the mathematical description of the frequency of execution of
instructions in the inner loop so much larger than lower-order terms that we can
ignore them. Some programs havea significantamount of code outside the inner
loop that needs to be taken into consideration.
System considerations. Typically, there are many, many things going on in your
computer. Javais one application of many competing for resources,and Javaitself
has many options and controls that significantly affectperformance. Such consid
erations can interfere with the bedrock principle of the scientific method that ex
periments should be reproducible, sincewhat is happening at this moment in your
computer will never be reproduced again.Whateverelseis going on in your system
(that is beyond your control) should inprinciple be negligible.
Too close to call. Often, when we compare two different programs for the same
task, one might be faster in some situations, and slower in others. One or more
of the considerations just mentioned could make the difference. Again, there is
a natural tendency among some programmers (and some students) to devote an
extreme amount ofenergy running such horseraces to find the "best" implementa
tion, but such work is best left for experts.
Strong dependence on input values. One of the first assumptions that we made
in order to determine the order of growth of the program's running time of a pro
gram was that the running time should be relatively insensitiveto the input values.
When that is not the case,we may get inconsistent results or be unable to validate
our hypotheses. Our running example ThreeSum does not have this problem, but
many of the programs that we write certainly do. We will see several examples of
such programs in this chapter. Often, a prime design goal is to eliminate the de
pendence on input values. If we cannot do so,we need to more carefully model the
kind of input to be processed in the problems that we need to solve, which may
be a significant challenge. For example, if we are writing a program to process a
genome, how do we know how it will perform on a different genome? But a good
model describing the genomes found in nature is precisely what scientists seek,
so estimating the running time of our programs on data found in nature actually
amounts to contributing to that model!

488
Algorithms and Data Structures
Multipleproblemparameters. We have beenfocusing onmeasuring performance
asa function of a singleparameter,generallythe valueof a command-line argument
or the size of the input. However, it is not unusual to have several parameters. For
example, the percolation probability estimation method Esti mate. eval () in Sec
tion 2.4 has two parameters: JV (the sizeof the grid) and T (the number of trials).
In such cases, wetreat the parametersseparately, holding one fixed whileanalyzing
the other. In the caseof Esti mate. eval (), the order of growth of the running time
is TN2, or linear in Tand quadratic in JV.
Despiteall these caveats, understanding the order of growth of the running time
of each program is valuableknowledgefor any programmer, and the methods that
we have described are powerful and broadly applicable. Knuth's insight was that
we can carry these methods through to the last detail inprinciple to make detailed,
accurate predictions. Typical computer systems are extremely complex and close
analysis is best left for experts, but the same methods are effective for developing
approximate estimates of the running time of anyprogram. Arocket scientist needs
to have some idea of whether a test flightwillland in the ocean or in a city; a medi
cal researcher needs to know whether a drug trial will kill or cure all the subjects;
and anyscientist or engineer using a computer program needs to havesome idea of
whether it will run for a second or for a year.
Performance guarantees
For some programs, we demand that the running
time of a program is lessthan a certain bound, no matter what the input values. To
provide such performance guarantees, theoreticians take an extremely pessimistic
view of the performance of algorithms: what would the running time be in the
worst case7.
For example,such a conservativeapproach might be appropriate for the soft
ware that runs a nuclear reactor or an air traffic control system or the brakes in
your car. We want to guarantee that such software completes its job within the
bounds that we set because the result could be catastrophic if it does not.
Scientists normally do not contemplate the worst case when studying the
natural world: in biology,the worst casemight the extinction of the human race;in
physics,the worst case might be the end of the universe. But the worst case can be
a very real concern in computer systems,where the input may be generated by an
other (potentially malicious) user,rather than by nature. For example, websites that
do not use algorithms with performance guarantees are subject to denial-of-service

4.1
Performance
489
attacks, where hackers flood them with pathological requests that make them run
much more slowlythan planned.
Performance guarantees are difficult to verifywith the scientific method, be
cause we cannot test a hypothesis such as Mergesort isguaranteed to be linearith
micwithout trying all possible input values,which we cannot do because there are
far too many of them. We might falsify such a hypothesis by providing inputs for
which mergesort is slow,but how can we prove it to be true? We can do this not
with experimentation, but with mathematical models. In fact, it is often no more
difficult to develop performance guarantees than it is to predict performance. In
deed, it is often the case that the same mathematical model used to prove that a
program computes the expected results can also provide the performance guaran
tees that we need.
Often, randomness provides performance guarantees.For example, it is pos
sible,though extraordinarily unlikely, that CouponCol 1ector (Program 1.4.2) will
not terminate, but mathematical analysis provides a way for us to guarantee that
its running time is linearithmic. The guarantee is probabilistic, but the chance that
it is invalid is less than the chance your computer will be simultaneously struck by
lightning and hit by a meteor.
It is the task of the algorithm analystto discoveras much relevant information
about an algorithm as possible, and it is the task of the applications programmer
to apply that knowledge to develop programs that effectively solvethe problems at
hand. For example, if you are using a quadratic algorithm to solve a problem but
can find an algorithm that is guaranteed to be linearithmic, you certainly are well
advised to consider it, because an algorithm that makes the worst caselinearithmic
makes the running time for every case linearithmic or better. On the other hand, it is
sometimes true that an algorithm that provides worst case performance guarantee
is overly complex, adding unnecessary overhead to protect against a situation that
you will never encounter. For example, an algorithm that provides a linearithmic
guarantee might not be the best one to use, because some other algorithm might
solveyourproblem in linear time (your input values might not be the worst case).
Ideally,we want algorithms that lead to clear and compact code that provides
both a good guarantee and good performance on input values of interest. Many of
the classicalgorithms that we consider in this chapter are ofimportance for a broad
variety of applications precisely because they have all of these properties. Using
these algorithms as models, you can develop good solutions yourself for typical
problems that you face while programming.

490
Algorithms and Data Structures
Memory
Aswith running time, a program's memory usageconnects directlyto
the physicalworld: a substantial amount of your computer's circuitry enablesyour
program to store values and later retrievethem. The more values you need to have
stored at any giveninstant, the more circuitry you need. Topayattention tothecost,
you need to be aware of memory usage.Youprobably are aware oflimits on mem
ory usage on your computer (even more so than for time) because you probably
have paid extra money to get more memory.
Memory usage is well-defined for Java on your computer (every value will
require precisely the same amount of memory each time that you run your pro
gram), but Java is implemented on a very wide range of computational devices,
and memory consumption is implementation-dependent. For economy,we use the
word typical to signal values that are particularly subject to machine dependen
cies.Analyzing memory usage is somewhat different from analyzing time usage,
primarily because one of Java's most significant features is its memory allocation
system,which is supposed to relieve you of having to worry about memory. Cer
tainly,you are welladvised to take advantage of this feature when appropriate. Still,
it isyour responsibilityto know,at leastapproximately, when a program's memory
requirements willprevent you from solving a given problem.
type
bytes
boolean
1
byte
1
char
2
type. For example,sincethe Java i nt data type is the set of integer values
int
4
between -2,147,483,648 and 2,147,483,647, a grand total of 232 differ-
float
4
entvalues> ^ *s reasonable to expect implementations to use 32 bits to
represent i nt values,and similar considerations hold for other primitive
types. Typical Java implementations use 8-bit bytes, representing each
char value with 2 bytes (16 bits), each i nt value with 4 bytes (32 bits),
Typical memory
each doubl e value with 8bytes (64 bits), and each bool eanvalue with1
requirementsfor
byte (since computers typically access memory one byte at a time). For
primitive types
example, ifyou have 1GB ofmemory onyour computer (about 1billion
bytes), you cannot fit more than about 32 million i nt values or 16 mil
lion doubl e values in memory at any one time.
Objects. To determine thememory consumption ofanobject, weaddtheamount
of memory used by each instance variable to the overhead associated with each
long
8
double
8
Primitive types.
It is easy to estimate memory usage for simple pro
grams like the ones we considered in Chapter 1: Count up the number
of variables and weight them by the number of bytes according to their

4.1
Performance
object, typically 8 bytes. For example, a Charge (Program 3.2.1) object uses 32
bytes (8 bytes of overhead and 8 bytes for each of its three double instance vari
ables).Similarly, a Compl ex object uses24bytes. Since many programs create mil
lions of Color objects, typical Javaimplementations pack the information needed
for them into 32bits (three bytesfor RGB values and one fortransparency).Arefer
ence to an object typically uses 4 bytes of memory. When a data type contains a
reference to an object,wehaveto accountseparately forthe 4bytesfor the reference
and the 8 bytes overhead for each object plus the memory needed for the object's
instance variables. In particular, a Document
(Program 3.3.4) object uses 16bytes (8bytesof
overhead and 4 bytes each for the referencesto
the Stri ngand Vector objects) plus the mem
ory needed for the Stri ng and Vector objects
themselves (which we consider next).
Charge object (Program 3.2.1)
public class Charge
{
private double rx;
private double ry;
private double q;
}"
32 bytes
24 bytes
12 bytes
491
String objects. We account for memory in a
St ri ngobject in the samewayasfor anyother
object. Java's implementation of a String ob
ject consumes 24 bytes: a reference to a char
acter array (4 bytes), three i nt values (4 bytes
each), and the object overhead (8 bytes). The
first i nt value is an offset into the character ar
ray;the secondisa count (the string length).In
terms of the instancevariablenames in the fig
ure at right, the string that is represented con
sists of the characters val [offset] through
val [offset + count - 1]. The third i nt value
in String objects is a hash code that saves re-
computation in certain circumstances that
need not concern us now. In addition to the 24
bytes for the String object, we must account
for the memory needed for the characters
themselves,which are in the array.Weaccount
for this space next.
Complex object (Program 3.2.6)
public class Complex
{
private double re;
private double im;
}"
Color object (Java library)
public class Color
{
private byte r;
private byte g;
private byte b;
private byte a;
}"
Document object (Program 3.3.4)
public class Document
{
private String id;
private Vector profile;
}"
String object (Java library)
public class String
{
private char[] val;
private int offset;
private int count;
private int hash;
16 bytes + string+ vector
references
24 bytes + chararray
reference
Typical object memoryrequirements

492
Algorithms and Data Structures
Arrays. Arrays in Java are implemented as objects, typically with two instance
variables (a pointer to the memory location of the first array element and the
length). For primitive types, an array of N elements requires 16bytes of header in
formation plus N times the number of bytes needed to store an element. For ex
ample, the int array in Sample (Program 1.4.1) uses 4JV +16 bytes, whereas the
bool ean arraysin Coupon (Program 1.4.2)usesJV + 16bytes.Note than a boolean
array consumes one byte of memory per entry (wasting 7 of the 8bits)—with some
extra work, you could get the job done with N/8 bytes (see Exercise 4.1.26).An ar
ray of objects is an array of references to the objects,so we need to add the space for
the referencesto the spacerequired for the objects.For example, the array of Charge
objects in Potenti al (Program 3.1.7) uses 16 (array overhead) plus 4N (referenc
es) plus 32N (objects) bytesfor a total of 36N+16 bytes.This analysisassumes that
all of the objects are different:it ispossiblethat multiple array entries could refer to
Array ofint values (Program 1.4.1)
int[]
perm = new int[N];
16bytes
reference
int
values
Total: 16+ 4N
4N bytes
Array o/doubl e values (Program 2.1.4)
doubl e[]
c = new doubl e[N];
16 bytes
Total: 16+ 8N
Array ofpointcharges (Program 3.1.7)
Charge[] a = new Charge[N];
for (int k = 0; k < N; k++)
{
a[k] = new Charge(x0,
yO,
qO)
Total: 16 + 4N + NX32 = 16 + 36N
32 bytes
Memory requirementsfor arrays ofprimitive-type values (left)and objects (right)

4.1
Performance
type
int[]
doubl e[]
Charged
int[][]
doubled []
String
Typical memory requirements
for variable-length
data structures
bytes
4N+16
8N+16
36N+16
4N2 + 20N+16
8N2 + 20N+16
2N+40
the same object (aliasing). Normally,we do not need
to account for such aliasing in our code,with one sig
nificant exception: in conjunction with Java String
objects, as discussed next.
String values and substrings. A String of length
N typicallyuses 24 bytes (for the Stri ng object) plus
2JV + 16bytes (for the array that contains the charac
ters) for a total of 2JV + 40 bytes.It is typical in string
processing to work with substrings, and Java's string
representation enables us to do so without having to
make copies of the string's characters. When you use
the substringO method, you create a new String object (24 bytes) but do not
make copiesof any characters,so a substring of an exist
ing string takesjust 24 bytes.The substring storesan alias
to the character array in the original string, and usesthe
offset and count fields to identify the substring. In oth
er words, a substring takes constant extra memory (and
forming a substring takes constant time), evenwhen the
lengths of the string and the substringare huge. A naive
representation that requires copying characters to make
substrings would take linear time. The ability to create
substrings using a constant extra memory (and constant
time) isthe keyto efficiency in manybasicstring-process
ing algorithms, as we will seein the next section (Program
4.2.8). On the other hand, this representation requires
that allof the charactersin a string be contiguousin some
array,which impliesthat the string concatenationmethod
concatO (which is called when the built-in + operator
is used) has to copy charactersfrom the two strings into
a new array and thus takes time and extra space proportional to the total number
of characters in the two strings. Java's StringBuilder class is an alternative that
implements string concatenation more efficiently than does Stri ng.
Two-dimensional arrays. As we saw in Section 1.4, a two-dimensional arrayin
Java is an array of arrays. For example, the two-dimensional array in Markov
493
String genome
String codon
"CGCCTGCCGTCTGTAC";
genome.substring(6,
3);
genome
codon
A Stri ngand a substring

494
Algorithms and Data Structures
(Program 1.6.3)uses 16bytes (overheadfor the array of arrays) plus 4JVbytes (ref
erences to the row arrays) plus JV times 16 bytes (overhead from the row arrays)
plus JV times JV times 8 bytes (for the JV doubl e values in each of the JV rows) for a
grand total of 8JV2 + 20JV + 16 - 8JV2 bytes.If the array entries are objects,then a
similar accounting gives 4JV2 + 20JV + 16- 4JV2 bytes for the array of arrays filled
with references to objects, to which we need to add the memory for the objects
themselves.
These basic mechanisms are effective for estimating the memory usage of a great
many programs, but there
are numerous
complicating factors that can make the task
significantly more difficult. We have already
noted the potential effect of aliasing. More
over, memory consumption is a complicated
dynamic process when function calls are in
volved because the system memory alloca
tion mechanism plays a more important role,
with more system dependencies. For example,
when your program callsa method, the system
allocates the memory needed for the method
(for its local variables) from a special area of
memory calledthe stack, and when the method
returns to the caller, the memory is returned
to the stack. For this reason, creating arrays
or other large objects in recursive programs
is dangerous, since each recursive call implies
significantmemory usage.When you createan
object with new, the system allocates the mem
ory needed for the object from another special
area of memory known as the heap, and you
must remember that every object livesuntil no
referencesto it remain, at which point a system
process known as garbage collection reclaims
its memory for the heap. Such dynamics can
make the task of precisely estimating memory
usage of a program challenging.
doubl e[][]
t
= new doubl e [N] [N];
16 bytes
8N bytes
Total: 16 + 4N + NX16 + NX8N = 8N2 + 20N + 16
Memory requirementsfor a 2D array

4.1
Performance
495
Perspective
Good performance is important. An impossibly slow program is
almost as useless as an incorrect one,so it is certainly worthwhile to payattention
to the cost at the outset, to have some idea of what sorts of problems you might
feasibly address. In particular, it is always wise to have some idea of which code
constitutes the inner loop of your programs.
Perhapsthe most common mistakemade in programming isto paytoo much
attention to performance characteristics. Your first priority is to make your code
clear and correct. Modifying a program for the sole purpose of speeding it up is
best left for experts. Indeed, doing so is often counterproductive, as it tends to cre
ate code that is complicated and difficultto understand. C.A.R.Hoare (the inven
tor of Quicksort and a leading proponent of writing clearand correct code) once
summarized this idea by sayingthat ''premature optimization is the root ofallevil,"
to which Knuth added the qualifier"(or at least most of it) inprogramming." Be
yond that, improving the running time is not worthwhile if the availablecost ben
efitsare insignificant. For example, improving the running time of a program by
a factor of 10is inconsequential if the running time is only an instant. Evenwhen
a program takes a few minutes to run, the total time required to implement and
debug an improved algorithm might be substantially more than the time required
simply to run a slightlyslowerone—you mayaswelllet the computer do the work.
Worse,you might spend a considerable amount of time and effort implementing
ideas that should improve a program but actuallydo not do so.
Perhaps the second most common mistakemade in developingan algorithm
is to ignore performance characteristics. Faster algorithms are often more com
plicated than brute-force solutions, so you might be tempted to accept a slower
algorithm to avoid having to deal with more complicatedcode. However, you can
sometimes reap huge savingswith just a fewlines of good code. Users of a surpris
ing number of computer systemslosesubstantial time waitingfor simple quadratic
algorithms to finish solving a problem, even though linear or linearithmic algo
rithms are available that are only slightly more complicated and could therefore
solvethe problem in a fraction of the time.When weare dealingwith huge problem
sizes,we often have no choice but to seekbetter algorithms.
Improving a program to make it clearer, more efficient, and elegant should
be your goal every time that you work on it. If you payattention to the cost all the
waythrough the development of a program, you will reap the benefits everytime
you use it.

496
Algorithms and Data Structures
Q. How do I find out how long it takesto add or multiply two doubl e valueson my
computer?
A. Run some experiments! The program TimePrimitives on the booksite uses
Stopwatch to test the execution time of various arithmetic operations on primitive
types. This technique measures the actual elapsed time as would be observed on a
wallclock.If your systemis not running many other applications, this can produce
accurate results.Youcan find much more information about refining such experi
ments on the booksite.
Q. How much time do functions such as Math.sqrtO, Math.logO, and Math.
sin() take?
A. Run some experiments! Stopwatch makes it easy to write programs such as
Ti mePri mi ti ves to answer questions of this sort for yourself, and you willbe able
to use your computer much more effectively if you get in the habit of doing so.
Q. How much time do string operations take?
A. Run some experiments! (Haveyou gotten the messageyet?)The standard imple
mentation is written to allow the methods 1ength(), charAt(), and substri ng()
to run in constant time. Methods such as tol_owerCase() and replaceO are lin
ear in the string size. The methods compareToO, and startsWithO take time
proportional to the number of characters needed to resolvethe answer (constant in
the best case and linear in the worst case), but i ndexOf() can be slow.String con
catenation takes time proportional to the total number of characters in the result.
Q. Why does allocating an array of sizeJV take time proportional to N?
A. In Java, all array elements are automatically initialized to default values (0,
false, or null). In principle, this could be a constant time operation if the sys
tem would defer initialization of each element until just before the program ac
cessesthat element for the first time, but most Java implementations go through
the whole array to initialize each value.
Q. How do I find out how much memory is availablefor my Javaprograms?

4.1 Performance
A. Since Java will tell you when it runs out of memory, it is not difficultto run
some experiments. For example, if you use PrimeSieve (Program 1.4.3)by typing
% Java PrimeSieve 100000000
and get the result
50847534
but then type
% Java PrimeSieve 1000000000
and get the result
Exception in thread "main"
java.lang.OutOfMemoryError: Java heap space
then you can figure that you have enough room for an arrayof 100million bool-
ean values but not for an array of 1 billion boolean values. You can increase the
amount of memory allottedto Java with command-lineflags. The following com
mand executes PrimeSieve with the command-line argument 1000000000, re
questing a maximum of 1100 megabytesof memory (if available).
Java -XmxllOOmb PrimeSieve 1000000000
Q. Whatdoesit meanwhensomeone says that the runningtimeof an algorithmis
O(NlogJV)?
A. That is an example of a notation known as big-Oh notation. We write/(JV) is
0(g(N)) if there exists a constant csuch that/(JV) < cg(N) for all JV. Wealsosay
that the running timeof an algorithmis0(g(N)) iftherunning timeis0(g(N)) for
allpossibleinputs. This notation is widely usedby theoreticalcomputer scientists
to prove theorems about algorithms,so you are sure to seeit if you take a course in
algorithms and data structures. It provides a worst-caseperformance guarantee.
497

498
Algorithms and Data Structures
Q. So can I use the fact that the running time of an algorithm is 0(JVlog JV) or
0(N2) to predict performance?
A. No, because the actual running time might be much less.Perhaps there is some
input for which the running time isproportional to the givenfunction, but perhaps
the that input is not found among those expected in practice. Mathematically, big-
Oh notation is lessprecisethan the tilde notation we use:iff(JV) ~ g(JV), then/(JV)
is 0(g(JV)),but not necessarily viceversa. Consequently, big-Oh notation cannot
be used to predict performance.For example, knowledge that the running time of
one algorithm is 0(Nlog N) and the running time of another algorithm is 0(N2)
does not tell you which will be faster when you run implementations of them.
Generally, hypothesesthat usebig-Oh notation are not usefulin the context of the
scientificmethod because they are not falsifiable.

4.1
Performance
Exercises
4.1.1
Implement the method pri ntAl1() for Th reeSum, which prints all of the
triples that sum to zero.
4.1.2
ModifyTh reeSum to take a command-line argument x and find a triple of
numbers on standard input whose sum is closestto x.
4.1.3
Writeaprogram Fou rSum that takes an integerJVfromstandard input, then
reads JV long valuesfrom standard input, and counts the number of 4-tuples that
sum to zero. Usea quadrupleloop.Whatisthe orderofgrowthof the running time
of your program? Estimate the largest JV that yourprogramcanhandlein an hour.
Then, run your program to validateyour hypothesis.
4.1.4
Prove by induction that the number of distinct pairs of integersbetween
0 and JV-1 isN(N—1)/2, and then provebyinduction that the number of distinct
triples of integers between 0 and JV-1 isJV(JV-1)(JV-2)/6.
Answerforpairs: TheformulaiscorrectforJV = 1,since thereare0 pairs.ForJV> 1,
count all the pairs that do not includeJV-1, whichis N(N-1)/2 by the inductive
hypothesis, and allthe pairsthat do includeJV-1,whichisJV—1,to getthe total
(JV-l)(JV-2)/2 +(JV-1) = JV(N-l)/2.
Answerfortriples: The formula is correctfor JV = 2.ForJV> 2, count allthe triples
that do not includeJV-1,whichis(N- l)(JV-2)(JV-3)/6 bythe inductivehypoth
esis, and all the triples that do include JV-1, which is (JV-1)(JV—2)/2, to get the
total
(JV-l)(JV-2)(JV-3)/6 + (JV-l)(JV-2)/2 = JV(N-l)(JV-2)/6.
4.1.5
Show by approximating with integralsthat the number of distinct triples
of integers between 0 and JV is about JV3/6.
Answer: 20N2^ 1- ^r';f
SXf'o dkdjdi =iXjdjdi= /0V/2)<£ = N3/6.
4.1.6
What is the value of x after running the following code fragment?

int x = 0;
for (int i =0;
i
< N;
for (int j
= i
+ 1;
for (int k = j
+
x++;
Algorithms and Data Structures
i++)
j
< N; j++)
1;
k < N;
k++)
Answer:JV(JV-l)(JV-2)/6.
4.1.7
Usetilde notation to simplifyeach of the followingformulas, and givethe
order of growth of each:
a. N(N- l)(JV-2)(JV-3)/24
b. (JV-2)(lgJV-2)(lgJV+2)
c. JV(JV + 1)-JV2
d. JV(JV + l)/2 + JVlgJV
e. ln((JV- l)(JV-2)(JV-3))2
4.1.8
Determine the order of growth of the running time of the input loop of
ThreeSum:
int N = Integer.parselnt(args[0]);
int[]
a = new int[N] ;
for (int i =0;
i
< N; i++)
a[i]
= Stdln.readlntO;
Answer: Linear.The bottlenecks are the array initialization and the input loop. De
pending on your systemand the implementation, the readlntO statement might
lead to inconsistent timings for small values of JV. The cost of an input loop like
this might dominate in a linearithmic or even a quadratic program with JV that is
not too large.
4.1.9
Determine whether the following code fragment is linear, quadratic, or cu
bic (as a function ofJV).
for (int i
= 0;
i
< N; i++)
for (int j
= 0;
j
< N; j++)
if (i
== j) c[i][j] = 1.0;
else
c[i][j] = 0.0;

4.1
Performance
4.1.10 Supposethe running time of an algorithmon inputs of sizeone thousand,
two thousand, three thousand, and four thousand is 5 seconds, 20 seconds, 45 sec
onds,and80seconds, respectively. Estimate howlongitwill take to solve aproblem
of size 5,000. Is the algorithm linear, linearithmic, quadratic, cubic, or exponen
tial?
4.1.11 Whichwouldyou prefer: a quadratic, linearithmic, or linear algorithm?
Answer: Whileit istemptingto make aquickdecision basedon theorderofgrowth,
it isveryeasy to be misled bydoingso. You needto have someideaof the problem
size and of the relative value of the leading coefficients of the running time. For
example, suppose thattherunningtimes areJV2 seconds, 100JVlog2JVseconds, and
10000JV seconds. The quadratic algorithm will be fastest for JV up to about 1000,
and the linear algorithm will never be faster than the linearithmic one (JV would
have to begreater than 2100, fartoo large to botherconsidering).
4.1.12 Apply the scientific method to develop and validate a hypothesis about
order of growthof the running timeof the following codefragment, asa function
of the input argument n.
public static int f(int n)
{
if (n
== 0) return 1;
return f(n-l)
+ f(n-l);
}
4.1.13 Apply the scientific method to develop and validate a hypothesis about
order of growth of the running time of the collectO method in Coupon (Pro
gram 2.1.3), asa functionof the input argument N. Note: Doubling isnot effective
fordistinguishing between thelinear andlinearithmic hypotheses—you mighttry
squaring the sizeof the input.
4.1.14 Apply the scientific method to develop and validate a hypothesis about
order of growth of the running time of Markov (Program 1.6.3), as a function of
the input parameters T and N.
501

502
Algorithms and Data Structures
4.1.15 Apply the scientific method to develop and validate a hypothesis about
orderofgrowth oftherunning time ofeach ofthefollowing two code fragments as
a function of N.
String s = "";
for (int i
= 0;
i
< N; i++)
if (StdRandom.bernoulli(0.5)) s += "0";
else
s
+= "1";
StringBuilder sb = new StringBuilderO;
for (int i
= 0;
i
< N; i++)
if (StdRandom.bernoulli(0.5)) sb.append("0");
else
sb.appendCl");
String s = sb.toStringO;
Answer: The first is quadratic; the second is linear.
4.1.16 Each of the four Java functions below returns a string of length Nwhose
characters are all x. Determine the order of growth of the running time of each
function. Recall that concatenating two stringsin Java takes time proportional to
the sum of their lengths.
public static String methodl(int N)
{
if (N == 0) return "";
String temp = methodl(N / 2);
if (N % 2 == 0) return temp + temp;
else
return temp + temp + "x";
}
public static String method2(int N)
{
String s = "";
for (int i
= 0;
i
< N; i++)
s
=
s
-
return s;

4.1
Performance
public static String method3(int N)
{
if (N == 0) return "";
if (N == 1) return "x";
return method3(N/2) + method3(N - N/2);
}
public static String method4(int N)
{
char[] temp = new char[N];
for (int i
= 0;
i
< N; i++)
temp[i]
= fxf;
return new String(temp);
}
4.1.17 The following code fragment (adapted from a Java programming book)
createsa random permutation of the integersfrom 0 to JV-1. Determine the order
ofgrowth of itsrunningtimeasafunction ofJV. Compare itsorderof growthwith
the shuffling code in Section 1.4.
int[]
a = new int[N];
boolean[] taken = new boolean[N];
int count = 0;
while (count < N)
{
int r = StdRandom.uniform(N);
if (!taken[r])
{
a[r] = count;
taken[r]
= true;
count++;
}
}
4.1.18 What is order of growth of the running time of the following function,
which reverses a string s of length N?

504
Algorithms and Data Structures
public static String reverse(String s)
{
int N = s.lengthO;
String reverse = "";
for (int i
= 0;
i
< N; i++)
reverse = s.charAt(i) + reverse;
return
reverse;
}
4.1.19 What isthe order of growthof the running time of the following function,
which reversesa string s of length N?
public static String reverse(String s)
{
int N = s.lengthO;
if (N <= 1) return s;
String left = s.substring(0, N/2);
String right = s.substring(N/2,
N);
return reverse(right) + reverse(left);
}
4.1.20 Givea linear algorithm for reversinga string.
Answer:
public static String reverse(String s)
{
int N = s.lengthO;
char[]
a = new char[N];
for (int i
= 0;
i
< N; i++)
a[i]
= s.charAt(N-i-l);
return new String(a);
}
4.1.21 Write a program MooresLaw that takes a command-line argument JV and
outputs the increase in processorspeed over a decade if microprocessors double
everyJV months. How much willprocessorspeed increaseover the next decade if
speeds double everyJV= 15 months? 24 months?

4.1
Performance
4.1.22 Using the modelin thetext, give thememory requirements foreach object
of the followingdata types from Chapter 3:
a.
Stopwatch
b.
Turtle
c.
Vector
d. Body
e.
Universe
4.1.23 Estimate, asafunction ofthegridsize JV, theamountofspace usedbyVi -
sualize (Program 2.4.3) with the vertical percolationdetection (Program 2.4.2).
Extra credit: Answer thesame question forthecase where therecursive percolation
detection method in Program 2.4.5 is used.
4.1.24 Estimate the size of the biggest two-dimensional arrayof i nt values that
yourcomputercanhold,and then try to allocate suchan array.
4.1.25 Estimate, as a function of the number of documents JVand the dimension
dy the amount of spaceused by CompareAl 1 (Program3.3.5).
4.1.26 Write a version of Pri meSi eve (Program 1.4.3) that uses a byte arrayin
stead ofa bool ean array and uses allthebitsin each byte, to raise thelargest value
of Nthat it can handle by a factor of 8.
4.1.27 Thefollowing tablegives runningtimes forvarious programs for various
values of JV. Fill in the blanks with estimates that youthink are reasonable on the
basisof the information given.
program
1,000
A
.001 seconds
B
1 minute
C
1 second
10,000
100,000
1,000,000
.012 seconds
.16 seconds
? seconds
10 minutes
1.7 hours
? hours
1.7minutes
2.8 hours
?days
Give hypotheses for the order of growthof the running timeof eachprogram.
505

506
Algorithms and Data Structures
^reatm^^MBmi
4.1.28 ThreeSum analysis. Calculate the probabilitythat no triple amongJV ran
dom 32-bitintegers sums to 0, and give an approximate estimate for JV equal to
1000,2000,and 4000. Extra credit: Give an approximate formula for the expected
number of suchtriples(asa function of JV), and run experiments to validate your
estimate.
4.1.29 Closest pair. Design a quadratic algorithm that finds the pair of integers
that are closest to each other. (In the next section you will be asked to find a lin
earithmic algorithm.)
4.1.30 Power law. Show that a log-log plot of the function cNb has slope b and
x-intercept logc. Whatarethe slope andx-intercept for 4 JV3 (logJV)2 ?
4.1.31 Sumfurthestfrom zero. Design an algorithm that finds the pair of integers
whosesum is furthest from zero. Canyou discover a linear algorithm?
4.1.32 The "beck" exploit. A popular web server supports a function called
no2slash() whose purposeis to collapse multiple / characters. For example, the
string/dl///d2////d3/test. html becomes /dl/d2/d3/test. html.Theoriginal
algorithm was to repeatedly search fora / and copy the remainder of the string:
void no2slash(char[]
name)
{
for (int x = 0;
x < name.length;
)
if (x > 0)
if C(name[x-1]
== '/')
&& (name[x] == '/'))
for(int y = x+1;
y < name.length;
y++)
name[y-l] = name[y];
else x++;
}
Unfortunately, the running time of this codeisquadratic in the number of/ char
acters in the input. Bysending multiple simultaneous requests withlargenumbers
of / characters, a hacker can deluge a server and starve other processes for CPU
time, therebycreatinga denial-of-service attack.Develop a versionof no2sl ash ()
that runs in linear time and does not allowfor the this type of attack.

4.1
Performance
4.1.33 Young tableaux. Suppose youhave in memoryan JV-by-JV grid of integers
asuchthata[i][j] < a[i+l] [j] anda[i] [j] < a[i] [j+1] foralli and j, like
the table below.
5
23
54
67
89
6
69
73
74
90
10
71
83
84
91
60
73
84
86
92
99
91
92
93
94
Devisean algorithm whose order of growth is linear in JV to determine whether a
given integer x is in a givenYoungtableaux.
Answer: Start at the upper-right corner.Ifthe valueisx,return true. Otherwise,go
leftif the valueisgreaterthan x and godownifthevalue isless than x.If you reach
bottom leftcorner,then x is not in table. The algorithm is linearbecause you can
go left at most JV times and down at most JV times.
4.1.34 Subsetsum. WriteaprogramAnySum that takes anintegerJVfromstandard
input, then reads JV long values from standard input, and counts the number of
subsets that sum to 0. Give the order of growthof the running time of your pro
gram.
4.1.35 String rotation. Givenan arrayof JV elements, give a linear time algorithm
to rotate the string kpositions.That is,if the arraycontains a0, av ..., aN_}, the ro
tated array is ak, ak+v ..., aN_p a0,..., z.k_v Use at most a constant amount of extra
space(array indicesand arrayvalues). Hint: Reverse three subarraysas in Exercise
4.1.20.
4.1.36 Finding a duplicated integer, (a) Given an array of JV integersfrom 1 to JV
with one value repeated twice and one missing, give an algorithm that finds the
missing integer,in linear time and constant extra space. Integer overflowis not al
lowed, (b) Givena read-only array of JV integers, where eachvalue from 1 to JV— 1
occurs once and one occurs twice,givean algorithm that finds the duplicated value,
in linear time and constant extra space, (c) Given a read-only array of JV integers
with valuesbetween 1and JV-1, give an algorithmthat findsa duplicated value,in
linear time and constant extra space.

Algorithms and Data Structures
4.1.37 Factorial. Design a fast algorithm to compute JV! forlarge values of JV, us
ingJava's Bi glnteger class. Use yourprogram to compute the longest run of con
secutive 9sin 1000000!. Develop and validate a hypothesisfor the order of growth
of the running time of your algorithm.
4.1.38 Maximum sum. Design a linear algorithm that finds a contiguous sub
sequence of at mostM in a sequence of JV 1ong integers that has the highest sum
among all such subsequences. Implement your algorithm, and confirm that the
order of growth of its running time islinear.
4.1.39 Pattern matching. Given an JV-by-JV array of black (1) and white (0) pix
els, design alinearalgorithm that finds thelargest square subarray that consists of
entirelyblackpixels. In the example below there isa 3-by-3 subarray.
Implementyour algorithm and confirm that the order of growth of its running
timeislinearin the number of pixels. Extra credit: Design an algorithmto findthe
largest rectangular black subarray.
4.1.40 Maximum average. Write a program that finds a contiguous subarray of
at most M elements in an array of JV long integers that has the highest average
value amongallsuchsubarrays, bytryingallsubarrays. Use the scientific method
to confirm that the order of growth of the running time of your program is MN2.
Next, write a program that solves the problem by first computing prefi x[i ] =
a[0] + ... + a[i ] for each i, then computing the average in the interval from
a[i] to a[j] with the expression (prefix[j] - prefix[i]) / (j - i + l).Use
the scientific method to confirm that this method reduces the order of growth by a
factor of JV.

4.1
Performance
4.1.41 Sub-exponentialfunction. Find a function whose order-of-growth is slow
er than any polynomial function, but faster than any exponential function. Extra
credit Find a program whose running time has that order of growth.
509

Algorithms and Data Structures
4.2
Sorting and Searching
The sorting problemisto rearrange a set of items in ascending order. It is a famil
iar and critical task in many computational applications: the songs in your mu
sic library are in alphabetical order, your email messages are in order of the time
received, and so forth. Keeping things in
some kind of order is a natural desire.
One reason that it is so useful is that it
4.2.1
Binarysearch (20 questions)
512
is much easier to search for something in
*22
Bjsection8Cf* ' ': ' ' \
515
, ,.
.
,
J;. .
4.2.3
Binary search (sorted array) . . . .517
a sorted list than an unsorted one. This
424 Insertionsort
524
need is particularly acute in computing,
4.2.5
Doubling test for insertion sort. . .526
where the list of things to search can be
4.2.6
Mergesort
528
huge and an efficient search can be an
4-2-7
Frequencycounts
533
.
. r
4.
ui
>
I*-
4.2.8
Longest repeated substring
539
important factor in a problems solution.
&
Y
&
Sorting and searching are impor-
Programs in this section
tant for commercial applications (busi
nesses keep customer files in order) and
scientific applications (to organize data and computation), and have all manner
of applications in fieldsthat may appear to have little to do with keeping things in
order, including data compression, computer graphics, computational biology,nu
merical computing, combinatorial optimization, cryptography, and many others.
We use these fundamental problems to illustrate the idea that efficient algo
rithms are one keyto effective solutions for computational problem. Indeed, many
different sorting and searchingmethods havebeen proposed. Which should we use
to address a given task?This question is important because different programs can
have vastly differing performance characteristics, enough to make the difference
between successin a practical situation and not coming close to doing so, even on
the fastest available computer.
In this section, we will consider in detail two classicalalgorithms for sorting
and searching,along with severalapplications in which their efficiencyplaysa criti
cal role. With these examples,you will be convinced not just of the utility of these
methods, but also of the need to pay attention to thecostwhenever you address a
problem that requires a significant amount of computation.

4.2 Sorting and Searching
Binarysearch
The gameof"twentyquestions"(seeProgram 1.5.2)providesan
important and usefullesson in the idea of designingand using efficientalgorithms
for computational problems. The setup is simple:your task is to guess the value of
a hidden number that is one of the JV integersbetween0 and JV— 1.Each time that
you make a guess,you are told whether your guessis equal to the hidden number,
too high, or too low.Aswe discussed in Section 1.5,an effective strategy is to guess
the number in the middle of the in
terval, then use the answer to halve
the interval size. For reasons that will
become clearlater,webegin by slight
ly modifying the game to make the
questions of the form "is the number
less than m ?" with true or false an
swers, and assume for the moment
that N is a power of two. Now, the ba
sis of an effective method that always
gets to the hidden number in a mini
mal number of questions is to main
tain an interval that contains the hid
den number and shrinks by half at
each step. More precisely, we use a
half-open interval, which contains the
left endpoint but not the right one.
We use the notation [/, h) to denote
all of the integers greater than or equal to / and less than (but not equal to) h.We
start with / = 0 and h —N and use the followingrecursivestrategy:
• Base case: If h —Iis 1, then the number is /.
• Recursive step:Otherwise, ask whether the number is lessthan the number
m = 1+ (h—l )/2. If so, look for the number in [/, ra); if not, look for the
number in [ra,/z).
This strategy is an example of the general problem-solving method known as bi
narysearch, which has many applications. TwentyQuesti ons (Program 4.2.1) is an
implementation.
interval
-1=
64
64
76
80
7678
96
—T
128
128
128
Q
<64?
false
64
< 96 ?
true
32
< 80 ?
true
16
<72?
false
8
<76?
false
< 78 ?
true
2
<77?
false
•-11
Findinga hidden number with binary search
511

512
Algorithms and Data Structures
Program4,2.1
Binary search (20 questions)
public class TwentyQuestions
{
public static int search(int lo, int hi)
{
// Find number in [lo, hi)
if ((hi
- lo) == 1) return lo;
int mid = lo + (hi
- lo)
/
2;
StdOut.print("Less than " + mid + "?
");
if (Stdln.readBooleanO)
return search(lo, mid);
else return search(mid, hi);
}
$$i
public static void main(String[] args)
{
// Play twenty questions.
int n = Integer.parselnt(args[0]);
int N = (int) Math.pow(2, n);
StdOut.print("Think of a number ");
StdOut.println("between 0 and " + (N-l));
int v = search(0, N);
StdOut.println("Your number is " + v);
}
lo
hi
-
1
mid
n
smallestpossible value
largestpossible value
midpoint
number ofquestions
number ofpossible values
This code uses binary search toplay thesamegameas Program 1.5.2, but with the roles re
versed: youprovide the number and theprogram guesses its value. It takes a command-line
argument ny asks you to think of a number between 0 and N—l, where N = 2", and always
guesses theanswer withn questions.
% Java TwentyQuestions 7
Think of a number between 0
and 127
Less than 64?
false
Less than 96?
true
Less than 80?
true
Less than 72?
false
Less than 76?
false
Less than 78?
true
Less than 77?
false
Your
number is
77
^"W^^-^^S^^^^^^^pp^*

4.2 Sorting and Searching
513
Correctness proof First,wehave to convince ourselves that the method is correct:
that it always leadsus to the hidden number.Wedo sobyestablishingthe following
facts:
• The interval always contains the hidden number.
• The interval sizesare the powers of two,decreasingfrom N.
The first of these facts is enforced by the code;the second follows by noting that if
(h —I) is a power of two, then (h—I)/2 is the next smaller power of two and also
the sizeof both halved intervals.These factsare the basisof an induction proofthat
the method operates as intended. Eventually, the interval sizebecomes 1,so we are
guaranteed to find the number.
Analysis of running time. Since N is a power of 2, we write N = 2", where n =
IgiV. Now,let T(N)be the number of questions.The recursivestrategy immediately
implies that T(N) must satisfythe followingrecurrence relation:
T(N) = T(N/2) + l
with T(l) = 1. Substituting 2" for N, we can telescope the recurrence (apply it to
itself) to immediately get a closed-form expression:
T(2«) = TC2""1) + 1 = T(2«"2) -1- 2 = ...= T(l) + n-l = n.
Substituting back JV for 2n (and IgiV for n) gives the result
T(N) = IgiV
We normally use this equation to justify a hypothesis that the running time of a
program that uses binary search is logarithmic. Note: Binary search and Twenty-
Questi ons. search () work evenwhen N is not a power of two—we just assumed
that iV is a power of two to simplifyour proof (seeExercise 4.2.14).
Linear-logarithmic chasm. The alternative to using binary search is to guess 0,
then 1, then 2, then 3, and so forth, until hitting the hidden number. We refer to
such an algorithm as a brute-force algorithm: it seemsto getthe job done, but with
out much regard to the cost (which might prevent it from actually getting the job
done for large problems). In this case, the running time of the brute-force algo
rithm is sensitive to the input value, but could be as much as N and has expected
value iV/2 if the input value is chosen at random. Meanwhile,binary search is guar
anteed to use no more than IgiVsteps.Asyou willlearn to appreciate, the difference

514
Algorithms and Data Structures
between N and IgiV makes a huge difference in practical applications. Understand
ing the enormousness of this difference is a critical step to understanding the impor
tance ofalgorithm design andanalysis. In the present context, suppose that it takes
1 second to process a guess. With binary search, you can guess the value of any
number lessthan 1 million in 20 seconds;with the brute-force algorithm, it might
take 1 million seconds, which is more than 1 week. We will see many examples
where such a cost differenceis the determining factor in whether or not a practical
problem can be feasiblysolved.
Binary representation. If you
look back to Program 1.3.7,
you will immediately recognize
that binary search is nearly the
same computation as convert
ing a number to binary! Each
guessdetermines one bit of the
answer. In our example, the
information that the number
is between 0 and 127 says that
the number of bits in its binary
representation is 7, the answer
to the first question (is the
number less than 64?) tells us
the value of the leading bit, the
answer to the second question
tells us the value ofthe next bit,
and so forth. For example, if
the number is 77, the sequence
of answers no yes yes no no yes no immediately yields 1001101, the binary
representation of 77.Thinking in terms of the binary representation is another way
to understand the linear-logarithmic chasm: when we have a program whose run
ning time islinear in a parameter iV, its running time is proportional to the value of
iV, whereas a logarithmic running time is just proportional to the number of digits
in N. In a context that is perhaps slightlymore familiar to you, think about the fol
lowing question, which illustrates the same point: would you rather earn $6 or a
six-figure salary?
the known value
is between
<£(/) and <£>{m)
the unknown value
is between I and m
Binary search (bisection) to invert an increasingfunction

4.2 Sorting and Searching
^^•^^^^^^^^^BSBBB^^^^^^^M
Program 4.2.2
Bisection search (function inversion)
public static void Phi Inverse(double y)
{
return Philnverse(y,
.00000001, -8, 8)
}
private static double PhiInverse(double y, double delta,
double lo, double hi)
{
// Compute x with Phi(x) = y.
double mid = lo + (hi
- lo)/2;
if (hi
- lo < delta)
return mid;
if (Phi(mid) > y)
return Philnverse(y, delta, lo, mid);
else return Philnverse(y, delta, mid, hi);
515
^&$M^
;'•• i
••'•3.
;.-••
\t
1
y
delta
lo
mid
hi
argument
precision
smallestpossible value
midpoint
largest possible value
}
This implementation of PhiInverse () for ourGaussian library (Program 2.1.2) uses binary
search tocompute a valuexfor which $>(x) isequal toa givenvaluey, within a givenprecision
delta. It is a recursivefunction thathalves the interval containing thegiven value, evaluates
thefunction at themidpoint of the interval andtakes advantage of thefact thatO is increas
ingtodecide whether the desired pointis in the left halforthe right half continuing until the
interval size is less than thegivenprecision.
Inverting a function. As an example of the utility of binarysearch in scientific
computing, we revisit a problem that wefirst encountered in Section 2.1:inverting
an increasingfunction. Tofixideas,we referto the Gaussiancumulative distribu
tion function <E> when describingthe method, but it worksfor anyincreasingfunc
tion. Givena valuey, our task is to find a valuex such that 4>(x) =y. In this situa
tion, we use real numbers as the endpoints of our interval,not integers,but we use
the sameessential method asfor guessing a hiddeninteger: wehalve the sizeof the
intervalat eachstep,keeping x in the interval, until the intervalissufficiently small
that weknow the valueof x to within a desiredprecision8.Westart with an interval
(/, h) known to contain x and use the following recursive strategy:
• Compute m = / + (h—l)/2.
• Base case: If h —/ is less than 8, then return m as an estimate ofx.
•Recursive step: Otherwise, testwhether <£(m) >y.Ifso, lookforx in (/, m);
if not, look for x in (m, h).

516
Algorithms and Data Structures
The keyto this method is the idea that the function is increasing—for any values a
and by knowing that <I>(a)<0(b) tells us that a<b, and vice versa. The recursive
step just applies this knowledge: knowing thaty = <l>(x) < <I>(ra) tellsus that x<m,
so that x must be in the interval (/, m), and knowing that y = ®(x) > O(m) tells us
that x > m,so that x must be in the interval (m,h). You can think of the problem as
determining which of the N = (h-1)/8 tiny intervals of size8 within (/,h) contains
x,with running time logarithmic in N.Aswith number conversionfor integers,we
determine one bit of x for each iteration. In this context, binary search is often
called bisection search becausewebisect the interval at each stage.
thekey
(known value)
is between
a [mid] and a [hi -1]
the index
(unknown value)
is between mi d and hi
Binary search in a sorted array. One of the most
important uses of binary search is to find a piece of
information using a key to guide the search. This us
ageisubiquitous in modern computing, to the extent
that printed artifacts that depend on the same con
ceptsare wellon their wayto becoming obsolete. For
example,during the last fewcenturies, people would
use a publication known as a dictionary to look up
the definition of a word, and during much of the last
century people would use a publication known as a
phone book to look up a person's phone number. In
both cases, the basic mechanism is the same: entries
appear in order, sorted by a key that identifies it (the
word in the case of the dictionary, and the persons
name in the caseof the phone book, sorted in alpha
betical order in both cases). You probably use your
computer to reference such information, but think
about howyou would look up aword in a dictionary.Abrute-force solution would
be to start at the beginning, examineeach entry one at a time, and continue until
you find the word. No one uses that method: instead, you open the book to some
interior page and look for the word on that page. If it is there, you are done; other
wise, you eliminateeither the part of the book before the current page or the part
of the book after the current page from consideration, and then repeat. We now
recognize this method as binary search. Whether or not you look exactlyin the
middle is immaterial; as long as you eliminate at least a fraction ofthe entries each
time that you look, your searchwillbe logarithmic (seeExercise 4.2.15).
Binary search in a sorted array (onestep)

4.2 Sorting and Searching
517
wmmmmms^s^^^^^^^^^m^^^mm^M^m^m
w
S3
Program4.2.3
Binary search (sorted array)
public class BinarySearch
{
public static int search(String key, String[] a)
{
return search(key, a, 0, a.length);
}
public static int search(String key,String[] a, int lo, int hi)
{
// Search for key in a[lo, hi).
if (hi
<= lo) return -1;
int mid = lo + (hi
- lo) /
2;
int cmp = a[mid].compareTo(key);
if
(cmp > 0) return search(key,
else if (cmp < 0) return search(key,
else
return mid;
}
a, lo, mid);
a,
mid+1, hi);
i
public static void main (Stri ng[] args)
{
// Print keys in Stdln that are not found
// in the whitelist file args[0].
In in = new In(args[0]);
String[] a = in. readAHO .split("WS+") ;
while (!Stdln.isEmptyO)
{
String key = Stdln. readStringO ;
if (search(key, a) < 0) StdOut.println(key);
}
key
a[]
lo
mid
hi
stringsought
sortedlistofstrings
smallestpossible index
midpoint
largest possible index
The search () method in this class uses binary search tofind theindex ofa string key ina sorted
array (orreturns -1 if the string is notin the array). The test client is an exception filterthat
reads a (sorted) whitelistfrom the filegiven on the command lineandprints thewords from
standard inputthatarenotin thewhitelist.
more
test.txt
bob@office
carl©beach
marvin@spam
bob@office
bob@office
mallory@spam
dave@boat
eve@airport
ali ce@home
!^?£p£?f»^^^ii^^f^fpp^
^iM^MiitM^i,
% more whitelist.txt
ali ce@home
bob@office
carl©beach
dave@boat
% Java BinarySearch whitelist.txt < test.txt
marvin@spam
mallory@spam
eve@airport
^i^^^^^^^^^^^^^sm^^^^^^^s^mm^^!^^^^^mmm
SS

518
Algorithms and Data Structures
Exception filter. We will consider in Section 4.3 the details of implementing the
kind of computerprogramthat youusein place of a dictionary or a phone book.
Program 4.2.3 usesbinary searchto solve the simpler existence problem: is a given
keyin a sorted database of keys, or not? For example, when checking the spelling
of a word,you need onlyknowwhetheryourword isin the dictionaryand arenot
interested in the definition. In a computer search, we keep the information in an
array,sorted in order of the key (for some applications,the information comes in
sorted order; for others,wehaveto sort it first, usingone of the methods discussed
later in this section).Thebinary searchin Program4.2.3 differs from our other ap
plicationsin two details.First,the file sizeN need not be a power of two.Second,it
hasto allow the possibility that the itemsoughtis not in the array. Coding binary
search to account for these details requires some care, as discussed in this section's
Q&A and exercises. The test clientin Program 4.2.3 isknown as an exceptionfilter.
it reads in a sorted list of strings from a file (which we refer to as the whitelist) and
an arbitrary sequence of strings from standard input, and prints those in the se
quencethat arenot in the whitelist. Exception filters havemanydirectapplications.
For example, if the whitelist is the words from a dictionary and standard input
is a text document, the exception filter will print the misspelledwords. Another
examplearisesin web applications: your emailapplication might use an exception
filter to reject any mail messages that are not on a whitelist that contains the mail
addresses of your friends,or your operating systemmight have an exceptionfilter
that disallows networkconnections toyourcomputerfrom anydevice havingan IP
address that is not on a preapproved whitelist.
Weighing an object. Binarysearch hasbeenknownsince antiquity, perhaps partly
because ofthefollowing application. Suppose that youneedto determinetheweight
of a given object using only a balancing scale. With binary search,you can do so
with weights that are powers of two (youneed only one weight of each type). Put
the objecton the leftsideof the balance and try the weights in decreasing order on
the right side.If a weight causesthe balance to tilt to the left, remove it; otherwise,
leave it. This processis precisely analogous to determining the binary representa
tion of a number by subtracting decreasingpowers of two, as in Program 1.3.7.

4.2 Sorting and Searching
twenty questions
(converting to binary)
1??????
greater than64
less than 64+32
/
10?????
. fess(/i<w64+16
100????
1001???
greater than64+8
10011??
greaterthan64+8+4
less than 64+8+4 + 2
/
100110?
equalto64+8+4 + 2+1
I
1001101
weighing an object
i
it
84
in
842
_
ii .
64
84
1
<96
inverting afunction
increase4>(/) -
•• decrease <t>(r)
sr
*decrease $>{r)
V
increase 0(/K
W
increase $(/)•>
K
>decrease <£(r)
7
y = &(x)
7
Three applications ofbinarysearch
519

520
Algorithms and Data Structures
Fast algorithms are an essential element of the modern world, and binary search
is a prototypical examplethat illustrates the impact of fast algorithms.With a few
quickcalculations,you canconvince yourselfthat problemslikefindingallthe mis
spelled wordsin a documentor protecting your computer from intruders usingan
exceptionfilterrequire a fastalgorithmlikebinary search.Take the time todoso. You
can find the exceptions in a million-entry document to a million-entrywhitelist
in an instant, whereas that task might take days or weeks using the brute force
algorithm.Nowadays, webcompanies routinelyprovide services that are based on
using binarysearch billions oftimes in tables with billions ofentries—without a fast
algorithm likebinary search,wecould not contemplate such services.
Whether it be extensive experimental data or detailed representations of
some aspect of the physicalworld, modern scientists are awashin vast amounts of
data.Binarysearch and fast algorithms like it areessential componentsof scientific
progress. Using a brute-force algorithm is precisely analogous to searchingfor a
wordin adictionarybystartingat thefirstpageand turning pages onebyone.With
a fastalgorithm,you canliterally search amongbillionsof pieces of information in
an instant.Taking the timeto identify and usea fast algorithm for search certainly
canmake thedifference between being able to solve a problemeasily and spending
substantialresources trying to do so (and failing).

4.2 Sorting and Searching
521
Insertion sort
Binary search requires that the databe sorted, and sorting has
many other directapplications, sowe now turn to sortingalgorithms.We first con
sider a brute-force method, then a sophisticated method that we can use for huge
data sets.
The brute-force algorithm is known asinsertion sortand is based on a simple
method that people often use to arrange hands ofplayingcards. Consider the cards
one at a time and insert each into its proper placeamong those alreadyconsidered
(keeping them sorted). The following code mimics this process in a Java method
that sorts strings in an array:
public static void sort(String[] a)
{
int N = a.length;
for (int i
= 1;
i
< N; i++)
for (int j = i;
j > 0;
j—)
if (a[j-l].compareTo(a[j]) > 0)
exch(a, j-1, j);
else break;
}
The outer for loop sorts the first i entries in the array; the inner for loop com
pletesthe sortby putting a[i ] into its properpositionin the array, asin the follow
ing example when i is 6:
1
3
0
1
2
3
4
5
6
7
6
6
and
had
him
his
was
you
the
but
6
5
and
had
him
his
was
the
you
hut
6
4
and
had
him
his
the
was
you
hut.
and
had
him
his
the
was
you
but
Inserting a[6] intoposition byexchanging with larger entries to itsleft
Entry a[i] is put in its place among the sorted entries to its left by exchanging
it (using the exch() method that we first encountered in Section 2.1) with each
largerelement to its left, moving from right to left, until it reaches its proper posi
tion. The black entries in the three bottom rows in this trace are the ones that are
compared (and exchanged,on allbut the final iteration).
The insertion process just described isexecuted, first with i equalto 1,then 2,
then 3, and so forth, as illustrated in the following trace.

522
Algorithms and Data Structures
1
J
0
1
2
3
4
5
6
7
was
had
him
and
you
his
the
but
1
0
had
was
him
and
you
his
the
hut
2
1
had
him
was
and
you
his
the
but
3
0
and
had
him
was
you
his
the
but
4
4
and
had
him
was
you
his
the.
but
5
3
and
had
him
his
was
you
the
hut
6
4
and
had
him
his
the
was
you
but.
7
1
and
but
had
him
his
the
was
you
and
but
had
him
his
the
was
you
Inserting all] through a[N-l] into position (insertion sort)
This trace displaysthe contents of the array eachtime the outer for loop completes,
along with the value of j at that time. The highlighted element is the one that was
in a[i ] at the beginning of the loop, and the other elements printed in black are
the other ones that were involved in exchanges and moved to the right one posi
tion within the loop. Sincethe elements a[0] through a[i -1] are in sorted order
when the loop completes for eachvalue of i, they are, in particular, in sorted order
the final time the loop completes, when the value of i is a. 1ength. This discussion
again illustrates the first thing that you need to do when studying or developing a
new algorithm: convinceyourselfthat it is correct. Doing so provides the basic un
derstanding that you need in order to study its performance and use it effectively.
Analysis of running time. The inner loop of the insertion sort code is within a
double for loop, which suggests that the running time is quadratic, but we cannot
immediately draw this conclusion, because of the break. For example, in the best
case,when the input array isalreadyin sorted order, the inner for loop amounts to
nothing more than a comparison (to learn that a [j -1] is less than a [j ] for each j
from 1 to N-l) and the break, so the total running time is linear. On the other
hand, in the reverse-sorted case,the inner loop fullycompletes without a break, so
the frequencyof executionof the instructions in the inner loop is 1 + 2 + ... +
N— 1 ~ N2 and the running time is quadratic. To understand the performance of
insertion sort for randomly ordered input, take a careful look at the trace: it is an
N-by-N arraywith one blackelementcorresponding to each exchange. That is,the
number of black elements isthe frequencyof execution of instructions in the inner

4.2 Sorting and Searching
523
loop.Weexpectthat eachnewelementto be insertedisequallylikelyto fallinto any
position, so that element willmove halfway to the left on average. Thus, on the av
erage,we expect only about one-halfthe elementsbelowthe diagonal (about N2/4
in total) to be black,. This leads immediately to the hypothesis that the expected
running time of insertion sort for a randomly ordered input array is quadratic.
Sorting other types of data. We want to be able to sort alltypesof data, not just
strings. In a scientificapplication, we maywish to sort experimental results by nu
meric values; in a commercial application, we may wish to use monetary amounts,
times, or dates; in systems software, we might wish to use IP addresses or account
numbers. The idea of sorting in each of these situations isintuitive, but implement
ing a sort method that works in all of them is
a prime example of the need for a functional
~N72 entries ahove the diasoml are shaded
abstraction mechanism like the one provided
unshaded
\
by Java. For sorting objects in an array, we
e%r!eLZ6^^ was had him and y°u his t:he but
7 t
.
,
,
,
j
had was him and vou his the but
need only assume that we can compare two el-
that moved
had Mm was and you his the but
ements to see whether thefirst isbigger than,
™* US K» w^ 12 ^t T* tl
oo
'
and had him was you his the but
Smaller than, Or equal tOthe Second. Java pro-
N2 entries^r and had him his was you the but
. ,
,
_.
, ,
r
r
•
i
in total
and had him his the was
you but
vides the Comparable interface for precisely
and but had him his the was you
this purpose. Simply put, a class that imple-
S
ments the Comparable interface promises to
_NV4 (half) ofthe entries below the
implement a method COmpareTo() for Objects
diagonal on the average, are black
of its type so that a.compareTo(b) returns a
negative integer ifa is less than b, a positive
Analysis ofinsertion sort
integer if a is greater than b, and 0 if a is equal
to b.The precise meanings of less than, greater than, and equal toare up to the data
type, though implementations that do not respect the natural laws of mathematics
surrounding these concepts will yield unpredictable results.With this convention,
we can implement our sort method so that it sorts arrays of Comparable objects,
and use compareToO to compare them, as illustrated in Insertion (Program
4.2.4).As discussed in Section 3.3,Java's Stri ng type implements the Comparable
interface (we have been using its compareToO method), as does the Date type and
wrappers for primitive numeric types such as Integer and Double. Thus, we can
use Inserti on. sort () to sort arrays of all of these types of data. It is also easyto
implement the interface so that we can sort user-defined types of data, as we saw
in Section 3.3.

524
Algorithms and Data Structures
*&4
M
Program 4.2.4
Insertion sort
public class Insertion
{
public static void sort(Comparable[] a)
{
// Sort a[] into increasing order,
int N = a.length;
for (int i =1;
i
< N; i++)
// Insert a[i] into position by exchanging
// it with the larger elements to its left,
for (int j = i;
j > 0; j--)
if (a[j-l].compareTo(a[j]) > 0)
exch(a, j-1, j);
else break;
}
public static void exch(Comparable[] a, int i, int j)
{
Comparable t
= a[j]; a[j] = a[j-l];
a [j-1] = t;
}
public static void main(String[] args)
{
// Read strings from standard input, sort them,
and print.
String[]
a = Stdln. readAllO .split(,,\\s+M) ;
sort(a);
for (int i
= 0;
i
< a.length;
i++)
StdOut.print(a[i] + " ");
StdOut.println();
}
}
The sort O function isan implementation ofinsertion sort. Itsorts arrays ofanytype ofdata
thatimplements the Comparableinterface (has a compareToO method). This method isap
propriateforsmallfiles orforlargefiles that are nearly inorder, butis too slow touseforlarge
filesthatareoutoforder.
w^^^^^w^^ss^^^^^^^^^^^^^^^^^^^^^^^^^^w^w
% more tiny.txt
was had him and you his the but
% Java Insertion < tiny.txt
and but had him his the was you
% Java Insertion < TomSawyer.txt
tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick
tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick
tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick
tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick
tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick tick
^^^^^^Si^^^^S^^^^^^P^S^S^^BSS^^^^^^^^^lRSIS^^IBHP^PS&&mt&3^&w?-'-

4.2 Sorting and Searching
525
Empirical analysis. Inserti onTest (Program4.2.5) testsour hypothesisthat in
sertion sort is quadratic for randomly ordered files by running Inserti on. sort()
on N random Doubl e values,computing the ratios of running times as N doubles.
This ratio convergesto 4, which validates the hypothesis that the running time is
quadratic, as discussed in the last section. You are encouraged to run Insertion-
Test on your own computer. As usual, you might notice the effect of caching or
some other system characteristic for some values of JV, but the quadratic running
time should be quite evident, and you willbe quicklyconvincedthat insertion sort
is too slow to be useful for large inputs.
Sensitivity to input.
Note that Inserti onTest takesa command-line argument
Tand runs Texperiments for eacharraysize, not just one.Aswehavejust observed,
one reason for doing so is that the running time of insertion sortis sensitive to its
inputvalues. This behavior is quite different from (for example) ThreeSum, and
means that we have to carefully interpret the results of our analysis.It is not correct
to flatly predict that the running time of insertion sort will be quadratic, because
your application might involve input for whichthe running time islinear.When an
algorithm's performance is sensitive to input values, you might not be ableto make
accurate predictions without taking the input values into account.
There are many natural applications for which insertion sort is quadratic, so we
need to consider faster sorting algorithms.Asweknow from Section 4.1,a back-of-
the-envelope calculation can tell us that havinga fastercomputer is not much help.
Adictionary,a scientificdatabase,or a commercialdatabasecan contain billions of
entries; how can we sort such a large array?

526
Algorithms and Data Structures
Program 4.2.5
Doubling test for insertion sort
public class InsertionTest
{
public static double timeTrials(int T, int N)
{
// Sort T random arrays of size N.
double total =0.0;
Doubled
a = new Double[N];
for (int t
= 0;
t
< T; t++)
{
for (int i
= 0;
i
< N; i++)
a[i] = Math.random();
Stopwatch watch = new Stopwatch();
Insertion.sort(a);
total += watch.elapsedTimeO;
}
return total;
}
public static void main(String[] args)
{
// Print doubling ratios for T trials of insertion sort
int T = Integer.parselnt(args[0]);
double prev = timeTrials(T,
512);
for (int N = 1024; true;
N += N)
{
double curr =
timeTrials(T,
N);
StdOut.printf(M%7d %4.2f\n",
N, curr /
prev);
prev
= curr;
}
}
}
The method ti meTri al s () runs Inserti on. sort () forarrays ofrandom double values. The
first argument is the length of the array; the second is the number of trials. Multiple trials
produce more accurate results because they dampen system effects andbecause insertion sorfs
runningtime depends on theinput.
% Java InsertionTest 1
1024 0.71
2048
3.00
4096
5.20
8192
3.32
16384 3.91
32768
3.89
^"^^^^^^^^^^^^^^^^^^^s^^^^^^
Java InsertionTest 10
1024 1.89
2048
5.00
4096 3.58
8192 4.09
16384 4.83
32768
3.96
^^l^^^^^m^^^^^W^^^^W^^^^^^^^^S^^

4.2 Sorting and Searching
Mergesort
To develop a faster sorting method, we use recursion (as we did for
binary search) and a divide-and-conquer approach to algorithm design that every
programmer needs to understand. This nomenclature
refers to the idea that one way to solve a problem is to
divide it into independent parts, conquer them inde
pendently, and then use the solutions for the parts to
develop a solution for the full problem. Tosort an array
with this strategy,we divide it into two halves, sort the
two halvesindependently, and then merge the results to
sort the full array. This method is known as mergesort.
We process contiguous subarrays of a given array,
using the notation a[lo, hi) to refer to a[lo],
a[l o+l],..., a [hi -1] (adopting the same convention as we used for binary search
to denote a half-open interval that excludesa [hi ]). Tosort a [1o, hi), we use the
following recursive strategy:
• Basecase: If the subarray sizeis 0 or 1,it is already sorted.
• Recursive step:Otherwise, compute mi d = 1o + (hi - 1o)/2, sort (recur
sively) the two subarrays a [1o, mi d) and a [mi d, hi), and merge them.
Merge (Program 4.2.6) is an implementation of this algorithm. The array elements
are rearranged by the code that follows the recursive calls, which merges the two
halves of the array that were sorted by the recursivecalls. As usual, the easiest way
to understand the merge process is to study a trace of the contents of the array dur
ing the merge. The code maintains one index i into the first half, another index j
527
input
was had him and you his the but
sort left
and had him was you his the but
sortright
and had him was but his the you
merge
and but had him his the was you
Mergesort overview
i
j
k
aux[k]
0
1
2
3
4
5
6
7
and
had
him
was
but
his
the
you
0
4
0
and
and
had
hi in
wa s
but
his
the
you
1
4
1
but
and
had
him
was
but
his
the
you
1
5
2
had
and
had
hi in
was
but
his
the
you
2
5
3
him
and
had
him
was
hut
his
the
you
3
5
4
his
and
had
hi in
was
but
his
the
you
3
6
5
the
and
had
him
was
hut
h is
the
you
3
6
6
was
and
had
him
was
but
his
the
you
4
7
7
you
and
had
him
was
but:
his
the
you
Trace of the merge of thesorted lefthalfwith thesorted righthalf

528
Algorithms and Data Structures
Program 4.2.6
Mergesort
public class Merge
{
public static void sort(Comparable[] a)
{
sort(a, 0, a.length);
}
public static void sort(Comparable[] a, int lo, int hi)
{
// Sort a[lo, hi),
int N = hi
- lo;
if (N <= 1) return;
int mid = lo + N/2;
sort(a, lo, mid);
sort(a, mid, hi);
Comparable[] aux = new Comparable[N];
int i
= lo,
j = mid;
for (int k = 0;
k < N;
k++)
if
(i == mid)
aux[k] = a[j++];
else if (j «
hi)
aux[k] = a[i++];
else if (a[j].compareTo(a[i]) < 0) aux[k] = a[j++];
else
aux[k] = a[i++];
for (int k = 0;
k < N; k++)
a[lo + k]
= aux[k];
}
public static void main(String[] args)
{
/* See Program 4.2.4 (and text) */
}
a[lo, hi)
N
mid
aux[]
subarray tosort
sizeofsubarray
midpoint
extra arrayfor merge
}
The sort() function in this class is afast method thatyou can useto sortarrays of any type
of data thatimplements Comparable. It is based on a recursive sort () thatsorts a [1o, hi)
bysorting its two halves recursively then merging together thetwo halves to create thesorted
result. The output below andat right isa trace ofthe sorted subarrayforeach call tosort Q. In
contrast toInserti on, this implementation issuitableforsorting huge arrays.
java Merge < tiny.txt
was had him and you his the but
had was
and him
and had him was
his you
but the
but his the you
and but had him his the was you
'•^Mmmmmmm
mmmmmwm
nSWSH^^^^

4.2 Sorting and Searching
529
into the second half,and a third index kinto an auxiliaryarray aux [] that holds the
result. The merge implementation is a singleloop that sets aux[k] to either a[i]
or a [j ] (and then increments k and the index for the value that is used). If either i
or j has reached the end of its subarray, aux[k] is set from the other; otherwise, it
is set to the smaller of a [i ] or a [j ]. After all of the elements from the two halves
have been copied to aux[], the sorted result is copied back to the original array.
Take a moment to study the trace just givento convinceyourself that this code al
waysproperly combines the two sorted subarrays to sort the full array.
The recursive method ensures that the two halves of the array are put into
sorted order before the merge. Again, the best way to gain an understanding of
this process is to study a trace of the contents of the array each time the recursive
sort() method returns. Sucha trace for our exampleisshown next. First a [0] and
a[l] are merged to make a sorted subarray in a[0, 2), then a[2] and a[3] are
merged to make a sorted subarray in a[2, 4), then thesetwo subarrays ofsize2 are
merged to make a sorted subarray in a[0, 4), and so forth. If you are convinced
that the mergeworks properly,you need only convinceyourselfthat the code prop
erlydividesthe array to be convincedthat the sort worksproperly. Note that when
the number of elements is not even, the left half will have one fewer element than
the right half.
0
12
3
4
5
6
7
was
had
him
and
you
his
the
but
sort(a, 0,
8)
sort(a, 0, 4)
sort(a, 0,
2)
return
had
was
him
and
you
his
the
but
sort(a, 2, 4)
return
had
was
and
him
you
the
the
but
return
and
had
him
was
you
the
the
but
sort(a, 4, 8)
sort(a, 4,
6)
return
and
had
him
was
his
you
the
but
sort(a, 6,
8)
return
and
had
him
was
his
you
but
the
return
and
had
him
was
but
his
the
you
return
and
but
had
him
his
the
was
you
Trace of recursive mergesort calls

530
Algorithms and Data Structures
Analysis of running time. Theinnerloopof mergesort iscentered on the auxil
iary array.The two for loops involve N iterations (and creating the array takestime
proportional to N), so the frequency of execution of the instructions in the inner
loop is proportional to the sum of the subarray sizes for all calls to the recursive
function. The value of this quantity emerges when we arrange the calls on levels
according to their size.For simplicity, suppose that JV is a power of 2, with N = 2n.
On the first level, we have one call for size iV;
1x N/i = n
i
^^3
on the second level, we have two calls for
2x n/2 = n
i
ji
zi
size N/2; on the third level, we have four
4xjv/4 =n I
ii
n
||
I
igN
calls for size N/4; and so forth, down tothe
8xn/8 =n
cUEOOJOJOJEJEJCn *" &*
last level with N/2 calls ofsize 2. There are
preciselyn = IgiVlevels,giving the grand to-
n/2 x 2 = n
nnQD
DDDD
tal N IgiV for the frequency of execution of
Total: Nign
the instructions in the inner loop of merge-
Mergesort inner loop count (when Nis apower of2)
sort This equation justifies a hypothesis
that the running time of mergesort is lin
earithmic. Note: When iVis not a power of
two,the subarrayson eachlevel are not necessarily allthe same size, but the num
ber of levels is stilllogarithmic, so the linearithmic hypothesis is justifiedfor allN
(see Exercises 4.2.16-17).
You are encouraged to run a doubling test such as Program 4.2.5for Merge.
sort O on your computer. Ifyou do so,you certainlywillappreciate that it ismuch
faster for large files than is Insertion.sort() and that you can sort huge arrays
with relativeease.Validatingthe hypothesisthat the running time is linearithmic is
a bit more work,but you certainlycanseethat mergesort makesit possiblefor us to
addresssorting problemsthat wecouldnot contemplatesolvingwith a brute-force
algorithm such as insertion sort.
Quadratic-linearithmic chasm. The difference between N2 and NlgiV makes a
huge difference in practical applications, just the same as the linear-logarithmic
chasmthat isovercomebybinary search.Understandingtheenormousness ofthis dif
ference isanother criticalstep tounderstandingthe importance ofthe design andanal
ysisofalgorithms. For a great many important computational problems, a speedup
from quadratic to linearithmic—such as we achieve with mergesort—makes the
differencebetween the ability to solve a problem involving a huge amount of data
and not being able to effectively address it at all.

4.2 Sorting and Searching
531
Divide-and-conquer algorithms. Thesame basic approach iseffective for many
important problems, as you will learn if you take a course on algorithm design.
For the moment, you are particularly encouraged to study the exercises at the end
of this section, which describe a host of problems for which divide-and-conquer
algorithms provide feasible solutions and which could not be addressed without
such algorithms.
Reduction to sorting. A problem A reduces to a problem Bif wecan use a solu
tion to B to solveA. Designing a new divide-and-conquer algorithm from scratch
is sometimes akin to solving a puzzle that requires some experience and ingenuity,
so you may not feelconfident that you can do so at first.But it is often the casethat
a simpler approach is effective: givena new problem that lends itself to a quadratic
brute-force solution, ask yourself how you would solveit if the data were sorted. It
often turns out to be the casethat a relatively simple linear pass through the sorted
data will do the job. Thus, we get a linearithmic algorithm, with the ingenuity hid
den in the mergesort implementation. For example, consider the problem of de
termining whether the elements in an array are all different. This problem reduces
to sorting because we can sort the array,and then pass through the sorted array to
checkwhether any entry is equal to the next—if not, the elements are all different.
For another example, an easyway to implement StdStats. sel ect() (see Section
2.2) is to reduce selection to sorting. We consider next two more complicated ex
amples, and you can find many others in the exercises at the end of this section.
Mergesort traces backto john von Neumann, an accomplished physicist,who was
among the first to recognize the importance of computation in scientific research.
Von Neumann made many contributions to computer science, including a basic
conception of the computer architecture that has been used since the 1950s.When
it came to applications programming, von Neumann recognized that:
• Sorting is an essential ingredient in many applications.
• Quadratic algorithms are too slow for practical purposes.
• A divide-and-conquer approach is effective.
• Proving programs correct and knowing their cost is important.
Computers are many orders of magnitude faster and have many orders of magni
tude more memory, but these basic concepts remain important today. People who
use computers effectively and successfully know, as did von Neumann, that brute-
force algorithms are often not good enough to do the job.

532
Algorithms and Data Structures
Application: frequency counts
FrequencyCount (Program 4.2.7) reads a
sequence of strings from standard input and then prints a table of the distinct
values found and the number of times each was found, in decreasing order of the
frequencies. This computation is usefulin numerous applications: a linguist might
be studying patterns of word usage in long texts, a scientist might be looking for
frequently occurring events in experimental data, a merchant might be looking
for the customers who appear most frequently in a long list of transactions, or a
network analyst might be looking for the heaviest users. Each of these applications
might involvemillions of strings or more, so we need a linearithmic algorithm (or
better). FrequencyCount is an example of developing such an algorithm by reduc
tion to sorting. It actuallydoes two sorts.
Computing thefrequencies. Our first stepisto sort the strings on standardinput.
In this case,we are not so much interested in the fact that the strings are put into
sorted order, but in the fact that sorting brings equal strings together. If the input is
to be or not to be to
then the result of the sort is
be be not or to to to
with equal strings, such as the two occurrences of be and the three occurrences of
to, brought together in the array. Now,with equal strings all together in the array,
we can make a single pass through the array to compute all of the frequencies. The
Counter data type that we considered in Section 3.3 is the perfect tool for the job.
Recall that a Counter has a string instance variable (initialized to the construc
tor argument), a count instance variable (initialized to 0), and an incrementO
instance method, which increments the counter by one. We maintain an array of
Counter objects and do the followingfor each string:
• If the string is not equal to the previous one, create a new Counter.
• Increment the most recently created Counter.
At the end, the value of Mis the number of different string values, and zi pf[i ]
contains the i th string value and its frequency.
Sorting the frequencies. Next, we sort the Counter objects byfrequency. We can
do so in client code without any special arrangements because Counter imple
ments the Comparable interface (and therefore has a compareToO method). We

4.2 Sorting and Searching
533
"\&.
•4.-?
I
1
'11
IS
i^^&^^^M
Program4.2.7
Frequency counts
public class FrequencyCount
{
public static void main(String[] args)
{
// Print input strings in decreasing order
// of frequency of occurence.
String s = Stdln.readAl1();
String[] words = s.split("\\s+") ;
Merge, sort (words);
Counter[] zipf = new Counter[words.1ength];
int M = 0;
for (int i = 0;
i < words.length; i++)
{
// Create new counter or increment prev counter,
if (i — 0 ||
!words [i]. equals (words [i-1]))
zipf[M++] = new Counter(words[i], words.1ength);
zipf [M-l] .incrementQ;
}
}
Merge.sort(zipf,
0,
M);
for (int j = M-l; j >= 0; j—)
StdOut.pri ntln(zi pf[j]);
This program sorts the words on standard input, uses the sorted list to count the frequency of
occurrence ofeach, andthen sorts the frequencies. The testfile used below has over 20 million
words. The plotcompares the i th frequency relative to thefirst (bars) with 1/i (blue)..
% Java FrequencyCount < LeipziglM.txt
1160105 the
593492 of
560945 to
472819
a
435866 and
430484 in
205531 for
192296 The
188971 that
172225 is
148915 said
147024 on
141178 was
118429 by
I
!
^^^w^^^^^^s^^^^^^^^SSf^P^^I^K^^^^^^^^^
I
SSK^SE^CKaJsl^SsnS^

534
Algorithms and Data Structures
simply sort the array! Note that FrequencyCount allocates zipf[] to its maxi
mum possible size and sorts a subarray, as opposed to the alternative of making
an extrapassthrough words [] to determine the number of distinctentriesbefore
allocating zipf[]. Leaving its recursive sort() function
for subarrays public (there is not reason not to) allows
MergeSort to support such applications.
Zipfs law. The application highlighted in Frequency-
Count is elementary linguistic analysis: which words ap
pear most frequently in a text? A phenomenon known as
Zipfs law says that the frequency of the ith most frequent
word in a text of M distinct words is proportional to 1/i,
with its constant of proportionalitythe Harmonic number
HM. Forexample, the secondmost common word should
Counting thefrequencies
appear about half a$ often as ±efirst This is an empirical
hypothesis that holds in a surprising variety of situations
rangingfrom financial data to webusage statistics. The test clientrun in Program
4.2.7validates Zipfs lawfor a databasecontaining 1 million sen-
tencesdrawn from popular publications(seethe booksite).
Youare likelyto find yourselfwritinga program sometime in the
future for a simple task that could easily be solvedby first using
a sort. How many distinct valuesare there?Which value appears
most frequently? Arethe stringsalldifferent? Which is the medi
an element?With a linearithmic sorting algorithm such asmerge
sort, you can address these problems and many other problems
like them, even for huge data sets. FrequencyCount, which uses
two differentsorts, is a prime example. If sorting does not apply
directly, some other divide-and-conquer algorithm might apply,
SortmZthefre1uencies
or some more sophisticated method might be needed. Without a
good algorithm (and an understanding of its performance char
acteristics), you might find yourselffrustrated by the idea that your fast and ex
pensive computer cannot solve a problemthat seems to be a simpleone.With an
ever-increasing setofproblemsthat youknowhowto solve efficiently, youwillfind
that your computer can be a much more effective tool than you now imagine.Toil
lustrate this idea, we consider next an application to a problem in bioinformatics.
M
a[1]
zipf[i] .count0
i
0
1
2
3
0
0
1
be
1
1
1
be
2
2
2
not
•y
1
3
3
or
2
1
1
4
4
to
2
1
1
1
5
4
to
2
1
1
2
6
4
to
2
1
1
3
2
1
1
3
before
0
2
be
1
1
not
2
1
or
3
3
to
after
0
1
not
1
1
or
2
2
be
3
3
to

4.2 Sorting and Searching
535
Application:longest repeated substring
Another important computational
taskthat reduces to sortingisthe problemof finding the longest repeated substring
in a given string. For example, the longestrepeatedsubstring in the string to be
or not to be is the string to be. This problem is simpleto state and has many
important applications,including data compression,cryptography, and computer-
assistedmusic analysis. Think brieflyabout howyou might solve it. Could you find
the longestrepeated substring in a string that has millionsof characters?
Another applicationis refactoring code. Programmersoften put together new
programs bycutting-and-pasting codefrom oldprograms.In alargeprogram built
over a long period of time, replacing duplicate code by function calls to a single
copy of the code can make the program much easierto understand and maintain.
This improvement can easily be accomplished by findinglong repeatedsubstrings
in the program. Documented success storiesof using this approach on large sys
tems have led to its being a standard technique in the repertoire of people who
develop large software systems.
Another application is found in computational biology. Aresubstantial iden
ticalsubstringsto be found in a genome? Again, the basiccomputational problem
underlyingthis questionisto findthe longest repeated substringin a string.Scien
tists are typically interested in more detailed questions (indeed, the nature of the
repeated substrings is preciselywhat scientistsseekto understand), but such ques
tions are certainly no easier than the basic question of finding the longest repeated
substring. Various modifications of our solution to this problem can solve other
problems of interest, as addressed in severalof the exercises.
With such applications in mind, we now focus on the basic computational
problem of finding the longest repeatedsubstringin a given string.
Longest common prefix. As awarm-up, consider thefollowing simple task: given
two strings,find their longestcommon prefix(the longestsubstring that is a prefix
of both strings). For example,the longestcommon prefixof acctgttaac and ac-
cgttaa is ace. The following codefor solvingthis problem isa usefulstarting point
for addressingmore complicatedtasks:

536
Algorithms and Data Structures
public static String lcp(String s, String t)
{
int N = Math.min(s.length() , t.lengthO);
for (int i
= 0;
i
< N; i++)
if (s.charAt(i)
!= t.charAt(i))
return s.substring(0, i);
return s.substring(0,
N);
}
This code is trickier than it looks:you should convinceyourself that it works prop
erlywhen the first charactersof the two strings are different,when one or both of
the strings are of length 0, and the two cases when each of the strings is a prefixof
the other.
Brute-force solution. Now, how do we find the longest sequence of characters
that is repeated in a givenstring?With lcp(), the following brute-force solution
immediately suggestsitself:
public static String lrs(String s)
{
String Irs = "";
for (int i
= 0;
i
< N; i++)
{
for (int j = i+1;
j < N; j++)
{
String x = lcp(s.substring(i,
N), s.substring(j, N));
if (x.lengthO > Irs.lengthO)
Irs = x;
}
}
return Irs;
}
We compare the substring starting at each string position i with the substring
starting at eachother starting position j, keepingtrack of the longestmatch found.
This code is not useful for long strings,because its running time is at least quadratic
in the length of the string: by examiningthe nested for loops, it is easyto see that
the number of callson 1cp() is N—1 + N—2 + ... + 2 + 1 ~ N2. Using this code
for a genomic sequencewith millionsof characterswould require trillions of 1cp()
calls, which is infeasible.

4.2 Sorting and Searching
537
Suffix sortsolution. Thefollowing clever approach, which again takes advantage
of sorting in an unexpected way, is an effective way to find the longest repeated
subsequence, evenin hugestrings: weusesubstri ng() to makean arrayof strings
that consists of the suffixes of s (the substrings starting
at eachposition and goingto the end), and then wesort
this array. The key to the algorithm is that every sub
string appears somewhere as a prefix of one of the suf
fixes in the array.Aftersorting,the longestrepeatedsub
strings will appear in adjacent positions in the array
(like the equal keys in FrequencyCount). Thus, we can
proceed just as we did for FrequencyCount: make a sin
gle pass through the sorted array, keeping track of the
longestmatchingprefixes between adjacent strings. LRS
(Program 4.2.8) is an implementation of this method.
This program is significantly more efficient than the
brute-forcemethod. Analyzing itsperformancedepends
upon an understanding of details of Java's Stri ng im
plementation, which we examine next. The end result is
that the running time is linearithmic(unless the length
of the repeat is huge), and so we certainlycan handle
strings with millions of characters.
String representation. The running time of LRS is
strongly dependent on the way that Java represents
Stri ng objects, so we briefly revisit the representation.
Avalue of the Stri ng data type is a sequenceof charac
ters. Java represents them using an array of characters,
plus the offset to the first character and the length.As
witharrays, the implementationcanreturn thelengthin
constant time. Also, the string data type is immutable (it
has no methods to changeanystring'svalue),soJava can
reuse the array holding the characters. In the present
context,the most important consequence of this design
is that the substri ng() method does nottaketime proportional to the length of
the result,but insteadrequires just a few machine instructions: it simplycalculates
the necessaryoffsetto the first character and length in a straightforward manner.
inputstring
012345678 91011121314
aacaagtttacaagc
suffixes
o
1
2
3
4
5
6
7
8
9
10
11
12
13
14
aacaagtttacaagc
acaagtttacaagc
caagtttacaagc
aagtttacaagc
agtttacaagc
gtttacaagc
tttacaagc
ttacaagc
t a c aa g c
a c aa g c
c aag c
a ag c
age
gc
c
sorted suffixes
o aacaagtttacaagc
n
a a g c
3 aagtttacaagc
9
a c a a g c
i acaagtttacaagc
12 ag c
4 agtttacaagc
14
C
io
c a a g c
2 caagtttacaagc
13
g c
5 gtttacaagc
8 tacaagc
7 ttacaagc
6 tttacaagc
longest repeated substring
l
9
aacaagtttacaagc
Computing theLRS bysortingsuffixes

538
288
311
407
Algorithms and Data Structures
Therefore, the substring operation in Java takes constant time and space.Javapro
grammers are well-advised to take advantage of this efficient implementation of
substringO.
288
|e—a.length
mmm:.
407
311
462
12
459
ttt a
c aag
Hel 1
W
o r 1 d
string
objects
"tttacaagc";
'Hello, World"
311
407
iSl^-V.fV^W.TJ^.::
Ill
exch(a, 0,
1)
Exchanging twostrings in an array
Sorting
strings. Given
an
array of strings,
we can rearrange them so that they appear
in lexicographic order in the array (the or
der they would appear in a dictionary) with
Merge.sort() because String implements the
Comparabl e interface. It is very important to note
that this approach is effective for long strings and
large objects because of the Java reference repre
sentation for objects: when weexchange two objects,
weare exchanging onlyreferences, notthewhole ob
ject. Now, the costof comparingtwo strings maybe
proportional to the length of the strings in the case
when their common prefix is very long, but most
comparisons in typical string sort applications in
volve only a fewcharacters. If so, the running time
of the string sort is linearithmic.
Suffix arrays. From the standpoint of the sort,
there is no differencebetween sorting an array of
strings and sorting a suffix array: both refer to an
array of references to strings. A suffix array is an
arrayof string objects,eachconsistingof the stan
dard object overhead, a reference to an array of
char values,an offset,a length, (and a hash value).
Suffix arrays are characterized by the fact that all
of the array references are to the same char array,
which holds the string of interest, and that each
possible offset and length appears once.
LRS analysis. We cannowseewhythe suffix sort
ing approach to solving the longest repeated substring problem in Program 4.2.8
is effective, even though the suffixes of a verylong string are themselvesvery long.

4.2 Sorting and Searching
539
ZW:^i^mimmaaam^^Mmm^ismi^
:M
m
•x- ?•>•
fm
&£?&!
Program 4.2.8
Longest repeated substring
public class LRS
{
public static String lcp(String s, String t)
{
// See text.
}
public static String Irs(String s)
{
// Find the longest repeated substring in s.
// Create and sort suffix array.
int N
= s.lengthO ;
String[] suffixes = new String[N];
for (int i
= 0;
i
< N; i++)
suffixes[i] = s.substring(i,
N);
Merge.sort(suffixes);
s
N
suffixes []
Irs
inputstring
length
suffixarray
longest repeated
substring
String Irs = "";
for (int i
= 0;
i
< N-l;
i++)
{
// LRS is longest common prefix in adjacent strings.
String x = lcp(suffixes[i], suffixes[i+1]);
if (x.length() > Irs.lengthO)
Irs = x;
}
return Irs;
}
public static void main(String[] args)
{
// Find the longest repeated substring in Stdln.
String s = Stdln.readAll();
StdOut.println(lrs(s));
}
;«^s^:?PSW!iKP^^K!
}
To find the longest repeated substring in a string, we form an array ofall the strings suffixes,
sort the array, andthenfind the longest common prefix ofadjacent strings in the result.
% more example.txt
aacaagtttacaagc
% Java LRS < example.txt
acaag
% Java LRS < genome.txt
aaactcgacaaacccatttaccccacactttt
Wg^^1m!!&^wz&&&&m&
^^$mW&^$&^^r%$^m^%i&

540
Algorithms and Data Structures
String s = "ATAGATGCATACCGCATAGCTAGATGTGCTAGCAT"
int N
= s.lengthO;
String[] suffixes = new String[N];
for (int i =0;
i < N; i++)
suffixes[i] = s.substringO',
N);
16 bytes
suffixes []
Total: 16 + 4N + NX24 + 16 + 2N = 32 + 30N
16 bytes
2N bytes
Memory requirementsfor a suffix array
The total length of the suffixes isquadratic,but the actual spaceused is onlylinear,
becauseJava representseachsubstringwith a constant amount of extra space. The
substringO operations all take constant time, most string comparisons involve
only a fewcharacter comparisons, and all exchanges are fast because they just in
volve exchanging references. In summary,this discussion supports the hypothesis
that the running time of Program 4.2.8 is linearithmic. We expect the sort to be
linearithmic, and then we make a singlepass through the string to find the longest
common prefix among adjacent substrings.
Longrepeats. Amore preciseanalysis showsthat our suffixsorting approach (and
finding the longest repeated substring) is quadratic (or worse) in the length of the
repeated substring, because each suffixofthe repeated substring appears twice as a

4.2 Sorting and Searching
541
prefix in the suffixarray and requires time proportional to its length for 1cp() and
for comparisons during the sort. Accordingly, computational biologists and com
puter scientists have developed more sophisticated
algorithms to look for repeated substrings whose
length is substantially longer than the square root of
the string length.
Lessons
The vast majority of programs that we
write involvemanaging the complexityof addressing
a new practical problem by developing a clearand cor
rect solution, breaking the program into modules of
manageable size whenever possible, and making use
of the basic available resources. From the very start,
our approach in this book has been to develop pro
grams along these lines. But as you become involved
in ever more complex applications, you will find that
a clear and correct solution is not always sufficient,
because the cost of computation can be a limiting fac
tor. The examples in this section are a basic illustra
tion of this fact.
Respect thecostof computation. Ifyou canquickly
solve a small problem with a simple algorithm, fine.
But if you need to address a problem that involvesa
large amount of data or a substantial amount of computation, you need to take
into account the cost.
input string
aacaagtttacaagc
suffixes of longest repeat (M
ac aag
c aag
aag
ag
g
--5)
all appearat least
twiceas a prefixof
a suffixstring
sortedsuffixes of input
aacaagtttacaagc
a a g c
aagtttacaagc
a c a a g c
acaagtttacaagc
age
agtttacaagc
c
c a a g c
caagtttacaagc
gc
gtttacaagc
t ac a ag c
ttacaagc
tttacaagc
comparison costis at least
1+2 + ...+M- M2/2
LRS costisquadratic in repeat length
Reduce to a known problem. Our useof sortingfor frequency counting and for
solvingthe longest repeated substring problem illustratesthe utility of understand
ing fundamental algorithms and using them for problem solving.
Divide-and-conquer. It isworthwhile foryouto reflect a bit on the powerof the
divide-and-conquer paradigm, as illustrated by developing a logarithmic search
algorithm (binary search) and a linearithmic sorting algorithm (mergesort) that
serves as the basis for addressing so many computational problems. Divide-and-
conquer is but one approach to developing efficient algorithms.

542
Algorithms and Data Structures
Since the advent of computing, people have been developing algorithms such as
binary search and mergesort that can efficiently solvepractical problems. The field
of study known as design and analysis of algorithms encompasses the study of de
sign paradigms like divide-and-conquer, techniques to develop hypotheses about
algorithms performance, and algorithms for solving fundamental problems like
sorting and searching that can be put to use for practical applications of all kinds.
Implementations of many of these algorithms are found in Javalibraries or other
specialized libraries, but understanding these basic tools of computation is like
understanding the basic tools of mathematics or science. You can use a matrix-
processing package to find the eigenvaluesof a matrix, but you still need a course
in linear algebra.Now that you know that a fast algorithm can make the difference
between spinning your wheels and properly addressing a practical problem, you
can be on the lookout for situations where algorithm design and analysiscan make
the difference, and for efficient algorithms like binary search and mergesort that
can do the job.

4.2 Sorting and Searching
Q. Why do we need to go to such lengths to prove a program correct?
A. To spare ourselves considerable pain. Binary search is a notable example. For
example, you now understand binary search; a classic programming exerciseis to
write a version that uses a while loop instead of recursion. Try solving Exercise
4.2.1 without looking back at the code in the book. In a famous experiment, Jon
Bentleyonce asked several professional programmers to do so, and most of their
solutions were not correct.
Q. Arethere implementations for sorting and searchingin the Java library?
A. Yes. The Javalibrary Java, util .Arrays contains the methods Arrays, sort ()
and Arrays.binarySearchO that implement mergesort and binary search for
Comparable types and a sorting implementation for primitive types based on a
version of the quicksort algorithm, which is fasterthan mergesort and also sorts an
array in place (without using any extra space).
Q. Sowhy not just use them?
A. Feelfree to do so.Aswith many topics we havestudied, you will be able to use
such tools more effectively if you understand the background behind them.
Q. Why do I get a unchecked or unsafe operation warning when compiling In
sertion and Merge?
A, The argument to sort() is a Comparable array, but nothing, technically, pre
vents its elements from being of differenttypes.Toeliminatethe warning, change
the signature to:
public static <Key extends Comparable<Key» void sort(Key[] a)
We'll learn about the <Key> notation in the next section.

544
Algorithms and Data Structures
4.2.1
Develop an implementation of TwentyQuesti ons that takes the maximum
number N as command-line argument. Prove that your implementation is cor
rect.
4.2.2
Add code to Inserti on to produce the trace givenin the text.
4.2.3
Add codeto Merge to produce the trace givenin the text.
4.2.4
Give tracesof insertion sort and mergesort in the styleof the traces in the
text, for the input i t was the best of times it was.
4.2.5
Describe whyit is desirable to useimmutablekeys with binary search.
4.2.6
Explain whyweuse1o + (hi - 1o) / 2 to compute the index midwaybe
tween lo and hi instead of using (lo + hi) / 2.
Answer: The latter fails when 1o + hi overflows an i nt.
4.2.7
Modify Bi narySearch (Program 4.2.3) so that if the search key is in the
array,it returns the smallestindex i for which a [i ] is equal to key, and otherwise,
it returns -i, where i isthe smallest indexsuch that a[i ] is greaterthan key.
4.2.8
Describewhat happens if you apply binary search to an unorderd array.
Why shouldn't you check whether the array is sorted before each call to binary
search? Couldyou checkthat the elements binary searchexamines arein ascending
order?
4.2.9
Write a program DeDup that reads strings from standard input and prints
them on standard output with allduplicates removed (and in the same order they
are found in the input).
4.2.10 Find the frequency distribution of words in your favorite book. Does it
obey Zipf's law?
4.2.11 Find the longest repeated substring in your favoritebook.
4.2.12 Add code to LRS (Program 4.2.8) to make it print indices in the original
string where the long repeated substring occur.

4.2 Sorting and Searching
4.2.13 Find a pathologicalinput for which LRS (Program 4.2.8)runs in quadratic
time (or worse).
4.2.14 Showthat binary searchin a sorted array islogarithmic as long as it elimi
nates at least a constant fraction of the array at each step.
4.2.15 Modify BinarySearch (Program 4.2.3) so that if the search key is not in
the array, it returns the largestindex i for whicha[i ] is smallerthan key (or -1 if
no such index exists).
4.2.16. Analyze mergesort mathematicallywhen N is a power of 2, as we did for
binary search.
Answer: Let M(N) be the frequency of execution of the instructions in the inner
loop. Then M(N) must satisfythe followingrecurrence relation:
M(N) = 2M(N/2) + N
with M(l) = 0. Substituting 2" for AT gives
M(2»)=2M(2""1)+ 2"
which is similar to but more complicatedthan the recurrence that we considered
for binary search. But if we divide both sidesby 2",we get
M(2»)/ 2" = M(2»-!)/ 2""1 4- 1
which is precisely the recurrence that we had for binary search. That, is M(2n)/ 2n
= T(2") = n. Substituting back N for 2n (and IgN for n) gives the result M(N) =
NlgN.
4.2.17 Analyze mergesort for the casewhen N not a power of two.
Partial answer:
When N is an odd number, one subarray has to have one more
entry than the other, so when N is not a powerof two,the subarrayson eachlevel
are not necessarilyall the same size. Still,everyelement appears in some subarray,
and the number of levelsis stilllogarithmic, so the linearithmic hypothesis is justi
fied for all N.
545

546
Algorithms and Data Structures
XIreatiMMSEx&iiBiltes
Thefollowing exercises are intended to giveyouexperience indevelopingfastsolutions
totypicalproblems. Think about using binary search, mergesort, ordevisingyour own
divide-and-conquer algorithm. Implement andtestyouralgorithm.
4.2.18 Median. Add to StdStats a method medi an() that computes in linearith
mic time the median of a sequence of N integers. Hint:Reduce to sorting.
4.2.19 Mode. Add to StdStats a method mode() that computes in linearithmic
time the mode (value that occurs most frequently) of a sequence of JV integers.
Hint: Reduce to sorting.
4.2.20 Integer sort. Write a linear-time filter that takes from standard input a se
quence of integersthat are between0 and 99 and prints the same set of integersin
sorted order on standard output. For example, presented with the input sequence
98 2310003 98 98 2220002
your program should print the output sequence
00000012222233 98 98 98
4.2.21 Floor and ceiling. Given a sorted array of Comparabl e items, write meth
ods f1oor () and cei 1() that returns the indexof the largest(or smallest)item not
larger (or smaller) than an argument item in logarithmic time.
4.2.22 Closest pair. Given an array of JV real numbers, write a static method to
find in linearithmic time the pair of integersthat are closestin value.
4.2.23 Furthestpair. Given an array of AT real numbers, write a static method to
find in linear time the pair of integersthat are farthest apart in value.
4.2.24 Two sum. Write a static method that takes as argument an array of JV i nt
valuesand determines in linearithmic time whether any two of them sum to 0.
4.2.25 Three sum. Writea staticmethod that takesasargument an array of JVint
valuesand determines whether any three of them sum to 0.Yourprogram should
run in time proportional to JV2 log N. Extra credit Develop a program that solves
the problem in quadratic time.

4.2 Sorting and Searching
4.2.26. Majority. An element isa majority if it appearsmore than JV/2 times.Write
a static method that takesan array of JV strings asargument and identifiesa major
ity (if it exists) in linear time.
4.2.27 Common element. Write a static method that takes as argument three ar
raysof strings,determines whether there is anystring common to allthree arrays,
and if so, returns one such string. The running time of your method should be
linearithmic in the total number of strings.
4.2.28 Prefix-free codes. In data compression, a set of strings isprefix-free if no
string is a prefixof another.Forexample, the setof strings01,10,0010, and 1111
are prefix-free, but the set of strings 01,10, 0010,1010 is not prefix-free because
10 is a prefixof 1010.Write a program that readsin a set of strings from standard
input and determines whether the set isprefix-free.
4.2.29 Longest common substring. Write a static method that finds the longest
common substring of two givenstrings s and t.
4.2.30 Longest repeated, non-overlapping string. Modify LRS (Program 4.2.8) to
find the longest repeated substring that does notoverlap.
4.2.31 Partitioning. Write a static method that sorts a Comparable array that is
known to have at most two different values. Hint: Maintain two pointers, one start
ingat the leftend and movingright,the other startingat the right end and moving
left. Maintain the invariant that all elements to the left of the left pointer are equal
to the smaller of the two values and allelements to the right of the right pointer are
equal to the larger of the two values.
4.2.32 Dutch nationalflag. Write a static method that sorts a Comparable array
that isknown to haveat most three differentvalues. (EdsgarDijkstranamed this the
Dutch-national-flagproblem because the result is three"stripes" of values likethe
three stripes in the flag.) Hint:Reduce to the previousproblem,byfirstpartitioning
the arrayinto twoparts with allelements having the smallest valuein the firstpart
and allother elements in the secondpart, then partition the second part.
547

Algorithms and Data Structures
4.2.33 Quicksort. Write a recursive program that sorts an array of randomly or
dered distinct Comparabl e elements. Hint: Use a method like the one described in
the previousexercise. First,partition the arrayinto a left part with allelementsless
than v,followed byv,followed byarightpart with allelementsgreaterthan v.Then,
recursively sort the two parts. Extra credit: Modifyyour method (if necessary) to
work properlywhen the elementsare not necessarily distinct.
4.2.34 Reverse domain. Write a program to read in a list of domain names from
standard input and print the reverse domain names in sorted order.For example,
the reverse domain of cs. pri nceton.edu is edu. pri nceton. cs. This computa
tion is usefulfor web log analysis. Todo so,create a data type Domai n that imple
ments the Comparabl e interface,using reversedomain name order.
4.2.35 Local minimum in an array. Given an array of JV real numbers, write a
static method to find in logarithmic time a local minimum (an index i such that
a[i-l] <a[i] <a[i+l]).
4.2.36 Discrete distribution. Design a fastalgorithm to repeatedlygenerate num
bersfromthe discrete distribution:Given an arraya[] ofnonnegativerealnumbers
that sum to 1,the goalisto return indexi with probabilitya[i ]. Form an array s []
of cumulated sums such that s [i ] is the sum of the first i elements of a []. Now,
generatea random realnumber r between0 and 1,and usebinary searchto return
the index i for which s[i] < r < s [i +1].
4.2.37 Rhyming words. Tabulate a listthat youcan useto findwords that rhyme.
Usethe followingapproach:
• Readin a dictionary of wordsinto an array of strings.
• Reverse the lettersin eachword (confound becomesdnuofnoc,for example).
• Sort the resulting array.
• Reverse the letters in eachword backto their original order.
For example, confound is adjacent to words such as astound and surround in the
resulting list.

4.2 Sorting and Searching
549

Algorithms and Data Structures
4.3
Stacks and Queues
In this section, we introduce two closelyrelated data types for manipulating arbi
trarily large collections of objects:the stack and the queue. Stacks and queues are
special cases of the idea of a collection. A
collection of objects is characterized by
four operations: create the collection, in-
4.3.1
Stack ofstrings (array)
554
sert an object, remove an object, and test
43'2 ^ackofstrings (linkedlist)..
559
l. ^
^
ii
^
^
4.3.3
Stack of strings (array doubling). , 563
whether the collection is empty.
434 Generk stack* ...;..;./*.. 568
When we insert an object, our in-
43.5
Expression evaluation
572
tent is clear. But when we remove an ob-
4.3.6
Generic FIFO queue (linked list). . 578
ject, which onedo we choose? Each type
4-3-7
M/D/1 <lueue simulation
583
of collection is characterized by the rule
4'3'8 Load balancingsimulation
591
used for remove, and each is amenable
Programs inthis section
to various implementations with differ
ing performance characteristics.You have
encountered differentwaysto answerthis question in various real-world situations,
perhaps without thinking about it.
For example,the rule used for a queue is to always remove the item that has
been in the collectionthe mostamount of time.Thispolicyisknown asfirst-infirst-
out, or FIFO.Peoplewaitingin line to buy a ticketfollowthis discipline: the line is
arrangedin the order of arrival, sothe onewholeaves the linehasbeen therelonger
than any other person in the line.
A policywith quite differentbehavior is the rule used for a stack: always re
movethe item that has been in the collection the least amount of time.This policy
is known as last-in first-out, or LIFO. For example, you follow a policy closer to
LIFO when you enter and leave the coach cabin in an airplane: people near the
front of the cabin board last and exit before those who boarded earlier.
Stacks and queues are broadlyuseful,so it is important for you to be familiar
with their basicproperties and the kind of situation where each might be appro
priate. They are excellent examples of fundamental data types that we can use to
address higher-level programmingtasks. Theyare widely used in systems and ap
plications programming, as we willsee in several examplesin this section and in
Section 4.5.

4.3 Stacks and Queues
Pushdown stacks
Apushdown stack (or just a stack) isa collectionthat isbased
on the last-in-first-out (LIFO) policy.
When you keep your mail in a pile on your desk,you are using a stack.You
pile pieces of new mail on the top when they ar
riveand take each piece ofmail from the top when
you are ready to read it. People do not process as
many papers as they did in the past, but the same
organizing principle underlies severalof the appli
cations that you use regularly on your computer.
For example, many people organize their email as
a stack, where messages go on the top when they
are receivedand are taken from the top, with most
recently received first (last in, first out). The ad
vantage of this strategy is that we see interesting
email as soon as possible; the disadvantage is that
some old email might never get read if we never
empty the stack.
You have likely encountered another com
mon example of a stack when surfing the web.
When you clicka hyperlink, your browser displays
the new page (and inserts it onto a stack). You can
keep clicking on hyperlinks to visit new pages,but
you can always revisit the previous page by click
ing the back button (remove it from a stack).The
last-in-first-out policy offered by a pushdown
stack provides just the behavior that you expect.
Such uses of stacks are intuitive, but perhaps
not persuasive.In fact,the importance of stacksin
computing is fundamental and profound, but we
defer further discussions of applications to later in
this section. For the moment, our goal is to make
sure that you understand how stacks work and
how to implement them.
Stacks have been used widelysince the earliestdays of computing. Bytradi
tion, we name the stack insert operation pushand the stack remove operation pop,
as indicated in the following API:
a stack of
documents N^
push(
push(.
popO
^mmr = popO
551
new (gray)one
goes on top
new (black) on>
goes on top
remove the
black one
from thetop
remove the
gray one
from thetop
Operations on a pushdown stack

552
Algorithms and Data Structures
public class *StackOfStrings
*StackOfStri ngs ()
create anempty stack
bool ean
i sEmpty()
isthe stack empty?
void
push(St ring item)
push astring onto the stack
St ri ng
pop ()
pop the stack
APIforapushdown stackforstrings
The asterisk indicates that we will be considering more than one implementation
of this API (we consider three in this section: ArrayStackOfStri ngs, Linked-
StackOfSt ri ngs, and Doubli ngStackOfSt ri ngs). This API also includes ameth
od to testwhetherthe stackisempty,leaving to the clientthe responsibilityofusing
i sEmpty() to avoidinvoking popO when the stackis empty (an alternative design
would be to throw an exception in that case).
This API has an important restriction that is inconvenient in applications:
we would like to havestacks that containother types of data, not just strings. We
examine waysto remove this restriction (and the importance of doing so) laterin
this section.
Array implementation
Representing stacks with arrays is a natural idea, but
before reading further, it is worthwhile for you to think for a moment about how
you would implement a class ArrayStackOfStri ngs.
The first problemthat you might encounteris implementing the constructor
ArrayStackOfStri ngs(). You clearly need an instancevariable a[] with an array
of strings to hold the stackitems,but how big shouldthe array be? One solution is
to startwith an array of size0 and make surethat the array sizeis always equal to
the stack size, but that solution necessitates allocating anew array and copying all
of the itemsintoit for each push() and pop() operation, whichisunnecessarilyin
efficientand cumbersome.We willtemporarilyfinesse this problemby havingthe
client providean argument forthe constructorthat gives the maximum stacksize.
Your next problemmight stem fromthe naturaldecision to keep the items in
the array in the orderthey appear on the stack, with the top element in a[0], the
secondelement in a[1], andso forth. Butthen eachtime you push or pop anitem,
you would have to move all of the other items to reflect the new state ofthe stack.
A simplerand more efficientwayto proceed isto keep the items in reverse orderof

4.3 Stacks and Queues
their arrival, as illustrated. This policy allowsus to add and remove items at the end
without moving any of the other items in the stack.
We could hardly hope for a simpler implementation of the stack API than
ArrayStackOfStrings (Program 4.3.1)—all of the methods are one-liners! The
instance variables are an array a[] that hold the items in the stack and an integer N
that counts the number of items in the stack. To remove an item, we decrement N
and then return a [N]; to insert a new item, we set a [N] equal to the new item and
then increment N. These operations preservethe following properties:
• The items in the array are in
their insertion order.
• The stack is empty when Nis 0.
• The top of the stack (if it is
nonempty) is at a [N-l].
Asusual, thinking in terms ofinvari
ants of this sort is the easiest way to
verify that an implementation op
erates as intended. Be sure that you
fully understand this implementation.
Perhaps the best way to do so is to
carefullyexamine a trace ofthe stack
contents for a sequence of push()
and popO operations. The test cli
ent in Stri ngStackArray allows for
testing with an arbitrary sequence of
operations: it does a push() for each
string on standard input except the
string consisting of a minus sign, for
which it does a pop().
The primarycharacteristic of this implementation isthat thepushandpopop
erations take constant time. The drawback of this implementation is that it requires
the client to estimate the maximum sizeof the stackahead of time and always uses
space proportional to that maximum, which may be unreasonable in some situa
tions. We omit the code in push () to test for a full stack, but later we will examine
implementations that address these drawbacksby not allowingthe stack to get full
(except in an extreme circumstance when there is no memory at all available for
use by the Javasystem).
a[]
Stdln
StdOut
N
0
1
2
3
4
0
to
1
to
be
2
to
be
or
3
to
be
or
not
4
to
be
or
not
to
5
to
be
or
not
to
-
to
4
to
be
or
not
to
be
5
to
be
or
not
be
-
be
4
to
be
or
not
be
-
not
3
to
be
or
not
be
that
4
to
be
or
that
be
-
that
3
to
be
or
that
be
-
or
2
to
be
or
that
be
-
be
1
to
be
or
that
be
is
2
to
is
or
not
to
Trace o/ArrayStackOfStri ngs testclient
553

554
Algorithms and Data Structures
in
w
m
mmif
HI
it
mi
Program 43.1
Stackofstrings(array)
public class ArrayStackOfStrings
{
private String[]
a;
private int N = 0;
public ArrayStackOfStrings(int max)
{
a = new String[max];
}
public boolean isEmptyO
{
return (N ==0);
}
public void push(String item)
{
a[N++] = item;
}
public String popO
{
return a[--N];
}
public static void main(String[]
args)
{
// Create a stack of capacity max
// and push or pop strings as directed on Stdln.
int max = Integer.parselnt(args[0]);
ArrayStackOfStrings s = new ArrayStackOfStrings(max);
while (!Stdln.isEmptyO)
{
String item = Stdln. readStringO;
if (litem.equalsC'-"))
s.push(item);
else
StdOut.pri nt(s.popO);
}
}
a[]
N
N-l
stack values
number of items
indexof value
most recentlypushed
'^^^^^^^^^^^^Pl
Stack methods aresimple one-liners, asillustrated in this code. The clientpushes orpopsstrings
as directed from standard input (a minus sign indicates pop, and any other string indicates
push). Codein push () to testwhether thestack isfull is omitted (seetext).
% more tobe.txt
to
be or
not to
-
be
Java ArrayStackOfStrings 5 < tobe.txt
to
be
not that or
be

4.3 Stacks and Queues
555
Linked lists
Forclasses suchasstacks that implementcollections of objects, an
important objectiveis to ensure that the amount ofspace used isalwaysproportional
to thenumber of items in thecollection. The use of a fixed-size array to implement
stacks in ArrayStackOfStrings works against this objective: when you create a
huge stack, you are wasting a potentially huge amount of memory at times when
the stack is empty or nearly empty. This property makesthe array implementation
unusable in applications involving large numbers of items moving among large
numbers of stacks,which are typical. For example,a transaction system might in
volvebillions of items and thousands of collectionsof them. Wemight not be able
to afford the memory to allow for the possibility that each of those collections
could each hold all of those items. Worse, if all of the items do wind up in one
collection, we know that the others would all be empty, so that wasted memory is
unnecessary. One of the primary purposes of Java's memory allocation system is
to provide the flexibility to handle such situations. Now we consider the use of a
fundamental data structure known as a linked UsU which can provide implementa
tions of collections (and, in particular, stacks) that achievethe objectivecited at the
beginning of this paragraph.
A linked list is a recursive data structure defined as follows: it is either empty
(null) or a reference to a node having a reference to a linked list. The node in this
definition is an abstract entity that might hold any kind of data, in addition to the
node reference that characterizes its role in building linked lists.Aswith a recursive
program, the concept ofa recursive data structure can be a bit mindbending at first,
but is of great value because of its simplicity.
With object-oriented programming, implementing linked lists is not difficult.
We start with a class for the node abstraction:
class
Node
{
String item;
Node next;
}
A Node has two instance variables: a String and a Node. The String is a place
holder in this example for any data that we might want to structure with a linked
list (we can use any set of instance variables); the instance variable of type Node
characterizes the linked nature of the data structure. To emphasize that we are just
using the Node classto structure the data, we define no methods. Now,from the re
cursive definition, we can represent a linked list with a variable oftype Node simply

556
Algorithms and Data Structures
by ensuring that itsvalueiseither nul1 or a reference to a Node whose next fieldis
a reference to a linked list.
As with any type of data, we create an object of type Node by invoking the
(no-argument) constructor with new Node(). The result is a reference to a Node
object whose instance variablesare both initializedto the value null.
For example, to build a linked list that contains the items to, be, and or, we
create a Node for each item:
Node first
= new Node();
first.item
= "to";
f i rst
Node first
= new Node();
Node second = new Node();
Node third
= new Node();
and set the i tern field in each of the nodes
to the desired value:
Node second = new Node();
first.item
= "to";
second.item = "be";
second.item = "be";
first.next
= second;
third.item
= "or";
f i rst
and set the next fields to build the linked
list:
first.next
= second;
second.next = third;
As a result, thi rd is a linked list (it is a ref
erence to a node that contains null, which
is the null reference to an empty linked
list), and second is a linked list (it is a ref
erence to a node that has a reference to
thi rd, which is a linked list), and f i rst is
a linked list (it is a reference to a node that
has a reference to second, which is a linked
list). The code that we will examine does these assignment statements in a different
order, depicted in the diagram on this page.
A linked list represents a sequence of items. In the example just considered,
f i rst represents the sequence to be or. We can also use an array to represent a
sequence of items. For example, we could use
String[]
s = { "to", "be", "or" };
second
Muawwatm&t
i"TT i
1
null
|
Node third
= new Node();
third.item
= "or";
second.next = third;
second
thi rd
Linking together a list

4.3 Stacks and Queues
save a link to the list
Node oldfirst = first;
oldfirst
first
create a newnodefor thebeginning
first = new Node();
oldfi rst
fi rst -
set the instance variables in the new node
first.item = "not";
first, next = oldfirst;
first
557
to
represent the
same
sequence
of
strings. The difference is that it is easier
to insert items into the sequence and to
remove items from the sequence with
linked lists. Next, we consider code to
accomplish these tasks.
When tracing code that useslinked
lists and other linked structures, we use
a visual representation where:
• Wedraw a rectangle to represent
each object.
• We put the values of instance vari
ableswithin the rectangle.
• We use arrows that point to the ref
erenced objects to depict references.
This visual representation captures the
essential characteristic of linked lists.
For economy, we use the term links to
refer to node references. For simplicity,
when item values are strings (as in our
examples), we put the string within the
objectrectanglerather than the more accuraterendition depictingthe string object
and the character array that we discussed in Section 4.1. (If you work Exercise
4.3.12, you will better understand the precise representation of linked lists with
Inserting a newnode at thebeginning ofa linked list
first = first.next;
first
first
Removing thefirst nodein a linked list
string items in Java.) This visual representation
allows us to focus on the links.
Suppose that you want to inserta new node
into a linked list. The easiestplace to do so is at
the beginning of the list. For example, to insert
the string not at the beginning of a givenlinked
list whose first node is f i rst, we save f i rst in
oldfi rst, assign to fi rst a new Node,and as
sign its item field to not and its next field to
oldfirst.
Suppose that you want to remove the first node from a list. This operation is
even easier: simply assign to f i rst the value f i rst. next. Normally, you would

558
Algorithms and Data Structures
retrieve the value of the item (byassigningit to some String variable) before doing
this assignment,becauseonceyou changethe value of f i rst, you may not haveany
accessto the node to which it was referring. Typically, the node object becomes an
orphan, and the memory it occupies is eventually reclaimed by the Javamemory
management system.
This code for inserting and removing a node from the beginning of a linked
list involves just a few assignment statements and thus takes constant time (inde
pendent of the length of the list). If you hold a reference to a node at an arbitrary
position in a list, you can use similar (but more complicated) code to remove the
node after it or to insert a node after it, also in constant time. However, we leave
those implementations for an exercise (see Exercise 4.3.25-26) because inserting
and removingat the beginning are the only linked-list operations that we need in
order to implement stacks.
Implementing stacks with linked lists. LinkedStackOfStri ngs (Program4.3.2)
uses a linked list to implement a stack of strings, using little more code than the
elementary solution that uses arrays.
The implementation isbasedon a nested classNode likethe one wehavebeen
using. Java allows us to defineand use other classes within classimplementations
in this natural way. The classis private because clients do not need to know any
ofthe details of the linked lists. One characteristic of a private nested class is that
its instance variables can be directly accessed from within the enclosing classbut
nowhere else, so there is no need to declare the Node instance variables as publ i c
or private.
LinkedStackOfStrings itself has just one instance variable: a reference to
the linked list that represents the stack. That single link suffices to directly access
the item at the top of the stack and also provides access to the rest of the items in
the stackfor push() and pop(). Again, be sure thatyou understand this implemen
tation—it isthe prototype for several implementations usinglinked structures that
we willbe examining later in this chapter. Using the abstract visual list representa
tion to trace the code is the best way to proceed.
Linked list traversal. One of the most common operations weperform on collec
tions isto iterate through the itemsin the collection.For example,we might wish to
implement the toStri ng() method that is inherent in every JavaAPI to facilitate
debugging our stack code with traces. For ArrayStackOfStri ngs, this implemen
tation is familiar.

4.3 Stacks and Queues
&M^Ms£Jfc^^^
Program 43.2
Stack ofstrings (linked list)
public class LinkedStackOfStrings
{
private Node first;
private class Node
{
String item;
Node next;
}
public boolean isEmptyO
{
return (first == null);
}
public void push(String item)
{
// Add item to top of stack.
Node oldfirst = first;
first = new Node();
first.item = item;
first,next = oldfirst;
}
public String popO
{
// Remove item from top of stack.
String item = first.item;
first = first, next;
return item;
}
public static void main(String[] args)
{
LinkedStackOfStrings s = new LinkedStackOfStringsO;
// See Program 4.3.1 for the test client.
}
item
next
559
list item
next node on list
This stack implementation uses a private nested class Node as the basis for representing the
stack as a linked listof Node objects. The instance variable fi rst refers to thefirst (most re
cently inserted) Node on thelist. The next instance variable ineach Node refers tothenextNode
(the value of next in thefinal node is nul 1). No explicit constructors areneeded, because Java
initializes the instance variables to null.
V^!^!^^
% Java LinkedStackOfStrings < tobe.txt
to
be
not that or
be

560
Stdln
to
be
or
not
to
be
that
is
Algorithms and Data Structures
StdOut
to
be
not
that
or
be
Trace of LinkedStackOfStrings testclient

4.3 Stacks and Queues
public String toStringO
{
String s = "";
for (int i
= 0;
i
< N; i++)
s += a[i]
+ " ";
return s;
}
Asusual, this solution is intended for use onlywhen Nis small—ittakes quadratic
time because string concatenation takes
linear time. Our focus now is just on the
processof examining everyitem. There isa
corresponding idiom for visiting the items
in a linked list: We initialize a loop index
variable x that references the first Node of
the linked list. Then, we find the value of
the item associated with x by accessing
x. i tern, and then update x to refer to the
next Node in the linked list, assigningto it
the value of x.next and repeating this
process until x is null (which indicates
that we have reached the end of the linked
list). This process is known as traversing
the list, and is succinctly expressedin this
implementation
of
toStringO
for
Li nkedStackOfStri ngs:
public String toStringO
{
String s = "";
for
(Node x = first;
x
s += x.item + " ";
return s;
}
x
=
x
=
Traversing a linked list
!= null;
x = x.next)
When you program with linked lists, this idiom will become as familiar to you as
the standard idiom for iterating through the items in an array. At the end of this
section, we consider the concept of an iterator, which allowsus to write client code
to iterate through the objects ofa collection without having to program at this level
of detail.
561

562
Algorithms and Data Structures
With a linked-list implementation wecan write client programs that uselargenum
bers of stackswithout havingto worrymuch about spaceusage. Thesameprinciple
appliesto collections of data of anysort,solinkedlistsarewidelyusedin program
ming. Indeed, typical implementations of the Java memory management system
are based on maintaining linked listscorresponding to blocks of memory of vari
ous sizes. Before the widespreaduse of high-level languages likeJava, the detailsof
memory managementand programmingwith linkedlistswasa criticalpart of any
programmer's arsenal. In modern systems, most of these details are encapsulated
in the implementations of a fewdata types like the pushdown stack, including the
queue, the symbol table, and the set, which we will consider later in this chapter.
If you take a course in algorithms and data structures, you will learn several oth
ers and gainexpertisein creatingand debugging programs that manipulate linked
lists. Otherwise, you can focus your attention on understanding the role played
by linked lists in implementing these fundamental data types. For stacks,they are
significant because they allow us to implement the push() and pop() methods
in constant time while using only a small constant factor of extra space (for the
links).
Array doubling
Next, weconsideran alternative approach to accommodating
arbitrary growth and shrinkage in a data structure that is an attractive alternative
to linked lists.Aswith linked lists,we introduce it now because the approach is not
difficult to understand in the context of a stack implementation and because it is
important to know when addressing the challenges of implementing data types
that are more complicated than stacks.
The idea is to modify the array implementation to dynamically adjust the size
of the array a [] so that it isboth sufficientlylargeto hold allof the items and not so
large as to waste an excessive amount of space.Achievingthese goalsturns out to be
remarkably easy, and we do so in Doubl i ngStackOfStri ngs (Program 4.3.3).
First, in push(), we check whether the array is too small. In particular, we
check whether there is room for the new item in the array by checking whether the
stack size Nis equal to the array size a. 1ength. If there is room, we simply insert
the new item with the code a [N++] = i tern as before; if not, we double the size ofthe
array by creating a new array of twice the size, copying the stack items to the new
array, and resetting the a[] instance variable to reference the new array.
Similarly, in pop(), we begin by checking whether the array is too large, and
we halve its sizeif that is the case.If you think a bit about the situation, you will see

4.3 Stacks and Queues
563
m
0,
m
P
*?%
1
M
Program 4.3.3
Stack ofstrings (array doubling)
public class DoublingStackOfStrings
{
private String[] a = new String[l];
private int N = 0;
public boolean isEmptyO
{
return (N ==0);
}
private void resize(int max)
{
// Move stack to a new array of size max.
String[] temp = new String[max];
for (int i = 0; i < N;
i++)
temp[i] = a[i];
a = temp;
}
public void push(String item)
{
// Add item to top of stack.
if (N == a.length)
resize(2*a.length);
a[N++] = item;
}
public String pop()
{
// Remove item from top of stack.
String item = a[--N];
a[N] = null;
// Avoid loitering (see text).
if (N > 0 && N — a.length/4) resize(a.length/2);
return item;
}
public static void main(String[]
args)
{
DoublingStackOfStrings s = new DoublingStackOfStrings();
// See Program 4.3.1 for the test client.
}
}
a[]
N
stack items
number of itemsi
This implementation achieves theobjective ofsupporting stacks ofanysizewithoutexcessively
wastingspace bydoubling thesizeofthe array whenfullandhalving thesizeofthearray tokeep
it always at least one-quarterfull Onaverage, all operations areconstant-time (see text).
Java DoublingStackOfStrings < tobe.txt
to be not that or be
*%^s^ss^s^^*^SP^^^fci^Kl»«^^^^

564
Algorithms and Data Structures
Stdln
StdOut
N
a.length
0
1
2
3
4
5
6
7
0
1
null
to
1
1
to
be
2
2
to
be
or
3
4
to
be
or
null
not
4
4
to
be
or
not
to
5
8
to
be
or
not
to
null
null
null
-
to
4
8
to
be
Of
not
null
null
null
null
be
5
8
to
be
or
not
be
null
null
null
-
be
4
8
to
be
or
not
null
null
null
null
-
not
3
8
to
be
or
null
null
mill
n'iU
null
that
4
8
to
be
or
that
null
mill
null
null
-
that
3
8
to
be
o r
null
null
null
null
null
-
or
2
4
to
be
null
null
-
be
1
2
to
null
is
2
2
to
is
Trace ofDoubl i ngStackOfStri ngs test client
that the appropriate test is whether the stack size is less than one-fourth the array
size.Then, after the array is halved,it willbe about half full and can accommodate
a substantial number of push() and pop() operations before having to change
the sizeof the array again.This characteristicis important: for example,if wewere
to use to policy of halving the array when the stack size is one-half the array size,
then the resulting array would be full,which would mean it would be doubled for a
push(), leading to the possibilityof an expensive cycle of doubling and halving.
Amortized analysis. This doubling and halving strategy is a judicious tradeoff
between wasting space (by setting the size of the array to be too big and leaving
empty slots) and wasting time (by reorganizing the array after each insertion).
The specificstrategy in Doubli ngStackOfStri ngs guarantees that the stack never
overflows and never becomes less than one-quarter full (unless the stack is empty,
in which casethe array sizeis 1).If you are mathematically inclined, you might en
joy proving this fact with mathematical induction (see Exercise 4.3.20). More im
portant, we can prove that the cost of doubling and halving is alwaysabsorbed (to
within a constant factor) in the cost of other stack operations. Again, we leave the
details to an exercisefor the mathematically inclined, but the idea is simple: when

4.3 Stacks and Queues
555
push() doubles the sizeof the array to sizeN, it starts with N/2 items in the stack,
sothe size of the arraycannot doubleagain at until the clienthasmade at leastN/2
additional calls to push() (moreif there are some intervening calls to popO). If
weaverage the costof the push() operationthat causes the doublingwith the cost
of those N/2 push() operations, we get a constant. In other words, in Doubl i ng
StackOfSt ri ngs, the total cost ofallofthe stack operations divided by the number of
operations isbounded by a constant. Thisstatement isnot quiteasstrongas saying
that each operationisconstant-time, but it hasthe same implications in manyap
plications (for example, whenour primaryinterest is in totalrunning time).This
kind of analysis is knownas amortized analysis—array doubling is a prototypical
example ofits value.
Orphaned items. Java's garbage collection policy isto reclaim thememoryassoci
atedwith anyobjects that can no longerbe accessed. In the pop() implementation
in our initialimplementationArrayStackOfSt ri ngs,the reference to the popped
itemremainsin the array. Theitemisan orphan—we willneveruseit againwithin
the class, either because the stack will shrink or because it will be overwritten with
anotherreference if the stack grows—but the Java garbage collector hasno way to
knowthis. Even when the clientis done with the item, the reference in the array
maykeep it alive. Thiscondition(holding a reference to an itemwhichisno longer
needed)is known as loitering, whichis not the sameasa memory leak (whereeven
the memory management systemhas no referenceto the item). In this case,loiter
ing is easy to avoid. The implementation of pop() in Doubl ingStackOfStrings
sets the array entry corresponding to the popped item to null, thus overwriting
the unusedreference and making it possible forthe system to reclaim the memory
associatedwith the popped item when the client is finishedwith it.
With an array-doubling implementation (aswith a linked-list implementation), we
canwriteclientprogramsthat uselargenumbersofstacks without havingto worry
much about space usage. Again, the same principle applies to collections of data
of anysort.Forsomedatatypes that aremorecomplicated than stacks, arraydou
blingispreferredoverlinkedlistsbecause the ability to access anyitem in the array
in constant time (through indexing)iscriticalfor implementingcertain operations
(see, for example, RandomQueue in Exercise 4.3.36). Again as with linked lists,it is
best to keep array-doubling codelocalto the implementation of fundamental data
types and not worry about using it in client code.

566
Algorithms and Data Structures
Parameterized data types
We have developed stackimplementationsthat al
low us to build stacks of one particular type (Stri ng). But when developing cli
ent programs, weneedimplementations forcollections of other types of data,not
necessarily String objects. A commercial transaction processing system might
need to maintain collections of customers, accounts, merchants, and transactions;
auniversitycourse scheduling system mightneedto maintaincollections ofclasses,
students,and rooms;a portable musicplayer might need to maintain collections
of songs, artists, and albums; a scientific programmight needto maintain collec
tions of double or i nt values. In anyprogram that you write,you should not be
surprised to find yourself maintaining collections for any type of data that you
mightcreate. Howwouldyoudoso? After considering twosimple approaches (and
their shortcomings) that usethe Java language constructswehavediscussed so far,
we introduce a more advanced construct that can help us properly address this
problem.
Create a newcollection data typeforeach item datatype. We couldcreate classes
StackOfInts, StackOfCustomers, StackOfStudents, and so forth to supplement
StackOfStri ngs. This approachrequires that we duplicatethe code for eachtype
of data,whichviolatesa basicpreceptof software engineeringthat weshould reuse
(not copy) codewhenever possible. You needa different class forevery typeofdata
that you want to put on a stack, so maintaining your codebecomes a nightmare:
whenever youwantor needto make a change, youhave to do soin eachversion of
the code.Still, this approachiswidely usedbecause manyprogramminglanguages
(including early versions of Java) do not provide anybetterway to solve the prob
lem.Breaking thisbarrier isthe signof a sophisticated programmer and program
mingenvironment. Canweimplement stacks of Stri ng objects, stacks of integers,
and stacksof data of anytype whatsoever with just one class?
Use collections ofObjects. We could develop astackwhose elements arealloftype
Obj ect. Using inheritance, wecanlegally push an objectof anytype (ifwewant to
push an object of type Appl e, wecan do so becauseAppl e is a subclass of Object,
as are allother classes). When wepop the stack,we must cast it back to the appro
priate type (everything on the stackis an Object, but our code is processing ob
jectsof type Appl e). In summary, ifwecreatea class StackOfObjects bychanging
String to Object everywhere in one of our *StackOfStrings implementations,
we can write code like

4.3 Stacks and Queues
StackOfObjects stack = new StackOfObjectsO;
Apple a = new Apple();
stack.push(a);
a = (Apple) (stack.popO);
thusachieving our goal ofhaving a single class that creates andmanipulates stacks
of objects of anytype. However, this approach is undesirable because it exposes
clients to subtlebugsin clientprogramsthat cannotbe detected until runtime. For
example, there is nothing to stop a programmer from putting different types of
objects on the samestack, asin the following example:
ObjectStack stack = new ObjectStack();
Apple
a = new Apple();
Orange b = new OrangeO;
stack.push(a);
stack.push(b);
a = (Apple)
(stack.popO); // Throws a ClassCastException.
b = (Orange) (stack.popO) ;
Using type casting in this wayamounts to assuming that clients will cast objects
popped from the stack to the proper type, avoiding the protection provided by
Java's typesystem. Onereason that programmers use thetypesystem isto protect
against errorsthat arisefromsuchimplicit assumptions. Thecodecannot be type-
checked at compile time: theremightbe an incorrect castthat occurs in a complex
pieceof code that could escape detection until some particular runtime circum
stance arises. Weseek to avoid such errors because they can appear long after an
implementationis delivered to a client, whowouldhave no wayto fixthem.
Java generics. Aspecific mechanism inJava known asgeneric types solves precisely
theproblem thatwearefacing. Withgenerics, we canbuildcollections ofobjects of
a typeto be specified by clientcode. Theprimarybenefit of doingso isto discover
type mismatcherrors at compile time (whenthe software is being developed) in
steadof at runtime (when the software isbeing used bya client, perhaps longafter
development). Conceptually, generics are a bit confusingat first (their impact on
the programminglanguage issufficiently deepthat theywere not includedin early
versions of Java), but our use of them in the present context involves just a small
bit of extraJava syntaxand iseasyto understand. We namethe generic class Stack
and choose the generic name Item for the type of the objects in the stack (you
567

568
Algorithms and Data Structures
T^gfg^^
Bp
*$?$
"*:$
ti
%M
m
Program 4.3.4
Generic stack
public class Stack<Item>
{
private Node first;
private class Node
{
Item item;
Node
next;
}
public boolean isEmptyO
{
return (first == null);
}
public void push(Item item)
{
// Add item to top of stack.
Node oldfirst = first;
first = new Node();
first.item = item;
first, next = oldfirst;
}
public Item pop()
{
// Remove item from top of stack.
Item item = first.item;
first
= first, next;
return item;
}
public static void main(String[] args)
{
Stack<String> s = new Stack<String>();
// See Program 4.3.1 for the test client.
}
}
fi rst
| first node on list
item
next
list item
next node on
^wm^^m^^^^^^<^^^s
This code isalmost identical toProgram 4.3.2, butis worth repeating because it demonstrates
how easy it is to use generics toallow clients to make collections ofanytype ofdata. The key
word Item in this code isa type parameter, aplaceholderforanactual type name provided by
clients.

4.3 Stacks and Queues
569
can use any name). The code of Stack (Program 4.3.4) is identical to the code of
LinkedStackOfStrings (we drop the Linked modifier because we have a good
implementation for clients who donotcare about therepresentation), except that
we replaceeveryoccurrence of Stri ngwith Item and declarethe classwith the fol
lowing first line of code:
public class Stack<Item>
The name Itemisa typeparameter, asymbolic placeholder for some actual type to
beused bytheclient. You canread Stack<Item> as stack ofitems, which isprecisely
what we want. When implementing Stack,we donotknow theactual type ofItern,
but aclient canuse ourstack forany type ofdata, including onedefined long after
wedevelop our implementation. Theclient code provides an actual typewhen the
stack is created:
Stack<Apple> stack = new Stack<Apple>();
Apple a = new Apple();
stack.push(a);
Ifyou try to push an objectof the wrongtypeon the stack, likethis:
Stack<Apple> stack = new Stack<Apple>();
Apple
a = new Apple();
Orange b = new OrangeO;
stack.push(a);
stack.push(b);
// Compile-time error.
you will get a compile-time error:
push(Apple) in Stack<Apple> cannot be applied to (Orange)
Furthermore, in our Stack implementation, Java canusethe typeparameterItem
to check fortypemismatch errors—even thoughno actual typeisyetknown,vari
ables of type Item must be assigned values of type Item, and so forth.
Auto-boxing. Oneslight difficulty withgeneric code like Program 4.3.4 isthat the
type parameter stands for a reference type. How can we use the code for primitive
types suchasi nt and double? TheJava language feature knownasauto-boxingand
auto-unboxing enables us to reuse generic codewith primitive types as well. Java
supplies built-in objecttypesknownaswrapper types, one for eachof the primitive

570
Algorithms and Data Structures
types: Boolean, Byte, Character, Double, Float, Integer, Long, andShort cor
respond to bool ean, byte char,doubl e,f1oat, i nt, 1ong, andshort, respectively.
These classes consist primarilyofstatic methods suchasInteger. parselnt() and
Integer.toBinaryStringO, and they also include non-static methods such as
compareToO and equals(). Java automatically convertsbetween these reference
types andthecorresponding primitive types—in assignments, methodarguments,
and arithmetic/logic expressions—so thatwecanwritecodelike the following:
Stack<Integer> stack = new Stack<Integer>();
stack.push(17);
// Auto-boxing
(int -> Integer).
int a = stack.pop(); // Auto-unboxing (Integer ~> int).
In this example, Java automatically casts (auto-boxes) the primitive value 17 to
be of type Integer when we pass it to the push() method. The pop() method
returns an Integer, which Java casts (auto-unboxes) to an int before assigning
it to the variable a. This feature is convenient for writing code, but involvesa sig
nificant amount of processing behind the scenes that can affect performance. In
someperformance-critical applications, a class likeStackOfInts might be neces
sary,after all.
Genericsprovide the solution that weseek: they enable code reuse and at the same
time provide type safety. Studying Stack carefully and being sure that you un
derstand each line of code will pay dividends in the future, as the ability to pa
rameterize data types is an important high-level programming technique that is
well-supported in Java. You do not have to be an expertto takeadvantage of this
powerful feature.
Stack applications
Pushdown stacks play an essentialrole in computation. If
you studyoperating systems, programming languages, and other advanced topics
in computer science, youwilllearn that not onlyare stacksused explicitly in many
applications, but they alsostillserve asthe basisfor executingprograms written in
high-level languages such as Java.
Arithmetic expressions. Someofthe firstprogramsthat weconsideredin Chapter
1involved computing the valueof arithmetic expressions likethis one:
(l+((2 + 3)*(4*5)))

4.3 Stacks and Queues
571
If youmultiply 4 by 5,add 3to 2,multiply the result, and then add 1,yougetthe
value 101. But how does the Java system do this calculation? Without going into
the details of how the Java system is built,we can address the essential ideas just
bywritinga Java programthat cantake a stringasinput (theexpression) and pro
ducethe number represented bythe expression asoutput.Forsimplicity, webegin
with the following explicit recursive definition: an arithmetic expression is either: a
number or a left parenthesis followed by an arithmeticexpression followed by an
operator followed by another arithmeticexpression followed by a right parenthe
sis.For simplicity, this definition is forfully parenthesized arithmetic expressions,
which specifies preciselywhich operators applyto which operands—you are a bit
more familiar with expressionslike 1 + 2 * 3,in which we use precedence rules
instead of parentheses. The same basic mechanisms that we consider can handle
precedence rules, but we avoid that complication. For specificity, we support the
familiar binary operators *,+,-, and /, aswell asa square-rootoperator sqrt that
takesonly one argument.Wecould easily allow more operators and more kinds of
operators to embrace a large class of familiar mathematicalexpressions, involving
trigonometric, exponential, and logarithmic functions and whatever other opera
tors we might wish to include. Our focus is on understanding how to interpret the
string of parentheses,operators, and numbers to enableperforming in the proper
order the low-level arithmetic operationsthat areavailable on anycomputer.
Arithmetic expression evaluation. Precisely how can we convert an arithmetic
expression—a string of characters—to the value that it represents? A remarkably
simplealgorithm that wasdeveloped byEdsgarDijkstrain the 1960s usestwopush
down stacks(one for operands and one for operators)to do thisjob.An expression
consistsof parentheses,operators, and operands (numbers). Proceedingfrom left
to right and taking these entities one at a time, we manipulate the stacks according
to four possible cases,as follows:
• Push operands onto the operand stack.
• Push operators onto the operator stack.
• Ignore leftparentheses.
• On encountering a rightparenthesis, pop an operator, pop the requisite
number of operands, and push onto the operand stack the result of apply
ing that operator to those operands.
After the final right parenthesis has been processed, there is one value on the stack,
which is the value of the expression. This method may seem mysterious at first, but

572
Algorithms and Data Structures
St.
*"S
M
i&^^L; £:£:I:1L^
Program 4.3.5
Expression evaluation
public class Evaluate
{
public static void main(String[] args)
{
Stack<String> ops
= new Stack<String>();
Stack<Double> vals = new Stack<Double>();
while (!Stdln.isEmptyO)
{
// Read token,
push if operator.
String s = Stdln.readString();
if
(s.equals("("))
else if (s.equalsCV))
else if (s.equalsC'-"))
else if (s.equalsC*"))
else if (s.equals(M/n))
else if (s.equals("sqrt")) ops.push(s);
else if (s.equalsC')"))
{
// Pop,
evaluate,
and push result
String op = ops.popO;
double v = vals.popO;
if
(op.equals("+"))
else if (op.equalsC-"))
else if (op.equalsC'*"))
else if (op.equalsC'/"))
else if (op.equals("sqrt"))
vals.push(v);
}
// Token not operator or paren:
ops.push(s);
ops.push(s);
ops.push(s);
ops.push(s);
}
StdOut.pri ntln(vals.pop());
else vals.push(Double.parseDouble(s));
This Stack clientuses two stacks to evaluate arithmetic expressions, illustrating an essential
computationalprocess: interpreting a string asaprogram andexecuting thatprogram tocom
pute thedesired result. Executing a Java program is nothing other than a more complicated
version of thissameprocess.
Java Evaluate
(l+((2 + 3)*(4*5)))
101.0
% Java Evaluate
(
( 1 + sqrt ( 5.0 )
)
/
2.0 )
1.618033988749895
,3^^Pi^ffl^iP«^^^W^^^^^wP^SSP'w^WI^PSt^HK^^^
^^^^m^^^^^^^^^^^^^^^^^^^^^S^WWS^m^^^^'

4.3 Stacks and Queues
it is easyto convinceyourself that it computes the proper value: any time the algo
rithm encounters a subexpression consistingof two operands separated by an op
erator,allsurrounded by parentheses, it leaves the resultof performing that opera
tion on those operands on the operand stack.The result is the same as if that value
had appeared in the input instead of the sub
expression, so we can think of replacing the
subexpression by the value to get an expression
that would yield the same result.Wecan apply
this argument again and again until we get a
single value. For example, the algorithm com
putes the same value of all of these expres
sions:
573
(l+((2 + 3)* (4* 5) ) )
(
1
(
1
(
1
(
1
101
(
(
(
5
(
5
100
+ 3 )
*
(4*5
20 )
)
(
4
)
)
)
5 )
)
)
Evaluate (Program 4.3.5) is an implemen
tation of this method. This code is a simple
example of an interpreter: a program that in
terprets the computation specified by a given
string and performs the computation to ar
rive at the result. A compiler is a program that
converts the string into code on a lower-level
machine that can do the job. This conversion
is a more complicated process than the step-
by-step conversion used by an interpreter, but
it isbased on the same underlying mechanism.
Initially, Javawas based on using an interpret
er. Now, however, the Java system includes a
compiler that converts arithmetic expressions
(and, more generally,Javaprograms) into code
for the Java virtualmachine, an imaginary ma
chine that is easyto simulate on an actual com
puter.
+ C (2 + 3) * (4* 5) ) )
I ( (2 +3) * (4* 5) ) )
+ 3)
5) ) )
(4*5)))
5) ) )
(4*5)))
(4*5)))
5) ) )
5) ) )
) ) )
k.%^
))
Trace ofexpression evaluation (Program 4.3.5)

574
Algorithms and Data Structures
Stack-based programming languages. Remarkably, Dijkstra's 2-stack algorithm
also computes the same value as in our examplefor this expression:
(l((23 + )(45*)*)+)
In other words, we can put each operator after its two operands instead of between
them. In such an expression, each right parenthesis immediately followsan opera
tor so we can ignore both kinds of parentheses, writing the expressions as:
123 + 45**
+
This notation isknown as reverse Polish notation, or postfix. Toevaluate a postfix ex
pression, we use one stack (seeExercise 4.3.15). Proceeding from left to right, tak
ing these entities one at a time, we manipulate the stacks
according to just two possible cases,as follows:
• Push operands onto the operand stack.
• On encountering an operator, pop the requisite
number of operands and push onto the operand
stack the result of applying the operator to those
operands.
$TT
£
5
20
1
2
2
3
3
+
+
4
4
5
5 *
Again, this process leaves one value on the stack, which
is the value of the expression. This representation is so
simple that some programming languages,such as Forth
(a scientific programming language) and PostScript (a
page description language that is used on most printers)
use explicitstacks.For example,the string 1 2 3 + 45*
* +is a legalprogram in both Forth and PostScript that
leaves the value 101 on the execution stack. Aficionados
ofthese and similar stack-based programming languages prefer them because they
are simpler for many types of computation. Indeed, the Javavirtual machine itself
is stack-based.
3
+ 45
+ 45*
4
5
*
*
Trace ofpostfixevaluation
Function-call abstraction. Mostprogramsusestacksimplicitlybecausetheysup
port a natural wayto implement function calls,as follows: at any point during the
execution of a method, define its state to be the values of all of its variables and a
pointer to the next instruction to be executed. One of the fundamental character
isticsof computing environments is that everycomputation is fullydetermined by
its state (and the value of its inputs). In particular, the system can suspend a com-

4.3 Stacks and Queues
public static void sort(a,
{
int N = 4 - 0;
if (N <= 1) return;
sort(a, 0,
2); -<
sort(a, 2, 4);
// merge
}
0, 4)
public static void sort(a, 0, 4) j
public static void sort(a, 0,
2)
{
int N = 2 - 0;
if (N <= 1)
return;
sort(a, 0,
1); -<
sortCa, 1, 2);
// merge
}
public static void sort(a, 0, 4) I
/
i——
•
—
•—
public static void sort(a, 0, 2) |
public static void sort(a,
{
int N a 1 -
0;
if (N <= 1)
return;
-<-
sort(a, 0, 1);
sort(a, 1, 2);
// merge
}
0, 1)
public static void sort(a, 0, 4)]
public static void sort(a, 0,
2)
{
int N m 2 - 0;
if (N <= 1)
return;
sort(a, 0, 1);
sort(a,
1,
2); -<
// merge
}
public static void sort(a, 0, 4) |
public static void sort(a, 0, 2) |
public static void sort(a, 1, 2)
{
int N = 2 -
1;
if (N <= 1)
return;
-<
sort(a, 0, 1);
sort(a, 1, 2);
// merge
}
public static void sort(a, 0, 4) |
public static void sort(a, 0,
{
int N -
2 - 0;
if (N <= 1)
return;
sort(a, 0, 2);
sort(a,
2,
4);
// merge
}
//
return
•<
public static void sort(a, 0,
{
int N o 4 -
0;
if (N <o l) return;
sort(a, 0, 2);
sort(a, 2,4); -<
// merge
}
4)
•push
-push
•pop
•push
•pop
•pop
•push
Usinga stack tosupportfunction calls
putation by saving awayits state, then restart it
by restoring the state. If you take a course about
operating systems, you will learn the details of
this process, because it is critical to much ofthe
behavior of computers that we take for granted
(for example, switching from one application
to another is simply a matter of saving and re
storing state). Now, the natural way to imple
ment the function-call abstraction, which is
used by virtually all modern programming en
vironments, is to use a stack. To call a function,
pushthe state on a stack. To return from a func
tion call,popthe state from the stack to restore
all variables to their values before the function
call, substitute the function return value (if
there is one) in the expression containing the
function call (if there is one), and resume ex
ecution at the next instruction to be executed
(whose location was saved as part of the state
of the computation). This mechanism works
whenever functions call one another, even re
cursively. Indeed, if you think about the process
carefully, you will see that it is essentially the
same processthat wejust examined in detail for
expression evaluation.A program is a sophisti
cated expression.
The pushdown stack is a fundamental compu
tational abstraction. Stacks have been used for
expression evaluation, implementing the func
tion-call abstraction, and other basic tasks since
the earliestdaysof computing. Wewill examine
another (tree traversal) in Section 4.4. Stacks
are used explicitly and extensively in many ar
eas of computer science, including algorithm
design, operating systems, compilers, and nu
merous other computational applications.
575

576
Algorithms and Data Structures
enqueue
m
enqueue
CD
dequeue
CD
dequeue
CD
I
queueofcustomers
"ima
CD CD CD
TCDQ
TCDQ
first in line
leaves queue
new arrival
at the end
CE) CD CD CD
new arrival
at the end
\
CD CD CD CD CD
\
en
CD |CDCDCDCD
next in line
leaves queue
FIFO queues
A FIFO queue (or
just a queue) is a collection that is
based on the first-in-first-out (FIFO)
policy.
The policy of doing tasks in the
same order that they arrive is one that
we encounter frequently in everyday
life, from people waiting in line at a
theater, to cars waiting in line at a toll
booth, to tasks waiting to be serviced
by an application on your computer.
One bedrock principle of any
service policy is the perception of
fairness. The first idea that comes to
mind when most people think about
fairness is that whomever has been
waiting the longest should be served
first. That is precisely the FIFO disci
pline, so queues play a central role in
numerous applications. Queues are
a natural model for so many every
day phenomena, and their properties
were studied in detail even before the
advent of computers.
As usual, we begin by articulating
queue insert operation enqueue and the
the followingAPI:
an API
remove
CD TCDCD(ZD
A typical FIFO queue
,Again by tradition, we name the
operation dequeue, as indicated in
public class Queue<Item>
Queue<ltem>0
boolean
isEmptyO
void
enqueue(Item item)
Item
dequeueO
int
1engthO
APIfor ageneric FIFO queue
create an empty queue
is thequeueempty?
enqueuean item
dequeuean item
queuelength

4.3 Stacks and Queues
Asspecifiedin this API,we will use generics in our implementations, so that we can
write client programs that safely build and use queues of any reference type. We
include a 1ength () method, eventhough we did not havesuch a method for stacks
because queue clients often do need to be aware of the number of items in the
queue, whereas most stack clients do not (see Program 4.3.8 and Exercise 4.3.9).
Applyingour knowledgefrom stacks,wecan uselinked listsor array doubling
to develop implementations where the operations take constant time and the
memory associated with the queue grows and shrinks with the number ofelements
in the queue. As with stacks, each of these implementations represents a classic
programming exercise. Youmay wish to think about how you might achieve these
goalsin an implementation before reading further.
Linked-list implementation. To implement a queue with a linked list, we keep
the items in order of their arrival (the reverse of the order that we used in Stack).
The implementation of dequeue() is the same as the popO implementation in
Stack (save the item in the first list
save a link to the last node
Node oldlast = last;
oldlast
f i rst
create a newnodefor theend
Node last = new NodeO;
last.item = "not";
577
node, remove the first list node from
the queue, and return the saved item).
Implementing enqueue(), however,
is a bit more challenging: how do we
add a node to the end of a linked list?
To do so, we need a link to the last
node in the list, because that node's
link has to be changed to reference a
new node containing the item to be
inserted. In Stack, the only instance
variable is a reference to the firstnode
in the list; with only that information,
our only recourse is to traverse all
the nodes in the list to get to the end.
That solution is unattractive when
lists might be lengthy. A reasonable
alternative is to maintain a second in
stance variable that always references
the lastnode in the list. Adding an ex
tra instance variable that needs to be
fi rst
*I
1
not
null
linkthenewnodeto theendof thelist
oldlast.next = last;
oldlast
fi rst -
last
Inserting a newnodeat theend ofa linked list

578
Algorithms and Data Structures
Program4.3.6
GenericFIFOqueue (linked list)
public class Queue<Item>
{
private Node first;
private Node last;
private class Node
{
Item item;
Node next;
}
public boolean isEmptyO
{
return (first == null);
}
public void enqueue(Item item)
{
// Add item to the end of the list.
Node oldlast = last;
last = new Node();
last.item = item;
last.next = null;
if (isEmptyO) first = last;
else
oldlast.next = last;
}
public Item dequeueO
{
// Remove item from the beginning of the list.
Item item = first.item;
first = first,next;
if (isEmptyO) last = null;
return item;
}
public static void main(String[] args)
{
// Test client is similar to Program 4.3.2.
Queue<String> q = new Queue<String>();
}
f i rst
last
item
next
firstnodeon list
last node on list
list item
next node on list
•wm-im^m&m^m&
«HSBtt9»
This implementation is very similar toour linked-list stack implementation (Program 4.3.2):
dequeueO isalmost the same aspop() , fct/fenqueueO links the newitem onto the endofthe
list, notthe beginning asin push(). To doso, it maintains an instance variable thatreferences
thelastnode on thelist. The 1ength () method is leftfor an exercise (seeExercise 4.3.11).
% Java Queue < tobe.txt
to be or not to be
^W^^^^^SW^^^^^^^^^^^^^^'

4.3 Stacks and Queues
Stdln
StdOut
to
be
or
not
to
to
be
be
or
that
not
to
be
is
Trace ofQueue test client (see Program 4.3.6)
579

580
Algorithms and Data Structures
maintained is not something that should be taken lightly, particularly in linked-list
code, because every method that modifies the list needs code to check whether
that variableneeds to be modified (and to make the necessarymodifications).For
example, removing the first node in the list might involvechanging the reference
to the last node in the list, since when there is only one node in the list, it is both
the first one and the last one! (Details likethis makelinked-list code notoriously
difficultto debug.) Queue (Program 4.3.6) is a linked-list implementation of our
FIFOqueue interfacethat has the sameperformance properties as Stack: allof the
methods are constant-time,and space usage is proportional to the queue size.
Array implementations. It is also possible to develop FIFO queue implementa
tions that use arrays having the same performance characteristics as those that we
developed for stacks in ArrayStackOfStrings (Program 4.3.1) and Doubli ng
StackOfStri ngs (Program 4.3.3). These implementations are worthy program
ming exercises that you are encouraged to pursue further (see Exercise 4.3.18).
Random queues. Even though they are widely applicable, there isnothing sacred
about FIFO and LIFO. It makes perfect sense to consider other rules for remov
ing items.One of the most important to consideris a data type where dequeueO
removes a random element (samplingwithout replacement), and we have a meth
od sampl e() that returns a random elementwithout removingit from the queue
(sampling with replacement). Such actions areprecisely called for in numerous ap
plications, someof whichwehave already considered, starting with Sample (Pro
gram 1.4.1). With an arrayrepresentation, implementing sampl e() is straightfor
ward,and wecan usethe sameideaasin Program 1.4.1 to implement dequeueO
(exchange a random elementwiththe lastelementbeforeremoving it).We usethe
name RandomQueue to refer to this data type (see Exercise 4.3.36). Note that this
solution depends on usingan array representation; getting to a random element
from a linkedlist in constant time isnot possible becausewehaveto start from the
beginning and traverse links to findit.Witha (doubling) arrayrepresentation, all
of the operations are implemented in constant (amortized) time.
Thequeue, randomqueue, and stackAPIs areessentially identical—they differonly
in the choice of class and methodnames (which are chosen arbitrarily). Thinking
about this situationisa goodwayto cementunderstandingof the basicissues sur
roundingdatatypesthat weintroducedin Section3.3. Thetrue differences among

4.3 Stacks and Queues
581
these data types are in the semantics of the remove operation—which item is to be
removed? The differences between stacks and queues are in the English-language
descriptions of what they do. These differencesare akin to the differences between
Math .sin(x) and Math.1og(y), but we might want to articulate them with a for
mal description of stacks and queues (in the same way as we have mathematical
descriptions of the sineand logarithm functions).Butprecisely describingwhat we
mean by first-in-first-out or last-in-first-out or random-out is not so simple. For
starters, what languagewould you use for such a description? English? Java? Math
ematicallogic? The problem of describinghow a program behavesis known as the
specification problem, and it leads immediatelyto deep issuesin computer science.
One reason for our emphasis on clear and concise code is that the code itself can
serve as the specification for simple data types such as stacksand queues.
Queue applications
In the past century, FIFO queues proved to be accurate
and useful models in a broad variety of applications, ranging from manufactur
ing processes to telephone networksto trafficsimulations. A fieldof mathematics
known as queuing theory has been used with great success to help understand and
control complex systems of all kinds. FIFOqueues also playan important role in
computing. You often encounter queues when you use your computer: a queue
might hold songs on a playlist,documents to be printed, or events in a game.
Perhapsthe ultimate queue applicationisthe internet itself, whichisbased on
huge numbers of messages movingthrough huge numbers of queues that haveall
sorts of different properties and are interconnected in allsorts of complicated ways.
Understanding and controllingsuch a complexsysteminvolves solid implementa
tions of the queue abstraction, application of mathematical results of queueing
theory, and simulation studies involving both. Weconsider next a classic example
to givea flavor of this process.
MIDII queue. One of the simplestqueueingmodelsisknown asan M/D/l queue.
The M indicates that arrivals obey a Markov process (in this context, a Poisson pro
cess where arrivals obey a specific probabilitydistribution that has been shown to
accuratelymodel many real-worldsituations), the D indicatesthat departures are
deterministic (happen at a fixedrate), and the 1indicatesthat there is one server.It
isan appropriate modelfor asituation likeasingle lineof carsentering atollbooth:
they arrive at randomly spaced intervals, but leave at fixed intervals. An M/D/l
queue is parameterized by its arrival rate k (for example, the number of cars per

582
Algorithms and Data Structures
minute arriving at the toll booth) and its departure rate |jl (for
example,the number of carsper minute that can passthrough
the toll booth) and is characterizedby three properties:
• There is one server (a FIFO queue).
• Arrivalsare described by a Poisson processwith rate X,
where the arrivals come from an exponential distribution
(see Exercise 2.2.14).
• Departures happen at a fixedrate of |jlwhen the queue is
nonempty.
Note that the queue will grow without bound unless |x > X.
Otherwise,customers enter and leavethe queue in an interest
ing dynamic process.Also note that the time between arrivals
is l/X minutes, on the average, and the time between depar
tures, when the queue is nonempty, is 1/|ul minutes.
Analysis. In practical applications, people are interested in
the effectof the valuesof the parameters on various properties
of the queue. If you are a customer,you maywant to know the
expected amount of time you will have to wait in the queue;
if you are designingthe system, you might want to know how
many customers are likelyto be in the queue, or something
more complicated, such as the likelihood that the queue size
will exceeda given maximum size. For simple models, prob
ability theory yields formulas expressing these quantities as
functions of Xand (x. For M/D/l queues,it is known that:
• The average number of customers in the systemLis
\2/(2|x(Ijl-X)) + \/|x.
• The averagewait time Wis XI (2 |jl(fi - X)) + l/|x.
Forexample, if the carsarriveat an average rate of 10per min
ute and the servicerateis15per minute,then the average num
ber of cars in the systemwillbe 4/3 and the average wait time
will be 2/15 minutes or 8 seconds. These formulas confirm
that the wait time (and queue length) growwithout bound as
Xapproaches \l. They alsoobeya generalrule known asLittle's
law: the average number of customersin the systemis Xtimes
the average wait time (L = XW) for manytypes of queues.
Ted
Tam
qd Ten
Tedcd
CD IED
time (seconds)
ED T
Tcocb
Tcdcdcd
cdTcdcd
qdTcd
i- 0
-10
-20
30
CO
CO
CO
CO
CO
CO
arrival departure
wait
0
2
7
17
19
21
5
10
15
23
28
30
An M/D/l queue

4.3 Stacks and Queues
583
pmi
h^^M^Ml^S^^^^^^h.
Program 43J
M/D/l queue simulation
public class MDlQueue
{
public static void main(String[] args)
{
double lambda = Double.parseDouble(args[0]);
double mu
= Double.parseDouble(args[1]);
Histogram hist = new Histogram(60 + 1);
Queue<Double> queue = new Queue<Double>();
double nextArrival = StdRandom.exp(lambda);
double nextService = nextArrival
+ 1/mu;
while (true)
{
while (nextArrival
< nextService)
{
// Simulate an arrival.
queue.enqueue(nextArrival);
nextArrival += StdRandom.exp(lambda);
}
// Arrivals done; simulate a service.
double wait = nextService - queue.dequeueO;
StdDraw.clearO;
hist.addDataPoi nt(Math.mi n(60,
hist.drawO;
StdDraw.show(20);
if (queue.isEmptyO)
nextService
= nextArrival
+
else
nextService
= nextService
+
•g
lambda
arrival rate
mu
service rate
hist
histogram
queue
M/D/l queue
wait
time on queue
(int) (wait)));
}
1/mu;
1/mu;
This simulation ofan M/D/l queue keeps track of time with two variables nextArrival and
nextService and a single Queue of double values to calculate wait times. Thevalue of each
item on thequeue is the (simulated) timeit entered thequeue. Thewaiting timesareplotted
usingHi stogram (Program 3.2.3).
Wa
•:•'

584
Algorithms and Data Structures
Simulation. MDlQueue (Program 4.3.7) isa Queue client that youcan useto vali
date these sorts of mathematical results. It is a simple example of an event-based
simulation: we generate events that take place at particular times and adjust our
data structures accordingly for the events, simulating what happens at the time
they occur. In an M/D/l queue, there are two kinds ofevents: we either have a cus
tomer arrival or a customer service, so we maintain two variables:
• nextServi ce is the time of the next service.
• nextArrival is the time of the next arrival.
Tosimulate an arrival event,weenqueue a doubl e value (nextArri val, the time of
arrival);to simulatea service,wedequeueavalue,compute the waittime (nextSer-
vi ce, which isthe time of service,minus the value that came off the queue, which is
the time of arrival) and add the waittime data point to the histogram (seeProgram
3.2.3). The shape that results after a large number of trials is characteristic of the
M/D/l queueing system.From a practicalpoint of view,one ofthe most important
characteristics of the process,which you can discoverfor yourself by running MDl
Queuefor various values of Xand |ul, is that averagewait time (and queue length)
can increase dramatically when the servicerate approaches the arrival rate. When
the servicerate is high, the histogram has a visibletail where the frequency of cus
tomers having a given wait time decreases to being negligible as the wait time in
creases.But when the servicerate iscloseto the arrival rate, the tail ofthe histogram
stretches to the point that most values are in the tail, so the frequency ofcustomers
having at least the highest wait time displayeddominates.
As in many other applications that we have studied, the use ofsimulation to validate
a well-understood mathematical model is a starting point for studying more com
plex situations. In practical applications of queues, we may have multiple queues,
multiple servers,multi-stage servers,limits on queue size,and many other restric
tions. Moreover, the distributions of arrival and service times may not be possible
to characterize mathematically.In such situations, we may have no recourse but to
use simulations. It is quite common for a system designer to build a computational
model of a queuing system (such as MDlQueue) and to use it to adjust design pa
rameters (such as the service rate) to properly respond to the outside environment
(such as the arrival rate).

4.3 Stacks and Queues
585
Iterable collections
As mentioned earlier in this section, one ofthe fundamen
tal operations on arrays and linked listsisthe for loop idiom that weuse to process
each entry. This common programming paradigm need not be limited to low-level
data structures such as arrays and linked lists. For any collection, the ability to
process all of its items (perhaps in some specified order) is a valuable capability.
The client's requirement is just to process each of the items in some way, or to iter
ate through the items in the collection. This paradigm is so important that it has
achievedfirst-classstatus in Javaand many other modern languages (the program
ming language itself has specific mechanisms to support it, not just the libraries).
With it, we can write clear and compact code that is free from dependence on the
details of a collection's implementation.
To introduce the concept, we start with a snippet of client code that prints all
of the items in a collection of strings, one per line:
Stack<String> collection = new Stack<String>();
for (String s
: collection)
StdOut.println(s);
This construct is known as the foreach statement: you can read the for statement
asfor each strings in thecollection, prints. This client code does not need to know
anything about the representation or the implementation of the collection; it just
wants to process each of the items in the collection.The same for loop would work
with a Queue of strings or any other iterable collection.
We could hardly imagine code that is more clear and compact. However, im
plementing a collection that supports it requires some extra work, which we now
consider in detail. First, the foreach construct is shorthand for a while construct
(just like the for statement itself). For example, the foreach statement above is ex
actly equivalent to the following whi1e construct:
Iterator<String> i
= collection.iterator();
whi1e (i.hasNext())
{
String s = i.next();
StdOut.println(s);
}

586
Algorithms and Data Structures
This code exposes thethreejiecessary elements thatwe need to implement in any
iterable collection:
• The collection must implement an i terator() method that returns an
Iterator object.
• The Iterator class must include two methods: hasNextO (which returns
a bool ean value) and next () (which returns an item from the collection).
In Java, we use the interface mechanism to express the idea that a class imple
ments a specific method (see Section 3.3). For iterable collections, the necessary
interfaces are already defined for us in Java.
To make a class iterable, the first step is to add the phrase implements
Iterabl e<Item> to its declaration, matching the interface
public interface Iterable<Item>
{
Iterator<Item> iterator();
}
(which is in java. 1ang. Iterabl e), and to add a method to the class that returns
an Iterator<Item>. Iterators are generic;we can either use them in a generic class
or just use them to provide clientswith the ability to iterate through a specifictype
of objects.
What is an iterator? An object from a classthat implements the methods has-
Next() and next(), as defined in the following interface (which is in Java.uti 1.
Iterator):
public interface Iterator<Item>
{
boolean hasNextO;
Item next();
void
remove();
}
Although the interfacerequiresa remove() method, wealways use an empty meth
od for remove() in this book, because interleaving iteration with operations that
modify the data structure is best avoided.
Asillustrated in the followingtwo examples,implementing an iterator classis
often straightforward for array and linked-list representations of collections.

4.3 Stacks and Queues
587
Implementing an iteratorfor a class thatuses an internal array. As a first ex
ample, we will consider all of the steps needed to make ArrayStackOfStrings
(Program 4.3.1) iterable. First,change the class declaration to:
public class ArrayStackOfStrings implements Iterable<String>
In other words, we are promising to provide an i terator () method so that a client
can use a foreachstatement to iterate through the strings in the stack.The i tera-
tor() method itself is simple:
public Iterator<String> iterator()
{
return new ArraylteratorO;
}
It just returns an object from a private nested class that implements the Iterator
interface (which provides hasNextO, next(), and remove() methods):
private class Arraylterator implements Iterator<String>
{
private int i
= N-l;
public boolean hasNextO
{
return i
>= 0;
}
public Item next()
{
return a[i—];
}
public void remove()
{
}
}
Note that the nested classcan access the instancevariables of the enclosingclass, in
this case a[] and N(this ability is the main reason we use nested classesfor itera
tors). One crucial detail remains: we have to include
import Java.util.Iterator;
at the beginning of the program because (for historical reasons) Iterator is not
part of the standard library (eventhough Iterabl e ispart of the standard library).
Now a client using the foreach statement for this class willget behavior equivalent
to the common for loop for arrays,but does not need to be awareof the array rep
resentation (an implementation detail). This arrangement is ofcritical importance
for implementations offundamental data typeslikethose included in Javalibraries.
For example,it freesus to switchto a totallydifferentrepresentation without having
tochange anyclient code. More important, taking the client'spoint of view,it allows

588
Algorithms and Data Structures
clients to use iteration withouthaving to know any details of theclass implementa
tion.
Implementing an iterator for a class that uses a linked list. The same specific
steps (with different code) are effective to make Queue (Program 4.3.6) iterable,
even though it is generic.First,wechangethe classdeclaration to:
public class Queue<Item> implements Iterable<Item>
In other words,weare promising to provide an i terator () method so that a client
can use a foreach statement to iterate through the items in the stack,whatever their
type.Again, the i terator() method itselfissimple:
public Iterator<Item> iterator()
{
return new ListlteratorO;
}
Asbefore,we havea private nested class that implements the Iterator interface:
private class Listlterator implements Iterator<Item>
{
Node current = first;
public boolean hasNextO
{
return current != null; }
public Item next()
{
Item item = current.item;
current =
current.next;
return item;
}
public void remove()
{
}
}
Again,a client can build a queue of objectsof any type and then iterate through the
objects without any awareness of the linked-list representation:
Queue<String> queue = new Queue<String>();
for (String s
: queue)
StdOut.println(s);

4.3 Stacks and Queues
This client code is a clearer expres
sion of the computation and there
fore easier to write and maintain than
codebased on the low-level represen
tation.
Our stack iterator goes through
the items in LIFO order and our
queue iterator goes through them in
FIFO order, even though there is no
requirement to do so: we could re
turn the itemslnany order whatsoev
er. However, when developing itera
tors, it is wise to follow a simple rule:
if a data type specification implies a
natural iteration order, use it.
Iterator implementationsmay
seem a bit complicated to you at first,
but they are worth the effort.Youwill
not find yourselfimplementing them
veryoften,but when you do, you will
enjoythe benefits of clear and correct
client code and code reuse. Moreover,
as with any programming construct,
once you begin to enjoy these ben
efits, you willfind yourselftaking ad
vantage of them often.
Makinga class iterablecertainly
changes its API, but to avoid overly
complicated API tables, we simply
use the adjective iterable to indicate
that we have included the appropri
ate code to a class, as described in this
section, and to indicate that you can
use the foreach statement in client code
ent programs the iterable (and generic)
described here.
589
[import Java.util .Iterator;
public class Queue<Item>
{
Iterator
not in language
implements Iterable<Item>
private Node first;
private Node last;
private class Node
{
Item item;
Node next;
}
public void enqueue(Item item)
public Item dequeue()
public Iterator<Item> iteratorO
{
return new ListlteratorQ;
}
promise to
- implement
iteratorO
FIFO
queue
code
implementation
for Iterable
interface
additional
code to
make the
class iterable
I
private class Listlterator
Iimplements Iterator<Item>
}
Node current = first;
public boolean hasNextO
{
return current != null;
}
public Item next()
{
Item item = current.item;
current =
current.next;
return item;
}
public void remove()
{ }
Kpromise to implement
hasNextO, next(),
and remove ()
implementations
for Iterator
interface
public static void main(String[] args)
{
Queue<Integer> queue = new Queue<Integer>();
while (! Stdln. isEmptyO)
queue.enqueue(StdIn.readlntO) ;
for (int s
: queue)
}
StdOut.println(s);
foreach
statement
Anatomy of an iterable class
From this point forward we will use in cli-
Stack, Queue,and RandomQueue data types

590
Algorithms and Data Structures
Resource allocation
Next, we examine an application that illustrates the lan
guage features that we have been considering. A resource-sharing system involves
a large number of loosely cooperating servers who want to share resources. Each
server agrees to maintain a queue of items for sharing, and a central authority
distributes the items to the servers (and informs users where they may be found).
For example, the items might be songs, photos, or videos to be shared by a large
number of users. To fix ideas, we will think in terms of millions of items and thou
sands of servers.
We will consider the kind of program that the central authority might use
to distribute the items, ignoring the dynamics of deleting items from the systems,
adding and deleting servers,and so forth.
If weuse a round-robin policy, cycling through the serversto make the assign
ments, weget a balanced allocation,but it israrelypossiblefor a distributor to have
such complete control overthe situation: for example,there might be a large num
ber of independent distributors, so none of them could have up-to-date informa
tion about the servers. Accordingly, such systems often use a random policy, where
the assignments are based on random choice. An even better policy is to choose a
random sample of servers and assign a newitem to the one that has smallestnum
ber of items. For small queues,differences among these policiesis immaterial, but
in a system with millions of items on thousands of servers,the differencescan be
quite significant,since each serverhas a fixedamount of resources to devote to this
process. Indeed, similar systems are used in internet hardware, where some queues
might be implemented in special-purposehardware,so queue length translates di
rectlyto extra equipment cost.Buthow big a sample should we take?
LoadBal ance (Program 4.3.8) is a simulation of the sampling policy,which
we can use to study this question. This program makes good use of the high-level
constructs (genericsand iterators) that wehavebeen considering to provide an eas
ily understood program that we can use for experimentation. We maintain a ran
dom queue of queues of strings and build the computation around an inner loop
where we put each new request on the smallest of a sample of queues, using the
sample() method from RandomQueue to randomly sample queues. The surprising
end result is that samples of size two lead to near-perfect balancing, so there is no
point in taking larger samples.

4.3 Stacks and Queues
591
U
HI
wm
Program 43.8
Load balancing simulation
public class LoadBalance
{
public static void main(String[] args)
{
// Assign N items to M servers, using
// shortest-in-a-sample (of size S) policy,
int M = Integer.parselnt(args[0]);
int N = Integer.parselnt(args[l]);
int S = Integer.parselnt(args[2]);
// Create server queues.
RandomQueue<Queue<Integer» servers;
servers = new RandomQueue<Queue<Integer»();
for (int i = 0;
i < M;
i++)
servers.enqueue(new Queue<Integer>());
for (int j = 0; j < N;
j++)
{
// Assign an item to a server.
Queue<Integer> min = servers.sample();
for (int k = 1;
k < S;
k++)
{
// Pick a random server, update if new min
Queue<Integer> q = servers.sample();
if (q.lengthO < min.lengthO) min = q;
}
// min is the shortest server queue.
min.enqueue(j);
}
int i
= 0;
doubled
lengths = new double[M];
for (Queue<Integer> q:
servers)
lengths [i++] = q.lengthO;
StdDraw.setYscale(0,
2.0*N/M);
StdStats.piotBars(1engths);
M
N
S
servers
max
numberofservers
numberof items
samplesize
queues
shortestin sample
current value
y^^^^^^^w^^^^w.
This generic Queue client simulates the process ofassigning N items to a setofM servers. Re
quests areput on theshortest ofa sample ofS queues chosen at random.

592
Algorithms and Data Structures
We haveconsidered in detail the issuessurrounding the spaceand time usageof ba
sic implementations of the stack and queue APIsnot just because these data types
are important and useful,but alsobecauseyou arelikelyto encounter the verysame
issuesin the context of your own data type implementations.
Should you use a pushdown stack, a FIFO queue, or a random queue when
developing a client that maintains collections of data? The answer to this ques
tion depends on a high-levelanalysis of the client to determine which of the LIFO,
FIFO,or random disciplines is appropriate.
Should you use an array, a linked list, or a doubling array to structure your
data? The answer to this question depends on low-level analysis of performance
characteristics.With an array, the advantage is that you can access any element in
constant time and the disadvantagethat you need to know the maximum size in
advance.A linked listhas the advantage that you do not need to know the maxi
mum size in advance and the disadvantage that you cannot access an arbitrary
element in constant time. A doubling array combines the advantages of arrays and
linked lists (you can accessany element in constant time but do not need to know
the maximum size in advance) but has the (slight) disadvantage that the constant
running time is on an amortized basis.Each is appropriate in various different situ
ations; you are likely to encounter all three in most programming environments.
For example, the Javaclass java.util .ArrayList uses a doubling array, and the
Java class Java. uti 1. Li nkedLi st uses a linked list.
The powerful high-level constructs and new language features that we have
considered in this section (generics and iterators) are not to be taken for granted.
They are sophisticated language features that did not come into widespread use in
mainstream languages until the turn of the century, and they still are used mostly
by professional programmers. But their use is skyrocketing because they are well-
supported in Javaand C++, because new languages such as Python and Ruby em
brace them, and because many people are learning to appreciate the value of using
them in client code. Bynow,you know that learning to use a new language feature
is not so different from learning to ride a bicycle or implement Hell0W0rid: it
seems completely mysterious until you have done it for the first time, but quickly
becomes second nature. Learning to use generics and iterators will be well worth
your time.

4.3 Stacks and Queues
Q. When do I use newwith Node?
A. Just aswithanyotherclass, youshould only use new when youwantto create a
new Node object (a new element in the linked list).Youshould not use new to create
a new reference to an existingNode object.For example, the code
Node oldfirst = new Node();
oldfirst = first;
creates a new Node object, then immediately loses track of the only reference to it.
Thiscodedoesnot resultin an error, but it isa bit untidyto create orphans for no
reason.
Q. Whydeclare Node asa nested class? Why pri vate?
A. Bydeclaring the nested class Node to be pri vate, we restrict access to methods
within the enclosing class. Noteforexperts: Anestedclass that isnot staticisknown
asan inner class, so technically our Node classes areinner classes, though the ones
that are not generic could be static.
Q. When I type javac Li nkedStackOfStrings. Java to run Program 4.3.2 and
similar programs, I find a file LinkedStackOfStri ngs$Node.cl ass in addition to
LinkedStackOfStri ngs. cl ass. What is the purpose of that file?
A. That file is for the nested class Node. Java's naming convention is to use $ to
separate the name of the outer class from the nested class.
Q. Should a client beallowed to insert null items ontoastack or queue?
A. This question arises frequently when implementing collections in Java. Our
implementation (and Java's stackand queuelibraries) do permit the insertion of
null values.
Q. Arethere Java librariesfor stacks and queues?
593

594
Algorithms and Data Structures
A. Yes and no. Java has a built-in librarycalledj ava. uti 1. Stack, but you should
avoidusing it when you want a stack. It has several additional operations that are
not normally associated with a stack, e.g., getting the ith element. It also allows
adding an element to the bottom of the stack (instead of the top), so it can imple
ment a queue! Althoughhavingsuchextraoperations may appear to be a bonus, it
isactually a curse.Weusedata typesnot because theyprovideeveryavailable oper
ation, but rather becausethey allow us to precisely specify the operations weneed.
The prime benefit of doing so is that the systemcan prevent us from performing
operations that wedo not actually want.The j ava. uti 1. Stack APIis an example
of a wide interface, whichwegenerally striveto avoid.
Q. I want to use an arrayrepresentation for a generic stack, but codelikethe fol
lowingwillnot compile.What isthe problem?
private Item[] a = new Item[max];
A. Good try. Unfortunately, creatingarrays of generics is not allowed in Java 1.5.
Experts stillarevigorously debating thisdecision. As usual, complaining too loudly
about a language feature puts you on the slipperyslope toward becoming a lan
guagedesigner.There is a wayout, using a cast.Youcan write:
private Item[] a = (Item[]) new Object[max];
Q. Can I use a foreach loop with arrays?
A, Yes (even though arrays do not implementthe Iterator interface). Thefollow
ing one-liner prints out the command-line arguments:
public static void main(String[] args)
{
for (String s
: args) StdOut.println(s);
}
Q. Why not havea singleCol 1ecti on data type that implements methods to add
items, remove the most recently inserted, remove the least recently inserted, re
move random, iterate, return the number of items in the collection, and whatever
other operations we might desire? Then we could get them all implemented in a
single classthat could be used by many clients.

4.3 Stacks and Queues
A, Thisis an example of a wide interface, which, aswe pointedout in Section3.3,
are to be avoided. One reason to avoid wide interfaces is that it is difficult to con
struct implementations that areefficient foralloperations. Amore important rea
son is that narrow interfaces enforce a certaindiscipline on your programs,which
makes client code much easier to understand. If one client uses Stack<String>
and another usesQueue<Customer>, wehave a goodideathat the LIFO discipline
isimportant to the firstand the FIFO discipline isimportant to the second.Anoth
er approachisto useinheritanceto try to encapsulate operationsthat arecommon
to allcollections. However, suchimplementations areforexperts, whereas anypro
grammer can learn to build generic implementations such as Stack and Queue.
595

Algorithms and Data Structures
ExercismM
4.3.1
AddamethodisFullO to ArrayStackOfStrings (Program4.3.1)
4.3.2
Give the output printed by j ava ArrayStackOfSt rings 5for the input:
it was
-
the best
- of times
-
-
- it was
-
the
-
-
4.3.3
Supposethat a clientperformsan intermixedsequenceof (stack) push and
pop operations. The push operations put the integers 0 through 9 in order on to
the stack; the pop operations print out the return value.Which of the following
sequence(s) could notoccur?
a. 4321098765
b. 4687532901
c
2567489310
d. 4321056789
e.
1234569870
/ 0465381729
g. 1479865302
h. 2143658790
4.3.4
Write a stack client Reverse that reads in strings from standard input and
prints them in reverseorder.
4.3.5
Assumethat standard input has some unknown number N of doubl e val
ues. Write a method that reads all the values and returns an array oflength N con
taining them, in the order they appear on standard input.
4.3.6
Write a stack client Parentheses that reads in a text stream from standard
input and usesa stackto determine whether its parentheses are properly balanced.
For example,your program should print true for [()]{}{[()()]()} and fal se
for [ (]). Hint: Use a stack.
4.3.7
What does the following code fragment print when Nis 50? Give a high-
level description of what the code fragment in the previous exercise does when
presented with a positive integer N.

4.3 Stacks and Queues
Stack<Integer> stack = new Stack<Integer>();
while (N > 0)
{
stack.push(N % 2);
N = N /
2;
}
while (! stack. isEmptyO)
StdOut.print(stack.popO);
StdOut.printlnO;
Answer: Prints the binary representation of N(110010when Nis 50).
4.3.8
Whatdoesthe following code fragment do to the queueq?
Stack<String> stack = new Stack<String>();
while (Iq.isEmptyO)
stack.push(q.dequeueO);
while (!stack.isEmptyO)
q. enqueue(stack. popO) ;
4.3.9
Add a method peek() to Stack (Program4.3.4) that returns the most re
cently inserted element on thestack (without popping it).
4.3.10 Give thecontents andsize ofthearrayforDoubl i ngStackOfSt ri ngs with
the input:
it was - the best - of times -
-
- it was - the -
-
4.3.11 Add a method length() to Queue (Program4.3.6) that returns the num
ber of elements on the queue. Hint: Make sure that yourmethod takes constant
time by maintaining an instance variable Nthat you initialize to 0, increment in
enqueue(), decrement in dequeue(), and return in length().
4.3.12 Drawa memoryusage diagram in the style of the diagrams in Section4.1
for the three-node example used to introduce linked lists in this section.
597

598
Algorithms and Data Structures
4.3.13 Write a programthat takes fromstandardinput an expression withoutleft
parentheses and printsthe equivalent infix expression with the parentheses insert
ed. For example,giventhe input:
l
+ 2)*3-4)*5-6)))
your program should print
(
( 1 + 2 )
* (
( 3
4 )
* (
5 -
6 )
)
4.3.14 Write a filter Infi xToPostfi xthat converts an arithmetic expression from
infix to prefix.
4.3.15 Write a program EvaluatePostfix that takes a postfix expression from
standard input,evaluates it,and printsthe value. (Piping the output of your pro
gram from theprevious exercise tothisprogram gives equivalentbehaviorto Eva! -
uate, in Program 4.3.5).
4.3.16 Suppose thataclient performs anintermixed sequence of (queue) enqueue
and dequeue operations. The enqueue operations put the integers 0 through 9 in
orderonto thequeue; thedequeue operations print out thereturnvalue. Which of
the followingsequence(s) could notoccur?
a. 0123456789
b. 4687532901
a
2567489310
d. 4321056789
4.3.17 Write an iterable Stack clientthat has a static method copy () that takes a
stackof stringsas argumentand returns a copyof the stack. Note: This abilityis a
primeexample of thevalue ofhaving an iterator, because it allows development of
such functionality without changing the basic API. See Exercise 4.3.47 for a better
interface.

4.3 Stacks and Queues
4.3.18 Develop a class Doubl i ngQueueOfStri ngsthat implements the queueab
stractionwith a fixed-size array, and then extendyourimplementationto usearray
doubling to remove the size restriction.
4.3.19 Write a Queue clientthat takes a command-line argumentkprints the kth
from the last stringfound on standardinput.
4.3.20 (Forthemathematicallyinclined.) Prove thatthearrayin Doubl i ngStack
OfStri ngs is neverless than one-quarterfull. Then prove that, for anyDoubl i ng
StackOfSt ri ngs client, the total costof allof the stackoperationsdividedby the
number of operations is a constant.
4.3.21 Modify MDlQueue to make a program MMlQueue that simulates a queue
for which both arrival and service arePoisson processes. Verify Little's lawfor this
model.
4.3.22 Develop a class StackOfInts that usesa linked-list representation (but no
generics). Write a client that compares the performance of your implementation
with Stack<Integer> to determine the performance penaltyfromautoboxing on
your system.
599

600
Algorithms and Data Structures
Tfttk^St^1^^^^^*1^!^
This listofexercises isintended togiveyouexperience inworking with linked lists. The
easiest way towork them istomake drawings using the visual representation described
in the text
4.3.23 Writea method del ete() that takesan i nt argument kand deletes the kth
element in a linked list, if it exists.
4.3.24 Write a method find() that takes a linked list and a string key as argu
ments and returns true if some node in the list has key as its item field, false
otherwise.
4.3.25 Suppose x is a linked-list node. What is the effect of the following code
fragment?
x.next
= x.next.next;
Answer: Deletesfrom the list the node immediately following x.
4.3.26 Supposethat xisa linkedlistnode.What doesthe following codefragment
do?
t.next
= x.next;
x.next
= t;
Answer: Inserts node t immediatelyafter node x.
4.3.27 Why does the following code fragment not do the same thing as in the
previous question?
x.next = t;
t.next
= x.next;
Answer: When it comes time to update t. next, x. next is no longer the original
node following x,but is instead t itself!
4.3.28 Write a method removeAfterO that takes a linked-list Node as argument
and removes the node following the given one (and does nothing if the argument
or the next field in the argument node is null).

4.3 Stacks and Queues
4.3.29 Writea method i nsertAfter() that takes twolinked-list Node arguments
and insertsthe secondafterthe firston itslist(anddoesnothingifeitherargument
is null).
4.3.30 Writea method remove() that takes a linkedlist and a string key as argu
ments and removes all of the nodes in the list that have key as its item field.
4.3.31 Write a method max() that takes a reference to the first node in a linked list
as argument and returns the value of the maximum keyin the list.Assumethat all
keys are positive integers, and return 0 if the listisempty.
4.3.32 Develop a recursive solution to the previousquestion.
4.3.33 Write a recursive method to print the elements of a linked list in reverse
order. Do not modify any of the links. Easy: Use quadratic time, constant extra
space. Also easy: Uselinear time, linear extra space. Notsoeasy: Develop a divide-
and-conquer algorithmthat uses linearithmic time and logarithmic extra space.
4.3.34 Write a recursive method to randomly shuffle the elementsof a linked list
bymodifying the links. Easy: Use quadratic time,constantextraspace. Notsoeasy::
Develop a divide-and-conquer algorithm that uses linearithmic timeand logarith
mic extra space.

602
Algorithms and Data Structures
4.3.35 Deque. A double-ended queue ordeque (pronounced deck) isacombina
tion of a stackand and a queue. It stores a collection of items and supports the
following API:
public class Deque<Item>
Deque()
boolean
isEmpty()
void
enqueue(Item item)
void
push(Item item)
Item
pop()
Item
dequeue()
create an emptydeque
is thedequeempty?
add an item to the end
add an item to thebeginning
remove an itemfrom thebeginning
remove an itemfrom theend
APIforageneric double-ended queue
Write a class Deque that uses alinked list to implement this API.
4.3.36 Random queue. A random queue stores acollection of itemsandsupports
the following API:
public class RandomQueue<Item>
RandomQueue()
boolean
isEmptyO
void
enqueue(Item item)
Item
dequeueO
Item
sample()
create an empty random queue
is thequeueempty?
add an item
remove and return a random item
(sample without replacement)
return a random item, but do not remove
(sample with replacement)
APIfor a generic random queue
Write aclassRandomQueue that implements this API.Hint:Use an arrayrepresenta
tion (with doubling). To remove anitem,swap one at arandom position (indexed
0throughN-l) with the oneatthelast position(index N-l). Then delete andreturn

4.3 Stacks and Queues
the last object,as in Doubl i ngStack. Write a clientthat prints a deck of cards in
random order using RandomQueue<Card>.
4.3.37 Random iterator. Write an iterator for RandomQueue<Item> from the pre
vious exercise that returns the items in random order. Note: This exercise is more
difficult than it looks.
4.3.38 Josephus problem. In the Josephus problem from antiquity,N people are
in dire straits and agree to the following strategyto reduce the population. They
arrange themselves in a circle(at positions numbered from 0 to N—l) and proceed
around the circle,eliminating everyMth person until only one person is left.Leg
end has it that Josephusfiguredout whereto sit to avoidbeingeliminated.Write a
Queue client Josephus that takesN and M from the command line and prints out
the order in which people are eliminated (and thus wouldshowJosephuswhere to
sit in the circle).
% Java Josephus 7 2
13
5
0
4
2
6
4.3.39 Delete ithelement. Implement a class that supports the following API:
public class GeneralizedQueue<Item>
GeneralizedQueue()
boolean
isEmptyO
void
insert(Item item)
Item
delete (int i)
create an empty queue
is thequeue empty?
add an item
delete and return thei thleastrecently
inserted item
APIfor ageneric generalized queue
First, develop an implementation that uses an array implementation, and then de
velop one that uses a linked-list implementation. (See Exercise 4.4.48 for a more
efficientimplementation that uses a BST.)

Algorithms and Data Structures
4.3.40 Ring buffer. A ring buffer, or circular queue,is a FIFO data structure of a
fixed sizeN.It isusefulfor transferringdatabetweenasynchronousprocesses or for
storinglog files. When the bufferis empty, the consumer waitsuntil data is depos
ited;whenthebufferisfull, theproducerwaitsto depositdata.Develop anAPIfor a
ringbufferand an implementation that uses an arrayrepresentation (withcircular
wrap-around).
4.3.41 Merging two sorted queues. Given two queues with strings in ascending
order, moveallof the strings to a third queue so that the third queue ends up with
the strings in ascendingorder.
4.3.42 Nonrecursive mergesort. Given N strings,createN queues,each containing
one ofthe strings.CreateaqueueoftheN queues. Then,repeatedlyapplythe sorted
merging operationto thefirsttwoqueues andreinsertthe mergedqueueat the end.
Repeatuntil the queue of queuescontainsonlyone queue.
4.3.43 Queue withtwo stacks. Showhow to implement a queue using two stacks.
Hint:If you push elementsonto a stackand then pop them all,they appear in re
verseorder. Repeatingthe processputs them back in FIFOorder.
4.3.44 Move-to-front. Readin a sequence of charactersfrom standard input and
maintain the characters in a linked list with no duplicates. When you read in a
previouslyunseen character, insert it at the front of the list.When you read in a du
plicate character,delete it from the list and reinsert it at the beginning. Name your
program MoveToFront: it implementsthe well-know move-to-front strategy, which
is useful for caching, data compression, and many other applications where items
that havebeen recentlyaccessed are more likelyto be reaccessed.
4.3.45 Topological sort. You have to sequencethe order of Njobs that are num
bered from 0 to N-l on a server. Some of the jobs must complete before others
can begin. Write a program Topological Sorter that takes Nas a command-line
argument and a sequenceon standard input of ordered pairs of jobs i j, and then
prints a sequence of integers such that for each pair i j in the input, job i appears
before job j. Use the followingalgorithm: First, from the input, build, for each job,
(i) a queue of the jobs that must followit and (ii) its indegree (the number ofjobs

4.3 Stacks and Queues
that must come before it). Then, build a queue of allnodes whose indegree is 0 and
repeatedly delete some job with zero indegree,maintaining all the data structures.
This process has many applications: for example,you can use it to model course
prerequisites for your major so that you can find a sequence of courses to take in
order to graduate.
4.3.46 Text editor buffer. Develop a data type for a buffer in a text editor that
implements the following API:
public class Buffer
Buffer()
void
insert(char c)
char
deleteO
void
left(int k)
void
right (int k)
int
sizeQ
create an empty buffer
insert c at thecursorposition
delete and return the character at the cursor
move thecursor k positions to theleft
move thecursor kpositions to theright
number ofcharacters in thebuffer
APIfora text buffer
Hint: Use two stacks.
4.3.47 Copy a stack. Create a new constructor for the linked list implementation
of Stack so that
Stack<Item> t
= new Stack<Item>(s);
makes t a reference to a new and independent copy of the stack s. Youshould be
ableto push and pop from either s or t without influencingthe other.
4.3.48 Copy a queue. Create a new constructor so that
Queue<Item> r = new Queue<Item>(q);
makes r a reference to a new and independent copy of the queue q. Hint: Delete all
of the elements from q and add these elements to both q and r.

Algorithms and Data Structures
4.3.49 Reverse a linked list. Write a function that takes the first Node in a linked
list as argument and reverses the list,returning the first Node in the result.
Iterative solution: To accomplish this task, we maintain references to three con
secutive nodes in the linked list, reverse, f i rst, and second. At each iteration, we
extract the node f i rst from the original linked list and insert it at the beginning
of the reversed list. We maintain the invariant that f i rst is the first node ofwhat's
left ofthe original list, second is the second node of what's left of the original list,
and reverse is the first node of the resulting reversedlist.
public Node reverse(Node list)
{
Node first
= list;
Node reverse = null;
while (first != null) {
Node second = first.next;
first.next
= reverse;
reverse
= first;
first
= second;
}
}
return reverse;
When writing code involving linked lists, we must always be careful to properly
handle the exceptional cases (when the linked list is empty, when the list has only
one or two nodes) and the boundary cases(dealing with the first or last items). This
is usuallymuch trickier than handling the normal cases.
Recursive solution: Assumingthe linked list has N elements, we recursivelyreverse
the last N— 1 elements, and then carefullyappend the first element to the end.

4.3 Stacks and Queues
public Node reverse(Node first)
{
}
Node
second
Node
rest =
second.next = first;
first.next
= null;
return
rest;
= first.next;
reverse(second);
4.3.50 Queue simulations. Study what happens when you modify MDlQueue to
use a stack instead of a queue. Does Little's law hold? Answer the same question
for a random queue. Plot histograms and compare the standard deviationsof the
waiting times.
4.3.51 More queue simulations. Instrument LoadBal ance to print the average
queue length and the maximum queue length instead of plotting the histogram,
and use it to run simulations for 1million items on 100,000 queues. Print the aver
age valueofthe maximum queue length for 100trials eachwith samplesizes 1,2,3,
and 4. Do your experiments validatethe conclusion drawn in the text about using
a sample of size 2?
4.3.52 Listingfiles. A folderis alist of files and folders. Write a programthat takes
the name ofa folderasacommand-line argument and prints out allofthe files con
tained in that folder, with the contents of each folder recursivelylisted (indented)
under that folder's name. Hint: Use a queue, and see j ava. i o. Fi1e.
607

Algorithms and Data Structures
4.4
Symbol Tables
A symbol table isa data type that we use to associate values with keys. Clients can
store (put) an entry into the symboltable by specifying a key-value pair and then
can retrieve (get) the value correspond-
ing to aparticular key from the symbol
441 Dictionarylookup
614
table. For example, a university might
4.4.2
indexing
617
associate information such as a student's
4.4.3
BST symbol table
625
name, home address, and grades (the
4AA
Dedup filter ..'...'
633
value) with that student's social security
Programs inthis section
number (the key), so that each student's
record can be accessed byspecifying a So
cialSecuritynumber. The same approach might be appropriate for a scientist who
needs to organize data, a business that needs to keep track of customer transac
tions, an internet searchenginethat has to associate keywords with web pages, or
in countless other ways.
Because of their fundamental importance, symbol tables have been heavily
used and studied since the early days of computing. The development of imple
mentations that guarantee good performance continues to be an active area of re
searchinterest. Several other operations on symbol tablesbeyond the characteristic
put and get operations naturally arise, and guaranteeing good performance for a
given set of operations can be quite challenging.
In this chapter we consider a basic API for the symbol-table data type and a
classic implementation of that API.Our APIadds to the put and getoperations the
abilitiesto test whether any value has been associatedwith a givenkey (contains)
and to iterate through the keysin the table in order.
The implementation that we consider is based on a data structure known as
the binary search tree (BST). It is a remarkablysimple solution that performs well
in many practical situations and also serves as the basis for the industrial-strength
symbol-table implementations that are found in modern programming environ
ments. The BST code that we consider for symbol tables is only slightlymore com
plicated than the linked-list code that we considered for stacks and queues, but it
will introduce you to a new dimension in structuring data that has far-reaching
impact.

4.4 Symbol Tables
609
API
A symbol table is a collection of key-valuepairs. We use a generic type Key
for keysand a generic type Value for values—every symbol-table entry associatesa
Value with a Key. In most applications,the keys havesome natural ordering, so (as
we did with sorting) we require the key type Key to implement Java's Comparable
interface. These assumptions lead to the followingbasicAPI:
public class *ST<Key extends Comparable<Key>, Value>
*ST()
create a symbol table
void
put (Key key, Value v)
putkey-value pair into the table
Val ue
get (Key key)
return value paired with key, nul 1 if key notin table
bool ean
COntai ns (Key key)
isthere a value paired with key?
Note: Implementations should alsoimplement theIterabl e<Key> interface toenable clients toaccess
keys in sorted order withforeach loops.
APIfor a generic symbol table
As usual, the asterisk is a placeholder to indicate that multiple implementations
might be considered. In this section, weprovide one basicimplementation BST (we
describe some elementary implementations brieflyin the text and some other im
plementations in the exercises). ThisAPIreflects severaldesigndecisions,which we
now enumerate.
Comparable keys. Asyou willsee, wetake advantage of keyordering to develop
efficient implementations of put and get. An even more basic symbol-table API,
suitable for some applications, might omit extends Comparable. Since keys in
most applications are numbers or strings, this requirement is generally not restric
tive.
Immutable keys. We assume the keys do not change theirvalue while in the sym
bol table. The simplest and most commonly used types of keys,Stri ng and built-
in wrapper types such as Integer and Doubl e, are immutable.
Replace-the-old-value policy. If a key-value pair isinsertedinto the symboltable
that already associates another value with the given key, we adopt the convention

610
Algorithms and Data Structures
that the new value replaces the old one (just as with an array assignment state
ment). The contai ns() method gives the clientthe flexibility to avoiddoing so,if
desired.
Notfound. The method get() returns null if no entrywith the given key has
previously been put into the table. This choice has two implications, discussed
next.
Nullkeys andvalues. Clients arenot permittedto usenul1asakeyor value. This
convention enables us to implement contai ns() as follows:
public boolean contains(Key key)
{
return get(key)
!= null;
}
Remove. We do not include a method for removing keys from the symbol table.
Many applications do require such a method, but we leave implementations as an
exercise (see Exercise 4.4.13) or for a more advanced course in data structures in
algorithms.
Iterable. As indicated in the notein theAPI, we assume that the datatypeimple
ments the Iterabl e interfaceto providean appropriate iterator that allows clients
to visit the contents of the table. Since keys are Comparable, the natural order of
iteration is in order of the keys. Accordingly, we will implement Iterabl e<Key>
and clients can usegetto getvaluesassociatedwith keysif desired.
Variations. Computerscientists have identified numerousother useful operations
on symbol tables, and APIs based on various subsets of them have been widely
studied. Weconsider severalof these operations at the end of this section.
Symboltablesare among the most widely studied data structures in computer sci
ence, so the impact of these and many alternative design decisions has been care
fully studied, as you will learn if you take later courses in computer science. In
this chapter, our approachisto introduceyouto the most important propertiesof
symboltables byconsidering twoprototypical clientprograms,developing an effi
cient implementation,and studyingthe performancecharacteristics of that imple
mentation, to showyou that it can meet the needs of typical clients,evenwhen the
tables are huge.

4.4 Symbol Tables
611
Symbol table clients
Once you gain some experience with the idea, you will
find that symbol tables are broadly useful. To convince you of this fact, we start
with two prototypicalexamples, eachof whicharises in a large number of impor
tant and familiar practical applications.
Dictionary lookup. The most basic kind of symbol-table client builds a symbol
table with successiveput operations in order to supportgetrequests.Wemaintain a
collectionof data so that we can quicklyaccess the data weneed.Most applications
alsotake advantageof the idea that a symboltableis a dynamic dictionary,where it
is easyto look up information andto update the information in the table.The fol
lowinglist of familiar examples illustratesthe utilityof this approach.
• Phone book. When keysare people'snames and valuesare their phone num
bers, a symbol table models a phone book. A very significant difference
from a printed phone book isthat wecanadd newnamesor changeexisting
phone numbers. We could also use the phone number as the key and the
name asthe value.Ifyou haveneverdone so,try typingyour phone number
(with area code) into the search fieldin your browser.
• Dictionary. Associating a word with its definition is a familiar concept that
gives us the name"dictionary." Forcenturies peoplekept printed dictionar
ies in their homes and officesin order to checkthe definitions and spellings
(values) of words (keys). Now, becauseof good symbol-table implementa
tions, people expect built-in spell checkers and immediate access to word
definitions on their computers.
•Account information. People who own stock now regularlycheck the cur
rent price on the web. Several services on the webassociate a ticker symbol
(key) with the current price (value), usually alongwith a greatdealof other
information. Commercialapplications of this sort abound, includingfinan
cial institutions associating account information with a name or account
number or educational institutions associatinggrades with a student name
or identification number.
• Genomics. Symbols playa centralrole in modern genomics, as we haveal
readyseen (seeProgram 3.1.8).The simplestexampleisthe use of the letters
A, C, T,and Gto represent the nucleotides found in the DNAof living organ
isms.The next simplestis the correspondence betweencodons (nucleotide
triplets) and amino acids (TTA corresponds to leucine, TCT to cycstine, and
so forth), then the correspondence between sequences of amino acids and

612
Algorithms and Data Structures
proteins, and so forth. Researchers in genomics routinely usevarious types
of symbol tables to organize thisknowledge.
•Experimental data. From astrophysics to zoology, modern scientists are
awash in experimental data, and organizing and efficiently accessing this
data is vital to understanding what it means. Symbol tables are a critical
starting point, and advanced data structures and algorithms that are based
on symboltablesare now an important part of scientificresearch.
•Programming languages. One of the earliest uses of symbol tables was to
organize information for programming. At first, programswere simplyse
quences of numbers,but programmers veryquickly found that usingsym
bolic names for operations and memory locations (variable names) was
far more convenient. Associating
the names with the numbers re-
^ey
va\ue
quires a symbol table. As the size
of programs grew,the cost of the
symbol-table operations became
a bottleneckin program develop
ment time, which led to the de
velopment of data structures and
algorithms like the one we con
sider in this section.
•Files. We use symbol tables regu
larly to organize data on com
puter systems. Perhaps the most
prominent example is the file
system, where we associate a file name (key) with the location of its con
tents(value). Your music player uses thesamesystem to associate songtitles
(keys)with the location of the music itself (value).
Internet DNS. The domain name system (DNS) that is the basis for orga
nizing information on the internet associates URLs (keys) that humans
understand (such as www.princeton.edu or www.wikipedia.org) with
IP addresses (values) that computer network routers understand (such as
208.216.181.15 or 207.142.131.206). This systemis the next-generation
"phonebook." Thus,humanscanusenames that areeasy to remember and
machines can efficiently process the numbers.The number of symbol-table
lookups done each second for this purpose on internet routers around the
phonebook
name
phone number
dictionary
word
definition
account
account number
balance
genomics
codon
amino acid
data
data/time
results
Java compiler
variable name
memory location
file share
song name
machine
internet DNS
website
IP address
Typical dictionary applications

4.4 Symbol Tables
world is huge, so performance is of obvious im
portance. Millions of new computers and other
devices are put onto the internet each year, so
these symbol tableson internet routers need to be
dynamic.
Despite its scope, this list is still just a representative
sample, intended to giveyou a flavor of the scope of
applicability of the symbol-table abstraction. When
everyou specifysomething by name, there isa symbol
table at work. Your computer's file system or the web
might do the work for you, but there is stilla symbol
table there somewhere.
For example, to build a table associating codons
with amino acid names, we can write code like this:
ST<String,
String> amino;
amino = new ST<String, String>();
ami no.put("TTA", "leucine");
The idea of associating information with a key is so
fundamental that many high-level languages have a
built-in support for associative arrays, where you can
use standard array syntax but with keys inside the
brackets instead of an integer index. In such a lan
guage,you could write ami no["TTA"] = "1euci ne"
instead of ami no. put("TTA", "1euci ne"). Although
Java does not (yet) support such syntax, thinking in
terms of associativearrays is a good wayto understand
the basic purpose of symbol tables.
Lookup(Program 4.4.1) builds a set of key-value
pairs from a file of comma-separated values (seeSec
tion 3.1) as specified on the command line and then
prints out values corresponding to keys read from
standard input. The command-line arguments are the
file name and two integers, one specifying the fieldto
serve as the key and the other specifying the field to
% more amino.csv
TTT,Phe,F,Phenylalani ne
TTC,Phe,F,Phenylalani ne
TTA,Leu,L,Leucine
TTG,Leu,L,Leucine
TCT,Ser,S,Serine
TCC,Ser,S,Serine
TCA,Ser,S,Serine
TCG,Ser,S,Serine
TAT,Tyr,Y,Tyrosine
TAC,Tyr,Y,Tyrosine
TAA,Stop,Stop,Stop
GCA.Ala
GCG,Ala
GAT,Asp
GAC,Asp
GAA.Gly
GAG.Gly
GGT.Gly
GGCGly
GGA,Gly
GGG,Gly
,A,Alanine
,A,Alanine
,D,Aspartic Acid
,D,Aspartic Acid
,G,Glutamic Acid
,G,Glutamic Acid
,G,Glycine
,G,Glycine
,G,Glycine
,G,Glycine
613
% more DDIA.csv
20-0ct-87,1738.74,608099968,1841.01
19-0ct-87,2164.16,604300032,1738.74
16-0ct-87,2355.09,338500000,2246.73
15-Oct-87,2412.70,263200000,2355.09
30-Oct-29,230.98,10730000,2 58.47
29-0ct-29,252.38,16410000,230.07
28-Oct-29,295.18,9210000,260.64
25-Oct-29,299.47,5920000,301.22
% more np.csv
www.ebay.com,66.135.192.87
www.pri nceton.edu,128.112.128.15
www.cs.pri nceton.edu,128.112.136.35
www.harvard.edu,128.103.60.24
www.yale.edu,130.132.51.8
www.cnn.com,64.236.16.20
www.google.com,216.239.41.99
www.nyti mes.com,199.239.136.200
www.apple.com,17.112.152.32
www.siashdot.org,66.35.250.151
www.espn.com,199.181.135.201
www.weather.com,63.Ill.66.11
www.yahoo.com,216.109.118.65
Typical comma-separated-value (CSV) files

614
Algorithms and Data Structures
M
.'•s:;',
&&1
l
^.it:;M.^:-^& •: ."'^-vh^v*
^^:;:^^^:^^^:^i^v<^ '&
Program 4.4.1
Dictionary lookup
public class Lookup
{
public static void main(String[] args)
{
// Build dictionary,
provide values for keys in Stdln.
In in = new In(args[0]);
int keyField = Integer.parselnt(args[1]);
int valField = Integer.parselnt(args[2]);
String[] database = in.readAn().split("\n");
StdRandom.shuff1e(database);
BST<String, String> st = new BST<String, String>();
for (int i = 0; i < database.length;
i++)
{
ft
}
// Extract key, value from one line and add to ST.
String[] tokens = database[i].split(",");
String key = tokens[keyField];
String val = tokens[valField];
in
st. put(key, val);
keyField
valFi eld
database[]
st
tokens
key
val
while (!Stdln.isEmptyO)
{
// Read key and provide value.
String s = Stdln.readStringO;
if (st.contains(s))
StdOut.println(st.get(s));
else StdOut.println("Not found");
}
inputstream(.csv)
key position
valueposition
linesin input
symboltable(BST)
values on a line
key
value
query
}
i^WiWPSa
S>3«??p5SwlS§§!
This data-driven symbol table client reads key-value pairsfrom a comma-separatedfile, then
prints out values corresponding to keys on standard input. Both keys and values are strings.
^^^^^^m^^^^^^^^m^^^w^^^^^^^v^^^^^^
% Java Lookup ami no.csv 0 3
TTA
Leucine
ABC
Not found
TCT
Serine
% Java Lookup ami no.csv 3 0
Glycine
GGG
^1S1SP!PP
^wSJ^SSS^-S
% Java Lookup ip.csv 0 1
www.google.com
216.239.41.99
% Java Lookup ip.csv 1 0
216.239.41.99
www.google.com
% Java Lookup DJIA.csv 0 1
29-0ct-29
252.38
4JJPM8
^^jjswF^I^

4.4 Symbol Tables
615
serveas the value.Examples of similarbut slightly more sophisticated test clients
are described in the exercises. For instance, we could make the dictionary dynamic
by also allowing standard-input commands to change the value associated with a
key (seeExercise 4.4.1).
Your first step in understanding symboltablesis to download Lookup. Java
and BST. java (the symbol-table implementation that weconsider next) from the
booksite to do some symbol-table searches. You can find numerous comma-sep-
arated-value (. csv) files that are related to various applications that we have de
scribed, including ami no.csv (codon-to-amino-acid encodings), DJIA. csv (open
ingprice, volume, and closing priceofthestock market average, forevery dayin its
history), and i p. csv (aselection of entries fromthe DNS database). Whenchoos
ingwhich field to useas the key, remember that each key must uniquely determine
a value. If there are multipleputoperations to associate values with a key, the table
willrememberonly the most recentone (think about associative arrays). Wewill
consider next the casewhere we want to associatemultiple valueswith a key.
Laterin this chapter,wewillseethat the costof theputoperations and the get
requests in Lookup islogarithmic in the size of the table. Thisfactimplies that you
mayexperience a smalldelaygettingthe answer to yourfirstrequest(for alltheput
operationsto build the table), but yougetimmediate response for allthe others.
Indexing. Index (Program 4.4.2) isa prototypical example of a symbol-table cli
ent that usesan intermixedsequence of calls to get() and put (): it readsin a list
of stringsfrom standard input and prints a sortedtableof allthe different strings
alongwith a list of integers specifying the positions where eachstring appearedin
the input. Wehavea largeamount of data and want to knowwherecertain strings
of interest occur. In this case,we seem to be associatingmultiple values with each
key, but weactually associating justone: a queue. Again, thisapproach isfamiliar:
• Book index. Every textbook has an indexwhereyou look up a word and get
the pagenumbers containing that word.Whileno readerwants to seeevery
word in the book in an index, a program like Index can provide a starting
point for creating a good index.
•Programminglanguages. In alarge program that uses alarge numberofsym
bols, it is useful to know where each name is used. A program like Index
can be a valuable tool to help programmers keep track of where symbols
are used in their programs. Historically, an explicit printed symbol table
wasone of the most important tools usedby programmers to manage large

616
Algorithms and Data Structures
programs. In modern systems, symbol tables are the basis of software tools
that programmers useto manage names of modules in systems.
• Genomics. In a typical (if oversimplified) scenario in genomics research, a
scientist wants to knowthepositions ofagiven genetic sequence in an exist
inggenome or setof genomes. Existence or proximity of certain sequences
maybe of scientific significance. Thestartingpoint for such research is an
indexlikethe one producedbyIndex, modifiedto takeinto accountthe fact
that genomesare not separatedinto words.
• Web search. When youtype a keyword and get a listof websites containing
that keyword, you are using an index created byyour web search engine.
There isonevalue (thelistof pages) associated witheach key (the query),
although the reality isabitmoredynamic andcomplicated because weoften
specify multiple keys andthe pages arespread throughthe web, not keptin
a table on a single computer.
•Account information. One way for a companythat maintains customer ac
countsto keeptrack of a day's transactions is to keepan indexof the list of
the transactions. The keyis the account number; the value is the list of oc
currences of that account number in the
transaction list.
key
value
book
term
pagenumbers
genomics
DNA substring
locations
web search
keyword
websites
business
customer name
transactions
Index (Program 4.4.2) takes three com
mand-line arguments: a file name and two
integers. The first integer is the minimum
stringlength to include in the symboltable,
and the second is the minimum number of
occurrences (among the words that appear
in the text) to include in the printed index. Again, several similar clients for vari
ous useful tasks arediscussed in the exercises. Forexample, one commonscenario
isto buildmultiple indices on the same data, using different keys. In our account
example, one index might use customer account numbers for keys and another
might use vendor account numbers.
Aswith Lookup, you are certainly encouraged to download Index from the
booksite andrunitonvarious inputfiles togain further appreciation fortheutility
ofsymbol tables. Ifyou doso, you will find thatit canbuild large indices forhuge
files withlittle delay, because eachputoperation andgetrequest istaken care ofim
mediately. Providing thisimmediate response forhuge dynamic tables isoneofthe
classic contributions of algorithmic technology.
Typical indexingapplications

4.4 Symbol Tables
617
tiJ
m
I
?%i
Program 4.4.2
Indexing
public class Index
{
public static void main(String[] args)
{
int mini en = Integer.parselnt(args[0]);
int minocc = Integer.parselnt(args[1]);
String[] words = Stdln. readAll Q .split(,,\\s+") ;
BST<String, Queue<Integer» st;
st = new BST<String, Queue<Integer»();
for (int i =0;
i < words.length;
i++)
{
// Add word position to data structure.
String s = words[i];
if (s.lengthO < mini en) continue;
if (1st.contains(s))
st.put(s,
new Queue<Integer>());
Queue<Integer> q = st.get(s);
q.enqueue(i);
}
for (String s : st)
{
// Print words whose occurrence count exceeds threshold.
Queue<Integer> q = st.get(s);
if (q.length() >= minocc)
StdOut.println(s + ":
" + q);
}
mini en
mi nocc
words []
st
minimumlength
occurence threshold
words in Stdln
symbol table
current word
queueofpositions
for current word
P
£••;
IT
This symbol table client indexes a textfile by word position. Keys are words, and values are
queues ofpositions where theword occurs in thefile.
Java Index 9 30 < TaleOfTwoCities.txt
confidence:
2794 23064 25031 34249 47907 48268 48577
courtyard: 11885 12062 17303 17451 32404 32522 38663
evremonde:
86211 90791 90798 90802 90814 90822 90856
expression:
3777 5575 6574 7116 7195 8509 8928 15015
gentleman:
2521 5290 5337 5698 6235 6301 6326 6338 ..
influence:
27809
36881 43141 43150 48308
54049
54067
monseigneur:
85 90 36587 36590 36611 36636 36643 ...
prisoners:
1012 20729 20770 21240 22123 22209 22590 .
something: 3406 3765 9283 13234 13239 15245 20257 ...
sometimes:
4514 4530 4548 6082
20731 33883
34239
...
vengeance: 56041 63943 67705 79351 79941 79945 80225
,^^BBsR^^ffl^^^^W^^wvS&f-isi^?s*8s¥*3a!Spp^M^^^^^S^^^^^^^^^^^W^^^^^^^

618
Algorithms and Data Structures
Symbol table implementations
All of these examples are certainly persua
sive evidence of the importance of symboltables. Symbol-table implementations
have been heavily studied, many different algorithms and data
structures have been invented for this purpose, and modern
programming environments (including Java) have several dif
ferent symbol-table implementations. You are goingto learn a
remarkablysimpleone that serves as the basisfor many others.
Asusual,knowinghowa basicimplementation workswillhelp
you appreciate, chooseamong, and more effectively use the ad
vanced ones, or helpimplementyourownversionforsomespe
cialized situation that you might encounter.
One reasonfor the proliferation of algorithms and imple
mentations is that the needs of symbol-table clients can vary
widely. On the one hand, when the symbol table or the number
of operations to be performed issmall,anyimplementation will
do. On the other hand, symboltables for some applications are
so huge that they are organized as databases that reside on ex
ternal storageor the web. In this section,we focus on the huge
class of clients like Index and Lookup whose needs fall between
these extremes, wherewe need to be able to useput operations
to build and maintain large tables dynamically while also re
sponding immediatelyto a large number of getrequests.
We already considered the idea of a dictionary when we
considered binary search in Section 4.2. It is not difficult to
build a symbol-table implementation that is based on binary
search (see Exercise 4.4.5) but such an implementation is not
feasible for use with a client like Index, because it depends on
maintaining an array sorted in order of the keys. Each time a
new key is added, larger keys have to be shifted one position
higher in the array, whichimpliesthat the total time required to
build the table is quadratic in the size ofthe table.
Alternatively, we might consider basing an implementa
tion on an unordered linked list. But such an implementation
is also not feasible for use with a client like Lookup or Index,
because the only wayto search for a keyin a list is to traverse its links, so the total
time required for searches is the product of the number of searches and the size of
put CATinto
/
thearray
AAA
/
AAA
AAC
AAG
AAC
AAG
AAT
ACT
ATA
ATC
ATG
AGG
AGT
CAG
CCT
CGA
CGC
CGG
CGT
CTT
GAA
GAC
GAG
GAT
GCT
GGA
GTC
GTG
GTT
TAA
TAC
TAG
TAT
TCA
TGT
TTA
TTC
TTG
TTT
AAT
ACT
ATA
ATC
ATG
AGG
AGT
CAG
CAT
CCT
CGA
CGC
CGG
CGT
CTT
GAA
GAC
GAG
GAT
GCT
GGA
GTC
GTG
GTT
TAA
TAC
TAG
TAT
TCA
TGT
TTA
TTC
TTG
TTT
largerkeys
all have to move
Put intoa sortedarray
takes linear time

4.4 Symbol Tables
619
unordered
ccc
CCT
^-^
AAA
ACT
->
ACT ^r
CCC
CCC
->
Meed togo through
whole list to know
thatany keyis notthere
TAG
Ga
CGC
null
key-sorted order
ATG
GAA
^
GTT
J-
MCfl
GGG
^
GTT
^
TAG
^>
needtogo through
nearly thewholelisttofind
keysneartheend
ca
Get in a linked list takes linear time
the table,which againisprohibitive.Implementingputisalsoslowbecausewehave
to searchfirstto avoidputting duplicatekeys in the symboltable.Even keepingthe
list in sorted order does not help much—for example,traversingallthe links is still
required to add a new node to the end of the list.
Toimplement a symbol-tablethat isfeasible for usewith clientssuch as Look
up and Index, we need the flexibility of linked lists and the efficiency of binary
search.Next,we consider a data structure that providesthis combination.
Binary search trees
The binary tree is a mathematicalabstraction that plays
a central role in the efficient organization of information. Like arrays and linked
lists,a binary tree is a data type that storesa collection of data. Binarytrees playan
important role in computer programming because they strike an efficient balance
between flexibilityand ease of implementation.
For symbol-table implementations, weuse a specialtype of binary tree to or
ganize the data and to providea basisfor efficient implementationsof the symbol-
table put operations and get requests. A binary search tree (BST) associates com
parable keys with values, in a structure defined recursively. A BST is one of the
following:
• Empty (null)
• A node havinga key-value pair and two references to BSTs, a left BST with
smaller keysand a right BST with larger keys
The key type must implement Comparabl e, but the type of the value is not speci
fied, so a BST node can hold any kind of data in addition to the (characteristic)
references to BSTs. As with our linked-list definition in Section 4.3, the idea of a
recursivedata structure can be a bit mind bending,but allweare doing is adding a
second link (and imposing an ordering restriction) to our linked-list definition.

620
Algorithms and Data Structures
To implement BSTs, we start with a class for the nodeabstraction, which has
references to a key, a value, and leftand right BST:
class
Node
{
Key key;
Value val;
Node left,
right;
}
Thisdefinitionislikeour definition of nodesfor linkedlists, except that it has two
links, not just one. Fromthe recursive definition of BSTs, we can representa BST
with a variable of type Node byensuringthat its valueis either nul1 or a reference
to a Node whose 1eft and ri ght fields are
references to BSTs, and by ensuring that the
ordering condition is satisfied (keys in the
leftBST aresmallerthan keyand keys in the
right BST are larger than key).To(slightly)
simplify the code, we add a constructor to
Node that initializes key and val:
Node(Key key, Value val)
{
this.key = key;
this.val = val;
}
Binarysearch tree
The resultof new Node(key, val) is a reference to a Node object (whichwe can
assign to any variable of type Node) whose key and val instance variables are set to
the given values and whose 1eft and ri ght instance variables are both initialized
to null.
As with linked lists, when tracing code that uses BSTs, we can use a visual
representation of the changes:
• Wedraw a rectangleto representeachobject.
• Weput the valuesof instancevariables within the rectangle.
•Wedepictreferences asarrows that point to the referenced object.
Most often, we use an even simpler abstract representation where we draw rect
angles containingkeys to representnodes (suppressing the values) and connect the
nodes with arrows that representlinks. This abstract representation allows us to
focus on the structure.

4.4 Symbol Tables
For example, suppose that Key is String and Value is Integer. To build a
one-node BSTthat associatesthe key i t with the value 0,we just create a Node:
Node first = new NodeC'it", 0);
Sincethe left and right links are both null, both refer to BSTs, so this node is a BST.
To add a node that associates the key was with the value 1, we create another
Node:
621
Node first
= new NodeC'it", 0);
Node second = new Node("wasM, 1);
(which itself is a BST) and link to it from the right field of
the first Node
first.right = second;
The second node has to go to the right of the first because
was comes after i t in Comparabl e order (or we could have
chosen to set second. 1eft to fi rst). Now we can add a
third node that associatesthe key the with the value 2with
the code:
Node third = new NodeC'the",
2);
second.left = third;
and a fourth node that associates the key best with the
value 3 with the code
Node fourth = new NodeC'best",
3);
first.left = fourth;
Note that each of our links—fi rst, second, thi rd, and
fourth—are, by definition, BSTs (they each are either null
or refer to BSTs, and the ordering condition is satisfiedat
each node).
We often use tree-based terminology when discuss
ing BSTs. We refer to the node at the top as the rootof the
tree, the node referenced by its left link as the leftsubtree,
and the node referenced by its right link asthe rightsubtree.
Traditionally, computer scientists draw trees upside down,
with the root at the top. Nodes whose links are both null are called leafnodes. In
ull\»u"\
Node
second
first.right
new Node("was"
second;
t-nnof i—first
"•^
|jwas |ll
| null\nulll
1);
Node third=
new Node("the",
2);
second.left = third;
Node fourth
first.left
=
= new NodeC'best",
2);
fourth;
Linking together a BST

622
Algorithms and Data Structures
general, atree mayhave multiple linksper node,the order of the linksmaynot be
significant, and no keysor values in the nodes. General trees have many applica
tions in science, mathematics,and computational applications, so you are certain
to encounter the model on many occasions.
In the present context, we take care to ensure that we always link together
nodes suchthat every Node that we create is the root of a BST (hasakey,avalue, a
link to aleft BSTwith smaller values, and alink to aright BSTwith alarger value).
From the standpoint ofthe BST data structure, the value is immaterial, so we often
ignore it, but we include it in the definition becauseit plays such a centralrole in
the symbol-table concept. We also intentionally confuseour nomenclature, using
STto signifyboth "symboltable" and"search tree" because search trees playsucha
centralrolein symbol-table implementations.
A BST represents an ordered sequence of items. In the example just consid
ered, fi rst represents the sequence best i t the was.We canalso useanarray to
represent a sequence of items. Forexample,we could use:
String[]
a = { "best", "it", "the",
"was" };
to represent the sameordered sequence ofstrings. Givenasetofdistinctkeys, there
is only one way to represent them in an ordered array, but there are many ways
to represent it in a BST (see Exercise4.4.7). This
flexibility allows us to develop efficientsymbol-
table implementations. For instance, in our ex
ample we were ableto insert each new item by
creating a new node and changing just one link.
As it turns out, it is always possible to do so.
Equallyimportant, we caneasily find agivenkey
in the tree and find the place where we need to
add alink to a new node with a given key. Next,
we considersymbol-tablecodethat accomplish
es these tasks.
Suppose that you want to search for a node
with a givenkey in aBST (or to getavaluewith a
givenkey in a symbol table). There are two pos
sible outcomes: the search might be successful
(we find the key in the BST; in a symbol-table
implementation, we return the associatedvalue)
Two BSTs representing thesamesequence

4.4 Symbol Tables
623
or it might be unsuccessful (there is no key in the BST with the given key; in a
symbol-table implementation, we return null).
A recursive searching algorithm is immediate: Given a BST (a reference to
a Node), first check whether the tree is empty (the reference is null). If so, then
terminate the search as unsuccessful (in a symbol-table implementation, return
nul 1). If the tree is nonempty, check whether the key in the node is equal to the
search key. If so, then terminate the search as successful (in a symbol-table imple
mentation, return the value associatedwith the key).If not, compare the search key
with the keyin the node. If it is smaller, search (recursively) in the left subtree; if it
is greater,search (recursively)in the right subtree.
Thinking recursively, it is not difficultto become convincedthat this method
behavesas intended, based upon the invariant that the keyis in the BSTif and only
if it is in the current subtree. The key property of the recursivemethod is that we
always havejust one node to examine in order to decidewhat to do next. Moreover,
we typicallyexamine only a small number of the nodes in the tree: whenever we
go to one of the subtrees at a node, we neverwillexamineany of the nodes in the
other subtree.
successful search
unsuccessful search
fora node with key the
fora node with key ti mes
times isafterit
sogo to theright
the isafter it
best
so go to the right ["'the j
of
AT
_
jf
jbest |
| was |
[best |
| was |
„_.>p^
,*^<^ ti mes is before was
ttne 1 \
\^LA
so go to the left
— ^
the is before was
LJILJ
50 g0 to the left
,Liil
best
I the |
1 the |
times isafter the
"of I
T
| yf
^
so the BST has no node
ssuccess!
l
'
having that key
Searching in a BST

624
Algorithms and Data Structures
insert times
Suppose that you want to insert a new node into a BST (in a symbol-table
implementation, put a new key-value pair into the data structure). The logic is
similarto searchingfor a key, but the implementation istrickier.The keyto under
standing it isto realizethat onlyone link must be changed to point to the new node,
and that link is preciselythe link that would be found to be null in an unsuccessful
search for the key in that node.
If the BSTis empty, we create and return
a new Node containing the key-value pair; if
the search key is less than the key at the root,
we set the left link to the result of inserting the
key-valuepair into the left subtree; if the search
key is greater,we set the right link to the result
of inserting the key-value pair into the right
subtree; otherwise, if the search key is equal,
we overwrite the existing value with the new
value. Resetting the link after the recursive call
in this way is usually unnecessary,because the
link changesonly if the subtree is empty, but it
is as easy to set the link as it is to test to avoid
setting it.
BST (Program 4.4.3) is a symbol-table
implementation based on these two recursive
algorithms. If you compare this code with our
binary search implementation BinarySearch
(Program 4.2.3) and our stack and queue
implementations Stack (Program 4.3.4) and
Queue (Program 4.3.6), you will appreciate the
elegance and simplicity of this code. Take the
time to think recursively and convince yourself
that this code behaves as intended. Perhaps the
simplest way to do so is to trace the construc
tion of an initiallyempty BSTfrom a sample set
of keys. Your abilityto do so isa suretest of your understanding of this fundamen
tal data structure.
Moreover, the put() and get() methods in BST are remarkably efficient:
typically, each accesses a smallnumber of the nodes in the BST (those on the path
I best
it
of-jf
the
times is afterit
sogo to theright
]
times is be/orewas
sogo to theleft
times is after the
so it goeson the right
Insertinga new nodeinto a BST

4.4 Symbol Tables
mm
Hi
•::-''}.'-^-i%U^
Program 4.4.3
BST symbol table
public class BST<Key extends Comparable<Key>, Value>
{
private Node
root;
private class Node
{
Key key;
Value val;
Node left,
right;
Node(Key key, Value val)
{
this.key = key; this.val = val;
}
public Value get(Key key)
{
return get(root,
key);
}
private Value get(Node x,
Key key)
{
if (x == null) return null;
int cmp = key.compareTo(x.key);
if
(cmp < 0) return get(x.left,
key);
else if (cmp > 0) return get(x.right, key);
else
return x.val;
}
public boolean contains(Key key)
{
return (get(key)
!= null);
}
public void put(Key key, Value val)
{
root = put(root, key, val);
}
private Node put(Node x,
Key key, Value val)
{
if (x == null) return new Node(key, val);
int cmp = key.compareTo(x.key);
if
(cmp < 0) x.left
= put(x.left,
key, val);
else if (cmp > 0) x.right = put(x.right, key, val);
else
x.val = val;
return x;
}
Thisimplementation of thesymbol-table data type iscentered on therecursive BSTdatastruc
tureand recursive methodsfor traversing it.
625

626
key
inserted
^
the
| it
|
best
I it
I
best
the
of
fit
best
CZD
times
it
Constructing a BST
Algorithms and Data Structures
from the root to the node sought or to the null link that
is replaced by a link to the new node). Next, we show
that put operations and get requests take logarithmic
time (under certain assumptions). Also, put() only
creates one new Node and adds one new link. If you
make a drawing of a BSTbuilt by inserting some keys
into an initially empty tree, you certainly will be con
vinced of this fact—you can just draw each new node
somewhere at the bottom of the tree.
Performance characteristics of BSTs
The run
ning times of BSTalgorithms are ultimately dependent
on the shape of the trees, and the shape of the trees is
dependent on the order in which the keysare inserted.
Understanding this dependence isa criticalfactor in be
ing able to use BSTs effectively in practical situations.
Best case. In the best case, the tree is perfectly bal
anced (each Node has exactly two non-null children),
with lgN nodes between the root and each leaf node. In
such a tree, it iseasyto seethat the cost ofan unsuccess
ful search is logarithmic, because that cost satisfies the
same recurrence relation as the cost of binary search
(see Section 4.2) so that the cost of every put opera
tion and getrequest is proportional to lg JV or less.You
would haveto be quite luckyto get a perfectlybalanced
tree like this by inserting keys one by one in practice,
but it is worthwhile to know the best possible perfor
mance characteristics.
Average case. If we insert random keys, we might
expect the search times to be logarithmic as well, be
cause the first element becomes the root ofthe tree and
should divide the keys roughly in half. Applying the
same argument to the subtrees, we expect to get about
the same result as for the best case. This intuition is in-

4.4 Symbol Tables
worst|
Bestcase(perfectly balanced) BSTs
deed validatedby carefulanalysis: aclassic mathematical derivation shows that the
time required for put and get in a tree constructed from randomly ordered keys is
logarithmic (see the booksite for references). More precisely, the expected number
ofkeycomparisons is ~2 In Nfor a random put orget in a keybuiltfromN randomly
ordered keys. In a practical applicationsuch as Lookup, when we can explicitly ran
domize the order of the keys, this result suffices to (probabilistically) guarantee
logarithmic performance. Indeed, since 2 In JV is about 1.39lg JV, the average case
is only about 39% higher than the bestcase. In an applicationlike Index, where we
have no control of the order of insertion, there is no guarantee, but typical data
giveslogarithmic performance (seeExercise 4.4.17).As with binary search, this fact
is very significant because of the enormousness of the logarithmic-linear chasm:
with aBST-basedsymbol tableimplementation, we canperform millions ofopera
tions per second (or more), even in a huge table.
rofi
Typical BSTs constructedfrom randomly ordered keys
627

628
Algorithms and Data Structures
1best 1
ADI I\
,
[ of
A
,
the
A
|times|
\
was
|
\
.
|worst|
Iworstl
V
was |
/
1ti mes
,
'•
the
'•
r of
r±r^
UiJ
, ',
| best |
| best
worst|
1 ^
r
| was |
~s>~
c of
|
-^<
1timesi|
7
1 the |
Worst case. In the worstcase, eachnode has exactlyone null link,
so the BST islikea linkedlistwith an extra wastedlink,whereput
operations and get requests take linear time. Unfortunately, this
worst caseis not rare in practice—it arises, for example, when we
insert the keysin order.
Thus, good performance of the basic BSTimplementation is
dependent on the keys being sufficientlysimilar to random keys
that the tree is not likely to contain many long paths. If you are
not sure that assumption isjustified,donotusea simple BST. Your
onlycluethat somethingisamisswillbe slowresponsetime as the
problem size increases. (Note: It is not unusual to encounter soft
ware of this sort!) Remarkably, there are BSTvariants that elimi
nate this worst case and guarantee logarithmic performance per
operation, bymakingalltreesnearlyperfectlybalanced.One pop
ular variant is known as a red-black tree. The Java library Java,
uti 1.TreeMapimplements a symbol table using this approach.
Traversing a BST
Perhaps the most basic tree-processing
function isknown as tree traversal: givena (reference to) a tree,we
want to systematically processeverykey-valuepair in the tree. For
linked lists,we accomplish this task by following the single link
to move from one node to the next. For trees, however, we have
decisionsto make,becausethere are generallytwo links to follow.
Recursion comes immediatelyto the rescue.To process every key
in a BST:
Processeverykey-valuepair in the left subtree.
Processthe key-valuepair at the root.
Process everykey-value pair in the right subtree.
This approach is known as inorder tree traversal,to distinguish it
from preorder (do the root first) and postorder (do the root last),
which arise in other applications. Given a BST, it is easy to con
vince yourself with mathematical induction that not only does
this approach processeverykey pair in the BST, but that it pro
cesses them in key-sorted order. For example, the followingmeth
od prints the keys in the tree rooted at its argument in key-sorted
Worst-case BSTs
order:

4.4 Symbol Tables
629
private static void traverse(Node x)
{
if (x == null) return;
traverse(x.left);
StdOut.pri ntln(x.key);
traverse(x.right);
}
This remarkably simplemethod isworthyof care
ful study. It can be used as a basis for a toStri ng()
implementation for BSTs (see Exercise4.4.11) and
also a starting point for developing the iterator
that we need to provide clients the ability to use
a foreachloop to process the entries in key-sorted
order.
smallerkeys, in order
key
larger keys, in order
^ all keys,in order
Recursive inorder traversal ofa binary search tree
Implementing an iterable symbol table. Aclose lookattherecursive t raverse ()
method just considered leads to a way to make our BST data type Iterable. For
simplicity, we just process the keys because we can getthe values when we need
them. Our goalisto enableclientcodelikethe following:
BST<String,
Double> st = new BST<String, Double>();
for (String key: st)
StdOut.println(key +
" + st.get(key));
Index (Program 4.4.2) is another example of suchclientcode.
As usual, wefirstpromise to provide an iteratorO method by adding the
phrase implements
Iterable<Key> to the class declaration. This addition is a
commitment to provide an iteratorO method for iterating through the keys in
the table,in key-sorted order.Asusual, the i terator() method itselfis simple:
public Iterator<Key> iteratorO
{
return new BSTIterator();
}
We need a private nested classthat implements the Iterator interface, but im
plementing such a class is a bit of a challenge. We cannot direcdy use recursive
traversal, becausewe need to be ableto pauseand restart the process. Tothis end,
we maintain an explicit Stack that contains the sequence of nodes from the root

630
Algorithms and Data Structures
downto the current node.Thesystem call stackduring the execution of the recur
sive traverseO has essentially this sameinformation.
private class BSTIterator implements Iterator<Key>
{
Stack<Node> stack = new Stack<Node>();
}
BSTIteratorO
// see below
public boolean hasNextO
{
return !stack.isEmptyO;
}
public Key next()
// see below
public void remove()
{
}
To complete thisimplementation, weneeda BSTIterator() constructorthat ini
tializesthe stack and a next() method that returns the next key. The recursivet ra-
verseO method callsitselffor the left link of each node until reaching a null link
(at the node with the smallestkeyin the BST). Therefore,to prepare for processing
the smallest key, we need to initialize the stack to contain the nodes in the BST
reached byfollowing leftlinksfromthe root.To do so,weusea helpermethod:
private void pushl_eft(Node x)
{
while (x
!= null)
{
stack.push(x);
x = x.left;
}
}
BSTIteratorO
{
pushLeft(root);
}
In particular, the node with the smallest keyin the BST is on the top of the stack
after this initialization. Now, to processa key, we pop the top node from the stack
and process its right subtree using the same method:

4.4 Symbol Tables
631
public Key next()
{
Node x = stack.pop();
pushLeft(x.right);
return x.key;
}
Convincingyourselfthat these methods allow clientslikeIndex to iterate through
the keys of a BST in keyorder bytracingtheir operation on some sample trees will
teach you a great deal about BSTs, stacks,and recursion.
Extended symbol table operations
Theflexibility ofBSTs enables theimple
mentation of manyusefuladditionaloperationsbeyondthosedictatedbythe sym
boltableAPI. We leave implementations oftheseoperationsfor exercises and leave
further studyof their performance characteristics and applications for a coursein
algorithms and data structures.
Minimum and maximum. To find the smallest key in a BST, follow left links
from the root until reaching null. The lastkeyencountered is the smallest in the
BST. The same procedure following right linksleadto the largestkey.
Size. To keep trackof the numberof nodes in a BST, keep an extrainstance vari
able N in BST that counts the number of nodes in the tree. Initialize it to 0 and
increment it whenever creating a new Node. Alternatively, keep an extra instance
variable N in Node that counts the number of nodes in the subtree rooted at that
node. Initializeit to 1 and increment it for eachnode on the searchpath when in
serting a new Node, taking care to handle properlythe duplicate-keycase,when no
new Node is added (see Exercise 4.4.20).
Remove. Manyapplications demandthe ability to remove a key-value pair with a
givenkey. You can find explicitcodefor removinga node from a BST on the book-
siteor in a book on algorithms and datastructures. Aneasy, lazywayto implement
remove () relieson the fact that our symboltableAPIdisallows nul1 values:
public void remove(Key key)
{
if (contains(key))
put(key, null);
}

632
Algorithms and Data Structures
This approach necessitates periodically cleaningout nodes in the BST with null
values, becauseperformance willdegradeunlessthe sizeof the data structure stays
proportional to the number of key-value pairs in the table.
Range search. Witha recursive methodlike traverse(), wecancount the num
ber of keys that fall between two given values or return an iterator for keys fall
ing between two givenvalues. For example, a financial institution might build a
symbol-tablewhosekeys areaccountbalances to be ableto processaccountswhose
balances are above certain limits.
Order statistics. If wemaintain an instancevariablein each node havingthe size
of the subtree rooted at each node, we can implement a recursive method that re
turns the fcth largestkeyin the BST in logarithmic time.
Thislist is representative; numerous other important operations havebeen invent
ed for BSTs that are broadly useful in applications.
Henceforth, we will use the reference implementation ST that implements our
basic interface using the symbol-table implementation in Java.uti 1.TreeMap,
which is based on advancedtype of BST known as the red-black tree. Red-black
trees, which you are likely to encounter if you take an advanced course in data
structures and algorithms, are of interest because they support a logarithmic-time
guaranteefor get(), put(), and manyof the other operations just described.
Set data type
Asa finalexample, we consider a data type that is simpler than a
symboltable,stillbroadlyuseful, and easyto implement with BSTs.Asetisa collec
tion of distinct keys, likea symboltablewith no values. Wecould use ST and ignore
the values,but client code that usesthe followingAPI is simpler and clearer:
public class SET<Key extends Comparable<Key»
SET()
create a set
boolean
isEmptyO
is thesetempty?
void
add (Key key)
add key to theset
bool ean
contai ns (Key key)
is key in theset?
Note: Implementations shouldalsoimplement theIterabl e<Key> interface toenable
clientstoaccess keys in sortedorder withforeach loops
APIfor a generic set

4.4 Symbol Tables
PI
h&ftfo^'^t&^fi&fi^^
mm
Program 4AA
Dedupfilter
public class DeDup
{
public static void main(String[] args)
{
// Filter out duplicate strings.
SET<String> distinct = new SET<String>();
while (!Stdln.isEmptyO)
{
// Read a string, ignore if duplicate.
String key = Stdln. readStringO ;
if (!distinct.contains(key))
{
// Save and print new string,
distinct.add(key);
StdOut.pri nt(key);
}
StdOut.println();
>
>
>
di sti net
key
633
set of distinctstring
values in Stdln
This SET client isafilter that removes duplicate strings in the input stream, using a SET con
taining thedistinct strings encountered sofar.
% Java DeDup < TaleOfTwoCities.txt
it was the best of times worst age wisdom foolishness.
Aswith symbol tables,there is no intrinsic reasonthat the keytype should imple
ment the Comparable interface. However, processing Comparableitems is typical,
and we can take advantage of item comparison to develop efficient implementa
tions, so we include Comparable in the interface. Implementing SET by deleting
referencesto val in our BST code is a straightforward exercise (seeExercise 4.4.15).
DeDup (Program 4.4.4) is a SET client that reads a sequence of strings from
standard input and prints out the firstoccurrenceof eachstring (thereby removing
duplicates).Youcan find many other examplesof SET clientsin the exercises at the
end of this section. In the next section,you willseethe importance of identifying
such a fundamental abstraction, illustrated in the context of a case study.

634
Algorithms and Data Structures
Perspective
The use of binary search trees to implement symbol tables and
sets is a sterling example of exploiting the tree abstraction, which is ubiquitous
and familiar. Trees lie at the basis of many scientific topics, and are widely used
in computer science. We are accustomed to many tree structures in everyday life,
including family trees, sports tournaments, the organization chart of a company,
and parse trees in grammar. Trees also arise in numerous computational applica
tions, including function call trees, parse trees for programming languages, and
file systems. Manyimportant applications are rooted in science and engineering,
including phylogenetic trees in computational biology, multidimensional treesin
computergraphics, minimaxgame treesin economics, and quad treesin molecular
dynamics simulations. Other,morecomplicated, linkedstructurescanbe exploited
as well,as you will see in Section 4.5.
Symbol table implementations are a prime topic of further study in algo
rithms and data structures. Examples include balanced BSTs, hashing, and tries.
Implementations of many of these algorithms and data structures are found in
Java and most other computational environments.DifferentAPIsand different as
sumptionsabout keys callfordifferent implementations. Researchers in algorithms
and data structures stillstudysymbol-table implementations of allsorts.
People use dictionaries, indexes, and other kinds of symboltableseveryday.
Within a short amount of time, applicationsbased on symbol tableswillcomplete
lyreplace phone books,encyclopedias, and allsortsof physical artifacts that served
us well in the last millennium. Without symbol-table implementations based on
data structures such asBSTs, such applicationswould not be feasible; with them, we
havethe feeling that anythingthat weneed is instantly accessible online.

4.4 Symbol Tables
Q. Whyuse immutable symboltablekeys?
A. If we changed a key while it was in the BST, it would invalidate the ordering
restriction.
Q. Whynot usethe Java librarymethods forsymbol tables?
A. Now that you understand how a symbol table works, you are certainly wel
come to use the industrial-strength versions j ava. uti 1. TreeMap and Java. uti 1.
HashMap. Theyfollow the samebasicAPI as BST, but theyallow null keys and use
the names contai nsKeyO andkeySetO instead of contai ns() and iteratorO,
respectively. They also contain additional methods such as remove (), but they do
not provide any efficientwayto add some of the additional methods that we men
tioned, such as order statistics. You can also use Java.uti 1.TreeSet and Java,
uti 1. HashSet, which implement an API likeour SET.
635

636
Algorithms and Data Structures
4.4.1
ModifyLookup to to makeaprogram LookupAndPut that allowsputopera
tionsto bespecified on standardinput.Use the convention that aplussignindicates
that the next two stringstyped arethe key-value pair to be inserted.
4.4.2
Modify Lookup to make aprogramLookupMul ti pie that handlesmultiple
values having the samekeybyputtingthe values on a queue,asin Index, and then
printing them allout on agetrequest, asfollows:
% Java LookupMultipie ami no.csv 3 0
Leucine
TTA TTG CTT CTC CTA CTG
4.4.3
ModifyIndex to makea program IndexByKeyword that takesa file name
from the command line and makes an index from standard input using only the
keywords in that file. Note: Using the samefile for indexing and keywords should
givethe same result as Index.
4.4.4
Modify Index to make a program IndexLines that considers only con
secutive sequences of letters as keys (no punctuation or numbers) and uses line
numbers instead of word position asthe value.This functionality is usefulfor pro
grams, as follows:
% Java IndexLines 6 0 < Index.Java
continue 12
enqueue 15
Integer 4 5 7 8 14
parselnt 4
5
println 22
4.4.5
Develop an implementation Bi narySearchST of the symbol-tableAPIthat
maintains parallelarraysof keys and values, keepingthem in key-sorted order. Use
binary search for get, and movelarger elements to the right one position for put
(usearray doubling to keepthe arraysizeproportional to the number of key-value
pairs in the table).Test your implementationwith Index, and validatethe hypoth
esis that using such an implementation for Index takes time proportional to the
product of the number of strings and the number of distinct strings in the input.

4.4 Symbol Tables
4.4.6
Develop an implementation LinkedListST of the symbol-table API that
maintains a linked list of nodes containing keysand values,keeping them in arbi
trary order. Testyour implementation with Index, and validate the hypothesis that
using such an implementation for Index takes time proportional to the product of
the number of strings and the number of distinct strings in the input.
4.4.7
Draw allthe different BSTs that can represent the keysequence best of i t
the time was.
4.4.8
Draw the BST that results when you insert items with keys
EASYQUESTION
in that order into an initially empty tree.
4.4.9
Suppose we have integer keysbetween 1 and 1000 in a BSTand search for
363.Which of the followingcannot be the sequenceof keysexamined?
a.
2
252 401 398 330 363
b.
399 387 219 266 382 381 278 363
c.
3 923 220 911 244 898 258 362
363
d.
4 924 278 347 621 299 392 358 363
e.
5
925
202 910 245
363
4.4.10 Suppose that the following 31 keys appear (in some order) in a BST of
height 5:
10 15 18 21 23 24 30 30 38 41 42 45
50
55
59
60 61 63 71 77 78 83 84 85 86 88 91 92 93 94 98
Draw the top three nodes ofthe tree (the root and its two children).
4.4.11 Implement toStri ng() for BST, using a recursivehelper method like t ra
ve rse(). As usual, you can accept quadratic performance because of the cost of
string concatenation. Extra credit: Write a linear-time toStri ng() method for BST
that uses Stri ngBui 1der.
637

Algorithms and Data Structures
4.4.12 True or false: Givena BST, let x be a leaf node, and letp be its parent. Then
either (i) the key of p is the smallestkeyin the BST larger than the key of x or (ii)
the keyofp is the largestkeyin the BST smallerthan the keyofx.
4.4.13
Modify BST to add a method remove () that takes a key argument and
removes that key (and the corresponding value) from the symbol table, if it exists.
Implement it by setting the value associatedwith the given key to null.
4.4.14 Modifythe symbol-tableAPI to handle valueswith duplicate keysby hav
ing get() return an iterator for the values having a given key. Implement BST and
Index as dictated by this API.Discussthe pros and cons of this approach versus the
one given in the text.
4.4.15 Modify BST to implement the SET API givenat the end of this section.
4.4.16 Aconcordance isan alphabeticallistof the words in a text that gives allword
positions where each word appears. Thus, Java Index 0 0 produces a concor
dance. In a famous incident, one group of researcherstried to establish credibility
while keepingdetailsof the Dead SeaScrolls secretfrom others by making public
a concordance. Write a program InvertConcordance that takes a command-line
argument N, reads a concordance from standard input, and prints the first Nwords
of the corresponding text on standard output.
4.4.17 Run experiments to validate the claims in the text that the put operations
and getrequestsfor Lookup and Index are logarithmic in the sizeof the table when
using BST. Develop test clients that generate random keys and also run tests for
various data sets, either from the booksite or of your own choosing.
4.4.18 Modify BST to add a method si ze() that returns the number of elements
in the table. Use the approach of storing within each Node the number of nodes in
the subtree rooted there.
4.4.19 Modify BST to add a method rangeCount () that takes two Key arguments
and returns the number of keysin a BST between the two givenkeys. Yourmethod
should take time proportional to the height of the tree. Hint: First work the previ
ous exercise.

4.4 Symbol Tables
4.4.20 Modify BST to add methods mi n() and max() that return the smallest(or
largest) key in the table (or nul 1 if no such keyexists).
4.4.21 ModifyBST to implement a symbol-table APIwherekeys are arbitrary ob
jects.Use hashCodeO to convertkeys to integers and use integerkeys in the BST.
Note: This exercise is trickier than it might seem,because of the possibility that
hashCodeO can return the same integer for two different objects.
4.4.22 Modify your SET implementation from Exercise 4.4.15 to add methods
f loor() and cei 1() that take as argument a Key and return the largest (smallest)
element in the set that is no larger (no smaller) than the given Key.
4.4.23
Write an ST client that creates a symbol table mapping letter grades to
numerical scores, as in the table below,and then reads from standard input a list of
letter grades and computes their average (GPA).
A+
A
A-
B+
B
B-
C+
C
C-
D
F
4.33 4.00 3.67 3.33 3.00 2.67 2.33 2.00 1.67 1.00 0.00

Algorithms and Data Structures
^mav%^^^a^icQes
This list ofexercises is intended to give you experience in working with binary trees
that are notnecessarily BSTs. They all assume a Node class with three instance vari
ables: apositive double value and two Node references. As with linked lists, you will
findit helpful tomake drawings using the visual representation shown in the text.
4.4.24 Implement the following methods that each take as argument a Node that
is the root of a binary tree.
int
size()
int
1eaves()
double
totalO
number ofnodes in thetree
number of nodes whose links areboth null
sumof thekeyvalues in all nodes
Your methods should all run in linear time.
4.4.25 Implement a linear-time method heightO that returns the maximum
number of nodes on any path from the root to a leaf node (the height of the null
tree is 0; the height of a one-node tree is 1).
4.4.26 A binary tree is heap-ordered if the keyat the root is larger than the keys
in all of its descendants. Implement a linear-time method heapOrderedO that re
turns true if the tree is heap-ordered, and fal se otherwise.
4.4.27 Abinary tree is balanced ifboth its subtreesare balancedand the height of
its two subtrees differ by at most 1.Implement a linear-time method bal anced()
that returns true if the tree is balanced, and fal se otherwise.
4.4.28 Two binary trees are isomorphic if only their key values differ (they have
the same shape). Implement a linear-time static method i somorphi c() that takes
two tree references asarguments and returns true if they referto isomorphic trees,
and fal se otherwise. Then, implement a linear-time static method eq () that takes
two tree references as arguments and returns true if they refer to identical trees
(isomorphic with the same keyvalues),and fal se otherwise.
4.4.29 Implement a linear-time method i sBSTO that returns true if the tree is a
BST, and fal se otherwise.

4.4 Symbol Tables
Solution: This task is a bit more difficult than it might seem. Use an overloaded
recursive method isBSTO that takes two additional arguments min and max and
returns true if the tree is a BST and all its values are between mi n and max.
public static boolean isBSTO
{
return isBST(root, 0,
Double.POSITIVE_INFINITY);
private boolean isBST(Node x, int min, int max)
{
if (x == null) return true;
if (x.val <= min || x.val >= max)
return false;
if (!isBST(x.left, min, x.val))
return false;
if (!isBST(x.right, x.val, max))
return false;
}
}
4.4.30 Write a method levelOrderO that prints BST keys in level order: first
print the root, then the nodes one level belowthe root, leftto right, then the nodes
two levels below the root (left to right), and so forth. Hint:Usea Queue<Node>.
4.4.31 Compute the value returned by mysteryO on some sample binary trees
and then formulate a hypothesis about its behavior and prove it.
public int mystery(Node x)
{
if (x == null) return 0;
return mystery(x.left) +
}
Answer: Returns 0 for any binary tree.
mystery(x.right);
641

Algorithms and Data Structures
Treatiy^^mmiiMs
4.4.32 Spell checking. Write a SET client Spell Checker that takes as command-
line argument the name of a file containinga dictionary of words,and then reads
stringsfrom standard input and prints out anystring that is not in the dictionary.
You canfinda dictionaryfile on the booksite. Extra credit: Augment yourprogram
to handle common suffixes such as -ing or -ed.
4.4.33 Spell correction. Write an ST client Spell Corrector that serves as a filter
that replaces commonlymisspelled words on standard input with a suggested re
placement, printingtheresult tostandard output.Take ascommand-line argument
a file that containscommonmisspellings and corrections. You can findan example
on the booksite.
4.4.34 Web filter. Write a SET client WebBlocker that takes as command-line ar
gument the name of a file containing alistof objectionablewebsites,and then reads
stringsfrom standard input and prints out onlythose websites not on the list.
4.4.35 Set operations. Add methods union() and intersection() to SET that
eachtaketwosetsasarguments andreturn the union and intersection, respectively,
of those two sets.
4.4.36 Frequency symbol table. Develop a data type FrequencyTable that sup
ports the following operations: cl i ck() and count(), both of which take Stri ng
arguments. The data-type value is an integer that keeps track of the number of
times the cl i ck() operation has been called with the given Stri ng as argument.
The click() operation incrementsthe count by one, and the count () operation
returns the value,possibly 0. Clientsof this data type might include a web traffic
analyzer, a musicplayer that countsthenumberoftimeseachsonghasbeenplayed,
phone softwarefor counting calls, and so forth.
4.4.37 ID range searching. Develop a data type that supports the following op
erations: insert a date, search for a date, and count the number of dates in the data
structure that liein a particularinterval. Use Java's j ava. uti 1. Date data type.
4.4.38 Non-overlapping interval search. Given a list of non-overlapping inter
valsof integers, write a function that takesan integerargument and determines in
which, if any, interval that valuelies. For example, if the intervals are 1643-2033,

4.4 Symbol Tables
5532-7643, 8999-10332, and 5666653-5669321, then the query point 9122 lies in
the third interval and 8122 lies in no interval.
4.4.39
IP lookup by country. Write a BST client that uses the data file ip-to-
country. csv found on the booksite to determine from which country a given IP
addressiscoming. The data file hasfive fields: beginningof IP addressrange,end
ing of IP address range,two-charactercountry code,three character country code,
and country name. The IP addresses are non-overlapping.Sucha database tool can
be used for credit card fraud detection, spam filtering, auto-selection of language
on a website, and web server log analysis.
4.4.40 Inverted index of web. Given a list of web pages, create a symbol table of
words contained in the web pages. Associate with eachword a list of web pagesin
which that word appears.Write a program that readsin a list of web pages,creates
the symboltable,and support single wordqueries byreturningthe listofwebpages
in which that query word appears.
4.4.41 Inverted index of web. Extend the previous exercise so that it supports
multi-word queries. In this case, output the list of web pagesthat contain at least
one occurrence of each of the query words.
4.4.42 Multiple word search. Writea program that takes k wordsfrom the com
mand line, reads in a sequenceof words from standard input, and identifiesthe
smallest interval of text that contains all of the kwords (not necessarilyin the same
order). Youdo not need to consider partial words.
Hint: For each index i, find the smallest interval [i,j] that contains the k query
words. Keep a count of the number of times each of the k query words appear.
Given [i,j], compute [x+1,j'] bydecrementing the counterforwordi.Then,gradu
allyincrease;until the intervalcontains atleastonecopyofeachofthe kwords(or,
equivalently, word i).
4.4.43 Repetition draw in chess. In the game of chess, if a board position is re
peatedthreetimeswith the samesideto move, thesideto move candeclare a draw.
Describe how you could test this condition using a computer program.
643

Algorithms and Data Structures
4.4.44 Registrar scheduling. TheRegistrar at aprominentnortheasternuniversity
recently scheduled an instructor to teach two different classes at the same exact
time.Helpthe Registrar preventfuture mistakes by describing a method to check
for such conflicts. For simplicity, assumeallclasses run for 50 minutes and start at
9,10,11,1,2, or 3.
4.4.45 Entropy. Wedefinethe relative entropyof a text corpuswith JVwords,kof
which are distinct as
E= 1/ (Nig JV) (p0 lg(*/p0) + Pl]g(k/Pl) +... + pk_x \%{klpk_x))
where p% isthe fraction oftimes that word i appears. Write a programthat reads in
a textcorpus and prints out the relative entropy. Convertalllettersto lowercase and
treat punctuation marks as whitespace.
4.4.46 Order statistics. Add to BST a method select() that takes an integer ar
gument kand returns the kth largest keyin the BST. Maintain subtree sizes in each
node (see Exercise 4.4.18). Therunning timeshould beproportional to the height
of the tree.
4.4.47
Rank query. Add to BST a method rank() that takes a keyasargument
and returnsthe integer i suchthat keyisthe ith largest element in the BST. Main
tain subtree sizes in eachnode (see Exercise 4.4.18). The running time shouldbe
proportional to the height of the tree.
4.4.48
Delete ith element. Implement a class that supports the following API:
public class GeneralizedQueue<Item>
GeneralizedQueue()
boolean
isEmptyO
void
insert(Item item)
Item
delete (int i)
create an empty queue
is thequeueempty?
insert an item
delete andreturn the i thleast recently
inserted item
APIforageneric generalized queue

4.4 Symbol Tables
Use a BST that associatesthe fcth element inserted with the key kand maintains in
each node the total number of nodes in the subtree rooted at that node. To find the
ith leastrecently addeditem,search forthe ith smallest element in the BST.
4.4.49 Sparse vectors. AnN-dimensional vector issparse ifitsnumber ofnonzero
values issmall.Your goal istorepresent avectorwithspace proportional toitsnum
ber ofnonzeros, and to beableto addtwosparse vectors intimeproportional to the
total number of nonzeros.Implement a class that supports the following API:
public class SparseVector
SparseVector ()
create a vector
void
put(int i, double v)
set a; toy
double
get (int i)
return at
double
dot (SparseVector b)
vector dotproduct
SparseVector
pi us (SparseVector b)
vector addition
APIfora sparse vector ofdouble values
4.4.50 Sparse matrices. AnJV-by-JV matrixissparse if its number of nonzeros is
proportional to N (or less). Your goal is to represent a matrixwith space propor
tional to JV, and to be able to add and multiply two sparse matrices in time pro
portional to the total number of nonzeros (perhaps with an extra logN factor).
Implement a class that supports the following API:
public class SparseMatrix
SparseMatri x()
create a matrix
void
put (int i, int j, double v)
set aV) toy
double get(int i, int j)
return a-^
SparseMatrix
pi us (SparseMatrix b)
matrix addition
SparseMatrix
times (SparseMatrix b)
matrix product
API for a sparse matrix ofdouble values
645

646
Algorithms and Data Structures
4.4.51
Queue with no duplicates. Create a data typethat is a queue, except that
an element may only appear on the queue at most once at anygiven time. Ignore
requeststo insert an item if it is alreadyon the queue.
4.4.52 Mutable string. Create a data type that supports the following API on a
string.Usea BST to implementalloperationsin logarithmictime.
public class MutableString
MutableStringO
void
get(int i)
void
insert(int i, char c)
char
delete(int i)
int
lengthQ
create an emptystring
return the i thcharacter in thestring
insert c and make it the i th character
delete and return the i th character
return thelength of thestring
APIfora mutable string
4.4.53 Assignment statements. Write a program to parse and evaluate programs
consisting of assignmentand print statementswith fullyparenthesizedarithmetic
expressions (see Program4.3.5). Forexample, given the input
A
=
5
B = 10
C
=
A
+
B
D =
C
*
C
print(D)
your program should print the value 225.Assume that all variables and values are
of type double. Use a symbol tableto keep track of variable names.
4.4.54 Random element. Addto your SET implementation from Exercise 4.4.15 a
method random() thatreturns arandom key. Therunningtimeshould bepropor
tional to the length of the path from the root to the node returned. Hint Add to
Node an i nt instance variable si ze to contain the size of the subtree rooted at each
node and update the rest of the code to maintain si ze.

4.4 Symbol Tables
4.4.55 Dynamic discrete distribution. Create adata type thatsupports thefollow
ingtwo operations: add() and random(). The add() method should inserta new
item into the data structure if it has not been seen before; otherwise, it should in
crease itsfrequency countbyone.The random() methodshouldreturn an element
at random,where the probabilities areweighted bythe frequency of each element.
Usespaceproportional to the number of items.
4.4.56 Random phone numbers. Write a program that takes a command-line ar
gumentJVand prints JVrandom phonenumbersoftheform (xxx) xxx-xxxx.Use
a SET to avoid choosing thesame numbermorethanonce. Use onlylegal areacodes
(youcan find a file of such codes on the booksite).
4.4.57 Codon usage table. Writea programthat uses a symbol tableto print out
summarystatistics for each codon in a genome taken from standard input (fre
quencyper thousand), likethe following:
UUU
13.2
UCU
19.6
UAU
16.5
UGU
12.4
UUC 23.5
UCC 10.6
UAC 14.7
UGC
8.0
UUA
5.8
UCA 16.1
UM
0.7
UGA
0.3
UUG 17.6
UCC 11.8
UAG
0.2
UGG
9.5
CUU
21.2
ecu 10.4
CAU
13.3
CGU
10.5
CUC 13.5
CCC
4.9
CAC
8.2
CGC
4.2
CUA
6.5
CCA 41.0
CAA 24.9
CGA 10.7
CUC 10.7
CCG 10.1
CAG
11.4
CGG
3.7
AUU
27.1
ACU
25.6
AAU
27.2
AGU 11.9
AUC 23.3
ACC 13.3
AAC 21.0
AGC
6.8
AUA
5.9
ACA 17.1
AAA 32.7
AGA 14.2
AUC 22.3
ACG
9.2
AAG
23.9
AGG
2.8
GUU
25.7
GCU
24.2
GAU 49.4
GGU
11.8
GUC 15.3
GCC 12.6
GAC 22.1
GGC
7.0
GUA
8.7
GCA 16.8
GAA 39.8
GGA 47.2
4.4.58 Unique substrings of length L. Write a program that reads in text from
standardinput and calculates the number of uniquesubstrings of length Lthat it
contains. Forexample, if the input is cgcgggcgcg, then thereare five unique sub
strings of length 3: cgc,egg, gcg, ggc, and ggg. This calculation is useful in data
compression. Hint: Use the string method substri ng(i, i + L) to extract the
647

648
Algorithms and Data Structures
ith substring and insert intoasymbol table. Test your program onalarge genome
from the booksite andon the first 10 million digits of it.
4.4.59 Password checker. Write a program that reads in a string from the com
mandlineandadictionary of words from standard input,andchecks whether it is
a"good" password. Here, assume"good" means thatit (i) isatleast eight characters
long, (ii) isnot aword in thedictionary, (Hi) isnot aword in the dictionary fol
lowed byadigit 0-9 (e.g., hel1o5), (iv) isnottwo words separated byadigit (e.g.,
hello2world), and (v) none of (ii) through (iv) hold for reverses of wordsin the
dictionary.

4.4 Symbol Tables
649

Algorithms and Data Structures
4.5
Case Studjt SmallWorld
The mathematical model that we use for studying the nature of pairwise connec
tions among entities is known as the graph. Graphs are important for studying
the natural world and for helping us to better understand and refine the networks
that we create. From models of the ner
vous system in neurobiology, tothestudy
4.5.1
Graph data type
657
of the spread of infectious diseases in
4.5.2
Using agraph toinvert anindex . .661
medical science, to the development of
4-5*3
Shortest-paths client
665
.he telephone system, graphs have played
J£ ZSEZZfTT*?. \%
a critical role in science and engineering
over the past century, including the de-
Pn*rams'"thissection
velopment of the internet itself.
Some graphs exhibit a specific property known as the small-world phenom
enon. You may be familiar with this property, which is sometimes known as six
degrees ofseparation. It isthe basic ideathat, even though eachof us has relatively
few acquaintances, there is a relatively short chain of acquaintances (the six de
grees of separation) separatingus fromone another.Thishypothesiswasvalidated
experimentally by Stanley Milgram in the 1960s and modelled mathematically by
DuncanWatts and Stephen Strogatz in the 1990s. In recentyears, the principlehas
proven important in a remarkable variety of applications. Scientists are interested
in small-world graphsbecause theymodelnatural phenomena, and engineers are
interested in building networks that take advantage of the natural properties of
small-world graphs.
In this section, we address basic computational questions surrounding the
study of small-worldgraphs.Indeed,the simple question
Doesagiven graph exhibit the small-worldphenomenon?
can present a significant computationalburden. To address this question, we will
consider a graph-processing data type and several usefulgraph-processing clients.
In particular,wewillexaminea clientfor computingshortestpaths^ a computation
whichhas a vastnumber of important applications in its own right.
A persistent theme of this section is that the algorithms and data structures
that wehave beenstudying play a central role in graphprocessing. Indeed, youwill
see that several of the fundamental data types introduced earlier in this chapter
help usto develop elegant andefficient code forstudying the properties of graphs.

4.5 Small World Phenomenon
Graphs
To nip in the bud any terminological confusion, we start right away
with some definitions. A graph is comprised of a set of vertices and a set of edges.
Eachedge represents a connection between twovertices. Two vertices
are neighbors if they are connected by an edge, and the degree of a
vertex is its number of neighbors. Note that there is no relationship
betweena graph and the ideaof afunction graph (aplot of a function
values) or the idea of graphics (drawings). Weoften visualizegraphs
by drawing labelled geometric shapes (vertices) connected by lines
(edges), but it is always important to remember that it isthe connec
tions that are essential,not the waywe depict them.
The following list suggests the diverse range of systems where
graphs are appropriate starting points for understanding structure.
651
neighbors
\
vertex
of degree 2
Graph terminology
Human biology. Arteries and veins connect organs, synapses connect neurons,
and joints connect bones, so an understanding of the human biology depends on
understanding appropriate graph models. Perhaps the largest and most important
such modelling challengein this arena is the human brain. How do local connec
tions among neurons translate to consciousness, memory, and intelligence?
Social networks. Peoplehave relationshipswith other people. From the study of
infectiousdiseases to the study of politicaltrends, graph models of these relation-
vertices
edges
JFK
JFK MCO
MCO
ORD DEN
ATL
ORD HOU
ORD
DFW PHX
HOU
JFK ATL
DFW
ORD DFW
PHX
ORD
PHX
DEN
ATL
HOU
LAX
DEN
PHX
LAS
PHX
LAX
JFK ORD
DEN
LAS
DFW HOU
ORD ATL
LAS
LAX
ATL MCO
HOU MCO
LAS
PHX
Graph modelofa transportation system

652
system
vertex
edge
naturalphenomena
circulatory
organ
blood vessel
skeletal
joint
bone
nervous
neuron
synapse
social
person
relationship
epidemiological
person
infection
chemical
molecule
bond
N-body
particle
force
genetic
gene
mutation
biochemical
protein
interaction
engineered systems
transportation
airport
route
intersection
road
communication
telephone
wire
computer
cable
web page
link
distribution
power station
home
reservoir
power line
home
pipe
warehouse
retail outlet
truck route
mechanical
joint
beam
software
module
call
financial
account
transaction
Typical graph models
Algorithms and Data Structures
ships are critical to our understanding of their
implications. Hoesdoesinformation propagatein
online networks?
Physical systems. Atoms connect to form mol
ecules, molecules connect to form a material or
a crystal, and particles are connected by mutual
forces such as gravityor magnetism.Graph mod
els are appropriate for studying the percolation
problem that we considered in Section 2.4, the
interacting charges that we considered in Section
3.1, and the N-body problem that we considered
in Section 3.4. How do local interactions propa
gatethrough such systems as they evolve?
Transportation systems. Train tracks connect
stations, roads connect intersections, and airline
routes connect airports, so all of these systems
naturally admit a simple graph model. No doubt
you haveused applications that are based on such
models when getting directions from an interac
tive mapping program or a GPS device, or us
ing an online service to make travel reservations.
What isthe best wayto get from here to there?
Communicationssystems. Fromelectriccircuits,
to the telephone system,to the internet, to wireless
services, communications systemsare allbased on
the ideaofconnecting devices. Forat leastthe past
century, graph models have played a critical role
in the development of such systems.What is the
best wayto connect the devices?
Resource
distribution. Power
lines
connect
power stations and home electricalsystems,pipes
connect reservoirsand home plumbing, and truck

4.5 Small World Phenomenon
vertices
edges
aaa edu
aaa.edu
www.com
www
com
www.com
fff.org
mmm
net
www.com
mmm.net
fff org
www.com
ttt.gov
ttt gov
www.com
fff.org
www.com
mmm.net
mmm.net
fff.org
fff.org
aaa.edu
ttt.gov
aaa.edu
ttt.gov
mmm.net
Graph model of the web
routes connect warehouses and retail outlets. The study of effective and reliable
means of distributing resources depends on accurategraph models.Where are the
bottlenecks in a distribution system?
Mechanical systems. Trusses or steel beams connect jointsin a bridgeor a build
ing.Graph models help us to designthesesystems and to understand their proper
ties.What forcesmust a joint or a beam withstand?
Software systems. Methods in one program module invoke methods in other
modules. As we have seen throughout this book, understanding relationships of
this sort is a keyto success in software design. Whichmoduleswillbe affected by a
change in an API?
Financialsystems. Transactionsconnectaccounts, and accountsconnect custom
ers to financial institutions. These are but a few of the graph models that people
useto studycomplexfinancial transactions, and to profitfrom better understand
ing them. Which transactions are routine and whichare indicative of a significant
event that might translate to profits?
653

654
Algorithms and Data Structures
Some of these aremodels of natural phenomena,whereour goal isto gainabetter
understanding of the natural world by developing simple modelsand then using
them to formulate hypothesesthatwecantest.Other graphmodels are ofnetworks
that we engineer, where our goal isto build abetter network or to better maintain
anetwork by understanding its basiccharacteristics.
Graphs are useful modelswhetherthey are smallor massive. A graph hav
ing just dozensofvertices and edges (for example, one modelingachemical com
pound,where vertices are molecules andedges are bonds)isalready acomplicated
combinatorial objectbecause thereare a huge number of possible graphs, so un
derstanding the structures of the particular ones at hand is important. A graph
having billions or trillions of vertices andedges (for example, a governmentdata
base containing all phone calls or a graph model ofthe human nervoussystem)is
vastly morecomplex, andpresents significant computational challenges.
Processing graphs typically involves building
a graph from information in a database and then
answering questions about the graph. Beyond the
application-specific questions in the examples just
cited, we often need to ask basic questions about
graphs. Howmanyvertices andedges doesthe graph
have? What are the neighbors of a given vertex?
Some questionsdepend on an understanding ofthe
structure of a graph. For example,apaf/zin a graph
isasequence ofvertices connectedby edges. Isthere
a path connecting two given vertices? What is the
shortest such path? What isthe maximum length of
a shortestpath in the graph (the graph's diameter)7.
We have already seen in this book several examples of questions from scientific
applications that are much morecomplicated than these. What is the probability
thatarandom surfer willland on each vertex?What isthe probabilitythatasystem
representedby a certain graph percolates?
As you encounter complex systems in later courses, you are certain to en
countergraphs in many different contexts. You may also study their properties in
detail in later courses in mathematics, operations research, or computer science.
Some graph-processing problems present insurmountable computational chal
lenges; otherscanbe solved with relative ease with data-type implementationsof
the sort we havebeen considering.
a pathfrom
LAS to JFK
\
a shortestpath
from LAX toMCO
Paths in a graph

4.5 Small World Phenomenon
655
Graph data type
Graph-processingalgorithmsgenerallyfirst build an internal
representation of a graph by adding edges, then process it by iterating through the
verticesand through the edgesthat are adjacentto avertex. The following API sup
ports such processing:
public class Graph
Graph ()
create anempty graph
Graph(In in, String delim)
read graph from input stream
void
addEdge(String v, String w)
addedge v-w
int
V()
number of vertices
int
E()
number ofedges
Iterabl e<St ri ng> verti ces ()
vertices in thegraph
Iterabl e<String>
adjacentTo(String v)
neighbors of"v
int
degree(String V)
number ofneighbors ofv
boo! ean
hasVertex(Stri ng v)
isv a vertex in the graph?
boolean
hasEdge(String v, String w)
isv-wan edge in the graph?
APIfor a graph withStri ng vertices
As usual, this API reflects several design choices, each made from among various
alternatives, some of which we now brieflydiscuss.
Undirected graph. Edges are undirected: an edge that connects v to wis the same
as one that connects wto v. Our interest is in the connection, not the direction. Di
rectededges (forexample, one-waystreets in roadmaps)requireaslightly different
data type (see Exercise4.5.35).
String vertex type. We might use a generic vertex type, to allow clients to build
graphs with objects of any type. Weleave this sort of implementation for an ex
ercise, however, because the resulting code becomes a bit unwieldy (see Exercise
4.5.9).The Stri ngvertextype suffices for the applicationsthat we consider here.
Implicit vertex creation. When a String is used as an argument to addEdgeO,
weassumethat it isavertexname.If no edgeusingthat Stri nghasyetbeen added,
our implementationcreates avertex withthat name.Thealternative designof hav-

656
Algorithms and Data Structures
ing an addVertexO method requiresmore client code (to createthe vertices) and
morecumbersomeimplementationcode(to checkthat edges connectvertices that
havepreviouslybeen created).
Self-loops and parallel edges. Although the API does not explicidy address the
issue, weassume that implementations doallow self-loops (edges connectingaver
texto itself)but donotallow parallel edges (twocopies ofthe sameedge). Checking
forself-loops and parallel edges is easy; our choiceisto omit both checks.
Client query methods. We also include the methods V() and E() in our API to
provide to the clientthe number of vertices andedges in the graph. Suchmethods
should provide the requisite informationin constanttime. Similarly, the methods
degreeO, hasVertexO, and hasEdge() are useful in client code. We leave as ex
ercisesthe implementation ofthese methods, but assume them to be in our Graph
API.
None of these design decisions are sacrosanct; they are simply the choicesthat we
have made for the code in thisbook. Someotherchoices might be appropriate in
varioussituations, and some decisions are stillleft to implementations. It iswiseto
carefully consider the choices thatyoumake for design decisions likethis andtobe
preparedto defend them.
Graph (Program 4.5.1) implements this API. Its
internalrepresentation isasymbol table ofsets: the keys
are vertices and the valuesare the setsof neighbors—
the vertices adjacent to the key. This representation
usesthe two datatypes STand SET that we introduced
in Section 4.4.It hasthree important properties:
• Clientscanefficientlyiterate through the graph
vertices.
• Clientscanefficientlyiterate through avertex's
neighbors.
• Space usage is proportional to the number of
edges.
These properties follow immediatelyfrombasic prop
ertiesof ST and SET. As you will see, the two iterators
areat the heart of graphprocessing.
c
set of
neighbors
C
G
A
(To)
A
C
A
symbol
yS table
value
Symbol-table-of-sets
graph representation

4.5 Small World Phenomenon
657
mi
Program4,5.1
Graph data type
public class Graph
{
private ST<String,
SET<String» st;
st
public Graph()
"^WH
{
st = new ST<String, SET<String»();
}
symboltableof
vertexneighbor sets
}
public void addEdge(String v, String w)
{
// Put v in w's SET and w in v's SET.
if (1st.contains(v)) st.put(v,
new SET<String>0);
if (1st.contains(w)) st.put(w,
new SET<String>());
st.get(v).add(w);
st.get(w).add(v);
}
public Iterable<String> adjacentTo(String v)
{
return st.get(v);
}
public Iterable<String> verticesO
{
return st;
}
mm
// See exercise 4.5.1-4 for V(),
E(), degreeO,
// hasVertexQ,
and hasEdge().
public static void main(String[]
args)
{
// Read edges,
print Graph (sets of neighbors).
Graph G = new Graph();
while (!Stdln.isEmptyO)
G.addEdge(StdIn.readString(), Stdln.readString());
StdOut.print(G);
}
adjacentToO
verticesQ
neighbor iterator
vertex iterator
& Js^-^se^r™*^?
is?P$l3?Hy»5
This implementation uses ST and SET (see Section 4.4) to implement the graph data type.
Clients build graphs by adding edges and process them by iterating the vertex setandthe setof
vertices adjacent toagiven vertex. See the textfortoSt ri ng() anda matching constructor that
reads a graph from an inputstream.
% Java Graph < tiny.txt
A
B
C
G
H
B
A
CAG
GAC
H A
I

658
Algorithms and Data Structures
Asa simple exampleof clientcode,consider the problem of printing a Graph.
A natural way to proceed is to print a list of the vertices, along with a list of im
mediate neighbors of eachvertex.Weuse this approach to implement toStri ng()
in Graph, as follows:
public String toStringO
{
String s = "";
for (String v
: vertices())
{
s += v + " ";
for (String w : adjacentTo(v))
s
+=
w
-
s += "\n";
}
}
return s;
Thiscodeprints tworepresentations of eachedge, oncewhen discovering that wis
a neighborof v and oncewhendiscovering that v is a neighbor of w. Manygraph
algorithms are basedon this basicparadigmof processing each edgein the graph
in this way, and it is important to rememberthat they processeach edgetwice. As
usual, thisimplementationisintendedforuseonlyforsmallgraphs,asthe running
time is quadratic in the string length becausestring concatenation is linear-time.
The output format just considered definesa reasonable fileformat: each line
is a vertex name followed by the names of neighbors of that vertex. Accordingly,
our basic graph API includes a constructor for building a graph from an input
stream in this format (list of vertices with neighbors). For flexibility, we allowfor
the use of other delimiters besides spaces for vertex names (so that, for example,
vertex names may contain spaces),as in the following implementation:
public Graph(In in, String delimiter)
{
st = new ST<String, SET<String»();
while (Hn.isEmptyO)
{
String line = in.readLineO;
String[]
names = line.split(delimiter);
for (int i = 1;
i
< names.length; i++)
addEdge(names[0], names[i]);
}
}

4.5 Small World Phenomenon
659
Adding this constructor and toStri ng() to Graph provides a complete data type
suitable for a broad variety of applications, aswewill now see.Note that this same
constructor (with a spacedelimiter) worksproperly when the input is a list of edg
es, one per line, as in the test client for Program 4.5.1.
Graph diciat example
As a first graph-processing client, we consider an ex
ample of social relationships, one that is certainly familiar to you and for which
extensive data is readily available.
On the booksite you can find the file movies.txt (and many similar files),
which contains a list of movies and the performers who appeared in them. Each
line gives the name of a moviefollowed bythe cast (a list of the names of the per
formers who appeared in that movie). Since names have spaces and commas in
them, the / character is used as a delimiter. (Now you can see why our file input
Graph constructor takes the delimiter as an argument.)
If you study movies.txt, you will notice a number of characteristics that,
though minor, need attention when workingwith the database:
• Movies always havethe year in parenthesesafter the title.
• Special characters are present.
• Multiple performers with the same name are differentiatedby Roman
numerals within parentheses.
• Cast lists are not in alphabetical order.
Depending on your terminal and operating systemsettings,specialcharacters may
be replacedby blanks or question marks.Thesetypesof anomaliesare common in
working with large amounts of real-worlddata. Wecan either choose to livewith
them or write filters to minimize any annoyances.
% more movies.txt
Tin Men (1987)/DeBoy, David/Blumenfeld, Alan/... /Geppi, Cindy/Hershey,
Barbara
Tirez sur le pianiste (1960)/Heymann, Claude/.../Berger, Nicole (I)
Titanic (1997)/Mazin, Stan/...DiCaprio, Leonardo/.../Winslet, Kate/...
Titus (1999)/Weisskopf,
Hermann/Rhys, Matthew/.../McEwan, Geraldine
To
Be or Not to Be (1942)/Verebes,
Erno (I)/.../Lombard, Carole (I)
To
Be or Not to Be (1983)/.../Brooks,
Mel (I)/.../Bancroft, Anne/...
To Catch a Thief (1955)/Paris, Manuel/.../Grant, Cary/.../Kelly, Grace/...
To Die For (1995)/Smith,
Kurtwood/.../Kidman, Nicole/.../ Tucci,
Maria
Movie database example

660
Algorithms and Data Structures
_L
_
Caligola
_Y Patrick A
I nial M I
f
Grace \
-\ Allen
)
for Murder
V
Ke11V J
—•
Enigma
Eternal
Sunshine
of the Spotless —
Mind
i—r
( Serretta A__
^
Wilson J
Titanic P -f AYves \
\ I *^T~X
>
r"\
A tinyportion of the movie-performer relationship graph
UsingGraph, we can write a simpleand convenientclient for extracting in
formation from movi es. txt. We beginbybuilding a Graph to better structure the
information. What should the vertices and edges model? Should the vertices be
movies with edges connecting two movies if a performer has appeared in both?
Should the vertices be performers with edges connectingtwo performers if both
have appeared in the same movie? These choices are both plausible, but which
should weuse? Thisdecisionaffects both clientand implementation code.Another
wayto proceed (whichwechoosebecauseit leadsto simple implementation code)
isto have vertices for both themovies andtheperformers, withan edge connecting
each movie to each performer inthatmovie. As youwill see, programs that process
this graph can answera greatvarietyof interestingquestions.The Graph clientIn-
dexGraph (Program4.5.2) isa firstexample that takesa query,such asthe name of
a movie,and prints the list of performers that appear in that movie.

4.5 Small World Phenomenon
661
w^^^^^^^^^i^^^^m^^^mmmm^mmmms
Program 4.5.2
Usinga graph to invert an index
public class IndexGraph
{
public static void main(String[] args)
{
// Build a graph and process queries.
In in = new In(args[0]);
String delimiter = args[l];
Graph G = new Graph(in, delimiter);
while (!Stdln.isEmptyO)
{
// Read a vertex and print its neighbors.
String v = Stdln.readLine();
for (String w : G.adjacentTo(v))
StdOut.println("
" + w);
}
}
}
in
delimiter
G
v
w
input stream
inputdelimiter
graph
query
neighbor of v
This Graphclient builds agraph, then accepts vertex namesfrom standard inputandprints its
neighbors. When thefileisan index, itcreates a bipartitegraph andamounts toan interactive
inverted index.
'tP'-'fii'M-JA
W$M4 -iWW.M.Ifwm.rfu
,--T-
iM
-
u*
V„..,r.
% Java IndexGraph tiny.txt " "
c
A
A
G
B
C
G
H
mm:
% Java IndexGraph movies.txt "/"
Da Vinci Code, The
(2006)
Aubert, Yves
Herbert, Paul
Wilson, Serretta
Zaza, Shane
Bacon, Kevin
Animal House (1978)
Apollo 13 (1995)
Wild Things (1998)
River Wild, The (1994)
Woodsman,
The
(2004)
''IQffinfflPMSIVPMPi

662
Algorithms and Data Structures
Typinga movie name and gettingits castis not much more than regurgitating the
corresponding line in movies.txt (though the IndexGraph test client does print
the cast list sorted by last name, as that is the default iteration order provided by
SET). A more interesting feature of IndexGraph is that you can type the name of a
performer and get the list of movies in which that performer has appeared. Why
does this work? Even though the databaseseemsto connect movies to performers
and not the other wayaround, the edgesin the graph are connections that also con
nect performers to movies.
A graph in which connectionsallconnect one kind of vertexto another kind
of vertex is known as a bipartite graph.Asthis example illustrates,bipartite graphs
havemany natural properties that wecan often exploit in interesting ways.
As we saw at the beginning of Section 4.4, the
indexing paradigm is general and very familiar. It is
worth reflecting on the fact that building a bipartite
graph provides a simple wayto automatically invert
any index! The movi es. txt database is indexed by
movie, but we can query it by performer. Youcould
use IndexGraph in precisely the same way to print
the index words appearing on a given page or the
codons corresponding to a given amino acid, or to
invert any of the other indices discussed at the be
ginning of Section 4.2. Since IndexGraph takes the
delimiter as a command-line argument, you can use
it to create an interactive inverted index for a . csv
fileor a test filewith space delimiters.
This inverted-index functionality is a direct
benefit of the graph datastructure. Next,we examine
some of the added benefits to be derived from algo
rithms that process the data structure.
%
more ami no.csv
TTT,Phe,F,Phenylalani ne
TTC,Phe,F,Phenylalani ne
TTA,Leu,L,Leucine
TTG,Leu,L,Leucine
TCT,Ser,S,Serine
TCC,Ser,S,Serine
TCA,Ser,S,Serine
TCG,Ser,S,Serine
TAT,Tyr,Y,Tyrosine
GGA,Gly,G,Glycine
GGG,Gly,G,Glycine
% java IndexGraph amino.csv ", *
TTA
Lue
L
Leucine
Serine
TCT
TCC
TCA
TCG
Inverting an index

4.5 Small WorldPhenomenon
663
Shortest paths in graphs
Given twovertices in a graph,apath is a sequence
of edgesconnecting them. A shortestpathis one with minimal length over all such
paths (there typicallyare multiple shortest paths). Findinga shortest path connect
ing two vertices in a graph is a fundamental problem in computer science.Shortest
paths have been famously and successfully applied to solve large-scale problems
in a broad variety of applications, from routing the internet to financial arbitrage
transactions to studying the dynamics of neurons in the brain.
As an example, imagine that you are a customer of an imaginary no-frills
airline that serves a limited number of cities with a limited number of routes. As
sume that best wayto getfrom one placeto another isto minimizeyour number of
flightsegments,becausedelays in transferringfrom one flightto another are likely
to belengthy(or perhaps the bestthing to do isto considerpayingmore for a direct
flight on another airline!). Ashortest-pathalgorithmisjustwhatyou need to plan
a trip. Suchan application appealsto intuition in understanding the basicproblem
and our approach to solving it. After covering these topics in the context of this
example,wewill consider an applicationwherethe graph model is more abstract.
Depending upon the application, clients have various needs with regard to
shortest paths. Do we want the shortest path connecting two given vertices? Just
the length of such a path?Willwehavea largenumber of such queries? Is one par
ticular vertex of interest?In huge graphs or for huge numbers of queries, we have
to pay particular attention to such questionsbecause the cost of computing paths
might proveto be prohibitive.Westart with the following API:
public class PathFinder
PathFinder(Graph G, String s)
constructor
int distanceToCString v)
length ofshortestpath
3
fromstov inC
Iterabl e<String> pathTo(String v)
shortestpath
*
K
*
from stov inG
APIfor single-source shortestpaths ina Graph
Clients can construct a PathFi nder for a givengraph and a givenvertex, and then
usethe PathFinder either to findthe lengthofthe shortest path or to iterate through
the vertices on the shortest path to any other vertex in the graph. An implementa
tion of these methods is known as a single-source shortest-path algorithm. A classic
algorithm known as breadth-first search provides a direct and elegant solution.

664
Algorithms and Data Structures
Single-source client. Suppose that youhave available to you the graph of vertices
and connections for your no-frillsairline'sroute map. Then, using your home city
asa source,you can write a client that prints your route any time you want to go on
a trip. Program 4.5.3is a client for PathFi nder that provides this functionality for
any graph. This sort of client is particularly useful in applications where we antici
pate numerous queries from the same source.In this situation, the cost of building
a PathFi nder is amortized over the cost of all the queries. Youare encouraged to
explore the properties of shortest paths by running PathFinder on our sample
input routes. txt or any input model that you choose. The exercisesat the end of
this section describe several mod
els that you might consider.
Degrees of separation. One of
the classicapplications of shortest-
paths algorithms is to find the de
grees of separation of individuals
in social networks. To fix ideas, we
discuss this application in terms
of a recently popularized pastime
known as the Kevin Bacon game,
which uses the movie-performer
graph that we just considered.
Kevin Bacon is a prolific actor who
has appeared in many movies. We
assign every performer who has
appeared in a movie a Kevin Bacon
number: Bacon himself is 0, any
performer who has been in the same cast as Bacon has a Kevin Bacon number of 1,
any other performer (except Bacon) who has been in the same cast as a performer
whose number is 1 has a Kevin Bacon number of 2, and so forth. For example,
Meryl Streep has a Kevin Bacon number of 1 because she appeared in TheRiver
Wild with KevinBacon.Nicole Kidman's number is 2: although she did not appear
in any movie with KevinBacon,she was in ColdMountainwith Donald Sutherland,
and Sutherland appeared in AnimalHouse with Kevin Bacon. Given the name of
a performer, the simplest version of the game is to find some alternating sequence
of movies and performers that lead back to Kevin Bacon. For example, a movie
source destination distance
shortestpaths
DFK
LAX
3
LAS
MCO
4
HOU
DFK
2
JFK-0RD-PHX-LAX
LAS-PHX-DFW-H0U-MC0 andfourothers
HOU-ATL-DFK and two others
Examples ofshortestpathsin agraph

4.5 Small World Phenomenon
665
i
Program 4.5.3
Shortest-paths client
public class PathFinder
{
// See Program 4.5.5 for implementation.
}
public static void main(String[] args)
{
// Read a graph and process queries
// for shortest paths from s.
In in = new In(args[0]);
String delimiter = args[l];
Graph G = new Graph(in, delimiter);
String s = args[2];
PathFinder pf = new PathFinder(G, s);
while (!Stdln.isEmptyO)
{
// Print distance and shortest path from s to input t
String t
= Stdln.readLine();
int d = pf.distanceTo(t);
for (String v : pf.pathTo(t))
StdOut.println(M
" + v);
StdOut.println("distance " + d);
}
y
in
delimiter
G
s
pf
t
V
input stream
inputdelimiter
graph
source
PathFi nder from s
destination query
vertex onpath
This PathFi nder test client takes afilename, a delimiter, anda source vertex ascommand-line
arguments. It builds a graph from thefile, assuming thateach lineof thefile specifies a vertex
anda listofvertices connected tothatvertex, separated bythe delimiter. When you type a des
tination onstandard input, youget the shortest path from the source to thatdestination.
'^"""""
""ferial
'"'"' ;":'^;^^-^^j^-'i:^^^j!-''i:--' ^"ife
% more
routes.txt
jfk mco
ORD DEN
ORD HOU
DFW PHX
JFK ATL
ORD DFW
ORD
PHX
ATL
HOU
DEN
PHX
PHX
LAX
JFK ORD
DEN
LAS
DFW HOU
ORD ATL
LAS
LAX
ATL MCO
HOU
MCO
LAS
PHX
% Java PathFinder routes.txt " " JFK
LAX
JFK
ORD
PHX
LAX
distance
3
MCO
JFK
MCO
distance
1
DFW
JFK
ORD
DFW
distance
2

666
Algorithms and Data Structures
buff mightknowthat TomHankswas inJoe Versus the Volcano with Lloyd Bridges,
who wasin High Noon with Grace Kelly, who was in DialMfor Murder with Pat
rick Allen, who was in The Eagle Has Landed with Donald Sutherland, who we
know was in Animal House with Kevin Bacon.But this knowledge does not suffice
to establish Tom Hanks's Bacon number (it is actually 1 because he was in Apollo
13 with Kevin Bacon). You can see
%java PathFinder movies.txt "/" "Bacon, Kevin"
that the Kevin Bacon number has to
Kidman, Nicole
be defined by counting the movies in
Bacon, Kevin
theshortestsuch sequence, soitishard
Animal
House (1978)
^
.
Sutherland, Donald (I)
to be sure whether someone wins the
Cold Mountain (2003)
game without using a computer. Re-
distlnce^ NlC°1e
markably, the PathFinder test client
Hanks, Tom
in Program 4.5.3 is just the program
Bacon, Kevin
vou nee(j to f^ a shortest path that
Apollo 13 (1995)
ii. i
,
„
•
™
i_
Hanks
Tom
establishes the Kevin Bacon number
distance 2
of anyperformer in movi es. txt—the
number is precisely half the distance.
Degrees ofseparation from Kevin Bacon
„
. ,.
,i .
6
J r
J
You might enjoy using this program,
or extending it to answer some enter
taining questions about the moviebusiness or in one of many other domains. For
example, mathematicians play this same game with the graph defined by paper
co-authorship and their connection to Paul Erdos, a prolific 20th-century math
ematician. Similarly, everyone in New Jersey seems to have a Bruce Springsteen
number of 2,becauseeveryone in the state seemsto know someone who claimsto
know Bruce.
Otherclients. PathFi nder is a versatile data type that can be put to many practi
cal uses. For example,it is easyto develop a client that handles pairwise source-
destination requests on standard input, by building a PathFi nder for each vertex
(seeExercise 4.5.17).Travel services use preciselythis approach to handle requests
at a very high service rate. Since this client builds a PathFinder for each vertex
(each of which might consume space proportional to the number of vertices),
spaceusagemight be alimitingfactorin usingit for huge graphs.Foran evenmore
performance-criticalapplicationthat isconceptuallythe same,consideran internet
router that has a graph of connections among machines available and must decide
the best next stop for packetsheading to a givendestination. Todo so, it can build

4.5 Small World Phenomenon
a PathFi nder with itself as the source, then send a packet heading to destination
wto pf. pathTo(w) .next(), the next stop on the shortest path to w. Or a central
authority might build a PathFi nder for eachof several dependent routers and use
them to issuerouting instructions.Theabilityto handlesuchrequestsat ahigh ser
vicerate is one of the prime responsibilities of internet routers, and shortest-paths
algorithms are a critical part of the process.
Shortest-path distances. We define the distance between two vertices to be the
lengthof the shortestpath between them.Thefirst stepin understandingbreadth-
first search is to consider the problem of computing distances between the source
and each vertex (the implementation of distanceToQ in PathFinder). Our ap-
initializefor distance 0
distance 1
(LAS)
(LAX)
(PHX h-i DFWj^
distance 2
checkfor distance4
queue contents
distancesfrom JFK
JFK
ATL DEN DFW HOU
JFK
LAS
LAX MCO ORD
0
JFK
JFK ATL
1
JFK
AIL MCO
1
JFK
ATI. MCO ORD
1
ATL MCO ORD
ATL MCO ORD HOU
.1
MCO ORD HOU
1
ORD HOU
ORD HOU DEN
ORD HOU DEN DFW
1
ORD HOU DEN DFW PHX
1
HOU DEN DFW PHX
1
DEN DFW
PHX
1
DEN DFW PHX
LAS
1
DFW PHX
LAS
1
PHX
LAS
1
PHX
LAS
LAX
1
LAS
LAX
1
LAX
1
2
2
2
2
2
2
0
0
0
3
0
3
0
3
0
3
1
1
1
1
1
1
1
1
1
1
1
1
0
3
3
11
0
3
3
I
1
Using breadth-first search to compute shortestpath distances in a graph
667

668
Algorithms and Data Structures
proach is to compute and save awayall the distances in the constructor, and then
just return the requested value when a client invokes distanceTo(). To associate
an integer distance with eachvertexname, we use a symbol table:
ST<String, Integer> dist = new ST<String, Integer>();
The purpose of this symbol table is to associate with each vertex an integer: the
length of the shortest path (the distance)from that vertexto s. Webegin by giving
s the distance 0 with dist. put(s, 0), and we assign to s's neighbors the distance
1 with the following code:
for (String v
: G.adjacentTo(s))
dist.put(v, 1)
But then what do we do? If weblindly set the distances to all the neighbors of each
of those neighbors to 2, then not only would we face the prospect of unnecessar
ilysetting many valuestwice (neighbors may have many common neighbors), but
also wewould set s's distance to 2 (it is a neighbor ofeach ofits neighbors), and we
clearlydo not want that outcome. The solution to these difficultiesis simple:
• Consider the vertices in order of their distance from s.
• Ignore vertices whose distance to s is already known.
To organize the computation, we use a FIFO queue. Starting with s on the queue,
we perform the following operations until the queue is empty:
• Dequeue a vertex v.
• Assignall of v's unknown neighbors a distance 1 greater than v's distance.
• Enqueue all of the unknown neighbors.
This method dequeues the vertices in nondecreasing order of their distance from
the source s. Following a trace of this method on a sample graph will help to per
suade you that it is correct. Showing that this method labels each vertex v with its
distance to s is an exercise in mathematical induction (see Exercise 4.5.12).
Shortestpaths tree. We need notonly distances from thesource, but also paths. To
implement pathToO, we use a subgraph known as the shortest-paths tree, defined
as follows:
• Put the source at the root of the tree.
• Put vertex v's neighbors in the tree if they are added to the queue, with an
edge connecting each to v.

4.5 Small World Phenomenon
669
graph
shortest-paths tree
Since we enqueue each vertex only once, this structure is
a proper tree: it consists of a root (the source) connected
to one subtree for each neighbor of the source. Studying
such a tree, you can see immediately that the distance
from each vertex to the root in the tree is the same as the
shortest path distance to the source in the graph. More
importantly, each path in the tree is a shortest path in the
graph. This observation is important because it gives us
an easy way to provide clients with the shortest paths
themselves (implement pathToO in PathFinder). First,
we maintain a symbol table associating each vertex with
the vertex one step nearer to the source on the shortest
path:
ST<String, String> prev;
prev = new ST<String, String>();
parent-link representation
ATL DEN
DFW HOU JFK
LAS
LAX MCO ORD
PH
JFK ORF
ORD ATL
DEN
PHX
JFK
JFK OR
To each vertex w, we want to associatethe previous stop
Shortest-paths tree
on the shortest path from the source to w. Augmenting the
shortest-distances method to also compute this informa
tion is easy: when we enqueue wbecausewe first discover it as a neighbor of v, we
do so preciselybecauset v is the previous stop on the shortest path from the source
to w, so we can call prev.put(w,
v). The prev data structure is nothing more
than a representation of the shortest path tree: it provides a link from each node
to its parent in the tree. Then,
shortest-paths tree
(parent-link representation)
ATL
DEN DFW HOU
JFK
LAS
LAX MCO ORD
PHX
JFK ORF ORD ATL
DEN
PHX
JFK
JFK ORD
ATL
DEN DFW HOU
JFK
LAS
LAX MCO ORD PHX
JFK
ORF ORD
ATI.
DEN
PHX
JFK
JFK ORD
ATL
DEN DFW HOU
JFK
LAS
LAX MCO ORD PHX
JFK ORF ORD ATL
DEN
PHX
JFK
JFK ORD
ATL
DEN DFW HOU
JFK. LAS
LAX MCO ORD
PHX
JFK ORF
ORD
ATL
DEN
PHX
JFK
JFK
ORD
stack contents
LAX -*— destination
PHX
LAX
ORD
PHX
LAX
.path
JFK
ORD
PHX
LAX
Recovering a pathfrom thetree witha stack
to respond to a client request
for the path from the source
to w (a call to pathTo(w) in
PathFinder), we follow these
links upthe tree from w, which
traverses the path in reverse
order, so we push each vertex
encountered onto a stack and
then return that stack (an It
erabl e) to the client. At the
top of the stack is s; at the bot
tom of the stack is v; and the

670
Algorithms and Data Structures
Program 4.5.4
Shortest-paths implementation
1
£?4
IS
'••?s#
»l
*$
i&
public class PathFinder
{
private ST<String, String>
prev;
private ST<String,
Integer> dist;
public PathFinder(Graph G, String s)
prev
dist
previous vertex on
shortestpathfrom s
distance to s
{
// Use BFS to compute distances and p
// on shortest path from s to each ve
prev = new ST<String,
String>();
dist = new ST<String, Integer>();
Queue<String> q = new Queue<String>()
q.enqueue(s);
dist.put(s,
0);
while (!q.isEmptyO)
{
// Process next vertex on queue.
String v = q.dequeue();
for (String w : G.adjacentTo(v))
{
// Check whether distance is al
if (!dist.contains(w))
{
// Add to queue and save sho
q.enqueue(w);
dist.put(w,
1 + dist.get(v))
prev.put(w,
v);
revious
node
rtex.
mmm
G
s
q
V
w
graph
source
queueof vertices
current vertex
I
neighbors ofv
I
••<mmmm
ready known,
rtest-path information.
}
}
}
PathFi nder()
distanceToO
pathToQ
constructorfor s in G
distancefrom sfov
pathfrom s tov
j
^^^^^^^^^i^^w^^^^^^^^^'
public int distanceTo(String v)
{
return dist.get(v);
}
public Iterable<String> pathTo(String v)
{
// Return iterable object having shortest path from s to v.
Stack<String> path = new Stack<String>();
while (dist.contains(v))
{
// Push current vertex;
move to previous vertex on path,
path.push(v);
v = prev.get(v);
}
return path;
}
This class allows clients tofind (shortest) pathsconnecting a specified vertex toother vertices in
a graph. SeeProgram 4.5.3 and Exercise 4.5.17for sampleclients.
wm®

4.5 Small World Phenomenon
671
vertices on the path from s to v arein between, sothe clientgetsthe path from s to
v when using the return valuefrom pathToO in a foreachstatement.
Breadth-first search PathFinder (Program 4.5.4) is an implementation of the
single-source shortestpaths API that isbasedon the ideas just discussed. It main
tains two symbol tables, one for the distance from eachvertex to the source and
the other for the previous stopon the shortestpath fromthe source to eachvertex.
The constructoruses a queueto keep trackofvertices that have beenencountered
(neighbors ofvertices to which theshortest pathhasbeenfoundbut whose neigh
borshave not yetbeenexamined). Theprocess isreferred to asbreadth-first search
(BFS) because it searches broadly in the graph. By contrast, another important
graph-search method knownasdepth-first search isbasedon a recursive method
likethe one weusedfor percolation in Program 2.4.5 and searches deeply into the
graph. Depth-first search tends to findlongpaths; breadth-first search is guaran
teed to find shortest paths.
Performance. Thecostof graph-processing algorithms typically depends on two
graphparameters: the numberofvertices Vand thenumberof edges E. As imple
mented in PathFinder, the time required by breadth-first search is linearithmic in
the size ofthe input, proportional to Elog V. To convince yourselfof this fact, first
observethat the outer (whi 1e) loop iteratesat most Vtimes, once for each vertex,
because we are careful to ensure that each vertex is enqueued at most once. Then
observe that the inner (for) loop iterates a total of at most 2£ times overallitera
tions, because we are careful to ensure that each edge is examined at most twice,
once for each of the two vertices it connects. Each iteration of the loop requires at
least one contai ns() operation and perhaps two put() operations, on symbol
tables of sizeat most V. This linearithmic-time performance depends upon using a
symbol-table implementationlike BST (Program 4.4.3) that hasa linear-timeitera
tor and logarithmic-time search.
Adjacency matrix representation. Without proper data structures, fast perfor
mance for graph-processing algorithms is sometimes not easy to achieve, and so
should not be taken for granted. For example, another graph representation that
is often used,known asthe adjacency matrix representation, uses a symboltable to
mapvertex namesto integers between 0 and V-1, then maintains a V-by-V bool-
ean array with true in the entry in row i and column j (and the entry in row j

672
Algorithms and Data Structures
andcolumni) ifthereisan edge connecting thevertex corresponding to i withthe
vertex corresponding to j, and fal se ifthereisno suchedge. We have already used
similar representations in this book,when studyingthe random surfer model for
rankingweb pages in Section 1.6. The adjacency matrix representation is simple,
but infeasible for usewith hugegraphs—a graphwith a millionvertices wouldre
quirean adjacency matrixwitha trillion entries. Understanding thisdistinction for
graph-processing problems makes the difference between solving a problemthat
arisesin a practical situation and not being able to address it at all.
Breadth-first search isa fundamental algorithm that you could use to find your
way around an airline route map or a big city subway (see Exercise 4.5.34) or in
numerous similar situations. As indicated by our degrees-of-separation example,
it also is usedfor countless other applications, from crawling the web or routing
packets on the internet to studying infectious disease, models of the brain, or re
lationships among genomic sequences. Many of these algorithms involve huge
graphs, soan efficient algorithm isabsolutely necessary.
An important generalization of the shortest-paths model is to associate a
weight (which may represent distance or time) with each edge and seek to find
a path that minimizes the sum of the edge weights. If you take later courses in
algorithms or in operations research, you willlearn a generalization of breadth-
first search knownasDijkstra's algorithm that solves that problemin linearithmic
time.Whenyougetdirections froma GPS device or a map application on the web,
Dikstra's algorithm is the basis for solving the associated shortest-path problems.
These important and omnipresent applications are just the tip of an iceberg, be
causegraph modelsare much more general than maps.
Small-world graphs
Scientists have identified a particularly interesting class
of graphs that arise in numerous applications in the natural and social sciences.
Small-world graphsarecharacterized bythe following threeproperties:
• They are sparse.
• They exhibit local clustering of edgesaround vertices.
• They have a short average distance between vertices.
We refer to graphs having these three properties collectivelyasexhibiting thesmall-
world phenomenon. The term small world refers to the idea that the preponder
ance of vertices have both local clustering and short paths to other vertices. The
modifierphenomenon refers to the somewhat unexpectedfactthat alldistances are

4.5 Small World Phenomenon
short in so manysparsegraphswith local clustering that arisein practice. Beyond
the social-relationships applications just considered, small-world graphs havebeen
usedto studythe marketingor productsor ideas, theformationand spreadof fame
and fads, the analysis of the internet, the construction of secure peer-to-peer net
works, the development of routing algorithms, and wireless networks, the design
ofelectrical powergrids, modeling informationprocessing in the human brain,the
study of phase transitions in oscillators, the spreadof infectious viruses (in both
living organisms and computers), and many other applications too numerous to
list.Startingwith the seminalworkofWatts and Strogatz in the 1990s, an intensive
amount of researchhas gone into quantifyingthe small-world phenomenon.
Akeyquestionin suchresearch isthefollowing: Given agraph, how can we tell
whether it isa small-world graph ornot? To answer this question,we begin by im
posingthe conditionsthat the graph is not small (say, 1,000 vertices or more) and
that it isconnected(thereexists some path connecting eachpair of vertices). Then,
weneed to settleon specific thresholdsfor eachof the small-worldproperties:
• Bysparse, we mean the average vertexdegree isless than 10 lg V.
• Bylocally clustered, wemean that a certainquantity known as the cluster
coefficient should be greater than 10%.
• Byshort average distance, wemeanthe average distance between twoverti
ces is less than 10 lg V.
Average vertexdegree
vertex
degree
A
B
C
G
H
total
4
1
2
2
1
"To-
average degree
= 10/5 = 2
Average path length
Cluster coefficient
vertex
shortest
pair
path
length
1
vertex
edges in neighborhood
degree
possible
actual
A
B
A-B
A
4
10
5
A
C
A-C
1
B
1
1
1
A
G
A-G
1
C
2
3
3
A
H
A-H
1
G
2
3
3
B
C
B-A-C
2
H
1
1
1
B G
B-A-G
2
totals
18
13
B
H
B-A-H
C
G
C-G
C
H
C-A-H
2
1
2
totalpossible = ^
_ ^
total actual
G
H
G-A-H
total
2
15
totallength
M0= 1.5
number ofpairs
Calculating small-world graph characteristics
673

674
Algorithms and Data Structures
The definition of cluster coefficient is a bit more complicated than vertex distance.
Weuse a version of a definition suggested byWattsand Strogatzthat is not difficult
to compute. If avertexhas tneighbors,the total number of possibleedgesthat con
nect those neighbors (including the vertex itself) is
t(t+1)/2.Wedefine the cluster coefficient as the percent-
complete
age of those edges that are in the graph, using the totals
over all the vertices. Thus, if that percentage is greater
than 10%, we say that most edges are locally clustered
around the vertices.
To better familiarize you with these definitions,
we next define some simple graph models, and consider
whether they describe small-world graphs by checking
whether they exhibit the three requisiteproperties.
ring
star
Complete graphs. A complete graph with Vvertices has
V(V—1)/2 edges, one connecting each pair of vertices.
Complete graphs are not small-world graphs. They have
short distances (the distance between all pairs of nodes
is 1) and exhibit local clustering (cluster coefficientis 1),
but they are notsparse (the averagevertex degree is V— 1,
which is much greater than 10 lg V for large V).
Ringgraphs. Suppose that the vertices arethe integers 0
to V— 1. In a ring graph, edges connect vertex i to vertex
i+1 and V— 1 to 0. Ring graphs are also not small-world
graphs. They are sparse (average vertex degree 2) and ex
hibit local clustering (cluster coefficient .33),but they do
not have short distances (the average distance between
nodes is linear—see Exercise 4.5.22).
global
clustering
Star graphs. In a star graph, edges connect one vertex
to each of the others, but there are no other edges. Star
graphs are also not small-world graphs. They are sparse
(average vertex degree2) and haveshort distances (average distance between nodes
is slightlyless than 2), but they do notexhibit local clustering, because the cluster
coefficient is about 4/N (see Exercise 4.5.22).
Three graph models

4.5 Small World Phenomenon
675
Theseexamples illustratethat developing a graph modelthat satisfies allthree con
straints simultaneously is a puzzling challenge. Take a moment to try to design a
graphmodel that youthink mightdo so. After youhave thoughtaboutthisprob
lem,youwill realize that youarelikely to needa program to helpwithcalculations.
Also, youmayagree that it isquitesurprising that theyarefoundso oftenin prac
tice. Indeed,you might be wonderingif any graph isa small-world graph!
Choosing 10% for the local clustering threshold instead of someother fixed
percentage is somewhat arbitrary, as isthe choice of 10 lg V for the sparsity and
short path length thresholds, but we often do not come close to these borderline
values. Forexample, consider the graphdefined bypages on the web connected by
links. Analysts have estimated that the average distance between two pages on the
webisless than lg V. If there arebillions of pages, this estimate says that the num
ber of clicks to get from one documentto another is about 30 (and eachtime the
web grows by a factor of 1,000, onlyabout 10 moreclicks will be needed). These
real-world path lengths are very short, much lower
than our 10 lg Vestimate, which would be over 300
model
sparse? £m? ^i
for billions of vertices (but still much, much less than
—
—
—
.
complete
O
•
•
Having settledon thedefinitions, testing wheth-
ring
er a graph is a small-world graph can still be a sig-
star
•
•
°
nificant computational burden.As youprobably have
Small-worldproperties ofgraph models
suspected, the graph-processing data types that we
have been considering provide precisely the tools that we need. The Graph and
PathFinder client SmallWorld (Program 4.5.5) implements these tests. Without
the efficient data structuresand algorithms that wehave beenconsidering, the cost
of this computation wouldbe prohibitive. Even so, for huge graphs, we need to
resort to sampling to get estimatesof some of the quantities.
A classic small-world graph. Our movie-performer graph is not a small-world
graph, because it isbipartite and therefore hasa very low cluster coefficient. How
ever, the simplerperformer relationship graph defined byconnecting twoperform
ersby an edge if theyappeared in the same movie is a classic example of a small-
world graph. Since a performer relationship graphhasmanymore edges than the
corresponding movie-performer graph, we will work for the moment with the
smaller graph represented by the file moviesG.txt (G-rated movies). Performer
graphs are easy to constructfromfiles in the formatrepresented by movi es*. txt.

676
Algorithms and Data Structures
Eachline representsa movieand gives a setof actorswho are connectedbecauseof
that movie (eachslash-delimited string afterthe firstis an actor's name); webuild
a complete subgraph connecting allpairs of actors in that movie byaddinga graph
edge connecting each pair. Doing so for
each movie in the database gives a graph
movie-performer relationship graph
that connects the performers, as desired.
Note that the movie names are not
relevant in the performer relationship
graph—only in the performer relation
ships implied by the movie.One alterna
tive might be to use a Graph implemen
tation that assigns names to edges, not
just vertices, but our movie-performer
graph is a much better solution if the
edge names are also of interest.
Now, for movi esG. txt, our Smal1-
World client tells us that the resulting
graph has 20,734 vertices and 1,784,567
edges (so the average vertex degree is
139.0, just less than 10 lg V = 143.4),
whichmeans it issparse;its average path
length is 7.3 (much less than 143.4), so
it has short paths; and its cluster coeffi
cient is .92,so it has local clustering.We
have found a small-world graph! These
calculations validate the hypothesis that
social relationship graphs of this sort ex
hibit the small-world phenomenon. You
are encouraged to find other real-world
graphs and to test them with Small-
World.Youwill find many suggestions in
the exercises at the end of this section.
One approach to understanding
somethinglikethe small-world phenomenon is to develop a mathematical model
that wecanuseto testhypotheses andto makepredictions. We conclude byreturn
ing to the problem of developing a graph model that can help us to better under-
performer
vertices
performer in
two movies
performer relationship graph
performer in
two movies
connections
to other movies
connections
toother performer
incomplete graph.
for othermovies
/
complete graphs
connecting allperformers
in the same movie
Two waysto represent the moviedatabase

4.5 Small World Phenomenon
^M^KiSi
Program 4.5,5
Small-worldtest
public class SmallWorld
{
public static double avgDegree(Graph G)
{
return 2*G.E() / G.V();
}
public static double avgDistance(Graph G)
{
// Compute average vertex distance,
int total
= 0;
for (String v
: G.verticesO)
{
// Add to total distances from v.
PathFinder pf = new PathFinder(G, v);
for (String w : G.verticesO)
total += pf.distanceTo(w);
G
total
v
w
677
• .
•• -.- ..•-v.s-aMSfli-'«::->-
graph
cumulative sum of
distances between vertices
vertex iterator variable
neighbors o/v
sEswffiwf
I
return (double) total /
(G.V() * (G.V()
- 1));
}
public static double clusterCoeff(Graph G)
{
// Compute cluster coefficient,
int possible = 0;
int edges = 2*G.E();
for (String v
: G.verticesO)
{
// Cumulate local edge totals,
for (String u : G.adjacentTo(v))
for (String w : G.adjacentTo(v))
if (G.hasEdge(u, w)) edges++;
int t
= G.degree(v);
possible += (t + l)*t;
}
return (double) edges /
possible;
}
public static void main(String[] args)
{
/* See Exercise 4.5.19. */
}
possible
edges
v
u,
w
graph
cumulative sum of
possible local edges
cumulative sumof
actual localedges
vertex iterator variable
neighbors ofv
mBmmmmmmkmmm
This client reads agraphfrom standard input and computes the values ofvarious graph param
eters to test whether the graph exhibits the small-world phenomenon.
% Java MoviesToPerformers "/" < moviesG.txt | Java SmallWorld
20734 vertices
average degree 139.0
average distance 7.3
cluster coefficient
.92
^^^^^S^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^S^S^s?^^^^^
wmmmmw

678
Algorithms and Data Structures
public class MoviesToPerformers
{
public static void main(String[] args)
{
String delimiter = args[0];
while (!Stdln.isEmptyO)
{
String line = Stdln. readLineO ;
String[]
names = line.split(delimiter);
for (int i = 1; i < names.length; i++)
for (int j = i+1;
j < names.length;
j++)
StdOut.println(names[i] + delim + names[j]);
}
}
}
% Java MoviesToPerformers "/" < moviesG.txt > performersG.txt
% more performersG.txt
DeBoy, David/Blumenfeld, Alan
DeBoy, David/Geppi, Cindy
DeBoy, David/Hershey,
Barbara
Blumenfeld, Alan/Geppi, Cindy
Blumenfeld, Alan/Hershey, Barbara
Converting the movie-performergraph to aperformer-performergraph
stand the small-world phenomenon. The trick to developing such a model is to
introduce random edges.
Random graphs. One well-studied graph model is the random graph. The sim
plest way to generate a random sparse graph is to add edges connecting random
vertices, each chosen from Vpossibilities, untilEdifferent edges have beengener
ated. Sparse randomgraphs witha sufficient numberof edges areknown to have
short distances but are not small-world graphs, because theydo not exhibit local
clustering—see Exercise4.5.41.
Ring graphs with random shortcuts. One ofthemost surprising facts to emerge
from the work of Watts and Strogatz is that adding a relatively small numberof
random edges to a graph with local clustering produces small-world graphs. To
gainsomeinsight onwhythisisthecase, consider a ringgraph,where the distances

4.5 Small World Phenomenon
679
between vertices on opposite sides is ~V72. Adding ~V/2 edges around the ring
connecting vertexi to vertexi+2 (mod V) cutsthe lengthof theselongestshortest
paths to ~V74, but addingjust one shortcut across the graph accomplishes about
the same effect. Adding V/2 random shortcuts just in
creases the average number of neighborsby 1and doesnot
significantly affect the local clustering, but it is extremely
likely to yielda short average path length.Addingrandom
shortcuts to a ring graph doesthe trick: adding a random
edge from each vertex adds only 1 to the average vertex
degree and does not lower thecluster coefficient muchbe
low 1, but it does significantly lowerthe average distance
betweenvertices, makingthem logarithmic.
random
ringwith random shortcuts
Two additional graph models
Generators that create graphs drawn from such models
are simpleto develop, and wecan use SmallWorld to de
termine whether the graphs exhibit the small-world phe
nomenon. We also can check the analytic results that we
derived for simple graphs such as tiny.txt, complete
graphs, and ring graphs. As with most scientific research,
newquestions arise asquickly asweanswer old ones.How
manyrandom shortcuts do weneed to add to get a short
average path length? Whatis the average path length and
the cluster coeffi
cient in a random
graph? What other graph modelsmight be
appropriate for study? How many samples
do we need to accurately estimate the clus
ter coefficient or the average path length
in a huge graph? Youcan find in the exer
cises many suggestionsfor addressingsuch
questions and for further investigations of
the small-world phenomenon. With the
basic tools and the approach to program
ming developed in this book, you are well
equipped to address this and many other
scientific questions.
model
average
degree
average
path length
cluster.
coefficient
complete
999
O
1
•
1.0
•
ring
2
•
250
O
.66
•
star
2
•
2
•
.004
O
3V random edges
3
•
3
•
.02
O
ringwith V
random shortcuts
3
•
3
•
.62
•
Small-world parameters
for various 1,000-vertex graphs

680
Algorithms and Data Structures
Lessons
Thiscase studyillustrates theimportance ofalgorithms and datastruc
tures in scientific research. It also reinforces several of the lessons that we have
learnedthroughout this book,whichareworth repeating.
Carefully design your data type. One ofour most persistent messages through
out thisbook isthat effective programming isbasedon a precise understandingof
the possible set of data-type values and the operationson them. Using a modern
object-oriented programming languages such as Java provides a path to this un
derstandingbecause wedesign, build,and useour own data types. Our Graph data
type isa fundamentalone,the productof manyiterationsand experience with the
design choices that wehave discussed. Theclarityand simplicity of our clientcode
istestimonyto the valueof takingseriouslythe designand implementation of basic
data types in any program.
Develop code incrementally. As withallof our other case studies, webuildsoft
wareone moduleat a time,testing andlearning about eachmodulebeforemoving
to the next.
Solve problems that you understand before addressing the unknown. Our
shortest-paths example involving air routes between a few cities is a simple one
that is easyto understand.It isjust complicated enough to hold our interestwhile
debugging and following through a trace,but not so complicated asto makethese
tasks unnecessarilylaborious.
Keep testing and check results. When working with complex programs thatpro
cess hugeamounts of data,youcannotbe too careful in checking your results. Use
common senseto evaluate everybit of output that your program produces.Novice
programmers have an optimistic mindset ("if the program produces an answer,
it must be correct"); experienced programmers know that a pessimistic mindset
("theremust be somethingwrongwiththis result") isfarbetter.
Use real-world data. The movies. txt file from the InternetMovie Database is
just one example of the data files that are now omnipresent on the web. In past
years, such data was often cloaked behind private or parochial formats, but most
peopleare now realizing that simple textformatsare much preferred. The various
methods in Java's Stri ng data type make it easy to work with real data, which is

4.5 Small World Phenomenon
the best wayto formulate hypothesesabout real-worldphenomena. Start working
with small files in the real-world format, so that you can test and learn about per
formance before attacking huge files.
Reuse software. Another of our most persistent messages is
that effective programming isbasedon an understandingofthe
fundamental data types available for our use,so that we do not
have to rewrite code for basic functions. Our use of ST and SET
in Graph is a prime example—most programmers stilluselow
er-level representations and implementations that use linked
listsor arrays for graphs,which means, inevitably, that they are
rewriting code for simple operations such as maintaining and
(^set^) ( st ^
traversing linked lists. Our shortest-paths class PathFinder
uses Graph, ST, SET, Stack, and Queue, an all-star lineup of
fundamental data structures.
681
Code reusefor Pathfi nder
Maintain flexibility. Reusing software often means using Java library classes.
Theseclasses are generallyverywideinterfaces (manymethods), so it isalways wise
to defineand implementyourownAPIs withnarrowinterfaces betweenclientsand
implementations, evenif your implementationsare all calls on Java library meth
ods.Thisapproachprovides the flexibility that youneedto switch to more effective
implementations when warranted and avoids dependence on changes to parts of
the library that you do not use.For example, using ST in our Graph implementa
tions gives us the flexibility to use Java's Java, uti 1.TreeMap or our BST symbol-
table implementation without having to changeGraph at all.
Performance matters. Withoutgood algorithms anddatastructures, manyofthe
problemsthat wehaveaddressedin this chapterwould go unsolved, becausenaive
methods require an impossible amount of time or space.Maintaining an awareness
of the approximate resourceneedsof our programs is essential.
This casestudy isan appropriateplaceto end the book becausethe programs that
we haveconsidered are a starting point, not a completestudy.This book is a start
ingpoint,too,for your further studyin science, mathematics, or engineering. The
approachto programmingand the toolsthat youhave learnedhere shouldprepare
you wellfor addressing any computational problem whatsoever.

Algorithms and Data Structures
W+.A
Q. Howmanydifferent graphsaretherewith Vgiven vertices?
A. With no self-loops or parallel edges, there are V(V—1)/2 possible edges, each
of which can be present or not present,so the grand total is 2 v(v-i)/2e The number
growsto be huge quite quickly, asshown in the following table:
l
8
2vrv-u/2
1
2
8
64
1024
32768
2097152
268435456
68719476736
Thesehugenumbers providesomeinsightinto the complexities of socialrelation
ships. For example, if you just consider the next nine people that you see on the
street,there are over68 trillion mutual-acquaintance possibilities!
Q. Cana graphhave a vertex that isnot connected to anyother vertex byan edge?
A. Good question. Such vertices areknownas isolated vertices. Our implementa
tion disallows them.Anotherimplementationmight chooseto allowisolatedverti
cesby includingan explicit addVertexO method for the adda vertex operation.
Q. Whynot just usea linked-list representation for the neighborsof eachvertex?
A. You can do so,but you arelikely to wind up re-implementing basiclinked-list
code asyou discoverthat you need the size, an iterator, and so forth.
Q. Whydo theV() and E() querymethods needto have constant-time implemen
tations?
A. It mightseem that mostclients would call suchmethods onlyonce, but an ex
tremely common idiom is to use code like
for (int i
= 0;
i
< G.EQ;
i++)
{
}
whichwouldtakequadratictimeifyouwere to usealazyalgorithmthat countsthe
edges instead of maintainingan instance variable with the number of edges. See
Exercise 4.5.1.

4.5 Small World Phenomenon
Q. Why are Graph and PathFinder in separate classes? Wouldn't it make more
sense to include the PathFi nder methods in the Graph API?
A. Finding shortest paths is just one of many graph-processing algorithms. It
would be poor software design to include all of them in a single interface. Please
reread the discussion of wide interfaces in Section 3.3.
683

Algorithms and Data Structures
3&KSili^
4.5.1
Add to Graph the implementations of V() and E() that return the number
of vertices and edges in the graph, respectively. Make sure that your implementa
tions are constant-time. Hint: For V(), you may assume that the size() method in
ST is constant-time; for E(), maintain an instance variable that holds the value.
4.5.2
Add a method degree () to Graph that takes a Stri ng as input and returns
the degreeof the named vertex. Usethis method to find the performer in movi es.
txt who has appeared in the most movies.
Answer:
public int degree(String v)
{
if (st.contains(v)) return st.get(v).size();
else
return 0;
}
4.5.3
Add to Graph a method hasVertexO that takes a Stri ng argument and
returns true if it names a vertexin the graph, and fal se otherwise.
4.5.4
Add to Graph a method hasEdgeO that takes two Stri ng arguments and
returns true if they specifyan edge in the graph, and fal se otherwise.
4.5.5
Createa copyconstructor for Graphthat takes as argument a graph G, then
createsand initializes a new, independent copyof the graph. Anyfuture changesto
Gshould not affect the newlycreated graph.
4.5.6
Write a version of Graph that supports explicit vertex creation and allows
self-loops, paralleledges, and isolatedvertices. Hint: Usea Queue for the adjacency
lists instead of a SET.
4.5.7
Add to Graph a method remove() that takes two String arguments and
deletesthe specifiededgefrom the graph, if present.
4.5.8
Add to Graph a method subgraphO that takes a SET<String> as argu
ment and returns the induced subgraph (the graph comprised of those verticesand
all edgesfrom the original graph that connect any two of them).

4.5 Small World Phenomenon
4.5.9
Write a version of Graph that supports generic vertex types (easy). Then,
write a version of PathFi nder that uses your implementation to support finding
shortest paths using generic vertextypes (more difficult).
4.5.10 Create a version of Graph from the previous exercise to support bipartite
graphs (graphswhose edges allconnecta vertex of one generic type to a vertexof
another generic type).
4.5.11 True orfalse: Atsome point during breadth-first searchthe queue can con
tain two vertices, one whose distance from the source is 7 and one whose distance
is 9.
Answer: False. The queue can contain vertices of at most two distinct distances d
and d+1. Breadth first search examines the verticesin increasing order of distance
from the source.When examining a vertexat distanced,only verticesof distance
d+1 can be enqueued.
4.5.12 Proveby induction on the setof vertices visitedthat PathFi nder findsthe
shortest path distances from the source to each vertex.
4.5.13 Supposeyou usea stackinsteadofaqueueforbreadth-firstsearchin Path
Finder. Does it still find a path? Does it still correctlycompute shortest paths? In
each case,prove that it does or givea counterexample.
4.5.14 What would be the effectof using a queue instead of a stackwhen forming
the shortest path in pathToO?
4.5.15 Add a method isReachable(v) to PathFinder that returns true if there
existssome path from the source to v, and fal se otherwise.
4.5.16 Write a Graph client that uses the constructor given in the text to read a
Graph from a file, then prints the edgesin the graph, one per line.
4.5.17 Implement a PathFinder client AllShortestPaths that builds a Path
Fi nder for each vertex, with a test client that takes from standard input two-vertex
queries and prints the shortest path connectingthem.
685

686
Algorithms and Data Structures
Answer:
public class AllShortestPaths
{
public static void main(String[] args)
{
In in = new In(args[0]);
Graph G = new Graph(in,
" ");
ST<String,
PathFinder> all paths;
allpaths = new ST<String,
PathFinder>();
for (String s : G.verticesO)
all paths.put(s,
new PathFinder(G,
s));
while (!Stdln.isEmptyO)
{
String s = Stdln.readString();
String t = Stdln.readString();
for (String v : all paths.get(s).pathTo(t))
StdOut.print(" " + v);
}
}
}
Modifythis code to useadelimiter, sothatyou can type the two-string queries on
one line (separated by the delimiter) and get asoutput a shortest chainbetween
them. Note: For movi es. txt, the query strings may both be performers, both be
movies, or be a performer and a movie.
4.5.18 Write a program that plotsaverage distance versusthe number ofrandom
edges as random shortcuts are addedto aringgraph.
4.5.19 Implement atestclient mai n() for Smal 1Worl d (Program 4.5.5) that pro
duces the output given in the sample runs. Your program shouldtakea delimiter
as command-line argument andread the graph from Stdln in our standard edge-
list format. You programshould be aGraph and PathFinder client that builds the
graph; computes the numberof vertices, average degree, average path length, and
cluster coefficient for the graph; and indicates whether the values are too large or
too smallforthe graph to exhibitthe small-world phenomenon.

4.5 Small World Phenomenon
Partial answer:
public static void main(String[] args)
{
In stdin = new In();
String delim = args[0];
Graph G = new Graph(stdin,
delim);
StdOut.printf("%d vertices",
G.V());
if (G.V() < 1000)
{
StdOut.print(" (too small)
");
StdOut.println();
double val
= avgDegree(G);
StdOut.printf("average degree %7.3f",
val);
if (val > 10.0 * Math.log(G.VO) / Math.log(2))
{
StdOut.print(" (too big)
");
StdOut.println();
}
4.5.20 Add to SmallWorld a method isSmallWorldO that takes a graph as ar
gument and returns true if the graph exhibits the small-world phenomenon (as
definedby the specific thresholds givenin the text) and fal se otherwise.
4.5.21 Add to Smal 1Worl d a method cl usterCoeffi ci ent() that takes a graph
and an integer k as arguments and computes a cluster coefficient for the graph
basedon total edgespresent and total edges possibleamong the setofverticeswith
in distance k of each vertex. Your program should produce resultsidentical to the
method in Smal1Worl d when k is 1.)
4.5.22 Compute the average distance between two vertices in a ring
graph with N vertices, and computethe clustercoefficient of a star graph
with N vertices.
4.5.23 In a k-circle graph (for any givenconstant k),edgesconnect ver
tex i to vertex i+j (mod V) for all postivej less than k. Write a Smal 1-
World and Graph client that generates fc-circle graphs and tests whether
they exhibitthe small-worldphenomenon (firstdo Exercise 4.5.20).
687
3-circlegraph

Algorithms and Data Structures
4.5.24 In a gridgraph, vertices are arranged in an N-by-N grid, with edges con
necting each vertex to its neighbors above,below,to the left, and
to the right in the grid. Write a SmallWorl d and Graph client that
generates grid graphs and tests whether they exhibit the small-
world phenomenon (first do Exercise4.5.20).
4.5.25 Extend your solutions of the previous two exercises to
alsotakea command-lineargumentMand to add Mrandom edges
to the graph. Experiment with your programs for 1,024-vertex
graphs to find small-world graphs with as fewedgesas possible.
Grid graph

4.5 Small World Phenomenon
il^Biliiifl^WifiiS
4.5.26 LargeBacon numbers. Findthe performersin movi es. txt with the largest,
but finite, Kevin Bacon number.
4.5.27 Histogram. Write a program BaconHistogram that prints a histogram of
Kevin Baconnumbers, indicating how many performersfrom movi es. txt have a
Bacon number of 0, 1, 2, 3,.... Include a categoryfor those who have an infinite
number (not connected at all to Kevin Bacon).
4.5.28 Performer graph. As mentioned in the text, an alternate way to compute
Kevin Baconnumbers isto build a graph wherethere isa vertexfor eachperformer
(but not for each movie), and where two performers are connected by an edge
if they appear in a movie together. Calculate Kevin Bacon numbers by running
breadth-first searcheson the performer graph. Compare the running time with the
running time on movi es. txt. Explain whythis approach is so much slower. Also
explainwhatyouwouldneedto do to includethe movies alongthe path, ashappens
automatically with our implementation.
4.5.29 Connected components. Aconnected component in an undirected graph is a
maximal set of vertices that are mutually reachable.Write a Graph client CCFi nder
that computes the connected components of a graph. Include a constructor that
takes a Graph as an argument and computes all of the connected components us
ing breadth-first search. Include a method areConnected(v, w) that returns true
if v and ware in the same connected component and fal se otherwise. Also add a
method components () that returns the number of connected components.
4.5.30 FloodfillI imageprocessing. Ani mage isatwo-dimensional arrayof Color
values (see Section 3.1) that represent pixels. A blob is a collection of neighboring
pixels of the samecolor.Writea Graph clientwhoseconstructor builds a grid graph
(seeExercise 4.5.24)from a givenimageand supports thefloodfilloperation. Given
pixelcoordinates i and j and a color c, change the color of that pixeland all the
pixels in the same blob to c.
4.5.31 Word ladders. Write a program WordLadder that takestwo 5-letter strings
from the command line, and reads in a list of 5-letter words from standard input,
and prints out a shortest word ladder usingthe wordson standard input connecting
689

Algorithms and Data Structures
the two strings (if it exists).Two words can be connected in a word ladder chain if
they differin exactly one letter. Asan example, the following word ladder connects
green and brown:
green greet great groat groan grown brown
Writea simplefilter to getthe 5-letterwordsfrom a systemdictionaryfor standard
input or download a list from the booksite. (This game,originallyknown as dou
blet, wasinventedby Lewis Carroll.)
4.5.32 Allpaths. Write a Graph client Al1Paths whose constructor takes a Graph
as argument and supports operations to count or print out all simple paths be
tweentwo given vertices s and t in the graph.A simplepath does not revisitany
vertexmore than once.In two-dimensional grids,such paths are referredto asself-
avoiding walks (see Section1.4). It isa fundamental problemin statistical physics
and theoreticalchemistry, e.g., to modelthe spatialarrangement of linear polymer
molecules in a solution.Warning: Theremightbe exponentially manypaths.
4.5.33 Percolation. Develop a graph model for percolation,and write a Graphcli
ent that performs the same computation as Percol ati on (Program 2.4.5).
4.5.34 Subway graphs. In the Tokyo subway system, routes are labeled by letters
and stops by numbers, such as G-8 or A-3. Stations allowing transfers are sets of
stops. Find a Tokyo subway map on the web, develop a simple database format,
and write a Graph clientthat readsa file and can answershortest-path queriesfor
the Tokyo subway system. If you prefer, do the Paris subway system, whereroutes
are sequences of names and transfers are possiblewhen two routes have the same
name.
4.5.35 Directed graphs. Implement a Digraph data type that represents directed
graphs,where the direction of edgesissignificant: addEdge(v, w) means to add an
edgefrom v to wbut notfromwto v.Replace adj acentTo() with twomethods, one
to give the set of vertices having edges directed to themfrom the argument vertex,
theotherto give thesetofvertices having edges directed fromthem to theargument
vertex. Explain how PathFi nder wouldneed to be modifiedto find shortest paths
in directed graphs.

4.5 Small World Phenomenon
4.5.36 Random surfer. Modify your Digraph class of the previous exercise to
make a Mul tiDigraph class that allows parallel edges. For a test client, run a ran
dom surfer simulation that matches RAndomSurfer (Program 1.6.2).
4.5.37 Transitive closure. Write a Digraph clientTransi ti veCl osu re whose con
structor takes a Di graph as an argument and whose method i sReachabl e(v, w)
returns true if wis reachablefrom v along a directed path in the digraph and fal se
otherwise. Hint: Run breadth-first search from each vertex, as in All Shortest-
Paths (Exercise 4.5.17).
4.5.38 Cover time. A random walk in a connected undirected graph moves from
a vertex to one of its neighbors, each chosen with equal probability. (This process
is the random surfer analog for undirected graphs.) Write programs to run experi
ments so that support the developmentof hypotheses on the number of stepsused
to visiteveryvertexin the graph.What isthe covertime for a completegraph with V
vertices? A ring graph? Can you find a familyof graphs wherethe covertime grows
proportionally to V3 or 2 y?
4.5.39 CenteroftheHollywood universe. Wecan measure how good a center Kevin
Baconisby computing eachperformer's Hollywood number or average path length.
The Hollywood number of Kevin Bacon is the average Bacon number of all the
performers (in its connected component). The Hollywood number of another per
former is computed the same way, making that performer the source instead of
Kevin Bacon. Compute Kevin Bacon's Hollywood number and find a performer
with a better Hollywood number than Kevin Bacon. Find the performers (in the
same connected component as Kevin Bacon) with the best and worst Hollywood
numbers.
4.5.40 Diameter. The eccentricity of a vertex is the greatest distance between it
and any other vertex.The diameter of a graph is the greatestdistancebetween any
two vertices (the maximum eccentricity of any vertex). Write a Graph client Diam-
eter that can compute the eccentricityof a vertexand the diameter of a graph. Use
it to find the diameter of the graph represented by movi es. txt.
691

Algorithms and Data Structures
4.5.41 Erdos-Renyi graph model. In the classical random graph model,we build
a random graph on Vvertices by including eachpossible edgewith probabilityp.
Write a Graph client to verifythe following properties:
• Connectivity thresholds: Ifp < 1/Vand Vis large,then most of connected
components are small,with the largestlogarithmic in size. If p > l/V, then
there isalmostsurelya giantcomponentcontainingalmostallvertices. Ifp
< In VI V, the graph is disconnected with high probability;ifp > In VI V,
the graph is connectedwith high probability.
• Distribution ofdegrees: The distribution of degrees follows a binomial
distribution,centered on the average, so mostvertices havesimilardegrees.
The probability that a vertexis connected to kother vertices decreases
exponentially in k.
•Nohubs: Themaximum vertex degree whenp isa constantisat mostloga
rithmic in V.
• Little local clustering: The clustercoefficient is close to 0 if the graph is
sparseand connected.Random graphsare not small-worldgraphs.
• Small diameter: lip > In VI V, the diameter is logarithmic.
4.5.42 Power law ofweb links. The indegrees and outdegrees of pages in the web
obeya powerlawthat can be modeledby apreferred attachment process. Suppose
that eachwebpagehasexactlyone outgoinglink.Eachpageiscreatedone at a time,
startingwith a single pagethat pointsto itself. With probabilityp < 1,it linksto one
of the existing pages, chosen uniformly at random.With probability 1—p, it links
to an existing pagewith probability proportionalto the number of incominglinks
ofthat page. Thisrulereflects thecommon tendency fornewweb pages to point to
popularpages.Writeaprogramto simulate thisprocess and plot a histogramofthe
number of incoming links.
Partial answer: The fractionof pages with indegree kisproportional to k (_1 f(l~p)).
4.5.43 Watts-Strogatzgraph model.
(See Exercise 4.5.25.) Watts andStrogatz pro
posedahybridmodelthat contains typical linksofvertices neareachother (people
knowtheirgeographic neighbors), plussomerandomlong-range connectionlinks.
Plottheeffect ofadding randomedges toanN-by-iVgrid graphontheaverage path

4.5 Small World Phenomenon
length and on the cluster coefficient,for N = 100.Do the same for fc-circle graphs,
for various values of kup to 10log V,for V= 10,000
4.5.44 Kleinberg graph model.
There is no way for participants in the Watts-
Strogatz model to find short paths in a decentralized network. But Milgram's ex
periment also had a striking algorithmic component—individuals can find short
paths! Jon Kleinberg proposed making the distribution of shortcuts obey a power
law, with probability proportional to the dth power of the distance (in d dimen
sions).Eachvertexhas onelong-range neighbor.Writeaprogram to generate graphs
according to this model, with a test client that usesSmal 1Worl d to test whether they
exhibit the small-world phenomenon. Plot histograms to show that the graphs are
uniform over all distance scales (same number oflinks at distances 1-10 as 10-100
or 100-1000.Write a program to compute the average lengths of paths obtained by
taking the edge that brings the path as closeto target as possible in terms of lattice
distance, and test the hypothesis that this average is proportional to (log V)2.
693


In this closing section, weplaceyour newly-acquiredknowledgeof programming
in abroader contextbybrieflydescribing someof the basicelementsof the world
of computation that you arelikely to encounter.It isour hope that this information
willwhet your appetite to use your knowledge of programming as a platform for
learning more about the role of computation in the world around you.
You now know how to program. Just as learningto drive an SUVis not dif
ficult when you know how to drive a car, learning to program in a different lan
guage will not be difficult for you. Many scientists regularly use several different
languages, for various different purposes. The primitive data types, conditionals,
loops, and functional abstraction of Chapters 1 and 2 (that served programmers
well for the first couple of decades of computing) and the object-oriented pro
gramming approach of Chapter 3 (that is usedby modern programmers) arebasic
models found in many programming languages. Your skillin using them and the
fundamental data types of Chapter 4 willprepare you to cope with libraries, pro
gram development environments, and specialized applicationsof all sorts. You are
also well-positioned to appreciate the power of abstraction in designing complex
systems and understanding how they work.
The study of computer science is much more than learning to program. Now
that you are familiar with programming and conversant with computing, you are
well-prepared to learn about some of the outstanding intellectual achievements
of the past century, some of the most important unsolved problems of our time,
and their role in the evolution of the computational infrastructure that surrounds
us. Perhaps even more significant, as we have hinted throughout the book, is that
computation is playing an ever increasing role in our understanding of nature,
from genomics to moleculardynamics to astrophysics. Further study of the basic
precepts of computer scienceis certain to paydividendsfor you.
695

696
Context
fava libraries. TheJava system provides extensive resources foryouruse. We have
made extensive use of some Java libraries, such as Math and Stri ng,but haveig
nored most of them. One of Java's unique features is that a great deal of infor
mation about the libraries is readily available online. If you have not yet browsed
through the Javalibraries, now is the time to do so. Youwill find that most of this
code is for use by professionaldevelopers, but there are a number of libraries that
you arelikely to find to be interesting. Perhapsthe most important thing for you to
keepin mind when studyinglibraries is that you do need to usethem, but you can
use them. When you find an APIthat seems to meet your needs,take advantageof
it, by all means.
Programming environments. You will certainly find yourself using other pro
gramming environments besidesJava in the future. Many programmers, even ex
periencedprofessionals, are caughtbetween the past,becauseof huge amounts of
legacycode in old languagessuch as C, C++, and Fortran, and the future, because
of the availability of modern toolslike Ruby, Python, and JavaScript. Perhaps the
most important thing for you to keep in mind when using a programming lan
guage is that you do not need to use it. If some other language might better meet
your needs,takeadvantageof it,byallmeans.Peoplewho insist on stayingwithin a
singleprogramming environment, for whateverreason, are missing opportunities.
Scientific computing. In particular, computing with numbers canbe verytricky,
because of accuracy and precision, so the use of libraries of mathematical func
tions is certainlyjustified. Manyscientists use Fortran, an old scientific language;
manyothers useMatlab, a language that wasdevelopedspecifically for computing
with matrices.The combination of good libraries and built-in matrix operations
makesMatlab an attractivechoicefor manyproblems. However, sinceMatlab lacks
support for mutable types and other modern facilities, Java is a better choice for
many other problems. You can useboth! The same mathematical libraries used by
Matlab and Fortran programmersare accessible from Java (and bymodern script
ing languages).
Computer systems. Properties of specific computersystems oncecompletely de
termined the nature and extent of problems that could be solved, but now they
hardly intrude. You can still count on having a faster machine with much more
memory next year at this time. Strive to keep your code machine-independent,

so that you can easily make the switch. More importantly, the web is playing an
increasingly critical role in commercial and scientificcomputing, as you have seen
in many examples in this book. You can write programs that process data that is
maintained elsewhere, programs that interact with programs executing elsewhere,
and take advantage of many other properties of the extensive and evolvingcompu
tational infrastructure. Do not hesitate to do so.Peoplewho investsignificant effort
in writing programs for specificmachines,evenhigh-poweredsupercomputers, are
missing opportunities.
Theoretical computer science. By contrast, fundamental limits on computation
have been apparent from the start and continue to playan important role in deter
mining the kinds of problems that wecan address. You might be surprised to learn
that there are some problemsthat no computer program can solve and many other
problems, which arise commonlyin practice, that are thought to be too difficult
to solve on any conceivable computer.Everyone who depends on computation for
problem solving,creativework, or researchneeds to respectthese facts.
You have certainly come a long way since you tentatively created, compiled, and
ran Hell0W0rid, but you certainly still have a great deal to learn. Keep program
ming, and keep learning about programming environments, scientific computing,
computer systems,and theoretical computer science,and you will open opportuni
ties for yourself that people who do not program cannot even conceive.
697


(() (Gaussianpdf) 194
<I> (Gaussian cdf) 194
it (pi) 29
Abstract data structure
SeealsoAPI; Encapsulation
deque 602
graph 650
queue 576
random queue 580,602
set 632
stack 551
symbol table 608
Abstract data type
SeeEncapsulation
Abstraction 315
Access modifier 372
Adaptive plot 300-303
Albers, Josef 325
Algorithm 471-606
binary search 511-519
breadth-first search 663-671
brute-force 513
depth-first search 298-299
Dijkstra's2-stack571
Dijkstra'sshortest path 672
Euclid's gcd 81,259-260
Horner's method 214
insertion sort 521-526
Mandelbrot test 394-397
mergesort 527
Newton's method 61
quicksort 548
shuffling an array 93
Sieve of Eratosthenes 99-101
Aliasing
defined 353
with substrings 493
Alpha-blending 334
Amortized analysis564
Analysis of algorithms
amortized analysis564
big-Oh notation 497
binary search tree 626-628
breadth-first search 671
inner loop 478
insertion sort 522
leading term 478
memory 490-494
mergesort 530
order of growth 478-489
running time 473-489
space-time tradeoff 95
tilde notation 478
worst-case 488
Anatomy
of a class 377
of a command 128
of a constructor 373
of an expression 17
of a for loop 57
of an i f statement 47
of an instance method 373
of a pri ntf statement 124
of a program 7
of a signature 30
of a static method 188
of a whi1e loop 50
Animation 143-145
API 29,223,318
Body 458
Charge 318
Color 326
Complex 391,721
Counter 424,721
Deque 602
Document 434
Draw 351,716
Gaussian 223
Graph 655,721
Histogram 718
In 345,715
Interval 408
Math 29,714
Out 346,714
PathFi nder 663,723
Picture 330,718
Poi nt 409
Queue 577,722
RandomQueue 602
Rational 408
SET 632,720
ST 609,720
Stack 552,720
StdArrayI0 229,719
StdAudi 0 149,718
StdDrawl46,718
Stdln 127,717
StdOut 124,716
StdRandom225,719
699

700
StdStats236,719
StockAccount 398
Stopwatch 718
String 338,717
System.out 28,716
Turtle 382,720
Universe 461
Vector 431,721
APLlanguage 404
Applicationsprogramming
interface. See API
Argument variable 187,190
Arithmetic expression 17,570
Arithmetic overflow.
SeeInteger overflow
Array 86-119
as an object 355
as an argument 198
as a return value 201
assignment 96
bounds checking 91
copy an 89
create an 87
declare an 87
default initialization 87
equality test 96
exchangetwo elements 200
indexing 86
initialization 87,91
input and output 229,230
length 89
memory allocation 90
memory representation 90
memory usage 492
multidimensional 107
of objects 355
one-dimensional 86
out-of-bounds 91
parallel 399
plot an 238
print an 200
ragged 106
reverse an 89,113
two-dimensional 86,102-110
zero-basedindexing 112
Array doubling 562
Assert statement 446-447
Assignment statement
parse an 646
with arrays 96
with primitive types 16
with reference types 353
Associative array 613
Associativity 17
Audioprocessing.
SeeDigitalaudio
Auto-boxing 569
Automatic initialization
of array elements 87,496
of instance variables 403
Automatic type conversion
See Type conversion
Auto-unboxing 569
Average
of a stream of numbers 130
of elements in an array 89
B
Bacon, Kevin 664
Balanced search tree 632
Barnsleyfern 232
Base case 256
Base class 438
Beckett, Samuel 265
Benford'slaw215
Bentley, Jon 543
Bernouilli, Jacob 386
Bernoulli distribution 225,241v
Big-Oh notation 497
Index
Binary number 63
Binary operator 17
Binary representation
binary search 514
number conversion 63
Binary search 511-520
binary representation 514
exception filter 518
in a sorted array 516
in a symbol table 636
Javalibrary 543
to invert a function 214,515
to weigh an object 518
twenty questions 512
Binary search tree 619-631
Seealso Binary tree
ceiling 639
find the maximum 631
find the minimum 631
floor 639
insert into 624-625
order statistics 632,644
performance of 626
range search 632
rank query 644
red-black tree 628,632
removal in 631
search in 622
traversal of 628-631
visual representation 620
Binary tree
balanced 640
inorder traversal 628
isomorphism between 640
leaf in 621
level-order traversal 641
postorder traversal 628
preorder traversal 628
root of 621
Binomial coefficient 119

Binomial distribution 215
Birthday problem 119,213
Bisection search 214
Bit 21
Bitmapped image 329
Black-Scholes formula 214
Block statement 46
Body
of an if statement 46
of a loop 49
Booksite 4
bool ean data type 25-27
Boolean logic 26
Bounding box 138
Bouncing ball 144-145,457
Box-Muller formula 42,213
Breadth-first search 663-671
break statement 70
Brownian bridge 270-271
Brownian island 284
Brownian motion 388
Brown, Robert 388
BST.SeeBinarysearch tree
Buffer overflow 91
Bug. See Error
Built-in type 14-45
Byte 490
byte data type 23
c
C language 3
array declaration 112
compound assignment 56
memory leak 357
printf 123
C++ language 3
iterators 592
memory leak 357
operator overloading 404
Caching 486
Calendar 216
Call a method 29
Callback 438
Call by reference201
Calls itself. See Recursion
Carroll, Lewis 690
Case study
N-body simulation 456-469
percolation 286-313
random web surfer 162-181
small-world 650-693
Cast 31-33
Centroid 156
Chaos 85
with Newton's method 414
char data type 19
\n (newline) 19
\t (tab) 19
\" (quotation mark) 19
\\ (backslash) 19
Checksum 82,210
Chord 202,216
Chromatic scale 148
Circular queue 604
Class
anatomy of 377
as a data type 371
as a program 6
as a set of methods 218
inner 558,593
nested 558,593
classpath 153,247,307
Client 222
CMYK color format 43,361
Code maintenance 245,681
Code reuse 218,245,306,681
Coin flip 49
Collatz function 283
Collection 550
701
Color 324-328
CMYK format 361
Col or API 326
compatibility 327
luminance 326
RGBrepresentation 324,361
RGB to CMYK conversion 43
to grayscale327
with standard draw 324
Column-major order 105
Combination 281-282
Command 128
Command-line argument 8,9
Command-line input 121
Comment 10
Comparabl e interface 434-436
compareToO 436,523
for sorting 523
keys in a BST609
Compiler 5,573
Compile-time error
See Error
Complex number 390-397
Compound assignment 56
Computer science 695
Concatenation 19
Concert A 147
Concordance 638
Conditional
i f statement 46
switch statement 70-71
Connected component 689
Constant
Doubl e.NaN 185
Double.NEGATIVE_INFINITY 36
Double.POSITIVE_INFINITY 36
Integer.MAX_VALUE54
Integer.MIN_VALUE54
Math.E 29
Math.PI 29

702
Constant running time 481
Constructor
anatomy of 373
default no-argument 403
defined 372
overloading a 372
conti nue statement 70
Control flow 185
Conversion. See Type conversion
Conway's game of life312
Corner case 228
Cost. SeePerformance
Coulomb's law 317
Coupon collector 97-99,196
Crichton, Michael 412
Ctrl-c 72,153
ctrl-dl31
ctrl-zl31
Cubic running time 482
D
Dangling el se 75
Data abstraction 315,370
Data-driven code 133,163,177
Data mining 439-445
Data structure 471-693
See also Abstract data struc
ture
array 86
binary search tree 619-631
linked list 555-558
parallel arrays 399
Data type
built-in 14-45
creating a 370-469
defined 14
designing a 416-469
generic 566
immutable 427-429
mutable 427-429
parameterized 566
primitive type 36
referencetype 316
using a 316-369
wrapper 569
Day of the week42
Debugging
by printing variables52
by tracing code 17
compile-time errors 8
corner case 228
is difficult 177
run-time errors 8
stress test 228
unit test 227
Declaration statement
array 87
primitive type variable 16
referencetype variable319
instance variable 372
Defensive copy429
Delimiter 659
De Morgan'slaws26
Dependency graph 243
Deprecated method 448
Depth-first search 298-299
Deque data type 602
Dequeue (from a queue) 576
Derived class 438
Descartes, Rene 386
Design
of a data type 416-469
of a library 224-225
Design-by-contract 446
Dictionary lookup 611-615
Digital audio
chord 202
chromatic scale 148
concert A 147
Index
Fourier series 217
harmonics 202
plotting a wave241
sampling 148
save to a file 149
superposition of 202-203
visualization of 159
Digitalimage processing
SeeImage processing
Digitalsignalprocessing147
Dijkstra, Edsgar 547,571
Dijkstra's algorithm 672
Discrete distribution 164,226,
647
Divide-and-conquer
binary search 511
binary search tree 622
mergesort 527
paradigm 541
Dot product 88,200
doubl e data type 23-24
do-while loop 71
Doubling hypothesis 474
Dragon curve 44,155,412
Drawing.SeeStandard drawing
Dynamic dispatch 435
Dynamic programming 275
E
Einstein, Albert 388
el se clause 47
Empirical analysis474
Encapsulation 420-426
modular programming 420
private modifier 422
End-of-file 131
Enhanced for loop
SeeForeach loop
Enqueue (onto a queue) 576

Entropy 367,644
equal sO method
with Stri ng data type 338
with wrapper types 570
inherited from Object 438
versus ==operator 359-360
with Color data type 354
with user-defined types 449
Erdos number 666
Erdos, Paul 666
Error
ArraylndexOutOfBounds 12,
91,122
buffer overflow 91
bug 8
ClassCast567
defined 8
divide by zero 37
FormatConversion 125
loss of precision 33
missing return statement 207
NoClassDefFound 152
non-static method cannot be
referenced 207
Null Pointer 360,403
NumberFormat 128
off-by-one 89
0ut0fMemory497
RuntimeException 446
shadowing a variable 407
Stack0verflow273,274
syntax 11
throw an exception 446
uninitialized variable 90
unreachable code 207
variable not initialized 35
Escape sequence 19
Euclidean distance 113
Euclid's algorithm 81,259-260
Euler, Leonhard 85
Event-based programming 437
Exception. SeeError
Exceptionfilter518
Exchange.SeeSwap
Exponential distribution 250,
582
Exponential running time
263-264,274-275,482
Exponentiation 29
Expression 17
Factorial function 57,256-257
Factoring 68-69
false literal 25
Fast Fourier transform 254
Fibonacci sequence 78,274-275
FIFO 550
FIFO queue. See Queue
File extension
.class 5,9,20
.csv 349,613,662
.Java 5,9,371
.jpg 146,330
.png 146,330
.wav 149
File format 164,229,399
Filter 134-135,139-140
f i nal modifier 372
Find the maximum
in a binary searchtree 631
in a linked list 601
in an array 89,200
of an arbitrary sequence 154
of two numbers 29
Find the minimum
in a binary searchtree 631
of an arbitrary sequence 154
First-in first-out 550
703
float data type 25
Floating-point number 23-25
infinity 25
NaN (not a number) 25
precision 24
with ==operator 38
Flood fill 689
Flowchart
i f statement 47
nested loops 58
while loop 54
Foreach loop
with arrays 594
with Iterable collections 585
for loop 55
Formatted printing 124-126
Forth language 574
Fortran language 696
Fourier series 217
Fractal
Barnsley fern 232
Brownian bridge 270-272
dimension 272
dragon curve 44,412
Hilbert curve 412
H-tree 268-269
iterated function system 231
Koch curve 385
Mandelbrot set 394-397
plasma cloud 272
Sierpinskitriangle 231
Fractional Brownian motion
270
Fragilebase class438
Frequency count 532-534
Function. See Static method
Function abstraction 315
Functional programming lan
guage 437
Function call

704
stack implementation of 574
trace 187
tree 261
Gambler's ruin 65-67
Game of life 312
Garbage collection 357
Gardner, Martin 412
Gaussian distribution 193,270
binomial distribution 241
cdf515
random value 42,213,226
library 223
Generic array creation 594
Generic type 567-569
Genomics 341
Geometric mean 154
Global variable 245,405
Google 176
Graph 650-693
adjacencymatrix 671
bipartite 662
breadth-first search 671
complete 674
connected component 689
diameter 691
directed 690
Erdos-Renyi692
Graph API 655,723
parallel edge656
random 678
ring 674
self-loop 656
shortest path in 663-672
transitive closure 691
vertex degree 684
Gray code 265-267,282
Grayscale 327-331
Great circle 44
Greatest common divisor
259-260
Grep 135,440
H
Hamming distance 282
Harmonic mean 154
Harmonic number 60-61,95,
191,202,213,257
hashCodeO method
for profiling443
inherited from Object 438
Hashing 442
Heap-ordered 640
Hello, World 6-7
Hertz 147
Hexadecimal integer 152
Hilbert curve 412
Hilbert, David 412
Histogram 169,380-381
Hoare,C.A.R.495
Horner's method 214
H-tree 268-269
Hurst exponent 272
Hyperlink 551
i
Identifier 15
i f statement 46-49
Image processing 329-337
alpha-blending334
convert to grayscale 330
digital zoom 369
flood fill 689
scaling332
Immutability 427-429
and aliasing354
defensive copy429
Index
final modifier and 428-429
of strings 363,427-429, 537
of symboltable keys609,635
Implementation 223
import directive 361
Indentation 58
Index
inverted 643
symbol table client 615
this 699
Induction 254,258
Infinite loop 72,273
Infix notation 570,574
Information hiding
SeeEncapsulation
Inheritance 434-438
Initialization 16
of array elements 87
primitive types 16
Inner class 558,593
Inner loop 478,486
Inorder traversal 628
Input and output 120-161
for arrays 229
In data type 345
object-oriented 344-351
Out data type 346
Stdln library 126
StdOut library 123
Insertion sort 521-526
In silicoexperiment 304
Instance. See Object
Instance method 319
access modifier 372
anatomy of 373
callingan 319
define an 373
versus static method 323
Instance variable
accessing an 391

access modifier 372
defined 372
initialization of 403
shadowing an 407
int data type 21-22
Integer overflow21,36,54,544
Interface inheritance 434-436
Internet movie database 659
Interpolation 158
Interpreter 573
Invariant 447
Inverted index 643
Inverting a function 515
I/O. SeeInputandoutput
Iterable collection 585-589,638
with a binary tree 629
with a graph 656
with a linked list 588
with an array 587
Iterable interface 586
Iterated function system 231
J
Java 3
installing 4
why use? 10
javac command 5
java command 5
Java program 4
anatomy of 7
compile a 5
create a 5
execute a 5
java.uti!.ArrayList 592
j ava. uti 1.Ar rays 435, 543
java.uti1.Color 326
java.uti1.Date 454
java.uti1.HashMap 635
j ava.uti1.HashSet 635
java.util.Iterator 586
j ava.uti1.Li nkedLi st 592
java.util.Stack 594
java.util .TreeMap 632,635
j ava.uti1.TreeSet 635
Java Virtual Machine 5,573,574
Josephusproblem 603
JVM. Seelava Virtual Machine
K
Kevin Bacon game 664
Keyword10
k-gram 442
Kleinberg, Jon 693
Knuth, Donald 474,476,495
Koch curve 385
Last-in first-out 550
Layers of abstraction 445
Leading term 478
Leap year 27
Left-associativity 17
lg function 481
Library 222
LIFO 550
Linearithmic running time 482
Linear running time 481
Link 557
Linked list 555-562
defined 555
insert into front 556
Node data type 555
queue 577-580
remove from front 557
reverse a 606
stack 558-562
traverse a 558
visual representation 557
705
Linked structure 471
binary tree 621
linked list 555
Lissajous pattern 160
Literal
boolean 25
char 19
defined 15
double 23
int 21
null 403
String 19
Little's law 582
In function 30,481
Load balancing 590
Local variable 374
Logarithmic running time 481
Logarithmic spiral 386
Logistic map 85
Log-logplot 476
Logo language 388
Loitering 565
long data type 23
Longest common prefix
535-536
Longestrepeated substring
535-541
Loop
break statement 70
conti nue statement 70
do-whi 1 e statement 71
foreach statement 585
infinite 72
for statement 55
while statement 49
Luminance 326

706
M
Magritte, Rene 353
main() method 6,199
command-line arguments 199
in each class 221
Mandelbrot, Benoit 394
Mandelbrot set 394-397
Markov,Andrey 168
Markov chain 168
mixing a 171
squaring a 171
Markov process 581
Mathematical analysis476
Mathematical function
closed form 194
implementing 193
no closed form 194
Mathematical induction
See Induction
Math library 29,716
Matlab 3
matrix operations 696
mutable types 447
pass by value 208
Matrix 102
addition 105
Hadamardll7,308
library 249
multiplication 105-106,171
sparse 645
transpose 114
McCarthy's 91 function 285
M/D/l queue 581
Mean 154,236
Memoization 275
Memory address.SeePointer
Memory allocation 356-358
heap 494
of a linked list 555,562
of an array 90
stack 494
Memory leak 357,565
Memory representation
aliased variables 353
array of objects355
object 321
orphaned object356
substring 537
two-dimensionalarray 103
Memory usage 490-494
arrays 492
objects 490-491
primitive types 490
strings 491
substrings 493
two-dimensional arrays493
Mergesort 527-530
nonrecursive 604
Method 6
static 184-217
instance 373
Midpoint displacementmethod
270-272
Milgram,Stanley650
M/M/l queue 599
Modularprogramming 183,
218-219,243-245,420
Module 183,220
Monochrome luminance
See Luminance
Monte Carlo simulation 286
See also Simulation
Moore's law 484-485
more command 135
Multidimensionalarray 107
Mutability
defined 427-429
of arrays 427-429
Index
NaN (not a number) 185
Natural ordering 434
N-body simulation 456-469
Nested class 558,593
Nesting 58
new operator
with arrays 87
with objects 319
Newline character 19
Newton, Isaac 61,84,457
Newton's method 61,186
N log N running time
SeeLinearithmic running time
Node data type
in a binary tree 620-621
in a linked list 555
Normal distribution
See Gaussian distribution
null literal
array elements 87
as a default value 403
defined 403
with linked lists 556
with binary trees 619
Null pointer exception 403
Number conversion 63,80
Object 315
create an 319
identity 354
memory representation 321
orphaned 356
type conversion 322
Object class 438
Object-oriented programming
315-469

Off-by one-error 89
Operand 17
Operating systemdirective
| (piping) 133
< (redirect stdin) 132
> (redirect stdout) 132
Operator
Seealso Separator
compound assignment 56
defined 17
+ (addition) 21
+ (string concatenation) 18
++ (increment) 56
-
(subtraction) 21
— (decrement) 56
* (multiplication) 21,23
% (remainder) 21
/
(division) 21
== (equal to) 26
== versus = 359
!= (not equal to) 26
> (greater than) 26
>= (greaterthan or equal to)
26
< (less than) 26
<= (lessthan or equal to) 26
& (bitwise and) 38
&& (logicaland) 25
|| (logicor) 25
! (logicalnot) 25
a
(exclusive or) 39
() (cast) 31
Operator overloading392,404
Order of growth 478-489
Order statistic 632,644
Orphaned object 356,565,593
Out of memory 497
Overflow. SeeInteger overflow
Overloading
of constructors 372
of methods 192
of operators 392,404
Pagerank 168
Palindrome 340
Papert, Seymour 388
Parallel arrays 399
Parameterized data type 566
Parse
an assignment statement 646
parseDoubleO method 18
parselnt() method 18
Passby reference
defined 190
of arrays 199
versuspassbyvalue208
with objects 354
Passby value
defined 190
of primitive types 354
of references 354
versuspassby reference 208
Percolation 286-313
bond 311
directed 303,308
using graphs 690
three-dimensional 311
vertical 291-292,310
Performance 472-509
guarantees 488-489
Permutation 281
inverse 117
random 93
Phase transition 303
Picture data type 330
Piping 133
707
Pixel 329
Plasma cloud 272
Plotting
experimental results241
function graphs 140,300-303
sound waves 241
Pointer
defined 321
safe 355
Poisson process 581
Poker 253
Polar coordinates 42,422
Polymorphism 435
Pop (from a stack) 551
Postcondition 447
Postorder traversal 628
PostScript language 388,574
Power law 476,692
Power method 172
Powers of two 52
Precedence order 17
Precondition 447
Preorder traversal 628
Primality test 191
Prime number 99
Primitive data type 14
converting to string 18
type conversion 31-33
using a 16
printfO method 124-126,152
private access modifier
and encapsulation 422
instance method 372
instance variable 372
Probability 171
Problem size 473
Program
AlbersSquares 325
ArrayStackOfStrings 554
Average 130

708
Beckett 267
Bernoulli 242
Binary64
BinarySearch 517
Body460
BouncingBall 145
Brownian 271
BST 625
Cat 347
Charge 375
Charged ient 320
CompareAll 444
Compl ex 393
Counter 425
Coupon 197
CouponCollector 98
DeDup633
DivisorPattern 59
Document 441
Doubli ngStackOfStri ngs
563
DoublingTest 477
Estimate 297
Euclid 259
Eval uate 572
Factors 69
Fade 335
Flip49
FrequencyCount 533
Gambler 66
Gaussian 195,515
GeneFind342
Graph 657
Grayscale 331
Harmonic 61
HelloWorld6
Histogram381
Htree269
IFS 233
Index 617
IndexGraph 661
Insertion 524
InsertionTest 526
IntOps 22
LeapYear27
LinkedStackOfStrings 559
LoadBalance 591
Lookup614
LRS 539
Luminance 328
Mandelbrot 397
Markov 174
MDlQueue 583
Merge 528
Newton 186
PathFi nder 665,670
Percolation 290
PercPlot302
PlayThatTune 150
PIayThatTuneDeluxe 205
PlotFilterl39
Potential 337
PowersOfTwo53
PrimeSieve 100
Quadratic 24
Queue 578
Randomlnt 33
RandomSeq 122
RandomSurfer 167
RangeFilter 134
Ruler 20
Sample94
Scale 333
SelfAvoidingWalkl09
Small Wo rid 677
Spiral 387
Split 350
Sqrt62
Stack 568
StdArrayI0230
Index
StdRandom 226
StdStats 237
StockAccount 401
StockQuote 349
Stopwatch 379
ThreeSum475
TowersOfHanoi 262
Transition 165
Turtle 384
TwentyQuestions 129,512
Universe 463
Vector 432
Visualize 475
Programming 6
Promotion 32
private access modifier
instance method 372
static method 220
withmainO 10
Push (onto a stack) 551
Pushdown stack. See Stack
Python language 592
Quadratic formula 24-25
Quadraticrunning time 482
Quadrature 437
Quaternion 411
Queue datatype 576-584
iterator 589
Queue API 576,722
random 580
with array580
with linked list 577-580
Queueing theory 581
Quicksort 495,548

R
Raggedarray 106
Ramanujan, Srinivasa 82
Random integer 33
Random number generation
Bernoulli 225
binomial 215
discrete 226
exponential 582
Gaussian 42,213,226
Maxwell-Boltzmann 249
StdRandom 224-228
uniform 33,191,226
Random queue 580,602
Random simulation
See Simulation
Random surfer 162
Random walk
Brownian motion 388
self-avoiding 107-109
two-dimensional 82
Rangesearch 632,642
Raphson, Joseph 61
Raster image 329
Rational number 408
Recurrence relation 264,513
Recursion 254-283
Seealso Callsitself
induction 258
base case 258,273
convergence 273
depth-first search 298-299
excessive memory 274,277
excessiverecomputation 274
pitfalls of 273-275
reduction step 258
versus iteration 277
Recursive graphics
Brownian bridge 270-271
Brownian island 284
dragon curve 44,412
Hilbert curve 412
H-tree 268-269
Koch curve 385
plasmacloud 272
Red-black tree 628,632
Redirection 131-133
of standard input 132
of standard output 132
Reduction 531
Refactoringcode 535
Reference
declare a variable 319
defined 321
objects versus name 352
this 433
Reference type 316
Regular expression 339
Reserved word 15
return statement 188
Return type 188
Return value 29
Reverse
a linked list 601,606
an array 89,113
a stream 596
a string 504
Reverse Polish notation 574
RGB color format 43,324,361
Ringbuffer 604
Root of all evil 495
Row-major order 105
RSAcryptosystem 69,259
Ruby language 592
Ruler function 19,20,57,266
Running time
constant 481
cubic 482
doubling hypothesis474
709
empirical analysis474
exponential 263,275,482-483
hypotheses 474
linear 481
linearithmic 482
logarithmic 481
mathematical analysis476
observations 473
of percolation 296
order of growth 478-489
predictions 483
quadratic 482
worst-case 488-489
Run-time error. See Error
Sampling
an array 158
digital sound 148
points in the plane 395
to plot a function 140
to rescale an image 332
without replacement 93
Scaffolding288-289
Scientific method 473
Scientific notation 23
Scope 56,189
Screen scraping 346
Search
breadth-first 663-671
depth-first 298-299
in a binary search tree 622
in a sorted array 516
Self-avoidingwalk 107-109
Semantics 48
Separator
[ ] (array indexing) 86
{ } (block delimiter) 46
{ } (array initializer) 91,104

710
C ) (precedence) 17
C ) (method call) 187,319
; (statement terminator) 6,46
, (delimiter) 91,190
. (object accessor) 319,391
Sequential search 516
Set data type
defined 632-633
java.util.HashSet 635
java.uti1.TreeSet 635
SET API 632,722
Shepherd, Jessy 369
short datatype 23
Shortest path 663-672
Shortest-pathstree 668
Shuffling
a linked list 601
an array 93,199,226
Side effect
defined 193
design-by-contract447
with arrays 199
Sierpinksitriangle231
Sieve of Eratosthenes 99-101
Signature
anatomy of 30
of a static method 29,187
Similarity search445
Simulation
Bernoulli trials 241
birthday problem 119,213
coin flip 48
coupon collector 97-99,196
gambler's ruin 65
IFS 231-235
loadbalancing590-591
M/D/l queue 584
N-body 456-469
percolation 286-313
point in unit disk 71
random surfer 166-168
self-avoiding walk 107-109
SI units 317,461
Six degrees of separation 650
Small-world 650-693
Sorting 510-529
insertion sort 521-526
mergesort 527-530
system sort 435,543
Sound processing.
See Digitalaudio
Space-time tradeoff 95,101
Spatial vector 430-433
Specification problem 417,581
Speedy 369
Spira mirabilis 386
Square root
Math library29
Newton's method 61-63
user-defined 185-189
Stackdatatype 551-575
and recursion 273
for expression evaluation 570
for function calls 574-575
iterator 589
for memory allocation494
Stack API 552,720
using a doublingarray 562
using alinked list 558
using an array552
Stack overflow 273,274
Standard deviation 154,238
Standard drawing 136-146
animation 143-145
color 142
filled shapes 141
outline shapes 141
rescale 138
StdDraw API 146,718
text 142
Index
Standard input 126-131
arbitrary-size input 130
end-of-file 131
piping from 133
redirection from file 132
Stdln API 127,717
Standardoutput 123-126
redirection to file 132
StdOut API 124,716
Standards 417
Statement 6,15
assignment 16
asssert 446
block 46
break 70
compound assignment 56
continue 70
declaration 16
do-while 71
empty 76
for 55
foreach 585
if 46
return 188
switch 70
while 49
stati c keyword 10
Static method 184-217
anatomy of 187-188
argument variable 187
calling 190
call trace 204
control flow 185
defining 185
function call trace 187
main() 199
multiple arguments 190
overloading192
return statement 192
scope 189

side effects 193
signature 187
singlereturn value 192
terminology 188
to organize code 196
use in other programs 219
with array as return value 201
with array as argument 198
Static variable 405
Stationary distribution 168
Statistics 236-241
histogram 380-381
mean 154,236
median 238
plotting 238-240
sampling 93
select 632,644
standard deviation 154,238
StdStatsAPI236,719
Tukeyplot 251
variance 236
StdArraylO library
API 229,719
defined 229-230
StdAudio library
API 149,718
defined 147-151
StdDrawlibrary
API 146,718
defined 136-146
Stdln library
API 127,717
defined 126-131
stdlib.jar289
StdOut
API 124,716
defined 123-142
StdRandom library
API 719
defined 224-228
StdStats library
API 236,719
defined 236-242
Stri ngBui1der class 493,502
String data type
API 338,717
as immutable type 363
compareToO method 338
concatenation 502
defined 19
extract a substring 493
literal 19
memory usage 491
representationof 537
reverse a 504
with ==operator 37
String processing338-351
Strogatz,Stephen650
Strongly-typedlanguage16
Stub 289
Substring
extract a 493
memory usage 493
substringO method 338
Subtyping 438
Suffixarray 538
Suffixsorting 537
Swap
array elements 92,199-200
variable values 17
switch statement 70-71
Symboltable data type 608-649
as associative array 613
binary search 618
binary searchtree 619-632
dictionary lookup 611-615
elementary 618
indexing 615
j ava.uti1.HashMap 635
j ava. uti 1 .TreeMap 632,635
711
sequential search 618
ST API 609,720
Syntax error 11
Systemlibrary
indexing 615
currentTimeMillisO 378
out.printfO 124-126
out.printO 28
out. pri ntl n() 28
Tab character 19
Taylorseries 63,83,194
Terminal application 4
Text editor 4,5
Text processing
SeeStringprocessing
thi s reference 433
Throw an exception 446
Tilde notation 478
Timing a program 378-379
toStringO method
automatically invoked 359
inherited from Object 438
with binary trees 629
with graphs 658
with linked lists 561
with reference types 322
Towers of Hanoi 260-264
Trace
changein variables17
function call 204
Transition matrix 164
Transitive closure 691
Traversal
inorder 628
level-order 641
postorder 628
preorder 628

712
Tree
V
SeealsoBinarysearch tree
SeealsoBinarytree
Variable
function call 261
argument 374
H-tree 268
defined 15
true literal 25
global245,405
Truth table 25
instance 372,374
Turing, Alan 399
local 374
Turing machine 151
scope of 56,374
Turtle graphics 382-389
static 245,405
Twenty questions 128-129,512
visibilityof 372
Two-dimensional array
Variance 236
102-110
Vector 88
column-major order 105
dot product 88,200
initialization 102
sparse 645
input and output 229
spatial430-433
memory representation 103
Vector API 431,721
memory usage 493
Vector image 329
ragged 106
Visibility modifier 372
row-major order 105
void literal 10,30,207
Type.SeeData type
von Neumann, John 531
Type conversion
auto-boxing 569
w
auto-unboxing 569
objects 322
primitive type to Stri ng 18
Watts, Duncan 650
Weighing an object 518
promotion 32
Stri ng to primitive type 30
Type parameter 569
while loop 49-54
Whitespace 10,126,339
Wide interface 418,595,683
Worst-case 488-489
u
Wrapper type 569
Uniform distribution 43,226
x
Uninitialized variable
primitive type 35,90
Xor function 39
reference type 322
z
Unix operating system 123,134
Unreachable code 207
Zero-based indexing 89,112
Zipfs law 534
Index

Elements of Programming
Your FirstProgram
1.1.1
Hello, World
6
1.1.2
Usingacommand-line argument . 8
Built-in Types ofData
1.2.1
Stringconcatenation example. . .20
1.2.2
Integer multiplication and division 22
1.2.3
Quadratic formula
24
1.2.4
Leap year
27
1.2.5
Castingto get arandom integer. .33
Conditionals andLoops
1.3.1
Flippinga fair coin
49
1.3.2
Your firstwhile loop
51
1.3.3
Computing powers oftwo . . . . 53
1.3.4
Your first nested loops
59
1.3.5
Harmonic numbers
61
1.3.6
Newton's method
62
1.3.7
Converting to binary
64
1.3.8
Gambler's ruin simulation .
.
.
. 66
1.3.9
Factoringintegers
69
Arrays
1.4.1
Samplingwithout replacement . .94
1.4.2
Coupon collector simulation . . .98
1.4.3
Sieve of Eratosthenes
100
1.4.4
Self-avoiding random walks . . 109
Inputand Output
1.5.1
Generating a random sequence . 122
1.5.2
Interactive user input
129
1.5.3
Averaging a stream of numbers . 130
1.5.4
A simple filter
134
1.5.5
Input-to-drawing filter .... 139
1.5.6
Bouncing ball
145
1.5.7
Digital signal processing . ... 150
Case Study: Random Web Surfer
1.6.1
Computing the transition matrix 165
1.6.2
Simulating a random surfer
. . 167
1.6.3
Mixing a Markov chain
. ... 174
Functions and Modules
Static Methods
2.1.1
Newton's method (revisited) . . 186
2.1.2
Gaussian functions
195
2.1.3
Coupon collector (revisited) . . 197
2.1.4
Playthat Tune (revisited) ... 205
Libraries and Clients
2.2.1
Random number library. . . . 226
2.2.2
Array I/O library
230
2.2.3
Iteratedfunction systems. . . . 233
2.2.4
Dataanalysis library
237
2.2.5
Plotting data values in anarray . 239
2.2.6
Bernoulli trials
242
Recursion
2.3.1
Euclid's algorithm
259
2.3.2
Towers of Hanoi
262
2.3.3
Gray code
267
2.3.4
Recursive graphics
269
2.3.5
Brownian bridge
271
CaseStudy: Percolation
2.4.1
Percolation scaffolding
290
2.4.2
Vertical percolation detection.
. 292
2.4.3
Visualization client
295
2.4.4
Percolation probabilityestimate. 297
2.4.5
Percolation detection
299
2.4.6
Adaptive plot client
302

Object-Oriented Programming
Data Types
3.1.1
Charged particles
320
3.1.2
Albers squares
325
3.1.3
Luminance library
328
3.1.4
Convertingcolor to grayscale . . 331
3.1.5
Image scaling
333
3.1.6
Fade effect
335
3.1.7
Visualizing electricpotential . . 337
3.1.8
Finding genes in a genome . . . 342
3.1.9
Concatenating files
347
3.1.10
Screenscraping for stock quotes 349
3.1.11
Splitting a file
350
Creating Data Types
3.2.1
Charged-particleimplementation 375
3.2.2
Stopwatch
379
3.2.3
Histogram
381
3.2.4
Turtle graphics
384
3.2.5
Spira mirabilis
387
3.2.6
Complex numbers
393
3.2.7
Mandelbrot set
397
3.2.8
Stock account
401
DesigningData Types
3.3.1
Complexnumbers (alternate). . 421
3.3.2
Counter
425
3.3.3
Spatial vectors
432
3.3.4
Document
441
3.3.5
Similarity detection
444
Case Study: N-bodySimulation
3.4.1
Gravitational body
460
3.4.2
N-body simulation
463
Algorithms and Data Structures
Performance
4.1.1
3-sum problem
475
4.1.2
Validating a doublinghypothesis 477
Sorting andSearching
4.2.1
Binarysearch(20questions) . . 512
4.2.2
Bisection search
515
4.2.3
Binarysearch(sorted array) . . 517
4.2.4
Insertion sort
524
4.2.5
Doubling test for insertion sort . 526
4.2.6
Mergesort
528
4.2.7
Frequencycounts
533
4.2.8
Longestrepeated substring . . . 539
Stacks and Queues
4.3.1
Stackof strings (array)
554
4.3.2
Stackof strings (linked list). . . 559
4.3.3
Stackof strings (array doubling) 563
4.3.4
Generic stack
568
4.3.5
Expressionevaluation
572
4.3.6
Generic FIFO queue (linked list) 578
4.3.7
M/D/l queue simulation. . . . 583
4.3.8
Load balancing simulation . . . 591
Symbol Tables
4.4.1
Dictionary lookup
614
4.4.2
Indexing
617
4.4.3
BSTsymbol table
625
4.4.4
Dedup filter
633
Case Study: Small World
4.5.1
Graph data type
657
4.5.2
Using a graph to invertan index. 661
4.5.3
Shortest-paths client
665
4.5.4
Shortest-paths implementation . 670
4.5.5
Small-world test
677
715

public class System.out/StdOut/Out
Out(String name)
void print(String s)
void
println(String s)
void
pri ntl n()
void
printf(String f,
.
)
create outputstreamfrom name
print s
prints, followed bynewline
print a new line
formattedprint
Note: Methods are static and constructor does not applyfor System.out/StdOut.
public class Math
double abs(double a)
absolute value ofa
double max(double a, double b)
maximum ofaand b
double min(double a, double b)
minimum ofaand b
Note 1: abs (), max(), andmi n() are defined alsofori nt, 1ong, andfloat.
double sin(double theta)
sinefunction
double cos(double theta)
cosinefunction
double tan (double theta)
tangentfunction
Note2:Angles areexpressed in radians. Use toDeg rees () andtoRadi ans () toconvert.
Note 3:Use asi n(), acos (), andatan () forinversefunctions.
double
exp(double a)
double
log(double a)
double
pow(double a, double b)
long
round(double a)
double
randomO
double
sqrt(double a)
double
E
double
PI
exponential (ea)
natural log(loge a, orIn a)
raise a to thebthpower(ab)
round tothe nearest integer
random numberin [0,1)
square rootofa
valueofe (constant)
valueofTT (constant)

public class Stdln/In
In(String name)
boolean
isEmptyO
int
readlntO
double
readDouble()
long
readLongO
boolean
readBoolean()
char
readCharO
Stri ng
readStri ng()
String
readLineO
String
readAHO
Note:Methods arestaticand constructor does notapplyfor
create inputstreamfrom name
true if nomorevalues, else fal se
reada valueoftype i nt
reada valueoftype doubl e
reada valueoftype long
reada valueoftype bool ean
reada valueof type char
reada valueoftype Stri ng
readtherestof theline
readtherestof the text
Stdln.
public class String
String(String s)
int
length()
char
charAt(int i)
String
substring(int i, int j)
boolean
contains(String sub)
boolean
startsWith(String pre)
boolean
endsWith(String post)
int
indexOf(String p)
int
indexOf(String p, int i)
String
concat(String t)
int
compareTo(String t)
String
replaceAll(String a, String b)
String[]
split (String delim)
boolean
equals(String t)
create a stringwith thesamevalueas s
stringlength
i th character
i th through (j-l)st characters
does string contain sub asa substring?
does string startwith pre?
does stringendwith post?
indexoffirstoccurrence ofp
index offirst occurrence ofp after i
thisstringwith t appended
stringcomparison
result ofchanging as to bs
strings between occurrences o/del i m
isthis string's value thesame ast's?

718
public class StdDraw/Draw
Draw()
create anew Draw object
void
line(double xO, double yO, double xl, double yl)
void
point(double x,
double y)
void
text(double x,
double y, String s)
void
circle(double x, double y, double r)
void
filledCircle(double x,
double y,
double r)
void
square(double x,
double y,
double r)
void
filledSquare(double x, double y,
double r)
void
polygon (doubled x,
doubl e[] y)
void
filledPolygon(double[] x, double[] y)
void
setXscale(double xO, double xl)
void
setYscale(double yO, double yl)
void
setPenRadius(double r)
void
setPenColor(Color c)
void
setFont(Font f)
void
setCanvasSize(int w, int h)
void
clear(Color c)
void
show(int dt)
void
save(String filename)
Note: Methods are static and constructor does not applyfor StdDraw.
APIs
resetx range to(x0, xt)
resety range to (y0, yx)
setpen radiusto r
setpen colorto c
settextfont tof
setcanvas tow-by-hwindow
clear the canvas; color it c
showall;pausedt milliseconds
save toa . j pg or . pngfile
public class StdAudio
void
pi ay(String file)
void
pi ay(double[] a)
void
pi ay(double x)
void
save(String file, double[] a)
double[]
read(String file)
playthe given .wastfile
playthegiven sound wave
playsamplefor 1/44100 second
savetoa .wavfile
readfrom a .wavfile

public class StdRandom
int
uniform(int N)
integer between 0 andN-l
double
uniform(double lo, double hi)
real between lo and hi
719
boolean
bernoulli(double p)
double
gaussianO
double
gaussian(double m, double s)
int
discrete(double[]
a)
void
shuffle(double[] a)
true with probability p
normal mean 0, standard deviation 1
normal mean m, standard deviation s
i withprobability a [i ]
randomly shuffle thearray a []
public class StdArraylO
double[]
readDoublelD()
double[][]
readDouble2D()
void
print (doubl e[] a)
void
print(double[] [] a)
read a one-dimensional array ofdoubl e values
read a two-dimensional array o/doubl e values
printaone-dimensional array o/doubl e values
print a two-dimensional array o/doubl e values
Note 1.IDformat isaninteger Nfollowed byN values.
Note 2.2Dformat istwo integers Mand Nfollowed byMxNvalues in row-major order.
Note 3.Methodsfori nt and bool ean are also included.
public class StdStats
double
max(double[] a)
double
min(double[] a)
double
mean(double[] a)
double
var(double[] a)
double
stddev(double[] a)
double
median (doubled
a)
void
piotPoints(double[] a)
void
piotLines(double[] a)
void
piotBars(doubled a)
largest value
smallest value
average
sample variance
sample standard deviation
median
plotpoints at (i, a[i ] )
plotlines connecting (i, a [i ] )
plotbars topoints at (i, a [i ] )
Note: overloaded implementations are includedforallnumeric types

720
public class Picture
Picture(String name)
Picture(int w, int h)
int
width()
int
heightO
Color get(int i, int j)
void set(int i, int j, Color c)
void
show()
void
save(String name)
public class Stopwatch
create apicturefromafile
create a blank w-by-h picture
return thewidth ofthepicture
return theheight ofthepicture
return thecolor ofpixelft j)
setthecolor ofpixelft j) toc
display theimage ina window
save theimage toafile
APIs
Stopwatch()
double
elapsedTi me()
create a new stopwatch andstart it running
return theelapsed timesince creation, in seconds
public class Histogram
Hi Stog ram(int N)
create adynamic histogramfor the Ninteger values in [0, N)
double
addDataPoint(int i)
add an occurrence ofthe value i
public class Turtle
Turtle(double xO, double yO, double aO)
createan^turtkat(X(,y0)facinga0
degrees counterclockwisefrom x-axis
void
turnLeft(double delta)
void
goForward(double step)
rotate del ta degrees counterclockwise
move distance step, drawing a line

721
public class Counter
Counter(String id, int max)
void
incrementO
int
valueO
String
toStringO
create a counter, initialized to 0
increment counter unless its value is max
return thevalueofthecounter
stringrepresentation
public class Complex
Complex(double real, double imag)
Complex
pi us(Complex b)
Complex
times(Complex b)
double
abs()
double
re()
double
im()
String
toStringO
sumofthisnumber and b
product ofthis number andb
magnitude
realpart
imaginarypart
stringrepresentation
public class Vector
Vector(double[]
a)
Vector
pi us(Vector b)
Vector
minus(Vector b)
Vector
times(double t)
double
dot(Vector
b)
double
magnitudeO
Vector
di rection()
double
cartesian(int i)
String
toStringO
create a vector withthegiven Cartesian coordinates
sumofthisvector and b
difference ofthis vector andb
scalarproduct ofthis vector andt
dotproduct ofthis vector andb
magnitude ofthisvector
unit vector with same direction as this vector
i thcartesian coordinate of thisvector
stringrepresentation

722
public class Stack<Item>
Stack<Item>
boolean
isEmptyO
void
push(Item item)
Item
pop()
public class Queue<Item>
Queue<Item>()
boolean
isEmptyO
void
enqueue(Item item)
Item
dequeueO
int length()
create an emptystack
is thestack empty?
pushan itemonto thestack
popthestack
create an empty queue
is thequeue empty?
enqueuean item
dequeue an item
queue length
public class ST<Key extends Comparable<Key>, Value>
APIs
ST()
void put(Key key, Value v)
Value
get(Key key)
boolean
contains(Key key)
create a symboltable
putkey-valuepairintothetable
return valuepaired with key, nul 1 ifkey notin table
isthere a valuepaired with key?
public class SET<Key extends Comparable<Key»
SET()
createa set
bool ean i sEmpty()
is the set empty?
void
add (Key key)
add key tothe set
boolean
contains (Key key)
iskey in the set?

public class Graph
Graph()
Graph(In in, String delim)
void
addEdge(String v, String w)
int
V()
int
EC)
Iterable<Stri ng> vertices()
Iterable<String>
adjacentTo(String v)
int
degree(String v)
boolean
hasVertex(String v)
boolean
hasEdge(String v, String w)
public class PathFinder
PathFinder(Graph G, String s)
int
distanceTo(String v)
Iterable<String>
pathTo(String v)
723
create an empty graph
readgraphfrom inputstream
add edgev-w
numberofvertices
numberofedges
verticesin thegraph
neighbors o/v
numberofneighbors o/v
is v a vertexin thegraph?
isv-w an edgein thegraph?
createan objectthat
finds pathsinQfroms
length ofshortestpath
from s to v in G
shortestpath
from s to v in G

Introductory Programming in Java™/ Programmingfor Scienceand Engineering
Engage with Applications
"The authors lead with science and applications, andshow how thelanguage is the tool.
This is how introductory programming should betaught.. .interesting from the start."
—Ted PawlicW, University of Rochester
Introduction to Programming in Java: An Interdisciplinary Approach is a solid introduc
tion to Javaprogramming that emphasizes its application in familiar scenarios, such
as physical and biological science, engineering, and commercial computing. These
real-world explorations foster a foundation of computer science concepts and pro
gramming skillswhile illustrating the broad reach of computation.
This bookissuitable for any student who has a general interest in science and engi
neering, including computer science students. Computer science majors will find
thatthe book's scientific approach prepares them for advanced concepts later in
the curriculum. Science and engineering majors will learn basic programming ina
modern programming environment, which they can then apply to later courses in
their chosen major. Most importantly, students will leam that computation is an
integral part of the modern scientific world.
Highlights:
I Familiar applications from high school mathematics and science help students
leam basic computer science concepts and help them appreciate that program
ming is fundamental to scientific research.
"Objects in the middle" approach teaches students basic control structures and
functions and men instructs them how to use, create, and design classes.
Full programming model includes standard libraries for input, graphics, sound,
and image processing that students can apply and use from the very beginning
of their coursework.
Integrated Companion Website features extensive Java coding examples,
additional exercises, and links to associated Web materials, available at
www.aw.com/SedgewickWayne.
Visit www.aw.com/computing formore information about
Addison-Wesley computing books. To order any of our products,
contact ourcustomer service department at (800) 824-7799 or
(201) 767-5021 outside of the U.S., orvisit your campus bookstore.
Leading Authors • Quality Products
ISBN-13: 978-0-321-49805-2
ISBN-10:
0-321-49805-4
9
0
0
0
0
78032 1"498052

