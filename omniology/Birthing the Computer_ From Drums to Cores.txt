
Birthing the Computer 


Birthing the Computer: 
From Drums to Cores 
By 
Stephen H. Kaisler 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Birthing the Computer: From Drums to Cores 
 
By Stephen H. Kaisler 
 
This book first published 2017  
 
Cambridge Scholars Publishing 
 
Lady Stephenson Library, Newcastle upon Tyne, NE6 2PA, UK 
 
British Library Cataloguing in Publication Data 
A catalogue record for this book is available from the British Library 
 
Copyright © 2017 by Stephen H. Kaisler 
 
All rights for this book reserved. No part of this book may be reproduced, 
stored in a retrieval system, or transmitted, in any form or by any means, 
electronic, mechanical, photocopying, recording or otherwise, without 
the prior permission of the copyright owner. 
 
ISBN (10): 1-4438-8511-8 
ISBN (13): 978-1-4438-8511-9 

This volume is dedicated to my mother, Dolores, and to my wife, Chryl, 
who have supported this endeavor – each in her own way. Their 
forbearance allowed me to work on the multiple volumes in this series 
concurrently. My children, Rebecca and John, both put up with dad’s 
passion for documenting historical computing machines. And, the family 
cats – Annie, now deceased, and Izzy, Scooby and Tatiana – have all taken 
turns at sentry duty lying behind my keyboards and ensuring that I worked 
diligently. 


TABLE OF CONTENTS
List of Figures........................................................................................... xvi 
List of Tables ............................................................................................ xix
Acknowledgement .................................................................................. xxiii 
Introduction ............................................................................................ xxiv
Part I: Magnetic Drum Machines ............................................................ 1
Chapter One ................................................................................................. 3
IBM 650 Magnetic Drum Calculator
1.1 650 System Architecture .................................................................. 4
1.1.1 Magnetic Drum Memory ......................................................... 5
1.1.2 Arithmetic Unit ....................................................................... 7
1.1.3 IBM 650 Self-Checking .......................................................... 8
1.1.4 IBM 650 Console .................................................................. 10
1.1.5 Magnetic Tape Units ............................................................. 11
1.1.6 IBM 652 Control Unit ........................................................... 11
1.1.7 IBM 653 High-Speed Core Storage Unit .............................. 11
1.1.8 IBM 407 Accounting Machine .............................................. 12
1.2 IBM 650 Instruction Set ................................................................. 12
1.2.1 I/O Instructions ...................................................................... 13
1.2.2 Arithmetic Instructions .......................................................... 13
1.2.3 Shifting Instructions .............................................................. 15
1.2.4 Branching Instructions .......................................................... 15
1.2.5 Table Lookup Instruction ...................................................... 16
1.2.6 Miscellaneous Instructions .................................................... 16
1.2.7 Index Accumulator Instructions ............................................ 17
1.2.8 Index Accumulator Operations Instructions .......................... 17
1.2.9 Floating Point Instructions .................................................... 18
1.2.10 IAS Instruction .................................................................... 19
1.3 IBM 650 Programming .................................................................. 20
1.4 Symbolic Assembly ....................................................................... 21
1.5 IBM 650 RAMAC ......................................................................... 22
1.6 IBM 650 Assessment ..................................................................... 23

Table of Contents 
viii
Chapter Two .............................................................................................. 25
Royal McBee/Librascope Machines
2.1 LGP-30 System Architecture ......................................................... 27
2.2 LGP-30 Instruction Set .................................................................. 28
2.3 The Story of Mel ............................................................................ 30
2.4 LGP-30 Assessment ....................................................................... 34
2.5 The LGP-21 ................................................................................... 34
2.5.1 LGP-21 System ..................................................................... 35
2.5.2 LGP-21 Memory ................................................................... 36
2.5.3 LGP-21 Control Registers ..................................................... 37
2.6 LGP-21 Instruction Set .................................................................. 39
2.7 Timing and Optimization ............................................................... 41
2.8 LGP-21 Assessment ....................................................................... 41
Chapter Three ............................................................................................ 44
Bendix G Machines
3.1 Bendix G-15 ................................................................................... 44
3.2 G-15 System Configuration ........................................................... 50
3.2.1 Short Lines ............................................................................ 51
3.2.2 Registers ................................................................................ 51
3.2.3 Command Lines .................................................................... 52
3.2.4 I/O System ............................................................................. 52
3.3 G-15 Instruction Set ....................................................................... 53
3.3.1 Special Values for S/D Fields................................................ 54
3.3.2 Special Instructions ............................................................... 54
3.4 Peripheral Devices ......................................................................... 56
3.4.1 Magnetic Tape MTA-2 .......................................................... 56
3.4.2 Digital Differential Analyzer DA-1 ....................................... 57
3.4.3 Graph Plotter PA-3 ................................................................ 57
3.4.4 Punched Card Coupler CA-1/CA-2 ....................................... 57
3.4.5 Universal Code Accessory AN-1 .......................................... 58
3.5 Programming Languages ............................................................... 58
3.5.1 ALGO .................................................................................... 58
3.5.2 Intercom 1000 ....................................................................... 61
3.5.3 Sample G-15 Program ........................................................... 66
3.6 Tracking Station Application ......................................................... 67
3.7 G-15 Assessment ........................................................................... 68
Further Reading ......................................................................................... 69
Exercises for the Reader ............................................................................ 70

Birthing the Computer: From Drums to Cores 
ix
Part II: Core Memory Machines ............................................................ 73
 
Chapter Four .............................................................................................. 77
RCA BIZMAC I/II
4.1 BIZMAC System Architecture ...................................................... 81
4.2 BIZMAC I/O System ..................................................................... 83
4.3 Data Representation ....................................................................... 84
4.4 BIZMAC Instruction Set ................................................................ 84
4.5 BIZMAC Assessment .................................................................... 85
 
Chapter Five .............................................................................................. 86
Ferranti Atlas
5.1 Atlas System Architecture ............................................................. 89
5.1.1 Central Processor ................................................................... 89
5.1.2 Program Control .................................................................... 90
5.1.3 Storage Hierarchy .................................................................. 91
5.1.4 Virtual Storage ...................................................................... 92
5.2 Peripherals ..................................................................................... 94
5.3 Atlas Instruction Set ....................................................................... 94
5.3.1 Floating Point Arithmetic Instructions .................................. 96
5.3.2 Indexing Operations .............................................................. 97
5.3.3 Atlas Branching Instructions ................................................. 98
5.3.4 Atlas Shifting Instructions ..................................................... 99
5.3.5 Atlas Odd/Even test Instructions ........................................... 99
5.3.6 Atlas B-test Register Instructions ........................................ 100
5.3.7 Atlas Instruction Example ................................................... 100
5.4 Atlas Programming ...................................................................... 101
5.5 The Atlas Supervisor .................................................................... 102
5.5.1 Structure of the Atlas Supervisor ........................................ 103
5.5.2 Job Structure ........................................................................ 105
5.5.3 Programs ............................................................................. 106
5.5.4 Process Control ................................................................... 106
5.5.5 Interrupt Handling ............................................................... 107
5.5.6 Atlas Supervisor Assessment .............................................. 108
5.6 Atlas 2 .......................................................................................... 108
5.6.1 Atlas 2 Central Processor .................................................... 109
5.6.2 Atlas 2 Memory ................................................................... 110
5.6.3 Magnetic Tape ..................................................................... 112
5.6.4 Magnetic Disc Files ............................................................. 113
5.7 The Atlas 2 Supervisor ................................................................. 113
5.7.1 Interrupt Routines ................................................................ 114

Table of Contents 
x
5.7.2 Supervisor Extracode Routines ........................................... 115
5.7.3 Extended Interrupt Routines ................................................ 116
5.7.4 Object Programs .................................................................. 116
5.7.5 Error Conditions .................................................................. 117
5.8 Atlas Assessment ......................................................................... 117
Chapter Six .............................................................................................. 120
JOHNNIAC
6.1 JOHNNIAC System Architecture ................................................ 122
6.2 JOHNNIAC System Configuration ............................................. 123
6.3 JOHNNIAC Instruction Set ......................................................... 124
6.3.1 Conditional Transfer Orders ................................................ 124
6.3.2 Transfer Orders ................................................................... 125
6.3.3 Add Orders .......................................................................... 126
6.3.4 Multiply Operations ............................................................ 127
6.3.5 Division Orders ................................................................... 129
6.3.6 Store Orders......................................................................... 130
6.3.7 Register Movement Orders ................................................. 130
6.3.8 Shift Orders ......................................................................... 131
6.3.9 Input/Output Orders ............................................................ 132
6.3.10 Drum Orders ...................................................................... 133
6.3.11 Logical Product Orders ..................................................... 134
6.3.12 Control Orders ................................................................... 134
6.4 JOHNNIAC Operation................................................................. 135
6.5 JOSS ............................................................................................ 136
6.5.1 JOSS Structure .................................................................... 137
6.5.2 JOSS Remote Console ......................................................... 138
6.5.3 JOSS Implementation .......................................................... 139
6.6 JOHNNIAC Assessment .............................................................. 140
Further Reading ....................................................................................... 141
Exercises for the Reader .......................................................................... 143
Part III: Transistor Machines .............................................................. 145
Chapter Seven .......................................................................................... 147
UNIVAC Solid State Computer
7.1 Solid State Computer Architecture .............................................. 148
7.1.1 SSC Central Processor......................................................... 152
7.1.2 Magnetic Drum ................................................................... 153

Birthing the Computer: From Drums to Cores 
xi
7.1.3 Operator’s Console .............................................................. 154
7.2 SSC80/SSC90 Instructions .......................................................... 155
7.2.1 Executing an Instruction ...................................................... 156
7.2.2 Arithmetic Instructions ........................................................ 156
7.2.3 Transfer Instructions............................................................ 156
7.2.4 Logical and Shift Instructions ............................................. 157
7.2.5 Comparison Instructions ...................................................... 157
7.2.6 Translate Instructions .......................................................... 158
7.2.7 SS80 Printer Control Instructions ........................................ 158
7.2.8 Card Reader Control Instructions ........................................ 158
7.3 SSC Peripherals ........................................................................... 159
7.4 Solid State Computer System Software ....................................... 160
7.4.1 FLOW-MATIC ................................................................... 160
7.5 SSC Assessment .......................................................................... 161
Chapter Eight ........................................................................................... 162
UNIVAC 418
8.1 UNIVAC 418-I ............................................................................ 163
8.2 UNIVAC 418 System Architecture ............................................. 163
8.3 Instruction Format ........................................................................ 163
8.3.1 Type I Instructions .............................................................. 164
8.3.2 Type II Instructions ............................................................. 164
8.3.3 Type III Instructions ............................................................ 165
8.4 System Software .......................................................................... 165
8.5 UNIVAC 418-II ........................................................................... 165
8.6 UNIVAC 418-III .......................................................................... 166
8.6.1 UNIVAC 418-III System Architecture ................................ 167
8.6.2 Command/Arithmetic Unit (CAU) ...................................... 168
8.6.3 Main Storage ....................................................................... 169
8.6.4 I/O Modules (IOMs) ............................................................ 170
8.6.5 Magnetic Drums .................................................................. 173
8.6.6 Attached Processors ............................................................ 174
8.6.7 Communications Systems ................................................... 174
8.6.8 Unit Record Peripherals ...................................................... 175
8.7 UNIVAC 418 System Software ................................................... 175
8.7.1 RTOS Executive .................................................................. 176
8.7.2 Programming Languages ..................................................... 181
8.7.3 System Applications ............................................................ 182
8.8 UNIVAC 418-III Application ...................................................... 183
8.8 UNIVAC 418 Assessment ........................................................... 183 

Table of Contents 
xii
Chapter Nine ............................................................................................ 185
UNIVAC 490/494
9.1 UNIVAC 494 ............................................................................... 187
9.1 System Architecture ..................................................................... 188
9.1.1 Central Processor ................................................................. 189
9.1.2 Memory ............................................................................... 191
9.1.3 I/O System ........................................................................... 191
9.1.4 Communications Handling .................................................. 193
9.1.5 Transfer Switch ................................................................... 194
9.2 Instruction Set .............................................................................. 195
9.2.1 Shift Instructions ................................................................. 197
9.2.2 UNIVAC 494 Transfer Instructions .................................... 199
9.2.3 Arithmetic Instructions ........................................................ 201
9.3.4 Logical Instructions ............................................................. 203
9.3.5 Comparison Instructions ...................................................... 204
9.3.6 Jump Instructions ................................................................ 205
9.3.7 Sequence Modifying Instructions ........................................ 206
9.3.8 I/O Instructions .................................................................... 207
9.3 Peripherals ................................................................................... 208
9.3.1 Magnetic Drums .................................................................. 209
9.3.2 Magnetic Tape Subsystem ................................................... 210
9.3.3 Operator’s Console .............................................................. 210
9.3.4 High-Speed Printer Subsystem ............................................ 210
9.4 UNIVAC 490/494 System Software ............................................ 211
9.4.1 Primary Input Stream .......................................................... 211
9.4.2 Input Cooperative ................................................................ 211
9.4.3 Programming Languages ..................................................... 212
9.5 UNIVAC 490/494 Assessment .................................................... 212
Chapter Ten ............................................................................................. 214
MIT’s TX-0
10.1 TX-0 System Architecture ......................................................... 217
10.1.1 TX-0 Registers .................................................................. 217
10.1.2 Toggle Switch Storage ...................................................... 218
10.1.3 Main Memory .................................................................... 218
10.2 TX-0 Instructions ....................................................................... 218
10.2.1 TX-0 Operate Instructions ................................................. 219
10.2.2 Combining Instructions ..................................................... 220
10.2.3 Modified Instruction Set .................................................... 222
10.3 Operating Modes ........................................................................ 223
10.4 TX-0 I/O Equipment .................................................................. 224

Birthing the Computer: From Drums to Cores 
xiii 
10.5 FLIT ........................................................................................... 224
10.6 TX-1 ........................................................................................... 225
10.7 TX-2 ........................................................................................... 225
10.7.1 TX-2 System Architecture ................................................. 226
10.8 TX-0 and TX-2 Assessment ....................................................... 227
Chapter Eleven ........................................................................................ 229
Philco Ford computers
11.1 Philco 1000 ................................................................................ 230
11.1.1 Philco 1000 Central Processor ........................................... 231
11.1.2 Philco 1000 System Architecture ...................................... 232
11.1.3 Instruction Set ................................................................... 232
11.2 Philco TRANSAC S-2000 ......................................................... 233
11.3 TRANSAC S-2000 System Architecture ................................... 238
11.3.1 Secondary Memory ........................................................... 239
11.4 TRANSAC S-2000 Instruction Set ............................................ 240
11.4.1 Program Control ................................................................ 241
11.4.2 Instruction Control ............................................................ 241
11.4.3 Algorithm Control ............................................................. 241
11.4.4 Floating Point Control ....................................................... 242
11.4.5 Memory Cycle Control ...................................................... 242
11.5 Philco 212 .................................................................................. 242
11.5.1 Control Unit ....................................................................... 245
11.5.2 Instruction Unit ................................................................. 245
11.5.3 Index Unit .......................................................................... 246
11.5.4 Arithmetic Unit ................................................................. 247
11.5.5 Store Unit .......................................................................... 248
11.5.6 I/O Subsystem ................................................................... 248
11.5.7 Real-Time System ............................................................. 249
11.5.8 Philco 212 Instruction Set ................................................. 250
11.6 Operating System 32KSYS ........................................................ 265
11.7 TRANSAC S-2000 Software ..................................................... 266
11.8 Philco 2400 Input/Output System .............................................. 269
11.8.1 Philco 2400 System Architecture ...................................... 270
11.8.2 Executive Control .............................................................. 271
11.8.3 Program Control ................................................................ 272
11.8.4 Arithmetic Element ........................................................... 273
11.8.5 Main Memory .................................................................... 273
11.8.6 Operator Control Panel ...................................................... 274
11.8.7 Philco 2400 Instruction Set ............................................... 275
11.8.8 I/O Operations ................................................................... 275

Table of Contents 
xiv
11.8.9 Internal Operations ............................................................ 279
11.8.10 Arithmetic Operations ..................................................... 284
11.8.11 Philco 2400 I/O Devices .................................................. 287
11.9 Assessment of the Philco Machines ........................................... 287
Chapter Twelve ....................................................................................... 289
Bendix G-20
12.1 Bendix G-20 System Architecture ............................................. 289
12.1.1 Arithmetic Unit ................................................................. 292
12.1.2 Registers ............................................................................ 292
12.1.3 Core Memory .................................................................... 293
12.1.4 Interrupts ........................................................................... 293
12.2 Instruction Set Architecture ....................................................... 294
12.2.1 Add/Subtract Operations and Tests ................................... 294
12.2.2 Logic Operations and Tests ............................................... 296
12.2.3 Repeated Commands ......................................................... 297
12.2.4 Multiply/Divide ................................................................. 298
12.2.5 Storage Operations ............................................................ 298
12.2.6 Index Operations ............................................................... 299
12.2.7 Control Operations ............................................................ 299
12.2.8 I/O Operations ................................................................... 300
12.2.9 Bus Register Operations .................................................... 301
12.3 I/O System ................................................................................. 302
12.4 G-21 Dual Processor .................................................................. 302
12.4.1 G-21 Software ................................................................... 303
12.5 Bendix G-20 Assessment ........................................................... 303
Chapter Thirteen ...................................................................................... 304
Packard Bell
13.1 PB250 System Architecture ....................................................... 306
13.1.1 Central Processor ............................................................... 307
13.1.2 Main Memory .................................................................... 308
13.1.3 Flexowriter ........................................................................ 309
13.1.4 Other I/O Devices .............................................................. 310
13.1.5 HYCOMP 250 ................................................................... 310
13.2 PB250 Commands ..................................................................... 311
13.2.1 Class I Commands ............................................................. 312
13.2.2 Class II Commands ........................................................... 314
13.2.3 Class III Commands .......................................................... 316
13.2.4 Class IV Commands .......................................................... 316
13.2.5 Sequence Tag .................................................................... 317

Birthing the Computer: From Drums to Cores 
xv
13.3 Packard Bell 440 ........................................................................ 318
13.3.1 PB440 System Architecture .............................................. 321
13.3.2 Memory System ................................................................ 322
13.3.3 I/O System ......................................................................... 323
13.3.4 PB440 Programming ......................................................... 324
13.4 PB440 Micro Instruction Format ............................................... 325
13.5 Packard Bell Assessment ........................................................... 325
Further Reading ....................................................................................... 327
Exercises for the Reader .......................................................................... 328
Appendix A: Glossary ............................................................................. 331
References ............................................................................................... 332
Index ........................................................................................................ 340

LIST OF FIGURES
1-1. IBM 650 Magnetic Drum Computer 
1-2. IBM 650 System Architecture 
1-3. IBM 650 Magnetic Drum Assembly 
1-4. IBM 650 Magnetic Drum Arrangement  
1-5. IBM 650 Operators Console 
1-6. IBM 650 Instruction Format 
1-7. SOAP II Coding Form 
2-1. Royal McBee LGP-30 
2-2. LGP-30 Instruction Format 
2-3. LGP-30 Computer System 
2-4. General Precision LGP-21 Computer System 
2-5. LGP-21 Brochure 
2-6. LGP-21 Instruction Format 
2-7(a). Front of Optimum Address Locator 
2-7(b) Rear of Optimum Address Locator 
3-1. Bendix G-15 Computer System Advertisement 
3-2. Bendix G-15 Ad (Datamation 11-60) 
3-3. Bendix G-15 Advertisement 
3-4. Bendix G-15 installed at Naval Supersonic Laboratory at MIT 
3-5. Bendix G-15 with Operator’s Console 
3-6. Bendix G-15 Instruction Format 
3-7. Simple ALGO Program 
3-8. Bendix G-15 ALGO Programming Language 
4-1. RCA BIZMAC Used For Military Application 
4-2. RCA BIZMAC at U.S. Army Tank Automotive Command 
4-3. RCA BIZMAC II 
4-4. BIZMAC System Architecture 
4-5. RCA BIZMAC Instruction Format 
5-1. Manchester University – Atlas 1 Input Area 
5-2. The Ferranti Atlas Operator Console 
5-3. Atlas CPU Architecture 

Birthing the Computer: From Drums to Cores 
xvii
5-4. Ferranti Atlas One-level Store Concept 
5-5. Atlas Instruction Format 
5-6. Central Store Address Structure 
5-7. Sample Atlas Autocode Program 
5-8. Structure of the Atlas Supervisor 
5-9. Titan Computer 
6-1. JOHNNIAC 
6-2. JOHNNIAC System Architecture 
7-1. UNIVAC Solid State Computer 
7-2. Univac Solid State Computer Cabinet 
7-3. UNIVAC SSC90 Voltage Monitoring Panel 
7-4. UNIVAC SSC90 System Console 
7-5. UNIVAC SS90 Circuit Board with Ferractors 
7-6. SSC90 System Architecture 
7-7. UNIVAC SSC90 Operators Console 
7-8. SSC80/SSC90 Instruction Format 
7-9. Jan Lindeboom at the UNIVAC SSC90 Console 
8-1(a). UNIVAC 418 Instruction Format I/II 
8-1(b). UNIVAC 418 Instruction Format III 
8-2. UNIVAC 418-II System 12-1. Bendix G-20 
8-3. UNIVAC 418-III System Configuration 
8-4. UNIVAC 418 Interrupt Table Pointer Word Format 
9-1. UNIVAC 490 
9-2. UNIVAC 490 System 
9-3. UNIVAC 494 System 
9-4. UNIVAC 494 System Architecture 
9-5. UNIVAC 404 BCW Format 
9-6. UNIVAC 494 Cascade System 
9-7. UNIVAC 494 Instruction Format 
10-1. TX-0 Computer Room 
10-2. TX-0 at MIT 
10-3. TX-2 System Architecture 
11-1. Philco 1000 Central Processing Unit Structure 
11-2. Transac S-1000 Instruction Format 
11-3. Philco S-2000 Advertisement 

List of Figures 
xviii
11-4. Philco Transac S-2000 Advertisement 
11-5. Philco 210 System 
11-6. Philco S-2000 Computer System 
11-7. TRANSAC 2000 Operator Control Panel 
11-8. TRANSAC S-2000 Repeat Register Format 
11-9. TRANSAC S-2000 Instruction Address Format 
11-10. Philco 212 Advertisement 
11-11. Philco 212 System Configuration 
11-12. Philco 212 Central Processor 
11-13. TIO Data Format 
11-14. Philco 212 Real-Time Order Format 
11-15. Philco 212 Instruction Format 
11-16. Philco 212 Address Field Format 
11-17. DR instruction for Repeating Four Instructions 
11-18. ALTAC Translation Process 
11-19. Philco ALTAC Advertisement 
11-20. Philco 2400 System Architecture 
11-21. Philco 2400 Operator Control Panel 
11-22. Philco 2400 Instruction Format 
12-2. Bendix G-20 System Architecture 
12-3. Bendix G-20 Computer System Advertisement 
12-4 Bendix G-20 Instruction Format 
12-5. Repeat Command Instruction Format 
12-6. Block Transfer Instruction Format  
12-7. Bendix G-20 Bus Register Layouts 
13-1. Packard Bell 250 
13-2. Packard Bell 250 Front Panel 
13-3. Packard Bell 250 System Architecture 
13-4. PB250 Machine Sector Counter 
13-5. Flexowriter Console 
13-6. Packard Bell 250 Command Format 
13-7. Packard Bell 440 
13-8. PB440 Operator Console 
13-9. PB440 Advertisement 
13-10. Packard-Bell 440 System Architecture 
13-11. Packard Bell 440 Memory System 
13-12. Use of a Memory Interchange Unit 

LIST OF TABLES
1-1 IBM 650 – Basic Characteristics 
1-2. Self-Checking Techniques 
1-3. IBM 650 I/O Instructions 
1-4. IBM 650 Arithmetic Instructions 
1-5. IBM 650 Shifting Instructions 
1-6. IBM 650 Branching Instructions 
1-7. IBM 650 Table Lookup Instruction 
1-8 IBM 650 Miscellaneous Instructions 
1-9. IBM 650 Index Accumulator Instructions 
1-10. IBM 650 Index Accumulator Instructions 
1-11. IBM 650 Floating Point Instructions 
1-12. IBM 650 IAS Timing Ring Instruction 
1-13. IBM 650 IAS Multiple Word Transfer Instructions 
2-1. LGP-30 Characteristics 
2-2. LGP-30 Instruction Set 
2-3. LGP-21 Characteristics 
2-4. LGP-21 Instruction Set 
3-1. Bendix G-15 Characteristics 
3-2. Register Roles in Multiplication and Division 
3-3. Special Values for S/D Fields 
3-4. Special Instructions 
3-5. Intercom 1000 Commands 
3-6. Sample G-15 Intercom 1000 Program to add Two Numbers 
3-7. Sample G-15 Intercom 1000 Program to compute (a2 – bc)/d 
4-1. RCA BIZMAC Basic Characteristics 
5-1. Atlas – Basic Characteristics 
5-2. Floating Point Arithmetic Instructions 
6-1. JOHNNIAC Characteristics (Weik 1961) 
6-2. Conditional Transfer Orders 
6-3. Transfer Orders 

List of Tables 
xx
6-4. Add Operations 
6-5. Multiply Operations 
6-6. Division Operations 
6-7. Store and Substitute Operations 
6-8. Register Movement Operations 
6-9. Shift Operations 
6-10. Input/Output Operations 
6-11. Drum Operations 
6-12. Logical Product Operations 
6-13. Control Operations 
6-14. Sample JOSS Program 
7-1. Solid State 80 – Basic Characteristics 
7-2. SS80 Arithmetic Instructions 
7-3. SS80 Transfer Instructions 
7-4. SS80 Logical and Shift Instructions  
7-5. SS80 Comparison Instructions 
7-6. SS80 Translate Instructions 
7-7. SS80 Print Instructions 
7-8. SS80 Card Reader Instructions 
8-1. UNIVAC 418 Basic Characteristics 
8-2. UNIVAC 418-III – Basic Characteristics 
8-3. Magnetic Drum Systems 
8-4. Mass Storage Systems 
9-1. UNIVAC 490/494 Basic Characteristics 
9-2. UNIVAC 490/494 Registers 
9-3. UNIVAC 494 I/O Registers 
9-4. Special Interpretation of j Designators for Selected Instructions 
9-5. UNIVAC 494 Shift Instructions 
9-6. UNIVAC 494 Transfer Instructions 
9-7. k Field Modification to Enter Bj 
9-8. UNIVAC 494 Integer Arithmetic Instructions 
9-9. UNIVAC 494 Floating Point Arithmetic Instructions 
9-10. UNIVAC 494 Decimal Arithmetic Instructions 
9-11. Decimal Test Conditions 
9-12. UNIVAC 494 Logical Instructions 
9-13. UNIVAC 494 Comparison Instructions 
9-14. UNIVAC 494 Jump Instructions 

Birthing the Computer: From Drums to Cores 
xxi
9-15. UNIVAC 494 Jump Instructions 
9-16. UNIVAC 494 I/O Instructions 
9-17. Magnetic Drum Systems 
9-18. Mass Storage Systems 
9-19. UNISERVO Magnetic Tape Subsystems 
10-1. TX-0 Basic Characteristics 
10-2. TX-0 Machine Registers 
10-3. Operate Instructions 
10-4. Useful Combinations of Operate Commands 
10-5. Operating Modes 
10-6. TX-2 – Basic Characteristics 
11-1. Philco 1000 Basic Characteristics 
11-2. TRANSAC S-2000 Basic Characteristics 
11-3. TRANSAC S-2000 Processor Registers 
11-4. Effective Address Calculation 
11-5. Philco 212 Addressable Registers 
11-6. Control Bits for Indirect Addressing 
11-7. Philco 212 ADD Instructions 
11-8. Philco 212 SUBTRACT Instructions 
11-9. Philco 212 MULTIPLY Instructions 
11-10. Philco 212 DIVIDE Instructions 
11-11. Philco 212 CLEAR Instructions 
11-12. Philco 212 TRANSFER Instructions 
11-13. Philco 212 JUMP Instructions 
11-14. Philco 212 SHIFT Instructions 
11-15. Philco 212 INDEX REGISTER Instructions 
11-16. Philco 212 EXTRACT Instructions 
11-17. Philco 212 LOGIC Instructions 
11-18. Philco 212 SPECIAL Instructions 
11-19. Modifier Interpretation 
11-20. Magnetic Tape drive Assignments for 32KSYS 
11-21. Philco 2400 – Basic Characteristics 
11-22. PCU Registers 
11-23. Philco 2400 Operator Control Panel Elements 
11-24. Feed/PUNCH Instructions 
11-25. MOVE Instructions 
11-26. Card Punch Instructions 
11-27. Character Selection Instructions 
11-28. Printer Instructions 

List of Tables 
xxii
11-29. Magnetic Tape Instructions 
11-30. Setting and Moving Register Values 
11-31. Moving and Editing Data Instructions 
11-32. Code Translation Instructions 
11-33. Field Comparison Instructions 
11-34. Register Save Instructions 
11-35. Register Test Instructions 
11-36. Jump Instructions 
11-37. Increment and Decrement Instructions 
11-38. Arithmetic Operations 
11-39. Philco 2400 Conversion Instructions 
11-40. Philco 2400 Shift Instructions 
11-41. Philco 2400 Logical Instructions 
12-1. Bendix G-20 – Basic Characteristics 
12-2. Bendix G-20 Addressing Modes 
12-3. Add/Subtract Operations 
12-4. Arithmetic Test Operations 
12-5. Logic Operations 
12-6. Logic Tests 
12-7. Multiply/Divide 
12-8. Storage Operations 
12-9. Index Operations 
12-10. Transfer Operations 
12-11. I/O Operations 
12-12. Block Transfer Operations 
12-13. Bendix G-20 Bus Registers 
12-14. Bus Register Operations 
13-1. Packard Bell 250 – Basic Characteristics 
13-2. PB250 Class I Commands 
13-3. PB250 Class II Commands 
13-4. PB250 Class III Commands 
13-5. PB250 Class IV Commands 
13-6. Packard Bell 440 – Basic Characteristic 

ACKNOWLEDGEMENT
I wish to acknowledge the staff of Cambridge Scholars Publishing, 
particularly Sam Baker, the commissioning editor for the series; Ms. 
Victoria Carruthers, the Author Liaison, and Ms. Sophie Edminson, 
Design and Coordinator, for shepherding this book from initial manuscript 
through to publication.  I want to acknowledge the diligent and excellent 
work of my proofreaders, Mrs. Rebecca Williams (daughter) and Mr. Eric 
Ward, Scouting colleagues.  They have made the book immeasurably 
better through their efforts. Thank you all for help me to make this book a 
successful publication! 
.

INTRODUCTION
This volume is the second of a multiple volume set on Historical 
Computing Machines. We continue with the evolution of computing 
systems from two perspectives. First, a variety of memory systems 
evolved to provide larger, faster memories. As a consequence, computing 
machines became more capable and evolved through enhanced 
functionality. We also see the beginnings of I/O systems which allowed 
users to interact with the system, and to have persistent storage that was 
somewhat easier to use for their programs and data. 

PART I 
MAGNETIC DRUM MACHINES 
 
 
 
Pre-core memory machines relied on a variety of devices to provide 
working memory, including magnetic drums, mercury delay lines, and 
plated wires. Drum memories were one of the earliest mass storage 
devices attached to computing machines. Several variations will be 
addressed in coming chapters as auxiliary storage devices after magnetic 
disks were developed. Magnetic drums were rotating cylinders whose 
exterior surfaces were coated with a ferromagnetic material. In most early 
systems, a linear array of read/write heads was positioned along the length 
of the drum to store and retrieve bits of data by magnetizing positions on 
the drum’s surface.  
Gustav Tauschek, an Austrian national, invented the first magnetic 
drum in 1932. Early in his career, Tauschek developed several punched 
card accounting machines. In 1932, he received a US Patent, No. 1880523, 
entitled “Setting Device for Calculating Machines and the Like”, which 
clearly depicts a rotating drum on which data could be recorded. The 
patent was received for the magnetic drum. His device could record about 
500,000 bits or about 62.5 Kbytes. 
The idea of the magnetic drum was further elaborated at the Institute 
for Advanced Study (IAS) in Princeton, New Jersey in 1946 as a way to 
provide additional, easily accessible storage for the IAS machine. In the 
early 1950s, engineers at Engineering Research Associates (ERA) 
designed and developed a magnetic drum for the main memory of the 
ERA 1101 (Hill 1950, ERA UNK). Other manufacturers also designed and 
used their own magnetic drums in ‘one-off’ designs until the mid-1950s. 
By then, magnetic drums came into wide use as computer manufacturers 
developed product lines that needed highly reliable magnetic drum 
subsystems for main and auxiliary memories for their computers. Reliable, 
low-cost magnetic drums of varying capacities enabled the production of 
lower-cost reliable machines. 
In its most basic form, a magnetic drum was a cylinder coated with a 
ferromagnetic material and mounted either vertically or horizontally on a 
spinning shaft. Most magnetic drums had one head per track. The heads 

Part I 
 
2
did not move. The controller selected the head for the track where the data 
was stored and waited for the data to come under the head. However, the 
Univac FASTRAND drums had multiple moving heads which reduced 
cost but increased latency to access and transfer data. As wait time was 
due solely to the rotational latency of the drum, a number of sophisticated 
schemes were developed for early machines to optimize the placement of 
data on the drum. Knowing the time it took to load an instruction or data 
item from a particular location on the drum, the programmer could place 
the next sequential data item just at the point where the previous read 
ended and a new read could begin. 
It is interesting to note that the concept of a drum is retained in today’s 
UNIX and variant systems. /dev/drum is used to refer to the default virtual 
(swap) device. (Gloutnikov UNK) 
Part I explores a few of the magnetic drum machines. Others will be 
described in volumes associated with specific manufacturers, such as 
National Cash Register (NCR), the Consolidated Engineering Corporation 
CEC 201, which became Datatron and was bought by Burroughs, and the 
General Electric GE 210. 
 
Chapters: 
Chapter One: IBM 650 Magnetic Drum calculator 
Chapter Two: Royal McBee/Librascope 
Chapter Three: Bendix G computers 
 

CHAPTER ONE 
IBM 650 MAGNETIC DRUM CALCULATOR 
 
 
 
The IBM 650 was IBM’s first commercial computer offering. It was a 
general-purpose, stored-program computer that used a magnetic drum for 
the primary memory. Hence, it was called the Magnetic Drum Calculator. 
It evolved from IBM’s Card Programmed Calculator (CPC). Frank 
Hamilton, who designed the ASCC and SSEC, was the designer. Figure 1-
1 depicts the IBM 650. The basic characteristics of the IBM 650 are 
depicted in Table 1-1 (IBM UNKa, Weik 1961). 
 
 
 
Figure 1-1. IBM 650 Magnetic Drum Computer 
Source: IBM UNKa 
Courtesy of International Business Machines Corporation, © International 
Business Machines Corporation. 
 
 
 

Chapter One 
 
4
Table 1-1 IBM 650 – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal Representation 
Fixed Point Decimal 
# Bits/Word 
70 (10 digits of 7 bits each) plus 1 bit for sign 
#Instructions/Word 
2 
# Instructions 
42 
Instruction Type 
Two address: operand and next instruction 
CPU Technology 
Vacuum Tube 
CPU Registers 
3 Accumulators – 10 digits (Upper, Lower and 
Distributor) 
Main Memory 
Magnetic Core: 60 words 
Magnetic Drum: Basic: 2,000 words (Model 
2); 4,000 words (Model 4) 
Expanded: up to 10,000 words 
Add Time 
Fixed Point: 760 microseconds 
Multiply Time 
Fixed Point: 12 milliseconds 
Divide Time 
Fixed Point: 16.2 milliseconds 
 
Several thousand of the IBM 650s were delivered beginning in 
December 1954. This machine’s base price was approximately $182,000. 
It could also be rented for about $3,500 per month. At the time, the rental 
price was about the same as required to rent a fully loaded Cadillac from 
General Motors. 
An academic discount of about 60% made the machine available for 
$72,800. For many universities, the IBM 650 was to be their first 
computer. The academic discount was conditional on the institution 
teaching computer-related courses. IBM foresaw that a lack of computer 
professionals would hamper their ability to sell machines into markets that 
could effectively use them. IBM seeded the programming industry through 
its academic discount by encouraging the teaching of computer-related 
courses. The graduates who used IBM computers in their courses were 
more likely to become buyers of IBM computers when they entered the 
commercial marketplace. 
The last IBM 650 was sold in 1962. However, industry and universities 
continued to use these workhorse machines for over 10 more years. 
1.1 650 System Architecture 
The IBM 650 system architecture is depicted in Figure 1-2. The CPU 
consisted of three units: the accumulator, the distributor, and the adder. All 
data entering the accumulator first had to pass through the distributor and 

IBM 650 Magnetic Drum Calculator 
5 
the adder. Data going from the accumulator to general drum storage also 
passed through the distributor.  
Arithmetic operations were performed using the contents of the 
distributor and the contents of the accumulator using the adder which 
processed data one digit at a time. 
 
 
 
Figure 1-2. IBM 650 System Architecture 
Source: Adapted from Andree 1956 
1.1.1 Magnetic Drum Memory 
The IBM 650 primary memory was provided by a magnetic drum, 
which originally had 1,000 words, then 2,000 words of storage, later 
expanded to 4,000 words and then, 10,000 words. Figure 1-3 depicts the 
magnetic drum assembly. 
 
 

Chapter One 
 
6
 
 
Figure 1-3. IBM 650 Magnetic Drum Assembly 
Source: IBM 1957b 
Courtesy of International Business Machines Corporation, © International 
Business Machines Corporation. 
 
The drum had a speed of 12,500 rpm. Parallel to the axis of the drum 
were attached several inductive heads that read and wrote the information. 
The general storage portion had 2000 words where ten-digit words could 
be stored.  The word position was location by determining first one of the 
40 five-track bands, then determining the angular displacement of the 
word along the track. Figure 1-4 depicts the layout of the drum. 
 
 
 
Figure 1-4. IBM 650 Magnetic Drum Arrangement  
Source: IBM 1957b 
Courtesy of International Business Machines Corporation, © International 
Business Machines Corporation. 
 

IBM 650 Magnetic Drum Calculator 
7 
Each of the 5-track bands had tracks for bit positions 6, 3, 2, 1, and 0, 
which corresponded to the bi-quinary representation. Fifty 10-digit words 
were stored in each band. The heads were displaced in a spiral fashion 
around the drum as seen in the figure above. Six timing tracks contained 
permanently recorded spots that were used to establish the reference 
position of the drum. These spots drove timing rings that generated the 
pulses for use throughout the machine. 
Later models provided drums with greater capacity – up to 10,000 
words. Drum addresses 0000 to 7999 were used as follows. Addresses 
0000-1999 were basic drum addresses that were directly addressed. Drum 
addresses in the ranges 2000-3999, 4000-5999, and 6000-7999 were 
modified by the contents of the corresponding index register A, B, or C. 
Similarly, the CSU addresses added 200, 400, or 600 to indicate indexing 
by the appropriate index register. 
Data could be transferred to and from the Immediate Access Storage 
(IAS) in single-word or multiple word quantities. IAS addresses were in 
the range 9000 – 9059. IAS used a Timing Ring to keep track of the core 
locations. The Timing Ring was used to affect multiple word transfers. A 
single instruction was used to set the Timing Ring to any of the IAS 
locations. 
1.1.2 Arithmetic Unit 
The IBM 650 had one accumulator divided into two sections, each 10 
digits in length, called Upper and Lower. The Upper Accumulator was 
used for addition and subtraction, while the Lower Accumulator was 
considered an extension that was used for multiplication, division, and 
shifting. There was only one sign for the entire accumulator, except during 
division operations when the quotient and remainder could have different 
signs. If there was a carry beyond the Lower section during an arithmetic 
operation, the carry propagated to the Upper Section. The contents of the 
Upper section were then lost. 
Each half of the accumulator was synchronized to even or odd 
addresses since only 10 digits were read by the RD instruction. The lower 
half was synchronized to even words and the upper half was synchronized 
to odd words. So, to get a word into the lower half of the accumulator, the 
sequence of instructions would be: RD <address>, RAL <address>. Then, 
if it was loaded into the upper half, the programmer had to perform a left 
shift of 10 digits. 

Chapter One 
 
8
The Distributor, also of 10 digits, could be thought of as a cache. Any 
data retrieved from the magnetic drum passed through the Distributor. It 
held one word of ten digits and a sign. 
The one-bit Adder performed all arithmetic calculations through 
adding, complementing or shifting digits. Thus, the IBM 650 performed 
arithmetic in serial order. During addition, a single digit was fetched from 
each of the accumulator and the distributor and then added together. 
Adding two 10-digit words required ten such additions plus any carry 
propagation. 
The Program Register held the instruction to be executed. Instructions 
were fetched from the drum using the Address Register. The 2-digit 
operation code was extracted from the instruction and stored in the 
Operation Register (OR). During the Instruction Half-Cycle of processing, 
the instruction address was placed in the Address Register, while during 
the Data Half-cycle, the operand address was placed in the Address 
Register. 
The IBM 650 provided three index registers and floating-point decimal 
arithmetic operations. The addresses assigned to the index registers were 
A = 8005, B = 8006, and C = 8007.  The index registers could also be used 
as separate accumulators. An address was stored in the four low-order 
digits of the index register while the high-order six digits were zero. If the 
index register address was used in an instruction other than 00-01 and the 
shifting instructions, the contents of the index register was reset-added to 
the lower accumulator. Instructions 00-01 did not use the D field and the 
shifting instructions treated the unit's position of the address as a shift 
count of 5, 6, or 7 respectively. 
1.1.3 IBM 650 Self-Checking 
Early on, IBM realized that the quality of the vacuum tubes required 
self-checking mechanisms to detect errors and ensure that computations 
were carried out correctly. Several techniques were used as depicted in 
Table 1-2. 
 
 
 

IBM 650 Magnetic Drum Calculator 
9 
Table 1-2. Self-Checking Techniques 
Technique 
Description 
Validity 
Checking 
The bi-quinary representation allowed the validity of data 
to be easily checked. Either no binary or two binary bits 
had to be present for the binary portion of the data to be 
valid. For the quinary portion, either no binary bits or 
more than one bit were required. 
Read Check 
Data read through the card reader into the Read Buffer 
was also checked for validity. 
Output Check 
All data punched to cards went through the Output Buffer 
and was checked by the card punch. If any bits were lost 
between the (last) validity check and punching, this 
resulted in a blank column on the punch card. 
Conversely, if a bit was added between the (last) validity 
check and punching, this resulted in multiple punches 
within a column on the card. 
Control 
Checks 
The machine checked the validity of the addresses based 
on the size of the magnetic drum installed. It also 
checked the 2-digit opcode extracted from the instruction 
 
Bi-Quinary Data Representation 
The IBM 650 used a 7-bit bi-quinary notation to represent numbers: one 
bit out of 5 represented a value from zero to four; one bit out of two 
indicated whether or not to add 5 to that value, essentially an electronic 
abacus. The front panel had rows of lights in groups of five to display 
register contents. "28019" would be displayed as follows: 
 
*      o   o      *   *      o   *      o   o      * 
0  o  5   0  o  5   0  *  5   0  o  5   0  o  5 
1  o  6   1  o  6   1  o  6   1  *  6   1  o  6 
2  *  7   2  o  7   2  o  7   2  o  7   2  o  7 
3  o  8   3  *  8   3  o  8   3  o  8   3  o  8 
4  o  9   4  o  9   4  o  9   4  o  9   4  *  9 
 
The 650 did not have the ability to represent characters directly. So, it used 
a 2-digit scheme to represent characters. However, it was only able to 
represent upper-case letters and a few punctuation marks. 

Chapter One 
 
10
1.1.4 IBM 650 Console 
The IBM 650 console is depicted in Figure 1-5. A description  
of the console is found at the Columbia University website: 
http://www.columbia.edu/cu/computinghistory/650.html. 
“The bank of buttons across the top is used to control power to the 
machine. The black items are buttons, the light items are indicator lights.  
Below the power control is a row of lights for displaying ten decimal 
digits and a sign, ten columns 7 lights each for ten digits, plus 2 lights for 
the sign. Each column had two lights on top; the left one indicates 0, the 
right one 5. The five vertical lights below indicate the number, 0-4, to be 
added to base indicated by the top lights, thus allowing all digits 0-9 to be 
displayed by 7 lamps. Since the top two lights are binary (base 2) and the 
ones below it "quinary" (base 5), this is called a bi-quinary display. The 
rightmost column of 2 lights indicates the sign, + (top) or - (bottom).  
Then comes a row of knobs marked Storage Entry, used for entering 
decimal digits into any desired location. The rightmost knob selects the sign.” 
 
 
 
Figure 1-5. IBM 650 Operators Console 
Source: IBM 1955a 
Courtesy of International Business Machines Corporation, © International 
Business Machines Corporation. 

IBM 650 Magnetic Drum Calculator 
11 
1.1.5 Magnetic Tape Units 
The IBM 650 used the IBM 727 Magnetic Tape Unit (MTU) for data 
and persistent storage. This tape unit was developed for the 700 series 
electronic data processing machines. The tape was blocked into records of 
100 characters organized as 10 words of 10 digits each. Alphabetic 
characters comprised five to a word with nine words per record. The 
average capacity of a tape reel was about 23,000 records. Up to four 
MTUs could be attached to the IBM 652 Tape Control Unit (TCU). An 
IBM 650 could support only one TCU. 
The 727 could exchange information with the IBM 407 Accounting 
Machine via alphabetic and special characters. Other machines could only 
exchange numeric data with signs unless an alphabetic hardware device 
was installed. 
1.1.6 IBM 652 Control Unit 
 
The IBM 652 Control Unit provided power and control for IBM 727 
MTUs, up to four IBM 355 Disk Storage Units, and up to ten IBM 838 
Inquiry Stations. Only one IBM 652 could be attached to an IBM 650 and 
it had to be accompanied by an IBM 653. 
1.1.7 IBM 653 High-Speed Core Storage Unit 
The IBM 650 incorporated 60 words of 10-digit magnetic core 
memory. Small programs could be loaded into core and executed. 
However, the primary purpose of the core memory was to serve as a  
buffer between the magnetic drum and magnetic tape, which transferred 
data at different rates. The user had to copy data from a device, say  
tape, to the core memory, and then write it the magnetic drum 
(http://www.columbia.edu/cu/computinghistory/650.html). 
The IBM 653 High-Speed Core Storage Unit (CSU) was used to buffer 
data to and from the MTUs. It also provided access to 60 words of 10 
digits of high-speed immediate access storage for the 650 to use as 
temporary storage. Data could be transferred in blocks of one to 50 words 
from the magnetic drum to the IBM 653. Only one 653 unit could be 
attached to an IBM 650. Data read into the CSU was continuously 
available until overwritten. 

Chapter One 
 
12
1.1.8 IBM 407 Accounting Machine 
The IBM 407 Accounting Machine was adapted to directly couple to 
the IBM 650 as an I/O device. Data read or written by the 407 could be 
pre- or post-processed by wiring the 407’s control panel appropriately. 
Thus, it provided an additional process capability to augment the IBM 
650’s data processing capabilities.  
1.2 IBM 650 Instruction Set 
Source: IBM 1958e 
 
An IBM 650 instruction was 10 digits long as depicted in Figure 1-6. 
The operand address, called the D address in 650 literature, specified one 
of the operands for most instructions. The other operand was assumed to 
be in either the upper or lower part or the entire accumulator. 
 
 
 
Figure 1-6. IBM 650 Instruction Format 
Source: Adapted from Weik 1961 
 
Each instruction included the address of the next instruction to execute. 
In computers with rotating memory, by the time the current instruction 
was finished executing, the next one had rotated out of reach. Thus, the 
computer had to wait for it to come back under the read head to fetch it. 
To program the IBM 650 was not just a matter of algorithm and numerical 
analysis, but also of optimizing the arrangement of instructions to prevent 
drum latency from slowing the program down. 
When programming in machine language, the programmer knew the 
drum rotated at 12,500 rpm, so he had to pick the location of the next 
instruction based on the execution time of the current instruction. When the 
Symbolic Optimal Assembly Program (SOAP) became available, it included 
an algorithm to solve this optimization problem for the programmer. 
IBM 650 Instructions were grouped into several categories. Additional 
instructions were added with optional features. The next instruction field is 
included in every instruction so we will not show it in the mnemonic. 

IBM 650 Magnetic Drum Calculator 
13 
Effective addresses were the operand field, often called the ‘D’ address, in 
the instruction. These addresses specified a group in one of the magnetic 
drum bands. 
1.2.1 I/O Instructions 
Table 1-3 presents the IBM 650 I/O instructions. Each drum memory 
band had 10 words that could be used for read buffer storage. The operand 
addressed one of the 20 or 40 groups of 10 words in the selected drum 
band. Data could also be moved from the accumulator or distributor to 
drum storage. 
 
Table 1-3. IBM 650 I/O Instructions 
OpCode 
Mnemonic 
Description 
70 
RD D 
Read: Read cards as follows: 
- transfer 10 words from read buffer storage to 
group D into read general storage 
- read the contents of the card in the card reader 
into the read buffer storage 
71 
PCH D 
Punch: Punch cards as follows: 
- transfer the 10 words of the group D to punch 
buffer storage. 
- punch the card with the contents of the punch 
buffer storage 
69 
LD D 
Load Distributor: Load the Distributor with the 
contents of the specified group. 
24 
STD D 
Store Distributor: Store the contents of the 
Distributor in the specified group 
20 
STL D 
Store Lower Accumulator: D <- c(Lower) 
21 
STU D 
Store Upper Accumulator: D <- c(Upper) 
22 
SDA D 
Store Data Address of Lower Accumulator: D <- 
c(Lower5-8) 
23 
SIA D 
Store Instruction Address of Lower: D <- 
c(Lower1-4) 
1.2.2 Arithmetic Instructions 
Table 1-4 presents the IBM 650 arithmetic instructions. To execute an 
arithmetic operation, the contents of the D address were moved to the 
Distributor where sign analysis took place.  Sign analysis of the two 

Chapter One 
 
14
operands then occurred to determine the sign of the result. The result was 
used to set the sign of the accumulator at the end of the operation.  
 
Table 1-4. IBM 650 Arithmetic Instructions 
OpCode 
Mnemonic 
Description 
15 
ALO  D 
Add to Lower: Lower <- c(D) + c(Lower) 
65 
RAL D 
Reset and Add to Lower: Lower <- 0; Lower <- 
c(D) + c(Lower) 
10 
AUP D 
Add to Upper: Upper <- c(D) + c(Upper) 
60 
RAU D 
Reset and Add to Upper: Upper <- 0; Upper <- 
c(D) + c(Upper) 
16 
SLO  D 
Subtract from Lower: Lower <- c(D) - c(Lower) 
66 
RSL D 
Reset and Subtract from Lower: Lower <- 0; 
Lower <- c(D) - c(Lower) 
11 
SUP D 
Subtract from Upper: Upper <- c(Upper) - c(D) 
61 
RSU D 
Reset and Subtract from Upper: Upper <- 0; 
Upper <- c(Upper) - c(D) 
19 
MPY D 
Multiply: Upper, Lower <- c(D) * c(Upper) 
14 
DIV D 
Divide: Upper, Lower <- c(Upper, Lower)/c(D); 
Remainder in Upper; Quotient in Lower 
64 
DVR D 
Divide and Reset Upper: perform DIV; Upper <- 
0. 
17 
AML D 
Add Magnitude to Lower: Lower <- |c(D)| + 
c(Lower) 
When c(D) is loaded into the distributor, its sign 
is set to positive. 
67 
RAM D 
Reset 
and 
Add 
Magnitude 
to 
Lower: 
Accumulator <- 0; Lower <- |c(D)| + c(Lower) 
When c(D) is loaded into the distributor, its sign 
is set to positive. 
18 
SML D 
Subtract Magnitude from Lower: Lower <- 
c(Lower) - |c(D)| 
When c(D) is loaded into the distributor, its sign 
is set to positive. 
68 
RSM D 
Reset and Subtract Magnitude from Lower: 
Accumulator <- 0; Lower <- c(Lower) - |c(D)| 
When c(D) is loaded into the distributor, its sign 
is set to positive. 

IBM 650 Magnetic Drum Calculator 
15 
1.2.3 Shifting Instructions 
Table 1-5 presents the IBM 650 instructions to shift data. All shifting 
instructions were executed using the accumulator. The contents of both 
halves of the accumulator were shifted left or right as indicated by the 
instruction. All positions vacated by the shift were filled with zeroes. The 
sign of the accumulator is not affected by shifting operations.  If the D 
field unit’s position is 0, the shift amount is 10.  
 
Table 1-5. IBM 650 Shifting Instructions 
OpCode 
Mnemonic 
Description 
30 
SRT D 
Shift Right: Shift the number of places given by 
the units position of the D field 
31 
SRD D 
Shift Right and Round: Shift the number of 
places given by the unit’s position of the D field. 
Add 5 to the last digit shifted out; add 1 to last 
digit of the accumulator. 
35 
SLT D 
Shift Left: Shift the number of places given by 
the units position of the D field 
36 
SCT D 
Shift Left and Count: Shift the number of places 
given by the unit’s position of the D field until a 
nonzero digit is encountered in the high-order 
position. Place a count of the number of shifts 
that occurred in the 2nd low-order position. If no 
significant digit is sensed when the shift is 
finished, signal an overflow condition. 
1.2.4 Branching Instructions 
Table 1-6 presents the IBM 650 branching instructions. A branching 
operation consisted of the opcode and two parts providing the YES-NO 
choices. If the conditional was successful, the next instruction was fetched 
at the D address; otherwise it is fetched from the Next Instruction field.  
 
Table 1-6. IBM 650 Branching Instructions 
OpCode 
Mnemonic 
Description 
44 
NZU D 
Branch on Non-Zero in Upper Accumulator:  
branch if c(UPPER) /= 0. 
45 
NZE D 
Branch on Non-Zero Accumulator: branch if 
c(Upper, Lower) /= 0. 
 
 

Chapter One 
 
16
46 
BMI D 
Branch on Minus Accumulator:  Branch if 
accumulator sign is minus. 
47 
BOV D 
Branch on Overflow: Branch if the Overflow 
indicator is 1. 
90-99 
BD 0-9 
Branch on digit 8 in a distributor position. 
1.2.5 Table Lookup Instruction 
The IBM 650 table lookup function (see Table 1-7) allowed the 
processor to search a table for a specified value. A table consisted of a set 
of arguments or reference factors (e.g., keys) and one or more associated 
functions, e.g., associated data items.  Arguments were stored in a band on 
the drum in ascending order. An argument’s length could be up to 10 
digits stored in the 10 most significant digits of a word. The 10 least 
significant digits could store a function.  
The table lookup operation searched the table looking for a match to an 
argument. It stopped if a match was found or the next argument value was 
larger than the search parameter. Thus, the table did not need to contain 
arguments for all possible values, but could be sparse. The search 
parameter was stored in the distributor. Functions could be stored a fixed 
number of locations away from the argument.  
The search always began at word 0000 of a band. A count was kept of 
the number of drum locations passed while the search was conducted. 
When the search was complete, the number of drum locations was added 
to the D field contents, which was then placed in the lower accumulator. 
 
Table 1-7. IBM 650 Table Lookup Instruction 
OpCode 
Mnemonic 
Description 
84 
TLU D 
Table Lookup: Search tables beginning with the 
band given by D.  
1.2.6 Miscellaneous Instructions 
Table 1-8 presents the IBM 650 miscellaneous instructions which 
controlled machine operation. 
 
 
 

IBM 650 Magnetic Drum Calculator 
17 
Table 1-8 IBM 650 Miscellaneous Instructions 
OpCode 
Mnemonic 
Description 
00 
NOP 
No Instruction:  fetch the next instruction from 
the I-field. 
01 
HLT 
Halt: Depending on the Programmed switch on 
the console, either halt the machine or act like a 
NOP. If switch is set to STOP, halt the machine. 
69 
LDD D 
Load Distributor: distributor <- c(D). 
1.2.7 Index Accumulator Instructions 
The IBM 650 index accumulator instructions operated like the 
branching instructions of Table 1-9. They were only available with the 
installation of an IBM 653 CSU. 
 
Table 1-9. IBM 650 Index Accumulator Instructions 
OpCode 
Mnemonic 
Description 
40 
BNZA D 
Branch on Non-Zero Index Accumulator A 
41 
BMNA D 
Branch Minus Index Accumulator A 
42 
BNZB D 
Branch on Non-Zero Index Accumulator B 
43 
BMNB D 
Branch Minus Index Accumulator B 
48 
BNZC D 
Branch on Non-Zero Index Accumulator C 
49 
BMNC D 
Branch Minus Index Accumulator C 
1.2.8 Index Accumulator Operations Instructions 
Table 1-10 presents the IBM 650 index accumulator operations 
instructions. Arithmetic operations could be performed on index 
accumulators. However, these instructions were limited to residing in 
effective addresses 0000-1999, 8000-8003, or 9000-9059. When the 
instruction resided in 0000-1999, the D field contained the actual amount 
to modify the index accumulator by.  
 
Table 1-10. IBM 650 Index Accumulator Instructions 
OpCode 
Mnemonic 
Description 
50 
AA D 
Add to Index Accumulator A: A <- c(A) + D, if 
0000 < D < 1999; else A <- c(A) + c(c(D)), as 
indexed. 
Examples: 
Instruction         Before        After 
50 0001 0123    +0500         +0501 

Chapter One 
 
18
50 2156 0123    +0656        +1156  because 2156 
is indexed 
51 
SA D 
Subtract from Index Accumulator A: A <- c(A) - 
D, if 0000 < D < 1999; else A <- c(A) - c(c(D)), 
as indexed 
52 
AB D 
Add to Index Accumulator B: B <- c(B) + D, if 
0000 < D < 1999; else B <- c(B) + c(c(D)), as 
indexed 
53 
SB D 
Subtract from Index Accumulator B: B <- c(B) - 
D, if 0000 < D < 1999; else B <- c(B) - c(c(D)), 
as indexed 
58 
AC D 
Add to Index Accumulator C: C <- c(C) + D, if 
0000 < D < 1999; else C <- c(C) + c(c(D)), as 
indexed 
59 
SC D 
Subtract from Index Accumulator C: C <- c(C) - 
D, if 0000 < D < 1999; else C <- c(C) - c(c(D)), 
as indexed 
80 
RAA D 
Reset Add to Index Accumulator A: A <- 0; A <- 
c(A) + D, if 0000 < D < 1999; else A <- c(A) + 
c(c(D)), as indexed  
81 
RSA D 
Reset Subtract from Index Accumulator A: A <- 
0; A <- c(A) - D, if 0000 < D < 1999; else A <- 
c(A) - c(c(D)), as indexed 
82 
RAB D 
Reset Add to Index Accumulator B: B <- 0; B <- 
c(B) + D, if 0000 < D < 1999; else B <- c(B) + 
c(c(D)), as indexed  
83 
RSB D 
Reset Subtract from Index Accumulator B: B <- 
0; B <- c(B) - D, if 0000 < D < 1999; else B <- 
c(B) - c(c(D)), as indexed 
88 
RAC D 
Reset Add to Index Accumulator C: C <- 0; C <- 
c(C) + D, if 0000 < D < 1999; else C <- c(C) + 
c(c(D)), as indexed  
89 
RSC D 
Reset Subtract from Index Accumulator C: C <- 
0; C <- c(C) - D, if 0000 < D < 1999; else C <- 
c(C) - c(c(D)), as indexed 
1.2.9 Floating Point Instructions 
Table 1-11 presents the IBM 650 floating point instructions. Floating 
point operations took roughly the same time as the fixed point operations. 

IBM 650 Magnetic Drum Calculator 
19 
The addition operations varied depending on the amount of normalization 
to be performed through shifting.  
 
Table 1-11. IBM 650 Floating Point Instructions 
OpCode 
Mnemonic 
Description 
32 
FA D 
Floating Add: Upper <- c(Upper) + c(D) 
33 
FS D 
Floating Subtract: Upper <- c(Upper) - c(D) 
34 
FD D 
Floating 
Divide: 
c(Upper)/c(D); 
Rounded 
Quotient to Upper 
37 
FAAB D 
Floating Add Absolute:  Upper <- c(Upper) + 
|c(D)| 
38 
FSAB D 
Floating Subtract Absolute: Upper <- c(Upper) - 
|c(D)| 
39 
FM D 
Floating Multiply: Upper <- c(Upper) * c(D) 
02 
FASN D 
Floating Add, Suppress Normalization: Upper <- 
c(Upper) + c(D), but suppress normalization 
1.2.10 IAS Instruction 
The IAS used a Timing Ring to process multiple word transfers. It had 
one instruction associated with it. This instruction (see Table 1-12) usually 
preceded multiple word transfer instructions 04 through 09 or 28 to 29. 
 
Table 1-12. IBM 650 IAS Timing Ring Instruction 
OpCode 
Mnemonic 
Description 
27 
SET D 
Set IAS Timing Ring: TR <- C(D); 9000 < D < 
9059 
 
Table 1-13 presents the IBM 650 IAS transfer instructions. Single 
word transfers were accomplished using the standard load and store 
instructions. Multiple word transfers of 1 to 50 words were accomplished 
by special instructions. The number of words transferred was dependent 
on: 
 
The setting of the timing ring 
The operation code used 
The end of the band on the drum. 
 
 
 
 

Chapter One 
 
20
Table 1-13. IBM 650 IAS Multiple Word Transfer Instructions 
OpCode 
Mnemonic 
Description 
09 
LDI D 
Load IAS: Transfers from one to 50 words 
beginning at D to the location beginning at the 
timing ring. 
29 
STI D 
Store IAS: Transfers 1 to 50 words from IAS to 
the drum. 
08 
LIB D 
Load IAS Block: Loads a maximum of 10 words 
from the drum to the IAS locations. 
28 
SIB D 
Store IAS Block: Transfers a maximum of 10 
words from the IAS to the drum. 
1.3 IBM 650 Programming 
Bell Telephone Laboratories received one of the first IBM 650s for use 
in engineering and scientific development. However, operators soon 
realized that something other than machine language was necessary to 
make effective use of this machine. Two languages were developed: the 
L1 language (Bell 1), developed by V. Michael Wolontis and Dolores C. 
Leagus, and the L2 language (Bell 2), developed by Richard W. Hamming 
and Ruth A. Weiss. Both languages were easy to use and eventually 
released outside of Bell Labs. By the late 1950s, at least half the IBM 650s 
doing scientific and engineering work used either Bell 1 or Bell 2. One 
organization became so fond of the Bell 1 programming language that, 
when its 650 was replaced by the more powerful IBM 1401, they went to 
the trouble of writing their own Bell 1 interpreter for the new machine. 
Bell 1 and Bell 2 were eventually replaced by FORTRAN when Bell Labs 
took delivery of an IBM 704. (Brown, Holbrook, and McIlroy 1984) 
Numerous routines were developed for the IBM 650. One of the most 
widely used routines was the Floating Decimal Interpretive System that 
was developed by V.M. Wolontis (Wolontis 1956). An early book on 
programming the IBM 650 is Andree (1958). 
 
 

IBM 650 Magnetic Drum Calculator 
21 
1.4 Symbolic Assembly 
Source: IBM 1957c 
 
The IBM 650 was originally programmed in machine language via 
card input. Later, SOAP provided a minimal assembly language-like 
capability for writing programs. The principal goal of symbolic assembly 
programs was to relieve the programmer of the task of assigning actual 
storage locations to instructions, constants or variables. Instead, the 
programmer assigned a symbolic name comprised of characters and 
numbers to variables. For example, “WAGES” might be assigned as the 
name of a variable holding the monthly wages of an employee.  
Programmers used SOAP coding forms to write down their programs 
before wiring the patch panel with the program. A portion of a SOAP 
coding form is depicted in Figure 1-7 (IBM 1957d). 
 
 
 
Figure 1-7. SOAP II Coding Form 
Source: IBM 1957c 
Courtesy of International Business Machines Corporation, © International 
Business Machines Corporation. 
 
In 1957, a FORTRAN I translator, FORTRANSIT, became available. 
FORTRANSIT compiled to SOAP, which was then assembled. A typical 
sequence for preparing a program for execution might go something like 
this: 
x Load the FORTRANSIT compiler into the card reader along with 
you FORTRAN program 
x FORTRANSIT is loaded into memory and compiles your program. 
It produces a SOAP program which is punched to cards. 
x Load SOAP plus the program deck output by FORTRANSIT into 
the card reader. 
x SOAP is loaded into memory and assembles your program. It 
punches the executable program onto a deck of cards. 
x Load the LOADER program plus your executable card deck into 
the card reader. 
x Your program is loaded into memory and executed. 

Chapter One 
 
22
x The output of your program was punched onto another deck of 
cards. 
x The program results deck were loaded into a machine like the IBM 
407, which then printed a listing of the card deck. 
 
Speckhard (1959) describes SAP (Symbolic Assembly Program), 
written by IBM to perform similar functions to SOAP. It attempted to 
improve upon some of the limitations of SOAP. For example, to provide 
flexibility beyond sequential instruction execution, SAP provided the 
pseudo-instruction TRA which transferred to an arbitrary drum location. 
This gave the programmer more flexibility in location program 
components on the drum. In SAP, the programmer could define a block of 
addresses to be reserved for later data storage. It included a capability to 
define alphabetic constants in a program through the pseudo-operation 
ALF. 
1.5 IBM 650 RAMAC 
Source: Royse 1957 
 
A second-generation RAMAC system was based on the IBM 650. The 
original RAMAC system was discussed in volume 1: Birthing the 
Computer: From Relays to Vacuum Tubes. A basic IBM 650 was 
augmented with the IBM 653 Core Storage Unit (CSU), which could 
contain additional immediate access core storage, an optional floating 
decimal arithmetic unit, and optional index registers. The core storage unit 
contained 60 ten-digit words plus a sign. The time for a single word 
transfer was 2 x 96 microseconds. Block transfers could be accomplished 
between the magnetic drum and the core storage unit.  
An IBM 652 Magnetic Tape Control Unit handled one or more 
magnetic tape drives attached to the IBM 650. It also contained an address 
buffer for the IBM 355 disk storage unit. The IBM 355 Disk Storage Unit 
(DSU) had a capacity of 6 million digits plus signs or 3 million 
alphanumeric characters. Data was recorded on each side of the 50 
vertically-stacked disks which rotated at 1200 rpm. The IBM 355 had 
three independently moveable access arms containing a read-write head 
for each tine to provide access to opposite sides of a disk. Access to the 
DSU was provided through three commands: seek, read, and write. Seek 
did not perform a data transfer, but was used to position the access arms in 
anticipation of a read or write command. The write command transferred a 

IBM 650 Magnetic Drum Calculator 
23 
60-word content from the CSU to a particular track on the DSU. A read 
command performed the obverse operation.  
The speed of the IBM 650 RAMAC system was significantly improved 
through the use of enhanced I/O commands and the CSU. Additionally, 
the use of the seek command allowed preplacing the arm in anticipation of 
a read or write command, which enhanced the I/O operation.  
According to Weik (1961, pp. 350-362), the U.S. Army Corp of 
Engineers used several IBM 650 RAMAC machines for engineering 
computations in support of their primary mission. It was also used by the 
U.S. Navy for logistics management, engineering calculations, and 
administrative data processing at several sites. Many commercial firms 
and government organizations also installed IBM 650 RAMAC machines 
for various computing task, including Fort Motor Co. for administrative 
and management data processing; the Institute for Defense Analysis for 
statistical analysis; and numerous universities for academic and 
administrative computing tasks. 
1.6 IBM 650 Assessment 
IBM often referred to the IBM 650 as its “first computer”. In fact, it 
was predated by the IBM 701, which was a commercial machine used for 
scientific and engineering calculations. Thus, it is perhaps more 
appropriate to refer to the IBM 650 as IBM’s first commercial business 
computer system. It was also IBM’s first computer that earned enough to 
cover development costs, sustainment expenses and yield a profit. IBM 
manufactured it from 1953 to 1962, and supported the system until 1969. 
However, many IBM 650s operated well into the 1970s. 
Originally designed as a cards-only machine, the advances in design 
and development of storage devices for the IBM 701 were quickly 
retrofitted to the IBM 650, including magnetic tapes, line printers, disk 
drives, and core memory. Wallace Eckert and Rebecca Jones (1955) noted: 
 
“One of the most exciting achievements of our generation is the 
development of the electronic automatic digital calculator. Although any 
schoolboy can perform any operation done by the calculator, the speed 
and economy with which the calculator does them are so great that 
automatic calculation is revolutionizing large areas of science, 
engineering, business, industry, and defense. A single giant calculator can 
do more arithmetic than the entire population of the United States could do 
with pencil and paper” 
 

Chapter One 
 
24
It was this kind of enthusiasm that stimulated the use of computing and 
created the demand for computers, albeit slowly at first, across the United 
States in the 1950s and 1960s. 
IBM expected to sell about 50 of the 650 computer system. However, 
the deep discounts, the small size – it fit in one room – and its hands-on 
use by programmers – made it a very popular machine. By the end of its 
manufacturing run in 1962, over 2000 machines had been sold and 
delivered. 
As with many drum-based machines, placing succeeding instructions 
on the drum to reduce delays in execution time was an art. Gordon (1955) 
describes one program developed at Equitable Life Assurance to optimize 
small programs for the IBM 650. 
 

CHAPTER TWO 
ROYAL MCBEE/LIBRASCOPE MACHINES 
 
 
 
Royal McBee Corporation, a subsidiary of the Royal Typewriter Co., 
was a manufacturer located in Port Chester, NY. It contracted with the 
Librascope Corporation to design and build a simple machine for 
engineering calculations, which it then marketed. The LGP-30 represented 
a minimum design machine. It was referred to as a “desk computer” from 
its appearance. However, it was anything but. This machine weighed over 
800 pounds, required eight square feet of floor space, and over 1500 watts 
to operate. As long as the room was kept reasonably cool, no air 
conditioning was required. An LGP-30 is depicted in Figure 2-1. The main 
characteristics of the LGP-30 are presented in Table 2-1. 
The LGP-30 arose from a design by Stan Frankel, who worked at Los 
Alamos, but lost his security clearance during the McCarthy “Red Scare” 
in the 1950s. He was introduced to the ENIAC during World War II and 
had many discussions with the physicists at Los Alamos about the use of 
electronic computers. After the war, he traveled to the University of 
Manchester and learned how to program the Ferranti Mercury. After 
losing his security clearance, he taught and worked at the California 
Institute of Technology (CalTech) where he designed a computer, the 
MINAC, to explore the lower limits of what a computer might be. After 
visiting, Eckert-Mauchly Computer Corporation, Raytheon, the National 
Bureau of Standards (NBS) and the MIT Whirlwind Group, he worked 
with Physics graduate student James Cass to construct a breadboard 
version of the MINAC. Librascope licensed the design from CalTech, and 
hired Cass and Frankel to turn it into a commercial product. 
 

Chapter Two 
 
26
 
 
Figure 2-1. Royal McBee LGP-30 
Source: Royal McBee (UNK) 
 
The University of Saskatchewan began the digital age when an LGP-
30 was installed on campus in 1957. As Dr. Kavanaugh (2007) noted, “… 
this was a machine that was designed to fit into a Steelcase office desk”. It 
was used primarily by the Mathematics faculty. The LGP-30 was a 
compact processor meant to be used as a “personal computer”, e.g., one 
operator at a time, before that term was ever used in the media, and had 
4096 words of 31-bit memory. 
 
Table 2-1. LGP-30 Characteristics 
Characteristic 
Value/Explanation 
Internal Representation 
Binary Fixed Point 
# Bits/Word 
32 (but only 31 read from magnetic drum; high 
order bit 32 always read as 0) 
# Instructions/Word 
1 
# Instructions 
16 
# Bits/Instruction 
16 
Instruction Type 
One Address Code 
CPU Technology 
Vacuum Tubes 
CPU Registers 
Counter C; Accumulator A; Instruction Register 
R 

Royal McBee/Librascope Machines 
27 
Main Memory 
Magnetic Drum 
Add Time 
260 microseconds (Fixed Point) 
Multiply Time 
8.75 milliseconds (Fixed Point) 
Divide Time 
24 milliseconds (Fixed Point) 
 
The Meaning of LGP 
LGP stood for ‘Librascope General Purpose’. However, General Precision 
Corporation (GP) of Glendale, CA bought Librascope and LGP came to 
stand for ‘Librascope General Precision’. GP controlled the manufacturing 
while Royal-McBee Corporation marketed the computer, trained its 
customers, and serviced the machines through its data-processing division. 
That is why you see advertisements for the Royal-McBee LGP-30. Today, 
Librascope is a division of Lockheed Martin Co. 
2.1 LGP-30 System Architecture 
The LGP-30 had a word size of 32 bits consisting of 30 data bits, a 
sign bit, and a spacer bit. The spacer bit was required because the main 
memory of the machine was a magnetic drum. 
I/O was performed through a Friden Flexowriter, which was used as 
the console, and a paper tape reader. To reduce the cost of the machine, 
the LGP-30 did not have lights representing the values in the registers. 
Rather, it had a small oscilloscope mounted on the front panel which 
allowed the operator to see the bits being read by the read head. The bits 
were represented by the rising and falling traces on the oscilloscope 
screen. 
The magnetic drum stored 4,096 words and had an average access time 
of 2.3 milliseconds. The LGP-30 magnetic drum stored both the registers 
and the memory for the machine. The drum was configured with 64 tracks 
of 64 sectors. Each track had its own read-record head. Since the drum 
rotated at a speed of 17 milliseconds, each sector was available every 17 
milliseconds.  
Three additional tracks were allocated to store recalculating registers 
each one sector in length. As the recalculating register passed under a read 
head, a record head continuously recorded the information read back to the 
drum at a distance of one sector length from the read head. The advantage 
of the recalculating register was a reduction of sector access time 
equivalent to one sector length (0.26 milliseconds). The three recalculating 
registers were the accumulator, the instruction register, and the counter 
register. (Frankel 1957) 

Chapter Two 
 
28
2.2 LGP-30 Instruction Set 
The LGP-30 had only 16 instructions for performing computations. 
The instruction format is depicted in Figure 2-3. Bit 31 contained the 
spacer bit which separated one instruction from the next on the drum. 
Table 2-2 presents the instruction set of the LGP-30. 
 
 
 
Figure 2-3. LGP-30 Instruction Format 
Source: Adapted from Weik 1961 
 
Table 2-2. LGP-30 Instruction Set 
Symbol 
Opcode 
Description 
0000 
Z 
Stop computation 
0001 
B 
Bring: Replace the contents of the accumulator with 
the contents of the memory location. 
0010 
Y 
Store Address: Replace the contents of the address 
portion of the word in the memory location with the 
contents of the address portion of the word in the 
accumulator. 
0011 
R 
Return Address: add one to the contents of the counter 
register and replace the address portion of the memory 
location with the contents of the counter register. 
0100 
I 
Input: Transfer into the last four bits of accumulator the 
character code for the next character on the paper tape. 
0101 
D 
Divide: Divide the number in the accumulator by the 
number in the memory location and place the 
quotient rounded to thirty bits in the accumulator. 
0110 
N 
Multiply: Multiply the number in the accumulator by 
the number in the memory location and place the 
least significant thirty-one magnitude bits of the 
product in the sign bit and thirty magnitude bits of 
the accumulator. 
0111 
M 
Multiply: Multiply the number in the accumulator by 
the number in the memory location and place the 
most significant thirty bits of the product in the 
accumulator. 

Royal McBee/Librascope Machines 
29 
1000 
P 
Print: Execute the typewriter keyboard function 
indicated by the 6 track bits. 
1001 
E 
Extract: Place zeroes in the word in the accumulator 
wherever there were zeroes in location 2000 but 
otherwise leave the word in the accumulator 
unchanged. 
1010 
U 
Unconditional Transfer: Replace the number in the 
counter register with the contents of the address 
portion of the unconditional transfer instruction 
1011 
T 
Test: If sign bit of the accumulator equals one, do an 
unconditional transfer. If the sign bit is zero, the next 
following instruction in normal sequence is executed. 
1100 
H 
Hold: Replace the contents of memory location with 
the contents of the accumulator 
1101 
C 
Clear and Store: Replace the contents of memory 
location with the contents of the accumulator and 
replace the contents of the accumulator with zero 
1110 
A 
Add: Add the contents of memory location to the 
contents of the accumulator and place the result in 
the accumulator. 
1111 
S 
Subtract: Subtract the contents of memory location 
from the contents of the accumulator and place the 
result in the accumulator. 
 
Suppose that we need to evaluate the expression (((a0x + a1)x + a2)x + 
a3) x+ a4 ?  Here is a program extracted from the Royal McBee 
Programming Manual for the LGP-30 (Royal McBee 1957): 
 
 
Location 
Instruction 
Operand 
 
1000 
b  
 
2001 
a0 
 
1001 
m  
 
2000 
x 
 
1002 
a  
 
2002 
a1 
 
1003 
m  
 
2000 
x 
 
1004 
a  
 
2003 
a2 
 
1005 
m  
 
2000 
x 
 
1006 
a  
 
2004 
a3 
 
1007 
m  
 
2000 
x 
 
1998 
a  
 
2005 
a4 
 
1009 
h  
 
2006 
 
   
 
answer = (((a0x + a1)x + a2)x + a3) x+ a4 

Chapter Two 
 
30
2.3 The Story of Mel 
In May 1983, Ed Nather posted to USENET a prose story he had 
written about a Royal-McBee programmer named Mel. It is the lament of 
a “real programmer” that resounded through the past 50 years or so. It is 
possible that it refers to Mel Kaye, who wrote the ACT-I assembler for the 
LGP-30. The story as written by Nather involved Kaye's work on 
rewriting a blackjack program from the LGP-30 to a newer Royal McBee 
system, the RPC-4000. Company sales executives requested Kaye to 
modify the program so that the player had more winning chances, a 
request that Kaye reluctantly acceded to, but to his own delight, he 
accidentally changed the odds in favor of the dealer rather than the player. 
Subsequent to Kaye's departure, Nather was asked to fix the bug. 
While examining the code, he found out that an apparent infinite loop had 
in fact been coded in such a way as to take advantage of a carry-overflow 
error, causing the loop to change itself into a jump instruction to the next 
part of the code. This impressed Nather so much that, out of respect, he 
gave up the task and reported that he could not find the bug. 
Mel Kaye went on to found a consulting company in Basking Ridge, 
New Jersey. He passed away in 2008, but his story and legend lives on. 
 
Real Programmers Write in Fortran 
Source: http://www.pbm.com/~lindahl/mel.html 
 
Maybe they do now, in this decadent era of Lite beer, hand calculators 
and "user-friendly" software but back in the Good Old Days, when the 
term "software" sounded funny and Real Computers were made out of 
drums and vacuum tubes, Real Programmers wrote in machine code. Not 
Fortran. Not RATFOR. Not, even, assembly language. Machine Code. 
Raw, unadorned, inscrutable hexadecimal numbers. Directly 
   
  
  
Lest a whole new generation of programmers grow up in ignorance of this 
glorious past, I feel duty-bound to describe, as best I can through the 
generation gap, how a Real Programmer wrote code. I'll call him Mel, 
because that was his name. 
   
  
  
I first met Mel when I went to work for Royal McBee Computer Corp., a 
now-defunct subsidiary of the typewriter company. The firm manufactured 
the LGP-30, a small, cheap (by the standards of the day) drum-memory 
computer, and had just started to manufacture the RPC-4000, a much-
improved, bigger, better, faster -- drum-memory computer. Cores cost too 

Royal McBee/Librascope Machines 
31 
much, and weren't here to stay, anyway. (That's why you haven't heard of 
the company, or the computer.) 
  
  
  
I had been hired to write a Fortran compiler for this new marvel and Mel 
was my guide to its wonders. Mel didn't approve of compilers. 
    
  
"If a program can't rewrite its own code," he asked, "what good is it?" 
    
Mel had written, in hexadecimal, the most popular computer program the 
company owned. It ran on the LGP-30 and played blackjack with potential 
customers at computer shows. Its effect was always dramatic. The LGP-30 
booth was packed at every show, and the IBM salesmen stood around 
talking to each other. Whether or not this actually sold computers was a 
question we never discussed. 
   
  
  
Mel's job was to re-write the blackjack program for the RPC-4000. 
(Port?  What does that mean?) The new computer had a one-plus-one 
addressing scheme, in which each machine instruction, in addition to the 
operation code and the address of the needed operand, had a second 
address that indicated where, on the revolving drum, the next instruction 
was located. In modern parlance, every single instruction was followed by 
a GO TO! Put *that* in Pascal's pipe and smoke it. 
    
  
Mel loved the RPC-4000 because he could optimize his code: that is, 
locate instructions on the drum so that just as one finished its job, the next 
would be just arriving at the "read head" and available for immediate 
execution. There was a program to do that job, an "optimizing assembler", 
but Mel refused to use it. 
    
  
"You never know where it’s going to put things", he explained, "so you'd 
have to use separate constants". 
   
  
It was a long time before I understood that remark. Since Mel knew the 
numerical value of every operation code, and assigned his own drum 
addresses, every instruction he wrote could also be considered a 
numerical constant. He could pick up an earlier "add" instruction, say, 
and multiply by it, if it had the right numeric value. His code was not easy 
for someone else to modify. 
 
I compared Mel's hand-optimized programs with the same code massaged 
by the optimizing assembler program, and Mel's always ran faster. That 

Chapter Two 
 
32
was because the "top-down" method of program design hadn't been 
invented yet, and Mel wouldn't have used it anyway. He wrote the 
innermost parts of his program loops first, so they would get first choice of 
the optimum address locations on the drum. The optimizing assembler 
wasn't smart enough to do it that way. 
    
  
Mel never wrote time-delay loops, either, even when the balky Flexowriter 
required a delay between output characters to work right. He just located 
instructions on the drum so each successive one was just *past* the read 
head when it was needed; the drum had to execute another complete 
revolution to find the next instruction. He coined an unforgettable term for 
this procedure. 
 
Although "optimum" is an absolute term, like "unique", it became common 
verbal practice to make it relative: "not quite optimum" or "less optimum" 
or "not very optimum". Mel called the maximum time-delay locations the 
"most pessimum". 
    
  
After he finished the blackjack program and got it to run, ("Even the 
initializer is optimized", he said proudly) he got a Change Request from 
the sales department. The program used an elegant (optimized) random 
number generator to shuffle the "cards" and deal from the "deck", and 
some of the salesmen felt it was too fair, since sometimes the customers 
lost. They wanted Mel to modify the program so, at the setting of a sense 
switch on the console, they could change the odds and let the customer 
win. 
   
  
  
Mel balked. He felt this was patently dishonest, which it was, and that it 
impinged on his personal integrity as a programmer, which it did, so he 
refused to do it. The Head Salesman talked to Mel, as did the Big Boss 
and, at the boss's urging, a few Fellow Programmers. Mel finally gave in 
and wrote the code, but he got the test backwards, and, when the sense 
switch was turned on, the program would cheat, winning every time. Mel 
was delighted with this, claiming his subconscious was uncontrollably 
ethical, and adamantly refused to fix it. 
  
  
  
After Mel had left the company for greener pastures, the Big Boss asked 
me to look at the code and see if I could find the test and reverse it. 
Somewhat reluctantly, I agreed to look. Tracking Mel's code was a real 
adventure.  
  
  
  

Royal McBee/Librascope Machines 
33 
I have often felt that programming is an art form, whose real value can 
only be appreciated by another versed in the same arcane art; there are 
lovely gems and brilliant coups hidden from human view and admiration, 
sometimes forever, by the very nature of the process. You can learn a lot 
about an individual just by reading through his code, even in hexadecimal. 
Mel was, I think, an unsung genius. 
  
  
  
Perhaps my greatest shock came when I found an innocent loop that had 
no test in it. No test. *None*. Common sense said it had to be a closed 
loop, where the program would circle, forever, endlessly. Program control 
passed right through it, however, and safely out the other side. It took me 
two weeks to figure it out.  
  
  
  
The RPC-4000 computer had a really modern facility called an index 
register. It allowed the programmer to write a program loop that used an 
indexed instruction inside; each time through, the number in the index 
register was added to the address of that instruction, so it would refer to 
the next datum in a series. He had only to increment the index register 
each time through. Mel never used it.  
  
  
  
Instead, he would pull the instruction into a machine register, add one to 
its address, and store it back. He would then execute the modified 
instruction right from the register. The loop was written so this additional 
execution time was taken into account -- just as this instruction finished, 
the next one was right under the drum's read head, ready to go. But the 
loop had no test in it. 
   
  
  
The vital clue came when I noticed the index register bit, the bit that lay 
between the address and the operation code in the instruction word, was 
turned on-- yet Mel never used the index register, leaving it zero all the 
time. When the light went on it nearly blinded me. 
    
  
He had located the data he was working on near the top of memory – the 
largest locations the instructions could address -- so, after the last datum 
was handled, incrementing the instruction address would make it 
overflow. The carry would add one to the operation code, changing it to 
the next one in the instruction set: a jump instruction. Sure enough, the 
next program instruction was in address location zero, and the program 
went happily on its way. 
 
 

Chapter Two 
 
34
I haven't kept in touch with Mel, so I don't know if he ever gave in to the 
flood of change that has washed over programming techniques since those 
long-gone days. I like to think he didn't. In any event, I was impressed 
enough that I quit looking for the offending test, telling the Big Boss I 
couldn't find it. He didn't seem surprised. 
  
When I left the company, the blackjack program would still cheat if you 
turned on the right sense switch, and I think that's how it should be. I 
didn't feel comfortable hacking up the code of a Real Programmer." 
2.4 LGP-30 Assessment 
The LGP-30 might well be considered the first ‘personal computer’. 
Over 500 of these machines were built and sold at a time when 2 or 3 sales 
were considered the norm. Its minimal configuration (113 vacuum tubes, 
1450 solid-state diodes, and a rotating drum) yielded a relatively 
inexpensive machine at about $47,000 (circa late 1950s). Another view of 
the LGP-30 is depicted in Figure 2-3. 
 
 
 
Figure 2-3. LGP-30 Computer System 
Source: General Precision 1962c 
2.5 The LGP-21 
Source: GP 1963a, GP 1963b 
 
The LGP-21 was a small, compact machine with a 4096 word memory 
that could be plugged into any wall outlet (an unusual feature for its time). 
It was a transistor-based machine that was about one-third as fast as the 

Royal McBee/Librascope Machines 
35 
LGP-30, but cost about $16,200 in 1963. Table 2-3 presents the LGP-21 
basic characteristics. 
 
Table 2-3. LGP-21 Characteristics 
Characteristic 
Value/Explanation 
Internal Representation 
Binary Fixed Point 
# Bits/Word 
32 (bit 32 always read as 0 from magnetic drum) 
# Instructions/Word 
1 
# Instructions 
23 
# Bits/Instruction 
16 
Instruction Type 
One Address Code 
CPU Technology 
Transistors: cycle time: 390 microseconds 
CPU Registers 
Location Counter C; Accumulator A; Instruction 
Register R 
Main Memory 
Magnetic Drum: 4096 words 
Add Time 
390 microseconds (Fixed Point) 
Multiply Time 
25.74 milliseconds (Fixed Point) 
Divide Time 
26.13 milliseconds (Fixed Point) 
2.5.1 LGP-21 System 
An LGP-21 is depicted in Figure 2-5. The primary I/O device was the 
Model 121 Friden Flexowriter Tape Typewriter on the middle desktop, 
which is the device on the right desk in Figure 2-4. The Model 101 Visual 
Oscilloscope Display provided a visual representation of the three LGP-21 
registers to support program checkout and debugging. It displayed three 
registers in binary: the Location Counter, the Last Instruction Executed, 
and the Accumulator. Below it were a Model 141 60 cps paper tape reader 
and a Model 151 20 cps paper tape punch for auxiliary I/O. The 
Accumulator was stored on the magnetic disk enclosed in the left hand 
side of the desk unit. Figure 2-5 is a brochure that describes the LGP-21. 
 

Chapter Two 
 
36
 
 
Figure 2-4. General Precision LGP-21 Computer System 
Source: General Precision 1963a 
2.5.2 LGP-21 Memory 
The memory disk had a capacity of 4096 words divided into 64 
sectors. Each sector held 64 tracks. Each word was uniquely addressed by 
its sector and track number. Note that sectors were not numbered 
sequentially within track, but rather organized using an 18-word interlace. 
This allowed efficient programming based on an access time of 7.26 
milliseconds so that the next word was available just as the current word 
was read. 
The LGP-21 was controlled by three registers located in a recirculating 
track which had both a read-head and a write-head placed one word-time 
apart. These heads continuously copied one sector to another within the 
track thus allowing the same information to be available at every word-
time. 
A fourth register, the Extended Accumulator had read- and write-heads 
located two word-times apart. It recorded the results of a multiply 
operation as a double-length word. Either the high or low part of this 
register was also recorded in the accumulator depending on the command 
executed. 

Royal McBee/Librascope Machines 
37 
2.5.3 LGP-21 Control Registers 
The Accumulator (A) was used for manipulation of data. All data 
transferred to or from the CPU and the I/O devices passed through the 
Accumulator. It contained one of the operands for arithmetic instructions 
and received the result after the instruction was executed. Multiply 
operations produced 62-bit results of which either half of 31 bits could be 
stored in the Accumulator. The Accumulator had one read- and one write-
head spaced one word apart. They continually copied one word from one 
sector to the next, thus making that word continually available. 
On the same track was a two-word recirculating line – the Extended 
Accumulator – which was not addressable by the programmer. It 
contained intermediate results during multiplication and division 
operations. The track containing the accumulator and the Extended 
Accumulator was not one of the 64 main data tracks. This track also 
contained the Instruction Register and the Counter Register. 
The Instruction Register (R) held the instruction being executed by the 
computer. Each instruction specified a command and an operand address. 
For many instructions, the other operand was assumed to reside in the 
Accumulator. During multiply and divide operations, it contained the 
second operand. 
The Counter Register (C) contained the address of the next instruction 
to be executed. After an instruction was executed, the contents of C were 
used to access the next instruction from the memory disk. Once the word 
was retrieved, the contents of the C register were incremented by one. Two 
commands, T and U, could set the C register to a specified address. 
When overflow occurred due to execution of add, subtract, or divide 
instructions, the sign bit of the C register was set to one. This bit could be 
tested and reset to 0 by a negative Sense and Transfer instruction. 
 
 

Chapter Two 
 
38
 
 
Figure 2-5. LGP-21 Brochure 
Source :http://www.wps.com/projects/LGP-21/Documentation/G3-
3101/images/G3-3101-1.jpg 
 

Royal McBee/Librascope Machines 
39 
The LGP-21 could support up to 32 I/O devices. They could be 
individually selected under program control. Output could be directed to 
several devices simultaneously. 
2.6 LGP-21 Instruction Set 
Source: GP 1963a 
 
The LGP-21 instruction set was simple and focused on arithmetic 
calculations. The instruction word format is depicted in Figure 2-6. The 
LGP-21 instruction set is depicted in Table 2-4.  
 
 
 
Figure 2-6. LGP-21 Instruction Format 
Source: GP 1963a 
 
In the following instruction definitions, ‘mm’ indicated a memory 
address comprised of a track number and a sector number. If the memory 
operand was specified as ‘t’, the track number was interpreted as a code 
and the sector number was ignored. EA specified the Extended 
Accumulator of size 62 bits. MSB indicated the most significant bits, 
while LSB indicated the least significant bits. 
 
Table 2-4. LGP-21 Instruction Set 
Mnemonic 
Description 
Z00 
Stop: Halt computation 
Z01 
Stop: Halt computation. 
Zt 
Sense Branch Switch: Interrogate the Branch Switch given 
by ‘t’. If the switch was OFF, skip the next instruction; 
otherwise, execute the next instruction. Branch switches 
were numbered 4, 8, 16, and 32. 
800Zt 
Sense Branch Switch & Overflow: Interrogate the Branch 
Switch given by ‘t’, then halt. Branch on continuation. 
800Z02 
Sense Overflow: If bit 0 of c(C) was 0, skip the next 
instruction in sequence; otherwise, execute the next 
instruction. 
800Z00 
Sense Overflow & Stop: If bit 0 of c(C) was 0, halt 
computation. On continuation, branch or not. 

Chapter Two 
 
40
800Z01 
Sense Overflow & Stop: If bit 0 of c(C) was 0, halt 
computation. On continuation, branch or not. 
Bmm 
Bring the contents of mm to A: A <- c(mm). 
Ymm 
Store Address: mm18-29 <- c(A)18-29 
Rmm 
Set Return Address: mm18-29 <- c(C) + 1. 
It 
Input, 6 bit: Shift A left 6 bits inserting zeroes at the right. 
Send a start signal to the device specified by ‘t’ to read 6 bits 
into the six high order bits of A. Bits shifted out the left end 
were lost. If t = 62, no input was read. 
800It 
Input, 4 bit: Shift A left 4 bits inserting zeroes at the right. 
Send a start signal to the device specified by ‘t’ to read 4 bits 
into the four high order bits of A. Bits shifted out the left 
end were lost. If t = 62, no input was read. 
I62 
Input Shift, 6 bit: Shift A left 6 bits and insert zeroes into the 
high-order bits. 
800I62 
Input Shift, 4 bit: Shift A left 4 bits and insert zeroes into the 
high-order bits. 
Dmm 
Divide: A <- c(A)/c(mm). The quotient, rounded to 30 bits, 
was stored in A. The absolute value of c(A) must be greater 
than the absolute value of c(mm) or overflow would occur. 
The R register held the divisor. 
Nmm 
Multiply & Save Right: EA <- c(A) * c(mm). The sign and 
31 MSB were saved in A. The R register held the 
multiplicand. 
MM 
Multiply & Save Left: EA <- c(A) * c(mm). The sign and 31 
LSB were saved in A. The R register held the multiplicand. 
Pt 
Print, 6 bit: Transmit A0-5 to the I/O device specified by ‘t’. 
800Pt 
Print, 4 bit: Transmit A0-3 concatenated with ‘10’ to the I/O 
device specified by ‘t’ as a hexadecimal character. 
Emm 
Extract: Where 1 bits were in the mask c(mm), retain the bit 
value in the corresponding position in A. Where a 0 bit 
occurs, set the corresponding bit to 0 in A. 
Umm 
Unconditional Transfer: C18-29 <- m and retrieve next 
instruction from m. 
Tmm 
Conditional transfer: if c(A) < 0, C18-29 <- m and retrieve 
next instruction from m. 
800Tmm 
Transfer Control: if c(A) <0 or switch TC on the console 
was ON, C18-29 <- m and retrieve next instruction from m; 
otherwise, execute the next instruction. 
Hmm 
Hold: mm <- c(A). 
Cmm 
Clear the Accumulator: A <- 0. 

Royal McBee/Librascope Machines 
41 
Amm 
Add: A <- c(A) + c(mm). Overflow could be set. 
Smm 
Subtract: A <- c(A) – c(mm). Overflow could be set. 
 
For arithmetic operations, if the resulting value exceeded the size of 
the accumulator, an overflow condition occurred. 
2.7 Timing and Optimization 
Source: GP 1963a 
 
All instructions were executed in sequence. The time to execute an 
instruction depended on its location and the location of its operand, if 
needed, in memory. The process of executing an instruction was called an 
instruction cycle. An instruction cycle began with a search for an 
instruction and terminated when the search for the next instruction began. 
A complete cycle consisted of four phases: 
1. Search for the instruction 
2. Transfer the instruction to the I register; increment the C register by 
one. 
3. Search for and retrieve the operand 
4. Execute the instruction 
 
To search for an instruction, the LGP-21 used a read-only Sector 
Reference Timing Track (SRTT) where the sections were numbered 0 to 
127. The SRTT was written at the time of manufacture. However, sections 
were addressed from 0 to 63. Sector numbers above 63 were taken modulo 
63. When a specified sector address was read on the SRTT, the read/write 
head on the appropriate track was activated, and the word could be read 
from or written to memory. For example, assume that location 1432 is to 
be read into the Accumulator. When the SRTT reads 32, read head 14 is 
activated. As sector 32 passes under the read head, its contents were 
transferred to the Accumulator. 
Royal McBee provided a circular slide rule for calculating the optimal 
placement of data on the magnetic drum. The front and back of this slide 
rule are depicted in Figure 2-7(a) and 2-7(b). 
2.8 LGP-21 Assessment 
The LGP-21 was a transistorized version of the LGP-30 with 100% 
compatible software. However, the LGP-21 was roughly three times 

Chapter Two 
 
42
slower, making it one of the few computers where the successor was 
slower than its predecessor.  
The Librascope Company, now a division of Lockheed Martin 
Company, which is still based in Glendale, California, was the 
manufacturer of the LGP-21. The machines were marketed by Royal 
McBee, hence the nameplates on some of the machines.  
SIMH 3.9.0, which can be downloaded from http://simh.trailing-
edge.com/, has simulators for both the LGP-21 and the LGP-30. 
 
 
 
Figure 2-7(a). Front of Optimum Address Locator 
Source: http://www.wps.com/projects/LGP-21/Documentation/index.html 

Royal McBee/Librascope Machines 
43 
 
 
Figure 2-7(b) Rear of Optimum Address Locator 
Source: http://www.wps.com/projects/LGP-21/Documentation/index.html 

CHAPTER THREE 
BENDIX G MACHINES 
 
 
 
The Bendix Corporation was founded in South Bend, Indiana, in 1924 
by Vincent Bendix. Initially, they designed and manufactured car and 
truck brakes. Bendix Aviation Corporation was formed in 1929, to 
manufacture aviation and automotive parts, before branching out into 
electronics. During World War II, it made several types of radars and 
navigation equipment. Later, the Bendix Corporation manufactured 
navigation and control equipment for commercial and defense 
applications. During the 1960s, it developed digital computers for aviation 
navigation and control (Bendix 1971f). 
In 1952, Bendix formed a computer division. In 1956, it introduced the 
Bendix G-15, a minicomputer (or personal computer) about the size of a 
large refrigerator. A successor, the transistorized Bendix G-20, was 
released in 1961. Eventually, Bendix acquired the LGP-30 from General 
Precision. In 1963, Control Data Corporation purchased the Bendix 
Computer Division. Eventually, Control Data spun off its software 
division and kept Bendix with the hardware division. Control Data closed 
its hardware division and eventually went out of business. 
Throughout the 1970s and until the early 1990s, Bendix experienced a 
series of mergers, acquisitions, and buy-outs. After a hostile takeover of 
Martin Marietta failed (in fact, Martin Marietta executed a neat reverse 
takeover bid), the remaining divisions of Bendix became a subsidiary of 
Allied Signal Corporation. Finally, Allied Signal bought Honeywell and 
adopted the Honeywell name, but the Bendix name exists as a subsidiary 
today. 
3.1 Bendix G-15 
Source: Bendix 1955j, Bendix 1955k 
 
The Bendix G-15 was a general purpose computer manufactured by the 
Bendix Aviation Corporation, Los Angeles, California. It was mainly used 
in scientific and engineering applications. It had a word size of 29 bits 

Bendix G Machines 
45 
with 28 significant bits and one sign bit. Numbers were generally stored as 
absolute value and sign. Approximately 50 vacuum tubes were used in its 
construction (Weik 1961).  
Harry Huskey, a professor at the University of California at Berkeley 
at the time, designed the Bendix G-15. Huskey had just returned from a 
sabbatical in England where he worked with Alan Turing on the Pilot Ace 
system. The G-15 embodied a significant number of Turing’s idea for 
designing and building computing machines (Horning 2006). 
 
Harry Huskey (1916-2017) 
Harry Huskey was born in North Carolina in 1916. He received his Ph.D. 
from Ohio State University in 1943. In 1945, he taught mathematics at the 
University of Pennsylvania where he worked part-time on the ENIAC. In 
1947 he visited the National Physical Laboratory in England where he 
worked on the Pilot ACE with Alan Turing. Upon his return to the US, he 
participated in the design of the SWAC at the National Bureau of 
Standards from 1949 to 1953. He also designed the Bendix G-15, 
sometime considered the world’s first “personal computer”. Indeed, 
Huskey even had one in his home. He joined the faculty at University of 
California at Berkeley in 1954 and moved to the Santa Cruz Campus when 
it opened in 1966. He retired as Professor Emeritus from the University of 
California. 
 
The basic G-15 used a Friden Flexowriter for manual input and paper 
tape for both input and output. A separate power supply and air 
conditioning were not required for the G-15. Main memory was a 
magnetic drum of 2160 29-bit words – 28 bits for data, 1 for parity. 
Internally, data was represented in binary code. The G-15 was one of the 
first machines to use a higher-level language for programming – the 
Intercom 1000 system (Smillie 2004). 
The approximate cost of the G-15 base system without peripherals was 
about $45,000 in the 1950s. The Bendix G-15 is depicted in an 
advertisement as seen in Figure 3-1 that appeared in Scientific American 
circa the late 1950s. A second advertisement appeared in Datamation in 
November 1960 as depicted in Figure 3-2. 
 

Chapter Three 
 
46
 
 
Figure 3-1. Bendix G-15 Computer System Advertisement 
Source: Bendix Corporation UNK 
 
 

Bendix G Machines 
47 
 
 
Figure 3-2. Bendix G-15 Advertisement 
Source: Bendix Corporation 1960 
 
The Bendix G-15 was an unpretentious, workhorse computer system. 
The basic cabinet was gunmetal gray, with approximate dimensions of 5 x 

Chapter Three 
 
48
3 x 3 feet and weighing about 950 pounds, some say “refrigerator-sized”. 
It drew about 3 KWatts of power. A Bendix G-15 has been displayed at 
the Smithsonian American History Museum, Washington, DC.  Figure 3-3 
depicts another Bendix G-15 advertisement that clearly shows the system 
cabinet. Figure 3-4 depicts a Bendix G-15 installed for the U.S. Navy. 
Table 3-1 presents the Bendix G-15 basic characteristics. 
 
 
 
Figure 3-3. Bendix G-15 Advertisement 
Source: Bendix Corporation, BULLETIN AB-059-R0460, circa 1960 

Bendix G Machines 
49 
 
 
Figure 3-4. Bendix G-15 installed at Naval Supersonic Laboratory at MIT 
Source: U.S. Navy, Weik 1961 
 
Table 3-1. Bendix G-15 Characteristics 
Characteristic 
Value/Explanation 
Internal 
Representation 
Binary Fixed Point 
# Bits/Word 
28 plus 1 sign bit 
#Instructions/Word 
1 
#Bits/Instruction 
28 
# Instructions 
60 
Instruction Type 
Two address 
CPU Technology 
Vacuum Tubes 
CPU Registers 
AR: single precision accumulator 
PN: double precision accumulator 
MQ, ID: double precision shift registers 
An input register 
Main Memory 
2160 word Magnetic Drum/16 words for registers 
Add Time 
Fixed Point: 275 microseconds 
Multiply Time 
Fixed Point: 1600 microseconds/Double Precision: 
3200  
Divide Time 
Fixed Point: 1600 microseconds/Double Precision: 
3200 

Chapter Three 
 
50
3.2 G-15 System Configuration 
Source: Bendix 1955j, Bendix 1955k 
 
The Bendix G-15 used 450 vacuum tubes and about 3,000 germanium 
diodes to implement its arithmetic and control unit. The Bendix G-15 used 
a magnetic drum of 2,160 word capacity for its primary storage. While 60 
operation codes were available, the G-15 used only 29 of these. 
The G-15’s magnetic drum had 20 tracks of 108 words each for main 
memory for a total storage of about 2716 words; these were known as long 
lines. One track was used for an I/O buffer, but lines 19 and 23 could also 
be used in a similar manner. Four tracks of 4 words were used for main 
memory registers; these were known as short lines. Several tracks were 
used for arithmetic and control. Thus, there were 27 opportunities (108 
divided by 4) to read a word from a long line during a single drum cycle, 
with an average access time of 0.54 milliseconds. The different line 
lengths allowed the programmer to trade-off between storage capacity and 
access time. The magnetic drum had separate read and write heads 
associated with each track – each optimized for their functions. All 
information was read, erased, and rewritten at every drum rotation-just like 
the mercury delay lines (Huskey 1984). 
The G-15 was a model of hardware simplicity. Instead of adding 
numbers as a word (e.g., 29 bits), it operated on them one bit at a time. It 
combined bits from two sources with a possible carry bit and immediately 
wrote the result bit to the destination word, while setting the carry bit for 
the next addition. The G-15 used a relative fast (for the time) clock rate of 
105 KHz. Programmers were trained to think in two times: word time of 
275 microseconds and drum cycle time of 29 milliseconds. 
The G-15 did not have a program counter. Rather, each instruction 
carried the address of the next instruction to be executed. Programmers 
rarely laid out instructions in adjacent memory locations, but rather 
distributed them in such a way that when one instruction finished 
executing, the next instruction would be available to be read in from the 
drum.  
The console was a Friden Flexowriter. Input and output were via paper 
tape. One to four MTA-2 magnetic tape units and an IBM 026 Card Punch 
could also be attached as optional devices. The magnetic tape units stored 
57 characters per linear inch. The tape unit could transfer 427 characters 
per second. Data was written to tape in blocks equivalent to the size of a 
drum line – 108 words. Paper tape was used as the backing store. Figure 3-
5 depicts the Bendix G-15 with an operator (Bendix UNKm). 
 

Bendix G Machines 
51 
 
 
Figure 3-5. Bendix G-15 with Operator’s Console 
Source: Bendix Corporation UNKm 
 
Later, a number of optional peripherals could be attached including 
graphical plotters and a digital differential analyzer with 54 integrators and 
54 constant multipliers, which supported the numerical solution of 
differential equations. 
3.2.1 Short Lines 
Eight rapid access lines, each holding four words, were located on the 
magnetic drum to provide data more than once per drum revolution. Four 
of these lines, short lines, were numbered 20 to 23. 
3.2.2 Registers 
Four other rapid access lines were used for registers. The four lines 
used for machine registers were named: 
Multiplicand/Denominator (ID) 
Product/Numerator (PN) 
Multiplier/Quotient (MQ) 
Accumulator (AR) 

Chapter Three 
 
52
The first three registers all held two words, while the accumulator held 
only one. ID, PN, and MQ were used in multiplication and division. Table 
3-2 depicts their roles in these operations. 
 
Table 3-2. Register Roles in Multiplication and Division 
Register 
Multiplication 
Division 
MQ 
Multiplier 
Quotient 
ID 
Multiplicand 
Denominator 
PN 
Product 
Numerator 
 
The AR and PN registers were used as accumulators to perform 
addition and subtraction.  
3.2.3 Command Lines 
Eight of the lines on the magnetic drum were assigned as command 
lines: long lines 0, 1, 2, 3, 4, 5, 19 and short line 23. Commands could 
only be executed from these lines and the accumulator. The particular 
command line could be selected by the programmer or by the operator 
from the keyboard. Commands were stored in any memory location, but 
had to be transferred to one of these lines or the AR to be executed. Once a 
command line was selected, all subsequent commands had to be taken 
from this line until: 
a.  The operator selected a new command line, or 
b. A special command taken from the command line causes a new line 
to be selected. 
 
Another special command caused the word in the AR register to be 
executed as a command, but then control reverted to the control line from 
which this command was taken. 
3.2.4 I/O System 
The buffered I/O system operated concurrently with the computation 
unit. A program could place 108 words into the I/O buffer (a long line), 
start an I/O operation, and perform other computations. Later, the program 
could test for I/O completion or wait for ready and then initiate another 
I/O operation.  

Bendix G Machines 
53 
3.3 G-15 Instruction Set 
Source: Bendix 1961o, 1962g 
 
The G-15 did not have a program counter. So, every instruction had to 
specify the address of the next instruction to be executed. A single 
command could operate on a single word or a selected group of words. A 
conditional transfer of control could be based on the existence of non-zero 
information, on the sign of a number, or on the overflow of an arithmetic 
register. Commands could operate directly on information stored in any 
drum channel. 
A memory address consisted of a line number and a word time from 0 
to 107, so 4:63 designated line 4, word 63. Figure 3-6 depicts the 
instruction format of the G-15. 
 
 
 
Figure 3-6. Bendix G-15 Instruction Format 
Source: Adapted from Weik 1961 
 
where: 
I = 0 and D < 31, execute a normal instruction 
I = 0 and D = 31, execute block mode instruction 
I = 1, execute in block mode 
 
T/Lk = 00 – 06 
BP = 1, set a breakpoint 
N = 00 – u6, next instruction to be executed 
C = 0 – 3, single precision, modified the load/store commands 
C = 4 – 7, double precision 
S = 00 – 31, source operand address (one of 20 long, 4 short lines) 
D = 00 – 31, destination operand address (one of 20 long, 4 short lines) 
P = 1, if breakpoint 
 
The S, D, and T/Lk fields determined the source and destination of the 
operands for the instruction. In normal instructions, T specified the word 
position of the operand on a line (drum track). The S and D fields 
specified the particular drum line on which the operands would be found. 
In multiply, divide, shift, and normalize commands, the T field specified 
the number of word times during which the command was allowed to 

Chapter Three 
 
54
execute. In block mode instructions, the T field specified the address of the 
end of the block.  
The notation Ln was used, where L0 was the address of the command, 
L1 the word time following the command, etc. The start of the block was 
determined by the word time during which the command was read. The 
block operations were valid for address L1 to Lk-1, where L1 was the word 
time after the reading of the command, and Lk-1 = Lk - 1. 
3.3.1 Special Values for S/D Fields 
Special values in the S field allowed bitwise Boolean operations 
between lines and the AR register; special values in the D field allowed 
addition or subtraction from the accumulator registers. Table 3-3 specifies 
these special values. 
 
Table 3-3. Special Values for S/D Fields 
Value 
In S Field 
In D Field 
0-19 
Long line (lines 0-5, 19 can 
hold commands, 19 also 
used for I/O) 
Long line (lines 0-5, 19 can hold 
commands, 19 also used for I/O) 
20-23 
Short line (line 23 can hold 
commands and used for 
I/O) 
Short line (line 23 can hold 
commands and used for I/O) 
24 
MQ 
MQ 
25 
ID 
ID 
26 
PN 
PN 
27 
(line 20 AND line 21) OR 
(NOT line 20 AND AR) 
Test for zero 
28 
AR 
AR 
29 
Line 20 AND (special 
input register) 
Add to AR 
30 
NOT Line 20 AND Line 
21 
Add to PN 
31 
Line 20 AND Line 21 
Indicates a "special" instruction. 
3.3.2 Special Instructions  
For special instructions, which performed I/O, where D=31, the S Field 
described the operation to be performed. An input or output operation for 
as many as 108 words could be initiated by a single command. The 
operation, which could be simultaneous with internal computation, 

Bendix G Machines 
55 
proceeded without intervention and terminate itself on completion. Table 
3-4 describes these special operations. 
 
Table 3-4. Special Instructions 
S Value 
Operation 
0 
Set "Ready" for regular Input-Output 
1 
Write on magnetic tape 
2 
Fast punch leader on punched tape 
3 
Fast punch Line 19 on punched tape 
4 
Search magnetic tape forward 
5 
Search magnetic tape reverse 
6 
Unassigned 
7 
Unassigned 
8 
Type out AR 
9 
Type line 19 
10 
Punch line 19 on tape 
11 
Punch line 19 on cards 
12 
Permit type in 
13 
Unassigned 
14 
Unassigned 
15 
Read punched tape 
16 
Halt 
17 
Test for PUNCH Switch On (Ring bell) 
18 
Send data to auxiliary equipment: Transfer information 
from Line 20 to Output Register under control of ID 
19 
Test "Ready" for Special Input (Output) Register; Start/Stop 
Differential Analyzer 
20 
Select command line and return (i.e., branch to command 
line C at the word time saved by the previous Mark; 
subroutine return) 
21 
Select command line and mark (i.e., branch to C:N and 
store T; subroutine call) 
22 
Test if sign of AR negative 
23 
Depending on C: 
- Clear multiplication and division registers, if C = 0 
- Extract and Copy into line 25 the bits of line 26 that 
correspond to bits in 2:T, clearing the extracted bits in line 
26, if C = 3 
24 
Multiply (T determines # iterations) 
25 
Divide (as above) 

Chapter Three 
 
56
26 
Shift MQ left and ID right (controlled by T or contents of 
AR) 
27 
Normalize MQ (shift left until no leading zeroes; add # 
places shifted to AR) 
28 
Test for Ready state of Regular Input-Output; Test if 
Differential Analyzer Off 
29 
Test for overflow (and clear the overflow bit) 
30 
Write file code on magnetic tape 
31 
Take next command from AR 
 
The C Field was called the “characteristic”. It was used to modify the 
load and store commands. 
3.4 Peripheral Devices 
The Bendix G-15 had multiple peripheral devices that could be 
attached to enhance performance. Various input-output devices were 
included: Typewriter, tape punch, and searchable photo-electric reader for 
punched tape were included in the basic price. Optional accessories 
included magnetic tape units and punched card equipment. Other 
accessories simplified the programming of differential equations, provided 
compatibility between the computer and external, data-processing 
equipment and prepared tape for machine tool control. Selected 
peripherals are discussed below. 
3.4.1 Magnetic Tape MTA-2 
Source: Bendix 1961n 
 
The Bendix MTA-2 Magnetic Tape units provided inexpensive, fast 
storage for the Bendix G-15. One to four MTA-2 units could be connected 
to the G-15 and each unit could be individually addressed. One MTA-2 
could store up to 300,000 words on standard half-inch magnetic tape. A 
tape could be searched for a block of up to 108 words or for files sections 
containing an arbitrary number of blocks. A tape could be searched in 
either the forward or backward direction at the rate of 2500 cps. 
Information could be read or written from the tape at 430 cps.  
 

Bendix G Machines 
57 
3.4.2 Digital Differential Analyzer DA-1 
Source: Bendix 1961n 
 
The Differential Analyzer DA-1 provided the G-15 with the capability 
to solve differential equations. The DA-1 was programmed using a similar 
technique to an analog differential analyzer, but with greater precision at 
seven decimal digits. The DA-1 provided 108 integrators and 108 constant 
multipliers. The integrators processed 34 times per second. The DA-1 
could solve a wide variety of problems expressed in the form of 
differential equations, including linear and non-linear differential 
equations, linear and non-linear simultaneous equations, solutions for roots 
of transcendental equations, and the simulation of real systems. The DA-1 
was enclosed in a cabinet the size of a standard filing cabinet and attached 
to the G-15 by cables. 
3.4.3 Graph Plotter PA-3 
Source: Bendix 1961n 
 
 
The Graph Plotter PA-3 was an incremental plotter that plotted output 
directly from the DA-1. Its plotting could begin at any point on the paper 
using a retractable pen, under manual or automatic control at speeds up to 
200 increments per second. 
3.4.4 Punched Card Coupler CA-1/CA-2 
Source: Bendix 1961n 
 
 
The Punched Card Coupler CA-1 was designed for use with an IBM 
Model 026 Card Reader-Punch. One or two units could be attached to a G-
15. When one was attached, it was used for both reading and punching 
standard 80-column cards. When two were attached, one read and one 
punched them under computer control. A program card inserted in the 
IBM 026 selected the columns to be read or punched. Cards were read at a 
rate of 17 columns per second and punched at a rate of 11 columns per 
second. 
 
The CA-2 operated similarly to the CA-1, but at a faster rate. It could 
read or punch cards at the rate of 100 cards per minute by summary 
punches, such as the IBM 514 or IBM 523. Output information could be 
tabulated at the rate of 100 lines per minute by the IBM 402. Up to three 

Chapter Three 
 
58
IBM units could be attached to a CA-2. The flexibility of these IBM units 
extended the I/O versatility of the G-15. 
3.4.5 Universal Code Accessory AN-1 
Source: Bendix 1961n 
 
 
The Universal Code Accessory AN-1 enabled the G-15 to connect to 
external, data processing equipment. It also provided paper tape for 
machine tool control. The user typed a specification on a Flexowriter to 
prepare a six-channel paper tape. After the tape was read into the G-15 via 
the AN-1 paper tape reader, computations were performed and the G-15 
directed the AN-1 to punch a seven-channel control tape, which could then 
be read by machine tool control units.  
 
The AN-1 accepted alphanumeric or numeric input and entered the 
data directly into the computer’s memory, where it was converted to the 
format required by the G-15. Results could be read out in any numeric or 
alphanumeric format. The HSR-8 reader and HSP-8 punch were included 
with the AN-1.  A modified Flexowriter could also be attached to the AN-
1. 
3.5 Programming Languages 
 
The Bendix G-15 was able to execute several programming 
languages, including FORTRAN and ALGO, a language for expressing 
mathematical equations. ALTRAN was a system that translated simple 
symbolic commands into optimized G-15 machine code. It was similar to a 
basic assembly language processor (Bendix 1962p). 
3.5.1 ALGO 
Source: Bendix 1960d 
 
 
ALGO was an algebraic language, much simpler than FORTRAN, 
which allowed the user to develop and run simple programs specified in 
symbolic form (unlike Intercom 1000). ALGO contained two types of 
lines: declaration and statements. Declarations specified information about 
the contents of the program, while statements described actions to be 
performed. A declaration was identified by the first five letters of the 
word, but the programmer could enter the entire word. A simple ALGO 
program is depicted in Figure 3-7. 

Bendix G Machines 
59 
01. TITLE find u[i] 
02. LIBRAry SIN(0101000) 
03. SUBSCript i 
04. BEGIN 
05. x == KEYBD 
06. FOR i == 0 (1) KEYBD   BEGIN 
07. U == EXP x + x ^ 5 + sin x 
08. PRINT (FL) == x 
09. PRINT (FL) == u 
10. CARR(2) 
11. x == x + 01  END 
12. END 
 
Figure 3-7. Simple ALGO Program 
Source: Bendix 1960d 
 
ALGO had a number of built-in operators – trigonometric, LOG, EXP, 
ABS and SQRT – to simplify the programmer’s computational task. The 
keyword KEYBD specified input taken from the attached alphanumeric 
typewriter, and the keyword PRINT caused the value to be type on it. (FL) 
specified floating-point notation, while (F) specified fixed-point notation. 
CARR specified a carriage return. Other keywords included BELLS, 
PERIOD, and TABS. 
ALGO programs were prepared in two steps. First, the program was 
entered into the computer, usually from paper tape, where the ALGO 
system translated it into an “object” program. Then, the object program 
was executed to solve the problem. The ALGO Operating instructions 
(Bendix 1960e) describe this process and the different peripherals to input 
and output data used. 
Bendix compared programming in ALGO to using a slide rule to show 
how much easier it was to use the computer. Figure 3-7 depicts an 
advertisement for the ALGO programming language for the Bendix G-15. 
(Bendix 1960d, Bendix 1961e, Bendix UNKm) 
 

Chapter Three 
 
60
 
 
Figure 3-7. Bendix G-15 ALGO Programming Language 
Source: Bendix Corporation UNKm 
 

Bendix G Machines 
61 
ALGO compiled programs written in a subset of the Algol 
programming language. ALGO handled numbers in the range from 10-14 to 
1014-1. The program also handled both fixed and floating point numbers. 
3.5.2 Intercom 1000 
Source: Bendix UNKr, Bendix 1961b, Bendix 1961n 
 
Intercom 1000 was an easy-to-use, interactive programming system 
(Bendix 1955, Bendix 1961b). Bendix claimed that if one could use a desk 
calculator, one could learn to use an electronic computer and program it in 
Intercom 1000 (Bendix UNKr). 
Numbers were accepted by Intercom 1000 exactly as they were 
written. There was no need for scaling, such as moving the decimal point 
to the far left in order for them to be accepted. Since numbers were stored 
internally in floating point format, Bendix asserted that overflow was 
unlikely to occur. In fact, overflow only occurred if a number exceeded 
1038. Numbers less than 10-38 were assumed to be equivalent to zero. 
Computations were performed with either five-digit or twelve digit 
accuracy which was selectable by the programmer. 
 
3.2.5.1 Commands 
 
The operator could type a command and see the immediate results of 
his instructions. Intercom 1000 was provided in two forms: single 
precision and double precision. The single precision version handled up to 
1200 5-digit words, while the double precision version handled up to 1000 
12-digit words. In the single-precision version, numbers could be stored at 
any addresses while in double precision mode, numbers were stored at two 
address on even-numbered boundaries. 
Commands were comprised of 7 digits: the first digit specified the 
index register, the next two the opcode, and the last four the operand 
address. Intercom 1000 Single-Precision defined memory locations to 
number from 0700 to 1899 inclusive. The other memory locations were 
used for intermediate results and storage of the Intercom program. The 
address consisted of two digits representing a channel on the magnetic 
drum, while the last two digits referred to a word position within a 
channel. Table 3-5 summarizes the Intercom 1000 commands. 
 
 

Chapter Three 
 
62
3.2.5.2 Index Registers 
 
Index registers were used to specify the number of times a set of 
commands could be executed using different addresses each time. The 
contents of the address in the command were modified by the value found 
in the index register. 
Intercom 1000 provided nine index registers, numbered 1 to 9. As 
noted above, the index register was the first digit of the command. Each 
index register contained a word base (WB), a word difference (DWD), and 
a word limit (WL). The contents of the specified index register’s WB were 
added to the address of the command when the command was executed. 
The WB value could be changed by an instruction (see below) after an 
initial value assignment. 
 
3.2.5.3 Accumulator 
 
A special memory location was designated the accumulator. Arithmetic 
operations were performed with the accumulator providing one of the 
operands. The numerical constants zero and one were often needed in 
arithmetic operations. Rather than consuming a memory location to hold 
them, the value of zero could be placed in the accumulator by executing 
the Subtract instruction (41) with the accumulator address in the address 
portion of the instruction. Similarly, if the accumulator did not contain 
zero, a value of one could be placed in the accumulator by executing the 
Divide instruction (48) with the accumulator address in the address portion 
of the instruction.  
 
3.2.5.4 Subroutines in Intercom 1000 
 
A subroutine was a previously prepared sequence of commands, 
performing oft-used functions, which could be loaded into memory from 
paper tape or console. It could then be jumped to by opcode 08. 
Alternatively, subroutines could be jumped to and returned from by means 
of the ‘Mark Place and Transfer’ commands. 
Intercom 1000 had a large library of subroutines written by many 
contributors. Typically, the programmer loaded a value into the 
accumulator, performed the subroutine, and retrieved the new value from 
the accumulator. 
 
 
 

Bendix G Machines 
63 
Table 3-5. Intercom 1000 Commands 
Opcode 
Command 
Description 
 
Transfer Control 
Commands 
 
06 
Type Location of 
Last Command 
Executed 
The address of the last command executed 
was typed out; then, the typewriter carriage 
was moved to the next tab stop. 
08 
Perform 
Subroutine 
Execute the subroutine beginning at 
address. 
16 
Return To 
Marked Place I 
Control was transferred to the address in 
the special register. [It had no effect if the 
special register had not been loaded by a 
“Mark Place and Transfer I” command.] 
18 
 
Return To 
Marked Place II 
Control was transferred to the address in 
the special register. [It had no effect if the 
special register had not been loaded by a 
“Mark Place and Transfer II” command.] 
20 
Transfer Control  
If AR >= 0 
If c(AR) >= 0, then the next command was 
found at address; else, it was in the next 
location. 
22 
Transfer Control  
If AR < 0 
If c(AR) < 0, then the next command was 
found at address; else, it was in the next 
location. 
23 
Transfer Control 
If AR = 0 
If c(AR) = 0, the next command was found 
at address; else, it was in the next location. 
26 
Mark Place and  
Transfer I 
The current address was stored in a special 
register; control was transferred to the 
instruction in address. 
28 
Mark Place and  
Transfer II 
The current address was stored in a special 
register; control was transferred to the 
instruction in address. 
29 
Transfer Control  
Unconditionally 
Control was transferred to the next 
command at address. 
 
Arithmetic 
Commands 
 
40 
Clear and 
Subtract 
The contents of the accumulator were 
replaced by the contents of the address 
with the sign reversed. 
41 
Subtract 
The 
contents 
of 
the 
address 
were 
subtracted from the accumulator; the 
difference replaced the contents of the 

Chapter Three 
 
64
accumulator. 
42 
Clear and Add 
The contents of the address replaced the 
contents of the accumulator. 
43 
Add 
The contents of the address were added to 
the accumulator; the sum replaced the 
contents of the accumulator. 
44 
Multiply 
Multiply the contents of the accumulator 
by the contents of the address; result 
replaced the contents of the accumulator. 
45 
Clear and Add 
Absolute Value 
The absolute value of the contents of 
address replaced the contents of the 
accumulator. 
47 
Inverse Divide 
The contents of the address were divided by 
the contents of the accumulator; the quotient 
replaces the contents of the accumulator. 
48 
Divide 
The contents of the accumulator were 
divided by the contents of the address; the 
quotient replaces the contents of the 
accumulator. 
49 
Store 
The contents of the accumulator were 
stored at address. 
 
I/O Commands 
 
30 
Position 
Typewriter Paper 
Execute carriage returns to position 
typewriter at a specific line (from 00 to 
99); then, position at tab stop 00-31. 
31 
Type Tabulating 
Number and Tab 
The number in address was typed out; and 
moved the carriage to the next tab stop. 
The address was a four-digit number in the 
range 0000 to 3000. 
32 
Type Floating 
Point 
Number and Tab 
The contents of address were typed out in 
floating point notation with proper placement 
of the decimal point. The typewriter carriage 
moved to the next tab stop. 
33 
Type Fixed Point 
Number and Tab 
The contents of address were typed out in 
fixed point notation with proper placement 
of the decimal point. The typewriter 
carriage moved to the next tab stop. 
34 
Type Floating 
Point 
Number and 
Return Carriage 
The contents of address were typed out in 
floating point notation with proper 
placement of the decimal point. The 
typewriter carriage moves to the next line. 

Bendix G Machines 
65 
35 
Type Command 
From Memory 
The command at address was typed out in 
the form 
“K Word Opcode Channel”  
38 
Type Fixed Point 
Number and 
Return Carriage 
The contents of address were typed out in 
fixed point notation with proper placement 
of the decimal point. The typewriter 
carriage moved to the next line. 
39 
Punch Paper 
Tape 
The first two digits of address specified a 
channel beginning at word 00 to the word 
in address-1. 
50 
Permit Command 
Type-in 
Computation halted. If a command, 
followed by <tab> was entered, the 
command was stored in address and 
computation proceeded. 
51 
Permit Type-in 
of 
Fixed Point Data 
Computation halted. If a number, followed 
by <tab> was entered, the number was 
stored in address and computation 
proceeded. 
52 
Permit Type-in 
of 
Floating Point 
Data 
Computation halted. If a number, followed 
by <tab> was entered, the number was 
stored in address and computation 
proceeded. 
 
Special 
Commands 
 
63 
Ring Bell 
Sound the bell on the typewriter once. 
67 
Halt and Permit 
Manual 
Operation 
Computation was halted. Computer entered 
manual operating mode.  
68 
Breakpoint Halt 
Computation was halted. Resume 
computation by pressing the Compute 
switch on the typewriter. 
69 
Compute 
Automatically 
Computation began at address and 
continued until opcode 67 is executed. 
 
Index Register 
Commands 
 
70 
Assign Word 
Base 
The last two digits of address were 
assigned to WB of the specified index 
register. 
71 
Assign Word 
Difference 
The last two digits of address were 
assigned to WD of the specified index 
register. 

Chapter Three 
 
66
72 
Assign Word 
Limit 
The last two digits of address were 
assigned to WL of the specified index 
register. 
73 
Assign Channel 
Base 
The first two digits of address were 
assigned to CB of the specified index 
register. 
74 
Assign Channel 
Difference 
The first two digits of address were 
assigned to CD of the specified index 
register. 
75 
Assign Channel 
Limit 
The first two digits of address were 
assigned to CL of the specified index 
register. 
76 
Increment Word 
Base 
The WD of the specified index register was 
added to the WB; the sum replaced the 
contents of the WB. If c(WB) <= c(WL), 
control was transferred to the command in 
address. Otherwise, the next command in 
sequence was executed. 
77 
Increment 
Channel Base 
The CD of the specified index register was 
added to the CB; the sum replaced the 
contents of the CB. If c(CB) <= c(CL), 
control was transferred to the command in 
address. Otherwise, the next command in 
sequence was executed. 
Note: Bendix used the word ‘channel’ to refer to a magnetic drum line consisting 
of 108 words. 
3.5.3 Sample G-15 Program 
Bendix claimed that Intercom 1000 could be learned in two days of 
instruction and practice. Users wrote out their programs on coding forms, 
punched them on paper tapes, and input them to the machine. A simple G-
15 program to add two numbers is presented in Table 3-6 and gives a 
flavor of how programs might be written using Intercom 1000. 
 
 
 

Bendix G Machines 
67 
Table 3-6. Sample G-15 Intercom 1000 Program to add Two Numbers 
Location 
K 
Opcode 
Address 
Notes 
1400 
1 
70 
0000 
Assign 00 to WB 
1401 
1 
71 
0001 
Assign 01 to WD 
1402 
1 
72 
0099 
Assign 99 to WL 
1403 
0 
42 
1500 
Clear Accumulator 
1404 
1 
43 
1600 
Add 
contents 
of 
Address 
to 
Accumulator 
1405 
1 
76 
1404 
Increment Word Base 
1406 
0 
49 
1502 
Store Accumulator 
 
The program depicted in Table 3-7 computes the value of (a2 – bc)/d 
(Bendix 1961b). 
 
Table 3-7. Sample G-15 Intercom 1000 Program to Compute (a2 – 
bc)/d 
Location 
K 
Opcode 
Address 
Notes 
0900 
0 
42 
1102 
Clear accumulator and add b 
0901 
0 
44 
1104 
Multiply b, in accumulator, by c 
0902 
1 
49 
1108 
Store bc 
0903 
0 
42 
1100 
Clear accumulator and add a 
0904 
0 
44 
2100 
Multiply a, in accumulator, by a 
0905 
0 
41 
110 
Subtract bc from a2 
0906 
0 
48 
1106 
Divide a2 – bc by d 
0907 
1 
33 
2100 
Type contents of accumulator in 
fixed point form 
…. 
 
 
 
Storage for numbers 
1100 
 
 
 
a 
1102 
 
 
 
b 
1104 
 
 
 
c 
1106 
 
 
 
d 
3.6 Tracking Station Application 
According to Weik (1961), Bendix G-15 computer systems were used 
at Air Force Tracking Stations at Tyndall Air Force Base, Cape San Blas 
and Carabelle, Florida. Data were transferred from the two tracking sites 
to Tyndall where a computing site was located. A program converted 
direction cosines measured from x & y baselines for up to three 
approaching targets and frequency correction words for each target 

Chapter Three 
 
68
transmitted. Although the system was basically designed for scoring air-to-
air missile firings it was successfully used to track missiles fired from the 
ground. 
3.7 G-15 Assessment 
While the LGP-30 and the Packard-Bell 250 had similar architectures, 
only the LGP-30 was as commercially successful as the Bendix G-15. 
According to the Australian Computer Museum, about 300 G-15s were 
built (Smillie 2002). However, others have suggested that over 400 of 
these machines were sold before Control Data acquired the Bendix 
computer division.  A strength of the G-15 was its ability to optimize 
programs for a recirculating memory. The G-15 could also make a claim 
for being the world’s first “personal computer” as it supported a single 
user at a time.  
The Bendix G-15 appears to be the first personal computer based on 
the Intercom 1000 interpretive system, which predated BASIC by several 
years. It has been argued that the LINC and the PDP-8 should also be 
considered, but the Bendix G-15 predated these machines by at least five 
years, so, that argument seems spurious. 
Bendix was also one of the first firms to provide a detailed 
programming guide for the G-15 (Bendix 1960q). This four-part manual 
described numerous routines and algorithms for programming the G-15. 
Optimizing programs for the G-15 was an art – often slowly learned. 
However, the Bendix G-15 was an architectural dead-end. 

FURTHER READING 
 
 
 
Bendix Computer Division. 1956. G15 Automatic Programming Systems, 
AR-1060 
—. 1960. Programming for the Bendix G-15: Parts 1-4 
Boermeester, J. M. 1954. “Analysis of Business Application Problems on 
IBM 650 Magnetic Drum Data-processing Machine’, AIEE-IRE 
Proceedings of the Eastern Joint Computer Conference, pp. 79-81 
Copeland, B. J. 2005. Alan Turing’s Automatic Computing Engine: The 
Master Codebreaker's Struggle to Build the Modern Computer , 
Oxford University Press, Oxford, England 
Evans, D., and H. Huskey. 1954. “The Bendix G15 General Purpose 
Computer”. Proceedings of the WESCON Computer Sessions, Los 
Angeles, pp. 87-91 
Frankel, S. 1957. “The logical design of a simple general purpose 
computer”, Transactions of the I.R.E. Professional Group on 
Electronic Computers, EC-6/1 
Huskey, H.D. 2004. Harry D. Huskey: His Story. Booksurge Publishing 
—. “The ACE Test Assembly, the Pilot ACE, the Big ACE, and the 
Bendix G15”. In Copeland, B. J., Alan Turing's Automatic Computing 
Engine, chapter 13, pages 281–295. Oxford University Press 
IBM. 1956. IBM 650 Data Processing System: Additional Features, Form 
22-6319-1 
—. 1956. IBM 650 Data Processing System with 355 Random Access 
memory and 838 Inquiry Stations, 22-6270-1 
Lebson, S.  2010. “Stan Frankel: Unrecognized Genius”,  
 
http://www.hp9825.com/html/stan_frankel.html 
—. UNK. “The Magnetic Drum of Gustav Tauschek“,  
 
http://historycomputer.com/ModernComputer/Basis/magnetic_drum.html 

EXERCISES FOR THE READER 
 
 
 
1. The IBM 650 Additional Features manual proposed a number of test 
problems to work to improve one’s skills. Here are a few of them to be 
used with the IBM 650 simulator. In each case, write the program and run 
it on the simulator.  
 
a.  Store 6 words from high speed storage onto band 1800 of the drum 
beginning at word 9000. What is the position of the Timing Ring at 
the end of transfer? 
 
b.  What is the position of the Timing Ring at the completion of the 
following program: 
 
SET 
27-9016 
STBB 
28-1201 
LB  
09-1343 
 
c.  Reset IA-C to zero, then add the contents of IA-B to it. 
 
2. Write a simulator for a magnetic drum model of your choice. Then, 
write a program to implement the calculations of the Optimum Address 
Locator. Demonstrate both programs with a visual display. [Hint: see 
www.bitsavers.org for some magnetic drum manuals.]  
 
3. Develop a simulator for the Bendix G-15 Intercom 1000 programming 
system. Select several projects from Bendix G-15 User Projects, Volume 1 
and Volume 2, available at the Bitsavers.org website, code them, and 
demonstrate the working of your simulator. 
 
4. Compare and contrast the capabilities of the early versions of the 
BASIC programming language, as initially defined by Kemeny and Kurtz. 
Are these languages substantially similar or different and how? 
 
5. Develop a simulator for the Bendix G-15 computer system. Carefully 
consider how you will emulate the magnetic drum. Build the first version 
without timing and the second version with timing. Demonstrate that you 
simulator emulates a G-15 with high fidelity. 

Birthing the Computer: From Drums to Cores 
71 
6. The Bendix G-15 performed arithmetic operations on operands serially, 
e.g., one bit at a time, rather than word-parallel mode. This made the 
computational circuitry much simpler than corresponding machines and 
also reduced costs. Select a word-parallel machine from this volume and 
compare parallel versus serial execution of arithmetic operations: 
 


PART II 
CORE MEMORY MACHINES 
 
 
 
 
Magnetic core memory was a paradigm shift (following Thomas 
Kuhn’s model) that revolutionized the computer industry. Once 
engineering processes were developed to produce core memory cheaply 
(e.g., much cheaper than CRTs), main memory capacity on computing 
machines exploded over night. Larger memories meant larger programs, 
more data, and more complex problems solved. Core memory was utilized 
in most computers from the mid-1950s until the early 1980s, although by 
the end of the 1980s it had become very much a slower and lower-cost 
option for most machines. 
 
Chapters: 
Chapter Four: RCA BIZMAC 
Chapter Five: Ferranti Atlas 
Chapter Six: JOHNNIAC 
 
 

Part II 
 
74
Magnetic Core Technology 
Magnetic core memory is a random access memory (RAM) system that 
was developed at MIT by Jay Forrester in 1951. The memory consists of 
an array of ferrite toroids (or cores) that are about 11 millimeters in 
diameter. A core is required for each bit of memory. Each core has three 
wires passing through it that provide the means to select and detect the 
contents of each bit. 
 
Core memory works through the property of hysteresis of the magnetic 
material used to make the toroid. A magnetic field over a certain intensity 
(generated by the wires through the core) will cause the core to change its 
magnetic polarity (or state from '0' to '1'). To select a memory location, 
one of the X and one of the Y lines are driven with half the current 
required to cause this change. Only the combined magnetic field generated 
at the intersection the driven X and Y lines is sufficient to change the state 
of the bit. The following figure depicts this arrangement: 
 
 
 
The common sense/inhibit line for each bit, is used to alter or detect the 
contents of a memory location. Every memory access involves a read/write 
cycle. A read cycle is always destructive; the memory contents are lost 
after the location is read. A read cycle must be followed by a write cycle to 
restore the contents of the memory location. A read cycle behaves as 
follows: 
 
The address of the memory location to be read is decoded into X and Y 
coordinates. Only one X and Y line is driven with a pulse of current to 
access the required location All other memory locations will at worst, only 

Core Memory Machines 
75 
have half the required magnetic pulse, and will not be affected. If the 
memory bit accessed in already in the 0 state, the sense/inhibit will not 
detect a change, and the location will have a value of 0. If the memory bit 
accessed was in the 1 state, then the combined pulse of current with flip it 
into a 0 state, and the sense/inhibit will detect the pulse created by the 
change, so the location will have a value of 1 
 
A write cycle will always follow a read cycle. Either new data is written, 
or the old data is put back. A write cycle behaves as follows: 
 
A read cycle must have preceded the write to set all the bits in the word to 
0. The address of the memory location to be written is decoded into its X 
and Y coordinates. Only one X and Y line is driven with a pulse of current 
to access the required location. This pulse is in the opposite direction to 
the read current.  All other memory locations will, at worst, only have half 
the required magnetic pulse, and will not be affected. 
 
If the memory location is to contain a 0, the sense/inhibit line is driven 
with sufficient current to neutralize the effect of the XY lines and the 
memory location will be unaffected and stay in the 0 state.  If the memory 
location is to contain a 1, the sense/inhibit line is not driven, and the XY 
lines will flip the memory core into the 1 state.  
 
Core memory is said to be non-volatile and will not lose its contents when 
the power is removed. A picture of magnetic core memory is presented in 
the following figure. 
 
 
 
 

Part II 
 
76
Jay Wright Forrester (1918 – 2016) 
Jay Forrester was born in 1918 in Nebraska on a cattle ranch without 
electricity. At age 12, he built an electrical system for the ranch from used 
car parts. He graduated from the University of Nebraska in 1939 in 
electrical engineering, and then headed to MIT to pursue a Ph.D. 
 
During World War II, he worked on developing servomechanisms to 
control radar antennas and gun mounts. After the war, he built an 
advanced aircraft flight simulator, which evolved into the Whirlwind 
digital computer. Whirlwind became the basis for SAGE. Although 
several people conceived of magnetic core memory, Forrester received the 
principal patent for his invention of the co-incident core memory that 
enabled the 3D storage of information. Thus, he is credited as the “Father 
of magnetic core memory”. 
 
In 1956, Forrester joined the Sloan School of Management. From the late 
1950s on, he focused on the development of system dynamics (arising 
from his earlier work in servomechanism and feedback control) that 
became a mainstay of the simulation and modeling community. 
 
Dr. Forrester later developed system dynamics as an analytical method 
which he pioneered through his book, Industrial Dynamics. He continued 
to develop this concept as well as to focus on education throughout the 
remainder of his career.  
 
Dr, Forrester died peacefully in his sleep on November 16, 2016 
 
[Personal Note: In 2005, at a DARPA PCAS meeting at MIT, I arranged 
for Jay W. Forrester to come speak to the participants for an hour on 
system dynamics and modeling – a significant event and rare honor. 
Professor Forrester gave a spirited lecture encouraging our program to 
continue to explore the benefits of simulation and modeling in 
understanding our world and educating our students.] 
 

CHAPTER FOUR 
RCA BIZMAC I/II 
 
 
 
The Radio Corporation of America (RCA) was involved in computer 
design from the earliest days. It built several small machines in its research 
laboratories. The Institute for Advanced Studies (IAS) computer intended 
to use the RCA Selectron Tubes for its memory. However, the reliability 
of the Selectrons was not satisfactory and IAS used Williams Tubes 
instead. This motivated RCA to focus its research on magnetic core 
memory. 
RCA introduced the BIZMAC, a large computer designed for business 
use, in 1956. This was RCA’s first foray into the field of commercial 
computing. It had about 25,000 vacuum tubes and used magnetic core 
memory, backed up by a magnetic drum. Rosen (Rosen 1969) believes 
that RCA may have been the first computer manufacturer to build an 
operational coincident current magnetic core memory.  
BIZMAC programs were stored on drum, but loaded into the magnetic 
core memory to be executed via block transfers of 32 instructions at a 
time. The BIZMAC was a variable word length computing machine. RCA 
claimed this feature minimized the amount of filler used on magnetic 
tapes. As one of the bottlenecks in many data processing centers was the 
loading and unloading of magnetic tapes, RCA tried to minimize or 
eliminate this problem by allowing the BIZMAC to attach up to 200 
magnetic tape drives. Thus, program-required data would almost always 
be available. Figure 4-1 depicts the BIZMAC console. 
 

Chapter Four 
 
78
 
 
Figure 4-1. RCA BIZMAC Used For Military Application 
Source: U.S. Army 
 
In the above picture, Arthur Malcarney of RCA explains the control 
panel to Brigadier General Nelson Lynde of the U.S. Army Ordnance 
Tank Automotive Command (OTAC) in Detroit, Michigan. The Army 
purchased the $4.2 million machine containing 30,000 vacuum tubes and 
60,000 diodes for inventory management (Howe 2005). It was used by the 
U.S. Army to keep track of the 2 billion spare parts for its various tanks. 
Owings (1956) describes the operation of the BIZMAC at OTAC. Figure 
4-2 depicts the entirety of the BIZMAC computing machine at the U.S. 
Army Ordnance Tank Automotive Command near Detroit, Michigan. 
  

RCA BIZMAC I/II 
 
79 
 
 
Figure 4-2. RCA BIZMAC at U.S. Army Tank Automotive Command 
Source: Weik 1961, U.S. Army 
 
The BIZMAC installation at OTAC required 20,000 square feet and 
consisted of 45 computer cabinets and 180 tape units. Total memory was 
8K characters and the magnetic drum stored 32K characters with a 512 
millisecond access time. The computer system consumed about 360 
KWatts and required over 15 tons of air conditioning capacity. 
The BIZMAC was operated for several years, but competition from 
IBM computers, notably the IBM 705, rendered its architecture obsolete. 
The OTAC machine was decommissioned in 1962 and shipped to the U.S. 
Army Signal Corp for disposition.  Another installation was the Higbee 
Department Store in Cleveland, Ohio, where it supported point of sale 
operations. However, this application was not very successful, and the 
machine was sold back to RCA. Both Travelers Life Insurance Company 
and New York Life Insurance Company acquired BIZMACs and operated 
them for several years. 
The BIZMAC I was superseded by the BIZMAC II in 1960. It was 
functionally equivalent to the BIZMAC I, but incorporated 8192 
characters of memory and a 32K character magnetic drum. The BIZMAC 
II is depicted in Figure 4-3 as located at the RCA Camden EDP Facility 
(Weik 1961). 
 

Chapter Four 
 
80
 
 
Figure 4-3. RCA BIZMAC II 
Source: Weik 1961 
 
Only six BIZMACs were manufactured and delivered. It appeared on 
the cusp of the transition to transistor-based machines which provided 
much enhanced performance at lesser cost. Poor performance and limited 
capability led to its replacement by the RCA 501. According to Weik 
(1961), a good operating week averaged about 92 hours. A typical 
BIZMAC installation required 470 cabinets. Table 4-1 presents the basic 
characteristics of the RCA BIZMAC. 
 
Table 4-1. RCA BIZMAC Basic Characteristics 
Characteristic 
Value/Explanation 
Internal Representation 
Fixed Point Decimal 
# Bits/Word 
 
#Instructions/Word 
 
# Instructions 
24 basic, 140 total (variations on the basic 
instructions) 
#Characters/Instruction 
8 characters/word 
Instruction Type 
Three Address Code 

RCA BIZMAC I/II 
 
81 
CPU Technology 
Vacuum Tube/Diode 
28,759 tubes; 12 types 
62,897 diodes 
CPU Registers 
Counters A, B, C; Memory Registers; Surge 
Length Register; Program Counter 
Main Memory 
Magnetic Core: 4KB, 20 microseconds/byte 
access time 
Magnetic Drum: 18K characters, 5.1 
milliseconds/byte access time 
Magnetic Tape: 5.0 milliseconds/byte access 
time 
Add Time 
120 +40c microseconds (C = # characters in 
longest operand) 
Multiply Time 
160 + 288N +145MN where M = #digits in 
multiplicand and N = # digits in multiplier. 
Divide Time 
Varies based on algorithm used 
 
The Computer History Archives Project produced a 9-minute video of 
the RCA BIZMAC which can be found on YouTube as:  RCA BIZMAC 
Computer History Archives Project - Cold War Military Technology, 
https://www.youtube.com/watch?v=JcPT7QDJlko. 
4.1 BIZMAC System Architecture 
Source: Beard, Bensky, Nettleton, and Poorte 1956 
 
The BIZMAC I was a vacuum tube machine. Memory consisted of 
4,096 characters of magnetic core storage with 20 microseconds access. A 
magnetic drum of about 18,000 characters provided additional program 
and data storage. Data was transferred between memory and the magnetic 
drum in blocks of 8 characters at 80 microseconds per block. Longer term 
storage was provided through magnetic tape (125 characters/inch, 7-bit 
code) which could read/write characters at 10,000 characters/second. Its 
system architecture is depicted in Figures 4-4(a) and 4-4(b). 
 
 

Chapter Four 
 
82
 
 
Figure 4-4(a). BIZMAC System Architecture 
Source: Adapted from Beard, Bensky, Nettleton, and Poorte 1956 
 
 
 
 
Figure 4-4(b). BIZMAC System Architecture 
Source: Adapted from Beard, Bensky, Nettleton, and Poorte 1956 

RCA BIZMAC I/II 
 
83 
The A, B, and C counters were used to address high speed memory. A 
was associated with the left bank, B with the right bank, and C with either 
bank. Each memory location was individually addressable by these 
registers. The program counter kept track of the current instruction within 
the program being executed. It was also used to locate blocks of 
instructions to be transferred from auxiliary memory to main memory. The 
program sub-counter was used as a conventional program counter to step 
through instructions in the magnetic core memory.  
Programs were stored in the auxiliary memory. To achieve a 
reasonable execution time, small blocks of instructions were moved from 
auxiliary memory to main memory. This process was referred to as the 
surge of instructions. Blocks of instructions ranged from four words up to 
64 words in multiples of four. Blocks of instructions were automatically 
surged by the hardware. The program sub-counter kept track of the last 
instruction in a block of instructions so that hardware could initiate an 
automatic surge of the next block of instructions. 
When instructions were read from main memory, both banks of 
memory were accessed by the program sub-counter. Four 20 microsecond 
cycles were required to read an instruction as the hardware read two 
characters per cycle. At the completion of the read operation, instruction 
execution was initiated. 
 
RCA Selectron Vacuum Tube 
The RCA Selectron Tube was a large vacuum tube designed by Jan 
Rachman in the early 1950s. Each tube provided 256 bits of storage. A 
thermionic cathode was aligned with the axis, while a dielectric formed the 
curved surface. Bits were read and written by a series of “holding beams” 
controlled by a precise alignment of internal circuit elements. Once a 
Selectron tube was “burned in” it was extremely reliable. Moreover, it was 
not subject to memory loss due to power failure. 
4.2 BIZMAC I/O System 
RCA tried to eliminate the loading and unloading of magnetic tapes by 
providing the capability to attach 100 to 200 tape drives to the machine. 
However, the price of tape drives at that time made such a scheme 
prohibitive as the tape drives would have cost more than the computer 
system. Only the OTAC system mentioned above had nearly a full 
complement of tape drives. 
Additional I/O peripherals included a card reader, which transcribed to 
magnetic tape, and a paper tape reader/writer. A 300/600 line per minute 

Chapter Four 
 
84
printer provided hard copy output, and special-purpose sorters with built-
in programming could be attached to the system to facilitate faster tape 
sorts. 
4.3 Data Representation 
The RCA BIZMAC was a fixed point computing machine that 
supported decimal and binary. Operands were variable length, but, decimal 
arithmetic operands were limited to 32 characters due to end-around carry. 
The BIZMAC code was designed such that each character (7 bits) 
included a single parity bit for even parity checking. The various devices 
in the system checked parity on each transfer. The character code 
consisted of 63 characters including ten decimal digits, 26 letters, control 
symbols, and miscellaneous symbols. 
A variable number of characters preceded by a control character 
comprised an item (like a word in other computing machines). 
4.4 BIZMAC Instruction Set 
The BIZMAC used a three address instruction format, where the 
addresses were two characters each – specified as Address-1, Address-2, 
and Address-3. Each address character consisted of 6 bits yielding 
addressability of 4,096 memory locations. The seventh bits were used for 
parity checking. The Basic Opcode specified the basic instruction and V 
specified variations to the basic instruction. An instruction consists of 8 
BIZMAC characters interpreted as depicted in figure 4-5.  
 
 
 
Figure 4-5. RCA BIZMAC Instruction Format 
Source: Weik 1961 
 
Each address specified the least significant characters of the operands 
and the result. Characters were fetched right-to-left until a control symbol 
or a space character was encountered. BIZMAC provided 22 basic 
instructions which could be varied to yield 140 distinct operations. 

RCA BIZMAC I/II 
 
85 
4.5 BIZMAC Assessment 
According to Rosen (1969), the BIZMAC was one “of the interesting 
failures” of the first generation of computing machines because RCA 
misread the developing computer field. As magnetic core memory became 
prevalent, larger memories that provided more capacity quickly became 
available. Users did not want small core memories backed up by slow 
magnetic drums. By the time the BIZMAC appeared in the marketplace in 
1958, magnetic core technology was becoming readily available. RCA 
was not agile enough to switch the BIZMAC design to magnetic core 
technology. 
The BIZMAC interconnected its components through a relay switching 
system. This was the first implementation of such a scheme, but it would 
be tried again in later machines. As Rosen notes, a mechanism similar to 
telephone dialing allowed tapes and sorters to be dynamically connected to 
each other. After sorting, the tapes could be switched to output devices for 
printing or punching. 
One of the first uses of BIZMAC after installation at OTAC was to 
compute the predicted batting averages for a dozen star players for the 
1957 baseball season. The goal was to demonstrate for the public the 
utility of this computer system. Data from the previous five seasons were 
fed to the computer. After serious number crunching and analysis, 
BIZMAC made predictions which were published in The Sporting News 
March 20, 1957 issue. The average deviation between the computer’s 
prediction and the actual batting average was 10.12% with a composite 
average of 0.316, while the actual average was 0.305 for a difference of 
3.5%. 
(http://boblemke.blogspot.com/2012/10/armys-computer-used-to-
predict-1957-bas.html) 
The BIZMAC was one of the first machines for which the concept of a 
data base was developed. It encompassed a set of structured files of 
information pertaining to a specific application. However, because of its 
limited memory capacity, it often took considerable time to assemble a 
block of data, operate upon it, and then store it in order to retrieve the next 
block. The concept was feasible, but the hardware was just not up to the 
task (Moreau 1984). 
The BIZMAC has the distinction of being the only true variable word 
length computer ever built. Although later machines also implemented 
variable word length operations, the difficulty and complexity these 
engendered in CPU design caused many manufacturers to forego this 
feature. 
 

CHAPTER FIVE 
FERRANTI ATLAS 
 
 
 
Tom Kilburn and Ferranti, Ltd. developed the Atlas in response to two 
driving factors: the need of UK nuclear physicists for more powerful 
machines and the knowledge that American scientists were developing 
more powerful machines. The latter factor meant that the leadership role in 
computing architecture was slipping from Britain’s grasp. Tom Kilburn’s 
project was called MUSE (for Microsecond Engine). He was focused on 
building a supercomputer – a term first used in a National Research 
Development Corporation (NRDC) meeting in January 1957, somewhat 
before the advent of STRETCH. When Ferranti, the University of 
Manchester, and the NRDC decided to collaborate, they changed the 
project name to Atlas (Lavington 2012, Edwards 2103). 
The Ferranti Atlas (also called the ‘Manchester Atlas’) was developed 
at the University of Manchester in the late 1950s as a fast machine that 
could achieve a speed of one order per microsecond. The 1 microsecond 
instruction time was never achieved in practice. Practically, the best that 
was achieved was 2 – 3 microseconds. 
Potential users desired a very large storage capacity and the ability to 
attach a large number of different peripherals to the machine. It was the 
first machine to have a prototype virtual memory capability (Fotheringham 
1961; Kilburn, Edwards, Lanigan and Sumner 1962). The designers 
differentiated between an ‘address’ (of data or instruction) and a ‘memory 
location’. Figure 5-1 depicts the Atlas 1 Input Area at the University of 
Manchester (Ferranti 1962c). 
Initially, a pilot version of the Atlas was constructed, tested and 
demonstrated as a proof of concept. This was moved to the Ferranti Plant 
at West Groton, England for training and development purposes. By 1962, 
Atlas was running at Manchester with several users programming in 
Mercury Autocode. By early 1963, regular computing services began and 
the fully operational version of the Supervisor was running by early 1964. 
(Lavington 2012) 
During a 20-hour day, the Atlas could run up to 1,000 user programs. It 
continued in operational use until 30 September 1971. Meanwhile, Tom 
Kilburn’s engineering team had moved on to the MU5 design. 

Ferranti Atlas 
 
87 
 
 
Figure 5-1. Manchester University – Atlas 1 Input Area 
Source: Ferranti 1962c, see also Edwards 2013 
 
The Ferranti Atlas had a small main memory of 16K words of 
magnetic core organized as 32 blocks of 512 words each. A paging store 
consisting of four 24 KWord magnetic drums was used to hold memory 
pages of 1024 24-bit words each. Memory was likewise divided into 1024 
word blocks, so that one page equaled one block. Note that a 48-bit 
instruction consumed two memory words. This was the first 
implementation of virtual memory and the first use of demand paging as a 
fetch strategy. The small size of main memory precluded full 
multiprogramming. Rather, paging was used as a memory management 
technique within a user’s program. In the late 1960s, a magnetic disc was 
added to the system configuration. It had a 16 million word capacity with a 
6.5 millisecond transfer rate per 512 words (ACL 1969). Figure 5-2 
depicts the control panel of the Ferranti Atlas. 
Four Atlas computers were built: the original one at Manchester 
University, one each for British Petroleum and the University of London, 
and one for the Atlas Computer Laboratory at Chilton near Oxford, 
England. Table 5-1 describes its basic characteristics. 

Chapter Five 
 
88
Table 5-1. Atlas – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal Representation 
Fixed Point Binary; Floating Point Binary 
# Bits/Word 
48 
# Instructions/Word 
1 instruction per two words 
# Instructions 
~100 implemented in hardware; ~300 
implemented by extracode routines 
# Bits/Instruction 
48 
Instruction Type 
One Address for accumulator orders; Two 
Address for B-line orders 
CPU Technology 
Discrete germanium transistors 
CPU Registers 
128 24-bit B-line registers, 0.7 microsecond 
cycle; 96-bit accumulator 
Main Memory 
Magnetic Core: 16 KWords; 2 microsecond 
cycle time 
Magnetic Drum: 4 x 24 KWords; 6 millisecond 
avg. access time 
Add Time 
Fixed Point: 1.59 microseconds; Floating Point: 
1.61 microseconds 
Multiply Time 
Floating Point: 4.79 microseconds 
Divide Time 
Floating Point: 10.66 microseconds to 29.8 
microseconds 
Note: The times shown are for the commercial version of the Ferranti Atlas. 
 
 
 
Figure 5-2. The Ferranti Atlas Operator Console 
Source: SKaisler at TNMOC November 2016 

Ferranti Atlas 
 
89 
5.1 Atlas System Architecture 
Source Ferranti 1981b 
 
The Atlas featured an innovative architecture. It was the first machine 
to introduce key ideas in system architecture including virtual storage, 
paging, and multiprogramming. It has been dubbed one of the world’s first 
supercomputers. 
 5.1.1 Central Processor 
Source: Sumner, Haley and Chen 1962 
 
The central processor had one floating point accumulator of 48 bits. 
Eight bits were used for the exponent. It provided 128 B lines of 24 bits 
each. B120 to B127 were special purpose registers; the remainder were 
general purpose registers. The accumulator and the B lines had 
independent arithmetic units that could operate in parallel. The Atlas CPU 
architecture is depicted in Figure 5-3. 
The Atlas accumulator stored 48-bit floating point numbers comprised 
of a sign bit, a 7-bit exponent, a 1-bit mantissa sign, and a 39-bit mantissa. 
The exponent had a range of -128 to +127. The mantissa had a range of -1 
to 1-2-39. This allowed the system to represent numbers whose magnitudes 
were 10-116 to 10113. All arithmetic was performed using the accumulator. 
Most instructions operated on two operands leaving the result in the 
accumulator. 
Instruction fetching and execution was overlapped. As soon as the 
control unit had decoded the odd address instruction, it fetched the next 
pair. It was possible for the CPU to be in different stages of execution for 
up to five instructions. But, the constraints were that the even instruction 
of a pair must not alter the odd instruction, and the odd instruction must 
not alter the even part or the instructions in the next pair. 
 

Chapter Five 
 
90
 
 
Figure 5-3. Atlas System Architecture 
Source: Adapted from Ferranti 1962c 
 5.1.2 Program Control 
The Atlas provided three levels of program control, each with its own 
control register: 
x Main Control (B127): used by user programs and Supervisor high-
level routines 
x Extracode Control (B126): used by Supervisor routines and 
extracode routines 
x Interrupt Control (B125): used by the interrupt handlers 
 
The programmer could use up to 90 of the 128 B lines for addressing. 
During design, it was thought that the programmer would like to keep the 
base addresses and offsets for many data structures in fast registers 
(Lavington 1993). Address arithmetic was carried out in a special 
arithmetic unit dedicated to the B lines. B lines could also be used for 
fixed point arithmetic. B line access time was about 0.35 milliseconds. 

Ferranti Atlas 
 
91 
With the large number of B lines, context switching between programs 
could have been problematic. The Atlas solved this problem by 
maintaining three program counters: one for users, one for the operating 
system, and one for the extracodes, which were library routines stored in 
fast ROM. Additionally, 37 of the 128 B lines had dedicated system usage 
and, so, were not swapped during a context switch. Nevertheless, 90 of the 
B lines had to be saved. This would strongly influence the design of the 
Manchester University MU5. 
 5.1.3 Storage Hierarchy 
The Atlas provided a number of different storage systems. Main 
memory was 16 KWords of magnetic core. In addition, there was a fixed 
store of 1K words and a system read-only store of 8K words. The read-
only store contained the system software, including extracode and 
interrupt routines, and frequently used user library routines. It consisted of 
a wire mesh with small ferrite plugs inserted into the spaces. The contents 
of the store were indicated by the presence or absence of the plugs. Access 
to the store was very fast at about 0.2 microseconds. The contents of the 
store had to be physically modified prior to booting the machine, so it was 
considered a part of the machine hardware. (Ferranti UNKc) 
The fixed store contained the library of mathematical functions which 
were accessed by extracodes. Ferranti believed that this approach made the 
machine instruction set much simpler as these functions were implemented 
in machine instructions. 
A special area of main memory, the Auxiliary Store, was reserved for 
the extracodes and interrupt routines. A special area, called the V Store, 
held bit and character strings required by the peripherals. The V Store was 
comprised of various flip-flops that were located throughout the computer 
which could be read or set by reading or writing from various addresses. 
The ROM, Auxiliary Store, and V store were given fixed negative 
addresses so that they were outside the virtual address space.  
Backing store was implemented through four 24 KWord magnetic 
drums, each with a 12 millisecond revolution time and an average latency 
of 6 milliseconds. These drums could deliver 1 block of 1024 words every 
2 milliseconds. Data was transferred directly between the drum and the 
core store in units of 512 words. Additional drums could be added in 
multiples of four drums up to a total memory capacity of 1 MWord. In 
1967, a disc subsystem was added that provided about 32,000 pages of 
backing store. 

Chapter Five 
 
92
 5.1.4 Virtual Storage 
The Atlas was the first machine to implement a virtual memory 
capability. The magnetic core and magnetic drum presented to the 
programmer a one-level store. The memory design contained three 
innovations: 
x The hardware automatically translated each address to its current 
memory location. 
x Demand paging, which caused an interrupt by the address translator 
when a missing page of data needed to be brought into memory. 
x A replacement algorithm that detected and moved the least useful 
pages from main memory to backing store in order to provide space 
for a demanded page. 
 
The unification of core and drum was facilitated by a set of page 
address registers in the V store. Information in the unified store was 
contained in a series of numbered blocks of 512 words. These blocks were 
transferred between the core and the drum as necessary. Addresses used in 
programs consisted of a block number and a word number within a block. 
The page address registers contained a list of all the blocks currently in the 
core store. When a particular store access was required, the page address 
registers were scanned rapidly in parallel by special hardware to locate the 
address. Each page address register was 12 bits in length. The most 
significant bit was set if the corresponding block was locked out because 
the particular program to which it belongs had been interrupted. This 
feature made it possible for programmers to use the same store address in 
different programs and be certain that they were completely independent. 
Figure 5-4 depicts this address mapping operation (Ferranti 1962e). 
 

Ferranti Atlas 
 
93 
 
 
Figure 5-4. Ferranti Atlas One-level Store Concept 
Source: Adapted from Ferranti 1962c 
 
If one of these registers contained the number of the block in which the 
required word resided, the corresponding page in the store was used for 
the command. As long as the required commands and their data were in 
the core store, access was made at the full speed of the core store. If a 
word was requested which was not in the core store, then none of the page 
address registers contained the proper information. When this happened, 
the program was automatically interrupted and control was transferred to a 
special routine in the fixed store, called the drum transfer routine. 
The drum transfer routine selected a block from the core store to be 
replaced by the requested block. It arranged to write the block contents 
from the core store to the drum and then to load the requested block from 
the drum into the selected block in the core store. It also updated the page 
address registers to reflect the new contents of the core store block.  
A block written to drum was not written to the same drum location 
each time. A directory in the subsidiary store held the actual drum 
addresses corresponding to each block. It could be written to the next 
available drum block to minimize waiting time. The current angular 
position of the drum was held in a V store register.  
The drum learning program, a part of the Supervisor, attempted to 
arrange programs inside the one-level store to minimize the drum transfers 
that were required when programs were executing. Note that two 
successive blocks of a program or data need not be in consecutive pages in 

Chapter Five 
 
94
the core store. In fact, the core store was a set of pages; its contents were 
re-arranged into the most convenient order. The programmer, of course, 
was generally not aware of this. 
 5.2 Peripherals 
In addition to the magnetic drum used as backing store, the Atlas had 
the standard complement of peripherals: magnetic tape units, card 
readers/punchers, paper tape reader and punch, and high-speed printer. 
The Atlas also had general-purpose 24-bit and 12-bit in/out channels 
which could be used to attach other types of devices. Optional peripherals 
included graphic plotters, real time clocks, data links, Friden Flexowriters, 
and random access stores. 
Each Ampex TM2 1-inch magnetic tape stored about 3 million words. 
Up to 32 magnetic tapes could be attached to Atlas in blocks of four with 
an attached magnetic tape controller via up to 8 channels. A switching unit 
could control blocks of 8 tapes on two channels, which allowed a magnetic 
tape drive on each channel to operate concurrently. The tapes were pre-
addressed and transferred data in blocks of 512 words each at an effective 
rate of 64K cps. 
 5.3 Atlas Instruction Set 
The Atlas instruction format is depicted in Figure 5-5. 
 
 
 
Figure 5-5. Atlas Instruction Format 
Source: Adapted from Ferranti 1962c 
 
Where: 
Function 
 
Function code 
Index 
 
B line: A codes indicated index register access; 
  
 
B codes indicated operand register access 
Index 
 
as above 
U/S 
 
User or System Address 
Address 
 
Word address 
CA 
 
Character address 
 

Ferranti Atlas 
 
95 
Atlas addresses with a 1 in bits 0 or 24 were system addresses which 
referred to the extracode store, the subsidiary store, or the V store. 
Addresses in the main store referred to words and characters within words. 
Because there were eight characters in a word, it was convenient to 
represent the character address as an octal fraction. Thus, character 5 in 
word 1234 had the address 1234.5. When a 24-bit address in a command 
was interpreted as a main store address, it had the structure depicted in 
Figure 5-6. 
 
 
 
Figure 5-6. Central Store Address Structure 
Source: Adapted from Ferranti 1961b 
 
When an extracode was to be entered, Atlas performed the following 
actions. First, the opcode of the instruction was copied into B119, after 
being modified by one or both of the specified indices. For extracodes, the 
Ba part of the command was copied into B121. The function bits were 
copied into the extracode control register, B126. The command was then 
executed by entering a routine associated with the extracode. On exit, the 
machine resumed control at the instruction following the extracode. 
Interrupt and extracode routines were allowed to access the entire 
store. When main memory was used, the private store was locked out. This 
meant that user programs were not able to access the V store which 
contained the links to the peripheral equipment. They could not control the 
peripheral equipment, but had to request an extracode program to perform 
the operation for them.  
 
Extracode 
Extracodes were software interrupts or traps. They were used to call 
mathematical procedures which were too inefficient to implement in 
hardware, for example sine, logarithm, and square root. About half of the 

Chapter Five 
 
96
codes were designated as Supervisor functions, which invoked operating 
system procedures. Typical examples would be “Print the specified 
character on the specified stream” or “Read a block of 512 words from 
logical tape N”. Extracodes were the only means by which a program 
could communicate with the Supervisor.  
 
The uppermost ten bits of Atlas machine instruction indicated which 
operation should be performed. If the most significant bit was set to zero, 
this was an ordinary machine instruction which was executed directly by 
the hardware. If the uppermost bit was set to one, this was an extracode 
instruction and was implemented as a special kind of subroutine jump to a 
location in the fixed store, its address being determined by the other nine 
bits. About 250 extracodes were implemented, of the 512 possible. 
5.3.1 Floating Point Arithmetic Instructions 
Floating point numbers had an 8-bit octal exponent and a 40-bit 
mantissa, including the sign. True complements were used for negative 
numbers. In Table 5-2, which presents the floating point arithmetic 
instructions, ‘s’ represents a storage location’s contents and ‘a’ represents 
the contents of the accumulator. Results were placed in the accumulator. 
 
Table 5-2. Floating Point Arithmetic Instructions 
Opcode8 
Operation 
Description 
0300 
0301 
0302 
a+s 
a-s 
s-a 
Floating, unrounded add, subtract 
0320 
0321 
0322 
a+s 
a-s 
s-a 
Floating, rounded add, subtract 
0330 
0331 
0332 
a+s 
a-s 
s-a 
Fixed Point add, subtract 
0324 
0325 
s 
-s 
Floating, standardized 
Floating, negative 
0334 
0335 
s 
-s 
Fixed point, unstandardized 
Fixed point, negative 
0342 
0343 
a.s 
-a.s 
Unrounded floating point multiplication 
(‘.’ Was the symbol for multiplication) 
0362 
0363 
a.s 
-a.s 
Rounded floating point multiplication 
 

Ferranti Atlas 
 
97 
0352 
0353 
a.s 
-a.s 
Single length integer multiplication 
0372 
0373 
a.s 
-a.s 
Double length integer multiplication 
 
Other commands were provided for division, storing the result from 
the accumulator, testing the sign of the accumulator, and forming the 
modulus of a or s. Rounding involved adding a digit to the least significant 
digit of the most significant half of the accumulator if this digit was zero, 
and if the least significant half of the accumulator was not zero. 
5.3.2 Indexing Operations 
Indexing commands operated on a 24-bit index register whose address 
was Ba. The second operand could either be the half word (s) of the 
storage location given in the address portion of the instruction or the 
address (n) itself. Table 5-3 depicts the indexing operations. 
 
Table 5-3. Atlas Indexing Operations 
Opcode8 
Operation 
Description 
0100 
b <- s – b 
Subtract index register from memory 
0101 
b <- s 
Move memory to index register 
0102 
b <- b - s 
Subtract memory from index register 
0103 
b<- -s 
Move complement of memory to index 
register 
0104 
b <- b + s 
Add memory to index register 
0106 
b <- b /= s 
Set index register if b not equal to s 
0107 
b <- b AND s 
Logical And index register and memory 
0147 
b <- b OR s 
Logical Or index register and memory 
0110 
s <- s - b 
Subtract index from memory 
0111 
s <- -b 
Move complement of index register to 
memory 
0112 
s <- b - s 
Subtract memory from index register 
0113 
s <- b 
Move index register to memory 
0114 
s <- b + s 
Add memory to index register 
0116 
s <- b /= s 
Set memory if index register not equal to 
memory 
0117 
s <- b AND s 
Logical And of index register and memory 
0120 
b <- n – b 
Subtract index register from address 
0121 
b <- n 
Move address to index register 

Chapter Five 
 
98
0122 
b <- b - n 
Subtract address from index register 
0123 
b<- -n 
Move complement of address to index 
register 
0124 
b <- b + n 
Add address to index register 
0126 
b <- b /= n 
Set index register if b not equal to n 
0127 
b <- b AND n 
Logical And index register and address 
0167 
b <- b OR n 
Logical Or index register and address 
 
As an example, 0164, 60, 59, 7.7 would mean “Add to index register 
60 the last 7-bit character from index register 59”. 
5.3.3 Atlas Branching Instructions 
There were three control registers with addresses 127, 126, and 125 
respectively. Branching was performed by altering the contents of the 
appropriate control register. An unconditional branch was obtained by 
copying the address of the desired next instruction into the appropriate 
control register. For example, 0121, 127, 0, 1234 would cause the program 
to transfer control to location 1234 to fetch the next instruction. 
Conditional branching occurred by testing the contents of the accumulator 
or an index register. Table 5-4 presents the branching instructions. 
 
Table 5-4. Atlas Branching Operations 
Opcode8 
Operation 
Description 
0214 
If bm = 0, b <- n 
If bm = 0, move address to index register 
0215 
If bm /= 0, b <- n 
If bm /= 0, move address to index register 
0216 
If bm >= 0, b <- n 
If bm >= 0, move address to index 
register 
0217 
If bm < 0, b <- n 
If bm < 0, move address to index register 
0234 
If a = 0, b <- n 
If a = 0, move address to index register 
0235 
If a /= 0, b <- n 
If a /= 0, move address to index register 
0236 
If a >= 0, b <- n 
If a >= 0, move address to index register 
0237 
If a < 0, b <- n 
If a < 0, move address to index register 
 
As an example, to jump to location 1234 if index register 50 is 
negative, the instruction would be 0217, 127, 50, 1234. 
To facilitate counting, such as for loops, Table 5-4 presents the 
counting instructions. 
 
 
 

Ferranti Atlas 
 
99 
Table 5-5. Atlas Counting Operations 
Opcode8 
Operation 
Description 
0200 
If bm /= 0, add 0.4 to bm 
and b <- n 
If bm /= 0, step forward half word 
and move address to index register 
0201 
If bm /= 0, add 1.0 to bm 
and b <- n 
If bm /= 0, step forward word and 
move address to index register 
0202 
If bm /= 0, subtract 0.4 
from bm and b <- n 
If bm /= 0, step backward half word 
and move address to index register 
0203 
If bm = 0, subtract 0.4 
from bm and b <- n 
If bm = 0, step backward word and 
move address to index register 
5.3.4 Atlas Shifting Instructions 
Four instructions were provided shifting the contents of a B register. 
The shifts were either 6 places up or 1 place down and were circular. The 
primary use of these instructions was to manipulate 6-bit characters. 
 
Table 5-6. Atlas Shifting Operations 
Opcode8 
Operation 
Description 
105 
ba’ <- 26ba + s 
Shift ba 6 places to left add;6 bits shifted 
out to right end and add s 
125 
ba’ <- 26ba + n 
Shift ba 6 places to left add;6 bits shifted 
out to right end and add n 
143 
ba’ <- 2-1ba -s 
Shift ba one place to right; 1 bit shifted out 
inserted at left; subtract s 
163 
ba’ <- 2-1ba -n 
Shift ba one place to right; 1 bit shifted out 
inserted at left; subtract n 
5.3.5 Atlas Odd/Even test Instructions 
These instructions tested the least significant bit of bm. 
 
Table 5-7. Atlas Odd-Even Test Operations 
Opcode8 
Operation 
Description 
210 
If bm is odd, ba’ = n 
If the least significant bit in bm is 1, 
set ba = n 
211 
If bm is even, ba’ = n 
If the least significant bit in bm is 0, 
set ba = n 

Chapter Five 
 
100
5.3.6 Atlas B-test Register Instructions 
The B-test register Bt consisted of 2 digits. When a number was 
written to Bt, one of these digits was set to show whether the number was 
equal to zero or not equal to zero. The other digit was set to show whether 
it was greater than or equal to zero or less than zero. Table 5-8 describes 
the B-test register instructions. 
 
Table 5-8. Atlas B-Test Register Operations 
Opcode8 
Operation 
Description 
152 
bt = ba -s 
Set the B-test register to the contents of 
ba – s 
150 
bt = s - ba 
Set the B-test register to s minus ba 
172 
bt = ba - n 
Set the bt register to ba - n 
170 
bt – n -ba 
Set the bt register to n - ba 
224 
If bt = 0, ba = n 
If bt equal to 0, put n in ba 
225 
If bt /= 0, ba = n 
If bt not equal to 0, put n in ba 
226 
If bt >=0, ba = n 
If bt greater than or equal to 0, put n in 
ba 
227 
If bt < 0, ba = n 
If bt less than 0, put n in ba 
220 
If bt /= 0, ba = n, 
bm = bm + 0.4 
If bt not equal to 0, set n into ba and 
add 0.4 to bm. 
221 
If bt /= 0, ba =n, bm 
= bm + 1 
If bt not equal to 0, put n into ba and 
add one to bm 
222 
If bt /= 0, ba = n, 
bm = bm - 0.4 
If bt not equal to 0, set n into ba and 
subtract 0.4 from bm. 
223 
If bt /= 0, ba =n, bm 
= bm - 1 
If bt not equal to 0, put n into ba and 
subtract one from bm 
5.3.7 Atlas Instruction Example 
An example of a simple program for the Atlas is depicted below. Two 
numbers, a and b, were stored in locations 14 and 14.4. A program that 
will use these two numbers is stored beginning at location 100. The 
program computes the following: 
 
x If a < b, b >= 0, enter the program at 100. 
x If a < b, b < 0, enter the program at 101 
x If a >= 0, b >= 0, enter the program at 102 
x If a >= 0, b < 0, enter the program at 103. 
 

Ferranti Atlas 
 
101 
A program to apply the algorithm above is: 
 
 
Register 
 
Contents  
Comment 
 
0 101 
1 
0 
14 
place a in B1 
 
1 101 
2 
0 
14.4 
place b in B2 
 
2 216 
127 
1 
5 
if a >= b, jump t register 5 
 
3 217 
127 
2 
101 
if b < 0, jump to 101 
 
4 121 
127 
0 
100 
so a < 0, b >- 9, jump to 100 
 
5 216 
127 
2 
103 
if a >- 0, b >- 0, jump to 102 
 
6 121 
127 
0 
103 
so, jump to 103 
5.4 Atlas Programming 
By the late 1960s, compilers existed for numerous programming 
languages, including ABL – the Atlas Basic Language, the assembly 
language for the Atlas; FORTRAN; ALGOL; Atlas Autocode; and Lisp 
1.6. 
Atlas Autocode programs consisted of a sequence of statements written 
in an algebraic notation that performed a computation. The Autocode 
compiler translated these statements into machine language. Suppose the 
user wanted to perform the calculation depicted in Figure 5-7. 
 
 
 
Figure 5-7. Sample Atlas Autocode Program 
Source: Brooker and Rohl 1965 
 
This computation fits a straight line equation y = ax + b to sets of data 
of the form  X1, Y1; X2, Y2; ----; Xn, Yn. Each set of data is terminated by 
the number 999999 and the final set by two such numbers. The Autocode 
program to perform this computation is (Brooker and Rohl 1965): 
 
 

Chapter Five 
 
102
1.2 
          begin 
          real   a, b, c, Sx, Sy, Sxx, Sxy, Syy, nextx, nexty 
          integer n 
          read (nextx) 
2:       Sx = 0; Sy = 0; Sxx = 0; Sxy = 0; Syy = 0 
          n = 0 
1:       read (nexty) ; n = n + 1 
          Sx = Sx + nextx; Sy = Sy + nexty 
          Sxx = Sxx + nextx² ; Syy = Syy + nexty² 
          Sxy = Sxy + nextx*nexty 
3:       read (nextx) ; ->1 unless nextx = 999 999 
          a = (n*Sxy - Sx*Sy)/(n*Sxx - Sx²) 
          b = (Sy - a*Sx)/n 
          c = Syy - 2(a*Sxy + b*Sy) + a²*Sxx - 2a*b*Sx + n*b² 
          newline 
          print fl(a,3) ; space ; print fl(b,3) ; space ; print fl(c,3) 
          read (nextx) ; ->2 unless nextx = 999 999 
          stop 
          end of program 
 
Atlas Autocode was developed primarily to assist in computations with 
numbers as scientific computing was the prevailing use of computers in 
the 1960s. Autocode could be considered a competitor to FORTRAN in 
that it had many of the same features as FORTRAN II/IV. 
 5.5 The Atlas Supervisor 
Source: Kilburn 1961; Kilburn, Payne and Howarth 1962; Howarth et al 1962 
 
The Atlas operating system, also known as the Atlas Supervisor, 
resided in either fixed store or main memory. The Atlas Supervisor was 
designed to support multiprogramming operations. As a batch system, it 
accepted jobs, which consisted of control statements, programs, and data. 
A job description provided to the machine a list of all the documents 
required for that particular job and also, optionally, such data as estimated 
computer time and storage space. An example of a job is (Ferranti 1962e): 
 
 
 
 

Ferranti Atlas 
 
103 
JOB 
AUTOPROCESS 3 
STORE 2 
COMPUTING 10.0 SECS 
INPUT 
1 EXPERIMENT A 
2 EXPERIMENT B 
OUTPUT 
1  TELETYPE 1 BLOCK 
COMPILER MERCURY AUTOCODE 
then the program itself terminated by 
***Z 
 
The program to be executed was called AUTOPROCESS 3. It was 
written in Mercury Autocode. It required at most 2 blocks of storage and 
required no more than 10 seconds of computing time. Data was stored on 
two magnetic tapes called, respectively, EXPERIMENT A and 
EXPERIMENT B. Output would consist of one block of data which would 
be output to the teletype printer. 
5.5.1 Structure of the Atlas Supervisor 
Source: Morris, Sumner, and Wyld 1967 
 
The Atlas Supervisor used magnetic tapes to store the system files and 
to hold the input jobs and output results. Typically, jobs were buffered 
from unit record peripherals to the input tape in batches. Then, the jobs on 
the tape were run and results recorded on the output tape. Users could use 
private magnetic tapes to store large amounts of data and receive large 
volumes of output for later processing. The structure of the Atlas 
supervisor – as used at Manchester University – is depicted in Figure 5-8 
(Howarth 1961, Kilburn, 1961, Morris and Rohl 1961, Morris, Sumner 
and Wyld 1967). 
The Atlas Supervisor was constructed from several components, as 
depicted in Figure 5-8. Jobs were submitted through the input peripherals 
and transmitted to the Input Supervisor, which placed them on magnetic 
tape. The Input Supervisor made an entry in the Input List. The Scheduler 
retrieved a job entry from the Input List and passed it to the Job Assembler 
(not shown). The Job Assembler controlled the loading of any magnetic 
tapes required by the job (e.g., a compiler tape) and copied the job data 
from magnetic tape into main memory. The job entry was passed to the 

Chapter Five 
 
104
Central Executive which executed the job when the CPU was available. 
Output from the job was passed through the Output Assembler (not 
shown) onto an Output List. As peripherals were available, the Output 
Supervisor retrieved data from the Output List and sent it to the 
appropriate peripherals. 
 
 
 
Figure 5-8. Structure of the Atlas Supervisor 
Source: Adapted from Morris and Rohl 1961, Morris, Sumner and Wyld 1967 
 
Jobs were not necessarily executed in the order they were received 
because execution was determined by the availability of the specified 
peripherals. The Central Executive controlled the starting, ending and 
monitoring of jobs. It trapped jobs which exceeded their specified time 
limit as well as jobs that encountered errors. 
The Central Executive allocated blocks from the 2048 available on the 
Manchester Atlas. Of these 2048, 256 blocks were reserved for I/O 
buffering and use by the supervisor. The remaining 1792 were used for 
multiple user programs. The maximum physical space allocatable to a user 
job was 165 blocks. Each program had a block directory which mapped its 
program blocks to actual physical blocks in the main memory as the 
Manchester Atlas was a paged system. 
Within the block directory, entries had two parts: (1) the block address 
in the program’s address space, and (2) the block (page) address in 
physical storage. On the Manchester Atlas, 32 blocks were in core store 
while the remainder were on magnetic drum. Associated with each page 
was a 12-bit page address register (PAR). When a core store block was 
allocated to a program, the block number of the program’s address space 
was placed in the PAR for the assigned page. All storage accesses were 

Ferranti Atlas 
 
105 
checked against the 32 PARs in parallel to determine which physical block 
contained the address. Typically, this increased store access time by 30 
percent, but provided greater flexibility in core store management. 
If the requested address was not in a PAR block, an interrupt was 
generated which was fielded by the Central Executive. The block directory 
was scanned to find the location of the block on the magnetic drum. The 
block was then copied to a vacant page in core store. The appropriate PAR 
was updated and program execution continued from the instruction that 
caused the interrupt. While a block was being copied into a page, the 
Central Executive selected another page to have its contents copied to the 
magnetic drum. This outgoing transfer was initiated before returning to the 
program and proceeded concurrently with program execution. 
For all blocks in page store, a use digit was associated with each one. 
All use digits were periodically scanned by the Central Executive and a 
pattern of use established. This pattern of use was used to select a page to 
be transferred from core store to the magnetic drum. Morris, Sumner and 
Wyld (1967) noted that 99% of all accesses were found in core store. 
When a page needed to be fetched from magnetic drum, the average time 
was 20 milliseconds of which 6 milliseconds was spent in the Central 
Executive and 14 milliseconds was spent waiting for the transfer to occur. 
The most significant digit in the PAR was a lock bit, which when set 
indicated that the page could not be accessed by user programs. The 
Central Executive locked out all pages that were not part of the currently 
executing program to provide program protection. 
5.5.2 Job Structure 
Jobs were identified by heading specifying steps to be performed. For 
example, the following sequence of records would specify a FORTRAN 
job to be compiled followed by its data. The JOB card initiated the 
processing of a job. 
 
JOB 
… optional data …. 
COMPILER FORTRAN 
…. Source Program …. 
DATA 
…. Program data … 
 
 
Optional data included the specification of other magnetic tapes to be 
used, the amount of store required, and the time limit for executing the job. 

Chapter Five 
 
106
In the latter case, if the job exceeded the time limit, it was terminated by 
the Supervisor. 
Input tapes were specified in the JOB section as follows: 
 
INPUT 
… magnetic tape drive 1 … 
… magnetic tape drive 2 … 
 
Similarly, output equipment was specified by the OUTPUT label in the 
JOB section. 
5.5.3 Programs 
Object programs were initiated by a Supervisor Extracode Routine 
which entered them into the object program list. An object program was 
(re)started by the coordinator program. Object programs ran until they 
were interrupted, completed, or failed. Object programs could not use 
extracode control or interrupt control directly. They used B127, which 
prohibited access to the V store or the subsidiary store. Attempts to access 
these stores caused an interrupt and entry to the Supervisor to handle the 
illegal access. 
Each object program started at address 0. Actual addresses were 
assigned by the Supervisor when the program was loaded into memory. 
When a program was loaded, it was allocated a fixed number of 512-word 
blocks. The hardware mapped the program address to physical addresses. 
Program blocks could be moved automatically between the main memory 
and the backing store thus creating the one-level store concept. 
Up to 512 extracode routines could be loaded into the private stores. 
Access to these routines was through an extracode operation which, using 
the extracode control register, entered the Supervisor. 
5.5.4 Process Control 
The Supervisor allowed any number of processes to be executed in the 
machine. Only one was active at a time as its current address was accessed 
by B127. The Supervisor handled the switching of execution among the 
different Main processes. Supervisor Extracode Routines (SERs) formed 
the primary mechanism for switching in and out of the Supervisor. Since 
key supervisor routines ran under Extracode control, they could interrupt a 
Main Process and cause control to switch to another Main Process. 

Ferranti Atlas 
 
107 
When an Extracode routine was initiated, the extracode control register 
of the current object program was preserved and subsequently restored 
when control was returned to the user program. They used private B-lines 
- B-lines 100 to 110 inclusive. If any other working registers were 
required, the Extracode routines themselves preserved and restored the 
contents of such registers. The SERs thus applied mutual protection 
between themselves and an object program. 
Any number of Extracode routines could be loaded in the machine, but 
only one was ever active as they used B-line register 126. The rest were 
queued waiting to be run. Extracode routines could be interrupted by an 
interrupt handler. However, all queued extracode routines were run before 
control was returned to Main Control. Main processes could not be 
directly interrupted by another Main process, but could be indirectly 
interrupted. 
SERs could be activated at any time. An SER could be interrupted by 
an interrupt routine, which might call other SERs. Thus, several SERs 
could be active at any time, but only one was executed at any time. The 
Supervisor’s coordinator routine ensured that one SER could not be 
interrupted by other SERs. Active SERs were recorded in a list structure in 
the subsidiary store. Once an SER was initiated, it ran to completion 
unless interrupted. When an SER completed or halted itself, the highest 
priority SER in the list was activated next 
Four lists were used to manage activate SERs: (1) drum transfer SERs 
and those caused by core store failures; (2) magnetic tape transfers and 
interruptions; (3) other peripheral equipment interruptions; and (4) object 
program SER invocations. 
Switching between extracode routines required about 60 microseconds. 
Switching between Main Control routines required about a 1000 
microseconds because the accumulator and relevant B lines had to be 
saved. 
5.5.5 Interrupt Handling 
Only one interrupt could be handled at a time since it required B-line 
register 125, the Interrupt Control Register, to support addressing for the 
handler. Further interruptions were inhibited until control reverted to main 
or extracode control. 
Each part of the machine that required attention during processing had 
an interrupt bit present in the V store. Prior to beginning each instruction, 
the Atlas polled the interrupt bits to see if any was set. If so, it transferred 
control to the routine at B125 to determine the interrupting part and to 

Chapter Five 
 
108
handle the interrupt. After one routine was finished, it would check the bits 
again and handle another interrupt, if it was set. Interrupt routines were 
compact and arranged in priority order. They made no assumptions about 
the contents of the B-line registers. The contents of working registers were 
not saved, so interrupt switching was occurred quickly. This ensured that 
an interrupt would always be handled from a component before another 
interrupt could occur. Once all interrupts were handled, the Atlas then 
checked to see if any extracode routines were queued. It worked off this 
queue before returning control to the Main Control. 
Transfers of pages to or from the backing store were handled 
“autonomously” so that interrupts were not required. While a transfer was 
underway, the memory page was locked so that it could not be accessed. 
5.5.6 Atlas Supervisor Assessment 
The Atlas Supervisor is often thought to be the first modern operating 
system. Lavington (1980, pp. 50-52) and Brinch Hansen (2000) thought it 
to be one of the most significant breakthroughs in OS history. The Atlas 
supervisor incorporated three innovative ideas (Lavington 1978): 
 
1. Multiprogramming of up to 16 concurrent jobs 
2. On-line spooling of input and output 
3. Job scheduling 
 5.6 Atlas 2 
Ferranti provided the University of Cambridge with some Atlas 
components under special arrangement. In turn, Cambridge developed a 
less complex machine – the Cambridge Titan Computer. David Wheeler 
led the joint effort between Cambridge and Ferranti. This machine was the 
prototype for the Atlas 2. It became operational in 1964 and was 
decommissioned in 1973. The Titan Computer is depicted in Figure 5-9. 
 

Ferranti Atlas 
 
109 
 
 
Figure 5-9. Titan Computer 
Source: http://www.cl.cam.ac.uk/Relics/archive_photos.html 
via https://commons.wikimedia.org/wiki/File:Titan_computer.jpg 
 
Landy describes numerous other improvements including a system 
dump capability, an interactive command capability, enhancements to the 
multiprogramming code, and several programming languages including 
FORTRAN and ALGOL. 
Two other machines were delivered to the Aldermaston Atomic 
Weapons Research Establishment and the Computer-aided Design Centre 
at Cambridge. The latter machine was turned off in 1976. An image of the 
Titan Computer can be found at http://www.ourcomputerheritage.org/ 
F5%20Cambridge%20Titan%20(the%20prototype%20Atlas%202).htm. A 
Ferranti Atlas 2 brochure can be reviewed at http://www.chilton-
computing.org.uk/acl/technology/atlas/p018.htm. 
5.6.1 Atlas 2 Central Processor 
The Atlas 2 had four registers, labeled R1-R4, two of which were used 
for a simple memory management system using a base and limit approach. 
R1 specified the starting address of a program in core. A user address was 
OR’ed with R1 to produce the absolute hardware address. R2 specified the 
size of the program region, so c(R1) + c(R2) -1 specified the last address 

Chapter Five 
 
110
of the program. The limitations of this approach were that the memory 
allocated to a program had to be contiguous in main memory unlike the 
scheme used with the Atlas 1. 
The other two registers were used to lock peripheral transfers. R4 
specified the lower address and R3 the upper address of a block of 
memory locations within the limits established by R1, R2. A user program 
was not allowed to access this subregion. This area was intended for I/O 
transfers – usually from magnetic tape. 
As a result, the Atlas 1 Supervisor could not be used on the Atlas 2. A 
new supervisor was developed as a joint collaboration between Ferranti 
and Cambridge University. Numerous people including David Hartley, 
Roger Needham, David Barron, and Barry Landy all participated in the 
development of this supervisor. The entire Supervisor consisted of about 
40K words of which 15K were permanently resident. The remaining code 
was blocked in pages of 512 words which were “paged in” from magnetic 
tape. Landy suggests the Atlas 2 Supervisor never worked at Cambridge, 
but did run on the machine delivered to Aldermaston Atomic Weapons 
Research Establishment. The version of the Supervisor used at 
Aldermaston was a variant of that used at Cambridge. 
5.6.2 Atlas 2 Memory 
Source: ICT 1964a 
 
The Atlas 2 initially had core store for main memory. As Landy (2012) 
notes, the lack of a magnetic drum meant that Atlas 2 had to use magnetic 
tapes for I/O buffering. Later in 1965, two 16 MWord disks were added to 
the Cambridge machine. Each disk had independent heads for each platter. 
There was also a fixed head region which was used as if it were a 
magnetic drum. The disk was used for swapping supervisor pages and to 
buffer data streams in lieu of the magnetic tapes. 
The core store used register r1 to provide a base address which was 
automatically or-ed to all store references for operands and instructions. 
Object programs were written, compiled, and linked assuming a starting 
address of zero. By setting an address in r1, a program could be loaded 
anywhere in available memory. Because the addition was performed by 
the hardware, the Supervisor could move a program by copying its words 
to a new location and setting r1 appropriately. This provided a mechanism 
for compacting memory which had become fragmented. 
Register r2 specified the upper bound of an object program. Attempts 
by an object program to address a relative location beyond the upper 

Ferranti Atlas 
 
111 
bound or below the base address caused an automatic interrupt to occur. 
The use of r1 and r2 prevented an object program from interfering with 
other programs.  
Register r3 and r4 were used to lock out parts of store within an object 
program. For example, if a magnetic tape data transfer had been requested, 
r3 and r4 would be set to the starting and ending addresses of a buffer that 
was to receive the data from the magnetic tape to prevent access to the 
area until the data transfer was complete. Store references to addresses in 
[r3, r4] caused a hardware interrupt to occur. 
The store could be accessed “absolutely”. This was determined by the 
three most significant bits (MSBs) of the address. If these digits were zero, 
then the address was the normal program relative address. The 17 store 
address bits were OR-ed with r1 to produce an absolute store address. If 
these bits were 1’s, then the 17 address bits represented an absolute store 
address. Object programs were not permitted to use absolute addresses, but 
extracode routines and interrupt routines performed absolute addressing. 
Further, when using absolute addressing, no checks against the contents of 
r2, r4, or r4 were performed. 
If the MSBs had a value of 011, then relative addressing with r1 was 
performed, but no checks with r2, r3, or r4 were performed. This mode 
was used by the Supervisor to access routines or tables not in the FA or the 
AFA. If the MSBs had values 110 or 101, these were used to access the V 
–store and were used only by extracode routines or interrupt routines. 
In addition to the V-store, there were two small stores constructed from 
tunnel diodes: the Fast Operand Store and the Slave Store. The Fast 
Operand Store was comprised of eight 48-bit registers that were addressed 
by the first eight words of an object program. These were used to store 
frequently used operands with faster access than main store. 
The Slave Store consisted of 32 48-bit registers each of which had an 
associated 12-bit register. The Slave Store was not addressed directly. 
Rather, it operated automatically. Whenever an instruction was retrieved 
from main store, it was also placed in the Slave Store at an appropriate 
location. Its position was determined by its address in main store modulo 
32. At the same time, the number of the block of 32 instructions in main 
store from which it was retrieved was placed into the associated 12-bit 
register. The Slave Store was automatically searched by the CPU when 
fetching an instruction to determine if the instruction was already located 
there. If so, it was fetched from the Slave Store rather than main store. 
This is one of the earliest implementations of the cache concept. This was 
particularly useful in executing loops of instructions due to the faster 
access to the Slave Store. 

Chapter Five 
 
112
The Space Routine Domain (SRD) contained all of the memory not 
allocated to the Fixed Area or the Auxiliary Fixed Area. The SRD was 
divided into Sections and blocks. A section consisted of a multiple of 512 
words of store aligned on a 512-word boundary. A block consisted of 512 
words of store aligned on a 512-word boundary and was either equivalent 
to a section or a subelement of a section. One block sections could be 
divided into blocklets consisting or 64 words aligned on 64-word 
boundaries. Blocklets were intended to hold data and tables which were 
usually allocated in small quantities. 
Supervisor routines requested and released space in the SRD. Central 
Space Routines (CSRs) allocated space requests first from free space, then 
by overwriting already allocated space where the data already exists on 
backing store. CSRs could also shift data around in order to coalesce 
fragments of free space into a larger area. Any data might be shifted, but 
the shift was delayed if the area was locked for a data transfer. Each 
request had a requesting priority, and each block or section had a keeping 
priority, both of which were dynamically assigned. Data was only 
removed from the core store if the requesting priority was greater than its 
keeping priority. Requests were queued and executed in order of 
descending priority. 
Data in SRD blocks, sections, and blocklets was always pointed to by 
pointers or chains of pointers maintained in the Fixed Area. 
5.6.3 Magnetic Tape 
The Atlas 2 used the Potter MT120 magnetic tape drives with 1-inch 
tape. The tape had 16 tracks – 12 data tracks two timing tracks, and two 
reference tracks. Tapes were used in a fixed block, pre-addressed mode. 
Data was stored on tape in 512 word blocks of 48-bit words. Blocks could 
be read in either the forward or reverse direction. Writing was only 
performed when the tape was moving in a forward direction. Pre-
addressing mean that blocks gaps were laid down on the tape so that 
searching or moving to a specified block could be accomplished quickly. 
The Atlas 2 could attach either two or four tape channels. Up to eight 
tape drives could be attached to a pair of channels. Channels could operate 
simultaneously with each channel performing one read, write or search 
operation. Wind, rewind, and search operations could proceed 
independently, once initiated, without being connected to a channel. 
Transfer operations were handled by the Tape Co-ordinator. Each channel 
had eight codewords – one for each blocklet in a 512 word block - which 
were stored in fixed positions in core store. 

Ferranti Atlas 
 
113 
Tape transfers were handled as blocks of 512 words, but a block could 
have eight 64-word blocklets which could be scattered to or gathered from 
core store. The mode of transfer was written to the V-store. The 
codewords specified the area in code store where the data would be written 
to or written from. Object programs read or wrote data in blocks, but 
Supervisor routines could read or write data in blocklets. Once a transfer 
was completed, an interrupt was generated.  
The first block of every tape was used by the Supervisor for identifying 
information. This block contained the tape identifier, a serial number, and 
a record of faulty blocks on the tape. The serial number was assigned 
when the tape was pre-addressed.  
5.6.4 Magnetic Disc Files 
The Atlas 2 could attach Data Products Disc Files - up to 16 disc drives 
each with 256K words capacity or a total of 4M words for a module. 
Several modules could be attached to the system. Data was stored in 512 
word sectors on the disc. Eight sectors comprised a band of 4,096 words. 
Rotational speed was 52 milliseconds with an effective transfer rate of 52 
milliseconds for 4,096 words. The disc module was attached to the system 
via a separate channel. 
Data was transferred between the core store and the disc files through 
extracode routines under the control of the Supervisor, 
5.7 The Atlas 2 Supervisor 
The Atlas 2 Supervisor implemented a time-sharing system in which 
there was more than one active, although not executing, program resident 
in memory. Concurrently, there was independent handling of I/O 
activities. Protection was provided by the hardware, which prevented one 
program from interfering or corrupting others resident in memory. The 
Supervisor controlled the hardware resources, scheduled programs for 
execution, controlled the I/O devices, and provided the foundation for the 
Operating System. ICT developed a particular Operating System running 
under control of the Supervisor. (ICT 1964a) 
The kernel or central parts of the Supervisor were stored at the highest 
addresses in the store – the Fixed Area (FA). The kernel contained those 
parts which no program could do without. Other parts, which were usually, 
but not always required, were stored in the Auxiliary Fixed Area (AFA). 
The AFA was adjacent to the FA. It was also used to double buffer slow 

Chapter Five 
 
114
peripherals. The remainder of the store, called the Space-Routine Domain 
(SRD), was available for object programs.  
The Supervisor ceded control of the CPU to an object program to 
execute. However, the Supervisor because active when an object program 
or a peripheral needed service from it. It could be entered by the object 
program executing a call to one of the Supervisor routines. The Supervisor 
was also entered when an object program generated an error, such as 
divide overflow, or when a peripheral generated an interrupt that required 
servicing.  Also, certain failures of CPU elements could cause the 
Supervisor to be entered. 
The Supervisor consisted of several branches of code called Supervisor 
Extracode Routines (SERs). SERs could have different priorities, but were 
generally executed in the order in which they were requested.  
5.7.1 Interrupt Routines 
Interrupt routines were entered when an interrupt was generated by a 
peripheral or, in certain cases, by the CPU. Interrupt routines were kept as 
short duration as possible since they could not be interrupts. An interrupt 
routine generally performed immediate servicing and then invoked an SER 
to take expanded action. However, the hardware was designed such that 
very little action was required by the interrupt routine. 
When a peripheral required attention, a flip-flop known as Look-At-
Me (LAM) was set in the V store. Each type of interrupt had its own 
LAM. If a LAM was set and interrupts were not inhibited, then before the 
next instruction was executed in an object program, control was 
transferred to an interrupt handler associated with that LAM. When an 
interrupt occurred, further interrupts were inhibited by the hardware. Thus, 
only one interrupt could be serviced at a time. When interrupt servicing 
was completed by the interrupt handler and the associated SER, control 
returned to either the object program or a SER that was executing when 
the interrupt occurred. However, there were two exceptions. First, if other 
LAMs were set, a jump occurred under interrupt control to one of eight 
fixed addresses. Second, when the return address was not an object 
program or a SER, but a part of the Supervisor, then the SER was queued 
and control passed to the Supervisor routine. 
To ensure no interference with object programs or the Supervisor, 
interrupt routines used only a small set of FA addresses and only a few 
registers: B125 – the interrupt control register; B123, and B113 to B118 
inclusive. Interrupt routines made no assumptions about the content of B-
lines. No lockout was imposed on these B-lines, so an object program 

Ferranti Atlas 
 
115 
accessing them would result in erroneous functioning. Interrupt routines 
did not preserve register contents, so transfer to/from an interrupt routine 
was quickly accomplished. 
5.7.2 Supervisor Extracode Routines 
Supervisor Extracode Routines (SERs) were the principal branches of 
the Supervisor and formed sets of services that the Supervisor could 
perform on behalf of object programs or in response to interrupts. They 
used private lines – those from B100 to B112 inclusive. The maximum 
number of SERS supported by the Supervisor was 512 although, in 
practice, many less were actually defined. The average time to enter, 
execute, and return from a SER was about 30 microseconds. However, this 
time varied on the functions performed by individual SERS. 
A SER could be invoked at random intervals by an object program or 
an interrupt routine. Only one SER was executed at a time, but other SERs 
were queued awaiting assignment of the CPU. The Supervisor Co-
ordinator (e.g., scheduler) placed a SER into execution. Once initiated, A 
SER was (almost) always allowed to run to completion. There was no time 
limit placed on SER execution. The exception was if an interrupt occurs. 
Higher priority SERs did not interrupt lower priority SERs, but were only 
initiated when A SER completes or suspended itself with request for a 
Supervisor service. 
When SERs were queued for execution, they were placed on one of 
four queues: 
1. a queue associated with SERS required by high-speed devices. 
2. a queue for holding SERS associated with magnetic tape operations 
3. a queue for peripheral interrupts (e.g., unit record equipment) 
4. a queue for object program requests for services/ 
 
The SER queues were accessed in priority order with a particular 
emptied before the next queue was accessed. When a SER completed, the 
Co-ordinator selected the next SER, if any, in the queue for execution. 
Otherwise, it descended to the next queue. As one can see, object program 
service requests were lowest priority and not deemed time critical. 
Although SERS originated as routines to control peripherals, magnetic 
tapes, and discs, they evolved into providing common services required by 
many programs. For example, communication with the system operators 
evolved into a sophisticated interaction mechanisms that allowed operators 
to manage the scheduling and execution of programs efficiently. As 
mentioned, the Supervisor was divided into branches each composed of 

Chapter Five 
 
116
several SERs. Most SERS were stored in the FA or loaded into the AFA as 
needed. Less frequently used SERS were loaded from magnetic tape into 
the SRD when needed. These routines were protected from object 
programs through hardware lock-out and backing store routines of the 
Supervisor. 
5.7.3 Extended Interrupt Routines 
Extended Interrupt Routines (EIRs) were logically inserted between 
Interrupt Routines and SERs. Every time a SER was requested, initiated, 
halted, or terminated, the Co-ordinator had to intervene. For example, 
when a SER was halted, the Co-ordinator had to save a restart point. Some 
SERs were written never to be halted, but were known to have a maximum 
duration. Depending on the time duration of certain peripheral IRs and the 
known duration of a SER, the Co-ordinator could run the SER with 
interrupts inhibited. Such SERs were called EIRs. But, if the duration of 
currently active IRs was less than the duration of the EIR, it was run as a 
normal SER. The choice as to how to run an EIR was made dynamically 
by the Supervisor. This approach allowed the Supervisor to attempt to 
keep the machine running as efficiently as possible. 
5.7.4 Object Programs 
Object programs were executable programs provided by the system 
users. The Supervisor attempted to organize the activity of the computer to 
have the minimum possible delay while maintaining a high level of 
activity across all elements of the system. Object programs were initiated 
by SERs, which inserted them into the program list. Object programs were 
activated in turn by a Co-ordinator routine. Object programs had lower 
priority than any SER. While the object program was executing, the 
Supervisor was dormant. 
For object programs to execute with the minimum of supervision, they 
were not allowed to use extracode control or interrupt control directly. 
This allowed Supervisor code and other programs to be protected against 
interference as enforced by the hardware.  Object programs used the main 
control register, B127, and were not allowed to access the V store, the FA, 
or the AFA. Attempts to access these areas was detected by the hardware 
and cause an interrupt which forced entry to the Supervisor. 
Object programs were halted by SERs whenever access to information 
that was not immediately available in core store was required. For 
example, when data was to be read from a magnetic tape or disc. The 

Ferranti Atlas 
 
117 
program was halted while the data transfer was made. For peripheral 
transfers, the data was buffered in core and in backing store and transfer 
was handled by the Supervisor. For example, when paper tape was read, 
the data might already be available in a core store buffer and so could be 
transferred directly to a program area. An object program requested data 
transfers to or from magnetic taper or disc by calling the relevant SERs. 
When one program was halted due to a service request, the Co-
ordinator attempted to switch control to the next object program in the 
program list. To maintain full protection of the system, the contents of 
working registers, such as B-lines and accumulators, were preserved, and 
appropriate core store regions were locked out. These actions were 
performed by a SER which occupied the CPU for about 800 microseconds. 
For efficient operation of the system, the Supervisor attempted to 
minimize the number of changes between object programs and utilize the 
rapid switching between SERs. Guidance was also provided to object 
program developers regarding program construction and use of I/O in 
order for them to assist in achieving the goal of maximum efficiency. 
5.7.5 Error Conditions 
The hardware could detect certain error conditions that occurred during 
the execution of a program. Similarly, the SERs could detect errors 
through program checks and the Supervisor could detect program faults. 
The hardware caused entry to the Supervisor by setting a LAM. Errors 
detected by the SERs or the Supervisor would result in invoking other 
SERs to handle the problem. 
When an error was detected by the Supervisor, the action taken 
depended on the nature of the error. Some errors could be recovered from, 
but others required the object program to be terminated. For program 
faults, the Supervisor might execute SERs to obtain diagnostic information 
which it could print along with a program dump, if requested. In some 
cases, the standard response was to print the program dump and terminate 
the program. For hardware, the condition might be corrected, but often the 
machine was halted after alerting the operator as to the cause. 
5.8 Atlas Assessment 
The Atlas 1 demonstrated a number of key concepts in computing, 
including multiprogramming, job scheduling, interrupts, virtual storage, 
paging and operating systems. While Ferranti only sold two more 
machines beyond the one delivered to the University of Manchester – to a 

Chapter Five 
 
118
BP/University of London Consortium and to the Chilton Laboratory at 
Harwell, its impact on successor machines was significant. As Edwards 
(2013) notes, the Manchester Atlas was shut down in September 1971, 
“having provided a good computing service to the University, some other 
Universities too and also to Ferranti who utilized 50% of the total time 
available”. Ross (2001) provides some information on Ferranti’s London 
Computer Centre.  
A key feature of the Atlas was the allocation of a control register for 
each level of control. This made switching between levels relatively fast. 
Note that since the Atlas had no accumulator registers other than the 
floating point accumulator, nothing had to be saved in order to switch to a 
different control level process. 
Another aspect of Atlas was its concept of a one-level store. Programs 
and data were grouped into blocks of 512 words. These were addressed by 
the program. Block addresses did not necessarily correspond to physical 
locations in core store. However, a block could be located in core store via 
a fast parallel scan. If a block resided on drum when required, a drum 
transfer was performed under the control of the Supervisor. In effect, the 
maximum size of a program was a combination of available core store 
after allowing for Supervisor requirements and the space on the magnetic 
drums. This represented an early form of virtual memory. 
The V Store contained the various registers needed to control the tape 
decks, input/output devices, paging mechanism, etc., thus avoiding the 
need to use special functions for this purpose. The technique of 
incorporating peripherals into the address space was subsequently used in 
a number of computer systems, such as the DEC PDP-11. It was termed 
'memory-mapped I/O'. 
However, as Tweedale (1993) notes, being the first technologically 
does not necessarily translate into increased market share. When Ferranti 
sold its computer division to ICT, the Atlas was scrapped in favor of the 
ICT 1900 series. Ferranti’s foray into computing ended and its leadership 
role was surrendered to other British companies. 
The Atlas Users Handbook gives some insight into the early operation 
of a large mainframe computer at a government facility.  
Simon Lavington’s The Atlas Story (2012), prepared by the University 
of Manchester for the 50th Anniversary of the Atlas, provides considerably 
more detail and some excellent photos about the individual machines and 
their usage. It can be obtained online at http://elearn.cs.man.ac.uk/~atlas/ 
docs/The%20Atlas%20story.pdf. Lavington (2015) also describes the 
circuit packages that were used to implement the Ferranti Atlas. It can be 

Ferranti Atlas 
 
119 
obtained 
online 
at 
https://elearn.cs.man.ac.uk/~atlas/docs/Guide%20 
to%20Ferranti%20Atlas%20circuit%20packages.pdf. 
The Atlas 2 demonstrated several advanced features for operating 
systems, including hardware protection and a variety of services provide 
by the Supervisor Extracode Routines (SERs). These influenced other 
operating system developers although the Atlas hardware did not directly 
influence future ICT computers. 
 

CHAPTER SIX 
JOHNNIAC 
 
 
 
The John von Neumann Integrator and Automatic Computer 
(JOHNNIAC) was designed, developed, and operated by The RAND 
Corporation of Santa Monica, California. It was one of several clones of 
the Institute for Advanced Studies (IAS) computer and was named in 
honor of John von Neumann, designer of the IAS machine. It was used to 
support the scientific and engineering studies performed by RAND for its 
Department of Defense (DOD) customers and for general data processing. 
The JOHNNIAC was commissioned in 1953. Figure 6-1 depicts the 
JOHNNIAC at RAND Corporation. The main characteristics of the 
JOHNNIAC are described in Table 6-1 (Weik 1961). 
The JOHNNIAC used vacuum tubes for its primary computation 
circuitry. Initially, main memory consisted of 80 RCA Selectron Tubes 
each of which stored 256 bits. They cost about $500 to manufacture, an 
enormous amount at the time, so they were quickly replaced. 
In the latter part of 1953, RAND contracted with Telemeter Magnetics 
to design and deliver a magnetic core memory. By March 1955, main 
memory consisted of 4096 words of core memory with an access time of 
15 microseconds. Secondary memory consisted of a 12,188 word magnetic 
drum with an average access time of 18 milliseconds. The magnetic core 
storage was the first commercially built core storage. [Note: For this 
reason, I have placed the JOHNNIAC in this section because it used 
magnetic core storage for most of its lifetime.] 
 
 

JOHNNIAC 
 
121 
 
 
Figure 6-1. JOHNNIAC 
Source: Weik 1961 
 
JOHNNIAC ran its last program and was decommissioned in 1966. It 
is now on display at the Computer History Museum in Mountain View, 
California. An excellent description of its early days is the RAND report 
by Fred Gruenberger (Ware 1966, Gruenberger 1968). Table 6-1 describes 
the basic JOHNNIAC characteristics. 
 
Table 6-1. JOHNNIAC Characteristics (Weik 1961) 
Characteristic 
Value/Explanation 
Internal Representation 
Fixed Point Binary 
# Bits/Word 
40 
# Instructions/Word 
19 (later 20) 
# Instructions 
128 (approximately 85 actually used) 
# Bits/Instruction 
20 
Instruction Type 
One Address Code 
CPU Technology 
Vacuum Tube (later partially transistorized) 
CPU Registers 
Accumulator, MQ, Number Register, Instruction 
Register 
Main Memory 
Magnetic Core: 4096 words; Access Time: 15 
microseconds 
Secondary Memory 
Magnetic Drum: 12,288 words; Access time: 
1000 
microseconds 
to 
first 
word, 
60 
microseconds for each succeeding word 
Add Time 
Fixed Point Binary: 10 microseconds  
Multiply Time 
Fixed Point Binary: 385 microseconds 
Divide Time 
Fixed Point Binary: 385 microseconds 

Chapter Six 
 
122
6.1 JOHNNIAC System Architecture 
The JOHNNIAC was a variation of the IAS computer developed at 
Princeton University. Like the IAS, it had four internal registers: the 
Accumulator (ACC), the Multiplier-Quotient (MQ) Register, the Number 
Register, and the Instruction Register. These as well as the arithmetic logic 
were implemented in digital transistor logic by late 1956. In 1957, the 
vacuum tube analog adder was replaced by a transistorized logical adder. 
This reduced add time to 0.8 microseconds. The ACC and MQ were used 
in the logical and arithmetic operations. The Number register acted as a 
buffer between memory and the control. It held an instruction while it was 
being executed. The JOHNNIAC system architecture is depicted in Figure 
6-2. 
JOHNNIAC words were 40 bits in length. A word was transferred into 
the Instruction register. As an instruction it had four components: left 
order, left address, right order, and right address. Orders required 7 bits 
and addresses used 12 bits. The remaining two bits at bit locations 19 and 
20 were not used, but intended for later enhancements. 
JOHNNIAC’s main memory was a 4,096 word magnetic core store. 
Additionally, it had a secondary memory of 12,288 words implemented 
via a magnetic drum, although this was later increased to 24,576 words via 
an enhanced magnetic drum. The Control could not directly address 
individual words on the drum, but could transfer blocks of words up to 
1024 words in length to and from memory. 
Programs and data were entered into JOHNNIAC via an 80-column 
card reader. Data could also be entered by switches and keys on the 
JOHNNIAC console. Output was via an 80-column card punch and a 40-
column Analex printer. However, this printer could only print decimal 
numbers, not special or alphabetic characters. 
Originally, JOHNNIAC used 19 bits to represent an instruction. In 
1962 one level indirect addressing was added to the machine using the two 
heretofore unused bits in the instruction format. Shortly after the machine 
came back on the air, it was discovered that a number of library programs 
ran incorrectly because the programmers had used one or both of the 
"unused" bits in instruction words as semaphores. A switch was added to 
the operator's console to disable or enable indirect addressing. 
Also, in 1962, the Multiple Typewriter Communication System 
(MTCS) consisting of 8 IBM Model B typewriter consoles and drum 
buffer was added. Additional instructions were added to control the flow 
of data between the drum buffers and core storage. 

JOHNNIAC 
 
123 
In 1964 a real time clock was added to support the time sharing 
functions of JOSS (the JOHNNIAC Open Shop System). 
 
 
 
Figure 6-2. JOHNNIAC System Architecture 
Source: Adapted from Melahn 1955 
6.2 JOHNNIAC System Configuration 
The JOHNNIAC had the standard peripherals for its era. A card reader 
could read about 240 cards per minute. A card punch could punch about 
100 cards per minute. An IBM 523 printer could print 136-column hard 
copy at about 1,000 lines per minute. Later, this was replaced by an 
Analex printer that could print at 1,200 lines per minute. Input was 
provided by a keyboard resembling the Friden Flexowriter plus some extra 
buttons for operating the computer. 

Chapter Six 
 
124
Most of the I/O devices were not built for the JOHNNIAC. As a result, 
a considerable lore of operating knowledge evolved about how to operate 
the machine. For example, “don’t hit stop while the card reader is reading 
unless you want to lose a card”. Most of the lore concerned timing 
considerations during program execution. Some of the causes were known, 
but no effort was made to correct them as obeying the rules meant the 
machine worked well. (Gruenberger 1968) 
JOHNNIAC had a loudspeaker attached so as to make the machine’s 
operation audible to the operator. Operators came to recognize certain 
sound patterns as indicating certain types of operations. Eventually, 
someone figured out that programming certain instructions caused 
something resembling music to be played. As Gruenberger notes, there 
was extensive extracurricular effort expended in the construction of card 
decks to play certain themes. He noted that this idea is rediscovered 
independently on most college campuses where an FM radio served a 
similar purpose. 
[Personal Note: this is another one of the lost features of programming 
and operating computers from operator’s consoles that went the way of 
minicomputers. As a student at the University of Maryland, College Park 
during the late 1960s and early 1970s, I remember the systems 
programming staff had developed several card decks that could be 
submitted to the IBM 7094 and the UNIVAC 1108 to play tunes at 
Christmas time.] 
The JOHNNIAC had a modified EAI plotter installed in 1959. The 
plotter could produce 40-inch x 40-inch plots under JOHNNIAC’s 
program control. 
The JOHNNIAC comprised about 5000 vacuum tubes of 11 different 
types. It weighed about 2.5 tons and required approximately 25 tons of air 
conditioning to cool it to operational temperature. 
6.3 JOHNNIAC Instruction Set 
The JOHNNIAC instruction set was divided into 12 groups. The high 4 
bits of the order designated the group and the low order 3 bits specified the 
individual operation. Of the 128 possible operations, approximately 85 
were defined and implemented. 
6.3.1 Conditional Transfer Orders 
Conditional Transfer Orders moved data between registers or 
transferred control, e. g., fetching the next instruction from the right or left 

JOHNNIAC 
 
125 
half of the word based on some condition becoming true. Table 6-2 
describes the conditional transfer orders. 
 
Table 6-2. Conditional Transfer Orders 
Order 
Code 
Mnemonic 
Description 
000 
No 
operation 
This instruction caused the Control to go ahead to 
the next step in the control cycle of left, right, 
fetch. It was used as a filler instruction. 
004 
LM 
Load Multiplier-Quotient: The word at the 
memory address was transferred to the Number 
register, thence to the MQ. 
001 
TNL 
Transfer Negative to the Left: if bit 0 of the ACC 
was 1, control was transferred to the left order of 
the word at the address.  
005 
TNR 
Transfer Negative to the Right: if bit 0 of the ACC 
was 1, control was transferred to the right order of 
the word at the address. 
002 
TPL 
Transfer Plus to the Left: if bit 0 of the ACC was 
0, control was transferred to the left order of the 
word at the address. 
006 
TPR 
Transfer Plus to the Right: if bit 0 of the ACC was 
0, control was transferred to the right order of the 
word at the address. 
003 
TFL 
Transfer Overflow to Left: If the Overflow toggle 
was on, transfer control to the left order of the 
word at the address. 
007 
TFR 
Transfer Overflow to Right: If the Overflow 
toggle was on, transfer control to the right order of 
the word at the address. 
6.3.2 Transfer Orders 
The word at the address was transferred to the Number register, thence 
to the Instruction register. Table 6-3 describes the Transfer Orders. 
 
 
 
 
 
 

Chapter Six 
 
126
Table 6-3. Transfer Orders 
Order 
Code 
Mnemonic 
Description 
010 
TRL 
Transfer to the Left: Unconditional transfer to the 
left order of the word at the address. 
014 
TRR 
Transfer to the Right: Unconditional transfer to 
the right order of the word at the address. 
011 
T1L 
Transfer to the Left if Switch T1 is On: Transfer 
control to the left order of the word at the address 
if switch T1 on the operator’s console is on. 
015 
T1R 
Transfer to the Right if Switch T1 is On: Transfer 
control to the right order of the word at the 
address if switch T1 on the operator’s console is 
on. 
012 
T2L 
Transfer to the Left if Switch T2 is On: Transfer 
control to the left order of the word at the address 
if switch T2 on the operator’s console is on. 
016 
T2R 
Transfer to the Right if Switch T2 is On: Transfer 
control to the right order of the word at the 
address if switch T2 on the operator’s console is 
on. 
013 
T3L 
Transfer to the Left if Switch T3 is On: Transfer 
control to the left order of the word at the address 
if switch T3 on the operator’s console is on. 
017 
T3R 
Transfer to the Right if Switch T3 is On: Transfer 
control to the right order of the word at the 
address if switch T3 on the operator’s console is 
on. 
6.3.3 Add Orders 
The Add Orders transferred the word from the address into the Number 
register. Then, they produced a result in the accumulator. The Overflow 
Toggle was turned on if any of the operation’s results exceeded the 
allowable number. Subtraction was performed by complementing and 
adding. Table 6-4 describes the Add operations. 
 
 
 
 
 

JOHNNIAC 
 
127 
Table 6-4. Add Operations 
Order 
Code 
Mnemonic 
Description 
020 
RA 
Reset Add: Replace the Accumulator contents 
with the word stored at address. This operation 
clears the accumulator, then adds the word at 
address to the accumulator. 
021 
RS 
Reset Subtract: Complement the word from Store 
in the Number Register. Clear the Accumulator 
and add the word in the Number register to the 
Accumulator. 
022 
RAV 
Reset Add Absolute Value: Replace the contents 
of the Accumulator with the absolute value of the 
word at the address. Conditionally, based on the 
sign bit of the Number register (after placing the 
word there), perform an RA or RS. 
023 
RSV 
Reset Subtract Absolute Value: Replace the 
contents of the Accumulator with the negated 
value of the word at the address. Conditionally, 
based on the sign bit of the Number register (after 
placing the word there), perform an RA or RS. 
024 
A 
Add: Add the word specified by the address to the 
contents of the Accumulator replacing the 
contents of the Accumulator. 
025 
S 
Subtract: Add the complement of the word 
specified by the address to the contents of the 
Accumulator replacing the contents of the 
Accumulator. 
026 
AV 
Add Absolute Value: If the sign bit = 0 of the 
word in the Number register, add to the 
Accumulator; else complement and add to the 
accumulator. 
027 
SV 
Subtract Absolute Value: If the sign bit = 1 of the 
word in the Number register, add to the 
Accumulator; else complement and add to the 
accumulator. 
6.3.4 Multiply Operations 
For Multiplication Orders, the multiplier was loaded into the MQ 
register while the address in the instruction specified the multiplicand, 

Chapter Six 
 
128
which was loaded into the Number register. The double length product 
was stored in the Accumulator and the M-Q register. The M-Q register had 
the sign bit and the high order 39 bits, while the accumulator held the low-
order 39 bits of the product with a zero in its sign bit. Table 6-5 describes 
the multiply operations. 
Multiplication proceeded by a conditional add and shift right 
operations for 39 steps. At each step, an addition occurred if the multiplier 
bit was 1. The right shift always occurred. At each step, it brought the next 
bit into bit 39 where it could be examined. The low order bits of the 
product were shifted into the high-order bits of the M-Q register. After 39 
steps, the multiplier sign bit was in bit 39 of the M-Q register and the 
product is contained in the Accumulator and MQ registers. Finally, a 
conditional corrective subtraction (if the Complement Gate was 1) was 
followed by a shift of the MQ register to move a zero into bit 39. 
 
Table 6-5. Multiply Operations 
Order 
Code 
Mnemonic 
Description 
030 
MR 
Multiply Round: Clear the accumulator and insert 
1 into bit 1. Then, multiply as above. 
031 
MNR 
Multiply Negatively And Round: Clear the 
accumulator and insert 1 into bit 1. Then, add the 
complement of the multiplicand during 
multiplication. 
032 
M 
Multiply: Clear the accumulator and perform the 
multiplication as above. 
033 
MN 
Multiply Negatively: Clear the accumulator and 
multiply. Set the product to negative. 
036 
MA 
Multiply And Accumulate: Add the contents of 
the accumulator to the product as it is developed 
during multiplication. 
037 
MNA 
Multiply Negatively And Accumulate: As with 
MA, but the Complement Gate is set to negate the 
addend. 
034 
MB 
Multiply – Both Round And Accumulate: The 
contents of the accumulator were added to the 
product as it is developed. 
035 
MNB 
Multiply Negatively – Both Round And 
Accumulate: The complement of the contents of 
the accumulator were added to the product as it is 
developed. 

JOHNNIAC 
 
129 
6.3.5 Division Orders 
During Division Orders, the dividend resided in the Accumulator and 
MQ registers while the address in the instruction specified the divisor, 
which was loaded into the Number register. The quotient was left in the 
MQ register and the remainder in the Accumulator. Table 6-6 describes 
the division operations. 
The divisor sign bit and the dividend sign bit were examined to 
determine the sign of the quotient. If the quotient was negative, one was 
put in the sign bit of the MQ register and the divisor was added to the 
Accumulator; otherwise, zero was put in the MQ register and no addition 
was performed. The number in the Accumulator and the MQ register was 
shifted left one place, skipping the sign bit. A “trial” subtraction was 
made. Zero or one was put into bit 39 of the MQ register to indicate the 
divisor did or did not go into the dividend. If the sign bits of the divisor 
and the result agree, one was written in the quotient and the subtraction 
was taken; otherwise, zero was written and the subtraction was rejected. 
The left shift positions to the next bit of the dividend to be considered. 
After 39 shifts, the quotient had been generated. 
Division could give results which exceeded the representable numbers 
of the machine. No checks were built into the machine and there was no 
way to reconstruct the correct quotient and remainder from the results of 
an improper division.  
 
Table 6-6. Division Operations 
Order 
Code 
Mnemonic 
Description 
040 
DS 
Divide with Short Dividend: Clear the MQ 
register. Divide the number in the Accumulator by 
the number in the Number register.  
041 
DNS 
Divide Negatively with Short Dividend: Clear the 
MQ 
register. 
Divide 
the 
number 
in 
the 
Accumulator by the complement of the number in 
the Number register. 
044 
D 
Divide: Perform division as indicated above. 
045 
DN 
Divide Negatively: Perform division as indicated 
above, but complement the divisor in the Number 
register. 

Chapter Six 
 
130
6.3.6 Store Orders 
Store Orders allowed all or parts of the word in the Accumulator to be 
transferred to the specified word in memory. The parts that could be stored 
individually were the left order, left address, right order, and right address 
as well as left or right halfwords. Table 6-7 describes the store operations. 
 
Table 6-7. Store and Substitute Operations 
Order 
Code 
Mnemonic 
Description 
050 
ST 
Store Full Word: Store the Accumulator at the 
address specified in the instruction. 
051 
SOL 
Store Left Order: Store the left order part of the 
Accumulator at the address specified in the 
instruction. 
052 
SAL 
Store Left Address: Store the left address part of 
the Accumulator at the address specified in the 
instruction. 
053 
SHL 
Store Left Half: Store the left halfword of the 
Accumulator at the address specified in the 
instruction. 
054 
SAB 
Store Both Addresses: Store the left and right 
addresses at the corresponding positions at the 
address specified in the instruction. 
055 
SOR 
Store Right Order: Store the right order part of the 
Accumulator at the address specified in the 
instruction 
056 
SAR 
Store Right Address: Store the right address part 
of the Accumulator at the address specified in the 
instruction 
057 
SHR 
Store Right Half: Store the right halfword of the 
Accumulator at the address specified in the 
instruction. 
6.3.7 Register Movement Orders 
Register Movement Orders moved data between the MQ register and 
the accumulator. At the same time, they also performed arithmetic 
operations upon the data being moved. Table 6-8 describes the register 
movement operations. 
 

JOHNNIAC 
 
131 
Table 6-8. Register Movement Operations 
Order 
Code 
Mnemonic 
Description 
060 
STQ 
Reset Add MQ to Acc: Clear the Accumulator. 
Add the contents of MQ into Acc. Store the result 
at the address specified in the instruction. 
061 
SNQ 
Reset Subtract MQ from Acc: Clear the 
Accumulator. Subtract the contents of MQ from 
Acc. Store the result at the address specified in the 
instruction. 
062 
SVQ 
Reset Add the Absolute Value of MQ to Acc: 
Clear the Accumulator. Add the absolute value of 
the contents of MQ into Acc. Store the result at 
the address specified in the instruction. 
063 
SNV 
Reset Subtract the Absolute Value of MQ from 
ACC: Clear the Accumulator. Subtract the 
absolute value of the contents of MQ from Acc. 
Store the result at the address specified in the 
instruction. 
064 
AQS 
Add MQ to ACC and Store: Add the contents of 
the MQ to the contents of the ACC and store the 
result at the address specified in the instruction. 
065 
SQS 
Subtract the Absolute Value of MQ from ACC: 
Subtract the absolute value of the contents of MQ 
from ACC. Store the result at the address 
specified in the instruction. 
6.3.8 Shift Orders 
Shift Orders operated on the Accumulator, the MQ register, or a 
combination of both. The number of places to shift was specified in the 
address portion of the instruction. The maximum shift was 127 places. 
Table 6-9 describes the shift operations. 
 
Table 6-9. Shift Operations 
Order 
Code 
Mnemonic 
Description 
070 
SRC 
Accumulator to the Right: Clear MQ. Shift the 
ACC right the specified number of bits. Zeroes 
were loaded into the 0 bit. Bits shifted out of 
position 39 were lost. 

Chapter Six 
 
132
074 
SRH 
Accumulator to the Short Right: Shift the ACC 
right the specified number of bits. Zeroes were 
loaded into the 0 bit. Bits shifted out of position 
39 were lost. 
071 
CLC 
Long Circular Shift to the Left: Clear MQ. Shift 
the ACC-MQ pair to the left the specified number 
of places. 
075 
CLH 
Long Circular Shift to the Left: Shift the ACC-
MQ pair to the left the specified number of places. 
072 
LRC 
Long Right Power Shift: Clear MQ. Shift ACC-
MQ pair right by the specified number of 
positions. Equivalent to multiplying by 2. 
076 
LRH 
Long Right Power Shift: Shift ACC-MQ pair right 
by the specified number of positions. Equivalent 
to multiplying by 2. 
073 
LLC 
Long Left Power Shift: Clear MQ. Shift ACC-MQ 
pair left by the specified number of positions. 
Equivalent to dividing by 2. 
077 
LLH 
Long Left Power Shift: Shift ACC-MQ pair left 
by the specified number of positions. Equivalent 
to dividing by 2. 
6.3.9 Input/Output Orders 
JOHNNIAC had explicit instructions for communicating with each of 
the I/O devices. Table 6-10 describes the I/O Orders. 
 
Table 6-10. Input/Output Operations 
Order 
Code 
Mnemonic 
Description 
10.0 
SEL 
Select I/O Device: Selected the I/O device 
specified by the octal digit in the address part. The 
digit values were: 
 
Digit  Device 
   0     Card Reader – Primary Feed 
   1     Card Reader – Secondary Feed 
   2     Card Punch – Feed Mechanism 
   3     Card Punch – Feed and Echo Mechanism 
   4     Select Analex Printer – Spaces one line 
   5     Select Analex Printer – No spacing 

JOHNNIAC 
 
133 
10.1 
C 
Copy: Operation determined by device selected. 
 
For the card reader, cards were read as two 40-bit 
words. The first word was placed at the address 
specified in the instruction, while the second word 
was placed in the Accumulator. 
 
For the Card Punch, one card was fed past the 
punching station. 12 copy operations caused 24 
binary words to be punched on the card. 
 
For the Analex Printer, the word at the address 
specified in the instruction was brought into the 
Number register, then sent to the printer. 
10.4 
DIS 
Display: The word in the register selected by a 
button on the console was presented on the 
console’s display unit. 
10.5 
HUT 
Hoot: A pulse was sent to the audio amplifier and 
speaker connected to JOHNNIAC. 
10.6 
EJ 
Eject Page. The page in the Analex printer was 
ejected. 
6.3.10 Drum Orders 
One magnetic drum was installed as part of the standard configuration 
on the JOHNNIAC. However, up to four drums could be supported, each 
of 12,288 words capacity. The MQ register held the parameters for either 
operation: a drum identifier d (if more than one installed), the position p of 
the movable head mechanism, the drum band b, and the addresses of the 
first f and last l words in the band to be read or written. The amount of 
information read or written could vary from 1 word up to the band limit of 
1024 words. Table 6-11 describes the Drum Orders. 
 
Table 6-11. Drum Operations 
Order 
Code 
Mnemonic 
Description 
11.0 
RD 
Read Drum: Read words from the drum to 
memory via the Accumulator. The Accumulator is 
cleared at the end of the instruction. The words 
were read from f until l. 
11.1 
WD 
Write Drum: Write words to the drum from 

Chapter Six 
 
134
memory via the Number register. The words were 
written from f until l. 
6.3.11 Logical Product Orders 
The Logical Product Orders performed bit-by-bit intersections of a 
word from memory and the word in the Accumulator. The word from 
memory was passed through the Number register so that complement 
operations could be performed via the Complement Gate. Table 6-12 
describes the logical product operations. 
 
Table 6-12. Logical Product Operations 
Order 
Code 
Mnemonic 
Description 
12.4 
PI 
Positive Intersection: The intersection, e.g., AND, 
of the two words was formed and the result placed 
in the Accumulator. 
12.5 
NI 
Negative Intersection: The intersection of the 
logical complement of the word from memory and 
the word in the Accumulator was formed and the 
result placed in the Accumulator. 
12.6 
PMI 
Conditional Positive Intersection: If bit 0 of the 
word from memory was 0, form the intersection; 
otherwise, invert the bits of the word from 
memory and form the intersection. The result 
placed in the Accumulator. 
12.7 
NMI 
Conditional Negative Intersection: If bit 0 of the 
word from memory was 1, form the intersection; 
otherwise, invert the bits of the word from 
memory and form the intersection. The result 
placed in the Accumulator. 
6.3.12 Control Orders 
The JOHNNIAC Control Orders handled the operating status of the 
machine. Principally, these instructions halted the machine under certain 
conditions in order to allow the programmer to debug a program problem. 
Table 6-13 describes the control operations. 
 
 
 

JOHNNIAC 
 
135 
Table 6-13. Control Operations 
Order 
Code 
Mnemonic 
Description 
13.0 
HTL 
Halt: Restart the computer with the left order at 
the address in the instruction when the GO button 
was pressed. 
13.4 
HTR 
Halt: Restart the computer with the right order at 
the address in the instruction when the GO button 
was pressed. 
13.1 
H1L 
Halt if Conditions Switch 1: Restart the computer 
with the left order at the address in the instruction 
when the GO button was pressed. 
13.5 
H1R 
Halt if Conditions Switch 1: Restart the computer 
with the right order at the address in the 
instruction when the GO button was pressed. 
13.2 
H2L 
Halt if Conditions Switch 2: Restart the computer 
with the left order at the address in the instruction 
when the GO button was pressed. 
13.6 
H2R 
Halt if Conditions Switch 2: Restart the computer 
with the right order at the address in the 
instruction when the GO button was pressed. 
13.3 
H3L 
Halt if Conditions Switch 3: Restart the computer 
with the left order at the address in the instruction 
when the GO button was pressed. 
13.4 
H3R 
Halt if Conditions Switch 3: Restart the computer 
with the right order at the address in the 
instruction when the GO button was pressed. 
6.4 JOHNNIAC Operation 
JOHNNIAC was installed at RAND Corporation headquarters at 1700 
Main St in Santa Monica, California. JOHNNIAC was typically operated 
in two 8-hour shifts. One technician and one engineer were available 
during these hours to handle any problems or special requests. 
Weik (1961) notes that its average operating time was about 10 hours 
(July – November 1956) with an availability of 92%. When the magnetic 
core memory and transistorized ALU were installed in the late 1950s, the 
system became more stable which significantly increased the operating 
time. 
JOHNNIAC was used almost continuously until it was shut down in 
February 1966. At some point, it ended up on the scrap heap, but was 

Chapter Six 
 
136
rescued only to end up again on the scrap heap a short time later. After its 
final rescue it was stored until it could be displayed at the Computer 
History Museum in Mountain View, California. 
6.5 JOSS 
An early interactive calculator language developed for the JOHNNIAC 
was JOSS – JOHNNIAC Open Shop System. JOSS I, a preliminary 
version, was developed by J. Clifford Shaw in May, 1963 (Shaw 1964). A 
full implementation was deployed by Charles L. Baker at RAND in 1964 
(Clark 1975). This became JOSS II; it was ported to the PDP-6 computer 
in 1966 (Marks and Amerding 1967). 
In 1955 Cliff Shaw had envisioned a system for a particular type of 
user not likely to be satisfied by the prospective commercial or 
governmental systems. He called this individual the “open-shopper”, the 
nonprogrammer who was a physicist, engineer, economist, or 
mathematician with a small numerical problem. Sometimes the open-
shopper required the facilities of a desk calculator, but at other times the 
capabilities of a computer. Because computers were difficult to use, Shaw 
sought to develop a system that could be used with little or no training. 
Moreover, Shaw envisioned a system in which the user would interact 
with the computer in the same language that he would use to write 
procedures for indirect invocation.  
In 1959, Willis Ware had described future information processors as 
having multiple I/O stations, so that many people could work with the 
machine at one time. Shaw proposed using the JOHNNIAC as the 
platform on which such a service could be based, since it had been 
superseded at RAND by more modern equipment. As Shaw noted (Shaw 
1964), “The purpose of the JOSS experiment was not to make 
JOHNNIAC machine language available, but rather to provide a service 
through a new, machine-independent language which was designed 
specifically for the purpose”. 
By 1961, the U.S. Air Force had agreed to sponsor an Information 
Processor Project, whose goal was to improve communication between 
human and machine. Cliff Shaw worked with a number of people, 
including Tom Ellis, Ike Nehama, Al Newell, and Keith Uncapher to 
define the characteristics of the system. 

JOHNNIAC 
 
137 
6.5.1 JOSS Structure 
By 1964, the first version of JOSS was operational on the JOHNNIAC 
with five terminals running from 9 AM to Noon each day. By July, its 
operating hours had been extended into the evening hours to accommodate 
the large number of users.  
JOSS was written in a symbolic assembly language called EasyFox (E 
and F in the US military's phonetic alphabet of that time). EasyFox was 
also developed by Cliff Shaw. The JOSS program ran to about 6000 
words. The less used portions resided on the magnetic drum and overlaid 
each other in memory as necessary (Shaw 1964). 
JOSS was dubbed "The Helpful Assistant" because of its 
conversational user interface. Originally green/black typewriter ribbons 
were used in its terminals with green being used for user input and black 
for the computer's response. Any command that was not understood 
elicited the response "EH?". 
Each command took the form of an imperative English sentence with 
one command per line. Commands were either direct or indirect. Direct 
commands began with a verb. An indirect command began with a number 
as seen below. To execute this JOSS program, the user would type “Do 
part 1.1”. Table 6-14 depicts a sample JOSS program (after Clark1975). 
The JOSS approach influenced many later interactive computer languages 
such as FOCAL, CAL and MUMPS. 
 
Table 6-13. Sample JOSS Program 
Sample JOSS Program 
1.1 Demand p,q. 
  
1.2 Stop if q<0 or r(q,2)=0. 
  
1.3 Set a=1. 
  
1.4 Do part 2 while q>1 and a~=0. 
  
1.5 Type a in form 3. 
  
1.6 Stop. 
2   Do part 20. 
  
2.1   Do part 11 if p<0. 
  
2.2 Do part 12 if p>=q. 
  
2.3 Do part 13 if p=0. 
  
2.4 Done if a=0. 
  
2.5 Set p=p/4 while r(p,4)=0. 
  
2.6 Do part 14 if r(p,2)=0. 
  
2.7 Do part 20. 
  
2.8 Set a=-a if r(p,4)=r(q,4)=3. 

Chapter Six 
 
138
  
2.9 Set s=p, p=q, q=s. 
 
2.95 Do part 20. 
11.1 Set a=-a if r(q,4)=3. 
11.2 Set p=|p|. 
11.3 Do part 20. 
12.1 Set p=r(p,q). 
12.2 Do part 20. 
13.1 Set a=0, p=1, q=1. 
14.1 Set a=-a if r(q,8)=3 or r(q,8)=5. 
14.2 Set p=p/2. 
20.1 Type p, q in form 1 if a=1. 
20.2  Type p, q in form 2 if a=-1. 
Form 1: "  L(%.0f,%.0f)  =" 
Form 2: "  -L(%.0f,%.0f)  =" 
Form 3: "  %.0fn" 
 
All calculation was carried out in decimal with 10-digit accuracy. 
Variables could be indexed to provide a vector or array representation. 
Wherever a number or variable could appear, an arbitrarily complex 
expression could be substituted.  
JOSS is described further in Wexelblat (1981) and Rand (1967). Bryan 
(1966) describes an implementation of JOSS at the Lawrence Radiation 
Laboratory at the University of California at Berkeley. 
[Personal Note: Ike Nehama went on to found a company called 
International Computing Corporation (ICC) which was headquartered in 
Bethesda, Maryland on Wisconsin Avenue. It started out as both a data 
processing company – punching cards for larger companies – and a time 
sharing service based, I believe, on an IBM 360/50. By the time I arrived 
in the Fall of 1976, ICC had converted to an engineering services company 
doing consulting and application development. While there, I worked on 
the analysis and design of a Vessel Traffic Management System for the 
U.S. Coast Guard, an operating system for off-track betting for the Hong 
Kong Jockey Club based on a Varian 73, and as a system engineer on a 
contract to the U.S. Air Force Foreign Technology Division at Wright-
Patterson Air Force Base. Eventually, ICC was acquired by Continental 
Telephone Co. in the early 1980s.] 
6.5.2 JOSS Remote Console 
JOSS was operated over a suite of multiple remote consoles each 
interfaced to the JOHNNIAC by a line buffer. JOSS transferred data to 

JOHNNIAC 
 
139 
and from the line buffers to JOHNNIAC, enabled or disabled consoles, 
cleared line buffers, assigned a line buffer to a console, and relinquished a 
console when a session was over. The console was an IBM model 868 
typewriter augmented by a small box with several status lights and control 
switches. The control switches included a POWER switch, ON and OFF 
switches to connect/disconnect the console to/from JOHNNIAC, IN and 
OUT switches to request control for input or relinquish control to receive 
output, and a READY switch to indicate a fresh roll of paper was installed. 
JOSS’s control philosophy was one of exclusive use: either the user or 
JOSS had control of the console. 
6.5.3 JOSS Implementation 
Source: Bryan 1966 
 
JOSS software was divided into five components as described briefly 
in the following paragraphs. All code, consisting of about 16,000 memory 
locations was resident in low-order memory. 
The interpreter examined users’ commands and computed answers in 
response to them. Users’ programs were analyzed character by character. 
User commands and data were stored in linked lists in blocks of varying 
sizes. A block had to be fully resident in a contiguous area of memory 
during interpretation. The minimum block size was 1000 words, but it 
could increase to a maximum of 4000 words in chunks of 1000 words. 
Arithmetic subroutines were used during the computation of results for a 
user command. 
The distributor and disk routines controlled the transfer of data to and 
from the user console and the disk files. They communicated with the 
monitor through signals or traps, which were software analogs akin to 
machine interrupts. The monitor performed scheduling, resource 
allocation, and synchronization operations. It ensured that all data and 
hardware required for a particular action were simultaneously available 
and decided when to schedule actions that could be executed. It 
maintained a set of queues holding user blocks in various activity states. 
The monitor switched users from state to state based on signals and 
completion of actions in user blocks.  
The monitor included the code to handle traps from tape, drum, TTY 
console I/O, the real-time clock (RTC), and routines to gather and display 
statistics and performance data. The latter were used by RAND computer 
time-charging algorithms. Trap device handles responded only to 
hardware interrupts, such as completion of transferring data from a disk 

Chapter Six 
 
140
file to memory or a carriage return signaling the end of input on a TTY 
console. 
The monitor regained control at least every 200 milliseconds as a result 
of an RTC interrupt, but could gain control upon a user command 
executing a software trap. During its period of control, the monitor would 
adjust user states, initiate appropriate I/O activities, and schedule user 
actions for execution. 
As Bryan noted, usage was very heavy across 500 users (as of Fall 
1966) with some being casual and others being addicted (his word).  
6.6 JOHNNIAC Assessment 
By 1957, JOHNNIAC became essentially a free resource as 
maintenance was quite low and RAND’s computing needs were handled 
by leased equipment from IBM. Several individuals advanced the 
fledgling art of computer science through their use of the JOHNNIAC. 
Allen Newell, Herbert Simon, and Cliff Shaw used the machine 
extensively for research into artificial intelligence. The first list processing 
languages – the IPL family – were developed on it as were the first chess 
playing programs (CP-1 and CP-2). The Logic Theorist (LT) and the 
General Problem Solver (GPS) were also developed on the machine. 
The NSS Chess Program, developed by Newell, Shaw and Simon, and 
written in IPL, ran on the JOHNNIAC. This program used a goal-directed 
approach to playing the game – an early innovation in AI research. Each 
goal was implemented as a separate procedure. At each step of the game, 
an analysis program determined which goals were relevant to the current 
state. These goals were passed to the move generator which executed the 
goal procedures to generate the next set of positions. These were evaluated 
and one was selected as the move to be made. 
JOHNNIAC was one of the first machines to support multiuser 
timesharing through JOSS. Although RAND first supported this in-house, 
it eventually made it a commercial timesharing service. JOSS established 
the concept of interactive problem solving, which matured into 
multiprogramming systems and ultimately led to the personal computer – a 
one-on-one interactive, personal problem solver. 
When JOHNNIAC was turned off, it was donated to the Los Angeles 
(LA) County Museum, where it resided until 1989. In 1989, it was rescued 
by the Computer Museum of Boston from the LA County Museum 
parking lot just weeks before it was to be consigned to the landfill.  
Delivered to Boston, it was later moved to the Computer History Museum 
in Mountain View, California. 

FURTHER READING 
 
 
 
Atlas Computer Laboratory (ACL). 1969. Atlas User’s Handbook, Science 
Research Council 
Baker, C. L. 1967. JOSS Rubrics, Rand Corporation, P-3560, Santa 
Monica, CA 
Barron, D. W., A. G. Fraser, D. F. Hartley, et al. 1967. “File Handling at 
Cambridge University”, Proceedings of the Spring Joint Computer 
Conference, ACM, New York, NY, pp. 163-167 
Bryan, G. E. 1966. JOSS; Introduction to the System Implementation, 
RAND Corporation, Santa Monica, P-3486 
Endres, R. O. 2003. Early Transistor History at RCA, available at: 
http://www.semiconductormuseum.com/Transistors/RCA/OralHistorie
s/Endres/Endres_Index.htm 
Goldstine, H. H. 1972. The Computer from Pascal to von Neumann. 
Princeton University Press, Princeton, NJ 
Hardisty, B. Unk. My Involvement with Atlas: Reminisces of Events, 
http://curation.cs.manchester.ac.uk/atlas/elearn.cs.man.ac.uk/_atlas/ 
IEEE. 1985. “David Wheeler, 1985 Computer Pioneer Award”,  
 
https://www.computer.org/web/awards/pioneer-david-wheeler 
International Computers and Tabulators, Ltd (ICT). 1967. I.C.T Atlas 1 
Operators Manual, London, England 
Kuhn, T. S. 1970. The Structure of Scientific Revolutions, University of 
Chicago Press, Chicago, IL 
Moffatt, A. 2012. Memories of the Manchester Atlas,  
 
http://curation.cs.manchester.ac.uk/atlas/elearn.cs.man.ac.uk/_atlas/doc
s/Days and nights with the Manchester Atlas.pdf 
Needham, R. M. and D. F. Hartley. 1969. “Theory and practice in 
operating system design”, 2nd ACM Symposium on Operating System 
Principles, ACM, New York, NY, pp. 8-12 
Needham, R. M. 1992. “Later Developments at Cambridge: Titan, CAP, 
and the Cambridge Ring”, IEEE Annals of the History of Computing, 
14(4):57-58 
Pyle, I. 2012. Memories of Atlas Fortran,  
 
http://curation.cs.manchester.ac.uk/atlas/elearn.cs.man.ac.uk/_atlas/doc
s/Atlas-Fortran-final.pdf 
Redmond, K. C. and T. M. Smith. 1980. Project Whirlwind: The History 
of a Pioneer Computer, Digital Press (DEC), 1980,  

Chapter Six 
 
142
Ross, H .M. 2000. “Ferranti’s London Computer Centre, Resurrection 25, 
Computer Conservation Society 
Shapiro, M. 1956. JOHNNIAC Operator’s Console, RAND Corporation, 
Santa Monica, CA, D-3518 
Shaw, J.C. 1965. JOSS: Examples of the Use of an Experimental ON-Line 
Computing Service, Rand Corporation, P-3131, Santa Monica, CA 
Stinton, I. 2013 (transcribed). The Story of Atlas: A Computer, 
http://curation.cs.manchester.ac.uk/atlas/elearn.cs.man.ac.uk/_atlas/doc
s/london%20atlas%20book.pdf 
Wang, A. 1986. Lessons, An Autobiography. Wang Institute of Graduate 
Studies, Lowell, MA 
 
 

EXERCISES FOR THE READER 
 
 
 
1. JOSS was one of the first interactive computing languages. Research the 
JOSS language and develop an interpreter for it in Java. 
 
2. Develop a simulator for the JOHNNIAC. Research the differences 
between the JOHNNIAC and the IAS machine. 
 
3. Continuing question 2, research the differences among the other 
members of the so-called IAS machine “class”, such as ORDVAC, 
MANIAC, etc. Prepare a summary report which identifies the differences. 
 
4. Following question 2, implement the simulator using the SIMH 
framework. 
 
5. BIZMAC’s two-level memory – high-speed memory and auxiliary 
memory – presaged a technique that was used in early IBM PC’s when 
640K was not adequate for some programs. The transfer of data between 
high speed and auxiliary memory was performed by the hardware on the 
BIZMAC. In the PC, it was performed by calls to the Disk Operating 
System (DOS) from available high address memory accessible by the Intel 
processor, but not directly addressable by the DOS. Compare and contrast 
these two approaches. 
 
6. The BIZMAC supported items, which were variable length character 
strings demarcated by a special character. Compare and contrast the 
BIZMAC implementation of items to the IBM 14xx series implementation 
for variable length words. 
 
7. RCA’s concept of attaching a large number of magnetic tapes to the 
BIZMAC was intended to give the users an “unlimited” amount of online 
memory that was easily accessible. However, the cost of magnetic tape 
drives made this approach economically infeasible for most organizations. 
Assuming magnetic tape drive costs were relatively low-cost, determine an 
upper limit on the number of tape drives that could be reasonably 
supported given the 8K memory. What assumptions do you have to make 
about device drivers and the operating system? 


PART III 
TRANSISTOR MACHINES 
 
 
 
The advent of the transistor contributed to the reduction in the size of 
computers. Early transistor machines were still large systems because of 
the memory systems and the peripherals, but the arithmetic and control 
units became faster and more compact. The transistor also contributed to a 
significant increase in speed over the vacuum tube and magnetic drums of 
the early 1950s. 
 
Transistors 
William Shockley, Walter Brattain, and John Bardeen developed the 
transistor at AT&T’s Bell Laboratories in 1947. Transistors ultimately 
replaced vacuum tubes in computer construction because they used less 
power, generated less heat, were easier to manufacture, and cost less.  
 
A transistor has two basic functions: switching and modulation and/or 
amplification. Acting as a switch, the transistor either allows current to 
flow or not depending on its state – just like the living room switch. 
Alternatively, like a dimmer knob, you can adjust the amount of current 
allowed to flow. 
 
Transistors are made of semiconductors such as silicon or gallium 
arsenide. Putting a layer of semiconductor of one type between two layers 
of another type allows you to control how much current flows and its 
direction between the two layers. Control is provided by the amount of 
current fed to the intermediate layer. 
 
See 
http://www.beatriceco.com/bti/porticus/bell/belllabs_transistor.html 
for a history of the transistor. 
 
William Shockley, Walter Brattain, and John Bardeen 
William Shockley, Walter Brattain, and John Bardeen won the Nobel Prize 
in Physics in 1956 for the invention of the transistor. Shockley led the 
Solid State Physics Group at Bell Labs tasked with finding alternatives to 
the fragile vacuum tube amplifiers. He developed the initial concepts 

Part III 
 
146
while Brattain and Bardeen developed the experimental methods and 
demonstrated the point-contact transistor in December 1947. 
 
See the American Physical Society article on the invention of the 
transistor: 
https://www.aps.org/programs/outreach/history/historicsites/transistor.cfm 
 
Chapters: 
Chapter Seven: UNIVAC Solid State Computer 
Chapter Eight: UNIVAC 418 
Chapter Nine: UNIVAC 490/494 
Chapter Ten: MIT’s TX-0 
Chapter Eleven: Philco Ford Computers 
Chapter Twelve: Bendix G-20 
Chapter Thirteen: Packard Bell PB250 
 

CHAPTER SEVEN 
UNIVAC SOLID STATE COMPUTER 
 
 
 
UNIVAC was one of the first companies to recognize the versatility of 
transistors. In 1952, it began the development of the UNIVAC Solid State 
Computer (SSC) for the U. S. Air Force Cambridge Research Center 
(AFCRC). This machine was completed in 1956 by the Philadelphia 
Division – the former Eckert-Mauchly Computer Corporation. The Solid 
State I and II were designed as general purpose data processing systems 
for use in business applications. They were intended to directly compete 
with the IBM 650.   
The first Solid State Computer was delivered to the Economics 
Laboratory, Inc., a St. Paul, Minnesota company which manufactured 
detergents and cleaning compounds (Gray 1999). This machine was called 
the UNIVAC Card Tabulator (UCT).  
It wasn’t until 1958 that UNIVAC released the Solid State 80 and the 
Solid State 90 computing machines as commercial products. The primary 
difference between the two models was that one was capable of reading 
and punching the IBM standard 80 column cards while the other operated 
using the European standard 90 column cards. 
Figure 7-1 depicts the UNIVAC Solid State Computer. The SSC used a 
data representation called bi-quinary coded decimal, which was well-
suited for business applications. Table 7-1 provides the basic 
characteristics of the Solid State 80, the first model. 
 
 
 
Figure 7-1. UNIVAC Solid State Computer  
Source: Remington Rand 1958b 
Photo reproduced courtesy of Unisys Corporation, 2016 

Chapter Seven 
 
148
Table 7-1. Solid State 80 – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal 
Representation 
Bi-quinary Coded Decimal 
# Digits/Word 
10 plus sign (41 bits) 
# Instructions/Word 
1 
# Instructions 
76 
# Digits/Instruction 
10 
Instruction Type 
One and a Half Address Code 
CPU Technology 
Transistors 
CPU Registers 
3 – Arithmetic Registers; 9 Index Registers (4 bits) 
Main Memory 
Magnetic Drum: 5000 words 
Add Time 
Fixed Point: 85 microseconds 
Multiply Time 
 
Divide Time 
 
 
In 1956, Univac delivered the first commercial solid state computer to 
the Dresdner Bank in Hamburg, Germany. It had several enhancements 
over the machines built for the U.S. Air Force (Remington Rand 1958e, 
Gray 1999). The UNIVAC Solid State 80 had a list price of approximately 
$350,000. Sales were brisk during 1959 and 1960 with about 600 being 
sold, but the advent of the IBM 1401, which was faster and more capable, 
coupled with IBM’s marketing expertise, caused the demise of the Solid 
State 80. 
7.1 Solid State Computer Architecture 
Source: Gray 1999 
 
The UNIVAC Solid State Computer’s (SSC) base configuration 
consisted of the CPU and drum memory, card reader, card punch, and 
printer. Purchasers could optionally add a tape controller and up to ten 
UNISERVO II tape drives. The drives could read both the new Mylar tape 
and the old UNIVAC metallic tape. 
The UNIVAC Solid State CPU had 20 vacuum tubes, about 700 
transistors, and over 3,000 Ferractor amplifiers. UNIVAC packaged them 
with support resistors and diodes on small, pluggable printed circuit 
boards. Typically, 2 or 3 boards were used for one vacuum tube in other 
machines. The boards were accessible through the front panels of the 
machine. Figure 7-2 depicts a Solid State Computer with glass doors 
showing the printed circuit boards.  

UNIVAC Solid State Computer 
 
149 
 
 
Figure 7-2. Univac Solid State Computer Cabinet  
Source: Remington Rand 1958b 
Photo reproduced courtesy of Unisys Corporation 
 
The SSC was an air-cooled unit. Fans and blowers in each cabinet 
dissipated the heat generated by the motors and the solid-state circuits. 
Room air conditioning facilitated machine cooling, but was often primarily 
for the operator’s comfort. The rightmost cabinet contained the system 
console and other operating panels. Below the console, behind an 
aluminum panel, was a large fan that blew cool air onto the shelves on the 
left side of the cabinet containing the circuit cards. Behind the console 
resided the magnetic drum.  
Figure 7-3 depicts the voltage monitoring panel located above the 
system console. The voltmeter was used by the operators to diagnose 
power fluctuations in the system which were often indicative of failing 
parts. To the left of the voltmeter were a set of lamps that indicated 
various fault conditions. The system console is depicted in Figure 7-4. 
 

Chapter Seven 
 
150
 
 
Figure 7-3. UNIVAC SSC90 Voltage Monitoring Panel 
Source: http://ussc90.nl/menu.htm 
Courtesy of Jan Lindeboom, Grote Kerkstraat 58, 8911EG, Leeuwarden The 
Netherlands. 
 
 
 
Figure 7-4. UNIVAC SSC90 System Console  
Source: http://ussc90.nl/menu.htm 
Courtesy of Jan Lindeboom, Grote Kerkstraat 58, 8911EG, Leeuwarden The 
Netherlands. 

UNIVAC Solid State Computer 
 
151 
Like the IBM 650, it used a magnetic drum memory for its main 
memory. The drum was small (5 x 8 inches) and had 25 tracks of 200 ten-
digit words for a maximum capacity of 5000 words. 
The Solid State Computer competed rather successfully with the IBM 
650. Indeed, Remington Rand released a 650 emulation program to 
facilitate the process of migration from the IBM 650 to its machine. 
 
Ferractor 
A Ferractor was a type of transformer wound on a storable iron core used 
to build magnetic amplifiers. Each Ferractor performed a 1-bit operation. 
In the first half of a cycle, the Ferractor was magnetized or not depending 
on the current in a bias coil. In the second half, the Ferractor showed on a 
secondary coil either high- or low-impedance. Low impedance generated a 
bias current on the next Ferractor. UNIVAC used them for building logic 
circuits rather than vacuum tubes or transistors. The benefits of the 
Ferractor were a longer life, better reliability and smaller size.  
 
Figure 7-5 depicts a circuit board with four Ferractors embedded. 
 
 
 
Figure 7-5. UNIVAC SS90 Circuit Board with Ferractors 
Source: http://ussc90.nl/circ.htm 
Courtesy of Jan Lindeboom, Grote Kerkstraat 58, 8911EG, Leeuwarden The 
Netherlands. 

Chapter Seven 
 
152
7.1.1 SSC Central Processor 
Source: Remington Rand 1958d, 1959f 
 
The SSC Central Processor consisted of the following components: 
 
x Control section,  including arithmetic, logic, and control circuits 
x Main memory drum 
x Supervisory control panel 
x An inquiry keyboard 
x Central power supply and voltage regulator 
 
The control section had multiple printed circuit boards which plugged 
into the front chassis of the processor (see Figure 7-2). 
The SSC had three 10-digit arithmetic registers: A, X, and L. None of 
these could support indexing. A (address 000K) was used for addition and 
subtraction operations and received the significant digits of the result after 
multiplication. A also received the quotient after division, while X 
(address 000T) received the remainder. L (address 000Y) was used for 
multiplication. Register C held the instruction being executed.  
Index registers were available as $7500 option. Three index registers – 
B1, B2, and B3 – were provided, each containing a 4-digit value 
corresponding to the four digit address of the instruction. Many customers 
chose to modify instructions rather than purchase the index register option. 
As Gray notes, the Solid State Computer programming manual called this 
an “invaluable feature”. It is difficult to accept this today when the 
instructions are treated as read-only code. 
The SSC80 CPU was implemented on 1000 circuit cards, each with a 
few active components on it. The system architecture of the SSC90 is 
depicted in Figure 7-6. 
 
 

UNIVAC Solid State Computer 
 
153 
 
 
Figure 7-6. SSC90 System Architecture 
Source: Adapted from Remington Rand 1958d, 1959f 
7.1.2 Magnetic Drum 
Source: Remington Rand 1958d, 1959f 
 
The primary storage for the SSC was a magnetic drum. The SS90’s 
magnetic drum had a capacity of 5000 words of 10 digits each. A 
maximum of 20 words could be fetched during one drum rotation at a 
speed of 17,670 rpm. This yielded a data rate of approximately 707,000 
characters per second. The drum was hermetically sealed in a helium 
atmosphere to reduce air friction heating. This allowed closer head 
placement to the magnetic drum surface with greater operational 
efficiency. The magnetic drum required about 8 minutes to spin up to its 
operating speed. 
The drum was divided into 25 bands of 200 words each. Bands 1 
through 20 were fast-access bands that had one read/write head associated 
with each band. The average access time was 1.70 milliseconds. Bands 
4000, 4200, 4400, 4600, and 4800 were high-speed bands, each equipped 
with four groups of heads, which were spaced 50 words apart. They had 
average access times of 0.212 milliseconds.  

Chapter Seven 
 
154
A section of the drum was assigned as I/O buffers with an average 
access time of 212 microseconds. These buffers mediated the transfer 
speed between the I/O devices and the CPU. These bands had eight 
read/write heads positioned over the band. These buffers were accessible 
only through instructions with opcodes 46, 81, and 96. The I/O devices 
automatically read/wrote their data from this buffer area. A drum timing 
band was used to generate addresses to control the buffer transfers. The 
paper tape punch and reader shared a common buffer while the high-speed 
printer had its own buffer. 
Data was represented in 10 digits with an implied decimal point to the 
left of the most significant digit. Thus, every word represented a value 
between 0 and 1. 
7.1.3 Operator’s Console 
To initiate a program in the SSC90, the operator placed the Load 
program into the card reader followed by his program. At the console, he 
pressed ‘General Clear’, selected the C register, and pressed ‘one 
instruction’ under Operation. He then entered a72 0000 000K+ into the 
control register, selected register A, and typed in a96 4000 4001+. Then, 
he pressed ‘Continuous’ and ‘Run’. The operator’s console is depicted in 
Figure 7-7. 
This caused instruction 72 to be executed which read a card from the 
card reader. The CPU fetched the next instruction from register A which 
executed instruction 96 placing the card image in the 4000 band. This in 
turn read in a 16-card program that read a larger loading program. This 
program initialized memory and loaded the user’s program, which started 
automatically.  
 

UNIVAC Solid State Computer 
 
155 
 
 
Figure 7-7. UNIVAC SSC90 Operators Console 
Source: http://ussc90.nl/ireg.htm 
Courtesy of Jan Lindeboom, Grote Kerkstraat 58, 8911EG, Leeuwarden The 
Netherlands. 
7.2 SSC80/SSC90 Instructions 
The Solid State Computer specified – as a half address – the address of 
the next instruction to be executed in the C portion of the instruction. The 
values of these fields were expressed as decimal digits. The format of the 
Solid State 80 instruction is depicted in Figure 7-8. 
 
 
 
Figure 7-8. SSC80/SSC90 Instruction Format 
Source: Remington Rand 1958d, 1959f 
Photo reproduced courtesy of Unisys Corporation 
 
The M address was usually the address of the word in memory while 
the C address specified where the next instruction would be found. Thus, 
the instruction 50 3456 4356 specified the opcode as 50, the operand 
address as 3456, and the next instruction address as 4356. 
In the following instruction descriptions, A, X, and L represent 
arithmetic registers. 

Chapter Seven 
 
156
7.2.1 Executing an Instruction 
Executing an instruction required four steps: 
1. Staticize the instruction. The opcode of the instruction located by 
the previous search was transferred from the drum to the Static 
Register. The entire word was loaded into register C. 
2a. Locate the operand in memory. If this instruction required a 
memory-based operand, the contents of the M part of register C 
was compared with the next drum address until a match was 
obtained. This could take up to 200 word times – the maximum size 
of a band. 
2b. If it does not refer to drum memory, this action was skipped. 
3. Execute the instruction. The instruction was performed. 
4. Search for Next Instruction. Every word time, the address of the 
next drum storage location was compared with the C part of 
register C until a match is obtained. 
7.2.2 Arithmetic Instructions 
Table 7-2 presents the basic arithmetic instructions. Arithmetic 
instructions operated on data contained in the Accumulator and in 
memory. The result was left in the accumulator or in the A and X registers 
for multiply and divide instructions. 
 
Table 7-2. SS80 Arithmetic Instructions 
Mnemonic 
Opcode 
Description 
ADD m,c 
70 
Add to Accumulator: A <- c(A) + c(m); if 
overflow, increment C 
SUB m,c 
75 
Subtract from Accumulator: A <- c(A) - c(m); if 
overflow, increment C 
MUL m,c 
85 
Multiply Accumulator: A = MSD, X = LSD <- 
c(L) 8 c(m) 
DIV m,c 
55 
Divide Accumulator: A = Quotient, X = 
Remainder <- c(L) / c(m) 
7.2.3 Transfer Instructions 
Table 7-3 presents transfer instructions which moved data between 
memory and the registers and registers to registers. 
 
 

UNIVAC Solid State Computer 
 
157 
Table 7-3. SS80 Transfer Instructions 
Mnemonic 
Opcode 
Description 
LDA m,c 
25 
Load A: A <- c(m) 
LDX m, c 
05 
Load X: X <- c(m) 
LDL m,c 
30 
Load L: L <- c(m) 
STA m,c 
60 
Store A: m <- c(A) 
STX m, c 
65 
Store X: m <- c(X) 
STL m,c 
50 
Store L: m <- c(L) 
ATL -,c 
77 
Store A in L: L <- c(A) 
CTA m,- 
23 
Carry to A: A <- c(C) 
CLA m,- 
26 
Clear A: A <- 0 
CLX m,- 
06 
Clear X: X <- 0 
CLL m,- 
31 
Clear L: L <- 0 
CAA ,- 
36 
Clear A, retain sign: A <- 0, keep sign 
CAX m,- 
86 
Clear A and X, Copy Sign: A <- 0; X <- 0, 
Sign(A) <- Sign(L); Sign(X) <- Sign(L) 
7.2.4 Logical and Shift Instructions 
Table 7-4 presents the logical and shift instructions which operated 
primarily upon the A register. 
 
Table 7-4. SS80 Logical and Shift Instructions 
Mnemonic 
Opcode 
Description 
BUF m,c 
20 
Superimpose: A <- c(M) on c(A) 
ERS m,c 
35 
Extract: A <- c(M) from c(A) 
SHR 
0n00,c 
32 
Shift Right n places: shift c(A) -> X <- A 
SHL 
0n00,c 
37 
Shift Left n places: a<- Zeroes LSD 
ZUP -,c 
62 
Suppress Zeroes, Commas. MC-6 in A, X 
JMP m,- 
00 
Skip (e.g., Jump unconditional) 
STP m,c 
67 
Stop 
7.2.5 Comparison Instructions 
Table 7-5 presents the instructions for comparing two values contained 
in the A and L registers respectively. Note there was no compare less 
instruction as the engineers believed the other two instructions covered 
that case. 

Chapter Seven 
 
158
Table 7-5. SS80 Comparison Instructions 
Mnemonic 
Opcode 
Description 
TEQ =, /= 
82 
Compare Equal: c(A): c(L); if equal, skip one 
instruction 
TGR >, <= 
87 
Compare Greater Than: c(A): c(L); if greater 
than, skip one instruction 
7.2.6 Translate Instructions 
Table 7-6 presents the instructions for translating a reference to an 
address using an index register. 
 
Table 7-6. SS80 Translate Instructions 
Mnemonic 
Opcode 
Description 
LIR m,c 
02 
Load Index Register: m of instruction word -> 
IRi 
IIR m,c 
07 
Increment Index Register: m of instruction word 
+ c(IRi) -> IRi 
7.2.7 SS80 Printer Control Instructions 
Table 7-7 presents the instructions for controlling the high-speed 
printer. 
 
Table 7-7. SS80 Print Instructions 
Mnemonic 
Opcode 
Description 
PRN 
bbnn,c 
11 
Advance nn lines, print bb band; A, X 
overwritten 
PFD 
00nn,c 
16 
Advance nn lines 
PBT 
Yes,No 
27 
Printer-Free Test: Yes c(C) -> A 
7.2.8 Card Reader Control Instructions 
Table 7-8 presents the instructions for controlling the high-speed card 
reader. 
 
 
 
 

UNIVAC Solid State Computer 
 
159 
Table 7-8. SS80 Card Reader Instructions 
Mnemonic 
Opcode 
Description 
HBT Yes, 
No 
42 
Buffer-Loaded Test: Yes c(C) -> A 
HBU 
bb00,c 
96 
Store Card Reader Buffer: c(B) -> J, interlace on 
BB00 band 
HBU 
bb01,c 
96 
Store Card Reader Buffer: c(B) -> MC-6 -> J, 
interlace on BB01 band 
HCC m,c 
72 
Card Cycle. Interlock c(C) -> A; NI -> m 
HSS 
0n00,c 
47 
Select Stacker n (n = 0,1,2) 
Note: other SS80 peripheral instructions are omitted. 
7.3 SSC Peripherals 
Source: Remington Rand 1959g 
 
The SSC had a small complement of peripherals. These peripherals 
were essentially the same as those described for UNIVAC 418 and 494 
systems below, except for interfaces to the devices themselves. These 
included a high-speed card reader, a high-speed card read-punch unit, and 
a high-speed printer. The high-speed reader read 90-column punched cards 
at speeds up to 450 cards per minute. A card hopper held up to 1000 cards. 
Three output stackers held up to 800 cards each, which allowed a division 
of an input deck into three output decks. The CPU controlled the reader on 
a time-shared basis so that reading cards occurred concurrently with data 
processing.  
The read-punch unit could read, punch, and check 90-column cards at 
speeds up to 150 cards per minute. Reading and punching were also time-
shared with computation under control of the CPU. Checking was 
performed on a word-for-word basis within the unit. 
The high-speed printer could print up to 600 lines per minute with up 
to 130 print positions per line. Printing occurred concurrently with 
computation under control of the CPU. The printer supported 51 printable 
characters: 26 alphabetic, 10 numeric, and 15 special characters. Each 
print position had a rotating print wheel contain the character set. 
Character spacing was ten characters per inch. Line spacing was single, 
double, or variable with six lines per inch. An interlock system suspended 
printing while paper sheets advanced. This printer was an enhanced 
version of the printer used with the UNIVAC I and II since the early 
1950s. 

Chapter Seven 
 
160
7.4 Solid State Computer System Software 
The SSC used the Z assembly language and the X-6 assembly 
language processing system based on cards and tape. The X-6 system used 
symbolic instructions and symbolic addresses which allowed the 
programmer to not worry about the rotation of the drum in calculating 
addresses. The X-6 system allowed the work of multiple programmers to 
be combined together. The ARGUS debugging system provided a 
primitive symbolic debugging system that could scan the instructions in 
memory to detect interrupted program sequences. A second program, 
KOPRA, simulated program execution and produced a list with the 
executed instructions, the register-contents and the operands used. When a 
program was debugged to the programmer’s satisfaction, a separate 
program could be loaded into memory to punch the program onto cards. 
7.4.1 FLOW-MATIC 
Although much programming was done in assembly language, 
Remington Rand also provided a version of FLOW-MATIC which used 
English language-like statements to describe the computation. FLOW-
MATIC consisted of 21 statements of which five controlled I/O operations 
and sixteen were used to describe basic programming operations such as 
add, subtract, compare, transfer, etc. Two examples of FLOW-MATIC 
statements are provided below (Remington Rand 1958e): 
 
MULTIPLY AND ROUND GROSS-EARNINGS 02 BY FICA 
RATE C PLACE THE RESULT IN FICA –DEDUCTION 02 
 
ADD FICA-DEDUCTION 02 TO ACCUMULATED-FICA 01 
PLACE THE RESULT IN TEST-ACCUMULATION W. 
 
Remington Rand claimed that programmers could be trained in 
FLOW-MATIC in only two weeks, thus yielding substantial productivity 
over the process of assembly language programming. Remington Rand 
believed there was greater clarity in high-level language statements over 
assembly language. Further, managers and auditors could read the 
programs and generally understand them because of FLOW-MATIC’s 
style. 
Programming with FLOW-MATIC proceeded in two phases. First, the 
problem was analyzed and a flow chart created using the English-like 
FLOW-MATIC statements. In stage two, the FLOW-MATIC statements 

UNIVAC Solid State Computer 
 
161 
were transcribed to punched cards, and submitted to the FLOW-MATIC 
processor for checking, and translation into machine language instructions. 
For larger systems, FORTRAN II, the S4 Assembly system, a Report 
Generator, PROGENY, and a variety of other utility programs were also 
available.  
7.5 SSC Assessment 
The SSC was the first commercially available electronic computer in 
the marketplace. The SSC competed with the UNIVAC File Computer. 
Delays in the File Computer and the SSC impacted Remington Rand’s 
ability to compete with IBM. Delays on the LARC impacted further 
development of the SCC successor. Although the SSC was as powerful as 
the IBM 650, it was not as capable as the IBM 1401 which was announced 
in 1959.  
However, the SSC was one of UNIVAC’s most successful products 
selling over 300 of these medium computer systems. It was the 
Philadelphia division of Remington Rand Univac’s second offering. The 
Solid State 80 was UNIVAC management’s recognition that the 80-
column IBM card had become the industry standard.  
Initially, the machine was only sold in Europe Management thought 
such sales would undermine its File Computer and key Remington Rand 
product such as the 90-hole card punches and tabulators that U.S. orders 
were refused until 1959. Eventually, 600 of the combined series of SSC 80 
and SSC 90 were sold in the U.S. and Europe. 
Jan Lindeboom (http://ussc90.nl/menu.htm) describes his use of a 
UNIVAC SSC90 at the Christiaan Huygenschool in the Netherlands from 
1970 to 1978. The Holland America Line donated this machine to the 
school. He and his friends repaired the machine, taught themselves how to 
program, did some rewiring, and built new parts to keep the machine 
running for eight years. This website contains a picture of Jan standing at 
the SSC90 operator’s console. 
 

CHAPTER EIGHT 
UNIVAC 418 
 
 
 
The UNIVAC 418 Real-Time Computer was primarily as a medium-
sized real-time computer system developed in the early 1960s. It evolved 
from the Control Unit Tester (CUT), a device used in the factory to test the 
peripheral equipment for larger UNIVAC systems. However, as with other 
UNIVAC commercial systems, it evolved into a system capable of 
supporting the three major types of data processing – batch, timesharing, 
and real-time. (Remington Rand 1969, Gray 2000) 
In 1962, Westinghouse became interested in the 418 for use as an 
industrial process control computer. UNIVAC modified it to become a 
component of the Westinghouse PRODAC 510 and 580 machines. 
The UNIVAC 418’s name came from its 4 millisecond cycle time and 
18-bit word size. As a medium-size, real-time computing system, it was 
intended for use with transaction processing systems and real-time 
communications systems. The  
There were three models of the UNIVAC 418 developed over several 
years. All told, a total of four hundred machines were delivered to various 
customers. (Gray 2000) The basic characteristics of the UNIVAC 418 are 
described in table 8-1. 
 
Table 8-1. UNIVAC 418 – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal Representation 
Fixed Point Binary 
# Bits/Word 
18 
# Instructions/Word 
1 
# Instructions 
98 
# Bits/Instruction 
18 
Instruction Type 
One Address Code 
CPU Technology 
4 microsecond cycle time 
CPU Registers 
2 accumulators(AUpper,ALower); 8 index 
registers; index control register; special register 
(SR) 
Main Memory 
Magnetic Core: 4K – 16 KWords 

UNIVAC 418 
 
163 
Secondary Memory 
Magnetic Drum: FH-220 
Add Time 
Fixed Point: 8 microseconds 
Multiply Time 
Fixed Point: 26 – 48.7 microseconds 
Divide Time 
Fixed Point: 48 microseconds 
8.1 UNIVAC 418-I 
Source: Gray 2007 
 
The UNIVAC 418-I was the original version of the machine. A basic 
system consisted of 4K -16K words and eight I/O channels, but up to eight 
additional channels could be added to the machine. The UNIVAC 418 
used one’s complement arithmetic for both single- and double-precision 
calculations. 
Only six UNIVAC 418-Is were produced, with the first one was 
delivered in June 1963. It was powered by the Real Time Executive (RTE) 
operating system. A typical system consisted of a UNIVAC 1004 card 
processor, 
FH-220 
drum, 
UNISERVO 
IIIC 
tape 
drives, 
and 
communications devices. 
8.2 UNIVAC 418 System Architecture 
The UNIVAC 418 had 32 words of non-destructive readout memory 
used to initially boot the machine. The central processor had two 18-bit 
registers referred to as AU(upper) and AL(lower) which could be used as 
one register for double-word operations. There were eight index registers 
and an index control register which was used to designate which of the 
eight index registers was to be used at any given moment. 
The 418’s address register (AR) was 12 bits, which allowed it to access 
4K words. The machine had a 6-bit special register (SR), which 
augmented the address register to address larger memories. The high order 
bit was a control bit while the remaining five bits were used with the AR 
to form a 17-bit address. Thus, the 418 could effectively address up to 
131K words of memory. 
8.3 Instruction Format 
The UNIVAC 418 provided three types of instructions, labeled Types 
I, II, and III, as depicted in Figures 8-1 (a) and 8-1(b). 
Type I and II instructions comprised a 6-bit operation code and a 12-bit 
address. For Type I instructions, if the lead bit of the Special Register was 

Chapter Eight 
 
164
set, the remaining five bits were used to form a 17-bit address. Otherwise, 
the needed five bits were taken from a separate Instruction Address 
Register (IAR).  
Type II instructions always used the IAR to or from the 17-bit address. 
In some Type II instructions, the 12-bit address field was used as an 
immediate operand. Type III instructions consisted of a 6-bit function 
code, a 6-bit minor function code, and a 6-bit data field. Most I/O 
instructions were of Type III. The two words following a Type III 
instruction were used for buffer control information. 
 
 
 
Figure 8-1(a). UNIVAC 418 Instruction Format I/II 
 
 
 
Figure 8-1(b). UNIVAC 418 Instruction Format III 
Photo reproduced courtesy of Unisys Corporation 
8.3.1 Type I Instructions 
Type I instructions referenced main storage. They were sensitive to the 
SR Active bit in the Special Register. When the SR Active bit was 1, the 
high order five bits necessary to complete a 17-bit main storage address 
were taken from the low-order five bits of the SR. Otherwise, the five bits 
were taken from the high-order five bits of the IAR.  
8.3.2 Type II Instructions 
Type II instructions referenced main storage, but were not sensitive to 
the SR Active bit. They also included instructions that used an immediate 
operand. For Type II instructions, the high order five bits necessary to 
complete a 17-bit storage access were obtained from the high-order five 
bits of the IAR. 

UNIVAC 418 
 
165 
8.3.3 Type III Instructions 
Type III instructions are those which contained special parameters that 
were supplied to execute certain functions. For example, the Designator 
field in Figure 8-1(b) might be a shift count, or a channel number. Some 
Type III instructions also required additional data. For example, the 
instruction to set BCWs for the IOMs used the following two words for 
these parameters. 
8.4 System Software 
UNIVAC provided the TRIM assembler to translate assembly 
language source code into machine code. This assembler used octal digits 
because the 18-bit word was evenly divisible by three.  
8.5 UNIVAC 418-II 
Source: Gray 2007 
 
The UNIVAC 418 Model II became available in November 1964. It 
supported a memory ranging from 4K to 65K words, while its cycle time 
was reduced to 2 microseconds. Figure 8-2 depicts a UNIVAC 418-II 
system. The enhanced operating system, known as EXEC-II, supported 
more peripherals and a sophisticated communications subsystem for 
handling interactive systems.  
 
 
 
Figure 8-2. UNIVAC 418-II System 
Source: http://bitsavers.trailing-edge.com/pdf/univac/418/photos/418-II.jpg 
Photo reproduced courtesy of Unisys Corporation 

Chapter Eight 
 
166
The UNIVAC 1219 was the militarized version of the UNIVAC 418-
III and delivered at the same time. The UNIVAC 1219 became a 
component of the U.S. Navy’s Mk76 control system for the Tartar missile 
system, it was designated the Mk152 Fire control Computer. The 
UNIVAC 1219 will be described in a forthcoming volume on military 
computers. 
8.6 UNIVAC 418-III 
Source: Remington Rand 1969c, Gray 2007 
 
The UNIVAC 418 Model III was delivered in mid-1969. Its primary 
features were a memory size increased to 131KWords, and a CPU cycle 
time reduced to 750 nanoseconds. New instructions for floating point 
operations were added to the system as were binary-to-decimal and 
decimal-to-binary conversion instructions. The basic characteristics of the 
UNIVAC 418-III are presented in table 8-2. 
 
Table 8-2. UNIVAC 418-III – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal 
Representation 
Fixed Point Binary 
# Bits/Word 
18 
# Instructions/Word 
1 
# Instructions 
108 
# Bits/Instruction 
18 
Instruction Type 
One Address Code 
CPU Technology 
750 nanosecond cycle time 
CPU Registers 
2 accumulators(AU,AL); 8 index registers; index 
control register; special register (SR) 
Main Memory 
Magnetic Core: 32K-128KWords 
Secondary Memory 
Magnetic Drums: FH-220, FH-432, FH-1782 
(Model III), FASTRAND II/III (Model III) 
Add Time 
750 nanoseconds 
Multiply Time 
26 – 48.7 microseconds 
Divide Time 
48 microseconds 
 
 
 

UNIVAC 418 
 
167 
8.6.1 UNIVAC 418-III System Architecture 
Source: UNIVAC 1969e 
 
The UNIVAC 418-III system architecture consisted of six components: 
x Command/Arithmetic Unit (CAU) 
x Input/Output Modules (IOMs) 
x Main Storage 
x Auxiliary Storage Systems 
x Peripheral Systems 
x Communications Subsystem 
 
A typical UNIVAC 418-III system configuration is depicted in Figure 
8-3. The upper two levels constitute the central processor unit. A 
minimum configuration consisted of a CAU, main storage with 32 
KWords, and one IOM with eight I/O channels. These are drawn with 
heavy black lines.  The basic configuration could be expanded with several 
options which will be described in the following sections. 
  
 
 
Figure 8-3. UNIVAC 418-III System Configuration 
Source: Adapted from Remington Rand 1969c 

Chapter Eight 
 
168
8.6.2 Command/Arithmetic Unit (CAU) 
The CAU consisted of two sections: the Command Section and the 
Arithmetic Section. The Command Section contained all of the circuitry to 
decode and execute the instructions contained in the UNIVAC 418-III 
instruction repertoire. An optional floating point unit increased 
performance when executing floating point operations. Another optional 
feature handled decimal-to-binary and binary-to-decimal conversions. The 
CAU registers are described in the following sections. 
 
8.6.2.1 Special Register 
 
The Special Register (SR) was a 6-bit register that could be used as a 
base register for Type I instructions. The SR Active Bit, when set to 1, 
specified that the other 5 bits were prepended to the 12 bits in the 
instruction to form a 17-bit address.  
 
8.6.2.2 Instruction Address Register 
 
The Instruction Address Register (IAR) was a 17-bit register used to 
access instructions in main memory. The high-order 5 bits could also be 
used as a base register for Type I and Type II instructions. The IAR could 
be incremented by one for sequential access, by one or two for branching 
instructions, and receive a new value to for jump instructions. 
 
8.6.2.3 Index Registers 
 
Eight memory locations were reserved for Index Registers (IRs). An 
Index Register Pointer (IRP), a 3-bit register, controlled the storing and 
loading of the B register to and from the IRs. When an IR was specified to 
modify an address, it was applied after any SR or OAR modifications to 
the address in the instruction. The IRP was set by the Load Index Register 
Pointer instruction as follows: 
1.  C(IRP) specified an address to store the contents of the B register 
2.  The IRP is loaded from the value in the instruction 
3.  The B register is automatically loaded to the specified IR. 
 
8.6.2.4 Real Time Clock and Time-of-Day Clock 
 
The Real Time Clock (RTC) was located in IOM 0. Every 200 
microseconds it updated location 0000268 by decrementing it by one. 
When the value of location 0000268 reached 0, a CAU interrupt was 

UNIVAC 418 
 
169 
generated which caused control to be transferred to location 0000258. 
Real-time control was effected by specifying a time to elapse as the value 
of 0000268 before the interrupt was generated. The elapsed time value was 
set by the Executive under program control. 
The Time-of-Day Clock (TDC) was an optional feature that kept time 
in hours, minutes, and seconds for a 24-hour period. Every six seconds it 
updated location 0000248 in main memory. Every minute a CAU interrupt 
was generated to location 0000238 with the current time of day. Programs 
could request the time of day through an Executive request. 
 
8.6.2.5 Accumulators 
 
The CAU provided two 18-bit accumulators that were used for most 
instruction execution. For certain instructions, these accumulators were 
treated as a single 36-bit register. Fixed point arithmetic could be 
performed on an 18-bit or 36-bit basis. Multiplication of two 18-bit 
quantities yielded a 36-bit result. Division was performed on a 36-bit 
dividend which yielded an 18-bit quotient and remainder, respectively. 
 
8.6.2.5 Floating Point Option 
 
An optional floating point arithmetic feature provided high-speed 
floating point operations for scientific and engineering calculations. A 
floating point number consisted of an 8-bit exponent and 27-bit mantissa. 
All floating point operations were performed on normalized operands and 
produced normalized results. 
 
8.6.2.6 Binary-Decimal Conversion 
 
An optional set of instructions performed binary-to-decimal (and vice 
versa) conversion. This feature enhanced the UNIVAC 418-III use in 
commercial data processing operations. Binary-coded decimal (BCD) 
numbers in 6-bit format were converted to and from binary format. 
8.6.3 Main Storage 
Main storage consisted of magnetic cores with a capacity of 32K to 
128K words, configured as one to four 32K-word banks. It had a 750 
nanosecond cycle time that yielded up to 2.66 million word per second I/O 
transfer rate. Main storage had three ports which allowed two IOMs and 
the CAU to simultaneously access non-interfering locations within the 

Chapter Eight 
 
170
memory banks. Paths to the storage module were serviced in priority 
order, based on the order in which requests were received. If a higher 
priority request occurred before the lowest priority was serviced, the 
higher priority request waited until completion, then serviced the lower 
priority request. This prevented any of the units accessing the memory 
bank from monopolizing its services. 
Parity checking was performed on all storage accesses. Each word 
contained two parity bits – one bit for each halfword. If a parity error was 
detected, the memory bank issued a parity error interrupt signal to the 
CAU. 
A Guard Limits Register (GLR), which contained upper and lower 
boundary limits for a program during execution, provided storage 
protection. The GLR was loaded by the Executive prior to transferring 
control to a program. Storage protection was assigned in chunks of 256 
words. Storage protection prevented one program from modifying another 
program in a multiprogramming environment. 
Before each access to storage by the CAU, the GLR was checked to 
see if the current address was within the bounds determined by the GLR’s 
upper and lower limits. If Guard Mode was set, a Guard Mode Interrupt 
was initiated which terminated the storage access request and transferred 
control to the Executive. In a multiprogramming environment, this 
prevented unintentional alteration of one program’s memory allocation by 
another program. 
The Executive normally operated in open mode, e.g., there was no 
checking of storage access requests. When the Guard Mode was 
deactivated, the Executive could access all of storage. 
Each bank had maintenance switches which allowed it to be removed 
logically from the system configuration to facilitate servicing and testing. 
8.6.4 I/O Modules (IOMs) 
The IOMs operated independently of the CAU. They controlled 
input/output operations and data transfers. Up to two IOMs could be 
configured in a UNIVAC 418-III system. Each IOM contained from eight 
to sixteen 18-bit I/O channels – eight were standard, and eight were an 
optional extension. Each IOM operated independently of the other, thus 
yielding up to 1.33 million words of data transfer per second per module. 
Each IOM had a separate data path to main storage. Data transfers on a 
channel were bi-directional, but only one channel per IOM was active at 
any time. 

UNIVAC 418 
 
171 
Each channel operated in one of three modes: input, output or function. 
The operated in either input or output state during data transfer and could 
switch between states. The function state was used by the CAU to 
communicate with the peripheral subsystem to transfer function words, 
including parameters, to the subsystem. Function words directed the 
peripheral subsystem to perform the desired operations. 
 
8.6.4.1 Role of the SAR 
 
Each IOM had a Storage Address Register (SAR). When a storage 
access request was granted by the memory bank, the low order 15 bits held 
the specific storage location requested. This allowed three simultaneous 
storage accesses to occur if they were to different memory banks. In a 
multiprogramming environment, this allowed one program’s execution 
and the I/O operations of other programs to occur simultaneously. 
 
8.6.4.2 Integrated General Registers 
 
Each IOM was a small processor with its own memory. Each IOM 
contained a set of high speed buffers and two Integrated General Registers 
(IGR), which controlled I/O. One of the IGRs was designated to hold the 
Interrupt Table Pointer (ITP) for the communications channels attached to 
the IOM. The Interrupt Table Pointer Word (ITPW) specified the blocks 
table size of 64 words up to a maximum of 512 words. Figure 8-4 depicts 
the format of the ITPW. 
 
 
 
Figure 8-4. UNIVAC 418 Interrupt Table Pointer Word Format 
Source: Adapted from Remington Rand 1969c 
 
The ITPW specified a table address where the next interrupt status 
word would be stored. This word was incremented each time an interrupt 
status was stored. When it reached the end of the table, it wrapped around 
to the beginning. TS specified the Table Size; B specified the address of 
the interrupt table; and TP specified an address within the table where the 
interrupt status would be stored. 
 

Chapter Eight 
 
172
8.6.4.3 Buffer Control Words 
 
The CAU loaded index values into Buffer Control Words (BCW), 
selected a specific peripheral, then provided peripherals commands and 
parameters. This was referred to as Internally Specified Indexing (ISI) 
because the data request caused the UNIVAC 418 to internally generate 
the address reference to the specific BCWs based on the channel identifier. 
Thereafter, the IOM scanned the I/O channels automatically, transferring 
data to or from the subsystem. For a data transfer, the channel’s BCW 
contained the main storage address. As each word was transferred, the 
IOM updated the BCW and tested for a completion of the data transfer or 
an error. 
 
8.6.4.4 ESI Mode 
 
Alternatively, Externally Specified Indexing (ESI) mode was used with 
UNIVAC data communications systems. ESI mode allowed multiple 
communication lines to automatically transfer data to and from main 
memory through a pair of IOM channels. In ESI mode, each channel had 
its data flow controlled by a unique BCW pair. In this case, the ESI BCWs 
were located in main memory rather than in the IOM in order to 
accommodate many multiplexed communication lines. As each line 
presented a character, the NCW address was concurrently presented to the 
channel. As a result, each communication line had a unique buffer area in 
main memory to receive or transmit characters. Data communications was 
thus controlled by the IOM without intervention by the CAU. 
The UNIVAC 418-III hardware supported ESI buffer chaining. Its 
purpose was to eliminate intervention by programs running on the CAU to 
provide additional buffer areas for lengthy messages. A bit in the ESI 
BCW controlled buffer chaining. When the bit was set, the hardware 
caused the two words following the current address in the Initial Address 
BCW and the terminal Address to become the new values of these two 
addresses at the end of a data transfer. Data transfer then continued with 
the new addresses. When the chaining control bit was 0, the data transfer 
ceased. 
 
8.6.4.5 Automatic Tabling of ESI Interrupts 
 
When lengthy messages or many short messages occurred rapidly, the 
time to process an interrupt for each one detracted from other 
computations. In the UNIVAC 418-III, a separate area in memory was 

UNIVAC 418 
 
173 
assigned as a table to hold ESI interrupts. As an interrupt occurred at the 
end of a data transfer and chaining control was enabled, the interrupt was 
entered into the table by the IOM and the CAU was not interrupted. When 
the Executive completed a task, it examined the table which was specified 
by the Interrupt Table Pointer (ITR) located in one of the IGRs. The ITR 
was treated as a circular buffer. Automatic tabling coupled with buffer 
chaining provided the real-time programmer with much flexibility in 
designing and implementing communications routines. 
8.6.5 Magnetic Drums 
The UNIVAC 418 used FH-432/1782 flying head magnetic drums 
with a transfer rate of 1.44 million characters per second and an average 
access rates of 4.25 and 17 milliseconds, respectively. Up to eight FH-432, 
FH-880 or FH-1782 drums could be attached to a UNIVAC 418-III. 
Tables 8-3 describe the features of these drum systems. 
The FH-880 magnetic drum had 880 tracks of which 768 were used for 
data storage, 32 for parity, and the remaining tracks for spares and timing 
operations. The 768 tracks were organized into 128 bands of six tracks 
each band having a capacity of 6,144 words. Reading and writing were 
performed on all six tracks simultaneously at a rate 60,000 words per 
second. Odd parity checking was used to validate the data stored on the 
drum. When data was written to the drum, a parity bit was generated for 
each word written and stored in a predetermined location on one of the 
parity tracks. When data is read from the drum, the parity bit is also read 
and checked automatically. If a parity error occurred, magnetic drum 
control unit generated an external interrupt to the processor. 
 
Table 8-3. Magnetic Drum Systems 
Characteristics 
FH-432* 
FH-880 
FH-1782 
Capacity (Words) 
512K 
1.5M 
4.2M 
# Units per I/O channel 
3 
8 
16 
Avg. Access Time 
(milliseconds) 
4.25 
17 
67.5 
Transfer Rate (chars/s) 
1.44M 
360K 
1.44M 
* Each FH432 contained three drums; a maximum of 3 FH432s per Drum Control 
Unit on an I/O Channel 
 
The 418 could also attach either a FASTRAND II mass storage system 
with a capacity of over 1 billion characters or a FASTRAND III mass 

Chapter Eight 
 
174
storage system with a capacity of 1.6 billion characters. Table 8-4 presents 
the characteristics of the FASTRAND mass storage systems. 
 
Table 8-4. Mass Storage Systems 
Characteristics 
FASTRAND II 
FASTRAND III 
Capacity (characters) 
1.0 billion 
1.6 billion 
# Units per I/O channel 
8 
8 
Avg. Access Time 
(milliseconds) 
92 
92 
Transfer Rate (chars/s) 
Unk 
Unk 
8.6.6 Attached Processors 
The UNIVAC 418 could attach a UNIVAC 9200/9300 series computer 
system to handle unit record peripherals, communications, and remote job 
entry (RJE) operations. The UNIVAC 9200/9300 series machines were 
connected to the UNIVAC 418-III through an Inter-Computer Control 
Unit (ICCU), which provided for interrupt transmission in both directions 
and a buffer for data transfer. The ICCU connected to the UNIVAC 418-
III through a channel on the IOM and through a subchannel on the 
Multiplex Channel. 
The UNIVAC 9000 series acted as a card reader/line printer for the 
UNIVAC 418-III. Basically, cards were read on the 9xxx, buffered in 
memory or on disk, then transferred electronically to the 418-III upon 
request from the latter. When data was to be printed, the 418-III sent a 
command and data to the 9000, which buffered it, then printed it. 
8.6.7 Communications Systems 
UNIVAC 
data 
communications 
systems 
allowed 
multiple 
communications lines to transfer characters automatically to and from 
main storage through a pair of IOM channels. Each communication line 
had a unique pair of BCWs that controlled the data flow. Externally 
Specified Index (ESI) BCWs were contained in main storage. As a 
communication channel presented a character for transfer to main storage, 
its BCW pair was presented to the channel. Thus, the BCWs were 
externally specified. Any adjacent even/odd pair of IOM channels, except 
0/1, could be used for data communications. Additionally, the paired 
channels had to designate whether they operated in full word or half word 
storage mode. Half word mode allowed two characters to be stored in each 
18-bit word. 

UNIVAC 418 
 
175 
ESI buffers could be chained to provide additional areas for 
communication messages thus, eliminating program intervention. 
Hardware buffer chaining provided some savings in memory because it 
automatically traversed the buffer chain during communications 
operations. Thus, the CAU could execute a program faster as it did not to 
continually check the communications status and specify another set of 
BCWs. 
The UNIVAC Data Communications Terminal (DCT) 2000 was a 
special-purpose computer system that served as a data communications 
handler for the UNIVAC 41 and later systems. It consisted of a control 
unit bar printer, card reader/punch data transmission device, and a 
communication interface attached to a switched telephone network. The 
control unit contained the control logic and the buffer storage for 
messages. A Data Line Terminal (DLT) handled communications between 
the DCT 2000 and a UNIVAC 1004 or 1050. Data transmission across 
telephone lines used ASASCII code and 8-bit transmission code consisting 
of seven bits of data and the 8th bit for parity. Communications with the 
UNIVAC 1004 or 1050 used a 6 bit XS-3 code for data communications. 
8.6.8 Unit Record Peripherals 
The primary unit record peripherals were a card reader/punch and a 
high-speed line printer. The high speed card reader read 90-columns cards 
on the SS90 and 80-column cards on the SS80. It consisted of an input 
station, two card read stations, three output stations. The input station 
could up to 1000 cards, while the output stations could each hold up to 
1200 cards. An input card was fetched from the input station, read at read 
station 1 and transported to read station 2. It was read again at read station 
2. If the data read at both stations was the same, the card was directed to 
an output station and the data transferred to the magnetic drum’s main 
storage area for further processing. Output station selection was 
determined by the programmer through the use of the 47 instruction. 
The high speed printer could print at 1200 or 1600 lines per minute 
with a font of 26 alphabetic, 10 numeric, and 27 special characters on wide 
paper with up to 132 characters per line at 10 characters per inch. The 
printer could handle any type of sprocket-feed paper, including card stock. 
8.7 UNIVAC 418 System Software 
The UNIVAC 418-III could handle batch, timesharing, and real-time 
processing tasks with dynamic resource allocation to each of these three 

Chapter Eight 
 
176
operating modes. The UNIVAC 418-III Real Time Operating System 
(RTOS) controlled the computer system in each of the three modes. RTOS 
was divided into three sections: Executive, Language Processors, and 
Services and Library. 
8.7.1 RTOS Executive 
The RTOS Executive controlled all operations within the UNIVAC 
418-III. RTOS was divided into four modules: Executive Control, I/O 
Control, Job Control, and Real Time Communications control. Its task was 
to make it easier for users to perform their tasks efficiently by providing 
common services rather than requiring each program to provide its own 
services. 
 
8.7.1.1 Executive Control 
 
The Executive was implemented as a series of interlinked routines that 
controlled program execution flow. It provided a multiprogramming 
capability through scheduling work according to a priority scheme. An 
internal real-time clock provided interrupts that allowed interval 
scheduling.  
It made efficient use of the hardware by overlapping the execution of 
instructions and I/O channel operations. To accommodate slow peripherals 
and make efficient IOMs use, data transfers to and from peripherals were 
also overlapped. Because the CAU and the IOM(s) were independent 
processors, they operated simultaneously in handling instruction execution 
and data transfers. This simultaneity supported the multiprogramming 
operation provided by the Executive. 
Entry to the Executive was accomplished through execution of the 
Supervisor Call Interrupt, a special function code that caused a software 
interrupt and allowed the Executive to receive control of the CAU. When a 
software interrupt occurred, the Supervisor call control section checked the 
function and its parameters and then passed control to the appropriate 
processing elements.  
When certain hardware instructions, such as floating point instructions 
or binary/decimal instructions were incorporated into a configuration, 
attempts to execute these instructions also triggered interrupts which led to 
Executive intervention. The Executive passed control to a library function 
which performed an equivalent function. 
Some elements of the Executive were not permanently resident, but 
loaded as needed from overlays. A portion of Executive memory was 

UNIVAC 418 
 
177 
allocated as overlay areas where these elements could be dynamically 
loaded and executed. Overlays contained Executive routines that were not 
expected to be called frequently. They were not time critical in their 
execution and could be interrupted to handle I/O operations. Overlays 
were memoryless and, thus, could be reused without reloading. Overlays 
were stored on a magnetic drum and accessed through an index in the 
Executive which specified the overlay’s address without resorting to file 
system operations. 
The Executive also maintained a list of variable length buffers which 
could be allocated to various system functions and then released when no 
longer needed. Queue control maintained these buffers in blocks of 512 
words. Special Executive functions allocated and released buffers as 
needed. This dynamic storage allocation approach meant that main storage 
did not need to be reserved for functions that were invoked at various 
times. 
 
8.7.1.2 I/O Control 
 
The I/O Control subsystem provided the user program with routines for 
reading and writing data records to different I/O devices. It provided the 
user with two levels of interface: the device handler level and the file 
control level. 
Symbionts (device handlers) were designed for each device type and 
handled the task of transferring data to and from that device, checking its 
status, and checking for errors. Each symbiont could initiate an input to 
output operation at the request of a program that was executing and 
monitor its operation until its completion was indicated by an interrupt. 
Symbionts also interpreted error conditions and attempted recovery when 
possible. 
The symbiont provided one routine that could be used by all programs 
that needed to use a particular device. Across all symbionts a standard 
interface was defined that allowed programs to switch among different 
devices without having to have special routines for each device. Within the 
418-III Executive, symbionts were provided for the operator’s console, 
magnetic tape subsystems, magnetic drum subsystems, paper tape 
reader/puncher, and the intercomputer coupler. Symbionts were managed 
by a module called Symbiont Control. It provided an interface between the 
symbionts and the rest of the Executive. 
The File Control subsystem was a set of routines which provided 
centralized control over files stored on drums, disks, and magnetic tapes. It 
provided an interface to the rest of the Executive and to user programs for 

Chapter Eight 
 
178
creating, managing, storing, and deleting files. A file control module 
provided a set of commands for interfacing between user programs and the 
file access module. File control required a file specification which 
described the file(s) to be processed and the operations to be performed on 
them. File specifications were passed to the file access module which 
handled the scheduling and controlled the transfer of data between main 
storage, mass storage and magnetic tapes. The file access modules 
interfaced with the symbionts. Some of the functions performed by these 
modules included: 
x Randomly seeking records in a file 
x Performing file maintenance in an indexed sequential access 
method 
x Reading and/or writing data 
x Blocking and unblocking records 
x Creating, expanding, and deleting files 
x Handling files and file labels on magnetic tapes 
x Detecting error conditions and correcting them when possible 
 
8.7.1.3 Job Control 
 
Job control managed user programs – scheduling them, providing 
support for allocation of hardware facilities, and error handling support. A 
job was comprised of individual steps – indicated by control statements – 
which could invoke programs or utility routines, set parameters, and 
provide specifications for files and devices to be used during program 
execution. 
A job stream was a sequence of user and system programs, often called 
a run. The job stream consisted of control information specifying 
operations to be performed, limited data, source code for the language 
processors, program parameters, and other information pertinent to the 
run. A job stream could be submitted via a deck of cards or card images 
from a files or magnetic tape or on a magnetic drum or disk. When remote 
operations were enabled via telecommunications, a job stream consisted of 
a sequence of commands entered interactively at a remote site and sent to 
the system one-at-a-time. 
Job control assigned all the hardware facilities under control of the 
Executive. It analyzed requests for peripherals, main storage, and mass 
storage. Based on availability, it scheduled jobs while attempting to 
efficiently utilize the equipment across active runs in the system. It 
invoked the file control system to create and catalogue files and make files 

UNIVAC 418 
 
179 
available to programs. When a program completed, its assigned resources 
were released for re-assignment. 
The smallest logical unit of information in RTOS, which was 
controlled by the system, was the element. Each run had its own run 
library which was an accumulation of elements. Elements were entered 
into the run library as specified in the job stream. For example, a compiler 
would compile source files, create relocatable object modules, bind (map) 
them with language library modules, and create an executable file. This 
executable file would be entered into the run library to be called upon 
downstream in the run. A run library could be pre-existing or created 
dynamically for the duration of a run.  
Certain control statements invoked an executable element from the run 
library to be executed. Job control provided for loading the element into 
main storage after the specified environment was established by job 
control, such as allocation of storage and hardware devices. A job was not 
loaded into main storage until all resources were available. Thus, the 
absence of a require magnetic tape drive would cause the loading and 
execution of the job to be deferred until one became available. 
When program execution began, it usually ran to completion via its 
normal termination criteria. When the program completed, its resources 
were re-assigned, including removing the program code from main 
storage. Sometimes, programs encountered errors which forced the system 
to abort them with error conditions. When this event occurred, the main 
storage could be dumped to a file or a printer for later inspection to 
diagnose the error.  
Many of the operations that could be specified in the job stream control 
statements could also be executed from within the user or system program 
via executive requests. Job control serviced these requests just as if they 
had been submitted within the job stream from a control statement. In 
addition, the program could request segment loads and overlays as 
established within the program map. And, it could request that another job 
be loaded and executed either concurrently or as a successor when the 
current job was completed. Finally, it could request that another job stream 
be initiated which would be executed concurrently as an independent run. 
 
8.7.1.4 Real Time Communications Control 
 
The Real Time Communications Control (RTCC) subsystem provided 
users with a flexible system for communicating with remote 
communication facilities. The interface consisted of the Communications 

Chapter Eight 
 
180
Terminal Modular Controller (CTMC) and the Word Terminal 
Synchronous (WTS) controller. 
The CTMC provided the interface by which user programs could 
communicate with a remote device. The user program issued an executive 
request with a line control table (LCT). The CTMC handled all ESI 
interrupts. When it received an interrupt, it analyzed it and then initiated or 
terminated the transfer of data based on parameters contained within the 
LCT. It supported auto-dial and auto-release functions which allowed a 
real-time user program to access a remote device on a timed basis without 
user intervention as, for example, to collect data from the device. 
The WTS controller operated in IS mode. It interfaced with a single or 
pair of hardware I/O channels. This allowed the 418-III to simulate an 
online device at a remote location. 
The transaction routing routine handled the assignment of all 
communication facilities. Upon opening a communication line, this routine 
identified and loaded the remote device handler from the system library. It 
set up queue processing when the first data queue was opened. Subsequent 
calls were passed directly to the queue processor. 
The queue processor provided independent message buffering between 
the user program and the remote device. This facility could also be used to 
allow independent programs to communicate as if each program believed 
the other to be a remote device. Messages were queued according to their 
priority level. Multiple destinations could be designated for a message 
giving a limited broadcast capability. 
Remote device handlers provided with RTOS were designed to be re-
entrant and to operate with multiple communications lines. This 
minimized the storage footprint when a system was configured for tens or 
hundreds of communication lines. A packed buffer was sent to the device 
handler by executive request. There it was unpacked, translated to the 
device code as necessary, and formatted into a line buffer. For incoming 
messages, each character was translated and inserted a pack buffer. When 
a buffer was filled, the transaction routing routine was notified to transfer 
the buffer to the user program. A buffer might not contain a complete 
message. The user program determined the protocol. 
Standard device handlers were provided for the DCT 2000 Data 
Communications Terminal, the UNISCOPE 100 and UNISCOPE 300 
terminals, the Teletype ASR/KSR series, and the UNIVAC 1004 and 
UNIVAC 9200/9300 computer systems. These latter systems, serving as 
unit record peripheral stations, communicated with the 418-III as remote 
devices.  

UNIVAC 418 
 
181 
8.7.2 Programming Languages 
RTOS supported three programming languages: a sophisticated 
assembly language, COBOL, and FORTRAN. FORTRAN and COBOL 
compilers translated source code into relocatable object modules which 
were then bound (mapped) together to form an executable module, 
possibly including a segment or overlay library. The Assembler translated 
a symbolic representation of the 418-III instructions to machine code. It 
provided a number of directives that gave the programmer flexibility in 
laying out his program and data structures. 
The FORTRAN compiler did not support complex data types and 
certain ANSI size specifications for the basic data type. It provided several 
extensions to the FORTRAN language, including a return K statement, an 
implied DO loop in a DATA statement, and mixed type arithmetic. The 
compiler was a one-pass compiler from source code input from cards or 
files to relocatable object code stored on the drum. 
The COBOL compiler complied with the specifications of USA 
COBOL standard X3.23-1968 at levels 1 and 2. The COBOL compiler 
was a five-phase compiler that translated source code supplied by cards or 
files to relocatable object code stored on the magnetic drum. The five 
phases were: 
x Phase 1 accomplishes the initial scanning, syntax checking and 
encoding of the source program. 
x Phase 2 builds a dictionary (symbol table) of all source program 
definitions. 
x Phase 3 passes the encoded Procedure Division against the 
dictionary so that each reference is augmented by the definition 
information. 
x Phase 4 is the code generation phase wherein the compiler selects 
the appropriate sequences of machine instructions to perform the 
actions specified by the Procedure Division. 
x Phase 5 comprises several optional overlays which accomplish the 
following: 
(a) Produces the procedure portion of the object program. 
(b) Prepares the source program and diagnostic listing of the 
compilation. 
(c) Prepares the data and/or procedure map of the object program. 
(d) Prepares the object program listing. 
(e) Produces a cross-reference listing of the source program. 
 

Chapter Eight 
 
182
A Phase 0 remained resident in memory to provide input-output system 
for the manipulation of its work-files, interphase communication storage 
and the mechanism for loading the individual overlays. The complexity of 
the COBOL language and the memory limitations required the compiler to 
be divided into multiple phases with intermediate products stored on 
magnetic drum.  
RTOS provided services and library elements which handled different 
tasks associated with program preparation and provided functionality at 
run-time. Among these were Sort and Merge programs, program 
maintenance utilities, program debugging aids, and routines for moving 
data between memory, magnetic tape, and mass storage. 
8.7.3 System Applications 
RTOS provided a number of system programs such as Sort/Merge, 
Program Utility Routine (PUR) and the Element Processor (ELT). The 
Sort program sorted a file of randomly organized records into a sequence 
defined by a key. Different types of sorts were selected through input 
parameters. Sorting could be performed using either UNISERVO 
magnetic tape drives or FASTRAND mass storage. The Merge program 
was a generalized merge over up to eight files of arbitrary length with 
either fixed-length or variable-length records. Input parameters controlled 
different aspects of the merge with respect to checking, key description, 
and data description. 
The Program Utility Routine (PUR) and the Element Processor (ELT) 
enabled the user to manipulate and update programs, program elements, 
and program libraries. Elements could be added from a magnetic tape or 
mass storage file into a run library, extracted from a run library, or their 
contents punched to cards or printed. Elements could be updated through 
control cards followed by data cards containing the updates during any of 
the above operations. 
Utility programs included the ability to dump main storage or mass 
storage to files or print their contents. Several programs assisted the 
operator in managing and operating the UNIVAC 418-III system and to 
check its status, loading, and operating parameters. 
System libraries provided programmers with a set of commonly used 
procedures (PROCs) and subroutines which could be linked into their 
programs during mapping. These included file control calls, interfaces to 
executive requests, intrinsic and mathematical routines, code conversion, 
and many others. The system libraries were open-ended in the sense that 
installations could add their own local procedures and subroutines to them. 

UNIVAC 418 
 
183 
8.8 UNIVAC 418-III Application 
The Metropolitan Toronto Traffic Control System used the UNIVAC 
418-III as a control computer system component beginning in the early 
1960s. Every intersection had sensors reporting to the central computer 
system. By 1969, approximately 600 traffic signals were controlled by the 
central computer. The UNIVAC 418-III acted as a communication and 
message switching device as a front-end to a UNIVAC 1107 mainframe. It 
received data from the individual intersections, forwarded them to the 
UNIVAC 1107 after some data reduction, received control data in return, 
then transmitted this data to the traffic signals. The UNIVAC 418-III had 
16K Words of memory, which could be accessed directly from the 
UNIVAC 1107 by a channel interface. Typically, the UNIVAC 1107 
fetched two 418 words as one 36-bit word. (Hodges and Whitehead 1969) 
8.8 UNIVAC 418 Assessment 
The UNIVAC 418 developed some of the basic concepts for real-time 
computing which contributed greatly to the success of the follow-on 1100 
series machines. As Gray 2000 notes, six UNIVAC 418-I systems were 
produced with the first being delivered in 1963. Its operating system was 
called EXEC(-I). However, Sperry Rand Univac quickly realized its small 
memory limitations and developed the UNIVAC 418-II with a larger 
memory. A military version, called the UNIVAC 1218, was developed for 
the U.S. Navy for its shipboard Talos missile system, and was also 
adopted by the U.S. Army. It was also adopted by the Federal Aviation 
Administration for its Automated Radar Tracking System (ARTS-I), 
which was deployed at the Atlanta, Georgia airport in 1966. 
The UNIVAC 418-II was delivered in late 1964. Approximately 250 of 
these 
machines 
were 
produced 
that 
were 
primarily 
used 
in 
telecommunications, real-time and interactive systems by, among others, 
NASA, the Federal Telecommunications System, and the Dept. of 
Defense’s AUTODIN Communications System. The military version as 
designated the UNIVAC 1219. Two of these were used to control an 
ARTS-like radar system for the New York City Airports. 
According to Gray (2007), the UNIVAC 418-III was a greatly 
improved version of the 418-II, but it was also very costly. Eventually, 
about 150 of these machines were delivered to customers. After the 
UNIVAC 418-III, however, Sperry Rand Univac stopped making any 
further enhancements to this architecture in favor of developing the 
490/494 and the 1100 series machines.  

Chapter Eight 
 
184
Robert Brand, who worked for Australia’s Overseas Telecommunication 
Commission (OTC) in Paddington posted some reminisces about the 
UNIVAC 418 which was used for OTC’s automatic message relay system. 
You can read his story at https://zerogees.wordpress.com/2015/12/06/ 
univac-418-paddington/. 

CHAPTER NINE 
UNIVAC 490/494 
 
 
 
The UNIVAC 490 and its successor, the UNIVAC 494, were the first 
computing machines developed to support real-time processing. The 
underlying concept to real-time processing was to “… accept transaction 
data with speed and reliability while the output units display results with 
accuracy and clarity” (Remington Rand 1961h). Transactions initiated 
from remote points were conveyed along common carrier lines to the 
computer. They were processed and evaluated, and a result determined and 
returned along the same path. 
This computing machine could be connected to any telephone or telegraph 
system in the continental US. An improved UNISET – a terminal for airline 
reservation agents – was developed for this machine. It included a keyboard 
allowing the ticket agent to enter the passenger's name and telephone number. 
Printouts initiated by the computer could be produced for reconfirmation or 
cancellation. The UNISET was equally adaptable for inventory control. A 
variant, the UNISAVER, was developed for use in Savings Banks. The 
customer’s savings account book could be slipped into the machine which 
printed updated information when a deposit or withdrawal was made. Figure 
9-1 depicts a UNIVAC 490 system. (Remington Rand 1961h). Another view 
is depicted in Figure 9-2. The Computer Museum has a nice image of a 
UNIVAC 490 at https://museum.syssrc.com/artifact/minicomputers/300/. 
Phillippe Nieuwbourg posted a nice image of a UNIVAC 490 to flickr at 
https://www.flickr.com/photos/museeinformatique/3784346103/in/photostrea
m/. 
 
 

Chapter Nine 
 
186
 
 
Figure 9-1. UNIVAC 490 Real Time System 
Source: Weik 1961 
 
 
 
Figure 9-2. UNIVAC 490 System 
Source: Snyder 1964 (DOD) 
 

UNIVAC 490/494 
 
187 
The UNIVAC 490 was a 30 bit per word machine with a core memory 
of 16K – 131K words and a 4.8 millisecond cycle time. The system could 
accommodate up to 24 I/O channels. It was usually shipped with a 
UNIVAC FH880 or UNIVAC FH432 or FH1782 magnetic drum storage. 
Table 9-1 presents the basic characteristics of the UNIVAC 490/494 
series. 
 
Table 9-1. UNIVAC 490/494 – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal Representation 
Fixed Point Binary 
# Bits/Word 
30 
# Instructions/Word 
1 
# Instructions 
62 (490); 99 (494) 
# Bits/Instruction 
30 
Instruction Type 
One Address 
CPU Technology 
Transistors/Diodes; Cycle Time:  
CPU Registers 
Accumulator: 30 bits; Q register: 30 bits; 7 B 
registers: 15 bits (later increased to 14) 
Main Memory 
Magnetic Core: 16K – 128K words; Cycle Time: 
4.8 milliseconds (490), 750 nanoseconds (494) 
Add Time 
Fixed Point: 7/2 – 12 microseconds 
Multiply Time 
Fixed Point: 19.2 – 8+ microseconds 
Divide Time 
Fixed Point: 84 microseconds 
 
Because the UNIVAC 494 was an enhanced version of the UNIVAC 
490, we’ll describe the UNIVAC 494 in more detail. 
9.1 UNIVAC 494 
Source: UNIVAC UNK. Sperry Rand 1966d, Weik 1961 
 
The UNIVAC 494 was the successor to the UNIVAC 490. It was 
designed to support both real-time programs and multiple batch 
applications. The UNIVAC 494 depicted in Figure 9-3 was used by 
Traveler’s Insurance Company in the mid-1960s to support transaction 
processing. 
  

Chapter Nine 
 
188
 
 
Figure 9-3. UNIVAC 494 System 
Source: Sperry Rand UNK 
Photo reproduced courtesy of Unisys Corporation 
9.1 System Architecture 
Source: Sperry Rand 1969a 
 
The system architecture of the UNIVAC 494 is depicted in Figure 9-4. 
 
 

UNIVAC 490/494 
 
189 
 
 
Figure 9-4. UNIVAC 494 System Architecture 
Source: Adapted from Sperry Rand 1969a 
9.1.1 Central Processor 
The 494 CPU, an enhanced version of the 490 CPU, executed all of the 
instructions and controlled the subsystems. Table 9-2 presents the registers 
provided by the UNIVAC 490/494 (Sperry Rand 1969a). 
 
Table 9-2. UNIVAC 490/494 Registers 
Register 
Bits 
Description 
B 
15 
Seven (490)/Fourteen (494) index registers 
used for address modification. 
A 
30 
Accumulator used for arithmetic, logical, etc. 
operations. 
Q 
30 
Auxiliary arithmetic register used for 
multiply/divide and double word operations. 
PC 
15, 17 (494) 
Program Counter for program control. 
 
 

Chapter Nine 
 
190
RIR 
15, 17 (494) 
Relative Index Register providing base 
addressing. 
OAR 
15 
Operand Address Register 
PAR 
15 
Program Address Register 
MSR 
15 
Memory Select Register for selecting memory 
addressing mode. 
IFR 
30 
Internal Function Register used to facilitate 
execution of Executive routines, 
PLR 
30 
Program Lock-in Register for establishing 
upper and lower address bounds for a program 
residing in memory. 
X, R 
30 
Registers used for communicating with other 
registers: X (arithmetic), R (index). 
 
The UNIVAC 494 provided a Day Clock using a 24-hour range to 
records the time of day in hours, minutes and hundredths of minutes. The 
updated value was stored in a fixed memory address every 600 
milliseconds. Approximately every six seconds, a Day Clock interrupt was 
generated to allow the operating system to receive control for various 
operations. 
The UNIVAC 494 also provided a Real-Time Clock (RTC) which 
acted as an 18-bit counter. It was incremented every 200 microseconds. 
When the counter overflowed, an interrupt was generated. The maximum 
count was approximately 52 seconds, whence the counter was reset to 
zero. 
The CPU responded to both unconditional and conditional interrupts 
which transferred control to predefined locations in memory which 
contained the address of an interrupt handler. An unconditional interrupt 
was one which could not be locked out, e.g., could not be inhibited from 
occurring. These interrupts included memory parity errors, memory 
protection violations, floating point overflow, and illegal instructions, 
among others. 
Conditional interrupts might not require immediate intervention and 
could be inhibited if higher priority tasks need to be performed. These 
interrupts included I/O parity errors, power loss interrupts, external 
interrupts from peripherals, and clock interrupts. 
The UNIVAC 494 also had a maintenance subsystem which allowed 
field engineers to diagnose problems with the system. Readers may view 
the maintenance panel at http://www.computerhistory.org/collections/ 
catalog/X343.84A. 

UNIVAC 490/494 
 
191 
9.1.2 Memory 
The UNIVAC 494 supported a ferrite core memory of 16K words to 
128K words with a cycle time of 750 nanoseconds. Memory was 
organized in banks of 32K words composed of 34-plane, coincident 
current, ferrite core arrays. The UNIVAC 494’s magnetic core memory 
featuring parity and single error correction capability. Memory transfers 
occurred as 60-bit double precision words, 30-bit whole words, 15-bit 
half-words, or program selected bits from a single word. To reduce 
processing time, memory banks were organized as odd-even addresses so 
that two access could occur concurrently if they were addressed to 
different banks. A maximum of two memory banks each consisting of 64K 
words comprised of two 32K word modules could be configured in a 
system. 
Each storage module contained: 
x a 15-bit address register 
x a 30-bit read/write register 
x parity checking/generating logic 
x request/acknowledge circuitry 
x several maintenance switches allowing the module to be 
dynamically removed from the configuration for servicing. 
 
The CPU generated a 17-bit address consisting of two bits from the 
MSR designating the bank and a 15-bit address from the program. Bit 20 
selected the bank, while bit 216 specified the odd or even module. Parity 
was checked during reading or calculated during writing on each 15-bit or 
30-bit storage access. If a parity error occurred, a parity error was 
generated by the module.  
A set of preassigned memory addresses was reserved for system usage 
such as interrupt handler addresses, ISI buffer control registers, and day 
clock data. 
Memory could be protected from writing in 64-word segments that 
were primarily used for debugging.  
9.1.3 I/O System 
The UNIVAC 494 I/O system consisted of 12 full-word I/O channels. 
An additional 12 channels could be added as an option. I/O was buffered 
providing a capability for concurrent data transfer and program execution. 
The I/O channels could attach high-speed peripherals and satellite 
computer systems – the UNIVAC 1004 computer system or UNIVAC 

Chapter Nine 
 
192
9200/9300 computer system. These systems could be attached to the 494 
to provided integrated unit record peripheral controls for remote job entry. 
A Transfer Switch could connect peripherals and satellite computer 
systems to two UNIVAC 494s, but only one at a time. Table 9-3 presents 
the I/O registers (Sperry Rand 1969a). 
 
Table 9-3. UNIVAC 494 I/O Registers 
Register 
Description 
Buffer Control 
Register (BCR) 
Each BCR contained a Buffer Control Word which 
acted as an index transfer of data from a buffer area 
in core storage and a peripheral device. 
Output Data 
Register (ODR) 
Each ODR held data that was sent on the output 
data lines long enough to satisfy the timing 
requirements of slow speed peripheral devices.  
Channel Select 
Register (CSR) 
Specified the channel to activate, deactivate, or test 
during normal I/O operations. 
Interrupt Address 
Storage Register 
(IASR) 
Contained the number of a channel receiving an 
external interrupt or a monitor interrupt signal. 
Within the interrupt subroutine, it was used to select 
the channel to handle. 
Parity Error 
Channel Storage 
Register (PECSR) 
Contained a channel number when a BCR parity 
error or I/O data parity error occurred. It was used 
by the interrupt subroutine during interrupt handling. 
 
9.1.3.1 Index Modes 
 
The Buffer Control Word (BCW) specified the index for accessing the 
buffer area during data transfers. An index was specified either internally 
or externally. The Internally Specified Index (ISI) mode provided a BCW 
for each channel. Only one I/O system path was assigned to a channel at a 
time. The BCW, whose format is depicted in Figure 9-5, controlled the 
flow of data to or from the peripheral device. 
 
 
 
Figure 9-5. UNIVAC 494 BCW Format 
Source: Adapted from Sperry Rand 1969a 

UNIVAC 490/494 
 
193 
The Word Count specified the number of words to be transferred to or 
from the peripheral device. As each word was transferred, the Word Count 
was decremented. When the Word Count reached zero, an interrupt was 
generated to request service from the Executive. The Buffer Address 
specified the first word of the buffer. 
The Externally Specified Index (ESI) specified different buffer areas, 
each defined by a pair of BCRs for multiple devices attached to an I/O 
channel via a multiplexor. The pair of BCRs was used for input and output 
operations. The index was specified by the external system, such as the 
Communication Terminal Module Controller, which provided a value 
specifying the particular device and whether input or output was 
requested. Bits 15-29 received the input data address, while bits 00-14 
provided the output data address.  
 
9.1.3.2 External Device Control 
 
The CPU controlled external devices through function codes and status 
words transmitted over the I/O channel data lines. A function code was 
sent by the CPU to initiate a particular operation on the device. The 
function code was differentiated from a data word by activating the 
External Function control line during transmission. Using function codes 
rather than instructions made the CPU independent of the characteristics of 
the devices which interpreted the functions. It also allowed for different 
devices to be assigned to the dynamic range of identifiers associated with 
devices attached to the I/O channels. No modification of the CPU was 
required to attach different devices, such as upgraded peripherals over the 
system’s lifetime. 
Once a function was completed by the device, it sent a status word 
back to the CPU. The status word was distinguished from data by 
activating the External Interrupt line. Activating this line forced program 
control to be transferred to an address which handled the interrupt by 
analyzing the status word and taking appropriate action. 
9.1.4 Communications Handling 
UNIVAC’s Communication Terminal Module Controller (CTMC) 
provided the interface to Data Communication Terminals which handled 
dial-up circuits at up to 2K chars/s. Each CTMC provided for data transfer 
between a UNIVAC 494 CPU and up to 32 remote site devices. The 
CTMC was attached to the CPU by an I/O channel. Up to 16 
Communication Terminal Modules (CTMs) could be configured in a 

Chapter Nine 
 
194
single CTMC cabinet. Interface Modules (IMs), which handled the 
conversion between the remote device’s protocol and the CTM were also 
mounted in the cabinet. 
The CTM provided the logical interface between the communication 
lines and the UNIVAC 494. There were four types of CTMs: low-, 
medium-, and high-speed synchronous and dial-up. Each CTM had a 
service priority determined by its attachment to the CTMC. Each CTM 
presented a service request to the CTMC when it had received a complete 
character from an IM or had completed transmission of a character to an 
IM. Many concurrent requests could be active. The CTMC samples the 
CTMs requesting service and granted priority to the one with the highest 
priority. Once a CTM had been serviced, all current service requests were 
evaluated and the CTMC locked-on to another CTM within 13 
microseconds. 
The CTMs were grouped into modules of two input terminals and two 
output terminals except for the dial-up systems, which were output only 
and have up to six output terminals. The terminals could be used in 
simplex, half-duplex, or full-duplex mode. The rates for the synchronous 
CTMs were low: 20-300 bits per second; medium: 300-1600 bits per 
second; and high:  up to 50,000 bits per second. Dial-up CTM rates were 
determined by Bell System 801 Automatic Calling Units. 
The remote devices were UNISCOPE terminals that adhered to the 
EIA specification RS-232. These included the Data Communication 
Terminal 2000, the UNISCOPE 3000, the UNIVAC 9200/9300 systems 
and the UNIVAC 1004 system. The latter two devices provided the 
UNIVAC 494 with a remote job entry and off-line printing capability or a 
means to connect multiple computer systems together in a network. The 
UNIVA 9200/9300 and UNIVAC 1004 systems will be discussed in a 
forthcoming volume on UNIVAC computer systems. 
9.1.5 Transfer Switch 
A Transfer Switch was an optional device which allowed a number of 
multicomputer, multiple peripheral subsystem configurations to be 
implemented. The simplest was to connect a single CPU to two peripheral 
subsystems or two CPUs to a single peripheral subsystem, which allowed 
data to be shared between the two CPUs. A more complex configuration is 
depicted in Figure 9-6 which allowed any number of systems to be 
cascaded together. 
 

UNIVAC 490/494 
 
195 
 
 
Figure 9-6. UNIVAC 494 Cascade System 
Source: Adapted from Sperry Rand 1969a 
9.2 Instruction Set 
Source: Sperry Rand 1969a, 1969c 
 
The 494 used three instruction formats which are depicted in figure 9-7 
The Normal Instruction Word supported instructions divided into three 
classes: read, store, and replace. 
 
 
 
Figure 9-7. UNIVAC 494 Instruction Format 
Source: Adapted from Sperry Rand 1969a 

Chapter Nine 
 
196
The instruction set featured a register-address structure with the 
address modifiable by one of seven index registers. The 6-bit opcode in 
field f allowed 64 basic operations. However, the 3-bit branch condition 
designator extended the number of operations and some operations did not 
use the operand address. The total number of instructions was 99. 
 
f -  Function code designator (6 bits)  
j -  Branch condition designator (3 bits)  
k -  Operand-interpretation designator (3 bits)  
b -  Operand address modification designator (3 bits)  
y -  Operand designator (15 bits)  
 
The extended instruction word, indicated by 778 in the f field, extended 
the range of functions and was used by executive program functions. The 
opcode 778 signaled that an executive function was requested and 
indicated functions added tot eh instruction set which had previously 
implemented as subroutines on the UNIVAC 490 series. The g designator 
specified the function to be performed. 
The I/O instruction word differed from the normal instruction word in 
that field j was increased to four bits and field k decreased to 2 bits. 
Table 9-4 presents the interpretation of the j instruction for different 
instructions as an example of the complexity of the instruction set. In 
effect, each entry in the table represented a different instruction. 
 
[Note: I do not pretend to understand all of the nuances of these different 
instructions or how they might be used in applications or system software, 
such as the operating system or compilers. I have been unable to find 
adequate documentation or programming examples that show how some 
of these combinations would be used in practical programming. But, I 
assume that the system designers had valid reasons for including each of 
these cases as part of the machine’s functionality.] 
 
Table 9-4. Special Interpretation of j Designators for Selected Instructions 
j 
40,44 
43 
60,64 
61,65 
70 
71 
0 
No 
skip 
No 
skip 
No jump; 
60 – clear lockout 
64 – lock out interrupts 
Jump 
Next Y 
= Y 
Skip if 
Y = 
+0 
1 
Skip 
Skip 
Jump; 
60 – clear lockout 
64 – lock out interrupts 
Jump 
if Key 
1 was 
set 
Next Y 
= Y+1 
Bj = 
B1 

UNIVAC 490/494 
 
197 
2 
Skip if 
c(A) 
has 
even 
no. of 
1s 
c(Q) 
= + 
Jump if sign(c(Q)) = + 
Jump 
if Key 
2 was 
set 
Next Y 
= Y-1 
Bj = 
B2 
3 
Skip if 
c(A) 
has 
odd 
no. of 
1’s 
C(Q) 
= - 
Jump if sign(c(Q)) = - 
Jump 
if Key 
31 
was 
set 
Next Y 
= Y + 
c(B0) 
Bj = 
B3 
4 
Skip if 
c(A) = 
0 
A-
LP(c(
Y), 
c(Q)) 
= + 0 
Jump if c(A) = +0 
Jump 
if Key 
4is set 
Next Y 
= Y + 
c(B6) 
Bj = 
B4 
5 
Skip if 
c(A) 
/= 
A-
LP(c(
Y), 
c(Q)) 
/= + 0 
Jump if c(A) /= +0 
Jump 
if Key 
5 was 
set 
Next Y 
= Y + 
1 + 
c(B6) 
Bj = 
B5 
6 
Skip if 
sign(c(
A)) = 
+ 
A-
LP(c(
Y), 
c(Q)) 
= +  
Jump if sign(c(A)) = + 
Jump 
if Key 
6 was 
set 
Next Y 
= Y -1 
+ c(B6) 
Bj = 
B6 
7 
Skip if 
sign(c(
A)) = - 
A-
LP(c(
Y), 
c(Q)) 
= - 
ump if sign(c(A)) = - 
Jump 
if Key 
7 was 
set 
Next Y 
= Y + 
c(B0) + 
c(B6) 
Bj = 
B7 
 
In the following sections, notation c(…) indicates to use the contents of 
the designated register or location. 
9.2.1 Shift Instructions 
Shift instructions, presented in Table 9-5, move the contents of the 
selected register to the right or left as many positions specified. On right 
shifts, all bits moved out of the register were lost and the vacated bits were 

Chapter Nine 
 
198
filled with the current sign bit. Logical right shifts resulted in filling the 
vacated bits with zero.  Left shifts were circular shifts in that bits moved 
out of high order positions were entered into low-order positions. Other 
than the Scale Factor Shift, the low order six bits of Y specified the shift 
count. 
 
Table 9-5. UNIVAC 494 Shift Instructions 
Instruction 
Opcode 
Description 
RSQ 
01 
Right Shift Q: Shift contents of Q register right 
the number of positions specified by the shift 
count. If the shift count > 28 and less than 60, 
the Q register was filled with the original sign 
bit (bit 29). 
RSA 
02 
Right Shift A: Shift contents of A register right 
the number of positions specified by the shift 
count. If the shift count > 28 and less than 60, 
the A register was filled with the original sign 
bit (bit 29). 
RSAQ 
03 
Right Shift AQ: Shift contents of AQ register 
right the number of positions specified by the 
shift count. If the shift count > 59, the AQ register 
was filled with the original sign bit (bit 29). 
LSQ 
05 
Circular Left Shift Q: Shift the contents of the Q 
register left the number of positions specified by 
the shift count. If the shift count > 30, the 
contents of the Q register were its initial state. 
LSA 
06 
Circular Left Shift A: Shift the contents of the A 
register left the number of positions specified by 
the shift count. If the shift count > 30, the 
contents of the A register were its initial state. 
LSAQ 
07 
Circular Left Shift AA: Shift the contents of the 
AA register left the number of positions 
specified by the shift count. If the shift count > 
30, the contents of the A and Q register were 
interchanged. 
LRSQ 
7751 
Logical Right Shift Q: Shift contents of Q 
register right the number of positions specified 
by the shift count with zero fill.  
LRSA 
7755 
Logical Right Shift A: Shift contents of A 
register right the number of positions specified 
by the shift count with zero fill. 

UNIVAC 490/494 
 
199 
LRSAQ 
7756 
Logical Right Shift AQ: Shift contents of AQ 
register right the number of positions specified 
by the shift count with zero fill. 
SFS 
7730 
Scale Factor Shift: Shift the A register left until 
the two highest order bits were different. Place 
the number of shifts in the Q register. When all 
bits in A were equal, a shift count of 28 was 
placed in the Q register. 
9.2.2 UNIVAC 494 Transfer Instructions 
Transfer instructions, depicted in Table 9-6, were used to move data 
within the CPU between memory and the registers. Transfers could occur 
for 60, 30, or 15 bits, or in character packing and unpacking. Transfers of 
data to and from index registers involved 17 bits if index register mode 
was activated by IFR. Normally, for user or worker programs, only 15-bit 
mode was activated. 
 
Table 9-6. UNIVAC 494 Transfer Instructions 
Instruction 
Opcode 
Description 
LQ 
10 
Enter Q: Q <- c(Y) 
LA 
11 
Enter A: A <- c(Y) 
LB 
12 
Enter Bj: Transfer Y to the index register 
designated by j. See below for effect of k. 
STRQ 
14 
Store Q: Y <- c(Q). The value of k determined 
show much of the Q register was stored. 
STRA 
15 
Store A: Y <- c(A). The value of k determined 
show much of the A register was stored. 
SB 
16 
Store Bj: Store the contents of the index 
register designated by j at Y. If j = 0 and k =3, 
store all zeroes. If j = 0 and k = 7, store all 
ones. 
DPL 
7721 
Enter AQ: AQ <- c(Y), c(Y+1) 
DPS 
7725 
Store AQ: Y, Y+1 <- c(AQ) 
CPL 
7731 
Character Pack Lower: Transfer into A from 
leftmost bit the six bits from c(Y)00-05, 
c(Y+1)00-05, c(Y+2)00-05; ,,,, c(Y+4)00-05 
CPU 
7732 
Character Pack Upper: Transfer into A from 
leftmost bit the six bits from c(Y)15-20, c(Y+1) 
15-20, c(Y+2) 15-20, ,,,, c(Y+5) 15-20 
 
 

Chapter Nine 
 
200
CUL 
7735 
Character Unpack Lower: Y00-05 <- c(A)24-29, 
Y+100-05 <- c(A)18-23, …, Y+400-05 <- c(A)00-05 
CUU 
7736 
Character Unpack Upper: Y15-20 <- c(A)24-29, 
Y+115-20 <- c(A)18-23, …, Y+415-20 <- c(A)00-05 
LIFR 
7761 
Enter IFR and RIR: IFR <- c(Y); RIR <- 
c(Y+1)06-16 
LPLR 
7762 
Load PLR: PLR <- c(Y). This instruction was 
intended for executive routines.  
SIFR 
7765 
Store IFR: Y <- c(IFR) 
LRIR 
7766 
Enter RIR: RIR <- c(Y)06-16. 
LBW 
7771 
Enter B Registers: Transfer the lowest order 
bits of seven successive primary storage 
locations to the B registers. 
SWB 
7775 
Store B Registers: Transfer the contents of the 
B registers to the low order bit positions of the 
seven successive primary storage locations 
beginning at Y. 
 
The value of the k field effects the Bj transfer instruction based on the j 
fields as depicted in table 9-7. The subscripts L and U indicate the lower 
or upper portion of the argument.  
 
Table 9-7. k Field Modification to Enter Bj. 
j 
k 
Description 
4,5,6,7 
0 
1 
2 
3 
4 
5 
6 
7 
Bj <- 17-bit y 
Bj <- 15-bit c(y)L with zero-fill at high end 
Bj <- 15-bit c(y)U with zero-fill at high end 
Bj <- 17-bit c(Y)0-16 
Bj <- 15-bit y with sign extension 
Bj <- 15-bit c(y)L with sign extension 
Bj <- 15-bit c(y)U with sign extension 
Bj <- 17-bit c(A)0-16 
1,2,3 
0 
1 
2 
3 
4 
5 
6 
7 
Bj <- 15-bit y 
Bj <- 15-bit c(y)L  
Bj <- 15-bit c(y)U  
Bj <- 15-bit c(Y)0-14 
Bj <- 15-bit y  
Bj <- 15-bit c(y)L  
Bj <- 15-bit c(y)U  
Bj <- 15-bit c(A)0-14 
0 
 
No operation 

UNIVAC 490/494 
 
201 
As with Table 9-4 above, this table indicates the complexity of the 
functionality provided in the machine by the system designers. 
9.2.3 Arithmetic Instructions 
All the UNIVAC 494 arithmetic instructions used the 60-bit adder. The 
programmer had to guard against overflow conditions. Integer 
multiplication and division were performed as a sequence of additions and 
subtractions. In floating point arithmetic operations, an overflow was 
indicated when the exponent exceeded 1023 or division by zero was 
attempted. Decimal arithmetic was performed using either nines 
complement or tens complement representations. Tables 9-8 through 9-10 
presents the fixed point (integer), floating point, and decimal arithmetic 
instructions. 
 
Table 9-8. UNIVAC 494 Integer Arithmetic Instructions 
Instruction 
Opcode 
Description 
A 
20 
Add A: A <_ c(A) + c(Y) 
AN 
21 
Add Negative A: A <- c(A) – c(Y), e.g. 
subtract 
M 
22 
Multiply: AQ <- c(Q) * c(Y) 
D 
23 
Divide: Q <- c(AQ)/c(Y), remainder to A 
RA 
24 
Replace A+Y: Y, A <- c(Y) + c(A) 
RAN 
25 
Replace A-Y: Y, A <- c(A) – c(Y) 
AQ 
26 
Add Q: Q <- c(Q) + c(Y) 
ANQ 
27 
Subtract Q: Q <- c(Q) – c(Y) 
LAQ 
30 
Enter Y+Q: A <- c(Q) + c(Y) 
LANQ 
31 
Enter Y-Q: A <- c(Y) – c(Q) 
SAQ 
32 
Store A+Q: Y, A <- c(A) + c(Q) 
SANQ 
33 
Store A-Q: Y, A <- c(A) – c(Q) 
RAQ 
34 
Replace Y+Q: Y, A <- c(Q) + c(Y) 
RANQ 
35 
Replace Y-Q: Y,A <- c(Y) – c(Q) 
R1 
36 
Replace Y+1: Y, A <- c(Y) + 1 
RD 
37 
Replace Y-1: Y, A <- c(Y) - 1 
DPA 
7722 
Add AQ: AQ <- c(AQ) + c(Y, Y+1) 
DPAN 
7724 
Complement AQ: AQ <- CP(AQ) 
DPN 
7726 
Subtract AQ: AQ <- c(AQ) - c(Y, Y+1) 
 
 

Chapter Nine 
 
202
For floating point arithmetic instructions, the result was always 
normalized after the arithmetic operation was performed. Floating point 
arithmetic operations were checked for underflow and overflow. The Pack 
operation packed the biased exponent c(Y)00-10 with the unnormalized  
fixed point part, c(AQ) to make up a floating point number. For the 
Unpack operation, the absolute magnitude of the exponent of the floating 
point number in AQ was stored in Y00-10 and Y11-14 was filled with zeroes. 
The fixed point part of AQ was sign-extended to fill the exponent part of 
AQ. 
 
Table 9-9. UNIVAC 494 Floating Point Arithmetic Instructions 
Instruction 
Opcode 
Description 
FA 
7701 
Floating –Point Add: AQ <- c(AQ) + c(Y, 
Y+1)  
FAN 
7702 
Floating-Point Subtract: AQ <- c(AQ) - 
c(Y, Y+1) 
FM 
7703 
Floating-Point Multiply: AQ <- c(AQ) * 
c(Y, Y+1) 
FD 
7705 
Floating-Point Divide: AQ <- c(AQ)/c(Y, 
Y+1) 
FPP 
7706 
Floating-Point Pack: AQ <- c(Y) AND 
c(AQ) 
FU 
7707 
Floating-Point Unpack: Y, AQ <- c(AQ) 
 
BDC digits were represented by 4 bits, so that AQ could hold 10 
decimal digits. DCL converted a five-digit decimal number consisting of 
the five individual digits in five successive locations, e.g., Y through Y+4 
into a single BCD number stored in AQ. DCU performs the obverse 
operation decomposing the single BCD number into five individual digits. 
 
Table 9-10. UNIVAC 494 Decimal Arithmetic Instructions 
Instruction 
Opcode 
Description 
DT 
7710 
Decimal Test AQ: Skip per Y (see below) 
DA 
7711 
Decimal Add: AQ <- c(AQ) + c(Y,Y+1)  
DAN 
7712 
Decimal Subtract: AQ <- c(AQ) - c(Y,Y+1) 
DCP 
7714 
Decimal 
Complement: 
9’s 
or 
10’s 
Complement AQ <- AQ Per Y 
DAC 
7715 
Decimal Carry: AQ <- c(AQ) + c(Y,Y+1)  + 
CARRY 
DANB 
7715 
Decimal Subtract With Borrow: c(AQ) - 
c(Y,Y+1) - BORROW 

UNIVAC 490/494 
 
203 
DCL 
7733 
Decimal Convert Lower: AQ <- c(Y)0-5 Thru 
c(Y+4)0-5 
DCU 
7734 
Decimal Convert Upper: AQ <- c(Y)15-20 Thru 
c(Y+4)15-20 
 
DT performs a skip based on the bits 0-10 in c(Y) as depicted in Table 
9-11. The tests in bit positions 5 thru 9 were often used by programmers to 
detect a result that exceeded the normal data field length. 
 
Table 9-11. Decimal Test Conditions 
Bit 
Description 
0 
Skip if decimal overflow indicator was set in IFR 
1 
Skip if decimal overflow indicator was clear in IFR 
2 
Skip if sign bit was + 
3 
Skip if number was zero, disregarding sign 
4 
Skip if sign bit was - 
5 
Skip if sixth decimal digit was not equal to zero 
6 
Skip if seventh decimal digit was not equal to zero 
7 
Skip if eighth decimal digit was not equal to zero 
8 
Skip if ninth decimal digit was not equal to zero 
9 
Skip if tenth decimal digit was not equal to zero 
10 
Skip if AQ was not equal to 0, disregarding sign 
9.3.4 Logical Instructions 
Logical instructions allowed the programmer to operate upon specific 
bits within a word. Thus, a programmer could interpret different bit 
positions to indicate different statuses or conditions or actions to take. This 
provided a means of encoding information to conserve memory space. The 
logical operation was performed upon bits in the same corresponding 
positions within the two operands. In the following descriptions Table 9-
12 presents the logical instructions. Xn represents an iteration over the bits 
of the respective register. 
 
Table 9-12. UNIVAC 494 Logical Instructions 
Instruction 
Opcode 
Description 
LLP 
40 
Enter Logical Product: A <- LP(c(Y),c(Q)) 
ALP 
41 
Add 
Logical 
Product: 
A 
<- 
c(A) 
+ 
LP(c(Y),c(Q)) 
ANLP 
42 
Subtract Logical Product: A <- c(A) - 

Chapter Nine 
 
204
LP(c(Y),c(Q)) 
RLP 
44 
Replace Logical Product: Y, 
A <- LP(c(Y),c(Q)) 
RALP 
45 
Replace A + Logical Product: Y, 
A <- c(A) + LP(c(Y),c(Q)) 
RANLP 
46 
Replace A – Logical Product: Y, 
A <- c(A) - LP(c(Y),c(Q)) 
SAND 
47 
Store Logical Product: Y <- LP(c(Q), c(A)) 
OR 
50 
Selective Set: If c(A) n OR c(Y) n = 1, A n <- 1 
XOR 
51 
Selective Complement: If either c(A) n OR 
c(Y) n = 1, A n <- 1 
NOT 
52 
Selective Clear: If c(Y)n = 1, A n = 0 
SSU 
53 
Selective Substitute: If Q n = 1, A n <- Y n 
ROR 
54 
Replace Selective Set: If c(A) n OR c(Y) n = 1, 
A n <- 1, Y <- c(A) 
RXOR 
55 
Replace Selective Complement: If either c(A) n 
OR c(Y) n = 1, A n <- 1, Y <- c(A) 
RNOT 
56 
Replace Selective Clear: If c(Y)n = 1, 
A n = 0, Y <- c(A) 
RSSU 
57 
Replace Selective Substitute: If Q n = 1, 
A n <- Y n, Y <- c(A) 
9.3.5 Comparison Instructions 
Comparison instructions extended the range of comparisons that could 
be performed using the j designator for most read instructions. 
Comparisons could be either arithmetic or alphanumeric. Alphanumeric 
comparisons performed absolute comparisons on the whole word, e.g., the 
sign bit was included in the comparison. Alphanumeric comparisons were 
useful in sorting and collating programs where characters and numbers 
were both involved. Table 9-13 presents the comparison instructions. 
 
Table 9-13. UNIVAC 494 Comparison Instructions 
Instruction 
Opcode 
Description 
MATE 
7753 
Masked Alphanumeric Equal: if LP(c(A), 
c(Q))  was equal to LP(c(Y), c(Q)), skip per j 
MATL 
7757 
Masked Alphanumeric Less: if LP(c(A), c(Q))  
was less than LP(c(Y), c(Q)), skip per j 
TA 
04 
Compare A: compare c(Y) to c(A) and skip 
per j 

UNIVAC 490/494 
 
205 
TQ 
04 
Compare Q: compare c(Y) to c(Q) and skip 
per j 
TR 
04 
Compare AQ: if y ranges between c(A) and 
c(Q), skip per j 
TLP 
43 
Compare Masked: compare c(A) to LP(c(Y), 
c(Q)) and skip per j 
DPTE 
7723 
Compare AQ Equal: if c(AQ) was equal to 
c(Y,Y+1), skip per j 
DPTL 
7727 
Compare AQ Less: if c(AQ) was less than 
c(Y,Y+1), skip per j 
 
Note that Sperry Rand defined only two of the four comparison 
instructions as the alternative became the failure condition. Thus, 
comparing two data items equal, when it did not succeed, led to a result 
that they were not equal. This allowed easy translation of if…then….else 
statements in FORTRAN and other programming languages. 
9.3.6 Jump Instructions 
Jump instructions transferred program control to the next sequential 
instruction at the specified memory location if the conditions for the jump 
were satisfied. In jump instructions, the operand Y was the address of a 
memory location which contained the address of the next instruction. The 
address was determined by the k field and consisted of the low order 15 or 
17 bits depending on the operating mode. Table 9-4 describes the 
interpretation of the j designator with respect to these instructions. Table 
9-14 presents the UNIVAC 494 jump instructions. 
 
Table 9-14. UNIVAC 494 Jump Instructions 
Instruction 
Opcode 
Description 
J 
60 
Jump Arithmetic: P<- c(Y) if j condition 
satisfied 
J 
61 
Jump Manual: P<- c(Y) if j condition satisfied 
SLJT 
64 
Return Jump – Arithmetic: Y<- c(P) +1; P <- 
Y+1 per j; SIL per j 
SLJ 
65 
Return Jump – Manual: Y<- c(P) +1; P <- Y+1 
per j and Key 
ER 
7737 
Execute Remote: c(Y) = NI; return if no skip 
or jump at NI 
LPBx 
774x 
Enter Bx and Jump: Bx <- c(P); P <- c(Y)  for 
x = 0,…,7 

Chapter Nine 
 
206
9.3.7 Sequence Modifying Instructions 
Sequence modifying instructions were used to repeat a particular 
instruction some number of times as specified by the repeat count. They 
could also transfer control to another part of the program. Table 9-15 
presents the sequence modifying instructions. 
 
Table 9-15. UNIVAC 494 Jump Instructions 
Instruction 
Opcode 
Description 
R 
70 
Repeat: Repeat NI Y times; B7 <- Y 
With each execution of the repeat 
instruction, Bj <- Bj – 1 until Bj = 0. The j 
designator specified how Y was modified 
after each instruction execution: 
   j         Modification 
0 or 4    Y remains unchanged 
1 or 5    Y <- Y + 1 
2 or 6    Y <- Y – 1 
3 or 7    Y <- Y + Bb 
TBI 
71 
Skip on Bj: if Bj = Y, Bj <- 0 and skip; else 
Bj <- Bj + 1. The k designator determines 
the bit length of the operands – either 15 
bits or 30 bits. 
JBD 
72 
Jump on Bj: if Bj not equal to 0, Bj <- Bj – 
1and jump else if Bj = 0, go to NI 
TSET 
7752 
Test and Set: if Y14 = 0, Y0-14 <- 1’s, else 
interrupt 
EXRN 
7754 
Executive Return: Interrupt the executing 
program to a fixed address ot handle an 
executive routine. 
 
The repeat instruction could not be applied to several instructions: 
illegal instruction – 00 or 7700; Enter Bj – 12; Send External Function – 
13; Store Channel – 17; Any Jump instruction or Buffer Activation and 
Termination – 60 through 76; and all 77xx instructions. If a repeat was 
attempted for these instructions and the repeat count was non-zero, the 
instruction would be executed at most once and then program control 
transferred to NI. If the repeat count was zero, the instruction was skipped. 

UNIVAC 490/494 
 
207 
9.3.8 I/O Instructions 
I/O instructions transferred data and control signals between 
peripherals and the CPU through I/O channels. These instructions activate 
and terminate buffers and channels, and keep track of the status of I/O 
operations occurring within the system. Table 9-16 presents the UNIVAC 
494 I/O Instructions. 
 
Table 9-16. UNIVAC 494 I/O Instructions 
Instruction 
Opcode 
Description 
LC 
13 
Send External Function: CHCSR <- Y AND EF. 
Send the one function word together with the 
External Function signal on the channel 
specified by CSR.  
SC 
17 
Store Channel: Y <- Input CHCSR. Store the 
status word on the input data words that 
accompanied the External Interrupt signal. 
JIC 
62 
Jump On Active Input Buffer: If Input CHCSR 
active, P <- Y 
JOC 
63 
Jump On Active Output Buffer: If Output 
CHCSR active, P <- Y 
DIC 
66 
Terminate Input Buffer: Terminate Input 
CHCSR. Any input in progress was completed, 
but further input was inhibited. 
DOC 
67 
Terminate Output Buffer: Terminate Output 
CHCSR. Any output in progress was completed, 
but further output was inhibited. 
LIC 
73 
Activate Input Buffer Without Monitor: Activate 
Input CHCSR. Because the input buffer was 
activated without a monitor, no interrupt will be 
generated as the buffer was filled, even though 
the buffer was deactivated when the word count 
became zero. Restricted to ISI input. 
LOC 
74 
Activate Output or External Function Buffer 
Without Monitor: Activate Output CHCSR or 
EFCSR. Because the output buffer was activated 
without a monitor, no interrupt will be 
generated as the buffer was emptied, even 
though the buffer was deactivated when the 
word count became zero. Restricted to ISI 
input. 

Chapter Nine 
 
208
LICM 
75 
Activate Input Buffer With Monitor: When the 
buffer was filled and the address count in the 
BCR was zero, a monitor interrupt will be 
generated. 
LOCM 
76 
Activate Output Buffer With Monitor: When 
the buffer was emptied and the address count 
in the BCR was zero, a monitor interrupt will 
be generated. 
ISI 
7770 
Initiate Synchronizing Interrupt: Interrupt. 
Sent an interrupt signal to either of two 
collocated CPUs working together.  
SCN 
7772 
Store Channel Number: Select IASR or 
PECSR 
LCSR 
7773 
Enter Channel Select Register: CSR <- Y0-4 
9.3 Peripherals 
The UNIVAC 494 Peripheral subsystems were directly connected to 
the I/O channels and included: 
x Magnetic Drum Systems: The FH-432, FH-1782, and FH-880 
magnetic drums provided random access, online storage with 
access times ranging from 4.33 to 17 milliseconds and transfer rates 
of 60,000 to 240,000 words per second. Up to eight subsystems per 
I/O channel could be connected to the 494 yielding a storage 
capacity of between 786K to 16.7M words depending upon unit 
configurations. 
x Mass Storage Systems: Mass storage was provided by FASTRAND 
II or FASTRAND III random access, magnetic drum systems with 
access times ranging from 35 to 92 milliseconds and data transfer 
rates from 50K to 76K words per second. Up to eight systems per 
I/O channel could be connected to the 494 providing a storage 
capacity of 25M to 311M words depending on unit configuration. 
x Magnetic Tape Subsystems: Up to 16 UNISERVO VIII C or 
UNISERVO VI C magnetic drive drives could be attached to an 
I/O channel. They had recording densities of 200 to 800 frames per 
inch with transfer rates between 8,500 and 96,000 frames per 
second. Magnetic tapes used either the 7- or 9-track format, and 
could read forward and backward. 
x High-Speed Printer Subsystem: Type 0755 or 0758 printers could 
print 700 to 1600 132-character lines per minute. 

UNIVAC 490/494 
 
209 
x Punched Card System: A Type 0706 Card Reader and a Type 0600 
Card Punch could be attached to an I/O channel. 
9.3.1 Magnetic Drums 
Source: Adapted from Sperry Rand 1969a 
 
The UNIVAC 494 supported the several different magnetic drum 
systems. Tables 9-17 and 9-18 presents the features of these drum systems. 
The FH-432 magnetic drum had 432 recording tracks each equipped with 
a read/write head. 384 of these tracks were used for storing data, while the 
rest were either spares or used for timing purposes. When data was 
recorded on the drum, three parity bits were generated and stored with 
each word. The accuracy of the data was checked via odd parity checking. 
 
Table 9-17. Magnetic Drum Systems 
Characteristic 
FH-432 
FH-880 
Capacity(Words) 
786K 
786K 
# Units per I/O channel 
3 - 9 
1 - 8 
Avg. Access Time (milliseconds) 
4.33 
17 
Transfer Rate 
(chars/s) 
1.2M 
3.9M 
 
The FH-880 magnetic drum had 880 recording tracks each equipped 
with a read/write head. 786 of these tracks were used for storing data, 32 
tracks were used for parity data, and the rest were either spares or used for 
timing purposes. When data was recorded on the drum, three parity bits 
were generated and stored for each word on the parity. The accuracy of the 
data was checked via odd parity checking. 
 
Table 9-18. Mass Storage Systems 
Characteristic 
FASTRAND 1A 
FASTRAND II 
Capacity  (Words) 
12.9M 
25.9M 
# Units per I/O channel 
8 
8 
Avg. Access Time  (milliseconds) 
92 
92 
Transfer Rate  (chars/s) 
185,200 
185,200 
 
The FASTRAND II contained magnetic drums – one mounted on top 
of the other in the cabinet.  Each drum had a total of 6, 534 tracks of which 
6,144 were used for data recording, and the remaining 390 tracks were 
used for spares and timing purposes. Data tracks were divided into 64 

Chapter Nine 
 
210
sectors of 33 words each. Two channels and two control units were 
required for simultaneous operation of both drums. The FASTRAND 1A 
had just a single drum. 
9.3.2 Magnetic Tape Subsystem 
The UNIVAC 494 supported two magnetic tape systems for on-
line/off-line storage. Table 9-19 presents features of these systems. A Type 
5008 Control Unit could attach either or a mix of the UNISERVO tape 
drives. The magnetic tape drives had the same function with the difference 
in speed and capacity. 
 
Table 9-19. UNISERVO Magnetic Tape Subsystems 
Characteristic 
UNISERVO VIC 
UNISERVO VIIIC 
Transfer Rate (chars/s) 
8.5K, 24K, 34K 
24K, 66.7K, 96K 
Recording Density (bits/in) 
200, 556, 800 
200, 556, 800 
Speed (in/s) 
42 
120 
Channels 
6 data, 1 parity 
6 data, 1 parity 
# Units per I/O Channel 
16 
16 
 
Unit record peripherals included a 600/900 cards per minute card 
reader, a 300 cards per minute card punch, a 700/922 lines per minute line 
printer, and paper tape subsystem.  
9.3.3 Operator’s Console 
The Type 400 Operator’s Console provided the means for the operator 
to communicate with the system and monitor its operations. The operating 
system informed the operator when manual intervention was required, 
such as loading a magnetic tape onto a drive. It consisted of a keyboard, 
printer, control and display panel, and the Day Clock Display. The control 
and display panel provided displays of the CPU’s registers and switches 
by which the operator could control the internal, operations of the system, 
when operating under control of the Executive. The Operator’s Console 
was attached to channel 0. 
9.3.4 High-Speed Printer Subsystem 
The Type 0755 or 0758 high-speed printer subsystem differed only in 
their printing speed: the 0755 could print at 700 to 920 lines per minute 
while the 0758 printed at a rate of 1200 to 1600 lines per minute. The 

UNIVAC 490/494 
 
211 
maximum rate was attained by printing a subset of the complete character 
set. The complete character set contained 63 printable characters: 26 
alphabetic, 10 numerals, and 27 special characters. Each printer could 
print 132 character per line. 
9.4 UNIVAC 490/494 System Software 
Source: Sperry Rand 1969a 
 
The standard UNIVAC 490/494 operating system was REX (Real-
Time Exec), which was similar to the EXEC-I operating system developed 
for the UNIVAC 418 systems. 
At Eastern Airlines and British European Airlines (BEA), a custom 
operating system was developed for airline reservations (CONTORTS - 
CONTrol Of Real Time System). CONTORTS was the origin of Univac's 
subsequent RT operating systems for the UNIVAC 494 (STARS) and later 
converted to the 1100 Series (RTOS). 
The UNIVAC 494 executed the OMEGA operating system. 
Conceptually, it featured a master control program, the EXECUTIVE, 
which supported a multiprogramming environment.  
9.4.1 Primary Input Stream 
The primary input stream for REX was a job stream consisting of a 
sequence of statements and data. Typically, jobs were entered sequences 
of tasks, each task indicated by one or more control statements, but could 
also be entered from remote devices. The input consisted of control 
statements, program data, program parameters, and source code for 
programs to be translated by the language processors.  
9.4.2 Input Cooperative 
The input cooperative was a collection of scheduling routines which 
accepted the input stream from the input devices, buffered the data to mass 
storage devices, scheduled jobs for execution, and coordinated with the 
output cooperative to produce results to unit record peripherals or mass 
storage or other devices. Each unit input routine scanned the input stream 
for job decks which were queued for job control. The job control queue 
was maintained in a common storage pool, which dynamically expanded 
or contracted as jobs entered and left the system.  

Chapter Nine 
 
212
9.4.3 Programming Languages 
The UNIVAC 494 operating system supported two assemblers, the 494 
ASM and the 494 SPURT, and two programming languages: COBOL and 
FORTRAN IV. Each of these language processors was able to separately 
compile program modules which were then collected and integrated into 
an executable program. Each of these processors provided access to 
operating system executive routines which provided common functions for 
system operation. 
A variant of ALGOL 58, called NELIAC, which was developed by the 
U.S. Navy Electronics Laboratory, was also ported to the UNIVAC 494. 
NELIAC was the first programming language to be compiled by a 
compiler written in itself. NELIAC was described more fully in Maurice 
Halstead’s book Machine Independent Computer Programming, Spartan 
Pres, 1962. 
9.5 UNIVAC 490/494 Assessment 
Apparently, the UNIVAC 490 computer was the last computing 
machine designed by Seymour Cray before he left Univac to help establish 
Control Data Corporation. 
According to The Computer Museum, https://museum.syssrc.com/ 
artifact/minicomputers/300/, about 47 490 systems were manufactured and 
delivered to customers. Several 494s were installed at the National Air and 
Space Administration’s Houston facility to support the Gemini and Apollo 
missions as part of the Communications, Command and Telemetry 
Systems (CCATS). Two 494s were used to monitor conditions inside the 
spacecraft while a third 494 checked the other two. The 494s were used to 
route 
communications 
to 
and 
from 
the 
Apollo 
astronauts 
(https://www.flickr.com/photos/museeinformatique/3783421497/in/photos
tream/). 
Various customers used this machine type; however, it was principally 
utilized for airline reservations systems at Eastern Airlines (1963) and 
British European Airways (BEA) (BEACON 1964). Phil Mayes describes 
how the UNIVAC 494s were used BEA (http://www.philmayes.com/ 
work/univac-494s-at-bea/). Several commercial installations – notably 
Bethlehem Steel, Alcoa, and US Steel also installed 490 systems. The only 
complete surviving UNIVAC 490 is displayed at the System Source in 
Hunt Valley, MD.  
According to Benson (VIP Club 2015), the National Security Agency 
purchased two UNIVAC 490 systems for ingest of signal data. These 

UNIVAC 490/494 
 
213 
systems were operated in either master-slave mode or as independent 
computer systems. A former classmate of mine, Ray Haygood, told me 
that it ran a home-grown operating system called RYE. Further 
information can be found in the reference. Additional information can also 
be in the Report of the Second Computer Study Group, chaired by Willis 
Ware, at https://www.nsa.gov/news-features/declassified-documents/tech-
journals/assets/files/report-of-the-second-computer.pdf. 
According to Pearse, the Central Intelligence Agency used UNIVAC 
490 and 494 computer systems as part of its suite of image processing 
computers https://www.cia.gov/library/center-for-the-study-of-intelligence/ 
kent-csi/vol15no1/html/v15i1a03p_0001.htm. 
Plaumann (1965) describes the use of a UNIVAC 490 as a real-time 
message switch by NASA’s Communication Division. 
The military version of the UNIVAC 490 was designated as the 
UNIVAC 1230 and will be described in a forthcoming volume on military 
computer systems. 
 

CHAPTER TEN 
MIT’S TX-0 
 
 
 
The Massachusetts Institute of Technology (MIT) developed a number 
of experimental computers in the early 1950s. The TX-0 was a 
transistorized machine built at the Lincoln Laboratories beginning in 1953. 
The original engineering team included Wesley Clark as the logic designer 
and Ken Olsen as the engineer in charge of building the machine. Phil 
Peterson, Jack Gilmore, John Frankovich and Jim Forgie worked on logic 
design under Wes Clark. Bob Hudson and Chuck Norman were involved 
in the construction working for Ken Olsen in the engineering group. It was 
originally built as a machine to test a 64K ferrite memory and transistors 
for the TX-2, which was then on the drawing boards. (McKenzie 1999) 
Lincoln Laboratory and IBM had developed the SAGE computer for 
the national air defense system in the early 1950s. As a result of this effort, 
in 1955 Lincoln’s engineers realized that enhancements in memory size, 
elimination of vacuum tubes, and reorganization of the I/O system could 
lead to significant performance improvements. The Lincoln engineers 
began to think about a 36-bit computing machine. However, the advanced 
memory technology – 256 x 256 bit memory array – needed further 
evaluation. So, they designed a computing machine with 18-bit words as a 
test platform, which became the TX-0. The TX-0 used 3600 of the new 
Philco transistors which cost $80 each. The TX-0 computer room is 
presented in Figure 10-1 (Gilmore and Petersen 1958). 
 

MIT’s TX-0 
 
215 
 
 
Figure 10-1. TX-0 Computer Room 
Source: www.bitsavers.org/mit/tx-0 
 
The TX-0 was disassembled and moved to the MIT Electrical 
Engineering Department in 1958. It took 100 days to get the computer up 
and running again. At MIT, programmers were on intimate terms with the 
machine. They could walk up to the console, set a few switches and press 
some buttons to get the machine to execute a program. Users experimented 
with drawing interesting patterns on the screen, often trying to see how 
few instructions were required to do so. This “interactive” use of the 
computer opened up a new world of experimentation in programming.  
At MIT, it delivered service until 1975. Ken Olson and DEC then 
bought it from MIT for the first incarnation of the Computer History 
Museum, which was based in Marlboro, Massachusetts. When the 
Computer History Museum was formed in California, the TX-0 was 
moved to that location where it is currently displayed. 
On October 26, 1960, a television broadcast was aired on the CBS 
show "The Thinking Machine" which featured a series of western playlets 
developed by a program run on the TX-0. The program, called SAGA II, 
was developed for the TX-0 by Douglas Ross and Harrison Morse of 
MIT's Electronics Systems Laboratory. 
 

Chapter Ten 
 
216
 
 
Figure 10-2. TX-0 at MIT 
Source: www.bitsavers.org/miy/tx-0 
 
Figure 10-2 shows the Speech Research Group huddled around the 
TX-0 console. Osamu Fujimura, Hiroya Fujisaka, John Heinz, Gordon 
Bell (with his hand over his mouth) and Professor Ken Stevens watch Pete 
Brady at the TX-0 console in 1959 at MIT (Computer Museum Reports 
1984a). Table 10-1 presents the basic characteristics of the TX-0. 
 
Table 10-1. TX-0 – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal Representation 
Fixed Point Binary 
# Bits/Word 
18 
# Instructions/Word 
1 
# Instructions 
4 (2-bit opcode): extensible (see below) 
# Bits/Instruction 
18 
Instruction Type 
One Address Code 
CPU Technology 
Discrete Transistor Circuits 
CPU Registers 
Accumulator, I/O Register; Index Register 
Main Memory 
Magnetic Core: 8192 words initially, later 65, 
536 words (1958); Cycle time: 7 microseconds 
CPU Clock Rate 
Variable, but max 5 MHz; 80K IPS 
Add Time 
Fixed Point: 1.2 microseconds 

MIT’s TX-0 
 
217 
Multiply Time 
Fixed Point: 1.2 microseconds 
Divide Time 
Fixed Point: Unknown 
10.1 TX-0 System Architecture 
The TX-0 was one of the earliest computers to use a cathode ray tube 
(CRT) for interactive computation. The operator could immediately see 
the results of changes made to the program. At the time, about the TX-0 
was unique in that the operator could sit at the console and enter 
instructions to be executed immediately. In some sense, this presaged 
today’s calculators. A pastime of some of the programmers was to enter 
programs which cause interesting displays to appear on the CRT.  
It was designed and built as a memory test computer. Thus, it had an 
18-bit word with a 16-bit address field. This presented a problem in 
designing an effective instruction set as described below.  
10.1.1 TX-0 Registers 
The TX-0 used a number of internal registers to support instruction 
execution and represent the condition of the machine. Table 10-2 describes 
these registers. 
 
Table 10-2. TX-0 Machine Registers 
Register 
Size 
Description 
Memory Buffer 
Register (MBR) 
18 
Stored data being received from or 
transmitted to memory 
Accumulator (ACC) 
18 
Used for numerical operations; also as a 
buffer for I/O equipment 
Memory Address 
Register (MAR) 
16 
Held the address for the memory 
controller to access a word in memory 
Program Counter (PC) 
16 
Held the address of the next instruction 
being executed. 
Instruction Register 
(IR) 
2 
Held the opcode of the instruction being 
executed 
Live Register (LR) 
18 
Implemented using flip flops. It was used 
by the operate class commands. It could 
be updated like any other register if a 
console switch was set. 
Toggle Switch Buffer 
Register (TBR) 
18 
Used for manual intervention in the 
program. 18 toggle switches 
 
 

Chapter Ten 
 
218
Toggle Switch 
Accumulator (TAC) 
18 
Used for manual intervention in the 
program. 18 toggle switches. 
Toggle Switch Storage 
(TSS) 
16 
Sixteen registers that could replace the 
first 16 words of memory depending on a 
console switch setting. TSS registers 
could replace memory locations 
individually or as a complete block. 
 
The accumulator could be viewed as a ring adder. With the high-order 
bit representing the sign, adding one to the largest integer produced the 
smallest integer. There was no overflow checking. This feature was often 
used in decision analysis programs (Gilmore and Peterson 1958). 
10.1.2 Toggle Switch Storage 
The Toggle Switch Storage (TSS) consisted of sixteen registers that 
represented an auxiliary memory storage. These registers were located in the 
operator console. Each TSS register had 18 switches for entering data. There 
were two switches – one to the left and one to the right – which were of 
particular importance. The left switch, labeled ‘cm’, determined whether that 
register was represented in core memory or not. Similarly, the right was a 
switch labeled ‘lr’ which determined if that TSS register represented the Live 
Register or not. A master switch, CM, for Core Memory Select, determined 
whether all 16 registers were represented in core memory or TSS. This meant 
that the LR could have zero, one, or sixteen different addresses. 
10.1.3 Main Memory 
Main memory was a vacuum-tube driven magnetic core memory of 64 
KWords. It had a memory cycle of 7 microseconds. 
10.2 TX-0 Instructions 
Source: MIT 2004a 
 
The TX-0 used 16-bit addresses. This meant that two bits were left for 
the operation code. The challenge was to design a useful instruction set 
with two bits. Kenneth Olsen, in charge of the engineering group, came up 
with an innovative solution that presaged the use of instruction emulation 
and jump tables in later DEC computing machines. The four bits of the 
operation code were used as follows: 

MIT’s TX-0 
 
219 
00:  Stored the accumulator to a memory location 
01:  Added x to the accumulator 
10:  Transferred control to the location specified by the address 
11:  Operate: Use the contents of the address portion not as an address, 
but as a micro-code extension of the “operate” command. For the 
time, this provided an opportunity for a very large set of 
instructions. However, only a small fraction was ever used. 
 
Instructions were executed in two memory cycles with the instruction 
fetched in the first cycle, and the operand fetched in the second cycle. 
10.2.1 TX-0 Operate Instructions 
The Operate instructions are presented in table 10-3. 
 
Table 10-3. Operate Instructions 
Mnemonic 
Code 
Description 
CLL 
100,000 
Clear the left nine digits of the ACC 
CLR 
040,000 
Clear the right nine digits of the ACC 
IOS 
020,000 
I/O Stop: stop the machine so that an I/O 
instruction may be executed. The I/O instruction 
was specified by digits 6-8 of the MAR. 
HLT 
030,000 
Halt the computer 
P7H 
007,000 
Punch holes in positions 1-6 of a paper tape 
specified by AC digital positions 2, 5, 8, 11, 14, 
17. Also punch a seventh hole on the tape. 
P6H 
006,000 
Same as P7H except do not punch seventh hole. 
PNT 
004,000 
Print one Flexowriter character specified by 
ACC digital positions 2, 5, 8, 11, 14, 17. 
R1C 
001,000 
Read positions 1-6 of a paper tape and place into 
ACC positions 0, 3, 6, 9, 12, 15. 
R3C 
0003,000 
Read positions 1-6 of paper tape into positions 
0, 3, 6, 9, 12, 15. Then, cycle AC right and 
repeat. Then, cycle AC right and repeat. 
Equivalent to the instruction sequence CYR, 
R1C. 
DIS 
002,000 
Display: Intensify a point on the scope at 
coordinates x,y, where x was given by ACC 
positions 0-8 with position 0 as the sign and y 
was given by ACC positions 9-17 where 
position 0 was the sign. 

Chapter Ten 
 
220
SHR 
000,400 
Shift the AC one position to the right. 
CYR 
000,600 
Cycle the AC one position to the right. ACC0 <- 
ACC17. 
MLR 
000,200 
Store the contents of the MBR in the live 
register. 
PEN 
000,100 
Read light pen flip flops 1 and 2 into ACC0 and 
ACC1 
TAC 
000,004 
Insert a 1 into each position of the ACC 
wherever there was a 1 in the TAC. 
COM 
000,040 
Complement the ACC 
PAD 
000,020 
Partial add the AC to the MBR, e.g., for every 
digit of the MBR that was 1, complement the 
corresponding digit in the ACC. 
CRY 
000,010 
Partial add the 18 digits if the ACC to the 18 
digits of the Carry (see below for determining 
contents of Carry)* 
AMB 
000,001 
Store the contents of the ACC in the MBR 
TBR 
000,003 
Store the contents of the TBR in the MBR 
LMB 
000,003 
Store the contents of the LR in the MBR 
* The contents of the Carry were determined as follows: “Grouping the AC and 
MBR digits into pairs, and proceeding from right to left, assign the carry digit of 
the next pair to be one if in the present pair MBR = 1 and AC = 0, or in the present 
pair AC = 1 and Carry = 1”. (Gilmore and Peterson 1958) 
 
Gilmore and Peterson noted that there was no Cycle Left command 
because this was equivalent to AMB, PAD, CRY. Numerous other 
combinations were possible that yielded additional instructions. 
10.2.2 Combining Instructions 
Combinations of operate commands were used to implement further 
instructions. Table 10-4 presents these useful combinations. Some of these 
were not given symbolic names, but were recognized as idioms by the 
assembly language programmers. 
 
Table 10-4. Useful Combinations of Operate Commands 
Mnemonic 
Code 
Description 
CLA 
140,000 
Clear the ACC. Equal to CLL + CLR. 
CYL 
000,031 
Cycle Left the AC one digit position. Equal to 
AMB + PAD + CRY. 
 
 

MIT’s TX-0 
 
221 
CLC 
140,040 
Clear and Complement the ACC. Equal to CLL 
+ CLR + COM. 
DIS 
022,000 
Display. Demonstrated that every I/O command 
must have an IOS command. 
 
160,000 
I/O Stop with ACC Cleared. Equal to IOS + 
CLL + CLR. 
 
027,600 
Punch 7 holes and Cycle ACC Right. Equal to 
IOS + P7H + CYR. 
 
026,600 
Punch 6 holes and Cycle ACC Right. Equal to 
IOS + CLL + CLR + P6H. 
 
024,600 
Print and Cycle ACC Right. Equal to IOS + 
PNT +CYR. 
 
027,021 
Punch 7 holes and leave ACC Cleared. Equal to 
IOS + P7H + AMB + PAD. 
 
026,021 
Punch 6 holes and leave ACC Cleared. Equal to 
IOS + P6H + AMB + PAD. 
 
024,021 
Print and leave ACC Cleared. Equal to IOS + 
PNT + AMB + PAD. 
 
141,000 
Clear AC and leave petr running. Equal to CLL 
+ CLR + RIC. 
 
001,031 
Start petr and cycle ACC left. Equal to RIC + 
AMB + PAD +CRY. 
 
001,600 
Start petr running and cycle right. Equal to RIC 
+ CYR. 
 
163,000 
Clear ACC. Read 3 lines of tape. Equal to CLL 
+ CLR +R3C +IOS. 
 
161,000 
Clear ACC and read one line of tape. Equal to 
CLL +CLR + IOS + RIC + PAD + CRY 
 
161,600 
Read one line of tape and cycle right. 
 
140,004 
Put contents of TAC in ACC. Equal to CLL + 
CLR + TAC.  
 
000,030 
ACC <- c(MBR) + c(ACC). Equal to PAD + 
CRY. 
LAC 
140,022 
Clear ACC. MBR <- c(LR. ACC <- c(MBR). 
Equal to CLL = CLR + IMB + PAD. 
ALR 
000,201 
Store contents of ACC in MBR. LR <- c(MBR). 
Equal to AMB + MLR. 
LPD 
000,022 
MBR <- c(LR). Partial add c(MBR) + c(ACC) -
> ACC. 
MLR 
000,200 
Clear LR. 

Chapter Ten 
 
222
LAD 
000,032 
Full add LR to ACC. ACC <- c(LR) + c(ACC). 
 
140,023 
Store contents of TBR in ACC. Equal to CLL + 
CBR + TBR + PAD. 
10.2.3 Modified Instruction Set 
Source: MIT 1960b 
 
The TX-0 was later modified to include new registers and additional 
instructions. It added both an 18-bit index register and a program flag 
register. In the following instructions, x indicates the index register. 
 
Table 10-5. Modified TX-0 Instructions 
Mnemonic 
Code 
Description 
STO y 
000000 
Store y: y <- c(ACC) 
STX y 
020000 
Store ACC, indexed: y + c(x) <- c(ACC) 
SXA y 
040000 
Store index in Address: y <-x 
ADO y 
060000 
Add One: y <- c(y) + 1 
SLR y 
100000 
Store LR: y <- c(LR) 
SLX y 
120000 
Store LR, Indexed: y + c(x) <- c(LR) 
STZ y 
140000 
Store Zero: y <- 0 
ADD y 
200000 
Add contents of register y to ACC 
ADX y 
220000 
Add, Indexed:  
LDX y 
240000 
Load Index: x <- c(y). 
AUX y 
260000 
Augment Index 
LLR y 
300000 
Load LR: ACC < c(LR) 
LLX y 
320000 
Load LR, Indexed 
LDA y 
340000 
Load Accumulator: ACC <-c(y) 
LAX y 
360000 
Load Accumulator, Indexed: ACC <- c(y+c(x)) 
TRN y 
400000 
Transfer on Negative ACC: if c(ACC) < 0, PC 
<- y. 
TZE y 
420000 
Transfer on Zero: if c(ACC) = 0, PC <-y 
TSX y 
440000 
Transfer and Set Index: x <- c(PC), PC <- y 
TIX y 
460000 
Transfer and Index 
TRA y 
500000 
Transfer: PC <- y 
TRX y 
520000 
Transfer, Indexed 
TLY y 
540000 
Transfer on External Level 

MIT’s TX-0 
 
223 
10.3 Operating Modes 
The TX-0 could operate in either Normal Mode or Test Mode. These 
modes were selected by a push button on the operator’s console. It was 
implemented to assist engineers and operators in diagnosing system 
problems. 
When test mode was activated, the first two digits (opcode) were sent 
to the IR and the last 16 digits were sent to the MAR. The PC was 
incremented by one and the instruction was executed. 
This mode could be modified by the repeat and step switches which 
were also located on the operator’s console. The repeat switch caused the 
instruction to be executed over and over again, while the step switch 
incremented the address section by one each time the instruction was 
executed. 
In Normal mode, the operator could push the Read-In button on the 
operator’s console. This button caused the paper tape reader to be 
activated and any paper tape to be read into memory.  
The TX-0 had three modes of operation: normal, test, and read-in. The 
four instructions executed different functions in each of the three modes. 
Table 10-6 describes the values and source of instructions. 
 
Table 10-6. Operating Modes 
Mode 
R 
T 
Instruction Source 
Normal 
0 
0 
Program 
Test 
0 
1 
Toggle Switch Buffer Register (TBR) 
Read-In 
1 
1 
Paper Tape 
 
In Normal mode operation, the four opcodes selected the following 
instructions. X was a memory address. 
 
 
Opcode 
Instruction 
Description 
 
00 
sto x 
x <- c(AC) 
 
01 
add x            AC <- c(AC) + c(x) 
 
10 
trn x 
if sign(Ac) = 1, PC <- c(x); 
 
 
 
else PC <- PC + 1 
 
11 
opr x 
Execute one of the operate class commands 

Chapter Ten 
 
224
10.4 TX-0 I/O Equipment 
The TX-0 had simple I/O equipment. A Ferranti photoelectric paper 
tape reader for data input and a corresponding paper tape punch were used 
for input and output. 
The operator could set one or more of 16 toggle switches on the 
console. When a switch was set, it was registered as a bit in the Toggle 
Switch Accumulator (TAC), which could be read by an instruction. 
For output, the TX-0 had a 12.5 inch CRT oscilloscope that displayed 
511 points by 511 points in a 8-inch by 7-inch array and a standard Friden 
Flexowriter . 
On the operator console were two pushbuttons, labeled R and T, which 
were used to select either the Read-In or Test modes of operation. 
10.5 FLIT 
FLIT, the Flexowriter Interrogation Tape, was a program for 
performing symbolic debugging on the TX-0. It was written for the 
Flexowriter, which was a typewriter-like device used for input and output 
on the TX-0. FLIT was named after a substance available for household 
use to get rid of flies. It was written by Jack Dennis at the urging of 
Thomas Stockham (Computer Museum Reports (b)).  
The symbol table generated by the assembly program was loaded into 
the debugger. The debugger could then be commanded to read through the 
program in terms of the symbolic addresses and symbolic instruction 
codes. It was documented in memorandum M-5001-23 available at 
http://bitsavers.informatik.uni-stuttgart.de/pdf/mit/tx-0/memos/M-5001-
23_FLIT_Jun60.pdf. 
FLIT allowed the operator to insert breakpoints into a program and then 
execute it. The debugger would take over control whenever a breakpoint 
was reached, at which time the operator could interrogate the state of a 
program and decide whether to go on or not. Since many programmers 
wanted to debug programs using the CRT display, the character tables could 
not be stored in memory. So, Stockham introduced the idea that whenever 
the user types something that was in error, the program would tell him about 
it by typing a red question mark. But, this often occurred while the user was 
still typing, which necessitated many repairs to the Flexowriter due to 
jamming. Full-duplex communication was in the future. 
FLIT was a large program. It could not be used to debug itself, so 
Dennis wrote a program called MicroFLIT which he used to debug FLIT. 
FLIT influenced the design of DDT (Dynamic Debugging Tool) for the 

MIT’s TX-0 
 
225 
PDP-1 and later generations of DEC computers (Computer Museum 
Reports 1984b). 
10.6 TX-1 
There was no TX-1. Wesley Clark remarked that “We don’t build odd 
computers” (Computer Museum Reports 1984b). 
10.7 TX-2 
Source: MIT 1957d 
 
The TX-2 was the successor to the Lincoln TX-0. Once the TX-0 was 
successfully completed, the Lincoln engineers were ready to take the next 
step to a full 36-bit computing machine (Clark 1957). 
It was a transistor-based machine that had 64KWords of 36 bits of core 
memory. All of the circuits of the TX-2 were built using flip-flops and 
inverters. This experience would serve Olson well when he founded 
Digital Equipment Corporation to design and build FlipChip modules. 
(Olson 1957) During the mid-1960s, hardware modifications were 
performed to support multiprogrammed timesharing. Table 10-7 describes 
the basic characteristics of the TX-2. 
 
Table 10-7. TX-2 – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal Representation 
Fixed Point Binary 
# Bits/Word 
36 
# Instructions/Word 
1 
# Instructions 
 
# Bits/Instruction 
36 
Instruction Type 
One Address 
CPU Technology 
Transistors and Diodes 
CPU Registers 
64 index registers 
Main Memory 
“T” Memory: 4096 words, magnetic core w/ 
transistor drivers; “S” memory: 65K Words, 
magnetic core w/ vacuum tube drivers 
Auxiliary Memory 
Magnetic Tape Subsystem 
Add Time 
Fixed Point: ~6.6 microseconds 
Multiply Time 
Fixed Point: ~12.5 microseconds 
Divide Time 
Fixed Point: Unknown 

Chapter Ten 
 
226
10.7.1 TX-2 System Architecture 
Source: MIT 1961g 
 
The TX-2 was a much larger machine than the TX-0. It had about 
22,000 transistors. The TX-2 design was focused on I/O efficiency. I/O 
controllers were given direct access to memory. Separate program 
counters were maintained for controlling I/O using the main processor. 
This was a precursor to Direct Memory Access (DMA). This philosophy 
was continued in the DEC machines (and later Motorola microprocessors, 
among others) where memory-mapped registers were used to control I/O. 
To this day, there were two approaches to I/O: memory-mapped registers 
with no special instructions versus I/O specific instructions accessing 
discrete registers (Intel) or separate processors (IBM). 
The TX-2 ALU had parallelism built in. Its 36-bit ALU could be 
partitioned into configurations such as 4 x 9, 2 x 18, 1 x 36 or even one 9-
bit and one 27-bit ALU operating concurrently. It also provided separate 
adders for indexing and incrementing the program counter. (Johnstone 
1992) 
The TX-2 tape system implemented a block-addressable format that 
later became the basis for LINCtape and DECtape. The tape system 
consisted of 10 tracks spread across a 0.5-inch tape. Five tracks constituted 
a channel: three information, one timing and one block mark. The two 
channels provided redundancy and were simultaneously read and written 
by the tape system hardware.  
The reader can examine examples of TX-2 programming (MIT 1958f) 
which provides some interesting insights into the care and exactitude 
required to effectively program the TX-2. 
The TX-2 Users Handbook provides a detailed discussion of the 
instruction set and numerous examples of how the instructions could be 
used to partially solve problems (MIT 1961e). 
The TX-2 was finally decommissioned and dismantled in 1977. Figure 
10-3 depicts the system architecture for the TX-2. 
 

MIT’s TX-0 
 
227 
 
 
Figure 10-3. TX-2 System Architecture 
Source: Adapted from Fadiman 1958 
10.8 TX-0 and TX-2 Assessment 
The TX-0 was designed as a test computer, but evolved into a useful 
problem-solving machine. It was a transistorized version of the MIT 
Whirlwind. But, whereas the Whirlwind had occupied an entire floor of a 
building, the TX-0 fit comfortably into a large room. It pioneered several 
innovations in computing architecture and was the basis for the DEC PDP-
1 computer. The TX-0 became operational in 1956 and was used almost 
continuously until the early 1970s. 
The TX-0 was extensively documented through a series of over 50 
memoranda written between 1958 and 1966. which can be obtained from 
http://bitsavers.informatik.uni-stuttgart.de/pdf/mit/tx-0/memos/. 
The TX-0 was used to implement several early video games such as 
“Mouse in the Maze” and “Tic-Tac-Toe” and begat “Spacewar” on the 
PDP-1, thus spawning a creative surge amongst programmers that evolved 
into a multibillion dollar industry within the U.S. alone. William Daley, Jr. 
wrote his Master’s Thesis “Computer Strategies for the Game of Cubic” 

Chapter Ten 
 
228
based on a program he wrote for the TX-) in 1961 (http://bitsavers.trailing-
edge.com/pdf/mit/tx-0/Daly_Thesis_Feb61_Cubic/mastersthesis.pdf). 
These were some of the earliest examples of games being played on a 
computer system but, who knew that it would evolve into the gaming 
industry that we have today. 
The Operate instruction of the TX-0 used bit coding to select one of 
many different subintructions such as `clear right half of accumulator' and 
`shift right'. This scheme was used in many of the early PDP computer 
systems up to and including the PDP-8 to make the best use of a small 
word size and limited memory. 
Early computer consoles were often criticized as being homely. Ken 
Olson took such criticism into account while designing the TX-0 and spent 
hours in stores examining the user interfaces of many home appliances. At 
this time, many appliances boasted mechanical and electrical interfaces, 
rather than the windows-based software we use today). One result was that 
many of his systems up to the VAX-11/780 included electrical toggle 
switches for data entry and display (Johnstone 1992). 
The TX-2 was used by Ivan Sutherland to develop Sketchpad, the basis 
for his Ph.D. thesis (Sutherland 2003). Sketchpad was a graphical 
communication system that used a CRT and a light pen to allow the user to 
draw diagrams on the CRT. Various programs interpreted this information 
and used it to direct the computer to perform certain tasks. This was, 
perhaps, the first graphical user interface. 

CHAPTER ELEVEN 
PHILCO FORD COMPUTERS 
 
 
 
Philco Corporation, formerly the Philadelphia Storage Battery 
Corporation, was a pioneer in the early development and manufacturing of 
radio and television sets. At one time, it had employed Philo Farnsworth, 
the inventor of the television tube. In 1960, NASA contracted with Philco 
to build the world-wide tracking station network for Project Mercury and 
subsequent manned space ventures. Philco began building computers as 
part of this effort. 
In 1961, Philco was acquired by Ford Motor Company. Philco 
pioneered the development of high-speed transistors for computing 
systems. Its engineers invented the Surface Barrier Transistor. Its C-series 
of computer systems were designed for closed loop control systems where 
the input and output were handled through A/D and D/A converters. The 
C-3000, the most popular model, was developed for Leeds and Northrup 
for industrial process control. The Philco 1000 was built for a special 
government agency. 
The Philco 2000 began as a computer for the Navy Bureau of Ships, 
known as “CXPQ”. Philco also developed several medium-sized 
machines, known as BASICPAC, for the Signal Corps Engineering 
Laboratories at Fort Monmouth, New Jersey (Philco 1968h). The first 
model, 210, was delivered to Ford Motor Company’s Western 
Development Labs in Mountain View, CA. It was the only instance of the 
Model 210 as newer and better Micro-Alloy Diffusion Transistors 
(MADTs) had been developed that offered better reliability and 
performance (Rosen 2004). MADTs were used in the design and 
development of Model 211. The first Model 211 was delivered to United 
Aircraft in Hartford, CT. Several more models were delivered to Defense 
contractors.  
When IBM announced the IBM 7090 with 2 microsecond memory, the 
S-2000’s 10 microsecond memory looked meager by comparison. Philco 
acquired 2 microsecond memories from Ampex Corporation for use in the 
Philco 212, the last model of the S-2000. The first Model 212 was 

Chapter Eleven 
 
230
delivered in early 1963. Several of the early machines replaced Model 
211s at Defense contractors. 
In 1966, Ford renamed the division Philco Ford, but later renamed it to 
Ford Aerospace Corporation. In 1962, its Transac S-2000 computer 
system was selected for use in the North American Aerospace Defense 
Command’s Cheyenne Mountain facility. Three of these systems remained 
operational at the facility until the early 1980s. By the mid-1960s, Philco 
Ford had designed a Model 213, but none were ever built (Bright 1964). 
But, Ford decided that it did not want to compete against IBM in the 
manufacture of large digital general purpose computer systems (Rosen 
2004). It closed the computer division in 1965. 
Philco was famous for manufacturing electronic appliances, radios and 
televisions. Its Government and Industrial Division (GID) conducted 
research projects for the U.S. Government. GID was one of the first 
companies to develop a commercially viable transistor in 1954.  
11.1 Philco 1000 
According to Rosen (2004), the National Security Agency (NSA) 
contracted with Philco to develop a high-speed computer system to 
support its cryptographic and other security work using Surface Barrier 
Transistors (SBT)s. The Philco 1000, also called the Transac S-1000, was 
an early transistorized computer. The Philco 1000 could have one or two 
central processing units – one of the first computers to be so configurable. 
Table 11-1 presents the major characteristics of the Philco 1000 (Weik 
1961, Philco 1962b). 
 
Table 11-1. Philco 1000 – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal 
Representation 
Fixed Point Binary, Binary Coded Decimal – 1’s 
Complement 
# Bits/Word 
36 
#Instructions/Word 
2 
# Instructions 
225  
#Bits/Instruction 
24 
Instruction Type 
Two Address 
CPU Technology 
Transistors 
CPU Registers 
Accumulator: 72 bits; Multiplier/Quotient 
Registers: 36 bits; Program Control Register – 36 
bits; Program Address Register; Exchange (X) 
Register; memory Address Register – 13 bits 

Philco Ford Computers 
 
231 
Main Memory 
Magnetic Core: 4 KWords 
Magnetic Drum: 32K-1MWords 
Add Time 
Fixed Point Binary: 5.5 microseconds 
Multiply Time 
Fixed Point Binary: 130 microseconds 
Divide Time 
Fixed Point Binary: 200 microseconds 
11.1.1 Philco 1000 Central Processor 
The Philco 1000 central processing unit structure is depicted in Figure 
11-1. It was influenced by the Engineering Research Associates UNIVAC 
1103 computer system. 
 
 
 
Figure 11-1. Philco 1000 Central Processing Unit Structure 
Source: Adapted from Philco 1962b 

Chapter Eleven 
 
232
11.1.2 Philco 1000 System Architecture 
The Philco 1000 was implemented with direct-coupled transistor 
circuits. It contained over 7000 transistors, plus some resistors, and 
capacitors all of which were placed on 132 wiring boards. 
The accumulator was a 72-bit register which was capable of handling 
double precision multiplication without destroying the contents of the 
multiplier register.  
The Transac Philco 1000 CPU used five control units to perform 
computations. The basic idea was that each control unit performed its 
function well and routed signals to other units when it needed their 
services (Maddox, OToole and Wong 1956). 
 
1. Program control: The program control unit was responsible for 
sequencing the instructions of the program, and initiating the 
instruction control. 
2. Repeat control: The repeat control modified the two addresses of an 
instruction that was being repeated. It was also responsible for 
determining the number of times the repeated instruction had been 
executed. 
3. Instruction control: The instruction control was responsible for 
managing operands and results that were processed by the 
arithmetic or input-output controls. 
4. Arithmetic control: The arithmetic control sequenced the clearing 
and transfer operations of the arithmetic section to perform: 
addition, subtraction, multiplication, division, shifting. 
5. Input-output control: The input-output control acted as a buffer 
between the computer and input-output devices. 
11.1.3 Instruction Set 
Instructions were grouped into three categories. Each instruction was 
36 bits in length. The format of the instructions is presented in Figure 11-
2. 
 
 
 
Figure 11-2. TRANSAC Philco 1000 Instruction Format 

Philco Ford Computers 
 
233 
U and V were usually memory addresses. However, in some 
instructions V was the number of places the operand should be shifted. S 
and T were modifiers of the memory addresses.  
11.2 Philco TRANSAC S-2000 
Source: Philco 1958e 
 
The Philco Corporation’s TRANSAC S-2000 was one of the first 
commercially transistorized mainframe computer systems. TRANSAC 
stood for Transistorized Automatic Computer. The S-2000 series were 
general-purpose computer systems built for scientific, business, and real-
time processing (Philco 1958j). They were intended to be faster than the 
IBM 704 and 708 and compete with the follow-on systems – the IBM 
7000 series (Rosen 2004). They also could accommodate different central 
processor models. Figure 11-3 presents a 1959 advertisement for the 
Philco S-2000 
The TRANSAC S-2000 was initially built using Philco Ford’s surface 
barrier transistor (SBT) technology. However, the performance of the SBT 
technology did not yield the desired reliability and performance, so Philco 
switched to field effect transistor (FET) technology with the model 211. 
Philco executives thought that transistor technology would give them a 
significant advantage over IBM’s vacuum tube technology in the late 
1950s. But, as Rosen (2004) noted: “they … underestimated the resources 
that would be needed for a profitable incursion into the large-scale 
computer field”. Philco hired Morris Rubinoff, who had worked on the 
IAS design, to develop the new TRANSAC S-2000. 
The S-2000 was delivered in three models: the Model 210 with SBT 
technology, the Model 211 with MADT technology, and the Model 212. 
Figures 11-3 and 11-4 depict two advertisements for the Philco S-2000 
computer system. 
 
 

Chapter Eleven 
 
234
 
 
Figure 11-3. Philco S-2000 Advertisement 
Source: Philco Ford Corporation UNK 
 

Philco Ford Computers 
 
235 
 
 
Figure 11-4. Philco TRANSAC S-2000 Advertisement 
Source: Philco Ford Corporation UNK 
 
Figure 11-5 depicts a Philco 210. Figure 11-6 depicts another view of 
the Philco TRANSAC S-2000. 

Chapter Eleven 
 
236
 
 
Figure 11-5. Philco 210 System 
Source: Weik 1961 
 
 
 
Figure 11-6. Philco S-2000 Computer System 
Source: Philco Ford Corporation UNK  

Philco Ford Computers 
 
237 
A base system with 32 KWords of magnetic core and 16 tape drives 
and controller rented for about $67,000 per month. To this, one had to add 
card reader/punches and printers priced at $9,000 per month. Table 11-2 
presents the major characteristics of the TRANSAC S-2000 (Weik 1961, 
Philco 1958j). 
 
Table 11-2. TRANSAC S-2000 – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal 
Representation 
Fixed Point Binary, Floating Point Binary, Binary 
Coded Decimal 
# Bits/Word 
48 
#Instructions/Word 
2 
# Instructions 
225 (Model 212) 
#Bits/Instruction 
24 
Instruction Type 
One Address 
CPU Technology 
Transistors 
CPU Registers 
Accumulator: 48 bits 
3 Registers: 24 bits 
32 Index Registers: ?? bits (Optional) 
Main Memory 
Magnetic Core: 
Model 2200: 4K-65Kwords - 10 microseconds 
access time 
Model 2100: 4K-65Kwords - 2 microseconds access 
time  
Magnetic Drum: 32K-1MWords 
Add Time 
Fixed Point: 1.7 microseconds; Floating Point: 8 
microseconds 
Multiply Time 
Fixed Point: 40.7 microseconds; Floating Point: 22 
microseconds 
Divide Time 
Fixed Point: 43 microseconds; Floating Point: 22 
microseconds 
 
Only the first TRANSAC S-2000, a model 210, had a magnetic drum 
attached to it. It was shipped to Philco Ford’s Western Development 
Laboratories in Palo Alto, California. Thereafter, the magnetic drum 
disappeared from the product line (Rosen 2004). At the time, magnetic 
tapes units were considered more reliable and their usage as secondary 
storage was well understood. 
The Operator Control Panel of the TRANSAC S-2000 is depicted in 
Figure 11-7.  

Chapter Eleven 
 
238
 
 
Figure 11-7. TRANSAC 2000 Operator Control Panel 
Source: Philco 1958e 
11.3 TRANSAC S-2000 System Architecture 
The TRANSAC S-2000 processor registers are described in table 11-3. 
Depending on the size of the core memory configured with the system, 12, 
13, or 15 bits were used to address memory. 
 
Table 11-3. TRANSAC S-2000 Processor Registers 
Register 
Size 
(bits) 
Description 
Program Register 
(PR) 
48 
Held the current instruction being 
executed. Composed of two 24-bit 
instruction words, labeled I0 and I1. 
SW2 
1 
Determined which instruction word was 
being executed: when SW2 = 0, I0 was 
being executed, otherwise I1. 
Memory Address 
Register (MA) 
15 
Held the address portion of the instruction 
being executed. 
Index Registers 
(IR) 
15 
Up to 32 registers organized in groups of 
four. 
Program 
Address 
Register (PA) 
15 
Held the address of the next instruction 
word (48 bits). 
Jump Address 
Register (JA) 
12 
Held the address of the next instruction to 
be performed in a normal sequence. Thus, 
a program could transfer to another address 
via a jump, and then return by using the 
Jump Address Register contents. 

Philco Ford Computers 
 
239 
Repeat Register 
(RR) 
6 
The format of RR is depicted below. It 
controlled the execution of repeat 
instructions. 
Repeat Counter (N) 
12 
Controlled the number of repetitions 
Core Memory 
Address (CMA) 
15 
Stored address for paper tape, magnetic 
drum, and printer access to memory. 
Data Registers: A, 
D, Q 
48 
Handled data during instruction execution. 
Each had a complementary register – A*, 
D*, Q* - for extended operations. 
 
The format of the Repeat Register is depicted in Figure 11-8. 
 
 
 
Figure 11-8. TRANSAC S-2000 Repeat Register Format 
Source: Adapted from Weik 1961 
 
 
where: 
 
 R=1 
indicated repeat mode operation 
 
 I  
indicated whether one or a pair of instructions was 
 
   
being repeated 
 
 DEJG 
specified the type of repeat 
11.3.1 Secondary Memory 
The secondary memory on the TRANSAC S-2000 was a suite of 
magnetic tape units. Philco chose the Ampex FR-300 tape drive because of 
Ampex’s success in developing magnetic tape technology for the 
television industry. The FR-300 could transfer up to 90,000 characters per 
second. The tape was 1-inch wide with two 6-bit characters stored per 
frame. Data was recorded in fixed-length blocks with block begin and 
block end patterns surrounding each block. While the initial idea was to be 
able to access blocks on the tape by known position, this did not appear to 
work very well. Considerable time was spent in preparing blank tapes for 
use by pre-recording the block start and block end markers. 
The magnetic tape control unit was implemented as a crossbar switch. 
It could have 16 magnetic tape drives attached to it and could connect any 
four of these drives to four channels which were directly connected to 

Chapter Eleven 
 
240
main memory. However, as Rosen (2004) notes, only a few 4-channel 
controllers were built and most had only two channels.  
Problems with the tape drives and the tape controller meant that Philco 
Ford was late in its deliveries of S-2000 to its customers. When Ampex 
delivered the improved TM-2 tape drives, system reliability and 
performance was improved. However, they required considerable 
preventative maintenance in order to ensure system operability. 
While tapes could be written only in the forward direction, they could 
be read in either the forward or backward direction. This was deemed 
essential to tape-based sorting programs. Based on the sorting algorithm 
several tape units were assigned to the sorting program. They were divided 
into two groups. At each pass, the data on the first set of tapes was sorted 
and merged into longer files on the second set of tapes. The roles of the 
two groups were reversed and the process continued until a single tape 
contained all of the data. The backward reading capability meant that no 
time was lost in rewinding all of the tapes (Rosen 2004). 
11.4 TRANSAC S-2000 Instruction Set 
Source: Philco 1958e, Philco UNKa 
 
The S-2000 instruction consisted of six groups of instructions. Each 
instruction group had an associated control register. The left-most 16 bits 
of each instruction had the following format as shown in Figure 11-9. 
 
 
 
Figure 11-9. TRANSAC S-2000 Instruction Address Format 
Source: Weik 1961 
 
The R field indicated the computation of the effective address. If zero, 
the instruction furnished the effective address, i.e., bits 1-15. If R = 1, the 
effective address was computed by adding the Iv field contents to the 
contents of the specified index register, IA. The IA and Iv fields varied in 
length depending on the number of index registers installed into the central 
processor. The number of registers and the length of the IA field were 
hardwired in the computer. In Figure 11-9, we depict IA as 5 bits 
indicating a maximum of 32 index registers. If IA had a length of just 2 

Philco Ford Computers 
 
241 
bits, then the minimum number of four index registers was configured. 
After the IA field length was set, the Iv field used the remaining bits. 
A discussion of the instruction set is presented in section 11.5.8 for the 
Philco 212, the third model of the S-2000 family. 
11.4.1 Program Control 
This group of instructions controlled program sequencing. They 
included transfer of the instruction word from the memory to the program 
register, selection of the instruction to execute, and index register 
modification. The Program Control Register (PI) consisted of 2 bits whose 
values were interpreted as follows: 
 
PI = 0 
Perform the next instruction 
PI = 1 
Transfer the next instruction word to PR 
PI = 2 
Modify an index register 
PI = 3 
Count down repeat register 
11.4.2 Instruction Control 
This group of instructions set up conditions for the execution of other 
instructions. The Instruction Control Register (II) consisted of 1 bit whose 
values were interpreted as follows: 
 
II = 0 
normal control state for most instructions 
II = 1 
multiply cycle of multiply then add or subtract 
instructions 
11.4.3 Algorithm Control 
This group consisted of the arithmetic operations. The Algorithm 
Control Register (AI) consisted of 3 bits interpreted as follows: 
 
AI = 0 
force add in multiplication 
AI = 1 
add or subtract 
AI = 2 
double length multiplication 
AI = 3 
single length multiplication, rounded 
AI = 4 
fixed point division, first cycle 
AI = 5 
fixed point division, other than first cycle 
AI = 6 
shift 
AI = 7 
Q jump 

Chapter Eleven 
 
242
11.4.4 Floating Point Control 
This group of instructions performed manipulations of data prior to and 
after the execution of arithmetic operations. The Floating Point Control 
Register (FI) consisted of 3 bits that were interpreted as follows: 
 
FI = 0 
arrange first cycle (beginning of add or subtract) 
FI = 1 
exponent 
addition 
or 
subtraction 
(beginning 
of 
multiplication or division) 
FI = 2 
shift D (arrange D since DE < AE) 
FI = 3 
shift A (arrange A since DE > AE) 
FI = 4 
normalize (following arithmetic operation) 
FI = 5 
correction (before if division; following if addition, 
subtraction or multiplication) 
FI = 6 
clear D (DE << AE) 
FI = 7 
clear A (DE >> AE) 
 
Floating point numbers had a 12-bit exponent and a 36-bit mantissa. 
11.4.5 Memory Cycle Control 
This group controlled the transfer of information to and from core 
storage. The Memory Control Register (MI) consisted of 3 bits whose 
values were interpreted as follows: 
 
MI = 0 
memory not being used by computer 
MI = 1 
(M) -> PR -> M [read and write PR] 
MI = 2 
(M) -> D [read D] 
MI = 3 
(D) -> M [write D] 
MI = 4 
(M) -> D -> M [read and write D] 
MI = 5 
clear M, (D) -> M [ read 0, write D] 
MI = 6 
clear M [read and write 0] 
MI = 7 
clear M [read 0] 
11.5 Philco 212 
The Philco 212 was the third model of the S-2000 transistorized 
computer. It had been preceded by the Philco 210 and Philco 211, which 
were largely experimental models. It seems only a few of these were 
actually delivered before Philco closed its computer division (Philco 

Philco Ford Computers 
 
243 
1968g). Figure 11-10 depicts an advertisement for the Philco 212 that ran 
in Scientific American in March 1963. 
 
 
 
Figure 11-10. Philco 212 Advertisement 
Source: Philco Ford Corporation 1963 

Chapter Eleven 
 
244
Figure 11-10 presents a Philco 212 configuration. A Philco 1000 could 
be interfaced to the I/O Channel to connect to the low-speed peripherals 
and relieve the Philco 212 from handling these peripherals. 
 
 
 
Figure 11-11. Philco 212 System Configuration 
Source: Adapted from Philco Ford 1968g 
 
Main memory was configured as either 32K or 64K words of magnetic 
core. A Philco 212 could be configured with up to 64 magnetic tape units. 
Weik (1961) notes that only four systems had been built as of 1961. 
The Accounting Clock System, which was part of the Real Time 
System, was used to transmit the date and time to memory whenever a 
program requested it. A set of switches allowed the operator to set the 
current date and time. It automatically corrected for the number of days 
per month. An additional switch was used to indicate a leap year. It was 
connected to the I/O Control Unit through a special interface that it shared 
with the On-Line Paper Tape System. 

Philco Ford Computers 
 
245 
The On-Line Paper Tape System (PTR) provided a means for reading 
programs and data into the Philco 212. It could read punched paper tape at 
a rate of 1000 cps. 
11.5.1 Control Unit 
The Philco 212 Control Unit consisted of an Instruction Unit, an Index 
Unit, an Arithmetic Unit, and a Store Unit. These semi-independent units 
allowed a degree of parallelism to occur in executing instructions. Figure 
11-12 depicts the structure of the Philco 212 central processor (Philco 
1968g). 
 
 
 
Figure 11-12. Philco 212 Central Processor 
Source: Adapted from Philco 1968h 
11.5.2 Instruction Unit 
The Instruction Unit (IU) accessed memory to acquire instructions for 
execution. It could store up to four instructions until they could be 
accepted by the Index Unit. A pair of instructions was read from memory 
into the Program Buffer, PR*. When both instructions in the Program 

Chapter Eleven 
 
246
Register had been presented to the Indexing Unit for processing, the 
contents of PR* were transferred to the Program Register. The contents of 
the Program Address Register (PAR) were transferred to the Address 
Buffer, PA*. PA* was incremented and its content stored back in the PAR. 
at which time another memory request was initiated.  
11.5.3 Index Unit 
The Index Unit (XU) decoded an instruction and performed operand 
resolution. If the XU attempted to decode an instruction whose opcode 
was invalid, it displayed the invalid opcode on the operator’s console and 
halted the machine. 
When an instruction was loaded into the XU Instruction Register (IR), 
it was analyzed to determine whether an effective address was required or 
not. If an Index Register (XR) was to be used, its contents were transferred 
to an Index Register Buffer (XRB). The contents of the XRB were then 
added to or subtracted from the instruction address. This value was then 
transferred to the Operand Address Register. 
If an operand was required, a memory request was generated and the 
operand stored in the Operand Register. These actions were performed 
while the Arithmetic Unit was executing the previous instruction. 
The XU supported eight index registers that allowed full accessibility 
to the largest physical memory. Data was transferred between the index 
registers and the D register of the Arithmetic Unit or could be loaded from 
the instruction itself. Each index register had two bits – the C-bit and the 
Y-bit – which affected how the effective address (EA) was formed. Table 
11-4 presents the effect of the C- and Y- bits. 
 
Table 11-4. Effective Address Calculation 
C 
Y 
Description 
0 
0 
EA = c(V field) + c(XRi), where i = 0,.,7. The TXCZ 
instruction set the bits to perform this calculation. 
1 
0 
EA = c(V field) + c(XRi), where i = 0,.,7. The TXCS 
instruction set the bits to perform this calculation. 
Afterwards, XRi = c(XRi) + 1. 
0 
1 
EA = c(XRi) , where i = 0,.,7. The TYXZ instruction set 
the bits to perform this calculation. Afterwards, XRi = 
c(XRi) + 1. 
1 
1 
EA = c(XRi) , where i = 0,.,7. The TYXS instruction set 
the bits to perform this calculation. Afterwards, XRi = 
c(XRi) - 1. 

Philco Ford Computers 
 
247 
The XU checked to see if the operand address it generated referred to 
an operand that was being used by another unit. For example, if the AU 
was modifying an operand, the XU delayed processing its instruction until 
the result was stored by the SU to avoid interaction. Another example 
occurred when a conditional jump instruction was presented to the AU. 
Since the XU was processing the following instruction, which might or 
might not be executed, the XU delays the modification of any XR until it 
had determined whether the jump wouldl be taken or not. If the Jump was 
performed, no reconstruction of registers had to be performed (Philco 
1968h). 
11.5.4 Arithmetic Unit 
The Arithmetic Unit (AU) received instructions and operands from the 
XU, executed those instructions, and transferred results to the Store Unit. 
The AU had four addressable registers as described in table 11-5. 
 
Table 11-5. Philco 212 Addressable Registers 
Register 
Size 
(bits) 
Description 
Accumulator 
(A) 
48 
A register that was used in arithmetic and 
comparison operations. 
Data 
Register (D) 
48 
A register that received all data transferred to 
and from memory and between the other AU 
registers, and was used in arithmetic and 
comparison operations. 
Quotient 
Register (Q) 
48 
A register used in multiplication and division, in 
comparison operations, as a mask register for 
certain operations, and as a status register for 
certain I/O devices. 
Jump 
Address 
Register (JA) 
12 
A register that recorded the location following a 
Jump instruction so that a return to that location 
after executing a subroutine could be performed. 
Every jump instruction, except JL and JR, 
automatically recorded the next location in the 
JA register. 
 
The A, D, and Q registers were duplicated in the Philco 212 CPU. At 
any instant, the processor knew which pair of registers was being 
addressed. For example, if the number in A was to be shifted, it was sent 
through the shifter to the other accumulator. The AU also had its own 

Chapter Eleven 
 
248
Instruction Register which it used to decode the instruction and set up the 
control signals for executing the instruction.  
11.5.5 Store Unit 
The Store Unit, Model 2100 memory, was a 2 microsecond core 
storage system which could be configured with 8K, 16K, or 32K words in 
8K word modules. Each module had its own 13-bit Memory Address 
Register (MAR) and 48-bit Memory Data Register (MDR) registers, which 
allowed independent concurrent operation of up to four modules if 
accesses were to different modules. Once a module received enough 
information to complete its operation – either load or store, it could be 
released from control by the CPU to proceed independently. This early 
release mechanism allowed overlapping memory accesses in different 
modules or overlapping I/O operations. 
The Store Unit (SU) received results from the AU and stored them in 
memory. This decoupling of storage operations allowed the AU to begin 
execution of next instruction, while data from the previous instruction 
were being stored in memory. 
Auxiliary storage was provided by a Disc File System with a 
maximum capacity of 5.2 MWords. It had a maximum transfer rate of 120 
KWords/s. The Disc File System had a separate path through the I/O 
Control Unit and its own line to memory. 
11.5.6 I/O Subsystem 
Up to three Buffer Units (BUs) were attached to the CPU. Each BU 
had an I/O Buffer Register (IOB), and I/O Processor (IOP), and a 
Universal Buffer Controller (UBC). The 48-bit IOB stored one word while 
that word was being read from or written to memory, and then sent to the 
D register. 
The IOP was used to couple magnetic tape systems and UBCs to the 
CPU. UBCs provided a 128-word buffer for holding a block of data being 
transferred from or to a magnetic tape subsystem. A UBC had eight data 
channels. Channel 0 was used to transfer data to and from the IOP. 
Channels 1 and 2 were used for magnetic tape subsystems, while channels 
3 through 7 were used for low-speed systems. 
I/O was performed via the TIO (Transfer Control to Input/Output) 
instruction. The TIO instruction transferred the contents of the D register 
to the I/O system. The format of the word in the D register is depicted in 
Figure 11-13. 

Philco Ford Computers 
 
249 
 
 
Figure 11-13. TIO Data Format  
Source: Philco 1963d 
 
where: 
StartAddr 
Starting address in the I/O system; number of blocks 
to be skipped in the magnetic tape subsystem. 
Unit Address 
I/O channel number 
BC 
UBC channel to which I/O device was connected 
Amount 
Amount of data to be transferred (words, cards, or 
blocks) 
From 
Device from which data was received 
To 
Device to which data was being sent 
11.5.7 Real-Time System 
The Real-Time System (RTS) provided a direct channel to the CPU for 
high priority data. A Real-Time Scanner checked either four or eight real-
time units that were connected to it. When a real-time unit was ready to 
transmit data, the RTS sent a signal to the CPU which caused an interrupt 
to allow the data to be transmitted. The Scanner was designed to 
accommodate special-purpose devices whether developed by Philco or by 
the customer. It continuously interrogated each real-time unit attached to 
it. Data transmission was performed by the TIO instruction when the D 
register contained a real-time order. The format of a real-time order is 
depicted in Figure 11-14. 
 
 
 
Figure 11-14. Philco 212 Real-Time Order Format 
Source: Adapted from Philco UNKh 
 
Unit specified the real-time unit number (0 to 7). Amount specified the 
number of words to transfer. Command specified the direction: RDRT 
(1101): RTS -> Memory; WRRT (0111): Memory -> RTS. 

Chapter Eleven 
 
250
The Auto-Control Unit (ACU) was a unit attached to the RTS which 
provided a means of program-controlled interrupts. Interrupts could be 
generated by status and error conditions of the I/O devices and internal 
machine conditions. The ACU was able to mask the recognition and 
handling of interrupts. 
An Interval Timer could also be connected to the RTS to provide a 
time reference of up to 9 hours counted in milliseconds. A TIO instruction 
transferred the contents of a memory location to the Interval Timer 
specifying the amount of time to elapse before an interrupt occurred. 
Another TIO instruction could read the Interval Timer’s internal counter to 
determine how much time remained before an interrupt occurred. 
11.5.8 Philco 212 Instruction Set 
Source: Philco 1958e 
 
The instruction set of the Philco 212 was arranged in several 
categories. Instructions were 24 bits in length and stored two per word. 
Normally, the instruction in the left half of the word was fetched and 
executed first, then the instruction in the right half. The format of an 
instruction is depicted in Figure 11-15.  
 
 
 
Figure 11-15. Philco 212 Instruction Format 
Source: Adapted from Philco 1968g 
 
Of the eight bits of the Command Field, the first bit, the F-bit, 
specified whether arithmetic was to be performed in fixed point (F = 0) or 
floating point (F = 1) format. For jump instructions the F-bit specified 
whether the jump was to the left half (F = 0) or the right half (F = 1) of the 
address. 
The Address Field had two formats depending on whether an index 
register was used or not. The S-bit acted as the index register selector. If 
zero, no index register was used in informing the effective address. If S = 
1, then the N-field specified the index register to use in computing the 
effective address. On a 65Kword system, the first bit was used to specify 
the 32Kword bank to which the address will refer. Figure 11-16 depicts 
the Philco 212 Address Field formats. 

Philco Ford Computers 
 
251 
 
 
Figure 11-16. Philco 212 Address Field Format 
Source: Adapted from Philco 1968g 
 
Indirect addressing was performed for extended instruction using bits 
14 and 15. Table 11-6 depicts the use of these bits to control indirect 
addressing. 
 
Table 11-6. Control Bits for Indirect Addressing 
Bit 14 
Bit 15 
Indirect Addressing Type 
1 
0 
The address specified in the V-field of the instruction 
in the left half of the word was used to form the 
effective address. 
1 
1 
The address specified in the V-field of the instruction 
in the right half of the word was used to form the 
effective address. 
0 
1 
The address field specified by the address field of the 
extended instruction was used to form the EA. 
0 
0 
No indirect addressing 
 
For arithmetic instructions, the overflow flip-flop was normally set to 
zero before the execution of the instruction. If the result of the arithmetic 
instruction overflowed the capacity of the target register, the overflow flip-
flop was set to one.  
 
11.5.8.1 ADD Instructions 
 
ADD instructions added the contents of a register or a memory 
location to the A register. All ADD instructions cleared the Overflow bit 

Chapter Eleven 
 
252
unless an ICOS instruction had been executed and was still in effect. Table 
11-7 describes the ADD instructions. 
 
Table 11-7. Philco 212 ADD Instructions 
Mnemonic 
OpCode 
Description 
AM 
FAM 
1000 
3000 
Add Memory: D <- c(M); A <- c(A) + c(D) 
AMS 
FAMS 
1001 
3001 
Add Memory and Store: D <- c(M); 
A <- c(A) + c(D); D <- c(A); M <-c(D) 
CAM 
FCAM 
1002 
3002 
Clear and Add Memory: A<- 0; D <- c(M); 
A <- c(D) 
CAMS 
FCAMS 
1003 
3003 
Clear, Add Memory and Store: A <- 0; 
D <- c(M); A <- c(A) + c(D); D<- c(A);M<-c(D) 
AMA 
FAMA 
1010 
3010 
Add Memory Absolute: D <- |c(M)|; 
A <- c(A) + c(D) 
AMAS 
FAMAS 
1011 
3011 
Add Memory Absolute and Store: D <- |c(M)|; 
A <- c(A) + c(D); D <- c(A); M <-c(D) 
CAMA 
FCAMA 
1012 
3012 
Clear and Add Memory Absolute: A<- 0; 
D <- |c(M)|; A <- c(D) 
CAMAS 
FCAMAS 
1013 
3013 
Clear and Add Memory Absolute and Store: A<- 
0; D <- |c(M)|; A <- c(A) + c(D); D <- c(A); 
M <-c(D) 
AQ 
FAQ 
1020 
3020 
Add Q: D <- c(Q); A <- c(A) + c(D) 
AQS 
FAQS 
1021 
3021 
Add Q and Store: D <- c(Q); A <- c(A) + c(D); 
D <-c(A); M <- c(D) 
CAQ 
FCAQ 
1022 
3022 
Clear and Add Q: A <- 0; D <- c(Q); 
A <- c(A) + c(D) 
CAQS 
FCAQS 
1023 
3023 
Clear and Add Q and Store: A <- 0; D <- c(Q); 
A <- c(A) + c(D); M <- c(D) 
AQA 
FAQA 
1030 
3030 
Add Q Absolute: D <- c(Q); A <- c(A) + c(D) 
AQAS 
FAQAS 
1031 
3031 
Add Q Absolute and Store: D <- c(Q); A <- c(A) 
+ c(D); D <-c(A); M <- c(D) 
AD 
FAD 
1330 
3330 
Add D: A <- c(A) + c(D) 
 
11.5.8.2 SUBTRACT Instructions 
 
SUBTRACT instructions subtracted the contents of a register or a 
memory location to the A register. All SUBTRACT instructions cleared 

Philco Ford Computers 
 
253 
the Overflow bit unless an ICOS instruction had been executed and was 
still in effect. Table 11-8 describes the SUBTRACT instructions. 
 
Table 11-8. Philco 212 SUBTRACT Instructions 
Mnemonic 
OpCode 
Description 
SM 
FSM 
1100 
3100 
Subtract Memory: D <- c(M); A <- c(A) - c(D) 
SMS 
FSMS 
1101 
3101 
Add Memory and Store: D <- c(M); 
A <- c(A) + c(D); D <- c(A); M <-c(D) 
CSM 
FCSM 
1102 
3102 
Clear and Subtract Memory: A<- 0; D <- -c(M); 
A <- c(D) 
CSMS 
FCSMS 
1103 
3103 
Clear and Subtract Memory and Store: A <- 0; 
D <- -c(M);  <- c(A) + c(D); D<- c(A); M<c(D) 
SMA 
FSMA 
1110 
3110 
Subtract Memory Absolute: D <- |c(M)|; 
A <- c(A) - c(D) 
SMAS 
FSMAS 
1111 
3111 
Subtract Memory Absolute and Store: D<- 
|c(M)|; A <- c(A) - c(D); D <- c(A); M <-c(D) 
CSMA 
FCSMA 
1112 
3112 
Clear and Subtract Memory Absolute: A<- 0; 
D <- |c(M)|; A <- -c(D) 
CSMAS 
FCSMAS 
1113 
3113 
Clear and Subtract Memory Absolute and Store: 
A<- 0; D <- |c(M)|; A <- -c(D); D <- c(A); 
M <-c(D) 
SQ 
FSQ 
1120 
3120 
Subtract Q: D <- c(Q); A <- c(A) - c(D) 
SQS 
FSQS 
1121 
3121 
Subtract Q and Store: D <- c(Q); 
A <- c(A) - c(D); D <-c(A); M <- c(D) 
CSQ 
FCSQ 
1122 
3122 
Clear and Subtract Q: A <- 0; D <- c(Q); 
A <- c(A) - c(D) 
CSQS 
FCSQS 
1123 
3123 
Clear and Subtract Q and Store: A <- 0; 
D <- c(Q); A <- c(A) - c(D); M <- c(D) 
SQA 
FSQA 
1130 
3130 
Subtract Q Absolute: D <- c(Q); 
A <- c(A) - c(D) 
SQAS 
FSQAS 
1131 
3131 
Subtract Q Absolute and Store: D <- c(Q); 
A <- c(A) - c(D); D <-c(A); M <- c(D) 
SD 
FSD 
1331 
3331 
Subtract D: A <- c(A) - c(D) 
 
11.5.8.3 MULTIPLY Instructions 
 
MULTIPLY instructions multiplied the contents of the Q register by 
the contents of the A register or a memory location. All MULTIPLY 

Chapter Eleven 
 
254
instructions cleared the Overflow bit unless an ICOS instruction had been 
executed and was still in effect. Table 11-9 describes the MULTIPLY 
instructions. 
 
Table 11-9. Philco 212 MULTIPLY Instructions 
Mnemonic 
OpCode 
Description 
MM 
FMM 
1200 
3200 
Multiply Memory: D <- c(M); 
AQ <- c(D) * c(M) 
MMS 
FMMS 
1201 
3201 
Multiply Memory and Store: D <- c(M); 
 AQ <- c(D) * c(M); D <- c(A); M <- c(D) 
MMR 
FMMR 
1202 
3202 
Multiply Memory and Round: D <- c(M); 
AQ <- c(D) * c(M); A <- rounded (AQ) 
Round the fixed point 47-bit product to the 
closest 94-bit result. Round the 35-bit floating 
point product to the nearest 7-bit result.  
MMRS 
FMMRS 
1203 
32032 
Multiply Memory and Round and Store: D <- 
c(M); AQ <- c(D) * c(M); A <- rounded (AQ); 
D <- c(A); M <- c(D) 
Round the fixed point 47-bit product to the 
closest 94-bit result. Round the 35-bit floating 
point product to the nearest 7-bit result.  
MMA 
FMMA 
1210 
3210 
Multiply Memory Absolute: D <- |c(M)|; 
AQ <- c(D) * c(M) 
MMAS 
FMMAS 
1211 
3211 
Multiply Memory Absolute and Store: 
D <- |c(M)|; AQ <- c(D) * c(M); D <- c(A); 
M <- c(D) 
MMAR 
FMMAR 
1212 
3212 
Multiply Memory Absolute and Round: D <- 
|c(M)|; AQ <- c(D) * c(M); A <- rounded (AQ) 
Round the fixed point 47-bit product to the 
closest 94-bit result. Round the 35-bit floating 
point product to the nearest 7-bit result.  
MMARS 
FMMARS 
1213 
3213 
Multiply Memory Absolute and Round and 
Store: D <- |c(M)|; AQ <- c(D) * c(M); 
A <- rounded (AQ); D <- c(A); M <- c(D) 
Round the fixed point 47-bit product to the 
closest 94-bit result. Round the 35-bit floating 
point product to the nearest 7-bit result.  
MA 
FMA 
1220 
3220 
Multiply A: D <- c(A); AQ <- c(A) * c(Q) 
MAS 
FMAS 
1221 
3221 
Multiply A and Store: D <- c(A); 
AQ <- c(A) * c(Q); M <- c(A) 

Philco Ford Computers 
 
255 
MAR 
FMAR 
1222 
3222 
Multiply A and Round: D <- c(A); 
AQ <- c(A) * c(Q); A <- rounded (AQ). 
Round the fixed point 47-bit product to the 
closest 94-bit result. Round the 35-bit floating 
point product to the nearest 7-bit result. 
MARS 
FMARS 
1223 
3223 
Multiply A and Round: D <- c(A); 
AQ <- c(A) * c(Q); A<- rounded (AQ); 
M<- c(A). 
Round the fixed point 47-bit product to the 
closest 94-bit result. Round the 35-bit floating 
point product to the nearest 7-bit result. 
MAA 
FMAA 
1230 
3230 
Multiply A Absolute: D <- |c(A)|; 
AQ <- |c(A)| * c(Q) 
MAAS 
FMAAS 
1231 
3231 
Multiply A Absolute and Store: D <- |c(A)|; AQ 
<- |c(A)| * c(Q); M <- c(A). 
MAAR 
FMAAR 
1232 
3232 
Multiply A Absolute and Round: D <- |c(A)|; 
AQ <- {c(A)| * c(Q); A <- rounded (AQ). 
Round the fixed point 47-bit product to the 
closest 94-bit result. Round the 35-bit floating 
point product to the nearest 7-bit result. 
MAARS 
FMAARS 
1233 
3233 
Multiply A Absolute and Round: D <- |c(A)|; 
AQ <- c(A) * c(Q); A <- rounded (AQ); 
M <- c(A). 
Round the fixed point 47-bit product to the 
closest 94-bit result. Round the 35-bit floating 
point product to the nearest 7-bit result. 
MAD 
FMAD 
1320 
3320 
Multiply and Add: UR <- c(A); D <- c(M); 
A <- c(D) * c (Q); A <- c(UR) + c(A). 
UR was an unaddressable register which holds 
the original contents of A.  
MSD 
FMSD 
1321 
3321 
Multiply and Subtract: UR <- c(A); D <- c(M); 
A <- c(D) * c (Q); A <- c(UR) - c(A). 
UR was an unaddressable register which holds 
the original contents of A.  
 
11.5.8.4 DIVIDE Instructions 
 
DIVIDE instructions divided the contents of the A register or the A,Q 
registers by the contents of a memory location. All DIVIDE instructions 
cleared the Overflow bit unless an ICOS instruction had been executed 
and was still in effect. Table 11-10 describes the DIVIDE instructions. 

Chapter Eleven 
 
256
Table 11-10. Philco 212 DIVIDE Instructions 
Mnemonic 
OpCode 
Description 
DAQ 
FDAQ 
1300 
3300 
Divide AQ: D <- c(M); Q <- c(AQ)/c(D); 
A <- Remainder; 
DAQS 
FDAQS 
1301 
3301 
Divide AQ and Store: D <- c(M); 
Q <- c(AQ)/c(D); A <- Remainder; M <- c(A). 
DA 
FDA 
1302 
3302 
Divide A: D <- c(M); Q <- c(A)/c(D); 
A <- Remainder. 
DAS 
FDAS 
1303 
3303 
Divide A and Store: D <- c(M); Q <- c(A)/c(D); 
A <- Remainder; D <- c(A); M <- c(D). 
 
11.5.8.5. CLEAR Instructions 
 
CLEAR instructions cleared the contents of a register or of a memory 
location. Table 11-11 describes the CLEAR instructions. 
 
Table 11-11. Philco 212 CLEAR Instructions 
Mnemonic 
OpCode 
Description 
CM 
0100 
Clear Memory: M0-47 <- 0. 
CA 
0111 
Clear A: A0-47 <- 0. 
CQ 
0122 
Clear Q: Q0-47 <- 0. 
CD 
0133 
Clear D: D0-47 <- 0. 
 
11.5.8.6 TRANSFER Instructions 
 
TRANSFER instructions moved information between registers or 
between a register and a memory location. Table 11-12 describes the 
TRANSFER instructions. 
 
Table 11-12. Philco 212 TRANSFER Instructions 
Mnemonic 
OpCode 
Description 
TMA 
0101 
Transfer Memory To A: D <- c(M); A <- c(D). 
TMQ 
0102 
Transfer Memory To Q: D <- c(M); Q <- c(D). 
TMD 
0103 
Transfer Memory To D: D <- c(M); 
TAM 
0110 
Transfer A To Memory: D <- c(A); M <- c(D). 
TAQ 
0112 
Transfer A To Q: D <- c(A); Q <- c(D). 
TAD 
0113 
Transfer A To D: D <- c(A). 
TQM 
0120 
Transfer Q To Memory: D <- c(Q); M <- c(D). 
TQA 
0121 
Transfer Q To A: D <- c(Q); A <- c(D). 
TQD 
0123 
Transfer Q To D: D <- c(Q). 

Philco Ford Computers 
 
257 
TDM 
0130 
Transfer D To Memory: M <- c(D). 
TDA 
0131 
Transfer D To A: A <- c(D). 
TDQ 
0132 
Transfer D To Q: Q <- c(D). 
TIJL 
TIJR 
0022 
2022 
Transfer the Instruction Address Field to JA: 
JA <- EA; JAF <- 0, if TIJL, or 1, if TIJR. 
TTD 
2010 
Transfer from Toggle Register to D: 
D <- Toggle Register. The Toggle register was a 
48-bit register that records the console switches. 
TCM 
0011 
Transfer from Console Typewriter to Memory: 
D42-47 <- CT; M <- D. 
TDC 
2011 
Transfer from D to Console Typewriter: 
CT <- D0-5. 
TIO 
0010 
Transfer Control to Input-Output: transfer the 
word from the D register to the I/O system. If the 
instruction was valid to the I/O system, skip the 
next instruction; otherwise, execute the next 
instruction. 
 
11.5.8.7 JUMP Instructions 
 
JUMP instructions caused a transfer of control from the current 
location to another location in memory. Both unconditional and 
conditional jump instructions were provided. Every jump instruction, 
except JL and JR, first stored the next location after the jump instruction in 
the JA register and set the F-bit of the JA register to 0 or 1 depending on 
whether the next location was in the left or right half of the JA register. 
Table 11-13 describes the JUMP instructions. 
On a 65K word system, the first bit if the JA register was set to the first 
bit of the 16-bit address of the memory location in which the instruction 
was stored unless (1) it was controlled by a RPT or DR instruction; (2) not 
indexed; or (3) not extended by an EXT instruction. The jump was thus 
performed within the same 32K bank of memory. For RPT and DR 
instructions, the first bit of the JA registers was set to the first bit of the 
address of the RPT or DR memory location. 
 
Table 11-13. Philco 212 JUMP Instructions 
Mnemonic 
OpCode 
Description 
JMPL 
JMPR 
0200 
2200 
Jump: Execute the instruction from the left or 
right half of the EA. 
 
 

Chapter Eleven 
 
258
JAZL 
JAZR 
0201 
2201 
Jump if A Is Zero: if c(A) = 0, execute the next 
instruction from left or right at the EA; 
otherwise, execute the next instruction. 
JNOL 
JNOR 
0202 
2202 
Jump If No Overflow Zero: If OV = 0, execute 
the next instruction from left or right at the EA; 
otherwise, execute the next instruction. 
JOFL 
JOFR 
0202 
2202 
Jump If Overflow Zero: If OV = 0, execute the 
next instruction from left or right at the EA; 
otherwise, execute the next instruction. 
JAPL 
JAPR 
0210 
2210 
Jump if A Positive: if c(A) > 0, execute the next 
instruction from left or right at the EA; 
otherwise, execute the next instruction. 
JANL 
JANR 
0220 
2220 
Jump if A Negative: if c(A) < 0, execute the next 
instruction from left or right at the EA; 
otherwise, execute the next instruction. 
JAEDL 
JAEDR 
0213 
2213 
Jump if A Equals D: if c(A) = c(D), execute the 
next instruction from left or right at the EA; 
otherwise, execute the next instruction. 
JAEQL 
JAEQR 
0212 
2212 
Jump if A Equals Q: if c(A) = c(Q), execute the 
next instruction from left or right at the EA; 
otherwise, execute the next instruction. 
JQPL 
JQPR 
0220 
2220 
Jump if Q > 0: if c(Q) > 0, execute the next 
instruction from left or right at the EA; 
otherwise, execute the next instruction. 
JQNL 
JQNR 
0221 
2221 
Jump if Q Negative: if c(Q) < 0, execute the next 
instruction from left or right at the EA; 
otherwise, execute the next instruction. 
JQEL 
JQER 
0222 
2222 
Jump if Q Even: if c(Q) was even (rightmost bit 
was zero), execute the next instruction from left 
or right at the EA; otherwise, execute the next 
instruction. 
JQOL 
JQOR 
0223 
2223 
Jump if Q Odd: if c(Q) was odd (rightmost bit 
was one), execute the next instruction from left 
or right at the EA; otherwise, execute the next 
instruction. 
JDPL 
JDPR 
0230 
2230 
Jump if D > 0: if c(D) > 0, execute the next 
instruction from left or right at the EA; 
otherwise, execute the next instruction. 
JAGQFL 
JAGQFR 
0231 
2231 
Jump if A is Greater Than or Equal to Q, 
Floating Point: 
D <- c(Q); if c(A) > c(D), execute the next 

Philco Ford Computers 
 
259 
instruction from left or right at the EA; 
otherwise, execute the next instruction. 
JAGQL 
JAGQR 
0232 
2232 
Jump if A is Greater Than or Equal to Q: 
D <- c(Q); if c(A) > c(D), execute the next 
instruction from left or right at the EA; 
otherwise, execute the next instruction. 
JAGDL 
JAGDR 
0233 
2233 
Jump if A is Greater Than or Equal to D: 
if c(A) > c(D), execute the next instruction from 
left or right at the EA; otherwise, execute the 
next instruction. 
JL 
JR 
0320 
2320 
Jump to the EA, but do not store the new 
instruction address in the JA register. 
JBTL 
JBTR 
0001 
2001 
Breakpoint Jump: the JBT instruction was 
executed based on the setting of two pushbuttons 
on the Operator’s console: the Breakpoint Jump 
(BPJ) and Breakpoint Halt (BPH) buttons. The 
following table presents the execution modes: 
BPJ  BPH     Effect 
On     On        Jump After Halt   
On     Off       Unconditional Jump 
Off    On        Halt 
Off    Off       Execute Next Instruction 
 
11.5.8.8 SHIFT Instructions 
 
SHIFT instructions shift some or all of the bits in a register left, right, or 
circularly. All SHIFT instructions cleared the Overflow indicator if an ICOS 
instruction was in effect. Table 11-14 describes the SHIFT instructions. 
 
Table 11-14. Philco 212 SHIFT Instructions 
Mnemonic 
OpCode 
Description 
SLAQ 
2100 
Shift Left A and Q: A0-46 <- A1-47; A47 <- Q0; 
Q0-46 <- Q1-47; Q47 <- 0 
SRAQ 
2101 
Shift Right A and Q: A0 <- 0; A1-47 <- A0-46; 
Q0 <- A47; Q1-47 <- Q0-46 
SLAQN 
2102 
Shift Left A and Q Numerical: A0 <- A0; 
A1-46 <- A2-47; A47 <- Q1; 
Q0 <- A0; Q1-46 <- Q2-47; Q47 <- 0 
SRAQN 
2103 
Shift Right A and Q Numerical: A0 <- A0;  
A1 <- A0; A2-47 <- A1-46; 
Q0 <- Q0; Q1 <- A47; Q2-47 <- Q1-46 

Chapter Eleven 
 
260
SLA 
2110 
Shift Left A: A0-46 <- A1-47; A47 <- 0 
SRA 
2111 
Shift Right A: A0 <-0; A1-47 <- A0-46 
SLAN 
2112 
Shift Left A Numerically: A0 <- A0; 
A1-46 <- A2-47, A47 <- 0 
SRAN 
2113 
Shift Right A Numerically: A2-47 <- A1-46; 
A1 <- A0; A0 <- 0. 
SLQ 
2120 
Shift Left Q: Q0-46 <- Q1-47; Q47 <- 0 
SRQ 
2121 
Shift Right Q: Q0 <-0; Q1-47 <- Q0-46 
SLQN 
2122 
Shift Left Q Numerically: Q0 <- Q0; 
Q1-46 <- Q2-47, Q47 <- 0 
SRQN 
2123 
Shift Right Q Numerically: Q2-47 <- Q1-46; 
Q1 <- Q0; Q0 <- 0 
SCD 
2130 
2132 
Shift Circular D: D0 <- D47; D1-47 <- D0-46 
SRD 
2131 
Shift Right D: D0 <-0; D1-47 <- D0-46 
SRDN 
2133 
Shift Right D Numerically: D2-47 <- D1-46; 
D1 <- D0; D0 <- 0. 
 
11.5.8.9 INDEX REGISTER Instructions 
 
INDEX REGISTER instructions altered the contents of an index 
register, set the C- and Y-bits of an index register, or transferred data 
between an index register and the D register. Data was taken from the 
address field of the current instruction or from the D register. The number 
of bits operated on depended on the size of memory and the S-bit of the 
address field used as the source of data. Table 11-15 describes the INDEX 
REGISTER instructions. 
 
Table 11-15. Philco 212 INDEX REGISTER Instructions 
Mnemonic 
OpCode 
Description 
TDXL 
TDXR 
0300 
2300 
Transfer D to Index Register: transferred the V-
field of the specified half of the D register to the 
specified index register. The Y-bit of the index 
register was set to 0. 
TDXLC 
TDXRC 
0301 
2301 
Transfer D to Index Register with C-bit: 
transferred the V-field of the specified half of the 
D register to the specified index register. The Y-
bit of the index register was set to 0. Replace the 
C-bit of the index register by the F-bit of the half 
word of D. 
 
 

Philco Ford Computers 
 
261 
TDXLY 
TDXRY 
0322 
2322 
Transfer D to Index Register with C-bit and Y-
bit: transferred the V-field of the specified half 
of the D register to the specified index register. 
The C- and Y-bits were set to bits 16,17 or bits 
40,41 of the specified half of the D register. 
TXDL 
TXDR 
0302 
2302 
Transfer from Index Register to D Register: JA 
<- c(Xi); DL/R <- c(JA) based on S-bit value. 
TXDLC 
TXDRC 
0303 
2303 
Transfer from Index Register to D Register: JA 
<- c(Xi); DL/R <- c(JA) based on S-bit value. 
Replace the C-bit of the D register by the F-bit of 
the specified half of the index register. 
TXDLY 
TXDRY 
0323 
2323 
Transfer Index Register to D Register with C-bit 
and Y-bit: transferred the V-field of the specified 
half of the index register to the specified half of 
the D register. The C- and Y-bits were set to bits 
16,17 or bits 40,41 of the specified half of the 
index register. 
ADXL 
ADXR 
0310 
2310 
Add D to Index Register: add the V-field of the 
specified half to the index register. 
SDXL 
SDXR 
0311 
2311 
Subtract D from Index Register: subtract the V-
field of the specified half to the index register. 
TIXZ 
TIXS 
0321 
2321 
Transfer Instruction Address Field to Index 
Register: Transfer the V-field of the instruction 
to the index register. 
Set the C-bit to 0 (TIXZ) or 1 (TIXS). Set the Y-
bit of the index register to 0. 
TCXZ 
TCXS 
TCXCS 
0013 
2013 
2013 
Transfer C-bit to Index Register: Set the C-bit to 
0 (TCXZ) or 1 (TCXS). TCXCS sets the C-bit to 
1 and increments the contents of the index 
register by 1. 
TYXZ 
TYXS 
1332 
1333 
Transfer Y-bit to Index Register: Set index 
register C-bit to 0 (TYXZ) or 1 (TYXS). Set the 
Y-bit to 1. 
AIXJ 
0330 
0230 
Add Instruction Address Field to Index Register 
and Jump:  JA <- M+1; X <- c(X) + c(V). 
AIXJS 
2312 
Add Instruction Address Field to Index Register 
and Jump Than D: JA <- M+1; X <- c(X) + c(V). 
Jump only if c(X) < c(V) of the Left Half of the 
D register. 
AIXJEG 
0312 
Add Instruction Address Field to Index Register 
and Jump Than D: JA <- M+1; X <- c(X) + c(V). 

Chapter Eleven 
 
262
Jump only if c(X) >= c(V) of the Left Half of the 
D register. 
SIXJ 
0331 
2331 
Subtract Instruction Address Field to Index 
Register and Jump:  JA <- M+1; X <- c(X) - 
c(V). 
SIXJES 
2313 
Subtract Index Register From Address Field and 
Jump Less Than or Equal To Left Half of D 
Register: X <- c(X) - c(V); if c(A) was less than 
c(DL), jump to c(DR). 
SIXJG 
0313 
Subtract Index Register From Address Field and 
Jump Greater Than Left Half of D Register: X <- 
c(X) - c(V); if c(A) was less than c(DL), jump to 
c(DR). 
AIXOL 
AIXOR 
0332 
2332 
Add Instruction Address Field to Index Register 
and Set Overflow: OVFLO <- 0;  
X <- c(X) + c(V). 
SIXOL 
SIXOR 
0332 
2332 
Add Instruction Address Field to Index Register 
and Set Overflow: OVFLO <- 0;  
X <- c(X) - c(V). 
 
11.5.8.10 EXTRACT Instructions 
 
EXTRACT instructions performed bit-by-bit multiplications between 
the bits of the Q register and the bits of the specified memory location. 
This operation performed a logical AND function on the corresponding 
bits. Table 11-16 describes the EXTRACT instructions. 
 
Table 11-16. Philco 212 EXTRACT Instructions 
Mnemonic 
OpCode 
Description 
ETD 
0030 
Extract Transfer To D: D <- c(Q) AND c(M)  
ETA 
2030 
Extract Transfer To A: D <- c(Q) AND c(M); 
A <- c(D) 
EI 
0032 
Extract and Insert: D <- c(Q) AND c(M); 
DA <- c(A) AND c(Q) OR c(D) 
EIS 
2032 
Extract and Insert and Store: D <- c(Q) AND 
c(M); A <- c(A) AND c(Q) OR c(D); D <- c(A); 
M <- c(D) 
EA 
FEA 
1322 
3322 
Extract and Add: D <- c(Q) AND c(M); 
A <- c(D) + c(A) 
ES 
FES 
1323 
3323 
Extract and Subtract: D <- c(Q) AND c(M); 
A <- c(A) - c(D) 

Philco Ford Computers 
 
263 
11.5.8.11 LOGIC Instructions 
 
The logic instructions performed bit-by-bit operations upon two 
arguments. Table 11-17 describes the LOGIC instructions. 
 
Table 11-17. Philco 212 LOGIC Instructions 
Mnemonic 
OpCode 
Description 
DORMS 
0031 
D Or Memory and Store: D <- c(D) OR c(M); M 
<- c(D) 
AWCS 
2031 
Add Without Carry and Store: D <- c(A) AND 
c(M); M <- c(D). No carries were performed in 
any bit location. 
 
11.5.8.12 SPECIAL Instructions 
 
The SPECIAL instructions did not fit easily into any other category. 
Table 11-18 describes the SPECIAL instructions. 
 
Table 11-18. Philco 212 SPECIAL Instructions 
Mnemonic 
OpCode 
Description 
HLT 
HLTR 
0000 
2000 
Stopped the CPU after modifying an index register. 
When the Advance Bar on the Operator’s 
Console was pressed, the CPU proceeded to 
execute the next instruction. 
NOPL 
NOPR 
0003 
2003 
Caused the CPU to proceed to the next 
instruction after modifying an index register. 
ICOS 
2002 
Inhibited Clearing the Overflow Indicator 
ICOZ 
0002 
Removed Inhibition on Clearing the Overflow 
Indicator 
INCAL 
INCAR 
0021 
2021 
Increased Address Field in Memory Location: 
 
D <- c(Address) 
Dv <- c(Dv) + 1 
JA <- c(Dv) 
Address <- c(Dv) 
SKC 
0012 
Skip Check: Checked the status of registers of 
I/O devices. The address field contained the 
specific unit, status registers within the device, 
and comparison quantity (CQ). If CQ exceeded 
the value of the status register, the next 
instruction was skipped. 

Chapter Eleven 
 
264
SKF 
2012 
Skip if No Fault: Like the SKC instruction, but 
explicitly tested the fault registers of the 
specified I/O device. 
RPT 
0023 
2023 
Repeat: Caused the next instruction to be 
performed the number of times specified in the 
address field of the RPT instruction. If RPT was 
in the left half of the instruction, the instruction 
in the right half was repeated. If the RPT was in 
the right half, the next pair of instructions was 
repeated. The value in the address field was 
between 0-4095. If an instruction in a repeat loop 
caused a transfer of control, the repeat loop was 
terminated. 
DR 
1312 
Double 
Repeat: 
caused 
the 
next 
three 
instructions (if in left half) or next four 
instructions (if in right half) to be repeated as per 
the RPT instruction. 
LWD 
0033 
Larger Word: D <- c(M); compare c(D) to c(A) 
alphanumerically; if c(D) > c(A), then A <- c(D) 
and JA <- M and the next instruction was 
executed; otherwise, the next instruction was 
skipped. 
SWD 
2033 
Smaller Word: D <- c(M); compare c(D) to c(A) 
alphanumerically; if c(D) < c(A), then A <- c(D) 
and JA <- M and the next instruction was 
executed; otherwise, the next instruction was 
skipped. 
EXT 
1313 
Extend: extended the address field of the 
instruction to include the bits necessary to access 
the largest computer address, thus forming an 
extended V-field.  
 
The RPT instructions could specify from 1 to 2 instructions to be 
repeated. If the RPT instruction was in the left side of the word, then the 
instruction to be repeated was in the right side. If it was in the right side, 
then the next pair of instructions in the following word were repeated. 
These instructions could be repeated up to 4095 times. 
The format of a DR instruction for repeating four instructions is 
depicted in Figure 11-17. These instructions could be repeated up to 255 
times. The four fields ML1, MR1, ML2, MR2 referred, respectively, to the 
four instructions that were being repeated. 

Philco Ford Computers 
 
265 
 
 
Figure 11-17. DR instruction for Repeating Four Instructions 
Source: Adapted from Philco UNKh 
 
As seen in Figure 11-17, the high order bits were divided into pairs per 
each instruction to be repeated. The modifier bits were interpreted as show 
in Table 11-19. 
 
Table 11-19. Modifier Interpretation 
M 
Description 
00 
Normal index register modification sign the C- and Y-bits. 
10 
Modification performed as if C = 0, Y = 1 
11 
Modification performed as if C = 1, Y = 1 
11.6 Operating System 32KSYS 
32KSYS was an operating system for Philco Transac S-2000 systems 
that had 32K words of memory. It relieved the operator of loading 
programs, rewinding magnetic tapes, and preparing post-mortem dumps 
upon program failure. It accepted programs written in assembly language 
via the TAC assembler or written in the ALTAC programming language. 
(Philco 1968i) 
32KSYS required a minimum of nine magnetic tape drives with the 
assignments specified in Table 11-20. 
 
Table 11-20. Magnetic Tape drive Assignments for 32KSYS 
Assignment 
Description 
TSYSTEM 
System Program Tape, which contained 32KSYS in 
image form, and system utility routines and compilers. 
TSYSDMP 
System Scratch Tape, which was used for intermediate 
dumps and as a scratch tape for system utilities and 
compilers. 
TSYSIN 
System Input Tape, which contained job control 
commands and code. 
TSYSOUT 
System Output Tape, which contained job completion 
information and results for offline printing and punching. 
TSYSLIB 
System Library Tape, which contained TAC subroutines 
in a relocatable binary format. 
 
 

Chapter Eleven 
 
266
TSYSCRx 
System Scratch Tapes (x = 0, 3, 4, 6), which were used 
as scratch tapes by various system utilities and 
compilers. 
11.7 TRANSAC S-2000 Software 
Source: Philco 1962k 
 
Several programming languages were made available for the Philco 
Transac S-2000. Software development was led by Mac Nisbet who had 
come to Philco from Burroughs Philadelphia plant. He hired Saul Rosen, 
who had developed the Datacode programming system for the Burroughs 
205 computer system, to be head of the programming systems group. 
Rosen (2004) describes his experiences in establishing a programmng 
systems group for Philco in Philadelphia. 
The Translator-Assembler-Compiler (TAC) was the program that 
processed the Philco Transac S-2000’s assembly language. 
ALTAC (Algebraic Language for TAC) was a clone of FORTRAN II 
with extensions (Rosen 1959, 1961). The ALTAC compiler translated 
either an ALTAC program or an existing FORTRAN II program into the 
TAC language using the process depicted in Figure 11-18. Rosen (2004) 
believed that his group was the first to develop a FORTRAN compiler on 
a non-IBM computer system. Rosen’s group attempted to make ALTAC 
as compatible with the IBM 704 FORTRAN II compiler as much as 
possible. However, while 704 FORTRAN provided a run-time 
interpretation of format statements which allowed them to be read in just 
prior to use, ALTAC could not support it. Additionally, they limited the 
number of parameters that could be passed to a subroutine to 32. However, 
704 FORTRAN allowed up to 64 parameters. Whether or not anyone ever 
used all 32 or all 64 parameters is not clear. 
 
 

Philco Ford Computers 
 
267 
 
 
Figure 11-18. ALTAC Translation Process 
Source: Adapted from Philco 1962k 
 
Calculations were performed primarily in floating point format to a 
precision of 10 decimal digits. ALTAC extended FORTRAN II with some 
S-2000 specific statements such as being able to read the sense lights on 
the operator’s control panel. The ALTAC designers had considered some 
of the limitations of FORTRAN II and had tried to alleviate them in 
ALTAC. Figure 11-19 depicts an ALTAC advertisement circa 1960. 

Chapter Eleven 
 
268
 
 
Figure 11-19. Philco ALTAC Advertisement 
Source: Philco Ford UNK 
 
Philco claimed several enhancements over earlier assemblers and 
FORTRAN (Philco 1962k): 

Philco Ford Computers 
 
269 
x Use of symbolic addresses in lieu of or in addition to decimal 
statement addresses. 
x Enhanced conditional statements for greater flexibility. 
x Embedding of TAC into ALTAC programs 
x Removal of some limitations on subscript usage 
x Mixed mode expressions 
 
In many respects, ALTAC was very similar to FORTRAN, which had 
been described several years previously. By the emergence of ALTAC, the 
limitations of FORTRAN I and II had begun to be realized. 
Each ALTAC statement ended with a $. This use of a special character 
helped the compiler to figure out where the end of a statement was and 
thus improve compiler performance. Multiple statements, separated by 
semicolons, could be included, in a single line of text. Functions could be 
defined by a 
single 
statement 
in 
a 
program. 
For 
example, 
XVALUEF(A,N) = P*A + N**2 $. This function could then be called 
from other statements in the program. 
Rosen (1961, 1964) has made cogent observations about trying to be 
compatible with other manufacturer’s software systems. He noted that 
compatibility requires compatibility of implementation as well as 
compatibility of language. He also noted that in designing language 
processors, one had to be aware that the compiler must deal with programs 
written by people who neither knew nor cared about programming per se, 
and he neither knew or cared about how the programming practices they 
practiced affected compilation and running of their programs. Today, with 
modern compilers and lots of memory, we can more blasé about 
programming, but the physical limitations of memory and speed of the 
machine back then meant that careful attention had to be paid to every 
statement in a program.   
11.8 Philco 2400 Input/Output System 
The Philco 2400 Input/Output System offloaded the slow I/O of 
reading and punching paper tapes and printing output from a TRANSAC 
S-2000 computing machine. Input was converted to magnetic tape; output 
was printed off of magnetic tape. Two Program Control sections were 
complete and independent, thus allowing two complete programs to be run 
simultaneously. 
The Philco 2400 had numerous software modules for editing, searching 
and selecting, sorting, and translating data. The basic characteristics of the 
Philco 2400 are presented in Table 11-21. 

Chapter Eleven 
 
270
Table 11-21. Philco 2400 – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal 
Representation 
Fixed Point Binary, Binary Coded Decimal 
# Characters/Word 
4 (24 bits) 
# Instructions/Word 
1 
# Instructions 
Unknown 
# Bits/Instruction 
24 
Instruction Type 
Three-address 
CPU Technology 
transistor 
CPU Registers 
4 Base Address Registers 
Main Memory 
Magnetic Core: 8K – 32K characters; ~3 
microseconds/character access time 
Add Time 
Unknown 
Multiply Time 
Unknown 
Divide Time 
Unknown 
11.8.1 Philco 2400 System Architecture 
The system architecture of the Philco 2400 is depicted in Figure 11-20. 
The first three I/O Control Units IOCUs) were assigned as indicated in 
Figure 11-20. IOCUs 4 thru 8 could be assigned to other types of devices. 
Each IOCU could accommodate up to eight devices. Data could be 
transferred through any two IOCUs simultaneously. 
 

Philco Ford Computers 
 
271 
 
 
Figure 11-20. Philco 2400 System Architecture 
Source: Adapted from Philco 1962c 
11.8.2 Executive Control 
The Executive Control Unit (ECU) operated in parallel with the 
Program Control Units. The ECU executed orders stored in memory to (1) 

Chapter Eleven 
 
272
check the status of I/O devices, and (2) connect an I/O device to a 
particular program 
11.8.3 Program Control 
The Philco 2400 had two Program Control Units (PCU) which 
operated simultaneously and could access main memory simultaneously, if 
the accesses were to separate core matrices. Each PCU contained four 
Base Address Registers (BARs) and an instruction decoding network. The 
four BARS were labeled XA, XB, XC, and XD. Associated with the first 
three BARs were three Relative Address Registers (RARs) labeled A, B, 
and C. BAR XD was a buffer with an associated character counter. Each 
PCU had a Program Address Register (PAR) and five special registers: 
Test, Fault, Comparison, Direction, and N registers. 
Each PCU received information from the ECU when an I/O device was 
connected and the assigned program was started. The PCU executed the 
program while the ECU executed stored executive orders. When a 
program was initiated, the PCU performed the following: 
x Set the BARs from data in the CONNECT order 
x Sets to zero the RAR, Test, Comparison, Fault, and N registers 
x Sets the Direction register to access data in a forward direction 
 
Instructions were accessed sequentially by adding the contents of XA 
and the P register. Program flow could be modified by selecting another 
base register or changing the value of the P register. 
An instruction word of four characters was fetched from memory and 
decoded in the PCUs. The first two characters defined the operation code 
and the BAR to access operands. The remaining two character specified 
the number of characters (from 0 to 4095) to be processed by the 
instruction. 
The BARs were set by the CONNECT order issued by the ECU which 
connected an I/O device to a free PCU. An instruction specified which 
BAR to use in accessing memory. The number of characters specified in 
the instruction was loaded into an RAR. The RAR contents were used as 
an offset from the BAR. An RAR could be set to increment, decrement, or 
not change after each instruction execution. Thus, the PCU did not directly 
access characters in memory. 
The Buffer Register XD, also set by the CONNECT order, was used to 
specify an area in memory to receive/send data from/to punched card or 
tape equipment and the printer. The character counter was used to count 
the number of characters received from or sent to an I/O device. XD could 

Philco Ford Computers 
 
273 
also be used to augment other registers for multiply, divide, and 
conversion operations. 
The Program Address Register, augmented by a BAR, specified the 
effective address for the next instruction. The EA specified the first 
character of a four character instruction word. Thus, the PAR was 
incremented by 4 after each instruction was fetched. 
Four special registers were used to record the status of the PCUT as 
described in Table 11-22. 
 
Table 11-22. PCU Registers 
Register 
Description 
Test Register 
After an internal transfer, indicated the type of 
characters that were transferred. 
Comparison 
Register 
Set after a comparison instruction to indicate the result. 
Fault Register 
Set when a fault was detected during I/O or internal 
operations. 
Direction 
Register 
Stored the direction of change of the RARs. 
 
The N Register was a 12-bit register set by instructions that moved 
data within memory. It contained the number of characters to move and 
was decremented as each character was transferred. A non-zero value 
indicated that an End-of-Field character had been encountered thus 
terminating a move. 
11.8.4 Arithmetic Element 
The arithmetic element executed either fixed point binary or binary 
coded decimal (BCD) operations. Registers in the arithmetic element were 
not directly addressable. Operands were taken from memory and results 
stored back into memory. The Arithmetic Element was shared by the two 
Program Control sections. It performed the standard arithmetic fixed point 
operations. 
11.8.5 Main Memory 
Main memory had a capacity from 8K to 32K characters. Each block 
of 8K characters was organized as two 64x64 core matrices each of 4096 
characters. The matrices were interwired to provide even and odd address 
banks which could be accessed simultaneously. Either bank of memory 

Chapter Eleven 
 
274
could be accessed in less than 6 microseconds for the entire read/write 
cycle. 
Data flows between main memory and the I/O devices over two 
separate channels one character at a time. Each character consisted of 6 
bits, plus a parity bit.  
11.8.6 Operator Control Panel 
The Philco 2400 Operator Control Panel is depicted in Figure 11-21. 
Table 11-23 describes the elements of this panel. 
 
Table 11-23. Philco 2400 Operator Control Panel Elements 
Element 
Description 
Executive Control 
Switch 
A rocker switch that allowed the operator to select 
HALT or CONTINUE 
Program Control 
Switch 
A rocker switch that allowed the operator to select 
HALT or CONTINUE 
I/O Channel 
Switches 
A rocker switch that allowed the operator to select 
HALT or CONTINUE 
CLEAR Buttons 
Clear the current state of the switch. 
Program Load 
Buttons  
Used to initiate an I/O operation from a specific 
device 
Step/Run Toggle 
Each Program Control had a toggle switch to set the 
mode: step one instruction at a time or to run 
continuously 
Six Toggle 
Switches 
Used to enter data into the program. 
 
 

Philco Ford Computers 
 
275 
 
 
Figure 11-21. Philco 2400 Operator Control Panel 
Source:  Philco 1962c 
11.8.7 Philco 2400 Instruction Set 
The Philco 2400 handled data represented in either binary of BCD 
format. It provided instructions for conversion between BCD and binary 
formats. The Philco 2400 instruction format is depicted in Figure 11-22. It 
was comprised of four characters totaling 24 bits. 
 
 
 
Figure 11-22. Philco 2400 Instruction Format 
Source: Adapted from Philco 1962c 
11.8.8 I/O Operations 
Each PCU was connected to only one I/O unit at a time. Only I/O 
devices connected to a PCU could receive I/O instructions to send or 
receive data. An I/O instruction had to complete before another one could 

Chapter Eleven 
 
276
be issued. As an example, consider the process of reading data from a 
punched card: 
x The ECU checked the punched card reader for availability using 
the CHECK order 
x When available, the punched card reader was CONNECTed to a 
PCU. 
x The PCU reset its Character Counter and initiated the read 
operation by a FEED instruction. Data were read from the punched 
card into memory in an area defined by the Buffer Register. 
x The data was transferred by the MOVE instruction to the working 
area specified by one of the BARs. 
 
11.8.8.1 FEED/PUNCH Instructions 
 
The FEED instruction resets the Character Counter and causes data to be 
moved into the Buffer Register. The PUNCH instruction punches a card 
from the buffer area. Table 11-24 describes the FEED/PUNCH instructions. 
 
Table 11-24. Feed/PUNCH Instructions 
Instruction 
Description 
FEED 
Begins a new card by setting the Character Counter 
to zero. The following card was automatically fed 
into the card reader. 
FEED AND STOP 
Acts like FEED, but does not automatically set a 
new card 
PUNCH 
Punches a card of 80 columns form the buffer area 
and automatically set a new card. 
PUNCH AND 
STOP 
As above, except a new card was not automatically 
set. 
 
11.8.8.2 MOVE Instructions 
 
The MOVE instruction moves data from the Buffer Register to areas 
A, B, or C, where it may be processed. Table 11-25 describes the MOVE 
instructions. 
 
Table 11-25. MOVE Instructions 
Instruction 
Description 
MOVE D to {A, B,C} 
Reads data into A, B, or C the number of 
characters specified by N. No control 
characters were recognized. 

Philco Ford Computers 
 
277 
MOVE WITH EDIT D 
To {A, B, C} 
Reads data into A, B, or C the number of 
characters specified by N. Control characters 
were recognized. An End-of-Field character 
stopped the operation. 
MOVE AN 
DTRANSLATE D To A 
As above, but translated the characters to 
Philco Code. 
MOVE {A, B, C} TO D 
Transfer characters from a work area to the 
buffer area for the card punch. 
MOVE WITH EDIT {A, 
B, C} TO D 
As above, but check for control characters. 
MOVE AND 
TRANSLATE {A, B, 
C} TO D 
Translate characters from Philco Code to 12-
bit Hollerith characters and moved into the 
buffer area. 
 
11.8.8.3Card Punch Instructions 
 
The Card Punch instructions caused data to be transferred from area D 
to the card punch. Table 11-26 describes the Card Punch instructions. 
 
Table 11-26. Card Punch Instructions 
Instruction 
Description 
PUNCH 
Punches a card by transferring characters from area D 
to the buffer. Queues up another card for the punch. 
PUNCH AND 
STOP 
Punches a card, but does not queue up another card. 
 
11.8.8.4 Character Selection Instructions 
 
The character counter was reset to 1 by a Feed and Punch instruction. 
Each time a character was transmitted from the buffer, it was incremented 
by one. These instructions allowed characters to be selected from areas A, 
B, and C. Table 11-27 describes the character selection instructions. 
 
Table 11-27. Character Selection Instructions 
Instruction 
Description 
SET D TO 
CHARACTER N 
Sets the character counter to N. The counter 
specified a character in the buffer area. 
TAB FORWARD N 
CHARACTERS 
Increments the character counter by N.  
REVERSE N 
CHARACTERS 
Decrements the character counter by N. 

Chapter Eleven 
 
278
11.8.8.5 Printer Instructions 
 
Data was horizontally formatted by transmitting data from areas A, B, 
C by the MOVE instruction. Table 11-28 describes the printer instructions. 
 
Table 11-28. Printer Instructions 
Instruction 
Description 
MOVE {A, B, C} 
TO D 
These instructions transmit N characters from A, 
B, or C to the Buffer Area. 
MOVE WITH EDIT 
{A, B, C} To D 
As above, but checks were made for control 
characters. 
SET D TO 
CHARACTER N 
Sets the column counter for formatting to column 
N 
TAB D FORWARD 
N CHARACTERS 
Increments the column counter by N. 
TAB D REVERSE N 
CHARACTERS 
Decrements the column counter by N. 
PRINT 
The first 120 characters from the Buffer Area 
were transmitted to the printer. 
ADVANCE TO 
LINE N 
Advances the form to line N. 
SPACE N LINES 
Advance the form the specified number of lines. 
PAGE 
Begins a new page. 
 
11.8.8.6 Magnetic Tape Instructions 
 
The magnetic tape unit transmits data to and from the areas A, B, and 
C. If the number of characters transmitted to or from the magnetic tape 
does not fill a block, the tape will be spaced to the end of the block and the 
block will be filled out with null characters. A block of characters 
consisted of 1024 characters plus two parity characters. Table 11-29 
describes the magnetic tape instructions. 
 
Table 11-29. Magnetic Tape Instructions 
Instruction 
Description 
READ MAG TAPE 
INTO {A, B, C} 
Read into area {A, B, C} the number of 
characters specified by N. 
WRITE MAG TAPE 
INTO {A, B, C} 
Write to magnetic tape from area {A, B, C} the 
specified number of characters. 
ERASE 
Erase the block preceding the next end of block 
mark. 

Philco Ford Computers 
 
279 
REWIND 
Rewinds tape to the beginning of the reel 
REWIND WITH 
LOCKOUT 
Rewind tape to the beginning of the reel and 
places the transport under operator control. 
RESET 
This 
function 
performs 
FEED, 
PUNCH, 
REWIND, and PRINT functions. 
RESET AND STOP 
As above, but stops after each function. 
TOGGLE 
The settings of toggles on the operator’s console 
were transmitted to the Test Register. 
11.8.9 Internal Operations 
The Philco 2400 incorporated a flexible set of instructions to facilitate 
I/O operations. These are described in the following paragraphs. 
 
11.8.9.1 Setting/Moving the Relative Registers 
 
The relative registers were incremented or decremented by one each 
time data specified by the register was accessed, or was left the same. 
When the count reached zero or 4096, bit 2 in the Fault Register was set. 
The efficient use of the autoincrementing feature depended on the data 
being chained in memory. Table 11-30 describes the setting and moving 
instructions. 
 
Table 11-30. Setting and Moving Register Values 
Instruction 
Description 
SET (A, B, C} 
FORWARD 
Transfer N characters of this instruction to Relative 
Register {A, B, C}. The counter was incremented as 
each character was accessed. 
SET (A, B, C} 
REVERSE 
Transfer N characters of this instruction to Relative 
Register (A, B, C}. The counter was decremented as 
each character was accessed. 
SET (A, B, C} 
STEADY 
Transfer N characters of this instruction to Relative 
Register (A, B, C}. The counter was not changed. 
TAB {A. B. C} 
FORWARD 
Add N to the relative register specified. 
TAB {A. B. C} 
REVERSE 
Subtract N from the relative register specified. 
 
 
 

Chapter Eleven 
 
280
11.8.9.2 Moving/Editing Data 
 
Once data had been read into memory, the MOVE instructions allowed 
data to be moved from one area in memory to another. On the EDIT 
instructions, the End-Of-Field character (Octal 77) stops the transmission 
when encountered. Table 11-31 describes the moving and editing 
instructions. 
 
Table 11-31. Moving and Editing Data Instructions 
Instruction 
Description 
MOVE A TO 
{B, C} 
Copy from A to either B or C. The relative register of 
each area was incremented, decremented, or remains 
steady depending on how it was set. 
MOVE B TO 
{A, C} 
Copy from B to either A or C. The relative register of 
each area was incremented, decremented, or remains 
steady depending on how it was set. 
MOVE C TO 
{A, B} 
Copy from C to either A or B. The relative register of 
each area was incremented, decremented, or remains 
steady depending on how it was set. 
MOVE WITH 
EDIT A TO 
{B, C} 
Copy from A to either B or C. Test for control characters 
and set bits in the Test and Comparison Registers. The 
relative register of each area was incremented, 
decremented, or remains steady depending on how it was 
set. 
MOVE WITH 
EDIT B TO 
{A, C} 
Copy from B to either A or C. Test for control characters 
and set bits in the Test and Comparison Registers. The 
relative register of each area was incremented, 
decremented, or remains steady depending on how it was 
set. 
MOVE WITH 
EDIT C TO 
{A, B} 
Copy from C to either A or B. Test for control characters 
and set bits in the Test and Comparison Registers. The 
relative register of each area was incremented, 
decremented, or remains steady depending on how it was 
set. 
 
11.8.9.3 Philco Code - Hollerith Translations 
 
These instructions provided the ability to translate 12-bit Hollerith 
characters to 6-bit Philco characters and vice versa. The N register 
specified the number of characters to move. Table 11-32 describes the 
translation instructions. 

Philco Ford Computers 
 
281 
Table 11-32. Code Translation Instructions 
Instruction 
Description 
MOVE AND 
TRANSLATE 
BCD A TO {B, C} 
Move and translate Hollerith code to Philco Code. 
The relative register of each area was incremented, 
decremented, or remains steady depending on how 
it was set. 
MOVE AND 
TRANSLATE 
BCD B TO {A, C} 
Move and translate Hollerith code to Philco Code. 
The relative register of each area was incremented, 
decremented, or remains steady depending on how 
it was set. 
MOVE AND 
TRANSLATE 
BCD C TO {A, B} 
Move and translate Hollerith code to Philco Code. 
The relative register of each area was incremented, 
decremented, or remains steady depending on how 
it was set. 
MOVE AND 
TRANSLATE A 
TO  HOLLERITH 
{B, C} 
Convert Philco characters to Hollerith characters. 
The relative register of each area was incremented, 
decremented, or remains steady depending on how 
it was set. 
MOVE AND 
TRANSLATE B 
TO HOLLERITH 
{A, C} 
Convert Philco characters to Hollerith characters. 
The relative register of each area was incremented, 
decremented, or remains steady depending on how 
it was set. 
MOVE AND 
TRANSLATE C 
TO HOLLERITH 
{A, B} 
Convert Philco characters to Hollerith characters. 
The relative register of each area was incremented, 
decremented, or remains steady depending on how 
it was set. 
 
11.8.9.4 Comparing Fields 
 
These instructions compared N characters from the first field to N 
characters of the second field. The comparison used the Philco 2400 
alphameric ordering. The instructions cleared the Comparison Register, 
then set bits 2, 4, 5, or 6. Table 11-33 describes the field comparison 
instructions. 
 
Table 11-33. Field Comparison Instructions 
Instruction 
Description 
BINARY 
COMPARE A TO 
{B, C} 
Compare Field A to Field {B, C}. End-Of-Field and 
null characters were compared like the others. 
BINARY 
Compare Field B to Field {A, C}. End-Of-Field and 

Chapter Eleven 
 
282
COMPARE B TO 
{A, C} 
null characters were compared like the others. 
BINARY 
COMPARE C TO 
{A, B} 
Compare Field C to Field {A, B}. End-Of-Field and 
null characters were compared like the others. 
COMPARE A TO 
{B, C} 
Compare Field A to Field {B, C}. End-Of-Field 
character in the first field stops the comparison. 
COMPARE B TO 
{A, C} 
Compare Field B to Field {A, C}. End-Of-Field 
character in the first field stops the comparison. 
COMPARE C TO 
{A, B} 
Compare Field C to Field {A, B}. End-Of-Field 
character in the first field stops the comparison. 
 
11.8.9.5 Saving Registers 
 
The Test, Comparison, Fault, Relative, Direction, and N registers could 
be saved after being set. In these instructions the N part of the instruction 
specifies an address relative to the base area of the register to be saved. 
Table 11-34 describes the register save instructions. 
 
Table 11-34. Register Save Instructions 
Instruction 
Description 
SAVE N 
Stores the content of N in two characters. Does not 
clear N. 
SAVE {A, B, C} 
Stores the value of the corresponding relative 
register in two characters. Does not clear the RR. 
SAVE 
DIRECTION 
Stores in one character the direction setting for the 
three areas A, B, and C 
SAVE TEST 
Stores the contents of the Test Register in one 
character. Clears the Test Register. 
SAVE 
COMPARISON 
Stores the contents of the Comparison Register in 
one character. Clears the Comparison Register. 
SAVE FAULT 
Stores the contents of the Fault Register in one 
character. Clears the Fault Register. 
 
11.8.9.6 Testing Registers 
 
These instructions tested the registers and skipped if the specified 
condition was true. The operation code specified the register to be tested. 
If a character in memory was being tested, the op code designated the base 
register. The relative register had to be set to the character to be tested. 
Table 11-35 describes the register test instructions. 

Philco Ford Computers 
 
283 
Table 11-35. Register Test Instructions 
Instruction 
Description 
SKIP ALL ONES 
Skips if each bit in the fourth character of the 
instruction was matched by a one bit in the 
specified register or memory location. 
SKIP ANY ONES 
Skips if any bit in the fourth character of the 
instruction was matched by a one bit in the 
specified register or memory location. 
SKIP ALL ZEROES 
Skips if each bit in the fourth character of the 
instruction was matched by a zero bit in the 
specified register or memory location. 
SKIP ANY ZEROES 
Skips if any bit in the fourth character of the 
instruction was matched by a zero bit in the 
specified register or memory location. 
SKIP EQUAL 
Skips if six bits in the fourth character of the 
instruction was matched by the six bits in the 
specified register or memory location. 
SKIP UNEQUAL 
Skips if six bits in the fourth character of the 
instruction was not matched by the six bits in the 
specified register or memory location. 
 
11.8.9.7 Jump Instructions 
 
The Jump instructions allow the sequential flow of the program to be 
modified. When executed, the N part of the instruction was transferred to 
the Program Address Register. The new EA was the sum of the PAR and 
the BAR. Table 11-36 describes the jump instructions. 
 
Table 11-36. Jump Instructions 
Instruction 
Description 
JUMP, REMAIN IN 
CURRENT AREA 
Place N in the PAR, but do not change the 
Relative Register. 
JUMP TO AREA 
{A, B, C} 
If the program was in specified area, this 
instruction transfers the contents of the PAR to the 
RR of the specified area. Then, it transfers the N 
part into the PAR. If it was in a different area, the 
previous setting of the PAR was transferred to the 
RR of the specified area. The N part was set into 
the RR and the next instruction was taken relative 
to the Base Register of the specified area. 
 

Chapter Eleven 
 
284
11.8.9.8 Incrementing and Decrementing 
 
These instructions incremented or decremented one field within 
memory. The location of the least significant digit was designated by the 
value of the associated Relative Register. If carry was to go from right to 
left, then the Relative Register must be set to Reverse. The maximum 
number of characters through which the carry may extend was specified 
by the N part of the instruction. Table 11-37 describes the increment and 
decrement instructions. 
 
Table 11-37. Increment and Decrement Instructions 
Instruction 
Description 
DECIMAL 
INCREMENT 
{A, B, C} 
Add one in decimal arithmetic to a field of N 
characters. Set the overflow bit in the Comparison 
Register if the carry goes beyond the field. A carry 
beyond the field was not stored. 
DECIMAL 
DECREMENT 
{A, B, C} 
Subtract one in decimal arithmetic to a field of N 
characters. Set the overflow bit in the Comparison 
Register if the borrow comes from beyond the field.  
BINARY 
INCREMENT 
{A, B, C} 
Add one in binary arithmetic to a field of N 
characters. Set the overflow bit in the Comparison 
Register if the carry goes beyond the field.  
BINARY 
DECREMENT 
{A, B, C} 
Subtract one in binary arithmetic to a field of N 
characters. Set the overflow bit in the Comparison 
Register if the borrow comes from beyond the field.  
11.8.10 Arithmetic Operations 
The Philco 2400 had an arithmetic section that handled computations 
not amenable to increment and decrement operations. It had no 
addressable registers. The instructions specified the area where the two 
operands were located. Relative Register A was always used to form the 
EA of the first operand and Relative Register B was always used to form 
the EA of the second operand. Table 11-38 describes the arithmetic 
operations for the Philco 2400. 
 
Table 11-38. Arithmetic Operations 
Instruction 
Description 
ADD BINARY 
Add the two specified operands and place the result in 
memory. All operands were presumed to be N-groups 
of 6 bits. 

Philco Ford Computers 
 
285 
ADD DECIMAL 
Add the two specified operands and place the result in 
memory. All operands were presumed to be N 
characters. 
SUBTRACT 
BINARY 
Subtract the two specified operands and place the 
result in memory. All operands were presumed to be 
N-groups of 6 bits. 
SUBTRACT 
DECIMAL 
Subtract the two specified operands and place the 
result in memory. All operands were presumed to be 
N characters. 
MULTIPLY 
The two operands of N characters each were 
multiplied to yield a 2N result that was stored in 
memory. 
DIVIDE 
A Dividend, the first operand, of 2N characters, was 
divided by the Divisor, the second operand of N 
characters yielding a Quotient of N characters which 
were stored in memory. Relative Register C specifies 
where the high-order bit of the Quotient was placed in 
memory. If a Quotient of more than N characters 
would result, the division fails and the overflow 
indicator in the Comparison Register was set. 
 
When performing decimal arithmetic, any character not in the set 0-9 
acted as an End-Of-Field character and terminated the operation.  
 
11.8.10.1 Conversions 
 
The arithmetic section was also used to convert numbers from BCD to 
binary and vice versa. The number of characters to be converted was 
specified by the N part of the instruction. The operand could be retrieved 
from any of areas A, B, or C. Area D was used to store partial results. 
Relative Registers B and C specified the source of the operation and the 
destination of the result, respectively. Table 11-39 describes the Philco 
2400 conversion instructions. 
 
Table 11-39. Philco 2400 Conversion Instructions 
Instruction 
Description 
BCD TO BINARY, 
INTEGRAL 
Convert N characters from BCD to binary starting 
at the EA given by Relative Register B plus the 
specified Base Register and place the result at the 
EA given by the Relative Register C plus the 
specified Base Register. 

Chapter Eleven 
 
286
BCD TO BINARY, 
FRACTIONAL 
As above, but the most significant digit was 
addressed first. 
BINARY TO BCD, 
INTEGRAL 
Convert N groups of 6 bits from binary to BCD 
starting at the EA given by Relative Register B plus 
the specified Base Register and place the result at 
the EA given by the Relative Register C plus the 
specified Base Register. 
BINARY TO BCD, 
FRACTIONAL 
As above, but the least significant 6 bits were 
accessed first. 
 
11.8.10.2 Shift Instructions 
 
These instructions caused N characters to be shifted one bit left or 
right. The characters to be shifted were specified by any base register plus 
its relative register and the result was placed in memory designated by 
another base register and its relative register. The bit shifted out of the N 
character was not stored. A zero bit was always shifted into the vacated 
position in the first character. These instructions used registers in the 
Program Section and did not tie up the Arithmetic Section. Table 11-40 
describes the Philco 2400 shift instructions. 
 
Table 11-40. Philco 2400 Shift Instructions 
Instruction 
Description 
SHIFT LEFT {A, B, C} 
Shift the specified characters one bit left. 
SHIFT RIGHT {A, B, C} 
Shift the specified characters one bit right. 
 
11.8.10.3 Logical Instructions 
 
These instructions performed logical bit-by-bit operations on N 
characters specified by the N part of the instruction. The first operand was 
specified by BAR {A, B, C, or P} plus the Relative Register A and the 
second operand by BAR {A, B, C, or P} plus the Relative Register B. The 
result was placed at the memory location specified by BAR {A, B, C, or 
P} plus the Relative Register C. Table 11-41 describes the Philco 2400 
logical instructions. 
 
Table 11-41. Philco 2400 Logical Instructions 
Instruction 
Description 
Exclusive OR 
Performed an exclusive OR on the two operands 
and placed the result in memory. 
EXTRACT – 
Performed 
logical 
multiplication 
of 
the 

Philco Ford Computers 
 
287 
LOGICAL 
MULTIPLICATION 
corresponding bits of the two operands. [Similar to 
the Philco 2000’s EXTRACT operation.] 
EXTRACT – ZERO 
MASK, LOGICAL 
COMPLEMENTED 
MULTIPLICATION 
Performed 
a 
logical 
multiplication 
of 
the 
corresponding bits after complementing the second 
operand. 
INCLUSIVE OR 
Performed an inclusive OR on the two operands 
and placed the result in memory. [Similar to the 
PHILCO 2000’s D0RMS instruction.] 
11.8.11 Philco 2400 I/O Devices 
Source: Philco 1962c 
 
The Philco 2400 provided a standard suite of I/O devices to support the 
I/O handling operations that it performed for the TRANSAC S-2000. 
These devices and their speeds were: 
 
Magnetic Tape Drive: 90,000 cps 
Printer: 900 lines per minute 
Punched Card Reader: 2,000 cards per minute 
Punched Card Punch: 250 cards per minute 
Paper Tape Reader: 1000 cps 
Paper Tape Punch: 60 cps 
 
The Philco 2400 could accommodate up to eight I/O control units, of 
which three were required for the minimum configuration with the 
following assignments: 
 
Control Unit 1: Punched Card Reader and Punch Control Unit 
Control Unit 2: DMNI/DMNO Control Units 
Control Unit 3: Magnetic Tape Control Unit 
 
I/O control Units could be used for a variety of devices.  
11.9 Assessment of the Philco Machines 
The character-based operations of the Philco machines may seem odd 
to the modern reader (except perhaps those familiar with the IBM 
360/370/390 assembly language). These machines were developed when 
the computing industry was still trying to find its identity. It was trying to 

Chapter Eleven 
 
288
determine whether it would be focused solely on scientific computation, or 
expand into business data processing and other application areas. 
Problems with SBT’s in the transact S-2000 arose from the fact that 
individual transistors could have different performance characteristics. 
One could not simply replace one transistor with another, but had to hand-
select a replacement transistor with the right performance parameters. The 
first model of the S-2000, model 210, was delivered to the Western 
Development Laboratories in Palo Alto, California for further software 
development and in-house use. Beginning with model 211, Philco used 
micro-alloy diffusion transistors (MADTs), a variant of the field effect 
transistor, which exhibited more uniform and stable unit-to-unit 
performance characteristics. This necessitated a redesign of the S-2000 
that required considerable effort. However, the result was a more reliable 
machine with much improved performance. 
Rosen (2004) believed that Philco underestimated IBM’s commitment 
to computing systems. He suggested that Philco executives did not believe 
IBM was able to switch from its large investment in vacuum tube 
technology for the IBM 700 series to utilize the new transistor technology. 
He also believed they did not understand the amount of resources need to 
develop, support, and maintain large computer systems – an area in which 
IBM had significant experience. And, the problems with SBTs mean that 
Philco computer systems did not perform as well as expected. 
The Philco Transac S-2000 has been claimed to be the first large-scale 
transistorized computer (Philco UNKh). However, there were several 
contemporary transistorized computing machines – in whole or in part – 
which make it difficult to validate this assertion. 
The Philco Transac S-2000 was also an early adopter of asynchronous 
logic. In an asynchronous computer, a new instruction began execution on 
the signal that the previous operation had been completed. In a 
synchronous computer, each operation began on a clock tick specified by a 
real-time clock. 
 
 
 

CHAPTER TWELVE 
BENDIX G-20 
 
 
 
Bendix built on the success of the G-15 by developing and 
manufacturing a more capable machine. The Bendix G-20 system was a 
general purpose mainframe, constructed of transistorized modules and 
magnetic core memory. The G-20 was a 32-bit machine plus contained an 
extra bit for parity. It could support up to 32 KWords of memory. It was 
built using a little over 5,000 transistors and 30,000 diodes. (Bendix 
1962g, Bendix 1963i) 
The G-20 operated on both single- and double-precision floating point 
numbers. It also provided a feature known as Pick-A-Point which allowed 
a custom scaling of a floating point number. Using a special form of Pick-
a-Point, the G-20 could represent and operate upon integers. The Bendix 
G-20 is depicted in Figure 12-1. 
 
 
 
Figure 12-1. Bendix G-20 
Source: Bendix 1962g 
12.1 Bendix G-20 System Architecture 
The Bendix G-20 system architecture is depicted in simplified form in 
Figure 12-2. Figure 12-3 depicts a Bendix G-20 advertisement. 
 

Chapter Twelve 
 
290
 
 
Figure 12-2. Bendix G-20 System Architecture 
Source: Adapted from Bendix 1962g 
 
The address of the next command or instruction was placed in the 
Memory Address Register (MAR), The word at the specified address was 
transferred to the Memory Buffer, where it was decoded and the operand 
address placed in the MAR. The instruction was transferred to the 
Arithmetic Unit while the operand was being fetched. The word at the 
operand address was loaded into the Memory Buffer. 
If indirect addressing was specified, this cycle was repeated until the 
memory yielded an operand, which was transferred from the Memory 
Buffer to the Arithmetic Unit. The instruction with its operand was then 
executed using the Accumulator. The result was placed back into the 
Memory Buffer for transfer to the Memory. 
If the command required operand assembly, e.g., an index register was 
used, the operand from the instruction was transferred to the Operand 
Assembly (OA) register. Since the first 63 words of memory were used as 
index registers, indexing involved additional fetches from main memory. 
 

Bendix G-20 
 
291 
 
 
Figure 12-3. Bendix G-20 Computer System Advertisement 
Source: Bendix Corporation UNK 
 
 
 
 

Chapter Twelve 
 
292
Table 12-1. Bendix G-20 – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal 
Representation 
Floating Point Binary 
# Bits/Word 
32 
# 
Instructions/Word 
1 
# Instructions 
110 
# Bits/Instruction 
32 
Instruction Type 
One Address 
CPU Technology 
Transistors and diodes; 1 microsecond clock 
CPU Registers 
See below 
Main Memory 
Magnetic Core: 4K – 32K Words; Cycle time: 6 
microseconds 
Add Time 
Floating Point: 13 - 27 microseconds 
Multiply Time 
Floating Point: 56 - 70 microseconds 
Divide Time 
Floating Point: 98 - 112 microseconds 
12.1.1 Arithmetic Unit 
The Arithmetic Unit performed all operations in parallel using 50-bit 
double precision floating point arithmetic. The mantissa was 42 bits, the 
exponent was 6 bits, and there were 2 sign bits – one for the mantissa and 
one for the exponent. Numbers could be stored as either 29-bit single-
precision values or 50-bit double-precision values.  
12.1.2 Registers 
The accumulator actually consisted of three registers, which held, 
respectively: 
x The 14-octal digit mantissa of an operand 
x The sign of that operand 
x The 2-octal digit exponent and the sign of that exponent. 
 
The G-20 used the first 63 words of memory as index registers. This 
added 8 microseconds to instruction execution time when indexing was 
specified. 
The Operand Assembly (OA) register was similar to the accumulator 
but contained the 14-octal digit mantissa, sign, and 2-octal digit exponent 
in a single register. It was used solely for address calculations as Horning 

Bendix G-20 
 
293 
(2006) believes that it would have been a waste to use the accumulator for 
such computations. The contents of the OA were added to a 15-bit base 
address from the instruction, followed by indexing and indirection, if 
specified. Normal instruction cleared the OA before the next instruction, 
but a special class of instructions stored their result in the OA. 
12.1.3 Core Memory 
The G-20 supported core memory from 4 KWords up to 32 KWords in 
increments of 4 KWords. Up to 8 KWords was installed in the main 
processor cabinet. The remaining memory was installed in an Auxiliary 
Memory Cabinet. Each word consisted of 32 bits plus a parity bit.  
12.1.4 Interrupts 
The G-20 provided two types of interrupts requests: automatic requests 
and enabled requests. Automatic requests were generated by certain 
machine conditions, such as an attempt to execute an illegal opcode or 
reference a nonexistent address, and also by I/O devices. Enabled requests 
originated with the setting of flags in certain instructions or via an 
interrupt request from the real-time clock. The G-20 provided four circuits 
on which it could receive interrupts and two circuits on which it could 
transmit interrupts.  
An interrupt could not occur unless the master interrupt control was 
enabled. An interrupt request was stored in IR and could cause an interrupt 
at a future time if the master interrupt control was currently off. A program 
could clear an interrupt request at any time up until the master interrupt 
control was enabled. 
When an interrupt of either type occurred and the master interrupt 
control was enabled, the execution of the current program was suspended. 
The computer stored the current contents of NC in word 64 and fetched 
the address of the Interrupt Service Routine (ISR) from location 65. The 
ISR determines which bit(s) were set in the IR and dispatches to the 
appropriate routines to handle these requests. For external interrupts from 
I/O devices, the ISR determines the particular line on which the interrupt 
request occurred and then polled the known units on that line to see which 
one generated the interrupt. 

Chapter Twelve 
 
294
12.2 Instruction Set Architecture 
The Bendix G-20 instruction set architecture was a single-address 
machine which supported flexible addressing. The format of an instruction 
is depicted in Figure 12-4. 
 
 
 
Figure 12-4. Bendix G-20 Instruction Format 
Source: Adapted from Bendix 1962g 
 
FF represented two flag bits. M represented the addressing mode, 
which determined how the effective address was computed. Its operation 
was given by the following table, where OA specified an operand 
assembly register, an index register (I), and the address in the instruction 
(A). Table 12-2 describes the addressing modes. 
 
Table 12-2. Bendix G-20 Addressing Modes 
Address Mode Bits 
Description 
00 
X = c(OA) + A + c(I) 
01 
X = c(OA) + c(A) + c(I) 
10 
X = c(c(OA) + A + c(I)) 
11 
X = c(c(OA) + c(A) + c(I)) 
 
Simple addressing with single command words used no indexing. The 
I field contained six bits which allowed access to all 63 index registers. 
Location 0 was not an index register. Commands requiring more than one 
level of indexing had to use general address arithmetic to construct the 
operand address using the address preparation commands. 
A few commands could not be indexed, specifically those commands 
dealing with the bus register or the index registers. 
12.2.1 Add/Subtract Operations and Tests 
All arithmetic commands were carried out in double precision floating 
point. Left or right shifts were performed only when needed to equalize 
exponents or prevent overflow or underflow. Exponent equalization was 
performed by left shifting the number with the larger exponent. In most 

Bendix G-20 
 
295 
cases, this was satisfactory. But, when it was not the other number was 
shifted right as necessary and rounded off. 
The hardware accessed the I field as a number. Under certain 
conditions, this allowed the contents of the I field to be used as an 
operand. For example, with mode 1, two numbers in OA or Acc could be 
added by a single command: 
 
OCA- 
(Acc) + (I) 
 
which yielded 
 
(OA)  + (Acc)  + (I) -> OA 
CLA- 
(B) + (J) 
 
which gave 
 
(OA) + (B) + (J) + (Acc) -> Acc. 
 
The net result was: (OA) + (Acc) + (I) + (B) + (J) + (Acc) -> Acc. The 
Add/Subtract operations are presented in Table 12-3. In the following 
instructions, X represents the address contained in the instruction. 
 
Table 12-3. Add/Subtract Operations 
Mnemonic 
Description 
CLA X 
Clear and Add: Acc <- c(X) 
CLS X 
Clear and Subtract: Acc <- -c(X) 
ADD X 
Add X to Acc: Acc <- c(Acc) + c(X) 
SUB X 
Subtract X from Acc: Acc <- c(Acc) – c(X) 
ADN X 
Add and Negate: Acc <- -(c(Acc) + c(X)) 
SUN X 
Subtract and Negate: Acc <- -(c(Acc) - c(X)) 
ADA X 
Add and Take Absolute Value: Acc <- |c(Acc) + c(X)| 
SUA X 
Subtract and Take Absolute Value: Acc <- |c(Acc) - c(X)| 
 
The Arithmetic Test operations are presented in Table 12-4. Note that 
after the instruction was fetched, the PC was incremented b one. If the test 
was successful, another increment caused that instruction to be skipped. 
 
 
 

Chapter Twelve 
 
296
Table 12-4. Arithmetic Test Operations 
Mnemonic 
Description 
FOP 
If Operand Plus: if X > 0, NC <- NC + 1 
FOM 
If Operand Minus: if -X > 0, NC <- NC + 1 
FGO 
If c(Acc) Greater Than Operand: -X + c(Acc) > 0, NC <- 
NC + 1 
FLO 
If c(Acc) Less Than Operand: -[-X + c(Acc)] > 0,  NC <- 
NC + 1 
FUO 
If c(Acc) Unequal to Operand: [-X + c(Acc)] > 0, NC <- NC 
+ 1 
FSP 
If Sum Plus: if X + c(Acc), NC <- NC + 1 
FSM 
If Sum Minus: if –[X + c(Acc)], NC <- NC + 1 
FSN 
If Sum Non-Zero: if |X + c(Acc)|, NC <- NC + 1 
12.2.2 Logic Operations and Tests 
Logic operations and tests drew words from memory in number 
format, except for the final access n addressing modes 2 and 3 which use 
logic format. In logic format, the exponent was all zeroes, rendering the 
number as an integer. Bits 41-32 of the accumulator were cleared in logic 
operations, but undisturbed in logic tests.  In the instructions shown in 
Table 12-5, an operand underlined indicates that that operand was 
complemented. 
 
Table 12-5. Logic Operations 
Mnemonic 
Description 
CAL 
Clear and Add Logic Word: Acc <- X0-31 
CCL 
Clear and Add Complement Logic Word: Acc <- X0-31 
ADL 
Add Logic Word: Acc <- [c(Acc) + X] 0-31 
SUL 
Subtract Logic Word: Acc <- [c(Acc) - X] 0-31 
EXL 
Extract with Logic Word: Acc <- [c(Acc) AND X] 0-31 
ECL 
Extract With Complement of Logic Word: Acc <- [c(Acc) 
AND X] 0-31 
UNL 
Unite With Logic Word: Acc <- [c(Acc) OR X] 0-31 
UCL 
Unite With Complement of Logic Word: Acc <- [c(Acc) OR 
X] 0-31 
 
Table 12-6 presents the logic tests. In each of these tests, if the test was 
satisfied, execute the next instruction; otherwise, skip it and execute the 
one thereafter. 

Bendix G-20 
 
297 
Table 12-6. Logic Tests 
Mnemonic 
Description 
IOZ 
If Operand Zero: X 0-31 = 0 
ICZ 
If Complement of Operand Zero: X 0-31 = 0 
ISN 
If Sum Nonzero: [X + c(Acc)] 0-31 = 0 
IUO 
If Unequal to Operand: [-X + c(Acc)] 0-31 = 0 
IEZ 
If Extraction Zero: [c(Acc) AND X] 0-31 = 0 
IEC 
If Extraction of Complement Zero: [c(Acc) AND X] 0-31 = 0 
IUZ 
If Union Zero: [c(Acc) OR X] 0-31 = 0 
IUC 
If Union of Complement Zero: [c(Acc) OR X] 0-31 = 0 
12.2.3 Repeated Commands 
A block of commands could be executed repeatedly. An R was 
prepended to the instruction mnemonic and the number of times to execute 
the command was appended to the operand. So, to repeat an ADD 
command, we might write: 
 
RADD A+(I), B 
 
where B was the number of times to repeat the command. This command 
placed in the accumulator the value c(Acc) + 6 Qi, i = 1,B. 
The repeat command occupied two words of memory. A block length 
of zero caused an error. Figure 12-5 depicts the format of the repeat 
command. 
 
 
 
Figure 12-5. Repeat Command Instruction Format 
Source: Adapted from Bendix 1962g 
 
A repeated test command could be terminated early if the test condition 
was not satisfied. All of the instructions in the previous sections could be 
repeated.  

Chapter Twelve 
 
298
12.2.4 Multiply/Divide 
Multiplication and division were performed by three commands as 
depicted in Table 12-7. The multiplicand was the contents of Acc, while 
the multiplier was X. The multiplicand was a binary number normalized 
prior to multiplication. For division, both operands were binary numbers 
normalized prior to division. The quotient was truncated and the remainder 
was lost. 
 
Table 12-7. Multiply/Divide 
Mnemonic 
Description 
MPY X 
Multiply: Acc <- c(Acc) * X 
DIV X 
Divide: Acc <- c(Acc)/X 
RDV 
Reverse Divide: Acc <- X/c(Acc) 
 
Shifting was accomplished by taking advantage of the fact that the 
hardware could automatically shift a number left or right so as to reduce 
its exponent to zero. Thus, shifting was accomplished by multiplying by 1, 
2, or 4 times, followed by a reduction to zero exponent, which yielded a 
fraction between 0 and 1. 
Suppose we had two words A1 and A2. We want to combine the last 
two characters of A1 and the first two characters of A2 and store the result 
in A3. We could use the following code (Bendix 1962g): 
 
CAL 
A1 
; load A1 into accumulator 
MPY 
L16 
; multiply by L16 = 2*85 = 216 
STL 
A3 
; reduce to zero exponent, truncate and store 
CAL 
A2 
; load A2 
MPY 
R16 
; multiply by R16 = 4*8-6 = 2-16 
UNL 
A3 
 ; reduce to zero exponent, truncate and unite 
with A3 
STL 
A3 
; store 
12.2.5 Storage Operations 
The G-20 storage operations are depicted in Table 12-8. For STL, the 
number was shifted to a zero exponent prior to being stored. For STD, bit 
29 of location X was set to one which told the hardware to also fetch the 
contents of X+1. 
 
 

Bendix G-20 
 
299 
Table 12-8. Storage Operations 
Mnemonic 
Description 
STL X 
Store Logic Word: EXP <- 0; X <- c(Acc) 0-31 
STD X 
Store Double Precision: X 0-20 <- c(Acc) 0-20; 
(X+1) 0-20 <- c(Acc) 21-41 
STS 
Store Single Precision: (X) 0-20 <- c(Acc) 21-41 
STI 
Store Integer: X 0-20 <- c(Acc) 0-20 
STZ 
Store Zero: X 0-31 <- 0 
12.2.6 Index Operations 
Index operations that set and stored the index registers are described in 
Table 12-9. They could not be indexed because the portion of the 
instruction used for the index register specified which one to set or store.  
 
Table 12-9. Index Operations 
Mnemonic 
Description 
LXP 
Load Index Plus: I <- X 
LXM 
Load Index Minus: I <- -X 
ADX 
Add to Index: I <- c(I) + X 
SUX 
Subtract from Index: I <- c(I) - X 
XPT 
Load Index Plus and Test: I <- X; 
if I = 0, skip next instruction 
XMT 
Load Index Minus and Test: I <- -X; 
if I = 0, skip next instruction 
AXT 
Add to Index and Test: I <- c(I) + X; 
if I = 0, skip next instruction 
SXT 
Subtract from Index and Test: I <- c(I) - X; 
if I = 0, skip next instruction 
12.2.7 Control Operations 
The control operations handled transfer of control within a program. 
TRA represented an unconditional transfer. TRM represented a subroutine 
call. TRE turned on the master interrupt flip-flop after the transfer. This 
feature could be used to execute a program one command at a time. Table 
12-10 depicts the control operations. 
 
 
 

Chapter Twelve 
 
300
Table 12-10. Transfer Operations 
Mnemonic 
Description 
TRA 
Transfer [to X]: NC <-X 0-14 
TRE 
Transfer and Enable Interrupts: NC <-X 0-14 
SKP 
Skip X Words: NC <- (NC + X) 0-14 
TRM 
Transfer to X+1; Mark in X: X <- c(NC); NC <- X+1 0-14 
12.2.8 I/O Operations 
I/O operations either transmitted a single character or a block of 
characters. Table 12-11 depicts the I/O operations. 
 
Table 12-11. I/O Operations 
Mnemonic 
Description 
TLC 
Transmit Line Command: Command <- X 0-7 
TDC 
Transmit Data Character: Data <- X 0-7 
 
Block Transfer operations transmitted a block of words to or from a 
device. A G-20 word accommodated one 8-bit and four 6-bit characters or 
four 8-bit characters. Packing and unpacking of the data was performed 
automatically by the hardware. The format of a Block transfer operation is 
depicted in Figure 12-6. Table 12-x presents six block transfer 
instructions. 
 
 
 
Figure 12-6. Block Transfer Instruction Format 
Source: Adapted from Bendix 1962g 
 
 
 

Bendix G-20 
 
301 
Table 12-12. Block Transfer Operations 
Mnemonic 
Description 
BTD8 A+I (B) 
Block Transmit Data 8-bit Characters: transfer a block 
of 8-bit characters (B) to the device. 
BTC8 A+I (B) 
Block Transmit Commands 8-bit Characters: transfer a 
block of 8-bit characters (B) to the device. 
BRD8 A+I (B) 
Block Receive Data 8-bit Characters: transfer a block 
of 8-bit characters (B) from the device. 
BTD6 A+I (B) 
Block Transmit Data 6-bit Characters: transfer a block 
of 8-bit characters (B) to the device. 
BTC6 A+I (B) 
Block Transmit Commands 6-bit Characters: transfer a 
block of 8-bit characters (B) to the device. 
BRD6 A+I (B) 
Block Receive Data 6-bit Characters: transfer a block 
of 8-bit characters (B) from the device. 
 
The normal mode of operation was to transmit and receive 8-bit 
characters. 6-bit characters were used when the vocabulary was limited to 
63 characters to save some time and space. 
12.2.9 Bus Register Operations 
The G-20 provided four program-accessible registers that the 
programmer could read and write, as described in Table 12-23. 
 
Table 12-13. Bendix G-20 Bus Registers 
Bus Register 
Description 
Next Command 
Address Word (NC) 
Contains the address of the next instruction to be 
executed. 
Pickapoint Exponent 
(PE) 
Contains the pickapoint address. 
 
Control and Enable 
(CE) 
Contains a set of flags which can be set by the 
program to permit computation to be interrupted 
when an interrupt request occurs. CEO controls 
all requests. 
Interrupt Request (IR) 
A set of flags which were set when an interrupt 
request was generated for certain machine 
conditions, or external devices. 
 
All but PE were 15 bits in length; PE was 7 bits in length. Table 12-14 
presents the bus register operations. 
 

Chapter Twelve 
 
302
Table 12-14. Bus Register Operations 
Mnemonic 
Description 
LDR 
Load Register: load one of CE, IR, LRE, PE: I <- X0-14 or I 
<- X0-6 
EXR 
Extract Register I into itself: I <- [(I) AND X]0-14 
ERO 
Extract Register I into OA: OA <- [(I) AND X]0-14 
ERA 
Extract Register I into Accumulator: A <- [(I) AND X]0-14 
12.3 I/O System 
Source: Bendix 1962g 
 
The G-20 provided an array of input and output devices including 
paper tape reader and punch, magnetic tape subsystem, card reader, and 
operator’s console. These devices were connected to the G-20’s interrupt 
circuits. 
A high-speed magnetic tape system read or wrote data at up to 120,000 
characters per second. Software libraries allowed the magnetic tape system 
to operate as an addressable storage system based on a block length of 512 
words.  
A paper tape unit could punch data at a rate of 110 cps. It could read 
forward or backward at a rate of 500 cps.  
A Card-Printer Coupler allowed conventional 80-column card readers 
or unbuffered line printers to be attached to the G-20. The line printer 
could print at a rate up to 1,500 lines per minute. 
The operator console was an 88-character typewriter configured with a 
set of indicator lights which could be used to provide the operator with 
data on the status of the machine and programs running on it. 
Communication with external devices was handled directly by the 
central processor through connected devices. The CP packed and 
unpacked words into 6-bit or 8-bit characters. It could transmit or receive 
data at rates up to 200,000 cps. 
12.4 G-21 Dual Processor 
The Bendix G-21 was a dual processor version of the G-20. It was 
developed as an experimental machine at Carnegie Institute of Technology 
(now CMU) in the summer of 1963 (Quatse 1965). 
The G-21 used a combination of a bus and portal system in which two 
CPUs were connected to eight memory modules (MM). The bulk memory 
was a planned enhancement to the system. From each MM, three terminals 

Bendix G-20 
 
303 
exited: one to a display controller (DC), one terminal to the high capacity 
bus connecting MMs to CPUs, and one terminal to a general exchange 
controller (GXC). The DC acted as bus to connect up to four CRTs. This 
allowed users to play a version of SpaceWar which enabled each player to 
see the other’s ships on his screen. Buttons were used for thrust control, 
changing direction, and firing missiles. 
The GXC acted as a bus to connect up to four telephone channels 
connected to 202A data phone sets. The GXC contained a single character 
register acting as a buffer to each 202A. 
Seven of the MMs of 8 KWords each provided 56 KWords of common 
memory. The eighth MM provided 4 Kwords of private memory to each of 
the processors. Another 4 KWords of private memory were housed in the 
processor frame. Internal memory operated on a 3 microsecond cycle 
while the external memory operated on a 4 microsecond cycle. 
I/O access to memory was through the CPUs. Buffer card equipment, 
magnetic tape drives, and rotating disc memory were attached to the CPUs 
through a general exchange interface (GXI). These devices were 
programmably switchable from one CPU to the other. A 900 lines per 
minute printer was attached to each CPU and was not switchable. This 
allowed a means of outputting messages from the CPU without having to 
switch a printer. 
12.4.1 G-21 Software 
A variety of software was used with the G-21. The supervisory 
program was called MONITOR. The directory system was called AND – 
Alpha Numeric Directory. 
Several programming languages were available. The principal one was 
Algol-20, a variant of Algol 60. They also used the programming 
languages IPL-V and COMIT. 
12.5 Bendix G-20 Assessment 
Bendix sold its computer division to Control Data Corporation (CDC) 
in 1963. CDC terminated the G-20 in favor of its 160A and 1604 systems. 
As with the Bendix G-15, the Bendix G-20 seemed to be a dead end in 
computer architecture.  However, it showed that “personal computing” in 
the sense of “one person, one computer” was a viable concept, although 
not cost beneficial with the technology of the 1960s.     

CHAPTER THIRTEEN 
PACKARD BELL 
 
 
 
Packard Bell Electronics was founded by Herbert Bell and Leon 
Packard in 1933. However, Leon Packard was bought out in 1935 after 
disagreements over company direction. Originally, Packard Bell 
manufactured radios and electronic components. After World War II, they 
moved into manufacturing consumer electronics, such as television sets. 
Raytheon acquired the Packard Bell computer operations in 1964. 
Teledyne Corporation acquired the remainder of Packard Bell in 1968, 
after which time it was referred to as Teledyne Packard Bell.  
In 1961, Packard Bell Electronics introduced the Packard Bell 250, 
which was constructed from discrete logic components (transistors and 
diodes), but used a multiple nickel-steel magnetostrictive delay lines for its 
memory. Its CPU was completely comprised of solid-state components. It 
processed data one bit at a time. Figure 13-1 depicts the Packard Bell 250 
(Packard Bell 1961a). To some, it looked like two suitcases tied together 
on top of a pedestal. 
 
 
 
Figure 13-1. Packard Bell 250 
Source: Packard Bell 1961a 

Packard Bell 
 
305 
Figure 13-2 depicts a close-up of the front panel of the PB250. Note 
that the design was relatively simple because the objective was to 
communicate with the machine through its operator’s console, a Friden 
Flexowriter. 
 
 
 
Figure 13-2. Packard Bell 250 Front Panel 
Source: Packard Bell 1961a 
 
The Packard Bell B250 (PB250) was a single address computer. 
However, it included an index register which allowed line number 
modification. Usually, one instruction was read from memory at a time. 
However, a minimum access scheme, specified by a tag bit, was present 
which if set, allowed the next word to be read immediately. Table 13-1 
describes the basic characteristics of the PB 250. 
 
 
 
 

Chapter Thirteen 
 
306
Table 13-1. Packard Bell 250 – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal 
Representation 
Fixed Point Binary 
# Bits/Word 
21 + sign bit + 1 parity + 1 guard bit 
# Instructions/Word 
1 
# Instructions 
63 
# Bits/Instruction 
22 
Instruction Type 
One Address 
CPU Technology 
Discrete Logic: Transistors and Diodes; cycle 
time: 12 microseconds 
CPU Registers 
Arithmetic Registers: A, B, and C – each 22 bits; 
one Index Register 
Main Memory 
Magnetostrictive Delay Line: 1808 words, but 
expandable in 256 word increments to 15,888 
words; Avg. Access Time: 96 microseconds 
Add Time 
Fixed Point: 12 microseconds 
Multiply Time 
Fixed Point: 276 microseconds 
Divide Time/Square 
Root 
Fixed Point: 252 microseconds 
NOTE: This Packard Bell Corporation was NOT the Packard Bell Corporation that 
produced personal computers in the 1990s. 
13.1 PB250 System Architecture 
The PB250 was a serial bit processing system. All operations were 
controlled by a central clock that operated at 2 megacycles giving a 
processing time of about 12 microseconds. The serial approach required 
fewer parts and provided greater reliability. Figure 13-3 depicts the 
Packard Bell System Architecture (Weik 1961). 
 
 

Packard Bell 
 
307 
 
 
Figure 13-3. Packard Bell 250 System Architecture 
Source: Adapted from Weik 1961 
 
Interestingly, the PB250 could distribute the central clock to two other 
machines, thus raising the possibility of multi-processor operation. 
However, it is not known if this arrangement was ever accomplished. 
13.1.1 Central Processor 
Source: Packard-Bell 1961d 
 
The CPU consisted of an arithmetic unit and a control unit as depicted 
in Figure 13-3. Three arithmetic registers, - labeled A, B, and C – were 
used for arithmetic and information handling operations. For double 
precision instructions, A and B were considered to be a single register. An 
index register stored a line number and was used to replace the line 
address in commands which had an index tag of one.  Consider the 
following instruction: 
 
ADD  03204 1 
 
// 1 is the value of the index tag 
 
If the index register contained the line number 01, then the operand 
would be fetched from 03201 rather than 03204. 
The Index Register was accessed via addresses 00037 through 37737. 
Bit positions 16 through 21 were the useful bit position in the index 

Chapter Thirteen 
 
308
register. Thus, STA 00037 would place the contents of A into bits 
positions 16 - 21 of the index register. 
The Machine Sector Counter had the following format depicted in 
Figure 13-4. Bit G was the guard bit and bit P was the parity bit. The Input 
Buffer register was an element of the machine Sector Counter. 
 
 
 
Figure 13-4. PB250 Machine Sector Counter 
Source: Packard Bell 1961d 
 
It received input from the Flexowriter as an 8-bit character. Because 
the PB250 was a bit serial machine, data entered into the Input Buffer was 
accumulative with bits being shifted left as new bits arrived. Thus, the 
Input Buffer had to be cleared before each input. Input was provided by 
either the READ TYPEWRITER KEYBOARD or READ PAPER TAPE 
instructions. 
13.1.2 Main Memory 
The PB250 used nickel steel magnetostrictive delay lines, constructed 
from nickel-steel wire, for its primary memory. There were three types of 
delay lines: long, short, and register. Long lines held 256 24-bit words, 
while short lines held sixteen 24-bit words. Register lines held just one 24-
bit word. 
It contained ten lines numbered octally 00 through 11. Line 008 was a 
fast access line containing 16 words. Each of the long lines 018 through 
118 contained 256 words, also called sectors. Sectors were numbered 0008 
through 3778. 
A word, which could contain either data or commands, was addressed 
by its line number and sector number. Acoustic pulses were entered onto 
the wire via a transmitter, traveled the length of the wire, and were picked 
up by a receiver at the other end. The receiver generated a bit which was 

Packard Bell 
 
309 
sent to the computational electronics at the same time it passed the data to 
the transmitter to re-enter on the wire. A word consisted of a sign bit, 21 
data bits, a guard bit, and a parity bit.  The sign bit plus the 21 data bits 
were used to represent a 6-digit decimal number. 
Each word included an additional parity bit which was used for an 
even parity check. Parity bits were generated during the STORE and 
MOVE commands. A parity check was performed during arithmetic 
commands and reading commands. Computation would stop when a parity 
error was detected, but could be restarted by clearing the parity flip-flop 
through the BREAKPOINT switch and ENABLE switch on the 
Flexowriter.  
The basic memory was 1808 words long. However, it could be 
expanded to 15,888 words through additional lines of 256 words. Up to 53 
additional lines could be added to the machine. These lines were numbered 
128 through 368 and 408 through 778. Line 378 was designated as the Index 
Register. 
The average access time for the delay line was about 1,540 
microseconds. Commands could be executed only from lines 008 through 
078. Thus, these lines were often called command lines. 
The PB250 kept a running tally of the number of hours of operations. 
Presumably, this was used for accounting purposes and also, perhaps, for 
maintenance. 
13.1.3 Flexowriter 
The PB250 used a Friden Flexowriter as its operator console. The 
Flexowriter consisted of a keyboard, typewriter, paper tape reader and 
punch. Paper tapes could be prepared manual via the keyboard or by being 
punched from a program. The paper tape reader could read and print the 
contents of a paper tape either manually or under program control. The 
Flexowriter is depicted in Figure 13-5. (Packard Bell 1961a). 
 

Chapter Thirteen 
 
310
 
 
Figure 13-5. Flexowriter Console 
Source: Packard Bell Computer 1961b 
 
The Flexowriter had several switches and keys that were used to 
control the computer. The ENABLE SWITCH interrupted computation 
and also enabled other switches. The 1 Key pressed in combination with 
the ENABLE SWITCH caused the computer to execute the command in 
memory location 00001. The C Key pressed in combination with the 
ENABLE SWITCH caused the computer to execute one command. The 
BREAKPOINT SWITCH sent a signal to the computer which could be 
tested by the TES command.  
13.1.4 Other I/O Devices 
Other devices such as paper tape readers, magnetic tape drives, and 
analog-to-digital converters were also available. Up to 6 magnetic tape 
drives could be connected to a PB250. The PB250 also had 30 input lines 
which could be sampled under program control and 32 output lines on which 
signals could be placed. This permitted the PB250 to act as a controller for 
multiple pieces of equipment such as laboratory instrumentation. 
13.1.5 HYCOMP 250 
Source: Packard Bell 1961e 
 
The HYCOMP 250 was a hybrid analog digital computing system 
comprised of a PB250 and a T-50 analog computer made by Electronic 

Packard Bell 
 
311 
Associates, Inc. The PB250 could interact with the T-50 through 64 
channels of analog-to-digital communications or digital-to-analog 
communications. The A/D and D/A converters were 12 bit, 65 Kcycle 
devices. A full library of software to support engineering and scientific 
applications included A/D and D/A conversion routines, appropriate I/O 
subroutines, and numerous mathematical subroutines.  
The PB250 contained 2320 22-bit words of memory which 
communicated at a rate of 2 Mcycles/s. Memory could be expanded to 
15,888 words in increments of 256 words. 
The A/D system included a PB EM3 Multiplexor, an SH3 Sample and 
Hold Unit, and an ADC 21-12B-B Analog-to-Digital Converter. The EM3 
could be randomly addressed or sequentially stepped through the A/D 
channels. It was expandable in 2 channel increments up to the limit of the 
number of channels. The SH3 reduced the aperture time for A/D 
conversion from 14.4 microseconds to 1 microsecond. 
The Buffer and Control Unit (BCU) provided 6 bits of address and 12 
bits of data for communicating with the T-50. For A/D input, address 008 
selected the multiplexor. A channel was selected by the data bits. In 
sequential mode, after accepting data from the channel, the channel 
number was automatically increased. Channels could also be selected 
randomly for sampling purposes. The Sample and Hold unit operated in 
sample mode to accept the input, then switched to hold mode to perform 
the data conversion. The data was then read into the PB250, via the 
Transfer on External Signal (TES) command. 
For D/A operations, the data was transferred to the BCU and then 
transferred in parallel to Packard Bell DAC 20-12B-B digital-to-analog 
converter. 
13.2 PB250 Commands 
The PB250 read commands from the command lines whose addresses 
were 0008 through 3778. the next address after 3778 was 0008 for each of 
the eight command lines. One word could be read every 12 microseconds, 
so the 256 words in one line could be read and executed in 3,072 
microseconds.  
PB250 instructions were executed in four phases: (1) wait to read the 
next command; (2) read the next command; (3) wait to execute the 
command; and (4) execute the command. The PB250 instruction format is 
depicted in Figure 13-6. 
Fast Access Line words were identified by one of 16 channels. Line 00 
channels were identified by channels  

Chapter Thirteen 
 
312
 
 
Figure 13-6. Packard Bell 250 Command Format 
Source: Adapted from Packard Bell Computer 1961b 
 
Addresses consisted of a sector number and a line number: SSLL. For 
example, a command in 00001* to store A in location 03004 would be read 
in sector 000, held for execution in sectors 001 through 027, executed in 
sector 30, and held while waiting to read the next command in sectors 031 
to 000. Field S indicated a Sequence Tag which will be explained below. 
Field I specified the index register value. 
The PB250 had four classes of commands which are described in the 
following sections.  Most commands were executed from sequential 
sectors. However, to speed up operation, the sequence tag (bit 14) 
specified that the next command would be read in the sector directly 
following the execution phase.  
13.2.1 Class I Commands 
In this class, execution of the command was executed immediately 
after being read, thus skipping Phase III. Most of the commands in this 
class require an extended interval for execution, which varies with the 
command. This class included the arithmetic commands, some I/O 
commands, and some data transfer commands. Class I commands are 
presented in Table 13-2. 
 
Table 13-2. PB250 Class I Commands 
Opcode8 
Mnemonic 
Description 
00 
HLT 
Halt: Stop computation. Turn on the parity 
indicator light. To resume computation, press 
both the ENABLE SWITCH and the 
BREAKPOINT SWITCH on the Flexowriter. 
00 
MAC 
Merge A into C: B <- c(A) OR c(C) 
20 
NAD N 
Normalize and Decrement: Shift c(A,B) left until: 
 
c(A,B) >= 0.5 or c(A,B) <= -0.5, with the binary 
point between the sign and position 1, or 
c(A,B) was shifted S positions, with S selected 
by the programmer. 

Packard Bell 
 
313 
c(C) was decremented for each position shifted. 
Position 0 of A does not move, but position 0 of 
B participates in the shift. Vacated positions of B 
were filled with zeroes. C should be initialized to 
S. N specifies the address of the next command. 
21 
LSD N 
Left Shift and Decrement: c(A,B) was shifted 
left for S positions. c(C) was decremented for 
each position shifted. Vacated positions of B 
were filled with zeroes. . Position 0 of A does 
not move, but position 0 of B participates in the 
shift. C should be initialized to S. N specifies the 
address of the next command. 
22 
RSI N  
Right Shift and Increment: c(A,B) was shifted 
right for S positions. c(C) was incremented for 
each position shifted. Bits shifted past position 
21 of B were lost. The sign bit was copied into 
position1 of A after each shift. Position 0 of A 
does not move, but position 0 of B participates in 
the shift. C should be initialized to 0. N specifies 
the address of the next command. 
23 
SAI N 
Scale Right and Increment: Shift c(A,B) right 
and c(C) was incremented until: 
 
c(C) >= 0, or 
c(A,B) were shifted S positions. 
 
Bits shifted past position 21 of B were lost. The 
sign bit was copied into position 1 of A after 
each shift. Position 0 of A does not move, but 
position 0 of B participates in the shift. C should 
be initialized to 0. N specifies the address of the 
next command. 
24 
NOP 
No Operation: Proceed to fetch the next 
command. 
25 
IAM M 
Interchange A and M: A <- c(M), M <- c(A) 
26 
MLX X 
Move Line X to Line 7: Move the words in line 
X to Line 07 
30 
SQR N 
Square Root: Remainder to A, Root to B <- 
SQR(A,B); C was overwritten; N specifies the 
sector address of the next command 
 
 

Chapter Thirteen 
 
314
31 
DIV 
Divide: Remainder in A, Quotient in B <- 
c(A,B)/c(C). 
31 
DVR 
Divide Remainder: after division, divide the 
remainder in A by c(C) again 
32 
MUP 
Multiply: a,B <- c(B) * c(C) 
33 
SBR 
Shift B Right: c(A,B) was shifted right for S 
positions. The A register was cleared after 
shifting right one position. Bits shifted past 
position 21 of B were lost. N specifies the 
address of the next command. 
6X 
WOC 
Write Output Character: Write the character in 
bits 12-19 of the command to the output device 
selected by the line from which the command 
was executed. Line 05 selects the typewriter 
while line 06 selects the paper tape punch. 
70 
PTU 
Pulse to Specified Unit: Produce a specified 
combination of signals on five output lines and 
an activate on the sixth line. These signals were 
used to start and stop equipment external to the 
computer. 
71 
MCL N 
Move Command Line Block: Copy all words 
following the MLC command in the line to the 
line designated by the argument N.  
72 
BSO 
Block Serial Output: Data was shifted from the 
Data Line to the external register.  
73 
BSI 
Block Serial Input: Data presented from some 
external register was loaded directly into 
memory at the rate of 0.5 microseconds per bit. 
13.2.2 Class II Commands 
This class contained those commands which were always executed in 
the sector specified by the sector number of the command. It consisted of 
all one-sector operations. All commands required 12 microseconds to 
execute. The effective address was indicated by M. Table 13-3 depicts the 
class II commands. 
 
 
 
 
 

Packard Bell 
 
315 
Table 13-3. PB250 Class II Commands 
Opcode 
Mnemonic 
Description 
01 
IAC 
Interchange A and C: C<- c(A), A <- c(C) 
02 
IBC 
Interchange B and C: c<- c(B), B <- c(C) 
05 
LDA M 
Load A: A < c(M) 
06 
LDB M 
Load B: B < c(M) 
04 
LDC M 
Load C: C < c(M) 
11 
STA M 
Store A: M <- c(A) 
12 
STB M 
Store B: M <- c(B) 
10 
STC M 
Store C: M <- c(C) 
14 
ADD M 
Add: A <- c(A) + c(M) 
15 
SUB M 
Subtract: A <- c(A) – c(M) 
40 
EBP M 
Extend Bit Pattern: Starting from the right, each 
bit was examined. If it was 1, the corresponding 
bit in A was changed to the value of the bit to its 
immediate right. 
 
M:   1 1 1 0 0 0 1 1 1 0 0 0 
A:    0 1 0 1 0 1 0 1 0 0 0 1 
 
After EBP: 
A:  1 1 1 1 0 1 0 0 0 0 0 1 
41 
GTB 
Gray To Binary: A <- Gray(c(A)) 
42 
AMC M 
And M and C: B <- c(C) AND c(M) 
45 
CLA 
Clear A: A <- 0 
43 
CLB 
Clear B: B <- 0 
44 
CLC 
Clear C: C <- 0 
46 
AOC M 
And Or Combined: B <- (c(M) AND c(C)) OR 
(~c(M) AND c(B)) 
47 
EXF M 
Extract Field: B <- c(M) AND ~c(B) 
50 
DIU 
Disconnect Input Unit: Disable the input buffer. 
Turn off the INDICATING LIGHT of the 
Flexowriter. 
51 
RTK 
Read Typewriter Keyboard: Turn on the 
INDICATING LIGHT on the Flexowriter. Enable 
the input buffer to accet a character input from 
the keyboard. 
52 
RPT 
Read Paper Tape: Read a character form the 
Flexowriter paper tape reader into the input 
buffer.  

Chapter Thirteen 
 
316
53 
RFU 
Read Fast Unit: Accept input into the input buffer 
from a device previously energized by a PTU 
command. 
55 
LAI 
Load A From Input Buffer: Copy input buffer to 
A14-21. 
56 
CAM 
Compare A to M: compare c(A) to C(M). If 
equal, turn Overflow Switch on; otherwise, it was 
turned off. 
57 
CIB 
Clear Input Buffer: Set the input buffer to zeroes. 
13.2.3 Class III Commands 
This class handled double precision operations. Execution started in 
the sector specified in the command, but extended into the following 
sector. All commands in this class required 24 microseconds to execute. 
Table 13-4 depicts the class III commands. 
 
Table 13-4. PB250 Class III Commands 
Opcode 
Mnemonic 
Description 
03 
ROT 
Rotate: C <- c(A), B <- c(C), A <- c(B) 
07 
LDP M 
Load Double Precision: B <- c(M), A <- c(M+1) 
13 
STD 
Store Double Precision: M <-C(B), M+1 <- c(A) 
16 
DPA M 
Double Precision Add: A,B <- c(A, B) + c(M, 
M+1) 
16 
DPS M 
Double Precision Subtract: A,B <- c(A, B) - c(M, 
M+1) 
13.2.4 Class IV Commands 
This class contained the commands for conditional and unconditional 
transfer of control. The condition was tested and, if met, the next 
command was read from the line and sector specified in the command. If 
the condition was not met, sequencing proceeded to the following 
command. Table 13-5 depicts the class IV commands. 
 
 
 

Packard Bell 
 
317 
Table 13-5. PB250 Class IV Commands 
Opcode 
Mnemonic 
Description 
37 
TRU N 
Transfer Unconditionally: Next command was 
taken from address N 
35 
TAN N 
Transfer if A Negative: if c(A) < 0, next 
command at address N; else next command in 
following sector 
36 
TBN N 
Transfer if B Negative: if c(B) < 0, next 
command at address N; else next command in 
following sector 
34 
TCN N 
Transfer if C Negative: if c(C) < 0, next 
command at address N; else next command in 
following sector 
75 
TOF N 
Transfer on Overflow On: if Overflow Switch 
was on, next command was taken from address 
N. The Overflow Switch was then turned off. 
77 
TES N 
Transfer on External Signal: Take the next 
command from address N if any of the following 
signals occur, where the line portion of the 
address N was used: 
Lines 25-32: Any arbitrary signal 
Line 33: Magnetic tape reader clock input signal 
Line 34: Photo Tape Reader Sprocket Input 
Signal 
Line 35: Breakpoint Switch Input Signal 
Line 36: Typewriter (Keyboard) or Paper Tape 
Reader Input Complete Signal 
Line 37: Typewriter not ready for an output 
character signal 
13.2.5 Sequence Tag 
With commands stored in sequential sectors, command execution 
proceeded at a rate of 12 microseconds plus 3072 microseconds per 
command. The 3072 microseconds accounted for the recirculation rate of 
256 words through the delay line. A high rate could be achieved by setting 
field S – the Sequence Tag – to 1, which forced the next command to be 
read in the sector directly following the execution phase. Thus, a 
command stored in 00001 to store A into 02004 would be followed by the 
command in sector 02101, when S was set to 1.  

Chapter Thirteen 
 
318
13.3 Packard Bell 440 
The Packard Bell 440 was the successor to the PB250. It was oriented 
towards both scientific computing and data processing operations. The 
instructions were termed “micro-orders” and packed two per 24 bit word. 
The PB 250 was designed by Max Palevsky who was later to go onto fame 
at Scientific Data Systems. 
As Weik (1964) notes, the PB440 could emulate other computing 
machines by defining their instruction sets in terms of the micro orders. As 
the micro-order programs could be dynamically loaded, a PB440 could 
take on different computing “personas”. This yielded two advantages. 
First, a computing installation only needed one PB440 which could be 
reconfigured as necessary by loading the appropriate micro-order set. 
Second, it allowed programs for larger computing machines “to be 
checked out simply and economically” (Weik 1964). The PB440 could 
also serve as a satellite computer for larger computing machines with the 
function of handling unit record devices. 
The PB 440 is depicted in Figure 13-7 with a close-up view depicted in 
Figure 13-8. Figure 13-9 presents an advertisement for the PB440 
computer system. 
 
 
 
Figure 13-7. Packard Bell 440  
Source: Weik 1964 
 
 

Packard Bell 
 
319 
 
 
Figure 13-8. PB440 Operator Console  
Source: Packard Bell 1962c 
 
 

Chapter Thirteen 
 
320
 
 
Figure 13-9. PB440 Advertisement 
Source: Packard Bell 1962 
 
 
 
 

Packard Bell 
 
321 
Table 13-6. Packard Bell 440 – Basic Characteristics 
Characteristic 
Value/Explanation 
Internal 
Representation 
Fixed Point Binary; Floating Point Binary 
# Bits/Word 
24 + Parity Bit; 12 (Micro level) 
# Instructions/Word 
2 (micro instructions) 
# Instructions 
64 (micro-instructions) 
# Bits/Instruction 
12 
Instruction Type 
One Address (Macro level); Two Address (Micro 
level) 
CPU Technology 
 
CPU Registers 
4 Arithmetic; 2 Index; 1 Repeat Count; 1 
Command 
Main Memory 
Magnetic Core: 4K – 32K words, 5 microsecond 
cycle time; Fast memory (Biaxial Cores): 256 
Words, 1 microsecond cycle time 
Add Time 
Fixed Point: 1 – 11 microseconds; Floating Point: 
35 microseconds 
Multiply Time 
Fixed Point: 23 - 38 microseconds; Floating Point: 
111 microseconds 
Divide Time 
Fixed Point: 47 - 57 microseconds; Floating Point: 
224 microseconds 
13.3.1 PB440 System Architecture 
The PB 440 had two input busses (busses 1 and 2 in the diagram) and 
two output busses (busses 3 and 4 in the diagram). Busses could be 
selectively gated to different inputs or outputs of the adder and 
manipulative logic placed in line with the input and output busses. For 
example, Boutwell and Hoskinson (1963) noted the following: 
 
“The l's complement of the contents of register L may be obtained by 
connecting the outputs of L to bus 2, selecting the inversion logic input to 
bus 4, and connecting bus 4 to the register L input logic. Data transfers and 
register exchanges were facilitated by a direct connection between busses 2 
and 4 and by the ability to disable the bus 2 input to the full add logic.” 
 
Busses 1, 2, and 4 were used to communicate with the memory system. 
Using the manipulative logic, additional operations could be performed 
before a datum was sent to memory or after a datum was retrieved from 
memory. For example, while sending a datum to memory, it could be 

Chapter Thirteen 
 
322
incremented by one by enabling the manipulative logic connecting bus 2 
to the memory interface. The system architecture of the Packard Bell 440 
is depicted in Figure 13-10. 
 
 
 
Figure 13-10. Packard-Bell 440 System Architecture 
Source: Adapted from Packard Bell UNK 
13.3.2 Memory System 
Source: Boutwell and Hoskinson 1963 
 
Memory control logic treated each memory module as an 
asynchronous device. Bus communication allowed memory modules to be 
added to the system as needed, up to seven modules of 4096 words each. 
Memory modules could have different access and cycle times. Using the 
multiple busses, one memory module could be reading while another was 
writing. The basic access time was 2 microseconds while the cycle time 
was 5 microseconds. The memory system is depicted in Figure 13-11. 
Alternatively, the eighth memory module could be replaced by a fast 
memory module of 256 words which stored the microsequences. Fast 
memory could be expanded in blocks of 256 words up to a maximum of 
4096 words. Fast memory had an access time of less than 1 microsecond. 
 
 

Packard Bell 
 
323 
 
 
Figure 13-11. Packard Bell 440 Memory System 
Source: Adapted from Boutwell and Hoskinson 1963 
 
Additionally, a special component, the Memory Interchange Unit could 
connect up to eight memory modules to four devices as shown in Figure 
13-12. In one configuration each of the four devices could be a separate 
PB 440. This allowed a four- way multiprocessor system to be configured 
around 32 KWords of memory. 
13.3.3 I/O System 
The PB 440 had a single I/O bus to which controllers for various 
devices were attached. The device controllers were unique to the types of 
devices. A device controller could attach up to four devices. The device 
controller performed three functions: (1) determine when one of its 
devices was being addressed by the computer; (2) connect the device to 
the I/O bus; and (3) execute the commands issued by the computer to the 
device. The device controller buffered the data sent to or received from the 
device on a character or word basis as appropriate. It also handled any 
errors detected during device operation. Character transfers were 
supported up to 80K characters per second. Faster transfers up to 800K 

Chapter Thirteen 
 
324
characters per second required an optional high-speed I/O adapter which 
provided for uninterrupted data transfers to memory. 
The standard I/O equipment was a paper tape reader capable of reading 
at 500 characters per second, a paper tape punch capable of punching at 
110 characters per second, and an electric typewriter. IBM-compatible 
card reader, line printer, and magnetic tape drives could be attached as 
optional equipment. 
Up to 256 magnetic tape units could be attached to a PB 440, although 
it is doubtful that any system had more than a few tape drives physically 
attached. The magnetic tape drives supported 7 tracks per inch with 
transfer speeds up to 800 characters per second.  
 
 
 
Figure 13-12. Use of a Memory Interchange Unit 
Source: Adapted from Boutwell and Hoskinson 1963 
13.3.4 PB440 Programming 
Source: Packard Bell 1962c 
 
The PB440 did not have an instruction set, but rather executed a 
sequence of steps, which we would call micro-operations. A sequence of 
micro-operations formed a micro-routine which corresponded to an 
instruction. Thus, an instruction set consisted of a control sequence and a 
set of micro-routines. Instructions were normally stored in fast memory, 
but could be executed from main memory at a slower rate. This allowed 

Packard Bell 
 
325 
the PB440, like the Burroughs 1700/1800/1900 and Nanodata QM-1 
systems, to have many different instruction sets focused on different types 
of computing problems. 
The ability to design an instruction set to fit a problem provided the 
programmer with a significant advantage as he could essentially design the 
computer to fit his problem. Thus, he could design the instruction set for 
compactness, efficiency, and speed. 
For those programmers who did not want to design their own 
instruction sets, Packard Bell provided pre-written scientific and data 
processing instruction sets. They also, provided a FORTRAN compiler 
that compiled source code to the scientific instruction set. 
13.4 PB440 Micro Instruction Format 
The PB440 micro instruction format is depicted in Figure 13-13. 
 
 
 
Figure 13-13. PB440 Instruction Format 
Source: Weik 1964 
13.5 Packard Bell Assessment 
The PB250 was a sophisticated machine. It was one of the first, if not 
the first, machines that had a square root operation built into its instruction 
set. The average execution speed for square root was 252 microseconds, 
the same as division. An advantage/disadvantage of the PB250 was its 
serial processing of data. Its advantage was that it could use cheaper, more 
reliable, but simpler parts. However, the use of an acoustic delay line 
made the machine much slower than some of its contemporaries. A 
Packard Bell 250 is displayed at the Retrocomputing Society of Rhode 
Island,   http://www.rcsri.org/. 
According to Weik (1961), a PB250 with a Flexowriter and a 2320 
word memory cost about $40,000. In this configuration, it had 9 delay 
lines of 256 words and one delay line of 16 words. Later, the acoustic 
delay lines were replaced by magnetic core memory which significantly 
improved performance.  

Chapter Thirteen 
 
326
The PB 440 was an unconventional computer design. Rather than 
instructions, as most programmers were used to, it implemented a set of 
micro-orders (e.g., akin to transparent microcode) which allowed the 
programmer to define a sequence of steps which constituted a macro-
instruction. Thus, in some sense, the macro-instructions varied based on 
programmer and computation needs. Usually, these “instructions” were 
stored in fast memory, but micro-orders could be executed from main 
memory as well. 
Boutwell and Hiskinson (1963) argued that the micro-order approach 
was a flexible replacement for customized and dedicated circuitry. It 
allowed the programmer to adapt the machine to his computational needs, 
including, simulating other computer systems. The downside was the extra 
time required to decode or interpret pseudo-instructions. 

FURTHER READING 
 
 
 
Gandy, A. 2012. The Early Computing Industry: Limitations of Scale and 
Scope, Palgrave McMillan, ?? 
Gertner, J. 2012. The Idea Factory: Bell Labs and the Great Age of 
American Innovation. Penguin Books, ?? 
Recounts the story of the invention of the transistor. 
Koss, A. M. 2003. “Programming at Burroughs and Philco in the 1950s”, 
IEEE Annals of the History of Computing, 25(4):41-50 
Massachusetts Institute of Technology (MIT), Cambridge, MA: 
(a) 1961. TX-2 Technical Manual, Volumes 2 & 3, Lincoln Manual 
No. 44 
(b) 1961. TX-2 User’s Handbook, Lincoln Manual No. 45 
Mitchell, J. L. and K. H. Olsen. 1956. “TX-0, A Transistor Computer with 
a 256 by 256 Memory”, AIRE-IRE Eastern Joint Computer 
Conference: New Developments in Computers, pp. 93-101 
Packard Bell Computer. 1961a. PB250 Technical Manual, Volume 1. PBC 
1000 rev 4, Los Angeles, CA 
—. 1961b. PB250 Technical Manual, Volume 2. PBC 1002 rev 1, Los 
Angeles, CA 
Segal, R.J., J.L. Maddox, and P. Plano. 1958. “Performance Advances in a 
Transistorized 
Computer 
System: 
the 
TRANSAC 
S-2000”, 
Proceedings of the Eastern Joint Computer Conference, pp. 168-174 
Ray Gollub reminisced about the Philco 212 (http://ed-thelen.org/comp-
hist/philco-212.html). 
Sperry Rand Corporation, King of Prussia, PA: 
(a) 1969. FH-880 Magnetic Drum System, UP-7666 
(b) 1969. File Control Routine, UP-7687 
 

EXERCISES FOR THE READER 
 
 
 
1. The Philco 2400 served as an I/O auxiliary computer to the Philco 
TRANSAC S-2000, thus relieving the latter of slower I/O operations. This 
may have been the first example of a dual-computer operation with 
division of duties. Discuss the pros and cons of this approach to separating 
computation from I/O handling. 
 
2. Philco conceived of the idea of blocked tapes (e.g., tapes with pre-
recorded block start and block end markers) that allowed direct access to 
blocks on the tape. DEC later successfully developed this same idea for 
DECTape. Discuss the programming conditions under which direct-access 
magnetic tape could compete with magnetic drums in the late 1950s and 
early 1960s. 
 
3. Using magnetic tapes, it is easy to see how to use two tapes to sort and 
perform other types of business data processing such as updating a master 
file. The extension to more than two tapes is more difficult. Analyze and 
discuss three data processing problems that are easily solvable using two 
tapes and determine how to extend their algorithms and logic to use four 
tapes. Describe your algorithms in pseudo-code. 
 
4. In the Bendix G-20, TRE transferred control to a new location and 
enabled interrupts. What was the effect of the location that was transferred 
to was a TRE instruction. (see Bendix 1962g). 
 
5. The Philco 212 could be coupled with a Philco 1000 which handled the 
operation of the low-speed peripherals. Several other manufacturers 
developed and delivered “coupled” systems, such as IBM’s 1401-7094 and 
Univac’s 1004-1100 systems. Develop a simulation of a coupled system 
and determine the relative performance increase over a single system. 
Review the documentation of these three examples and compare and 
contrast their capabilities. 
 
6. Extend Bob Supnik’s SIMH system to handle coupled systems. Donate 
the code back to the community. [Programming Exercise] 
 

Birthing the Computer: From Drums to Cores 
 
329 
7. The Philco 212 was able to store up to four instructions in the 
Instruction Unit. This is one of the earliest examples of instruction 
prefetch. Determine how you could extend this concept to support an 
instruction buffer in the Philco 212. [Note: Requires additional reading of 
the system manuals: http://www.bitsavers.org] 
 
8. The Philco 212 had, like many other early computer systems, some 
interesting mathematical instructions. On the Philco 212, the LWD and 
SWD instructions determined the maximum or minimum of two values 
and jumped accordingly. Explore the many early machines in volume 1, 
catalog the different instructions other than what you would expect a CPU 
to have. Discuss the intrinsic value of these instructions in writing 
programs. 
 
9. Compare and contrast the design of the Packard Bell 440 with its micro-
order approach with the Burroughs B1700 and the Nanodata QM-1. 
[Further research is required into all three machines.] 
 
10. The Philco 212 checked for and prevented hazards due to instruction 
conflicts since its CPU was comprised of four semi-independent units. 
Explain what information the Philco 212 needed in the XU and the AU to 
detect and avoid hazards. 
 
11. Compare the DEC Flip Chip modules with the modules developed for 
the UNIVAC Solid State Computer. 
 
12.  Horning (2006) avers that he has not seen the operand assembly 
register capability of the G-20 in any other computer. One could argue that 
the separate register file for address computation in the large CDC 
mainframes and the Cray computers is used for the same purpose. 
Research both mechanism and argue pro or con for similarity of purpose. 
 
13. Develop a simulator for the Packard Bell 440 using SIMH or your own 
design in Java. Develop and implement one or more instructions sets for 
scientific and business data processing use. Also, consider developing and 
implementing an instruction that directly executes the BASIC language.  
 
14. Review the design and development of the MIT Whirlwind, TX-0, TX-
2, and the DEC PDP-1. Trace the evolution of design decisions through 
these four computer systems. 
 

Exercises for the Reader 
 
330
15. The Packard Bell 440 had the ability to emulate other computing 
machines by defining their instruction sets through its micro instructions. 
Compare and contrast this approach with the Burroughs B1700 and the 
Nanodata QM-1. 
 
16. Compare and contrast IBM’s 704 FORTRAN compiler running under 
IBSYS with Philco’s ALTAC compiler. Two incompatibilities have been 
addressed in the text. Identify others, discuss the conditions causing the 
incompatibilities, and determine whether each was a significant constraint 
on moving FORTRAN code between the two machines. 
 

APPENDIX A:  
GLOSSARY 
 
 
 
cps  
Characters per second 
 
IBM 
International Business Machines Corporation 
 
ICT  
International Computers and Tabulators, Ltd. 
 
Kbytes 
Kilobytes 
 
lpm  
lines per minute 
 
MBytes 
Megabytes 
 
MTU 
Magnetic Tape Unit 
 
MWords 
Megawords 
 
TCU 
Tape Control Unit 


REFERENCES 
 
 
 
Note: The letters UNK indicate that the data of writing or publication is unknown. 
Some of the references depend on web pages that I have saved from the Internet. If 
I have an approximate date for when I saved the web pages, I will note the date as 
ca. <date>. 
 
Andree, R. V. 1958. Programming the IBM 650 Magnetic Drum 
Computer and Data Processing Machine, Henry Holt & Co., New 
York, NY 
Beard, A. D., L. S. Bensky, D. L. Nettleton, and G. E. Poorte. 1958. 
“Characteristics of the RCA BIZMAC Computer”, Proceedings of the 
Joint ACM-AIEE-IRE Western Computer Conference 
Bendix Corporation, Los Angeles, CA and Teterboro, NJ: 
(a)  UNK. Operating Manual for the Bendix G-15 
(b)  1961. The Intercom 1000 Programming System for the Bendix G-
15 General Purpose Digital Computer, APG-07581-4, April 
(c)  1961. Coding Manual for the Bendix G-15 General Purpose 
Digital Computer, APG-01571-3, April 
(d)  1960. ALGO: Algebraic Compiler for the Bendix G-15 General 
Purpose Digital Computer, T-21, August 
(e)  1961. ALGO Operating Instructions, T-22, January 
(f)   1971. Bendix Digital Computers, Pub. No. 716-2 
(g)  1962. Bendix G-20 General Reference Manual 
(h)  1962. Bendix G-20 Central Processor Machine Language 
(i)  1963. G-20 Central Processor Service Manual, Vol. 1 & 2, MA-
2193 
(j)  1955. The Easy to Use Bendix G15 General Purpose Digital 
Computer, brochure, AB-116-R-018 
(k)  1955. The Easy to Use Bendix G15 General Purpose Digital 
Computer, brochure, AB-116-R-098 
(l)   1955. Intercom 1000, brochure, AR-058-R118 
(m) UNK. Bendix G-15 Automatic Programming System, AR-1060 
(n)  1961. G-15 Technical Bulletin – Equipment Series 
(o)  1961. G-15D Programmers Reference Manual 
(p)  1962. ALTRAN Translator Reference Manual for the Bendix G-
15, APR-01621 
(q)  1960. Programming for the G-15, APR-1601-1 (parts 1-4) 

Birthing the Computer: From Drums to Cores 
 
333 
(r)   UNK. Intercom 1000, AR-058-R118 (brochure) 
Best, R. L. 1957. “Memory Units in the Lincoln TX-2 Computer”, 
Western Joint Computer Conference, Los Angeles, CA, February 1957 
Brooker, R. A. and J. S. Rohl. 1965. Atlas Autocode Reference Manual, 
Ferranti Corporation 
Brown, W. S., B. D. Holbrook, and M. D.  McIlroy. 1984. “Computer 
Science at Bell Labs”, in S. Millman (ed.) A History of Engineering 
and Science in the Bell System, Communication Sciences (1925-1980), 
AT&T Bell Laboratories (1984) 
Bryan, G. E. 1966. JOSS: Introduction to the System Implementation. 
Lawrence Radiation Laboratory; Presented at the Fall Symposium of 
the Digital Equipment Corporation Users Society, Berkeley, CA, 
available at:  
 
https://archive.org/details/bitsavers_randjossP3ToTheSystemImplemen
tationNov66_1568010 
Boutwell, E., Jr. and E.A. Hoskinson. 1963. “The Logical Organization of 
the PB 440 Microprogrammable Computer”, Proceedings – Fall Joint 
Computer Conference, pp. 201-213 
Bright, H.S. 1964. “A Philco Multiprocessing System”, Fall Joint 
Computer Conference, Vol. 23, Part II, pp. 07-114. AFIPS Conference 
Proceedings, Spartan Books, Washington, DC. 
Clark, R. L. 1975. "JOSS Users' Reference Manual", Report F-1535/9, 
RAND Corp., Santa Monica, CA 
Clark, W. A. 1957. “The Lincoln TX-2 Computer Development”, Western 
Joint Computer Conference, Los Angeles, CA, February 1957 
Colonies, V. M. 1956. “A Complete Floating-Decimal Interpretive System 
for the IBM 650 Magnetic Drum Calculator”, IBM Technical 
Newsletter, No. 11, IBM Corporation, New York, NY,  
 
http://www.bitsavers.org/pdf/ibm/650/34-6822-0_FltDecIntrpsys.pdf 
Computer Museum Reports. Mountain View, CA: 
(a) 1984. The TX-0: Its Past and Present, Vol. 8 
  http://ed-thelen.org/comp-hist/TheCompMusRep/TCMR-
V08.html#di 
 (b)1984. The TX-0 at MIT, Vol. 8 
  http://ed-thelen.org/comp-hist/TheCompMusRep/TCMR-
V08.html#di 
Eckert, W. J, and R. Jones. 1955. Faster, Faster: a simple description of a 
giant electronic calculator and the problems it solves, McGraw-Hill, 
New York 
Edwards, D. 2013. “Designing and Building Atlas”, Resurrection, Vol. 
62Computer Conservation Society 

References 
 
334
Engineering Research Associates (ERA). UNK. Magnetic Storage 
Systems, St. Paul, MN, PX-29710 (brochure) 
Fadiman, J. 1958. TX-2 Circuitry Handbook, MIT Radiation Laboratory, 
6D-2631, Cambridge, MA 
Ferranti Electronics, Ltd, London, England: 
(a) UNK. The Atlas Computer, W159 
(b) 1961. Features of the Ferranti Atlas Computer, CS277B 
(c) 1962. Ferranti Computing Systems Atlas 1 Brochure 
Forgie, J. W. 1957. “The Lincoln TX-2 Input-Output System”, Western 
Joint Computer Conference, Los Angeles, CA, February 1957 
Frankel, S P, “The Logical Design of a Simple General Purpose 
Computer,” IRE Transactions on Electronic Computers, March 1957, 
p 5-14. 
Frankovich, J. M. and H. P. Peterson. 1957. “A Functional Description of 
the TX-2 Computer”, Proceedings of the Western Joint Computer 
Conference (WJCC), Los Angeles, CA, pp. 146-155 
General Precision (GP), Inc.,  
(a) 1963. LGP-21 Computer System Reference Manual, SC2000 
(b) 1963. LGP-21 Programming Manual, SC2001 
(c) 1962. The Cold Competitive Facts Are Embarrassing to the 
Competition, Science, Vol. 137, p. 6 (advertisement) 
Gilmore, J. T., Jr. and H.P. Peterson. 1958. “A Functional Description of 
the TX-0 Computer”, MIT Lincoln Laboratory, Memorandum 6M-
4789-1 
Gloutnikov, S. UNK. “The History and Real-Life Stories of Historic 
Memory and Storage Systems”,  
 
http://gloutnikov.com/compuer.history.project.pdf 
Gordon, B. 1956. “An Optimizing Program for the IBM 650”, Journal of 
the ACM, 3(1) 
Gray, G. 1999. The UNIVAC Solid State Computer, UNISYS History 
Newsletter, 1(2),  
 
https://wiki.cc.gatech.edu/folklore/index.php/The_UNIVAC_Solid_Sta
te_Computer (revised from original 1992 version) 
—. 2007. The UNIVAC 418 Computer, UNIVAC History Newsletter, 
4(2), available at  
 
https://wiki.cc.gatech.edu/folklore/index.php/The_UNIVAC_418_Com
puter (revised from the original 2000 version) 
Gruenberger, F. 1968. The History of the JOHNNIAC. Rand Corporation, 
RM-5654-PR, Santa Monica, CA 
Hansen, P. B. 2000. Classic Operating Systems: From Batch Processing 
to Distributed Systems, Springer-Verlag 

Birthing the Computer: From Drums to Cores 
 
335 
Hartley, D. F., B. Landy, and R. M. Needham. 1968. “The Structure of the 
Multiprogramming Supervisor”, The Computer Journal, 11, pp 247-
255. 
Hill, J. L. 1950. “Design Features of a Magnetic Drum Information 
Storage System”, paper delivered at the Association for Computing 
Machinery Conference, Rutgers University, NJ 
Hodges, Jr., J. D. and D. W. Whitehead. 1969. Automatic Traffic Signal 
Control Systems – the Metropolitan Toronto Experience. AFIPS 
Spring Joint Computer Conference, AFIPS Press, Baltimore, MD, pp. 
529-535. 
Horning, J. 2006. “The Way It Was: Tales From A Life”,  
 
http://horningtales.blogspot.com/2006_05_01_archive.html 
Howarth, D. J., et al. 1961. ”The Manchester University Atlas Operating 
System. Part II: User's Description”, Computer Journal, 4(3):226-229 
Huskey, H. 1984. “From ACE to the G-15”, Annals of the History of 
Computing, 6(4):350-371 
International Business Machines (IBM) Corporation, New York, NY: 
(a) 1955. Type-650 Magnetic Drum Processing Machine: Manual of 
Operation, 22-6060-1 
(b) 1957. IBM 650 Data Processing System: Customer Engineer 
Manual of Instruction, 22-6284-1 
(c) 1957. SOAP II for the IBM 650 Data Processing System, C24-
4000-0 
(d) 1958. IBM 650 Data Processing System Bulletin General 
Information, G24-5000-0 
(e) 1958. IBM 650 Data Processing System Bulletin Basic Operation 
Codes, G24-5002-0 
International Computers and Tabulators, Ltd. (ICT), London, England: 
(a)  1964. I.C.T. Atlas 2 Supervisor and Operating System, 5056 
(b) 1965. I.C.T. Atlas 1 Computer Programming Manual for Atlas 
Basic Language (ABL), CS 348A 
Kavanaugh, R. N. 2007. History of Computing at the University of 
Saskatchewan: The First Three Decades, 1957-1987, unpublished, U of 
Saskatchewan, Saskatoon, Saskatchewan 
Kilburn, T. 1961.”The Manchester University Atlas Operating System. 
Part I: Internal Organization”, The Computer Journal, 4(3):222-226 
Kilburn, T., R. B. Payne, and D. J. Howarth. 1962. “The Atlas 
Supervisor”,  
Landy, B. 2012. Atlas 2 at Cambridge Mathematical Laboratory,  
 
http://curation.cs.manchester.ac.uk/atlas/elearn.cs.man.ac.uk/_atlas/docs/
Atlas%202%20at%20Cambridge%20Mathematical%20Laboratory.pdf 

References 
 
336
Lavington, S. H. 1978. “The Manchester Mark I and Atlas: A Historical 
Perspective”, Communications of the ACM, 21(1):4-12 
—. 1980. Early British Computers.  Manchester University Press, 
Manchester, England 
—. 2012. The Atlas Story. University of Manchester,  
 
http://elearn.cs.man.ac.uk/~atlas/docs/The%20Atlas%20story.pdf
Maddox, J. L., J. B. O’toole, and S. Y. Wong. 1956. “The Transac S-1000 
Computer”. Proceedings of the Eastern Joint Computer Conference, 
ACM, New York, NY 
Mankovich, J. and H. P. Petersen. 1957. “Functional Description of the 
Lincoln TX-2 Computer”, Western Joint Computer Conference, Los 
Angeles, CA, February 1957 
Marks, S. L. and G. W. Armerding. 1967. The JOSS Primer. Rand 
Corporation, RM-5220-PR, Santa Monica, CA 
Massachusetts Institute of Technology (MIT), Cambridge, MA: 
(a) 2004. MIT TX-0 Instruction Set 
(b) 1960. The Future TX-0 Instruction Code, M-5001-29 
(c) 1958. A Functional Description of the TX-0 Computer, 6M-4789-1 
(Memorandum) 
(d) 1957. The Lincoln TX-2 Company, 6M-4968 (Memorandum) 
(e) 1961. TX-2 Users Handbook, ed. By A. Vanderburgh, Lincoln 
Manual No. 45 
(f) 1958. Some Examples of TX-2 Programming, by H. Peterson, 
Memorandum 6M-5780 
(g) 1961. TX-2 Technical Manual, Vols. 1-3, Lincoln Manual No. 44 
McKenzie, J. A. 1999. TX-0 Computer History, RLE Technical Report 
No. 627, MIT Research Laboratory for Electronics, Cambridge, MA 
Mitchell, J. L. 1956. “TX-0: A Transistor Computer with a 256 by 256 
Memory”, AIEE-IRE '56 Eastern Joint Computer Conference, pp. 93-
101 
Morris, D. and J. S. Rohl. 1961. “The ATLAS Compiler System”, The 
Computer Journal, 4(3):227-230 
Morris, D. F. H. Sumner, and M. T. Wyld. 1967. “An Appraisal of the 
Atlas Supervisor”, Proceedings of the ACM National Meeting, ACM, 
New York, NY, pp. 67-75 
Moreau, R. 1984. The Computer Comes of Age: The People, The 
Hardware, and The software, The MIT Press, Cambridge, MA 
Olsen, K. H. 1957. “Transistor Circuitry in the Lincoln TX-2”, 
Proceedings of the Western Joint Computer Conference (WJCC), Los 
Angeles, CA, pp. 161-171 

Birthing the Computer: From Drums to Cores 
 
337 
Owings, J. L. 1956. The RCA BIZMAC System Central, ACM-AIEE-IRE 
Western Computer Conference, pp. 126-132 
Packard Bell Computer Corporation, Los Angeles, CA: 
(a) 1961. PB250 General Purpose Digital Computer Reference Manual, 
SP-174 
(b) 1961. PB250 Technical Manual, Volumes I & II, PBC-1000 
(c) 1962. An introduction to PB440 Microprogramming, PBC 11-62 
(d) 1961. PB250 programming manual, PBC 1004 rev 1 
(e) 1961. HYCOMP 250 – The First Desk Top Hybrid Analog/Digital 
Computer System, SP-182 
Philco Corporation, Computer Division, Willow Grove, PA: 
(a) UNK. TRANSAC S-2000 Technical Manual, No. 141 
(b) 1962. Philco 1000 Computer Series, TM-22 
(c) 1962. Philco 2400 Reference Manual 
(d) 1963. Philco S-2000 Input-Output Systems, TM-16C 
(e) 1958. TRANSAC 2000 System Description 
(f) 1962. Introducing a New Concept in Computer Speed, Efficiency 
and Flexibility: Philco 212 
(g) 1968. Philco 212 Reference Manual 
(h) UNK. Philco 2000 Information Manual, TM-13 
(i) 1968. Philco 2000 32KSYS Operating System 
(j) 1958. Philco Transac S-2000 (brochure) 
(k) 1962. Philco 2400 ALTAC Manual, TM-5C 
Plaumann, R. H. 1965. The Use of the UNIVAC 490 as a Real-Time 
message Switching Unit, NASA TMX54710 
Quatse, J. T. 1965. Design of the G-21 Multi-Processor System, Carnegie 
Institute of Technology, Pittsburgh, PA 
Rand Corporation (Rand). 1967. JOSS Central Processing Routines, RM-
5720-PR, 
http://www.rand.org/pubs/research_memoranda/RM5270.html 
Remington Rand/Sperry Rand Corporation, New York, NY: 
(a) 1956. 
UNIVAC 
Scientific 
General-Purpose 
Computer 
– 
Programming, PX 18 
(b) 1958. UNIVAC Solid State Computer, U1770 
(c) 1969. UNIVAC 418-III Real-Time Computer System Description, 
UP-7576-01 
(d) 1958. UNIVAC Solid State 90 Central Processor 
(e) 1958. UNIVAC Solid State 90 General Description 
(f) 1959. UNIVAC Solid State 90 Specification Features 
(g) 1959. UNIVAC Solid State 90 Input Output Units 

References 
 
338
(h) 1961. UNIVAC 490 Real-time System: General Description, 
UT2403-1 
Rosen, S. 1959. “ALTAC, The TRANSAC Algebraic Translator”, 
Presented at the 14th National Meeting of the ACM 
—. 1961. “ALTAC, FORTRAN, and Compatibility”, Presented at the 
16th National Meeting of the ACM. 
—. 1964. “Programming Systems and Languages: A Historical Survey”, 
Proceedings of the Spring Joint Computer Conference 
—. 2004. “Recollections of the Philco TRANSAC S-2000”, IEEE Annals 
of the History of Computing, 26(2):34-47 
Royal McBee Corporation. 1957. Electronic Computer Programming 
Manual. Westchester, NY 
—. 1963. LGP-21/LGP-30 Subroutine Manual, Westchester, NY, retrieved 
on May 15, 2016 from http://worldpowersystems.com/projects/LGP-
21/Documentation/Subroutine-Manual/index.html 
—. Unk. LGP30: The Royal Precision Electronic Computer, S-526, 
Westchester, NY 
Royse, D. 1957. “The IBM 650 RAMAC System Disk Storage Operation, 
Proceedings of the IREͲAIEEͲACM'57 Western Computer Conference 
Shaw, J.C. 1964. A Designer’s View of an Experimental On-Line 
Computing System, Rand Corporation, P-2922, Santa Monica, CA 
Speckhard, A. E. 1959 “A SAP-like Assembly Program for the IBM 650”, 
Communications of the ACM, 3(1):2-5 
Sperry Rand Corporation, Univac Division, St. Paul, MN: 
(a)  1969. UNIVAC 494 Real-Time System: System Description, UP-
4032-2 
(b) 1966. Preliminary OMEGA Design Manual 
(c) 1969. UNIVAC 494 Programmer/Operator Reference Manual, 
UP4049-2 
(d) 1966. The UNIVAC 494 Real-Time System (brochure) 
(e)  1969. UNIVAC 418 Processor and Storage, UP-7627 
Smillie, K. 2002. The Computer and Me,  
 
http://www.cs.ualberta.ca/~smillie/ComputerAndMe/Part12.html 
Snyder, S. 194. A History of the NSA General-Purpose Electronic Digital 
Computers, National Security Agency, FT. George G. Meade, MD 
Sumner, F. H., G. Haley, and E. C. Y. Chen. 1962. “The Central Control 
Unit of the Atlas Computer”, Proceedings of the 1962 IFIP Congress,  
 
http://www.chilton-computing.org.uk/acl/literature/reports/p028.htm 
VIP Club. 2015. NSA Used UNIVAC Computers,  
 
http://vipclubmn.org/Articles/NSA-UnivacNotes.pdf 

Birthing the Computer: From Drums to Cores 
 
339 
Ware, W. H. 1966. JOHNNIAC Eulogy. Rand Corporation, P-3313, Santa 
Monica, CA 
Weik, M. H. 1961. A Third Survey of Domestic Electronic Digital 
Computing Systems, Report No. 1115, Ballistic Research Laboratories, 
Aberdeen Proving Ground, MD (HTML at http://www.ed-thelen.org/ 
comp-hist/BRL61.html) 
—. 1964. A Fourth Survey of Domestic Electronic Digital Computing 
Systems, Report No. 1227, Ballistic Research Laboratories, Aberdeen 
Proving 
Ground, 
MD 
(HTML 
at 
http://ed-thelen.org/comp-
hist/BRL64.html 
Weiss, H. G. 1964. The Haystack Experimental Facility, Lincoln 
Laboratory, Cambridge MA (also ESD-TDR-64-378) 
Wexelblat, R., Ed. 1981. History of Programming Languages, Academic 
Press, New York, NY 
Wolontis, V. M. 1956. A Complete Floating Point Decimal Interpretive 
System, Technical Newsletter No. 11, IBM Applied Science Division, 
White Plains, NY 



INDEX 
 
 
 
Air Force Cambridge Research 
Center, 106 
Al Newell, 98 
Alan Turing, 42 
Aldermaston Atomic Weapons 
Research Establishment, 83 
Algo, 51 
ALGOL, 58, 147 
ALTAC 
see Translator Assembly 
Language, 181 
ALTRAN, 51 
Ampex TM2, 73 
Analex, 91 
Atlas 
branching instructions, 76 
floating point arithmetic 
instructions, 75 
Indexing commands, 75 
Atlas 2, 82, 84 
Auxiliary Fixed Area, 85 
Co-ordinator, 86 
error conditions, 87 
Extended Interrupt Routines, 87 
Fast Operand Store, 84 
Fixed Area, 85 
Interrupt routines, 86 
Look-At-Me, 86 
Slave Store, 84 
Supervisor, 85 
Supervisor Extracode Routines, 
86 
Atlas Autocode,78, 79 
Atlas Basic Language,78 
Atlas Computer Laboratory,70 
Atlas Supervisor,79 
Central Executive,80 
Input Supervisor,80 
Job Assembler,80 
Output Supervisor,80 
Scheduler,80 
Atlas Users Handbook, 88 
Australia’s Overseas 
Telecommunication 
Commission, 129 
AUTODIN Communications 
System,129 
Automated Radar Tracking System, 
129 
Baker, Charles L., 98 
Bardeen, John, 105 
Barron, David, 83 
Bell Telephone Laboratories, 27 
Bell, Gordon, 149 
Bell, Herbert, 206 
Bendix Aviation Corporation, 42 
Bendix Corporation, 42 
Bendix G-15, 42 
command lines, 47 
Differential Analyzer DA-1, 50 
Graph Plotter PA-3, 50 
I/O system, 48 
Instruction Format, 48 
long lines, 46 
MTA-2 Magnetic Tape, 50 
Punched Card Coupler CA-1, 51 
short lines, 46 
Bendix G-20, 42, 196 
Memory Address Register, 197 
Operand Assembly, 197 
Bendix G-21,205 
Bendix, Vincent, 42 
bi-quinary coded decimal, 106 
bi-quinary notation, 21 
BIZMAC, 62 
Bizmac II, 63 
Brattain, Walter, 105 
British European Airways, 147 

Birthing the Computer: From Drums to Cores 
 
341 
cache concept, 84 
California Institute of Technology, 
30 
Cambridge Titan Computer, 82 
Card Programmed Calculator, 17 
Cass, James, 30 
Central Intelligence Agency, 147 
Chilton Laboratory, 87 
Christiaan Huygenschool, 115 
Clark, Wesley, 148 
COBOL, 146 
common sense/inhibit line, 60 
Computer History Archives Project, 
64 
Computer History Museum, 89 
Computer-aided Design Centre, 83 
Control Data Corporation,42 
Control Unit Tester, 116 
Cray, Seymour, 147 
Data Communications Terminal, 
124 
Data Line Terminal, 124 
Datamation, 43 
DCT 2000 Data Communications 
Terminal, 127 
DDT, 154 
Dennis, Jack, 154 
Dresdner Bank, 107 
EAI plotter, 91 
Eastern Airlines, 147 
EasyFox, 98 
Eckert-Mauchly Computer 
Corporation, 30, 106 
Economics Laboratory, Inc, 106 
Engineering Research Associates, 
158 
Equitable Life Assurance, 29 
Extracodes, 75 
Farnsworth, Philo, 157 
FASTRAND II, 124 
FASTRAND III, 124 
Ferractor, 109 
Ferranti, 69 
Ferranti Atlas, 69 
Auxiliary Store, 72 
page, 73 
V Store, 72 
Ferranti Mercury, 30 
ferrite, 60 
FH-432/1782 flying head magnetic 
drums, 123 
field effect transistor, 159 
Flexowriter Interrogation Tape, 154 
FLIT, 54 
FLOW-MATIC, 114 
Ford Aerospace, 157 
Ford Motor Company, 157 
Forgie, Jim, 148 
Forrester, Jay, 60 
FORTRAN, 51, 183 
FORTRAN I, 28 
FORTRAN IV, 146 
FORTRANSIT, 28 
Frankel, Stan, 30 
Frankovich, John, 148 
Friden Flexowriter, 31, 36, 42, 46, 
154, 206, 209 
Friden Flexowriters, 73 
General Precision Corporation, 31 
Gilmore, Jack, 148 
Government and Industrial 
Division, 157 
Hamilton, Frank, 17 
Hamming, Richard W., 27 
Harry Huskey, 42 
Hartley, David, 83 
Haygood, Ray, 147 
Higbee Department Store, 63 
Hudson, Bob,148 
Huskey, Harry,42 
hysteresis, 60 
IBM 026 Card Punch, 46 
IBM 355 Disk Storage Unit, 28 
IBM 407 Accounting Machine, 22, 
23 
IBM 523 printer, 91 
IBM 650, 17, 106 
Adder, 20 
Address Register, 20 
arithmetic instructions, 24 
branching instructions, 25 
Distributor, 20 

Index 
 
342
floating point instructions, 26 
I/O instructions, 23 
IAS transfer instructions, 27 
index accumulator instructions, 
25 
index accumulator operations 
instructions, 26 
index registers, 20 
Lower Accumulator, 20 
miscellaneous instructions, 25 
Operation Register, 20 
RAMAC, 28 
shifting instructions, 24 
table lookup instruction, 25 
Upper Accumulator, 20 
IBM 652 Control Unit, 22 
IBM 652 Magnetic Tape Control 
Unit, 28 
IBM 652 Tape Control Unit, 22 
IBM 653 Core Storage Unit, 28 
IBM 653 High-Speed Core Storage 
Unit, 22 
IBM 705, 63 
IBM 727 Magnetic Tape Unit, 22 
Ike Nehama, 98 
Institute for Advanced Studies, 89 
Intercom 1000, 42, 53 
Inter-Computer Control Unit, 124 
John Bardeen, 105 
John von Neumann Integrator and 
Automatic Computer, 89 
JOHNNIAC, 89 
Add Orders, 93 
Conditional Transfer Orders, 92 
Control Orders, 97 
Division Orders, 94 
Drum Orders, 97 
I/O Orders, 96 
instruction set, 92 
Logical Product Orders, 97 
Multiple Typewriter 
Communication System, 90 
Multiplication Orders, 93 
Register Movement Orders, 95 
Shift Orders, 95 
Store Orders, 95 
Transfer Orders, 92 
JOHNNIAC Open Shop System, 98 
JOSS, 98 
Kaye, Mel, 33 
Keith Uncapher, 98 
Kilburn, Thomas, 69 
L1 language, 27 
L2 language, 27 
Landy, Barry, 83 
Lavington, Simon, 88 
Lawrence Radiation Laboratory, 99 
Leagus, Dolores C., 27 
LGP-21, 35 
Accumulator, 36 
circular slide rule, 40 
Counter Register, 37 
Extended Accumuator, 36 
Instruction Format, 39 
Instruction Register, 37 
Sector Reference Timing Track, 
40 
LGP-30, 30 
Instruction Format, 32 
Librascope Corporation, 30 
Lincoln Laboratory, 148 
Lindeboom, Jan, 115 
Lockheed Martin Company, 40 
Lynde, Nelson, 62 
Magnetic core, 59 
Magnetic Drum Calculator, 17 
Magnetic drums, 16 
magnetostrictive delay lines, 209 
Malcarney, Arthur, 62 
Massachusetts Institute of 
Technology, 148 
Mercury Autocode, 69 
Metropolitan Toronto Traffic 
Control System, 128 
micro-alloy diffusion transistors, 
195 
Microsecond Engine, 69 
MINAC, 30 
MIT 148 
Electrical Engineering 
Department, 149 
Speech Research Group, 149 

Birthing the Computer: From Drums to Cores 
 
343 
MIT Whirlwind Group, 30 
Morse, Harrison, 149 
MUSE, 69 
Nather, Ed, 33 
National Air and Space 
Administration’s, 147 
National Bureau of Standards, 30 
National Research Development 
Corporation, 69 
National Security Agency, 147, 157 
Navy Bureau of Ships, 157 
Needham, Roger, 83 
NELIAC, 147 
New York Life Insurance Company, 
63 
Newell, Allen, 100 
Nisbet, Mac, 181 
non-volatile, 60 
Norman, Chuck, 148 
North American Aerospace Defense 
Command, 157 
NSS Chess Program, 100 
Olsen, Ken, 148 
Olsen, Kenneth, 151 
Packard Bell 250, 206 
Packard Bell 440, 214 
Packard Bell Corporation, 206 
Packard Bell Electronics, 206 
Packard, Leon, 206 
Palevsky, Max, 214 
PB 440, 214 
PB250 
Index Register, 208 
Machine Sector Counter, 208 
Peterson, Phil, 148 
Philadelphia Storage Battery 
Corporation, 157 
Philco 1000, 157, 167 
Philco 212, 166 
Arithmetic Unit, 170 
Buffer Units, 171 
Control Unit, 168 
I/O Buffer Register, 171 
I/O Processor, 171 
Index Register Buffer, 169 
Index Unit, 169 
Instruction Unit, 169 
On-Line Paper Tape System, 
168 
Real-Time System, 171 
Store Unit, Model 2100, 170 
Universal Buffer Controller, 171 
Philco 2400, 184 
arithmetic element, 186 
Executive Control Unit, 185 
Program Control Units, 185 
Philco Corporation, 157 
Philco Ford, 157 
Pilot Ace, 42 
Rachman, Jan, 66 
Radio Corporation of America, 62 
RAND Corporation, 89, 98 
random access memory, 60 
Raytheon, 30 
RCA, 62 
RCA 501, 64 
RCA Camden EDP Facility, 63 
RCA Selectron Tubes, 89 
Real Programmers Write in 
Fortran, 33 
register-address structure, 137 
Rosen, Saul, 181 
Ross, Douglas, 149 
Royal McBee Corporation, 30, 42 
Rubinoff, Morris, 159 
SAGE, 148 
Santa Monica, California, 98 
SC90 
print control instructions, 113 
Scientific American, 43 
Selectron Tube, 66 
Selectron Tubes, 62 
Shaw, Cliff, 100 
Shaw, J. Clifford, 98 
Shockley, William, 105 
Simon, Herbert, 100 
Sketchpad, 156 
Smithsonian American History 
Museum, 44 
SOAP See Symbolic Optimal 
Assembly Program 
Solid State Computer, 106 

Index 
 
344
SSC90 
arithmetic instructions, 112 
comparison instructions, 113 
logical and shift instructions, 
112 
reader control instructions, 113 
transfer instructions, 112 
translate instructions, 113 
X-6 assembly language, 114 
Z assembly language, 114 
Supervisor Extracode Routines, 81 
Surface Barrier Transistors, 157 
Sutherland, Ivan, 156 
Symbolic Assembly Program, 28 
Symbolic Optimal Assembly 
Program, 23 
Tauschek, Gustav, 16 
Teledyne Corporation, 206 
Telemeter Magnetics, 89 
Teletype ASR/KSR series, 127 
The Atlas Story, 88 
The Sporting News, 67 
Tom Ellis, 98 
Transac S-1000, 157 
TRANSAC S-2000, 159 
transistor, 105 
Transistorized Automatic Computer, 
159 
Translator-Assembler-Compiler, 
181 
Travelers Life Insurance Company, 
63 
Traveller’s Insurance Company, 132 
TX-0, 148 
Ferranti photoelectric paper tape 
reader, 154 
Toggle Switch Storage, 150 
TX-2, 154 
U.S. Army Corp of Engineers, 29 
U.S. Army Ordnance Tank 
Automotive Command, 62 
UNISCOPE 100, 127 
UNISCOPE 300, 127 
UNISERVO II tape drive, 107 
UNISET, 130 
UNIVAC, 106 
Solid State 80, 106 
Solid State 90, 106 
UNIVAC 1004 computer system, 
134 
UNIVAC 1103, 158 
UNIVAC 1107, 128 
UNIVAC 1230, 147 
Univac 418, 116 
UNIVAC 418, 129 
COBOL, 127 
Element Processor, 28 
FORTRAN, 127 
Index Register Pointer, 121 
Program Utility Routine, 128 
UNIVAC 418 Model II, 118 
Univac 418 Model III 
Externally Specified Indexing, 
123 
UNIVAC 418 Model III, 118 
Buffer Control Words, 123 
Command/Arithmetic Unit, 120 
Communications Terminal 
Modular Controller, 127 
ESI buffer chaining, 123 
Externally Specified Index, 124 
I/O Modules, 122 
Index Registers, 121 
Instruction Address Register, 
120 
Integrated General Registers, 
122 
Internally Specified Indexing, 
123 
Main Storage, 121 
Real Time Clock, 121 
Real Time Communications 
Control, 127 
Real Time Operating System, 
125 
Special Register, 120 
Storage Address Register, 122 
Time-of-Day Clock, 121 
Word Terminal Synchronous, 
127 
UNIVAC 418 RTOS, 125 
Executive, 125 

Birthing the Computer: From Drums to Cores 
 
345 
File Control, 126 
I/O Control, 125 
UNIVAC 418-II, 129 
UNIVAC 418-III, 129 
Univac 490, 130 
UNIVAC 494, 130, 132 
arithmetic instructions, 140 
Buffer Control Word, 135 
Communication Terminal 
Module Controller, 135, 136 
Communication Terminal 
Modules, 136 
Comparison instructions, 142 
Day Clock, 134 
Externally Specified Index, 135 
ferrite core memory, 134 
FH-432 magnetic drum, 145 
FH-880 magnetic drum, 145 
I/O instructions, 144 
I/O system, 134 
Interface Modules, 136 
Internally Specified Index, 135 
Jump instructions, 143 
Logical instructions, 142 
OMEGA, 146 
Real-Time Clock, 134 
Sequence modifying 
instructions, 143 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Shift instructions, 138 
Transfer instructions, 139 
Transfer Switch, 136 
Type 400 Operator’s Console, 
146 
UNIVAC 9000, 124 
UNIVAC 9200/9300 computer 
system, 134 
UNIVAC Card Tabulator, 106 
University of California at Berkeley, 
42 
University of London, 70, 87 
University of Manchester, 69, 87, 
88 
University of Saskatchewan, 30 
virtual memory, 72 
Walter Brattain, 105 
Ware, Willis, 98 
Weiss, Ruth A., 27 
Westinghouse PRODAC, 116 
Wheeler, David, 82 
William Shockley, 105 
Williams Tubes, 62 
Wolontis, V. Michael, 27

